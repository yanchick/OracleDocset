<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-114707"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Sample%20XStream%20Client%20Application"></a><title>Sample XStream Client Application</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="Examples illustrate how to configure the Oracle Database components that are used by XStream. The examples configure sample client applications that communicate with an XStream outbound server and inbound server."/>
<meta name="keywords" content="XStream, configuring, client applications, example, demos"/>
<meta name="dcterms.created" content="2017-06-13T10:02:49Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database XStream Guide"/>
<meta name="dcterms.identifier" content="E53119-03"/>
<meta name="dcterms.isVersionOf" content="XSTRM"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2009, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="GUID-08D451B5-2D76-447B-B39B-20CC73110D19.htm" title="Previous" type="text/html"/>
<link rel="Next" href="xstrm_out_restrict.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53119-03.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8"></a> <span id="PAGE" style="display:none;">21/24</span> <!-- End Header -->
<a id="XSTRM1568"></a>
<h1 id="XSTRM-GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" class="sect1"><span class="enumeration_chapter">A</span> Sample XStream Client Application</h1>
<div>
<p>Examples illustrate how to configure the Oracle Database components that are used by XStream. The examples configure sample client applications that communicate with an XStream outbound server and inbound server.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><strong><a href="xstrm_ap_sample_appl.htm#GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94">About the Sample XStream Client Application</a></strong><br/>
A sample XStream client application illustrates the basic tasks that are required of an XStream Out and XStream In application.</li>
<li class="ulchildlink"><strong><a href="xstrm_ap_sample_appl.htm#GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4">Sample XStream Client Application for the Oracle Call Interface API</a></strong><br/>
To run the sample XStream client application for the OCI API, compile and link the application file.</li>
<li class="ulchildlink"><strong><a href="xstrm_ap_sample_appl.htm#GUID-952CEB45-9E0D-49AE-853A-912524B49853">Sample XStream Client Application for the Java API</a></strong><br/>
To run the sample XStream client application for the Java API, compile and link the application file.</li>
</ul>
<div class="infoboxnotealso" id="GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8__GUID-23B0AF79-7AA7-43A2-8A86-14BDFBF48D7E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xstrm_xout_cncpt.htm#GUID-B59B1F79-91F6-4495-B946-5DCEB317E0D6" title="Become familiar with concepts related to XStream Out.">XStream Out Concepts</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xstrm_intro.htm#GUID-21FC23DF-2881-4CFD-AF74-9A1173D768FF" title="There are several common XStream use cases.">XStream Use Cases</a>&#34;</span></p>
</li>
<li>
<p><a class="olink LNOCI72903" target="_blank" href="../LNOCI/oci25xstrmint.htm#LNOCI72903"><span><cite>Oracle Call Interface Programmer&#39;s Guide</cite></span></a></p>
</li>
<li>
<p><a class="olink STXJV" target="_blank" href="../STXJV/toc.htm"><span><cite>Oracle Database XStream Java API Reference</cite></span></a></p>
</li>
</ul>
</div>
<div class="familylinks">
<div class="parentlink">
<p><strong>Parent topic:</strong> <a href="GUID-08D451B5-2D76-447B-B39B-20CC73110D19.htm" title="Appendixes include information about XStream client applications and XStream restrictions.">Appendixes</a></p>
</div>
</div>
</div>
<a id="XSTRM1640"></a><a id="XSTRM72732"></a>
<div class="props_rev_3"><a id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94"></a>
<h2 id="XSTRM-GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94" class="sect2"><span class="enumeration_section">A.1</span> About the Sample XStream Client Application</h2>
<div>
<p>A sample XStream client application illustrates the basic tasks that are required of an XStream Out and XStream In application.</p>
<p>The application performs the following tasks:</p>
<ul style="list-style-type: disc;">
<li>
<p>It attaches to an XStream outbound server and inbound server and waits for LCRs from the outbound server. The outbound server and inbound server are in two different databases.</p>
</li>
<li>
<p>When it receives an LCR from the outbound server, it immediately sends the LCR to the inbound server.</p>
</li>
<li>
<p>It periodically gets the processed low position from the inbound server and sends this value to the outbound server.</p>
</li>
<li>
<p>It periodically sends a &#34;ping&#34; LCR from the outbound server to the inbound server to move the inbound server&#39;s processed low position forward in times of low activity.</p>
</li>
</ul>
<p>In an XStream Out configuration that does not send LCRs to an inbound server, the client application must obtain the processed low position in another way.</p>
<p>This application waits indefinitely for transactions from the outbound server. To interrupt the application, enter the interrupt command for your operating system. For example, the interrupt command on some operating systems is <code class="codeph">control-C</code>. If the program is restarted, then the outbound server starts sending LCRs from the processed low position that was set during the previous run.</p>
<p><a href="xstrm_ap_sample_appl.htm#GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__CBDIHADI">Figure A-1</a> provides an overview of the XStream environment configured in this section.</p>
<div class="figure" id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__CBDIHADI">
<p class="titleinfigure">Figure A-1 Sample XStream Configuration</p>
<img width="672" height="290" src="img/GUID-818063D0-88C0-4A77-9B73-18D30C530B76-default.gif" alt="Description of Figure A-1 follows" title="Description of Figure A-1 follows"/><br/>
<a href="img_text/GUID-818063D0-88C0-4A77-9B73-18D30C530B76-print.htm">Description of &#34;Figure A-1 Sample XStream Configuration&#34;</a></div>
<!-- class="figure" -->
<p>Before running the sample application, ensure that the following components exist:</p>
<ul style="list-style-type: disc;">
<li>
<p>Two Oracle databases with network connectivity between them</p>
</li>
<li>
<p>An XStream administrator on both databases</p>
</li>
<li>
<p>An outbound server configuration on one database, including a capture process, queue, and outbound server</p>
</li>
<li>
<p>An inbound server configuration on another database</p>
</li>
</ul>
<p>If you are running the sample application with a multitenant container database (CDB), then ensure that the client application connects to the correct container:</p>
<ul style="list-style-type: disc;">
<li>
<p>When the client application connects to the outbound server, it must connect to the root.</p>
</li>
<li>
<p>When the client application connects to the inbound server, it must connect to the container in which the inbound server was created.</p>
</li>
</ul>
<p>The sample applications in the following sections perform the same tasks. One sample application uses the OCI API, and the other uses the Java API.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="xstrm_ap_sample_appl.htm#GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4" title="To run the sample XStream client application for the OCI API, compile and link the application file.">Sample XStream Client Application for the Oracle Call Interface API</a></p>
</li>
<li>
<p><a href="xstrm_ap_sample_appl.htm#GUID-952CEB45-9E0D-49AE-853A-912524B49853" title="To run the sample XStream client application for the Java API, compile and link the application file.">Sample XStream Client Application for the Java API</a></p>
</li>
</ul>
<div class="infobox-note" id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__GUID-4231CE64-849C-4E9B-BDE1-268608E66A2E">
<p class="notep1">Note:</p>
<p>An Oracle Database installation includes several XStream demos. These demos are in the following location:</p>
<pre dir="ltr">$ORACLE_HOME/rdbms/demo/xstream
</pre></div>
<div class="infoboxnotealso" id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__GUID-EA6145CF-AA41-47AE-BB6E-900BE0424BA2">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="xstrm_gen_cncpt.htm#GUID-077AAE24-54CF-4102-9969-9540608FFB65" title="Each LCR has a position attribute. The position of an LCR identifies its placement in the stream of LCRs in a transaction.">Position Order in an LCR Stream</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xstrm_xout_config.htm#GUID-1338E648-E214-4666-98A1-8B8D0085EB23" title="You can configure the Oracle Database components that are used by XStream Out.">Configuring XStream Out</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="xstrm_xin_config.htm#GUID-B0F20D2D-7F63-4CE6-B15F-435B5A3DFBED" title="You can configure the Oracle Database components that are used by XStream.">Configuring XStream In</a>&#34;</span></p>
</li>
<li>
<p><a class="olink LNOCI72903" target="_blank" href="../LNOCI/oci25xstrmint.htm#LNOCI72903"><span><cite>Oracle Call Interface Programmer&#39;s Guide</cite></span></a></p>
</li>
<li>
<p><a class="olink STXJV" target="_blank" href="../STXJV/toc.htm"><span><cite>Oracle Database XStream Java API Reference</cite></span></a></p>
</li>
<li>
<p><a class="olink ARPLS73653" target="_blank" href="../ARPLS/d_xstrm_auth.htm#ARPLS73653"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="XSTRM1569"></a>
<div class="props_rev_3"><a id="GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4"></a>
<h2 id="XSTRM-GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4" class="sect2"><span class="enumeration_section">A.2</span> Sample XStream Client Application for the Oracle Call Interface API</h2>
<div>
<p>To run the sample XStream client application for the OCI API, compile and link the application file.</p>
<p>Next, enter the following on a command line:</p>
<pre dir="ltr">xio -ob_svr <span class="italic">xout_name</span> -ob_db <span class="italic">sn_xout_db</span> -ob_usr <span class="italic">xout_cu</span> -ob_pwd <span class="italic">xout_cu_pass</span> 
-ib_svr <span class="italic">xin_name</span> -ib_db <span class="italic">sn_xin_db</span> -ib_usr <span class="italic">xin_au</span> -ib_pwd <span class="italic">xin_au_pass</span>
</pre>
<p>Substitute the appropriate values for the following placeholders:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="italic">xout_name</span> is the name of the outbound server.</p>
</li>
<li>
<p><span class="italic">sn_xout_db</span> is the service name for the outbound server&#39;s database.</p>
</li>
<li>
<p><span class="italic">xout_cu</span> is the outbound server&#39;s connect user.</p>
</li>
<li>
<p><span class="italic">xout_cu_pass</span> is the password for the outbound server&#39;s connect user.</p>
</li>
<li>
<p><span class="italic">xin_name</span> is the name of the inbound server.</p>
</li>
<li>
<p><span class="italic">sn_xin_db</span> is the service name for the inbound server&#39;s database.</p>
</li>
<li>
<p><span class="italic">xin_au</span> is the inbound server&#39;s apply user.</p>
</li>
<li>
<p><span class="italic">xin_au_pass</span> is the password for the inbound server&#39;s apply user.</p>
</li>
</ul>
<p>When the sample client application is running, it prints information about the row LCRs it is processing. The output looks similar to the following:</p>
<pre dir="ltr"> ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=UPDATE txid=17.0.74
  owner=HR oname=COUNTRIES 
 
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=COMMIT txid=17.0.74
 
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=UPDATE txid=12.25.77
  owner=OE oname=ORDERS 
 
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=UPDATE txid=12.25.77
  owner=OE oname=ORDERS 
</pre>
<p>This output contains the following information for each row LCR:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">src_db_name</code> shows the source database for the change encapsulated in the row LCR.</p>
</li>
<li>
<p><code class="codeph">cmd_type</code> shows the type of SQL statement that made the change.</p>
</li>
<li>
<p><code class="codeph">txid</code> shows the transaction ID of the transaction that includes the row LCR.</p>
</li>
<li>
<p><code class="codeph">owner</code> shows the owner of the database object that was changed.</p>
</li>
<li>
<p><code class="codeph">oname</code> shows the name of the database object that was changed.</p>
</li>
</ul>
<p>This demo is available in the following location:</p>
<pre dir="ltr">$ORACLE_HOME/rdbms/demo/xstream/oci
</pre>
<p>The file name for the demo is <code class="codeph">xio.c</code>. See the <code class="codeph">README.txt</code> file in the demo directory for more information about compiling and running the application.</p>
<p>The code for the sample application that uses the OCI API follows:</p>
<pre dir="ltr">#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
 
#ifndef _STDIO_H
#include &lt;stdio.h&gt;
#endif
 
#ifndef _STDLIB_H
#include &lt;stdlib.h&gt;
#endif
 
#ifndef _STRING_H
#include &lt;string.h&gt;
#endif
 
#ifndef _MALLOC_H
#include &lt;malloc.h&gt;
#endif
 
/*---------------------------------------------------------------------- 
 *           Internal structures
 *----------------------------------------------------------------------*/ 
 
#define M_DBNAME_LEN    (128)
 
typedef struct conn_info                                     /* connect info */
{
  oratext * user;
  ub4       userlen;
  oratext * passw;
  ub4       passwlen;
  oratext * dbname;
  ub4       dbnamelen;
  oratext * svrnm;
  ub4       svrnmlen;
} conn_info_t;
 
typedef struct params
{
  conn_info_t  xout;                                        /* outbound info */
  conn_info_t  xin;                                          /* inbound info */
} params_t;
 
typedef struct oci                                            /* OCI handles */
{
  OCIEnv      *envp;                                   /* Environment handle */
  OCIError    *errp;                                         /* Error handle */
  OCIServer   *srvp;                                        /* Server handle */
  OCISvcCtx   *svcp;                                       /* Service handle */
  OCISession  *authp;
  OCIStmt    *stmtp;        
  boolean     attached;
  boolean     outbound;
} oci_t;
 
static void connect_db(conn_info_t *opt_params_p, oci_t ** ocip, ub2 char_csid,
                       ub2 nchar_csid);
static void disconnect_db(oci_t * ocip);
static void ocierror(oci_t * ocip, char * msg);
static void attach(oci_t * ocip, conn_info_t *conn, boolean outbound);
static void detach(oci_t *ocip);
static void get_lcrs(oci_t *xin_ocip, oci_t *xout_ocip);
static void get_chunks(oci_t *xin_ocip, oci_t *xout_ocip);
static void print_lcr(oci_t *ocip, void *lcrp, ub1 lcrtype, 
                      oratext **src_db_name, ub2  *src_db_namel);
static void print_chunk (ub1 *chunk_ptr, ub4 chunk_len, ub2 dty);
static void get_inputs(conn_info_t *xout_params, conn_info_t *xin_params, 
                       int argc, char ** argv);
static void get_db_charsets(conn_info_t *params_p, ub2 *char_csid, 
                            ub2 *nchar_csid);
static void set_client_charset(oci_t *outbound_ocip);
 
#define OCICALL(ocip, function) do {\
sword status=function;\
if (OCI_SUCCESS==status) break;\
else if (OCI_ERROR==status) \
{ocierror(ocip, (char *)&#34;OCI_ERROR&#34;);\
exit(1);}\
else {printf(&#34;Error encountered %d\n&#34;, status);\
exit(1);}\
} while(0)
 
/*---------------------------------------------------------------------
 *                M A I N   P R O G R A M
 *---------------------------------------------------------------------*/
main(int argc, char **argv)
{
  /* Outbound and inbound connection info */
  conn_info_t   xout_params;
  conn_info_t   xin_params;
  oci_t        *xout_ocip = (oci_t *)NULL;
  oci_t        *xin_ocip = (oci_t *)NULL;
  ub2           obdb_char_csid = 0;                 /* outbound db char csid */
  ub2           obdb_nchar_csid = 0;               /* outbound db nchar csid */
 
  /* parse command line arguments */
  get_inputs(&amp;xout_params, &amp;xin_params, argc, argv); 
 
  /* Get the outbound database CHAR and NCHAR character set info */
  get_db_charsets(&amp;xout_params, &amp;obdb_char_csid, &amp;obdb_nchar_csid);
 
  /* Connect to the outbound db and set the client env to the outbound charsets
   * to minimize character conversion when transferring LCRs from outbound 
   * directly to inbound server. 
   */
  connect_db(&amp;xout_params, &amp;xout_ocip, obdb_char_csid, obdb_nchar_csid);
 
  /* Attach to outbound server */
  attach(xout_ocip, &amp;xout_params, TRUE);
 
  /* connect to inbound db and set the client charsets the same as the 
   * outbound db charsets.
   */
  connect_db(&amp;xin_params, &amp;xin_ocip, obdb_char_csid, obdb_nchar_csid);
 
  /* Attach to inbound server */
  attach(xin_ocip, &amp;xin_params, FALSE);
 
  /* Get lcrs from outbound server and send to inbound server */
  get_lcrs(xin_ocip, xout_ocip);
 
  /* Detach from XStream servers */
  detach(xout_ocip);
  detach(xin_ocip);
 
  /* Disconnect from both databases */
  disconnect_db(xout_ocip);
  disconnect_db(xin_ocip);
 
  free(xout_ocip);
  free(xin_ocip);
  exit (0);
}
 
/*---------------------------------------------------------------------
 * connect_db - Connect to the database and set the env to the given
 * char and nchar character set ids. 
 *---------------------------------------------------------------------*/
static void connect_db(conn_info_t *params_p, oci_t **ociptr, ub2 char_csid,
                ub2 nchar_csid)
{
  oci_t        *ocip;
 
  printf (&#34;Connect to Oracle as %.*s@%.*s &#34;,
          params_p-&gt;userlen, params_p-&gt;user, 
          params_p-&gt;dbnamelen, params_p-&gt;dbname);
       
  if (char_csid &amp;&amp; nchar_csid)
    printf (&#34;using char csid=%d and nchar csid=%d&#34;, char_csid, nchar_csid);
 
  printf(&#34;\n&#34;);
 
  ocip = (oci_t *)malloc(sizeof(oci_t));
 
  if (OCIEnvNlsCreate(&amp;ocip-&gt;envp, OCI_OBJECT, (dvoid *)0,
                     (dvoid * (*)(dvoid *, size_t)) 0,
                     (dvoid * (*)(dvoid *, dvoid *, size_t))0,
                     (void (*)(dvoid *, dvoid *)) 0,
                     (size_t) 0, (dvoid **) 0, char_csid, nchar_csid))
  {
    ocierror(ocip, (char *)&#34;OCIEnvCreate() failed&#34;);
  }
 
  if (OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;errp,
                     (ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0))
  {
    ocierror(ocip, (char *)&#34;OCIHandleAlloc(OCI_HTYPE_ERROR) failed&#34;);
  }
 
  /* Logon to database */
  OCICALL(ocip,
          OCILogon(ocip-&gt;envp, ocip-&gt;errp, &amp;ocip-&gt;svcp,
                   params_p-&gt;user, params_p-&gt;userlen,
                   params_p-&gt;passw, params_p-&gt;passwlen,
                   params_p-&gt;dbname, params_p-&gt;dbnamelen));
 
  /* allocate the server handle */
  OCICALL(ocip,
          OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;srvp,
                         OCI_HTYPE_SERVER, (size_t) 0, (dvoid **) 0));
 
  OCICALL(ocip, 
          OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;stmtp,
                     (ub4) OCI_HTYPE_STMT, (size_t) 0, (dvoid **) 0));
 
  if (*ociptr == (oci_t *)NULL)
  {
    *ociptr = ocip;
  }
}
 
/*---------------------------------------------------------------------
 * get_db_charsets - Get the database CHAR and NCHAR character set ids.
 *---------------------------------------------------------------------*/
static const oratext GET_DB_CHARSETS[] =  \
 &#34;select parameter, value from nls_database_parameters where parameter = \
 &#39;NLS_CHARACTERSET&#39; or parameter = &#39;NLS_NCHAR_CHARACTERSET&#39;&#34;;
 
#define PARM_BUFLEN      (30)
 
static void get_db_charsets(conn_info_t *params_p, ub2 *char_csid, 
                            ub2 *nchar_csid)
{
  OCIDefine  *defnp1 = (OCIDefine *) NULL;
  OCIDefine  *defnp2 = (OCIDefine *) NULL;
  oratext     parm[PARM_BUFLEN];
  oratext     value[OCI_NLS_MAXBUFSZ];
  ub2         parm_len = 0;
  ub2         value_len = 0;
  oci_t       ocistruct; 
  oci_t      *ocip = &amp;ocistruct;
   
  *char_csid = 0;
  *nchar_csid = 0;
  memset (ocip, 0, sizeof(ocistruct));
 
  if (OCIEnvCreate(&amp;ocip-&gt;envp, OCI_OBJECT, (dvoid *)0,
                     (dvoid * (*)(dvoid *, size_t)) 0,
                     (dvoid * (*)(dvoid *, dvoid *, size_t))0,
                     (void (*)(dvoid *, dvoid *)) 0,
                     (size_t) 0, (dvoid **) 0))
  {
    ocierror(ocip, (char *)&#34;OCIEnvCreate() failed&#34;);
  }
 
  if (OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;errp,
                     (ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0))
  {
    ocierror(ocip, (char *)&#34;OCIHandleAlloc(OCI_HTYPE_ERROR) failed&#34;);
  }
 
  OCICALL(ocip, 
          OCILogon(ocip-&gt;envp, ocip-&gt;errp, &amp;ocip-&gt;svcp,
                   params_p-&gt;user, params_p-&gt;userlen,
                   params_p-&gt;passw, params_p-&gt;passwlen,
                   params_p-&gt;dbname, params_p-&gt;dbnamelen));
 
  OCICALL(ocip, 
          OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;stmtp,
                     (ub4) OCI_HTYPE_STMT, (size_t) 0, (dvoid **) 0));
 
  /* Execute stmt to select the db nls char and nchar character set */ 
  OCICALL(ocip, 
          OCIStmtPrepare(ocip-&gt;stmtp, ocip-&gt;errp,
                         (CONST text *)GET_DB_CHARSETS,
                         (ub4)strlen((char *)GET_DB_CHARSETS),
                         (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT));
 
  OCICALL(ocip,
          OCIDefineByPos(ocip-&gt;stmtp, &amp;defnp1,
                         ocip-&gt;errp, (ub4) 1, parm,
                         PARM_BUFLEN, SQLT_CHR, (void*) 0,
                         &amp;parm_len, (ub2 *)0, OCI_DEFAULT));
 
  OCICALL(ocip,
          OCIDefineByPos(ocip-&gt;stmtp, &amp;defnp2,
                         ocip-&gt;errp, (ub4) 2, value,
                         OCI_NLS_MAXBUFSZ, SQLT_CHR, (void*) 0,
                         &amp;value_len, (ub2 *)0, OCI_DEFAULT));
 
  OCICALL(ocip, 
          OCIStmtExecute(ocip-&gt;svcp, ocip-&gt;stmtp, 
                         ocip-&gt;errp, (ub4)0, (ub4)0, 
                         (const OCISnapshot *)0,
                         (OCISnapshot *)0, (ub4)OCI_DEFAULT));
 
  while (OCIStmtFetch(ocip-&gt;stmtp, ocip-&gt;errp, 1,
                      OCI_FETCH_NEXT, OCI_DEFAULT) == OCI_SUCCESS)
  {
    value[value_len] = &#39;\0&#39;;
    if (parm_len == strlen(&#34;NLS_CHARACTERSET&#34;) &amp;&amp;
        !memcmp(parm, &#34;NLS_CHARACTERSET&#34;, parm_len))
    {
      *char_csid = OCINlsCharSetNameToId(ocip-&gt;envp, value);
      printf(&#34;Outbound database NLS_CHARACTERSET = %.*s (csid = %d) \n&#34;,
             value_len, value, *char_csid);
    }
    else if (parm_len == strlen(&#34;NLS_NCHAR_CHARACTERSET&#34;) &amp;&amp;
             !memcmp(parm, &#34;NLS_NCHAR_CHARACTERSET&#34;, parm_len))
    {
      *nchar_csid = OCINlsCharSetNameToId(ocip-&gt;envp, value);
      printf(&#34;Outbound database NLS_NCHAR_CHARACTERSET = %.*s (csid = %d) \n&#34;,
             value_len, value, *nchar_csid);
    }
  }
 
  disconnect_db(ocip);
}
 
/*---------------------------------------------------------------------
 * attach - Attach to XStream server specified in connection info
 *---------------------------------------------------------------------*/
static void attach(oci_t * ocip, conn_info_t *conn, boolean outbound)
{
  sword       err;
 
  printf (&#34;Attach to XStream %s server &#39;%.*s&#39;\n&#34;, 
          outbound ? &#34;outbound&#34; : &#34;inbound&#34;,
          conn-&gt;svrnmlen, conn-&gt;svrnm);
 
  if (outbound)
  {
    OCICALL(ocip, 
            OCIXStreamOutAttach(ocip-&gt;svcp, ocip-&gt;errp, conn-&gt;svrnm,
                              (ub2)conn-&gt;svrnmlen, (ub1 *)0, 0, OCI_DEFAULT));
  }
  else
  {
    OCICALL(ocip, 
            OCIXStreamInAttach(ocip-&gt;svcp, ocip-&gt;errp, conn-&gt;svrnm,
                               (ub2)conn-&gt;svrnmlen, 
                               (oratext *)&#34;From_XOUT&#34;, 9,
                               (ub1 *)0, 0, OCI_DEFAULT));
  }
 
  ocip-&gt;attached = TRUE;
  ocip-&gt;outbound = outbound;
}
 
/*---------------------------------------------------------------------
 * ping_svr - Ping inbound server by sending a commit LCR.
 *---------------------------------------------------------------------*/
static void ping_svr(oci_t *xin_ocip, void *commit_lcr,
                     ub1 *cmtpos, ub2 cmtpos_len, 
                     oratext *source_db, ub2 source_db_len)
{
  OCIDate     src_time;
  oratext     txid[128];
 
  OCICALL(xin_ocip, OCIDateSysDate(xin_ocip-&gt;errp, &amp;src_time));
  sprintf((char *)txid, &#34;Ping %2d:%2d:%2d&#34;,
          src_time.OCIDateTime.OCITimeHH,
          src_time.OCIDateTime.OCITimeMI,
          src_time.OCIDateTime.OCITimeSS);
 
  /* Initialize LCR with new txid and commit position */
  OCICALL(xin_ocip,
          OCILCRHeaderSet(xin_ocip-&gt;svcp, xin_ocip-&gt;errp,
                          source_db, source_db_len,
                          (oratext *)OCI_LCR_ROW_CMD_COMMIT,
                          (ub2)strlen(OCI_LCR_ROW_CMD_COMMIT),
                          (oratext *)0, 0,                     /* null owner */
                          (oratext *)0, 0,                    /* null object */
                          (ub1 *)0, 0,                           /* null tag */
                          txid, (ub2)strlen((char *)txid),
                          &amp;src_time, cmtpos, cmtpos_len,
                          0, commit_lcr, OCI_DEFAULT));
 
  /* Send commit lcr to inbound server. */
  if (OCIXStreamInLCRSend(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, commit_lcr,
                          OCI_LCR_XROW, 0, OCI_DEFAULT) == OCI_ERROR)
  {
    ocierror(xin_ocip, (char *)&#34;OCIXStreamInLCRSend failed in ping_svr()&#34;);
  }
}
 
/*---------------------------------------------------------------------
 * get_lcrs - Get LCRs from outbound server and send to inbound server.
 *---------------------------------------------------------------------*/
static void get_lcrs(oci_t *xin_ocip, oci_t *xout_ocip)
{
  sword       status = OCI_SUCCESS;
  void       *lcr;
  ub1         lcrtype;
  oraub8      flag;
  ub1         proclwm[OCI_LCR_MAX_POSITION_LEN];
  ub2         proclwm_len = 0;
  ub1         sv_pingpos[OCI_LCR_MAX_POSITION_LEN];
  ub2         sv_pingpos_len = 0;
  ub1         fetchlwm[OCI_LCR_MAX_POSITION_LEN];
  ub2         fetchlwm_len = 0;
  void       *commit_lcr = (void *)0;
  oratext    *lcr_srcdb = (oratext *)0;
  ub2         lcr_srcdb_len = 0;
  oratext     source_db[M_DBNAME_LEN];
  ub2         source_db_len = 0;
  ub4         lcrcnt = 0;
 
  /* create an lcr to ping the inbound server periodically by sending a
   * commit lcr.
   */
  commit_lcr = (void*)0;
  OCICALL(xin_ocip,
          OCILCRNew(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, OCI_DURATION_SESSION,
                    OCI_LCR_XROW, &amp;commit_lcr, OCI_DEFAULT));
 
  while (status == OCI_SUCCESS)
  {
    lcrcnt = 0;                         /* reset lcr count before each batch */
 
    while ((status = 
                OCIXStreamOutLCRReceive(xout_ocip-&gt;svcp, xout_ocip-&gt;errp,
                                        &amp;lcr, &amp;lcrtype, &amp;flag, 
                                        fetchlwm, &amp;fetchlwm_len, OCI_DEFAULT))
                                               == OCI_STILL_EXECUTING)
    {
      lcrcnt++;
 
      /* print header of LCR just received */
      print_lcr(xout_ocip, lcr, lcrtype, &amp;lcr_srcdb, &amp;lcr_srcdb_len);
 
      /* save the source db to construct ping lcr later */
      if (!source_db_len &amp;&amp; lcr_srcdb_len)
      {
        memcpy(source_db, lcr_srcdb, lcr_srcdb_len);
        source_db_len = lcr_srcdb_len;
      }
      
      /* send the LCR just received */
      if (OCIXStreamInLCRSend(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, 
                              lcr, lcrtype, flag, OCI_DEFAULT) == OCI_ERROR)
      {
        ocierror(xin_ocip, (char *)&#34;OCIXStreamInLCRSend failed&#34;);
      }
 
      /* If LCR has chunked columns (i.e, has LOB/Long/XMLType columns) */
      if (flag &amp; OCI_XSTREAM_MORE_ROW_DATA)
      {
        /* receive and send chunked columns */
        get_chunks(xin_ocip, xout_ocip); 
      }
    }
 
    if (status == OCI_ERROR)
      ocierror(xout_ocip, (char *)&#34;OCIXStreamOutLCRReceive failed&#34;);
 
    /* clear the saved ping position if we just received some new lcrs */
    if (lcrcnt)
    {
      sv_pingpos_len = 0;
    }
 
    /* If no lcrs received during previous WHILE loop and got a new fetch 
     * LWM then send a commit lcr to ping the inbound server with the new
     * fetch LWM position.
     */
    else if (fetchlwm_len &gt; 0 &amp;&amp; source_db_len &gt; 0 &amp;&amp;
        (fetchlwm_len != sv_pingpos_len ||
         memcmp(sv_pingpos, fetchlwm, fetchlwm_len))) 
    {
      /* To ensure we don&#39;t send multiple lcrs with duplicate position, send
       * a new ping only if we have saved the last ping position.
       */
      if (sv_pingpos_len &gt; 0)
      {     
        ping_svr(xin_ocip, commit_lcr, fetchlwm, fetchlwm_len,
                 source_db, source_db_len); 
      }
 
      /* save the position just sent to inbound server */
      memcpy(sv_pingpos, fetchlwm, fetchlwm_len);
      sv_pingpos_len = fetchlwm_len;
    }
 
    /* flush inbound network to flush all lcrs to inbound server */
    OCICALL(xin_ocip,
            OCIXStreamInFlush(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, OCI_DEFAULT));
 
    
    /* get processed LWM of inbound server */   
    OCICALL(xin_ocip, 
            OCIXStreamInProcessedLWMGet(xin_ocip-&gt;svcp, xin_ocip-&gt;errp,
                                        proclwm, &amp;proclwm_len, OCI_DEFAULT));
 
    if (proclwm_len &gt; 0)
    {
      /* Set processed LWM for outbound server */
      OCICALL(xout_ocip, 
              OCIXStreamOutProcessedLWMSet(xout_ocip-&gt;svcp, xout_ocip-&gt;errp, 
                                           proclwm, proclwm_len, OCI_DEFAULT));
    }
  }
  
  if (status != OCI_SUCCESS)
    ocierror(xout_ocip, (char *)&#34;get_lcrs() encounters error&#34;);
}
 
/*---------------------------------------------------------------------
 * get_chunks - Get each chunk for the current LCR and send it to 
 *              the inbound server.
 *---------------------------------------------------------------------*/
static void get_chunks(oci_t *xin_ocip, oci_t *xout_ocip)
{
  oratext *colname;
  ub2      colname_len;
  ub2      coldty;
  oraub8   col_flags;
  ub2      col_csid;
  ub4      chunk_len;
  ub1     *chunk_ptr;
  oraub8   row_flag;
  sword    err;
  sb4      rtncode;
 
  do
  {
    /* Get a chunk from outbound server */
    OCICALL(xout_ocip,
            OCIXStreamOutChunkReceive(xout_ocip-&gt;svcp, xout_ocip-&gt;errp, 
                                      &amp;colname, &amp;colname_len, &amp;coldty, 
                                      &amp;col_flags, &amp;col_csid, &amp;chunk_len, 
                                      &amp;chunk_ptr, &amp;row_flag, OCI_DEFAULT));
   
    /* print chunked column info */
    printf(
     &#34;  Chunked column name=%.*s DTY=%d  chunk len=%d csid=%d col_flag=0x%lx\n&#34;,
      colname_len, colname, coldty, chunk_len, col_csid, col_flags);
 
    /* print chunk data */
    print_chunk(chunk_ptr, chunk_len, coldty);
 
    /* Send the chunk just received to inbound server */
    OCICALL(xin_ocip,
            OCIXStreamInChunkSend(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, colname,
                                  colname_len, coldty, col_flags,
                                  col_csid, chunk_len, chunk_ptr,
                                  row_flag, OCI_DEFAULT));
 
  } while (row_flag &amp; OCI_XSTREAM_MORE_ROW_DATA);
}
 
/*---------------------------------------------------------------------
 * print_chunk - Print chunked column information. Only print the first
 *               50 bytes for each chunk.
 *---------------------------------------------------------------------*/
static void print_chunk (ub1 *chunk_ptr, ub4 chunk_len, ub2 dty)
{
#define MAX_PRINT_BYTES     (50)          /* print max of 50 bytes per chunk */
 
  ub4  print_bytes;
 
  if (chunk_len == 0)
    return;
 
  print_bytes = chunk_len &gt; MAX_PRINT_BYTES ? MAX_PRINT_BYTES : chunk_len;
 
  printf(&#34;  Data = &#34;);
  if (dty == SQLT_CHR)
    printf(&#34;%.*s&#34;, print_bytes, chunk_ptr);
  else
  {
    ub2  idx;
 
    for (idx = 0; idx &lt; print_bytes; idx++)
      printf(&#34;%02x&#34;, chunk_ptr[idx]);
  }
  printf(&#34;\n&#34;);
}
 
/*---------------------------------------------------------------------
 * print_lcr - Print header information of given lcr.
 *---------------------------------------------------------------------*/
static void print_lcr(oci_t *ocip, void *lcrp, ub1 lcrtype, 
                      oratext **src_db_name, ub2  *src_db_namel)
{
  oratext     *cmd_type;
  ub2          cmd_type_len;
  oratext     *owner;
  ub2          ownerl;
  oratext     *oname;
  ub2          onamel;
  oratext     *txid;
  ub2          txidl;
  sword        ret;
 
  printf(&#34;\n ----------- %s LCR Header  -----------------\n&#34;,
         lcrtype == OCI_LCR_XDDL ? &#34;DDL&#34; : &#34;ROW&#34;);
 
  /* Get LCR Header information */
  ret = OCILCRHeaderGet(ocip-&gt;svcp, ocip-&gt;errp, 
                        src_db_name, src_db_namel,              /* source db */
                        &amp;cmd_type, &amp;cmd_type_len,            /* command type */
                        &amp;owner, &amp;ownerl,                       /* owner name */
                        &amp;oname, &amp;onamel,                      /* object name */
                        (ub1 **)0, (ub2 *)0,                      /* lcr tag */
                        &amp;txid, &amp;txidl, (OCIDate *)0,   /* txn id  &amp; src time */
                        (ub2 *)0, (ub2 *)0,              /* OLD/NEW col cnts */
                        (ub1 **)0, (ub2 *)0,                 /* LCR position */
                        (oraub8*)0, lcrp, OCI_DEFAULT);
 
  if (ret != OCI_SUCCESS)
    ocierror(ocip, (char *)&#34;OCILCRHeaderGet failed&#34;);
  else
  {
    printf(&#34;  src_db_name=%.*s\n  cmd_type=%.*s txid=%.*s\n&#34;,
           *src_db_namel, *src_db_name, cmd_type_len, cmd_type, txidl, txid );
 
    if (ownerl &gt; 0)
      printf(&#34;  owner=%.*s oname=%.*s \n&#34;, ownerl, owner, onamel, oname);
  } 
}
 
/*---------------------------------------------------------------------
 * detach - Detach from XStream server
 *---------------------------------------------------------------------*/
static void detach(oci_t * ocip)
{
  sword  err = OCI_SUCCESS;
 
  printf (&#34;Detach from XStream %s server\n&#34;,
          ocip-&gt;outbound ? &#34;outbound&#34; : &#34;inbound&#34; );
 
  if (ocip-&gt;outbound)
  {
    OCICALL(ocip, OCIXStreamOutDetach(ocip-&gt;svcp, ocip-&gt;errp, OCI_DEFAULT));
  }
  else
  {
    OCICALL(ocip, OCIXStreamInDetach(ocip-&gt;svcp, ocip-&gt;errp, 
                                     (ub1 *)0, (ub2 *)0,    /* processed LWM */
                                     OCI_DEFAULT));
  }
}
 
/*---------------------------------------------------------------------
 * disconnect_db  - Logoff from the database
 *---------------------------------------------------------------------*/
static void disconnect_db(oci_t * ocip)
{
  if (OCILogoff(ocip-&gt;svcp, ocip-&gt;errp))
  {
    ocierror(ocip, (char *)&#34;OCILogoff() failed&#34;);
  }
 
  if (ocip-&gt;errp)
    OCIHandleFree((dvoid *) ocip-&gt;errp, (ub4) OCI_HTYPE_ERROR);
 
  if (ocip-&gt;envp)
    OCIHandleFree((dvoid *) ocip-&gt;envp, (ub4) OCI_HTYPE_ENV);
}
 
/*---------------------------------------------------------------------
 * ocierror - Print error status and exit program
 *---------------------------------------------------------------------*/
static void ocierror(oci_t * ocip, char * msg)
{
  sb4 errcode=0;
  text bufp[4096];
 
  if (ocip-&gt;errp)
  {
    OCIErrorGet((dvoid *) ocip-&gt;errp, (ub4) 1, (text *) NULL, &amp;errcode,
                bufp, (ub4) 4096, (ub4) OCI_HTYPE_ERROR);
    printf(&#34;%s\n%s&#34;, msg, bufp);
  }
  else
    puts(msg);
 
  printf (&#34;\n&#34;);
  exit(1);
}
 
/*--------------------------------------------------------------------
 * print_usage - Print command usage
 *---------------------------------------------------------------------*/
static void print_usage(int exitcode)
{
  puts(&#34;\nUsage: xio -ob_svr &lt;outbound_svr&gt; -ob_db &lt;outbound_db&gt;\n&#34; 
         &#34;           -ob_usr &lt;conn_user&gt; -ob_pwd &lt;conn_user_pwd&gt;\n&#34; 
         &#34;           -ib_svr &lt;inbound_svr&gt; -ib_db &lt;inbound_db&gt;\n&#34;
         &#34;           -ib_usr &lt;apply_user&gt; -ib_pwd &lt;apply_user_pwd&gt;\n&#34;);
  puts(&#34;  ob_svr  : outbound server name\n&#34;
       &#34;  ob_db   : database name of outbound server\n&#34;
       &#34;  ob_usr  : connect user to outbound server\n&#34;
       &#34;  ob_pwd  : password of outbound&#39;s connect user\n&#34;
       &#34;  ib_svr  : inbound server name\n&#34;
       &#34;  ib_db   : database name of inbound server\n&#34;
       &#34;  ib_usr  : apply user for inbound server\n&#34;
       &#34;  ib_pwd  : password of inbound&#39;s apply user\n&#34;);
 
  exit(exitcode);
}
 
/*--------------------------------------------------------------------
 * get_inputs - Get user inputs from command line
 *---------------------------------------------------------------------*/
static void get_inputs(conn_info_t *xout_params, conn_info_t *xin_params, 
                       int argc, char ** argv)
{
  char * option;
  char * value;
 
  memset (xout_params, 0, sizeof(*xout_params));
  memset (xin_params, 0, sizeof(*xin_params));
  while(--argc)
  {
    /* get the option name */
    argv++;
    option = *argv;
 
    /* check that the option begins with a &#34;-&#34; */
    if (!strncmp(option, (char *)&#34;-&#34;, 1))
    {
      option ++;
    }
    else
    {
      printf(&#34;Error: bad argument &#39;%s&#39;\n&#34;, option);
      print_usage(1);
    }
 
    /* get the value of the option */
    --argc;
    argv++;
 
    value = *argv;    
 
    if (!strncmp(option, (char *)&#34;ob_db&#34;, 5))
    {
      xout_params-&gt;dbname = (oratext *)value;
      xout_params-&gt;dbnamelen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)&#34;ob_usr&#34;, 6))
    {
      xout_params-&gt;user = (oratext *)value;
      xout_params-&gt;userlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)&#34;ob_pwd&#34;, 6))
    {
      xout_params-&gt;passw = (oratext *)value;
      xout_params-&gt;passwlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)&#34;ob_svr&#34;, 6))
    {
      xout_params-&gt;svrnm = (oratext *)value;
      xout_params-&gt;svrnmlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)&#34;ib_db&#34;, 5))
    {
      xin_params-&gt;dbname = (oratext *)value;
      xin_params-&gt;dbnamelen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)&#34;ib_usr&#34;, 6))
    {
      xin_params-&gt;user = (oratext *)value;
      xin_params-&gt;userlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)&#34;ib_pwd&#34;, 6))
    {
      xin_params-&gt;passw = (oratext *)value;
      xin_params-&gt;passwlen = (ub4)strlen(value);
    }
    else if (!strncmp(option, (char *)&#34;ib_svr&#34;, 6))
    {
      xin_params-&gt;svrnm = (oratext *)value;
      xin_params-&gt;svrnmlen = (ub4)strlen(value);
    }
    else
    {
      printf(&#34;Error: unknown option &#39;%s&#39;.\n&#34;, option);
      print_usage(1);
    }
  }
 
  /* print usage and exit if any argument is not specified */
  if (!xout_params-&gt;svrnmlen || !xout_params-&gt;passwlen || 
      !xout_params-&gt;userlen || !xout_params-&gt;dbnamelen ||
      !xin_params-&gt;svrnmlen || !xin_params-&gt;passwlen || 
      !xin_params-&gt;userlen || !xin_params-&gt;dbnamelen)
  {
    printf(&#34;Error: missing command arguments. \n&#34;);
    print_usage(1);
  }
}
</pre></div>
</div>
<a id="XSTRM1570"></a>
<div class="props_rev_3"><a id="GUID-952CEB45-9E0D-49AE-853A-912524B49853"></a>
<h2 id="XSTRM-GUID-952CEB45-9E0D-49AE-853A-912524B49853" class="sect2"><span class="enumeration_section">A.3</span> Sample XStream Client Application for the Java API</h2>
<div>
<p>To run the sample XStream client application for the Java API, compile and link the application file.</p>
<p>Next, enter the following on a command line:</p>
<pre dir="ltr">java xio <span class="italic">xsin_oraclesid</span> <span class="italic">xsin_host</span> <span class="italic">xsin_port</span> <span class="italic">xsin_username</span> 
<span class="italic">xsin_passwd</span> <span class="italic">xin_servername</span> <span class="italic">xsout_oraclesid</span> <span class="italic">xsout_host</span> <span class="italic">xsout_port</span> 
<span class="italic">xsout_username</span> <span class="italic">xsout_passwd</span> <span class="italic">xsout_servername</span>
</pre>
<p>Substitute the appropriate values for the following placeholders:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="italic">xsin_oraclesid</span> is the Oracle SID of the inbound server&#39;s database.</p>
</li>
<li>
<p><span class="italic">xsin_host</span> is the host name of the computer system running the inbound server.</p>
</li>
<li>
<p><span class="italic">xsin_port</span> is the port number of the listener for the inbound server&#39;s database.</p>
</li>
<li>
<p><span class="italic">xsin_username</span> is the inbound server&#39;s apply user.</p>
</li>
<li>
<p><span class="italic">xsin_passwd</span> is the password for the inbound server&#39;s apply user.</p>
</li>
<li>
<p><span class="italic">xin_servername</span> is the name of the inbound server.</p>
</li>
<li>
<p><span class="italic">xsout_oraclesid</span> is the Oracle SID of the outbound server&#39;s database.</p>
</li>
<li>
<p><span class="italic">xsout_host</span> is the host name of the computer system running the outbound server.</p>
</li>
<li>
<p><span class="italic">xsout_port</span> is the port number of the listener for the outbound server&#39;s database.</p>
</li>
<li>
<p><span class="italic">xsout_username</span> is the outbound server&#39;s connect user.</p>
</li>
<li>
<p><span class="italic">xsout_passwd</span> is the password for the outbound server&#39;s connect user.</p>
</li>
<li>
<p><span class="italic">xsout_servername</span> is the name of the outbound server.</p>
</li>
</ul>
<p>When the sample client application is running, it prints information about attaching to the inbound server and outbound server, along with the last position for each server. The output looks similar to the following:</p>
<pre dir="ltr">xsin_host = server2.example.com
xsin_port = 1482
xsin_ora_sid = db2
xsin connection url: jdbc:oracle:oci:@server2.example.com:1482:db2
xsout_host = server1.example.com
xsout_port = 1481
xsout_ora_sid = db1
xsout connection url: jdbc:oracle:oci:@server1.example.com:1481:db1
Attached to inbound server:xin
Inbound Server Last Position is: 0000000920250000000100000001000000092025000000010000000101
Attached to outbound server:xout
Last Position is: 0000000920250000000100000001000000092025000000010000000101
</pre>
<p>This demo is available in the following location:</p>
<pre dir="ltr">$ORACLE_HOME/rdbms/demo/xstream/java
</pre>
<p>The file name for the demo is <code class="codeph">xio.java</code>. See the <code class="codeph">README.txt</code> file in the demo directory for more information about compiling and running the application.</p>
<p>The code for the sample application that uses the Java API follows:</p>
<pre dir="ltr">import oracle.streams.*;
import oracle.jdbc.internal.OracleConnection;
import oracle.jdbc.*;
import oracle.sql.*;
import java.sql.*;
import java.util.*;
 
public class xio
{
  public static String xsinusername = null;
  public static String xsinpasswd = null;
  public static String xsinName = null;
  public static String xsoutusername = null;
  public static String xsoutpasswd = null;
  public static String xsoutName = null;
  public static String in_url = null;
  public static String out_url = null;
  public static Connection in_conn = null;
  public static Connection out_conn = null;
  public static XStreamIn xsIn = null;
  public static XStreamOut xsOut = null;
  public static byte[] lastPosition = null;
  public static byte[] processedLowPosition = null;
    
  public static void main(String args[])
  {
    // get connection url to inbound and outbound server
    in_url = parseXSInArguments(args);    
    out_url = parseXSOutArguments(args);    
 
    // create connection to inbound and outbound server
    in_conn = createConnection(in_url, xsinusername, xsinpasswd);
    out_conn = createConnection(out_url, xsoutusername, xsoutpasswd);
 
    // attach to inbound and outbound server
    xsIn = attachInbound(in_conn);
    xsOut = attachOutbound(out_conn);
    
    // main loop to get lcrs 
    get_lcrs(xsIn, xsOut);
    
    // detach from inbound and outbound server
    detachInbound(xsIn);
    detachOutbound(xsOut);
  }
    
  // parse the arguments to get the conncetion url to inbound db
  public static String parseXSInArguments(String args[])
  {
    String trace, pref;
    String orasid, host, port;
    
    if (args.length != 12)
    {
      printUsage();
      System.exit(0);
    }
 
    orasid = args[0];
    host = args[1];
    port = args[2];
    xsinusername = args[3];
    xsinpasswd = args[4];
    xsinName = args[5];
    
    System.out.println(&#34;xsin_host = &#34;+host);
    System.out.println(&#34;xsin_port = &#34;+port);
    System.out.println(&#34;xsin_ora_sid = &#34;+orasid);
 
    String in_url = &#34;jdbc:oracle:oci:@&#34;+host+&#34;:&#34;+port+&#34;:&#34;+orasid;
    System.out.println(&#34;xsin connection url: &#34;+ in_url);
 
    return in_url;
  }
 
  // parse the arguments to get the conncetion url to outbound db
  public static String parseXSOutArguments(String args[])
  {
    String trace, pref;
    String orasid, host, port;
    
    if (args.length != 12)
    {
      printUsage();
      System.exit(0);
    }
 
    orasid = args[6];
    host = args[7];
    port = args[8];
    xsoutusername = args[9];
    xsoutpasswd = args[10];
    xsoutName = args[11];
    
    
    System.out.println(&#34;xsout_host = &#34;+host);
    System.out.println(&#34;xsout_port = &#34;+port);
    System.out.println(&#34;xsout_ora_sid = &#34;+orasid);
 
    String out_url = &#34;jdbc:oracle:oci:@&#34;+host+&#34;:&#34;+port+&#34;:&#34;+orasid;
    System.out.println(&#34;xsout connection url: &#34;+ out_url);
 
    return out_url;
  }
 
  // print out sample program usage message
  public static void printUsage()
  {
    System.out.println(&#34;&#34;);      
    System.out.println(&#34;Usage: java xio &#34;+&#34;&lt;xsin_oraclesid&gt; &#34; + &#34;&lt;xsin_host&gt; &#34;
                                         + &#34;&lt;xsin_port&gt; &#34;);
    System.out.println(&#34;                &#34;+&#34;&lt;xsin_username&gt; &#34; + &#34;&lt;xsin_passwd&gt; &#34;
                                         + &#34;&lt;xsin_servername&gt; &#34;);
    System.out.println(&#34;                &#34;+&#34;&lt;xsout_oraclesid&gt; &#34; + &#34;&lt;xsout_host&gt; &#34;
                                         + &#34;&lt;xsout_port&gt; &#34;);
    System.out.println(&#34;                &#34;+&#34;&lt;xsout_username&gt; &#34; + &#34;&lt;xsout_passwd&gt; &#34;
                                         + &#34;&lt;xsout_servername&gt; &#34;);
  }
 
  // create a connection to an Oracle Database
  public static Connection createConnection(String url, 
                                            String username, 
                                            String passwd)
  {
    try
    {
      DriverManager.registerDriver(new oracle.jdbc.OracleDriver());
      return DriverManager.getConnection(url, username, passwd);
    }
    catch(Exception e)
    {
      System.out.println(&#34;fail to establish DB connection to: &#34; +url);
      e.printStackTrace();
      return null;
    }
  }
 
  // attach to the XStream Inbound Server
  public static XStreamIn attachInbound(Connection in_conn)
  {
    XStreamIn xsIn = null;
    try
    {
      xsIn = XStreamIn.attach((OracleConnection)in_conn, xsinName,
                              &#34;XSDEMOINCLIENT&#34; , XStreamIn.DEFAULT_MODE);
 
      // use last position to decide where should we start sending LCRs  
      lastPosition = xsIn.getLastPosition();
      System.out.println(&#34;Attached to inbound server:&#34;+xsinName);
      System.out.print(&#34;Inbound Server Last Position is: &#34;);
      if (null == lastPosition)
      {
        System.out.println(&#34;null&#34;);
      }
      else
      {
        printHex(lastPosition);
      }
      return xsIn;
    }
    catch(Exception e)
    {
      System.out.println(&#34;cannot attach to inbound server: &#34;+xsinName);
      System.out.println(e.getMessage());
      e.printStackTrace();
      return null;
    }        
  }
 
  // attach to the XStream Outbound Server    
  public static XStreamOut attachOutbound(Connection out_conn)
  {
    XStreamOut xsOut = null;
 
    try
    {
      // when attach to an outbound server, client needs to tell outbound
      // server the last position.
      xsOut = XStreamOut.attach((OracleConnection)out_conn, xsoutName,
                                lastPosition, XStreamOut.DEFAULT_MODE);
      System.out.println(&#34;Attached to outbound server:&#34;+xsoutName);
      System.out.print(&#34;Last Position is: &#34;);  
      if (lastPosition != null)
      {
        printHex(lastPosition);
      }
      else
      {
        System.out.println(&#34;NULL&#34;);
      }
      return xsOut;
    }
    catch(Exception e)
    {
      System.out.println(&#34;cannot attach to outbound server: &#34;+xsoutName);
      System.out.println(e.getMessage());
      e.printStackTrace();
      return null;
    } 
  }
 
  // detach from the XStream Inbound Server
  public static void detachInbound(XStreamIn xsIn)
  {
    byte[] processedLowPosition = null;
    try
    {
      processedLowPosition = xsIn.detach(XStreamIn.DEFAULT_MODE);
      System.out.print(&#34;Inbound server processed low Position is: &#34;);
      if (processedLowPosition != null)
      {
        printHex(processedLowPosition);
      }
      else
      {
        System.out.println(&#34;NULL&#34;);
      }
    }
    catch(Exception e)
    {
      System.out.println(&#34;cannot detach from the inbound server: &#34;+xsinName);
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
 
  // detach from the XStream Outbound Server    
  public static void detachOutbound(XStreamOut xsOut)
  {
    try
    {
      xsOut.detach(XStreamOut.DEFAULT_MODE);
    }
    catch(Exception e)
    {
      System.out.println(&#34;cannot detach from the outbound server: &#34;+xsoutName);
      System.out.println(e.getMessage());
      e.printStackTrace();
    }       
  }
 
  public static void get_lcrs(XStreamIn xsIn, XStreamOut xsOut)
  {
    if (null == xsIn) 
    {
      System.out.println(&#34;xstreamIn is null&#34;);
      System.exit(0);
    }
 
    if (null == xsOut)
    {
      System.out.println(&#34;xstreamOut is null&#34;);
      System.exit(0);
    }
 
    try
    {
      while(true) 
      {
        // receive an LCR from outbound server
        LCR alcr = xsOut.receiveLCR(XStreamOut.DEFAULT_MODE);
 
        if (xsOut.getBatchStatus() == XStreamOut.EXECUTING) // batch is active
        {
          assert alcr != null;
          // send the LCR to the inbound server
          xsIn.sendLCR(alcr, XStreamIn.DEFAULT_MODE);
 
          // also get chunk data for this LCR if any
          if (alcr instanceof RowLCR)
          {
            // receive chunk from outbound then send to inbound
            if (((RowLCR)alcr).hasChunkData())
            {
              ChunkColumnValue chunk = null; 
              do
              {
                chunk = xsOut.receiveChunk(XStreamOut.DEFAULT_MODE);
                xsIn.sendChunk(chunk, XStreamIn.DEFAULT_MODE);
              } while (!chunk.isEndOfRow());
            }
          }
          processedLowPosition = alcr.getPosition();
        }
        else  // batch is end 
        {
          assert alcr == null;
          // flush the network
          xsIn.flush(XStreamIn.DEFAULT_MODE);
          // get the processed_low_position from inbound server
          processedLowPosition = 
              xsIn.getProcessedLowWatermark();
          // update the processed_low_position at oubound server
          if (null != processedLowPosition)
            xsOut.setProcessedLowWatermark(processedLowPosition, 
                                           XStreamOut.DEFAULT_MODE);
        }
      }
    }
    catch(Exception e)
    {
      System.out.println(&#34;exception when processing LCRs&#34;);
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
 
  public static void printHex(byte[] b) 
  {
    for (int i = 0; i &lt; b.length; ++i) 
    {
      System.out.print(
        Integer.toHexString((b[i]&amp;0xFF) | 0x100).substring(1,3));
    }
    System.out.println(&#34;&#34;);
  }    
}
</pre></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5143">
<tr>
<td class="cellalignment5150">
<table class="cellalignment5148">
<tr>
<td class="cellalignment5147"><a href="GUID-08D451B5-2D76-447B-B39B-20CC73110D19.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5147"><a href="xstrm_out_restrict.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2009, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5152">
<table class="cellalignment5146">
<tr>
<td class="cellalignment5147"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5147"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5147"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5147"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5147"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5147"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>