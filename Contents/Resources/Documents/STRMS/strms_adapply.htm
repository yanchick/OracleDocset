<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-104437"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Advanced%20Apply%20Process%20Concepts"></a><title>Advanced Apply Process Concepts</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032"/>
<meta name="dcterms.created" content="2014-12-23T13:28:6Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Streams Concepts and Administration"/>
<meta name="dcterms.identifier" content="E53116-02"/>
<meta name="dcterms.isVersionOf" content="STRMS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="strms_glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="strms_adprop.htm" title="Previous" type="text/html"/>
<link rel="Next" href="strms_adrules.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53116-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">18/57</span> <!-- End Header -->
<div id="STRMS497" class="chapter"><a id="BABEABGC"></a>
<h1 class="chapter"><span class="secnum">10</span> Advanced Apply Process Concepts</h1>
<p><a id="sthref459"></a><a id="sthref460"></a>The following topics contain information about consuming information with Oracle Streams.</p>
<ul>
<li>
<p><a href="#i1007097">Apply Process Creation</a></p>
</li>
<li>
<p><a href="#BABDFDBI">Apply Processes and Dependencies</a></p>
</li>
<li>
<p><a href="#i1006927">Considerations for Applying DML Changes to Tables</a></p>
</li>
<li>
<p><a href="#i1007257">Considerations for Applying DDL Changes</a></p>
</li>
<li>
<p><a href="#i1009248">Instantiation SCN and Ignore SCN for an Apply Process</a></p>
</li>
<li>
<p><a href="#i1009319">The Oldest SCN for an Apply Process</a></p>
</li>
<li>
<p><a href="#i1009376">Low-Watermark and High-Watermark for an Apply Process</a></p>
</li>
<li>
<p><a href="#BABEBIII">Apply Processes and Triggers</a></p>
</li>
<li>
<p><a href="#i1007130">Oracle Streams Data Dictionary for an Apply Process</a></p>
</li>
<li>
<p><a href="#BGBCEHCB">Multiple Apply Processes in a Single Database</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_apply.htm#BABFBJDG">&#34;Implicit Consumption with an Apply Process&#34;</a></p>
</li>
<li>
<p><a href="strms_mapply.htm#g1026098">Chapter 17, &#34;Managing Oracle Streams Information Consumption&#34;</a></p>
</li>
<li>
<p><a href="strms_apmon.htm#CFFGFJBB">Chapter 26, &#34;Monitoring Oracle Streams Apply Processes&#34;</a></p>
</li>
</ul>
</div>
<a id="i1007097"></a>
<div id="STRMS498" class="sect1">
<h2 class="sect1">Apply Process Creation<a id="sthref461"></a><a id="sthref462"></a><a id="sthref463"></a></h2>
<p>You can create an <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> using the <code dir="ltr">DBMS_STREAMS_ADM</code> package or the <code dir="ltr">DBMS_APPLY_ADM</code> package. Using the <code dir="ltr">DBMS_STREAMS_ADM</code> package to create an apply process is simpler because defaults are used automatically for some configuration options. Alternatively, using the <code dir="ltr">DBMS_APPLY_ADM</code> package to create an apply process is more flexible.</p>
<p>When you create an apply process by running the <code dir="ltr">CREATE_APPLY</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package, you can specify nondefault values for the <code dir="ltr">apply_captured</code>, <code dir="ltr">apply_database_link</code>, and <code dir="ltr">apply_tag</code> parameters. You can use the procedures in the <code dir="ltr">DBMS_STREAMS_ADM</code> package or the <code dir="ltr">DBMS_RULE_ADM</code> package to add rules to a rule set for the apply process.</p>
<p>If you create more than one apply process in a database, then the apply processes are completely independent of each other. These apply processes do not synchronize with each other, even if they apply <a href="strms_glossary.htm#CHDJDFAD"><span class="xrefglossterm">LCR</span></a>s from the same <a href="strms_glossary.htm#CHDHFBJG"><span class="xrefglossterm">source database</span></a>.</p>
<p><a href="#BABIFCCH">Table 10-1</a> describes the differences between using the <code dir="ltr">DBMS_STREAMS_ADM</code> package and the <code dir="ltr">DBMS_APPLY_ADM</code> package for apply process creation.</p>
<div id="STRMS499" class="tblhruleformal">
<p class="titleintable"><a id="sthref464"></a><a id="BABIFCCH"></a>Table 10-1 DBMS_STREAMS_ADM and DBMS_APPLY_ADM Apply Process Creation</p>
<table class="cellalignment5973" title="DBMS_STREAMS_ADM and DBMS_APPLY_ADM Apply Process Creation" summary="This tables describes the differences between using the DBMS_STREAMS_ADM package and the DBMS_APPLY_ADM package for apply process creation, including differences in rule sets and rules, local and remote apply, and tag values for applied changes." dir="ltr">
<thead>
<tr class="cellalignment5964">
<th class="cellalignment5974" id="r1c1-t3">DBMS_STREAMS_ADM Package</th>
<th class="cellalignment5974" id="r1c2-t3">DBMS_APPLY_ADM Package</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5964">
<td class="cellalignment5970" id="r2c1-t3" headers="r1c1-t3">
<p>A <a href="strms_glossary.htm#CHDCHGGB"><span class="xrefglossterm">rule set</span></a> is created automatically for the apply process and <a href="strms_glossary.htm#CHDIFFCF"><span class="xrefglossterm">rule</span></a>s can be added to the rule set automatically. The rule set is a <a href="strms_glossary.htm#CHDEEDIJ"><span class="xrefglossterm">positive rule set</span></a> if the <code dir="ltr">inclusion_rule</code> parameter is set to <code dir="ltr">TRUE</code> (the default). It is a <a href="strms_glossary.htm#CHDBHJHI"><span class="xrefglossterm">negative rule set</span></a> if the <code dir="ltr">inclusion_rule</code> parameter is set to <code dir="ltr">FALSE</code>. You can use the procedures in the <code dir="ltr">DBMS_STREAMS_ADM</code> and <code dir="ltr">DBMS_RULE_ADM</code> package to manage rule sets and rules for the apply process after the apply process is created.</p>
</td>
<td class="cellalignment5970" headers="r2c1-t3 r1c2-t3">
<p>You create one or more rule sets and rules for the apply process either before or after it is created. You can use the procedures in the <code dir="ltr">DBMS_RULE_ADM</code> package to create rule sets and add rules to rule sets either before or after the apply process is created. You can use the procedures in the <code dir="ltr">DBMS_STREAMS_ADM</code> package to create rule sets and add rules to rule sets for the apply process after the apply process is created.</p>
</td>
</tr>
<tr class="cellalignment5964">
<td class="cellalignment5970" id="r3c1-t3" headers="r1c1-t3">
<p>The apply process can apply <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a>s only at the local database.</p>
</td>
<td class="cellalignment5970" headers="r3c1-t3 r1c2-t3">
<p>You specify whether the apply process applies messages at the local database or at a remote database during apply process creation.</p>
</td>
</tr>
<tr class="cellalignment5964">
<td class="cellalignment5970" id="r4c1-t3" headers="r1c1-t3">
<p>Changes applied by the apply process generate tags in the redo log at the <a href="strms_glossary.htm#CHDGCAJA"><span class="xrefglossterm">destination database</span></a> with a value of <code dir="ltr">00</code> (double zero).</p>
</td>
<td class="cellalignment5970" headers="r4c1-t3 r1c2-t3">
<p>You specify the <a href="strms_glossary.htm#CHDBJJHH"><span class="xrefglossterm">tag</span></a> value for changes applied by the apply process during apply process creation. The default value for the tag is <code dir="ltr">00</code> (double zero).</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink STREP206" href="../STREP/capply.htm#STREP206"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a> for information about creating an apply process</p>
</li>
<li>
<p><a class="olink STREP008" href="../STREP/rep_tags.htm#STREP008"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a> for more information about Oracle Streams tags</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="BABDFDBI"></a>
<div id="STRMS207" class="sect1">
<h2 class="sect1">Apply Processes and Dependencies<a id="sthref465"></a><a id="sthref466"></a></h2>
<p>The following sections describe how apply processes handle dependencies:</p>
<ul>
<li>
<p><a href="#BABFHGAI">How Dependent Transactions Are Applied</a></p>
</li>
<li>
<p><a href="#BABHJFEI">Row LCR Ordering During Apply</a></p>
</li>
<li>
<p><a href="#BABJECDF">Dependencies and Constraints</a></p>
</li>
<li>
<p><a href="#BABFABHJ">Dependency Detection, Rule-Based Transformations, and Apply Handlers</a></p>
</li>
<li>
<p><a href="#BABDHCJE">Virtual Dependency Definitions</a></p>
</li>
<li>
<p><a href="#BABHBCCH">Barrier Transactions</a></p>
</li>
</ul>
<a id="BABFHGAI"></a>
<div id="STRMS500" class="sect2">
<h3 class="sect2">How Dependent Transactions Are Applied</h3>
<p>The <code dir="ltr">parallelism</code> apply process parameter controls the parallelism of an apply process. When apply process parallelism is set to 1, a single apply server applies transactions in the same order as the order in which they were committed on the source database. In this case, dependencies are not an issue. For example, if transaction A is committed before transaction B on the source database, then, on the destination database, all of the LCRs in transaction A are applied before any LCRs in transaction&nbsp;B.</p>
<p>However, when apply process parallelism is set to a value greater than 1, multiple apply servers apply transactions simultaneously. When an apply process is applying transactions in parallel, it applies the row LCRs in these transactions until it detects a row LCR that depends on a row LCR in another transaction. When a dependent row LCR is detected, an apply process finishes applying the LCRs in the transaction with the lower commit system change number (CSCN) and commits this transaction before it finishes applying the remaining row LCRs in the transaction with the higher CSCN.</p>
<p>For example, consider two transactions: transaction A and transaction B. The transactions are dependent transactions, and each transaction contains 100 row LCRs. Transaction A committed on the source database before transaction B. Therefore, transaction A has the lower CSCN of the two transactions. An apply process can apply these transactions in parallel in the following way:</p>
<ol>
<li>
<p>The apply process begins to apply row LCRs from both transactions in parallel.</p>
</li>
<li>
<p>Using a constraint in the destination database&#39;s data dictionary or a virtual dependency definition at the destination database, the apply process detects a dependency between a row LCR in transaction A and a row LCR in transaction&nbsp;B.</p>
</li>
<li>
<p>Because transaction B has the higher CSCN of the two transactions, the apply process waits to apply transaction B and does not apply the dependent row LCR in transaction B. The row LCRs before the dependent row LCR in transaction B have been applied. For example, if the dependent row LCR in transaction B is the 81st row LCR, then the apply process could have applied 80 of the 100 row LCRs in transaction B.</p>
</li>
<li>
<p>Because transaction A has the lower CSCN of the two transactions, the apply process applies all the row LCRs in transaction A and commits.</p>
</li>
<li>
<p>The apply process applies the dependent row LCR in transaction B and the remaining row LCRs in transaction B. When all of the row LCRs in transaction B are applied, the apply process commits transaction B.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can set the <code dir="ltr">parallelism</code> apply process parameter using the <code dir="ltr">SET_PARAMETER</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package.</div>
</div>
<!-- class="sect2" -->
<a id="BABHJFEI"></a>
<div id="STRMS501" class="sect2">
<h3 class="sect2">Row LCR Ordering During Apply</h3>
<p>An apply process orders and applies row LCRs in the following way:</p>
<ul>
<li>
<p>Row LCRs within a single transaction are always applied in the same order as the corresponding changes on the source database.</p>
</li>
<li>
<p>Row LCRs that depend on each other in different transactions are always applied in the same order as the corresponding changes on the source database. When apply process parallelism is greater than 1, and the apply process detects a dependency between row LCRs in different transactions, the apply process always executes the transaction with the lower CSCN before executing the dependent row LCR. This behavior is described in more detail in <a href="#BABFHGAI">&#34;How Dependent Transactions Are Applied&#34;</a>.</p>
</li>
<li>
<p>If <code dir="ltr">commit_serialization</code> apply process parameter is set to <code dir="ltr">FULL</code>, then the apply process commits all transactions, regardless of whether they contain dependent row LCRs, in the same order as the corresponding transactions on the source database.</p>
</li>
<li>
<p>If <code dir="ltr">commit_serialization</code> apply process parameter is set to <code dir="ltr">DEPENDENT_TRANSACTIONS</code>, then the apply process might apply transactions that do not depend on each other in a different order than the commit order of the corresponding transactions on the source database.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can set the <code dir="ltr">commit_serialization</code> apply process parameter using the <code dir="ltr">SET_PARAMETER</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package.</div>
</div>
<!-- class="sect2" -->
<a id="BABJECDF"></a>
<div id="STRMS502" class="sect2">
<h3 class="sect2">Dependencies and Constraints</h3>
<p>If the names of shared database objects are the same at the source and destination databases, and if the objects are in the same schemas at these databases, then an apply process automatically detects dependencies between row LCRs, assuming constraints are defined for the database objects at the destination database. Information about these constraints is stored in the data dictionary at the destination database.</p>
<p>Regardless of the setting for the <code dir="ltr">commit_serialization</code> parameter and apply process parallelism, an apply process always respects dependencies between transactions that are enforced by database constraints. When an apply process is applying a transaction that contains row LCRs that depend on row LCRs in another transaction, the apply process ensures that the row LCRs are applied in the correct order and that the transactions are committed in the correct order to maintain the dependencies. Apply processes detect dependencies for captured row&nbsp;LCRs and persistent row LCRs.</p>
<p>However, some environments have dependencies that are not enforced by database constraints, such as environments that enforce dependencies using applications. If your environment has dependencies for shared database objects that are not enforced by database constraints, then set the <code dir="ltr">commit_serialization</code> parameter to <code dir="ltr">FULL</code> for apply processes that apply changes to these database objects.</p>
</div>
<!-- class="sect2" -->
<a id="BABFABHJ"></a>
<div id="STRMS503" class="sect2">
<h3 class="sect2">Dependency Detection, Rule-Based Transformations, and Apply Handlers</h3>
<p>When rule-based transformations are specified for rules used by an apply process, and apply handlers are configured for the apply process, LCRs are processed in the following order:</p>
<ol>
<li>
<p>The apply process dequeues LCRs from its queue.</p>
</li>
<li>
<p>The apply process runs rule-based transformations on LCRs, when appropriate.</p>
</li>
<li>
<p>The apply process detects dependencies between LCRs.</p>
</li>
<li>
<p>The apply process passes LCRs to apply handlers, when appropriate.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="strms_apply.htm#i1007083">&#34;Apply Process Subcomponents&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="BABDHCJE"></a>
<div id="STRMS504" class="sect2">
<h3 class="sect2">Virtual Dependency Definitions<a id="sthref467"></a><a id="sthref468"></a></h3>
<p>In some cases, an apply process requires additional information to detect dependencies in row LCRs that are being applied in parallel. The following are examples of cases in which an apply process requires additional information to detect dependencies:</p>
<ul>
<li>
<p>The data dictionary at the destination database does not contain the required information. The following are examples of this case:</p>
<ul>
<li>
<p>The apply process cannot find information about a database object in the data dictionary of the destination database. This can happen when there are data dictionary differences for shared database objects between the source and destination databases. For example, a shared database object can have a different name or can be in a different schema at the source database and destination database.</p>
</li>
<li>
<p>A relationship exists between two or more tables, and the relationship is not recorded in the data dictionary of the destination database. This can happen when database constraints are not defined to improve performance or when an application enforces dependencies during database operations instead of database constraints.</p>
</li>
</ul>
</li>
<li>
<p>Data is denormalized by an apply handler after dependency computation. For example, the information in a single row LCR can be used to create multiple row LCRs that are applied to multiple tables.</p>
</li>
</ul>
<p>Apply errors or incorrect processing can result when an apply process cannot determine dependencies properly. In some of the cases described in the previous list, you can use rule-based transformations to avoid apply problems. For example, if a shared database object is in different schemas at the source and destination databases, then a rule-based transformation can change the schema in the appropriate LCRs. However, the disadvantage with using rule-based transformations is that they cannot be executed in parallel.</p>
<p>A <span class="bold">virtual dependency definition</span> is a description of a dependency that is used by an apply process to detect dependencies between transactions at a destination database. A virtual dependency definition is not described as a constraint in the data dictionary of the destination database. Instead, it is specified using procedures in the <code dir="ltr">DBMS_APPLY_ADM</code> package. Virtual dependency definitions enable an apply process to detect dependencies that it would not be able to detect by using only the constraint information in the data dictionary. After dependencies are detected, an apply process schedules LCRs and transactions in the correct order for apply.</p>
<p>Virtual dependency definitions provide required information so that apply processes can detect dependencies correctly before applying LCRs directly or passing LCRs to apply handlers. Virtual dependency definitions enable apply handlers to process these LCRs correctly, and the apply handlers can process them in parallel to improve performance.</p>
<p>A virtual dependency definition can define one of the following types of dependencies:</p>
<ul>
<li>
<p><a href="#BABIJAEA">Value Dependency</a></p>
</li>
<li>
<p><a href="#BABCBHFC">Object Dependency</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
A destination database must be running Oracle Database 10<span class="italic">g</span> Release 2 or later to specify virtual dependency definitions.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_mapply.htm#BGBBJHCB">&#34;Using Virtual Dependency Definitions&#34;</a></p>
</li>
<li>
<p><a href="strms_apmon.htm#CACCGDCE">&#34;Monitoring Virtual Dependency Definitions&#34;</a></p>
</li>
</ul>
</div>
<a id="BABIJAEA"></a>
<div id="STRMS505" class="sect3">
<h4 class="sect3">Value Dependency<a id="sthref469"></a></h4>
<p>A <span class="bold">value dependency</span> defines a table constraint, such as a unique key, or a relationship between the columns of two or more tables. A value dependency is set for one or more columns, and an apply process uses a value dependency to detect dependencies between row LCRs that contain values for these columns. Value dependencies can define virtual foreign key relationships between tables, but, unlike foreign key relationships, value dependencies can involve more than two tables.</p>
<p>Value dependencies are useful when relationships between columns in tables are not described by constraints in the data dictionary of the destination database. Value dependencies describe these relationships, and an apply process uses the value dependencies to determine when two or more row LCRs in different transactions involve the same row in a table at the destination database. For transactions that are being applied in parallel, when two or more row LCRs involve the same row, the transactions that include these row LCRs are dependent transactions.</p>
<p>Use the <code dir="ltr">SET_VALUE_DEPENDENCY</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package to define or remove a value dependency at a destination database. In this procedure, table columns are specified as attributes.</p>
<p>The following restrictions pertain to value dependencies:</p>
<ul>
<li>
<p>The row LCRs that involve the database objects specified in a value dependency must originate from a single source database.</p>
</li>
<li>
<p>Each value dependency must contain only one set of attributes for a particular database object.</p>
</li>
</ul>
<p>Also, any columns specified in a value dependency at a destination database must be supplementally logged at the source database. These columns must be unconditionally logged.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="strms_capture.htm#i1007293">&#34;Supplemental Logging in an Oracle Streams Environment&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="BABCBHFC"></a>
<div id="STRMS506" class="sect3">
<h4 class="sect3">Object Dependency<a id="sthref470"></a></h4>
<p>An <span class="bold">object dependency</span> defines a parent-child relationship between two objects at a destination database. An apply process schedules execution of transactions that involve the child object after all transactions with lower commit system change number (CSCN) values that involve the parent object have been committed. An apply process uses the object identifier in each row LCR to detect dependencies. The apply process does not use column values in the row LCRs to detect object dependencies.</p>
<p>Object dependencies are useful when relationships between tables are not described by constraints in the data dictionary of the destination database. Object dependencies describe these relationships, and an apply process uses the object dependencies to determine when two or more row LCRs in different transactions involve these tables. For transactions that are being applied in parallel, when a row LCR in one transaction involves the child table, and a row LCR in a different transaction involves the parent table, the transactions that include these row LCRs are dependent transactions.</p>
<p>Use the <code dir="ltr">CREATE_OBJECT_DEPENDENCY</code> procedure to create an object dependency at a destination database. Use the <code dir="ltr">DROP_OBJECT_DEPENDENCY</code> procedure to drop an object dependency at a destination database. Both of these procedures are in the in the <code dir="ltr">DBMS_APPLY_ADM</code> package.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Tables with circular dependencies can result in apply process deadlocks when apply process parallelism is greater than 1. The following is an example of a circular dependency: Table A has a foreign key constraint on table B, and table B has a foreign key constraint on table A. Apply process deadlocks are possible when two or more transactions that involve the tables with circular dependencies commit at the same SCN.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABHBCCH"></a>
<div id="STRMS507" class="sect2">
<h3 class="sect2">Barrier Transactions<a id="sthref471"></a></h3>
<p>When an apply process cannot identify the table row or the database object specified in a row LCR by using the destination database&#39;s data dictionary and virtual dependency definitions, the transaction that contains the row LCR is applied after all of the other transactions with lower CSCN values. Such a transaction is called a <span class="bold">barrier transaction</span>. Transactions with higher CSCN values than the barrier transaction are not applied until after the barrier transaction has committed. In addition, all DDL transactions are barrier transactions.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006927"></a>
<div id="STRMS202" class="sect1"><a id="BABHCGIA"></a>
<h2 class="sect1">Considerations for Applying DML Changes to Tables<a id="sthref472"></a><a id="sthref473"></a></h2>
<p>The following sections discuss considerations for applying DML changes to tables:</p>
<ul>
<li>
<p><a href="#BABHACGE">Constraints and Applying DML Changes to Tables</a></p>
</li>
<li>
<p><a href="#i1006973">Substitute Key Columns</a></p>
</li>
<li>
<p><a href="#i1007062">Apply Process Behavior for Column Discrepancies</a></p>
</li>
<li>
<p><a href="#i1007110">Conflict Resolution and an Apply Process</a></p>
</li>
<li>
<p><a href="#i1007135">Handlers and Row LCR Processing</a></p>
</li>
</ul>
<a id="BABHACGE"></a>
<div id="STRMS508" class="sect2">
<h3 class="sect2">Constraints and Applying DML Changes to Tables<a id="sthref474"></a><a id="sthref475"></a></h3>
<p>You must ensure that the primary key columns at the destination database are logged in the redo log at the source database for every update. A unique key or foreign key constraint at a destination database that contains data from more that one column at the source database requires additional logging at the source database.</p>
<p>There are various ways to ensure that a column is logged at the source database. For example, whenever the value of a column is updated, the column is logged. Also, Oracle has a feature called supplemental logging that automates the logging of specified columns.</p>
<p>For a unique key and foreign key constraint at a destination database that contains data from only one column at a source database, no supplemental logging is required. However, for a constraint that contains data from multiple columns at the source database, you must create a conditional supplemental log group containing all the columns at the source database that are used by the constraint at the destination database.</p>
<p>Typically, unique key and foreign key constraints include the same columns at the source database and destination database. However, in some cases, an apply handler or custom rule-based transformation can combine a multi-column constraint from the source database into a single key column at the destination database. Also, an apply handler or custom rule-based transformation can separate a single key column from the source database into a multi-column constraint at the destination database. In such cases, the number of columns in the constraint at the source database determines whether a conditional supplemental log group is required. If there is more than one column in the constraint at the source database, then a conditional supplemental log group containing all the constraint columns is required at the source database. If there is only one column in the constraint at the source database, then no supplemental logging is required for the key column.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STREP107" href="../STREP/prep_rep.htm#STREP107"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a> for more information about supplemental logging</div>
</div>
<!-- class="sect2" -->
<a id="i1006973"></a>
<div id="STRMS214" class="sect2">
<h3 class="sect2">Substitute Key Columns<a id="sthref476"></a><a id="sthref477"></a></h3>
<p>If possible, each table for which changes are applied by an apply process should have a primary key. When a primary key is not possible, Oracle recommends that each table have a set of columns that can be used as a unique identifier for each row of the table. If the tables that you plan to use in your Oracle Streams environment do not have a primary key or a set of unique columns, then consider altering these tables accordingly.</p>
<p>To detect conflicts and handle errors accurately, Oracle must be able to identify uniquely and match corresponding rows at different databases. By default, Oracle Streams uses the primary key of a table to identify rows in the table, and if a primary key does not exist, Oracle Streams uses the smallest unique key that has at least one <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> column to identify rows in the table. When a table at a destination database does not have a primary key or a unique key with at least one <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> column, or when you want to use columns other than the primary key or unique key for the key, you can designate a substitute key at the destination database. A substitute key is a column or set of columns that Oracle can use to identify rows in the table during apply.</p>
<p>You can specify the substitute primary key for a table using the <code dir="ltr">SET_KEY_COLUMNS</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package. Unlike true primary keys, the substitute key columns can contain nulls. Also, the substitute key columns take precedence over any existing primary key or unique keys for the specified table for all apply processes at the destination database.</p>
<p>If you specify a substitute key for a table in a destination database, and these columns are not a primary key for the same table at the source database, then you must create an unconditional supplemental log group containing the substitute key columns at the source database.</p>
<p>In the absence of substitute key columns, primary key constraints, and unique key constraints, an apply process uses all of the columns in the table as the key columns, excluding columns of the following data types: LOB, <code dir="ltr">LONG</code>, <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, user-defined types (including object types, <code dir="ltr">REF</code>s, varrays, nested tables), and Oracle-supplied types (including <code dir="ltr">Any</code> types, XML types, spatial types, and media types). In this case, you must create an unconditional supplemental log group containing these columns at the source database. Using substitute key columns is preferable when there is no primary key constraint for a table because fewer columns are needed in the row LCR.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Oracle recommends that each column you specify as a substitute key column be a <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> column. You should also create a single index that includes all of the columns in a substitute key. Following these guidelines improves performance for changes because the database can locate the relevant row more efficiently.</p>
</li>
<li>
<p>LOB, <code dir="ltr">LONG</code>, <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, user-defined type, and Oracle-supplied type columns cannot be specified as substitute key columns.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>The <code dir="ltr">DBMS_APPLY_ADM.SET_KEY_COLUMNS</code> procedure in the <a class="olink ARPLS315" href="../ARPLS/d_apply.htm#ARPLS315"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p>
</li>
<li>
<p><a class="olink STREP107" href="../STREP/prep_rep.htm#STREP107"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a> for more information about supplemental logging</p>
</li>
<li>
<p><a class="olink SQLRF0021" href="../SQLRF/sql_elements001.htm#SQLRF0021"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about data types</p>
</li>
<li>
<p><a href="strms_mapply.htm#BGBGJICI">&#34;Managing the Substitute Key Columns for a Table&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007062"></a>
<div id="STRMS509" class="sect2">
<h3 class="sect2">Apply Process Behavior for Column Discrepancies<a id="sthref478"></a></h3>
<p>A column discrepancy is any difference in the columns in a table at a source database and the columns in the same table at a destination database. If there are column discrepancies in your Oracle Streams environment, then use rule-based transformations, statement DML handlers, or procedure DML handlers to make the columns in row LCRs being applied by an apply process match the columns in the relevant tables at a destination database.</p>
<p>The following sections describe apply process behavior for common column discrepancies.</p>
<ul>
<li>
<p><a href="#BABJAFGI">Missing Columns at the Destination Database</a></p>
</li>
<li>
<p><a href="#BABGIHHA">Extra Columns at the Destination Database</a></p>
</li>
<li>
<p><a href="#BABIJHDI">Column Data Type Mismatch</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_apply.htm#BABGBDGD">&#34;DML Handlers&#34;</a></p>
</li>
<li>
<p><a href="strms_transform.htm#CACIIJHJ">Chapter 6, &#34;Rule-Based Transformations&#34;</a></p>
</li>
<li>
<p><a class="olink ARPLS307" href="../ARPLS/t_lcr.htm#ARPLS307"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about&nbsp;LCRs</p>
</li>
</ul>
</div>
<a id="BABJAFGI"></a>
<div id="STRMS510" class="sect3">
<h4 class="sect3">Missing Columns at the Destination Database</h4>
<p>If the table at the destination database is missing one or more columns that are in the table at the source database, then an apply process raises an error and moves the transaction that caused the error into the error queue. You can avoid such an error by creating a rule-based transformation or procedure DML handler that deletes the missing columns from the LCRs before they are applied. Specifically, the transformation or handler can remove the extra columns using the <code dir="ltr">DELETE_COLUMN</code> member procedure on the row LCR. You can also create a statement DML handler with a SQL statement that excludes the missing columns.</p>
</div>
<!-- class="sect3" -->
<a id="BABGIHHA"></a>
<div id="STRMS511" class="sect3">
<h4 class="sect3">Extra Columns at the Destination Database</h4>
<p>If the table at the destination database has more columns than the table at the source database, then apply process behavior depends on whether the extra columns are required for dependency computations. If the extra columns are not used for dependency computations, then an apply process applies changes to the destination table. In this case, if column defaults exist for the extra columns at the destination database, then these defaults are used for these columns for all inserts. Otherwise, these inserted columns are <code dir="ltr">NULL</code>.</p>
<p>If, however, the extra columns are used for dependency computations, then an apply process places the transactions that include these changes in the error queue. The following types of columns are required for dependency computations:</p>
<ul>
<li>
<p>For all changes, all key columns</p>
</li>
<li>
<p>For <code dir="ltr">INSERT</code> and <code dir="ltr">DELETE</code> statements, all columns involved with constraints</p>
</li>
<li>
<p>For <code dir="ltr">UPDATE</code> statements, if a constraint column is changed, such as a unique key constraint column or a foreign key constraint column, then all columns involved in the constraint</p>
</li>
</ul>
<p>When the extra columns are used for dependency computations, one way to avoid apply errors is to use statement DML handlers to add the extra columns.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="strms_apply.htm#BGBFBIAE">&#34;Statement DML Handlers&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="BABIJHDI"></a>
<div id="STRMS512" class="sect3">
<h4 class="sect3">Column Data Type Mismatch</h4>
<p>A column data type mismatch results when the data type for a column in a table at the destination database does not match the data type for the same column at the source database. An apply process can automatically convert certain data types when it encounters a column data type mismatch. If an apply process cannot automatically convert the data type, then apply process places transactions containing the changes to the mismatched column into the error queue. To avoid such an error, you can create a custom rule-based transformation or DML&nbsp;handler that converts the data type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="strms_apply.htm#BABICJGE">&#34;Automatic Data Type Conversion During Apply&#34;</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007110"></a>
<div id="STRMS513" class="sect2">
<h3 class="sect2">Conflict Resolution and an Apply Process<a id="sthref479"></a></h3>
<p>Conflicts are possible in an Oracle Streams configuration where data is shared between multiple databases. A <span class="bold">conflict</span> is a mismatch between the old values in an LCR and the expected data in a table. A conflict can occur if DML changes are allowed to a table for which changes are captured and to a table where these changes are applied.</p>
<p>For example, a transaction at the source database can update a row at nearly the same time as a different transaction that updates the same row at a destination database. In this case, if data consistency between the two databases is important, then when the change is propagated to the destination database, an apply process must be instructed either to keep the change at the destination database or replace it with the change from the source database. When data conflicts occur, you need a mechanism to ensure that the conflict is resolved in accordance with your business rules.</p>
<p>Oracle Streams automatically detects conflicts and, for update conflicts, tries to use an update conflict handler to resolve them if one is configured. Oracle Streams offers a variety of prebuilt handlers that enable you to define a conflict resolution system for your database that resolves conflicts in accordance with your business rules. If you have a unique situation that a prebuilt conflict resolution handler cannot resolve, then you can build and use your own custom conflict resolution handlers in an error handler or procedure DML handler. Conflict detection can be disabled for nonkey columns.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STREP001" href="../STREP/conflict.htm#STREP001"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1007135"></a>
<div id="STRMS514" class="sect2">
<h3 class="sect2">Handlers and Row LCR Processing<a id="sthref480"></a><a id="sthref481"></a><a id="sthref482"></a><a id="sthref483"></a><a id="sthref484"></a><a id="sthref485"></a></h3>
<p>Any of the following handlers can process a row LCR:</p>
<ul>
<li>
<p>DML handler (either statement DML handler or procedure DML handler)</p>
</li>
<li>
<p>Error handler</p>
</li>
<li>
<p>Update conflict handler</p>
</li>
</ul>
<p>The following sections describe the possible scenarios involving these handlers:</p>
<ul>
<li>
<p><a href="#i1007168">No Relevant Handlers</a></p>
</li>
<li>
<p><a href="#i1007171">Relevant Update Conflict Handler</a></p>
</li>
<li>
<p><a href="#i1007176">DML Handler But No Relevant Update Conflict Handler</a></p>
</li>
<li>
<p><a href="#i1007182">DML Handler And a Relevant Update Conflict Handler</a></p>
</li>
<li>
<p><a href="#BABFIIIH">Statement DML Handler and Procedure DML Handler</a></p>
</li>
<li>
<p><a href="#i1007206">Error Handler But No Relevant Update Conflict Handler</a></p>
</li>
<li>
<p><a href="#i1007212">Error Handler And a Relevant Update Conflict Handler</a></p>
</li>
<li>
<p><a href="#BABIEFEC">Statement DML Handler and Relevant Error Handler</a></p>
</li>
<li>
<p><a href="#BABFFHAI">Statement DML Handler, Error Handler, and Relevant Update Conflict Handler</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS307" href="../ARPLS/t_lcr.htm#ARPLS307"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">EXECUTE</code> member procedure for row&nbsp;LCRs</p>
</li>
<li>
<p><a href="strms_apply.htm#BABGBDGD">&#34;DML Handlers&#34;</a></p>
</li>
<li>
<p><a href="strms_rules.htm#g1049257">Chapter 5, &#34;How Rules Are Used in Oracle Streams&#34;</a></p>
</li>
<li>
<p><a class="olink STREP001" href="../STREP/conflict.htm#STREP001"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a></p>
</li>
</ul>
</div>
<a id="i1007168"></a>
<div id="STRMS515" class="sect3">
<h4 class="sect3">No Relevant Handlers</h4>
<p>If there are no relevant handlers for a row LCR, then an apply process tries to apply the change specified in the row LCR directly. If the apply process can apply the row LCR, then the change is made to the row in the table. If there is a conflict or an error during apply, then the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
</div>
<!-- class="sect3" -->
<a id="i1007171"></a>
<div id="STRMS516" class="sect3">
<h4 class="sect3">Relevant Update Conflict Handler</h4>
<p>Consider a case where there is a relevant update conflict handler configured, but no other relevant handlers are configured. An apply process tries to apply the change specified in a row LCR directly. If the apply process can apply the row LCR, then the change is made to the row in the table.</p>
<p>If there is an error during apply that is caused by a condition other than an update conflict, including a uniqueness conflict or a delete conflict, then the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
<p>If there is an update conflict during apply, then the relevant update conflict handler is invoked. If the update conflict handler resolves the conflict successfully, then the apply process either applies the LCR or discards the LCR, depending on the resolution of the update conflict, and the apply process continues applying the other LCRs in the transaction that should be applied according to the apply process rule sets. If the update conflict handler cannot resolve the conflict, then the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
</div>
<!-- class="sect3" -->
<a id="i1007176"></a>
<div id="STRMS517" class="sect3">
<h4 class="sect3">DML Handler But No Relevant Update Conflict Handler</h4>
<p>Consider a case where an apply process passes a row LCR to a DML handler, and there is no relevant update conflict handler configured. The DML handler can be a statement DML handler or a procedure DML handler.</p>
<p>The DML handler processes the row LCR. The designer of the DML handler has complete control over this processing. Some DML handlers can perform SQL operations or run the <code dir="ltr">EXECUTE</code> member procedure of the row LCR. If the DML handler runs the <code dir="ltr">EXECUTE</code> member procedure of the row LCR, then the apply process tries to apply the row LCR. This row LCR might have been modified by the DML handler.</p>
<div id="STRMS1510" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref486"></a>
<h5 class="sect4">Statement DML Handler Failure</h5>
<p>An apply process can have multiple statement DML handlers for the same operation on the same table. These statement DML handlers can run in any order, and each statement DML handler receives the original row LCR. If any SQL operation performed by any statement DML handler fails, or if an attempt to run the <code dir="ltr">EXECUTE</code> member procedure fails, then the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
<div id="STRMS1511" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref487"></a>
<h5 class="sect4">Procedure DML Handler Failure</h5>
<p>If any SQL operation performed by a procedure DML handler fails, or if an attempt to run the <code dir="ltr">EXECUTE</code> member procedure fails, then the procedure DML handler can try to handle the exception. If the procedure DML handler does not raise an exception, then the apply process assumes the procedure DML handler has performed the appropriate action with the row LCR, and the apply process continues applying the other LCRs in the transaction that should be applied according to the apply process rule sets.</p>
<p>If the procedure DML handler cannot handle the exception, then the procedure DML handler should raise an exception. In this case, the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1007182"></a>
<div id="STRMS518" class="sect3">
<h4 class="sect3">DML Handler And a Relevant Update Conflict Handler</h4>
<p>Consider a case where an apply process passes a row LCR to a DML handler and there is a relevant update conflict handler configured. The DML handler can be a statement DML handler or a procedure DML handler. An apply process can have multiple statement DML handlers for the same operation on the same table. These statement DML handlers can run in any order, and each statement DML handler receives the original row LCR.</p>
<p>The DML handler processes the row LCR. The designer of the DML handler has complete control over this processing. Some DML handlers might perform SQL operations or run the <code dir="ltr">EXECUTE</code> member procedure of the row LCR. If the DML handler runs the <code dir="ltr">EXECUTE</code> member procedure of the row LCR, then the apply process tries to apply the row LCR. If the DML handler is a procedure DML handler, then this row LCR could have been modified by the procedure DML handler.</p>
<p>If any SQL operation performed by a DML handler fails, or if an attempt to run the <code dir="ltr">EXECUTE</code> member procedure fails for any reason other than an update conflict, then the behavior is the same as that described in <a href="#i1007176">&#34;DML Handler But No Relevant Update Conflict Handler&#34;</a>. Note that uniqueness conflicts and delete conflicts are not update conflicts.</p>
<p>If an attempt to run the <code dir="ltr">EXECUTE</code> member procedure fails because of an update conflict, then the behavior depends on the setting of the <code dir="ltr">conflict_resolution</code> parameter in the <code dir="ltr">EXECUTE</code> member procedure:</p>
<dl>
<dt>The conflict_resolution Parameter Is Set to TRUE</dt>
<dd>
<p>If the <code dir="ltr">conflict_resolution</code> parameter is set to <code dir="ltr">TRUE</code>, then the relevant update conflict handler is invoked. If the update conflict handler resolves the conflict successfully, and all other operations performed by the DML handler succeed, then the DML handler finishes without raising an exception, and the apply process continues applying the other LCRs in the transaction that should be applied according to the apply process rule sets.</p>
<p>If the update conflict handler cannot resolve the conflict, and the DML handler is a statement DML handler, then the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
<p>If the update conflict handler cannot resolve the conflict, and the DML handler is a procedure DML handler, then a procedure DML handler can try to handle the exception. If the procedure DML handler does not raise an exception, then the apply process assumes the procedure DML handler has performed the appropriate action with the row LCR, and the apply process continues applying the other LCRs in the transaction that should be applied according to the apply process rule sets. If the procedure DML handler cannot handle the exception, then the procedure DML handler should raise an exception. In this case, the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
</dd>
<dt>The conflict_resolution Parameter Is Set to FALSE</dt>
<dd>
<p>If the <code dir="ltr">conflict_resolution</code> parameter is set to <code dir="ltr">FALSE</code>, then the relevant update conflict handler is not invoked. In this case, the behavior is the same as that described in <a href="#i1007176">&#34;DML Handler But No Relevant Update Conflict Handler&#34;</a>.</p>
</dd>
</dl>
</div>
<!-- class="sect3" -->
<a id="BABFIIIH"></a>
<div id="STRMS1512" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Statement DML Handler and Procedure DML Handler</h4>
<p>Consider a case where an apply process passes a row LCR to both a statement DML handler and a procedure DML handler for the same operation on the same table. In this case, the DML handlers can be run in any order, and each DML handler receives each original row LCR. Also, an apply process can have multiple statement DML handlers for the same operation on the same table. These statement DML handlers can run in any order, and each statement DML handler receives the original row LCR. Each DML handler processes the row LCR independently, and the behavior is the same as any other scenario that involves a DML handler.</p>
<p>If any statement DML handler or procedure DML handler fails, then the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
</div>
<!-- class="sect3" -->
<a id="i1007206"></a>
<div id="STRMS519" class="sect3">
<h4 class="sect3">Error Handler But No Relevant Update Conflict Handler</h4>
<p>Consider a case where an apply process encounters an error when it tries to apply a row LCR. This error can be caused by a conflict or by some other condition. There is an error handler for the table operation but no relevant update conflict handler configured.</p>
<p>The row LCR is passed to the error handler. The error handler processes the row LCR. The designer of the error handler has complete control over this processing. Some error handlers might perform SQL operations or run the <code dir="ltr">EXECUTE</code> member procedure of the row LCR. If the error handler runs the <code dir="ltr">EXECUTE</code> member procedure of the row LCR, then the apply process tries to apply the row LCR. This row LCR could have been modified by the error handler.</p>
<p>If any SQL operation performed by the error handler fails, or if an attempt to run the <code dir="ltr">EXECUTE</code> member procedure fails, then the error handler can try to handle the exception. If the error handler does not raise an exception, then the apply process assumes the error handler has performed the appropriate action with the row LCR, and the apply process continues applying the other LCRs in the transaction that should be applied according to the apply process rule sets.</p>
<p>If the error handler cannot handle the exception, then the error handler should raise an exception. In this case, the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
</div>
<!-- class="sect3" -->
<a id="i1007212"></a>
<div id="STRMS520" class="sect3">
<h4 class="sect3">Error Handler And a Relevant Update Conflict Handler</h4>
<p>Consider a case where an apply process encounters an error when it tries to apply a row LCR. There is an error handler for the table operation, and there is a relevant update conflict handler configured.</p>
<p>The handler that is invoked to handle the error depends on the type of error it is:</p>
<ul>
<li>
<p>If the error is caused by a condition other than an update conflict, including a uniqueness conflict or a delete conflict, then the error handler is invoked, and the behavior is the same as that described in <a href="#i1007206">&#34;Error Handler But No Relevant Update Conflict Handler&#34;</a>.</p>
</li>
<li>
<p>If the error is caused by an update conflict, then the update conflict handler is invoked. If the update conflict handler resolves the conflict successfully, then the apply process continues applying the other LCRs in the transaction that should be applied according to the apply process rule sets. In this case, the error handler is not invoked.</p>
<p>If the update conflict handler cannot resolve the conflict, then the error handler is invoked. If the error handler does not raise an exception, then the apply process assumes the error handler has performed the appropriate action with the row LCR, and the apply process continues applying the other LCRs in the transaction that should be applied according to the apply process rule sets. If the error handler cannot process the LCR, then the error handler should raise an exception. In this case, the transaction containing the row LCR is rolled back, and all of the LCRs in the transaction that should be applied according to the apply process rule sets are moved to the error queue.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABIEFEC"></a>
<div id="STRMS1513" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Statement DML Handler and Relevant Error Handler</h4>
<p>Consider a case where an apply process passes a row LCR to a statement DML handler and there is a relevant error handler configured.</p>
<p>The statement DML handler processes the row LCR. The designer of the statement DML handler has complete control over this processing. Some statement DML handlers might perform SQL operations or run the <code dir="ltr">EXECUTE</code> member procedure of the row LCR. If the statement DML handler runs the <code dir="ltr">EXECUTE</code> member procedure of the row LCR, then the apply process tries to apply the row LCR.</p>
<p>Also, an apply process can have multiple statement DML handlers for the same operation on the same table. These statement DML handlers can run in any order, and each statement DML handler receives the original row LCR.</p>
<p>If any SQL operation performed by any statement DML handler fails, or if an attempt to run the <code dir="ltr">EXECUTE</code> member procedure fails for any reason, then the behavior is the same as that described in <a href="#i1007206">&#34;Error Handler But No Relevant Update Conflict Handler&#34;</a>. The error handler gets the original row LCR, not the row LCR processed by the statement DML handler.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot have a procedure DML handler and an error handler simultaneously for the same operation on the same table. Therefore, there is no scenario in which they could both be invoked.</div>
</div>
<!-- class="sect3" -->
<a id="BABFFHAI"></a>
<div id="STRMS1514" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Statement DML Handler, Error Handler, and Relevant Update Conflict Handler</h4>
<p>Consider a case where an apply process passes a row LCR to a statement DML handler and there is a relevant error handler and a relevant update conflict handler configured.</p>
<p>The statement DML handler processes the row LCR. The designer of the statement DML handler has complete control over this processing. Some statement DML handlers might perform SQL operations or run the <code dir="ltr">EXECUTE</code> member procedure of the row LCR. If the statement DML handler runs the <code dir="ltr">EXECUTE</code> member procedure of the row LCR, then the apply process tries to apply the row LCR.</p>
<p>Also, an apply process can have multiple statement DML handlers for the same operation on the same table. These statement DML handlers can run in any order, and each statement DML handler receives the original row LCR.</p>
<p>If any SQL operation performed by any statement DML handler fails, or if an attempt to run the <code dir="ltr">EXECUTE</code> member procedure fails for any reason, then the behavior is the same as that described in <a href="#i1007212">&#34;Error Handler And a Relevant Update Conflict Handler&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot have a procedure DML handler and an error handler simultaneously for the same operation on the same table. Therefore, there is no scenario in which they could both be invoked.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007257"></a>
<div id="STRMS203" class="sect1">
<h2 class="sect1">Considerations for Applying DDL Changes<a id="sthref488"></a></h2>
<p>The following sections discuss considerations for applying DDL changes to tables:</p>
<ul>
<li>
<p><a href="#i1007358">System-Generated Names</a></p>
</li>
<li>
<p><a href="#i1007372">CREATE TABLE AS SELECT Statements</a></p>
</li>
<li>
<p><a href="#BABJACHA">DML Statements within DDL Statements</a></p>
</li>
</ul>
<a id="i1007358"></a>
<div id="STRMS521" class="sect2">
<h3 class="sect2">System-Generated Names<a id="sthref489"></a><a id="sthref490"></a></h3>
<p>If you plan to capture DDL changes at a source database and apply these DDL changes at a destination database, then avoid using system-generated names. If a DDL statement results in a system-generated name for an object, then the name of the object typically will be different at the source database and each destination database applying the DDL change from this source database. Different names for objects can result in apply errors for future DDL changes.</p>
<p>For example, suppose the following DDL statement is run at a source database:</p>
<pre dir="ltr">CREATE TABLE sys_gen_name (n1 NUMBER  NOT NULL); 
</pre>
<p>This statement results in a <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint with a system-generated name. For example, the <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint might be named <code dir="ltr">sys_001500</code>. When this change is applied at a destination database, the system-generated name for this constraint might be <code dir="ltr">sys_c1000</code>.</p>
<p>Suppose the following DDL statement is run at the source database:</p>
<pre dir="ltr">ALTER TABLE sys_gen_name DROP CONSTRAINT sys_001500;
</pre>
<p>This DDL statement succeeds at the source database, but it fails at the destination database and results in an apply error.</p>
<p>To avoid such an error, explicitly name all objects resulting from DDL statements. For example, to name a <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint explicitly, run the following DDL statement:</p>
<pre dir="ltr">CREATE TABLE sys_gen_name (n1 NUMBER CONSTRAINT sys_gen_name_nn NOT NULL);
</pre></div>
<!-- class="sect2" -->
<a id="i1007372"></a>
<div id="STRMS522" class="sect2">
<h3 class="sect2">CREATE TABLE AS SELECT Statements<a id="sthref491"></a><a id="sthref492"></a></h3>
<p>When applying a change resulting from a <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> <code dir="ltr">AS</code> <code dir="ltr">SELECT</code> statement, an apply process performs two steps:</p>
<ol>
<li>
<p>The <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> <code dir="ltr">AS</code> <code dir="ltr">SELECT</code> statement is executed at the destination database, but it creates only the structure of the table. It does not insert any rows into the table. If the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> <code dir="ltr">AS</code> <code dir="ltr">SELECT</code> statement fails, then an apply process error results. Otherwise, the statement automatically commits, and the apply process performs Step <a href="#i1007380">2</a>.</p>
</li>
<li id="i1007380">
<p>The apply process inserts the rows that were inserted at the source database because of the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> <code dir="ltr">AS</code> <code dir="ltr">SELECT</code> statement into the corresponding table at the destination database. It is possible that a capture process, a propagation, or an apply process will discard all of the row LCRs with these inserts based on their rule sets. In this case, the table remains empty at the destination database.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="strms_rules.htm#g1049257">Chapter 5, &#34;How Rules Are Used in Oracle Streams&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="BABJACHA"></a>
<div id="STRMS1620" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DML Statements within DDL Statements<a id="sthref493"></a></h3>
<p>When an apply process applies a data definition language (DDL) change, Oracle Streams ensures that the data manipulation language (DML) changes on the DDL target within the same transaction are not replicated at the destination database. Therefore, the source database and destination database can diverge in some cases. Divergence can result in apply process errors when the old values in row logical change records (LCRs) do not match the current values in a destination table.</p>
<p>The following cases cause the source database and destination database to diverge:</p>
<ul>
<li>
<p><a href="#BABCBFHJ">The DDL Statement Contains Derived Values</a></p>
</li>
<li>
<p><a href="#BABHBIDG">The DDL Statement Fires DML Triggers</a></p>
</li>
</ul>
<a id="BABCBFHJ"></a>
<div id="STRMS1621" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">The DDL Statement Contains Derived Values<a id="sthref494"></a></h4>
<p>When a DDL statement contains a non-literal value that is derived, the value that is derived might not match at the source database and destination database. For example, the following DDL statement adds a column to the <code dir="ltr">hr.employees</code> table and inserts a date value derived from the computer system running the source database:</p>
<pre dir="ltr">ALTER TABLE hr.employees ADD(start_date DATE DEFAULT SYSDATE);
</pre>
<p>Assume that a replication environment maintains DML and DDL changes made to the <code dir="ltr">hr.employees</code> table between a source database and a destination database. In this case, the <code dir="ltr">SYSDATE</code> function is executed independently at the source database and at the destination database. Therefore, the <code dir="ltr">DATE</code> value inserted at the source database will not match the <code dir="ltr">DATE</code> value inserted at the destination database.</p>
</div>
<!-- class="sect3" -->
<a id="BABHBIDG"></a>
<div id="STRMS1622" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">The DDL Statement Fires DML Triggers<a id="sthref495"></a></h4>
<p>When a DDL statement fires a DML trigger defined on the destination table, the DML changes made by the trigger are not replicated at the destination database. Because the DML changes made by the triggers occur in the same transaction as the DDL statement, and operate on the table that is the target of the DDL statement, the triggered DML changes are not replicated at the destination database.</p>
<p>For example, assume you create the following table:</p>
<pre dir="ltr">CREATE TABLE hr.temp_employees(
   emp_id       NUMBER  PRIMARY KEY,
   first_name   VARCHAR2(64),
   last_name    VARCHAR2(64),
   modify_date  TIMESTAMP);
</pre>
<p>Assume you create a trigger on the table so that whenever the table is updated the <code dir="ltr">modify_date</code> column is updated to reflect the time of change:</p>
<pre dir="ltr">CREATE OR REPLACE TRIGGER hr.trg_mod_dt BEFORE UPDATE ON hr.temp_employees
   REFERENCING
   NEW AS NEW_ROW FOR EACH ROW
BEGIN
   :NEW_ROW.modify_date:= SYSTIMESTAMP;
END;
/
</pre>
<p>Assume that a replication environment maintains DML and DDL changes made to the <code dir="ltr">hr.temp_employees</code> table between a source database and a destination database. In this case, the <code dir="ltr">hr.temp_employees</code> table is maintained correctly at the destination database for direct DML changes made to this table at the source database. However, if an <code dir="ltr">ADD</code> <code dir="ltr">COLUMN</code> statement at the source database adds a column to this table, then the <code dir="ltr">hr.trg_mod_dt</code> update trigger changes the <code dir="ltr">modify_date</code> column of all of the rows in the table to a new timestamp. These changes to the <code dir="ltr">modify_date</code> column are not replicated at the destination database.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009248"></a>
<div id="STRMS212" class="sect1">
<h2 class="sect1">Instantiation SCN and Ignore SCN for an Apply Process<a id="sthref496"></a><a id="sthref497"></a><a id="sthref498"></a><a id="sthref499"></a></h2>
<p>In an Oracle Streams environment that shares information within a single database or between multiple databases, a source database is the database where changes are generated in the redo log. Suppose an environment has the following characteristics:</p>
<ul>
<li>
<p>A capture process or a synchronous capture captures changes to tables at the source database and stages the changes as LCRs in a queue.</p>
</li>
<li>
<p>An apply process applies these LCRs, either at the same database or at a destination database to which the LCRs have been propagated.</p>
</li>
</ul>
<p>In such an environment, for each table, only changes that committed after a specific system change number (SCN) at the source database are applied. An <span class="bold">instantiation SCN</span> specifies this value for each table.</p>
<p>An instantiation SCN can be set during instantiation, or an instantiation SCN can be set using a procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package. If the tables do not exist at the destination database before the Oracle Streams replication environment is configured, then these table are physically created (instantiated) using copies from the source database, and the instantiation SCN is set for each table during instantiation. If the tables already exist at the destination database before the Oracle Streams replication environment is configured, then these table are not instantiated using copies from the source database. Instead, the instantiation SCN must be set manually for each table using one of the following procedures in the <code dir="ltr">DBMS_APPLY_ADM</code> package: <code dir="ltr">SET_TABLE_INSTANTIATION_SCN</code>, <code dir="ltr">SET_SCHEMA_INSTANATIATION_SCN</code>, or <code dir="ltr">SET_GLOBAL_INSTANTIATION_SCN</code>.</p>
<p>The instantiation SCN for a database object controls which LCRs that contain changes to the database object are ignored by an apply process and which LCRs are applied by an apply process. If the commit SCN of an LCR for a database object from a source database is less than or equal to the instantiation SCN for that database object at a destination database, then the apply process at the destination database discards the LCR. Otherwise, the apply process applies the LCR.</p>
<p>Also, if there are multiple source databases for a shared database object at a destination database, then an instantiation SCN must be set for each source database, and the instantiation SCN can be different for each source database. You can set instantiation SCNs by using export/import or transportable tablespaces. You can also set an instantiation SCN by using a procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package.</p>
<p>Oracle Streams also records the <span class="bold">ignore SCN</span> for each database object. The ignore SCN is the SCN below which changes to the database object cannot be applied. The instantiation SCN for an object cannot be set lower than the ignore SCN for the object. This value corresponds to the SCN value at the source database at the time when the object was prepared for instantiation. An ignore SCN is set for a database object only when the database object is instantiated using Oracle Data Pump.</p>
<p>You can view the instantiation SCN and ignore SCN for database objects by querying the <code dir="ltr">DBA_APPLY_INSTANTIATED_OBJECTS</code> data dictionary view.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STREP012" href="../STREP/instant.htm#STREP012"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a></div>
</div>
<!-- class="sect1" -->
<a id="i1009319"></a>
<div id="STRMS213" class="sect1">
<h2 class="sect1">The Oldest SCN for an Apply Process<a id="sthref500"></a><a id="sthref501"></a><a id="sthref502"></a></h2>
<p>If an apply process is running, then the <span class="bold">oldest SCN</span> is the earliest SCN of the transactions currently being dequeued and applied. For a stopped apply process, the oldest SCN is the earliest SCN of the transactions that were being applied when the apply process was stopped.</p>
<p>The following are two common scenarios in which the oldest SCN is important:</p>
<ul>
<li>
<p>You must recover the database in which the apply process is running to a certain point in time.</p>
</li>
<li>
<p>You stop using an existing capture process that captures changes for the apply process and use a different capture process to capture changes for the apply process.</p>
</li>
</ul>
<p>In both cases, you should determine the oldest SCN for the apply process by querying the <a class="olink REFRN23012" href="../REFRN/GUID-617435C9-AF1C-4D70-80A8-73BB502FFC00.htm#REFRN23012"><code dir="ltr">DBA_APPLY_PROGRESS</code></a> data dictionary view. The <code dir="ltr">OLDEST_MESSAGE_NUMBER</code> column in this view contains the oldest SCN. Next, set the start SCN for the capture process that is capturing changes for the apply process to the same value as the oldest SCN value. If the capture process is capturing changes for other apply processes, then these other apply processes might receive duplicate LCRs when you reset the start SCN for the capture process. In this case, the other apply processes automatically discard the duplicate LCRs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The oldest SCN is only valid for apply processes that apply LCRs that were captured by a capture process. The oldest SCN does not pertain to apply processes that apply LCRs captured by synchronous capture or LCRs enqueued explicitly.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#i1006559">&#34;SCN Values Related to a Capture Process&#34;</a></p>
</li>
<li>
<p><a class="olink STREP121" href="../STREP/man_gen_rep.htm#STREP121"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1009376"></a>
<div id="STRMS523" class="sect1">
<h2 class="sect1">Low-Watermark and High-Watermark for an Apply Process<a id="sthref503"></a><a id="sthref504"></a><a id="sthref505"></a><a id="sthref506"></a><a id="sthref507"></a><a id="sthref508"></a><a id="sthref509"></a></h2>
<p>The <span class="bold">low-watermark</span> for an apply process is the system change number (SCN) up to which all LCRs have been applied. That is, LCRs that were committed at an SCN less than or equal to the low-watermark number have definitely been applied, but some LCRs that were committed with a higher SCN also might have been applied. The low-watermark SCN for an apply process is equivalent to the <span class="bold">applied SCN</span> for a capture process.</p>
<p>The <span class="bold">high-watermark</span> for an apply process is the SCN beyond which no LCRs have been applied. That is, no LCRs that were committed with an SCN greater than the high-watermark have been applied.</p>
<p>You can view the low-watermark and high-watermark for one or more apply processes by querying the <a class="olink REFRN30266" href="../REFRN/GUID-8089B39B-D60F-4DF0-99B7-03C64DD0434C.htm#REFRN30266"><code dir="ltr">V$STREAMS_APPLY_COORDINATOR</code></a> and <a class="olink REFRN20012" href="../REFRN/GUID-0ACAB1C6-A2E2-42EC-87DC-B81C0CBAD98E.htm#REFRN20012"><code dir="ltr">ALL_APPLY_PROGRESS</code></a> data dictionary views.</p>
</div>
<!-- class="sect1" -->
<a id="BABEBIII"></a>
<div id="STRMS1623" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Apply Processes and Triggers</h2>
<p>This section describes how Oracle Streams apply processes interact with triggers.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1007390">Trigger Firing Property</a></p>
</li>
<li>
<p><a href="#BABFEEGG">Apply Processes and Triggers Created with the ON SCHEMA Clause</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BABHBIDG">&#34;The DDL Statement Fires DML Triggers&#34;</a></p>
</li>
<li>
<p><a class="olink CNCPT118" href="../CNCPT/srvrside.htm#CNCPT118"><span class="italic">Oracle Database Concepts</span></a></p>
</li>
</ul>
</div>
<a id="i1007390"></a>
<div id="STRMS215" class="sect2">
<h3 class="sect2">Trigger Firing Property<a id="sthref510"></a><a id="sthref511"></a><a id="sthref512"></a><a id="sthref513"></a></h3>
<p>You can control a DML or DDL trigger&#39;s firing property using the <code dir="ltr">SET_TRIGGER_FIRING_PROPERTY</code> procedure in the <code dir="ltr">DBMS_DDL</code> package. This procedure lets you specify whether a trigger always fires, fires once, or fires for apply process changes only.</p>
<p>The <code dir="ltr">SET_TRIGGER_FIRING_PROPERTY</code> procedure is overloaded. Set a trigger&#39;s firing property in one of the following ways:</p>
<ul>
<li>
<p>To specify that a trigger always fires, set the <code dir="ltr">fire_once</code> procedure parameter to <code dir="ltr">FALSE</code>.</p>
</li>
<li>
<p>To specify that a trigger fires once, set the <code dir="ltr">fire_once</code> parameter to <code dir="ltr">TRUE</code>.</p>
</li>
<li>
<p>To specify that a trigger fires for apply process changes only, set the <code dir="ltr">property</code> parameter to <code dir="ltr">DBMS_DDL.APPLY_SERVER_ONLY</code>.</p>
</li>
</ul>
<p>If <code dir="ltr">DBMS_DDL.APPLY_SERVER_ONLY</code> property is set for a trigger, then the trigger only fires for apply process changes, regardless of the setting of the <code dir="ltr">fire_once</code> parameter. That is, setting <code dir="ltr">DBMS_DDL.APPLY_SERVER_ONLY</code> for the <code dir="ltr">property</code> parameter overrides the <code dir="ltr">fire_once</code> parameter setting.</p>
<p>A trigger&#39;s firing property determines whether the trigger fires in each of the following cases:</p>
<ul>
<li>
<p>When a triggering event is executed by a user process</p>
</li>
<li>
<p>When a triggering event is executed by an apply process</p>
</li>
<li>
<p>When a triggering event results from the execution of one or more apply errors using the <code dir="ltr">EXECUTE_ERROR</code> or <code dir="ltr">EXECUTE_ALL_ERRORS</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package</p>
</li>
</ul>
<p><a href="#BABCAHBG">Table 10-2</a> shows when a trigger fires based on its trigger firing property.</p>
<div id="STRMS1624" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref514"></a><a id="BABCAHBG"></a>Table 10-2 Trigger Firing Property</p>
<table class="cellalignment5973" title="Trigger Firing Property" summary="This table lists each trigger firing property and shows whether the trigger fires based on the cause of the triggering event." dir="ltr">
<thead>
<tr class="cellalignment5964">
<th class="cellalignment5974" id="r1c1-t27">Trigger Firing Property</th>
<th class="cellalignment5974" id="r1c2-t27">User Process Causes Triggering Event</th>
<th class="cellalignment5974" id="r1c3-t27">Apply Process Causes Triggering Event</th>
<th class="cellalignment5974" id="r1c4-t27">Apply Error Execution Causes Triggering Event</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5964">
<td class="cellalignment5970" id="r2c1-t27" headers="r1c1-t27">
<p>Always fire</p>
</td>
<td class="cellalignment5970" headers="r2c1-t27 r1c2-t27">
<p>Trigger Fires</p>
</td>
<td class="cellalignment5970" headers="r2c1-t27 r1c3-t27">
<p>Trigger Fires</p>
</td>
<td class="cellalignment5970" headers="r2c1-t27 r1c4-t27">
<p>Trigger Fires</p>
</td>
</tr>
<tr class="cellalignment5964">
<td class="cellalignment5970" id="r3c1-t27" headers="r1c1-t27">
<p>Fire once</p>
</td>
<td class="cellalignment5970" headers="r3c1-t27 r1c2-t27">
<p>Trigger Fires</p>
</td>
<td class="cellalignment5970" headers="r3c1-t27 r1c3-t27">
<p>Trigger Does Not Fire</p>
</td>
<td class="cellalignment5970" headers="r3c1-t27 r1c4-t27">
<p>Trigger Does Not Fire</p>
</td>
</tr>
<tr class="cellalignment5964">
<td class="cellalignment5970" id="r4c1-t27" headers="r1c1-t27">
<p>For for apply process changes only</p>
</td>
<td class="cellalignment5970" headers="r4c1-t27 r1c2-t27">
<p>Trigger Does Not Fire</p>
</td>
<td class="cellalignment5970" headers="r4c1-t27 r1c3-t27">
<p>Trigger Fires</p>
</td>
<td class="cellalignment5970" headers="r4c1-t27 r1c4-t27">
<p>Trigger Fires</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" -->
<p>For example, in the <code dir="ltr">hr</code> schema, the <code dir="ltr">update_job_history</code> trigger adds a row to the <code dir="ltr">job_history</code> table when data is updated in the <code dir="ltr">job_id</code> or <code dir="ltr">department_id</code> column in the <code dir="ltr">employees</code> table. Suppose, in an Oracle Streams environment, the following configuration exists:</p>
<ul>
<li>
<p>A capture process or synchronous capture captures changes to both of these tables at the <code dir="ltr">dbs1.example.com</code> database.</p>
</li>
<li>
<p>A propagation propagates these changes to the <code dir="ltr">dbs2.example.com</code> database.</p>
</li>
<li>
<p>An apply process applies these changes at the <code dir="ltr">dbs2.example.com</code> database.</p>
</li>
<li>
<p>The <code dir="ltr">update_job_history</code> trigger exists in the <code dir="ltr">hr</code> schema in both databases.</p>
</li>
</ul>
<p>If the <code dir="ltr">update_job_history</code> trigger is set to always fire at <code dir="ltr">dbs2.example.com</code> in this scenario, then these actions result:</p>
<ol>
<li>
<p>The <code dir="ltr">job_id</code> column is updated for an employee in the <code dir="ltr">employees</code> table at <code dir="ltr">dbs1.example.com</code>.</p>
</li>
<li>
<p>The <code dir="ltr">update_job_history</code> trigger fires at <code dir="ltr">dbs1.example.com</code> and adds a row to the <code dir="ltr">job_history</code> table that records the change.</p>
</li>
<li>
<p>The capture process or synchronous capture at <code dir="ltr">dbs1.example.com</code> captures the changes to both the <code dir="ltr">employees</code> table and the <code dir="ltr">job_history</code> table.</p>
</li>
<li>
<p>A propagation propagates these changes to the <code dir="ltr">dbs2.example.com</code> database.</p>
</li>
<li>
<p>An apply process at the <code dir="ltr">dbs2.example.com</code> database applies both changes.</p>
</li>
<li>
<p>The <code dir="ltr">update_job_history</code> trigger fires at <code dir="ltr">dbs2.example.com</code> when the apply process updates the <code dir="ltr">employees</code> table.</p>
</li>
</ol>
<p>In this case, the change to the <code dir="ltr">employees</code> table is recorded twice at the <code dir="ltr">dbs2.example.com</code> database: when the apply process applies the change to the <code dir="ltr">job_history</code> table and when the <code dir="ltr">update_job_history</code> trigger fires to record the change made to the <code dir="ltr">employees</code> table by the apply process.</p>
<p>A database administrator might not want the <code dir="ltr">update_job_history</code> trigger to fire at the <code dir="ltr">dbs2.example.com</code> database when a change is made by the apply process. Similarly, a database administrator might not want a trigger to fire because of the execution of an apply error transaction. If the <code dir="ltr">update_job_history</code> trigger&#39;s firing property is set to fire once, then it does not fire at <code dir="ltr">dbs2.example.com</code> when the apply process applies a change to the <code dir="ltr">employees</code> table, and it does not fire when an executed error transaction updates the <code dir="ltr">employees</code> table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Only DML and DDL triggers can be set to fire once. All other types of triggers always fire.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS322" href="../ARPLS/d_ddl.htm#ARPLS322"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about setting a trigger&#39;s firing property with the <code dir="ltr">SET_TRIGGER_FIRING_PROPERTY</code> procedure</div>
</div>
<!-- class="sect2" -->
<a id="BABFEEGG"></a>
<div id="STRMS1625" class="sect2">
<h3 class="sect2">Apply Processes and Triggers Created with the ON SCHEMA Clause</h3>
<p><a id="sthref515"></a><a id="sthref516"></a><a id="sthref517"></a>If you use the <code dir="ltr">ON</code> <code dir="ltr">SCHEMA</code> clause to create a schema trigger, then the schema trigger fires only if the schema performs a relevant change. Therefore, when an apply process is applying changes, a schema trigger that is set to fire always fires only if the apply user is the same as the schema specified in the schema trigger. If the schema trigger is set to fire once, then it never fires when an apply process applies changes, regardless of whether the apply user is the same as the schema specified in the schema trigger.</p>
<p>For example, if you specify a schema trigger that always fires on the <code dir="ltr">hr</code> schema at a source database and destination database, but the apply user at a destination database is <code dir="ltr">strmadmin</code>, then the trigger fires when the <code dir="ltr">hr</code> user performs a relevant change on the source database, but the trigger does not fire when this change is applied at the destination database. However, if you specify a schema trigger that always fires on the <code dir="ltr">strmadmin</code> schema at the destination database, then this trigger fires whenever a relevant change is made by the apply process, regardless of any trigger specifications at the source database.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007130"></a>
<div id="STRMS524" class="sect1">
<h2 class="sect1">Oracle Streams Data Dictionary for an Apply Process<a id="sthref518"></a><a id="sthref519"></a></h2>
<p>When a database object is prepared for <a href="strms_glossary.htm#CHDCCEJE"><span class="xrefglossterm">instantiation</span></a> at a <a href="strms_glossary.htm#CHDHFBJG"><span class="xrefglossterm">source database</span></a>, an Oracle Streams data dictionary is populated automatically at the database where changes to the object are captured by a <a href="strms_glossary.htm#CHDBHECD"><span class="xrefglossterm">capture process</span></a>. The Oracle Streams data dictionary is a multiversioned copy of some of the information in the primary data dictionary at a source database. The Oracle Streams data dictionary maps object numbers, object version information, and internal column numbers from the source database into table names, column names, and column data types. This mapping keeps each <a href="strms_glossary.htm#CHDCHEJI"><span class="xrefglossterm">captured LCR</span></a> as small as possible because a captured LCR can often use numbers rather than names internally.</p>
<p>Unless a captured LCR is passed as a parameter to a <a href="strms_glossary.htm#CHDDGIFE"><span class="xrefglossterm">custom rule-based transformation</span></a> during capture or propagation, the mapping information in the Oracle Streams data dictionary at the source database is needed to interpret the contents of the LCR at any database that applies the captured LCR. To make this mapping information available to an <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a>, Oracle automatically populates a multiversioned Oracle Streams data dictionary at each <a href="strms_glossary.htm#CHDGCAJA"><span class="xrefglossterm">destination database</span></a> that has an Oracle Streams apply process. Oracle automatically propagates relevant information from the Oracle Streams data dictionary at the source database to all other databases that apply captured LCRs from the source database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_adcapture.htm#i1010145">&#34;The Oracle Streams Data Dictionary&#34;</a></p>
</li>
<li>
<p><a href="strms_adprop.htm#i1007091">&#34;Oracle Streams Data Dictionary for Propagations&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="BGBCEHCB"></a>
<div id="STRMS525" class="sect1">
<h2 class="sect1">Multiple Apply Processes in a Single Database</h2>
<p>If you run multiple <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a>es in a single database, consider increasing the size of the System Global Area (SGA). Use the <code dir="ltr">SGA_MAX_SIZE</code> initialization parameter to increase the SGA size. Also, if the size of the <a href="strms_glossary.htm#CHDHGDCA"><span class="xrefglossterm">Oracle Streams pool</span></a> is not managed automatically in the database, then you should increase the size of the Oracle Streams pool by 1 MB for each apply process parallelism. For example, if you have two apply processes running in a database, and the parallelism parameter is set to <code dir="ltr">4</code> for one of them and <code dir="ltr">1</code> for the other, then increase the Oracle Streams pool by 5 MB (4 + 1 = 5 parallelism).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The size of the Oracle Streams pool is managed automatically if the <code dir="ltr">MEMORY_TARGET</code>, <code dir="ltr">MEMORY_MAX_TARGET</code>, or <code dir="ltr">SGA_TARGET</code> initialization parameter is set to a nonzero value.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink STREP202" href="../STREP/prep_rep.htm#STREP202"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a> for information about configuring the Oracle Streams pool</p>
</li>
<li>
<p><a class="olink STREP201" href="../STREP/prep_rep.htm#STREP201"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a> for more information about the <code dir="ltr">STREAMS_POOL_SIZE</code> initialization parameter</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5963">
<tr>
<td class="cellalignment5970">
<table class="cellalignment5968">
<tr>
<td class="cellalignment5967"><a href="strms_adprop.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5967"><a href="strms_adrules.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5972">
<table class="cellalignment5966">
<tr>
<td class="cellalignment5967"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5967"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5967"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5967"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5967"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5967"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>