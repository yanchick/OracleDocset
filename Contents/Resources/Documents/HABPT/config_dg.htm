<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-46431"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Configuring%20Oracle%20Data%20Guard"></a><title>&nbsp;Configuring Oracle Data Guard</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1060"/>
<meta name="dcterms.created" content="2015-07-15T12:40:31Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database High Availability Best Practices"/>
<meta name="dcterms.identifier" content="E40019-02"/>
<meta name="dcterms.isVersionOf" content="HABPT"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2005, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="config_backuprec.htm" title="Previous" type="text/html"/>
<link rel="Next" href="config_gg.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E40019-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/20</span> <!-- End Header -->
<div id="HABPT4876" class="chapter"><a id="CEGEADFC"></a>
<h1 class="chapter"><span class="secnum">8</span> &nbsp;Configuring Oracle Data Guard</h1>
<p><a id="sthref460"></a><a id="sthref461"></a><a id="sthref462"></a>The proper configuration of Oracle Data Guard is essential to ensuring that all standby databases work properly and perform their roles within the necessary service levels after switchovers and failovers.</p>
<p>The best practices for Oracle Data Guard build on the best practices described in <a href="config_db.htm#BGBBDBFJ">Chapter 4, &#34;Configuring Oracle Database.&#34;</a></p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#CEGGAIGI">Oracle Data Guard Configuration Best Practices</a></p>
</li>
<li>
<p><a href="#CEGDJEDB">Determine Protection Mode and Data Guard Transport</a></p>
</li>
<li>
<p><a href="#CEGBIAJI">General Data Guard Configuration Best Practices</a></p>
</li>
<li>
<p><a href="#CHDCJBGB">Oracle Multitenant Databases in a Data Guard Environment</a></p>
</li>
<li>
<p><a href="#CEGFDHAB">Oracle Data Guard Role Transition Best Practices</a></p>
</li>
<li>
<p><a href="#CEGGABBA">Use Oracle Active Data Guard Best Practices</a></p>
</li>
<li>
<p><a href="#CEGJFGCB">Use Snapshot Standby Database Best Practices</a></p>
</li>
<li>
<p><a href="#CEGBCCAB">Assessing Data Guard Performance</a></p>
</li>
</ul>
<a id="CEGGAIGI"></a>
<div id="HABPT5256" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">8.1</span> Oracle Data Guard Configuration Best Practices</h2>
<p>Data Guard is the Oracle optimized solution for Data availability and protection. It excels at simple, fast, and reliable one-way replication of a complete Oracle Database to provide High Availability and Disaster Recovery. Data Guard offers various deployment options that address unplanned outages, pre-production testing, and planned maintenance. Active Data Guard, an extension of basic Data Guard capabilities, further enables production offload of read-only workload to a synchronized physical standby database, automatic repair of corrupt blocks, and offload of fast incremental backups.</p>
<p>The focus of Data Guard is High Availability and Data Recovery. Data Guard design principles are simplicity, high performance, and application transparency.</p>
<p>Data Guard is not intended to be a full-featured replication solution. Oracle GoldenGate is the solution recommended for advanced replication requirements, such as multi-master replication, granular replication of a subset of a database, many to one replication topologies, and data integration. Oracle GoldenGate also provides additional options for reducing downtime for planned maintenance and for heterogeneous platform migrations.</p>
<p>Depending upon your requirements, the most efficient solution to use may be using Data Guard alone, using Data Guard with Oracle GoldenGate in a complementary manner, or just using Oracle GoldenGate.</p>
<p>For more information about Data Guard and Oracle GoldenGate see the Product Technical Brief on Oracle Active Data Guard and Oracle GoldenGate at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/technetwork/middleware/goldengate/overview/index.html">http://www.oracle.com/technetwork/middleware/goldengate/overview/index.html</a></code></p>
<p><a href="#CHDJHHAC">Table 8-1</a> provides a summary of the Data Guard deployment options that are appropriate, depending on your requirements. Two or more options may be used in combination to address multiple requirements. This chapter also presents the Best practices for implementing each option.</p>
<div id="HABPT5281" class="tblruleformalwide">
<p class="titleintable"><a id="sthref463"></a><a id="CHDJHHAC"></a>Table 8-1 Requirements and Data Guard Deployment Options</p>
<table class="cellalignment2589" title="Requirements and Data Guard Deployment Options" summary="Requirements and Data Guard Deployment Options" dir="ltr">
<thead>
<tr class="cellalignment2580">
<th class="cellalignment2590" id="r1c1-t2">Requirement</th>
<th class="cellalignment2590" id="r1c2-t2">Data Guard Deployment Options</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r2c1-t2" headers="r1c1-t2">
<p>Zero data loss protection and availability for Oracle Database</p>
</td>
<td class="cellalignment2586" headers="r2c1-t2 r1c2-t2">
<p>Data Guard Maximum Protection or Maximum Availability (SYNC transport) and Redo Apply (physical standby). Active Data Guard Far Sync.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r3c1-t2" headers="r1c1-t2">
<p>Near-zero data loss (single-digit seconds) and availability for Oracle Database</p>
</td>
<td class="cellalignment2586" headers="r3c1-t2 r1c2-t2">
<p>Data Guard Maximum Performance (ASYNC transport) and Redo Apply</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r4c1-t2" headers="r1c1-t2">
<p>Multi-site protection, including topology with local zero data loss standby for HA and remote asynchronous standby for geographic disaster recovery for Oracle Database</p>
</td>
<td class="cellalignment2586" headers="r4c1-t2 r1c2-t2">
<p>Multi-standby Data Guard configuration and Redo Apply</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r5c1-t2" headers="r1c1-t2">
<p>Fastest possible database failover</p>
</td>
<td class="cellalignment2586" headers="r5c1-t2 r1c2-t2">
<p>Data Guard Fast-Start Failover with Oracle Data Guard broker for automatic failure detection and database failover. Automatic failover of accompanying client applications to the new production database is implemented using Oracle Fast Application Notification (FAN) and Oracle Client Failover Best Practices.</p>
<p>For more information, see the MAA white paper &#34;Client Failover Best Practices for Data Guard 11g Release 2&#34; from the MAA Best Practices area for Oracle Database at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r6c1-t2" headers="r1c1-t2">
<p>Offload read-only queries and fast incremental backups to a synchronized standby database. Use the standby database to automatically repair corrupt blocks, transparent to the application and user</p>
</td>
<td class="cellalignment2586" headers="r6c1-t2 r1c2-t2">
<p>Active Data Guard. Active Data Guard can be purchased in either of the following ways: (1) standalone as an option license for Oracle Database Enterprise Edition, or (2) included with an Oracle GoldenGate license.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r7c1-t2" headers="r1c1-t2">
<p>Pre-production testing</p>
</td>
<td class="cellalignment2586" headers="r7c1-t2 r1c2-t2">
<p>Snapshot Standby. A snapshot standby is a physical standby database that is temporarily open read/write for test and other read/write activity independent of primary database transactions. A snapshot standby is easily converted back into a synchronized standby database when testing is complete. Snapshot Standby is an included feature of Data Guard Redo Apply and is an ideal complement for Oracle Real Application Testing.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r8c1-t2" headers="r1c1-t2">
<p>Planned maintenance: certain platform migrations such as Windows to Linux, data center moves, patching and upgrading system software or Oracle Database</p>
</td>
<td class="cellalignment2586" headers="r8c1-t2 r1c2-t2">
<p>Data Guard switchover, planned role transition, using Redo Apply. Redo Apply and Standby-First Patch Apply for qualifying patches from 11.2.0.1 onward. SQL Apply and Data Guard Database Rolling Upgrades (10.1 onward). Data Guard Transient Logical Standby (Upgrades Made Easy) from 11.1.0.7 onward.</p>
<p>For more information, see the MAA white paper, &#34;Database Rolling Upgrades Made Easy by Using a Data Guard Physical Standby Database&#34;, from the MAA Best Practices area for Oracle Database at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r9c1-t2" headers="r1c1-t2">
<p>Data Protection for data residing outside of the Oracle Database</p>
</td>
<td class="cellalignment2586" headers="r9c1-t2 r1c2-t2">
<p>When practical, move operating system file system data into Oracle Database using Oracle Database File System (DBFS). Data Guard protects DBFS data in the same manner as any other Oracle data.</p>
<p>Data that must remain in operating system files can be protected using Oracle ASM Cluster File System (Oracle ACFS) or storage mirroring, and Data Guard.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblruleformalwide" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Standby-First Patch allows you to apply a patch initially to a physical standby database while the primary database remains at the previous software release (this applies for certain types of patches and does not apply for Oracle patch sets and major release upgrades; use the Data Guard transient logical standby method for patch sets and major releases). Once you are satisfied with the change, then you perform a switchover to the standby database. The fallback is to switchback if required. For more information, see &#34;Oracle Patch Assurance - Data Guard Standby-First Patch Apply&#34; in My Oracle Support Note 1265700.1 at
<p><code dir="ltr"><a href="https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1265700.1">https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1265700.1</a></code></p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink HAOVW120" href="../HAOVW/hafeatures.htm#HAOVW120"><span class="italic">Oracle Database High Availability Overview</span></a> for a description of the high availability solutions and benefits provided by Oracle Data Guard and standby databases</p>
</li>
<li>
<p><a class="olink SBYDB00010" href="../SBYDB/concepts.htm#SBYDB00010"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> provides complete information about Oracle Data Guard</p>
</li>
<li>
<p><a class="olink DGBKR585" href="../DGBKR/dgmgrl.htm#DGBKR585"><span class="italic">Oracle Data Guard Broker</span></a> for information about the DGMGRL command-line interface</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="CEGDJEDB"></a>
<div id="HABPT5282" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">8.2</span> Determine Protection Mode and Data Guard Transport</h2>
<p>Oracle Data Guard Zero Data Loss protection provides both a guarantee of data protection and the simplest recovery. For these reasons a Zero Data Loss protection mode, either Oracle Data Guard Maximum Protection or Maximum Availability, is recommended. While both modes use Oracle Data Guard synchronous redo transport by default, there are differences in the rule-sets used to govern behavior at failover time that must be considered, as described below. Oracle Data Guard synchronous redo transport, however, can impact primary database performance if round-trip network latency between primary and standby databases is too great (latency is a function of distance and how &#39;clean&#39; the network is). If this is the case (testing is easy to do, a database administrator can change protection modes and transport methods dynamically), then use Oracle Data Guard Maximum Performance. Maximum Performance uses Oracle Data Guard asynchronous transport services and does not have any impact on primary database performance regardless of network latency. In an environment with sufficient bandwidth to accommodate redo volume, data loss potential is measured in single-digit seconds when using Maximum Performance.</p>
<p>To determine the appropriate data protection mode for your application, consult <span class="italic">Oracle Data Guard Concepts and Administration</span>.</p>
<p>Best practices for the protection mode:</p>
<ul>
<li>
<p><span class="bold">Maximum Protection mode</span> guarantees that no data loss will occur if the primary database fails, even in the case of multiple failures (for example, the network between the primary and standby fails, and then at a later time, the primary fails). This is enforced by never signaling commit success for a primary database transaction until at least one synchronous Data Guard standby has acknowledged that redo has been hardened to disk. Without such an acknowledgment the primary database will stall and eventually shut down rather than allow unprotected transactions to commit. To maintain availability in cases where the primary database is operational but the standby database is not, the best practice is to always have a minimum of two synchronous standby databases in a Maximum Protection configuration. Primary database availability is not impacted if it receives acknowledgment from at least one synchronous standby database.</p>
</li>
<li>
<p><span class="bold">Maximum Availability mode</span> guarantees that no data loss will occur in cases where the primary database experiences the first failure to impact the configuration. Unlike the previous protection mode, Maximum Availability will wait a maximum of <code dir="ltr">NET_TIMEOUT</code> seconds for an acknowledgment from a standby database, after which it will signal commit success to the application and move to the next transaction. Primary database availability (thus the name of the protection mode) is not impacted by an inability to communicate with the standby (for example, due to standby or network outages). Oracle Data Guard will continue to ping the standby and automatically re-establish connection and resynchronize the standby database when possible, but during the period when primary and standby have diverged there will be data loss should a second failure impact the primary database. For this reason, it is a best practice to monitor protection level (simple to do using Enterprise Manager Grid Control) and quickly resolve any disruption in communication between primary and standby before a second failure can occur.</p>
</li>
<li>
<p><span class="bold">Maximum Performance mode</span> (the default mode) provides the highest level of data protection that is possible without affecting the performance or the availability of the primary database. This is accomplished by allowing a transaction to commit as soon as the redo data needed to recover that transaction is written to the local online redo log at the primary database (the same behavior as if there were no standby database). Oracle Data Guard transmits redo to the standby database directly from the primary log buffer asynchronous to the local online redo log write. There is never any wait for standby acknowledgment. Similar to Maximum Availability, it is a best practice to monitor protection level (simple to do using Enterprise Manager Grid Control) and quickly resolve any disruption in communication between primary and standby before a second failure can occur.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SBYDB02000" href="../SBYDB/protection.htm#SBYDB02000"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for information about Data Guard Protection Modes</div>
<a id="CEGCGCGF"></a>
<div id="HABPT4892" class="sect2">
<h3 class="sect2"><span class="secnum">8.2.1</span> Use Redo Transport Services Best Practices<a id="sthref464"></a><a id="sthref465"></a></h3>
<p>At a high level, the Redo Transport best practices for planning and implementing redo transport services for Oracle Data Guard are as follows:</p>
<ul>
<li>
<p>Use the <code dir="ltr">SYNC</code> redo transport mode for a high degree of synchronization between the primary and standby databases. Use <code dir="ltr">SYNC</code> redo transport for zero data loss protection where performance service levels can tolerate the impact caused by network latency and standby I/O performance.</p>
<ul>
<li>
<p>Use <code dir="ltr">SYNC</code> redo transport mode with the <code dir="ltr">NOAFFIRM</code> attribute (default=AFFIRM) when using Maximum Availability mode. This feature is known as FASTSYNC and helps to minimize the impact of <code dir="ltr">SYNC</code> redo transport by acknowledging the receipt of redo once it has been successfully received and verified within standby memory, but before the redo has been written to the standby redo log. Use <code dir="ltr">LogXptMode=FASTSYNC</code> in Data Guard Broker. Zero data loss protection is still preserved when only the primary database fails.</p>
</li>
</ul>
</li>
<li>
<p>Use the <code dir="ltr">ASYNC</code> redo transport mode for minimal impact on the primary database, but with a lower degree of synchronization. Use <code dir="ltr">ASYNC</code> redo transport when zero data loss protection is not required and sub-second or seconds of potential data loss is acceptable, or when the performance impact caused by network latency makes it impractical to use <code dir="ltr">SYNC</code>.</p>
</li>
<li>
<p>Optimize network throughput following the best practices described in <a href="#CEGFHACC">Section 8.2.2, &#34;Assess Performance with Proposed Network Configuration&#34;</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CEGFHACC"></a>
<div id="HABPT4893" class="sect2">
<h3 class="sect2"><span class="secnum">8.2.2</span> Assess Performance with Proposed Network Configuration</h3>
<p>Oracle recommends that you conduct a performance assessment with your proposed network configuration and current, or anticipated, peak redo rate. The network effect between the primary and standby databases, and the effect on the primary database throughput must be understood. Because the network between the primary and standby databases is essential for the two databases to remain synchronized, the infrastructure must have the following characteristics:</p>
<ul>
<li>
<p>Sufficient bandwidth to accommodate the maximum redo generation rate and any other activity sharing the same network</p>
</li>
<li>
<p>If using the <code dir="ltr">SYNC</code> transport, then minimal latency is necessary to reduce the performance impact on the primary database</p>
<ul>
<li>
<p>Use <code dir="ltr">FASTSYNC</code> or <code dir="ltr">SYNC NOAFFIRM</code> to eliminate the additional latency due to standby I/O.</p>
</li>
</ul>
</li>
<li>
<p>Multiple network paths for network redundancy</p>
</li>
</ul>
<p>In configurations that use a dedicated network connection, the required bandwidth is determined by the maximum redo rate of the primary database and the efficiency of the network. Depending on the data protection mode, there are other recommended practices and performance considerations. Maximum protection mode and <a id="sthref466"></a><a id="sthref467"></a>maximum availability mode require <code dir="ltr">SYNC</code> transport.</p>
<p>The maximum performance protection mode uses <code dir="ltr">ASYNC</code> redo transport. Use <code dir="ltr">ASYNC</code> redo transport when data loss can be tolerated or when the performance impact caused by network latency makes it impractical to use <code dir="ltr">SYNC</code> (use <code dir="ltr">SYNC</code> redo transport for zero data loss protection).</p>
<p>Unlike the <code dir="ltr">ASYNC</code> transport mode, the <code dir="ltr">SYNC</code> transport mode can affect the primary database performance due to the incurred network latency. Distance and network configuration directly influence latency, while high latency can slow the potential transaction throughput and quicken response time. The network configuration, number of repeaters, the overhead of protocol conversions, network congestion, and the number of routers also affect the overall network latency and transaction response time.</p>
</div>
<!-- class="sect2" -->
<div id="HABPT5370" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref468"></a>
<h3 class="sect2"><span class="secnum">8.2.3</span> Active Data Guard Far Sync</h3>
<p><code dir="ltr">SYNC</code> transport over WAN distances or on an underperforming network often has too large an impact on primary database performance to support zero data loss protection. Oracle 12<span class="italic">c</span> Active Data Guard Far Sync provides the ability to perform a zero data loss failover to a remote standby database without requiring a second standby database or complex operation. Far Sync enables this by deploying a Far Sync instance (a lightweight Oracle instance) at a distance that is within an acceptable range of the primary for <code dir="ltr">SYNC</code> transport. A Far Sync instance receives redo from the primary using <code dir="ltr">SYNC</code> transport and forwards the redo to up to 29 remote standby databases using <code dir="ltr">ASYNC</code> transport.</p>
<p>There are few new configuration best practices necessary in addition to those that would apply to any <code dir="ltr">SYNC</code> redo transport destination (see <a href="#CEGFHACC">Section 8.2.2, &#34;Assess Performance with Proposed Network Configuration&#34;</a>). They are:</p>
<ul>
<li>
<p>Standby Redo Logs (SRLs) should be placed on storage with sufficient IOPS (writes per second) capacity to support peak primary database redo rates in addition to any I/O activity using the same shared storage. This is an important consideration. For example:</p>
<ul>
<li>
<p>If the Far Sync instance has lower performing disks than the primary it will not be able to forward redo to remote destinations as fast as it is received, and an archive log gap may form.</p>
</li>
<li>
<p>In the case of redo gap resolution scenarios, due to planned maintenance on the standby or network outages, for example, there will be additional I/O requests for gap resolution on top of peak redo coming in.</p>
</li>
<li>
<p>Lower performing disks at the Far Sync instance will delay acknowledgement to the primary database, increasing the total round-trip time between primary and standby and impacting application response time. This impact can be eliminated by using Fast Sync between the primary and the Far Sync instance.</p>
</li>
</ul>
</li>
<li>
<p>The Far Sync instance should have the same number of redo log groups as the primary plus one for each thread as described in standard MAA Best Practices.</p>
</li>
<li>
<p>The SRLs of an alternate Far Sync instance should be manually cleared prior to use in order to achieve the best return to <code dir="ltr">SYNC</code> transport when the alternate Far Sync is acitvated. For example:</p>
<pre dir="ltr">ALTER DATABASE CLEAR LOGFILE GROUP 4, GROUP 5, GROUP 6, GROUP 7;
</pre></li>
<li>
<p>Performance testing has shown that a small Far Sync instance SGA does not impact performance of the Far Sync instance nor the primary database. The MAA recommendation is to configure the minimum SGA required for Far Sync to function.</p>
<ul>
<li>
<p>In order to achieve the smallest possible SGA, set CPU_COUNT=1 or 2.</p>
</li>
<li>
<p>MAA testing determined that a 300MB SGA (with CPU_COUNT=1) on Linux was sufficient for Far Sync</p>
</li>
</ul>
</li>
<li>
<p>When using RMAN, configure the RMAN archive log deletion policy at the Far Sync instance to <code dir="ltr">SHIPPED TO ALL STANDBY</code> or <code dir="ltr">APPLIED ON ALL STANDBY</code>. Backing up the archive logs at the Far Sync instance is not necessary provided there is a proper backup plan at the primary or standby site.</p>
</li>
<li>
<p>Configure Far Sync instances for both the primary and standby databases to allow for zero data loss protection to be maintained following role transitions. The second Far Sync instance configured in proximity to the standby database will be idle until the standby becomes primary, enabling <code dir="ltr">SYNC</code> redo transport in the reverse direction.</p>
<ul>
<li>
<p>Note that in a Data Guard Broker configuration, a switchover (planned role transition) cannot occur while in Maximum Availability mode unless the protection mode can be enforced from the target standby site. If the standby does not have its own Far Sync instance it will have to be configured to ship <code dir="ltr">ASYNC</code> to the original primary after roles are reversed. This will prevent a switchover from occurring unless the protection mode for the primary database is first dropped from Maximum Availability to Maximum Performance.</p>
</li>
</ul>
</li>
<li>
<p>Fast Sync improved performance between 5% and 12% depending on the network latency between the primary database and Far Sync instance.</p>
</li>
<li>
<p>Multiple Far Sync instances servicing multiple Data Guard configurations can share the same physical server, cluster, or virtual machine.</p>
</li>
</ul>
<div id="HABPT5371" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref469"></a>
<h4 class="sect3"><span class="secnum">8.2.3.1</span> Offloading to Far Sync</h4>
<p>A Far Sync instance also offloads from the primary any overhead of resolving gaps in redo received by the remote standby database (for example, following network or standby database outages) and can conserve WAN bandwidth by performing redo transport compression without impacting primary database performance (Note that redo compression requires that the Advanced Compression Option be licensed).</p>
<p>Redo Transport Encryption can additionally be offloaded to the Far Sync instance. Including Advanced Security Option (ASO) encryption during MAA testing showed no impact to the performance of the primary nor currency of the standby databases.</p>
<p>Oracle recommends using ASO for encryption because it is tested and integrated with Oracle Net and Data Guard. (Note that Oracle Advanced Security Option is a licensed option).</p>
</div>
<!-- class="sect3" -->
<div id="HABPT5372" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref470"></a>
<h4 class="sect3"><span class="secnum">8.2.3.2</span> Far Sync High Availability</h4>
<p>In a Far Sync configuration, high availability or uninterrupted redo shipment can be achieved in multiple ways. In this sense, HA refers to maintaining data protection. An outage of a Far Sync Instance does not affect the availability of the production database. Each approach has special considerations and is described in the sections that follow.</p>
<div id="HABPT5373" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref471"></a>
<h5 class="sect4"><span class="secnum">8.2.3.2.1</span> Far Sync using Oracle Real Application Clusters - Oracle RAC</h5>
<p>The Far Sync instance can be placed on an Oracle RAC cluster. In this configuration only one instance is used at a time while other instances remain available in case of node failure. The characteristics of this approach include:</p>
<ul>
<li>
<p>Lowest data loss potential and brown-out when the active Far Sync instance or node fails.</p>
</li>
<li>
<p>The ability to resume zero data loss protection quickly after Far Sync instance failure.</p>
</li>
<li>
<p>By itself, this solution does not address cluster failure.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="HABPT5374" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref472"></a>
<h5 class="sect4"><span class="secnum">8.2.3.2.2</span> Far Sync HA using Alternate Destinations and Multiple Far Sync instances</h5>
<p>Configuring two separate Far Sync instances on distinct physical machines, each serving as an alternate destination for the other, provides Far Sync high availability in a non-Oracle RAC environment. Each destination defined on the primary database contains the <code dir="ltr">ALTERNATE</code> keyword assigning the other Far Sync instance as the alternate. When the active Far Sync instance enters an error state the alternate destination pointing to the alternate Far Sync instance is enabled automatically. By defining a Far Sync instance as an alternate destination, Maximum Availability protection will be maintained after a briefly dropping to a resynchronization state while the new destination is prepared.</p>
<p>The characteristics of this approach include:</p>
<ul>
<li>
<p>Retains zero data loss coverage after Far Sync transport failures (instance or network outages).</p>
</li>
<li>
<p>Failure testing has shown</p>
<ul>
<li>
<p>During Far Sync instance failures a performance brownout of approximately 3.5 seconds while <code dir="ltr">SYNC</code> redo transport starts (network sync service - NSS).</p>
</li>
<li>
<p>During network failures a short brownout equal to the setting of the destination&#39;s <code dir="ltr">net_timeout</code> parameter was observed.</p>
</li>
</ul>
</li>
<li>
<p>HA for machine outage assuming each Far Sync instance is on separate hardware.</p>
</li>
<li>
<p>HA for site outage assuming Far Sync instances are deployed in separate sites.</p>
</li>
<li>
<p>Higher application brown-out and resynchronization time during Far Sync outages compared with Far Sync with Oracle RAC.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="HABPT5375" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref473"></a>
<h5 class="sect4"><span class="secnum">8.2.3.2.3</span> HA Using the Terminal Standby as an Alternate Destination</h5>
<p>When an alternate Far Sync instance and Far Sync with Oracle RAC are not feasible, it is possible to create an alternate <code dir="ltr">LOG_ARCHIVE_DEST_N</code> pointing directly to the terminal standby (the terminal failover target). To avoid performance impact on the primary, use Data Guard asynchronous redo transport (<code dir="ltr">ASYNC</code>). <code dir="ltr">ASYNC</code> can achieve near-zero data loss protection (sub-seconds to seconds of exposure) but it is unable to provide a zero data loss guarantee. In this configuration the protection level must be dropped to Maximum Performance prior to a switchover (planned event) as the level must be enforceable on the target in order to perform the transition. Changing protection levels and transport methods is a dynamic operation that does not require downtime. The characteristics of this approach include:</p>
<ul>
<li>
<p>No additional hardware or Far Sync instances to manage.</p>
</li>
<li>
<p>Loss of zero data loss coverage during a far sync instance outage. Data protection level drops to <code dir="ltr">UNSYNCHRONIZED</code> with <code dir="ltr">ASYNC</code> transport until the Far Sync instance can resume operation and the standby become fully synchronized.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="HABPT5376" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref474"></a>
<h5 class="sect4"><span class="secnum">8.2.3.2.4</span> Choosing a Far Sync Deployment Topology</h5>
<p>All configurations for Far Sync high availability perform equally with regard to receiving and sending redo. The choice of configuration should be based on application tolerance to the maximum data loss (RPO) and application brownout period of the different failure scenarios.</p>
<ul>
<li>
<p>An Oracle RAC Far Sync alone provides the lowest impact but requires an Oracle RAC license and has no coverage for cluster or site outage.</p>
</li>
<li>
<p>Alternate Far Sync instances provide the ability to place each instance on separate physical database servers and require no additional licensing. This provides another level of protection by deploying the Far Sync instances in different sites. There is, however, slightly increased application brownout and longer resynchronization time while transport transitions from one Far Sync instance to the other.</p>
</li>
<li>
<p>Terminal Standby Alternate configurations require that the application accept that there is no zero data loss protection while the Far Sync instance is not available, but requires no additional hardware to implement.</p>
</li>
</ul>
<p>The most critical applications are well served by a pair of Oracle RAC Far Sync instances configured as alternates for each other and deployed at different locations. This provides the most robust Far Sync HA (instance, node, cluster, and site failure) protection.</p>
<p>Applications where data protection is critical but where cost is an important consideration are best served by deploying a pair of single node Far Sync instances, each as an alternate for the other.</p>
<p>Applications that can tolerate increased data loss potential during a Far Sync instance outage and where low cost is the main consideration are best served by configuring the terminal standby as an alternate location using <code dir="ltr">ASYNC</code> redo transport.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
Oracle MAA white paper &#34;Oracle Active Data Guard Far Sync Zero Data Loss at Any Distance&#34; for details about Far Sync and <code dir="ltr">FASTSYNC</code></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGBIAJI"></a>
<div id="HABPT4884" class="sect1">
<h2 class="sect1"><span class="secnum">8.3</span> General Data Guard Configuration Best Practices</h2>
<p>Use the following configuration best practices for Data Guard:</p>
<ul>
<li>
<p><a href="#CEGFIBDE">Use Oracle Data Guard Broker with Oracle Data Guard</a></p>
</li>
<li>
<p><a href="#CEGEEEIB">Use Recovery Manager to Create Standby Databases</a></p>
</li>
<li>
<p><a href="#CEGDEEAD">Use Flashback Database for Reinstatement After Failover</a></p>
</li>
<li>
<p><a href="#CEGGJBBA">Use FORCE LOGGING Mode</a></p>
</li>
<li>
<p><a href="#CEGCEIBC">Use a Simple, Robust Archiving Strategy and Configuration</a></p>
</li>
<li>
<p><a href="#CEGJHEGH">Use Standby Redo Logs and Configure Size Appropriately</a></p>
</li>
<li>
<p><a href="#CEGHIEIE">Use Data Guard Transport and Network Configuration Best Practices</a></p>
</li>
<li>
<p><a href="#CEGHEFAI">Use Data Guard Redo Apply Best Practices</a></p>
</li>
<li>
<p><a href="#CEGEAFIB">Implement Multiple Standby Databases</a></p>
</li>
</ul>
<a id="CEGFIBDE"></a>
<div id="HABPT4888" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.1</span> Use <a id="sthref475"></a><a id="sthref476"></a>Oracle Data Guard Broker with Oracle Data Guard</h3>
<p>Use Oracle Data Guard broker to create, manage, and monitor a Data Guard configuration. You can perform all Data Guard management operations locally or remotely through the Oracle Data Guard broker&#39;s easy-to-use interfaces: the Data Guard management pages in Oracle Enterprise Manager, which is the broker&#39;s graphical user interface (GUI), and the Data Guard command-line interface called DGMGRL.</p>
<p>The broker&#39;s interfaces improve usability and centralize management and monitoring of the Data Guard configuration. Available as a feature of the Enterprise Edition and Personal Edition of the Oracle database, the broker is also integrated with the Oracle database and Oracle Enterprise Manager.</p>
<p>The benefits of using Oracle Data Guard broker include:</p>
<ul>
<li>
<p>Enhanced disaster protection.</p>
</li>
<li>
<p>Higher availability and scalability with Oracle Real Application Clusters (Oracle RAC) Databases.</p>
</li>
<li>
<p>Automated creation of a Data Guard configuration.</p>
</li>
<li>
<p>Easy configuration of additional standby databases.</p>
</li>
<li>
<p>Simplified, centralized, and extended management.</p>
</li>
<li>
<p>Simplified switchover and failover operations.</p>
</li>
<li>
<p>Fast Application Notification (FAN) after failovers<a id="sthref477"></a><a id="sthref478"></a><a id="sthref479"></a><a id="sthref480"></a><a id="sthref481"></a>.</p>
</li>
<li>
<p>Built-in monitoring and alert and control mechanisms.</p>
</li>
<li>
<p>Robust verification of Data Guard configuration using validate database command.</p>
</li>
<li>
<p>Transparent to application.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DGBKR020" href="../DGBKR/concepts.htm#DGBKR020"><span class="italic">Oracle Data Guard Broker</span></a> for more information about the benefits of using Data Guard Broker</div>
</div>
<!-- class="sect2" -->
<a id="CEGEEEIB"></a>
<div id="HABPT4885" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.2</span> Use Recovery Manager to Create Standby Databases<a id="sthref482"></a><a id="sthref483"></a></h3>
<p>Oracle recommends that you use the Recovery Manager (RMAN) utility to simplify the process of creating a physical standby database.</p>
<p>You can either create a standby database from backups of your primary database, or create a standby database over the network:</p>
<ul>
<li>
<p>Use the <a id="sthref484"></a>RMAN <code dir="ltr">DUPLICATE TARGET DATABASE FOR STANDBY</code> command to create a standby database from backups of your primary database.</p>
<p>You can use any backup copy of the primary database to create the physical standby database if the necessary archived redo log files to completely recover the database are accessible by the server session on the standby host. RMAN restores the most recent data files unless you execute the <code dir="ltr">SET UNTIL</code> command.</p>
</li>
<li>
<p>Use the <a id="sthref485"></a>RMAN <code dir="ltr">FROM ACTIVE DATABASE</code> option to create the standby database over the network if a preexisting database backup is not accessible to the standby system.</p>
<p>RMAN copies the data files directly from the primary database to the standby database. The primary database must be mounted or open.</p>
</li>
</ul>
<p>You must choose between active and backup-based duplication. If you do not specify the <code dir="ltr">FROM ACTIVE DATABASE</code> option, then RMAN performs backup-based duplication. Creating a standby database over the network is advantageous because:</p>
<ul>
<li>
<p>You can transfer redo data directly to the remote host over the network without first having to go through the steps of performing a backup on the primary database. (Restoration requires multiple steps including storing the backup locally on the primary database, transferring the backup over the network, storing the backup locally on the standby database, and then restoring the backup on the standby database.)</p>
</li>
<li>
<p>With active duplication you can backup a database (as it is running) from Oracle ASM, and restore the backup to a host over the network and place the files directly into Oracle ASM.</p>
<p>Before this feature, restoration required you to backup the primary and copy the backup files on the primary host file system, transfer the backup files over the network, place the backup files on the standby host file system, and then restore the files into Oracle ASM.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SBYDB04700" href="../SBYDB/rman.htm#SBYDB04700"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for information about using RMAN to Back Up and Restore Files</p>
</li>
<li>
<p><a class="olink SBYDB01500" href="../SBYDB/rcmbackp.htm#SBYDB01500"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for information about Creating a Standby Database with Recovery Manager</p>
</li>
<li>
<p><a class="olink BRADV010" href="../BRADV/rcmdupdb.htm#BRADV010"><span class="italic">Oracle Database Backup and Recovery User&#39;s Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CEGDEEAD"></a>
<div id="HABPT4886" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.3</span> Use Flashback Database for Reinstatement After Failove<a id="sthref486"></a>r</h3>
<p>Enable Flashback Database on both the primary and standby database so that, in case the original primary database has not been damaged, you can reinstate the original primary database as a new standby database following a failover. If there is a failure during the switchover process, then it can easily be reversed when Flashback Database is enabled. For more information, see <a href="config_db.htm#BGBFJGCI">Section 4.1.4, &#34;Enable Flashback Database&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CEGGJBBA"></a>
<div id="HABPT4887" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.4</span> Use FORCE LOGGING Mode</h3>
<p>When the primary database is in <code dir="ltr"><a id="sthref487"></a>FORCE LOGGING</code> mode, all database data changes are logged. <code dir="ltr">FORCE LOGGING</code> mode ensures that the standby database remains consistent with the primary database. If this is not possible because you require the load performance with <code dir="ltr">NOLOGGING</code> operations, then you must ensure that the corresponding physical standby data files are subsequently synchronized. To synchronize the physical standby data files, either apply an incremental backup created from the primary database or replace the affected standby data files with a backup of the primary data files taken after the nologging operation. Before the file transfer, you must stop Redo Apply on the physical standby database.</p>
<p>You can enable force logging immediately by issuing an <code dir="ltr">ALTER DATABASE FORCE LOGGING</code> statement. If you specify <code dir="ltr">FORCE LOGGING</code>, then Oracle waits for all ongoing unlogged operations to finish.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN11096" href="../ADMIN/create.htm#ADMIN11096"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for information about Specifying FORCE LOGGING Mode</p>
</li>
<li>
<p><a class="olink SBYDB4719" href="../SBYDB/create_ps.htm#SBYDB4719"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for information about Enable Forced Logging</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CEGCEIBC"></a>
<div id="HABPT4889" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.5</span> Use a Simple, Robust Archiving Strategy and Configuration<a id="sthref488"></a></h3>
<p>This <a id="sthref489"></a>archiving strategy is based on the following assumptions:</p>
<ul>
<li>
<p>Each database uses a fast recovery area.</p>
</li>
<li>
<p>The primary database instances archive remotely to only one apply instance.</p>
</li>
</ul>
<p><a href="#CEGBEBCD">Table 8-2</a> describes the recommendations for a robust archiving strategy when managing a Data Guard configuration through SQL*Plus. All of the following items are handled automatically when Oracle Data Guard broker is managing a configuration.</p>
<div id="HABPT4890" class="tblruleformalwide">
<p class="titleintable"><a id="sthref490"></a><a id="CEGBEBCD"></a>Table 8-2 Archiving Recommendations</p>
<table class="cellalignment2589" title="Archiving Recommendations " summary="This table contains descriptions of recommendations for archiving strategy." dir="ltr">
<thead>
<tr class="cellalignment2580">
<th class="cellalignment2590" id="r1c1-t10">Recommendation</th>
<th class="cellalignment2590" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r2c1-t10" headers="r1c1-t10">
<p>Start archiving on the primary and standby databases</p>
</td>
<td class="cellalignment2586" headers="r2c1-t10 r1c2-t10">
<p>Maintaining a standby database requires that you enable and start archiving on the primary database, as follows:</p>
<pre dir="ltr">SQL&gt; SHUTDOWN IMMEDIATE
SQL&gt; STARTUP MOUNT;
SQL&gt; ALTER DATABASE ARCHIVELOG;
SQL&gt; ALTER DATABASE OPEN;
</pre>
<p>Archiving must also be enabled on the standby database to support role transitions. To enable archiving on the standby database:</p>
<pre dir="ltr">SQL&gt; SHUTDOWN IMMEDIATE;
SQL&gt; STARTUP MOUNT;
SQL&gt; ALTER DATABASE ARCHIVELOG;
</pre></td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r3c1-t10" headers="r1c1-t10">
<p>Use a consistent log format (<code dir="ltr">LOG_ARCHIVE_FORMAT</code>).</p>
</td>
<td class="cellalignment2586" headers="r3c1-t10 r1c2-t10">
<p>The <code dir="ltr">LOG_ARCHIVE_FORMAT</code> parameter should specify the thread, sequence, and resetlogs ID attributes, and the parameter settings should be consistent across all instances. For example: <code dir="ltr"><a id="sthref491"></a>LOG_ARCHIVE_FORMAT=arch_%t_%S_%r.arc</code></p>
<p><span class="bold">Note:</span> If the fast recovery area is used, then this format is ignored.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r4c1-t10" headers="r1c1-t10">
<p>Perform remote archiving to only one standby instance and node for each Oracle RAC standby database.</p>
</td>
<td class="cellalignment2586" headers="r4c1-t10 r1c2-t10">
<p>All primary database<a id="sthref492"></a> instances archive to one standby destination, using the same net service name. Oracle Net Services connect-time failover is used to automatically switch to the &#34;secondary&#34; standby host when the &#34;primary&#34; standby instance has an outage.</p>
<p>If the archives are accessible from all nodes because Oracle ASM or some other shared file system is being used for the fast recovery area, then remote archiving can be spread across the different nodes of an Oracle RAC standby database.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r5c1-t10" headers="r1c1-t10">
<p>Specify role-based destinations with the <code dir="ltr">VALID_FOR</code> attribute</p>
</td>
<td class="cellalignment2586" headers="r5c1-t10 r1c2-t10">
<p>The <code dir="ltr"><a id="sthref493"></a><a id="sthref494"></a>VALID_FOR</code> attribute enables you to configure destination attributes for both the primary and the standby database roles in one <a id="sthref495"></a>server parameter file (SPFILE), so that the Data Guard configuration operates properly after a role transition. This simplifies switchovers and failovers by removing the need to enable and disable the role-specific parameter files after a role transition.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblruleformalwide" -->
<p>The following example illustrates the recommended <a id="sthref496"></a>initialization parameters for a primary database communicating to a physical standby database. There are two instances, <code dir="ltr">SALES1</code> and <code dir="ltr">SALES2</code>, running in <a id="sthref497"></a><a id="sthref498"></a><a id="sthref499"></a>maximum protection mode.</p>
<pre dir="ltr">*.DB_RECOVERY_FILE_DEST=+RECO
*.LOG_ARCHIVE_DEST_1=&#39;SERVICE=SALES_stby SYNC AFFIRM NET_TIMEOUT=30
    REOPEN=300 VALID_FOR=(ONLINE_LOGFILES, ALL_ROLES) DB_UNIQUE_NAME=SALES_stby&#39;
*.LOG_ARCHIVE_DEST_STATE_1=ENABLE
</pre>
<p>The fast recovery area must be accessible to any node within the cluster and use a shared file system technology such as automatic storage management (Oracle ASM), a cluster file system, a global file system, or high availability network file system (HA NFS). You can also mount the file system manually to any node within the cluster very quickly. This is necessary for recovery because all archived redo log files must be accessible on all nodes.</p>
<p>On the standby database nodes, recovery from a different node is required when a failure occurs on the node applying redo and the apply service cannot be restarted. In that case, any of the existing standby instances residing on a different node can initiate managed recovery. In the worst case, when the standby archived redo log files are inaccessible, the managed recovery process (MRP) on the different node fetches the archived redo log files using the FAL server to retrieve from the primary node directly.</p>
<p>When configuring hardware vendor shared file system technology, verify the performance and availability implications. Investigate the following issues before adopting this strategy:</p>
<ul>
<li>
<p>Is the shared file system accessible by any node regardless of the number of node failures?</p>
</li>
<li>
<p>What is the performance impact when implementing a shared file system?</p>
</li>
<li>
<p>Is there any effect on the interconnect traffic?</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CEGJHEGH"></a>
<div id="HABPT4891" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.6</span> Use Standby Redo Logs and Configure Size Appropriately</h3>
<p>You should configure <a id="sthref500"></a><a id="sthref501"></a>standby redo logs on all primary and standby databases for improved availability and performance.</p>
<p>For each redo log thread (a thread is associated with an OracleRAC database instance), number of Standby Redo Logs = number of Redo Log Groups + 1</p>
<p>The additional standby redo log eliminates the possibility of a standby database waiting on standby redo log. For example, if a primary database has two instances (threads) and each thread has three online log groups, then you should pre-configure 8 standby redo logs on the primary database and each standby database. Furthermore, if the primary or standby databases are not a symmetrical Real Application Cluster (example 8-node primary Oracle RAC cluster compared to 2-node standby Oracle RAC cluster), then the primary and standby databases should still have an equal number of standby redo logs and all threads should be represented.</p>
<p>The statements in <a href="#CEGIIBFG">Example 8-1</a> create three standby logs per thread.</p>
<div id="HABPT5351" class="example">
<p class="titleinexample"><a id="CEGIIBFG"></a>Example 8-1 Create Standby Log Members</p>
<pre dir="ltr">SQL&gt; ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 SIZE 1G;SQL&gt; ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 SIZE 1G;SQL&gt; ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 SIZE 1G;SQL&gt; ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 SIZE 1G;SQL&gt; ALTER DATABASE ADD STANDBY LOGFILE THREAD 2 SIZE 1G;SQL&gt; ALTER DATABASE ADD STANDBY LOGFILE THREAD 2 SIZE 1G;SQL&gt; ALTER DATABASE ADD STANDBY LOGFILE THREAD 2 SIZE 1G;SQL&gt; ALTER DATABASE ADD STANDBY LOGFILE THREAD 2 SIZE 1G;
</pre></div>
<!-- class="example" -->
<p>Consider the following additional guidelines when creating standby redo logs:</p>
<ul>
<li>
<p>Create the same number of standby redo logs on both the primary and standby databases.</p>
</li>
<li>
<p>Create all online redo logs and standby redo logs for both primary and standby databases so that they are the same size.</p>
</li>
<li>
<p>Create standby redo logs in the first available ASM high redundancy disk group, or ensure that the logs are protected using external storage redundancy.</p>
</li>
<li>
<p>In an Oracle RAC environment, create standby redo logs on a shared disk.</p>
</li>
<li>
<p>In an Oracle RAC environment, assign a thread when the standby redo log is created as described in <a href="#CEGIIBFG">Example 8-1</a>.</p>
</li>
<li>
<p>Do not multiplex the standby redo logs.</p>
</li>
</ul>
<p>To check the number and group numbers of the redo logs, query the <code dir="ltr">V$LOG</code> view:</p>
<pre dir="ltr">SQL&gt; SELECT * FROM V$LOG;
</pre>
<p>To check the results of the <code dir="ltr">ALTER DATABASE ADD STANDBY LOGFILE THREAD</code> statements, query the <code dir="ltr">V$STANDBY_LOG</code> view:</p>
<pre dir="ltr">SQL&gt; SELECT * FROM V$STANDBY_LOG;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SBYDB4752" href="../SBYDB/log_transport.htm#SBYDB4752"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for information about managing standby redo logs</div>
</div>
<!-- class="sect2" -->
<a id="CEGHIEIE"></a>
<div id="HABPT5284" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">8.3.7</span> Use Data Guard Transport and Network Configuration Best Practices</h3>
<p>The best practices for Data Guard transport and network configuration include:</p>
<ul>
<li>
<p><a href="#CEGJIGDF">Set the LOG_ARCHIVE_MAX_PROCESSES Parameter</a></p>
</li>
<li>
<p><a href="#CEGHCABI">Set the Network Configuration and Highest Network Redo Rates</a></p>
</li>
</ul>
<a id="CEGJIGDF"></a>
<div id="HABPT4897" class="sect3">
<h4 class="sect3"><span class="secnum">8.3.7.1</span> Set the LOG_ARCHIVE_MAX_PROCESSES Parameter</h4>
<p><a id="sthref502"></a><a id="sthref503"></a><a id="sthref504"></a><a id="sthref505"></a>In most cases the default for <code dir="ltr">LOG_ARCHIVE_MAX_PROCESSES</code> is sufficient. However, in a Data Guard configurations that have multiple standby databases it may be necessary to increase the number of archive processes. The value of the <code dir="ltr">LOG_ARCHIVE_MAX_PROCESSES</code> initialization parameter must be at least one greater than the total number of all remote destinations. Use the following equation when setting the <code dir="ltr">LOG_ARCHIVE_MAX_PROCESSES</code> parameter for highly available environments:</p>
<pre dir="ltr">LOG_ARCHIVE_MAX_PROCESSES = sum(<span class="italic">remote_destinations</span>) + count(<span class="italic">threads</span>)
</pre>
<p>You can adjust these parameter settings after evaluating and testing the initial settings in your production environment.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN11337" href="../ADMIN/archredo.htm#ADMIN11337"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information about Adjusting the Number of Archiver Processes</div>
</div>
<!-- class="sect3" -->
<a id="CEGHCABI"></a>
<div id="HABPT4898" class="sect3">
<h4 class="sect3"><span class="secnum">8.3.7.2</span> Set the Network Configuration and Highest Network Redo Rates</h4>
<p>To set the network configuration and highest network redo rates:</p>
<ul>
<li>
<p><a href="#CEGHFJJI">Properly Configure TCP Send / Receive Buffer Sizes</a></p>
</li>
<li>
<p><a href="#CEGGCHIH">Increase SDU Size</a></p>
</li>
<li>
<p><a href="#CEGBBICB">Set TCP.NODELAY to YES</a></p>
</li>
<li>
<p><a href="#CEGEBCGG">Determine When to Use Redo Transport Compression</a></p>
</li>
</ul>
<p class="subhead2"><a id="CEGHFJJI"></a><a id="HABPT5325"></a>Properly Configure TCP Send / Receive Buffer Sizes</p>
<p>To achieve high network throughput, especially for a high-latency, high-bandwidth network, the minimum recommended setting for the sizes of the TCP send and receive socket buffers is the bandwidth-delay product (BDP) of the network link between the primary and standby systems. Settings higher than the BDP may show incremental improvement. For example, in the MAA Linux test lab, simulated high-latency, high-bandwidth networks realized small, incremental increases in throughput when using TCP send and receive socket buffer settings up to three times the BDP.</p>
<p>BDP is product of the network bandwidth and latency. Socket buffer sizes are set using the Oracle Net parameters <code dir="ltr"><a id="sthref506"></a><a id="sthref507"></a>RECV_BUF_SIZE</code> and <code dir="ltr"><a id="sthref508"></a><a id="sthref509"></a>SEND_BUF_SIZE</code>, so that the socket buffer size setting affects only Oracle TCP connections. The operating system may impose limits on the socket buffer size that must be adjusted so Oracle can use larger values. For example, on Linux, the parameters <code dir="ltr">net.core.rmem_max</code> and <code dir="ltr">net.core.wmem_max</code> limit the socket buffer size and must be set larger than <code dir="ltr">RECV_BUF_SIZE</code> and <code dir="ltr">SEND_BUF_SIZE</code>.</p>
<p>Set the send and receive buffer sizes at either the value you calculated or 10 MB (10,485,760 bytes), whichever is larger. For example, if bandwidth is 622 Mbits and latency is 30 ms, then you would calculate the minimum size for the <code dir="ltr">RECV_BUF_SIZE</code> and <code dir="ltr">SEND_BUF_SIZE</code> parameters as follows: <span class="equationvariables">622,000,000 / 8 x 0.030 = 2,332,500 bytes</span>. Then, multiply the BDP <span class="equationvariables">2,332,500 x 3</span> for a total of <span class="equationvariables">6,997,500</span>.</p>
<p>In this example, you would set the initialization parameters as follows:</p>
<p><code dir="ltr">RECV_BUF_SIZE=10485760</code></p>
<p><code dir="ltr">SEND_BUF_SIZE=10485760</code></p>
<p class="subhead2"><a id="CEGGCHIH"></a><a id="HABPT5326"></a>Increase SDU Size</p>
<p>With Oracle Net Services it is possible to control data transfer by adjusting the size of the Oracle Net setting for the session data unit (SDU). Oracle internal testing has shown that setting the SDU to its maximum value of 65535 can improve performance for the SYNC transport. You can set SDU on a per connection basis using the SDU parameter in the local naming configuration file (<code dir="ltr">TNSNAMES.ORA</code>) and the listener configuration file (<code dir="ltr">LISTENER.ORA</code>), or you can set the SDU for all Oracle Net connections with the profile parameter <code dir="ltr"><a id="sthref510"></a><a id="sthref511"></a>DEFAULT_SDU_SIZE</code> in the <code dir="ltr">SQLNET.ORA</code> file.</p>
<p>Note that the <code dir="ltr">ASYNC</code> transport uses the new streaming protocol and increasing the SDU size from the default has no performance benefit.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NETRF" href="../NETRF/toc.htm"><span class="italic">Oracle Database Net Services Reference</span></a> for more information about the <a class="olink NETRF275" href="../NETRF/tnsnames.htm#NETRF275"><code dir="ltr">SDU</code></a> and <a class="olink NETRF006" href="../NETRF/sqlnet.htm#NETRF006"><code dir="ltr">DEFAULT_SDU_SIZE</code></a> parameters</div>
<p class="subhead2"><a id="CEGBBICB"></a><a id="HABPT5327"></a>Set TCP.NODELAY to YES</p>
<p><a id="sthref512"></a><a id="sthref513"></a><a id="sthref514"></a>To preempt delays in buffer flushing in the TCP protocol stack, disable the TCP Nagle algorithm by setting <code dir="ltr">TCP.NODELAY</code> to <code dir="ltr">YES</code> in the <code dir="ltr">SQLNET.ORA</code> file on both the primary and standby systems.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NETRF239" href="../NETRF/sqlnet.htm#NETRF239"><span class="italic">Oracle Database Net Services Reference</span></a> for more information about the <code dir="ltr">TCP.NODELAY</code> parameter</div>
<p class="subhead2"><a id="CEGEBCGG"></a><a id="HABPT5328"></a>Determine When to Use Redo Transport Compression</p>
<p><a id="sthref515"></a><a id="sthref516"></a><a id="sthref517"></a><a id="sthref518"></a>In Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2) redo transport compression is no longer limited to compressing redo data only when a redo gap is being resolved. When compression is enabled for a destination, all redo data sent to that destination is compressed.</p>
<p>In general, compression is most beneficial when used over low bandwidth networks. As the network bandwidth increases, the benefit is reduced. Compressing redo in a Data Guard environment is beneficial if:</p>
<ul>
<li>
<p>Sufficient CPU resources are available for the compression processing.</p>
</li>
<li>
<p>The database redo rate is being throttled by a low bandwidth network.</p>
</li>
</ul>
<p>Before enabling compression, assess the available CPU resources and decide if enabling compression is feasible. For complete information about enabling compression, see &#34;Redo Transport Compression in a Data Guard Environment&#34; in My Oracle Support Note 729551.1 at</p>
<p><code dir="ltr"><a href="https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=729551.1">https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=729551.1</a></code></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CEGHEFAI"></a>
<div id="HABPT4904" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.8</span> Use Data Guard Redo Apply Best Practices<a id="sthref519"></a><a id="sthref520"></a></h3>
<p>To improve the Redo Apply rate of a physical standby database (and media recovery):</p>
<ul>
<li>
<p><a href="#CEGEBHFD">Maximize I/O Rates on Standby Redo Logs and Archived Redo Logs</a></p>
</li>
<li>
<p><a href="#CEGFJIEF">Assess Recovery Rate</a></p>
</li>
<li>
<p><a href="#CEGHFHDB">Set <code dir="ltr">DB_BLOCK_CHECKSUM</code>=<code dir="ltr">FULL</code> and <code dir="ltr">DB_BLOCK_CHECKING=MEDIUM</code> or <code dir="ltr">FULL</code></a></p>
</li>
<li>
<p><a href="#CEGIEFEI">Set DB_CACHE_SIZE to a Value Greater than on the Primary Database</a></p>
</li>
<li>
<p><a href="#CEGCIFGC">Assess Database Wait Events</a></p>
</li>
<li>
<p><a href="#CEGFHJEI">Tune I/O Operations</a></p>
</li>
<li>
<p><a href="#CEGCAAEH">Assess System Resources</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p>The MAA white paper &#34;Active Data Guard 11g Best Practices (includes best practices for Redo Apply)&#34; from the MAA Best Practices area for Oracle Database at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</div>
<a id="CEGEBHFD"></a>
<div id="HABPT5329" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">8.3.8.1</span> Maximize I/O Rates on Standby Redo Logs and Archived Redo Logs</h4>
<p>Measure read I/O rates on the standby redo logs and archived redo log directories. Concurrent writing of shipped redo on a standby database might reduce the redo read rate due to I/O saturation. The overall recovery rate is always bounded by the rate at which redo can be read; so ensure that the redo read rate surpasses your required recovery rate.</p>
</div>
<!-- class="sect3" -->
<a id="CEGFJIEF"></a>
<div id="HABPT5330" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">8.3.8.2</span> Assess Recovery Rate</h4>
<p>To obtain the history of recovery rates, use the following query to get a history of recovery progress:</p>
<pre dir="ltr">SELECT * FROM V$RECOVERY_PROGRESS;
</pre>
<p>If your <code dir="ltr">ACTIVE</code> <code dir="ltr">APPLY</code> <code dir="ltr">RATE</code> is greater than the maximum redo generation rate at the primary database or twice the average generation rate at the primary database, then no tuning is required; otherwise follow the tuning tips below. The redo generation rate for the primary database can be monitored from Enterprise Manager or extracted from AWR reports under statistic <code dir="ltr">REDO</code> <code dir="ltr">SIZE</code>. If <code dir="ltr">CHECKPOINT</code> <code dir="ltr">TIME</code> <code dir="ltr">PER</code> <code dir="ltr">LOG</code> is greater than ten seconds, then investigate tuning I/O and checkpoints.</p>
</div>
<!-- class="sect3" -->
<a id="CEGHFHDB"></a>
<div id="HABPT5331" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">8.3.8.3</span> Set <code dir="ltr"><a id="sthref521"></a>DB_BLOCK_CHECKSUM</code>=<code dir="ltr">FULL</code> and <code dir="ltr"><a id="sthref522"></a>DB_BLOCK_CHECKING=MEDIUM</code> or <code dir="ltr">FULL</code></h4>
<p>Redo apply performance should be fast enough to keep up with most applications&#39; redo generation rates but you can temporarily disable <code dir="ltr">DB_BLOCK_CHECKING</code> to speed up recovery. If you disable <code dir="ltr">DB_BLOCK_CHECKING</code>, you will disable in-memory block semantic checks as described in My Oracle Support <a href="https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1302539.1">note 1302539.1</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To check for block corruption that was not preventable through the <code dir="ltr">DB_BLOCK_CHECKING</code> parameter, use:
<ul>
<li>
<p><a id="sthref523"></a><a id="sthref524"></a>RMAN <code dir="ltr">BACKUP</code> command with the <code dir="ltr">VALIDATE</code> option</p>
</li>
<li>
<p><a id="sthref525"></a><code dir="ltr">DBVERIFY</code> utility</p>
</li>
<li>
<p><a id="sthref526"></a><code dir="ltr">ANALYZE</code> <code dir="ltr">TABLE</code> <code dir="ltr"><span class="codeinlineitalic">tablename</span></code> <code dir="ltr">VALIDATE</code> <code dir="ltr">STRUCTURE</code> <code dir="ltr">CASCADE</code> SQL statement</p>
</li>
</ul>
</div>
<p>Set the <a id="sthref527"></a><code dir="ltr">DB_LOST_WRITE_PROTECT</code> parameter to <code dir="ltr">FULL</code> on the standby database to enable Oracle to detect writes that are lost in the I/O subsystem. The impact on redo apply is very small for OLTP applications and generally less than 5 percent.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="config_db.htm#BGBGIJBD">Section 4.1.6.1, &#34;Preventing Widespread Data Corruption&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="CEGIEFEI"></a>
<div id="HABPT5332" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">8.3.8.4</span> Set DB_CACHE_SIZE to a Value Greater than on the Primary Database</h4>
<p>Set <code dir="ltr">DB_CACHE_SIZE</code><a id="sthref528"></a> to a value greater than that for the primary database. Set <code dir="ltr"><a id="sthref529"></a>DB_KEEP_CACHE_SIZE</code> and <code dir="ltr"><a id="sthref530"></a>DB_RECYCLE_CACHE_SIZE</code> to <code dir="ltr">0</code>.</p>
<p>Having a large database cache size can improve media recovery performance by reducing the amount of physical data block reads. Because media recovery does not require <code dir="ltr">DB_KEEP_CACHE_SIZE</code> and <code dir="ltr">DB_RECYCLE_CACHE_SIZE</code> or require a large <code dir="ltr">SHARED_POOL_SIZE</code>, the memory can be reallocated to the <code dir="ltr">DB_CACHE_SIZE</code>.</p>
<p>Before converting the standby database into a primary database, reset these parameters to the primary database settings.</p>
</div>
<!-- class="sect3" -->
<a id="CEGCIFGC"></a>
<div id="HABPT5333" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">8.3.8.5</span> Assess Database Wait Events</h4>
<p>With the <a id="sthref531"></a><a id="sthref532"></a><a id="sthref533"></a>Active Data Guard option and real-time query, you can use Statspack from the primary database to collect data from a standby database that is opened read-only and performing recovery. Any tuning or troubleshooting exercise should start with collecting Standby Statspack reports. For complete details about installing and using Standby Statspack, see &#34;Installing and Using Standby Statspack in 11g&#34; in My Oracle Support Note 454848.1 at</p>
<p><code dir="ltr"><a href="https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=454848.1">https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=454848.1</a></code></p>
<p>If you do not have a license for the Active Data Guard option, you can determine the top system and session wait events by querying the standby database&#39;s <code dir="ltr"><a id="sthref534"></a>V$SYSTEM_EVENT</code>, <code dir="ltr"><a id="sthref535"></a>V$SESSION_WAIT</code>, and <code dir="ltr"><a id="sthref536"></a>V$EVENT_HISTOGRAM</code> and looking for the largest <code dir="ltr">TIME_WAITED</code> value. You may have to capture multiple snapshots of the query results and manually extract the difference to accurately assess a certain time period.</p>
<p>If recovery is applying a lot of redo data efficiently, the system is I/O bound and the I/O wait should be reasonable for your system. The vast majority of wait events related to parallel recovery coordinators and slaves apply to the coordinator. Slaves are either applying changes (clocking on CPU) or waiting for changes to be passed from the coordinator.</p>
<p>Typically, in a properly tuned system, the top wait event is <code dir="ltr">db file parallel write</code> followed by <code dir="ltr">checkpoint completed</code>. Consult the table below for tuning advice in cases where <code dir="ltr">db file parallel write</code> is not the top wait event. The database wait events are shown in <a href="#CEGBFFEC">Table 8-3</a> and <a href="#CEGJJCHF">Table 8-4</a>.</p>
<div id="HABPT4906" class="tblruleformal">
<p class="titleintable"><a id="sthref537"></a><a id="CEGBFFEC"></a>Table 8-3 Parallel Recovery Coordinator Wait Events</p>
<table class="cellalignment2589" title="Parallel Recovery Coordinator Wait Events" summary="Describes the parallel recovery coordinator wait events." dir="ltr">
<thead>
<tr class="cellalignment2580">
<th class="cellalignment2590" id="r1c1-t18">Wait Name</th>
<th class="cellalignment2590" id="r1c2-t18">Description</th>
<th class="cellalignment2590" id="r1c3-t18">Tuning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r2c1-t18" headers="r1c1-t18">
<p><code dir="ltr">Log file sequential read</code></p>
</td>
<td class="cellalignment2586" headers="r2c1-t18 r1c2-t18">
<p>The parallel recovery coordinator is waiting on I/O from the online redo log or the archived redo log.</p>
</td>
<td class="cellalignment2586" headers="r2c1-t18 r1c3-t18">
<p>Tune or increase the I/O bandwidth for the ASM diskgroup where the archive logs or online redo logs reside.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r3c1-t18" headers="r1c1-t18">
<p><code dir="ltr">Parallel recovery read buffer free</code></p>
</td>
<td class="cellalignment2586" headers="r3c1-t18 r1c2-t18">
<p>This event indicates that all read buffers are being used by slaves, and usually indicates that the recovery slaves lag behind the coordinator.</p>
</td>
<td class="cellalignment2586" headers="r3c1-t18 r1c3-t18">
<p>Tune or increase the I/O bandwidth for the ASM diskgroup where data files reside.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r4c1-t18" headers="r1c1-t18">
<p><code dir="ltr">Parallel recovery change buffer free</code></p>
</td>
<td class="cellalignment2586" headers="r4c1-t18 r1c2-t18">
<p>The parallel recovery coordinator is waiting for a buffer to be released by a recovery slave. Again, this is a sign the recovery slaves are behind the coordinator.</p>
</td>
<td class="cellalignment2586" headers="r4c1-t18 r1c3-t18">
<p>Tune or increase the I/O bandwidth for the ASM diskgroup where data files reside.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r5c1-t18" headers="r1c1-t18">
<p><code dir="ltr">Datafile init write</code></p>
</td>
<td class="cellalignment2586" headers="r5c1-t18 r1c2-t18">
<p>The parallel recovery coordinator is waiting for a file resize to finish, as would occur with file auto extend.</p>
</td>
<td class="cellalignment2586" headers="r5c1-t18 r1c3-t18">
<p>Tune or increase the I/O bandwidth for the ASM diskgroup where data files reside.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r6c1-t18" headers="r1c1-t18">
<p><code dir="ltr">Parallel recovery control message reply</code></p>
</td>
<td class="cellalignment2586" headers="r6c1-t18 r1c2-t18">
<p>The coordinator has sent a synchronous control messages to all slaves, and is waiting for all slaves to reply.</p>
</td>
<td class="cellalignment2586" headers="r6c1-t18 r1c3-t18">
<p>This is a non-tunable event.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblruleformal" -->
<p>When dealing with recovery slave events, it is important to know how many slaves were started. Divide the wait time for any recovery slave event by the number of slaves. <a href="#CEGJJCHF">Table 8-4</a> describes the parallel recovery slave wait events.</p>
<div id="HABPT4907" class="tblruleformal">
<p class="titleintable"><a id="sthref538"></a><a id="CEGJJCHF"></a>Table 8-4 Parallel Recovery Slave Wait Events</p>
<table class="cellalignment2589" title="Parallel Recovery Slave Wait Events" summary="Describes the wait events for parallel recovery slave events." dir="ltr">
<thead>
<tr class="cellalignment2580">
<th class="cellalignment2590" id="r1c1-t19">Wait Name</th>
<th class="cellalignment2590" id="r1c2-t19">Description</th>
<th class="cellalignment2590" id="r1c3-t19">Tuning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r2c1-t19" headers="r1c1-t19">
<p><code dir="ltr">Parallel recovery slave next change</code></p>
</td>
<td class="cellalignment2586" headers="r2c1-t19 r1c2-t19">
<p>The parallel recovery slave is waiting for a change to be shipped from the coordinator. This is in essence an idle event for the recovery slave. To determine the amount of CPU a recovery slave is using, divide the time spent in this event by the number of slaves started and subtract that value from the total elapsed time. This may be close, because there are some waits involved.</p>
</td>
<td class="cellalignment2586" headers="r2c1-t19 r1c3-t19">
<p>Tune or increase the I/O bandwidth for the ASM diskgroup where the archive logs or online redo logs reside.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r3c1-t19" headers="r1c1-t19">
<p><code dir="ltr">DB File Sequential Read</code></p>
</td>
<td class="cellalignment2586" headers="r3c1-t19 r1c2-t19">
<p>A parallel recovery slave (or serial recovery process) is waiting for a batch of synchronous data block reads to complete.</p>
</td>
<td class="cellalignment2586" headers="r3c1-t19 r1c3-t19">
<p>Tune or increase the I/O bandwidth for the ASM diskgroup where data files reside.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r4c1-t19" headers="r1c1-t19">
<p><code dir="ltr">Checkpoint completed</code></p>
</td>
<td class="cellalignment2586" headers="r4c1-t19 r1c2-t19">
<p>Recovery is waiting for checkpointing to complete, and Redo Apply is not applying any changes currently.</p>
</td>
<td class="cellalignment2586" headers="r4c1-t19 r1c3-t19">
<p>Tune or increase the I/O bandwidth for the ASM diskgroup where data files reside.</p>
<p>Also, increase the number of <code dir="ltr">db_writer_processes</code> until the <code dir="ltr">checkpoint completed</code> wait event is lower than the <code dir="ltr">db file parallel write</code> wait event. Consider also increasing the online log file size on the primary and standby to decrease the number of full checkpoints at log switch boundaries.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r5c1-t19" headers="r1c1-t19">
<p><code dir="ltr">Recovery read</code></p>
</td>
<td class="cellalignment2586" headers="r5c1-t19 r1c2-t19">
<p>A parallel recovery slave is waiting for a batched data block I/O.</p>
</td>
<td class="cellalignment2586" headers="r5c1-t19 r1c3-t19">
<p>Tune or increase the I/O bandwidth for the ASM diskgroup where data files reside.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblruleformal" --></div>
<!-- class="sect3" -->
<a id="CEGFHJEI"></a>
<div id="HABPT5334" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">8.3.8.6</span> Tune <a id="sthref539"></a>I/O Operations</h4>
<p>DBWR must write out modified blocks from the buffer cache to the data files. Always use native asynchronous I/O by setting <code dir="ltr"><a id="sthref540"></a>DISK_ASYNCH_IO</code> to <code dir="ltr">TRUE</code> (default). In the rare case that asynchronous I/O is not available, use <code dir="ltr">DBWR_IO_SLAVES</code> to improve the effective data block write rate with synchronous I/O.</p>
<p>Ensure that you have sufficient I/O bandwidth and that I/O response time is reasonable for your system either by doing some base I/O tests, comparing the I/O statistics with those for the primary database, or by looking at some historical I/O metrics. Be aware that I/O response time may vary when many applications share the same storage infrastructure such as with a <a id="sthref541"></a>Storage Area Network (SAN) or <a id="sthref542"></a>Network Attached Storage (NAS).</p>
</div>
<!-- class="sect3" -->
<a id="CEGCAAEH"></a>
<div id="HABPT5335" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">8.3.8.7</span> Assess <a id="sthref543"></a>System Resources</h4>
<p>Use system commands such as UNIX <code dir="ltr">sar</code> and <code dir="ltr">vmstat</code> commands, or use system monitoring tools to assess the system resources. Alternatively, you can monitor using Oracle Enterprise Manager, AWR reports, or performance views such as <code dir="ltr"><a id="sthref544"></a>V$SYSTEM_EVENT</code>, <code dir="ltr"><a id="sthref545"></a>V$ASM_DISK</code> and <code dir="ltr"><a id="sthref546"></a>V$OSSTAT</code>.</p>
<ol>
<li>
<p>If there are I/O bottlenecks or excessive wait I/O operations, then investigate operational or application changes that increased the I/O volume. If the high waits are due to insufficient I/O bandwidth, then add more disks to the relevant Oracle ASM disk group. Verify that this is not a bus or controller bottleneck or any other I/O bottleneck. The read I/O rate from the standby redo log should be greater than the expected recovery rate.</p>
</li>
<li>
<p>Check for excessive swapping or memory paging.</p>
</li>
<li>
<p>Check to ensure the recovery coordinator or MRP is not CPU bound during recovery.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CEGEAFIB"></a>
<div id="HABPT4883" class="sect2">
<h3 class="sect2"><span class="secnum">8.3.9</span> Implement Multiple Standby Databases</h3>
<p>You should deploy multiple standby databases for any of the following purposes. When desired, use standby databases for these purposes while reserving at least one standby database to serve as the primary failover target:</p>
<ul>
<li>
<p>To provide continuous protection following failover</p>
<p>The standby databases in a multiple standby configuration that are not the target of the role transition (these databases are referred to as <span class="italic">bystander standby databases</span>) automatically apply redo data received from the new primary database.</p>
</li>
<li>
<p>To achieve zero data loss protection while also guarding against widespread geographic disasters that extend beyond the limits of synchronous communication</p>
<p>For example, one standby database that receives redo data synchronously is located 200 miles away, and a second standby database that receives redo data asynchronously is located 1,500 miles away from the primary.</p>
</li>
<li>
<p>To perform rolling database upgrades while maintaining disaster protection throughout the rolling upgrade process</p>
</li>
<li>
<p>To perform testing and other ad-hoc tasks while maintaining disaster-recovery protection</p>
</li>
</ul>
<p class="subhead2"><a id="CEGCJGDE"></a><a id="HABPT5377"></a>Use Multiple Standby Databases Best Practices</p>
<p><a id="sthref547"></a><a id="sthref548"></a>The <a class="olink HAOVW120" href="../HAOVW/hafeatures.htm#HAOVW120"><span class="italic">Oracle Database High Availability Overview</span></a> describes how a multiple standby database architecture is virtually identical to that of single standby database architectures. Therefore, the configuration guidelines for implementing multiple standby databases described in this section complement the existing best practices for physical and logical standby databases.</p>
<p>When deploying multiple standby databases, use the following best practices:</p>
<ul>
<li>
<p>Use Oracle Data Guard broker to manage your configuration and perform role transitions. However, if you choose to use SQL*Plus statements, see the MAA white paper &#34;Multiple Standby Databases Best Practices&#34; for best practices from the MAA Best Practices area for Oracle Database at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</li>
<li>
<p>If you are using Flashback Database for the sole purpose of reinstating databases following a failover, a <code dir="ltr">DB_FLASHBACK_RETENTION_TARGET</code> of 120 minutes is the minimum recommended value. When you use Flashback Database to quickly reinstate the original primary as the standby after a failover, instead of re-creating the entire standby database from backups or from the primary database, when using Fast-start Failover, ensure the <code dir="ltr">UNDO_RETENTION</code> and <code dir="ltr">DB_FLASHBACK_RETENTION_TARGET</code> initialization parameters are set to a minimum of 120 so that reinstatement is still possible after a prolonged outage. On a standby the flashback barrier cannot be guaranteed to be published every 30 minutes as it is on a primary. Thus, when enabling flashback database on a standby, the <code dir="ltr">DB_FLASHBACK_RETENTION_TARGET</code> should be a minimum of 120. Since the primary and standby should match, this implies the same for the primary.</p>
</li>
<li>
<p>Enable supplemental logging in configurations containing logical standby databases. When creating a configuration with both physical and logical standby databases, issue the <code dir="ltr">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA</code> statement to enable supplemental logging in the following situations:</p>
<ul>
<li>
<p>When adding a logical standby database to an existing configuration consisting of all physical standby databases, you must enable supplemental logging on all existing physical standby databases in the configuration.</p>
</li>
<li>
<p>When adding a physical standby database to an existing configuration that contains a logical standby database, you must enable supplemental logging on the physical standby database when you create it.</p>
</li>
</ul>
<p>As part of the logical standby database creation supplemental logging is automatically enabled on the primary. Enabling supplemental logging is a control file change and therefore the change is not propagated to each physical standby database. Supplemental logging is enabled automatically on a logical standby database when it is first converted from a physical standby database to a logical standby database as part of the dictionary build process.To enable supplemental logging, issue the following SQL*Plus statement when connected to a physical standby database:</p>
<pre dir="ltr">SQL&gt; ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY, UNIQUE INDEX) COLUMNS;
</pre></li>
<li>
<p>If logical standby databases are not configured to perform real-time queries, then consider configuring SQL Apply to delay applying redo data to the logical standby database. By delaying the application of redo, you can minimize the need to manually reinstate the logical standby database after failing over to a physical standby database.</p>
<p>To set a time delay, use the <code dir="ltr">DELAY=minutes</code> attribute of the <a id="sthref549"></a><code dir="ltr">LOG_ARCHIVE_DEST_</code><code dir="ltr"><span class="codeinlineitalic">n</span></code> initialization parameter.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink HAOVW120" href="../HAOVW/hafeatures.htm#HAOVW120"><span class="italic">Oracle Database High Availability Overview</span></a> to learn about the benefits of using multiple standby database and for implementation examples</p>
</li>
<li>
<p><a class="olink HAOVW225" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=HAOVW225"><span class="italic">Oracle Database High Availability Overview</span></a> for an overview of multiple standby database architectures</p>
</li>
<li>
<p>The MAA white paper &#34;Multiple Standby Databases Best Practices&#34; from the MAA Best Practices area for Oracle Database at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCJBGB"></a>
<div id="HABPT5378" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">8.4</span> Oracle Multitenant Databases in a Data Guard Environment</h2>
<p>All of the functionality of Data Guard is available when using Oracle Multitenant. All role transitions, Fast Start Failover, Transient Logical Rolling Upgrade, Oracle Active Data Guard, and so on, can be used with container databases (CDBs). Note that role transitions occur at the CDB level, all pluggable databases (PDBs) will transition over to the new primary database.</p>
<p>PDBs can be created in a variety of ways.</p>
<ul>
<li>
<p>Unplug a PDB from one CDB and plug in to a second</p>
</li>
<li>
<p>Create as an empty PDB from the seed PDB</p>
</li>
<li>
<p>Clone an existing PDB, either a PDB in the same container (local) or from another CDB (remote)</p>
</li>
<li>
<p>Plug in an existing non-container database (non-CDB)</p>
</li>
</ul>
<p>If a PDB is created from SEED, the standby database can copy its local files for the source PDB to create the new PDB. In addition if the standby database is running the Oracle Active Data Guard option, clones from local PDBs can also be created automatically on the standby database.</p>
<p>Prior to Oracle Database 12c version 12.1.0.2, when a PDB is created from a remote source either via plugin or remote clone operation, the files must be made available to the standby by some outside method. If the files are not available at the time the plugin redo is applied at the standby, redo apply will stop and cannot be restarted until the files are successfully added to the database controlfile.</p>
<p>In 12.1.0.2, the <code dir="ltr">CREATE PLUGGABLE DATABASE</code> statement has a new clause, <code dir="ltr">STANDBYS=NONE</code>, that allows for deferral of file instantiation on the standby allowing the physical standby database to continue to protect existing PDBs. The clause allows the general structure of the PDB to be created on all physical standbys but all files belonging to the PDB are marked as OFFLINE/RECOVER at the standby. The PDB cannot be opened on the standby with the files in this state although all other PDBs at the standby are unaffected.</p>
<p>At some point in the future, it is possible to copy the files to the standby database and enable recovery of the PDB and thus begin Data Guard protection of the PDB. Oracle provides tools to copy the files from the primary database to the standby database while the PDB is open and accessible. Enabling recovery of the PDB requires a bounce of the standby database into MOUNT mode and a brief stoppage of redo apply.</p>
<p>The reasons for requiring deferral include but are not limited to:</p>
<ul>
<li>
<p>Remote clone of a PDB. It is not possible to pre-copy the files to the physical standby database and ensure they will be in the correct state when the <code dir="ltr">CREATE PLUGGABLE DATABASE</code> statement redo is applied to the standby.</p>
</li>
<li>
<p>The PDB is considered to be a test or short-lived PDB that will be dropped relatively quickly and thus does not need to be protected by Data Guard.</p>
</li>
<li>
<p>Timing of the PDB creation does not allow for pre-instantiation of the files at the standby since that will prolong the application downtime associated with that PDB, but recovery will be required after the PDB has been created.</p>
</li>
<li>
<p>Storage for the PDB on the standby environment is not immediately available.</p>
</li>
<li>
<p>In some cases, the newly added PDB does not require higher level of data protection that comes with having a physical standby database and can be permanently disabled. The MAA team does not recommend this &#34;subset standby&#34; architecture where some PDBs in the same CDB have different HA SLAs.</p>
</li>
</ul>
<p>It is also possible to disable recovery for a previously instantiated PDB. This requires a brief stoppage of redo apply. Potential reasons for removing a PDB from Data Guard protection include but are not limited to:</p>
<ul>
<li>
<p>Debugging operations of a particular PDB where redo being applied at the standby causes redo apply to fail, thus leaving the entire container database unprotected.</p>
</li>
<li>
<p>Application activity against a single PDB causes redo apply on the standby to lag beyond SLA requirements.</p>
</li>
</ul>
<p>MAA best practices recommend that you not run in this unprotected mode for an extended period of time. The implication of having some PDBs protected by a physical standby and others unprotected complicates the architecture and overall MAA solution. Refer to MAA&#39;s reference architectures for recommended architectures per SLAs. You should review the requirements of the PDBs created with <code dir="ltr">STANDBYS=NONE</code> carefully and consolidate them with PDBs with similar requirements.</p>
<p>Outages cannot always be predicted. Prior to Oracle 12.1.0.2, Oracle does not have complete Data Guard role transition support for a configuration where files are missing on either the primary or standby databases, a concept called &#34;subset standby.&#34; The Data Guard broker has been enhanced to report the files missing but not identify this as a reason to prevent a Data Guard role transition. If an issue arises prior to your opportunity to instantiate the files, Data Guard role transition will still work seamlessly to your standby site. The location of the files and the role of the respective database will determine PDB access. If a database in the primary role does not have the files for the PDB, it will not be able to open it, nor provide any access. If a database is in the standby role, the PDB can be opened accessed read only using the Active Data Guard option.</p>
</div>
<!-- class="sect1" -->
<a id="CEGFDHAB"></a>
<div id="HABPT5285" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">8.5</span> Oracle Data Guard Role Transition Best Practices</h2>
<p>With proper planning and execution, Data Guard role transitions can effectively minimize downtime and ensure that the database environment is restored with minimal impact on the business. Using a physical standby database, MAA testing has determined that switchover and failover times with Oracle Data Guard 11<span class="italic">g</span> have been reduced to seconds. This section describes best practices for both switchover and failover.</p>
<a id="CEGIEBCF"></a>
<div id="HABPT4913" class="sect2">
<h3 class="sect2"><span class="secnum">8.5.1</span> Oracle Data Guard Switchovers Best Practices</h3>
<p>A database switchover performed by Oracle Data Guard is a planned transition that includes a series of steps to switch roles between a standby database and a primary database. Following a successful switchover operation, the standby database assumes the primary role and the primary database becomes a standby database. Switchovers are typically completed in only seconds to minutes. At times the term <span class="italic">switchback</span> is also used within the scope of database role management. A switchback operation is a subsequent switchover operation to return the roles to their original state. While following best practices, switchover times of approximately 34 seconds for Oracle RAC and 19 seconds for a single instance database have been observed.</p>
<p>Data Guard enables you to change these roles dynamically by:</p>
<ul>
<li>
<p>Using Oracle Enterprise Manager</p>
</li>
<li>
<p>Using the Oracle Data Guard broker&#39;s DGMGRL command-line interface</p>
</li>
<li>
<p>Issuing SQL statements, as described in <a href="schedule_outage.htm#BABIGAAB">Section 13.2.1.3, &#34;How to Perform Data Guard Switchover&#34;</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DGBKR" href="../DGBKR/toc.htm"><span class="italic">Oracle Data Guard Broker</span></a> for information about using Oracle Enterprise Manager or Oracle Data Guard broker&#39;s DGMGRL command-line interface to perform database switchover</div>
<p>To optimize switchover processing, perform the following steps before performing a switchover:</p>
<ul>
<li>
<p>Disconnect all sessions possible using the <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code> <code dir="ltr">KILL</code> <code dir="ltr">SESSION</code> SQL*Plus command.</p>
</li>
<li>
<p>Stop job processing by setting the <a id="sthref550"></a><code dir="ltr">AQ_TM_PROCESSES</code> parameter to <code dir="ltr">0</code>.</p>
</li>
<li>
<p>Cancel any specified apply delay by using the <code dir="ltr">NODELAY</code> keyword to stop and restart log apply services on the standby database.</p>
<pre dir="ltr">ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE NODELAY DISCONNECT;
</pre>
<p>You can view the current delay setting on the primary database by querying the <code dir="ltr">DELAY_MINS</code> column of the <code dir="ltr">V$ARCHIVE_DEST</code> view.</p>
</li>
<li>
<p>For physical standby databases in an <a id="sthref551"></a><a id="sthref552"></a>Oracle RAC environment, ensure there is only one instance active for each primary and standby database.</p>
</li>
<li>
<p>Configure<a id="sthref553"></a><a id="sthref554"></a> the standby database to use real-time apply and, if possible, ensure the databases are synchronized before the switchover operation to optimize switchover processing.</p>
<p>For the fastest switchover, use real-time apply so that redo data is applied to the standby database as soon as it is received, and the standby database is synchronized with the primary database before the switchover operation to minimize switchover time. To enable real-time apply use the following SQL*Plus statement:</p>
<pre dir="ltr">ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT;
</pre></li>
<li>
<p>For a physical standby database, reduce the number of <a id="sthref555"></a><a id="sthref556"></a>archiver (ARC<span class="italic">n</span>) processes to the minimum needed for both remote and local archiving. Additional archiver processes can take additional time to shut down, thereby increasing the overall time it takes to perform a switchover. After the switchover has completed you can reenable the additional archiver processes.</p>
</li>
<li>
<p>Set the <a id="sthref557"></a><a id="sthref558"></a><code dir="ltr">LOG_FILE_NAME_CONVERT</code> initialization parameter to any valid value for the environment, or if it is not needed set the parameter to null.</p>
<p>As part of a switchover, the standby database must clear the online redo log files on the standby database before opening as a primary database. The time needed to complete the I/O can significantly increase the overall switchover time. By setting the <code dir="ltr">LOG_FILE_NAME_CONVERT</code> parameter, the standby database can pre-create the online redo logs the first time the MRP process is started. You can also pre-create empty online redo logs by issuing the SQL*Plus <code dir="ltr">ALTER DATABASE CLEAR LOGFILE</code> statement on the standby database.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Support notes for switchover best practices for Data Guard Physical Standby (11.2.0.2):
<ul>
<li>
<p>If using SQL*Plus, see &#34;11.2 Data Guard Physical Standby Switchover Best Practices using SQL*Plus&#34; in My Oracle Support Note 1304939.1 at</p>
<p><code dir="ltr"><a href="https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1304939.1">https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1304939.1</a></code></p>
</li>
<li>
<p>If using the Oracle Data Guard broker or Oracle Enterprise Manager, see &#34;11.2 Data Guard Physical Standby Switchover Best Practices using the Broker&#34; in My Oracle Support Note 1305019.1 at</p>
<p><code dir="ltr"><a href="https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1305019.1">https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1305019.1</a></code></p>
</li>
<li>
<p>The MAA white paper &#34;Switchover and Failover Best Practices&#34; from the MAA Best Practices area for Oracle Database at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="HABPT4915" class="sect2"><a id="sthref559"></a>
<h3 class="sect2"><span class="secnum">8.5.2</span> Oracle Data Guard Failovers Best Practices</h3>
<p>A failover is typically used only when the primary database becomes unavailable, and there is no possibility of restoring it to service within a reasonable period. During a failover the primary database is taken offline at one site and a standby database is brought online as the primary database.</p>
<p>With Data Guard the process of failover can be completely automated using fast-start failover or it can be a manual, user driven process. Oracle recommends using fast-start failover to eliminate the uncertainty inherent in a process that requires manual intervention. Fast-start failover automatically executes a failover within seconds of an outage being detected. While following best practices, failover times of approximately 16 seconds for Oracle RAC and 9 seconds for a single instance database have been observed.</p>
<p>For more on Data Guard failover best practices, see:</p>
<ul>
<li>
<p><a href="#CEGDCFGJ">Comparing Fast-Start Failover and Manual Failover</a></p>
</li>
<li>
<p><a href="#CEGCAJBH">Failover Best Practices (Manual Failover and Fast-Start Failover)</a></p>
</li>
<li>
<p><a href="#CEGFEGAB">Fast-Start Failover Best Practices</a></p>
</li>
<li>
<p><a href="#CEGGDAFD">Manual Failover Best Practices</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For a comprehensive review of Oracle Data Guard failover best practices, see:
<ul>
<li>
<p><a class="olink DGBKR330" href="../DGBKR/sofo.htm#DGBKR330"><span class="italic">Oracle Data Guard Broker</span></a> for information about Switchover and Failover Operations</p>
</li>
<li>
<p>&#34;Data Guard Fast-Start Failover&#34; MAA white paper from the MAA Best Practices area for Oracle Database at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</li>
<li>
<p>&#34;11.2 Data Guard Physical Standby Switchover Best Practices using SQL*Plus&#34; in My Oracle Support Note 1304939.1 at</p>
<p><code dir="ltr"><a href="https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1304939.1">https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1304939.1</a></code></p>
</li>
<li>
<p>&#34;11.2 Data Guard Physical Standby Switchover Best Practices using the Broker&#34; in My Oracle Support Note 1305019.1 at</p>
<p><code dir="ltr"><a href="https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1305019.1">https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=1305019.1</a></code></p>
</li>
</ul>
</div>
<a id="CEGDCFGJ"></a>
<div id="HABPT4916" class="sect3">
<h4 class="sect3"><span class="secnum">8.5.2.1</span> Comparing Fast-Start Failover and Manual Failover<a id="sthref560"></a><a id="sthref561"></a><a id="sthref562"></a></h4>
<p>There are two distinct types of failover: manual failover and fast-start failover. An administrator initiates manual failover when the primary database fails. In contrast, Data Guard automatically initiates a fast-start failover without human intervention after the primary database has been unavailable for a set period (the fast-start failover threshold).</p>
<p><a href="#CEGEDHFD">Table 8-5</a> compares fast-start failover and manual failover.</p>
<div id="HABPT4917" class="tblruleformalwidemax">
<p class="titleintable"><a id="sthref563"></a><a id="CEGEDHFD"></a>Table 8-5 Comparing Fast-Start Failover and Manual Failover</p>
<table class="cellalignment2589" title="Comparing Fast-Start Failover and Manual Failover" summary="Comparison of fast-start failover versus traditional manual failover." dir="ltr">
<thead>
<tr class="cellalignment2580">
<th class="cellalignment2590" id="r1c1-t24">Points of Comparison</th>
<th class="cellalignment2590" id="r1c2-t24">Fast-Start Failover</th>
<th class="cellalignment2590" id="r1c3-t24">Manual Failover</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r2c1-t24" headers="r1c1-t24">
<p><span class="bold">Benefits</span></p>
</td>
<td class="cellalignment2586" headers="r2c1-t24 r1c2-t24">
<p>Allows you to increase availability with less need for manual intervention, thereby reducing management costs.</p>
</td>
<td class="cellalignment2586" headers="r2c1-t24 r1c3-t24">
<p>Gives you control over exactly when a failover occurs and to which target standby database.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r3c1-t24" headers="r1c1-t24">
<p><span class="bold">Failover triggers</span></p>
</td>
<td class="cellalignment2586" headers="r3c1-t24 r1c2-t24">
<p>The following conditions automatically trigger a fast-start failover:</p>
<ul>
<li>
<p>Database instance failure (or last instance failure in an Oracle RAC configuration).</p>
</li>
<li>
<p>Shutdown abort (or a shutdown abort of the last instance in an Oracle RAC configuration).</p>
</li>
<li>
<p>Specific conditions that are detected through the database health-check mechanism (for example, data files taken offline due to I/O errors).</p>
<p>Fast-start failover can be enabled for these conditions (<code dir="ltr">ENABLE FAST_START FAILOVER CONDITION</code>) and <code dir="ltr">ORA</code> errors raised by the Oracle server when they occur.</p>
<p>See <a class="olink DGBKR392" href="../DGBKR/sofo.htm#DGBKR392"><span class="italic">Oracle Data Guard Broker</span></a> for a full list of conditions.</p>
</li>
<li>
<p>Both the observer and the standby database lose their network connection to the primary database.</p>
</li>
<li>
<p>Application initiated fast-start failover using the <code dir="ltr">DBMS_DG.INITIATE_FS_FAILOVER</code> PL/SQL procedure.</p>
</li>
</ul>
</td>
<td class="cellalignment2586" headers="r3c1-t24 r1c3-t24">
<p>A <a id="sthref564"></a><a id="sthref565"></a>manual failover is user initiated and involves performing a series of steps to convert a standby database into a primary database. A manual failover should be performed due to an unplanned outage such as:</p>
<ul>
<li>
<p>Site disaster which results in the primary database becoming unavailable (all instances of an Oracle RAC primary database).</p>
</li>
<li>
<p>User errors that cannot be repaired in a timely fashion.</p>
</li>
<li>
<p>Data failures, which impact the production application.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r4c1-t24" headers="r1c1-t24">
<p><span class="bold">Management</span></p>
</td>
<td class="cellalignment2586" headers="r4c1-t24 r1c2-t24">
<p>Use the following tools to manage fast-start failover failovers:</p>
<ul>
<li>
<p>Oracle Enterprise Manager</p>
</li>
<li>
<p>The Oracle Data Guard broker command-line interface (DGMGRL)</p>
</li>
</ul>
<p>See <a href="schedule_outage.htm#BABIGAAB">Section 13.2.1.3, &#34;How to Perform Data Guard Switchover&#34;</a>.</p>
</td>
<td class="cellalignment2586" headers="r4c1-t24 r1c3-t24">
<p>Use the following tools to perform manual failovers:</p>
<ul>
<li>
<p>Oracle Enterprise Manager</p>
</li>
<li>
<p>The Oracle Data Guard broker command-line interface (DGMGRL)</p>
</li>
<li>
<p>SQL statements</p>
</li>
</ul>
<p>See <a href="outage.htm#CDEGFJIB">Section 12.2.2.3, &#34;Best Practices for Performing Manual Failover&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r5c1-t24" headers="r1c1-t24">
<p><span class="bold">Restoring the original primary database after failover</span></p>
</td>
<td class="cellalignment2586" headers="r5c1-t24 r1c2-t24">
<p>Following a fast-start failover, Oracle Data Guard broker can automatically reconfigure the original primary database as a standby database upon reconnection to the configuration (<code dir="ltr">FastStartFailoverAutoReinstate</code>), or you can delay the reconfiguration to allow diagnostics on the failed primary. Automatic reconfiguration enables Data Guard to restore disaster protection in the configuration quickly and easily, returning the database to a protected state as soon as possible.</p>
</td>
<td class="cellalignment2586" headers="r5c1-t24 r1c3-t24">
<p>After manual failover, you must reinstate the original primary database as a standby database to restore fault tolerance.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r6c1-t24" headers="r1c1-t24">
<p><span class="bold">Restoring bystander standby databases after failover</span></p>
</td>
<td class="cellalignment2586" headers="r6c1-t24 r1c2-t24">
<p>Oracle Data Guard broker coordinates the role transition on all databases in the configuration.</p>
<p>Bystanders that do no require reinstatement are available as viable standby databases to the new primary. Bystanders that require reinstatement are automatically reinstated by the observer.</p>
</td>
<td class="cellalignment2586" headers="r6c1-t24 r1c3-t24">
<p>A benefit of using Oracle Data Guard broker is that it provides the status of bystander databases and indicates whether a database must be reinstated. Status information is not readily available when using SQL*Plus statements to manage failover.</p>
<p>See <a href="outage.htm#BABHHEEE">Section 12.3.2, &#34;Restoring a Standby Database After a Failover&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r7c1-t24" headers="r1c1-t24">
<p><span class="bold">Application failover</span></p>
</td>
<td class="cellalignment2586" headers="r7c1-t24 r1c2-t24">
<p>Oracle Data Guard broker automatically publishes FAN/AQ (Advanced Queuing) and FAN/ONS (Oracle Notification Service) notifications after a failover. Clients that are also configured for Fast Connection Failover can use these notifications to connect to the new primary database. You can also use the <code dir="ltr">DB_ROLE_CHANGE</code> system event to help user applications locate services on the primary database. (These events are also available for manual failovers performed by the broker. See <a class="olink DGBKR300" href="../DGBKR/dbresource.htm#DGBKR300"><span class="italic">Oracle Data Guard Broker</span></a>.)</p>
</td>
<td class="cellalignment2586" headers="r7c1-t24 r1c3-t24">
<p>Oracle Data Guard broker automatically publishes FAN/AQ (Advanced Queuing) and FAN/ONS (Oracle Notification Service) notifications after a failover. Clients that are also configured for Fast Connection Failover can use these notifications to connect to the new primary database. You can also use the DB_ROLE_CHANGE system event to help user applications locate services on the primary database. (These events are also available for fast-start failovers performed by the broker. See <a class="olink DGBKR300" href="../DGBKR/dbresource.htm#DGBKR300"><span class="italic">Oracle Data Guard Broker</span></a>.)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblruleformalwidemax" --></div>
<!-- class="sect3" -->
<a id="CEGCAJBH"></a>
<div id="HABPT4918" class="sect3">
<h4 class="sect3"><span class="secnum">8.5.2.2</span> Failover Best Practices (Manual Failover and Fast-Start Failover)</h4>
<p>To optimize failover processing:</p>
<ul>
<li>
<p>Enable Flashback Database to reinstate the failed primary databases after a failover operation has completed. Flashback Database facilitates fast point-in-time recovery, if needed.</p>
</li>
<li>
<p>Use real-time apply with Flashback Database to apply redo data to the standby database as soon as it is received, and to quickly rewind the database should user error or logical corruption be detected.</p>
</li>
<li>
<p>Consider configuring multiple standby databases to maintain data protection following a failover.</p>
</li>
<li>
<p>Set the <a id="sthref566"></a><code dir="ltr">LOG_FILE_NAME_CONVERT</code> parameter. As part of a failover, the standby database must clear its online redo logs before opening as the primary database. The time needed to complete this I/O can add significantly to the overall failover time. By setting the <code dir="ltr">LOG_FILE_NAME_CONVERT</code> parameter, the standby pre-creates the online redo logs the first time the MRP process is started. You can also pre-create empty online redo logs by issuing the SQL*Plus <code dir="ltr">ALTER DATABASE CLEAR LOGFILE</code> statement on the standby database.</p>
</li>
<li>
<p>Use fast-start failover. If possible, ensure that the databases are synchronized before the switchover operation to optimize switchover processing. Real-time apply ensures that redo is applied as received and ensures the fastest switchover. Real-time apply is now the default in Oracle Database 12<span class="italic">c</span>, if standby redo logs are configured on the standby. The <code dir="ltr">USING CURRENT LOGFILE</code> clause is no longer required. For more information, see <a href="#CEGFEGAB">Section 8.5.2.3, &#34;Fast-Start Failover Best Practices&#34;</a>.</p>
</li>
<li>
<p>For physical standby databases, do the following:</p>
<ul>
<li>
<p>When transitioning from read-only mode to Redo Apply (recovery) mode, restart the database.</p>
</li>
<li>
<p>Go directly to the <code dir="ltr">OPEN</code> state from the <code dir="ltr">MOUNTED</code> state instead of restarting the standby database (as required in releases before Oracle Database 11<span class="italic">g</span> release 2).</p>
</li>
<li>
<p>See the MAA white paper &#34;Oracle Data Guard Redo Apply and Media Recovery&#34; to optimize media recovery for Redo Apply from the MAA Best Practices area for Oracle Database at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CEGFEGAB"></a>
<div id="HABPT4919" class="sect3">
<h4 class="sect3"><span class="secnum">8.5.2.3</span> Fast-Start Failover Best Practices<a id="sthref567"></a><a id="sthref568"></a></h4>
<p>Fast-start failover automatically, quickly, and reliably fails over to a designated standby database if the primary database fails, without requiring manual intervention to execute the failover. You can use fast-start failover only in an Oracle Data Guard configuration that is managed by Oracle Data Guard broker.</p>
<p>The Oracle Data Guard configuration can be running in either the maximum availability or maximum performance mode with fast-start failover. When fast-start failover is enabled, the broker ensures fast-start failover is possible only when the configured data loss guarantee can be upheld. Maximum availability mode provides an automatic failover environment guaranteed to lose no data. Maximum performance mode provides an automatic failover environment guaranteed to lose no more than the amount of data (in seconds) specified by the <code dir="ltr">FastStartFailoverLagLimit</code> configuration property.</p>
<p>Use the following fast-start failover best practices in addition to the generic best practices listed in the <a href="#CEGCAJBH">Section 8.5.2.2, &#34;Failover Best Practices (Manual Failover and Fast-Start Failover)&#34;</a>:</p>
<ul>
<li>
<p>Run the fast-start failover observer process on a host that is not located in the same data center as the primary or standby database.</p>
<p>Ideally, you should run the observer on a system that is equally distant from the primary and standby databases. The observer should connect to the primary and standby databases using the same network as any end-user client. If the designated observer fails, Oracle Enterprise Manager can detect it and automatically restart the observer. If the observer cannot run at a third site, then you should install the observer on the same network as the application. If a third, independent location is not available, then locate the observer in the standby data center on a separate host and isolate the observer as much as possible from failures affecting the standby database.</p>
</li>
<li>
<p>Make the observer highly available by using Oracle Enterprise Manager to automatically restart the observer on the same host upon observer process death or fail over the observer to a designated alternate host when the primary observer host fails.</p>
</li>
<li>
<p>After the failover completes, the original primary database is automatically reinstated as a standby database when a connection to it is reestablished, if you set the <code dir="ltr">FastStartFailoverAutoReinstate</code> configuration property to <code dir="ltr">TRUE</code>.</p>
</li>
<li>
<p>Set the value of the <code dir="ltr">FastStartFailoverThreshold</code> property according to your configuration characteristics, as described in <a href="#CHDCBJCA">Table 8-6</a>.</p>
<div id="HABPT4920" class="tblruleformal">
<p class="titleintable"><a id="sthref569"></a><a id="CHDCBJCA"></a>Table 8-6 Minimum Recommended Settings for FastStartFailoverThreshold</p>
<table class="cellalignment2589" title="Minimum Recommended Settings for FastStartFailoverThreshold" summary="This table describes how to set a value for the Fast-Start Failover Threshold settings" dir="ltr">
<thead>
<tr class="cellalignment2580">
<th class="cellalignment2590" id="r1c1-t25">Configuration</th>
<th class="cellalignment2590" id="r1c2-t25">Minimum Recommended Setting</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r2c1-t25" headers="r1c1-t25">
<p>Single-instance primary, low latency, and a reliable network</p>
</td>
<td class="cellalignment2586" headers="r2c1-t25 r1c2-t25">
<p>15 seconds</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r3c1-t25" headers="r1c1-t25">
<p>Single-instance primary and a high latency network over WAN</p>
</td>
<td class="cellalignment2586" headers="r3c1-t25 r1c2-t25">
<p>30 seconds</p>
</td>
</tr>
<tr class="cellalignment2580">
<td class="cellalignment2586" id="r4c1-t25" headers="r1c1-t25">
<p>Oracle RAC primary</p>
</td>
<td class="cellalignment2586" headers="r4c1-t25 r1c2-t25">
<p><span class="equationvariables">Oracle RAC miscount + reconfiguration time + 30 seconds</span></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblruleformal" --></li>
</ul>
<p>Test your configuration using the settings shown in <a href="#CHDCBJCA">Table 8-6</a> to ensure that the fast-start failover threshold is not so aggressive that it induces false failovers, or so high it does not meet your failover requirements.</p>
</div>
<!-- class="sect3" -->
<a id="CEGGDAFD"></a>
<div id="HABPT4921" class="sect3">
<h4 class="sect3"><span class="secnum">8.5.2.4</span> Manual Failover Best Practices<a id="sthref570"></a><a id="sthref571"></a><a id="sthref572"></a><a id="sthref573"></a></h4>
<p>You should perform a manual failover, which is user-driven, only in case of an emergency. The failover should be initiated due to an unplanned outage such as:</p>
<ul>
<li>
<p>Site disaster that results in the primary database becoming unavailable</p>
</li>
<li>
<p>User errors that cannot be repaired in a timely fashion</p>
</li>
<li>
<p>Data failures, to include widespread corruption, which affects the production application</p>
</li>
</ul>
<p>Use the following manual failover best practices in addition to the generic best practices listed in <a href="#CEGCAJBH">Section 8.5.2.2, &#34;Failover Best Practices (Manual Failover and Fast-Start Failover)&#34;</a>:</p>
<ul>
<li>
<p>Reinstate the original primary database as a standby database to restore fault tolerance to your environment. The standby database can be quickly reinstated by using Flashback Database. See <a href="outage.htm#BABHHEEE">Section 12.3.2, &#34;Restoring a Standby Database After a Failover.&#34;</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For physical standby databases see the MAA white paper<a id="sthref574"></a><a id="sthref575"></a> &#34;Oracle Data Guard Redo Apply and Media Recovery&#34; from the MAA Best Practices area for Oracle Database at
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGGABBA"></a>
<div id="HABPT04477" class="sect1">
<h2 class="sect1"><span class="secnum">8.6</span> Use Oracle Active Data Guard Best Practices<a id="sthref576"></a><a id="sthref577"></a><a id="sthref578"></a></h2>
<p>If you have a license for the Oracle Active Data Guard option then you can open a physical standby database for read-only access while Redo Apply on the standby database continues to apply redo data received from the primary database. All queries reading from the physical standby database execute in real time and return current results, providing more efficient use of system resources and additional assurance that the standby is healthy without compromising data protection or extending recovery time if a failover is required. Hence, this capability is referred to as <a href="glossary.htm#CHDIDADC"><span class="xrefglossterm">real-time query</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A physical standby database can be open for read-only access while Redo Apply is active if a license for the Oracle Active Data Guard option has been purchased. This capability, known as real-time query also provides the ability to have block-change tracking on the standby database, thus allowing incremental backups to be performed on the standby.</div>
<p>To deploy real-time query:</p>
<ul>
<li>
<p>Ensure Active Data Guard is enabled.</p>
<p>The easiest and best way to view the status of Oracle Active Data Guard is on the Data Guard overview page through Oracle Enterprise Manager.</p>
<p>Alternatively, query the <code dir="ltr">v$database</code> view on the standby database and confirm the status of &#34;<code dir="ltr">READ ONLY WITH APPLY</code>&#39;:</p>
<pre dir="ltr">SQL&gt; SELECT open_mode FROM V$DATABASE;
OPEN_MODE
--------------------
READ ONLY WITH APPLY
</pre></li>
<li>
<p>Use real-time apply on the standby database so that changes are applied as soon as the redo data is received. Real-time apply is the default as of Oracle Database 12<span class="italic">c</span> provided standby redo logs are configured.</p>
</li>
<li>
<p>Enable Flashback Database on the standby database to minimize downtime for logical corruptions.</p>
</li>
<li>
<p>Monitor standby performance by using Standby Statspack. For complete details about installing and using Standby Statspack, see &#34;Installing and Using Standby Statspack in 11g&#34; in My Oracle Support Note 454848.1 at</p>
<p><code dir="ltr"><a href="https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=454848.1">https://support.oracle.com/CSP/main/article?cmd=show&amp;type=NOT&amp;id=454848.1</a></code></p>
</li>
<li>
<p>When you deploy real-time query to offload queries from a primary database to a physical standby database, monitor the apply lag to ensure that it is within acceptable limits. See <a class="olink SBYDB4778" href="../SBYDB/manage_ps.htm#SBYDB4778"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for information about Monitoring Apply Lag in a Real-time Query Environment.</p>
</li>
<li>
<p>Create an Oracle Data Guard broker configuration to simplify management and to enable automatic apply instance failover on an Oracle RAC standby database.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The &#34;Active Data Guard 11g Best Practices (includes best practices for Redo Apply)&#34; white paper available from the MAA Best Practices area for Oracle Database at
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</div>
</div>
<!-- class="sect1" -->
<a id="CEGJFGCB"></a>
<div id="HABPT04778" class="sect1">
<h2 class="sect1"><span class="secnum">8.7</span> Use Snapshot Standby Database<a id="sthref579"></a><a id="sthref580"></a> Best Practices</h2>
<p>Beginning with Oracle Database release 11<span class="italic">g</span>, you can convert a physical standby database into a fully updatable standby database called a <a href="glossary.htm#CHDFFBDH">snapshot standby database</a>.</p>
<p>To convert a physical standby database into a snapshot standby database, issue the SQL*Plus <a id="sthref581"></a><code dir="ltr">ALTER DATABASE CONVERT TO SNAPSHOT STANDBY</code> statement. This command causes Oracle Data Guard to perform the following actions:</p>
<ol>
<li>
<p>Recover all available redo data</p>
</li>
<li>
<p>Create a guaranteed restore point</p>
</li>
<li>
<p>Activate the standby database as a primary database</p>
</li>
<li>
<p>Open the database as a snapshot standby database</p>
</li>
</ol>
<p>To convert the snapshot standby back to a physical standby, issue the <code dir="ltr">ALTER DATABASE CONVERT TO PHYSICAL STANDBY</code> statement. This command causes the physical standby database to be flashed back to the guaranteed restore point that was created before the <code dir="ltr">ALTER DATABASE CONVERT TO SNAPSHOT STANDBY</code> statement was issued. Then, you must perform the following actions:</p>
<ol>
<li>
<p>Restart the physical standby database</p>
</li>
<li>
<p>Restart Redo Apply on the physical standby database</p>
</li>
</ol>
<p>To create and manage snapshot standby databases:</p>
<ul>
<li>
<p>Use the Oracle Data Guard broker to manage your Oracle Data Guard configuration, because it simplifies the management of snapshot standby databases. The broker will automatically convert a snapshot standby database into a physical standby database as part of a failover operation. Without the broker, this conversion must be manually performed before initiating a failover.</p>
</li>
<li>
<p>Create multiple standby databases if your business requires a fast recovery time objective (RTO).</p>
</li>
<li>
<p>Ensure the physical standby database that you convert to a snapshot standby is caught up with the primary database, or has a minimal apply lag. See <a href="#CEGHEFAI">Section 8.3.8, &#34;Use Data Guard Redo Apply Best Practices&#34;</a> for information about tuning media recovery.</p>
</li>
<li>
<p>Configure a fast recovery area and ensure there is sufficient I/O bandwidth available. This is necessary because snapshot standby databases use guaranteed restore points.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SBYDB00708" href="../SBYDB/manage_ps.htm#SBYDB00708"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for complete information about creating a snapshot standby database</div>
</div>
<!-- class="sect1" -->
<a id="CEGBCCAB"></a>
<div id="HABPT4928" class="sect1">
<h2 class="sect1"><span class="secnum">8.8</span> Assessing <a id="sthref582"></a><a id="sthref583"></a>Data Guard Performance</h2>
<p>To accurately assess the primary database performance after adding Data Guard standby databases, obtain a history of statistics from the <a id="sthref584"></a><a class="olink REFRN30345" href="../REFRN/GUID-9E298C9D-6D96-48F4-AB72-F8C31CBCFBBA.htm#REFRN30345"><code dir="ltr">V$SYSMETRIC_SUMMARY</code> view</a> or <a id="sthref585"></a>Automatic Workload Repository (AWR) snapshots before and after deploying Oracle Data Guard with the same application profile and load.</p>
<p>To assess the application profile, compare the following statistics:</p>
<ul>
<li>
<p>Physical reads per transaction</p>
</li>
<li>
<p>Physical writes per transaction</p>
</li>
<li>
<p>CPU usage per transaction</p>
</li>
<li>
<p>Redo generated per transaction</p>
</li>
</ul>
<p>To assess the application performance, compare the following statistics:</p>
<ul>
<li>
<p>Redo generated per second or redo rate</p>
</li>
<li>
<p>User commits per second or transactions per second</p>
</li>
<li>
<p>Database time per second</p>
</li>
<li>
<p>Response time per transaction</p>
</li>
<li>
<p>SQL service response time</p>
</li>
</ul>
<p>If the application profile has changed between the two scenarios, then this is not a fair comparison. Repeat the test or tune the database or system with the general principles outlined in the <a class="olink TGDBA" href="../TGDBA/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.</p>
<p>If the application profile is similar and you observe application performance changes on the primary database because of a decrease in throughput or an increase in response time, then assess these common problem areas:</p>
<ul>
<li>
<p>CPU utilization</p>
<p>If you are experiencing high load (excessive CPU usage of over 90%, paging and swapping), then tune the system before proceeding with Data Guard. Use the <a id="sthref586"></a><a class="olink REFRN30321" href="../REFRN/GUID-E1E48692-47FA-4AE3-9402-82477E66FFC0.htm#REFRN30321"><code dir="ltr">V$OSSTAT</code></a> view or the <a id="sthref587"></a><a class="olink REFRN23451" href="../REFRN/GUID-4A9988AE-B1B5-4E71-9C38-C95448B3F758.htm#REFRN23451"><code dir="ltr">V$SYSMETRIC_HISTORY</code></a> view to monitor system usage statistics from the operating system.</p>
</li>
<li>
<p>Higher I/O wait events</p>
<p>If you are experiencing higher I/O waits from the log writer or database writer processes, then the slower I/O effects throughput and response time. To observe the I/O effects, look at the historical data of the following wait events:</p>
<ul>
<li>
<p><code dir="ltr">Log file parallel writes</code></p>
</li>
<li>
<p><code dir="ltr">Log file sequential reads</code></p>
</li>
<li>
<p><code dir="ltr">Log file parallel reads</code></p>
</li>
<li>
<p><code dir="ltr">Data file parallel writes</code></p>
</li>
<li>
<p><code dir="ltr">Data file sequential reads parallel writes</code></p>
</li>
</ul>
</li>
</ul>
<p>With <code dir="ltr">SYNC</code> transport, commits take more time because of the need to guarantee that the redo data is available on the standby database before foreground processes get an acknowledgment from the log writer (LGWR) background process that the commit has completed. A LGWR process commit includes the following wait events:</p>
<ul>
<li>
<p><code dir="ltr">Log File Parallel Write</code> (local write for the LGWR process)</p>
</li>
<li>
<p><code dir="ltr">SYNC Remote Write</code></p>
</li>
</ul>
<p>Longer commit times for the LGWR process can cause longer response time and lower throughput, especially for small time-sensitive transactions. However, you may obtain sufficient gains by tuning the log writer local write (<code dir="ltr">Log File Parallel Write</code> wait event).</p>
<p>To tune the disk write I/O (<code dir="ltr">Log File Parallel Write</code> or the RFS I/O), add more spindles or increase the I/O bandwidth.</p>
<p>To reduce the network time:</p>
<ul>
<li>
<p>Tune the Oracle Net send and receive buffer sizes</p>
</li>
<li>
<p>Set SDU=65535 (for more information, see <a href="#CEGHCABI">Section 8.3.7.2, &#34;Set the Network Configuration and Highest Network Redo Rates&#34;</a>)</p>
</li>
<li>
<p>Increase the network bandwidth if there is saturation</p>
</li>
<li>
<p>Possibly find a closer site to reduce the network latency</p>
</li>
</ul>
<p>With <code dir="ltr">ASYNC</code> transport, the LGWR process never waits for the network server processes to return before writing a <code dir="ltr">COMMIT</code> record to the current log file. However, if the network server processes has fallen behind and the redo to be shipped has been flushed from the log buffer, then the network server process reads from the online redo logs. This causes more I/O contention and possibly longer wait times for the log writer process writes (<code dir="ltr">Log File Parallel Write</code>). If I/O bandwidth and sufficient spindles are not allocated, then the log file parallel writes and log file sequential reads increase, which may affect throughput and response time. In most cases, adding sufficient spindles reduces the I/O latency.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To enable most of the statistical gathering and advisors, ensure the <a id="sthref588"></a><code dir="ltr">STATISTICS_LEVEL</code> initialization parameter is set to <code dir="ltr">TYPICAL</code> (recommended) or <code dir="ltr">ALL</code>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink TGDBA" href="../TGDBA/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for general performance tuning and troubleshooting best practices</p>
</li>
<li>
<p><a class="olink TGDBA169" href="../TGDBA/gather_stats.htm#TGDBA169"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for Overview of the Automatic Workload Repository (AWR) and on Generating Automatic Workload Repository Reports</p>
</li>
<li>
<p>The MAA white paper &#34;Data Guard Redo Transport &amp; Network Best Practices&#34; from the MAA Best Practices area for Oracle Database at</p>
<p><code dir="ltr"><a href="http://www.oracle.com/goto/maa/">http://www.oracle.com/goto/maa</a></code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2579">
<tr>
<td class="cellalignment2586">
<table class="cellalignment2584">
<tr>
<td class="cellalignment2583"><a href="config_backuprec.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2583"><a href="config_gg.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2005, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2588">
<table class="cellalignment2582">
<tr>
<td class="cellalignment2583"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2583"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2583"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2583"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2583"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2583"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>