<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-72368"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Key%20Programming%20Considerations"></a><title>Key Programming Considerations</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743"/>
<meta name="dcterms.created" content="2013-12-02T6:55:13Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SQLJ Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17660-12"/>
<meta name="dcterms.isVersionOf" content="JSQLJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="overview.htm" title="Previous" type="text/html"/>
<link rel="Next" href="blangfea.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E17660-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">10/20</span> <!-- End Header -->
<div id="JSQLJ185" class="chapter"><a id="CEGHJAIE"></a> <a id="i1008679"></a>
<h1 class="chapter"><span class="secnum">3</span> Key Programming Considerations</h1>
<p>This chapter discusses key issues to consider before developing and running your SQLJ application, and also provides a summary and sample applications. The following topics are discussed:</p>
<ul>
<li>
<p><a href="#i1005587">Selection of the JDBC Driver</a></p>
</li>
<li>
<p><a href="#i1005714">Connection Considerations</a></p>
</li>
<li>
<p><a href="#i1006100">NULL-Handling</a></p>
</li>
<li>
<p><a href="#i1006166">Exception-Handling Basics</a></p>
</li>
<li>
<p><a href="#i1006304">Basic Transaction Control</a></p>
</li>
<li>
<p><a href="#i1008366">Summary: First Steps in SQLJ Code</a></p>
</li>
<li>
<p><a href="#i1006746">Oracle-Specific Code Generation (No Profiles)</a></p>
</li>
<li>
<p><a href="#BABGCJHI">ISO Standard Code Generation</a></p>
</li>
<li>
<p><a href="#i1006982">Requirements and Restrictions for Naming</a></p>
</li>
<li>
<p><a href="#i1007067">Considerations for SQLJ in the Middle Tier</a></p>
</li>
</ul>
<a id="i1005587"></a>
<div id="JSQLJ186" class="sect1">
<h2 class="sect1">Selection of the JDBC Driver</h2>
<p>You must consider which Java Database Connectivity (JDBC) driver will be appropriate for your situation and whether it may be advantageous to use different drivers for translation and run time. You must choose or register the appropriate driver class for each and then specify the driver in your connection URL.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Your application will require an Oracle JDBC driver if you use Oracle-specific code generation or if you use ISO SQLJ standard code generation with Oracle customizer, even if your code does not actually use Oracle-specific features.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1005595">Overview of Oracle JDBC Drivers</a></p>
</li>
<li>
<p><a href="#BABBCDAC">Driver Selection for Translation</a></p>
</li>
<li>
<p><a href="#i1005674">Driver Selection and Registration for Run Time</a></p>
</li>
</ul>
<a id="i1005595"></a>
<div id="JSQLJ187" class="sect2">
<h3 class="sect2">Overview of Oracle <a id="sthref61"></a>JDBC Drivers</h3>
<p>Oracle provides the following JDBC drivers:</p>
<ul>
<li>
<p>Oracle Call Interface (OCI) driver: For client-side use with an Oracle client installation.</p>
</li>
<li>
<p>Thin driver: A pure Java driver for client-side use, particularly with applets. It does not require an Oracle client installation.</p>
</li>
<li>
<p>Server-side Thin driver: Is functionally the same as the client-side Thin driver, but is for code that runs inside Oracle Database instance and needs to access a remote server.</p>
</li>
<li>
<p>Server-side internal driver: For code that runs inside the target server, that is, inside Oracle Database instance that it must access.</p>
</li>
</ul>
<p>Oracle Database 12<span class="italic">c</span> Release 1 (12.1) provides client-side drivers compatible with JDK 6 and JDK 7.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Remember that your choices may differ between translation time and run time. For example, you may want to use Oracle JDBC OCI driver at translation time for semantics-checking, but Oracle JDBC Thin driver at run time.</div>
<p class="subhead2"><a id="JSQLJ188"></a>Core JDBC Functionality</p>
<p>The core functionality of all Oracle JDBC drivers is the same. They support the same feature set, syntax, programming interfaces, and Oracle extensions.</p>
<p>All Oracle JDBC drivers are supported by the <code>oracle.jdbc.OracleDriver</code> class.</p>
<p class="subhead2"><a id="JSQLJ189"></a>JDBC OC<a id="sthref62"></a>I Driver</p>
<p>Oracle JDBC OCI driver accesses the database by calling the OCI directly from Java, providing the highest compatibility with the different Oracle Database versions. These drivers support installed Oracle Net adapters, including interprocess communication (IPC), named pipes, TCP/IP, and IPX/SPX.</p>
<p>The use of native methods to call C entry points makes the OCI driver dependent on the Oracle platform, requiring an Oracle client installation that includes Oracle Net. Therefore it is not suitable for applets.</p>
<p>Connection strin<a id="sthref63"></a>gs for the OCI driver are of the following form, where <code><span class="codeinlineitalic">tns</span></code> is an optional TNS alias or full TNS specification:</p>
<pre>jdbc:oracle:oci:@&lt;<span class="italic">tns</span>&gt;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
For backward compatibility, <code>oci8</code> is still acceptable instead of <code>oci</code>.</div>
<p class="subhead2"><a id="JSQLJ190"></a>JDBC Th<a id="sthref64"></a>in Driver</p>
<p>Oracle JDBC Thin driver is a platform-independent, pure Java implementation that uses Java sockets to connect directly to Oracle Database from any Oracle or non-Oracle client. It can be downloaded into a browser simultaneously with the Java applet being run.</p>
<p>The JDBC Thin driver supports only TCP/IP protocol and requires a TNS listener to be listening on TCP/IP sockets from the database server. When the JDBC Thin driver is used with an applet, the client browser must have the capability to support Java sockets.</p>
<p>Connection str<a id="sthref65"></a>ings for the JDBC Thin driver are typically of the following form:</p>
<pre>jdbc:oracle:thin:@<span class="italic">host</span>:<span class="italic">port</span>/<span class="italic">servicename</span>
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for information about database service names</div>
<p>In Oracle Database 12<span class="italic">c</span> Release 1 (12.1), connection strings using SIDs are deprecated, but are still supported for backward compatibility:</p>
<pre>jdbc:oracle:thin:@<span class="italic">host</span>:<span class="italic">port</span>:<span class="italic">sid</span>
</pre>
<p class="subhead2"><a id="JSQLJ191"></a>JDBC Ser<a id="sthref66"></a>ver-Side Thin Driver</p>
<p>Oracle JDBC server-side Thin driver offers the same functionality as the client-side JDBC Thin driver, but runs inside the database and accesses a remote server. This is useful in accessing one Oracle Database instance from inside another, such as from a Java stored procedure.</p>
<p>Connection strin<a id="sthref67"></a>gs for the server-side Thin driver are the same as for the client-side Thin driver.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In order to leave the originating database when using the server-side Thin driver, the user account must have <code>SocketPermission</code> assigned. Refer to the <a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for more information. Also, refer to the <a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a> for general information about <code>SocketPermission</code> and other permissions.</div>
<p class="subhead2"><a id="JSQLJ192"></a>JDBC Ser<a id="sthref68"></a>ver-Side Internal Driver</p>
<p>Oracle JDBC server-side internal driver provides support for any Java code that runs inside the target Oracle Database instance where the SQL operations are to be performed. The server-side internal driver enables Oracle Java virtual machine (JVM) to communicate directly with the SQL engine. This driver is the default JDBC driver for SQLJ code running as a stored procedure, stored function, or trigger in Oracle Database 12<span class="italic">c</span> Release 1 (12.1).</p>
<p>Con<a id="sthref69"></a>nection strings for the server-side internal driver are of the following form:</p>
<pre>jdbc:oracle:kprb:
</pre>
<p>If your SQLJ code uses the default connection context, then SQLJ automatically uses this driver for code running in Oracle JVM.</p>
</div>
<!-- class="sect2" -->
<a id="BABBCDAC"></a>
<div id="JSQLJ193" class="sect2">
<h3 class="sect2">Driver <a id="sthref70"></a>Selection for Translation</h3>
<p>Use SQLJ option settings, either on the command line or in a properties file, to choose the driver manager class and specify a driver for translation.</p>
<p>Use the SQLJ <code>-driver</code> option to choose any driver manager class other than <code>OracleDriver</code>, which is the default.</p>
<p>Specify the particular JDBC driver to choose, such as JDBC Thin or JDBC OCI for Oracle Database, as part of the connection URL you specify in the SQLJ <code>-url</code> option.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1006917">&#34;Connection Options&#34;</a></div>
<p>You will typically, but not necessarily, use the same driver that you use in your source code for the run-time connection.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Remember that the <code>-driver</code> option does not choose a particular driver. It registers a driver class with the driver manager. One driver class might be used for multiple driver protocols, such as <code>OracleDriver</code>, which is used for all of Oracle JDBC protocols.</div>
</div>
<!-- class="sect2" -->
<a id="i1005674"></a>
<div id="JSQLJ194" class="sect2">
<h3 class="sect2">Driver <a id="sthref71"></a><a id="sthref72"></a><a id="sthref73"></a>Selection and Registration for Run Time</h3>
<p>To connect to the database at run time, you must <span class="italic">register</span> one or more drivers that will understand the URLs you specify for any of your connection instances, whether they are instances of the <code>sqlj.runtime.ref.DefaultContext</code> class or of any connection context classes that you declare.</p>
<p>If you are using an Oracle JDBC driver and create a default connection using the <code>Oracle.connect()</code> method, then SQLJ handles this automatically. The <code>Oracle.connect()</code> method registers the <code>oracle.jdbc.OracleDriver</code> class.</p>
<p>If you are using an Oracle JDBC driver, but do not use <code>Oracle.connect()</code>, then you must manually register the <code>OracleDriver</code> class, as follows:</p>
<pre>DriverManager.registerDriver(new oracle.jdbc.OracleDriver());
</pre>
<p>If you are not using an Oracle JDBC driver, then you must register some appropriate driver class, as follows:</p>
<pre>DriverManager.registerDriver(new <span class="italic">mydriver.jdbc.driver.MyDriver()</span>);
</pre>
<p>In any case, you must also set your connection URL, user name, and password.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005732">&#34;Single Connection or Multiple Connections Using DefaultContext&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
As an alternative to using the JDBC driver manager in establishing JDBC connections, you can use data sources. You can specify a data source in a <code>with</code> clause, as described in <a href="blangfea.htm#CBBBBJEC">&#34;Declaration WITH Clause&#34;</a>. For general information about data sources, refer to the <a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a>.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005714"></a>
<div id="JSQLJ195" class="sect1">
<h2 class="sect1">Connection Considerations</h2>
<p>When deciding what database connection or connections you will need for your SQLJ application, consider the following:</p>
<ul>
<li>
<p>Will you need just one database connection or multiple connections?</p>
</li>
<li>
<p>If using multiple connections (possibly to multiple schemas), then will each connection use SQL entities of the same name: tables of the same name, columns of the same name and data types, stored procedures of the same name and signature, and so on?</p>
</li>
<li>
<p>Will you need different connections for translation and run time or will the same suffice for both?</p>
</li>
</ul>
<p>A SQLJ executable statement can specify a particular connection context instance, either of <code>DefaultContext</code> or of a declared connection context class, for its database connection. Alternatively, it can omit the connection context specification and use the default connection, which is an instance of <code>DefaultContext</code> that was previously set as the default.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If your operations will use different sets of SQL entities, then you will typically want to declare and use additional connection context classes.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1005732">Single Connection or Multiple Connections Using DefaultContext</a></p>
</li>
<li>
<p><a href="#i1005855">Closing Connections</a></p>
</li>
<li>
<p><a href="#BABIDJEI">Multiple Connections Using Declared Connection Context Classes</a></p>
</li>
<li>
<p><a href="#i1005907">More About the Oracle Class</a></p>
</li>
<li>
<p><a href="#i1005966">More About the DefaultContext Class</a></p>
</li>
<li>
<p><a href="#BABDAFFA">Connection for Translation</a></p>
</li>
<li>
<p><a href="#BABDCCHC">Connection for Customization</a></p>
</li>
</ul>
<a id="i1005732"></a>
<div id="JSQLJ196" class="sect2">
<h3 class="sect2">Single <a id="sthref74"></a><a id="sthref75"></a>Connection or Multiple Connections Using DefaultContext</h3>
<p>This section discusses scenarios where you will use connection instances of only the <code>DefaultContext</code> class.</p>
<p>This is typical if you are using a single connection, or multiple connections that use SQL entities with the same names and data types.</p>
<p class="subhead2"><a id="JSQLJ197"></a>Single <a id="sthref76"></a>Connection</p>
<p>For a single connection, use one instance of the <code>DefaultContext</code> class specifying the database URL, user name, and password, when you construct your <code>DefaultContext</code> object.</p>
<p>You can use the <code>connect()</code> method of the <code>oracle.sqlj.runtime.Oracle</code> class to accomplish this. Calling this method automatically initializes the default connection context instance. This method has several signatures, including ones that allow you to specify user name, password, and URL, either directly or using a properties file. In the following example, the properties file <code>connect.properties</code> is used:</p>
<pre>Oracle.connect(<span class="italic">MyClass.</span>class, &#34;connect.properties&#34;);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>connect.properties</code> file is searched for relative to the specified class. In the example, if <code>MyClass</code> is located in <code>my-package</code>, then <code>connect.properties</code> must be found in the same package location, <code>my-package</code>.</div>
<p>If you use <code>connect.properties</code>, then you must edit it appropriately and package it with your application. In this example, you must also import the <code>oracle.sqlj.runtime.Oracle</code> class.</p>
<p>Alternatively, you can specify user name, password, and URL directly:</p>
<pre>Oracle.connect(&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, &#34;HR&#34;, &#34;hr&#34;);
</pre>
<p>In this example, the connection will use the JDBC Thin driver to connect the <code>HR</code> user with the password, <code>hr</code>, to a database on the computer, <code>localhost</code>, through port <code>5221</code>, where <code>myservice</code> is the name of the database service for the connection.</p>
<p>Either of these examples creates a special static instance of the <code>DefaultContext</code> class and installs it as your default connection. It is not necessary to do anything with this <code>DefaultContext</code> instance directly.</p>
<p>Once you have completed these steps, you do not need to specify the connection for any of the SQLJ executable statements in your application, if you want them all to use the default connection.</p>
<p>Note that in using a JDBC Thin driver, the URL must include the host name, port number, and service name (or SID, which is deprecated in Oracle Database 12<span class="italic">c</span> Release 1 (12.1)), as in the preceding example. Also, the database must have a listener running at the specified port. In using the JDBC OCI driver, no service name (or SID) is required if you intend to use the default account of the client, as will be the case in examples in this document. Alternatively, you can use name-value pairs.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for more information</div>
<p>The following URL will connect to the default account of the client:</p>
<pre>jdbc:oracle:oci:@
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p><code>Oracle.connect()</code> will not set your default connection if one had already been set. In that case, it returns <code>null</code>. This enables you to use the same code on a client or in the server. If you do want to override your default connection, then use the static <code>setDefaultContext()</code> method of <code>DefaultContext</code>.</p>
</li>
<li>
<p>The <code>Oracle.connect()</code> method defaults to a <code>false</code> setting of the auto-commit flag. However, it also has signatures to set it explicitly. In the Oracle JDBC implementation, the auto-commit flag defaults to <code>true</code>.</p>
</li>
<li>
<p>You can optionally specify <code>getClass()</code> instead of <code>MyClass.class</code> in the <code>Oracle.connect()</code> call, as long as you are not calling <code>getClass()</code> from a static method. The <code>getClass()</code> method is used in some of the SQLJ demo applications.</p>
</li>
<li>
<p>You can access the static <code>DefaultContext</code> instance, which corresponds to your default connection, as follows:</p>
<pre>DefaultContext.getDefaultContext();
</pre></li>
</ul>
</div>
<p class="subhead2"><a id="JSQLJ198"></a>Multiple Connections</p>
<p>For multiple connections, you can create and use additional instances of the <code>DefaultContext</code> class, while optionally still using the default connection.</p>
<p>You can use the <code>Oracle.getConnection()</code> method to instantiate <code>DefaultContext</code>, as in the following examples.</p>
<p>First, consider a case where you want most statements to use the default connection, but other statements to use a different connection. You must create one additional instance of <code>DefaultContext</code>:</p>
<pre>DefaultContext ctx = Oracle.getConnection (
   &#34;jdbc:oracle:thin:@localhost2:5221/myservice2&#34;, &#34;bill&#34;, &#34;lion&#34;);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>ctx</code> could also use the <code>HR</code>/<code>hr</code> schema, if you want to perform multiple sets of operations on the same schema.</div>
<p>When you want to use the default connection, it is not necessary to specify a connection context:</p>
<pre>#sql { SQL operation };
</pre>
<p>This is actually a shortcut for the following:</p>
<pre>#sql [DefaultContext.getDefaultContext()] { <span class="italic">SQL operation</span> };
</pre>
<p>When you want to use the additional connection, specify <code>ctx</code> as the connection:</p>
<pre>#sql [ctx] { <span class="italic">SQL operation</span> };
</pre>
<p>Next, consider situations where you want to use multiple connections, where each of them is a named <code>DefaultContext</code> instance. This enables you to switch your connection back and forth.</p>
<p>The following statements establish multiple connections to the same schema (in case you want to use multiple Oracle Database sessions or transactions, for example). Instantiate the <code>DefaultContext</code> class for each connection you will need:</p>
<pre>DefaultContext ctx1 = Oracle.getConnection
   (&#34;jdbc:oracle:thin:@localhost1:5221/myservice1&#34;, &#34;HR&#34;, &#34;hr&#34;);
DefaultContext ctx2 = Oracle.getConnection
   (&#34;jdbc:oracle:thin:@localhost1:5221/myservice1&#34;, &#34;HR&#34;, &#34;hr&#34;);
</pre>
<p>This creates two connection context instances that would use the same schema, connecting to <code>HR/hr</code> using service <code>myservice1</code> on the computer <code>localhost1</code>, using Oracle JDBC Thin driver.</p>
<p>Now, consider a case where you would want multiple connections to different schemas. Again, instantiate the <code>DefaultContext</code> class for each connection you will need:</p>
<pre>DefaultContext ctx1 = Oracle.getConnection
   (&#34;jdbc:oracle:thin:@localhost1:5221/myservice1&#34;, &#34;HR&#34;, &#34;hr&#34;);
DefaultContext ctx2 = Oracle.getConnection
   (&#34;jdbc:oracle:thin:@localhost2:5221/myservice2&#34;, &#34;bill&#34;, &#34;lion&#34;);
</pre>
<p>This creates two connection context instances that use Oracle JDBC Thin driver but use different schemas. The <code>ctx1</code> object connects to <code>HR/hr</code> using service <code>myservice1</code> on the computer <code>localhost1</code>, while the <code>ctx2</code> object connects to <code>bill/lion</code> using service <code>myservice2</code> on the computer <code>localhost2</code>.</p>
<p>There are two ways to switch back and forth between these connections for the SQLJ executable statements in your application:</p>
<ul>
<li>
<p>If you switch back and forth frequently, then you can specify the connection for each statement in your application:</p>
<pre>#sql [ctx1] { <span class="italic">SQL operation</span> };
...
#sql [ctx2] { <span class="italic">SQL operation</span> };
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Include the square brackets around the connection context instance name; they are part of the syntax.</div>
</li>
<li>
<p><a id="sthref77"></a>If you use either of the connections several times in a row within your code flow, then you can periodically use the static <code>setDefaultContext()</code> method of the <code>DefaultContext</code> class to reset the default connection. This method initializes the default connection context instance. This way, you can avoid specifying connections in your SQLJ statements.</p>
<pre>DefaultContext.setDefaultContext(ctx1);
#sql { <span class="italic">SQL operation</span> };   // These three statements all use ctx1
#sql { <span class="italic">SQL operation</span> };
#sql { <span class="italic">SQL operation</span> };
...
DefaultContext.setDefaultContext(ctx2);
#sql { <span class="italic">SQL operation</span> };   // These three statements all use ctx2
#sql { <span class="italic">SQL operation</span> };
#sql { <span class="italic">SQL operation</span> };
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the preceding statements do not specify connection contexts, at translation time they will all be checked against the default connection context.</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1005855"></a>
<div id="JSQLJ199" class="sect2">
<h3 class="sect2">Closing <a id="sthref78"></a>Connections</h3>
<p>It is advisable to close your connection context instances when you are done, preferably in a <code>finally</code> clause of a <code>try</code> block (in case your application terminates with an exception).</p>
<p>The <code>DefaultContext</code> class, as well as any connection context classes that you declare, includes a <code>close()</code> method. Calling this method closes the SQLJ connection context instance and, by default, also closes the underlying JDBC connection instance and the physical connection.</p>
<p>In addition, the <code>oracle.sqlj.runtime.Oracle</code> class has a static <code>close()</code> method to close the default connection only. In the following example, presume <code>ctx</code> is an instance of any connection context class:</p>
<pre>...
finally
{
   ctx.close();
}
...
</pre>
<p>Alternatively, if the <code>finally</code> clause is not within a <code>try</code> block in case a SQL exception is encountered:</p>
<pre>...
finally
{
   try { ctx.close(); } catch(SQLException ex) {...}
}
...
</pre>
<p>Or, to close the default connection, the <code>Oracle</code> class also provides a <code>close()</code> method:</p>
<pre>...
finally
{
   Oracle.close();
}
...
</pre>
<p>Always commit or roll back any pending changes before closing the connection. Whether there would be an implicit <code>COMMIT</code> operation as the connection is closed is not specified in the JDBC standard and may vary from vendor to vendor. For Oracle, there is an implicit <code>COMMIT</code> when a connection is closed, and an implicit <code>ROLLBACK</code> when a connection is garbage-collected without being closed, but it is not advisable to rely on these mechanisms.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is also possible to close a connection context instance without closing the underlying connection (in case the underlying connection is shared). Refer to <a href="alangfea.htm#i1007208">&#34;Closing Shared Connections&#34;</a> for more information.</div>
</div>
<!-- class="sect2" -->
<a id="BABIDJEI"></a>
<div id="JSQLJ200" class="sect2">
<h3 class="sect2">Multiple <a id="sthref79"></a>Connections Using Declared Connection Context Classes</h3>
<p>For multiple connections that use different sets of SQL entities, it is advantageous to use connection context declarations to define additional connection context classes. Having a separate connection context class for each set of SQL entities that you use enables SQLJ to do more rigorous semantics-checking of your code.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1005583">&#34;Connection Contexts&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1005907"></a>
<div id="JSQLJ201" class="sect2">
<h3 class="sect2">More <a id="sthref80"></a><a id="sthref81"></a>About the Oracle Class</h3>
<p>The Oracle SQLJ implementation provides the <code>oracle.sqlj.runtime.Oracle</code> class to simplify the process of creating and using instances of the <code>DefaultContext</code> class.</p>
<p>The static <code>connect()</code> method initializes the default connection context instance, instantiating a <code>DefaultContext</code> object and installing it as your default connection. You do not need to assign or use the <code>DefaultContext</code> instance returned by <code>connect()</code>. If you had already established a default connection, then <code>connect()</code> returns <code>null</code>.</p>
<p>The static <code>getConnection()</code> method simply instantiates a <code>DefaultContext</code> object and returns it. You can use the returned instance as desired.</p>
<p>Both methods register Oracle JDBC driver manager automatically if the <code>oracle.jdbc.OracleDriver</code> class is found in the <code>CLASSPATH</code>. The static <code>close()</code> method closes the default connection.</p>
<p class="subhead2"><a id="JSQLJ202"></a>Signatures of the Oracle.co<a id="sthref82"></a><a id="sthref83"></a><a id="sthref84"></a><a id="sthref85"></a>nnect() and Oracle.getConnection() Methods</p>
<p>Both the method have signatures that take the following parameter sets as input:</p>
<ul>
<li>
<p>URL (<code>String</code>), user name (<code>String</code>), password (<code>String</code>)</p>
</li>
<li>
<p>URL (<code>String</code>), user name (<code>String</code>), password (<code>String</code>), auto-commit flag (<code>boolean</code>)</p>
</li>
<li>
<p>URL (<code>String</code>), <code>java.util.Properties</code> object containing properties for the connection</p>
</li>
<li>
<p>URL (<code>String</code>), <code>java.util.Properties</code> object, auto-commit flag (<code>boolean</code>)</p>
</li>
<li>
<p>URL (<code>String</code>) fully specifying the connection, including user name and password</p>
<p>The following is an example of the format of a URL string specifying user name (<code>HR</code>) and password (<code>hr</code>) when using Oracle JDBC drivers, in this case the JDBC Thin driver:</p>
<pre>&#34;jdbc:oracle:thin:HR/hr@localhost:5221/myservice&#34;
</pre></li>
<li>
<p>URL (<code>String</code>), auto-commit flag (<code>boolean</code>)</p>
</li>
<li>
<p>A <code>java.lang.Class</code> object for the class relative to which the properties file is loaded, name of properties file (<code>String</code>)</p>
</li>
<li>
<p>A <code>java.lang.Class</code> object, name of properties file (<code>String</code>), auto-commit flag (<code>boolean</code>)</p>
</li>
<li>
<p>A <code>java.lang.Class</code> object, name of properties file (<code>String</code>), user name (<code>String</code>), password (<code>String</code>)</p>
</li>
<li>
<p>A <code>java.lang.Class</code> object, name of properties file (<code>String</code>), user name (<code>String</code>), password (<code>String</code>), auto-commit flag (<code>boolean</code>)</p>
</li>
<li>
<p>JDBC connection object (<code>Connection</code>)</p>
</li>
<li>
<p>SQLJ connection context object</p>
</li>
</ul>
<p>These last two signatures inherit an existing database connection. When you inherit a connection, you will also inherit the auto-commit setting of that connection.</p>
<p>The auto-commit flag specifies whether SQL operations are automatically committed. For the <code>Oracle.connect()</code> and <code>Oracle.getConnection()</code> methods only, the default is <code>false</code>. If that is the setting you want, then you can use one of the signatures that does not take auto-commit as input. However, anytime you use a constructor to create an instance of a connection context class, including <code>DefaultContext</code>, you must specify the auto-commit setting. In the Oracle JDBC implementation, the default for the auto-commit flag is <code>true</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006304">&#34;Basic Transaction Control&#34;</a> and <a href="#i1005732">&#34;Single Connection or Multiple Connections Using DefaultContext&#34;</a></div>
<p class="subhead2"><a id="JSQLJ203"></a>Optional Oracle.cl<a id="sthref86"></a><a id="sthref87"></a>ose() Method Parameters</p>
<p>In using the <code>Oracle.close()</code> method to close the default connection, you have the option of specifying whether or not to close the underlying physical database connection. By default it is closed. This is relevant if you are sharing this physical connection between multiple connection objects, either SQLJ connection context instances or JDBC connection instances.</p>
<p>You can keep the underlying physical connection open as follows:</p>
<pre>Oracle.close(ConnectionContext.KEEP_CONNECTION);
</pre>
<p>You can close the underlying physical connection (default behavior) as follows:</p>
<pre>Oracle.close(ConnectionContext.CLOSE_CONNECTION);
</pre>
<p><code>KEEP_CONNECTION</code> and <code>CLOSE_CONNECTION</code> are static constants of the <code>ConnectionContext</code> interface.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1007208">&#34;Closing Shared Connections&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1005966"></a>
<div id="JSQLJ204" class="sect2">
<h3 class="sect2">More About the DefaultContext Class</h3>
<p>The <code>sqlj.runtime.ref.DefaultContext</code> class provides a complete default implementation of a connection context class. As with classes created using a connection context declaration, the <code>DefaultContext</code> class implements the <code>sqlj.runtime.ConnectionContext</code> interface. The <code>DefaultContext</code> class has the same class definition that would have been generated by the SQLJ translator from the declaration:</p>
<pre>#sql public context DefaultContext;
</pre>
<p class="subhead2"><a id="JSQLJ205"></a>DefaultC<a id="sthref88"></a>ontext Methods</p>
<p>The following are the key methods of the <code>DefaultContext</code> class:</p>
<ul>
<li>
<p><code>getConnection()</code></p>
<p>Gets the underlying JDBC connection object. This is useful if you want to have JDBC code in your application, which is one way to use dynamic SQL operations. You can also use the <code>setAutoCommit()</code> method of the underlying JDBC connection object to set the auto-commit flag for the connection.</p>
</li>
<li>
<p><code>setDefaultContext()</code></p>
<p>Sets the default connection your application uses. This is a <code>static</code> method and takes a <code>DefaultContext</code> instance as input. SQLJ executable statements that do not specify a connection context instance will use the default connection that you define using this method or the <code>Oracle.connect()</code> method.</p>
</li>
<li>
<p><code>getDefaultContext()</code></p>
<p>Returns the <code>DefaultContext</code> instance currently defined as the default connection for your application. This is a <code>static</code> method.</p>
</li>
<li>
<p><code>close()</code></p>
<p>Closes the connection context instance.</p>
</li>
</ul>
<p>The <code>getConnection()</code> and <code>close()</code> methods are specified in the <code>sqlj.runtime.ConnectionContext</code> interface.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
On a client, <code>getDefaultContext()</code> returns <code>null</code> if <code>setDefaultContext()</code> was not previously called. However, if a data source object has been bound under &#34;<code>jdbc/defaultDataSource</code>&#34; in JNDI, then the client will use this data source object as its default connection.
<p>In the server, <code>getDefaultContext()</code> returns the default connection, which is the connection to the server itself.</p>
</div>
<p class="subhead2"><a id="JSQLJ206"></a>Default<a id="sthref89"></a>Context Constructors</p>
<p>It is typical to instantiate <code>DefaultContext</code> using the <code>Oracle.connect()</code> or <code>Oracle.getConnection()</code> method. However, if you want to create an instance directly, then there are five constructors for <code>DefaultContext</code>. The different input parameter sets for these constructors are:</p>
<ul>
<li>
<p>URL (<code>String</code>), user name (<code>String</code>), password (<code>String</code>), auto-commit (<code>boolean</code>)</p>
</li>
<li>
<p>URL (<code>String</code>), <code>java.util.Properties</code> object, auto-commit (<code>boolean</code>)</p>
</li>
<li>
<p>URL (<code>String</code> fully specifying connection and including user name and password), auto-commit setting (<code>boolean</code>)</p>
<p>The following is an example of the format of a URL specifying user name and password when using Oracle JDBC drivers, in this case the JDBC Thin driver:</p>
<pre>&#34;jdbc:oracle:thin:HR/hr@localhost:5221/myservice&#34;
</pre></li>
<li>
<p>JDBC connection object (<code>Connection</code>)</p>
</li>
<li>
<p>SQLJ connection context object</p>
</li>
</ul>
<p>The last two signatures inherit an existing database connection. When you inherit a connection, you will also inherit the auto-commit setting of that connection.</p>
<p>Following is an example of constructing a <code>DefaultContext</code> instance:</p>
<pre>DefaultContext defctx = new DefaultContext
   (&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, &#34;HR&#34;, &#34;hr&#34;, false);
</pre>
<p class="subhead2"><a id="JSQLJ207"></a>Notes About Connection Context Constructors:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must keep the following in mind when using connection context constructors:
<ul>
<li>
<p>It is important to note that connection context class constructors, unlike the <code>Oracle.connect()</code> method, require an auto-commit setting.</p>
</li>
<li>
<p>To use any of the first three constructors listed, you must first register your JDBC driver. This happens automatically if you are using an Oracle JDBC driver and call <code>Oracle.connect()</code>. Refer to <a href="#i1005674">&#34;Driver Selection and Registration for Run Time&#34;</a>.</p>
</li>
<li>
<p>Connection context classes that you declare generally have the same constructor signatures as the <code>DefaultContext</code> class. However, if you declare a connection context class to be associated with a data source, a different set of constructors is provided. Refer to <a href="alangfea.htm#i1005952">&#34;Standard Data Source Support&#34;</a> for more information.</p>
</li>
<li>
<p>When using the constructor that takes a JDBC connection object, do not initialize the connection context instance with a null JDBC connection.</p>
</li>
<li>
<p>The auto-commit setting determines whether SQL operations are automatically committed. Refer to <a href="#i1006304">&#34;Basic Transaction Control&#34;</a> for more information.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JSQLJ208"></a>Optional De<a id="sthref90"></a><a id="sthref91"></a>faultContext cl<a id="sthref92"></a>ose() Method Parameters</p>
<p>When you close a connection context instance, you have the option of specifying whether or not to close the underlying physical connection. By default it is closed. This is relevant if you are sharing the physical connection between multiple connection objects, either SQLJ connection context instances or JDBC connection instances. The following examples presume a <code>DefaultContext</code> instance <code>defctx</code>.</p>
<p>To keep the underlying physical connection open, use the following:</p>
<pre>defctx.close(ConnectionContext.KEEP_CONNECTION);
</pre>
<p>To close the underlying physical connection, which is the default behavior, use the following:</p>
<pre>defctx.close(ConnectionContext.CLOSE_CONNECTION);
</pre>
<p><code>KEEP_CONNECTION</code> and <code>CLOSE_CONNECTION</code> are static constants of the <code>ConnectionContext</code> interface.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1007208">&#34;Closing Shared Connections&#34;</a> for more information about using these parameters and about shared connections</div>
</div>
<!-- class="sect2" -->
<a id="BABDAFFA"></a>
<div id="JSQLJ209" class="sect2">
<h3 class="sect2">Connection for Translation</h3>
<p>If you want to use online semantics-checking during tra<a id="sthref93"></a>nslation, then you must specify a database connection for SQLJ to use. These are referred to as <span class="bold">exemplar schemas</span>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1005597">&#34;Connection Context Concepts&#34;</a></div>
<p>You can use different connections for translation and run time. In fact, it is often necessary or preferable to do so. It might be necessary if you are not developing the application in the same kind of environment that it will run in. But even if the run-time connection is available during translation, it might be preferable to create an account with a narrower set of resources so that your online checking will be tighter. This would be true if your application uses only a small subset of the SQL entities available in the run-time connection. Your online checking would be tighter and more meaningful if you create an exemplar schema consisting only of SQL entities that your application actually uses.</p>
<p>Use the SQLJ translator connection options, either on the command line or in a properties file, to specify a connection for translation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1006917">&#34;Connection Options&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="BABDCCHC"></a>
<div id="JSQLJ210" class="sect2">
<h3 class="sect2">Connection for Customization</h3>
<p>Generally, Oracle customization does not require a database connection. However, the Oracle SQLJ implementation does support customizer connections. This is useful in two circumstances:</p>
<ul>
<li>
<p>If you are using Oracle customizer with the <code>optcols</code> option enabled, then a connection is required. This option allows iterator column type and size definitions for performance optimization.</p>
</li>
<li>
<p>If you are using <code>SQLCheckerCustomizer</code>, a specialized customizer that performs semantics-checking on profiles, then a connection is required if you are using an online checker, which is true by default.</p>
</li>
</ul>
<p>For Oracle-specific code generation, the SQLJ translator has an <code>-optcols</code> option with the same functionality. The <code>SQLCheckerCustomizer</code> is invoked through Oracle customizer harness <code>verify</code> option. Use the customizer harness <code>user</code>, <code>password</code>, <code>url</code>, and <code>driver</code> options to specify connection parameters for whatever customizer you are using, as appropriate.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="profcust.htm#i634971">&#34;Oracle Customizer Column Definition Option (optcols)&#34;</a>.</p>
</li>
<li>
<p><a href="profcust.htm#i635420">&#34;SQLCheckerCustomizer for Profile Semantics-Checking&#34;</a></p>
</li>
<li>
<p><a href="profcust.htm#i634663">&#34;Customizer Harness Options for Connections&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006100"></a>
<div id="JSQLJ211" class="sect1">
<h2 class="sect1">NULL-Handling</h2>
<p>Java primitive types, such as <code>int</code>, <code>double</code>, or <code>float</code>, cannot have null values. You must consider this in choosing your result expression and host expression types.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABEJEID">Wrapper Classes for NULL-Handling</a></p>
</li>
<li>
<p><a href="#BABDAIHJ">Examples of NULL-Handling</a></p>
</li>
</ul>
<a id="BABEJEID"></a>
<div id="JSQLJ212" class="sect2">
<h3 class="sect2">Wrapper <a id="sthref94"></a><a id="sthref95"></a>Classes for NULL-Handling</h3>
<p>SQLJ consistently enforces retrieving SQL <code>NULL</code> as Java <code>null</code>, in contrast to JDBC, which retrieves <code>NULL</code> as <code>0</code> or <code>false</code> for certain data types. Therefore, do not use Java primitive types in SQLJ for output variables in situations where a SQL <code>NULL</code> may be received, because Java primitive types cannot take <code>null</code> values.</p>
<p>This pertains to result expressions, output or input-output host expressions, and iterator column types. If the receiving Java type is primitive and an attempt is made to retrieve a SQL <code>NULL</code>, then a <code>sqlj.runtime.SQLNullException</code> is thrown and no assignment is made.</p>
<p>To avoid the possibility of <code>NULL</code> being assigned to Java primitives, use the following wrapper classes instead of primitive types:</p>
<ul>
<li>
<p><code>java.lang.Boolean</code></p>
</li>
<li>
<p><code>java.lang.Byte</code></p>
</li>
<li>
<p><code>java.lang.Short</code></p>
</li>
<li>
<p><code>java.lang.Integer</code></p>
</li>
<li>
<p><code>java.lang.Long</code></p>
</li>
<li>
<p><code>java.lang.Double</code></p>
</li>
<li>
<p><code>java.lang.Float</code></p>
</li>
</ul>
<p>In case you must convert back to a primitive value, each of these wrapper classes has an <code><span class="codeinlineitalic">xxx</span></code><code>Value()</code> method. For example, <code>intValue()</code> returns an <code>int</code> value from an <code>Integer</code> object and <code>floatValue()</code> returns a <code>float</code> value from a <code>Float</code> object. For example, presuming <code>intobj</code> is an <code>Integer</code> object:</p>
<pre>int j = intobj.intValue();
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p><code>SQLNullException</code> is a subclass of the standard <code>java.sql.SQLException</code> class.</p>
</li>
<li>
<p>Because Java objects can have <code>null</code> values, there is no need for indicator variables in SQLJ, such as those used in other host languages like C, C++, and COBOL.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABDAIHJ"></a>
<div id="JSQLJ213" class="sect2">
<h3 class="sect2">Examples of <a id="sthref96"></a>NULL-Handling</h3>
<p>The following examples show the use of the <code>java.lang</code> wrapper classes to handle <code>NULL</code>.</p>
<p class="subhead2"><a id="JSQLJ214"></a>Example: Null Input Host Variable</p>
<p>In the following example, a <code>Float</code> object is used to pass a <code>null</code> value to the database:</p>
<pre>int empno = 7499;
Float commission = null;

#sql { UPDATE employees SET commission_pct = :commission WHERE employee_id = :empno };
</pre>
<p>You cannot use the Java primitive type <code>float</code> to accomplish this.</p>
<p class="subhead2"><a id="JSQLJ215"></a>Example: Null Iterator Rows</p>
<p>In the following example, a <code>Double</code> column type is used in an iterator to allow for the possibility of <code>null</code> data.</p>
<p>For each employee in the <code>employee</code> table whose salary is at least $50,000, the employee name (<code>FIRST_NAME</code>) and commission (<code>COMMISSION_PCT</code>) are selected into the iterator. Then each row is tested to determine if the <code>COMMISSION_PCT</code> field is, in fact, null. If so, then it is processed accordingly.</p>
<pre>#sql iterator EmployeeIter (String first_name, Double commission);

EmployeeIter ei;
#sql ei = { SELECT first_name, commission_pct FROM employees WHERE salary &gt;= 50000 };

while (ei.next())
{
   if (ei.commission_pct() == null) 
      System.out.println(ei.first_name() + &#34; is not on commission.&#34;);
}
ei.close();
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To execute a <code>WHERE</code> clause comparison against <code>NULL</code>, use the following SQL syntax:
<pre>...WHERE :x IS NULL
</pre></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006166"></a>
<div id="JSQLJ216" class="sect1">
<h2 class="sect1">Exception-Handling Basics</h2>
<p>This section covers the basics of handling exceptions in SQLJ application, including requirements for error-checking. This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABFHDCA">SQLJ and JDBC Exception-Handling Requirements</a></p>
</li>
<li>
<p><a href="#BABDJDIC">Processing Exceptions</a></p>
</li>
<li>
<p><a href="#i1006281">Using SQLException Subclasses</a></p>
</li>
</ul>
<a id="BABFHDCA"></a>
<div id="JSQLJ217" class="sect2">
<h3 class="sect2">SQLJ and JDBC <a id="sthref97"></a>Exception-Handling Requirements</h3>
<p>Because SQLJ executable statements result in JDBC calls through <code>sqlj.runtime</code>, and JDBC requires SQL exceptions to be caught or thrown, SQLJ also requires SQL exceptions to be caught or thrown in any block containing SQLJ executable statements. Your source code will generate errors during compilation if you do not include appropriate exception-handling.</p>
<p>Handling SQL exceptions requires the <code>SQLException</code> class, which is included in the standard JDBC <code>java.sql.*</code> package.</p>
<p class="subhead2"><a id="JSQLJ218"></a>Example: Exception Handling</p>
<p>This example demonstrates the basic exception-handling required in SQLJ applications. The code declares a <code>main</code> method with a <code>try/catch</code> block and another method, which throws <code>SQLException</code> when an exception is encountered. The code is as follows:</p>
<pre>    /* Import SQLExceptions class.  The SQLException comes from
       JDBC. Executable #sql clauses result in calls to JDBC, so methods
       containing executable #sql clauses must either catch or throw
       SQLException.
    */
import java.sql.* ;
import oracle.sqlj.runtime.Oracle;

    // iterator for the select

#sql iterator MyIter (String ITEM_NAME);

public class TestInstallSQLJ 
{
    //Main method
  public static void main (String args[]) 
  {
    try { 

    // Set the default connection to the URL, user, and password
    // specified in your connect.properties file
      Oracle.connect(TestInstallSQLJ.class, &#34;connect.properties&#34;);

      TestInstallSQLJ ti = new TestInstallSQLJ();

    // This method throws SQLException. Therefore, it ic called within a try block
      ti.runExample();

    } catch (SQLException e) { 
      System.err.println(&#34;Error running the example: &#34; + e);
    }

  } //End of method main

  //Method that runs the example
  void runExample() throws SQLException
  {
      //Issue SQL command to clear the SALES table
    #sql { DELETE FROM SALES };
    #sql { INSERT INTO SALES(ITEM_NAME) VALUES (&#39;Hello, SQLJ!&#39;)};

    MyIter iter;
    #sql iter = { SELECT ITEM_NAME FROM SALES };

    while (iter.next()) {
      System.out.println(iter.ITEM_NAME());
    }
  }
}
</pre></div>
<!-- class="sect2" -->
<a id="BABDJDIC"></a>
<div id="JSQLJ219" class="sect2">
<h3 class="sect2">Processing <a id="sthref98"></a>Exceptions</h3>
<p>This section discusses ways to process and interpret exceptions in your SQLJ application. During run time, exceptions may be raised from any of the following:</p>
<ul>
<li>
<p>SQLJ run time</p>
</li>
<li>
<p>JDBC driver</p>
</li>
<li>
<p>RDBMS</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ220"></a>Printing Error Text</p>
<p>The example in the previous section showed how to catch SQL exceptions and output the error messages. Part of that code is as follows:</p>
<pre>...
try {
...
} catch (SQLException e) { 
      System.err.println(&#34;Error running the example: &#34; + e); 
}
...
</pre>
<p>This will print the error text from the <code>SQLException</code> object.</p>
<p>You can also retrieve error information using the <code>getMessage()</code>, <code>getErrorCode()</code>, and <code>getSQLState()</code> methods the <code>SQLException</code> class.</p>
<p>Printing the error text, as in this example, prints the error message with some additional text, such as <code>SQLException</code>.</p>
<p class="subhead2"><a id="i1006260"></a><a id="JSQLJ221"></a>Retrieving <a id="sthref99"></a><a id="sthref100"></a>SQL States and Error Codes</p>
<p>The <code>java.sql.SQLException</code> class and subclasses include the <code>getMessage()</code>, <code>getErrorCode()</code>, and <code>getSQLState()</code> methods. Depending on where the exception or error originated and how they are implemented there, the following methods provide additional information:</p>
<ul>
<li>
<p><code>String getMessage()</code></p>
<p>If the error originates in the SQLJ run time or JDBC driver, then this method returns the error message with no prefix. If the error originates in the RDBMS, then it returns the error message prefixed by the <code>ORA</code> number.</p>
</li>
<li>
<p><code>int getErrorCode()</code></p>
<p>If the error originates in the SQLJ run time, then this method returns no meaningful information. If the error originates in the JDBC driver or RDBMS, then it returns the five-digit <code>ORA</code> number as an integer.</p>
</li>
<li>
<p><code>String getSQLState()</code></p>
<p>If the error originates in the SQLJ run time, then this method returns a string with a five-digit code indicating the SQL state. If the error originates in the JDBC driver, then it returns no meaningful information. If the error originates in the RDBMS, then it returns the five-digit SQL state. Your application should have appropriate code to handle <code>null</code> values returned.</p>
</li>
</ul>
<p>The following example prints the error message and also checks the SQL state:</p>
<pre>...
try {
...
} catch (SQLException e) { 
      System.err.println(&#34;Error running the example: &#34; + e); 
      String sqlState = e.getSQLState();
      System.err.println(&#34;SQL state = &#34; + sqlState); 
}
...
</pre></div>
<!-- class="sect2" -->
<a id="i1006281"></a>
<div id="JSQLJ222" class="sect2">
<h3 class="sect2">Using <a id="sthref101"></a><a id="sthref102"></a>SQLException Subclasses</h3>
<p>For more specific error-checking, use any available and appropriate subclasses of the <code>java.sql.SQLException</code> class.</p>
<p>SQLJ provides the <code>sqlj.runtime.NullException</code> class, which is a subclass of <code>java.sql.SQLException</code>. You can use this exception in situations where a <code>NULL</code> might be returned into a Java primitive variable.</p>
<p>For batch-enabled environments, there is also the standard <code>java.sql.BatchUpdateException</code> subclass. Refer to <a href="apppfdbg.htm#i1006173">&#34;Error Conditions During Batch Execution&#34;</a> for further information.</p>
<p>When you use a subclass of <code>SQLException</code>, catch the subclass exception before catching <code>SQLException</code>, as in the following example:</p>
<pre>...
try {
...
} catch (SQLNullException ne) {
     System.err.println(&#34;Null value encountered: &#34; + ne); }
  catch (SQLException e) { 
     System.err.println(&#34;Error running the example: &#34; + e); }
...
</pre>
<p>This is because a subclass exception can also be caught as a <code>SQLException</code>. If you catch <code>SQLException</code> first, then execution will not proceed to the part where you have coded special processing for the subclass exception.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006304"></a>
<div id="JSQLJ223" class="sect1">
<h2 class="sect1">Basic <a id="sthref103"></a>Transaction Control</h2>
<p>This section discusses how to manage data updates. It covers the following topics:</p>
<ul>
<li>
<p><a href="#BABCIBHF">Overview of Transactions</a></p>
</li>
<li>
<p><a href="#BABCEFCA">Automatic Commits Versus Manual Commits</a></p>
</li>
<li>
<p><a href="#BABFFDCF">Specifying Auto-Commit as You Define a Connection</a></p>
</li>
<li>
<p><a href="#i1006369">Modifying Auto-Commit in an Existing Connection</a></p>
</li>
<li>
<p><a href="#i1006385">Using Manual COMMIT and ROLLBACK</a></p>
</li>
<li>
<p><a href="#i1006416">Effect of Commits and Rollbacks on Iterators and Result Sets</a></p>
</li>
<li>
<p><a href="#i1006439">Using Savepoints</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006992">&#34;Advanced Transaction Control&#34;</a></div>
<a id="BABCIBHF"></a>
<div id="JSQLJ224" class="sect2">
<h3 class="sect2">Overview of <a id="sthref104"></a>Transactions</h3>
<p>A <span class="bold">transaction</span> is a sequence of SQL operations that Oracle treats as a single unit. A transaction begins with the first executable SQL statement after any of the following:</p>
<ul>
<li>
<p>Connection to the database</p>
</li>
<li>
<p><code>COMMIT</code> (committing data updates, either automatically or manually)</p>
</li>
<li>
<p><code>ROLLBACK</code> (canceling data updates)</p>
</li>
</ul>
<p>A transaction ends with a <code>COMMIT</code> or <code>ROLLBACK</code> operation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In Oracle Database 12<span class="italic">c</span> Release 1 (12.1), all data definition language (DDL) statements, such as <code>CREATE</code> and <code>ALTER</code>, include an implicit <code>COMMIT</code>. This will commit not only the DDL statement, but all the preceding data manipulation language (DML) statements, such as <code>INSERT</code>, <code>DELETE</code>, and <code>UPDATE</code>, that have not yet been committed or rolled back.</div>
</div>
<!-- class="sect2" -->
<a id="BABCEFCA"></a>
<div id="JSQLJ225" class="sect2">
<h3 class="sect2">Automatic <a id="sthref105"></a><a id="sthref106"></a>Commits Versus Manual Commits</h3>
<p>In using SQLJ or JDBC, you can either have your data updates automatically committed or commit them manually. In either case, each <code>COMMIT</code> operation starts a new transaction. You can specify that changes be committed automatically by enabling the auto-commit flag. This can be done either when you define a SQLJ connection or by using the <code>setAutoCommit()</code> method of the underlying JDBC connection object of an existing connection. You can use manual control by disabling the auto-commit flag and using SQLJ <code>COMMIT</code> and <code>ROLLBACK</code> statements.</p>
<p>Enabling auto-commit may be more convenient, but gives you less control. For example, you have no option to roll back changes. In addition, some SQLJ or JDBC features are incompatible with auto-commit mode. For example, you must disable the auto-commit flag for update batching or <code>SELECT FOR UPDATE</code> syntax to work properly.</p>
</div>
<!-- class="sect2" -->
<a id="BABFFDCF"></a>
<div id="JSQLJ226" class="sect2">
<h3 class="sect2">Specifying <a id="sthref107"></a><a id="sthref108"></a><a id="sthref109"></a><a id="sthref110"></a>Auto-Commit as You Define a Connection</h3>
<p>When you use the <code>Oracle.connect()</code> or <code>Oracle.getConnection()</code> method to create a <code>DefaultContext</code> instance and define a connection, the auto-commit flag is set to <code>false</code> by default. However, there are signatures of these methods that enable you to set this flag explicitly. The auto-commit flag is always the last parameter.</p>
<p>The following is an example of instantiating <code>DefaultContext</code> and using the default <code>false</code> setting for auto-commit mode:</p>
<pre>Oracle.getConnection
   (&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, &#34;HR&#34;, &#34;hr&#34;);
</pre>
<p>Alternatively, you can specify a <code>true</code> setting as follows:</p>
<pre>Oracle.getConnection
   (&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, &#34;HR&#34;, &#34;hr&#34;, true);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005907">&#34;More About the Oracle Class&#34;</a></div>
<p>If you use a constructor to create a connection context instance, either of <code>DefaultContext</code> or of a declared connection context class, then you must specify the auto-commit setting. Again, it is the last parameter, as in the following example:</p>
<pre>DefaultContext ctx = new DefaultContext
   (&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, &#34;HR&#34;, &#34;hr&#34;, false);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005966">&#34;More About the DefaultContext Class&#34;</a></div>
<p>If you have reason to create a JDBC <code>Connection</code> instance directly, then the auto-commit flag is set to <code>true</code> by default if your program runs on a client, or <code>false</code> by default if it runs in the server. You cannot specify an auto-commit setting when you create a JDBC <code>Connection</code> instance directly, but you can use the <code>setAutoCommit()</code> method to alter the setting.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Auto-commit functionality is <span class="italic">not</span> supported by the JDBC server-side internal driver.</div>
</div>
<!-- class="sect2" -->
<a id="i1006369"></a>
<div id="JSQLJ227" class="sect2">
<h3 class="sect2">Modifying <a id="sthref111"></a><a id="sthref112"></a><a id="sthref113"></a><a id="sthref114"></a>Auto-Commit in an Existing Connection</h3>
<p>There is typically no reason to change the auto-commit flag setting for an existing connection, but you can if you desire. You can do this by using the <code>setAutoCommit()</code> method of the underlying JDBC connection object.</p>
<p>You can retrieve the underlying JDBC connection object by using the <code>getConnection()</code> method of any SQLJ connection context instance, whether it is an instance of the <code>DefaultContext</code> class or of a connection context class that you declared.</p>
<p>You can accomplish these two steps at once, as follows:</p>
<pre>ctx.getConnection().setAutoCommit(false);
</pre>
<p>or:</p>
<pre>ctx.getConnection().setAutoCommit(true);
</pre>
<p>In these examples, <code>ctx</code> is a SQLJ connection context instance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do <span class="italic">not</span> alter the auto-commit setting in the middle of a transaction.</div>
</div>
<!-- class="sect2" -->
<a id="i1006385"></a>
<div id="JSQLJ228" class="sect2">
<h3 class="sect2">Using <a id="sthref115"></a><a id="sthref116"></a><a id="sthref117"></a>Manual COMMIT and ROLLBACK</h3>
<p>If you disable the auto-commit flag, then you must manually commit any data updates. To commit any changes that have been executed since the last <code>COMMIT</code> operation, use the SQLJ <code>COMMIT</code> statement, as follows:</p>
<pre>#sql { COMMIT };
</pre>
<p>To roll back any changes that have been executed since the last <code>COMMIT</code> operation, use the SQLJ <code>ROLLBACK</code> statement, as follows:</p>
<pre>#sql { ROLLBACK };
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Do not use the <code>COMMIT</code> and <code>ROLLBACK</code> commands when auto-commit is enabled. This will result in unspecified behavior, or even SQL exceptions could be raised.</p>
</li>
<li>
<p>You can also roll back to a specified savepoint. Refer to <a href="#i1006439">&#34;Using Savepoints&#34;</a>.</p>
</li>
<li>
<p>All DDL statements in Oracle SQL syntax include an implicit <code>COMMIT</code> operation. There is no special SQLJ functionality in this regard. Such statements follow standard Oracle SQL rules.</p>
</li>
<li>
<p>If auto-commit mode is off and you close a connection context instance from a client application, then any changes since your last <code>COMMIT</code> will be committed, unless you close the connection context instance with <code>KEEP_CONNECTION</code>. Refer to <a href="alangfea.htm#i1007208">&#34;Closing Shared Connections&#34;</a> for more information.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006416"></a>
<div id="JSQLJ229" class="sect2">
<h3 class="sect2">Effect of <a id="sthref118"></a><a id="sthref119"></a><a id="sthref120"></a><a id="sthref121"></a>Commits and Rollbacks on Iterators and Result Sets</h3>
<p><code>COMMIT</code> and <code>ROLLBACK</code> operations do <span class="italic">not</span> affect open result sets and iterators. The result sets and iterators will still be open. Usually, all that is relevant to their content is the state of the database at the time of execution of the <code>SELECT</code> statements that populated them.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An exception to this is if you declared an iterator class with <code>sensitivity=SENSITIVE</code>. In this case, changes to the underlying result set may be seen whenever the iterator is scrolled outside of its window size. For more information about scrollable iterators, refer to <a href="alangfea.htm#i1006751">&#34;Scrollable Iterators&#34;</a>. For more information about the underlying scrollable result sets, refer to the <a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a>.</div>
<p>This also applies to <code>UPDATE</code>, <code>INSERT</code>, and <code>DELETE</code> statements that are executed after the <code>SELECT</code> statements. Execution of these statements does not affect the contents of open result sets and iterators.</p>
<p>Consider a situation where you <code>SELECT</code>, then <code>UPDATE</code>, and then <code>COMMIT</code>. A nonsensitive result set or iterator populated by the <code>SELECT</code> statement will be unaffected by the <code>UPDATE</code> and <code>COMMIT</code>.</p>
<p>As a further example, consider a situation where you <code>UPDATE</code>, then <code>SELECT</code>, and then <code>ROLLBACK</code>. A nonsensitive result set or iterator populated by the <code>SELECT</code> will still contain the updated data, regardless of the subsequent <code>ROLLBACK</code>.</p>
</div>
<!-- class="sect2" -->
<a id="i1006439"></a>
<div id="JSQLJ230" class="sect2">
<h3 class="sect2">Using Save<a id="sthref122"></a><a id="sthref123"></a><a id="sthref124"></a>points</h3>
<p>The JDBC 3.0 specification added support for savepoints. A <span class="bold">savepoint</span> is a defined point in a transaction that you can roll back to, if desired, instead of rolling back the entire transaction. The savepoint is the point in the transaction where the <code>SAVEPOINT</code> statement appears.</p>
<p>In Oracle9<span class="italic">i</span> Database Release 2 (9.2), SQLJ first included Oracle-specific syntax to support savepoints. In Oracle Database 12<span class="italic">c</span> Release 1 (12.1), SQLJ adds support for ISO SQLJ standard savepoint syntax.</p>
<p class="subhead2"><a id="JSQLJ231"></a>Sup<a id="sthref125"></a>port for ISO SQLJ Standard Savepoint Syntax</p>
<p>In ISO SQLJ standard syntax, use a string literal in a <code>SAVEPOINT</code> statement to designate a name for a savepoint. This can be done as follows:</p>
<pre>#sql { SAVEPOINT savepoint1 };
</pre>
<p>If you want to roll back changes to that savepoint, then you can refer to the specified name later in a <code>ROLLBACK TO</code> statement, as follows:</p>
<pre>#sql { ROLLBACK TO savepoint1 };
</pre>
<p>Use a <code>RELEASE SAVEPOINT</code> statement if you no longer need the savepoint:</p>
<pre>#sql { RELEASE SAVEPOINT savepoint1 };
</pre>
<p>Savepoints are saved in the SQLJ execution context, which has methods that parallel the functionality of these three statements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006403">&#34;Savepoint Methods&#34;</a></div>
<p>Because any <code>COMMIT</code> operation ends the transaction, this also releases all savepoints of the transaction.</p>
<p class="subhead2"><a id="JSQLJ232"></a>Ora<a id="sthref126"></a>cle SQLJ Savepoint Syntax</p>
<p>In addition to the ISO SQLJ standard syntax, the following Oracle-specific syntax for savepoints is supported. Note that the Oracle syntax uses string host expressions, rather than string literals.</p>
<p>You can set a savepoint as follows:</p>
<pre>#sql { SET SAVEPOINT :<span class="italic">savepoint</span> };
</pre>
<p>The host expression, <code><span class="codeinlineitalic">savepoint</span></code> in this example, is a variable that specifies the name of the savepoint as a Java <code>String</code>.</p>
<p>You can roll back to a savepoint as follows:</p>
<pre>#sql { ROLLBACK TO :<span class="italic">savepoint</span> };
</pre>
<p>To release a savepoint, use the following SQLJ statement:</p>
<pre>#sql { RELEASE :<span class="italic">savepoint</span> };
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle-specific syntax will continue to be supported for backward compatibility. Note the following differences between Oracle syntax and ISO SQLJ standard syntax:
<ul>
<li>
<p>Oracle syntax takes string variables rather than string literals.</p>
</li>
<li>
<p>Oracle syntax uses <code>SET SAVEPOINT</code> instead of <code>SAVEPOINT</code>.</p>
</li>
<li>
<p>Oracle syntax uses <code>RELEASE</code> instead of <code>RELEASE SAVEPOINT</code>.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008366"></a>
<div id="JSQLJ233" class="sect1">
<h2 class="sect1">Summary: First Steps in SQLJ Code</h2>
<p>The best way to summarize the SQLJ executable statement features and functionality discussed to this point is by examining short but complete programs. This section presents two such examples.</p>
<p>The first example, presented one step at a time and then again in its entirety, uses a <code>SELECT INTO</code> statement to perform a single-row query of two columns from a table of employees. If you want to run the example, ensure that you change the parameters in the <code>connect.properties</code> file to settings that will let you connect to an appropriate database.</p>
<p>The second example, slightly more complicated, will make use of a SQLJ iterator for a multi-row query.</p>
<p class="subhead2"><a id="JSQLJ234"></a>Import <a id="sthref127"></a>Required Classes</p>
<p>Import any JDBC or SQLJ packages you will need. You will need at least some of the classes in the <code>java.sql</code> package:</p>
<pre>import java.sql.*;
</pre>
<p>You may not need all the <code>java.sql</code> package. Key classes are <code>java.sql.SQLException</code> and any classes that you refer to explicitly. For example, <code>java.sql.Date</code> and <code>java.sql.ResultSet</code>.</p>
<p>You will need the following package for the <code>Oracle</code> class, which you typically use to instantiate <code>DefaultContext</code> objects and establish your default connection:</p>
<pre>import oracle.sqlj.runtime.*;
</pre>
<p>If you will be using any SQLJ run-time classes directly in your code, then import the following packages:</p>
<pre>import sqlj.runtime.*;
import sqlj.runtime.ref.*;
</pre>
<p>However, even if your code does not use any SQLJ run-time classes directly, it will be sufficient to have them in the <code>CLASSPATH</code>.</p>
<p>Key run-time classes include <code>ResultSetIterator</code> and <code>ExecutionContext</code> in the <code>sqlj.runtime</code> package and <code>DefaultContext</code> in the <code>sqlj.runtime.ref</code> package.</p>
<p class="subhead2"><a id="JSQLJ235"></a>Register JDBC Drivers and Set Default Connection</p>
<p>Declare the <code>SimpleExample</code> class with a constructor that uses the static <code>Oracle.connect()</code> method to set the default connection. This also registers Oracle JDBC drivers.</p>
<p>This uses a signature of <code>connect()</code> that takes the URL, user name, and password from the <code>connect.properties</code> file. An example of this file is in the directory <code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/sqlj/demo</code> and also in <a href="getstart.htm#i1005914">&#34;Set Up the Run-Time Connection&#34;</a>.</p>
<pre>public class SimpleExample {

  public SimpleExample() throws SQLException {
    // Set default connection (as defined in connect.properties).
    Oracle.connect(getClass(), &#34;connect.properties&#34;);
  }
</pre>
<p class="subhead2"><a id="i1006513"></a><a id="JSQLJ236"></a>Set Up <a id="sthref128"></a>Exception Handling</p>
<p>Create a <code>main()</code> that calls the <code>SimpleExample</code> constructor and then sets up a <code>try/catch</code> block to handle any SQL exceptions thrown by the <code>runExample()</code> method, which performs the real work of this application:</p>
<pre>...
public static void main (String [] args) {
    
   try {
      SimpleExample o1 = new SimpleExample();
      o1.runExample();
   }
   catch (SQLException ex) {
      System.err.println(&#34;Error running the example: &#34; + ex);
   }
}
...
</pre>
<p>You can also use a <code>try/catch</code> block inside a <code>finally</code> clause when you close the connection, presuming the <code>finally</code> clause is not already inside a <code>try/catch</code> block in case of SQL exceptions:</p>
<pre>finally
{
   try { Oracle.close(); } catch(SQLException ex) {...}
}
</pre>
<p class="subhead2"><a id="i1006540"></a><a id="JSQLJ237"></a>Set Up Host Variables, Execute SQLJ Clause, Process Results</p>
<p>Create a <code>runExample()</code> method that performs the following:</p>
<ol>
<li>
<p>Throws any SQL exceptions to the <code>main()</code> method for processing.</p>
</li>
<li>
<p>Declares Java host variables.</p>
</li>
<li>
<p>Executes a SQLJ clause that binds the Java host variables into an embedded <code>SELECT</code> statement and selects the data into the host variables.</p>
</li>
<li>
<p>Prints the results.</p>
</li>
</ol>
<p>The code for this method is as follows:</p>
<pre>void runExample() throws SQLException {
     
     System.out.println( &#34;Running the example--&#34; );
     
     // Declare two Java host variables--
     Float salary;
     String empname;

     // Use SELECT INTO statement to execute query and retrieve values.
      #sql { SELECT first_name, salary INTO :empname, :salary FROM employees
             WHERE employee_id = 7499 };
     
     // Print the results--
     System.out.println(&#34;Name is &#34; + empname + &#34;, and Salary is &#34; + salary);
  }
}    // Closing brace of SimpleExample class
</pre>
<p>This example declares <code>salary</code> and <code>empname</code> as Java host variables. The SQLJ clause then selects data from the <code>first_name</code> and <code>salary</code> columns of the <code>employees</code> table and places the data into the host variables. Finally, the values of <code>salary</code> and <code>empname</code> are printed.</p>
<p>Note that this <code>SELECT</code> statement could select only one row of the <code>employees</code> table, because the <code>employee_id</code> column in the <code>WHERE</code> clause is the primary key of the table.</p>
<p class="subhead2"><a id="JSQLJ238"></a>Example of <a id="sthref129"></a>Single-Row Query using SELECT INTO</p>
<p>This section presents the entire <code>SimpleExample</code> class from the previous step-by-step sections. Because this is a single-row query, no iterator is required.</p>
<pre>// Import SQLJ classes:
import sqlj.runtime.*;
import sqlj.runtime.ref.*;
import oracle.sqlj.runtime.*;

// Import standard java.sql package:
import java.sql.*;

public class SimpleExample {

  public SimpleExample() throws SQLException {
    // Set default connection (as defined in connect.properties).
    Oracle.connect(getClass(), &#34;connect.properties&#34;);
  }

  public static void main (String [] args) throws SQLException {
    
    try {
      SimpleExample o1 = new SimpleExample();
      o1.runExample();
    }
    catch (SQLException ex) {
      System.err.println(&#34;Error running the example: &#34; + ex);
    }
  }

  finally
  {
     try { Oracle.close(); } catch(SQLException ex) {...}
  }

  void runExample() throws SQLException {
     
     System.out.println( &#34;Running the example--&#34; );
     
     // Declare two Java host variables--
     Float salary;
     String empname;

     // Use SELECT INTO statement to execute query and retrieve values.
        #sql { SELECT first_name, salary INTO :empname, :salary FROM employees
              WHERE employee_id = 7499 };
     
     // Print the results--
     System.out.println(&#34;Name is &#34; + empname + &#34;, and Salary is &#34; + salary);
  }
}
</pre>
<p class="subhead2"><a id="JSQLJ239"></a>Set Up a <a id="sthref130"></a>Named Iterator</p>
<p>This example builds on the previous example by adding a named iterator and using it for a multiple-row query.</p>
<p>First, declare the iterator class. Use object types <code>Integer</code> and <code>Float</code>, instead of primitive types <code>int</code> and <code>float</code>, wherever there is the possibility of <code>NULL</code> values.</p>
<pre>#sql iterator EmpRecs(
      int empno,       // This column cannot be null, so int is OK.
                       // (If null is possible, use Integer.)
      String ename,
      String job,
      Integer mgr,
      Date hiredate,
      Float sal,
      Float comm,
      int deptno);
</pre>
<p>Next, instantiate the <code>EmpRecs</code> class and populate it with query results.</p>
<pre>EmpRecs employees;

#sql employees = { SELECT employee_id, first_name, job_id, manager_id, hire_date,
                   salary, commission_pct, department_tno FROM employees };
</pre>
<p>Then, use the <code>next()</code> method of the iterator to print the results.</p>
<pre>    while (employees.next())  {
      System.out.println( &#34;Name:       &#34; + employees.first_name() );
      System.out.println( &#34;EMPNO:      &#34; + employees.employee_id() );
      System.out.println( &#34;Job:        &#34; + employees.job_id() );
      System.out.println( &#34;Manager:    &#34; + employees.manager_id) );
      System.out.println( &#34;Date hired: &#34; + employees.hire_date() );
      System.out.println( &#34;Salary:     &#34; + employees.salary() );
      System.out.println( &#34;Commission: &#34; + employees.commission_pct() );
      System.out.println( &#34;Department: &#34; + employees.department_no() );
      System.out.println();
    }
</pre>
<p>Finally, close the iterator.</p>
<pre>employees.close();
</pre>
<p class="subhead2"><a id="JSQLJ240"></a>Example of <a id="sthref131"></a>Multiple-Row Query Using Named Iterator</p>
<p>This example uses a named iterator for a multiple-row query that selects several columns of data from a table of employees.</p>
<p>Apart from use of the named iterator, this example is conceptually similar to the previous single-row query example.</p>
<pre>// Import SQLJ classes:
import sqlj.runtime.*;
import sqlj.runtime.ref.*;
import oracle.sqlj.runtime.*;

// Import standard java.sql package:
import java.sql.*;

// Declare a SQLJ iterator.
// Use object types (Integer, Float) for mgr, sal, And comm rather
// than primitive types to allow for possible null selection.

#sql iterator EmpRecs(
      int empno,       // This column cannot be null, so int is OK.
                       // (If null is possible, Integer is required.)
      String ename,
      String job,
      Integer mgr,
      Date hiredate,
      Float sal,
      Float comm,
      int deptno);

// This is the application class.  
public class EmpDemo1App {

   public EmpDemo1App() throws SQLException {
      // Set default connection (as defined in connect.properties).
      Oracle.connect(getClass(), &#34;connect.properties&#34;);
   }

  public static void main(String[] args) {

    try {
      EmpDemo1App app = new EmpDemo1App();
      app.runExample();
    }
    catch( SQLException exception ) {
      System.err.println( &#34;Error running the example: &#34; + exception );
    }
  }

  finally
  {
     try { Oracle.close(); } catch(SQLException ex) {...}
  }

  void runExample() throws SQLException  {
    System.out.println(&#34;\nRunning the example.\n&#34; );

    // The query creates a new instance of the iterator and stores it in
    // the variable &#39;employees&#39; of type &#39;EmpRecs&#39;.  SQLJ translator has
    // automatically declared the iterator so that it has methods for
    // accessing the rows and columns of the result set.

    EmpRecs employees;

    #sql employees = { SELECT employee_id, first_name, job_id, manager_id, hire_date,
                       salary, commission_pct, department_no FROM employees };

    // Print the result using the iterator.

    // Note how the next row is accessed using method &#39;next()&#39;, and how
    // the columns can be accessed with methods that are named after the
    // actual database column names.

    while (employees.next())  {
      System.out.println( &#34;Name:       &#34; + employees.first_name() );
      System.out.println( &#34;EMPNO:      &#34; + employees.employee_id() );
      System.out.println( &#34;Job:        &#34; + employees.job_id() );
      System.out.println( &#34;Manager:    &#34; + employees.manager_id() );
      System.out.println( &#34;Date hired: &#34; + employees.hire_date() );
      System.out.println( &#34;Salary:     &#34; + employees.salary() );
      System.out.println( &#34;Commission: &#34; + employees.commission_pct() );
      System.out.println( &#34;Department: &#34; + employees.department_no() );
      System.out.println();
    }

    // You must close the iterator when it&#39;s no longer needed.
    employees.close() ;
  }
}
</pre></div>
<!-- class="sect1" -->
<a id="i1006746"></a>
<div id="JSQLJ241" class="sect1">
<h2 class="sect1">Oracle-Spe<a id="sthref132"></a>cific Code Generation (No Profiles)</h2>
<p>Throughout this manual there is general and standard discussion of the SQLJ run-time layer and SQLJ profiles. However, the Oracle SQLJ implementation, by default, generates Oracle-specific code with direct calls to Oracle JDBC driver instead of generating ISO SQLJ standard code that calls the SQLJ run time. With Oracle-specific code generation, there are no profile files, and the role of the SQLJ run-time layer is greatly reduced during program execution. Oracle-specific code supports all Oracle-specific extended features.</p>
<p>Code generation is determined through the SQLJ translator <code>-codegen</code> option. The default setting for Oracle-specific code generation is <code>-codegen=oracle</code>. Alternatively, you can set <code>-codegen=iso</code> for code generation according to the ISO SQLJ standard.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007494">&#34;Code Generation (-codegen)&#34;</a>.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1006823">Code Considerations and Limitations with Oracle-Specific Code Generation</a></p>
</li>
<li>
<p><a href="#i1006906">SQLJ Usage Changes with Oracle-Specific Code Generation</a></p>
</li>
<li>
<p><a href="#i1006945">Server-Side Considerations with Oracle-Specific Code Generation</a></p>
</li>
<li>
<p><a href="#i1006780">Advantages and Disadvantages of Oracle-Specific Code Generation</a></p>
</li>
</ul>
<a id="i1006823"></a>
<div id="JSQLJ243" class="sect2">
<h3 class="sect2">Code Consi<a id="sthref133"></a>derations and Limitations with Oracle-Specific Code Generation</h3>
<p>When coding a SQLJ application where Oracle-specific code generation will be used, be aware of the following programming considerations and restrictions:</p>
<ul>
<li>
<p>To use a nondefault statement cache size, you must include appropriate method calls in your code, because Oracle customizer <code>stmtcache</code> option is unavailable. Refer to <a href="#i1006906">&#34;SQLJ Usage Changes with Oracle-Specific Code Generation&#34;</a>.</p>
</li>
<li>
<p>Do not mix Oracle-specific generated code with ISO SQLJ standard generated code in the same application. However, if Oracle-specific code and ISO SQLJ standard code <span class="italic">must</span> share the same connection, do one of the following:</p>
<ul>
<li>
<p>Ensure that the Oracle-specific code and ISO standard code use different SQLJ execution context instances. Refer to <a href="alangfea.htm#i1006207">&#34;Execution Contexts&#34;</a> for information about SQLJ execution contexts.</p>
</li>
<li>
<p>Place a transaction boundary, that is, as a manual <code>COMMIT</code> or <code>ROLLBACK</code> statement, between the two kinds of code.</p>
</li>
</ul>
<p>This limitation regarding mixing code is especially significant for server-side code, because all Java code running in a given session uses the same JDBC connection and SQLJ connection context.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006945">&#34;Server-Side Considerations with Oracle-Specific Code Generation&#34;</a></div>
</li>
<li>
<p>Do not rely on side effects in parameter expressions when values are returned from the database. Oracle-specific code generation does not create temporary variables for evaluation of <code>OUT</code> parameters, <code>IN OUT</code> parameters, <code>SELECT INTO</code> variables, or return arguments on SQL statements.</p>
<p>For example, avoid statements such as the following:</p>
<pre>#sql { SELECT * FROM EMPLOYEES INTO :(x[i++]), :(f_with_sideffect()[i++]),
                              :(a.b[i]) };
</pre>
<p>or:</p>
<pre>#sql x[i++] = { VALUES f(:INOUT (x[i++]), :OUT (f_with_sideffect())) };
</pre>
<p>Evaluation of arguments is performed <span class="italic">in place</span> in the generated code. This may result in different behavior than when evaluation is according to ISO SQLJ standards.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="blangfea.htm#i1006346">&#34;Evaluation of Java Expressions at Run Time&#34;</a> and <a href="blangfea.htm#i1006398">&#34;Examples of Evaluation of Java Expressions at Run Time (ISO Code Generation)&#34;</a></div>
</li>
<li>
<p>Type maps for Oracle object functionality assumes that the corresponding Java classes implement the <code>java.sql.SQLData</code> interface, given that JPublisher-generated Java classes do not otherwise require a type map. If you use type maps for Oracle object functionality, then your iterator declarations and connection context declarations must specify the same type maps. Specify this through the <code>with</code> clause.</p>
<p>For example, if you declare a connection context class as follows:</p>
<pre>#sql context TypeMapContext with (typeMap=&#34;MyTypeMap&#34;);
</pre>
<p>and you populate an iterator instance from a SQLJ statement that uses an instance of this connection context class, as follows:</p>
<pre>TypeMapContext tmc = new TypeMapContext(...);
...
MyIterator it;
#sql [tmc] it = ( SELECT pers, addr FROM tab WHERE ...);
</pre>
<p>then the iterator declaration is required to have specified the same type map, as follows:</p>
<pre>#sql iterator MyIterator with (typeMap=&#34;MyTypeMap&#34;) 
              (Person pers, Address addr);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="objcoll.htm#i1005834">&#34;Custom Java Class Requirements&#34;</a> and <a href="blangfea.htm#CBBBBJEC">&#34;Declaration WITH Clause&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The reason for this restriction is that with Oracle-specific code generation, all iterator getter methods are fully generated as Oracle JDBC calls during translation. To generate the proper calls, the SQLJ translator must know whether an iterator will be used with a particular type map.</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006906"></a>
<div id="JSQLJ244" class="sect2">
<h3 class="sect2">SQLJ Us<a id="sthref134"></a>age Changes with Oracle-Specific Code Generation</h3>
<p>Some options that were previously available only as Oracle customizer options are useful with Oracle-specific code generation as well. Because profile customization is not applicable with Oracle-specific code generation, these options have been made available through other means.</p>
<p>To alter the statement cache size or disable statement caching when generating Oracle-specific code, use method calls in your code instead of using the customizer <code>stmtcache</code> option. The <code>sqlj.runtime.ref.DefaultContext</code> class, as well as any connection context class you declare, now has the following static methods:</p>
<ul>
<li>
<p><code>setDefaultStmtCacheSize(int)</code></p>
</li>
<li>
<p><code>int getDefaultStmtCacheSize()</code></p>
</li>
</ul>
<p>It also has the following instance methods:</p>
<ul>
<li>
<p><code>setStmtCacheSize(int)</code></p>
</li>
<li>
<p><code>int getStmtCacheSize()</code></p>
</li>
</ul>
<p>By default, statement caching is enabled.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1005618">&#34;Statement Caching&#34;</a></div>
<p>In addition, the following options are available as front-end Oracle SQLJ translator options as well as Oracle customizer options:</p>
<ul>
<li>
<p><code>-optcols</code>: Enable iterator column type and size definitions to optimize performance.</p>
</li>
<li>
<p><code>-optparams</code>: Enable parameter size definitions to optimize JDBC resource allocation. This option is used in conjunction with <code>optparamdefaults</code>.</p>
</li>
<li>
<p><code>-optparamdefaults</code>: Set parameter size defaults for particular data types. This option is used in conjunction with <code>optparams</code>.</p>
</li>
<li>
<p><code>-fixedchar</code>: Enable <code>CHAR</code> comparisons with blank padding for <code>WHERE</code> clauses.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#BCEGHEDB">&#34;Options for Code Generation, Optimizations, and CHAR Comparisons&#34;</a></div>
<p>Be aware of the following:</p>
<ul>
<li>
<p>Use the <code>-optcols</code> option only if you are using online semantics-checking, where you have used the SQLJ translator <code>-user</code>, <code>-password</code>, and <code>-url</code> options appropriately to request a database connection during translation.</p>
</li>
<li>
<p>The functionality of the <code>-optcols</code>, <code>-optparams</code>, and <code>-optparamdefaults</code> options, including default values, is the same as for the corresponding customizer options.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006945"></a>
<div id="JSQLJ245" class="sect2">
<h3 class="sect2">Server-Si<a id="sthref135"></a>de Considerations with Oracle-Specific Code Generation</h3>
<p>Consider the following if your SQLJ code will run in the server:</p>
<ul>
<li>
<p>The server-side SQLJ translator no longer supports ISO standard generated code. SQLJ source code that is loaded into the server and compiled there will always be translated with the default <code>-codegen=oracle</code> setting.</p>
<p>Therefore, to use ISO standard generated code in the server, you must translate and compile the SQLJ code on a client and then load the individual components into the server.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="inserver.htm#i1005719">&#34;Translating SQLJ Source on a Client and Loading Components&#34;</a></div>
</li>
<li>
<p>The caution against mixing Oracle-specific generated code with ISO standard generated code applies to server-side Java code that calls a Java stored procedure or stored function, even if the stored procedure is invoked through a PL/SQL wrapper. This constitutes a recursive call-in. By default, the <code>ExecutionContext</code> object is shared by both the calling module and the called module. Therefore, both modules should be translated with the same <code>-codegen</code> setting.</p>
<p>If you want to ensure interoperability with code that has been translated with ISO standard code generation, then it is advisable to explicitly instantiate execution context instances, as in the following example:</p>
<pre>public static method() throws SQLException
{
   Execution Context ec = new ExecutionContext();
   ...
   try {
      ...
      #sql [ec] { <span class="italic">SQL operation</span> };
      ...
   } finally { ec.close(); }
}
</pre></li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
To avoid resource leakage when using an explicit <code>ExecutionContext</code> instance, ensure that you use the <code>close()</code> method, as shown in this example.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006823">&#34;Code Considerations and Limitations with Oracle-Specific Code Generation&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006780"></a>
<div id="JSQLJ246" class="sect2">
<h3 class="sect2">Advantag<a id="sthref136"></a><a id="sthref137"></a>es and Disadvantages of Oracle-Specific Code Generation</h3>
<p>Oracle-specific code generation offers following advantages over ISO standard code generation:</p>
<ul>
<li>
<p>Applications run more efficiently. The code calls JDBC application programming interfaces (APIs) directly, placing run-time performance directly at the JDBC level. The role of the intermediate SQLJ run-time layer is greatly reduced during program execution.</p>
</li>
<li>
<p>Applications are smaller in size.</p>
</li>
<li>
<p>No profile files (<code>.ser</code>) are produced. This is especially convenient if you are loading a translated application into the database or porting it to another system, because there are fewer components.</p>
</li>
<li>
<p>Translation is faster, because there is no profile customization step.</p>
</li>
<li>
<p>During execution, Oracle SQLJ run time and Oracle JDBC driver use the same statement cache resources, so partitioning resources between the two is unnecessary.</p>
</li>
<li>
<p>Having the SQL-specific information appear in the Java class files instead of in separate profile files avoids potential security issues.</p>
</li>
<li>
<p>You need not have to rewrite your code to take advantage of possible future Oracle JDBC performance enhancements, such as enhancements being considered for execution of static SQL code. Future releases of Oracle SQLJ translator will handle this automatically.</p>
</li>
<li>
<p>The use of Java reflection at run time is eliminated, and thus, provides full portability to browser environments.</p>
</li>
</ul>
<p>However. there are a few disadvantages:</p>
<ul>
<li>
<p>Oracle-specific generated code may not be portable to generic JDBC platforms.</p>
</li>
<li>
<p>Profile-specific functionality is not available. For example, you cannot perform customizations at a later date to use Oracle customizer harness <code>-debug</code>, <code>-verify</code>, and <code>-print</code> options.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="profcust.htm#i634663">&#34;Customizer Harness Options for Connections&#34;</a> and <a href="profcust.htm#i635528">&#34;AuditorInstaller Customizer for Debugging&#34;</a></div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABGCJHI"></a>
<div id="JSQLJ247" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">ISO Standard Code Generation</h2>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABBEIDA">Environment Requirements for ISO Standard Code Generation</a></p>
</li>
<li>
<p><a href="#CJAJGCFF">SQLJ Translator and SQLJ Run Time</a></p>
</li>
<li>
<p><a href="#i1005661">SQLJ Profiles</a></p>
</li>
<li>
<p><a href="#BABIBHCF">SQLJ Translation Steps</a></p>
</li>
<li>
<p><a href="#BABFJCDF">Summary of Translator Input and Output</a></p>
</li>
<li>
<p><a href="#BABFDJHH">SQLJ Run-Time Processing</a></p>
</li>
<li>
<p><a href="#BABCEIBJ">Deployment Scenarios</a></p>
</li>
</ul>
<a id="BABBEIDA"></a>
<div id="JSQLJ248" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Environment Requirements for ISO Standard Code Generation</h3>
<p>The Oracle SQLJ implementation, by default, generates Oracle-specific code with direct calls to Oracle JDBC driver instead of generating ISO standard code that calls the SQLJ run time. The following is a typical environment setup for ISO standard code generation:</p>
<ul>
<li>
<p>SQLJ code generation: <code>-codegen=iso</code></p>
</li>
<li>
<p>SQLJ translation library: <code>translator.jar</code></p>
</li>
<li>
<p>SQLJ run-time library: <code>runtime12.jar</code> with JDK 6 or JDK 7, and Oracle Database 12<span class="italic">c</span> Release 1 (12.1)</p>
</li>
<li>
<p>JDBC drivers: Oracle Database 12<span class="italic">c</span> Release 1 (12.1)<code>ojdbc6.jar</code> or <code>ojdbc7.jar</code></p>
</li>
<li>
<p>JDK version: JDK 6 or JDK 7</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CJAJGCFF"></a>
<div id="JSQLJ249" class="sect2">
<h3 class="sect2">SQLJ <a id="sthref138"></a>Translator and SQLJ <a id="sthref139"></a>Run Time</h3>
<p>The following section describes the differences in Oracle SQLJ implementation in case of ISO standard code generation:</p>
<ul>
<li>
<p>SQLJ translator: Along with the <code>.java</code> file, the translator also produces one or more SQLJ profiles for ISO standard code generation. These profiles contain information about the embedded SQL operations. SQLJ then automatically invokes a Java compiler to produce <code>.class</code> files from the <code>.java</code> file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="overview.htm#BABJACEE">&#34;SQLJ Translator&#34;</a></div>
</li>
<li>
<p>SQLJ run time: For ISO standard code generation, the SQLJ run time implements the desired actions of the SQL operations by accessing the database using a JDBC driver. The generic ISO SQLJ standard does not require the SQLJ run time to use a JDBC driver to access the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="overview.htm#BABBADJF">&#34;SQLJ Run Time&#34;</a></div>
</li>
</ul>
<p>In addition to the translator and run time, there is a component known as the <a id="sthref140"></a><span class="bold"><a id="sthref141"></a>customizer</span> that plays a role. A customizer tailors SQLJ profiles for a particular database implementation and vendor-specific features and data types. By default, for ISO standard code, the SQLJ front end invokes an Oracle customizer to tailor your profiles for Oracle Database instance and Oracle-specific features and data types.</p>
<p>When you use Oracle customizer during translation, your application will require the SQLJ run time and an Oracle JDBC driver when it runs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Since Oracle Database 10<span class="italic">g</span> Release 1, only Oracle JDBC drivers are supported with SQLJ.</div>
</div>
<!-- class="sect2" -->
<a id="i1005661"></a>
<div id="JSQLJ250" class="sect2">
<h3 class="sect2">SQLJ <a id="sthref142"></a>Profiles</h3>
<p>With ISO standard code generation, SQLJ profiles are serialized Java resources or classes generated by the SQLJ translator, which contain details about the embedded SQL statements. The translator creates these profiles. Then, depending on the translator option settings, it either serializes the profiles and puts them into binary resource files or puts them into <code>.class</code> files.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CJADGFGD">Overview of Profiles</a></p>
</li>
<li>
<p><a href="#CJAJJIDA">Binary Portability</a></p>
</li>
</ul>
<a id="CJADGFGD"></a>
<div id="JSQLJ251" class="sect3">
<h4 class="sect3">Overview of Profiles</h4>
<p>SQLJ profiles are used in ISO standard code for implementing the embedded SQL operations in SQLJ executable statements. Profiles contain information about the SQL operations and the types and modes of data being accessed. A profile consists of a collection of entries, where each entry maps to one SQL operation. Each entry fully specifies the corresponding SQL operation, describing each of the parameters used in processing this instruction.</p>
<p>SQLJ generates a profile for each connection context class in your application, where each connection context class corresponds to a particular set of SQL entities you use in your database operations. There is one default connection context class, and you can declare additional classes. The ISO SQLJ standard requires that the profiles be of standard format and content. Therefore, for your application to use vendor-specific extended features, your profiles must be customized. By default, this occurs automatically, with your profiles being customized to use Oracle-specific extended features.</p>
<p>Profile customization enables vendors to add value in the following ways:</p>
<ul>
<li>
<p>Vendors can support their own specific data types and SQL syntax. For example, Oracle customizer maps standard JDBC <code>PreparedStatement</code> method calls in translated SQLJ code to <code>OraclePreparedStatement</code> method calls, which provide support for Oracle type extensions.</p>
</li>
<li>
<p>Vendors can improve performance through specific optimizations.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>By default, SQLJ profile file names have the <code>.ser</code> extension, but this does not mean that all <code>.ser</code> files are profiles. Other serialized objects can use this extension, and a SQLJ program unit can use serialized objects other than its profiles. Optionally, profiles can be converted to <code>.class</code> files instead of <code>.ser</code> files.</p>
</li>
<li>
<p>A SQLJ profile is not produced if there are no SQLJ executable statements in the source code.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CJAJJIDA"></a>
<div id="JSQLJ252" class="sect3">
<h4 class="sect3">Binary <a id="sthref143"></a><a id="sthref144"></a>Portability</h4>
<p>SQLJ-generated profile files support binary portability. That is, you can port them as is and use them with other kinds of databases or in other environments, if you have not used vendor-specific data types or features. This is true for generated <code>.class</code> files as well.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABIBHCF"></a>
<div id="JSQLJ253" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQLJ Translation Steps</h3>
<p>For ISO standard code generation (<code>-codegen=iso</code>), the translator processes the SQLJ source code, converts SQL operations to SQLJ run-time calls, and generates Java output code and one or more SQLJ profiles. A separate profile is generated for each connection context class in the source code, where a different connection context class is typically used for each interrelated set of SQL entities that is used in the operations.</p>
<p>Generated Java code is put into a <code>.java</code> output file containing the following:</p>
<ul>
<li>
<p>Any class definitions and Java code from the <code>.sqlj</code> source file</p>
</li>
<li>
<p>Class definitions created as a result of the SQLJ iterator and connection context declarations</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="blangfea.htm#i1005585">&#34;Overview of SQLJ Declarations&#34;</a></div>
</li>
<li>
<p>A class definition for a specialized class known as the <a id="sthref145"></a><span class="bold">profile-keys</span> class that SQLJ generates and uses in conjunction with the profiles (for ISO standard SQLJ code generation only)</p>
</li>
<li>
<p>Calls to the SQLJ run time to implement the actions of the embedded SQL operations</p>
</li>
</ul>
<p>Generated profiles contain information about all the embedded SQL statements in the SQLJ source code, such as actions to take, data types being manipulated, and tables being accessed. When the application is run, the SQLJ run time accesses the profiles to retrieve the SQL operations and passes them to the JDBC driver.</p>
<p>By default, profiles are put into <code>.ser</code> serialized resource files, but SQLJ can optionally convert the <code>.ser</code> files to <code>.class</code> files as part of the translation.</p>
<p>The compiler compiles the generated Java source file and produces Java <code>.class</code> files as appropriate. This includes a <code>.class</code> file for each class that is defined, each of the SQLJ declarations, and the profile-keys class. The JVM then invokes Oracle customizer or other specified customizer to customize the profiles generated.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transrun.htm#CHEJGJAB">&#34;Internal Translator Operations&#34;</a></div>
<p class="subhead2"><a id="JSQLJ254"></a>General SQLJ Notes</p>
<p>Consider the following when translating and running SQLJ applications for ISO specific code generation:</p>
<ul>
<li>
<p>Along with compiling existing <code>.java</code> files on the command line and making them available for type resolution, as for Oracle-specific code generation, you need to:</p>
<ul>
<li>
<p>Customize the existing profiles</p>
</li>
<li>
<p>Customize the Java Archive (JAR) files containing profiles</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1005569">&#34;Translator Command Line and Properties Files&#34;</a></div>
</li>
<li>
<p>SQLJ generates profiles and the profile-keys class only if your source code includes SQLJ executable statements.</p>
</li>
<li>
<p>If you use Oracle customizer during translation, then your application requires Oracle SQLJ run time and an Oracle JDBC driver when it runs, even if your code does not use Oracle-specific features. You can avoid this by specifying <code>-profile=false</code> when you translate, to bypass Oracle-specific customization.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABFJCDF"></a>
<div id="JSQLJ255" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Summary of Translator Input and Output</h3>
<p>We have seen what the SQLJ translator takes as input, what it produces as output, and where it places its output in case of Oracle-specific code generation. This section covers the same topics for ISO standard code generation:</p>
<ul>
<li>
<p><a href="#BABFGJAF">Translator Input</a></p>
</li>
<li>
<p><a href="#BABCJJEB">Translator Output</a></p>
</li>
<li>
<p><a href="#BABDIEJI">Output File Locations</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="overview.htm#CJAHHIGH">&#34;Summary of Translator Input and Output&#34;</a></div>
<a id="BABFGJAF"></a>
<div id="JSQLJ256" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Translator Input</h4>
<p>Similar to Oracle -specific code generation, the SQLJ translator takes one or more <code>.sqlj</code> source files as input, which can be specified on the command line. The name of the main <code>.sqlj</code> file is based on the public class it defines, if any, else on the first class it defines.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="overview.htm#CJAFJEAI">&#34;Translator Input&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="BABCJJEB"></a>
<div id="JSQLJ257" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Translator Output</h4>
<p>The translation step produces a Java source file for each <code>.sqlj</code> file in the application and at least one application profile for ISO standard code generation, presuming the source code uses SQLJ executable statements.</p>
<p>SQLJ generates Java source files and application profiles as follows:</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="overview.htm#CJAFHGHG">&#34;Translator Output&#34;</a></div>
<ul>
<li>
<p>Similar to Oracle-specific code generation, Java source files are <code>.java</code> files with the same base names as the <code>.sqlj</code> files.</p>
</li>
<li>
<p>The application profile files, if applicable, contain information about the SQL operations of the SQLJ application. There is one profile for each connection class that is used in the application. The profiles have names with the same base name as the main <code>.sqlj</code> file and the following extensions:</p>
<pre>_SJProfile0.ser
_SJProfile1.ser
_SJProfile2.ser
...
</pre>
<p>For example, for <code>MyClass.sqlj</code> the translator produces:</p>
<pre>MyClass_SJProfile0.ser
</pre>
<p>The <code>.ser</code> file extension indicates that the profiles are serialized. The <code>.ser</code> files are binary files.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>-ser2class</code> translator option instructs the translator to generate profiles as <code>.class</code> files instead of <code>.ser</code> files. Other than the file name extension, the naming is the same.</div>
</li>
</ul>
<p>Similar to the compilation step of Oracle-specific code generation, compiling the Java source file into multiple class files generates one <code>.class</code> file for each class defined in the <code>.sqlj</code> source file. But in case of ISO code generation, a <code>.class</code> file is also generated for a class known as the <a id="sthref146"></a><span class="bold">profile-keys</span> class that the translator generates and uses with the profiles to implement the SQL operations. Additional <code>.class</code> files are produced if you declare any SQLJ iterators or connection contexts. Also, like Oracle-specific code generation, separate <code>.class</code> files are produced for any inner classes or anonymous classes in the code.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="blangfea.htm#i1005585">&#34;Overview of SQLJ Declarations&#34;</a></div>
<p>The <code>.class</code> files are named as follows:</p>
<ul>
<li>
<p>Like Oracle-specific code generation, the class file for each class defined consists of the name of the class with the <code>.class</code> extension.</p>
</li>
<li>
<p>The profile-keys class that the translator generates is named according to the base name of the main <code>.sqlj</code> file, plus the following:</p>
<pre>_SJProfileKeys
</pre>
<p>So, the class file has the following extension:</p>
<pre>_SJProfileKeys.class
</pre>
<p>For example, for <code>MyClass.sqlj</code>, the translator together with the compiler produces:</p>
<pre>MyClass_SJProfileKeys.class
</pre></li>
<li>
<p>Like Oracle-specific code generation, the translator names iterator classes and connection context classes according to how you declare them.</p>
</li>
</ul>
<p>The customization step alters the profiles but produces no additional output.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transrun.htm#i1005877">&#34;Profile Customization (ISO Code Generation)&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is not necessary to reference SQLJ profiles or the profile-keys class directly. This is all handled automatically.</div>
</div>
<!-- class="sect3" -->
<a id="BABDIEJI"></a>
<div id="JSQLJ258" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Output File Locations</h4>
<p>The output file locations are the same for both Oracle-specific code generation and ISO standard code generation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="overview.htm#CJACIDFJ">&#34;Output File Locations&#34;</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABFDJHH"></a>
<div id="JSQLJ259" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQLJ Run-Time Processing</h3>
<p>This section discusses run-time processing for ISO standard code during program execution.</p>
<p>For ISO standard SQLJ applications, the SQLJ run time reads the profiles and creates connected profiles, which incorporate database connections. Then the following occurs each time the application must access the database:</p>
<ol>
<li>
<p>SQLJ-generated application code uses methods in a SQLJ-generated profile-keys class to access the connected profile and read the relevant SQL operations. There is a mapping between SQLJ executable statements in the application and SQL operations in the profile.</p>
</li>
<li>
<p>The SQLJ-generated application code calls the SQLJ run time, which reads the SQL operations from the profile.</p>
</li>
<li>
<p>The SQLJ run time calls the JDBC driver and passes the SQL operations to the driver.</p>
</li>
<li>
<p>The SQLJ run time passes any input parameters to the JDBC driver.</p>
</li>
<li>
<p>The JDBC driver executes the SQL operations.</p>
</li>
<li>
<p>If any data is to be returned, then the database sends it to the JDBC driver, which sends it to the SQLJ run time for use by your application.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
Passing input parameters can also be referred to as binding input parameters or binding host expressions. The terms host variables, host expressions, bind variables, and bind expressions are all used to describe Java variables or expressions that are used as input or output for SQL operations.</div>
</div>
<!-- class="sect2" -->
<a id="BABCEIBJ"></a>
<div id="JSQLJ260" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Deployment Scenarios</h3>
<p>We have discussed how to run Oracle-specific SQLJ code in the following scenarios:</p>
<ul>
<li>
<p>From an applet</p>
</li>
<li>
<p>In the server (optionally running the SQLJ translator in the server as well)</p>
</li>
</ul>
<p>There are a few considerations that you need to make while running your ISO standard code from an applet:</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="overview.htm#i1006184">&#34;Alternative Deployment Scenarios&#34;</a></div>
<ul>
<li>
<p>You must package all the SQLJ run-time packages with your applet. The packages are:</p>
<pre>sqlj.runtime
sqlj.runtime.ref
sqlj.runtime.profile
sqlj.runtime.profile.ref
sqlj.runtime.error
</pre>
<p>Also package the following if you used Oracle customization:</p>
<pre>oracle.sqlj.runtime
oracle.sqlj.runtime.error
</pre>
<p>These packages are included with your Oracle installation in one of several run-time libraries in the <code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/lib</code> directory.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="getstart.htm#i1005639">&#34;Requirements for Using the Oracle SQLJ Implementation&#34;</a></div>
</li>
<li>
<p>Some browsers, such as Netscape Navigator 4.x, do not support resource files with a <code>.ser</code> extension, which is the extension used by the SQLJ serialized object files that are used for profiles. However, the Sun Microsystems Java plug-in supports <code>.ser</code> files.</p>
<p>Alternatively, if you do not want to use the plug-in, then the Oracle SQLJ implementation offers the <code>-ser2class</code> option to convert <code>.ser</code> files to <code>.class</code> files during translation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007976">&#34;Conversion of .ser File to .class File (-ser2class)&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
This consideration <span class="italic">does not</span> apply to the default Oracle-specific code generation, where no profiles are produced.</div>
</li>
<li>
<p>Applets using Oracle-specific features require Oracle SQLJ run time to work. Oracle SQLJ run time consists of the classes in the SQLJ run-time library file under <code>oracle.sqlj.*</code>. Oracle SQLJ <code>runtime.jar</code> library requires the Java Reflection API, <code>java.lang.reflect.*</code>. Most browsers do not support the Reflection API or impose security restrictions, but the Sun Microsystems Java plug-in provides support for the Reflection API.</p>
<p>With ISO standard code generation, the following SQLJ language features always require the Java Reflection API, regardless of the version of the SQLJ run time you are using:</p>
<ul>
<li>
<p>The <code>CAST</code> statement</p>
</li>
<li>
<p><code>REF CURSOR</code> parameters or <code>REF CURSOR</code> columns being retrieved from the database as instances of a SQLJ iterator</p>
</li>
<li>
<p>Retrieval of <code>java.sql.Ref</code>, <code>Struct</code>, <code>Array</code>, <code>Blob</code>, or <code>Clob</code> objects</p>
</li>
<li>
<p>Retrieval of SQL objects as instances of Java classes implementing the <code>oracle.sql.ORAData</code> or <code>java.sql.SQLData</code> interfaces</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>An exception to the preceding is if you use SQLJ in a mode that is fully compatible with ISO. That is, if you use SQLJ in an environment that complies with J2EE and you translate and run your program with the SQLJ <code>runtime12ee.jar</code> library, and you employ connection context type maps as specified by ISO. In this case, instances of <code>java.sql.Ref</code>, <code>Struct</code>, <code>Array</code>, <code>Blob</code>, <code>Clob</code>, and <code>SQLData</code> are being retrieved without the use of reflection.</p>
</li>
<li>
<p>If you use Oracle-specific code generation, then you will eliminate the use of reflection in all of the instances listed.</p>
</li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<div id="JSQLJ261" class="sect1"><!-- infolevel="all" infotype="General" --><a id="sthref147"></a>
<h2 class="sect1">Oracle-Spe<a id="sthref148"></a>cific Code Generation Versus ISO Standard Code Generation</h2>
<p>The Oracle SQLJ implementation provides the option of Oracle-specific code generation, where Oracle JDBC calls are generated directly in the code. This is the default behavior. In the case of Oracle-specific code generation, you must be aware of the following:</p>
<ul>
<li>
<p>There are no profile files, and therefore, there is no customization step during translation.</p>
</li>
<li>
<p>At run time, SQL operations do not have to go through the SQLJ run-time layer, because JDBC calls, instead of the SQLJ run-time calls, are directly generated in the translated code.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1006982"></a>
<div id="JSQLJ262" class="sect1">
<h2 class="sect1">Requirements and Restrictions for Naming</h2>
<p>There are four areas to consider in discussing naming requirements, naming restrictions, and reserved words:</p>
<ul>
<li>
<p>The Java namespace, including additional restrictions imposed by SQLJ on the naming of local variables and classes</p>
</li>
<li>
<p>The SQLJ namespace</p>
</li>
<li>
<p>The SQL namespace</p>
</li>
<li>
<p>Source file names</p>
</li>
</ul>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABCIEII">Java Namespace: Local Variable and Class Naming Restrictions</a></p>
</li>
<li>
<p><a href="#BABGFFDC">SQLJ Namespace</a></p>
</li>
<li>
<p><a href="#BABIDDGH">SQL Namespace</a></p>
</li>
<li>
<p><a href="#BABFADJF">File Name Requirements and Restrictions</a></p>
</li>
</ul>
<a id="BABCIEII"></a>
<div id="JSQLJ263" class="sect2">
<h3 class="sect2">Java Namespace: <a id="sthref149"></a>Local Variable and Class Naming Restrictions</h3>
<p>The Java namespace applies to all standard Java statements and declarations, including the naming of Java classes and local variables. All standard Java naming restrictions apply, and you should avoid the use of Java reserved words.</p>
<p>In addition, SQLJ places minor restrictions on the naming of local variables and classes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Naming restrictions particular to host variables are discussed in <a href="blangfea.htm#i1006663">&#34;Restrictions on Host Expressions&#34;</a>.</div>
<p class="subhead2"><a id="JSQLJ264"></a>Local Variable Naming Restrictions</p>
<p>Some of the functionality of the SQLJ translator results in minor restrictions in naming local variables. The SQLJ translator replaces each SQLJ executable statement with a statement block, where the SQLJ executable statement is of the standard syntax:</p>
<pre>#sql { SQL operation };  
</pre>
<p>SQLJ may use temporary variable declarations within a generated statement block. The name of any such temporary variables will include the following prefix:</p>
<pre> __sJT_
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
There are two underscores at the beginning and one at the end.</div>
<p>The following declarations are examples of those that might occur in a SQLJ-generated statement block:</p>
<pre>int __sJT_index;
Object __sJT_key;
java.sql.PreparedStatement __sJT_stmt;
</pre>
<p>The string <code>__sJT_</code> is a reserved prefix for SQLJ-generated variable names. SQLJ programmers must not use this string as a prefix for the following:</p>
<ul>
<li>
<p>Names of variables declared in blocks that include executable SQL statements</p>
</li>
<li>
<p>Names of parameters to methods that contain executable SQL statements</p>
</li>
<li>
<p>Names of fields in classes that contain executable SQL statements, or whose subclasses or enclosed classes contain executable SQL statements</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ265"></a>Class Naming Restrictions</p>
<p>Be aware of the following minor restrictions in naming classes in SQLJ applications:</p>
<ul>
<li>
<p>You must not declare class names that may conflict with SQLJ internal classes. In particular, a top-level class cannot have a name of the following form, where <code>a</code> is the name of an existing class in the SQLJ application:</p>
<pre>a_SJb
</pre>
<p>where, <code>a</code> and <code>b</code> are legal Java identifiers.</p>
<p>For example, if your application class is <code>Foo</code> in file <code>Foo.sqlj</code>, then SQLJ generates a profile-keys class called <code>Foo_SJProfileKeys</code>. Do not declare a class name that conflicts with this.</p>
</li>
<li>
<p>A class containing SQLJ executable statements must not have a name that is the same as the first component of the name of any package that includes a Java type used in the application. Examples of class names to avoid are <code>java</code>, <code>sqlj</code>, and <code>oracle</code> (case-sensitive). As another example, if your SQLJ statements use host variables whose type is <code>abc.def.MyClass</code>, then you cannot use <code>abc</code> as the name of the class that uses these host variables.</p>
<p>To avoid this restriction, follow Java naming conventions recommending that package names start in lowercase and class names start in uppercase.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABGFFDC"></a>
<div id="JSQLJ266" class="sect2">
<h3 class="sect2">SQLJ <a id="sthref150"></a>Namespace</h3>
<p>The <span class="bold">SQLJ namespace</span> refers to <code>#sql</code> class declarations and the portion of <code>#sql</code> executable statements outside the curly braces.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Restrictions particular to the naming of iterator columns are discussed in <a href="blangfea.htm#i1006968">&#34;Using Named Iterators&#34;</a>.</div>
<p>Avoid using the following SQLJ reserved words as class names for declared connection context classes or iterator classes, in <code>with</code> or <code>implements</code> clauses, or in iterator column type declaration lists:</p>
<ul>
<li>
<p><code>iterator</code></p>
</li>
<li>
<p><code>context</code></p>
</li>
<li>
<p><code>with</code></p>
</li>
</ul>
<p>For example, do not have an iterator class or instance called <code>iterator</code> or a connection context class or instance called <code>context</code>.</p>
<p>However, note that it is permissible to have a stored function return variable whose name is any of these words.</p>
</div>
<!-- class="sect2" -->
<a id="BABIDDGH"></a>
<div id="JSQLJ267" class="sect2">
<h3 class="sect2">SQL <a id="sthref151"></a>Namespace</h3>
<p>The <span class="bold">SQL namespace</span> refers to the portion of a SQLJ executable statement inside the curly braces. Standard SQL naming restrictions apply here.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
<p>However, note that host expressions follow rules of the Java namespace, not the SQL namespace. This applies to the name of a host variable and to everything between the outer parentheses of a host expression.</p>
</div>
<!-- class="sect2" -->
<a id="BABFADJF"></a>
<div id="JSQLJ268" class="sect2">
<h3 class="sect2">File Name <a id="sthref152"></a><a id="sthref153"></a>Requirements and Restrictions</h3>
<p>SQLJ source files have the <code>.sqlj</code> file name extension. If the source file declares a public class (maximum of one), then the base name of the file must match the name of this class (case-sensitive). If the source file does not declare a public class, then the file name must still be a legal Java identifier, and it is recommended that the file name match the name of the first defined class.</p>
<p>For example, if you define the public class <code>MySource</code> in your source file, then your file name must be:</p>
<pre>MySource.sqlj
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
These file naming requirements follow the Java Language Specification (JLS) and are not SQLJ-specific. These requirements do not directly apply in Oracle Database 12<span class="italic">c</span> Release 1 (12.1), but it is still advisable to adhere to them.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007067"></a>
<div id="JSQLJ269" class="sect1">
<h2 class="sect1">Consid<a id="sthref154"></a>erations for SQLJ in the Middle Tier</h2>
<p>There are special considerations if you run SQLJ in the middle tier, such as in an Oracle9<span class="italic">i</span> Application Server Containers for J2EE (OC4J) environment.</p>
<p>Oracle JDBC drivers provide Oracle-specific interfaces in the <code>oracle.jdbc</code> package. The Oracle SQLJ libraries <code>runtime12.jar</code> and <code>runtime12ee.jar</code> make full use of these interfaces, but these libraries are not compatible with Oracle JDBC implementations prior to Oracle9<span class="italic">i</span> Application Server.</p>
<p>In Oracle9<span class="italic">i</span> Application Server, connections are established through data sources, which typically return instances of the <code>oracle.jdbc.OracleConnection</code> interface instead of the older <code>oracle.jdbc.driver.OracleConnection</code> class. This is necessary for certain connection functionality, such as distributed transactions (XA). To support such features, connection objects must implement the new interface.</p>
<p>This has the following consequences, relevant in an Oracle9<span class="italic">i</span> Application Server middle-tier environment, or any situation where data sources are used:</p>
<ul>
<li>
<p>For maximum portability and flexibility of your code, use <code>oracle.jdbc.OracleXXX</code> types instead of <code>oracle.jdbc.driver.OracleXXX</code> types.</p>
</li>
<li>
<p>For custom Java types (typically for SQL objects and collections), implement <code>oracle.sql.ORAData</code>.</p>
</li>
</ul>
<p>For general information about SQLJ support for data sources and connection JavaBeans, refer to the following sections:</p>
<ul>
<li>
<p><a href="alangfea.htm#i1005952">&#34;Standard Data Source Support&#34;</a></p>
</li>
<li>
<p><a href="alangfea.htm#i1006000">&#34;SQLJ-Specific Data Sources&#34;</a></p>
</li>
<li>
<p><a href="alangfea.htm#i1006101">&#34;SQLJ-Specific Connection JavaBeans for JavaServer Pages&#34;</a></p>
</li>
</ul>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4010">
<tr>
<td class="cellalignment4017">
<table class="cellalignment4015">
<tr>
<td class="cellalignment4014"><a href="overview.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4014"><a href="blangfea.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4019">
<table class="cellalignment4013">
<tr>
<td class="cellalignment4014"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4014"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4014"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4014"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4014"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4014"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>