<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-72367"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/SQLJ%20in%20the%20Server"></a><title>SQLJ in the Server</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743"/>
<meta name="dcterms.created" content="2013-12-02T6:55:15Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SQLJ Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17660-12"/>
<meta name="dcterms.isVersionOf" content="JSQLJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="apppfdbg.htm" title="Previous" type="text/html"/>
<link rel="Next" href="profcust.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E17660-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">18/20</span> <!-- End Header -->
<div id="JSQLJ785" class="chapter"><a id="CCHJFDHF"></a> <a id="i1007315"></a>
<h1 class="chapter"><span class="secnum">11</span> SQLJ in the Server</h1>
<p>SQLJ applications can be stored and run directly in the Oracle Database 12<span class="italic">c</span> Release 1 (12.1) server. You have the option of either translating and compiling them on a client and loading the generated classes and resources into the server or loading SQLJ source code into the server and having it translated and compiled by the embedded translator of the server.</p>
<p>This chapter discusses features and usage of SQLJ in the server, including additional considerations, such as multithreading and recursive SQLJ calls.</p>
<p>The following topics are discussed:</p>
<ul>
<li>
<p><a href="#i1005577">Overview of Server-Side SQLJ</a></p>
</li>
<li>
<p><a href="#i1005613">Creating SQLJ Code for Use in the Server</a></p>
</li>
<li>
<p><a href="#i1005719">Translating SQLJ Source on a Client and Loading Components</a></p>
</li>
<li>
<p><a href="#i1005892">Loading SQLJ Source and Translating in the Server</a></p>
</li>
<li>
<p><a href="#i1006162">Dropping Java Schema Objects</a></p>
</li>
<li>
<p><a href="#i1006182">Additional Server-Side Considerations</a></p>
</li>
</ul>
<a id="i1005577"></a>
<div id="JSQLJ786" class="sect1">
<h2 class="sect1">Overview of <a id="sthref897"></a>Server-Side SQLJ</h2>
<p>SQLJ code, as with any Java code, can run in Oracle Database 12<span class="italic">c</span> Release 1 (12.1) in stored procedures, stored functions, or triggers. Data access is through a server-side implementation of the SQLJ run time in combination with Oracle Java Database Connectivity (JDBC) server-side internal driver. In addition, an embedded SQLJ translator in Oracle Database 12<span class="italic">c</span> Release 1 (12.1) is available to translate SQLJ source files directly in the server.</p>
<p>Considerations for running SQLJ in the server include several server-side coding issues as well as decisions about where to translate your code and how to load it into the server. You must also be aware of how the server determines the names of generated output. You can either translate and compile on a client and load the class and resource files into the server or you can load <code>.sqlj</code> source files into the server and have the files automatically translated by the embedded SQLJ translator.</p>
<p>The embedded translator has a different user interface than the client-side translator. Supported options can be specified using a database table, and error output is to a database table. Output files from the translator are transparent to the developer.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
<ul>
<li>
<p>In Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the server uses a Java Development Kit (JDK) 6 Java2 Platform, Standard Edition (J2SE) environment. The server-side SQLJ environment is roughly equivalent to a client-side environment using the <code>runtime12ee</code> library, except for SQLJ-specific connection bean support and considering any relevant exceptions noted in <a href="#i1005613">&#34;Creating SQLJ Code for Use in the Server&#34;</a>.</p>
</li>
<li>
<p>This manual presumes that system configuration issues are outside the duties of most SQLJ developers. Therefore, configuration of the Oracle Database 12<span class="italic">c</span> Release 1 (12.1) Java virtual machine (JVM) is not covered here. For information about setting Java-related configuration parameters, refer to the <a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a>. If you need information about configuring the multithreaded server, dispatcher, or listener, refer to the <a class="olink NETAG" href="../NETAG/toc.htm"><span class="italic">Oracle Database Net Services Administrator&#39;s Guide</span></a>.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JSQLJ787"></a>Note Regarding Desupport of J2EE in Oracle Database</p>
<p>Since the introduction of Oracle9<span class="italic">i</span> Application Server Containers for J2EE (OC4J), a new, lighter-weight, easier-to-use, faster, and certified Java2 Platform, Enterprise Edition (J2EE) container, Oracle has desupported the J2EE and Common Object Request Broker Architecture (CORBA) stacks from the database. However, Oracle JVM will still be present and will continue to be enhanced to offer J2SE features, Java stored procedures, JDBC, and SQLJ in the database.</p>
<p>To summarize, Oracle no longer supports the following technologies in the database:</p>
<ul>
<li>
<p>The J2EE stack, consisting of Enterprise Beans (EJB) container, JavaServer Pages (JSP) container, and Oracle9<span class="italic">i</span> Servlet Engine (OSE)</p>
</li>
<li>
<p>The embedded CORBA framework, based on Visibroker for Java</p>
</li>
</ul>
<p>Customers can no longer deploy servlets, JSP pages, EJBs, and CORBA objects in Oracle Databases. Oracle9<span class="italic">i</span> Database Release 1 was the last database release to support the J2EE and CORBA stacks. Oracle encourages customers to migrate to OC4J for J2EE applications that previously ran in the database.</p>
</div>
<!-- class="sect1" -->
<a id="i1005613"></a>
<div id="JSQLJ788" class="sect1">
<h2 class="sect1">Creating <a id="sthref898"></a>SQLJ Code for Use in the Server</h2>
<p>With few exceptions, writing SQLJ code for use within the target Oracle Database 12<span class="italic">c</span> Release 1 (12.1) instance is identical to writing SQLJ code for client-side use. The few differences are due to Oracle JDBC characteristics or general Java characteristics in the server, rather than being specific to SQLJ. There are a few considerations to be aware of, however:</p>
<ul>
<li>
<p>There is an implicit connection to the server itself.</p>
</li>
<li>
<p>There are coding issues, such as lack of auto-commit functionality.</p>
</li>
<li>
<p>In the server, the default output device is the current trace file.</p>
</li>
<li>
<p>Name resolution functions differently in the server than on a client.</p>
</li>
<li>
<p>SQL names must be interpreted and processed differently from Java names.</p>
</li>
<li>
<p>There is no JSP, EJB, or CORBA functionality in the server. Because there is no JSP container, you cannot use the SQLJ JSP connection beans in server-side code.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Writing SQLJ code to connect from one server to another through the server-side Thin driver is identical to writing code for an application that uses a client-side JDBC Thin driver. The points in this discussion do not apply.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1005628">Database Connections Within the Server</a></p>
</li>
<li>
<p><a href="#CHDGDGBJ">Coding Issues Within the Server</a></p>
</li>
<li>
<p><a href="#CHDEEEJG">Default Output Device in the Server</a></p>
</li>
<li>
<p><a href="#CHDHBDBE">Name Resolution in the Server</a></p>
</li>
<li>
<p><a href="#CHDCDBDJ">SQL Names Versus Java Names</a></p>
</li>
</ul>
<a id="i1005628"></a>
<div id="JSQLJ789" class="sect2">
<h3 class="sect2">Database <a id="sthref899"></a><a id="sthref900"></a>Connections Within the Server</h3>
<p>The concept of connecting to a server is different when your SQLJ code is running within the server itself. There is no explicit database connection. By default, an implicit channel to the database is used for any Java program running in the server. You do not have to initialize this connection, as it is automatically initialized for SQLJ programs. You do not have to register or specify a driver, create a connection instance, specify a default connection context, specify any connection objects for any of your <code>#sql</code> statements, or close the connection.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In the server, setting the default connection context to <code>null</code>, as follows, will reinstall the default connection context (the implicit connection to the server):
<pre>DefaultContext.setDefaultContext(null);
</pre></div>
</div>
<!-- class="sect2" -->
<a id="CHDGDGBJ"></a>
<div id="JSQLJ790" class="sect2">
<h3 class="sect2">Coding <a id="sthref901"></a><a id="sthref902"></a><a id="sthref903"></a>Issues Within the Server</h3>
<p>There are a few coding issues to consider when your code will run within the target server using the server-side internal driver. Note the following:</p>
<ul>
<li>
<p>Result sets issued by the internal driver persist across calls, and their finalizers do not release their cursors. Because of this, it is especially important to close all iterators to avoid running out of available cursors, unless you have a particular reason for keeping an iterator open, such as when it is actually used across calls.</p>
</li>
<li>
<p><a id="sthref904"></a>The internal driver does not support auto-commit functionality, so the auto-commit setting is ignored within the server. Use explicit <code>COMMIT</code> or <code>ROLLBACK</code> statements to implement or cancel your data updates:</p>
<pre>#sql { COMMIT };
...
#sql { ROLLBACK };
</pre></li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are using any kind of XA transactions, such as Java Transaction Service (JTS) transactions, you cannot use SQLJ or JDBC <code>COMMIT</code>/<code>ROLLBACK</code> statements or methods.</div>
<ul>
<li>
<p>For ISO standard code generation, if you use SQLJ code that interacts with JDBC code and you use a nondefault connection context instance, then you must eventually close the connection context instance in order to clean up statements cached there, unless you use the same connection context instance for the duration of your session. Following is an example:</p>
<pre>DefaultContext ctx = new DefaultContext(conn); // conn is JDBC connection
#sql [ctx] { <span class="italic">SQL operation</span> };
...
ctx.close(sqlj.runtime.ConnectionContext.KEEP_CONNECTION);
...
</pre>
<p>If you do not close the connection context instance, you are likely to run out of statement handles in your session. Also be aware that simply closing the underlying JDBC connection object does <span class="italic">not</span> reclaim statement handles, which differs from the behavior when the application executes on a client.</p>
<p>For the default Oracle-specific code generation, statements are cached in the underlying JDBC statement cache and can be automatically reclaimed.</p>
</li>
<li>
<p>With Oracle-specific code generation for code that will run in the server, use an explicit <code>ExecutionContext</code> instance. This ensures that your application can fully interoperate with applications translated with ISO standard SQLJ code generation.</p>
<p>If you use one thread per connection, which translates to one thread per Oracle session, it is sufficient to use one static instance, as in the following example:</p>
<pre>public static ExecutionContext ec = new ExecutionContext();
...
#sql [ec] { <span class="italic">SQL operation</span> };    // use ec for all operations
</pre>
<p>If you use multiple threads per connection, then you must use a separate execution context instance for each method invocation.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect2" -->
<a id="CHDEEEJG"></a>
<div id="JSQLJ791" class="sect2">
<h3 class="sect2">Default <a id="sthref905"></a><a id="sthref906"></a><a id="sthref907"></a>Output Device in the Server</h3>
<p>The default standard output device in Oracle Java virtual machine (JVM) is the current trace file. If you wa<a id="sthref908"></a>nt to reroute all standard output from a program executing in the server, for example, output from any <code>System.out.println()</code> calls, to a user screen, then you can execute the <code>SET_OUTPUT()</code> procedure of the <code>DBMS_JAVA</code> package as in the following example. Input the buffer size in bytes (10,000 bytes in this case).</p>
<pre>sqlplus&gt; execute dbms_java.set_output(10000);
</pre>
<p>Output exceeding the buffer size will be lost.</p>
<p>If you want your code executing in the server to expressly write output to the user screen, then you can also use the PL/SQL <code>DBMS_OUTPUT.PUT_LINE()</code> procedure instead of the Java <code>System.out.println()</code> method. The <code>PUT_LINE()</code> procedure is overloaded, accepting either <code>VARCHAR2</code>, <code>NUMBER</code>, or <code>DATE</code> as input to specify what is printed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS" href="../ARPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></div>
</div>
<!-- class="sect2" -->
<a id="CHDHBDBE"></a>
<div id="JSQLJ792" class="sect2">
<h3 class="sect2">Nam<a id="sthref909"></a><a id="sthref910"></a><a id="sthref911"></a><a id="sthref912"></a>e Resolution in the Server</h3>
<p>Class loading and name resolution in the server follow a very different paradigm than on a client, because the environments themselves are very different.</p>
<p>Java name resolution in Oracle JVM includes the following:</p>
<ul>
<li>
<p>Class resolver specs, which are schema lists to search in resolving a class schema object (functionally equivalent to the classpath on a client)</p>
</li>
<li>
<p>The resolver, which maintains mappings between class schema objects that reference each other in the server</p>
</li>
</ul>
<p>A class schema object must be resolved before Java objects of the class can be instantiated or methods of the class can be executed. A class schema object is said to be resolved when all of its external references to Java names are bound. In general, all the classes of a Java program should be compiled or loaded before they can be resolved. This is because Java programs are typically written in multiple source files that can reference each other recursively.</p>
<p>When all the class schema objects of a Java program in the server are resolved and none of them have been modified since being resolved, the program is effectively prelinked and ready to run.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>loadjava</code> utility resolves references to classes but not to resources. For ISO standard code, which has to be translated on the client, be careful how you load any resources into resource schema objects in the server. If you enabled the SQLJ <code>-ser2class</code> flag for your client-side translation, then your SQLJ profiles will be in class files and you will typically not have any resource files. If you did not enable <code>-ser2class</code>, then your profiles will be in <code>.ser</code> resource files.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect2" -->
<a id="CHDCDBDJ"></a>
<div id="JSQLJ793" class="sect2">
<h3 class="sect2">SQL <a id="sthref913"></a><a id="sthref914"></a><a id="sthref915"></a>Names Versus Java Names</h3>
<p>SQL names, such as names of source, class, and resource schema objects, are not global in the way that Java names are global. The Java Language Specification (JLS) directs that package names use Internet naming conventions to create globally unique names for Java programs. By contrast, a fully qualified SQL name is interpreted only with respect to the current schema and database. For example, the <code>HR.FIZZ</code> name in one database does not necessarily denote the same program as <code>HR.FIZZ</code> in another database. In fact, <code>HR.FIZZ</code> in one database can even call <code>HR.FIZZ</code> in another database.</p>
<p>Because of this inherent difference, SQL names must be interpreted and processed differently than Java names. SQL names are relative names and are interpreted from the point of view of the schema where a program is executed. This is central to how the program binds local data stored at that schema. Java names are global names, and the classes that they designate can be loaded at any execution site, with reasonable expectation that those classes will be classes that were used to compile the program.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005719"></a>
<div id="JSQLJ794" class="sect1">
<h2 class="sect1">Translating <a id="sthref916"></a><a id="sthref917"></a><a id="sthref918"></a>SQLJ Source on a Client and Loading Components</h2>
<p>One approach to deploying SQLJ code in Oracle Database 12<span class="italic">c</span> Release 1 (12.1) is to run the SQLJ translator on a client computer to take care of translation, compilation, and profile customization, if applicable. Then load the resulting class and resource files, if any, into the server, typically using a Java Archive (JAR) file. In fact, this is the only way to use ISO standard code in the server, because the server-side translator supports only Oracle-specific code generation.</p>
<p>If you are developing your source on a client computer, as is usually the case, and have a SQLJ translator available there, then this approach is advisable. It provides flexibility in running the translator, because option-setting and error-processing are not as convenient in the server.</p>
<p>For ISO standard code, it might also be advisable to use the SQLJ <code>-ser2class</code> option during translation when you intend to load an application into the server. This results in SQLJ profiles being converted from <code>.ser</code> serialized resource files to <code>.class</code> files and simplifies their naming. However, be aware that profiles converted to <code>.class</code> files cannot be further customized. To further customize, you would have to rerun the translator and regenerate the profiles.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007976">&#34;Conversion of .ser File to .class File (-ser2class)&#34;</a></div>
<p>When you load <code>.class</code> files and <code>.ser</code> resource files into Oracle Database 12<span class="italic">c</span> Release 1 (12.1), either directly or using a JAR file, the resulting library units are referred to as Java class schema objects and Java resource schema objects. Your SQLJ profiles, if any, will be in resource schema objects, if you load them as <code>.ser</code> files, or in class schema objects if you enabled <code>-ser2class</code> during translation and load them as <code>.class</code> files.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1007297">Loading Classes and Resources into the Server</a></p>
</li>
<li>
<p><a href="#i1005791">Naming of Loaded Class and Resource Schema Objects</a></p>
</li>
<li>
<p><a href="#CHDHIEFB">Publishing the Application After Loading Class and Resource Files</a></p>
</li>
<li>
<p><a href="#CHDIJGDH">Summary: Running a Client Application in the Server</a></p>
</li>
</ul>
<a id="i1007297"></a>
<div id="JSQLJ795" class="sect2">
<h3 class="sect2">Loading <a id="sthref919"></a><a id="sthref920"></a><a id="sthref921"></a>Classes and Resources into the Server</h3>
<p>Once you run the translator on the client, use the Oracle <code>loadjava</code> client-side utility to load class and resource files into schema objects in the server. Either specify the class and resource files, if any, individually on the <code>loadjava</code> command line, or put them into a JAR file and specify the JAR file on the command line. A separate schema object is created for each <code>.class</code> or <code>.ser</code> file in the JAR file or on the command line.</p>
<p>Consider an example where you do the following:</p>
<ol>
<li>
<p>Translate and compile <code>Foo.sqlj</code>, which includes an iterator declaration for <code>MyIter</code>, using ISO standard code generation.</p>
</li>
<li>
<p>Enable the <code>-ser2class</code> option when you translate <code>Foo.sqlj</code>.</p>
</li>
<li>
<p>Archive the resulting files, <code>Foo.class</code>, <code>MyIter.class</code>, <code>Foo_SJProfileKeys.class</code>, and <code>Foo_SJProfile0.class</code>, into <code>Foo.jar</code>.</p>
</li>
</ol>
<p>Then run <code>loadjava</code> with the following command line (plus any options you want to specify). This examples uses the default JDBC Oracle Call Interface (OCI) driver:</p>
<pre>% loadjava -user HR Foo.jar
Password: <span class="italic">password</span>
</pre>
<p>Alternatively, you can use the original files:</p>
<pre>% loadjava -user HR Foo.class MyIter.class Foo_SJProfileKeys.class Foo_SJProfile0.class
Password: <span class="italic">password</span>
</pre>
<p>or:</p>
<pre>% loadjava -user HR Foo*.class MyIter.class
Password: <span class="italic">password</span>
</pre>
<p>You can use the JDBC Thin driver for loading as follows (specifying the <code>-thin</code> option and an appropriate URL):</p>
<pre>% loadjava -thin -user HR@localhost:5221/myservice Foo.jar
Password: <span class="italic">password</span>
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transrun.htm#i1005656">&#34;Code Generation&#34;</a> and <a href="transrun.htm#i1005790">&#34;Java Compilation&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>When you use the <code>-codegen=iso</code> setting during translation, generating profile files and then loading the profiles into the server as <code>.ser</code> files, they are first customized if they were not already customized on the client. If they were already customized, then they are loaded as is.</p>
</li>
<li>
<p>You can access the <code>USER_OBJECTS</code> view in your schema to verify that your classes and resources are loaded properly.</p>
</li>
</ul>
</div>
<p>Although the <code>loadjava</code> utility is recommended for loading your SQLJ and Java applications into the server, you can also use SQL <code>CREATE JAVA</code> commands such as the following:</p>
<pre>CREATE OR REPLACE &lt;AND RESOLVE&gt; JAVA CLASS &lt;NAMED <span class="italic">name</span>&gt;;

CREATE OR REPLACE JAVA RESOURCE &lt;NAMED <span class="italic">name</span>&gt;;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> and <a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1005791"></a>
<div id="JSQLJ796" class="sect2">
<h3 class="sect2">Naming of Loaded Class and Resource Schema Objects</h3>
<p>This section discusses how schema objects for classes and profiles are named when you load classes and profiles into the server. However, remember that profiles are created only for ISO standard code generation.</p>
<p>For ISO standard code generation, if the SQLJ <code>-ser2class</code> option was enabled when you translated your application on the client, then profiles were converted to <code>.class</code> files and will be loaded into class schema objects in the server. If <code>-ser2class</code> was not enabled, then profiles were generated as <code>.ser</code> serialized resource files and will be loaded into resource schema objects in the server.</p>
<p>In the following discussion, it is assumed that you use only the default connection context class for any application that will run in the server. Therefore, there will be only one profile.</p>
<p class="subhead2"><a id="i1005796"></a><a id="JSQLJ797"></a>Full N<a id="sthref922"></a><a id="sthref923"></a>ames and Short Names</p>
<p>There are two forms of schema object names in the server, full names and short names. Full names are fully qualified and are used as the schema object names whenever possible. If any full name is longer than 31 characters, however, or contains characters that are illegal or cannot be converted to characters in the database character set, then Oracle Database 12<span class="italic">c</span> Release 1 (12.1) converts the full name to a short name to use as the name of the schema object, keeping track of both names and how to convert between them. If the full name is 31 characters or less and has no illegal or inconvertible characters, then the full name is used as the schema object name.</p>
<p>For more information about these and about other file naming considerations, including <code>DBMS_JAVA</code> procedures to retrieve a full name from a short name, and vice versa, refer to <a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a></p>
<p class="subhead2"><a id="JSQLJ798"></a>Full <a id="sthref924"></a><a id="sthref925"></a><a id="sthref926"></a><a id="sthref927"></a>Names of Loaded Classes</p>
<p>Loaded classes will include profile files if you use ISO standard code generation and enable the <code>-ser2class</code> flag. The full name of the class schema object produced when you load a <code>.class</code> file into the server is determined by the package and class name in the original source code. Any path information you supply on the command line or in the JAR file is irrelevant in determining the name of the schema object. For example, if <code>Foo.class</code> consists of the <code>Foo</code> class, which was specified in the source code as being in the <code>x.y</code> package, then the full name of the resulting class schema object is as follows:</p>
<pre>x/y/Foo
</pre>
<p>Note that the <code>.class</code> extension is dropped.</p>
<p>If <code>Foo.sqlj</code> declares an iterator, <code>MyIter</code>, then the full name of its class schema object is as follows (unless it is a nested class, in which case it will not have its own schema object):</p>
<pre>x/y/MyIter
</pre>
<p>Furthermore, if you are using ISO standard code generation:</p>
<ul>
<li>
<p>The related profile-keys class file, generated by SQLJ when you translate <code>Foo.sqlj</code>, is <code>Foo_SJProfileKeys.class</code>. Therefore, the full name of its class schema object is:</p>
<pre>x/y/Foo_SJProfileKeys
</pre></li>
<li>
<p>If the <code>-ser2class</code> option was enabled when you translated your application, then the resulting profile is generated in <code>Foo_SJProfile0.class</code>. Therefore, the full name of the class schema object is:</p>
<pre>x/y/Foo_SJProfile0
</pre></li>
</ul>
<p class="subhead2"><a id="JSQLJ799"></a>Full <a id="sthref928"></a><a id="sthref929"></a><a id="sthref930"></a><a id="sthref931"></a>Names of Loaded Resources</p>
<p>This discussion is relevant only if you are using ISO standard code generation and did not enable the <code>-ser2class</code> option when you translated your application, or if you use other Java serialized resource (<code>.ser</code>) files in your application.</p>
<p>The naming of resource schema objects is handled differently from class schema objects. Their names are not determined from the contents of the resources. Instead, their full names are identical to the names that appear in a JAR file or on the <code>loadjava</code> command line, including path information. Also note that the <code>.ser</code> extension is <span class="italic">not</span> dropped.</p>
<p>It is important to note that because resource names are used to locate the resources at run time. Their names must include the correct path information. In the server, the correct full name of a resource is identical to the relative path and file name that Java would use to look it up on a client.</p>
<p>In the case of a SQLJ profile, this is a subdirectory under the directory specified by the translator <code>-d</code> option, according to the package name. If the <code>-d</code> option, used to specify the top-level output directory for generated <code>.class</code> and <code>.ser</code> files, is set to <code>/mydir</code> and the application is in the <code>abc.def</code> package, then <code>.class</code> and <code>.ser</code> files generated during translation will be placed in the <code>/mydir/abc/def</code> directory.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1006835">&#34;Output Directory for Generated .ser and .class Files (-d)&#34;</a></div>
<p>At run time, <code>/mydir</code> would presumably be in your classpath and Java will look for your application components in the <code>abc/def</code> directory underneath it. Therefore, when you load this application into the server, you must run <code>loadjava</code> or <code>jar</code> from the <code>-d</code> directory so that the path you specify on the command line to find the files also indicates the package name, as follows (where <code>%</code> is the system prompt):</p>
<pre>% cd /mydir
% loadjava &lt;...<span class="italic">options</span>...&gt; abc/def/*.class abc/def/*.ser
</pre>
<p>Alternatively, to use a JAR file:</p>
<pre>% cd /mydir
% jar -cvf myjar.jar abc/def/*.class abc/def/*.ser
% loadjava &lt;...<span class="italic">options</span>...&gt; myjar.jar
</pre>
<p>If your application is <code>App</code> and your profile is <code>App_SJProfile0.ser</code>, then either of the preceding examples will correctly result in the following full name of the created resource schema object:</p>
<pre>abc/def/App_SJProfile0.ser
</pre>
<p>Note that <code>.ser</code> is retained.</p>
<p>Note also that if you set <code>-d</code> to a directory whose hierarchy has no other contents (which is advisable), you can simply run the JAR utility as follows to recursively get your application components:</p>
<pre>% cd /mydir
% jar -cvf myjar.jar *
% loadjava &lt;...<span class="italic">options</span>...&gt; myjar.jar
</pre></div>
<!-- class="sect2" -->
<a id="CHDHIEFB"></a>
<div id="JSQLJ800" class="sect2">
<h3 class="sect2">Publishing the Application After Loading Class and Resource Files</h3>
<p>Before using your SQLJ code in the server, you must publish the top-level methods, as is true of any Java code you use in the server. Publishing includes writing call descriptors, mapping data types, and setting parameter modes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect2" -->
<a id="CHDIJGDH"></a>
<div id="JSQLJ801" class="sect2">
<h3 class="sect2">Summary: Runn<a id="sthref932"></a>ing a Client Application in the Server</h3>
<p>This section summarizes the typical steps of running a client application in the server. As an example, it uses a demo application called <code>NamedIterDemo</code>.</p>
<ol>
<li>
<p>Create a JAR file for your application components. For <code>NamedIterDemo</code>, the components include <code>SalesRec.class</code> as well as the application class and profile, if any.</p>
<p>You can create JAR file <code>niter-server.jar</code> as follows:</p>
<pre>% jar cvf niter-server.jar Named*.class Named*.ser SalesRec.class connect.properties
</pre>
<p>But remember that <code>.ser</code> files are only relevant for ISO standard code generation.</p>
</li>
<li>
<p>Load the JAR file into the server.</p>
<p>Use <code>loadjava</code> as follows. This example instructs <code>loadjava</code> to use the OCI driver in loading the files. The <code>-resolve</code> option results in the class files being resolved.</p>
<pre>% loadjava -oci -resolve -force -user HR niter-server.jar
Password: <span class="italic">password</span>
</pre></li>
<li>
<p>Create a SQL wrapper in the server for your application.</p>
<p>For example, run a SQL*Plus script that executes the following:</p>
<pre>set echo on
set serveroutput on
set termout on
set flush on

execute dbms_java.set_output(10000);

create or replace procedure SQLJ_NAMED_ITER_DEMO as language java 
name &#39;NamedIterDemo.main (java.lang.String[])&#39;;
/
</pre>
<p>The <code>DBMS_JAVA.SET_OUTPUT()</code> routine reroutes default output to your screen, instead of to a trace file. The input parameter is the buffer size in bytes.</p>
</li>
<li>
<p>Execute the wrapper.</p>
<p>For example:</p>
<pre>sqlplus&gt; call SQLJ_NAMED_ITER_DEMO();
</pre></li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005892"></a>
<div id="JSQLJ802" class="sect1">
<h2 class="sect1">Loading <a id="sthref933"></a><a id="sthref934"></a>SQLJ Source and Translating in the Server</h2>
<p>Another approach to developing SQLJ code for the server is loading the source code into the server and translating it directly in the server. This uses the embedded SQLJ translator in Oracle JVM. This discussion still assumes you created the source on a client computer.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The server-side SQLJ translator does not support ISO standard code generation. If you want to use such code in the server, you must translate on a client and load the individual class files and resources into the server.</div>
<p>As a general rule, loading SQLJ source into the server is identical to loading Java source into the server, with translation taking place implicitly when a compilation option is set, such as the <code>loadjava -resolve</code> option. When you load <code>.sqlj</code> source files into Oracle Database 12<span class="italic">c</span> Release 1 (12.1), either directly or using a JAR file, the resulting library units containing the source code are referred to as Java source schema objects. A separate schema object is created for each source file.</p>
<p>When translation and compilation take place, the resulting library units for the generated classes are referred to as Java class schema objects, just as they are when loaded directly into the server from <code>.class</code> files created on a client. A separate schema object is created for each class. Resource schema objects are used for properties files that you load into the server.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDHEAJC">Loading SQLJ Source Code into the Server</a></p>
</li>
<li>
<p><a href="#CCHBGEBD">Option Support in the Server Embedded Translator</a></p>
</li>
<li>
<p><a href="#i1006083">Naming of Loaded Source and Generated Class and Resource Schema Objects</a></p>
</li>
<li>
<p><a href="#CHDICEII">Error Output from the Server Embedded Translator</a></p>
</li>
<li>
<p><a href="#CHDGEAIC">Publishing the Application After Loading Source Files</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> and <a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a></div>
<a id="CHDHEAJC"></a>
<div id="JSQLJ803" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Loading SQLJ <a id="sthref935"></a><a id="sthref936"></a><a id="sthref937"></a>Source Code into the Server</h3>
<p>Use the Oracle <code>loadjava</code> client-side utility on a <code>.sqlj</code> file, instead of on a <code>.class</code> file, to load source into the server. If you enable the <code>loadjava -resolve</code> option in loading a <code>.sqlj</code> file, then the server-side embedded translator is run to perform the translation and compilation of your application as it is loaded. Otherwise, the source is loaded into a source schema object without any translation. However, in this case, the source <span class="italic">is</span> implicitly translated and compiled the first time an attempt is made to use a class defined in the source. Such implicit translation might seem surprising at first, because there is nothing comparable in client-side SQLJ.</p>
<p>For example, run <code>loadjava</code> as follows from the system prompt:</p>
<pre>% loadjava -user HR -resolve Foo.sqlj
Password: <span class="italic">password</span>
</pre>
<p>Alternatively, you can use the JDBC Thin driver to load:</p>
<pre>% loadjava -thin -user HR@localhost:5221/myservice -resolve Foo.sqlj
Password: <span class="italic">password</span>
</pre>
<p>Either of these will result in appropriate class schema objects being created in addition to the source schema object.</p>
<p>Before running <code>loadjava</code>, however, you must set SQLJ options appropriately. Note that encoding can be set on the <code>loadjava</code> command line, instead of through the server-side SQLJ <code>encoding</code> option, as follows:</p>
<pre>% loadjava -user HR -resolve -encoding SJIS Foo.sqlj
Password: <span class="italic">password</span>
</pre>
<p>The <code>loadjava</code> script, which runs the actual utility, is in the <code>bin</code> subdirectory under your <code><span class="codeinlineitalic">ORACLE_HOME</span></code> directory. This directory should already be in your path once Oracle has been installed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>In processing a JAR file, <code>loadjava</code> first processes <code>.sqlj</code>, <code>.java</code>, and <code>.class</code> files. It then makes a second pass and processes everything else as Java resource files.</p>
</li>
<li>
<p>You cannot load a <code>.sqlj</code> file along with <code>.class</code> files that were generated from processing of the same <code>.sqlj</code> file. This would create an obvious conflict, because the server would be trying to load the same classes that it would also be trying to generate.</p>
</li>
<li>
<p>You can put multiple <code>.sqlj</code> files into a JAR file and specify the JAR file to <code>loadjava</code>.</p>
</li>
<li>
<p>You can access the <code>USER_OBJECTS</code> view in your schema to verify that your classes are loaded properly.</p>
</li>
</ul>
</div>
<p>Although the <code>loadjava</code> utility is recommended for loading your SQLJ and Java applications into the server, you can also use SQL <code>CREATE JAVA</code> commands such as the following:</p>
<pre>CREATE OR REPLACE &lt;AND COMPILE&gt; JAVA SOURCE &lt;NAMED <span class="italic">srcname</span>&gt; &lt;AS <span class="italic">loadname</span>&gt;;
</pre>
<p>If you specify <code>AND COMPILE</code> for a <code>.sqlj</code> file, then the source is translated and compiled at that time, creating class schema objects as appropriate in addition to the source schema object. Otherwise, it is not translated and compiled. In this case, only the source schema object is created. In this latter case, however, the source <span class="italic">is</span> implicitly translated and compiled the first time an attempt is made to use a class contained in the source.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you first load a source file, some checking of the source code is performed, such as determining what classes are defined. If any errors are detected at this time, the load fails.</div>
</div>
<!-- class="sect2" -->
<a id="CCHBGEBD"></a>
<div id="JSQLJ804" class="sect2">
<h3 class="sect2">Option <a id="sthref938"></a><a id="sthref939"></a>Support in the Server Embedded Translator</h3>
<p>The following options are available in the server-side SQLJ translator:</p>
<ul>
<li>
<p><code>encoding</code></p>
</li>
<li>
<p><code>online</code></p>
</li>
<li>
<p><code>debug</code></p>
</li>
</ul>
<p>This section discusses these options, after leading off with some discussion of fixed settings in server-side SQLJ. There is also discussion of the <code>loadjava</code> utility and its <code>-resolve</code> option.</p>
<p class="subhead2"><a id="JSQLJ805"></a>Fixe<a id="sthref940"></a><a id="sthref941"></a>d Settings in the Server-Side SQLJ Translator</p>
<p>The following settings, supported by SQLJ translator options on a client, are fixed in the server-side translator:</p>
<ul>
<li>
<p>Both online semantics-checking and offline parsing are enabled in the server by default, equivalent to the default <code>-parse=both</code> setting on a client. You can override this to disable online semantics-checking through the <code>online</code> option, but cannot disable offline parsing.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1008220">&#34;Online Semantics-Checking Versus Offline Parsing&#34;</a></div>
</li>
<li>
<p>Oracle-specific code generation is used in the server, equivalent to the default <code>-codegen=oracle</code> setting on a client. This is a fixed setting.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1006746">&#34;Oracle-Specific Code Generation (No Profiles)&#34;</a></div>
</li>
<li>
<p>Class schema objects created during server-side translation reference line numbers that map to the SQLJ source code. This is equivalent to enabling the <code>-linemap</code> option when you translate on a client.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007436">&#34;Line-Mapping to SQLJ Source File (-linemap)&#34;</a></div>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ806"></a>The <a id="sthref942"></a><a id="sthref943"></a>encoding Option</p>
<p>This option determines any encoding used to interpret your source code when it is loaded into the server. The <code>encoding</code> option is used at the time the source is loaded, regardless of whether it is also compiled. Alternatively, when using <code>loadjava</code> to load your SQLJ application into the server, you can specify encoding on the <code>loadjava</code> command line. Any <code>loadjava</code> command-line setting for encoding overrides this <code>encoding</code> option.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If no encoding is specified, either through this option or through <code>loadjava</code>, then encoding is performed according to the <code>file.encoding</code> setting of the client from which you run <code>loadjava</code>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1006799">&#34;Encoding for Input and Output Source Files (-encoding)&#34;</a></div>
<p class="subhead2"><a id="JSQLJ807"></a>The <a id="sthref944"></a><a id="sthref945"></a><a id="sthref946"></a>online Option</p>
<p>A <code>true</code> setting for the <code>online</code> option (the default value) enables online semantics-checking. Semantics-checking is performed relative to the schema in which the source is loaded. You do not specify an exemplar schema, as you do for online-checking on a client. If the <code>online</code> option is set to <code>false</code>, offline checking is performed.</p>
<p>In either case, the default checker is <code>oracle.sqlj.checker.OracleChecker</code>, which will choose an appropriate checker according to your JDBC driver version and Oracle version.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1008088">&#34;Semantics-Checkers and OracleChecker Front End (default checker)&#34;</a></div>
<p>The <code>online</code> option is used at the time the source is translated and compiled. If you load it with the <code>loadjava</code> <code>-resolve</code> option enabled, then this will occur immediately. Otherwise it will occur the first time an attempt is made to use a class defined in the source, resulting in implicit translation and compilation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>online</code> option is used differently in the server than on a client. In the server, the <code>online</code> option is only a flag that enables online checking using a default checker. On a client, the <code>-online</code> option specifies which checker to use, but it is the <code>-user</code> option that enables online checking.</div>
<p class="subhead2"><a id="JSQLJ808"></a>The <a id="sthref947"></a><a id="sthref948"></a><a id="sthref949"></a>debug Option</p>
<p>Setting this option to <code>true</code> instructs the server-side Java compiler to output debugging information when a <code>.sqlj</code> or <code>.java</code> source file is compiled in the server. This is equivalent to using the <code>-g</code> option when running the standard <code>javac</code> compiler on a client.</p>
<p>Source is compiled during loading if you use the <code>loadjava</code> <code>-resolve</code> option, right after SQLJ translation in the case of a <code>.sqlj</code> file. If you do not use the <code>-resolve</code> option, then implicit translation and compilation occurs the first time an attempt is made to use a class defined in the source.</p>
<p class="subhead2"><a id="JSQLJ809"></a>Setting SQLJ <a id="sthref950"></a><a id="sthref951"></a><a id="sthref952"></a>Options in the Server</p>
<p>There is no command line and there are no properties files when running the SQLJ translator in the server. Information about translator and compiler options is held in each schema in a table named <code>JAVA$OPTIONS</code>. Manipulate options in this table through the following functions and procedures of the <code>DBMS_JAVA</code> package:</p>
<ul>
<li>
<p><code>DBMS_JAVA.GET_COMPILER_OPTION()</code></p>
</li>
<li>
<p><code>DBMS_JAVA.SET_COMPILER_OPTION()</code></p>
</li>
<li>
<p><code>DBMS_JAVA.RESET_COMPILER_OPTION()</code></p>
</li>
</ul>
<p>Use <code>set_compiler_option()</code> to specify separate option settings for individual packages or sources. It takes the following as input, with each parameter enclosed by single-quotes:</p>
<ul>
<li>
<p>Package name, using dotted names, or source name</p>
<p>Specify this as a full name, not a short name. If you specify a package name, then the option setting applies to all sources in that package and subpackages, except where you override the setting for a particular subpackage or source.</p>
</li>
<li>
<p>Option name</p>
</li>
<li>
<p>Option setting</p>
</li>
</ul>
<p>Execute the <code>DBMS_JAVA</code> routines using SQL*Plus as follows:</p>
<pre>sqlplus&gt; execute dbms_java.set_compiler_option(&#39;x.y&#39;, &#39;online&#39;, &#39;true&#39;);
sqlplus&gt; execute dbms_java.set_compiler_option(&#39;x.y.Create&#39;, &#39;online&#39;, &#39;false&#39;);
</pre>
<p>These two commands enable online checking for all sources in the <code>x.y</code> package, then override that for the <code>Create</code> source by disabling online checking for that particular source.</p>
<p>Similarly, set encoding for the <code>x.y</code> package to <code>SJIS</code> as follows:</p>
<pre>sqlplus&gt; execute dbms_java.set_compiler_option(&#39;x.y&#39;, &#39;encoding&#39;, &#39;SJIS&#39;);
</pre>
<p class="subhead2"><a id="JSQLJ810"></a>Server-Side Option Notes</p>
<p>Be aware of the following:</p>
<ul>
<li>
<p>The <code>set_compiler_option()</code> parameter for package and source names uses dotted names, such as <code>abc.def</code> as a package name, even though schema object names use slash syntax, such as <code>abc/def</code> as a package name.</p>
</li>
<li>
<p>When you specify a package name, be aware that the option will apply to any included packages as well. A setting of <code>a.b.MyPackage</code> sets the option for any source schema objects whose names are of the following form:</p>
<pre>a/b/MyPackage/subpackage/... 
</pre></li>
<li>
<p>Specifying <code>&#39;&#39;</code> (empty set of single-quotes) as a package name makes the option apply to the root and all subpackages, effectively making it apply to all packages in your schema.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006083"></a>
<div id="JSQLJ811" class="sect2">
<h3 class="sect2">Naming of Loaded Source <a id="sthref953"></a><a id="sthref954"></a><a id="sthref955"></a><a id="sthref956"></a>and Generated Class and Resource Schema Objects</h3>
<p>When you use the server-side SQLJ translator, such as when you use <code>loadjava</code> on a <code>.sqlj</code> file with the <code>-resolve</code> option enabled, the output generated by the server-side translator is essentially identical to what would be generated on a client. This output consists of a compiled class for each class you defined in the source and a compiled class for each iterator and connection context class.</p>
<p>As a result, the following schema objects will be produced when you load a <code>.sqlj</code> file into the server with <code>loadjava</code> and have it translated and compiled:</p>
<ul>
<li>
<p>A source schema object for the original source code</p>
</li>
<li>
<p>A class schema object for each class you defined in the source</p>
</li>
<li>
<p>A class schema object for each iterator or connection context class you declared in the source</p>
<p>But presumably you will not need to declare connection context classes in code that will run in the server, unless it is to specify type maps for user-defined types.</p>
</li>
</ul>
<p>The full names of these schema objects are determined as described in the following subsections. Use the <code>loadjava</code> <code>-verbose</code> option for a report of schema objects produced and what they are named.</p>
<p class="subhead2"><a id="CHDBDDAA"></a><a id="JSQLJ812"></a>Full <a id="sthref957"></a><a id="sthref958"></a><a id="sthref959"></a><a id="sthref960"></a>Name of Source</p>
<p>When you load a source file into the server, regardless of whether it is translated and compiled, a source schema object is produced. The full name of this schema object is determined by the package and class names in the source code. Any path information you supply to <code>loadjava</code> on the command line is irrelevant to the determination of the name of the schema object.</p>
<p>For example, if <code>Foo.sqlj</code> defines the <code>Foo</code> class in the <code>x.y</code> package and defines or declares no other classes, then the full name of the resulting source schema object is:</p>
<pre>x/y/Foo
</pre>
<p>Note that the <code>.sqlj</code> extension is dropped.</p>
<p>If you define additional classes or declare iterator or connection context classes, then the source schema object is named according to the first public class definition or declaration encountered, or, if there are no public classes, the first class definition. In the server, there can be more than one public class definition in a single source.</p>
<p>For example, if <code>Foo.sqlj</code> is still in the <code>x.y</code> package, defines public class <code>Bar</code> first and then class <code>Foo</code>, and has no public iterator or connection context class declarations preceding the definition of <code>Bar</code>, then the full name of the resulting source schema object is:</p>
<pre>x/y/Bar
</pre>
<p>However, if the declaration of public iterator class <code>MyIter</code> precedes the <code>Bar</code> and <code>Foo</code> class definitions, then the full name of the resulting source schema object is:</p>
<pre>x/y/MyIter
</pre>
<p class="subhead2"><a id="JSQLJ813"></a>Full <a id="sthref961"></a><a id="sthref962"></a><a id="sthref963"></a><a id="sthref964"></a>Names of Generated Classes</p>
<p>Class schema objects are generated for each class you defined in the source, each iterator you declared, and the profile-keys class. The naming of the class schema objects is based on the class names and the package name from the source code.</p>
<p>This discussion continues the example in <a href="#CHDBDDAA">&#34;Full Name of Source&#34;</a>. Presume your source code specifies the <code>x.y</code> package, defines public class <code>Bar</code> then class <code>Foo</code>, then declares public iterator class <code>MyIter</code>. The full names of the class schema objects for the classes you define and declare are as follows:</p>
<pre>x/y/Bar
x/y/Foo
x/y/MyIter
</pre>
<p>Note that <code>.class</code> is not appended.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is recommended that the source name always match the first public class defined or, if there are no public classes, the first class defined. This will avoid possible differences between client-side and server-side behavior.</div>
<p>The name of the original source file, as well as any path information you specify when loading the source into the server, is irrelevant in determining the names of the generated classes. If you define inner classes or anonymous classes in your code, then they are named according to the conventions of the standard <code>javac</code> compiler.</p>
</div>
<!-- class="sect2" -->
<a id="CHDICEII"></a>
<div id="JSQLJ814" class="sect2">
<h3 class="sect2">Error <a id="sthref965"></a><a id="sthref966"></a><a id="sthref967"></a>Output from the Server Embedded Translator</h3>
<p>SQLJ error processing in the server is similar to general Java error processing in the server. SQLJ errors are directed into the <code>USER_ERRORS</code> table of the user schema. You can <code>SELECT</code> from the <code>TEXT</code> column of this table to get the text of a given error message.</p>
<p>However, if you use <code>loadjava</code> to load your SQLJ source, then <code>loadjava</code> also captures and writes the error messages from the server-side translator.</p>
<p>Informational messages and suppressible warnings are withheld by the server-side translator in a way that is equivalent to the operation of the client-side translator with a <code>-warn=noportable,noverbose</code> setting, which is the default.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007284">&#34;Translator Warnings (-warn)&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDGEAIC"></a>
<div id="JSQLJ815" class="sect2">
<h3 class="sect2">Publishing the Application After Loading Source Files</h3>
<p>Before using your SQLJ code in the server, you must publish the top-level methods, as is true of any Java code you use in the server. Publishing includes writing call descriptors, mapping data types, and setting parameter modes. For information, refer to <a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006162"></a>
<div id="JSQLJ816" class="sect1">
<h2 class="sect1">Dropping <a id="sthref968"></a><a id="sthref969"></a><a id="sthref970"></a><a id="sthref971"></a>Java Schema Objects</h2>
<p>To complement the <code>loadjava</code> utility, Oracle provides the <code>dropjava</code> utility to remove Java source, class, and resource schema objects. It is recommended that any schema object loaded into the server using <code>loadjava</code> be removed using <code>dropjava</code> only.</p>
<p>The <code>dropjava</code> utility transforms command-line file names and JAR file contents to schema object names, then removes the schema objects. You can enter <code>.sqlj</code>, <code>.java</code>, <code>.class</code>, <code>.ser</code>, and <code>.jar</code> files on the command line in any order.</p>
<p>You should always remove Java schema objects in the same way that you first loaded them. If you load a <code>.sqlj</code> source file and translate it in the server, then run <code>dropjava</code> on the same source file. If you translate on a client and load classes and resources directly, then run <code>dropjava</code> on the same classes and resources.</p>
<p>For example, if you run <code>loadjava</code> on <code>Foo.sqlj</code>, then execute <code>dropjava</code> on the same file name, as follows:</p>
<pre>% dropjava -user HR/<span class="italic">password</span> Foo.sqlj
</pre>
<p>If you translate your program on the client and load it using JAR file containing the generated components, then use the same JAR file name to remove the program:</p>
<pre>% dropjava -user HR/<span class="italic">password</span> Foo.jar
</pre>
<p>If you translate your program on the client and load the generated components using the <code>loadjava</code> command line, then remove them using the <code>dropjava</code> command line, as follows (assume <code>-codegen=oracle</code> and no iterator classes):</p>
<pre>% dropjava -user HR/<span class="italic">password</span> Foo*.class
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect1" -->
<a id="i1006182"></a>
<div id="JSQLJ817" class="sect1">
<h2 class="sect1">Additional Server-Side Considerations</h2>
<p>This section discusses Java multithreading in the server and recursive SQLJ calls in the server. It covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDJGEHJ">Java Multithreading in the Server</a></p>
</li>
<li>
<p><a href="#CCHJFGCB">Recursive SQLJ Calls in the Server</a></p>
</li>
<li>
<p><a href="#CHDGGCGH">Verifying that Code is Running in the Server</a></p>
</li>
</ul>
<a id="CHDJGEHJ"></a>
<div id="JSQLJ818" class="sect2">
<h3 class="sect2">Java <a id="sthref972"></a><a id="sthref973"></a>Multithreading in the Server</h3>
<p>Programs that use Java multithreading can execute in Oracle Database 12<span class="italic">c</span> Release 1 (12.1) without modification. However, while client-side programs use multithreading to improve throughput for users, there are no such benefits when Java-multithreaded code runs in the server. If you are considering porting a multithreaded application into the server, be aware of the following important differences in the functionality of multithreading in Oracle JVM, as opposed to in client-side JVMs:</p>
<ul>
<li>
<p>Threads in the server run sequentially, not simultaneously.</p>
</li>
<li>
<p>In the server, threads within a call die at the end of the call.</p>
</li>
<li>
<p>Threads in the server are not preemptively scheduled. If one thread goes into an infinite loop, then no other threads can run.</p>
</li>
</ul>
<p>Do not confuse Java multithreading in Oracle Database 12<span class="italic">c</span> Release 1 (12.1) with general Oracle server multithreading. The latter refers to simultaneous Oracle sessions, not Java multithreading. In the server, scalability and throughput are gained by having many individual users, each with his own session, executing simultaneously. The scheduling of Java execution for maximum throughput, such as for each call within a session, is performed by Oracle Database 12<span class="italic">c</span> Release 1 (12.1), and not by Java.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006495">&#34;Multithreading in SQLJ&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="CCHJFGCB"></a>
<div id="JSQLJ819" class="sect2">
<h3 class="sect2">Recursive <a id="sthref974"></a><a id="sthref975"></a>SQLJ Calls in the Server</h3>
<p>SQLJ generally does not allow multiple SQLJ statements to use the same execution context instance simultaneously. Specifically, a statement trying to use an execution context instance that is already in use will be blocked until the first statement completes.</p>
<p>However, this functionality would be less desirable in the server than on a client. This is because different stored procedures or functions, which all typically use the default execution context instance, can inadvertently try to use this same execution context instance simultaneously in recursive situations. For example, one stored procedure might use a SQLJ statement to call another stored procedure that uses SQLJ statements. When these stored procedures are first created, there is probably no way of knowing when such situations might arise, so it is doubtful that particular execution context instances are specified for any of the SQLJ statements.</p>
<p>To address this situation, SQLJ <span class="italic">does</span> allow multiple SQLJ statements to use the same execution context instance simultaneously if this results from recursive calls.</p>
<p>Consider an example of a recursive situation to see what happens to status information in the execution context instance. Presume that all statements use the default connection context instance and its default execution context instance. If stored procedure <code>proc1</code> has a SQLJ statement that calls stored procedure <code>proc2</code>, which also has SQLJ statements, then the statements in <code>proc2</code> will each be using the execution context instance while the procedure call in <code>proc1</code> is also using it.</p>
<p>Each SQLJ statement in <code>proc2</code> results in status information for that statement being written to the execution context instance, with the opportunity to retrieve that information after completion of each statement, as desired. The status information from the statement in <code>proc1</code> that calls <code>proc2</code> is written to the execution context instance only after <code>proc2</code> has finished executing, program flow has returned to <code>proc1</code>, and the operation in <code>proc1</code> that called <code>proc2</code> has completed.</p>
<p>To avoid confusion about execution context status information in recursive situations, execution context methods are carefully defined to update status information about a SQL operation only after the operation has completed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>To avoid confusion, use distinct execution context instances as appropriate whenever you plan to use execution context status or control methods in code that will run in the server.</p>
</li>
<li>
<p>Be aware that if the preceding example does not use distinct execution context instances and <code>proc2</code> has any method calls to the execution context instance to change control parameters, then this will affect operations subsequently executed in <code>proc1</code>.</p>
</li>
<li>
<p>Update batching is not supported across recursive calls. By default, only the top-level procedure will perform batching, if enabled. This limitation can be avoided by using explicit execution context instances.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006297">&#34;Execution Context Methods&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDGGCGH"></a>
<div id="JSQLJ820" class="sect2">
<h3 class="sect2">Verifying that <a id="sthref976"></a>Code is Running in the Server</h3>
<p>A convenient way to verify that your code is actually running in the server is to use the static <code>getProperty()</code> method of the <code>java.lang.System</code> class to retrieve the <code>oracle.server.version</code> Java property. If this property contains a version number, then you are running in the server. If it is <code>null</code>, then you are not. Here is an example:</p>
<pre>...
if (System.getProperty(&#34;oracle.server.version&#34;) != null 
{
   // (running in server)
}
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not use the <code>getProperties()</code> method, as this causes a security exception in the server.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4010">
<tr>
<td class="cellalignment4017">
<table class="cellalignment4015">
<tr>
<td class="cellalignment4014"><a href="apppfdbg.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4014"><a href="profcust.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4019">
<table class="cellalignment4013">
<tr>
<td class="cellalignment4014"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4014"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4014"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4014"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4014"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4014"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>