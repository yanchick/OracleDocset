<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-72372"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Objects%2C%20Collections%2C%20and%20OPAQUE%20Types"></a><title>Objects, Collections, and OPAQUE Types</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743"/>
<meta name="dcterms.created" content="2013-12-02T6:55:14Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SQLJ Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17660-12"/>
<meta name="dcterms.isVersionOf" content="JSQLJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="typesupp.htm" title="Previous" type="text/html"/>
<link rel="Next" href="alangfea.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E17660-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/20</span> <!-- End Header -->
<div id="JSQLJ409" class="chapter"><a id="CIHEBGGC"></a> <a id="i1010078"></a>
<h1 class="chapter"><span class="secnum">6</span> Objects, Collections, and OPAQUE Types</h1>
<p>This chapter discusses how the Oracle SQLJ implementation supports user-defined SQL types. This includes discussion of Oracle JPublisher utility, which you can use to generate Java classes corresponding to user-defined SQL types. There is also a small section at the end regarding Oracle OPAQUE types.</p>
<p>The chapter consists of the following sections:</p>
<ul>
<li>
<p><a href="#i1005589">Oracle Objects and Collections</a></p>
</li>
<li>
<p><a href="#i1005685">Custom Java Classes</a></p>
</li>
<li>
<p><a href="#i1006214">User-Defined Types</a></p>
</li>
<li>
<p><a href="#i1006402">JPublisher and the Creation of Custom Java Classes</a></p>
</li>
<li>
<p><a href="#i1007225">Strongly Typed Objects and References in SQLJ Executable Statements</a></p>
</li>
<li>
<p><a href="#i1007474">Strongly Typed Collections in SQLJ Executable Statements</a></p>
</li>
<li>
<p><a href="#i1007794">Serialized Java Objects</a></p>
</li>
<li>
<p><a href="#i1008087">Weakly Typed Objects, References, and Collections</a></p>
</li>
<li>
<p><a href="#i1008113">Oracle OPAQUE Types</a></p>
</li>
</ul>
<a id="i1005589"></a>
<div id="JSQLJ410" class="sect1">
<h2 class="sect1">Oracle Objects and Collections</h2>
<p>This section provides some background conceptual information about Oracle Database 12<span class="italic">c</span> Release 1 (12.1) objects and collections.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> and <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Development Guide</span></a>.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABGGJAD">Overview of Objects and Collections</a></p>
</li>
<li>
<p><a href="#i1005653">Oracle Object Fundamentals</a></p>
</li>
<li>
<p><a href="#BABIIJJH">Oracle Collection Fundamentals</a></p>
</li>
<li>
<p><a href="#BABBEIIC">Object and Collection Data Types</a></p>
</li>
</ul>
<a id="BABGGJAD"></a>
<div id="JSQLJ411" class="sect2">
<h3 class="sect2">Overvi<a id="sthref300"></a><a id="sthref301"></a>ew of Objects and Collections</h3>
<p>The Oracle SQLJ implementation supports user-defined SQL object types, which are composite data structures, related SQL object reference types, and user-defined SQL collection types. Oracle objects and collections are composite data structures consisting of individual data elements.</p>
<p>The Oracle SQLJ implementation supports either strongly typed or weakly typed Java representations of object types, reference types, and collection types to use in iterators or host expressions. Strongly typed representations use a custom Java class that maps to a particular object type, reference type, or collection type and must implement either the Java Database Connectivity (JDBC) 2.0 standard <code>java.sql.SQLData</code> interface, for object types only, or the Oracle <code>oracle.sql.ORAData</code> interface. Either paradigm is supported by the Oracle Database 12<span class="italic">c</span> Release 1 (12.1) JPublisher utility, which you can use to automatically generate custom Java classes.</p>
<p>The term stron<a id="sthref302"></a><a id="sthref303"></a>gly typed is used where a particular Java type is associated with a particular SQL named type or user-defined type. For example, if there is a <code>PERSON</code> type, then a corresponding <code>Person</code> Java class will be associated with it.</p>
<p>Weakly typed representations use <code>oracle.sql.STRUCT</code> for objects, <code>oracle.sql.REF</code> for object references, or <code>oracle.sql.ARRAY</code> for collections. Alternatively, you can use standard <code>java.sql.Struct</code>, <code>java.sql.Ref</code>, or <code>java.sql.Array</code> objects in a weakly typed scenario.</p>
<p>The term wea<a id="sthref304"></a><a id="sthref305"></a>kly typed is used where a Java type is used in a generic way and can map to multiple SQL named types. The Java class or interface has no special information particular to any SQL type. This is the case for the <code>oracle.sql.STRUCT</code>, <code>oracle.sql.REF</code>, and <code>oracle.sql.ARRAY</code> types and the <code>java.sql.Struct</code>, <code>java.sql.Ref</code>, and <code>java.sql.Array</code> types.</p>
<p>Note that using Oracle extensions in your code requires the following:</p>
<ul>
<li>
<p>Use one of Oracle JDBC drivers.</p>
</li>
<li>
<p>Use default Oracle-specific code generation or, for ISO code generation, customize the profiles appropriately. For Oracle-specific generated code, no profiles are produced so customization is not applicable. Oracle JDBC application programming interfaces (APIs) are called directly through the generated Java code.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle recommends the use of the default customizer, <code>oracle.sqlj.runtime.util.OraCustomizer</code>.</div>
</li>
<li>
<p>Use Oracle SQLJ run time when your application runs. Oracle SQLJ run time and an Oracle JDBC driver are required whenever you use Oracle customizer, even if you do not actually use Oracle extensions in your code.</p>
</li>
</ul>
<p>For Oracle-specific semantics-checking, you must use an appropriate checker. The default checker, <code>oracle.sqlj.checker.OracleChecker</code>, acts as a front end and will run the appropriate checker based on your environment. This will be one of the Oracle specific checkers if you are using an Oracle JDBC driver.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle-specific types for Oracle objects and collections are included in the <code>oracle.sql</code> package.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1006917">&#34;Connection Options&#34;</a> and <a href="transopt.htm#i1008060">&#34;Semantics-Checking and Offline-Parsing Options&#34;</a></div>
<p class="subhead2"><a id="JSQLJ412"></a>Custom Java Class Usage Notes</p>
<ul>
<li>
<p>This chapter primarily discusses the use of custom Java classes with user-defined types. However, classes implementing <code>ORAData</code> can be used for other Oracle SQL types as well. A class implementing <code>ORAData</code> can be used to perform any kind of desired processing or conversion in the course of transferring data between SQL and Java.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006014">&#34;Additional Uses for ORAData Implementations&#34;</a></div>
</li>
<li>
<p>The <code>SQLData</code> interface is intended only for custom object classes. The <code>ORAData</code> interface can be used for any custom Java class.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ413"></a>Terminology Notes</p>
<ul>
<li>
<p>User-defined SQL object types and user-defined SQL collection types are referred to as user-defined types (UDTs).</p>
</li>
<li>
<p>Custom Java classes for objects, references, and collections are referred to as custom object classes, custom reference classes, and custom collection classes, respectively.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ" href="../ADOBJ/toc.htm"><span class="italic">Oracle Database Object-Relational Developer&#39;s Guide</span></a> for general information about Oracle object features and functionality</div>
</div>
<!-- class="sect2" -->
<a id="i1005653"></a>
<div id="JSQLJ414" class="sect2">
<h3 class="sect2">Oracle <a id="sthref306"></a>Object Fundamentals</h3>
<p>The Oracle SQL objects are composite data structures that group related data items, such as facts about each employee, into a single data unit. An object type is functionally similar to a Java class. You can populate and use any number of individual objects of a given object type, just as you can instantiate and use individual objects of a Java class.</p>
<p>For example, you can define an object type <code>EMPLOYEE</code> that has the attributes <code>name</code> of type <code>CHAR</code>, <code>address</code> of type <code>CHAR</code>, <code>phonenumber</code> of type <code>CHAR</code>, and <code>employeenumber</code> of type <code>NUMBER</code>.</p>
<p>Oracle objects can also have methods, or stored procedures, associated with the object type. These methods can be either static methods or instance methods and can be implemented either in PL/SQL or Java. Their signatures can include any number of input, output, or input-output parameters. All this depends on how they are initially defined</p>
</div>
<!-- class="sect2" -->
<a id="BABIIJJH"></a>
<div id="JSQLJ415" class="sect2">
<h3 class="sect2">Oracle <a id="sthref307"></a><a id="sthref308"></a>Collection Fundamentals</h3>
<p>There are two categories of Oracle SQL collections:</p>
<ul>
<li>
<p><a id="sthref309"></a>Variable-length arrays (VARRAY types)</p>
</li>
<li>
<p><a id="sthref310"></a>Nested tables (TABLE types)</p>
</li>
</ul>
<p>Both categories are one-dimensional, although the elements can be complex object types. VARRAY types are used for one-dimensional arrays, and nested table types are used for single-column tables within an outer table. A variable of any VARRAY type can be referred to as a VARRAY. A variable of any nested table type can be referred to as a nested table.</p>
<p>A VARRAY, as with any array, is an ordered set of data elements, with each element having an index and all elements being of the same data type. The size of a VARRAY refers to the maximum number of elements. Oracle VARRAYs, as indicated by their name, are of variable size, but the maximum size of any particular VARRAY type must be specified when the VARRAY type is declared.</p>
<p>A nested table is an unordered set of elements. Nested table elements within a table can themselves be queried in SQL. A nested table, as with any table, is not created with any particular number of rows. This is determined dynamically.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
The elements in a VARRAY or the rows in a nested table can be of a user-defined object type, and VARRAY and nested table types can be used for attributes in a user-defined object type. Oracle Database 12<span class="italic">c</span> Release 1 (12.1) supports nesting of collection types. The elements of a VARRAY or rows of a nested table can be of another VARRAY or nested table type, or these elements can be of a user-defined object type that has VARRAY or nested table attributes.</div>
</div>
<!-- class="sect2" -->
<a id="BABBEIIC"></a>
<div id="JSQLJ416" class="sect2">
<h3 class="sect2">Object <a id="sthref311"></a><a id="sthref312"></a>and Collection Data Types</h3>
<p>In Oracle Database 12<span class="italic">c</span> Release 1 (12.1), user-defined object and collection definitions function as SQL data type definitions. You can use these data types, as with any other data type, in defining table columns, SQL object attributes, and stored procedure or function parameters. In addition, once you have defined an object type, the related object reference type can be used as any other SQL reference type.</p>
<p>For example, consider the <code>EMPLOYEE</code> Oracle object described in the preceding section. Once you have defined this object, it becomes an Oracle data type. You can have a table column of type <code>EMPLOYEE</code> just as you can have a table column of type <code>NUMBER</code>. Each row in an <code>EMPLOYEE</code> column contains a complete <code>EMPLOYEE</code> object. You can also have a column type of <code>REF EMPLOYEE</code>, consisting of references to <code>EMPLOYEE</code> objects.</p>
<p>Similarly, you can define a variable-length array <code>MYVARR</code> as <code>VARRAY(10)</code> of <code>NUMBER</code> and a nested table <code>NTBL</code> of <code>CHAR(20)</code>. The <code>MYVARR</code> and <code>NTBL</code> collection types become Oracle data types, and you can have table columns of either type. Each row of a <code>MYVARR</code> column consists of an array of up to 10 numbers. Each row of an <code>NTBL</code> column consists of 20 characters.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005685"></a>
<div id="JSQLJ417" class="sect1">
<h2 class="sect1">Custom Ja<a id="sthref313"></a><a id="sthref314"></a><a id="sthref315"></a>va Classes</h2>
<p>Custom Java classes are first-class types that you can use to read from and write to user-defined SQL types transparently. The purpose of custom Java classes is to provide a way to convert data between SQL and Java and make the data accessible, particularly in supporting objects and collections or if you want to perform custom data conversions.</p>
<p>It is generally advisable to provide custom Java classes for all user-defined types that you use in a SQLJ application. Oracle JDBC driver will use instances of these classes in converting data, which is more convenient and less error-prone than using the weakly typed <code>oracle.sql.STRUCT</code>, <code>oracle.sql.REF</code>, and <code>oracle.sql.ARRAY</code> classes.</p>
<p>To be used in SQLJ iterators or host expressions, a custom Java class must implement either the <code>oracle.sql.<a id="sthref316"></a>ORAData</code> and <code>oracle.sql.ORADataFactory</code> interfaces or the standard <code>java.sql.SQL<a id="sthref317"></a>Data</code> interface. This section provides an overview of these interfaces and custom Java class functionality, covering the following topics:</p>
<ul>
<li>
<p><a href="#i1005718">Custom Java Class Interface Specifications</a></p>
</li>
<li>
<p><a href="#i1005809">Custom Java Class Support for Object Methods</a></p>
</li>
<li>
<p><a href="#i1005834">Custom Java Class Requirements</a></p>
</li>
<li>
<p><a href="#i1005971">Compiling Custom Java Classes</a></p>
</li>
<li>
<p><a href="#i1006004">Reading and Writing Custom Data</a></p>
</li>
<li>
<p><a href="#i1006014">Additional Uses for ORAData Implementations</a></p>
</li>
</ul>
<a id="i1005718"></a>
<div id="JSQLJ418" class="sect2">
<h3 class="sect2">Custom Java Class Interface Specifications</h3>
<p>This section discusses specifications of the <code>ORAData</code> and <code>ORADataFactory</code> interfaces and the standard <code>SQLData</code> interface.</p>
<p>Oracle Database 12<span class="italic">c</span> Release 1 (12.1) includes a set of APIs for Oracle-specific custom Java class functionality for user-defined types: <code>oracle.sql.ORAData</code> and <code>oracle.sql.ORADataFactory</code>.</p>
<p class="subhead2"><a id="i1005723"></a><a id="JSQLJ419"></a>ORAData <a id="sthref318"></a><a id="sthref319"></a><a id="sthref320"></a>and ORADataFactory Specifications</p>
<p>Oracle provides the <code>oracle.sql.ORAData</code> interface and the related <code>oracle.sql.ORADataFactory</code> interface to use in mapping and converting Oracle object types, reference types, and collection types to custom Java classes.</p>
<p>Data is sent or retrieved in the form of an <code>oracle.sql.Datum</code> object, with the underlying data being in the format of the appropriate <code>oracle.sql.Datum</code> subclass, such as <code>oracle.sql.STRUCT</code>. This data is still in its SQL format. The <code>oracle.sql.Datum</code> object is just a wrapper.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<p>The <code>ORAData</code> interface specifies a <code>toDatum()</code> method for data conversion from Java format to SQL format. This method takes as input your connection object and converts data to the appropriate <code>oracle.sql.*</code> representation. The connection object is necessary so that the JDBC driver can perform appropriate type checking and type conversions at run time. The <code>ORAData</code> and <code>toDatum()</code> specification is as follows:</p>
<pre>interface oracle.sql.ORAData
{
   oracle.sql.Datum toDatum(java.sql.Connection c) throws SQLException;
}
</pre>
<p>The <code>ORADataFactory</code> interface specifies a <code>create()</code> method that constructs instances of your custom Java class, converting from SQL format to Java format. This method takes as input a <code>Datum</code> object containing the data and a type code, such as <code>OracleTypes.RAW</code>, indicating the SQL type of the underlying data. It returns an object of your custom Java class, which implements the <code>ORAData</code> interface. This object receives its data from the <code>Datum</code> object that was input. The <code>ORADataFactory</code> and <code>create()</code> specification is as follows:</p>
<pre>interface oracle.sql.ORADataFactory
{
   oracle.sql.ORAData create(oracle.sql.Datum d, int sqlType) 
                      throws SQLException;
}
</pre>
<p>To complete the relationship between the <code>ORAData</code> and <code>ORADataFactory</code> interfaces, you must implement a static <code>getORADataFactory()</code> method in any custom Java class that implements the <code>ORAData</code> interface. This method returns an object that implements the <code>ORADataFactory</code> interface and that, therefore, can be used to create instances of your custom Java class. This returned object can itself be an instance of your custom Java class, and its <code>create()</code> method is used by Oracle JDBC driver to produce further instances of your custom Java class, as necessary.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
JPublisher output implements the <code>ORAData</code> interface and its <code>toDatum()</code> method and the <code>ORADataFactory</code> interface and its <code>create()</code> method in a single custom Java class. However, <code>toDatum()</code> and <code>create()</code> are specified in different interfaces to allow the option of implementing them in separate classes. You can have one custom Java class that implements <code>ORAData</code>, its <code>toDatum()</code> method, and the <code>getORADataFactory()</code> method, and have a separate factory class that implements <code>ORADataFactory</code> and its <code>create()</code> method. For purposes of discussion here, however, the assumption is that both interfaces are implemented in a single class.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005846">&#34;Oracle Requirements for Classes Implementing ORAData&#34;</a></div>
<p>If you use JPublisher, then specifying <code>-usertypes=oracle</code> will result in JPublisher generating custom Java classes that implement the <code>ORAData</code> and <code>ORADataFactory</code> interfaces and the <code>getORADataFactory()</code> method.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a></div>
<p class="subhead2"><a id="JSQLJ421"></a>SQLDa<a id="sthref321"></a><a id="sthref322"></a>ta Specification</p>
<p>Standard JDBC 2.0 supplies the <code>java.sql.SQLData</code> interface to use in mapping and converting structured object types to Java classes. This interface is intended for mapping structured object types only, not object references, collections or arrays, or other SQL types.</p>
<p>The <code>SQLData</code> interface is a JDBC 2.0 standard, specifying a <code>readSQL()</code> method to read data into a Java object and a <code>writeSQL()</code> method to write to the database from a Java object. If you use JPublisher, then specifying <code>-usertypes=jdbc</code> will result in JPublisher generating custom Java classes that implement the <code>SQLData</code> interface.</p>
<p>For additional information about standard <code>SQLData</code> functionality, refer to the Sun Microsystems JDBC 2.0 or later API specification.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005901">&#34;Requirements for Classes Implementing SQLData&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1005809"></a>
<div id="JSQLJ422" class="sect2">
<h3 class="sect2">Custom <a id="sthref323"></a><a id="sthref324"></a><a id="sthref325"></a>Java Class Support for Object Methods</h3>
<p>Methods of Oracle objects can be invoked from custom Java class wrappers. Whether the underlying stored procedure is written in PL/SQL or is written in Java and published to SQL is invisible to the user.</p>
<p>A Java wrapper method used to invoke a server method requires a connection to communicate with the server. The connection object can be provided as an explicit parameter or can be associated in some other way. For example, as an attribute of your custom Java class. If the connection object used by the wrapper method is a nonstatic attribute, then the wrapper method must be an instance method of the custom Java class in order to have access to the connection. Custom Java classes generated by JPublisher use this technique.</p>
<p>There are also issues regarding output and input-output parameters in methods of Oracle objects. If a stored procedure, that is, a SQL object method, modifies the internal state of one of its arguments, then the actual argument passed to the stored procedure is modified. In Java this is not possible. When a JDBC output parameter is returned from a stored procedure call, it must be stored in a newly created object. The original object identity is lost.</p>
<p>One way to return an output or input-output parameter to the caller is to pass the parameter as an element of an array. If the parameter is input-output, then the wrapper method takes the array element as input. After processing, the wrapper assigns the output to the array element. Custom Java classes generated by JPublisher use this technique, with each output or input-output parameter being passed in a one-element array.</p>
<p>When you use JPublisher, it implements wrapper methods by default. This is true for generated classes implementing either the <code>SQLData</code> interface or the <code>ORAData</code> interface. To disable this feature, set the JPublisher <code>-methods</code> flag to <code>false</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are implementing a custom Java class, then there are various ways that you can implement wrapper methods. Data processing in the server can be done either through the SQL object method directly or by forwarding the object value from the client to the server and then executing the method there. To see how JPublisher implements wrapper methods, and whether this may meet your needs, refer to <a href="#i1006926">&#34;JPublisher Implementation of Wrapper Methods&#34;</a>.</div>
</div>
<!-- class="sect2" -->
<a id="i1005834"></a>
<div id="JSQLJ423" class="sect2">
<h3 class="sect2">Custom Java <a id="sthref326"></a>Class Requirements</h3>
<p>Custom Java classes must satisfy certain requirements to be recognized by Oracle SQLJ translator as valid host variable types and to enable type-checking by the translator.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Custom Java classes for user-defined types are often referred to in this manual as &#34;wrapper classes&#34;.</div>
<p class="subhead2"><a id="i1005846"></a><a id="JSQLJ424"></a>Oracle Requirements for Classes Implementing ORAData</p>
<p>Oracle requirements for <code>ORAData</code> implementations are primarily the same for any kind of custom Java class, but vary slightly depending on whether the class is for mapping to objects, object references, collections, or some other SQL type.</p>
<p>These requirements are as follows:</p>
<ul>
<li>
<p>The class implements the <code>oracle.sql.ORAData</code> interface.</p>
</li>
<li>
<p>The class implements the <code>getORADataFactory()</code> method that returns an <code>oracle.sql.ORADataFactory</code> object. The method signature is as follows:</p>
<pre>public static oracle.sql.ORADataFactory getORADataFactory();
</pre></li>
<li>
<p>The class has a <code>String</code> constant, <code>_SQL_TYPECODE</code>, initialized to the <code>oracle.jdbc.OracleTypes</code> type code of the <code>Datum</code> subclass instance that <code>toDatum()</code> returns. The type code is:</p>
<ul>
<li>
<p>For custom object classes:</p>
<pre>public static final int _SQL_TYPECODE = OracleTypes.STRUCT;
</pre></li>
<li>
<p>For custom reference classes:</p>
<pre>public static final int _SQL_TYPECODE = OracleTypes.REF;
</pre></li>
<li>
<p>For custom collection classes:</p>
<pre>public static final int _SQL_TYPECODE = OracleTypes.ARRAY;
</pre></li>
</ul>
<p>For other uses, some other type code might be appropriate. For example, for using a custom Java class to serialize and deserialize Java objects into or out of <code>RAW</code> fields, a <code>_SQL_TYPECODE</code> of <code>OracleTypes.RAW</code> is used.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>OracleTypes</code> class simply defines a type code, which is an integer constant, for each Oracle data type. For standard SQL types, the <code>OracleTypes</code> entry is identical to the entry in the standard <code>java.sql.Types</code> type definitions class.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007794">&#34;Serialized Java Objects&#34;</a></div>
</li>
<li>
<p>For custom Java classes with <code>_SQL_TYPECODE</code> of <code>STRUCT</code>, <code>REF</code>, or <code>ARRAY</code>, that is, for custom Java classes that represent objects, object references, or collections, the class has a constant that indicates the relevant user-defined type name. This is as follows:</p>
<ul>
<li>
<p>Custom object classes and custom collection classes must have a <code>String</code> constant, <code>_SQL_NAME</code>, initialized to the SQL name you declared for the user-defined type, as follows:</p>
<pre>public static final String _SQL_NAME = <span class="italic">UDT name</span>;
</pre>
<p>For example, the custom object class for a user-defined <code>PERSON</code> object will have the constant:</p>
<pre>public static final String _SQL_NAME = &#34;PERSON&#34;;
</pre>
<p>The same can be specified along with the schema, if appropriate, as follows:</p>
<pre>public static final String _SQL_NAME = &#34;HR.PERSON&#34;;
</pre>
<p>The custom collection class for a collection of <code>PERSON</code> objects, which you have declared as <code>PERSON_ARRAY</code>, will have the constant:</p>
<pre>public static final String _SQL_NAME = &#34;PERSON_ARRAY&#34;;
</pre></li>
<li>
<p>Custom reference classes must have a <code>String</code> constant, <code>_SQL_BASETYPE</code>, initialized to the SQL name you declared for the user-defined type being referenced, as follows:</p>
<pre>public static final String _SQL_BASETYPE = <span class="italic">UDT name</span>;
</pre>
<p>The custom reference class for <code>PERSON</code> references will have the constant:</p>
<pre>public static final String _SQL_BASETYPE = &#34;PERSON&#34;;
</pre>
<p>For other <code>ORAData</code> uses, specifying a UDT name is not applicable.</p>
</li>
</ul>
</li>
</ul>
<p>Keep in mind the following usage notes:</p>
<ul>
<li>
<p>A collection type name reflects the collection type, not the base type. For example, if you have declared a VARRAY or nested table type, <code>PERSON_ARRAY</code>, for <code>PERSON</code> objects, then the name of the collection type that you specify for the <code>_SQL_NAME</code> entry is <code>PERSON_ARRAY</code>, not <code>PERSON</code>.</p>
</li>
<li>
<p>When specifying the SQL type in a <code>_SQL_NAME</code> field, if the SQL type was declared in a case-se<a id="sthref327"></a>nsitive way (in quotes), then you must specify the SQL name exactly as it was declared, such as <code>CaseSensitive</code> or <code>HR.CaseSensitive</code>. Note that this differs from usage in a JPublisher input file, where the case-sensitive name must also appear in quotes. If you did <span class="italic">not</span> declare the SQL type in a case-sensitive way, that is, without no quotes, then you must specify the SQL name in all uppercase, such as <code>ADDRESS</code> or <code>HR.ADDRESS</code>.</p>
<p>JPublisher automatically generates the value of this field appropriately, according to case-sensitivity and the JPublisher <code>-omit_schema_names</code> setting, if applicable.</p>
</li>
</ul>
<p class="subhead2"><a id="i1005901"></a><a id="JSQLJ425"></a>Requirements for Classes Implementing SQLData</p>
<p>The ISO SQLJ standard outlines requirements for type map definitions for classes implementing the <code>SQLData</code> interface. Alternatively, <code>SQLData</code> wrapper classes can identify associated SQL object types through the <code>public static final</code> fields.</p>
<p>Be aware of the following important points:</p>
<ul>
<li>
<p>Whether you use a type map or use alternative (nonstandard) <code>public static final</code> fields to specify mappings, you must be consistent in your approach. Either use a type map that specifies all relevant mappings so that you do not require the <code>public static final</code> fields, or do not use a type map at all and specify all mappings through the <code>public static final</code> fields.</p>
</li>
<li>
<p><code>SQLData</code>, unlike <code>ORAData</code>, is for mapping structured object types only. It is not for object references, collections or arrays, or any other SQL types. If you are not using <code>ORAData</code>, then your only choices for mapping object references and collections are the weak <code>java.sql.Ref</code> and <code>java.sql.Array</code> types, respectively, or <code>oracle.sql.REF</code> and <code>oracle.sql.ARRAY</code>.</p>
</li>
<li>
<p>When specifying the mapping from a SQL type to a Java type, if the SQL type was declared in a case-se<a id="sthref328"></a>nsitive way, then you must specify the SQL name exactly as it was declared, such as <code>CaseSensitive</code> or <code>HR.CaseSensitive</code>. Note that this differs from usage in a JPublisher input file, where the case-sensitive name must also appear in quotes. If you did <span class="italic">not</span> declare the SQL type in a case-sensitive way, then you must specify the SQL name in all uppercase, such as <code>ADDRESS</code> or <code>HR.ADDRESS</code>.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ426"></a>Mapping Specified in Type Map Resource</p>
<p>First, consider the mapping representation according to the ISO SQLJ standard. Assume that <code>Address</code>, <code>pack.Person</code>, and <code>pack.Manager.InnerPM</code>, where <code>InnerPM</code> is an inner class of <code>Manager</code>, are three wrapper classes that implement <code>java.sql.SQLData</code>.</p>
<p>Then, you need to consider the following:</p>
<ul>
<li>
<p>You must use these classes only in statements that use explicit connection context instances of a declared connection context type. For example, assuming that this type is called <code>SDContext</code>:</p>
<pre>Address               a =...;
pack.Person           p =...;
pack.Manager.InnerPM pm =...;
SDContext ctx = new SDContext(url,user,pwd,false);
#sql [ctx] { ... :a ... :p ... :pm ... };
</pre></li>
<li>
<p>The connection context type must have been declared using the <code>with</code> attribute <code>typeMap</code> that specifies an associated class implementing <code>java.util.PropertyResourceBundle</code>. In the preceding example, <code>SDContext</code> may be declared as follows:</p>
<pre>#sql public static context SDContext with (typeMap=&#34;SDMap&#34;);
</pre></li>
<li>
<p>The type map resource must provide the mapping from SQL object types to corresponding Java classes that implement the <code>java.sql.SQLData</code> interface. This mapping is specified with entries of the following form:</p>
<pre>class.java_class_name=STRUCT sql_type_name
</pre>
<p>The <code>STRUCT</code> keyword can also be omitted. In the example, the <code>SDMap.properties</code> resource file may contain the following entries:</p>
<pre>class.Address=STRUCT HR.ADDRESS
class.pack.Person=PERSON
class.pack.Manager$InnerPM=STRUCT PRODUCT_MANAGER
</pre>
<p>Although the period (.) separates package and class name, you <span class="italic">must</span> use the dollar sign ($) to separate an inner class name.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Important:</p>
If you used the default Oracle-specific code generation in this example, then any iterator that is used for a statement whose context type is <code>SDContext</code> must also have been declared with the same associated type map, <code>SDMap</code>, such as in the following example:
<pre>#sql public static iterator SDIter with (typeMap=&#34;SDMap&#34;);
...
SDContext sdctx = ...
SDIter sditer;
#sql [sdctx] sditer = { SELECT ...};
</pre>
<p>This is to ensure that proper code is generated for the iterator class.</p>
</div>
<p>This mechanism of specifying mappings in a type map resource is more complicated than the nonstandard alternative. Also, it is not possible to associate a type map resource with the default connection context. The advantage is that all the mapping information is placed in a single location, the type map resource. This means that the type mapping in an already compiled application can be easily adjusted at a later time, for example, to accommodate new SQL types and Java wrappers in an expanding SQL-Java type hierarchy.</p>
<p>Be aware of the following:</p>
<ul>
<li>
<p>You must employ the SQLJ <code>runtime12</code> or <code>runtime12ee</code> library to use this feature. Type maps are represented as <code>java.util.Map</code> objects. These are exposed in the SQLJ run-time API and, therefore, <span class="italic">cannot</span> be supported by the generic run-time library.</p>
</li>
<li>
<p>You must use Oracle SQLJ run time and Oracle-specific code generation or profile customization if your <code>SQLData</code> wrapper classes occur as <code>OUT</code> or <code>INOUT</code> parameters in SQLJ statements. This is because the SQL type of such parameters is required for <code>registerOutParameter()</code> by Oracle JDBC driver. Also, for <code>OUT</code> parameter type registration, the SQL type is &#34;frozen in&#34; by the type map in effect during translation.</p>
</li>
<li>
<p>The SQLJ type map is independent of any JDBC type map you may be using on the underlying connection. Thus, you must be careful when you are mixing SQLJ and JDBC code if both use <code>SQLData</code> wrappers. However, you can easily extract the type map in effect on a given SQLJ connection context:</p>
<pre>ctx.getTypeMap();
</pre></li>
</ul>
<p class="subhead2"><a id="JSQLJ427"></a>Mapping Specified in Static Field of Wrapper Class</p>
<p>A class that implements <code>SQLData</code> can satisfy the following nonstandard requirement:</p>
<ul>
<li>
<p>The Java class declares the <code>String</code> constant <code>_SQL_NAME</code>, which defines the name of the SQL type that is being wrapped by the Java class. In the example, the <code>Address</code> class would have the following field declaration:</p>
<pre>public static final String _SQL_NAME=&#34;HR.ADDRESS&#34;;
</pre>
<p>The following declaration would be in <code>pack.Person</code>:</p>
<pre>public static final String _SQL_NAME=&#34;PERSON&#34;;
</pre>
<p>And the <code>pack.Manager.InnerPM</code> class would have the following:</p>
<pre>public static final String _SQL_NAME=&#34;PRODUCT_MANAGER&#34;;
</pre></li>
</ul>
<p>Note that JPublisher always generates <code>SQLData</code> wrapper classes with the <code>_SQL_NAME</code> field. However, this field is ignored in SQLJ statements that reference a type map.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>If a class that implements the <code>_SQL_NAME</code> field is used in a SQLJ statement with an explicit connection context type and associated type map, then that type map is used and the <code>_SQL_NAME</code> field is ignored. This simplifies migration of existing SQLJ programs to the ISO SQLJ standard.</p>
</li>
<li>
<p>The static SQL-Java type correspondence specified in the <code>_SQL_NAME</code> field is independent from any JDBC type map you may be using on the underlying connection. Thus, you must be careful when you are mixing SQLJ and JDBC code if both use <code>SQLData</code> wrappers.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1005971"></a>
<div id="JSQLJ428" class="sect2">
<h3 class="sect2">Compiling <a id="sthref329"></a>Custom Java Classes</h3>
<p>You can include any <code>.java</code> files for your custom Java classes, whether <code>ORAData</code> or <code>SQLData</code> implementations, on the SQLJ command line together with the <code>.sqlj</code> files for your application. However, this is not necessary if the SQLJ <code>-checksource</code> flag is set to <code>true</code>, which is the default, and your classpath includes the directory where the custom Java source is located.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This discussion assumes you are creating <code>.java</code> files for your custom objects and collections, not <code>.sqlj</code> files. Any <code>.sqlj</code> files must be included in the SQLJ command line.</div>
<p>For example, if <code>ObjectDemo.sqlj</code> uses the <code>ADDRESS</code> and <code>PERSON</code> Oracle object types and you have produced custom Java classes for these objects, then you can run SQLJ as follows.</p>
<ul>
<li>
<p>If <code>-checksource=true</code> and the classpath includes the custom Java source location:</p>
<pre>% sqlj ObjectDemo.sqlj
</pre></li>
<li>
<p>If <code>-checksource=false</code> (this is a single wraparound line):</p>
<pre>% sqlj ObjectDemo.sqlj Address.java AddressRef.java Person.java PersonRef.java
</pre></li>
</ul>
<p>You also have the choice of using your Java compiler to compile custom <code>.java</code> source files directly. If you do this, then you must do it prior to translating <code>.sqlj</code> files.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="transopt.htm#BCEIIEAI">&#34;Source File Name Check (-checkfilename)&#34;</a></p>
</li>
<li>
<p><a href="transopt.htm#BCEDIABI">Chapter 8, &#34;Translator Command Line and Options&#34;</a></p>
</li>
</ul>
</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because <code>ORAData</code> implementations rely on Oracle-specific features, SQLJ will report numerous portability warnings if you do not use the <code>-warn=noportable</code> translator portability setting, which is the default. For information about the <code>-warn</code> flag, refer to <a href="transopt.htm#i1007284">&#34;Translator Warnings (-warn)&#34;</a>.</div>
</div>
<!-- class="sect2" -->
<a id="i1006004"></a>
<div id="JSQLJ429" class="sect2">
<h3 class="sect2">Reading and <a id="sthref330"></a>Writing Custom Data</h3>
<p>Through the use of custom Java class instances, the Oracle SQLJ and JDBC implementations allow you to read and write user-defined types as though they are built-in types. Exactly how this is accomplished is transparent to the user.</p>
<p>For the mechanics of how data is read and written, for both <code>ORAData</code> implementations and <code>SQLData</code> implementations, refer to the <a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i1006014"></a>
<div id="JSQLJ430" class="sect2">
<h3 class="sect2">Additional Uses for <a id="sthref331"></a>ORAData Implementations</h3>
<p>To this point, discussion of custom Java classes has been for use as one of the following.</p>
<ul>
<li>
<p>Wrappers for SQL objects: custom object classes, for use with <code>oracle.sql.STRUCT</code> instances</p>
</li>
<li>
<p>Wrappers for SQL references: custom reference classes, for use with <code>oracle.sql.REF</code> instances</p>
</li>
<li>
<p>Wrappers for SQL collections: custom collection classes, for use with <code>oracle.sql.ARRAY</code> instances</p>
</li>
</ul>
<p>It might be useful, however, to provide custom Java classes to wrap other <code>oracle.sql.*</code> types as well, for customized conversions or processing. You can accomplish this with classes that implement <code>ORAData</code>, but not <code>SQLData</code>, as in the following examples:</p>
<ul>
<li>
<p>Perform encryption and decryption or validation of data.</p>
</li>
<li>
<p>Perform logging of values that have been read or are being written.</p>
</li>
<li>
<p>Parse character columns, such as character fields containing URL information, into smaller components.</p>
</li>
<li>
<p>Map character strings into numeric constants.</p>
</li>
<li>
<p>Map data into more desirable Java formats, such as mapping a <code>DATE</code> field to <code>java.util.Date</code> format.</p>
</li>
<li>
<p>Customize data representation, for example, data in a table column is in feet, but you want it represented in meters after it is selected.</p>
</li>
<li>
<p>Serialize and deserialize Java objects, for example, into or out of <code>RAW</code> fields.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
This sort of functionality is not possible through the <code>SQLData</code> interface, as <code>SQLData</code> implementations can wrap only structured object types.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007794">&#34;Serialized Java Objects&#34;</a></div>
<p class="subhead2"><a id="JSQLJ431"></a>General <a id="sthref332"></a><a id="sthref333"></a><a id="sthref334"></a>Use of ORAData: BetterDate.java</p>
<p>This example shows a class that implements the <code>ORAData</code> interface to provide a customized representation of Java dates and can be used instead of <code>java.sql.Date</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This is not a complete application. There is no <code>main()</code> method.</div>
<pre>import java.util.Date;
import oracle.sql.ORAData;
import oracle.sql.DATE;
import oracle.sql.ORADataFactory;
import oracle.jdbc.OracleTypes;

// a Date class customized for user&#39;s preferences:
//      - months are numbers 1..12, not 0..11
//      - years are referred to through four-digit numbers, not two.

public class BetterDate extends java.util.Date
             implements ORAData, ORADataFactory {
  public static final int _SQL_TYPECODE = OracleTypes.DATE;
  
  String[]monthNames={&#34;JAN&#34;, &#34;FEB&#34;, &#34;MAR&#34;, &#34;APR&#34;, &#34;MAY&#34;, &#34;JUN&#34;,
                      &#34;JUL&#34;, &#34;AUG&#34;, &#34;SEP&#34;, &#34;OCT&#34;, &#34;NOV&#34;, &#34;DEC&#34;};
  String[]toDigit={&#34;0&#34;, &#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34;, &#34;9&#34;};

  static final BetterDate _BetterDateFactory = new BetterDate();

  public static ORADataFactory getORADataFactory() { return _BetterDateFactory;}

  // the current time...
  public BetterDate() {
    super();
  }

  public oracle.sql.Datum toDatum(java.sql.Connection conn) {
    return new DATE(toSQLDate());
  }

  public oracle.sql.ORAData create(oracle.sql.Datum dat, int intx) {
    if (dat==null) return null;
    DATE DAT = ((DATE)dat);
    java.sql.Date jsd = DAT.dateValue();
    return new BetterDate(jsd);
  }
   
  public java.sql.Date toSQLDate() {
    java.sql.Date retval;
    retval = new java.sql.Date(this.getYear()-1900, this.getMonth()-1,
             this.getDate());
    return retval;
  }
  public BetterDate(java.sql.Date d) {
    this(d.getYear()+1900, d.getMonth()+1, d.getDate());
  }
  private static int [] deconstructString(String s) {
    int [] retval = new int[3];
    int y,m,d; char temp; int offset;
    StringBuffer sb = new StringBuffer(s);
    temp=sb.charAt(1);
    // figure the day of month
    if (temp &lt; &#39;0&#39; || temp &gt; &#39;9&#39;) {
      m = sb.charAt(0)-&#39;0&#39;;
      offset=2;
    } else {
      m = (sb.charAt(0)-&#39;0&#39;)*10 + (temp-&#39;0&#39;);
      offset=3;
    }

    // figure the month
    temp = sb.charAt(offset+1);
    if (temp &lt; &#39;0&#39; || temp &gt; &#39;9&#39;) {
      d = sb.charAt(offset)-&#39;0&#39;;
      offset+=2;
    } else {
      d = (sb.charAt(offset)-&#39;0&#39;)*10 + (temp-&#39;0&#39;);
      offset+=3;
    }

    // figure the year, which is either in the format &#34;yy&#34; or &#34;yyyy&#34;
    // (the former assumes the current century)
    if (sb.length() &lt;= (offset+2)) {
      y = (((new BetterDate()).getYear())/100)*100 +
          (sb.charAt(offset)- &#39;0&#39;) * 10 +
          (sb.charAt(offset+1)- &#39;0&#39;);
    } else {
      y = (sb.charAt(offset)- &#39;0&#39;) * 1000 +
          (sb.charAt(offset+1)- &#39;0&#39;) * 100 +
          (sb.charAt(offset+2)- &#39;0&#39;) * 10 +
          (sb.charAt(offset+3)- &#39;0&#39;);
    }
    retval[0]=y;
    retval[1]=m;
    retval[2]=d;
//    System.out.println(&#34;Constructing date from string as: &#34;+d+&#34;/&#34;+m+&#34;/&#34;+y);
    return retval;
  }
  private BetterDate(int [] stuff) {
    this(stuff[0], stuff[1], stuff[2]);
  }
  // takes a string in the format: &#34;mm-dd-yyyy&#34; or &#34;mm/dd/yyyy&#34; or
  // &#34;mm-dd-yy&#34; or &#34;mm/dd/yy&#34; (which assumes the current century)
  public BetterDate(String s) {
    this(BetterDate.deconstructString(s));
  }

  // years are as &#39;1990&#39;, months from 1..12 (unlike java.util.Date!), date
  // as &#39;1&#39; to &#39;31&#39; 
  public BetterDate(int year, int months, int date) {
    super(year-1900,months-1,date);
  }
  // returns &#34;Date: dd-mon-yyyy&#34;
  public String toString() { 
    int yr = getYear();
    return getDate()+&#34;-&#34;+monthNames[getMonth()-1]+&#34;-&#34;+
      toDigit[(yr/1000)%10] + 
      toDigit[(yr/100)%10] + 
      toDigit[(yr/10)%10] + 
      toDigit[yr%10];
//    return &#34;Date: &#34; + getDate() + &#34;-&#34;+getMonth()+&#34;-&#34;+(getYear()%100);
  }
  public BetterDate addDays(int i) {
    if (i==0) return this;
    return new BetterDate(getYear(), getMonth(), getDate()+i);
  }
  public BetterDate addMonths(int i) {
    if (i==0) return this;
    int yr=getYear();
    int mon=getMonth()+i;
    int dat=getDate();
    while(mon&lt;1) { 
      --yr;mon+=12;
    }
    return new BetterDate(yr, mon,dat);
  }
  // returns year as in 1996, 2007
  public int getYear() {
    return super.getYear()+1900;
  }
  // returns month as 1..12
  public int getMonth() {
    return super.getMonth()+1;
  }
  public boolean equals(BetterDate sd) {
    return (sd.getDate() == this.getDate() &amp;&amp;
            sd.getMonth() == this.getMonth() &amp;&amp;
            sd.getYear() == this.getYear());
  }
  // subtract the two dates; return the answer in whole years
  // uses the average length of a year, which is 365 days plus
  // a leap year every 4, except 100, except 400 years =
  // = 365 97/400 = 365.2425 days = 31,556,952 seconds
  public double minusInYears(BetterDate sd) {
    // the year (as defined in the preceding text) in milliseconds
    long yearInMillis = 31556952L;
    long diff = myUTC()-sd.myUTC();
    return (((double)diff/(double)yearInMillis)/1000.0);
  }
  public long myUTC() {
    return Date.UTC(getYear()-1900, getMonth()-1, getDate(),0,0,0);
  }
  
  // returns &lt;0 if this is earlier than sd
  // returns = if this == sd
  // else returns &gt;0
  public int compare(BetterDate sd) {
    if (getYear()!=sd.getYear()) {return getYear()-sd.getYear();}
    if (getMonth()!=sd.getMonth()) {return getMonth()-sd.getMonth();}
    return getDate()-sd.getDate();
  }
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006214"></a>
<div id="JSQLJ432" class="sect1">
<h2 class="sect1">User-Defined <a id="sthref335"></a>Types</h2>
<p>This section contains examples of creating and using user-defined object types and collection types in Oracle Database 12<span class="italic">c</span> Release 1 (12.1).</p>
<p class="subhead2"><a id="i1006222"></a><a id="JSQLJ433"></a>Creating <a id="sthref336"></a>Object Types</p>
<p>SQL commands to create object types are of the following form:</p>
<pre>CREATE TYPE <span class="italic">typename</span> AS OBJECT
( 
  <span class="italic">attrname1    datatype1</span>,
  <span class="italic">attrname2    datatype2</span>,
  ...         ...
  <span class="italic">attrnameN    datatypeN</span>
);
</pre>
<p>Where <code><span class="codeinlineitalic">typename</span></code> is the desired name of your object type, <code><span class="codeinlineitalic">attrname1</span></code> through <code><span class="codeinlineitalic">attrnameN</span></code> are the desired attribute names, and <code><span class="codeinlineitalic">datatype1</span></code> through <code><span class="codeinlineitalic">datatypeN</span></code> are the attribute data types.</p>
<p>The remainder of this section provides an example of creating user-defined object types in Oracle Database 12<span class="italic">c</span> Release 1 (12.1).</p>
<p>In this example, the following items are created using SQL:</p>
<ul>
<li>
<p>Two object types, <code>PERSON</code> and <code>ADDRESS</code></p>
</li>
<li>
<p>A typed table for <code>PERSON</code> objects</p>
</li>
<li>
<p>An <code>EMPLOYEES</code> table that includes an <code>ADDRESS</code> column and two columns of <code>PERSON</code> references</p>
</li>
</ul>
<p>The script for creating these items is as follows:</p>
<pre>/*** Using user-defined types (UDTs) in SQLJ ***/
/
/*** Create ADDRESS UDT ***/
CREATE TYPE ADDRESS AS OBJECT
( 
  street        VARCHAR(60),
  city          VARCHAR(30),
  state         CHAR(2),
  zip_code      CHAR(5)
)
/
/*** Create PERSON UDT containing an embedded ADDRESS UDT ***/
CREATE TYPE PERSON AS OBJECT
( 
  name    VARCHAR(30),
  ssn     NUMBER,
  addr    ADDRESS
)
/
/*** Create a typed table for PERSON objects ***/
CREATE TABLE persons OF PERSON
/
/*** Create a relational table with two columns that are REFs 
     to PERSON objects, as well as a column which is an Address ADT. ***/
CREATE TABLE  employees
( 
  empnumber            INTEGER PRIMARY KEY,
  person_data     REF  PERSON,
  manager         REF  PERSON,
  office_addr          ADDRESS,
  salary               NUMBER
)
/*** Insert some data--2 objects into the persons typed table ***/
INSERT INTO persons VALUES (
            PERSON(&#39;Wolfgang Amadeus Mozart&#39;, 123456,
               ADDRESS(&#39;Am Berg 100&#39;, &#39;Salzburg&#39;, &#39;AT&#39;,&#39;10424&#39;)))
/
INSERT INTO persons VALUES (
            PERSON(&#39;Ludwig van Beethoven&#39;, 234567,
               ADDRESS(&#39;Rheinallee&#39;, &#39;Bonn&#39;, &#39;DE&#39;, &#39;69234&#39;)))
/
/** Put a row in the employees table **/
INSERT INTO employees (empnumber, office_addr, salary) VALUES (
            1001,
            ADDRESS(&#39;500 Oracle Parkway&#39;, &#39;Redwood Shores&#39;, &#39;CA&#39;, &#39;94065&#39;),
            50000)
/
/** Set the manager and PERSON REFs for the employee **/
UPDATE employees 
   SET manager =  
       (SELECT REF(p) FROM persons p WHERE p.name = &#39;Wolfgang Amadeus Mozart&#39;)
/
UPDATE employees 
   SET person_data =  
       (SELECT REF(p) FROM persons p WHERE p.name = &#39;Ludwig van Beethoven&#39;)
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Use of a table alias, such as <code>p</code> in the example, is a recommended general practice in the Oracle SQL implementation, especially in accessing tables with user-defined types. It is required syntax in some cases where object attributes are accessed. Even when not required, it helps in avoiding ambiguities. Refer to the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about table aliases.</div>
<p class="subhead2"><a id="i1006305"></a><a id="JSQLJ434"></a>Creating <a id="sthref337"></a>Collection Types</p>
<p>There are two categories of collections</p>
<ul>
<li>
<p>Variable-length arrays (VARRAYs)</p>
</li>
<li>
<p>Nested tables</p>
</li>
</ul>
<p>SQL commands to create VARRAY types are of the following form:</p>
<pre>CREATE TYPE <span class="italic">typename</span> IS VARRAY(<span class="italic">n</span>) OF <span class="italic">datatype</span>;
</pre>
<p>The <code><span class="codeinlineitalic">typename</span></code> designation is the desired name of your VARRAY type, <code><span class="codeinlineitalic">n</span></code> is the desired maximum number of elements in the array, and <code><span class="codeinlineitalic">datatype</span></code> is the data type of the array elements. For example:</p>
<pre>CREATE TYPE myvarr IS VARRAY(10) OF INTEGER;
</pre>
<p>SQL commands to create nested table types are of the following form:</p>
<pre>CREATE TYPE <span class="italic">typename</span> AS TABLE OF <span class="italic">datatype</span>;
</pre>
<p>The <code><span class="codeinlineitalic">typename</span></code> designation is the desired name of your nested table type and <code><span class="codeinlineitalic">datatype</span></code> is the data type of the table elements. This can be a user-defined type as well as a standard data type. A nested table is limited to one column, although that one column type can be a complex object with multiple attributes. The nested table, as with any database table, can have any number of rows. For example:</p>
<pre>CREATE TYPE person_array AS TABLE OF person;
</pre>
<p>This command creates a nested table where each row consists of a <code>PERSON</code> object.</p>
<p>The rest of this section provides an example of creating a user-defined collection type, as well as object types, in Oracle Database 12<span class="italic">c</span> Release 1 (12.1).</p>
<p>The following items are created and populated using SQL:</p>
<ul>
<li>
<p>Two object types, <code>PARTICIPANT_T</code> and <code>MODULE_T</code></p>
</li>
<li>
<p>A collection type, <code>MODULETBL_T</code>, which is a nested table of <code>MODULE_T</code> objects</p>
</li>
<li>
<p>A <code>PROJECTS</code> table that includes a column of <code>PARTICIPANT_T</code> references and a column of <code>MODULETBL_T</code> nested tables</p>
</li>
<li>
<p>A collection type <code>PHONE_ARRAY</code>, which is a VARRAY of <code>VARCHAR2(30)</code></p>
</li>
<li>
<p><code>PERSON</code> and <code>ADDRESS</code> objects (repeating the same definitions used earlier in <a href="#i1006222">&#34;Creating Object Types&#34;</a>)</p>
</li>
<li>
<p>An <code>EMPLOYEES</code> table, which includes a <code>PHONE_ARRAY</code> column</p>
</li>
</ul>
<p>The script for creating these items is as follows:</p>
<pre>Rem This is a SQL*Plus script used to create schema to demonstrate collection 
Rem manipulation in SQLJ 

CREATE TYPE PARTICIPANT_T AS OBJECT (
  empno   NUMBER(4),
  ename   VARCHAR2(20),
  job     VARCHAR2(12),
  mgr     NUMBER(4),
  hiredate DATE,
  sal      NUMBER(7,2),
  deptno   NUMBER(2)) 
/
SHOW ERRORS 
CREATE TYPE MODULE_T  AS OBJECT (
  module_id  NUMBER(4),
  module_name VARCHAR2(20), 
  module_owner REF PARTICIPANT_T, 
  module_start_date DATE, 
  module_duration NUMBER )
/
SHOW ERRORS
CREATE TYPE MODULETBL_T AS TABLE OF MODULE_T;
/
SHOW ERRORS
CREATE TABLE projects (
  id NUMBER(4),
  name VARCHAR(30),
  owner REF PARTICIPANT_T,
  start_date DATE,
  duration NUMBER(3),
  modules  MODULETBL_T  ) NESTED TABLE modules STORE AS modules_tab;

SHOW ERRORS
CREATE TYPE PHONE_ARRAY IS VARRAY (10) OF varchar2(30)
/

/*** Create ADDRESS UDT ***/
CREATE TYPE ADDRESS AS OBJECT
( 
  street        VARCHAR(60),
  city          VARCHAR(30),
  state         CHAR(2),
  zip_code      CHAR(5)
)
/
/*** Create PERSON UDT containing an embedded ADDRESS UDT ***/
CREATE TYPE PERSON AS OBJECT
( 
  name    VARCHAR(30),
  ssn     NUMBER,
  addr    ADDRESS
)
/
CREATE TABLE  employees
( empnumber            INTEGER PRIMARY KEY,
  person_data     REF  person,
  manager         REF  person,
  office_addr          address,
  salary               NUMBER,
  phone_nums           phone_array
)
/
</pre></div>
<!-- class="sect1" -->
<a id="i1006402"></a>
<div id="JSQLJ435" class="sect1">
<h2 class="sect1">JPublisher <a id="sthref338"></a><a id="sthref339"></a>and the Creation of Custom Java Classes</h2>
<p>Oracle offers flexibility in how users can customize the mapping of Oracle object types, reference types, and collection types to Java classes in a strongly typed paradigm. Developers have the following choices in creating these custom Java classes:</p>
<ul>
<li>
<p>Using Oracle JPublisher utility to automatically generate custom Java classes and using those classes directly without modification</p>
</li>
<li>
<p>Using JPublisher to automatically generate custom Java classes and corresponding subclasses, which can subsequently be user-modified for any desired functionality</p>
</li>
<li>
<p>Manually coding custom Java classes without using JPublisher, if the classes meet the requirements stated in <a href="#i1005834">&#34;Custom Java Class Requirements&#34;</a></p>
</li>
</ul>
<p>Although you have the option of manually coding your custom Java classes, it is advisable to instead use JPublisher-generated classes directly or modify JPublisher-generated subclasses.</p>
<p>JPublisher can implement either the Oracle <code>oracle.sql.ORAData</code> interface or the standard <code>java.sql.SQLData</code> interface when it generates a custom object class. If you choose the <code>ORAData</code> implementation, then JPublisher will also generate a custom reference class.</p>
<p>The <code>SQLData</code> interface is not intended for custom reference or custom collection classes. If you want your code to be portable, then you have no choice but to use standard weakly typed <code>java.sql.Ref</code> objects to map to references and <code>java.sql.Array</code> objects to map to collections.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1006430">What JPublisher Produces</a></p>
</li>
<li>
<p><a href="#i1006488">Generating Custom Java Classes</a></p>
</li>
<li>
<p><a href="#BABHFBIH">JPublisher INPUT Files and Properties Files</a></p>
</li>
<li>
<p><a href="#i1006908">Creating Custom Java Classes and Specifying Member Names</a></p>
</li>
<li>
<p><a href="#i1006926">JPublisher Implementation of Wrapper Methods</a></p>
</li>
<li>
<p><a href="#i1006955">JPublisher Custom Java Class Examples</a></p>
</li>
<li>
<p><a href="#i1007148">Extending Classes Generated by JPublisher</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a></p>
</li>
<li>
<p><a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></p>
</li>
</ul>
</div>
<a id="i1006430"></a>
<div id="JSQLJ436" class="sect2">
<h3 class="sect2">What <a id="sthref340"></a>JPublisher Produces</h3>
<p>When you use JPublisher to generate custom Java classes, you can use either an <code>ORAData</code> implementation, for custom object classes, custom reference classes, or custom collection classes, or a <code>SQLData</code> implementation, for custom object classes only. An <code>ORAData</code> implementation will also implement the <code>ORADataFactory</code> interface, for creating instances of the custom Java class.</p>
<p>This is controlled by how you set the JPublisher <code>-usertypes</code> option. A setting of <code>-usertypes=oracle</code> specifies an <code>ORAData</code> implementation, and a setting of <code>-usertypes=jdbc</code> specifies a <code>SQLData</code> implementation.</p>
<p class="subhead2"><a id="JSQLJ437"></a>ORAData Implementation</p>
<p>When you run JPublisher for a user-defined object type and use the <code>ORAData</code> implementation for your custom object class, JPublisher automatically creates the following:</p>
<ul>
<li>
<p>A custom object class, typically in a <code>.sqlj</code> source file, to act as a type definition to correspond to your Oracle object type</p>
<p>This class includes accessor methods for each attribute. For example, <code>getFoo()</code> and <code>setFoo()</code> are the accessor methods for the attribute <code>foo</code>. In addition, JPublisher by default will generate wrapper methods in your class that invoke the associated Oracle object methods executing in the server. However, this can be disabled by setting <code>-methods=false</code>. In this case, JPublisher produces no wrapper methods and generates <code>.java</code> files instead of <code>.sqlj</code> files for custom objects.</p>
</li>
<li>
<p>A related custom reference class for object references to your Oracle object type</p>
<p>This class includes a <code>getValue()</code> method that returns an instance of your custom object class and a <code>setValue()</code> method that updates an object value in the database, taking as input an instance of the custom object class.</p>
<p>A strongly typed reference class is always generated, regardless of whether the SQL object type uses references.</p>
</li>
<li>
<p>Custom classes for any object or collection attributes of the top-level object</p>
<p>This is necessary so that attributes can be materialized in Java whenever an instance of the top-level class is materialized.</p>
</li>
</ul>
<p>When you run JPublisher for a user-defined collection type, choosing the <code>ORAData</code> implementation, JPublisher automatically creates the following:</p>
<ul>
<li>
<p>A custom collection class to act as a type definition to correspond to your Oracle collection type</p>
<p>This class includes overloaded <code>getArray()</code> and <code>setArray()</code> methods to retrieve or update a collection as a whole, a <code>getElement()</code> method and <code>setElement()</code> method to retrieve or update individual elements of a collection, and additional utility methods.</p>
</li>
<li>
<p>A custom object class for the elements, if the elements of the collection are objects</p>
<p>This is necessary so that object elements can be materialized in Java whenever an instance of the collection is materialized.</p>
</li>
</ul>
<p>JPublisher-generated custom Java classes in any of these categories implement the <code>ORAData</code> interface, the <code>ORADataFactory</code> interface, and the <code>getORADataFactory()</code> method.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you specify the <code>ORAData</code> implementation, then the generated classes will use Oracle-specific features and, therefore, will not be portable.</div>
<p class="subhead2"><a id="i1006471"></a><a id="JSQLJ438"></a>Strongly Typed Object References for ORAData Implementations</p>
<p>For Oracle <code>ORAData</code> implementations, JPublisher always generates strongly typed object reference classes as opposed to using the weakly typed <code>oracle.sql.REF</code> class. This is to provide greater type safety and to mirror the behavior in SQL, where object references are strongly typed. The strongly typed classes, with names like <code>PersonRef</code> for references to <code>PERSON</code> objects, are essentially wrappers for the <code>REF</code> class.</p>
<p>In these strongly typed <code>REF</code> wrappers, there is a <code>getValue()</code> method that produces an instance of the SQL object that is referenced, in the form of an instance of the corresponding Java class. (Or, in the case of inheritance, perhaps as an instance of a subclass of the corresponding Java class.) For example, if there is a <code>PERSON</code> SQL object type with a corresponding <code>Person</code> Java class, then there will also be a <code>PersonRef</code> Java class. The <code>getValue()</code> method of the <code>PersonRef</code> class would return a <code>Person</code> instance containing the data for a <code>PERSON</code> object in the database.</p>
<p>Whenever a SQL object type has an attribute that is an object reference, the Java class corresponding to the object type would have an attribute that is an instance of a Java class corresponding to the appropriate reference type. For example, if there is a <code>PERSON</code> object with a <code>MANAGER REF</code> attribute, then the corresponding <code>Person</code> Java class will have a <code>ManagerRef</code> attribute.</p>
<p class="subhead2"><a id="JSQLJ439"></a>SQLData Implementation</p>
<p>When you run JPublisher for a user-defined object type and choose the <code>SQLData</code> implementation for your custom object class, JPublisher will produce a custom object class to act as a type definition to correspond to your Oracle object type. This class will include the following:</p>
<ul>
<li>
<p>Accessor methods for each attribute</p>
</li>
<li>
<p>Implementations of the <code>readSQL()</code> and <code>writeSQL()</code> methods of the standard <code>SQLData</code> interface</p>
</li>
<li>
<p>Wrapper methods that invoke the Oracle object methods executing in the server, unless you specify <code>-methods=false</code> when you run JPublisher</p>
</li>
</ul>
<p>Because the <code>SQLData</code> interface is intended only for objects, however, and not for references or collections, JPublisher will not generate a custom reference class for references to the Oracle object type. You will have to use standard weakly typed <code>java.sql.Ref</code> instances or perhaps <code>oracle.sql.REF</code> instances, if you do not require portability. Note that <code>REF</code> instances, like custom reference class instances, have Oracle extension methods, <code>getValue()</code> and <code>setValue()</code>, to read or write instances of the referenced object. Standard <code>Ref</code> instances do not have this functionality.</p>
<p>Similarly, because you cannot use a <code>SQLData</code> implementation for a custom collection class, you must use standard weakly typed <code>java.sql.Array</code> instances or perhaps <code>oracle.sql.ARRAY</code> instances, if you do not require portability. <code>Array</code> and <code>ARRAY</code> instances, like custom collection class instances, have <code>getArray()</code> functionality to read the collection as a whole or in part, but do not have the element-level access and writability offered by the <code>getElement()</code> and <code>setElement()</code> methods of the custom collection class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>SQLData</code> interface is defined in the JDBC specification to be portable. However, if you want the <code>SQLData</code> implementation produced by JPublisher to be portable, then you must avoid using any Oracle-specific features and Oracle type mapping, which uses the Oracle specific <code>oracle.sql.*</code> classes.</div>
</div>
<!-- class="sect2" -->
<a id="i1006488"></a>
<div id="JSQLJ440" class="sect2">
<h3 class="sect2">Generating <a id="sthref341"></a><a id="sthref342"></a>Custom Java Classes</h3>
<p>This section discusses key JPublisher command-line functionality for specifying the user-defined types that you want to map to Java and for specifying object class names, collection class names, attribute type mappings, and wrapper methods. These key points can be summarized as follows:</p>
<ul>
<li>
<p>Specify the implementation to use, through the JPublisher <code>-usertypes</code> option.</p>
</li>
<li>
<p>Specify user-defined types to map to Java. You can specify the custom object and custom collection class names for JPublisher to use, or you can accept the default names. Use the JPublisher <code>-sql</code>, <code>-user</code>, and <code>-case</code> options, as appropriate.</p>
</li>
<li>
<p>Optionally specify attribute type mappings through the JPublisher <code>-</code><code><span class="codeinlineitalic">xxx</span></code><code>types</code> options: <code>-numbertypes</code>, <code>-builtintypes</code>, and <code>-lobtypes</code>.</p>
</li>
<li>
<p>Choose whether or not JPublisher will create wrapper methods, in particular for Oracle object methods. Use the JPublisher <code>-methods</code> flag, which is enabled by default.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Throughout the remainder of this section, discussion of custom reference classes or custom collection classes is simplified by referring only to <code>ORAData</code> implementations.</div>
<p class="subhead2"><a id="i1006501"></a><a id="JSQLJ441"></a>Choose the Implementation for Generated Classes</p>
<p>Before running JPublisher, consider whether you want the generated classes to implement the Oracle <code>ORAData</code> interface or the standard <code>SQLData</code> interface. Using <code>SQLData</code> will likely make your code more portable, but using <code>ORAData</code> offers a number of advantages, including no need for type maps.</p>
<p>Remember the following:</p>
<ul>
<li>
<p>You must use <code>ORAData</code> implementations for custom collection classes. The <code>SQLData</code> interface does not support collections.</p>
</li>
<li>
<p>Strongly typed reference classes are always generated for <code>ORAData</code> custom object class implementations, but not for <code>SQLData</code> custom object class implementations. The SQLData interface does not support strongly typed object references. Use the weak <code>java.sql.Ref</code> type or <code>oracle.sql.REF</code> type instead.</p>
</li>
</ul>
<p>Use the JPublisher <code>-usertypes</code> option to specify which interface you want your classes to implement. A setting of <code>-usertypes=oracle</code>, which is the default, specifies the <code>ORAData</code> interface, while a setting of <code>-usertypes=jdbc</code> specifies the <code>SQLData</code> interface.</p>
<p>The following JPublisher command-line examples will result in implementation of <code>ORAData</code> and <code>SQLData</code>, respectively (assume <code>%</code> is a system prompt).</p>
<pre>% jpub -usertypes=oracle ... &lt;<span class="italic">other option settings</span>&gt;

% jpub -usertypes=jdbc ... &lt;<span class="italic">other option settings</span>&gt;
</pre>
<p class="subhead2"><a id="i1006541"></a><a id="JSQLJ442"></a>Specify User-Defined <a id="sthref343"></a><a id="sthref344"></a><a id="sthref345"></a><a id="sthref346"></a>Types to Map to Java</p>
<p>In using JPublisher to create custom Java classes, use the <code>-sql</code> option to specify the user-defined SQL types that you want to map to Java. You can either specify the custom object class names and custom collection class names, or you can accept the defaults.</p>
<p><a id="sthref347"></a><a id="sthref348"></a>The default names of your top-level custom classes, the classes that will correspond to the user-defined type names you specify to the <code>-sql</code> option, are identical to the user-defined type names as you enter them on the JPublisher command line. Because SQL names in the database are not case-sensitive by default, you can capitalize them to ensure that your class names are capitalized according to Java convention. For example, if you want to generate a custom class for <code>employee</code> objects, you can run JPublisher as follows:</p>
<pre>% jpub -sql=Employee ...
</pre>
<p>The default names of other classes, such as for the <code>home_address</code> objects that are attributes of <code>employee</code> objects, are determined by the JPublisher <code>-case</code> option. If you do not set the <code>-case</code> option, then it is set to <code>mixed</code>. This means that the default for the custom class name is to capitalize the initial character of the corresponding user-defined type name and the initial character of every word unit thereafter. JPublisher interprets underscores (_), dollar signs ($), and any characters that are illegal in Java identifiers as word-unit separators. These characters are discarded in the process.</p>
<p>For example, for Oracle object type <code>home_address</code>, JPublisher would create class <code>HomeAddress</code> in a <code>HomeAddress.sqlj</code> or <code>.java</code> source file.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Only SQL names that are not cas<a id="sthref349"></a>e-sensitiveare supported on the JPublisher command line. If a user-defined type was defined in a case-sensitive way in SQL, then you must specify the name in the JPublisher <code>INPUT</code> file instead of on the command line and in quotes.</p>
</li>
<li>
<p><a id="sthref350"></a><a id="sthref351"></a>For backward compatibility to previous versions of JPublisher, the <code>-types</code> option is still accepted as an alternative to <code>-sql</code>.</p>
</li>
</ul>
</div>
<p><a id="sthref352"></a><a id="sthref353"></a>On the JPublisher command line, use the following syntax for the <code>-sql</code> option:</p>
<pre>-sql=<span class="italic">udt1</span>&lt;:<span class="italic">mapclass1</span>&gt;&lt;,<span class="italic">udt2</span>&lt;:<span class="italic">mapclass2</span>&gt;&gt;,...,&lt;<span class="italic">udtN</span>&lt;:<span class="italic">mapclassN</span>&gt;&gt; ...
</pre>
<p>Note that you can specify multiple actions in a single option setting.</p>
<p>Use the <code>-user</code> option to specify the database schema. Following is an example:</p>
<pre>% jpub -sql=Myobj,mycoll:MyCollClass -user=HR
Enter HR password: <span class="italic">password</span>
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do <span class="italic">not</span> insert a space before or after the comma.</div>
<p>For the <code>MYOBJ</code> Oracle object, this command will name it as you typed it, creating <code>Myobj.sqlj</code> source to define a <code>Myobj</code> class. For the <code>MYCOLL</code> Oracle collection, this command will create source <code>MyCollClass.java</code> to define a <code>MyCollClass</code> class.</p>
<p>You can optionally specify schema names in the <code>-sql</code> option, such as in the following example that specifies the <code>HR</code> schema:</p>
<pre>% jpub -sql=HR.Myobj,HR.mycoll:MyCollClass -user=HR
Enter HR password: <span class="italic">password</span>
</pre>
<p>You cannot specify custom reference class names. JPublisher automatically derives them by adding <code>Ref</code> to custom object class names. This is relevant to <code>ORAData</code> implementations only. For example, if JPublisher produces the <code>Myobj.sqlj</code> Java source to define the <code>Myobj</code> custom object class, then it will also produce the <code>MyobjRef.java</code> Java source to define a <code>MyobjRef</code> custom reference class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When specifying the schema, such as <code>HR</code> in the preceding example, this is not incorporated into the custom Java class name.</div>
<p>To create custom Java classes for the object and collection types defined in <a href="#i1006214">&#34;User-Defined Types&#34;</a>, you can run JPublisher as follows:</p>
<pre>% jpub -user=HR -sql=Address,Person,Phone_array,Participant_t,Module_t,Moduletbl_t
Enter HR password: <span class="italic">password</span>
</pre>
<p>Alternatively, to explicitly specify custom object class and custom collection class names, run it as follows:</p>
<pre>% jpub -user=HR -sql=Address,Person,phone_array:PhoneArray,
participant_t:ParticipantT,module_t:ModuleT,moduletbl_t:ModuletblT
Enter HR password: <span class="italic">password</span>
</pre>
<p>Note that each of the preceding two examples is a single wraparound command line.</p>
<p>The second example will produce the following Java source files: <code>Address.sqlj</code>, <code>AddressRef.java</code>, <code>Person.sqlj</code>, <code>PersonRef.java</code>, <code>PhoneArray.java</code>, <code>ParticipantT.sqlj</code>, <code>ParticipantTRef.java</code>, <code>ModuleT.sqlj</code>, <code>ModuleTRef.java</code>, and <code>ModuletblT.java</code>. Examples of some of these source files are provided in <a href="#i1006955">&#34;JPublisher Custom Java Class Examples&#34;</a>.</p>
<p>So that it knows how to populate the custom Java classes, JPublisher connects to the specified schema to determine attributes of your specified object types or elements of your specified collection types.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
As an alternative to specifying multiple mappings in a single <code>-sql</code> setting, you can use multiple <code>-sql</code> options in the same command line. The effect of multiple <code>-sql</code> options is cumulative.</div>
<p><a id="sthref354"></a><a id="sthref355"></a>If you want to change how JPublisher uses character case in default names for the methods and attributes that it generates, including lower-level custom Java class names for attributes that are objects or collections, then you can accomplish this using the <code>-case</code> option. There are four possible settings:</p>
<ul>
<li>
<p><code>-case=mixed</code> (default)</p>
<p>The following will be uppercase: the first character of every word unit of a class name, every word unit of an attribute name, and every word unit after the first word unit of a method name. All other characters are in lowercase. JPublisher interprets underscores (_), dollar signs ($), and any characters that are illegal in Java identifiers as word-unit separators. These characters are discarded in the process.</p>
</li>
<li>
<p><code>-case=same</code></p>
<p>Character case is unchanged from its representation in the database. Underscores and dollar signs are retained, and illegal characters are discarded.</p>
</li>
<li>
<p><code>-case=upper</code></p>
<p>Lowercase letters are converted to uppercase. Underscores and dollar signs are retained, and illegal characters are discarded.</p>
</li>
<li>
<p><code>-case=lower</code></p>
<p>Uppercase letters are converted to lowercase. Underscores and dollar signs are retained, and illegal characters are discarded.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you run JPublisher without specifying the user-defined types to map to Java, it will process all user-defined types in the schema. Generated class names, for both your top-level custom classes and any other classes for object attributes or collection elements, will be based on the setting of the <code>-case</code> option.</div>
<p class="subhead2"><a id="i1006626"></a><a id="JSQLJ443"></a>Specify Type Ma<a id="sthref356"></a><a id="sthref357"></a><a id="sthref358"></a><a id="sthref359"></a>ppings</p>
<p>JPublisher offers several choices for how to map user-defined types and their attribute and element types between SQL and Java.</p>
<p>JPublisher categorizes <a id="sthref360"></a>SQL types into the following groups, with corresponding JPublisher options as noted:</p>
<ul>
<li>
<p>Numeric types: Anything stored as SQL type <code>NUMBER</code></p>
<p>Use the JPublisher <code>-number<a id="sthref361"></a><a id="sthref362"></a>types</code> option to specify type-mapping for numeric types.</p>
</li>
<li>
<p>Large object (LOB) types: SQL types <code>BLOB</code> and <code>CLOB</code></p>
<p>Use the JPublisher <code>-lobt<a id="sthref363"></a><a id="sthref364"></a>ypes</code> option to specify type-mapping for LOB types.</p>
</li>
<li>
<p>Built-in types: Anything stored as a SQL type not covered by the preceding categories, for example, <code>CHAR</code>, <code>VARCHAR2</code>, <code>LONG</code>, and <code>RAW</code></p>
<p>Use the JPublisher <code>-built<a id="sthref365"></a><a id="sthref366"></a>intypes</code> option to specify type-mapping for built-in types.</p>
</li>
</ul>
<p>JPublisher defines the following type-<a id="sthref367"></a>mapping modes:</p>
<ul>
<li>
<p><a id="sthref368"></a><a id="sthref369"></a>JDBC mapping (setting <code>jdbc</code>): Uses standard default mappings between SQL types and Java native types. This setting is valid for the <code>-numbertypes</code>, <code>-lobtypes</code>, and <code>-builtintypes</code> options.</p>
</li>
<li>
<p><a id="sthref370"></a><a id="sthref371"></a>Oracle mapping (setting <code>oracle</code>): Uses corresponding <code>oracle.sql</code> types to map to SQL types. This setting is valid for the <code>-numbertypes</code>, <code>-lobtypes</code>, and <code>-builtintypes</code> options.</p>
</li>
<li>
<p><a id="sthref372"></a><a id="sthref373"></a>Object-JDBC mapping (setting <code>objectjdbc</code>): This is an extension of JDBC mapping. Where relevant, object-JDBC mapping uses numeric object types from the standard <code>java.lang</code> package, such as <code>java.lang.Integer</code>, <code>Float</code>, and <code>Double</code>, instead of primitive Java types, such as <code>int</code>, <code>float</code>, and <code>double</code>. The <code>java.lang</code> types are nullable, but the primitive types are not. This setting is valid for the <code>-numbertypes</code> option only.</p>
</li>
<li>
<p><code><a id="sthref374"></a><a id="sthref375"></a>BigDecimal</code> mapping (setting <code>bigdecimal</code>): Uses <code>java.math.BigDecimal</code> to map to all numeric attributes. This is appropriate if you are dealing with large numbers, but do not want to map to the <code>oracle.sql.NUMBER</code> type. This setting is valid for the <code>-numbertypes</code> option only.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Using <code>BigDecimal</code> mapping can significantly degrade performance.</div>
<p>If you do not specify mappings for the attribute types of a SQL object type or the element types of a SQL collection type, then JPublisher uses the following defaults:</p>
<ul>
<li>
<p>For numeric types, object-JDBC mapping is the default mapping.</p>
</li>
<li>
<p>For LOB types, Oracle mapping is the default mapping.</p>
</li>
<li>
<p>For built-in type types, JDBC mapping is the default mapping.</p>
</li>
</ul>
<p>If you want alternate mappings, then use the <code>-numbertypes</code>, <code>-lobtypes</code>, and <code>-builtintypes</code> options as necessary, depending on the attribute types you have and the mappings you desire.</p>
<p>If an attribute type is itself a SQL object type, then it will be mapped according to the <code>-usertypes</code> setting.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you specify a <code>SQLData</code> implementation for the custom object class and want the code to be portable, then you must use portable mappings for the attribute types. The defaults for numeric types and built-in types are portable, but for LOB types you must specify <code>-lobtypes=jdbc</code>.</div>
<p><a href="#CIHEGCEA">Table 6-1</a> summarizes JPublisher categories for SQL types, the mapping settings relevant for each category, and the default settings.</p>
<div id="JSQLJ444" class="tblformal">
<p class="titleintable"><a id="sthref376"></a><a id="CIHEGCEA"></a>Table 6-1 JPublisher SQL Type Categories, Supported Settings, and Defaults</p>
<table class="cellalignment4020" title="JPublisher SQL Type Categories, Supported Settings, and Defaults" summary="summary" dir="ltr">
<thead>
<tr class="cellalignment4011">
<th class="cellalignment4021" id="r1c1-t39">SQL Type Category</th>
<th class="cellalignment4021" id="r1c2-t39">JPublisher Mapping Option</th>
<th class="cellalignment4021" id="r1c3-t39">Mapping Settings</th>
<th class="cellalignment4021" id="r1c4-t39">Default</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r2c1-t39" headers="r1c1-t39">
<p>UDT types</p>
</td>
<td class="cellalignment4017" headers="r2c1-t39 r1c2-t39">
<p><code>-usertypes</code></p>
</td>
<td class="cellalignment4017" headers="r2c1-t39 r1c3-t39">
<p><code>oracle</code>, <code>jdbc</code></p>
</td>
<td class="cellalignment4017" headers="r2c1-t39 r1c4-t39">
<p><code>oracle</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r3c1-t39" headers="r1c1-t39">
<p>Numeric types</p>
</td>
<td class="cellalignment4017" headers="r3c1-t39 r1c2-t39">
<p><code>-numbertypes</code></p>
</td>
<td class="cellalignment4017" headers="r3c1-t39 r1c3-t39">
<p><code>oracle</code>, <code>jdbc</code>, <code>objectjdbc</code>, <code>bigdecimal</code></p>
</td>
<td class="cellalignment4017" headers="r3c1-t39 r1c4-t39">
<p><code>objectjdbc</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r4c1-t39" headers="r1c1-t39">
<p>LOB types</p>
</td>
<td class="cellalignment4017" headers="r4c1-t39 r1c2-t39">
<p><code>-lobtypes</code></p>
</td>
<td class="cellalignment4017" headers="r4c1-t39 r1c3-t39">
<p><code>oracle</code>, <code>jdbc</code></p>
</td>
<td class="cellalignment4017" headers="r4c1-t39 r1c4-t39">
<p><code>oracle</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r5c1-t39" headers="r1c1-t39">
<p>Built-in types</p>
</td>
<td class="cellalignment4017" headers="r5c1-t39 r1c2-t39">
<p><code>-builtintypes</code></p>
</td>
<td class="cellalignment4017" headers="r5c1-t39 r1c3-t39">
<p><code>oracle</code>, <code>jdbc</code></p>
</td>
<td class="cellalignment4017" headers="r5c1-t39 r1c4-t39">
<p><code>jdbc</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The JPublisher <code>-mapping</code> option used in previous releases is deprecated but still supported. For information about how JPublisher converts <code>-mapping</code> option settings to settings for the new mapping options, refer to the <a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a>.</div>
<p class="subhead2"><a id="JSQLJ445"></a>Generate <a id="sthref377"></a><a id="sthref378"></a><a id="sthref379"></a>Wrapper Methods</p>
<p>In creating custom object classes to map Oracle objects to Java, the <code>-methods</code> option instructs JPublisher whether to include Java wrappers for Oracle object methods. The default <code>-methods=true</code> setting generates wrappers and also results in JPublisher generating a <code>.sqlj</code> file instead of a <code>.java</code> file for a custom object class, unless the underlying SQL object actually has no methods.</p>
<p>Wrapper methods generated by JPublisher are always instance methods, even when the original object methods are static. The following example shows how to set the <code>-methods</code> option:</p>
<pre>% jpub -sql=Myobj,mycoll:MyCollClass -user=HR -methods=true
Enter HR password: <span class="italic">password</span>
</pre>
<p>This will use default naming. The Java method names will be derived in the same fashion as custom Java class names, except that the initial character will be lowercase. For example, by default an object method name of <code>CALC_SAL</code> results in a Java wrapper method of <code>calcSal()</code>. Alternatively, you can specify desired Java method names, but this requires use of a JPublisher <code>INPUT</code> file.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>-methods</code> option has additional uses as well, such as for generating wrapper classes for packages or wrapper methods for package methods. This is beyond the scope of this manual. Refer to the <a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a> for information.</div>
<p class="subhead2"><a id="JSQLJ446"></a>Regarding Overloaded Methods</p>
<p>If you run JPublisher for an Oracle object that has an overloaded method where multiple signatures have the same corresponding Java signature, then JPublisher will generate a uniquely named method for each signature. It accomplishes this by appending <code><span class="codeinlineitalic">_n</span></code> to function names, where <code><span class="codeinlineitalic">n</span></code> is a number. This is to ensure that no two methods in the generated custom Java class have the same name and signature. For example, consider the SQL functions defined in creating a <code>MY_TYPE</code> object type:</p>
<pre>CREATE OR REPLACE TYPE my_type AS OBJECT
(
   ...

   MEMBER FUNCTION myfunc(x INTEGER)
      RETURN my_return IS
      BEGIN
         ...
      END;

   MEMBER FUNCTION myfunc(y SMALLINT)
      RETURN my_return IS
      BEGIN
         ...
      END;
   ...
);
</pre>
<p>Without precaution, both definitions of <code>myfunc</code> result in the following name and signature in Java:</p>
<pre>myfunc(Integer)
</pre>
<p>This is because both <code>INTEGER</code> and <code>SMALLINT</code> in SQL map to the Java <code>Integer</code> type.</p>
<p>Instead, JPublisher might call one <code>myfunc_1</code> and the other <code>myfunc_2</code>. The <code><span class="codeinlineitalic">_n</span></code> is unique for each. In simple cases it will likely be <code>_1</code>, <code>_2</code>, and so on, but it might sometimes be arbitrary, other than being unique for each.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
How JPublisher handles overloaded wrapper methods applies to SQL functions created within an object or within a package, but not to top-level functions. Overloading is not allowed at the top level.</div>
<p class="subhead2"><a id="i1006821"></a><a id="JSQLJ447"></a>Generate <a id="sthref380"></a><a id="sthref381"></a><a id="sthref382"></a><a id="sthref383"></a><a id="sthref384"></a>Custom Java Classes and Map Alternate Classes</p>
<p>You can use JPublisher to generate a custom Java class but instruct it to map the object type or collection type to an alternative class instead of to the generated class.</p>
<p>A typical scenario is to treat JPublisher-generated classes as superclasses, extend them to add functionality, and map the object types to the subclasses. For example, presume you have an Oracle object type <code>ADDRESS</code> and want to produce a custom Java class for it that has functionality beyond what is produced by JPublisher. You can use JPublisher to generate a <code>JAddress</code> custom Java class for extending it to produce a <code>MyAddress</code> class. Under this scenario you will add any special functionality to <code>MyAddress</code> and will want JPublisher to map <code>ADDRESS</code> objects to that class, not to the <code>JAddress</code> class. You will also want JPublisher to produce a reference class for <code>MyAddress</code>, not <code>JAddress</code>.</p>
<p>JPublisher has functionality to streamline the process of mapping to alternative classes. Use the following syntax in your <code>-sql</code> option setting:</p>
<pre>-sql=<span class="italic">object_type</span>:<span class="italic">generated_class</span>:<span class="italic">map_class</span>
</pre>
<p>For the preceding example, use this setting:</p>
<pre>-sql=ADDRESS:JAddress:MyAddress
</pre>
<p>This generates class <code>JAddress</code> in source file <code>JAddress.sqlj</code> (or possibly <code>.java</code>) but does the following:</p>
<ul>
<li>
<p>Maps the <code>ADDRESS</code> object type to the <code>MyAddress</code> class, not to the <code>JAddress</code> class. Therefore, if you retrieve an object from the database that has an <code>ADDRESS</code> attribute, then this attribute will be created as an instance of <code>MyAddress</code> in Java. Or, if you retrieve an <code>ADDRESS</code> object directly, then you will retrieve it into a <code>MyAddress</code> instance.</p>
</li>
<li>
<p>Creates a <code>MyAddressRef</code> class in <code>MyAddressRef.java</code>, instead of creating a <code>JAddressRef</code> class.</p>
</li>
<li>
<p>Creates an initial version of the <code>MyAddress</code> class in a <code>MyAddress.sqlj</code> source file (or possibly <code>MyAddress.java</code>), unless the file already exists, in which case it is not changed.</p>
</li>
</ul>
<p><code>MyAddress</code> subclasses <code>JAddress</code>. In order to implement the extended functionality for <code>MyAddress</code>, you can start with the JPublisher-generated <code>MyAddress</code> source file, editing it as desired.</p>
<p>For further discussion about extending JPublisher-generated classes (continuing the preceding example), refer to <a href="#i1007148">&#34;Extending Classes Generated by JPublisher&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABHFBIH"></a>
<div id="JSQLJ448" class="sect2">
<h3 class="sect2">JPublisher INPUT Files and Properties Files</h3>
<p>JPublisher supports the use of special <code>INPUT</code> files and standard properties files to specify type mappings and additional option settings.</p>
<p class="subhead2"><a id="i1006845"></a><a id="JSQLJ449"></a>Using JPu<a id="sthref385"></a>blisher INPUT Files</p>
<p>You can use the JPublisher <code>-input</code> command-line option to specify an <code>INPUT</code> file for JPublisher to use for additional type mappings. <code>SQL</code> in an <code>INPUT</code> file is equivalent to <code>-sql</code> on the command line, and the <code>AS</code> or <code>GENERATE...AS</code> syntax is equivalent to the command-line colon syntax. Use the following syntax, specifying just one mapping per SQL command:</p>
<pre>SQL <span class="italic">udt1</span> &lt;GENERATE <span class="italic">GeneratedClass1</span>&gt; &lt;AS <span class="italic">MapClass1</span>&gt;
SQL <span class="italic">udt2</span> &lt;GENERATE <span class="italic">GeneratedClass2</span>&gt; &lt;AS <span class="italic">MapClass2</span>&gt;
...
</pre>
<p>This generates <code><span class="codeinlineitalic">GeneratedClass1</span></code> and <code><span class="codeinlineitalic">GeneratedClass2</span></code>, but maps <code><span class="codeinlineitalic">udt1</span></code> to <code><span class="codeinlineitalic">MapClass1</span></code> and <code><span class="codeinlineitalic">udt2</span></code> to <code><span class="codeinlineitalic">MapClass2</span></code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a user-defined type was defined in a cas<a id="sthref386"></a>e-sensitive way in SQL, then you must specify the name in quotes. For example:
<pre>SQL &#34;CaseSenstiveType&#34; AS CaseSensitiveType
</pre>
<p>If you are also specifying a schema name that is <span class="italic">not</span> case-sensitive:</p>
<pre>SQL HR.&#34;CaseSensitiveType&#34; AS CaseSensitiveType
</pre>
<p>Alternatively, to also specify a case-sensitive schema name:</p>
<pre>SQL &#34;HR&#34;.&#34;CaseSensitiveType&#34; AS CaseSensitiveType
</pre>
<p>The <code>AS</code> clauses are optional.</p>
<p>Avoid using a period (.) as part of the schema name or type name itself.</p>
</div>
<p class="subhead2"><a id="JSQLJ450"></a>INPUT File Example</p>
<p>In the following example, JPublisher will pick up the <code>-user</code> option from the command line and go to <code>INPUT</code> file <code>myinput.in</code> for type mappings.</p>
<p>Command line:</p>
<pre>% jpub -input=myinput.in -user=HR
Enter HR password: <span class="italic">password</span>
</pre>
<p>Contents of <code>INPUT</code> file <code>myinput.in</code>:</p>
<pre>SQL Myobj
SQL mycoll AS MyCollClass
SQL employee GENERATE Employee AS MyEmployee
</pre>
<p>This accomplishes the following:</p>
<ul>
<li>
<p>User-defined type <code>MYOBJ</code> gets the custom object class name <code>Myobj</code> because that is how you typed it. JPublisher creates source <code>Myobj.sqlj</code> (or possibly <code>Myobj.java</code>, if <code>Myobj</code> has no methods) and <code>MyobjRef.java</code>.</p>
</li>
<li>
<p>User-defined type <code>MYCOLL</code> is mapped to <code>MyCollClass</code>. JPublisher creates a <code>MyCollClass.java</code> source file.</p>
</li>
<li>
<p>User-defined type <code>EMPLOYEE</code> is mapped to the <code>MyEmployee</code> class. JPublisher creates source <code>Employee.sqlj</code> (or possibly <code>Employee.java</code>) and <code>MyEmployeeRef.java</code>, as well as an initial version of <code>MyEmployee.sqlj</code> (or <code>.java</code>) unless the file already exists. If you retrieve an object from the database that has an <code>EMPLOYEE</code> attribute, then this attribute would be created as an instance of <code>MyEmployee</code> in Java. Or, if you retrieve an <code>EMPLOYEE</code> object directly, presumably you will retrieve it into a <code>MyEmployee</code> instance. You are responsible for the <code>MyEmployee</code> code, but for convenience you can start with the JPublisher-generated <code>MyEmployee</code> source file and edit it to implement your specialized functionality for <code>EMPLOYEE</code> objects in Java. <code>MyEmployee</code> subclasses the <code>Employee</code> class.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ451"></a>Using JPub<a id="sthref387"></a>lisher Properties Files</p>
<p>You can use the JPublisher <code>-props</code> command-line option to specify a properties file for JPublisher to use for additional type mappings and other option settings.</p>
<p>In a properties file, <code>jpub.</code> (including the period) is equivalent to the command-line &#34;<code>-</code>&#34; (single-dash), and other syntax remains the same. Specify only one option per line.</p>
<p>For type mappings, for example, <code>jpub.sql</code> is equivalent to <code>-sql</code>. You can specify multiple mappings in a single <code>jpub.sql</code> setting. Alternatively, you can use multiple <code>jpub.sql</code> options. The effect would be cumulative, as for multiple <code>-sql</code> options on the command line.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The behavior of properties files is to ignore any line that does not begin with <code>jpub.</code> or <code>--jpub.</code> (two dashes followed by <code>jpub.</code>). This enables you to use the same file as both a SQL script to create the types and a properties file for JPublisher. If you start each JPublisher statement with &#34;<code>--</code>&#34;, which indicates a SQL comment, it will be ignored by SQL*Plus. And SQL statements will be ignored by JPublisher.</div>
<p class="subhead2"><a id="JSQLJ452"></a>Properties File Example</p>
<p>In the following example, JPublisher will pick up the <code>-user</code> option from the command line and go to the <code>jpub.properties</code> properties file for type mappings and the attribute-mapping option.</p>
<p>Command line:</p>
<pre>% jpub -props=jpub.properties -user=HR
Enter HR password: <span class="italic">password</span>
</pre>
<p>Contents of properties file <code>jpub.properties</code>:</p>
<pre>jpub.sql=Myobj,mycoll:MyCollClass,employee:Employee:MyEmployee
jpub.usertypes=oracle
</pre>
<p>This produces the same results as the preceding input-file example, explicitly specifying the <code>oracle</code> mapping setting.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Unlike SQLJ, JPublisher has no default properties file. To use a properties file, you must use the <code>-props</code> option.</div>
</div>
<!-- class="sect2" -->
<a id="i1006908"></a>
<div id="JSQLJ453" class="sect2">
<h3 class="sect2">Creating <a id="sthref388"></a><a id="sthref389"></a><a id="sthref390"></a><a id="sthref391"></a>Custom Java Classes and Specifying Member Names</h3>
<p>In generating custom Java classes, you can specify the names of any attributes or methods of the custom class. However, this cannot be specified on the JPublisher command line. You must specify it in a JPublisher <code>INPUT</code> file using <code>TRANSLATE</code> syntax, as follows:</p>
<pre>SQL <span class="italic">udt</span> &lt;GENERATE <span class="italic">GeneratedClass</span>&gt; &lt;AS <span class="italic">MapClass</span>&gt; &lt;TRANSLATE <span class="italic">membername1</span> AS <span class="italic">Javaname1</span>&gt; &lt;, <span class="italic">membername2</span> AS <span class="italic">Javaname2</span>&gt; ...
</pre>
<p><code>TRANSLATE</code> pairs (<code><span class="codeinlineitalic">membernameN</span></code> <code>AS</code> <code><span class="codeinlineitalic">JavanameN</span></code>) are separated by commas.</p>
<p>For example, presume the <code>EMPLOYEE</code> Oracle object type has an <code>ADDRESS</code> attribute that you want to call <code>HomeAddress</code>, and a <code>GIVE_RAISE</code> method that you want to call <code>giveRaise()</code>. Also presume that you want to generate an <code>Employee</code> class but map <code>EMPLOYEE</code> objects to a <code>MyEmployee</code> class that you will create. (This is not related to specifying member names, but provides a full example of <code>INPUT</code> file syntax.)</p>
<pre>SQL employee GENERATE Employee AS MyEmployee 
TRANSLATE address AS HomeAddress, GIVE_RAISE AS giveRaise
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>When you specify member names, any member you do not specify will be given the default naming.</p>
</li>
<li>
<p>The reason to capitalize the specified attribute, <code>HomeAddress</code> instead of <code>homeAddress</code>, is that it will be used exactly as specified to name the accessor methods. For example, <code>getHomeAddress()</code> follows naming conventions, but <code>gethomeAddress()</code> does not.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006926"></a>
<div id="JSQLJ454" class="sect2">
<h3 class="sect2">JPublisher <a id="sthref392"></a><a id="sthref393"></a><a id="sthref394"></a>Implementation of Wrapper Methods</h3>
<p>This section describes how JPublisher generates wrapper methods and how wrapper method calls are processed at run time.</p>
<p class="subhead2"><a id="JSQLJ455"></a>Generation of Wrapper Methods</p>
<p>The following points describe how JPublisher generates wrapper methods:</p>
<ul>
<li>
<p>JPublisher-generated wrapper methods are implemented in SQLJ. Therefore, whenever <code>-methods=true</code>, the custom object class will be defined in a <code>.sqlj</code> file instead of in a <code>.java</code> file, assuming the object type defines methods. Run SQLJ to translate the <code>.sqlj</code> file.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Even if the object type does not define methods, you can ensure that a <code>.sqlj</code> file is generated by setting <code>-methods=always</code>. Refer to the <a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a> for more information.</div>
<ul>
<li>
<p>All wrapper methods generated by JPublisher are implemented as instance methods. This is because a database connection is required for you to invoke the corresponding server method. Each instance of a JPublisher-generated custom Java class has a connection associated with it.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ456"></a>Run Time Execution of Wrapper Method Calls</p>
<p>The following points describe what JPublisher-generated Java wrapper methods execute at run time. In this discussion, &#34;Java wrapper method&#34; refers to a method in the custom Java object, while &#34;wrapped SQL method&#34; refers to the SQL object method that is wrapped by the Java wrapper method.</p>
<ul>
<li>
<p>The custom Java object is converted to a SQL object and passed to the database, where the wrapped SQL method is invoked. After this method invocation, the new value of the SQL object is returned to Java in a new custom Java object, either as a function return from the wrapped SQL method, if the SQL method is a stored procedure, or as an array element in an additional output parameter, if the SQL method is a stored function and there already is a function return.</p>
</li>
<li>
<p>Any output or input-output parameter is passed as the element of a one-element array. If the parameter is input-output, then the wrapper method takes the array element as input. After processing, the wrapper assigns the output to the array element.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006955"></a>
<div id="JSQLJ457" class="sect2">
<h3 class="sect2">JPublisher <a id="sthref395"></a><a id="sthref396"></a>Custom Java Class Examples</h3>
<p>This section provides examples of JPublisher-generated <code>ORAData</code> implementations for the following user-defined types:</p>
<ul>
<li>
<p>A custom object class (<code>Address</code>, corresponding to the Oracle object type <code>ADDRESS</code>) and related custom reference class (<code>AddressRef</code>)</p>
</li>
<li>
<p>A custom collection class (<code>ModuletblT</code>, corresponding to the Oracle collection type <code>MODULETBL_T</code>)</p>
</li>
</ul>
<p>Assume that the <code>-methods</code> option has its default <code>true</code> setting and that the <code>ADDRESS</code> type has methods, so that a <code>.sqlj</code> file is generated for the <code>Address</code> class.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a> for examples of JPublisher-generated <code>SQLData</code> implementations, as well as further examples of JPublisher-generated <code>ORAData</code> implementations.</div>
<p class="subhead2"><a id="JSQLJ458"></a>Custom Object Class: Address.sqlj</p>
<p>Following is an example of the source code that JPublisher generates for a custom object class. Implementation details have been omitted.</p>
<p>In this example, unlike in <a href="#i1006222">&#34;Creating Object Types&#34;</a>, assume the Oracle object <code>ADDRESS</code> has only the <code>street</code> and <code>zip_code</code> attributes.</p>
<pre>package bar;

import java.sql.SQLException;
import java.sql.Connection;
import oracle.jdbc.OracleTypes;
import oracle.sql.ORAData;
import oracle.sql.ORADataFactory;
import oracle.sql.Datum;
import oracle.sql.STRUCT;
import oracle.jpub.MutableStruct;

public class Address implements ORAData, ORADataFactory
{
  public static final String _SQL_NAME = &#34;HR.ADDRESS&#34;;
  public static final int _SQL_TYPECODE = OracleTypes.STRUCT;

  public static ORADataFactory getORADataFactory()
  { ... }

  /* constructors */
  public Address()
  { ... }

  public Address(String street, java.math.BigDecimal zip_code)
                throws SQLException
  { ... }

  /* ORAData interface */
  public Datum toDatum(Connection c) throws SQLException
  { ... }

  /* ORADataFactory interface */
  public ORAData create(Datum d, int sqlType) throws SQLException
  { ... }

  /* accessor methods */
  public String getStreet() throws SQLException
  { ... }

  public void setStreet(String street) throws SQLException
  { ... }


  public java.math.BigDecimal getZipCode() throws SQLException
  { ... }

  public void setZipCode(java.math.BigDecimal zip_code) throws SQLException
  { ... }

}
</pre>
<p class="subhead2"><a id="JSQLJ459"></a>Custom Reference Class: AddressRef.java</p>
<p>Following is an example of the source code that JPublisher generates for a custom reference class to be used for references to <code>ADDRESS</code> objects. Implementation details have been omitted.</p>
<pre>package bar;

import java.sql.SQLException;
import java.sql.Connection;
import oracle.jdbc.OracleTypes;
import oracle.sql.ORAData;
import oracle.sql.ORADataFactory;
import oracle.sql.Datum;
import oracle.sql.REF;
import oracle.sql.STRUCT;

public class AddressRef implements ORAData, ORADataFactory
{
  public static final String _SQL_BASETYPE = &#34;HR.ADDRESS&#34;;
  public static final int _SQL_TYPECODE = OracleTypes.REF;

  public static ORADataFactory getORADataFactory()
  { ... }

  /* constructors */
  public AddressRef()
  { ... }

  public static AddressRef(ORAData o) throws SQLException
  { ... }

  /* ORAData interface */
  public Datum toDatum(Connection c) throws SQLException
  { ... }

  /* ORADataFactory interface */
  public ORAData create(Datum d, int sqlType) throws SQLException
  { ... }

  public static AddressRef cast(ORAData o) throws SQLException
  { ... }

  public Address getValue() throws SQLException
  { ... }

  public void setValue(Address c) throws SQLException
  { ... }
}
</pre>
<p class="subhead2"><a id="JSQLJ460"></a>Custom Collection Class: ModuletblT.java</p>
<p>Following is an example of the source code that JPublisher generates for a custom collection class. Implementation details have been omitted.</p>
<pre>import java.sql.SQLException;
import java.sql.Connection;
import oracle.jdbc.OracleTypes;
import oracle.sql.ORAData;
import oracle.sql.ORADataFactory;
import oracle.sql.Datum;
import oracle.sql.ARRAY;
import oracle.sql.ArrayDescriptor;
import oracle.jpub.runtime.MutableArray;

public class ModuletblT implements ORAData, ORADataFactory
{
  public static final String _SQL_NAME = &#34;HR.MODULETBL_T&#34;;
  public static final int _SQL_TYPECODE = OracleTypes.ARRAY;

  public static ORADataFactory getORADataFactory()
  { ... }

  /* constructors */
  public ModuletblT()
  { ... }

  public ModuletblT(ModuleT[] a)
  { ... }

  /* ORAData interface */
  public Datum toDatum(Connection c) throws SQLException
  { ... }

  /* ORADataFactory interface */
  public ORAData create(Datum d, int sqlType) throws SQLException
  { ... }

  public String getBaseTypeName() throws SQLException
  { ... }

  public int getBaseType() throws SQLException
  { ... }

  public ArrayDescriptor getDescriptor() throws SQLException
  { ... }

  /* array accessor methods */
  public ModuleT[] getArray() throws SQLException
  { ... }

  public void setArray(ModuleT[] a) throws SQLException
  { ... }

  public ModuleT[] getArray(long index, int count) throws SQLException
  { ... }

  public void setArray(ModuleT[] a, long index) throws SQLException
  { ... }

  public ModuleT getObjectElement(long index) throws SQLException
  { ... }

  public void setElement(ModuleT a, long index) throws SQLException
  { ... }
}
</pre></div>
<!-- class="sect2" -->
<a id="i1007148"></a>
<div id="JSQLJ461" class="sect2">
<h3 class="sect2">Extending <a id="sthref397"></a><a id="sthref398"></a><a id="sthref399"></a>Classes Generated by JPublisher</h3>
<p>You might want to enhance the functionality of a custom Java class generated by JPublisher by adding methods and transient fields. You can accomplish this by extending the JPublisher-generated class.</p>
<p>For example, suppose you want JPublisher to generate the <code>JAddress</code> class from the <code>ADDRESS</code> SQL object type. You also want to use a <code>MyAddress</code> class to represent <code>ADDRESS</code> objects and implement special functionality. The <code>MyAddress</code> class must extend <code>JAddress</code>.</p>
<p>Another way to enhance the functionality of a JPublisher-generated class is to simply add methods to it. However, adding methods to the generated class is not recommended if you anticipate running JPublisher at some future time to regenerate the class. If you run JPublisher to regenerate a class that you have modified in this way, then you would have to save a copy and manually merge your changes back in.</p>
<p class="subhead2"><a id="JSQLJ462"></a>JPublisher Functionality for Extending Generated Classes</p>
<p>The syntax to have JPublisher generate <code>JAddress</code> but map to <code>MyAddress</code> is as follows:</p>
<pre>-sql=ADDRESS:JAddress:MyAddress
</pre>
<p>Or, use the following in an <code>INPUT</code> file:</p>
<pre>SQL ADDRESS GENERATE JAddress AS MyAddress
</pre>
<p>As a result of this, JPublisher will generate the <code>MyAddressRef</code> reference class, rather than <code>JAddressRef</code>, in <code>MyAddressRef.java</code>.</p>
<p>In addition, JPublisher alters the code it generates to implement the following functionality:</p>
<ul>
<li>
<p>The <code>MyAddress</code> class, instead of the <code>JAddress</code> class, is used to represent attributes whose SQL type is <code>ADDRESS</code>.</p>
</li>
<li>
<p>The <code>MyAddress</code> class, instead of the <code>JAddress</code> class, is used to represent method arguments and function results whose type is <code>ADDRESS</code>.</p>
</li>
<li>
<p>The <code>MyAddress</code> factory, instead of the <code>JAddress</code> factory, is used to construct Java objects whose SQL type is <code>ADDRESS</code>.</p>
</li>
</ul>
<p>You would presumably use <code>MyAddress</code> similarly in any additional code that you write.</p>
<p>At run time, Oracle JDBC driver will map any occurrences of <code>ADDRESS</code> data in the database to <code>MyAddress</code> instances, instead of to <code>JAddress</code> instances.</p>
<p class="subhead2"><a id="JSQLJ463"></a>Requirements of Extended Classes</p>
<p>By default, JPublisher will create an initial version of the <code>MyAddress</code> user subclass in <code>MyAddress.sqlj</code>, if the original class uses methods and you are publishing these methods, or <code>MyAddress.java</code>, unless the file to be created already exists, in which case it will not be changed. You can edit this file as necessary to add your desired functionality.</p>
<p><code>MyAddress</code> must have a no-argument constructor. The easiest way to construct a properly initialized object is to invoke the constructor of the superclass, either explicitly or implicitly.</p>
<p>As a result of extending the JPublisher-generated class, the subclass will inherit definitions of the <code>_SQL_NAME</code> field, which it requires, and the <code>_SQL_TYPECODE</code> field.</p>
<p>In addition, one of the following will be true.</p>
<ul>
<li>
<p>If the JPublisher-generated class implements the <code>ORAData</code> and <code>ORADataFactory</code> interfaces, then the subclass will inherit this implementation and the necessary <code>toDatum()</code> and <code>create()</code> functionality of the generated class. The subclass implements a <code>getORADataFactory()</code> method that returns an instance of your map class, such as a <code>MyAddress</code> object.</p>
</li>
<li>
<p>If the JPublisher-generated class implements the <code>SQLData</code> interface, then the subclass will inherit this implementation and the necessary <code>readSQL()</code> and <code>writeSQL()</code> functionality of the generated class.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ464"></a>JPublisher-Generated Custom Object Class: JAddress.sqlj</p>
<p>The code for the JPublisher-generated <code>JAddress</code> class, implementing <code>ORAData</code> and <code>ORADataFactory</code>, is mostly identical to the code shown previously for the <code>Address</code> class, with the exception that mentions of <code>Address</code> are replaced by mentions of <code>JAddress</code>.</p>
<p class="subhead2"><a id="JSQLJ465"></a>JPublisher-Generated Alternate Reference Class: MyAddressRef.java</p>
<p>Continuing the example in the preceding sections, consider code for the JPublisher-generated reference class, <code>MyAddressRef</code> (as opposed to <code>JAddressRef</code>, because <code>MyAddress</code> is the class that <code>ADDRESS</code> objects map to). This class also implements <code>ORAData</code> and <code>ORADataFactory</code>. The implementation is nearly identical to that of <code>AddressRef.java</code>, except for the change in class name and the fact that accessor methods use <code>MyAddress</code> instances instead of <code>Address</code> instances.</p>
<p class="subhead2"><a id="JSQLJ466"></a>Extended Custom Object Class: MyAddress.sqlj</p>
<p>Again continuing the example, here is sample code for a <code>MyAddress</code> class that subclasses the JPublisher-generated <code>JAddress</code> class. The comments in the code show what is inherited from <code>JAddress</code>. Implementation details have been omitted.</p>
<pre>import java.sql.SQLException;
import oracle.sql.ORAData;
import oracle.sql.ORADataFactory;
import oracle.sql.Datum;
import oracle.sql.STRUCT;
import oracle.jpub.runtime.MutableStruct;

public class MyAddress extends JAddress
{
  /* _SQL_NAME inherited from MyAddress */
  /* _SQL_TYPECODE inherited from MyAddress */

  static _myAddressFactory = new MyAddress();

  public static ORADataFactory getORADataFactory()
  {
    return _myAddressFactory;
  }

  /* constructor */
  public MyAddress()
  { super(); }

  /* ORAData interface */
  /* toDatum() inherited from JAddress */

  /* ORADataFactory interface */
  public ORAData create(oracle.sql.Datum d, int sqlType) throws SQLException
  { ... }

  /* accessor methods inherited from JAddress */

  /* Additional methods go here.  These additional methods (not shown)
     are the reason that JAddress was extended.
  */
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007225"></a>
<div id="JSQLJ467" class="sect1">
<h2 class="sect1">Strongly Typed <a id="sthref400"></a><a id="sthref401"></a><a id="sthref402"></a>Objects and References in SQLJ Executable Statements</h2>
<p>The Oracle SQLJ implementation is flexible in how it enables you to use host expressions and iterators in reading or writing object data through strongly typed objects or references.</p>
<p>For iterators, you can use custom object classes as iterator column types. Alternatively, you can have iterator columns that correspond to individual object attributes, similar to extent tables, using column types that appropriately map to the SQL data types of the attributes.</p>
<p>For host expressions, you can use host variables of your custom object class type or custom reference class type. Alternatively, you can use host variables that correspond to object attributes, using variable types that appropriately map to the SQL data types of the attributes.</p>
<p>The remainder of this section provides examples of how to manipulate Oracle objects using custom object classes, custom object class attributes, and custom reference classes for host variables and iterator columns in SQLJ executable statements.</p>
<p>The following two examples operate at the object level:</p>
<ul>
<li>
<p><a href="#i1007258">Selecting Objects and Object References into Iterator Columns</a></p>
</li>
<li>
<p><a href="#i1007309">Updating an Object</a></p>
</li>
</ul>
<p>The <a href="#i1007392">Inserting an Object Created from Individual Object Attributes</a> example operates at the scalar-attribute level.</p>
<p>The <a href="#i1007422">Updating an Object Reference</a> example operates through a reference.</p>
<p>Refer to the Oracle object types <code>ADDRESS</code> and <code>PERSON</code> in <a href="#i1006222">&#34;Creating Object Types&#34;</a>.</p>
<a id="i1007258"></a>
<div id="JSQLJ468" class="sect2">
<h3 class="sect2">Selecting <a id="sthref403"></a><a id="sthref404"></a><a id="sthref405"></a>Objects and Object References into Iterator Columns</h3>
<p>This example uses a custom Java class and a custom reference class as iterator column types. Presume the following definition of the <code>ADDRESS</code> Oracle object type:</p>
<pre>CREATE TYPE ADDRESS AS OBJECT
(  street VARCHAR(40),
   zip NUMBER );
</pre>
<p>And the following definition of the <code>EMPADDRS</code> table, which includes an <code>ADDRESS</code> column and an <code>ADDRESS</code> reference column:</p>
<pre>CREATE TABLE empaddrs
(  name VARCHAR(60),
   home ADDRESS,
   loc REF ADDRESS );
</pre>
<p>Once you use JPublisher or otherwise create a custom Java class, <code>Address</code>, and custom reference class, <code>AddressRef</code>, corresponding to the <code>ADDRESS</code> Oracle object type, you can use <code>Address</code> and <code>AddressRef</code> in a named iterator as follows:</p>
<pre>#sql iterator EmpIter (String name, Address home, AddressRef loc);

...
EmpIter ecur;
#sql ecur = { SELECT name, home, loc FROM empaddrs };
while (ecur.next()) {
   Address homeAddr = ecur.home();
   // Print out the home address.
   System.out.println (&#34;Name: &#34; + ecur.name() + &#34;\n&#34; +
                       &#34;Home address: &#34; + homeAddr.getStreet() + &#34;   &#34; +
                       homeAddr.getZip());
   // Now update the loc address zip code through the address reference.
   AddressRef homeRef = ecur.loc();
   Address location = homeRef.getValue();
   location.setZip(new BigDecimal(98765));
   homeRef.setValue(location);
   }
...
</pre>
<p>The <code>ecur.home()</code> method call extracts an <code>Address</code> object from the <code>home</code> column of the iterator and assigns it to the <code>homeAddr</code> local variable (for efficiency). The attributes of that object can then be accessed using standard Java dot syntax:</p>
<pre>homeAddr.getStreet()
</pre>
<p>Use the <code>getValue()</code> and <code>setValue()</code> methods, standard with any JPublisher-generated custom reference class, to manipulate the location address (in this case its zip code).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The remaining examples in this section use the types and tables defined in the SQL script in <a href="#i1006222">&#34;Creating Object Types&#34;</a>.</div>
</div>
<!-- class="sect2" -->
<a id="i1007309"></a>
<div id="JSQLJ469" class="sect2">
<h3 class="sect2">Updati<a id="sthref406"></a>ng an Object</h3>
<p>This example declares and sets an input host variable of the <code>Address</code> Java type to update an <code>ADDRESS</code> object in a column of the <code>employees</code> table. Both before and after the update, the address is selected into an output host variable of the <code>Address</code> type and printed for verification.</p>
<pre>...
// Updating an object 

static void updateObject() 
{

   Address addr;
   Address new_addr;
   int empnum = 1001;

   try {
      #sql {
         SELECT office_addr
         INTO :addr
         FROM employees
         WHERE empnumber = :empnum };
      System.out.println(&#34;Current office address of employee 1001:&#34;);

      printAddressDetails(addr);

      /* Now update the street of address */

      String street =&#34;100 Oracle Parkway&#34;;
      addr.setStreet(street);

      /* Put updated object back into the database */

      try {
         #sql {
            UPDATE employees
            SET office_addr = :addr
            WHERE empnumber = :empnum };
         System.out.println
            (&#34;Updated employee 1001 to new address at Oracle Parkway.&#34;);

         /* Select new address to verify update */
      
         try {
            #sql {
               SELECT office_addr
               INTO :new_addr
               FROM employees
               WHERE empnumber = :empnum };
      
            System.out.println(&#34;New office address of employee 1001:&#34;);
            printAddressDetails(new_addr);

         } catch (SQLException exn) {
         System.out.println(&#34;Verification SELECT failed with &#34;+exn); }
      
      } catch (SQLException exn) {
      System.out.println(&#34;UPDATE failed with &#34;+exn); }

   } catch (SQLException exn) {
   System.out.println(&#34;SELECT failed with &#34;+exn); }
}
...
</pre>
<p>Note the use of the <code>setStreet()</code> accessor method of the <code>Address</code> object. Remember that JPublisher provides such accessor methods for all attributes in any custom Java class that it produces.</p>
<p>This example uses the <code>printAddressDetails()</code> utility. The source code for this method is as follows:</p>
<pre>static void printAddressDetails(Address a) throws SQLException
{

  if (a == null)  {
    System.out.println(&#34;No Address available.&#34;);
    return;
   }

   String street = ((a.getStreet()==null) ? &#34;NULL street&#34; : a.getStreet()) ;
   String city = (a.getCity()==null) ? &#34;NULL city&#34; : a.getCity();
   String state = (a.getState()==null) ? &#34;NULL state&#34; : a.getState();
   String zip_code = (a.getZipCode()==null) ? &#34;NULL zip&#34; : a.getZipCode();

   System.out.println(&#34;Street: &#39;&#34; + street + &#34;&#39;&#34;);
   System.out.println(&#34;City:   &#39;&#34; + city   + &#34;&#39;&#34;);
   System.out.println(&#34;State:  &#39;&#34; + state  + &#34;&#39;&#34;);
   System.out.println(&#34;Zip:    &#39;&#34; + zip_code + &#34;&#39;&#34; );
}
</pre></div>
<!-- class="sect2" -->
<a id="i1007392"></a>
<div id="JSQLJ470" class="sect2">
<h3 class="sect2">Inserting an <a id="sthref407"></a>Object Created from Individual Object Attributes</h3>
<p>This example declares and sets input host variables corresponding to attributes of <code>PERSON</code> and nested <code>ADDRESS</code> objects, then uses these values to insert a new <code>PERSON</code> object into the <code>persons</code> table in the database.</p>
<pre>...
// Inserting an object

static void insertObject() 
{
   String new_name   = &#34;NEW PERSON&#34;;
   int    new_ssn    = 987654;
   String new_street = &#34;NEW STREET&#34;;
   String new_city   = &#34;NEW CITY&#34;;
   String new_state  = &#34;NS&#34;;
   String new_zip    = &#34;NZIP&#34;;
  /*
   * Insert a new PERSON object into the persons table
   */
   try {
      #sql {
         INSERT INTO persons
         VALUES (PERSON(:new_name, :new_ssn,
         ADDRESS(:new_street, :new_city, :new_state, :new_zip))) };

      System.out.println(&#34;Inserted PERSON object NEW PERSON.&#34;); 

   } catch (SQLException exn) { System.out.println(&#34;INSERT failed with &#34;+exn); }
}
...
</pre></div>
<!-- class="sect2" -->
<a id="i1007422"></a>
<div id="JSQLJ471" class="sect2">
<h3 class="sect2">Updati<a id="sthref408"></a><a id="sthref409"></a>ng an Object Reference</h3>
<p>This example selects a <code>PERSON</code> reference from the <code>persons</code> table and uses it to update a <code>PERSON</code> reference in the <code>employees</code> table. It uses simple input host variables to check attribute value criteria. The newly updated reference is then used in selecting the <code>PERSON</code> object to which it refers, so that information can be output to the user to verify the change.</p>
<pre>...
// Updating a REF to an object

static void updateRef()
{
   int empnum = 1001;
   String new_manager = &#34;NEW PERSON&#34;;

   System.out.println(&#34;Updating manager REF.&#34;);
   try {
      #sql {
         UPDATE employees
         SET manager = 
            (SELECT REF(p) FROM persons p WHERE p.name = :new_manager)
         WHERE empnumber = :empnum };

      System.out.println(&#34;Updated manager of employee 1001. Selecting back&#34;);

   } catch (SQLException exn) {
   System.out.println(&#34;UPDATE REF failed with &#34;+exn); }

   /* Select manager back to verify the update */
   Person manager;

   try { 
      #sql {
         SELECT deref(manager)
         INTO :manager
         FROM employees e
         WHERE empnumber = :empnum };

      System.out.println(&#34;Current manager of &#34;+empnum+&#34;:&#34;);
      printPersonDetails(manager);

   } catch (SQLException exn) {
   System.out.println(&#34;SELECT REF failed with &#34;+exn); }

}
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example uses table alias syntax (<code>p</code>) as discussed previously. Also, the <code>REF</code> syntax is required in selecting a reference through the object to which it refers, and the <code>DEREF</code> syntax is required in selecting an object through a reference. Refer to the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about table aliases, <code>REF</code>, and <code>DEREF</code>.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007474"></a>
<div id="JSQLJ472" class="sect1">
<h2 class="sect1">Strongly <a id="sthref410"></a><a id="sthref411"></a>Typed Collections in SQLJ Executable Statements</h2>
<p>As with strongly typed objects and references, the Oracle SQLJ implementation supports different scenarios for reading and writing data through strongly typed collections, using either iterators or host expressions.</p>
<p>From the perspective of a SQLJ developer, both categories of collections, VARRAY and nested table, are treated essentially the same, but there are some differences in implementation and performance.</p>
<p>The Oracle SQLJ implementation supports syntax choices so that nested tables can be accessed and manipulated either apart from or together with their outer tables. In this section, manipulation of a nested table by itself will be referred to as detail-level manipulation and manipulation of a nested table together with its outer table will be referred to as master-level manipulation.</p>
<p>Most of this section, after a brief discussion of some syntax, focuses on examples of manipulating nested tables, given that their use is somewhat more complicated than that of VARRAYs.</p>
<p>Refer to the <code>MODULETBL_T</code> Oracle collection type and related tables and object types defined in <a href="#i1006305">&#34;Creating Collection Types&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In the Oracle SQLJ implementation, VARRAY types and nested table types can be retrieved only in their entirety. This is as opposed to the Oracle SQL implementation, where nested tables can be selectively queried.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABGHDEH">Accessing Nested Tables: TABLE syntax and CURSOR syntax</a></p>
</li>
<li>
<p><a href="#BABDGHID">Inserting a Row that Includes a Nested Table</a></p>
</li>
<li>
<p><a href="#BABIICJJ">Selecting a Nested Table into a Host Expression</a></p>
</li>
<li>
<p><a href="#BABJIFFD">Manipulating a Nested Table Using TABLE Syntax</a></p>
</li>
<li>
<p><a href="#i1007647">Selecting Data from a Nested Table Using a Nested Iterator</a></p>
</li>
<li>
<p><a href="#BABHBHEH">Selecting a VARRAY into a Host Expression</a></p>
</li>
<li>
<p><a href="#BABFBECE">Inserting a Row that Includes a VARRAY</a></p>
</li>
</ul>
<a id="BABGHDEH"></a>
<div id="JSQLJ473" class="sect2">
<h3 class="sect2">Accessing <a id="sthref412"></a><a id="sthref413"></a><a id="sthref414"></a>Nested Tables: TABLE syntax and CURSOR syntax</h3>
<p>The Oracle SQLJ implementation supports the use of nested iterators to access data in nested tables. Use the <code>CURSOR</code> keyword in the outer <code>SELECT</code> statement to encapsulate the inner <code>SELECT</code> statement. This is shown in <a href="#i1007647">&#34;Selecting Data from a Nested Table Using a Nested Iterator&#34;</a>.</p>
<p>Oracle also supports use of the <code>TABLE</code> keyword to manipulate the individual rows of a nested table. This keyword informs Oracle that the column value returned by a subquery is a nested table, as opposed to a scalar value. You must prefix the <code>TABLE</code> keyword to a subquery that returns a single column value or an expression that yields a nested table.</p>
<p>The following example shows the use of the <code>TABLE</code> syntax:</p>
<pre>UPDATE TABLE(SELECT a.modules FROM projects a WHERE a.id=555) b
       SET module_owner= 
       (SELECT ref(p) FROM employees p WHERE p.ename= &#39;Smith&#39;) 
       WHERE b.module_name = &#39;Zebra&#39;;
</pre>
<p>When you see <code>TABLE</code> used as it is here, realize that it is referring to a single nested table that has been selected from a column of an outer table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example uses table alias syntax (<code>a</code> for <code>projects</code>, <code>b</code> for the nested table, and <code>p</code> for <code>employees</code>) as discussed previously.</div>
</div>
<!-- class="sect2" -->
<a id="BABDGHID"></a>
<div id="JSQLJ474" class="sect2">
<h3 class="sect2">Inserting a <a id="sthref415"></a>Row that Includes a Nested Table</h3>
<p>This example shows an operation that manipulates the master level (outer table) and detail level (nested tables) simultaneously and explicitly. This inserts a row in the <code>projects</code> table, where each row includes a nested table of the <code>MODULETBL_T</code> type, which contains rows of <code>MODULE_T</code> objects.</p>
<p>First, the scalar values are set (<code>id</code>, <code>name</code>, <code>start_date</code>, <code>duration</code>), then the nested table values are set. This involves an extra level of abstraction, because the nested table elements are objects with multiple attributes. In setting the nested table values, each attribute value must be set for each <code>MODULE_T</code> object in the nested table. Finally, the <code>owner</code> values, initially set to <code>null</code>, are set in a separate statement.</p>
<pre>// Insert Nested table details along with master details 

  public static void insertProject2(int id)  throws Exception 
  {
    System.out.println(&#34;Inserting Project with Nested Table details..&#34;);
    try {
      #sql { INSERT INTO Projects(id,name,owner,start_date,duration, modules) 
             VALUES ( 600, &#39;Ruby&#39;, null, &#39;10-MAY-98&#39;,  300, 
             moduletbl_t(module_t(6001, &#39;Setup &#39;, null, &#39;01-JAN-98&#39;, 100),
                        module_t(6002, &#39;BenchMark&#39;, null, &#39;05-FEB-98&#39;,20) ,
                        module_t(6003, &#39;Purchase&#39;, null, &#39;15-MAR-98&#39;, 50),
                        module_t(6004, &#39;Install&#39;, null, &#39;15-MAR-98&#39;,44),
                        module_t(6005, &#39;Launch&#39;, null,&#39;12-MAY-98&#39;,34))) };
    } catch ( Exception e) {
      System.out.println(&#34;Error:insertProject2&#34;);
      e.printStackTrace();
    }

    // Assign project owner to this project 

    try {
      #sql { UPDATE Projects pr
          SET owner=(SELECT ref(pa) FROM participants pa WHERE pa.empno = 7698)
         WHERE pr.id=600 };
    } catch ( Exception e) {
      System.out.println(&#34;Error:insertProject2:update&#34;);
      e.printStackTrace();
    }
  }
</pre></div>
<!-- class="sect2" -->
<a id="BABIICJJ"></a>
<div id="JSQLJ475" class="sect2">
<h3 class="sect2">Selecting a <a id="sthref416"></a><a id="sthref417"></a>Nested Table into a Host Expression</h3>
<p>This example presents an operation that works directly at the detail level of the nested table. Recall that <code>ModuletblT</code> is a JPublisher-generated custom collection class (<code>ORAData</code> implementation) for <code>MODULETBL_T</code> nested tables, <code>ModuleT</code> is a JPublisher-generated custom object class for <code>MODULE_T</code> objects, and <code>MODULETBL_T</code> nested tables contain <code>MODULE_T</code> objects.</p>
<p>A nested table of <code>MODULE_T</code> objects is selected from the <code>modules</code> column of the <code>projects</code> table into a <code>ModuletblT</code> host variable.</p>
<p>Following that, the <code>ModuletblT</code> variable (containing the nested table) is passed to a method that accesses its elements through its <code>getArray()</code> method, writing the data to a <code>ModuleT[]</code> array. All custom collection classes generated by JPublisher include a <code>getArray()</code> method. Then each element is copied from the <code>ModuleT[]</code> array into a <code>ModuleT</code> object, and individual attributes are retrieved through accessor methods (<code>getModuleName()</code>, for example) and then printed. All JPublisher-generated custom object classes include such accessor methods.</p>
<pre>  static ModuletblT mymodules=null;
  ...

  public static void getModules2(int projId)
  throws Exception 
  {
    System.out.println(&#34;Display modules for project &#34; + projId );

    try {
      #sql {SELECT modules INTO :mymodules 
                           FROM projects  WHERE id=:projId };
      showArray(mymodules);
    } catch(Exception e) {
      System.out.println(&#34;Error:getModules2&#34;);
      e.printStackTrace();
    }
  }

  public static void showArray(ModuletblT a) 
  {
    try {
      if ( a == null )
        System.out.println( &#34;The array is null&#34; );
      else {
        System.out.println( &#34;printing ModuleTable array object of size &#34;
                             +a.length());
        ModuleT[] modules = a.getArray();

        for (int i=0;i&lt;modules.length; i++) {
          ModuleT module = modules[i];
          System.out.println(&#34;module &#34;+module.getModuleId()+
                &#34;, &#34;+module.getModuleName()+
                &#34;, &#34;+module.getModuleStartDate()+
                &#34;, &#34;+module.getModuleDuration());
        }
      }
    }
    catch( Exception e ) {
      System.out.println(&#34;Show Array&#34;);
      e.printStackTrace();
    }
  }
</pre></div>
<!-- class="sect2" -->
<a id="BABJIFFD"></a>
<div id="JSQLJ476" class="sect2">
<h3 class="sect2">Manipulating a <a id="sthref418"></a><a id="sthref419"></a>Nested Table Using TABLE Syntax</h3>
<p>This example uses <code>TABLE</code> syntax to work at the detail level to access and update nested table elements directly, based on master-level criteria.</p>
<p>The <code>assignModule()</code> method selects a nested table of <code>MODULE_T</code> objects from the <code>MODULES</code> column of the <code>PROJECTS</code> table, then updates <code>MODULE_NAME</code> for a particular row of the nested table. Similarly, the <code>deleteUnownedModules()</code> method selects a nested table of <code>MODULE_T</code> objects, then deletes any unowned modules in the nested table, where <code>MODULE_OWNER</code> is <code>null</code>.</p>
<p>These methods use table alias syntax, as discussed previously. In this case, <code>m</code> is used for the nested table, and <code>p</code> is used for the <code>participants</code> table.</p>
<pre>  /* assignModule 
     Illustrates accessing the nested table using the TABLE construct 
     and updating the nested table row 
  */
  public static void assignModule(int projId, String moduleName, 
                                  String modOwner) throws Exception 
  {
    System.out.println(&#34;Update:Assign &#39;&#34;+moduleName+&#34;&#39; to &#39;&#34;+ modOwner+&#34;&#39;&#34;);

    try {
      #sql {UPDATE TABLE(SELECT modules FROM projects WHERE id=:projId) m
            SET m.module_owner=
           (SELECT ref(p) FROM participants p WHERE p.ename= :modOwner) 
            WHERE m.module_name = :moduleName };
    } catch(Exception e) {
      System.out.println(&#34;Error:insertModules&#34;);
      e.printStackTrace();
    }
  }

  /* deleteUnownedModules 
  // Demonstrates deletion of the Nested table element 
  */

  public static void deleteUnownedModules(int projId)
  throws Exception 
  {
    System.out.println(&#34;Deleting Unowned Modules for Project &#34; + projId);
    try {
      #sql { DELETE TABLE(SELECT modules FROM projects WHERE id=:projId) m
             WHERE m.module_owner IS NULL };
    } catch(Exception e) {
      System.out.println(&#34;Error:deleteUnownedModules&#34;);
      e.printStackTrace();
    }
  }
</pre></div>
<!-- class="sect2" -->
<a id="i1007647"></a>
<div id="JSQLJ477" class="sect2">
<h3 class="sect2">Selecting Data from a <a id="sthref420"></a><a id="sthref421"></a><a id="sthref422"></a>Nested Table Using a Nested Iterator</h3>
<p>SQLJ supports the use of nested iterators as a way of accessing nested tables. This requires <code>CURSOR</code> syntax, as used in the following example. The code defines a named iterator class, <code>ModuleIter</code>, then uses that class as the type for a <code>modules</code> column in another named iterator class, <code>ProjIter</code>. Inside a populated <code>ProjIter</code> instance, each <code>modules</code> item is a nested table rendered as a nested iterator.</p>
<p>The <code>CURSOR</code> syntax is part of the nested <code>SELECT</code> statement that populates the nested iterators. Once the data has been selected, it is output to the user through the iterator accessor methods.</p>
<p>This example uses required table alias syntax, as discussed previously. In this case, <code>a</code> for the <code>projects</code> table and <code>b</code> for the nested table.</p>
<pre>...

//  The Nested Table is accessed using the ModuleIter 
//  The ModuleIter is defined as Named Iterator 

#sql public static iterator ModuleIter(int moduleId , 
                                       String moduleName , 
                                       String moduleOwner);

// Get the Project Details using the ProjIter defined as 
// Named Iterator. Notice the use of ModuleIter:

#sql public static iterator ProjIter(int id, 
                                     String name, 
                                     String owner, 
                                     Date start_date, 
                                     ModuleIter modules);

...

public static void listAllProjects() throws SQLException
{
  System.out.println(&#34;Listing projects...&#34;);

   // Instantiate and initialize the iterators 

   ProjIter projs = null;
   ModuleIter  mods = null;
   #sql projs = {SELECT a.id, 
                        a.name, 
                        initcap(a.owner.ename) as &#34;owner&#34;, 
                        a.start_date,
                        CURSOR (
                        SELECT b.module_id AS &#34;moduleId&#34;,
                               b.module_name AS &#34;moduleName&#34;,
                                 initcap(b.module_owner.ename) AS &#34;moduleOwner&#34;
                        FROM TABLE(a.modules) b) AS &#34;modules&#34;  
                 FROM projects a };
  
  // Display Project Details
  
  while (projs.next()) {
    System.out.println( &#34;\n&#39;&#34; + projs.name() + &#34;&#39; Project Id:&#34; 
                + projs.id() + &#34; is owned by &#34; +&#34;&#39;&#34;+ projs.owner() +&#34;&#39;&#34;
                + &#34; start on &#34;  
                + projs.start_date());
              
    // Notice the modules from the ProjIter are assigned to the module
    // iterator variable 

    mods = projs.modules();
    System.out.println (&#34;Modules in this Project are : &#34;);

    // Display Module details 

    while(mods.next()) { 
      System.out.println (&#34;  &#34;+ mods.moduleId() + &#34; &#39;&#34;+ 
                                mods.moduleName() + &#34;&#39; owner is &#39;&#34; +
                                mods.moduleOwner()+&#34;&#39;&#34; );
    }                    // end of modules 
    mods.close();
  }                      // end of projects 
  projs.close();
}
</pre></div>
<!-- class="sect2" -->
<a id="BABHBHEH"></a>
<div id="JSQLJ478" class="sect2">
<h3 class="sect2">Selecting a VAR<a id="sthref423"></a>RAY into a Host Expression</h3>
<p>This section provides an example of selecting a VARRAY into a host expression. Presume the following SQL definitions:</p>
<pre>CREATE TYPE PHONE_ARRAY IS VARRAY (10) OF varchar2(30)
/
/*** Create ADDRESS UDT ***/
CREATE TYPE ADDRESS AS OBJECT
( 
  street        VARCHAR(60),
  city          VARCHAR(30),
  state         CHAR(2),
  zip_code      CHAR(5)
)
/
/*** Create PERSON UDT containing an embedded ADDRESS UDT ***/
CREATE TYPE PERSON AS OBJECT
( 
  name    VARCHAR(30),
  ssn     NUMBER,
  addr    ADDRESS
)
/

CREATE TABLE  employees
( empnumber            INTEGER PRIMARY KEY,
  person_data     REF  person,
  manager         REF  person,
  office_addr          address,
  salary               NUMBER,
  phone_nums           phone_array
)
/
</pre>
<p>And presume that JPublisher is used to create a <code>PhoneArray</code> custom collection class to map from the <code>PHONE_ARRAY</code> SQL type.</p>
<p>The following method selects a row from this table, placing the data into a host variable of the <code>PhoneArray</code> type:</p>
<pre>private static void selectVarray() throws SQLException
{
  PhoneArray ph;
  #sql {select phone_nums into :ph from employees where empnumber=2001};
  System.out.println(
    &#34;there are &#34;+ph.length()+&#34; phone numbers in the PhoneArray.  They are:&#34;);

  String [] pharr = ph.getArray();
  for (int i=0;i&lt;pharr.length;++i) 
    System.out.println(pharr[i]);
}
</pre></div>
<!-- class="sect2" -->
<a id="BABFBECE"></a>
<div id="JSQLJ479" class="sect2">
<h3 class="sect2">Inserting a Ro<a id="sthref424"></a>w that Includes a VARRAY</h3>
<p>This section provides an example of inserting data from a host expression into a VARRAY, using the same SQL definitions and custom collection class (<code>PhoneArray</code>) as in the previous section.</p>
<p>The following methods populate a <code>PhoneArray</code> instance and use it as a host variable, inserting its data into a VARRAY in the database:</p>
<pre>// creates a varray object of PhoneArray and inserts it into a new row
private static void insertVarray() throws SQLException
{
  PhoneArray phForInsert = consUpPhoneArray();
  // clean up from previous demo runs
  #sql {delete from employees where empnumber=2001};
  // insert the PhoneArray object
  #sql {insert into employees (empnumber, phone_nums)
        values(2001, :phForInsert)};
}

private static PhoneArray consUpPhoneArray()
{
  String [] strarr = new String[3];
  strarr[0] = &#34;(510) 555.1111&#34;;
  strarr[1] = &#34;(617) 555.2222&#34;;
  strarr[2] = &#34;(650) 555.3333&#34;;
  return new PhoneArray(strarr);
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007794"></a>
<div id="JSQLJ480" class="sect1">
<h2 class="sect1">Seriali<a id="sthref425"></a><a id="sthref426"></a>zed Java Objects</h2>
<p>When writing and reading instances of Java objects to or from the database, it is sometimes advantageous to define a SQL object type that corresponds to your Java class and use the mechanisms of mapping custom Java classes described previously. This fully permits SQL queries on your Java objects.</p>
<p>In some cases, however, you may want to store Java objects &#34;as-is&#34; and retrieve them later, using database columns of the <code>RAW</code> or <code>BLOB</code> type. There are different ways to accomplish this:</p>
<ul>
<li>
<p>You can map a serializable Java class to <code>RAW</code> or <code>BLOB</code> columns by using a nonstandard extension to the type map facility or by adding a type code field to the serializable class, so that instances of the serializable class can be stored as <code>RAW</code> or <code>BLOB</code>.</p>
</li>
<li>
<p>You can use the <code>ORAData</code> facility to define a serializable wrapper class whose instances can be stored in <code>RAW</code> or <code>BLOB</code> columns.</p>
</li>
</ul>
<p>Serializing in any of these ways works for any Oracle SQLJ run-time library.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABHGACB">Serializing Java Classes to RAW and BLOB Columns</a></p>
</li>
<li>
<p><a href="#BABICJJA">SerializableDatum: an ORAData Implementation</a></p>
</li>
<li>
<p><a href="#BABCAEGC">SerializableDatum in SQLJ Applications</a></p>
</li>
<li>
<p><a href="#BABDFJCH">SerializableDatum (Complete Class)</a></p>
</li>
</ul>
<a id="BABHGACB"></a>
<div id="JSQLJ481" class="sect2">
<h3 class="sect2">Seriali<a id="sthref427"></a><a id="sthref428"></a>zing Java Classes to RAW and BLOB Columns</h3>
<p>If you want to store instances of Java classes directly in <code>RAW</code> or <code>BLOB</code> columns, then you must meet certain nonstandard requirements to specify the desired SQL-Java mapping. Note that in SQLJ statements the serializable Java objects can be transparently read and written as if they were built-in types.</p>
<p>You have two options in specifying the SQL-Java type mapping:</p>
<ul>
<li>
<p>Declare a type map in the connection context declaration and use this type map to specify mappings.</p>
</li>
<li>
<p>Use the <code>public static final</code> field <code>_SQL_TYPECODE</code> to specify the mapping.</p>
</li>
</ul>
<p class="subhead2"><a id="i1007809"></a><a id="JSQLJ482"></a>Defining a Type Map for Serializable Classes</p>
<p>Consider an example where <code>SAddress</code>, <code>pack.SPerson</code>, and <code>pack.Manager.InnerSPM</code>, where <code>InnerSPM</code> is an inner class of <code>Manager</code>, are serializable Java classes. In other words, these classes implement the <code>java.io.Serializable</code> interface.</p>
<p>You must use the classes only in statements that use explicit connection context instances of a declared connection context type, such as <code>SerContext</code> in the following example:</p>
<pre>SAddress               a =...;
pack.SPerson           p =...;
pack.Manager.InnerSPM pm =...;
SerContext ctx = new SerContext(url,user,pwd,false);
#sql [ctx] { ... :a ... :OUT p ... :INOUT pm ... };
</pre>
<p>The following is required:</p>
<ul>
<li>
<p>The connection context type must have been declared using the <code>typeMap</code> attribute of a <code>with</code> clause to specify an associated class implementing <code>java.util.PropertyResourceBundle</code>. In the example, <code>SerContext</code> may be declared as follows.</p>
<pre>#sql public static context SerContext with (typeMap=&#34;SerMap&#34;);
</pre></li>
<li>
<p>The type map resource must provide nonstandard mappings from <code>RAW</code> or <code>BLOB</code> columns to the serializable Java classes. This mapping is specified with entries of the following form, depending on whether the Java class is mapped to a <code>RAW</code> or a <code>BLOB</code> column:</p>
<pre>oracle-class.<span class="variable">java_class_name</span>=JAVA_OBJECT RAW
oracle-class.<span class="variable">java_class_name</span>=JAVA_OBJECT BLOB
</pre>
<p>The keyword <code>oracle-class</code> marks this as an Oracle-specific extension. In the example, the <code>SerMap.properties</code> resource file may contain the following entries:</p>
<pre>oracle-class.SAddress=JAVA_OBJECT RAW
oracle-class.pack.SPerson=JAVA_OBJECT BLOB
oracle-class.packManager$InnerSPM=JAVA_OBJECT RAW
</pre>
<p>Although the period (.) separates package and class names, you <span class="italic">must</span> use the dollar sign ($) to separate an inner class name.</p>
</li>
</ul>
<p>Note that this Oracle-specific extension can be placed in the same type map resource as standard <code>SQLData</code> type map entries.</p>
<p class="subhead2"><a id="i1007834"></a><a id="JSQLJ483"></a>Using Fields to Determine Mapping for Serializable Classes</p>
<p>As an alternative to using a type map for a serializable class, you can use static fields in the serializable class to determine type mapping. You can add either of the following fields to a class that implements the <code>java.io.Serializable</code> interface, such as the <code>SAddress</code> and <code>SPerson</code> classes from the preceding example:</p>
<pre>public final static int _SQL_TYPECODE = oracle.jdbc.OracleTypes.RAW;
</pre>
<pre>public final static int _SQL_TYPECODE = oracle.jdbc.OracleTypes.BLOB;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Using the type map facility supersedes manually adding the <code>_SQL_TYPECODE</code> field to the class.</div>
<p class="subhead2"><a id="JSQLJ484"></a>Limitations on Serializing Java Objects</p>
<p>You should be aware of the effect of serialization. If two objects, A and B, share the same object, C, then upon serialization and subsequent deserialization of A and B, each will point to its own clone of the object C. Sharing is broken.</p>
<p>In addition, note that for a given Java class, you can declare only one kind of serialization: either into <code>RAW</code> or into <code>BLOB</code>. The SQLJ translator can check only that the actual usage conforms to either <code>RAW</code> or <code>BLOB</code>.</p>
<p><code>RAW</code> columns are limited in size. You might experience run-time errors if the actual size of the serialized Java object exceeds the size of the column.</p>
<p>Column size is much less restrictive for <code>BLOB</code> columns. Writing a serialized Java object to a <code>BLOB</code> column is supported by Oracle JDBC Oracle Call Interface (OCI) driver and Oracle JDBC Thin driver. Retrieving a serialized object from a <code>BLOB</code> column is supported by all Oracle JDBC drivers since Oracle9<span class="italic">i</span>.</p>
<p>Finally, treating serialized Java objects this way is an Oracle-specific extension and requires Oracle SQLJ run time as well as either the default Oracle-specific code generation (<code>-codegen=oracle</code> during translation) or, for ISO standard code generation (<code>-codegen=iso</code>), Oracle-specific profile customization.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The implementation of this particular serialization mechanism does not use JDBC type maps. The map (to <code>BLOB</code> or to <code>RAW</code>) is hardcoded in the Oracle profile customization at translation time, or is generated directly into Java code.</div>
</div>
<!-- class="sect2" -->
<a id="BABICJJA"></a>
<div id="JSQLJ485" class="sect2">
<h3 class="sect2">Serializable<a id="sthref429"></a><a id="sthref430"></a><a id="sthref431"></a>Datum: an ORAData Implementation</h3>
<p><a href="#i1006014">&#34;Additional Uses for ORAData Implementations&#34;</a> includes examples of situations where you might want to define a custom Java class that maps to some <code>oracle.sql.*</code> type other than <code>oracle.sql.STRUCT</code>, <code>oracle.sql.REF</code>, or <code>oracle.sql.ARRAY</code>.</p>
<p>An example of such a situation is if you want to serialize and deserialize Java objects into and out of <code>RAW</code> fields, with a custom Java class that maps to the <code>oracle.sql.RAW</code> type. This could apply equally to <code>BLOB</code> fields, with a custom Java class that maps to the <code>oracle.sql.BLOB</code> type.</p>
<p>This section presents an example of such an application, creating a class, <code>SerializableDatum</code>, that implements the <code>ORAData</code> interface and follows the general form of custom Java classes. The example starts with a step-by-step approach to the development of <code>SerializableDatum</code>, followed by the complete sample code.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This application uses classes from the <code>java.io</code>, <code>java.sql</code>, <code>oracle.sql</code>, and <code>oracle.jdbc</code> packages. The import statements are not shown here.</div>
<ol>
<li>
<p>Begin with a skeleton of the class.</p>
<pre>public class SerializableDatum implements ORAData
{
   // <span class="italic">Client methods for constructing and accessing the Java object</span>

   public Datum toDatum(java.sql.Connection c) throws SQLException
   {
      // <span class="italic">Implementation of toDatum()</span>
   }

   public static ORADataFactory getORADataFactory()
   {
      return FACTORY;
   }

   private static final ORADataFactory FACTORY =
           // <span class="italic">Implementation of an ORADataFactory for SerializableDatum</span>

   // <span class="italic">Construction of SerializableDatum from oracle.sql.RAW</span>

   public static final int _SQL_TYPECODE = OracleTypes.RAW;
}
</pre>
<p><code>SerializableDatum</code> does not implement the <code>ORADataFactory</code> interface, but its <code>getORADataFactory()</code> method returns a static member that implements this interface.</p>
<p>The <code>_SQL_TYPECODE</code> is set to <code>OracleTypes.RAW</code> because this is the data type being read from and written to the database. The SQLJ translator needs this type code information in performing online type-checking to verify compatibility between the user-defined Java type and the SQL type.</p>
</li>
<li>
<p>Define client methods that perform the following:</p>
<ul>
<li>
<p>Create a <code>SerializableDatum</code> object.</p>
</li>
<li>
<p>Populate a <code>SerializableDatum</code> object.</p>
</li>
<li>
<p>Retrieve data from a <code>SerializableDatum</code> object.</p>
</li>
</ul>
<pre>// Client methods for constructing and accessing a SerializableDatum

private Object m_data;
public SerializableDatum()
{
   m_data = null;
}
public void setData(Object data)
{
   m_data = data;
}
public Object getData()
{
   return m_data;
}
</pre></li>
<li>
<p>Implement a <code>toDatum()</code> method that serializes data from a <code>SerializableDatum</code> object to an <code>oracle.sql.RAW</code> object. The implementation of <code>toDatum()</code> must return a serialized representation of the object in the <code>m_data</code> field as an <code>oracle.sql.RAW</code> instance.</p>
<pre>// Implementation of toDatum()

try {
   ByteArrayOutputStream os = new ByteArrayOutputStream();
   ObjectOutputStream oos = new ObjectOutputStream(os);
   oos.writeObject(m_data);
   oos.close();
   return new RAW(os.toByteArray());
} catch (Exception e) {
  throw new SQLException(&#34;SerializableDatum.toDatum: &#34;+e.toString()); }
</pre></li>
<li>
<p>Implement data conversion from an <code>oracle.sql.RAW</code> object to a <code>SerializableDatum</code> object. This step deserializes the data.</p>
<pre>// Constructing SerializableDatum from oracle.sql.RAW

private SerializableDatum(RAW raw) throws SQLException
{
   try {
      InputStream rawStream = new ByteArrayInputStream(raw.getBytes());
      ObjectInputStream is = new ObjectInputStream(rawStream);
      m_data = is.readObject();
      is.close();
   } catch (Exception e) {
     throw new SQLException(&#34;SerializableDatum.create: &#34;+e.toString()); }
}
</pre></li>
<li>
<p>Implement an <code>ORADataFactory</code>. In this case, it is implemented as an anonymous class.</p>
<pre>// Implementation of an ORADataFactory for SerializableDatum

new ORADataFactory()
{
   public ORAData create(Datum d, int sqlCode) throws SQLException
   {
      if (sqlCode != _SQL_TYPECODE)
      {
         throw new SQLException
                   (&#34;SerializableDatum: invalid SQL type &#34;+sqlCode);
      }
      return (d==null) ? null : new SerializableDatum((RAW)d);
   }
};
</pre></li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABCAEGC"></a>
<div id="JSQLJ486" class="sect2">
<h3 class="sect2">SerializableDatum in SQLJ Applications</h3>
<p>Given the <code>SerializableDatum</code> class created in the preceding section, this section shows how to use an instance of it in a SQLJ application, both as a host variable and as an iterator column.</p>
<p>Presume the following table definition:</p>
<pre>CREATE TABLE PERSONDATA (NAME VARCHAR2(20) NOT NULL, INFO RAW(2000));
</pre>
<p class="subhead2"><a id="JSQLJ487"></a>Serializable<a id="sthref432"></a>Datum as Host Variable</p>
<p>The following uses a <code>SerializableDatum</code> instance as a host variable:</p>
<pre>...
SerializableDatum pinfo = new SerializableDatum();
pinfo.setData (
   new Object[] {&#34;Some objects&#34;, new Integer(51), new Double(1234.27) } );
String pname = &#34;MILLER&#34;;
#sql { INSERT INTO persondata VALUES(:pname, :pinfo) };
...
</pre>
<p class="subhead2"><a id="JSQLJ488"></a>Serializab<a id="sthref433"></a><a id="sthref434"></a>leDatum in Iterator Column</p>
<p>Following is an example of using <code>SerializableDatum</code> as a named iterator column:</p>
<pre>#sql iterator PersonIter (SerializableDatum info, String name);

...
PersonIter pcur;
#sql pcur = { SELECT * FROM persondata WHERE info IS NOT NULL };
while (pcur.next())
{
   System.out.println(&#34;Name:&#34; + pcur.name() + &#34; Info:&#34; + pcur.info());
}
pcur.close();
...
</pre></div>
<!-- class="sect2" -->
<a id="BABDFJCH"></a>
<div id="JSQLJ489" class="sect2">
<h3 class="sect2">Serializable<a id="sthref435"></a><a id="sthref436"></a>Datum (Complete Class)</h3>
<p>The following is complete code for the <code>SerializableDatum</code> class, which was developed in step-by-step fashion in the preceding sections.</p>
<pre>import java.io.*;
import java.sql.*;
import oracle.sql.*;
import oracle.jdbc.*;

public class SerializableDatum implements ORAData
{
// Client methods for constructing and accessing a SerializableDatum

   private Object m_data;
   public SerializableDatum()
   {
      m_data = null;
   }
   public void setData(Object data)
   {
      m_data = data;
   }
   public Object getData()
   {
      return m_data;
   }

// Implementation of toDatum()

   public Datum toDatum(Connection c) throws SQLException
   {

      try {
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(os);
         oos.writeObject(m_data);
         oos.close();
         return new RAW(os.toByteArray());
      } catch (Exception e) {
        throw new SQLException(&#34;SerializableDatum.toDatum: &#34;+e.toString()); }
   }

   public static ORADataFactory getORADataFactory()
   {
      return FACTORY;
   }

// Implementation of an ORADataFactory for SerializableDatum

   private static final ORADataFactory FACTORY =
   
      new ORADataFactory()
      {
         public ORAData create(Datum d, int sqlCode) throws SQLException
         {
            if (sqlCode != _SQL_TYPECODE)
            {
               throw new SQLException(
                  &#34;SerializableDatum: invalid SQL type &#34;+sqlCode);
            }
            return (d==null) ? null : new SerializableDatum((RAW)d);
         }
      };

// Constructing SerializableDatum from oracle.sql.RAW

   private SerializableDatum(RAW raw) throws SQLException
   {
      try {
         InputStream rawStream = new ByteArrayInputStream(raw.getBytes());
         ObjectInputStream is = new ObjectInputStream(rawStream);
         m_data = is.readObject();
         is.close();
      } catch (Exception e) {
        throw new SQLException(&#34;SerializableDatum.create: &#34;+e.toString()); }
   }

   public static final int _SQL_TYPECODE = OracleTypes.RAW;
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008087"></a>
<div id="JSQLJ490" class="sect1">
<h2 class="sect1">Weakly Typed Ob<a id="sthref437"></a>jects, References, and Collections</h2>
<p>Weakly typed objects, references, and collections are supported by SQLJ. Their use is not generally recommended, and there are some specific restrictions, but in some circumstances they can be useful. For example, you might have generic code that can use &#34;any <code>STRUCT</code>&#34; or &#34;any <code>REF</code>&#34;.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1008091">Support for Weakly Typed Objects, References, and Collections</a></p>
</li>
<li>
<p><a href="#BABFGIFD">Restrictions on Weakly Typed Objects, References, and Collections</a></p>
</li>
</ul>
<a id="i1008091"></a>
<div id="JSQLJ491" class="sect2">
<h3 class="sect2">Support <a id="sthref438"></a><a id="sthref439"></a><a id="sthref440"></a><a id="sthref441"></a>for Weakly Typed Objects, References, and Collections</h3>
<p>In using Oracle objects, references, or collections in a SQLJ application, you have the option of using generic and weakly typed <code>java.sql</code> or <code>oracle.sql</code> instances instead of the strongly typed custom object, reference, and collection classes that implement the <code>ORAData</code> interface or the strongly typed custom object classes that implement the <code>SQLData</code> interface. Note that if you use <code>SQLData</code> implementations for your custom object classes, then you will have no choice but to use weakly typed custom reference instances.</p>
<p>The following weak types can be used for iterator columns or host expressions in the Oracle SQLJ implementation:</p>
<ul>
<li>
<p><code>java.sql.Struct</code> or <code>oracle.sql.STRUCT</code> for objects</p>
</li>
<li>
<p><code>java.sql.Ref</code> or <code>oracle.sql.REF</code> for object references</p>
</li>
<li>
<p><code>java.sql.Array</code> or <code>oracle.sql.ARRAY</code> for collections</p>
</li>
</ul>
<p>In host expressions, they are supported as follows:</p>
<ul>
<li>
<p>As input host expressions</p>
</li>
<li>
<p>As output host expressions in an <code>INTO</code>-list</p>
</li>
</ul>
<p>Using these weak types is not generally recommended, however, as you would lose all the advantages of the strongly typed paradigm that SQLJ offers.</p>
<p>Each attribute in a <code>STRUCT</code> object or each element in an <code>ARRAY</code> object is stored in an <code>oracle.sql.Datum</code> object, with the underlying data being in the form of the appropriate <code>oracle.sql.*</code> subtype of <code>Datum</code>, such as <code>oracle.sql.NUMBER</code> or <code>oracle.sql.CHAR</code>. Attributes in a <code>STRUCT</code> object are nameless. Because of the generic nature of the <code>STRUCT</code> and <code>ARRAY</code> classes, SQLJ cannot perform type checking where objects or collections are written to or read from instances of these classes.</p>
<p>It is generally recommended that you use custom Java classes for objects, references, and collections, preferably classes generated by JPublisher.</p>
</div>
<!-- class="sect2" -->
<a id="BABFGIFD"></a>
<div id="JSQLJ492" class="sect2">
<h3 class="sect2">Restrictions <a id="sthref442"></a><a id="sthref443"></a><a id="sthref444"></a><a id="sthref445"></a>on Weakly Typed Objects, References, and Collections</h3>
<p>A weakly typed object (<code>Struct</code> or <code>STRUCT</code> instance), reference (<code>Ref</code> or <code>REF</code> instance), or collection (<code>Array</code> or <code>ARRAY</code> instance) <span class="italic">cannot</span> be used in host expressions in the following circumstances:</p>
<ul>
<li>
<p><code>IN</code> parameter if null</p>
</li>
<li>
<p><code>OUT</code> or <code>INOUT</code> parameter in a stored procedure or function call</p>
</li>
<li>
<p><code>OUT</code> parameter in a stored function result expression</p>
</li>
</ul>
<p>They cannot be used in these ways, because there is no way to know the underlying SQL type name, such as <code>Person</code>, which is required by Oracle JDBC driver to materialize an instance of a user-defined type in Java.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008113"></a>
<div id="JSQLJ493" class="sect1">
<h2 class="sect1">Oracle OPA<a id="sthref446"></a>QUE Types</h2>
<p>Oracle OPAQUE types are abstract data types. With data implemented as simply a series of bytes, the internal representation is not exposed. Typically an OPAQUE type will be provided by Oracle, not implemented by a customer.</p>
<p>OPAQUE types are similar in some basic ways to object types, with similar concepts of static methods, instances, and instance methods. Typically, only the methods supplied with an OPAQUE type allow you to manipulate the state and internal byte representation. In Java, an OPAQUE type can be represented as <code>oracle.sql.OPAQUE</code> or as a custom class implementing the <code>oracle.sql.ORAData</code> interface. On the client-side, Java code can be implemented to manipulate the bytes, assuming the byte pattern is known. The Oracle Database 12<span class="italic">c</span> Release 1 (12.1) JPublisher utility can be useful in this way, creating a custom class implementing <code>ORAData</code> to allow you to manipulate data without having to make repeated round trips to the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a></div>
<p>A key example of an OPAQUE type is <code>XMLType</code>, provided with Oracle Database 12<span class="italic">c</span> Release 1 (12.1). This Oracle-provided type facilitates handling XML data natively in the database.</p>
<p><code>SYS.XMLType</code> offers the following features, exposed through the Java <code>oracle.xdb.XMLType</code> class:</p>
<ul>
<li>
<p>It can be used as the data type of a column in a table or view. <code>XMLType</code> can store any content but is designed to optimally store XML content. An instance of it can represent an XML document in SQL.</p>
</li>
<li>
<p>It has a SQL API with built-in member functions that operate on XML content. For example, you can use <code>XMLType</code> functions to create, query, extract, and index XML data stored in an Oracle Database 12<span class="italic">c</span> Release 1 (12.1) instance.</p>
</li>
<li>
<p>It can be used in stored procedures for parameters, return values, and variables.</p>
</li>
<li>
<p>Its functionality is also available through APIs provided in PL/SQL, Java, and C (OCI).</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDB" href="../ADXDB/toc.htm"><span class="italic">Oracle XML DB Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4010">
<tr>
<td class="cellalignment4017">
<table class="cellalignment4015">
<tr>
<td class="cellalignment4014"><a href="typesupp.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4014"><a href="alangfea.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4019">
<table class="cellalignment4013">
<tr>
<td class="cellalignment4014"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4014"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4014"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4014"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4014"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4014"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>