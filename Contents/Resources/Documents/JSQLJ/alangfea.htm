<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-72359"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Advanced%20Language%20Features"></a><title>Advanced Language Features</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743"/>
<meta name="dcterms.created" content="2013-12-02T6:55:14Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SQLJ Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17660-12"/>
<meta name="dcterms.isVersionOf" content="JSQLJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="objcoll.htm" title="Previous" type="text/html"/>
<link rel="Next" href="transopt.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E17660-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/20</span> <!-- End Header -->
<div id="JSQLJ494" class="chapter"><a id="CBBGHHFJ"></a> <a id="i1009135"></a>
<h1 class="chapter"><span class="secnum">7</span> Advanced Language Features</h1>
<p>This chapter discusses advanced SQLJ language features for use in coding your application. For more basic topics, refer to <a href="blangfea.htm#CBBFFFHF">Chapter 4, &#34;Basic Language Features&#34;</a>.</p>
<p>The following topics are discussed:</p>
<ul>
<li>
<p><a href="#i1005583">Connection Contexts</a></p>
</li>
<li>
<p><a href="#i1006207">Execution Contexts</a></p>
</li>
<li>
<p><a href="#i1006495">Multithreading in SQLJ</a></p>
</li>
<li>
<p><a href="#i1006593">Iterator Class Implementation and Advanced Functionality</a></p>
</li>
<li>
<p><a href="#i1006992">Advanced Transaction Control</a></p>
</li>
<li>
<p><a href="#i1007059">SQLJ and JDBC Interoperability</a></p>
</li>
<li>
<p><a href="#i1007348">Support for Dynamic SQL</a></p>
</li>
<li>
<p><a href="#CHDDCECE">Using Stored Outlines</a></p>
</li>
<li>
<p><a href="#CHDBIAIA">Using Plan Baselines</a></p>
</li>
</ul>
<a id="i1005583"></a>
<div id="JSQLJ495" class="sect1">
<h2 class="sect1"><a id="sthref447"></a><a id="sthref448"></a>Connection Contexts</h2>
<p>SQLJ supports the concept of connection contexts, allowing strongly typed connections for use with different sets of SQL entities. You can think of a connection context as being associated with a particular set of SQL entities, such as tables, views, and stored procedures. SQLJ lets you declare additional connection context classes so that you can use each class for connections that use a particular set of SQL entities. Different instances of a single connection context class are not required to use the same physical entities or connect to the same schema, but will at least use sets of entities with the same names and data types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1005714">&#34;Connection Considerations&#34;</a> for an overview of connection basics, focusing on situations where you are using just a single set of SQL entities and a single connection context class.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1005597">Connection Context Concepts</a></p>
</li>
<li>
<p><a href="#CHDFFGIE">Connection Context Logistics</a></p>
</li>
<li>
<p><a href="#i1005654">Declaring and Using a Connection Context Class</a></p>
</li>
<li>
<p><a href="#i1005781">Example of Multiple Connection Contexts</a></p>
</li>
<li>
<p><a href="#i1005839">Implementation and Functionality of Connection Context Classes</a></p>
</li>
<li>
<p><a href="#i1005906">Using the IMPLEMENTS Clause in Connection Context Declarations</a></p>
</li>
<li>
<p><a href="#CHDBFDJC">Semantics-Checking of Your Connection Context Usage</a></p>
</li>
<li>
<p><a href="#i1005952">Standard Data Source Support</a></p>
</li>
<li>
<p><a href="#i1006000">SQLJ-Specific Data Sources</a></p>
</li>
<li>
<p><a href="#i1006101">SQLJ-Specific Connection JavaBeans for JavaServer Pages</a></p>
</li>
<li>
<p><a href="#CHDDHECE">SQLJ Support for Global Transactions</a></p>
</li>
<li>
<p><a href="#CHDCGBAE">Connecting to PDBs</a></p>
</li>
</ul>
<a id="i1005597"></a>
<div id="JSQLJ496" class="sect2">
<h3 class="sect2">Connection <a id="sthref449"></a>Context Concepts</h3>
<p>If your application uses different sets of SQL entities, then you will typically want to declare and use one or more additional connection context classes, as discussed in <a href="blangfea.htm#i1005585">&#34;Overview of SQLJ Declarations&#34;</a>. Each connection context class can be used for a particular set of interrelated SQL entities, meaning that all the connections you define using a particular connection context class will use tables, views, stored procedures, and so on, which have the same names and use the same data types.</p>
<p>An example of a set of SQL entities is the set of tables and stored procedures used by the Human Resources (HR) department. Perhaps they use the <code>EMPLOYEES</code> and <code>DEPARTMENTS</code> tables and the <code>CHANGE_DEPT</code> and <code>UPDATE_HEALTH_PLAN</code> stored procedures. Another set of SQL entities might be the set of tables and procedures used by the Payroll department, perhaps consisting of the <code>EMPS</code> table (another table of employees, but different than the one used by HR) and the <code>GIVE_RAISE</code> and <code>CHANGE_WITHHOLDING</code> stored procedures.</p>
<p>The advantage in tailoring connection context classes to sets of SQL entities is in the degree of online semantics-checking that this allows. Online checking verifies that all the SQL entities appearing in SQLJ statements that use a given connection context class match SQL entities found in the exemplar schema used during translation. An exemplar schema is a database account that SQLJ connects to for online checking of all the SQLJ statements that use a particular connection context class. You provide exemplar schemas to the translator through the SQLJ command-line <code>-user</code>, <code>-password</code>, and <code>-url</code> options. An exemplar schema may or may not be the same account your application will use at run time.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1006917">&#34;Connection Options&#34;</a></div>
<p>If you have SQLJ statements that use a broad and perhaps unrelated group of SQL entities, but you use only a single connection context class for these statements, then the exemplar schema you provide must be very general. It must contain all the tables, views, and stored procedures used throughout all the statements. Alternatively, if all the SQLJ statements using a given connection context class use a tight, presumably interrelated, set of SQL entities, then you can provide a more specific exemplar schema that enables more thorough and meaningful semantics-checking.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Be aware that a connection context class declaration does not define a set of SQL entities to be used with the declared connection context class, and it is permissible to use the same connection context class for connections that use disparate and unrelated sets of entities. How you use your connection context classes is at your discretion. All that limits the SQL entities you can use with a particular connection context class are the set of entities available in the exemplar schema, if you use online semantics-checking during translation, and the set of entities available in the schema you connect to at run time, using instances of the connection context class.</p>
</li>
<li>
<p>If you use qualified SQL names in your application, such as <code>HR.EMPLOYEES</code>, which specifies the schema where the entity resides, then the exemplar schema, if you use online checking, and run-time schema must have permission to access resources by these fully qualified names.</p>
</li>
<li>
<p>It is possible to use a single connection context class, even for connections to databases from different vendors, as long as each schema you connect to has entities that are accessible by the same names and that use compatible data types.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDFFGIE"></a>
<div id="JSQLJ497" class="sect2">
<h3 class="sect2"><a id="sthref450"></a>Connection Context Logistics</h3>
<p>Declaring a connection context class results in the SQLJ translator defining a class for you in the translator-generated code. In addition to any connection context classes that you declare, there is always the default connection context class:</p>
<pre>sqlj.runtime.ref.DefaultContext
</pre>
<p>When you construct a connection context instance, specify a particular schema and a particular session and transaction in which SQL operations will execute. You typically accomplish this by specifying a user name, password, and database URL as input to the constructor of the connection context class. The connection context instance manages the set of SQL operations performed during the session.</p>
<p>In each SQLJ statement, you can specify a connection context instance to use. The following example shows basic declaration and use of a connection context class, <code>MyContext</code>, to connect to two different schemas. For typical usage, assume these schemas include a set of SQL entities with common names and data types.</p>
<pre>#sql context MyContext;

...
MyContext mctx1 = new MyContext
  (&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, &#34;HR&#34;, &#34;hr&#34;, false);
MyContext mctx2 =  new MyContext
  (&#34;jdbc:oracle:thin@localhost:5221/myservice&#34;, &#34;brian&#34;, &#34;mypasswd&#34;, false);
</pre>
<p>Note that connection context class constructors specify a boolean auto-commit parameter. In addition, note that you can connect to the same schema with different connection context instances. In the preceding example, both <code>mctx1</code> and <code>mctx2</code> can specify <code>HR/hr</code> if desired. However, during run time, one connection context instance would not see changes to the database made from the other until the changes are committed. The only exception to this would be if both connection context instances were created from the same underlying Java Database Connectivity (JDBC) connection instance. One of the constructors of any connection context class takes a JDBC connection instance as input.</p>
</div>
<!-- class="sect2" -->
<a id="i1005654"></a>
<div id="JSQLJ498" class="sect2">
<h3 class="sect2"><a id="sthref451"></a>Declaring and Using a Connection Context Class</h3>
<p>This section gives a detailed example of how to declare a connection context class, then define a database connection using an instance of the class.</p>
<p>A connection context class has constructors for opening a connection to a database schema that take any of the following input parameter sets (as with the <code>DefaultContext</code> class):</p>
<ul>
<li>
<p>URL (<code>String</code>), user name (<code>String</code>), password (<code>String</code>), auto-commit (<code>boolean</code>)</p>
</li>
<li>
<p>URL (<code>String</code>), <code>java.util.Properties</code> object, auto-commit (<code>boolean</code>)</p>
</li>
<li>
<p>URL (<code>String</code> fully specifying connection and including user name and password), auto-commit setting (<code>boolean</code>)</p>
</li>
<li>
<p>JDBC connection object (<code>Connection</code>)</p>
</li>
<li>
<p>SQLJ connection context object</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>When using the constructor that takes a JDBC connection object, do not initialize the connection context instance with a null JDBC connection.</p>
</li>
<li>
<p>The auto-commit setting determines whether SQL operations are automatically committed. For more information, refer to <a href="keyprog.htm#i1006304">&#34;Basic Transaction Control&#34;</a>.</p>
</li>
<li>
<p>If a connection context class is declared with a data source <code>with</code> clause, then it incorporates a different set of constructors. Refer to <a href="#i1005952">&#34;Standard Data Source Support&#34;</a> for more information.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JSQLJ499"></a>Declaring <a id="sthref452"></a>the Connection Context Class</p>
<p>The following declaration creates a connection context class:</p>
<pre>#sql context OrderEntryCtx &lt;<span class="italic">implements_clause</span>&gt; &lt;<span class="italic">with_clause</span>&gt;; 
</pre>
<p>This results in the SQLJ translator generating a class that implements the <code>sqlj.runtime.ConnectionContext</code> interface and extends some base class, probably an abstract class, that also implements the <code>ConnectionContext</code> interface. This base class would be a feature of the particular SQLJ implementation you are using. The <code>implements</code> clause and <code>with</code> clause are optional, specifying additional interfaces to implement and variables to define and initialize, respectively.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="blangfea.htm#i1005681">&#34;Declaration IMPLEMENTS Clause&#34;</a> and <a href="blangfea.htm#CBBBBJEC">&#34;Declaration WITH Clause&#34;</a></div>
<p>The following is an example of what the SQLJ translator generates (with method implementations omitted):</p>
<pre>class OrderEntryCtx implements sqlj.runtime.ConnectionContext 
      extends ...
{ 
   public OrderEntryCtx(String url, Properties info, boolean autocommit)
          throws SQLException {...} 
   public OrderEntryCtx(String url, boolean autocommit) 
          throws SQLException {...}   
   public OrderEntryCtx(String url, String user, String password, 
          boolean autocommit) throws SQLException {...} 
   public OrderEntryCtx(Connection conn) throws SQLException {...} 
   public OrderEntryCtx(ConnectionContext other) throws SQLException {...} 

   public static OrderEntryCtx getDefaultContext() {...} 
   public static void setDefaultContext(OrderEntryCtx ctx) {...} 
} 
</pre>
<p class="subhead2"><a id="JSQLJ500"></a>Creating a <a id="sthref453"></a>Connection Context Instance</p>
<p>Continuing the preceding example, instantiate the <code>OrderEntryCtx</code> class with the following syntax:</p>
<pre>OrderEntryCtx myOrderConn = new OrderEntryCtx
                            (<span class="italic">url</span>, <span class="italic">username</span>, <span class="italic">password, autocommit</span>);
</pre>
<p>For example:</p>
<pre>OrderEntryCtx myOrderConn = new OrderEntryCtx
  (&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, &#34;HR&#34;, &#34;hr&#34;, true);
</pre>
<p>This is accomplished in the same way as instantiating the <code>DefaultContext</code> class. All connection context classes, including <code>DefaultContext</code>, have the same constructor signatures.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>You typically must register your JDBC driver prior to constructing a connection context instance. Refer to <a href="keyprog.htm#i1005674">&#34;Driver Selection and Registration for Run Time&#34;</a>.</p>
</li>
<li>
<p>If a connection context class is declared with a data source <code>with</code> clause, then it incorporates a different set of constructors. Refer to <a href="#i1005952">&#34;Standard Data Source Support&#34;</a> for more information.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="i1005756"></a><a id="JSQLJ501"></a>Specifying a <a id="sthref454"></a>Connection Context Instance for a SQLJ Clause</p>
<p>Recall that the basic SQLJ statement syntax is as follows:</p>
<pre>#sql &lt;[&lt;<span class="italic">conn</span>&gt;<span class="italic">&lt;, &gt;&lt;exec</span>&gt;]&gt; { <span class="italic">SQL operation</span> };
</pre>
<p>Specify the connection context instance inside square brackets following the <code>#sql</code> token. For example, in the following SQLJ statement, the connection context instance is <code>myOrderConn</code> from the previous example:</p>
<pre>#sql [myOrderConn] { UPDATE TAB2 SET COL1 = :w WHERE :v &lt; COL2 };
</pre>
<p>In this way, you can specify an instance of either the <code>DefaultContext</code> class or any declared connection context class.</p>
<p class="subhead2"><a id="JSQLJ502"></a>Closing a Connection Context Instance</p>
<p>It is advisable to close all connection context instances when you are done. Each connection context class includes a <code>close()</code> method, as discussed for the <code>DefaultContext</code> class in <a href="keyprog.htm#i1005855">&#34;Closing Connections&#34;</a>.</p>
<p>In closing a connection context instance that shares the underlying connection with another connection instance, you might want to keep the underlying connection open.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007208">&#34;Closing Shared Connections&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1005781"></a>
<div id="JSQLJ503" class="sect2">
<h3 class="sect2"><a id="sthref455"></a>Example of <a id="sthref456"></a><a id="sthref457"></a>Multiple Connection Contexts</h3>
<p>The following is an example of a SQLJ application using multiple connection contexts. It implicitly uses an instance of the <code>DefaultContext</code> class for one set of SQL entities and an instance of the declared <code>DeptContext</code> connection context class for another set of SQL entities.</p>
<p>This example uses the static <code>Oracle.connect()</code> method to establish a default connection, then constructs an additional connection by using the static <code>Oracle.getConnection()</code> method to pass another <code>DefaultContext</code> instance to the <code>DeptContext</code> constructor. As previously mentioned, this is just one of several ways you can construct a SQLJ connection context instance.</p>
<pre>import java.sql.SQLException;
import oracle.sqlj.runtime.Oracle;

// declare a new context class for obtaining departments
#sql context DeptContext;

#sql iterator Employees (String ename, int deptno);

class MultiSchemaDemo 
{
  public static void main(String[] args) throws SQLException 
  {
    // set the default connection to the URL, user, and password
    // specified in your connect.properties file
    Oracle.connect(MultiSchemaDemo.class, &#34;connect.properties&#34;);

    // create a context for querying department info using
    // a second connection
    DeptContext deptCtx = 
      new DeptContext(Oracle.getConnection(MultiSchemaDemo.class, 
                     &#34;connect.properties&#34;));

    new MultiSchemaDemo().printEmployees(deptCtx);
    deptCtx.close();
  }

  // performs a join on deptno field of two tables accessed from
  // different connections. 
  void printEmployees(DeptContext deptCtx) throws SQLException
  {
    // obtain the employees from the default context
    Employees emps;
    #sql emps = { SELECT first_name, department_id FROM employees }; 

    // for each employee, obtain the department name
    // using the dept table connection context
    while (emps.next()) {
      String dname;
      int deptno = emps.deptno();
      #sql [deptCtx] { 
        SELECT dname INTO :dname FROM departments WHERE department_id = :deptno
      };
      System.out.println(&#34;employee: &#34; +emps.ename() +
                         &#34;, department: &#34; + dname);
    }
    emps.close();
  }
}
</pre></div>
<!-- class="sect2" -->
<a id="i1005839"></a>
<div id="JSQLJ504" class="sect2">
<h3 class="sect2"><a id="sthref458"></a>Implementation and <a id="sthref459"></a>Functionality of Connection Context Classes</h3>
<p>This section discusses how SQLJ implements connection context classes, including the <code>DefaultContext</code> class, and what noteworthy methods they contain. As mentioned earlier, the <code>DefaultContext</code> class and all generated connection context classes implement the <code>ConnectionContext</code> interface.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Extending connection context classes is not permitted in the SQLJ specification and is not supported by the Oracle SQLJ implementation.</div>
<p class="subhead2"><a id="JSQLJ505"></a>ConnectionContext Interface</p>
<p>Each connection context class implements the <code>sqlj.runtime.ConnectionContext</code> interface.</p>
<p><a id="sthref460"></a><a id="sthref461"></a><a id="sthref462"></a><a id="sthref463"></a>Basic methods specified by this interface include the following:</p>
<ul>
<li>
<p><code>close(boolean CLOSE_CONNECTION/KEEP_CONNECTION)</code>: Releases all resources used in maintaining this connection and closes any open connected profiles. It may close the underlying JDBC connection, depending on whether <code>CLOSE_CONNECTION</code> or <code>KEEP_CONNECTION</code> is specified. These are static boolean constants of the <code>ConnectionContext</code> interface.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007208">&#34;Closing Shared Connections&#34;</a></div>
</li>
<li>
<p><code>getConnection()</code>: Returns the underlying JDBC connection object for this connection context instance.</p>
</li>
<li>
<p><code>getExecutionContext()</code>: Returns the default <code>ExecutionContext</code> instance for this connection context instance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006207">&#34;Execution Contexts&#34;</a></div>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ506"></a>Additional <a id="sthref464"></a><a id="sthref465"></a>Connection Context Class Methods</p>
<p>In addition to the methods specified and defined in the <code>ConnectionContext</code> interface, each connection context class defines the following methods:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">YourCtxClass</span></code> <code>getDefaultContext()</code>: This is a static method that returns the default connection context instance for a given connection context class.</p>
</li>
<li>
<p><code>setDefaultContext(</code><code><span class="codeinlineitalic">YourCtxClass</span></code> <code><span class="codeinlineitalic">connctxinstance</span></code><code>)</code>: This is a static method that defines the given connection context instance as the default connection context instance for its class.</p>
</li>
</ul>
<p>Although it is true that you can use an instance of only the <code>DefaultContext</code> class as your default connection, it might still be useful to designate an instance of a declared connection context class as the default context for that class, using the <code>setDefaultContext()</code> method. Then you could conveniently retrieve it using the <code>getDefaultContext()</code> method of the particular class. This would enable you, for example, to specify a connection context instance for a SQLJ executable statement as follows:</p>
<pre>#sql context MyContext;

...
MyContext myctx1 = new MyContext(<span class="italic">url, user, password, autocommit</span>);
...
MyContext.setDefaultContext(myctx1);
...
#sql [MyContext.getDefaultContext()] { <span class="italic">SQL operations</span> };
...
</pre>
<p>Additionally, each connection context class defines methods for control of SQLJ statement caching. The following are the static methods:</p>
<ul>
<li>
<p><code>setDefaultStmtCacheSize(int)</code></p>
</li>
<li>
<p><code>int getDefaultStmtCacheSize()</code></p>
</li>
</ul>
<p>The following are the instance methods:</p>
<ul>
<li>
<p><code>setStmtCacheSize(int)</code></p>
</li>
<li>
<p><code>int getStmtCacheSize()</code></p>
</li>
</ul>
<p>By default, statement caching is enabled.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1005665">&#34;Connection Context Methods for Statement Caching (Oracle-Specific Code)&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1005906"></a>
<div id="JSQLJ507" class="sect2">
<h3 class="sect2">Using the <a id="sthref466"></a><a id="sthref467"></a>IMPLEMENTS Clause in Connection Context Declarations</h3>
<p>There may be situations where it is useful to implement an interface in your connection context declarations. For example, you may want to define an interface that exposes just a subset of the functionality of a connection context class. More specifically, you may want a class that has the <code>getConnection()</code> functionality, but does not have other functionality of a connection context class.</p>
<p>You can create an interface called <code>HasConnection</code>, for example, that specifies a <code>getConnection()</code> method, but does not specify other methods found in a connection context class. You can then declare a connection context class but expose only the <code>getConnection()</code> functionality by assigning a connection context instance to a variable of the <code>HasConnection</code> type, instead of to a variable that has the type of your declared connection context class.</p>
<p>Assuming <code>HasConnection</code> is in the <code>mypackage</code> package, the declaration will be as follows:</p>
<pre>#sql public context MyContext implements mypackage.HasConnection;
</pre>
<p>You can then instantiate a connection instance as follows:</p>
<pre>HasConnection myConn = new MyContext (<span class="italic">url</span>, <span class="italic">username</span>, <span class="italic">password, autocommit</span>);
</pre>
<p>For example:</p>
<pre>HasConnection myConn = new MyContext 
   (&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, &#34;HR&#34;, &#34;hr&#34;, true);
</pre></div>
<!-- class="sect2" -->
<a id="CHDBFDJC"></a>
<div id="JSQLJ508" class="sect2">
<h3 class="sect2"><a id="sthref468"></a>Semantics-Checking <a id="sthref469"></a>of Your Connection Context Usage</h3>
<p>A significant feature of SQLJ is strong typing of connections, with each connection context class typically used for operations on a particular set of interrelated SQL entities. This does not mean that all the connection instances of a single class use the same physical entities. Instead, they use entities that have the same properties, such as names and privileges associated with tables and views, data types of their rows, and names and definitions of stored procedures. This strong typing allows SQLJ semantics-checking to verify during translation that you are using your SQL operations correctly, with respect to your database connections.</p>
<p>To use online semantics-checking during translation, provide a sample schema, which includes an appropriate set of SQL entities, for each connection context class. These sample schemas are referred to as exemplar schemas. Provide exemplar schemas through an appropriate combination of the SQLJ <code>-user</code>, <code>-password</code>, and <code>-url</code> options. Following are two examples, one for the <code>DefaultContext</code> class and one for a declared connection context class, where the user, password, and URL are all specified through the <code>-user</code> option:</p>
<pre>-user=HR/hr@jdbc:oracle:oci:@
-user@MyContext=HR/hr@jdbc:oracle:oci:@
</pre>
<p>During semantics-checking, the translator connects to the specified exemplar schema for a particular connection context class and accomplishes the following:</p>
<ul>
<li>
<p>It examines each SQLJ statement in your code that specifies an instance of the connection context class and checks its SQL operations, such as what tables you access and what stored procedures you use.</p>
</li>
<li>
<p>It verifies that entities in the SQL operations match the set of entities existing in the exemplar schema.</p>
</li>
</ul>
<p>It is your responsibility to pick an exemplar schema that represents the run-time schema in appropriate ways. For example, it must have tables, views, stored functions, and stored procedures with names and data types that match what are used in your SQL operations, and with privileges set appropriately.</p>
<p>If no appropriate exemplar schema is available during translation for one of your connection context classes, then it is not necessary to specify SQLJ translator options for that particular connection context class. In that case, SQLJ statements specifying connection objects of that connection context class are semantically checked only to the extent possible.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Remember that the exemplar schema you specify in your translator option settings does not specify the schema to be used at run time. The exemplar schema furnishes the translator only with a set of SQL entities to compare against the entities you use in your SQLJ executable statements.</div>
</div>
<!-- class="sect2" -->
<a id="i1005952"></a>
<div id="JSQLJ509" class="sect2">
<h3 class="sect2">Standard Data So<a id="sthref470"></a><a id="sthref471"></a>urce Support</h3>
<p>The JDBC 2.0 extended application programming interface (API) specifies the use of data sources and Java Naming and Directory Interface (JNDI) as a portable alternative to the <code>DriverManager</code> mechanism for obtaining JDBC connections. It permits database connections to be established through a JNDI name lookup. This name is bound to a particular database and schema prior to program run time through a <code>javax.sql.DataSource</code> object, typically installed through a graphical user interface (GUI) JavaBeans deployment tool. The name can be bound to different physical connections without any source code changes simply by rebinding the name in the directory service.</p>
<p>SQLJ uses the same mechanism to create connection context instances in a flexible and portable way. Data sources can also be implemented using a connection pool or distributed transaction service, as defined by the JDBC 2.0 extended API.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<p class="subhead2"><a id="JSQLJ510"></a>Ass<a id="sthref472"></a>ociating a Connection Context with a Data Source</p>
<p>In SQLJ it is natural to associate a connection context class with a logical schema, in much the same way that a data source name serves as a symbolic name for a JDBC connection. Combine both concepts by adding the data source name to the connection context declaration. For example:</p>
<pre>#sql context EmpCtx with (dataSource=&#34;jdbc/EmpDB&#34;);
</pre>
<p>Any connection context class that you declare with a <code>dataSource</code> property provides additional constructors. To continue the <code>EmpCtx</code> example, the following constructors are provided:</p>
<ul>
<li>
<p><code>EmpCtx()</code>: Looks up the data source for <code>jdbc/EmpDB</code> and then calls the <code>getConnection()</code> method on the data source to obtain a connection.</p>
</li>
<li>
<p><code>EmpCtx(String user, String password)</code>: Looks up the data source for <code>jdbc/EmpDB</code> and calls the <code>getConnection(user,password)</code> method on the data source to obtain a connection.</p>
</li>
<li>
<p><code>EmpCtx(ConnectionContext ctx)</code>: Delegates to <code>ctx</code> to obtain a connection.</p>
</li>
</ul>
<p>Any connection context class declared with a <code>dataSource</code> property also omits a number of <code>DriverManager</code>-based constructors. Continuing the <code>EmpCtx</code> example, the following constructors are omitted:</p>
<ul>
<li>
<p><code>EmpCtx(Connection conn)</code></p>
</li>
<li>
<p><code>EmpCtx(String url, String user, String password, boolean autoCommit)</code></p>
</li>
<li>
<p><code>EmpCtx(String url, boolean autoCommit)</code></p>
</li>
<li>
<p><code>EmpCtx(String url, java.util.Properties info, boolean autoCommit)</code></p>
</li>
<li>
<p><code>EmpCtx(String url, boolean autoCommit)</code></p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ511"></a>Auto-Com<a id="sthref473"></a>mit Mode for Data Source Connections</p>
<p>The constructors based on data source, unlike those base on <code>DriverManager</code>, do not include an explicit auto-commit parameter. They always use the auto-commit mode defined by the data source.</p>
<p>Data sources are configured to have a default auto-commit mode depending on the deployment scenario. For example, data sources in the server and middle tier typically have auto-commit off. Those on the client may have it on. However, it is also possible to configure data sources with a specific auto-commit setting. This permits data sources to be configured for a particular application and deployment scenario. Contrast this with JDBC URLs that may specify only a single database/driver configuration.</p>
<p>Programs can verify and possibly override the current auto-commit setting with the JDBC connection that underlies their connection context instance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Be aware of the following points related to the auto-commit status of the connections you establish:
<ul>
<li>
<p>If you use the <code>Oracle</code> class, then auto-commit is off unless you turn it on explicitly.</p>
</li>
<li>
<p>If you use <code>DefaultContext</code> or a connection context class with <code>DriverManager</code>-style constructors, then the auto-commit setting must always be specified explicitly.</p>
</li>
<li>
<p>If you use the data source mechanism, then the auto-commit setting is inherited from the underlying data source. In most environments, the data source object originates from JDBC and the auto-commit option is on. To avoid unexpected behavior, always check the auto-commit setting.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JSQLJ512"></a>Asso<a id="sthref474"></a><a id="sthref475"></a>ciating a Data Source with the Default Context</p>
<p>If a SQLJ program accesses the default connection context, and the default context has not yet been set, then the SQLJ run time will use the SQLJ default data source to establish its connection. The SQLJ default data source is bound to the JNDI name, <code>jdbc/defaultDataSource</code>.</p>
<p>This mechanism provides a portable means to define and install a default JDBC connection for the default SQLJ connection context.</p>
<p class="subhead2"><a id="JSQLJ513"></a>Data Sou<a id="sthref476"></a>rce Support Requirements</p>
<p>For your program to use data sources, you must supply the <code>javax.sql.*</code> and <code>javax.naming.*</code> packages and an <code>InitialContext</code> provider in your Java environment. The latter is required to obtain the JNDI context in which the SQLJ run time can look up the data source object.</p>
<p>All SQLJ run-time libraries provided by Oracle support data sources. However, if you use the <code>runtime12ee</code> library you must have <code>javax.sql.*</code> and <code>javax.naming.*</code> in your classpath in order for the run time to load. By contrast, the other run-time libraries use reflection to retrieve <code>DataSource</code> objects.</p>
</div>
<!-- class="sect2" -->
<a id="i1006000"></a>
<div id="JSQLJ514" class="sect2">
<h3 class="sect2">SQLJ-Spe<a id="sthref477"></a><a id="sthref478"></a><a id="sthref479"></a>cific Data Sources</h3>
<p>The Oracle SQLJ implementation provides SQLJ-specific data source support in the <code>runtime12ee</code> library. Currently, SQLJ-specific data sources can be used in client-side or middle-tier applications, but not inside the server.</p>
<p>SQLJ-specific data sources extend JDBC data source functionality with methods that return SQLJ connection context instances. This enables a SQLJ developer to manage connection contexts just as a JDBC developer manages connections. In general, each SQLJ-specific data source interface or class is based on a corresponding standard JDBC data source interface or Oracle data source class.</p>
<p class="subhead2"><a id="i1006006"></a><a id="JSQLJ515"></a>SQLJ Data So<a id="sthref480"></a>urce Interfaces</p>
<p>The <code>sqlj.runtime.ConnectionContextFactory</code> interface acts as a base interface for SQLJ data source functionality. It is implemented by a set of more specialized Oracle data source interfaces that add support for features such as connection pooling, connection caching, or distributed transactions.</p>
<p>The <code>ConnectionContextFactory</code> interface specifies the following methods to return SQLJ connection context instances:</p>
<ul>
<li>
<p><code>DefaultContext getDefaultContext()</code></p>
</li>
<li>
<p><code>DefaultContext getDefaultContext(boolean autoCommit)</code></p>
</li>
<li>
<p><code>DefaultContext getDefaultContext(String user, String password)</code></p>
</li>
<li>
<p><code>DefaultContext getDefaultContext(String user, String password, boolean autoCommit)</code></p>
</li>
<li>
<p><code>ConnectionContext getContext(Class aContextClass)</code></p>
</li>
<li>
<p><code>ConnectionContext getContext(Class aContextClass, boolean autoCommit)</code></p>
</li>
<li>
<p><code>ConnectionContext getContext(Class aContextClass, String user, String password)</code></p>
</li>
<li>
<p><code>ConnectionContext getContext(Class aContextClass, String user, String password, boolean autoCommit)</code></p>
</li>
</ul>
<p>The <code>getDefaultContext</code> methods return a <code>sqlj.runtime.ref.DefaultContext</code> instance for the SQLJ default context. The <code>getContext()</code> methods return a <code>sqlj.runtime.ConnectionContext</code> instance. Specifically, it returns an instance of a user-declared connection context class that is specified in the method call.</p>
<p>For both <code>getDefaultContext()</code> and <code>getContext()</code>, there are signatures that enable you to specify connection parameters for the JDBC connection that underlies the connection context instance: the auto-commit setting, user and password settings, or all three. If you do not specify the user and password, then they are obtained from the underlying data source that generates the connection. If you do not specify an auto-commit setting, then the default is <code>false</code> unless it was explicitly set to <code>true</code> for the underlying data source.</p>
<p>Each Oracle data source interface that implements <code>ConnectionContextFactory</code> also implements a standard JDBC data source interface to specify methods for the appropriate functionality, such as for basic data sources, connection pooling data sources, or distributed transaction (XA) data sources. Oracle has implemented the <code>SqljDataSource</code>, <code>SqljConnectionPoolDataSource</code>, and <code>SqljXADataSource</code> interfaces, located in the <code>sqlj.runtime</code> package and specified as follows:</p>
<ul>
<li>
<p><code>interface SqljDataSource extends javax.sql.DataSource, ConnectionContextFactory { }</code></p>
</li>
<li>
<p><code>interface SqljDataSource extends javax.sql.ConnectionPoolDataSource, ConnectionContextFactory { }</code></p>
</li>
<li>
<p><code>interface SqljXADataSource extends javax.sql.XADataSource, ConnectionContextFactory { }</code></p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ516"></a>SQLJ Data So<a id="sthref481"></a>urce Classes</p>
<p>Oracle provides SQLJ-specific counterparts for the following JDBC data source classes: <code>OracleDataSource</code>, <code>OracleConnectionPoolDataSource</code>, <code>OracleXADataSource</code>, <code>OracleConnectionCacheImpl</code>, <code>OracleXAConnectionCacheImpl</code>, and <code>OracleOCIConnectionPool</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<p>Oracle SQLJ-specific data source classes are located in two packages: <code>oracle.sqlj.runtime</code> and <code>oracle.sqlj.runtime.client</code>.</p>
<p>The <code>oracle.sqlj.runtime</code> package includes the following:</p>
<ul>
<li>
<p><code>class OracleSqljDataSource extends oracle.jdbc.pool.OracleDataSource implements ConnectionContextFactory</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>OracleSqljDataSource</code> class implements the <code>java.io.Serializable</code> interface. It is therefore serializable and can be used in clustered environments, such as Oracle9<span class="italic">i</span> Application Server Containers for J2EE (OC4J).</div>
<ul>
<li>
<p><code>class OracleSqljConnectionPoolDataSource extends oracle.jdbc.pool.OracleConnectionPoolDataSource implements ConnectionContextFactory</code></p>
</li>
<li>
<p><code>abstract class OracleSqljXADataSource extends oracle.jdbc.xa.OracleXADataSource implements ConnectionContextFactory</code></p>
</li>
<li>
<p><code>class OracleSqljOCIConnectionPool extends oracle.jdbc.pool.OracleOCIConnectionPool implements ConnectionContextFactory</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>If you are using <code>OracleSqljConnectionCacheImpl</code>, then you need to replace it with <code>OracleSqljDataSource</code>.</p>
</li>
<li>
<p>If you are using <code>OracleSqljXAConnectionCacheImpl</code>, then you need to replace it with <code>OracleSqljXADataSource</code>.</p>
</li>
</ul>
</div>
<p>The <code>oracle.sqlj.runtime.client</code> package includes the following:</p>
<ul>
<li>
<p><code>class OracleSqljXADataSource extends oracle.jdbc.xa.client.OracleXADataSource implements ConnectionContextFactory</code></p>
</li>
</ul>
<p>You can use these classes in place of the corresponding JDBC classes that they extend. They include the <code>getDefaultContext()</code> and <code>getContext()</code> methods. When you call these methods, the following steps take place for you:</p>
<ol>
<li>
<p>A new logical JDBC connection is acquired from the present data source.</p>
</li>
<li>
<p>A connection context instance is created from the logical connection and returned.</p>
</li>
</ol>
<p class="subhead2"><a id="JSQLJ517"></a>Examples: Using SQLJ Data Sources</p>
<p>When used in middle-tier environments, SQLJ-specific data sources, like JDBC data sources, are bound to JNDI locations. You can do the binding explicitly, as in the following example:</p>
<pre>//Initialize the data source 
SqljXADataSource sqljDS = new OracleSqljXADataSource(); 
sqljDS.setUser(&#34;HR&#34;); 
sqljDS.setPassword(&#34;hr&#34;); 
sqljDS.setServerName(&#34;myserver&#34;); 
sqljDS.setDatabaseName(&#34;orcl&#34;); 
sqljDS.setDataSourceName(&#34;jdbc/OracleSqljXADS&#34;); 

//Bind the data source to JNDI 
Context ctx = new InitialContext(); 
ctx.bind(&#34;jdbc/OracleSqljXADS&#34;);
</pre>
<p>In a middle-tier OC4J environment, another alternative is to instantiate data sources and bind them to JNDI through settings in the <code>j2ee/home/config/data-sources.xml</code> file. For example, the following <code>&lt;data-source&gt;</code> element in that file creates an <code>OracleSqljXADataSource</code> instance and binds it to the JNDI location, <code>jdbc/OracleSqljXADS</code>:</p>
<pre>&lt;data-source 
     class=&#34;oracle.sqlj.runtime.OracleSqljXADataSource&#34; 
     name=&#34;jdbc/OracleSqljXADS&#34; 
     location=&#34;jdbc/OracleSqljXADS&#34; 
     xa-location=&#34;jdbc/OracleSqljXADS/xa&#34; 
     username=&#34;HR&#34; 
     password=&#34;hr&#34; 
     url=&#34;jdbc:oracle:thin:@myhost:5221/myservice&#34; 
/&gt;
</pre>
<p>A SQLJ-specific data source bound to a JNDI location can be looked up and used in creating connection context instances. The following code segment uses information from the preceding <code>&lt;data-source&gt;</code> element to create connection context instances, a <code>DefaultContext</code> instance and an instance of a user-declared <code>MyCtx</code> class, respectively:</p>
<pre>sqlj.runtime.SqljDataSource sqljDS; 
InitialContext initCtx = new InitialContext(); 
sqljDS = (sqlj.runtime.SqljDataSource)initCtx.lookup(&#34;jdbc/OracleSqljXADS&#34;); 
// getDefaultContext
DefaultContext ctx = sqljDS.getDefaultContext(); 
// getContext
/* Declare MyCtx connection context class. You could optionally use a &#34;with&#34;
   clause to specify  any desired connection parameters not available 
   through the underlying data source.
*/
#sql public static context MyCtx; 
MyCtx ctx = (MyCtx) sqljDS.getContext(MyCtx.class);
</pre></div>
<!-- class="sect2" -->
<a id="i1006101"></a>
<div id="JSQLJ518" class="sect2">
<h3 class="sect2">SQLJ-Specific Con<a id="sthref482"></a><a id="sthref483"></a><a id="sthref484"></a>nection JavaBeans for JavaServer Pages</h3>
<p>Oracle has implemented a set of JavaBeans for database connections from within Java Server Pages (JSP) pages. The original beans, <code>ConnBean</code> and <code>ConnCacheBean</code> in <code>oracle.jsp.dbutil</code>, are documented in the <a class="olink JIJSU" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=JIJSU"><span class="italic">Oracle Containers for J2EE JSP Tag Libraries and Utilities Reference</span></a>.</p>
<p>The Oracle SQLJ implementation provides the following extensions of these JavaBeans in the <code>runtime12ee</code> library for use in SQLJ JSP pages:</p>
<ul>
<li>
<p><code>oracle.sqlj.runtime.SqljConnBean</code></p>
</li>
<li>
<p><code>oracle.sqlj.runtime.SqljConnCacheBean</code></p>
</li>
</ul>
<p><code>ConnBean</code> and <code>ConnCacheBean</code> include methods that return JDBC connection objects. <code>SqljConnBean</code> and <code>SqljConnCacheBean</code> extend this functionality to support a bean property called <code>ContextClass</code> of type <code>String</code> and to return SQLJ connection context instances.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>SqljConnBean</code> class implements the <code>java.io.Serializable</code> interface. It is therefore serializable and can be used in clustered environments, such as OC4J.</div>
<p><code>SqljConnBean</code> and <code>SqljConnCacheBean</code> provide the following methods:</p>
<ul>
<li>
<p><code>void setContextClass(String contextClassName)</code></p>
</li>
<li>
<p><code>String getContextClass()</code></p>
</li>
<li>
<p><code>DefaultContext getDefaultContext()</code></p>
</li>
<li>
<p><code>ConnectionContext getContext()</code></p>
</li>
</ul>
<p>The <code>ContextClass</code> property specifies the name of a user-declared connection context class, if you are not using <code>DefaultContext</code>. You can set this property through the <code>setContextClass()</code> method.</p>
<p>To retrieve a connection context instance, use <code>getDefaultContext()</code> or <code>getContext()</code>, as appropriate. The former returns a <code>sqlj.runtime.ref.DefaultContext</code> instance, and the latter returns a <code>sqlj.runtime.ConnectionContext</code> instance, specifically, an instance of the class specified in the <code>ContextClass</code> property (by default, <code>DefaultContext</code>).</p>
<p>However, note that the <code>getDefaultContext()</code> and <code>getContext()</code> methods are implemented differently between <code>SqljConnBean</code> and <code>SqljConnCacheBean</code>.</p>
<p class="subhead2"><a id="JSQLJ519"></a>Behavior of SqljConnB<a id="sthref485"></a>ean (Simple Connections)</p>
<p>A <code>SqljConnBean</code> instance can wrap only one logical JDBC connection and one SQLJ connection context instance at any given time.</p>
<p>The first <code>getDefaultContext()</code> or <code>getContext()</code> method call will create and return a connection context instance based on the underlying JDBC connection. This connection context instance will also be stored in the <code>SqljConnBean</code> instance.</p>
<p>Once a connection context instance has been created and stored, the behavior of subsequent <code>getDefaultContext()</code> or <code>getContext()</code> calls will depend on the type of the stored connection context and, for <code>getContext()</code>, on the connection context type specified in the <code>ContextClass</code> property, as follows:</p>
<ul>
<li>
<p>For subsequent <code>getDefaultContext()</code> calls:</p>
<ul>
<li>
<p>If the stored connection context instance is a <code>DefaultContext</code> instance: The method will keep returning that instance.</p>
</li>
<li>
<p>If the stored connection context instance is <span class="italic">not</span> a <code>DefaultContext</code> instance: The method will close the stored connection context instance and reuse the underlying JDBC connection to create and return a new connection context as a <code>DefaultContext</code> instance (regardless of the previous connection context type). This becomes the new connection context instance stored in the <code>SqljConnBean</code> instance.</p>
</li>
</ul>
</li>
<li>
<p>For subsequent <code>getContext()</code> calls:</p>
<ul>
<li>
<p>If the stored connection context instance is of the same type as that specified by the <code>ContextClass</code> property: The method will keep returning that instance.</p>
</li>
<li>
<p>If the stored connection context instance is <span class="italic">not</span> of the same type as that specified by <code>ContextClass</code>: The method will close the stored connection context instance and reuse the underlying JDBC connection to create and return a new connection context instance, an instance of what is specified in <code>ContextClass</code>. This becomes the new connection context instance stored in the <code>SqljConnBean</code> instance.</p>
</li>
</ul>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
When <code>SqljConnBean</code> closes a connection context instance, it does so with the <code>KEEP_CONNECTION</code> setting, leaving the underlying JDBC connection intact. Refer to <a href="#i1007208">&#34;Closing Shared Connections&#34;</a> for related information.</div>
<p class="subhead2"><a id="JSQLJ520"></a>Behavior of SqljConnCa<a id="sthref486"></a>cheBean (Connection Caching)</p>
<p>Unlike with <code>SqljConnBean</code>, the <code>SqljConnCacheBean</code> JavaBean creates and returns a new connection context instance, based on a new logical JDBC connection, for each invocation of <code>getDefaultContext()</code> or <code>getContext()</code>. The connection context type will be <code>DefaultContext</code> for a <code>getDefaultContext()</code> call or the type specified in the <code>ContextClass</code> property for a <code>getContext()</code> call.</p>
<p><code>SqljConnCacheBean</code> does not store the connection context instances it creates.</p>
<p class="subhead2"><a id="JSQLJ521"></a>Example: SQLJ JSP Page Using SqljConnCacheBean</p>
<p>The following program, <code>SQLJSelectInto.sqljsp</code>, demonstrates the use of <code>SqljConnCacheBean</code>, its <code>ContextClass</code> bean property, and its <code>getContext()</code> method:</p>
<pre>&lt;%@ page language=&#34;sqlj&#34; 
         import=&#34;java.sql.*, oracle.sqlj.runtime.SqljConnCacheBean&#34; %&gt; 
&lt;jsp:useBean id=&#34;cbean&#34; class=&#34;oracle.sqlj.runtime.SqljConnCacheBean&#34;
             scope=&#34;session&#34;&gt; 
     &lt;jsp:setProperty name=&#34;cbean&#34; property=&#34;User&#34; value=&#34;HR&#34;/&gt; 
     &lt;jsp:setProperty name=&#34;cbean&#34; property=&#34;Password&#34; value=&#34;hr&#34;/&gt; 
     &lt;jsp:setProperty name=&#34;cbean&#34; property=&#34;URL&#34;
                      value=&#34;jdbc:oracle:thin:@myhost:5221/myservice&#34;/&gt; 
     &lt;jsp:setProperty name=&#34;cbean&#34; property=&#34;ContextClass&#34;
                      value=&#34;sqlj.runtime.ref.DefaultContext&#34;/&gt; 
&lt;/jsp:useBean&gt; 
&lt;HTML&gt; 
&lt;HEAD&gt; &lt;TITLE&gt; The SQLJSelectInto JSP  &lt;/TITLE&gt; &lt;/HEAD&gt; 
&lt;BODY BGCOLOR=white&gt; 
&lt;% String empno = request.getParameter(&#34;employee_id&#34;); 
   if (empno != null) { %&gt; 
      &lt;H3&gt; Employee # &lt;%=empno %&gt; Details: &lt;/H3&gt; 
      &lt;% String ename = null;  double sal = 0.0;  String hireDate = null; 
         StringBuffer sb = new StringBuffer(); 
         sqlj.runtime.ref.DefaultContext ctx=null; 
         try { 
           // Make the Connection 
           ctx = (sqlj.runtime.ref.DefaultContext) cbean.getContext(); 
         } catch (SQLException e) { 
         } 
          try { 
             #sql [ctx] { SELECT first_name, salary, TO_CHAR(hire_date, &#39;DD-MON-YYYY&#39;) 
                           INTO :ename, :sal, :hireDate 
                           FROM HR.employees WHERE UPPER(employee_id) = UPPER(:empno) 
             }; 
             sb.append(&#34;&lt;BLOCKQUOTE&gt;&lt;BIG&gt;&lt;B&gt;&lt;PRE&gt;\n&#34;); 
             sb.append(&#34;Name       : &#34; + ename + &#34;\n&#34;); 
             sb.append(&#34;Salary     : &#34; + sal + &#34;\n&#34;); 
             sb.append(&#34;Date hired : &#34; + hireDate); 
             sb.append(&#34;&lt;/PRE&gt;&lt;/B&gt;&lt;/BIG&gt;&lt;/BLOCKQUOTE&gt;&#34;); 
          } catch (java.sql.SQLException e) { 
              sb.append(&#34;&lt;P&gt; SQL error: &lt;PRE&gt; &#34; + e + &#34; &lt;/PRE&gt; &lt;/P&gt;\n&#34;); 
          } finally { 
              if (ctx!= null) ctx.close(); 
          } 
      %&gt; 
     &lt;H3&gt;&lt;%=sb.toString()%&gt;&lt;/H3&gt; 
&lt;%} 
%&gt; 
&lt;B&gt;Enter an employee number:&lt;/B&gt; 
&lt;FORM METHOD=get&gt; 
&lt;INPUT TYPE=&#34;text&#34; NAME=&#34;empno&#34; SIZE=10&gt; 
&lt;INPUT TYPE=&#34;submit&#34; VALUE=&#34;Ask Oracle&#34;); 
&lt;/FORM&gt; 
&lt;/BODY&gt; 
&lt;/HTML&gt; 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example uses the <code>ContextClass</code> property for illustrative purposes. However, be aware that <code>DefaultContext</code> is the default value anyway and if you want to use <code>DefaultContext</code>, then the value of <code>ContextClass</code> is irrelevant, if you use <code>getDefaultContext()</code> instead of <code>getContext()</code>.</div>
</div>
<!-- class="sect2" -->
<a id="CHDDHECE"></a>
<div id="JSQLJ522" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref487"></a>SQLJ Support for Global Transactions</h3>
<p>A distributed transaction, sometimes referred to as a global transaction, is a set of two or more related transactions that must be managed in a coordinated way. The transactions that constitute a distributed transaction might be in the same database, but more typically are in different databases and often in different locations. Each individual transaction of a distributed transaction is referred to as a transaction branch.</p>
<p>The X/Open Distributed Transaction Processing (DTP) architecture defines a standard architecture that enables multiple but related transactions belonging to the same resource manager or different resource managers to work as a single unit. It coordinates the work between an application program (AP) and a resource manager (RM) into global transactions. Either all the transactions are committed or rolled back.</p>
<p>The Oracle XA library is an external interface that enables transaction managers other than Oracle server to coordinate global transactions. XA library use supports non-Oracle resource managers, in distributed transactions. This is particularly useful in transactions between several databases and resources. The implementation of the Oracle XA library conforms to the X/Open Distributed Transaction Processing (DTP) software architecture&#39;s XA interface specification. The Oracle XA Library is installed as part of Oracle Database Enterprise Edition.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>JDBC provides several classes and interfaces to support XA. The OracleXADataSource implements the <code>XADataSource</code> interface. The OracleXADatasource is a factory for XA connections. For more information refer to <a class="olink JJDBC28000" href="../JJDBC/xadistra.htm#JJDBC28000"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a>.</p>
</li>
<li>
<p>This document clearly specifies the methods supported by SQLJ to form a Connection Context in a XA application. To form the connection context, SQLJ uses the JDBC connection formed from the OracleXADataSource.</p>
</li>
</ul>
</div>
<div id="JSQLJ523" class="figure">
<p class="titleinfigure"><a id="sthref488"></a>Figure 7-1 Global Transaction</p>
<img width="700" height="489" src="img/connection_context.gif" alt="Description of Figure 7-1 follows"/><br/>
<a id="sthref489" href="img_text/connection_context.htm">Description of &#34;Figure 7-1 Global Transaction&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Following is an example of Distributed Transaction Processing (DTP) model:</p>
<p>The <span class="bold">transaction manager</span> is an external middle tier component residing outside Oracle Database. It provides an API for specifying the boundaries of the transaction and manages commit and recovery. The TM implements a two-phase commit engine to provide an <span class="italic">all-or-none</span> semantics across distributed RMs.</p>
<p>A <span class="bold">resource manager</span> controls a shared, recoverable resource that can be returned to a consistent state after a failure. For example, Oracle is a resource manager.</p>
<p>The <code>javax.sql.XADataSource</code> interface outlines standard functionality of XA data sources. An XA data source is a factory for XA connections. Oracle JDBC implements the <code>XADataSource</code> interface though the OracleXADatasource class. The <code>getConnection( )</code> method of the OracleXADatasource class returns an XA connection to the underlying data source. In SQLJ, connections to the database can be obtained through the <code>DefaultContext</code> class or the <code>ConnectionContext</code> class. For multiple connections that use different SQL entities, it is advantageous to use connection context declarations to define additional connection context classes.</p>
<p>The code snippet shows how to create an <code>XADatasource</code> first and then a JDBC connection from the datasource through the following steps:</p>
<ul>
<li>
<p>Start XA Resource1</p>
</li>
<li>
<p>Start XA Resource2</p>
</li>
<li>
<p>Perform DML operations with the first Connection object</p>
</li>
<li>
<p>End XA Resource1</p>
</li>
<li>
<p>End XA Resource2</p>
</li>
<li>
<p>Prepare Resource1</p>
</li>
<li>
<p>Prepare Resource2</p>
</li>
<li>
<p>Commit 1</p>
</li>
<li>
<p>Commit 2</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following is not a complete example and contains only relevant codes to create and use an <code>XADatasource</code>.</div>
<p class="subhead2"><a id="JSQLJ524"></a>Example: Creating an XADatasource and using it to create a JDBC connection</p>
<pre>import javax.sql.*;
import javax.transaction.*;
import javax.transaction.xa.*;
...
import oracle.jdbc.driver.*;
import oracle.jdbc.xa.OracleXid;
import oracle.jdbc.xa.OracleXAException;
import oracle.jdbc.xa.client.*;
&hellip;&hellip;&hellip;&hellip;
#sql context MyContext;
#sql iterator Iterator2 (String job_id, String job_title);
#sql iterator Iterator3 (String region_id, String region_name);
&hellip;&hellip;&hellip;&hellip;
class XA3mod{
public static void main (String args [])throws SQLException{
try{
<span class="bold">/*create an XADataSource instance*/</span>
OracleXADataSource oxds = new OracleXADataSource();
oxds.setURL(url);
oxds.setUser(&#34;hr&#34;);
oxds.setPassword(&#34;hr&#34;);
<span class="bold">/*get an XA connection to the underlying data source*/</span>
javax.sql.XAConnection pc1  = oxds.getXAConnection();
<span class="bold">/*use the same data source */</span>
javax.sql.XAConnection pc2  = oxds.getXAConnection();
<span class="bold">/*get the Physical Connections*/</span>
java.sql.Connection conn1 = pc1.getConnection();
java.sql.Connection conn2 = pc2.getConnection();
<span class="bold">/*an application may access data through multiple database connections. Each database connection is enlisted </span>
<span class="bold">with the transaction manager as a transactional resource. The transaction manager obtains an XAResource</span>
<span class="bold"> for each connection participating in a global transaction */</span>
XAResource oxar1 = pc1.getXAResource();
XAResource oxar2 = pc2.getXAResource();
<span class="bold">/*create the Xids With the Same Global Ids. The Xid interface is a Java mapping of the X/Open transaction</span> 
<span class="bold">identifier XID structure*/</span>
Xid xid1 = createXid(1);
Xid xid2 = createXid(2);
<span class="bold">/*start the Resources. This would start work on behalf of a transaction branch specified in xid1 and xid2. </span>
<span class="bold">The transaction manager uses the start method to associate the global transaction with the resource, </span>
<span class="bold">and it uses the end method to disassociate the transaction from the resource */</span>
oxar1.start (xid1, XAResource.TMNOFLAGS);
oxar2.start (xid2, XAResource.TMNOFLAGS);
<span class="bold">/*Do something with conn1 */</span>
DoSomeWork (conn1);
<span class="bold">/*END both the branches */</span>
xar1.end(xid1, XAResource.TMSUCCESS);
xar2.end(xid2, XAResource.TMSUCCESS);
<span class="bold">/*Prepare the RMs. The Oracle XA library interface follows the two-phase commit protocol. Preparing the transactions </span>
<span class="bold">is the first step in this protocol. The two phase commit protocol is explained in detail in the glossary section. */</span>
int prp1 =  oxar1.prepare (xid1);
int prp2 =  oxar2.prepare (xid2);
boolean do_commit = true;
if(!((prp1==XAResource.XA_OK)||(prp1==XAResource.XA_RDONLY)))
            do_commit = false;
if(!((prp2==XAResource.XA_OK)||(prp2==XAResource.XA_RDONLY)))
            do_commit = false;
<span class="bold">/*issue a commit on all transactions only if all the transactions completed without and errors. Rollback even </span>
<span class="bold">if a single transaction failed.*/</span>
if (prp1 == XAResource.XA_OK)
           if (do_commit)
           oxar1.commit (xid1, false);
           else
              oxar1.rollback (xid1);
if (prp2 == XAResource.XA_OK)
           if (do_commit)
              oxar2.commit (xid2, false);
           else
              oxar2.rollback (xid2);
<span class="bold">/* close connections */</span>
conn1.close(); conn1 = null;
conn2.close(); conn2 = null;
pc1.close();   pc1 = null;
pc2.close();   pc2 = null;
} catch (XAException xae){
if (xae instanceof OracleXAException) {
System.out.println(&#34;XA Error is &#34; + ((OracleXAException)xae).getXAError());
System.out.println(&#34;SQL Error is &#34; +((OracleXAException)xae).getOracleError());
}
}
} //end class
</pre>
<p>The following examples explain the different SQLJ methods that can accept a JDBC connection obtained from an OracleXADatasource.</p>
<p class="subhead2"><a id="JSQLJ525"></a>Using Oracle.connect( ) method with a JDBC connection obtained from an XA Datasource:</p>
<pre>private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = &#34;XA_CERT&#34;;
Oracle.connect(conn);
#sql  {insert into xa_test values (1,:chr)};
try{
     Iterator3 iter = null;
     #sql iter = {SELECT id,name FROM xa_test};
     while (iter.next( )){
     System.out.print(iter.id());
     System.out.print(&#34; &#34;);
     System.out.println(iter.name());
     }
}
catch (Exception e){
     System.out.println(e);
     e.printStackTrace();
     }
}
</pre>
<p class="subhead2"><a id="JSQLJ526"></a>Using Oracle.getConnection( ) method with a JDBC connection obtained from an XA Datasource</p>
<pre>private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = &#34;XA_CERT&#34;;
DefaultContext  ctx = Oracle.getConnection(conn);
#sql [ctx]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [ctx] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(&#34; &#34;);
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre>
<p class="subhead2"><a id="JSQLJ527"></a>Using DefaultContext Constructor with a JDBC connection obtained from an XA Datasource</p>
<pre>private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = &#34;XA_CERT&#34;;
DefaultContext  ctx = new DefaultContext(conn)
#sql [ctx]  {insert into xa_test values (1,:chr)};
try{
Iterator3 iter = null;
#sql [ctx] iter = {SELECT id,name FROM xa_test};
while (iter.next( )){
System.out.print(iter.id());
System.out.print(&#34; &#34;);
System.out.println(iter.name());
}
}
catch (Exception e){
System.out.println(e);
e.printStackTrace();
}
}
</pre>
<p class="subhead2"><a id="JSQLJ528"></a>Using DefaultContext Constructor by passing a ConnectionContext to it. The ConnectionContext is created through the JDBC connection obtained from an XA Datasource</p>
<pre>private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = &#34;XA_CERT&#34;;
MyContext myctx1= new MyContext (conn);
DefaultContext  ctx = new DefaultContext(myctx1);
#sql [ctx]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [ctx] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(&#34; &#34;);
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre>
<p class="subhead2"><a id="JSQLJ529"></a>Using Oracle.connect( ) method by passing a ConnectionContext to it. The ConnectionContext is created through the JDBC connection obtained from an XA Datasource</p>
<pre>private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = &#34;XA_CERT&#34;;
MyContext myctx1= new MyContext (conn);
Oracle.connect(myctx1);
#sql {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(&#34; &#34;);
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
    }
}
</pre>
<p class="subhead2"><a id="JSQLJ530"></a>Using Oracle. getConnection( ) method by passing a ConnectionContext to it. The ConnectionContext is created through the JDBC connection obtained from an XA Datasource</p>
<pre>private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = &#34;XA_CERT&#34;;
MyContext myctx1= new MyContext (conn);
DefaultContext  ctx = Oracle.getConnection(myctx1);
#sql [ctx]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [ctx] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(&#34; &#34;);
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre>
<p class="subhead2"><a id="JSQLJ531"></a>The setDefaultContext( ) method of the DefaultContext class can also be used to set a context which was created through the JDBC connection obtained from an XA Datasource</p>
<pre>DefaultContext.setDefaultContext(ctx);
</pre>
<p class="subhead2"><a id="JSQLJ532"></a>Using the ConnectionContext constructor by passing a JDBC connection obtained from an XA Datasource</p>
<pre>private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = &#34;XA_CERT&#34;;
                        MyContext myctx1= new MyContext (conn);
#sql [myctx1]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [myctx1] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(&#34; &#34;);
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre>
<p class="subhead2"><a id="JSQLJ533"></a>Using the ConnectionContext constructor by passing a ConnectionContext to it. The ConnectionContext is created through the JDBC connection obtained from an XA Datasource</p>
<pre>private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = &#34;XA_CERT&#34;;
MyContext myctx= new MyContext (conn);
MyContext myctx1= new MyContext (myctx);
#sql [myctx1]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [myctx1] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(&#34; &#34;);
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre></div>
<!-- class="sect2" -->
<a id="CHDCGBAE"></a>
<div id="JSQLJ922" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref490"></a>Connecting to PDBs</h3>
<p>A pluggable database (PDB) enables an Oracle Database to contain a portable collection of schemas, schema objects, and nonschema objects that appears to an Oracle client as a separate database. A multitenant container database (CDB) is an Oracle Database that includes one or more PDBs. SQLJ applications can connect to a PDB using a service, whose <code>PLUGGABLE DATABASE</code> property is set to the relevant PDB.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN13973" href="../ADMIN/cdb_pdb_admin.htm#ADMIN13973"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information about configuring the services to connect to various pluggable databases</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006207"></a>
<div id="JSQLJ534" class="sect1">
<h2 class="sect1">Execution <a id="sthref491"></a>Contexts</h2>
<p>An execution context is an instance of the <code>sqlj.runtime.ExecutionContext</code> class and provides a context in which SQL operations are executed. An execution context instance is associated either implicitly or explicitly with each SQL operation in your SQLJ application.</p>
<p>The <code>ExecutionContext</code> class contains methods for the following features:</p>
<ul>
<li>
<p>Execution control operations modify the semantics of subsequent SQL operations.</p>
</li>
<li>
<p>Execution status operations describe the results of the most recent SQL operation.</p>
</li>
<li>
<p>Execution cancellation operations terminate the SQL operation that is currently executing.</p>
</li>
<li>
<p>Update-batching operations enable and disable update batching, set the batch limit, and get update counts.</p>
</li>
<li>
<p>Savepoint operations set a savepoint, roll back to a savepoint, and release a savepoint.</p>
</li>
<li>
<p>Closure operations close the execution context instance to avoid resource leakage.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is only one execution context class, unlike connection context classes where you declare additional classes as desired. Every execution context is an instance of the <code>ExecutionContext</code> class. So while the term connection context usually refers to a class that you have declared, the term execution context always refers to an instance of the <code>ExecutionContext</code> class. This document specifies connection context class, connection context instance, and execution context instance to avoid confusion.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDJDGDC">Relation of Execution Contexts to Connection Contexts</a></p>
</li>
<li>
<p><a href="#i1006247">Creating and Specifying Execution Context Instances</a></p>
</li>
<li>
<p><a href="#i1006271">Execution Context Synchronization</a></p>
</li>
<li>
<p><a href="#i1006297">Execution Context Methods</a></p>
</li>
<li>
<p><a href="#CHDFDFJG">Relation of Execution Contexts to Multithreading</a></p>
</li>
</ul>
<a id="CHDJDGDC"></a>
<div id="JSQLJ535" class="sect2">
<h3 class="sect2">Relation of <a id="sthref492"></a><a id="sthref493"></a>Execution Contexts to Connection Contexts</h3>
<p>Each connection context instance implicitly has its own default execution context instance, which you can retrieve by using the <code>getExecutionContext()</code> method of the connection context instance.</p>
<p>A single execution context instance will be sufficient for a connection context instance except in the following circumstances:</p>
<ul>
<li>
<p>You are using multiple threads with a single connection context instance.</p>
<p>When using multithreading, each thread must have its own execution context instance.</p>
</li>
<li>
<p>You want to use different SQL execution control operations on different SQLJ statements that use the same connection context instance.</p>
</li>
<li>
<p>You want to retain different sets of SQL status information from multiple SQL operations that use the same connection context instance.</p>
<p>As you execute successive SQL operations that use the same execution context instance, the status information from each operation overwrites the status information from the previous operation.</p>
</li>
</ul>
<p>Although execution context instances might appear to be associated with connection context instances (given that each connection context instance has a default execution context instance, and you can specify a connection context instance and an execution context instance together for a particular SQLJ statement), they actually operate independently. You can use different execution context instances in statements that use the same connection context instance, and vice versa.</p>
<p>For example, it is useful to use multiple execution context instances with a single connection context instance if you use multithreading, with a separate execution context instance for each thread. And you can use multiple connection context instances with a single explicit execution context instance if your program is single-threaded and you want the same set of SQL control parameters to apply to all the connection context instances.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006297">&#34;Execution Context Methods&#34;</a></div>
<p>To use different execution context instances with a single connection context instance, you must create additional instances of the <code>ExecutionContext</code> class and specify them appropriately with your SQLJ statements.</p>
</div>
<!-- class="sect2" -->
<a id="i1006247"></a>
<div id="JSQLJ536" class="sect2">
<h3 class="sect2">Creating and <a id="sthref494"></a>Specifying Execution Context Instances</h3>
<p>To use an execution context instance other than the default with a given connection context instance, you must construct another execution context instance. There are no input parameters for the <code>ExectionContext</code> constructor. For example:</p>
<pre>ExecutionContext myExecCtx = new ExecutionContext();
</pre>
<p>You can then specify this execution context instance for use with any particular SQLJ statement, much as you would specify a connection context instance. The general syntax is as follows:</p>
<pre>#sql [&lt;<span class="italic">conn_context</span>&gt;&lt;, &gt;&lt;<span class="italic">exec_context</span>&gt;] { <span class="italic">SQL operation</span> };
</pre>
<p>For example, if you also declare and instantiate a connection context class, <code>MyConnCtxClass</code>, and create an instance, <code>myConnCtx</code>, then you can use the following statement:</p>
<pre>#sql [myConnCtx, myExecCtx] { DELETE FROM employees WHERE salary &gt; 30000 };
</pre>
<p>You can subsequently use different execution context instances with <code>myConnCtx</code> or different connection context instances with <code>myExecCtx</code>.</p>
<p>You can optionally specify an execution context instance while using the default connection context instance, as follows:</p>
<pre>#sql [myExecCtx] { DELETE FROM employees WHERE salary &gt; 30000 };
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>If you specify a connection context instance without an execution context instance, then the default execution context instance of that connection context instance is used.</p>
</li>
<li>
<p>If you specify an execution context instance without a connection context instance, then the execution context instance is used with the default connection context instance of your application.</p>
</li>
<li>
<p>If you specify no connection context instance and no execution context instance, then SQLJ uses the default connection and its default execution context instance.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006271"></a>
<div id="JSQLJ537" class="sect2">
<h3 class="sect2">Execution <a id="sthref495"></a><a id="sthref496"></a>Context Synchronization</h3>
<p><code>ExecutionContext</code> methods are all <code>synchronized</code> methods. Therefore, for ISO standard code generation, anytime a statement tries to use an execution context instance already in use, the second statement will be blocked until the first statement completes.</p>
<p>In a client application, this typically involves multithreading situations. A thread that tries to use an execution context instance currently in use by another thread will be blocked. To avoid such blockage, you must specify a separate execution context instance for each thread that you use.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006495">&#34;Multithreading in SQLJ&#34;</a></div>
<p>The preceding discussion does not apply for default Oracle-specific code generation. For performance reasons, SQLJ performs no additional synchronization against <code>ExecutionContext</code> instances for Oracle-specific generated code. Therefore, you are responsible for ensuring that the same execution context instance will not be used by more than one thread. If multiple threads use the same execution context, then your application, rather than blocking, will experience errors such as incorrect results or <code>NullPointer</code> exceptions.</p>
<p>Another exception to the discussion is for recursion, which is encountered only in the server. Multiple SQLJ statements in the same thread are allowed to simultaneously use the same execution context instance if this situation results from recursive calls. An example of this is where a SQLJ stored procedure or function has a call to another SQLJ stored procedure or function. If both use the default execution context instance, as is typical, then the SQLJ statements in the second procedure will use this execution context while the SQLJ call statement from the first procedure is also still using it. This is allowed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="inserver.htm#CCHJFGCB">&#34;Recursive SQLJ Calls in the Server&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006297"></a>
<div id="JSQLJ538" class="sect2">
<h3 class="sect2">Execution Context Methods</h3>
<p>The following sections list public methods of the <code>ExecutionContext</code> class and provide an example:</p>
<ul>
<li>
<p><a href="#i1006300">Status Methods</a></p>
</li>
<li>
<p><a href="#i1009000">Control Methods</a></p>
</li>
<li>
<p><a href="#i1009005">Cancellation Method</a></p>
</li>
<li>
<p><a href="#i1009010">Update Batching Methods</a></p>
</li>
<li>
<p><a href="#i1006403">Savepoint Methods</a></p>
</li>
<li>
<p><a href="#i1009019">Close Method</a></p>
</li>
<li>
<p><a href="#i1009024">Example: Using ExecutionContext Methods</a></p>
</li>
</ul>
<a id="i1006300"></a>
<div id="JSQLJ539" class="sect3">
<h4 class="sect3">Status <a id="sthref497"></a>Methods</h4>
<p>Use the following methods of an execution context instance to obtain status information about the most recent SQL operation that completed using that instance:</p>
<ul>
<li>
<p><code>SQLWarning getWarnings()</code>: Returns a <code>java.sql.SQLWarning</code> object containing the first warning reported by the most recent SQL operation that completed using this execution context instance. Warnings are returned in a chain. Use the <code>getWarnings()</code> method of the execution context instance to get the first warning, then use the <code>getNextWarning()</code> method of each <code>SQLWarning</code> object to get the next warning. The chain contains all warnings generated during the execution of the SQL operation.</p>
</li>
<li>
<p><code>int getUpdateCount()</code>: Except when update batching is enabled, this returns an <code>int</code> value specifying the number of rows updated by the last SQL operation that completed using this execution context instance. Zero (<code>0</code>) is returned if the last SQL operation was not a data manipulation language (DML) statement. The <code>QUERY_COUNT</code> constant is returned, if the last SQL operation produced an iterator or result set. The <code>EXCEPTION_COUNT</code> constant is returned, if the last SQL operation terminated before completing execution or if no operation has yet been attempted using this execution context instance.</p>
<p>For batch-enabled applications, the value returned by <code>getUpdateCount()</code> would be one of several batch-related constant values: <code>NEW_BATCH_COUNT</code>, <code>ADD_BATCH_COUNT</code>, or <code>EXEC_BATCH_COUNT</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1006039">&#34;Execution Context Update Counts&#34;</a></div>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1009000"></a>
<div id="JSQLJ540" class="sect3">
<h4 class="sect3">Control <a id="sthref498"></a>Methods</h4>
<p>Use the following methods of an execution context instance to control the operation of future SQL operations executed using that instance (operations that have not yet started):</p>
<ul>
<li>
<p><code>int getMaxFieldSize()</code>: Returns an <code>int</code> value specifying the maximum amount of data (in bytes) that would be returned from a SQL operation subsequently, using this execution context instance. This applies only to columns of the <code>BINARY</code>, <code>VARBINARY</code>, <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>, or <code>LONGVARCHAR</code> type.</p>
<p>By default this parameter is set to <code>0</code>, meaning there is no size limit.</p>
</li>
<li>
<p><code>setMaxFieldSize(int)</code>: Takes an <code>int</code> value as input to modify the maximum field-size.</p>
</li>
<li>
<p><code>int getMaxRows()</code>: Returns an <code>int</code> value specifying the maximum number of rows that can be contained by any SQLJ iterator or JDBC result set created using this execution context instance. If the limit is exceeded, then the excess rows are silently dropped without any error report or warning.</p>
<p>By default, this parameter is set to <code>0</code>, meaning there is no row limit.</p>
</li>
<li>
<p><code>setMaxRows(int)</code>: Takes an <code>int</code> value as input to modify the maximum row value.</p>
</li>
<li>
<p><code>int getQueryTimeout()</code>: Returns an <code>int</code> value specifying the timeout interval, in seconds, for any SQL operation that uses this execution context instance. If a SQL operation exceeds this limit, then a SQL exception is thrown.</p>
<p>By default, this parameter is set to <code>0</code>, meaning there is no query timeout limit.</p>
</li>
<li>
<p><code>setQueryTimeout(int)</code>: Takes an <code>int</code> value as input to modify the query timeout limit.</p>
</li>
<li>
<p><code>int getFetchSize()</code>: Retrieves the number of rows that is the current fetch size for iterator objects generated from this <code>ExecutionContext</code> object. If this <code>ExecutionContext</code> object has not set a fetch size by calling <code>setFetchSize()</code>, then the value returned is <code>0</code>. If this <code>ExecutionContext</code> object has set a non-negative fetch size by calling the method <code>setFetchSize()</code>, then the return value is the fetch size specified on <code>setFetchSize()</code>.</p>
</li>
<li>
<p><code>setFetchSize(int)</code>: Gives the SQLJ run time a hint as to the number of rows that should be fetched when more rows are needed. The number of rows specified affects only iterator objects created using this <code>ExecutionContext</code> object. Specifying zero means that an implementation-dependent default value will be used for the fetch size.</p>
</li>
<li>
<p><code>int getFetchDirection()</code>: Retrieves the default direction for fetching data, for scrollable iterator objects that are generated from this <code>ExecutionContext</code> object. If this <code>ExecutionContext</code> object has not set a fetch direction by calling the method <code>setFetchDirection()</code>, then the return value is <code>FETCH_FORWARD</code>.</p>
</li>
<li>
<p><code>setFetchDirection(int)</code>: Gives the SQLJ run time a hint as to the direction in which rows of scrollable iterator objects are processed. The hint applies only to scrollable iterator objects that are created using this <code>ExecutionContext</code> object. The default value is:</p>
<pre>sqlj.runtime.ResultSetIterator.FETCH_FORWARD.
</pre>
<p>This method throws a <code>SQLException</code> if the given direction is not one of <code>FETCH_FORWARD</code>, <code>FETCH_REVERSE</code>, or <code>FETCH_UNKNOWN</code> (<code>int</code> constants).</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1009005"></a>
<div id="JSQLJ541" class="sect3">
<h4 class="sect3">Cancellation <a id="sthref499"></a>Method</h4>
<p>Use the following method to cancel SQL operations in a multithreading environment or to cancel a pending statement batch if update batching is enabled:</p>
<ul>
<li>
<p><code>cancel()</code>: In a multithreading environment, use this method in one thread to cancel a SQL operation currently executing in another thread. It cancels the most recent operation that has started but not completed, using this execution context instance. This method has no effect if no statement is currently being executed using this execution context instance.</p>
<p>In a batch-enabled environment, use this to cancel a pending statement batch. The batch is emptied, and none of the statements in the batch are executed. After you cancel a batch, the next batchable statement encountered will be added to a new batch.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1006005">&#34;Canceling a Batch&#34;</a></div>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1009010"></a>
<div id="JSQLJ542" class="sect3">
<h4 class="sect3">Update Ba<a id="sthref500"></a>tching Methods</h4>
<p>Use the following methods to control update batching if you want your application to use that performance enhancement feature:</p>
<ul>
<li>
<p><code>int[] executeBatch()</code>: Executes the pending statement batch, returning an array of <code>int</code> update counts.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1006039">&#34;Execution Context Update Counts&#34;</a>, <a href="apppfdbg.htm#i1005910">&#34;Explicit and Implicit Batch Execution&#34;</a>, and <a href="apppfdbg.htm#i1006173">&#34;Error Conditions During Batch Execution&#34;</a></div>
</li>
<li>
<p><code>int getBatchLimit()</code>: Returns an <code>int</code> value indicating the current batch limit. If there is a batch limit, then a pending batch is implicitly executed once it contains that number of statements.</p>
<p>By default, the batch limit is set to the <code>ExecutionContext</code> static constant value <code>UNLIMITED_BATCH</code>, meaning there is no batch limit.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1006064">&#34;Setting a Batch Limit&#34;</a></div>
</li>
<li>
<p><code>int[] getBatchUpdateCounts()</code>: Returns an array of <code>int</code> update counts for the last batch executed. This method is useful in situations where the batch was executed implicitly.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1006039">&#34;Execution Context Update Counts&#34;</a></div>
</li>
<li>
<p><code>boolean isBatching()</code>: Returns a boolean value indicating whether update batching is enabled.</p>
<p>This does not indicate whether there is currently a pending batch, but you can use the <code>getUpdateCount()</code> method to see whether a batch has been newly created, added to, or executed.</p>
</li>
<li>
<p><code>setBatching(boolean)</code>: Takes a boolean value to enable update batching.</p>
<p>Update batching is disabled by default.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1005700">&#34;Enabling and Disabling Statement Caching (Oracle-Specific Code)&#34;</a></div>
</li>
<li>
<p><code>setBatchLimit(int)</code>: Takes a positive, nonzero <code>int</code> value as input to set the current batch limit. Two special values you can assign are <code>UNLIMITED_BATCH</code>, which means there is no limit, and <code>AUTO_BATCH</code>, which lets the SQLJ run time to dynamically determine a batch limit.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1005806">&#34;Update Batching&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="i1006403"></a>
<div id="JSQLJ543" class="sect3">
<h4 class="sect3">Savep<a id="sthref501"></a><a id="sthref502"></a>oint Methods</h4>
<p>The Oracle SQLJ implementation supports JDBC 3.0 savepoints. Savepoints are stored in the <code>ExecutionContext</code> instance, and the following public methods exist to support the SQLJ savepoint statements:</p>
<ul>
<li>
<p><code>Object oracleSetSavepoint(ConnectionContextImpl, String)</code></p>
<p>Register a savepoint and return the savepoint as an <code>Object</code> instance. This method takes the connection context as an instance of the <code>sqlj.runtime.ref.ConnectionContextImpl</code> class and a string that specifies the savepoint name.</p>
<p>The Oracle SQLJ implementation instantiates a savepoint as an instance of the <code>oracle.jdbc.OracleSavepoint</code> class, which extends the <code>java.sql.Savepoint</code> interface.</p>
</li>
<li>
<p><code>void oracleRollbackToSavepoint (ConnectionContextImpl, Object)</code></p>
<p>Roll back changes to the specified savepoint. This method takes the connection context as an instance of <code>ConnectionContextImpl</code> and the savepoint as an <code>Object</code> instance.</p>
</li>
<li>
<p><code>void oracleReleaseSavepoint(ConnectionContextImpl, Object)</code></p>
<p>Release the specified savepoint. This method takes the connection context as an instance of <code>ConnectionContextImpl</code> and the savepoint as an <code>Object</code> instance.</p>
</li>
</ul>
<p>You will generally use SQLJ savepoint statements instead of using these methods directly.</p>
</div>
<!-- class="sect3" -->
<a id="i1009019"></a>
<div id="JSQLJ544" class="sect3">
<h4 class="sect3">Clo<a id="sthref503"></a><a id="sthref504"></a>se Method</h4>
<p>The Oracle SQLJ implementation provides extended functionality with a <code>close()</code> method for the <code>ExecutionContext</code> class:</p>
<ul>
<li>
<p><code>close()</code>: To avoid resource leakage, use this method if the following circumstances are all true:</p>
<ul>
<li>
<p>You are using the Oracle-specific code generation.</p>
</li>
<li>
<p>You explicitly created and used the <code>ExecutionContext</code> instance, instead of using the default instance available through the connection context instance.</p>
</li>
<li>
<p>You are <span class="italic">not</span> issuing SQLJ rollback or commit statements explicitly using the <code>ExecutionContext</code> instance:</p>
<pre>#sql [ec] { COMMIT };
#sql [ec] { ROLLBACK };
</pre></li>
<li>
<p>You are <span class="italic">not</span> calling <code>executeBatch()</code> on the <code>ExecutionContext</code> instance.</p>
</li>
</ul>
<p>Under this set of circumstances, a batchable statement might remain open on the <code>ExecutionContext</code> instance and over time you may run out of database cursors. To avoid this, use the <code>close()</code> method as in the following example:</p>
<pre>Execution Context ec = new ExecutionContext();
...
try {
   ...
   #sql [ec] { <span class="italic">SQL operation</span> };
   ...
} finally { ec.close(); }
</pre></li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
When an execution context instance is associated with a connection context instance, instead of being declared explicitly, then closing the connection context instance, with or without closing the underlying JDBC connection, will automatically close any statement remaining on the execution context instance.</div>
</div>
<!-- class="sect3" -->
<a id="i1009024"></a>
<div id="JSQLJ545" class="sect3">
<h4 class="sect3">Example: Using <a id="sthref505"></a>ExecutionContext Methods</h4>
<p>The following code demonstrates the use of some <code>ExecutionContext</code> methods:</p>
<pre>ExecutionContext execCtx =
   DefaultContext.getDefaultContext().getExecutionContext();

// Wait only 3 seconds for operations to complete
execCtx.setQueryTimeout(3);

// delete using execution context of default connection context
#sql { DELETE FROM employees WHERE salary &gt; 10000 };

System.out.println
     (&#34;removed &#34; + execCtx.getUpdateCount() + &#34; employees&#34;);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDFDFJG"></a>
<div id="JSQLJ546" class="sect2">
<h3 class="sect2">Relation of <a id="sthref506"></a><a id="sthref507"></a>Execution Contexts to Multithreading</h3>
<p>Do not use multiple threads with a single execution context. If you do, and two SQLJ statements try to use the same execution context simultaneously, then the second statement will be blocked until the first statement completes. Furthermore, status information from the first operation will likely be overwritten before it can be retrieved.</p>
<p>Therefore, if you are using multiple threads with a single connection context instance, then you should take the following steps:</p>
<ol>
<li>
<p>Instantiate a unique execution context instance for use with each thread.</p>
</li>
<li>
<p>Specify execution contexts with your <code>#sql</code> statements so that each thread uses its own execution context.</p>
</li>
</ol>
<p>If you are using a different connection context instance with each thread, then no instantiation and specification of execution context instances is necessary, because each connection context instance implicitly has its own default execution context instance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For performance reasons, SQLJ performs no additional synchronization against <code>ExecutionContext</code> instances for Oracle-specific generated code. Therefore, you are responsible for ensuring that the same execution context instance will not be used by more than one thread. If multiple threads use the same execution context, then your application, rather than blocking, will experience errors such as incorrect results or <code>NullPointer</code> exceptions.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006495"></a>
<div id="JSQLJ547" class="sect1">
<h2 class="sect1">Multithr<a id="sthref508"></a>eading in SQLJ</h2>
<p>This section discusses SQLJ support and requirements for multithreading and the relation between multithreading and execution context instances.</p>
<p>You can use SQLJ in writing multithreaded applications. However, any use of multithreading in your SQLJ application is subject to the limitations of your JDBC driver or proprietary database access vehicle. This includes any synchronization limitations.</p>
<p>You are required to use a different execution context instance for each thread. You can accomplish this in one of two ways:</p>
<ul>
<li>
<p>Specify connection context instances for your SQLJ statements such that a different connection context instance is used for each thread. Each connection context instance automatically has its own default execution context instance.</p>
</li>
<li>
<p>If you are using the same connection context instance with multiple threads, then declare additional execution context instances and specify execution context instances for your SQLJ statements such that a different execution context instance is used for each thread.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="blangfea.htm#i1006054">&#34;Specifying Connection Context Instances and Execution Context Instances&#34;</a></div>
<p>If you are using one of Oracle JDBC drivers, then multiple threads can use the same connection context instance, if desired, as long as different execution context instances are specified and there are no synchronization requirements directly visible to you. However, note that data access is sequential. Only one thread is accessing data at any given time. Synchronization refers to the control flow of the various stages of the SQL operations executing through your threads. For example, each statement can bind input parameters, then execute, and then bind output parameters. With some JDBC drivers, special care must be taken not to intermingle these stages.</p>
<p>For ISO standard code generation, if a thread attempts to execute a SQL operation that uses an execution context that is in use by another operation, then the thread is blocked until the current operation completes. If an execution context were shared between threads, then the results of a SQL operation performed by one thread would be visible in the other thread. If both threads were executing SQL operations, then a race condition might occur. The results of an execution in one thread might be overwritten by the results of an execution in the other thread before the first thread had processed the original results. This is why multiple threads are not allowed to share an execution context instance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The preceding paragraph does not apply if you use default Oracle-specific code generation. For performance reasons, SQLJ performs no additional synchronization against <code>ExecutionContext</code> instances for Oracle-specific generated code. Therefore, you are responsible for ensuring that the same execution context instance will not be used by more than one thread. If multiple threads use the same execution context, then your application, rather than blocking, will experience errors such as incorrect results or <code>NullPointer</code> exceptions.</div>
<p class="subhead2"><a id="JSQLJ548"></a>Multithreading: <a id="sthref509"></a><a id="sthref510"></a>MultiThreadDemo.sqlj</p>
<p>The following is an example of a SQLJ application using multithreading. A <code>ROLLBACK</code> operation is executed before closing the connection, so the data is not permanently altered.</p>
<pre>import java.sql.SQLException;
import java.util.Random;
import sqlj.runtime.ExecutionContext;
import oracle.sqlj.runtime.Oracle;
/**
  Each instance of MultiThreadDemo is a thread that gives all employees
  a raise of some ammount when run.  The main program creates two such 
  instances and computes the net raise after both threads have completed.
  **/
class MultiThreadDemo extends Thread
{
  double raise;
  static Random randomizer = new Random(); 
 
  public static void main (String args[]) 
  {
    try { 
      // set the default connection to the URL, user, and password
      // specified in your connect.properties file
      Oracle.connect(MultiThreadDemo.class, &#34;connect.properties&#34;);
      double avgStart = calcAvgSal();
      MultiThreadDemo t1 = new MultiThreadDemo(250.50);
      MultiThreadDemo t2 = new MultiThreadDemo(150.50);
      t1.start();
      t2.start();
      t1.join();
      t2.join();
      double avgEnd = calcAvgSal();
      System.out.println(&#34;average salary change: &#34; + (avgEnd - avgStart));
    } catch (Exception e) { 
      System.err.println(&#34;Error running the example: &#34; + e);
    }
    try { #sql { ROLLBACK }; Oracle.close(); } catch (SQLException e) { }
  } 
  static double calcAvgSal() throws SQLException
  {
    double avg;
    #sql { SELECT AVG(salary) INTO :avg FROM employees };
    return avg;
  }
  MultiThreadDemo(double raise)
  {
    this.raise = raise;
  }
  public void run()
  {
    // Since all threads will be using the same default connection
    // context, each run uses an explicit execution context instance to
    // avoid conflict during execution
    try {
      delay();
      ExecutionContext execCtx = new ExecutionContext();
      #sql [execCtx] { UPDATE EMPLOYEES SET salary = salary + :raise };
      int updateCount = execCtx.getUpdateCount();
      System.out.println(&#34;Gave raise of &#34; + raise + &#34; to &#34; + 
                          updateCount + &#34; employees&#34;);
    } catch (SQLException e) {
      System.err.println(&#34;error updating employees: &#34; + e);
    }
  }
  // delay is used to introduce some randomness into the execution order
  private void delay()
  {
    try {
      sleep((long)Math.abs(randomizer.nextInt()/10000000));
    } catch (InterruptedException e) {}
  }
}
</pre></div>
<!-- class="sect1" -->
<a id="i1006593"></a>
<div id="JSQLJ549" class="sect1">
<h2 class="sect1">Iterator Class Implementation and Advanced Functionality</h2>
<p>This section discusses how iterator classes are implemented and what additional functionality is available beyond the essential methods. The following topics are covered:</p>
<ul>
<li>
<p><a href="#i1006628">Implementation and Functionality of Iterator Classes</a></p>
</li>
<li>
<p><a href="#i1006680">Using the IMPLEMENTS Clause in Iterator Declarations</a></p>
</li>
<li>
<p><a href="#i1006706">Support for Extending Iterator Classes</a></p>
</li>
<li>
<p><a href="#i1006712">Result Set Iterators</a></p>
</li>
<li>
<p><a href="#i1006751">Scrollable Iterators</a></p>
</li>
</ul>
<a id="i1006628"></a>
<div id="JSQLJ550" class="sect2">
<h3 class="sect2">Implementation and <a id="sthref511"></a>Functionality of Iterator Classes</h3>
<p>Any named iterator class you declare will be generated by the SQLJ translator to implement the <code>sqlj.runtime.NamedIterator</code> interface. Classes implementing the <code>NamedIterator</code> interface have functionality that maps iterator columns to database columns by name, not by position.</p>
<p>Any positional iterator class you declare will be generated by the SQLJ translator to implement the <code>sqlj.runtime.PositionedIterator</code> interface. Classes implementing the <code>PositionedIterator</code> interface have functionality that maps iterator columns to database columns by position, not by name.</p>
<p>Both the <code>NamedIterator</code> interface and the <code>PositionedIterator</code> interface, and therefore all generated SQLJ iterator classes as well, implement or extend the <code>sqlj.runtime.ResultSetIterator</code> interface.</p>
<p>The <code>ResultSetIterator</code> interface specifies the following methods for all SQLJ iterators:</p>
<ul>
<li>
<p><code>close()</code>: Closes the iterator.</p>
</li>
<li>
<p><code>ResultSet getResultSet()</code>: Extracts the underlying JDBC result set from the iterator.</p>
</li>
<li>
<p><code>boolean isClosed()</code>: Determines if the iterator has been closed.</p>
</li>
<li>
<p><code>boolean next()</code>: Moves to the next row of the iterator, returning <code>true</code> if there is a valid next row to go to.</p>
</li>
</ul>
<p>The <code>PositionedIterator</code> interface adds the following method specification for positional iterators:</p>
<ul>
<li>
<p><code>boolean endFetch()</code>: Determines if you have reached the last row of a positional iterator.</p>
</li>
</ul>
<p>Use the <code>next()</code> method to advance through the rows of a named iterator and accessor methods to retrieve the data. The SQLJ generation of a named iterator class defines an accessor method for each iterator column, where each method name is identical to the corresponding column name. For example, if you declare a <code>name</code> column, then a <code>name()</code> method will be generated.</p>
<p>Use a <code>FETCH INTO</code> statement together with the <code>endFetch()</code> method to advance through the rows of a positional iterator and retrieve the data. A <code>FETCH INTO</code> statement implicitly calls the <code>next()</code> method. Do not explicitly use the <code>next()</code> method in a positional iterator unless you are using the special <code>FETCH CURRENT</code> syntax. The <code>FETCH INTO</code> statement also implicitly calls accessor methods that are named according to iterator column numbers. The SQLJ generation of a positional iterator class defines an accessor method for each iterator column, where each method name corresponds to the column position.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006889">&#34;FETCH CURRENT Syntax: from JDBC Result Sets to SQLJ Iterators&#34;</a></div>
<p>Use the <code>close()</code> method to close any iterator once you are done with it. The <code>getResultSet()</code> method is central to SQLJ-JDBC interoperability.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007230">&#34;SQLJ Iterator and JDBC Result Set Interoperability&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Alternatively, you can use a <code>ResultSetIterator</code> instance or a <code>ScrollableResultSetIterator</code> instance directly as a weakly typed iterator. (<code>ScrollableResultSetIterator</code> extends <code>ResultSetIterator</code>.) This is convenient if you are interested only in converting it to a JDBC result set and you do not need named or positional iterator functionality. You can also access it through SQLJ <code>FETCH CURRENT</code> syntax.</div>
</div>
<!-- class="sect2" -->
<a id="i1006680"></a>
<div id="JSQLJ551" class="sect2">
<h3 class="sect2">Using the <a id="sthref512"></a><a id="sthref513"></a>IMPLEMENTS Clause in Iterator Declarations</h3>
<p>There may be situations where it will be useful to implement an interface in your iterator declaration. For example, you may have an iterator class where you want to restrict access to one or more columns. A named iterator class generated by SQLJ has an accessor method for each column in the iterator. If you want to restrict access to certain columns, you can create an interface with only a subset of the accessor methods, then expose instances of the interface type to the user instead of exposing instances of the iterator class type.</p>
<p>For example, assume you are creating a named iterator of employee data, with columns <code>ENAME</code> (employee name), <code>EMPNO</code> (employee number), and <code>SAL</code> (salary). Accomplish this as follows:</p>
<pre>#sql iterator EmpIter (String ename, int empno, float sal);
</pre>
<p>This generates a class <code>EmpIter</code> with <code>ename()</code>, <code>empno()</code>, and <code>sal()</code> accessor methods.</p>
<p>Assume, though, that you want to prevent access to the <code>SAL</code> column. You can create an <code>EmpIterIntfc</code> interface that has <code>ename()</code> and <code>empno()</code> methods, but no <code>sal()</code> method. Then you can use the following iterator declaration instead of the preceding declaration (presuming <code>EmpIterIntfc</code> is in the <code>mypackage</code> package):</p>
<pre>#sql iterator EmpIter implements mypackage.EmpIterIntfc 
     (String emame, int empno, float sal);
</pre>
<p>Then if you code your application so that users can access data only through <code>EmpIterIntfc</code> instances, then they will not have access to the <code>SAL</code> column.</p>
</div>
<!-- class="sect2" -->
<a id="i1006706"></a>
<div id="JSQLJ552" class="sect2">
<h3 class="sect2">Support for Exte<a id="sthref514"></a><a id="sthref515"></a><a id="sthref516"></a><a id="sthref517"></a>nding Iterator Classes</h3>
<p>SQLJ supports the ability to extend iterator classes. This feature can be very useful in allowing you to add functionality to your queries and query results.</p>
<p>The one key requirement of an iterator subclass is that you must supply a public constructor that takes an instance of <code>sqlj.runtime.RTResultSet</code> as input. The SQLJ run time will call this constructor in assigning query results to an instance of your subclass. Beyond that, you provide functionality as you choose.</p>
<p>You can continue to use functionality of the original iterator class (the superclass of your subclass). For example, you can advance through query results by calling the <code>super.next()</code> method.</p>
</div>
<!-- class="sect2" -->
<a id="i1006712"></a>
<div id="JSQLJ553" class="sect2">
<h3 class="sect2">Result S<a id="sthref518"></a><a id="sthref519"></a><a id="sthref520"></a><a id="sthref521"></a>et Iterators</h3>
<p>You may have situations where you do not require the strongly typed functionality of a SQLJ iterator.</p>
<p>For such circumstances, you can directly use instances of the <code>sqlj.runtime.ResultSetIterator</code> type to receive query data, so that you are not required to declare a named or positional iterator class. Alternatively, you can use the <code>sqlj.runtime.ScrollableResultSetIterator</code> type, which extends <code>ResultSetIterator</code>. This enables you to use SQLJ scrollable iterator functionality. In using a result set iterator instead of a strongly typed iterator, you are trading the strong type-checking of the SQLJ <code>SELECT</code> operation for the convenience of not having to declare an iterator class.</p>
<p>The <code>ResultSetIterator</code> interface underlies all named and positional iterator classes and specifies the <code>getResultSet()</code> and <code>close()</code> methods. If you want to use SQLJ to process a result set iterator instance, then use a <code>ScrollableResultSetIterator</code> instance and the <code>FETCH CURRENT</code> syntax.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006889">&#34;FETCH CURRENT Syntax: from JDBC Result Sets to SQLJ Iterators&#34;</a></div>
<p>If you want to use JDBC to process a result set iterator instance, you can use its <code>getResultSet()</code> method and then process the underlying result set that you retrieve. If you process a result set iterator through its underlying result set, you should close the result set iterator, not the result set, when you are finished. Closing the result set iterator will also close the result set, but closing the result set will not close the result set iterator.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007295">&#34;Using and Converting Weakly Typed Iterators (ResultSetIterator)&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle SQLJ implementation supports result set iterators for use as host expressions and to represent cursors in <code>FETCH</code> statements. This functionality was not supported prior to Oracle9<span class="italic">i</span> Database.</div>
</div>
<!-- class="sect2" -->
<a id="i1006751"></a>
<div id="JSQLJ554" class="sect2">
<h3 class="sect2">Scroll<a id="sthref522"></a>able Iterators</h3>
<p>The ISO standard for SQLJ supports scrollable iterators, with functionality being patterned after the JDBC 2.0 specification for scrollable JDBC result sets. The Oracle SQLJ implementation supports this functionality.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<p class="subhead2"><a id="i1006761"></a><a id="JSQLJ555"></a>Decla<a id="sthref523"></a>ring Scrollable Iterators</p>
<p>To characterize an iterator as scrollable, add the following clause to the iterator declaration:</p>
<pre>implements sqlj.runtime.Scrollable
</pre>
<p>This instructs the SQLJ translator to generate an iterator that implements the <code>Scrollable</code> interface. Following is an example of a declaration of a named, scrollable iterator:</p>
<pre>#sql public static MyScrIter implements sqlj.runtime.Scrollable
                             (String ename, int empno);
</pre>
<p>The code that the SQLJ translator generates for the <code>MyScrIter</code> class will automatically support all the methods of the <code>Scrollable</code> interface.</p>
<p class="subhead2"><a id="i1006775"></a><a id="JSQLJ556"></a>Scrolla<a id="sthref524"></a>ble Iterator Sensitivity</p>
<p>You can declare scrollable iterators, like scrollable result sets, to have sensitivity to changes to the underlying data. By default, scrollable iterators in the Oracle SQLJ implementation have a <code>sensitivity</code> setting of <code>INSENSITIVE</code>, meaning they do not detect any such changes in the underlying data. However, you can use a <code>with</code> clause to alter this setting. The following example expands an earlier example to specify sensitivity:</p>
<pre>#sql public static MyScrIter implements sqlj.runtime.Scrollable
                             with (sensitivity=SENSITIVE) 
                             (String ename, int empno);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>implements</code> clause must precede the <code>with</code> clause.</div>
<p>The SQLJ standard also allows a setting of <code>ASENSITIVE</code>, which means accepting the default <code>sensitivity</code> of the Database. But, in Oracle, if you set <code>sensitivity</code> to <code>ASENSITIVE</code>, then it results in the default setting <code>INSENSITIVE</code> being used.</p>
<p>Given the preceding declaration, <code>MyScrIter</code> instances will be sensitive to data changes, subject to factors such as the fetch size window.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for information about scrollable result sets</div>
<p class="subhead2"><a id="i1006795"></a><a id="JSQLJ557"></a>The Scr<a id="sthref525"></a>ollable Interface</p>
<p>This section documents some key methods of the <code>sqlj.runtime.Scrollable</code> interface.</p>
<p>You can provide hints about the fetch direction to scrollable iterators. The following methods are defined on scrollable iterators as well as on execution contexts. Use an <code>ExecutionContext</code> instance to provide the default direction to be used in creation of scrollable iterators.</p>
<ul>
<li>
<p><code>setFetchDirection(int)</code>: Gives the SQLJ run time a hint as to the direction in which rows are processed. The direction should be one of <code>sqlj.runtime.ResultSetIterator.FETCH_FORWARD</code>, <code>FETCH_REVERSE</code>, or <code>FETCH_UNKNOWN</code>.</p>
<p>If you do not specify a value for the direction on the <code>ExecutionContext</code>, then <code>FETCH_FORWARD</code> will be used as a default.</p>
</li>
<li>
<p><code>int getFetchDirection()</code>: Retrieves the current direction for fetching rows of data (one of the integer constants described in the previous point).</p>
</li>
</ul>
<p>There are also a number of scrollable iterator methods that will return information about the current position of the iterator object in the underlying result set. All these methods will return <code>false</code> whenever the result set underlying the iterator contains no rows:</p>
<ul>
<li>
<p><code>boolean isBeforeFirst()</code>: Indicates whether the iterator object is before the first row in the result set.</p>
</li>
<li>
<p><code>boolean isFirst()</code>: Indicates whether the iterator object is on the first row of the result set.</p>
</li>
<li>
<p><code>boolean isLast()</code>: Indicates whether the iterator object is on the last row of the result set. Note that calling the <code>isLast()</code> method may be expensive, because the JDBC driver may have to fetch ahead one row to determine whether the current row is the last row in the result set.</p>
</li>
<li>
<p><code>boolean isAfterLast()</code>: Indicates whether the iterator object is after the last row in the result set.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Additional methods for navigation, also defined in the <code>Scrollable</code> interface, are available as well.</div>
<p class="subhead2"><a id="i1006816"></a><a id="JSQLJ558"></a>Scroll<a id="sthref526"></a><a id="sthref527"></a>able Named Iterators</p>
<p>Named iterators use navigation methods, defined in the <code>Scrollable</code> interface, to move through the rows of a result set. As described earlier in this manual, nonscrollable iterators have only the following method for navigation:</p>
<ul>
<li>
<p><code>boolean next()</code>: Moves the iterator object to the next row in the result set.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="blangfea.htm#i1006968">&#34;Using Named Iterators&#34;</a></div>
<p>Additional navigation methods are available for scrollable named iterators. These methods function similarly to the <code>next()</code> method. In that they try to position the iterator on an actual row of the result set. They return <code>true</code> if the iterator ends up on a valid row and <code>false</code> if it does not. Additionally, if you attempt to position the iterator object before the first row or after the last row in the result set, this leaves the iterator object in the &#34;before first&#34; or &#34;after last&#34; position, respectively.</p>
<p>The following methods are supported:</p>
<ul>
<li>
<p><code>boolean previous()</code>: Moves the iterator object to the previous row in the result set.</p>
</li>
<li>
<p><code>boolean first()</code>: Moves the iterator object to the first row in the result set.</p>
</li>
<li>
<p><code>boolean last()</code>: Moves the iterator object to the last row in the result set.</p>
</li>
<li>
<p><code>boolean absolute(int)</code>: Moves the iterator object to the given row number in the result set. The first row is row 1, the second is row 2, and so on. If the given row number is negative, then the iterator object moves to a row position relative to the end of the result set. For example, calling <code>absolute(-1)</code> positions the iterator object on the last row, <code>absolute(-2)</code> indicates the next-to-last row, and so on.</p>
</li>
<li>
<p><code>boolean relative(int)</code>: Moves the iterator object a relative number of rows, either positive or negative from the current position. Calling <code>relative(0)</code> is valid, but does not change the iterator position.</p>
</li>
<li>
<p><code>void beforeFirst()</code>: Moves the iterator object to the front of the result set, before the first row. This has no effect if the result set contains no rows.</p>
</li>
<li>
<p><code>void afterLast()</code>: Moves the iterator object to the end of the result set, after the last row. This has no effect if the result set contains no rows.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>beforeFirst()</code> and <code>afterLast()</code> methods return <code>void</code>, because they never place the iterator object on an actual row of the result set.</div>
<p class="subhead2"><a id="JSQLJ559"></a>Scroll<a id="sthref528"></a><a id="sthref529"></a>able Positional Iterators</p>
<p>General <code>FE<a id="sthref530"></a>TCH</code> syntax for positional iterators was described earlier, in <a href="blangfea.htm#i1007114">&#34;Using Positional Iterators&#34;</a>. For example:</p>
<pre>#sql { FETCH :iter INTO :x, :y, :z };
</pre>
<p>This is actually an abbreviated version of the following syntax:</p>
<pre>#sql { FETCH NEXT FROM :iter INTO :x, :y, :z  };
</pre>
<p>This suggests the pattern for alternatively moving to the previous, first, or last row in the result set. Unfortunately, JDBC 2.0, after which the movement methods were modeled, uses <code>previous()</code>. The <code>FETCH</code> syntax, which is patterned after SQL, employs <code>PRIOR</code>. In case you forget this inconsistency, the Oracle Database 12<span class="italic">c</span> Release 1 (12.1) SQLJ translator will also accept <code>FETCH PREVIOUS</code>.</p>
<p>The syntax are:</p>
<pre>#sql { FETCH PRIOR FROM :iter INTO :x, :y, :z  };
#sql { FETCH FIRST FROM :iter INTO :x, :y, :z  };
#sql { FETCH LAST FROM :iter INTO :x, :y, :z  };
</pre>
<p>There is also syntax to pass a numeric value for absolute or relative movements, to move to a particular (absolute) row, or to move forward or backward from the current position. The syntax are:</p>
<pre>#sql { FETCH ABSOLUTE :n FROM :iter INTO :x, :y, :z  };
#sql { FETCH RELATIVE :n FROM :iter INTO :x, :y, :z  };
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
In all of the preceding cases, the iterator <code>endFetch()</code> method returns <code>true</code> whenever the <code>FETCH</code> fails to move to a valid row and retrieve values.</div>
<p>Note that you <span class="italic">must</span> use a host expression to specify the movement. You cannot simply use a constant for the numeric value. Thus, instead of the following:</p>
<pre>#sql { FETCH RELATIVE 0 FROM :iter INTO :x, :y, :z };
</pre>
<p>You must write the following:</p>
<pre>#sql { FETCH RELATIVE :(0) FROM :iter INTO :x, :y, :z  };
</pre>
<p>Incidentally, this command leaves the position of the iterator unchanged. If the iterator is on a valid row, then the command just populates the variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Alternatively, you can navigate through a scrollable positional iterator through a combination of the navigation methods and the <code>FETCH CURRENT</code> syntax.</div>
<p class="subhead2"><a id="i1006889"></a><a id="JSQLJ560"></a>FE<a id="sthref531"></a>TCH CURRENT Syntax: from JDBC Result Sets to SQLJ Iterators</p>
<p>Consider a situation where you have an existing JDBC program that you want to rewrite in SQLJ with as little modification as possible.</p>
<p>Your JDBC result set will use only movement methods, such as <code>next()</code>, <code>previous()</code>, <code>absolute()</code>, and so on. You can immediately model this in SQLJ through a named iterator. However, this also implies that all columns of the SQL result set must have a proper name. In practice, many columns of the result set, if not all, will require introduction of alias names. This is unacceptable if the query text is to remain untouched.</p>
<p>The alternative, to avoid change to the query source, is to define a positional iterator type for the result set. However, this approach forces changes to the control-flow logic of the program. Consider the following JDBC code sample:</p>
<pre>ResultSet rs = ... // execute ...query...;
while (rs.next()) {
   x := rs.get<span class="italic">Xxx</span>(1); y:=rs.get<span class="italic">Xxx</span>(2);
   ...<span class="italic">process</span>...
}
</pre>
<p>This translates along the following lines to SQLJ:</p>
<pre>MyIter iter;
#sql iter = { ...query... };
while(true) {
   #sql { FETCH :iter INTO :x, :y };
   if (iter.endFetch()) break;
   ...process...
}
</pre>
<p>The transformations to the program logic will become even more difficult when considering arbitrary movements on scrollable iterators. Because positional iterators implement all the movement commands of named iterators, it is possible to exploit this and use <code>RELATIVE :(0)</code> to populate variables from the iterator:</p>
<pre>MyIter iter;
#sql iter = { ...query... };
while (iter.next()) {
   #sql { FETCH RELATIVE :(0) FROM :iter INTO :x, :y };
   ...process...
}
</pre>
<p>Now, you can preserve both the original query and the original program logic. Unfortunately, there still is one drawback to this approach. The <code>MyIter</code> iterator type must implement the <code>Scrollable</code> interface, even if this property is not really needed. To address this, the Oracle SQLJ implementation supports the following syntax extension:</p>
<pre>#sql { FETCH CURRENT FROM :iter INTO :x, :y, :z  };
</pre>
<p>Given this syntax, you can rewrite the JDBC example in SQLJ for scrollable as well as nonscrollable iterators:</p>
<pre>AnyIterator ai;
#sql ai = { ...query... };
while (ai.next()) {
   #sql { FETCH CURRENT FROM :ai INTO :x, :y };
   ...<span class="italic">process</span>...
}
</pre>
<p class="subhead2"><a id="i1006929"></a><a id="JSQLJ561"></a>Scrollable Re<a id="sthref532"></a><a id="sthref533"></a><a id="sthref534"></a>sult Set Iterators</p>
<p>Support in the Oracle SQLJ implementation for weakly typed result set iterators includes a scrollable result set iterator type:</p>
<pre>package sqlj.runtime;
public interface ScrollableResultSetIterator
                 extends ResultSetIterator
                 implements Scrollable
{ }
</pre>
<p>Because this type extends <code>sqlj.runtime.ResultSetIterator</code>, it supports the methods described in <a href="#i1006712">&#34;Result Set Iterators&#34;</a>.</p>
<p>Because it also implements the <code>sqlj.runtime.Scrollable</code> interface, it supports the methods described in <a href="#i1006795">&#34;The Scrollable Interface&#34;</a> and <a href="#i1006816">&#34;Scrollable Named Iterators&#34;</a>.</p>
<p>Furthermore, scrollable result set iterators support the <code>FETCH CURRENT</code> syntax described in <a href="#i1006889">&#34;FETCH CURRENT Syntax: from JDBC Result Sets to SQLJ Iterators&#34;</a>.</p>
<p>Consider the following JDBC code:</p>
<pre>Statement st = conn.createStatement(&#34;SELECT first_name, employee_id FROM employees&#34;);
ResultSet rs = st.executeQuery();
while (rs.next()) { 
   x = rs.getString(1); 
   y = rs.getInt(2);
}
rs.close();
</pre>
<p>You can use a SQLJ result set iterator in writing equivalent code, as follows:</p>
<pre>sqlj.runtime.ResultSetIterator rsi;
#sql rsi = { SELECT first_name, employee_id FROM employees };
while (rsi.next()) {
   #sql { FETCH CURRENT FROM :rsi INTO :x, :y };
}
rsi.close();
</pre>
<p>To take advantage of scrollability features, you could also write the following code:</p>
<pre>sqlj.runtime.ScrollableResultSetIterator srsi;
#sql srsi = { SELECT first_name, employee_id FROM employees };
srsi.afterLast();
while (srsi.previous()) {
   #sql { FETCH CURRENT FROM :srsi INTO :x, :y };
}
srsi.close();
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006992"></a>
<div id="JSQLJ562" class="sect1">
<h2 class="sect1">Advanced <a id="sthref535"></a>Transaction Control</h2>
<p>SQLJ supports the SQL <code>SET TRANSACTION</code> statement to specify the access mode and isolation level of any given transaction. Standard SQLJ supports <code>READ ONLY</code> and <code>READ WRITE</code> access mode settings, but the Oracle JDBC implementation does not support <code>READ ONLY</code>. However, you can set permissions to have the same effect. Supported settings for isolation level are <code>SERIALIZABLE</code>, <code>READ COMMITTED</code>, <code>READ UNCOMMITTED</code>, and <code>REPEATABLE READ</code>. However, the Oracle SQL implementation does not support <code>READ UNCOMMITTED</code> or <code>REPEATABLE READ</code>.</p>
<p><code>READ WRITE</code> is the default access mode in both standard SQL and the Oracle SQL implementation. <code>READ COMMITTED</code> is the default isolation level in the Oracle SQL implementation. <code>SERIALIZABLE</code> is the default in standard SQL.</p>
<p>The following sections provide details:</p>
<ul>
<li>
<p><a href="#i1008762">SET TRANSACTION Syntax</a></p>
</li>
<li>
<p><a href="#i1008767">Access Mode Settings</a></p>
</li>
<li>
<p><a href="#i1008772">Isolation Level Settings</a></p>
</li>
<li>
<p><a href="#i1008782">Using JDBC Connection Class Methods</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1006304">&#34;Basic Transaction Control&#34;</a></div>
<a id="i1008762"></a>
<div id="JSQLJ563" class="sect2">
<h3 class="sect2">SET <a id="sthref536"></a>TRANSACTION Syntax</h3>
<p>The SQLJ <code>SET TRANSACTION</code> statement has the following syntax:</p>
<pre>#sql { SET TRANSACTION &lt;<span class="italic">access_mode</span>&gt;, &lt;ISOLATION LEVEL <span class="italic">isolation_level</span>&gt; };
</pre>
<p>If you do not specify a connection context instance, then the statement applies to the default connection. If you use <code>SET TRANSACTION</code>, then it must be the first statement in a transaction, preceding any DML statements. In other words, the first statement since your connection to the database or your most recent <code>COMMIT</code> or <code>ROLLBACK</code>.</p>
<p>In standard SQLJ, any access mode or isolation level you set will remain in effect across transactions until you explicitly reset it at the beginning of a subsequent transaction. In a standard SQLJ <code>SET TRANSACTION</code> statement, you can optionally specify the isolation level first or only the access mode or only the isolation level. Following are some examples:</p>
<pre>#sql { SET TRANSACTION READ WRITE };

#sql { SET TRANSACTION ISOLATION LEVEL SERIALIZABLE };

#sql { SET TRANSACTION READ WRITE, ISOLATION LEVEL SERIALIZABLE };

#sql { SET TRANSACTION ISOLATION LEVEL READ COMMITTED, READ WRITE };
</pre>
<p>You can also specify a particular connection context instance for a <code>SET TRANSACTION</code> statement, as opposed to having it apply to the default connection:</p>
<pre>#sql [myCtxt] { SET TRANSACTION ISOLATION LEVEL SERIALIZABLE };
</pre>
<p>Note that in SQLJ, both the access mode and the isolation level can be set in a single <code>SET TRANSACTION</code> statement. This is not true in other Oracle SQL tools, such as Server Manager or SQL*Plus, where a single statement can set one or the other, but not both.</p>
</div>
<!-- class="sect2" -->
<a id="i1008767"></a>
<div id="JSQLJ564" class="sect2">
<h3 class="sect2">Access <a id="sthref537"></a><a id="sthref538"></a>Mode Settings</h3>
<p><a id="sthref539"></a><a id="sthref540"></a>The <code>READ WRITE</code> and <code>READ ONLY</code> access mode settings, where supported, have the following functionality:</p>
<ul>
<li>
<p><code>READ WRITE</code> (default): In a <code>READ WRITE</code> transaction, you are not allowed to update the database. <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> are all legal.</p>
</li>
<li>
<p><code>READ ONLY</code> (also supported by the Oracle JDBC implementation): In a <code>READ ONLY</code> transaction, you are not allowed to update the database. <code>SELECT</code> is legal, but <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>SELECT FOR UPDATE</code> are not.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1008772"></a>
<div id="JSQLJ565" class="sect2">
<h3 class="sect2">Isolation <a id="sthref541"></a><a id="sthref542"></a>Level Settings</h3>
<p><a id="sthref543"></a><a id="sthref544"></a><a id="sthref545"></a><a id="sthref546"></a><a id="sthref547"></a><a id="sthref548"></a><a id="sthref549"></a>The <code>READ COMMITTED</code>, <code>SERIALIZABLE</code>, <code>READ UNCOMMITTED</code>, and <code>REPEATABLE READ</code> isolation level settings, where supported, have the following functionality:</p>
<ul>
<li>
<p><code>READ UNCOMMITTED</code>: Dirty reads, nonrepeatable reads, and phantom reads are all allowed.</p>
</li>
<li>
<p><code>READ COMMITTED</code> (default): Dirty reads are prevented, and nonrepeatable reads and phantom reads are allowed. If the transaction contains DML statements that require row locks held by other transactions, then any of the statements will block until the row lock it needs is released by the other transaction.</p>
</li>
<li>
<p><code>REPEATABLE READ</code>: Dirty reads and nonrepeatable reads are prevented, and phantom reads are allowed.</p>
</li>
<li>
<p><code>SERIALIZABLE</code>: Dirty reads, nonrepeatable reads, and phantom reads are all prevented. Any DML statements in the transaction cannot update any resource that might have had changes committed after the transaction began. Such DML statements will fail.</p>
</li>
</ul>
<p>A dirty read occurs when transaction B accesses a row that was updated by transaction A, but transaction A later rolls back the updates. As a result, transaction B sees data that was never actually committed to the database.</p>
<p>A nonrepeatable read occurs when transaction A retrieves a row, transaction B subsequently updates the row, and transaction A later retrieves the same row again. Transaction A retrieves the same row twice but sees different data.</p>
<p>A phantom read occurs when transaction A retrieves a set of rows satisfying a given condition, transaction B subsequently inserts or updates a row such that the row now meets the condition in transaction A, and transaction A later repeats the conditional retrieval. Transaction A now sees an additional row. This row is referred to as a phantom.</p>
<p>You can think of the four isolation level settings being in a progression:</p>
<pre>SERIALIZABLE &gt; REPEATABLE READ &gt; READ COMMITTED &gt; READ UNCOMMITTED
</pre>
<p>If a desired setting is unavailable to you, such as <code>REPEATABLE READ</code> or <code>READ UNCOMMITTED</code> if you use Oracle Database 12<span class="italic">c</span> Release 1 (12.1), use a greater setting (one further to the left) to ensure having at least the level of isolation that you want.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Development Guide</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1008782"></a>
<div id="JSQLJ566" class="sect2">
<h3 class="sect2">Using <a id="sthref550"></a><a id="sthref551"></a><a id="sthref552"></a>JDBC Connection Class Methods</h3>
<p>You can optionally access and set the access mode and isolation level of a transaction, using methods of the underlying JDBC connection instance of your connection context instance. SQLJ code using these JDBC methods is not portable, however.</p>
<p>Following are the <code>Connection</code> class methods for access mode and isolation level settings:</p>
<ul>
<li>
<p><code>abstract int getTransactionIsolation()</code>: Returns the current transaction isolation level as one of the following constant values:</p>
<p><code>TRANSACTION_NONE TRANSACTION_READ_COMMITTED TRANSACTION_SERIALIZABLE TRANSACTION_READ_UNCOMMITTED TRANSACTION_REPEATABLE_READ</code></p>
</li>
<li>
<p><code>abstract void setTransactionIsolation(int)</code>: Sets the transaction isolation level, taking as input one of the preceding constant values.</p>
</li>
<li>
<p><code>abstract boolean isReadOnly()</code>: Returns <code>true</code> if the transaction is <code>READ ONLY</code>. Returns <code>false</code> if the transaction is <code>READ WRITE</code>.</p>
</li>
<li>
<p><code>abstract void setReadOnly(boolean)</code>: Sets the transaction access mode to <code>READ ONLY</code> if <code>true</code> is input. Sets the access mode to <code>READ WRITE</code> if <code>false</code> is input.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007059"></a>
<div id="JSQLJ567" class="sect1">
<h2 class="sect1">SQLJ and JDBC Interoperability</h2>
<p>SQLJ<a id="sthref553"></a> statements are typically used for static SQL operations. Oracle Database 12<span class="italic">c</span> Release 1 (12.1) has extensions to support dynamic SQL as well, but another alternative is to use JDBC code within your SQLJ application for dynamic operations, which would be more portable. And there might be additional scenarios where using JDBC code in your SQLJ application might be useful or even required. Because of this, SQLJ enables you to use SQLJ and JDBC statements concurrently and provides interoperability between SQLJ and JDBC constructs.</p>
<p>Two kinds of interactions between SQLJ and JDBC are particularly useful:</p>
<ul>
<li>
<p>Between SQLJ connection contexts and JDBC connections</p>
</li>
<li>
<p>Between SQLJ iterators and JDBC result sets</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1007079">SQLJ Connection Context and JDBC Connection Interoperability</a></p>
</li>
<li>
<p><a href="#i1007230">SQLJ Iterator and JDBC Result Set Interoperability</a></p>
</li>
</ul>
<a id="i1007079"></a>
<div id="JSQLJ568" class="sect2">
<h3 class="sect2">SQLJ <a id="sthref554"></a><a id="sthref555"></a>Connection Context and JDBC Connection Interoperability</h3>
<p>SQLJ enables you to convert, in either direction, between SQLJ connection context instances and JDBC connection instances.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When converting between a SQLJ connection context and a JDBC connection, bear in mind that the two objects are sharing the same underlying physical connection.</div>
<p class="subhead2"><a id="JSQLJ569"></a>Converting<a id="sthref556"></a> from Connection Contexts to JDBC Connections</p>
<p>If you want to perform a JDBC operation through a database connection that you have established in SQLJ (for example, if your application calls a library routine that returns a JDBC connection object), then you must convert the SQLJ connection context instance to a JDBC connection instance.</p>
<p>Any connection context instance in a SQLJ application, whether an instance of the <code>sqlj.runtime.ref.DefaultContext</code> class or of a declared connection context class, contains an underlying JDBC connection instance and a <code>getConnection()</code> method that returns that JDBC connection instance. Use the JDBC connection instance to create JDBC statement objects if you want to use JDBC operations.</p>
<p>Following is an example of how to use the <code>getConnection()</code> method.</p>
<pre>import java.sql.*;

...
DefaultContext ctx = new DefaultContext 
      (&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, &#34;HR&#34;, &#34;hr&#34;, true);
...
(<span class="italic">SQLJ operations through SQLJ </span>ctx <span class="italic">connection context instance</span>)
...
Connection conn = ctx.getConnection();
...
(<span class="italic">JDBC operations through JDBC</span> conn <span class="italic">connection instance</span>)
...
</pre>
<p>The connection context instance can be an instance of the <code>DefaultContext</code> class or of any connection context class that you have declared.</p>
<p>To retrieve the underlying JDBC connection of your default SQLJ connection, you can use <code>getConnection()</code> directly from a <code>DefaultContext.getDefaultContext()</code> call, where <code>getDefaultContext()</code> returns a <code>DefaultContext</code> instance that you had previously initialized as your default connection and <code>getConnection()</code> returns its underlying JDBC connection instance. In this case, because you do not have to use the <code>DefaultContext</code> instance explicitly, you can also use the <code>Oracle.connect()</code> method. This method implicitly creates the instance and makes it the default connection.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1005714">&#34;Connection Considerations&#34;</a> and <a href="keyprog.htm#i1005907">&#34;More About the Oracle Class&#34;</a></div>
<p>Following is an example:</p>
<pre>import java.sql.*;

...
Connection conn = Oracle.connect
   (&#34;jdbc:oracle:thin:@localhost:5221/myservice&#34;, 
    &#34;HR&#34;, &#34;hr&#34;).getConnection();
...
(<span class="italic">JDBC operations through JDBC</span> conn <span class="italic">connection instance</span>)
...
</pre>
<p class="subhead2"><a id="CBBEJJFD"></a><a id="JSQLJ570"></a>Example: JDBC and SQLJ Connection Interoperability for Dynamic SQL</p>
<p>Following is a sample method that uses the underlying JDBC connection instance of the default SQLJ connection context instance to perform dynamic SQL operations in JDBC. The dynamic operations are performed using JDBC <code>java.sql.Connection</code>, <code>java.sql.PreparedStatement</code>, and <code>java.sql.ResultSet</code> objects. Alternatively, you can use Oracle SQLJ extensions for dynamic SQL operations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> and <a href="#i1007348">&#34;Support for Dynamic SQL&#34;</a></div>
<pre>import java.sql.*;

public static void projectsDue(boolean dueThisMonth) throws SQLException {

   // Get JDBC connection from previously initialized SQLJ DefaultContext.
   Connection conn = DefaultContext.getDefaultContext().getConnection();

   String query = &#34;SELECT name, start_date + duration &#34; +
                  &#34;FROM projects WHERE start_date + duration &gt;= sysdate&#34;;
   if (dueThisMonth)
      query += &#34; AND to_char(start_date + duration, &#39;fmMonth&#39;) &#34; +
               &#34; = to_char(sysdate, &#39;fmMonth&#39;) &#34;;

   PreparedStatement pstmt = conn.prepareStatement(query);
   ResultSet rs = pstmt.executeQuery();
   while (rs.next()) {
      System.out.println(&#34;Project: &#34; + rs.getString(1) + &#34; Deadline: &#34; +
                         rs.getDate(2));
   }
   rs.close();
   pstmt.close();
}
</pre>
<p>For a rework of this example using SQLJ dynamic SQL functionality with <code>FETCH</code> functionality from a result set iterator, refer to <a href="#i1007507">Example 5: Dynamic SQL with FETCH from Result Set Iterator</a>.</p>
<p class="subhead2"><a id="JSQLJ571"></a>Converting <a id="sthref557"></a>from JDBC Connections to Connection Contexts</p>
<p>If you initiate a connection as a JDBC <code>Connection</code> instance but later want to use it as a SQLJ connection context instance (for example, if you want to use it in a context expression to specify the connection to use for a SQLJ executable statement), you can convert the JDBC connection instance to a SQLJ connection context instance.</p>
<p>The <code>DefaultContext</code> class and all declared connection context classes have a constructor that takes a JDBC connection instance as input and constructs a SQLJ connection context instance.</p>
<p>For example, presume you instantiated and defined the JDBC connection instance <code>conn</code> and want to use the same connection for an instance of a declared SQLJ connection context class <code>MyContext</code>. You can do this as follows:</p>
<pre>...
#sql context MyContext;
...
MyContext myctx = new MyContext(conn);
...
</pre>
<p class="subhead2"><a id="i1007195"></a><a id="JSQLJ572"></a>About Shared <a id="sthref558"></a>Connections</p>
<p>A SQLJ connection context instance and the associated JDBC connection instance share the same underlying physical connection. As a result, the following is true:</p>
<ul>
<li>
<p>When you get a JDBC connection instance from a SQLJ connection context instance (using the connection context <code>getConnection()</code> method), the <code>Connection</code> instance inherits the state of the connection context instance. Among other things, the <code>Connection</code> instance will retain the auto-commit setting of the connection context instance.</p>
</li>
<li>
<p>When you construct a SQLJ connection context instance from a JDBC connection instance (using the connection context constructor that takes a connection instance as input), the connection context instance inherits the state of the <code>Connection</code> instance. Among other things, the connection context instance will retain the auto-commit setting of the <code>Connection</code> instance. By default, a JDBC connection instance has an auto-commit setting of <code>true</code>, but you can alter this through the <code>setAutoCommit()</code> method of the <code>Connection</code> instance.</p>
</li>
<li>
<p>Given a SQLJ connection context instance and associated JDBC connection instance, calls to methods that alter session state in one instance will also affect the other instance, because it is actually the underlying shared session that is being altered.</p>
</li>
<li>
<p>Because there is just a single underlying physical connection, there is also a single underlying set of transactions. A <code>COMMIT</code> or <code>ROLLBACK</code> operation in one connection instance will affect any other connection instances that share the same underlying connection.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is also possible for multiple SQLJ connection context instances to be created from the same JDBC connection instance and, therefore, to share the same underlying physical connection. This might be useful, for example, if you want to share the same set of transactions between program modules. The preceding notes apply to this situation as well.</div>
<p class="subhead2"><a id="i1007208"></a><a id="JSQLJ573"></a>Closing <a id="sthref559"></a>Shared Connections</p>
<p>When you get a JDBC connection instance from a SQLJ connection context instance (using the <code>getConnection()</code> method) or you create a SQLJ connection context instance from a JDBC connection instance (using the connection context constructor), you must close only the connection context instance. By default, calling the <code>close()</code> method of a connection context instance closes the associated JDBC connection instance and the underlying physical connection, thereby freeing all resources associated with the connection.</p>
<p>If you want to close a SQLJ connection context instance <span class="italic">without</span> closing the associated JDBC connection instance (if, for example, the <code>Connection</code> instance is being used elsewhere, either directly or by another connection context instance), then you can specify the boolean constant <code>KEEP_CONNECTION</code> to the <code>close()</code> method, as follows (assume a connection context instance <code>ctx</code>):</p>
<pre>ctx.close(ConnectionContext.KEEP_CONN<a id="sthref560"></a>ECTION);
</pre>
<p>If you do not specify <code>KEEP_CONNECTION</code>, then the associated JDBC connection instance is closed by default. You can also specify this explicitly:</p>
<pre>ctx.close(ConnectionContext.CLOSE_CONN<a id="sthref561"></a>ECTION);
</pre>
<p><code>KEEP_CONNECTION</code> and <code>CLOSE_CONNECTION</code> are static constants of the <code>sqlj.runtime.ConnectionContext</code> interface.</p>
<p>If you close only the JDBC connection instance, this will <span class="italic">not</span> close the associated SQLJ connection context instance. The underlying physical connection would be closed, but the resources of the connection context instance would not be freed until garbage collection.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>If the same underlying JDBC connection is shared by multiple connection context instances, then use <code>KEEP_CONNECTION</code> when closing all but the last remaining open connection context instance.</p>
</li>
<li>
<p>An error message will be issued if you try to close a connection context instance whose underlying JDBC connection has already been closed, or if you try to close the underlying connection when it has already been closed. If you encounter this, then verify that the JDBC connection is not being closed independently by JDBC code and all preceding <code>close()</code> calls on SQLJ connection context instances that use the underlying connection use the <code>KEEP_CONNECTION</code> parameter.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007230"></a>
<div id="JSQLJ574" class="sect2">
<h3 class="sect2">SQLJ <a id="sthref562"></a><a id="sthref563"></a>Iterator and JDBC Result Set Interoperability</h3>
<p>SQLJ enables you to convert in either direction between SQLJ iterators and JDBC result sets. For situations where you are selecting data in a SQLJ statement but do not care about strongly typed iterator functionality, SQLJ also supports a weakly typed iterator, which you can convert to a JDBC result set.</p>
<p class="subhead2"><a id="i1007234"></a><a id="JSQLJ575"></a>Converting<a id="sthref564"></a><a id="sthref565"></a> from Result Sets to Named or Positional Iterators</p>
<p>There are a number of situations where you might find yourself manipulating JDBC result sets. For example, another package might be implemented in JDBC and provide access to data only through result sets or might require <code>ResultSetMetaData</code> information because it is a routine written generically for any type of result set. Or your SQLJ application might invoke a stored procedure that returns a JDBC result set.</p>
<p>If the dynamic result set has a known structure, it is typically desirable to manipulate it as an iterator to use the strongly typed paradigm that iterators offer.</p>
<p>In SQLJ, you can populate a named or positional iterator object by converting an existing JDBC result set object. This can be thought of as casting a result set to an iterator, and the syntax reflects this as follows:</p>
<pre>#sql iter = { CAST :rs };
</pre>
<p>This binds the result set object, <code>rs</code>, into the SQLJ executable statement, converts the result set, and populates the iterator, <code>iter</code>, with the result set data.</p>
<p>Following is an example. Assume <code>myEmpQuery()</code> is a static Java function in a class called <code>RSClass</code>, with a predefined query that returns a JDBC result set object:</p>
<pre>import java.sql.*;
...
#sql public iterator MyIterator (String ename, float sal);
...
ResultSet rs;
MyIterator iter;
...
rs = RSClass.myEmpQuery();
#sql iter = { CAST :rs };
...
(<span class="italic">process iterator</span>)
...
iter.close();
...
</pre>
<p>This example could have used a positional iterator instead of a named iterator. The functionality is identical.</p>
<p>The following rules apply when converting a JDBC result set to a SQLJ iterator and processing the data:</p>
<ul>
<li>
<p>To convert to a positional iterator, the result set and iterator must have the same number of columns and the types must map correctly.</p>
</li>
<li>
<p>To convert to a named iterator, the result set must have at least as many columns as the iterator and all columns of the iterator must be matched by name and type. If the result set and iterator do not have the same number of columns, then the SQLJ translator will generate a warning unless you use the <code>-warn=nostrict</code> option setting.</p>
</li>
<li>
<p>The result set being cast must implement the <code>java.sql.ResultSet</code> interface. The class <code>oracle.jdbc.OracleResultSet</code> implements this interface, as does any standard result set class.</p>
</li>
<li>
<p>The iterator receiving the cast must be an instance of an iterator class that was declared as <code>public</code>.</p>
</li>
<li>
<p>Do not access data from the result set, either before or after the conversion. Access data from the iterator only.</p>
</li>
<li>
<p>When you are finished, close the iterator, not the result set. Closing the iterator will also close the result set, but closing the result set will not close the iterator. When interoperating with JDBC, always close the SQLJ entity.</p>
</li>
</ul>
<p class="subhead2"><a id="i1007269"></a><a id="JSQLJ576"></a>Converting<a id="sthref566"></a><a id="sthref567"></a> from Named or Positional Iterators to Result Sets</p>
<p>You might also encounter situations where you want to define a query using SQLJ but ultimately need a result set.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQLJ offers more natural and concise syntax, but perhaps you want to do dynamic processing of the results, or perhaps you want to use an existing Java method that takes a result set as input.</div>
<p>So that you can convert iterators to result sets, every SQLJ iterator class, whether named or positional, is generated with a <code>getResultSet()</code> method. This method can be used to return the underlying JDBC result set object of an iterator object.</p>
<p>Following is an example showing use of the <code>getResultSet()</code> method:</p>
<pre>import java.sql.*;

#sql public iterator MyIterator (String ename, float sal);

...
MyIterator iter;
...
#sql iter = { SELECT * FROM employees };
ResultSet rs = iter.getResultSet();
...
(<span class="italic">process result set</span>)
...
iter.close();
...
</pre>
<p>The following rules apply when converting a SQLJ iterator to a JDBC result set and processing the data.</p>
<ul>
<li>
<p>When writing iterator data to a result set, you should access data only through the result set. Do not attempt to directly access the iterator, either before or after the conversion.</p>
</li>
<li>
<p>When you finish, close the original iterator, not the result set. Closing the iterator will also close the result set, but closing the result set will not close the iterator. When interoperating with JDBC, always close the SQLJ entity.</p>
</li>
</ul>
<p class="subhead2"><a id="i1007295"></a><a id="JSQLJ577"></a>Using and Converting <a id="sthref568"></a>Weakly Typed Iterators (ResultSetIterator)</p>
<p>You might have a situation similar to what is discussed in <a href="#i1007269">&#34;Converting from Named or Positional Iterators to Result Sets&#34;</a>, but where you do not require the strongly typed functionality of the iterator. All you might care about is being able to use SQLJ syntax for the query and then processing the data dynamically from a result set. For such circumstances, you can directly use the <code>sqlj.runtime.ResultSetIterator</code> type to receive query data.</p>
<p>In using SQLJ statements and <code>ResultSetIterator</code> functionality instead of using JDBC statements and standard result set functionality, you enable yourself to use the more concise <code>SELECT</code> syntax of SQLJ.</p>
<p>Following is an example of how to use and convert a weakly typed result set iterator:</p>
<pre>import sqlj.runtime.*;
import java.sql.*;

...
ResultSetIterator rsiter;
...
#sql rsiter = { SELECT * FROM table };
ResultSet rs = rsiter.getResultSet();
...
(<span class="italic">process result set</span>)
...
rsiter.close();
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle SQLJ implementation permits navigation through a result set iterator using the <code>next()</code> method and <code>FETCH CURRENT</code> syntax. Furthermore, for scrollable result set iterators, additional navigation methods are supported.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007348"></a>
<div id="JSQLJ578" class="sect1">
<h2 class="sect1">Suppo<a id="sthref569"></a>rt for Dynamic SQL</h2>
<p>The Oracle SQLJ implementation includes extensions to support dynamic SQL, operations that are not predefined and can change in real time. Dynamic SQL expressions embedded in SQLJ statements are referred to as meta bind expressions.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Using JDBC code is still an option for dynamic SQL in Oracle Database 12<span class="italic">c</span> Release 1 (12.1) and might be preferable if code portability is a concern, but SQLJ support for dynamic SQL permits use of SQLJ as a single, simplified API for data access.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDJJGAI">Meta Bind Expressions</a></p>
</li>
<li>
<p><a href="#CHDFCFAB">SQLJ Dynamic SQL Examples</a></p>
</li>
</ul>
<a id="CHDJJGAI"></a>
<div id="JSQLJ579" class="sect2">
<h3 class="sect2">Meta Bin<a id="sthref570"></a><a id="sthref571"></a>d Expressions</h3>
<p>Meta bind expressions are used for dynamic SQL in SQLJ statements, where otherwise static SQL clauses would appear. A meta bind expression contains a Java identifier of <code>String</code> type or a string-valued Java expression that is interpreted at run time. In addition, so that SQLJ can perform online semantics-checking, a meta bind expression can optionally include static SQL replacement code to be used for checking during translation.</p>
<p class="subhead2"><a id="JSQLJ580"></a>Meta Bind Expressions: General Usage and Restrictions</p>
<p>You can use a meta bind expression in place of any of the following:</p>
<ul>
<li>
<p>Table name</p>
</li>
<li>
<p>Column name in a <code>SELECT</code> statement (without the column alias, if specified)</p>
</li>
<li>
<p>All or part of a <code>WHERE</code> clause condition</p>
</li>
<li>
<p>Role, schema, catalog, or package name in a data definition language (DDL) or DML statement</p>
</li>
<li>
<p>SQL literal value or SQL expression</p>
</li>
</ul>
<p>Be aware of the following restrictions on meta bind expressions, enforced to ensure that the SQLJ translator can properly determine the nature of the SQL operation and can perform syntactic analysis of the SQLJ statement as a whole:</p>
<ul>
<li>
<p>A meta bind expression cannot be the first noncomment of the SQL operation within a SQLJ statement.</p>
</li>
<li>
<p>A meta bind expression cannot contain the <code>INTO</code> token of a SQLJ <code>SELECT INTO</code> statement and cannot expand to become the <code>INTO</code>-list of a <code>SELECT INTO</code> statement.</p>
</li>
<li>
<p>A meta bind expression cannot appear in any of the following kinds of SQL/SQLJ instructions or clauses: <code>CALL</code>, <code>VALUES</code>, <code>PSM SET</code>, <code>COMMIT</code>, <code>ROLLBACK</code>, <code>FETCH INTO</code>, or <code>CAST</code>.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ581"></a>Meta Bind Expressions: Syntax and Behavior</p>
<p>Following is the general syntax for meta bind expressions:</p>
<pre>:{ <span class="italic">Java_bind_expression</span> }
</pre>
<p>or:</p>
<pre>:{ <span class="italic">Java_bind_expression</span> :: <span class="italic">SQL_replacement_code</span> }
</pre>
<p>Note that spaces are optional. There can be multiple meta bind expressions within the SQL instructions of a SQLJ statement.</p>
<p class="subhead2"><a id="JSQLJ582"></a>Java Bin<a id="sthref572"></a>d Expression</p>
<p>A Java bind expression can be either of the following:</p>
<ul>
<li>
<p>Java identifier of the <code>String</code> type</p>
</li>
<li>
<p>Java expression that evaluates to a character string</p>
</li>
</ul>
<p>Java bind expressions within meta bind expressions are subject to standard Java lexing rules and have syntax similar to that of SQLJ host expressions. However, unlike host expressions, Java bind expressions within meta bind expressions are not enclosed within parentheses. This is because, if there is SQL replacement code, then the <code>::</code> token acts as a separator between the Java bind expression and the SQL code. If there is no SQL replacement code, then the closing braces (}) acts as a terminator. In either case, there is no ambiguity.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There can be no mode specifiers, <code>IN</code>, <code>OUT</code>, or <code>INOUT</code>, within a Java bind expression or between <code>:</code> and <code>{</code> of the meta bind expression.</div>
<p class="subhead2"><a id="JSQLJ583"></a>SQL Rep<a id="sthref573"></a>lacement Code</p>
<p>A SQL replacement code clause consists of a sequence of zero or more SQL tokens, with the following requirements and restrictions:</p>
<ul>
<li>
<p>It is subject to SQL lexing rules.</p>
</li>
<li>
<p>Braces ({ }) must occur in matching pairs (with the exception of those that are part of a SQL comment, constant, or identifier).</p>
</li>
<li>
<p>There can be no SQLJ host expressions or nested meta bind expressions within the SQL instructions.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is permissible for the SQL replacement code to be empty.</div>
<p class="subhead2"><a id="JSQLJ584"></a>Translat<a id="sthref574"></a>ion-Time Behavior</p>
<p>Whenever there is SQL replacement code (even if only an empty string) in a meta bind expression, then the meta bind expression is replaced by the SQL code during translation. The purpose of SQL replacement code is to enable the SQLJ translator to perform online semantics-checking.</p>
<p>If any meta bind expression within a SQLJ statement has no SQL replacement code clause, then the SQLJ translator cannot perform online semantics-checking on the statement. It is only checked syntactically.</p>
<p class="subhead2"><a id="JSQLJ585"></a>Run-Ti<a id="sthref575"></a>me Behavior</p>
<p>At run time, each meta bind expression is replaced by the evaluation of its Java bind expression. If a Java bind expression evaluates to <code>null</code>, then the dynamic SQL statement as a whole becomes undefined.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFCFAB"></a>
<div id="JSQLJ586" class="sect2">
<h3 class="sect2">SQLJ Dyn<a id="sthref576"></a>amic SQL Examples</h3>
<p>This section provides examples of dynamic SQL usage in SQLJ code.</p>
<p class="subhead2"><a id="JSQLJ587"></a>Example 1</p>
<pre>...
int x = 10;
int y = x + 10;
int z = y + 10;
String table = &#34;new_Emp&#34;;
#sql { INSERT INTO :{table :: emp} VALUES (:x, :y, :z) };
...
</pre>
<p>During translation, the SQL operation becomes:</p>
<pre>INSERT INTO emp VALUES (10, 20, 30);
</pre>
<p>SQLJ can perform online semantics-checking against a schema that has an <code>emp</code> table. Perhaps <code>new_Emp</code> only exists in the run-time schema and is not created until the application executes.</p>
<p>During run time, the SQL operation becomes:</p>
<pre>INSERT INTO new_Emp VALUES (10, 20, 30);
</pre>
<p class="subhead2"><a id="JSQLJ588"></a>Example 2</p>
<pre>...
String table = &#34;new_Emp&#34;;
String query = &#34;ename LIKE &#39;S%&#39; AND sal&gt;1000&#34;;
#sql myIter = { SELECT * FROM :{table :: emp2} 
                         WHERE :{query :: ename=&#39;HR&#39;} };
...
</pre>
<p>During translation, the SQL operation becomes:</p>
<pre>SELECT * FROM emp2 WHERE ename=&#39;HR&#39;;
</pre>
<p>SQLJ can perform online semantics-checking against a schema that has an <code>emp2</code> table.</p>
<p>During run time, the SQL operation becomes:</p>
<pre>SELECT * FROM new_Emp WHERE ename LIKE &#39;S%&#39; AND sal&gt;1000;
</pre>
<p class="subhead2"><a id="i1007458"></a><a id="JSQLJ589"></a>Example 3</p>
<pre>...
double raise = 1.12;
String col = &#34;comm&#34;;
String whereQuery = &#34;WHERE &#34;+col+&#34; IS NOT null&#34;;
for (int i=0; i&lt;5; i++)
{
   #sql { UPDATE :{&#34;emp&#34;+i :: emp} 
          SET :{col :: sal} = :{col :: sal} * :raise :{whereQuery ::} };
}
...
</pre>
<p>During translation, the SQL operation becomes:</p>
<pre>UPDATE emp SET sal = sal * 1.12;
</pre>
<p>SQLJ can perform online semantics-checking against a schema that has an <code>emp</code> table. There is no <code>WHERE</code> clause during translation, because the SQL replacement code is empty.</p>
<p>During run time, the SQL operation is executed five times, becoming:</p>
<pre>UPDATE emp0 SET comm = comm * 1.12 WHERE comm IS NOT null;
UPDATE emp1 SET comm = comm * 1.12 WHERE comm IS NOT null;
UPDATE emp2 SET comm = comm * 1.12 WHERE comm IS NOT null;
UPDATE emp3 SET comm = comm * 1.12 WHERE comm IS NOT null;
UPDATE emp4 SET comm = comm * 1.12 WHERE comm IS NOT null;
</pre>
<p class="subhead2"><a id="i1007483"></a><a id="JSQLJ590"></a>Example 4</p>
<pre>...
double raise = 1.12;
String col = &#34;comm&#34;;
String whereQuery = &#34;WHERE &#34;+col+&#34; IS NOT null&#34;;
for (int i=0; i&lt;10; i++)
{
   #sql { UPDATE :{&#34;emp&#34;+i} 
          SET :{col :: sal} = :{col :: sal} * :raise :{whereQuery ::} };
}
...
</pre>
<p>The run-time behaviors of <a href="#i1007458">Example 3</a> and <a href="#i1007483">Example 4</a> are identical. However, a difference occurs during translation, where SQLJ cannot perform online semantics-checking for <a href="#i1007483">Example 4</a>, because there is no SQL replacement code for the first meta bind expression, <code>:{&#34;emp&#34;+i}</code>.</p>
<p class="subhead2"><a id="i1007507"></a><a id="JSQLJ591"></a>Example 5: Dynamic SQL with FETCH from Result Set Iterator</p>
<p>This example is a rework of <a href="#CBBEJJFD">&#34;Example: JDBC and SQLJ Connection Interoperability for Dynamic SQL&#34;</a>, using SQLJ statements instead of JDBC statements. This example also uses <code>FETCH CURRENT</code> functionality from a result set iterator.</p>
<pre>import java.sql.*;

public static void projectsDue(boolean dueThisMonth) throws SQLException {

   ResultSetIterator rsi;
   String andClause = (dueThisMonth) ? 
                       &#34; AND to_char(start_date + duration, &#39;fmMonth&#39; ) &#34; 
                       + &#34; = to_char(sysdate, &#39;fmMonth&#39;) &#34; 
                       : &#34;&#34;;
   #sql rsi = { SELECT name, start_date + duration FROM projects
                WHERE start_date + duration &gt;= sysdate :{andClause :: } };
   while (rsi.next())
   {
      String name = null;
      java.sql.Date deadline = null;
      #sql { FETCH CURRENT FROM :rsi INTO :name, :deadline };
      System.out.println(&#34;Project: &#34; + name + &#34;Deadline: &#34; + deadline);
   } 
   rsi.close();
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDCECE"></a>
<div id="JSQLJ592" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref577"></a>Using Stored Outlines</h2>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 12<span class="italic">c</span> Release 1 (12.1), this feature is deprecated, and replaced with SQL Plan Management (SPM). Oracle recommends that you take advantage of the new feature, which is more powerful and offers better performance. For more information about SPM, refer to <a href="#CHDBIAIA">&#34;Using Plan Baselines&#34;</a>.</div>
<p>If you run the risk of any performance changes in the application due to change in the environment, then you may use the outline feature of Oracle. An outline is implemented as a set of optimizer hints that are associated with the SQL statement. If the use of the outline is enabled for the statement, Oracle automatically considers the stored hints and tries to generate an execution plan in accordance with those hints. You can group outlines into categories, that is, whether they are default or as specified by the client, and control the category of outlines Oracle uses to simplify outline administration and deployment. The hints in the outlines are used during the execution of respective statements if you have set <code>USE_STORED_OUTLINES</code> to the category name or to <code>TRUE.</code></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about outlines.</div>
<p>When you translate the file with the new outline option set to <code>true</code> or the category name, then:</p>
<ol>
<li>
<p>A separate SQL file is created containing the <code>CREATE OUTLINE</code> statements for all the SQL statements present in the input SQLJ file.</p>
</li>
<li>
<p>A log file containing the SQL statements, outline name, outline SQL statement, outline category, and status information is generated.</p>
</li>
<li>
<p>If you specify the <code>-runoutline option</code>, then the SQL file generated is run at the end of successful translation of the input file.</p>
</li>
</ol>
<p>SQL statements that can be used to create outlines are:</p>
<ul>
<li>
<p>SELECT</p>
</li>
<li>
<p>DELETE</p>
</li>
<li>
<p>UPDATE</p>
</li>
<li>
<p>INSERT ... SELECT</p>
</li>
<li>
<p>CREATE TABLE ... AS SELECT</p>
</li>
</ul>
<p>You have the following restrictions on creating outlines:</p>
<ul>
<li>
<p>You cannot create outlines on MERGE statements.</p>
</li>
<li>
<p>You cannot create outlines on a multi-table INSERT statement.</p>
</li>
<li>
<p>The SQL statement in the outline cannot include any DML operation on a remote object.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ594"></a><a id="sthref578"></a>Options to Generate Outlines</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The outline options are valid <span class="italic">only</span> if online checking is done.</div>
<p>Consider the SQLJ program <code>abc.sqlj</code> contains the following code snippet:</p>
<pre>{
#sql iter = {SELECT * FROM employees WHERE employee_id=:var;}
#sql iter1 = {SELECT * FROM departments};
}
</pre>
<p>Compile the SQLJ program as:</p>
<pre>%sqlj -url=jdbc:oracle:oci8:@ -user=HR -outline=abccat abc.sqlj
Password: <span class="italic">password</span>
</pre>
<p>The generated SQL file <code>abc_sqlj.sql</code> for the above SQLJ code snippet looks as follows:</p>
<pre>CREATE OR REPLACE OUTLINE abccat_abc_sqlj_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id=:B1 
/* abccat_abc_sqlj_0001 */;

CREATE OR REPLACE OUTLINE abccat_abc_sqlj_0002 FOR CATEGORY abccat ON SELECT * FROM departments 
/* abccat_abc_sqlj_0002 */;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The filename is not included in the outline name or comment when a prefix is given. In this section, you will see examples with and without using prefix. For more information on prefix, refer to <a href="#CHDFFGHI">&#34;sqlj.outlineprefix&#34;</a>.</div>
<p>The option <code>-outline</code> generates two files at the end of successful translation: a SQL file and a LOG file. The generated SQL file name has the following format:</p>
<pre>&lt;filename&gt;_&lt;filetype&gt;.sql
</pre>
<p>For example, the generated SQL file for filename <code>abc.sqlj</code> is <code>abc_sqlj.sql.</code></p>
<p>The format of the unique identifier used as outline name and comment is:</p>
<pre>&lt;categoryname &gt;_&lt;filename&gt;_&lt;filetype&gt;_&lt;sequence no.&gt;
</pre>
<p>where, the sequence number is a four-digit sequence number ranging from 0001 to 9999. If the SQLJ program contains more than 9999 SQL statements, then you get the &#34;<code>Max sequence number exceeded for outlines</code>&#34; error. For example, the format of the unique identifier generated for <code>abc.sqlj</code> is <code>abccat_abc_sqlj_0001</code>, where, <code>abccat</code> is the name of the category.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The same comment is added to the SQLs in the generated java or class file that is used at runtime.</div>
<p>If you set outline to <code>true</code>, then the default category will be used to store the outlines:</p>
<pre>%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=true abc.sqlj
Password: <span class="italic">password</span>
</pre>
<p>In this case, the generated SQL file <code>abc_sqlj.sql</code> looks as follows:</p>
<pre>CREATE OR REPLACE OUTLINE default_abc_sqlj_0001 ON SELECT * FROM employees WHERE employee_id=:B1 /* default_abc_sqlj_0001 */;

CREATE OR REPLACE OUTLINE default_abc_sqlj_0002 ON SELECT * FROM departments /* default_abc_sqlj_0002 */;
</pre>
<p>You can use the following command to set the outline name to a particular prefix:</p>
<pre>%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=abccat -outlineprefix=pref1 abc.sqlj
Password: <span class="italic">password</span>
</pre>
<p>In this case, the generated SQL file <code>abc_sqlj.sql</code> looks as follows:</p>
<pre>CREATE OR REPLACE OUTLINE pref1_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id=:B1 /* pref1_0001 */&#39;;

CREATE OR REPLACE OUTLINE pref1_0002 FOR CATEGORY abccat ON SELECT * FROM departments /* pref1_0002 */&#39;;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To translate multiple files with the <code>outlineprefix</code> option, you can do the following:
<pre>%sqlj -outline=abccat -outlineprefix=pref1,pref2,pref3 abc.sqlj def.sqlj fgh.sqlj
</pre></div>
<p>Currently, the upper limit on the length of the outline name is 30 bytes. Hence, if the generated outline name exceeds 30 bytes, a SQLJ error &#34;<code>Outline name exceeds maximum limit. Use -outlineprefix option</code>&#34; is thrown. In such cases, if you want to use the <code>-outline</code> option, you need to call <code>-outlineprefix</code> option as shown in the preceding example. If you want database server to generate the outline names instead of the SQLJ generated outline names, then you can set the <code>-outlineprefix</code> option to <code>none.</code> For example:</p>
<pre>%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=abccat -outlineprefix=none abc.sqlj
Password: <span class="italic">password</span>
</pre>
<p>In this case, the generated SQL file <code>abc_sqlj.sql</code> looks as follows:</p>
<pre>CREATE OR REPLACE OUTLINE FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id=:B1 /* abccat_abc_sqlj_0001 */&#39;;

CREATE OR REPLACE OUTLINE FOR CATEGORY abccat ON SELECT * FROM departments /* abccat_abc_sqlj_0002 */&#39;;
</pre>
<p>If you want to translate multiple files with the <code>-outlineprefix</code> option, then you can use the following command:</p>
<pre>%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=abccat -outlineprefix=pref1,pref2 abc.sqlj def.sqlj
Password: <span class="italic">password</span>
</pre>
<p>If the SQLJ file is part of a package and you have not specified the <code>-outlineprefix</code> option, then the package name is appended to the outline name and is added to the comment. For example, if <code>abc.sqlj</code> is part of <code>xyz.def.fgh</code> package, then generated SQL file <code>abc_sqlj.sql</code>, for the command <code>%sqlj -url=jdbc:oracle:oci8:@ -user=HR/</code><code><span class="codeinlineitalic">password</span></code> <code>-outline=abccat abc.sqlj</code> looks as follows:</p>
<pre>CREATE OR REPLACE OUTLINE abccat_xyz$def$fgh$abc_sqlj_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id=:B1 
/* abccat_xyz$def$fgh$abc_sqlj_0001 */;

CREATE OR REPLACE OUTLINE abccat_xyz$def$fgh$abc_sqlj_0002 FOR CATEGORY abccat ON SELECT * FROM departments 
/* abccat_xyz$def$fgh$abc_sqlj_0002 */;
</pre>
<p>If you want the generated SQL file to be executed by the translator at the end of successful translation, then you can set the <code>runoutline</code> option to <code>true</code>. By default it is <code>false.</code> For example:</p>
<pre>%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=default -runoutline=true abc.sqlj
Password: <span class="italic">password</span>
</pre>
<p>Now, if you want to retrieve the outline name for exporting or for modifying the plan of the SQL code, then you can retrieve the same from the <code>OL$</code> table, either manually or by using a tool. You can use the comment in the SQL query to search for the appropriate SQL statement to identify the outline name because the comment uniquely identifies the SQL statement.</p>
<p><a href="#CBBEEECI">Table 7-1</a> shows all the options and values you can pass to the translator for generating outlines.</p>
<div id="JSQLJ595" class="tblhruleformal">
<p class="titleintable"><a id="sthref579"></a><a id="CBBEEECI"></a>Table 7-1 Table showing the options and values for generating outlines</p>
<table class="cellalignment4024" title="Table showing the options and values for generating outlines" summary="Table showing options and values for generating outlines" dir="ltr">
<thead>
<tr class="cellalignment4011">
<th class="cellalignment4021" id="r1c1-t74">Option Name</th>
<th class="cellalignment4021" id="r1c2-t74">Option Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r2c1-t74" headers="r1c1-t74">
<p><code>-outline</code></p>
</td>
<td class="cellalignment4017" headers="r2c1-t74 r1c2-t74">
<p><code>true</code>&lt;category name&gt;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r3c1-t74" headers="r1c1-t74">
<p><code>-outlineprefix</code></p>
</td>
<td class="cellalignment4017" headers="r3c1-t74 r1c2-t74">
<p><code>none</code>&lt;prefix name&gt;|<code>none</code>&lt;prefix name 1, prefix name 2,&hellip;&gt;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r4c1-t74" headers="r1c1-t74">
<p><code>-runoutline</code></p>
</td>
<td class="cellalignment4017" headers="r4c1-t74 r1c2-t74">
<p><code>true</code>|<code>false</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01305" href="../SQLRF/statements_6006.htm#SQLRF01305"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about outlines.</div>
<p class="subhead2"><a id="JSQLJ596"></a>Generated LOG File Name</p>
<p>The format of the generated file name is:</p>
<pre>&lt;filename&gt;_&lt;filetype&gt;.log
</pre>
<p>For example, on translating <code>abc.sqlj</code>, the generated log file is <code>abc_sqlj.log.</code></p>
<p class="subhead2"><a id="JSQLJ597"></a>Generated LOG File Format</p>
<p>Suppose, you have the following code snippet:</p>
<pre>#sql iter = {SELECT * FROM employees WHERE employee_id=:var };
#sql iter1 = {SELECT * FROM departments };
</pre>
<p>The generated log file for the preceding code snippet is as follows:</p>
<pre>CATERGORY abccat
Source SQL_1
SELECT * FROM employees WHERE employee_id=:B1
OUTLINE NAME
abccat_abc_sqlj_0001
OUTLINE SQL_1
CREATE OR REPLACE OUTLINE abccat_abc_sqlj_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id = :B1 
/* abccat_abc_sqlj_0001 */
STATUS success
Source SQL_2
SELECT * FROM departments
OUTLINE NAME
abccat_abc_sqlj_0002
OUTLINE SQL_2
CREATE OR REPLACE OUTLINE abccat_abc_sqlj_2 FOR abccat ON SELECT * FROM departments
/* abccat_abc_sqlj_2 */
STATUS fail
</pre>
<p>In the preceding example of the generated log file format:</p>
<ul>
<li>
<p>Category means the category of the outline to be generated</p>
</li>
<li>
<p>Source means the SQL statements for which outline is to be generated</p>
</li>
<li>
<p>Outline Name is the name of the outline to be generated</p>
</li>
<li>
<p>Status is the execution status of the SQL statements used as the source. If the execution is successful, then status is <code>success.</code> Otherwise, it is <code>fail.</code></p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ598"></a><a id="sthref580"></a>Configuration Files</p>
<p>You can set the different command-line options in the configuration file as follows:</p>
<p class="subhead2"><a id="JSQLJ599"></a>sqlj.outline</p>
<ul>
<li>
<p>Parameter Name: <code>outline</code></p>
</li>
<li>
<p>Parameter Type: String</p>
</li>
<li>
<p>Allowable Values: {true|category_name}</p>
</li>
<li>
<p>Default Value: true</p>
</li>
<li>
<p>Description: Indicates that outline SQL file needs to be generated for the SQL statements and it should be in:</p>
<ul>
<li>
<p>DEFAULT category if the value is default, that is, <code>true</code></p>
</li>
<li>
<p>The category name if <span class="italic">category_name</span> is mentioned</p>
</li>
</ul>
<p>Outline SQL file is not generated if this option is not used.</p>
</li>
<li>
<p>Dependency on other parameters: Online check should be full when this option is turned on</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ600"></a>sqlj.runoutline</p>
<ul>
<li>
<p>Parameter Name: <code>runoutline</code></p>
</li>
<li>
<p>Parameter Type: boolean</p>
</li>
<li>
<p>Allowable Values: {true|false}</p>
</li>
<li>
<p>Default Value: false</p>
</li>
<li>
<p>Description: If <code>runoutline=true</code> then the generated SQL file should be executed by the translator at the end of successful translation.</p>
</li>
<li>
<p>Dependency on other parameters: Online check should be full when this option is turned on, and the outline option should be set.</p>
</li>
</ul>
<p class="subhead2"><a id="CHDFFGHI"></a><a id="JSQLJ601"></a>sqlj.outlineprefix</p>
<ul>
<li>
<p>Parameter Name: <code>outlineprefix</code></p>
</li>
<li>
<p>Parameter Type: String</p>
</li>
<li>
<p>Allowable Values: {prefix name}, none</p>
</li>
<li>
<p>Description: If this option is set, the outline name in the generated SQL is set to <code>&lt;prefix&gt;_&lt;seqno&gt;</code>. When this option is set to any value apart from <code>none</code> in the properties file, only one SQLJ file may be passed to the translator. If the option is set to <code>none</code>, outline name is generated by the system when the <code>create outline</code> statement is executed in the server. Also, you may pass multiple files to the translator when <code>&ndash;outlineprefix</code> is set to none.</p>
</li>
<li>
<p>Dependency on other parameters: Online check should be full when this option is turned on, and the outline option should be set.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDBIAIA"></a>
<div id="JSQLJ889" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref581"></a>Using Plan Baselines</h2>
<p>Starting from Oracle Database 12<span class="italic">c</span> Release 1, SQLJ supports the creation of plan baselines using Oracle Database SQL Plan Management (SPM). You can generate plan baselines at the time of translating the SQLJ files. The necessary SQL statements to create the plan baselines are generated in the <code>.sql</code> files. You can review, tune, and fix the plan baselines before deploying the SQLJ application.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink TGSQL615" href="../TGSQL/tgsql_spm.htm#TGSQL615"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for more information about plan baselines</div>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDCGDBJ">Generating Plan Baselines</a></p>
</li>
<li>
<p><a href="#CHDIFDDD">Command-Line and Property File Options</a></p>
</li>
</ul>
<a id="CHDCGDBJ"></a>
<div id="JSQLJ890" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Generating Plan Baselines</h3>
<p>You can generate plan baselines for all the SQL statements that are supported by SPM. The generated log file reports the unsupported statements, if any.</p>
<p class="subhead2"><a id="JSQLJ891"></a><a id="sthref582"></a>Parameters</p>
<p>When specifying plan baseline options, SQLJ generates SQL files with calls to the <code>dbms_spm_internal.create_sql_plan_baseline</code> procedure. This procedure has the following parameters:</p>
<div class="inftblhruleinformal">
<table class="cellalignment4024" summary="This table describes the parameters of create_sql_plan procedure" dir="ltr">
<thead>
<tr class="cellalignment4011">
<th class="cellalignment4021" id="r1c1-t77">Parameter</th>
<th class="cellalignment4021" id="r1c2-t77">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r2c1-t77" headers="r1c1-t77"><code>SQL_TEXT</code></td>
<td class="cellalignment4017" headers="r2c1-t77 r1c2-t77">Specifies the SQL text for which the plan baseline needs to be created.</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r3c1-t77" headers="r1c1-t77"><code>PARSING_SCHEMA</code></td>
<td class="cellalignment4017" headers="r3c1-t77 r1c2-t77">Specifies the schema that is used for semantic checking of the SQL text passed.</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r4c1-t77" headers="r1c1-t77"><code>PLAN_NAME</code></td>
<td class="cellalignment4017" headers="r4c1-t77 r1c2-t77">Specifies the name of the plan baseline. This parameter is optional. If this parameter is not specified, then the default plan name is <code>default.</code></td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r5c1-t77" headers="r1c1-t77"><code>ENABLED</code></td>
<td class="cellalignment4017" headers="r5c1-t77 r1c2-t77">Specifies whether the plan is to be enabled or not. Default value is <code>yes</code>.</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r6c1-t77" headers="r1c1-t77"><code>FIXED</code></td>
<td class="cellalignment4017" headers="r6c1-t77 r1c2-t77">Specifies whether the plan will be a fixed plan or not. Default value is <code>no</code>.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>To generate and execute the plan baseline SQL statements, you must have the <code>Execute</code> privilege on the <code>DBMS_SPM_INTERNAL</code> package and the <code>Administer</code> <code>SQL</code> <code>Management</code> <code>Object</code> privilege.</p>
</li>
<li>
<p>The plan baseline options are valid only if online semantic checking is done. If you specify these options with offline semantic checking, then the options are ignored and a warning is thrown informing that the options should be used with online semantic checking only.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDIFDDD"></a>
<div id="JSQLJ892" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref583"></a><a id="sthref584"></a>Command-Line and Property File Options</h3>
<p>Use the following command-line options for generating plan baseline SQL statements:</p>
<ul>
<li>
<p><a href="#CHDBGEIF">plan_baseline</a></p>
</li>
<li>
<p><a href="#CHDGFGCH">plan_prefix</a></p>
</li>
<li>
<p><a href="#CHDGBIHC">plan_run</a></p>
</li>
<li>
<p><a href="#CHDBFIFH">plan_fixed</a></p>
</li>
<li>
<p><a href="#CHDHJDCI">plan_enabled</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The generated files specify the appropriate user to run the files. For example, the following statements in a generated file specify that <code>HR</code> can run the file:
<pre>var ORA_SPM_PARSE_SCHEMA varchar2(30);
exec :ORA_SPM_PARSE_SCHEMA:=&#39;HR&#39;;
</pre></div>
<a id="CHDBGEIF"></a>
<div id="JSQLJ893" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">plan_baseline</h4>
<p>Use the <code>plan_baseline</code> option to specify whether baseline plans should be generated for all the SQL statements in the SQL file or not. If you set this option to <code>true</code>, then <code>default</code> is used as the baseline name. The baseline name is the equivalent to the category name when you use outlines. The value you provide for this option is used as the module name when running the SQL file.</p>
<p>The name of the SQL file is translated with a sequence number and the combination is used to uniquely identify each SQL statement in the SQL file. This combination is also used as the name of the plan. The sequence number can vary from 0 to 9999. The format of the plan name is as follows:</p>
<pre>&lt;filename&gt;_&lt;filetype&gt;_&lt;sequence_no&gt;
</pre>
<p class="subhead2"><a id="JSQLJ894"></a>Syntax</p>
<p>In command-line, the <code>plan_baseline</code> option is specified as the following:</p>
<pre>-plan_baseline= &lt;true/false/module_name&gt;
</pre>
<p>In the property file, the <code>plan_baseline</code> option is specified as the following:</p>
<pre>sqlj.plan_baseline=&lt;true/false/module_name&gt;
</pre>
<p class="subhead2"><a id="JSQLJ895"></a>Default Value</p>
<p>The default value for the <code>plan_baseline</code> option is <code>false</code>, in which case the plan baselines are not generated. If you specify the value <code>true</code> for this option, the module name is <code>default.</code></p>
<p class="subhead2"><a id="JSQLJ896"></a>Example</p>
<pre>sqlj test.sqlj &ndash;plan_baseline=true -user=HR/hr
</pre>
<p>If the <code>test.sqlj</code> is a part of a package named <code>mypackage</code> and contains only the following two SQL statements:</p>
<pre>Select first_name from employees;
Select employee_id from employees;
</pre>
<p>Then, the content of the generated SQL file is:</p>
<pre>var ORA_SPM_PARSE_SCHEMA varchar2(30);
exec :ORA_SPM_PARSE_SCHEMA:=&#39;HR&#39;;
begin
    dbms_application_info.set_module(&amp;rsquor;default&#39;,&#39;&#39;);
end;
 
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; &#39;mypackage_test_sqlj_0000&#39;) ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   &#39;Select first_name from employees /*mypackage_test_sqlj_0000*/&#39;, 
   :ORA_SPM_PARSE_SCHEMA, 
   &#39;mypackage_test_sqlj_0000&#39;, 
   &#39;no&#39;, 
   &#39;no&#39;); 
END ; 
/
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; &#39;mypackage_test_sqlj_0001&#39;) ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   &#39;Select employee_id from employees /*mypackage_test_sqlj_0001*/&#39;, 
   :ORA_SPM_PARSE_SCHEMA, 
   &#39;mypackage_test_sqlj_0001&#39;, 
   &#39;no&#39;, 
   &#39;no&#39;); 
END ; 
/
</pre>
<p>If the <code>test.sqlj</code> contains only the following two SQL statements:</p>
<pre>Select first_name from employees;
Select employee_id from employees;
</pre>
<p>And you provide an SPM plan name as the following:</p>
<pre>sqlj &ndash;plan_name=mybaseline -user=HR/hr test.sqlj
</pre>
<p>Then, the content of the generated SQL file is:</p>
<pre>var ORA_SPM_PARSE_SCHEMA varchar2(30) ; 
exec :ORA_SPM_PARSE_SCHEMA:=&#39;HR&#39;; 
begin
    dbms_application_info.set_module(&amp;rsquor;mybaseline,&#39;&#39;);
end;
 
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; &#39;mypackage_test_sqlj_0000&#39;) ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   &#39;Select first_name from employees /*mypackage_test_sqlj_0000*/&#39;, 
   :ORA_SPM_PARSE_SCHEMA, 
   &#39;mypackage_test_sqlj_0000&#39;, 
   &#39;no&#39;, 
   &#39;no&#39;); 
END ; 
/
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; &#39;mypackage_test_sqlj_0001&#39;) ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   &#39;Select employee_id from employees /*mypackage_test_sqlj_0001*/&#39;, 
   :ORA_SPM_PARSE_SCHEMA, 
   &#39;mypackage_test_sqlj_0001&#39;, 
   &#39;no&#39;, 
   &#39;no&#39;); 
END ; 
/
</pre></div>
<!-- class="sect3" -->
<a id="CHDGFGCH"></a>
<div id="JSQLJ897" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">plan_prefix</h4>
<p>Use the <code>plan_prefix</code> option to specify a name for the plan. This corresponds to the <code>PLAN_NAME</code> argument of the <code>create_sql_plan_baseline</code> procedure. If you do not use this option, then a plan name is generated automatically.</p>
<p class="subhead2"><a id="JSQLJ898"></a>Syntax</p>
<p>In command-line, the <code>plan_prefix</code> option is specified as the following:</p>
<pre>-plan_prefix=&lt;name&gt;
</pre>
<p>In the property file, the <code>plan_prefix</code> option is specified as the following:</p>
<pre>sqlj.plan_prefix=&lt;name&gt;
</pre>
<p class="subhead2"><a id="JSQLJ899"></a>Default Value</p>
<p>The value for the <code>plan_prefix</code> option is <code>none</code>. If you specify any other value for this option, then the format of the plan name becomes the following:</p>
<pre>&lt;name&gt;_&lt;sequence_no&gt;
</pre>
<p class="subhead2"><a id="JSQLJ900"></a>Example</p>
<p><code>sqlj test.sqlj &ndash;plan_baseline=mybaseline true -user=HR/hr &ndash;plan_prefix=myprefix</code></p>
<p>Suppose, <code>test.sqlj</code> contains only the following two SQL statements:</p>
<pre>Select first_name from employees;
Select employee_id from employees;
</pre>
<p>Then, the content of the generated SQL file is:</p>
<pre>var ORA_SPM_PARSE_SCHEMA varchar2(30);
exec :ORA_SPM_PARSE_SCHEMA:=&#39;HR&#39;;
begin
    dbms_application_info.set_module(&amp;rsquor;default&#39;,&#39;&#39;);
end;
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; &#39;myprefix_0000&#39;) ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   &#39;Select first_name from employees /*myprefix_0000*/&#39;, 
   :ORA_SPM_PARSE_SCHEMA, 
   &#39;myprefix_0000&#39;, 
   &#39;no&#39;, 
   &#39;no&#39;); 
END ; 
/
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; &#39;myprefix_0001&#39;) ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   &#39;Select employee_id from employees /*myprefix_0001*/&#39;, 
   :ORA_SPM_PARSE_SCHEMA, 
   &#39;myprefix_0001&#39;, 
   &#39;no&#39;, 
   &#39;no&#39;); 
END ; 
</pre></div>
<!-- class="sect3" -->
<a id="CHDGBIHC"></a>
<div id="JSQLJ901" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">plan_run</h4>
<p>Use the <code>plan_run</code> option to specify if you want SQLJ to execute the generated SQL file at the end of translation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You <span class="italic">must</span> have the following privileges to execute the generated SQL file:
<ul>
<li>
<p>Execute privilege on the <code>DBMS_SPM_INTERNAL</code> package</p>
</li>
<li>
<p>Administer SQL Management Object privilege</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JSQLJ902"></a>Syntax</p>
<p>In command-line, the <code>plan_run</code> option is specified as the following:</p>
<pre>-plan_run=&lt;yes|no&gt;
</pre>
<p>In the property file, the <code>plan_run</code> option is specified as the following:</p>
<pre>sqlj.plan_run=&lt;yes|no&gt;
</pre>
<p class="subhead2"><a id="JSQLJ903"></a>Default Value</p>
<p>This default value for the <code>plan_run</code> option is <code>yes</code>.</p>
</div>
<!-- class="sect3" -->
<a id="CHDBFIFH"></a>
<div id="JSQLJ904" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">plan_fixed</h4>
<p>Use the <code>plan_fixed</code> option to specify whether the generated baseline should be fixed or not.</p>
<p class="subhead2"><a id="JSQLJ905"></a>Syntax</p>
<p>In command-line, the <code>plan_fixed</code> option is specified as the following:</p>
<pre>-plan_fixed = &lt;yes|no&gt;
</pre>
<p>In the property file, the <code>plan_fixed</code> option is specified as the following:</p>
<pre>sqlj.plan_fixed=&lt;yes|no&gt;
</pre>
<p class="subhead2"><a id="JSQLJ906"></a>Default Value</p>
<p>This default value for this option is <code>yes</code>.</p>
</div>
<!-- class="sect3" -->
<a id="CHDHJDCI"></a>
<div id="JSQLJ907" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">plan_enabled</h4>
<p>Use the <code>plan_enabled</code> option to specify whether the generated baseline should be enabled or not.</p>
<p class="subhead2"><a id="JSQLJ908"></a>Syntax</p>
<p>In command-line, the <code>plan_enabled</code> option is specified as the following:</p>
<pre>-plan_enabled = &lt;yes|no&gt;
</pre>
<p>In the property file, the <code>plan_enabled</code> option is specified as the following:</p>
<pre>sqlj.plan_enabled=&lt;yes|no&gt;
</pre>
<p class="subhead2"><a id="JSQLJ909"></a>Default Value</p>
<p>This default value for this option is <code>yes</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="JSQLJ910" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref585"></a>
<h3 class="sect2"><a id="sthref586"></a>Generated SQL File</h3>
<p>At the end of precompilation of the SQLJ file with options described in <a href="#CHDIFDDD">Command-Line and Property File Options</a>, a SQL file is generated. This SQL file contains the SQL statements for creating SPM plans for each SQL statement in the SQLJ file.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDGEHCE">Generated SQL File Name</a></p>
</li>
<li>
<p><a href="#CHDEDDGH">Generated SQL File Format</a></p>
</li>
</ul>
<a id="CHDGEHCE"></a>
<div id="JSQLJ911" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Generated SQL File Name</h4>
<p>The name of the generated SQL file is in the following format:</p>
<pre>&lt;filename&gt;_&lt;filetype&gt;_bln.sql
</pre>
<p>For SQLJ, the file type is always <code>.sqlj</code>. So, the name of the SQL file is always in the following format:</p>
<pre>&lt;filename&gt;_sqlj_bln.sql
</pre></div>
<!-- class="sect3" -->
<a id="CHDEDDGH"></a>
<div id="JSQLJ912" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Generated SQL File Format</h4>
<p>Suppose, the <code>test.sqlj</code> file is a part of the package <code>mypackage</code> and it contains the following SQL statements:</p>
<pre>#sql  {select * from employees };
#sql  {select manager_id from employees };
</pre>
<p>If you precompile the file with the following command:</p>
<pre>sqlj test.sqlj &ndash;plan_baseline=mybaseline &ndash;plan_prefix=myprefix -userid=HR/hr
</pre>
<p>Then the content of the generated SQL file <code>mypackage_test_sqlj_bln.sql</code> is:</p>
<pre>var ORA_SPM_PARSE_SCHEMA varchar2(30) ;
exec :ORA_SPM_PARSE_SCHEMA:=&#39;HR&#39;;
begin
    dbms_application_info.set_module(&amp;rsquor;default&#39;,&#39;&#39;);
end;
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; &#39;myprefix_0000&#39;) ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   &#39;Select first_name from employees /*myprefix_0000*/&#39;, 
   :ORA_SPM_PARSE_SCHEMA, 
   &#39;myprefix_0000&#39;, 
   &#39;no&#39;, 
   &#39;no&#39;); 
END ; 
/
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; &#39;myprefix_0001&#39;) ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   &#39;Select employee_id from employees /*myprefix_0001*/&#39;, 
   :ORA_SPM_PARSE_SCHEMA, 
   &#39;myprefix_0001&#39;, 
   &#39;no&#39;, 
   &#39;no&#39;); 
END ;

</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The sequence number 0000 and 0001 are used to uniquely identify the plan name for each SQL statement.</p>
</li>
<li>
<p>If you specify a value other than <code>none</code> with the <code>plan_prefix</code> option, then the prefix value is used instead of the value that is specified with the <code>&ndash;plan_baseline</code> option.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="JSQLJ913" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref587"></a>
<h3 class="sect2"><a id="sthref588"></a>Generated Log File</h3>
<p>At the end of precompilation a SQL file is generated. This section describes the following details of the log file:</p>
<ul>
<li>
<p><a href="#CHDEHIED">Generated Log File Name</a></p>
</li>
<li>
<p><a href="#CHDFADJF">Generated Log File Format</a></p>
</li>
</ul>
<a id="CHDEHIED"></a>
<div id="JSQLJ914" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Generated Log File Name</h4>
<p>The name of the generated log file is in the following format:</p>
<pre>&lt;filename&gt;_&lt;filetype&gt;_bln.log
</pre>
<p>For SQLJ, the file type is always <code>.sqlj</code>. So, the name of the SQL file is always in the following format:</p>
<pre>&lt;filename&gt;_sqlj_bln.log
</pre></div>
<!-- class="sect3" -->
<a id="CHDFADJF"></a>
<div id="JSQLJ915" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Generated Log File Format</h4>
<p>Suppose, the <code>test.sqlj</code> file is a part of the package <code>mypackage</code> and it contains the following SQL statements:</p>
<pre>#sql  {select * from employees };
#sql  {select manager_id from employees };
</pre>
<p>If you precompile the file with the following command:</p>
<pre>sqlj test.sqlj &ndash;plan_baseline=true userid=HR/hr
</pre>
<p>Then the content of the generated log file is:</p>
<pre>MODULE default 
    SOURCE SQL_0
       select * from employees;
    PLAN NAME 
       mypackage_test_sqlj_0000 
    STATUS Success 
 
/******************************************/ 
/******************************************/ 
MODULE default 
    SOURCE SQL_1
       select manager_id from employees 
    PLAN NAME 
       mypackage_test_sqlj_0001 
    STATUS Success 
 
/******************************************/

</pre>
<p>If you precompile the file with the following command:</p>
<pre>sqlj test.sqlj &ndash;plan_baseline=true  userid=HR/hr &ndash;plan_prefix=myprefix
</pre>
<p>Then the content of the generated log file is:</p>
<pre>MODULE default 
    SOURCE SQL_0
       select * from employees;
    PLAN NAME 
       myprefix_0000 
    STATUS Success 
 
/******************************************/ 
/******************************************/ 
MODULE default 
    SOURCE SQL_1
       select manager_id from employees 
    PLAN NAME 
       myprefix_0001 
    STATUS Success 
 
/******************************************/
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="JSQLJ916" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref589"></a>
<h3 class="sect2"><a id="sthref590"></a>Generated Java File</h3>
<p>At the end of precompilation a Java file is generated.</p>
<p>Suppose, the <code>test.sqlj</code> file is a part of the package <code>mypackage</code> and it contains the following SQL statements:</p>
<pre>#sql {select * from employees };
</pre>
<p>If you precompile the file with the following command:</p>
<pre>sqlj test.sqlj &ndash;plan_baseline=mybaseline &ndash;plan_prefix=myprefix -userid=HR/hr
</pre>
<p>Then the generated Java file has an identifier appended to the SQL statement as follows:</p>
<pre>try {
   String theSqlTS = &#34;select first_name from employees  /*mybaseline_test_sqlj_0001*/&#34;;
   __sJT_st = __sJT_ec.prepareOracleStatement(__sJT_cc,&#34;0Select&#34;,theSqlTS);
   // execute query
   iter = new Iter(new sqlj.runtime.ref.OraRTResultSet(__sJT_ec.oracleExecuteQuery(),__sJT_st,&#34;0Select&#34;,null));
  } finally { __sJT_ec.oracleCloseQuery(); }
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4010">
<tr>
<td class="cellalignment4017">
<table class="cellalignment4015">
<tr>
<td class="cellalignment4014"><a href="objcoll.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4014"><a href="transopt.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4019">
<table class="cellalignment4013">
<tr>
<td class="cellalignment4014"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4014"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4014"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4014"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4014"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4014"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>