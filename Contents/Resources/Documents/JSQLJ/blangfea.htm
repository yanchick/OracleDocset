<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-72361"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Basic%20Language%20Features"></a><title>Basic Language Features</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743"/>
<meta name="dcterms.created" content="2013-12-02T6:55:14Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SQLJ Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17660-12"/>
<meta name="dcterms.isVersionOf" content="JSQLJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="keyprog.htm" title="Previous" type="text/html"/>
<link rel="Next" href="typesupp.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E17660-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/20</span> <!-- End Header -->
<div id="JSQLJ270" class="chapter"><a id="CBBFFFHF"></a> <a id="i1009466"></a>
<h1 class="chapter"><span class="secnum">4</span> Basic Language Features</h1>
<p>SQLJ statements always begin with a <code>#sql</code> token and can be broken into two main categories:</p>
<ul>
<li>
<p>Declarations: Used for creating Java classes for iterators, which is similar to Java Database Connectivity (JDBC) result sets, or connection contexts, which is designed to help you create strongly typed connections according to the sets of SQL entities being used.</p>
</li>
<li>
<p>Executable statements: Used to execute embedded SQL operations.</p>
</li>
</ul>
<p>This chapter discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1005585">Overview of SQLJ Declarations</a></p>
</li>
<li>
<p><a href="#i1009165">Overview of SQLJ Executable Statements</a></p>
</li>
<li>
<p><a href="#i1006176">Java Host, Context, and Result Expressions</a></p>
</li>
<li>
<p><a href="#i1006673">Single-Row Query Results: SELECT INTO Statements</a></p>
</li>
<li>
<p><a href="#i1006767">Multirow Query Results: SQLJ Iterators</a></p>
</li>
<li>
<p><a href="#i1007454">Assignment Statements (SET)</a></p>
</li>
<li>
<p><a href="#i1007491">Stored Procedure and Function Calls</a></p>
</li>
</ul>
<a id="i1005585"></a>
<div id="JSQLJ271" class="sect1">
<h2 class="sect1">Overview of SQLJ <a id="sthref155"></a>Declarations</h2>
<p>A SQLJ declaration consists of the <code>#sql</code> token followed by the declaration of a class. SQLJ declarations introduce specialized Java types into your application. There are currently two kinds of SQLJ declarations, iterator declarations and connection context declarations, defining Java classes as follows:</p>
<ul>
<li>
<p>Iterator declarations define iterator classes. Iterators are conceptually similar to JDBC result sets and are used to receive multi-row query data. An iterator is implemented as an instance of an iterator class.</p>
</li>
<li>
<p>Connection context declarations define connection context classes. Each connection context class is typically used for connections whose operations use a particular set of SQL entities, such as tables, views, and stored procedures. That is to say, instances of a particular connection context class are used to connect to schemas that include SQL entities with the same names and characteristics. SQLJ implements each database connection as an instance of a connection context class.</p>
<p>SQLJ includes the predefined <code>sqlj.runtime.DefaultContext</code> connection context class. If you only require one connection context class, then you can use <code>DefaultContext</code>, which does not require a connection context declaration.</p>
</li>
</ul>
<p>In any iterator or connection context declaration, you may optionally include the following clauses:</p>
<ul>
<li>
<p>The <code>implements</code> clause: Specifies one or more interfaces that the generated class will implement.</p>
</li>
<li>
<p>The <code>with</code> clause: Specifies one or more initialized constants to be included in the generated class.</p>
</li>
</ul>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDIIBEE">Rules for SQLJ Declarations</a></p>
</li>
<li>
<p><a href="#CHDBAFGJ">Iterator Declarations</a></p>
</li>
<li>
<p><a href="#CHDDCAJE">Connection Context Declarations</a></p>
</li>
<li>
<p><a href="#i1005681">Declaration IMPLEMENTS Clause</a></p>
</li>
<li>
<p><a href="#CBBBBJEC">Declaration WITH Clause</a></p>
</li>
</ul>
<a id="CHDIIBEE"></a>
<div id="JSQLJ272" class="sect2">
<h3 class="sect2">Rules for SQLJ Declarations</h3>
<p>SQLJ declarations are allowed in your SQLJ source code anywhere that a class definition would be allowed in standard Java. For example:</p>
<pre><span class="italic">SQLJ declaration</span>;   // OK (top level scope)

class Outer
{
   <span class="italic">SQLJ declaration</span>; // OK (class level scope)

   class Inner
   {
      <span class="italic">SQLJ declaration</span>; // OK (nested class scope)
   }

   void func()
   {
      <span class="italic">SQLJ declaration</span>; // OK (method block)
   }
}
</pre>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
As with standard Java, any public class should be declared in one of the following ways:
<ul>
<li>
<p>Declare it in a separate source file. The base name of the file should be the same as the class name.</p>
</li>
<li>
<p>Declare it at class-level scope or nested-class-level scope. In this case, it may be advisable to use <code>public static</code> modifiers.</p>
</li>
</ul>
<p>This is a requirement if you are using the standard <code>javac</code> compiler provided with the Sun Microsystems JDK.</p>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDBAFGJ"></a>
<div id="JSQLJ273" class="sect2">
<h3 class="sect2">Iterator <a id="sthref156"></a><a id="sthref157"></a>Declarations</h3>
<p>An iterator declaration creates a class that defines a kind of iterator for receiving query data. The declaration will specify the column types of the iterator instances, which must match the column types being selected from the database table.</p>
<p>Basic iterator declarations use the following syntax:</p>
<pre>#sql &lt;<span class="italic">modifiers</span>&gt; iterator<span class="italic"> iterator_classname</span> (<span class="italic">type declarations</span>);
</pre>
<p>Modifiers are optional and can be any standard Java class modifiers, such as <code>public</code>, <code>static</code>, and so on. Type declarations are separated by commas.</p>
<p>There are two categories of iterators, named iterators and positional iterators. For named iterators, you must specify column names and types. For positional iterators, you need to specify only types.</p>
<p>The following is an example of a named iterator declaration:</p>
<pre>#sql public iterator EmpIter (String ename, double sal);
</pre>
<p>This statement results in the SQLJ translator creating a public <code>EmpIter</code> class with a <code>String</code> attribute <code>ename</code> and a <code>double</code> attribute <code>sal</code>. You can use this iterator to select data from a database table with corresponding employee name and salary columns of matching names (<code>ENAME</code> and <code>SAL</code>) and data types (<code>CHAR</code> and <code>NUMBER</code>).</p>
<p>Declaring <code>EmpIter</code> as a positional iterator, instead of a named iterator, can be done as follows:</p>
<pre>#sql public iterator EmpIter (String, double);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006767">&#34;Multirow Query Results: SQLJ Iterators&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDDCAJE"></a>
<div id="JSQLJ274" class="sect2">
<h3 class="sect2">Connection Context <a id="sthref158"></a><a id="sthref159"></a>Declarations</h3>
<p>A connection context declaration creates a connection context class, whose instances are typically used for database connections that use a particular set of SQL entities. Basic connection context declarations use the following syntax:</p>
<pre>#sql &lt;<span class="italic">modifiers</span>&gt; context<span class="italic"> context_classname</span>;
</pre>
<p>As for iterator declarations, modifiers are optional and can be any standard Java class modifiers. For example:</p>
<pre>#sql public context MyContext;
</pre>
<p>As a result of this statement, the SQLJ translator creates a public <code>MyContext</code> class. In your SQLJ code you can use instances of this class to create database connections to schemas that include a desired set of entities, such as tables, views, and stored procedures. Different instances of <code>MyContext</code> might be used to connect to different schemas, but each schema might be expected, for example, to include an <code>EMPLOYEES</code> table, a <code>DEPARTMENTS</code> table, and a <code>SECURE_EMPLOYEES</code> stored procedure.</p>
<p>Declared connection context classes are an advanced topic and are not necessary for basic SQLJ applications that use only one interrelated set of SQL entities. In basic scenarios, you can use multiple connections by creating multiple instances of the <code>sqlj.runtime.ref.DefaultContext</code> class, which does not require any connection context declarations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1005714">&#34;Connection Considerations&#34;</a> and <a href="alangfea.htm#i1005583">&#34;Connection Contexts&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1005681"></a>
<div id="JSQLJ275" class="sect2">
<h3 class="sect2">Declaration <a id="sthref160"></a><a id="sthref161"></a>IMPLEMENTS Clause</h3>
<p>When you declare any iterator class or connection context class, you can specify one or more interfaces to be implemented by the generated class.</p>
<p>Use the following syntax for an iterator class:</p>
<pre>#sql &lt;<span class="italic">modifiers</span>&gt; iterator<span class="italic"> iterator_classname</span> implements <span class="italic">intfc1</span>,..., <span class="italic">intfcN</span> 
     (<span class="italic">type declarations</span>);
</pre>
<p>The portion <code>implements</code> <code><span class="codeinlineitalic">intfc1,..., intfcN</span></code> is known as the <code>implements</code> clause. Note that in an iterator declaration, the <code>implements</code> clause precedes the iterator type declarations.</p>
<p>Here is the syntax for a connection context declaration:</p>
<pre>#sql &lt;<span class="italic">modifiers</span>&gt; context<span class="italic"> context_classname </span>implements <span class="italic">intfc1</span>,..., <span class="italic">intfcN</span>;
</pre>
<p>The <code>implements</code> clause is potentially useful in either an iterator declaration or a connection context declaration, but is more likely to be useful in iterator declarations, particularly in implementing the <code>sqlj.runtime.Scrollable</code> or <code>sqlj.runtime.ForUpdate</code> interface. Scrollable iterators are supported in the Oracle SQLJ implementation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The SQLJ <code>implements</code> clause corresponds to the Java <code>implements</code> clause.</div>
<p>The following example uses an <code>implements</code> clause in declaring a named iterator class. Presume you have created a package, <code>mypackage</code>, that includes an iterator interface, <code>MyIterIntfc</code>.</p>
<pre>#sql public iterator MyIter implements mypackage.MyIterIntfc 
     (String ename, int empno);
</pre>
<p>The declared class <code>MyIter</code> will implement the <code>mypackage.MyIterIntfc</code> interface.</p>
<p>The following example declares a connection context class that implements an interface named <code>MyConnCtxtIntfc</code>. Presume that it is in the package <code>mypackage</code>.</p>
<pre>#sql public context MyContext implements mypackage.MyConnCtxtIntfc;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006680">&#34;Using the IMPLEMENTS Clause in Iterator Declarations&#34;</a> and <a href="alangfea.htm#i1005906">&#34;Using the IMPLEMENTS Clause in Connection Context Declarations&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="CBBBBJEC"></a>
<div id="JSQLJ276" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Declaration <a id="sthref162"></a><a id="sthref163"></a>WITH Clause</h3>
<p>In declaring a connection context class or iterator class, you can use a <code>with</code> clause to specify and initialize one or more constants to be included in the definition of the generated class. Most of this usage is standard, although Oracle implementation adds some extended functionality for iterator declarations.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1008927">Standard WITH Clause Usage</a></p>
</li>
<li>
<p><a href="#i1008750">Oracle-Specific WITH Clause Usage</a></p>
</li>
<li>
<p><a href="#i1008976">Example: Returnability</a></p>
</li>
</ul>
<a id="i1008927"></a>
<div id="JSQLJ277" class="sect3">
<h4 class="sect3">Standard WITH Clause Usage</h4>
<p>In using a <code>with</code> clause, the constants that are produced are always <code>public static final</code>. Use the following syntax for an iterator class:</p>
<pre>#sql &lt;<span class="italic">modifiers</span>&gt; iterator<span class="italic"> iterator_classname</span> with (<span class="italic">var1</span>=<span class="italic">value1</span>,..., <span class="italic">varN</span>=<span class="italic">valueN</span>)
     (<span class="italic">type declarations</span>);
</pre>
<p>The portion <code>with</code> <code>(</code><code><span class="codeinlineitalic">var1=value1,..., varN=valueN</span></code>) is the <code>with</code> clause. Note that in an iterator declaration, the <code>with</code> clause precedes the iterator type declarations.</p>
<p>Where there is both a <code>with</code> clause and an <code>implements</code> clause, the <code>implements</code> clause must come first. Note that parentheses are used to enclose <code>with</code> lists, but not <code>implements</code> lists.</p>
<p>Here is the syntax for a connection context declaration that uses a <code>with</code> clause:</p>
<pre>#sql &lt;<span class="italic">modifiers</span>&gt; context<span class="italic"> context_classname </span>with (<span class="italic">var1</span>=<span class="italic">value1</span>,..., <span class="italic">varN</span>=<span class="italic">valueN</span>);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
A predefined set of standard SQLJ constants can be defined in a <code>with</code> clause. However, not all of these constants are meaningful to Oracle Database 12<span class="italic">c</span> Release 1 (12.1) or to Oracle SQLJ run time.
<p>Attempts to define constants other than the standard constants is legal with Oracle Database 12<span class="italic">c</span> Release 1 (12.1), but might not be portable to other SQLJ implementations and will generate a warning if you have the <code>-warn=portable</code> flag enabled. For information about this flag, refer to <a href="transopt.htm#i1007284">&#34;Translator Warnings (-warn)&#34;</a>.</p>
</div>
<p class="subhead2"><a id="JSQLJ278"></a>Supported WITH Clause Constants</p>
<p>The Oracle SQLJ implementation supports the following standard constants in connection context declarations:</p>
<ul>
<li>
<p><code><a id="sthref164"></a>typeMap</code>: a <code>String</code> literal defining the name of a type map properties resource</p>
<p>Oracle also supports the use of <code>typeMap</code> in iterator declarations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1008750">&#34;Oracle-Specific WITH Clause Usage&#34;</a></div>
</li>
<li>
<p><code><a id="sthref165"></a>dataSource</code>: a <code>String</code> literal defining the name under which a data source is looked up in the <code>InitialContext</code></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1005952">&#34;Standard Data Source Support&#34;</a></div>
</li>
</ul>
<p>The Oracle SQLJ implementation supports the following standard constants in iterator declarations:</p>
<ul>
<li>
<p><code><a id="sthref166"></a><a id="sthref167"></a><a id="sthref168"></a><a id="sthref169"></a>sensitivity</code>: <code>SENSITIVE</code>/<code>ASENSITIVE</code>/<code>INSENSITIVE</code>, to define the sensitivity of a scrollable iterator</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006775">&#34;Scrollable Iterator Sensitivity&#34;</a></div>
</li>
<li>
<p><code><a id="sthref170"></a>returnability</code>: <code>true</code>/<code>false</code>, to define whether an iterator can be returned from a Java stored procedure or function</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1008976">&#34;Example: Returnability&#34;</a></div>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ279"></a>Unsupported WITH Clause Constants</p>
<p>If you have SQLJ code that uses these constants, then they will not cause an error but will result in no operation. The Oracle SQLJ implementation does <span class="italic">not</span> support the following standard constants in connection context declarations:</p>
<ul>
<li>
<p><code><a id="sthref171"></a>path</code>: a <code>String</code> literal defining the name of a path to be prepended for resolution of Java stored procedures and functions</p>
</li>
<li>
<p><code><a id="sthref172"></a>transformGroup</code>: a <code>String</code> literal defining the name of a SQL transformation group that can be applied to SQL types</p>
</li>
</ul>
<p>The Oracle SQLJ implementation does <span class="italic">not</span> support the following standard constants, involving cursor states, in iterator declarations:</p>
<ul>
<li>
<p><code><a id="sthref173"></a>holdability</code>: <code>true</code>/<code>false</code>, determining cursor holdability</p>
<p>The concept of holdability is defined in the SQL specification. A cursor that is holdable can, subject to application request, be kept open and positioned on the current row even when a transaction is completed. Use of the cursor can then be continued in the next transaction of the same SQL session, however, subject to some limitations.</p>
</li>
<li>
<p><code><a id="sthref174"></a><a id="sthref175"></a>updateColumns</code>: a <code>String</code> literal containing a comma-delimited list of column names</p>
<p>An iterator declaration having a <code>with</code> clause that specifies <code>updateColumns</code> must also have an <code>implements</code> clause that specifies the <code>sqlj.runtime.ForUpdate</code> interface. The Oracle SQLJ implementation enforces this, even though <code>updateColumns</code> is currently unsupported.</p>
</li>
</ul>
<p>The following is a sample connection context declaration using <code>typeMap</code>:</p>
<pre>#sql public context MyContext with (typeMap=&#34;MyPack.MyClass&#34;);
</pre>
<p>The declared class <code>MyContext</code> will define a <code>String</code> attribute <code>typeMap</code> that will be <code>public static final</code> and initialized to the value <code>MyPack.MyClass</code>. This value is the fully qualified class name of a <code>ListResourceBundle</code> implementation that provides the mapping between SQL and Java types for statements executed on instances of the <code>MyContext</code> class.</p>
<p>The following is a sample iterator declaration using <code>sensitivity</code>:</p>
<pre>#sql public iterator MyAsensitiveIter with (sensitivity=ASENSITIVE) 
     (String ename, int empno);
</pre>
<p>This declaration sets the cursor sensitivity to <code>ASENSITIVE</code> for the <code>MyAsensitiveIter</code> named iterator class.</p>
<p>The following example uses both an <code>implements</code> clause and a <code>with</code> clause:</p>
<pre>#sql public iterator MyScrollableIterator implements sqlj.runtime.Scrollable
     with (holdability=true) (String ename, int empno);
</pre>
<p>This declaration implements the interface <code>sqlj.runtime.Scrollable</code> and enables the cursor <code>holdability</code> for a named iterator class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>holdability</code> is currently <span class="italic">not</span> supported.</div>
</div>
<!-- class="sect3" -->
<a id="i1008750"></a>
<div id="JSQLJ280" class="sect3">
<h4 class="sect3">Oracle-Specific WITH Clause Usage</h4>
<p>In addition to the standard <code>with</code> clause usage in a connection context declaration to associate a type map with the connection context class, the Oracle SQLJ implementation enables you to use a <code>with</code> clause to associate a type map with the iterator class in an iterator declaration. For example:</p>
<pre>#sql iterator MyIterator with (typeMap=&#34;MyTypeMap&#34;) (Person pers, Address addr);
</pre>
<p>If you use Oracle-specific code generation and use type maps in your application, then your iterator and connection context declarations must use the same type maps.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1006823">&#34;Code Considerations and Limitations with Oracle-Specific Code Generation&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="i1008976"></a>
<div id="JSQLJ281" class="sect3">
<h4 class="sect3">Exa<a id="sthref176"></a>mple: Returnability</h4>
<p>Use <code>returnability=true</code> in the <code>with</code> clause of a SQLJ iterator declaration to specify that the iterator can be returned from a Java stored procedure to a SQL or PL/SQL statement as a REF CURSOR. With the default <code>returnability=false</code> setting, the iterator cannot be returned in this manner, and an attempt to do so will result in a SQL exception at run time.</p>
<p>Create the following database table:</p>
<pre>create table sqljRetTab(str varchar2(30));
insert into sqljRetTab values (&#39;sqljRetTabCol&#39;);
</pre>
<p>Define the <code>RefCursorSQLJ</code> class in the <code>RefCursorSQLJ.sqlj</code> source file as follows. Note that the iterator type <code>MyIter</code> uses <code>returnability=true</code>.</p>
<pre>public class RefCursorSQLJ
{
   #sql static public iterator MyIter with (returnability=true) (String str);

   static public MyIter sqljUserRet() throws java.sql.SQLException
   {
        MyIter iter=null;
        try {
        #sql iter = {select str from sqljRetTab};
        } catch (java.sql.SQLException e)
        {
           e.printStackTrace();
           throw e;
        }
        System.err.println(&#34;iter is &#34; + iter);
        return iter;
   }
}
</pre>
<p>Load <code>RefCursorSQLJ.sqlj</code> into Oracle Java Virtual Machine (JVM) inside the database as follows:</p>
<pre>% loadjava -u HR -r -f -v RefCursorSQLJ.sqlj
Password: <span class="italic">password</span>
</pre>
<p>Invoke the Java stored procedure defined for the <code>sqljUserRet()</code> method:</p>
<pre>create or replace package refcur_pkg as
     type refcur_t is ref cursor;
end;
/
create or replace function sqljUserRet
return refcur_pkg.refcur_t as
language java
name &#39;RefCursorSQLJ.sqljUserRet() return
RefCursorSQLJ.MyIter&#39;;
/
select HR.sqljUserRet from dual;
</pre>
<p>Here is the result of the <code>SELECT</code> statement:</p>
<pre>    SQLJRET1
    --------------------
    CURSOR STATEMENT : 1

    STR
    ------------------------------
    sqljRetTabCol
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009165"></a>
<div id="JSQLJ282" class="sect1">
<h2 class="sect1">Overview of SQLJ <a id="sthref177"></a>Executable Statements</h2>
<p>A SQLJ executable statement consists of the <code>#sql</code> token followed by a SQLJ clause, which uses syntax that follows a specified standard for embedding executable SQL statements in Java code. The embedded SQL operation of a SQLJ executable statement can be any SQL operation supported by the JDBC driver.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDHFAAA">Rules for SQLJ Executable Statements</a></p>
</li>
<li>
<p><a href="#CHDFAFBF">SQLJ Clauses</a></p>
</li>
<li>
<p><a href="#i1006054">Specifying Connection Context Instances and Execution Context Instances</a></p>
</li>
<li>
<p><a href="#CHDIEEHH">Executable Statement Examples</a></p>
</li>
<li>
<p><a href="#i1006136">PL/SQL Blocks in Executable Statements</a></p>
</li>
</ul>
<a id="CHDHFAAA"></a>
<div id="JSQLJ283" class="sect2">
<h3 class="sect2">Rules for SQLJ <a id="sthref178"></a>Executable Statements</h3>
<p>A SQLJ executable statement must adhere to the following rules:</p>
<ul>
<li>
<p>It is permitted in Java code wherever Java block statements are permitted. That is, it is permitted inside method definitions and static initialization blocks.</p>
</li>
<li>
<p>Its embedded SQL operation must be enclosed in curly braces: <code>{...}</code>.</p>
</li>
<li>
<p>It must be terminated with a semi-colon (;).</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>It is recommended that you do <span class="italic">not</span> close the SQL operation with a semi-colon. The parser will detect the end of the operation when it encounters the closing curly brace of the SQLJ clause.</p>
</li>
<li>
<p>Everything inside the curly braces of a SQLJ executable statement is treated as SQL syntax and must follow SQL rules, with the exception of Java host expressions.</p>
</li>
<li>
<p>During offline parsing of SQL operations, all SQL syntax is checked. However, during online semantics-checking only data manipulation language (DML) operations can be parsed and checked. Data definition language (DDL) operations, transaction-control operations, or any other kinds of SQL operations cannot be parsed and checked.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDFAFBF"></a>
<div id="JSQLJ284" class="sect2">
<h3 class="sect2">SQLJ <a id="sthref179"></a><a id="sthref180"></a>Clauses</h3>
<p>A SQLJ clause is the executable part of a statement, consisting of everything to the right of the <code>#sql</code> token. This consists of embedded SQL inside curly braces, preceded by a Java result expression if appropriate, such as <code>result</code> in the following example:</p>
<pre>#sql { <span class="italic">SQL operation</span> };   // For a statement with no output, like INSERT
...
#sql <span class="italic">result</span> = { <span class="italic">SQL operation</span> };   // For a statement with output, like SELECT
</pre>
<p>A clause without a result expression, such as in the first SQLJ statement in the example, is known as a statement clause. A clause that does have a result expression, such as in the second SQLJ statement in the example, is known as an assignment clause.</p>
<p>A result expression can be anything from a simple variable that takes a stored-function return value to an iterator that takes several columns of data from a multi-row <code>SELECT</code>, where the iterator can be an instance of an iterator class or subclass.</p>
<p>A SQL operation in a SQLJ statement can use standard SQL syntax only or can use a clause with syntax specific to SQLJ.</p>
<p><a href="#CBBHFEGH">Table 4-1</a> lists supported SQLJ statement clauses and <a href="#CBBFCJBJ">Table 4-2</a> lists supported SQLJ assignment clauses. The last two entries in <a href="#CBBHFEGH">Table 4-1</a> are general categories for statement clauses that use standard SQL syntax or Oracle PL/SQL syntax, as opposed to SQLJ-specific syntax.</p>
<div id="JSQLJ285" class="tblformal">
<p class="titleintable"><a id="sthref181"></a><a id="CBBHFEGH"></a>Table 4-1 SQLJ Statement Clauses</p>
<table class="cellalignment4020" title="SQLJ Statement Clauses " summary="summary" dir="ltr">
<thead>
<tr class="cellalignment4011">
<th class="cellalignment4021" id="r1c1-t15">Category</th>
<th class="cellalignment4021" id="r1c2-t15">Functionality</th>
<th class="cellalignment4021" id="r1c3-t15">More Information</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r2c1-t15" headers="r1c1-t15">
<p><code>SELECT INTO</code> clause</p>
</td>
<td class="cellalignment4017" headers="r2c1-t15 r1c2-t15">
<p>Select data into Java host expressions.</p>
</td>
<td class="cellalignment4017" headers="r2c1-t15 r1c3-t15">
<p><a href="#i1006673">&#34;Single-Row Query Results: SELECT INTO Statements&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r3c1-t15" headers="r1c1-t15">
<p><code>FETCH</code> clause</p>
</td>
<td class="cellalignment4017" headers="r3c1-t15 r1c2-t15">
<p>Fetch data from a positional iterator.</p>
</td>
<td class="cellalignment4017" headers="r3c1-t15 r1c3-t15">
<p><a href="#i1007114">&#34;Using Positional Iterators&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r4c1-t15" headers="r1c1-t15">
<p><code>COMMIT</code> clause</p>
</td>
<td class="cellalignment4017" headers="r4c1-t15 r1c2-t15">
<p>Commit changes to the data.</p>
</td>
<td class="cellalignment4017" headers="r4c1-t15 r1c3-t15">
<p><a href="keyprog.htm#i1006385">&#34;Using Manual COMMIT and ROLLBACK&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r5c1-t15" headers="r1c1-t15">
<p><code>ROLLBACK</code> clause</p>
</td>
<td class="cellalignment4017" headers="r5c1-t15 r1c2-t15">
<p>Cancel changes to the data.</p>
</td>
<td class="cellalignment4017" headers="r5c1-t15 r1c3-t15">
<p><a href="keyprog.htm#i1006385">&#34;Using Manual COMMIT and ROLLBACK&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r6c1-t15" headers="r1c1-t15">
<p><code>SAVEPOINT RELEASE SAVEPOINT ROLLBACK TO</code> clauses</p>
</td>
<td class="cellalignment4017" headers="r6c1-t15 r1c2-t15">
<p>Set a savepoint for future rollbacks, release a specified savepoint, roll back to a savepoint.</p>
</td>
<td class="cellalignment4017" headers="r6c1-t15 r1c3-t15">
<p><a href="keyprog.htm#i1006439">&#34;Using Savepoints&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r7c1-t15" headers="r1c1-t15">
<p><code>SET TRANSACTION</code> clause</p>
</td>
<td class="cellalignment4017" headers="r7c1-t15 r1c2-t15">
<p>Use advanced transaction control for access mode and isolation level.</p>
</td>
<td class="cellalignment4017" headers="r7c1-t15 r1c3-t15">
<p><a href="alangfea.htm#i1006992">&#34;Advanced Transaction Control&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r8c1-t15" headers="r1c1-t15">
<p>Procedure clause</p>
</td>
<td class="cellalignment4017" headers="r8c1-t15 r1c2-t15">
<p>Call a stored procedure.</p>
</td>
<td class="cellalignment4017" headers="r8c1-t15 r1c3-t15">
<p><a href="#i1007512">&#34;Calling Stored Procedures&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r9c1-t15" headers="r1c1-t15">
<p>Assignment clause</p>
</td>
<td class="cellalignment4017" headers="r9c1-t15 r1c2-t15">
<p>Assign values to Java host expressions.</p>
</td>
<td class="cellalignment4017" headers="r9c1-t15 r1c3-t15">
<p><a href="#i1007454">&#34;Assignment Statements (SET)&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r10c1-t15" headers="r1c1-t15">
<p>SQL clause</p>
</td>
<td class="cellalignment4017" headers="r10c1-t15 r1c2-t15">
<p>Use standard SQL syntax and functionality: <code>UPDATE</code>, <code>INSERT</code>, <code>DELETE</code>.</p>
</td>
<td class="cellalignment4017" headers="r10c1-t15 r1c3-t15">
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r11c1-t15" headers="r1c1-t15">
<p>PL/SQL block</p>
</td>
<td class="cellalignment4017" headers="r11c1-t15 r1c2-t15">
<p>Use <code>BEGIN..END</code> or <code>DECLARE..BEGIN..END</code> anonymous block inside SQLJ statement.</p>
</td>
<td class="cellalignment4017" headers="r11c1-t15 r1c3-t15">
<p><a href="#i1006136">&#34;PL/SQL Blocks in Executable Statements&#34;</a></p>
<p><a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="JSQLJ286" class="tblformal">
<p class="titleintable"><a id="sthref182"></a><a id="CBBFCJBJ"></a>Table 4-2 SQLJ Assignment Clauses</p>
<table class="cellalignment4020" title="SQLJ Assignment Clauses " summary="summary" dir="ltr">
<thead>
<tr class="cellalignment4011">
<th class="cellalignment4021" id="r1c1-t16">Category</th>
<th class="cellalignment4021" id="r1c2-t16">Functionality</th>
<th class="cellalignment4021" id="r1c3-t16">More Information</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r2c1-t16" headers="r1c1-t16">
<p>Query clause</p>
</td>
<td class="cellalignment4017" headers="r2c1-t16 r1c2-t16">
<p>Select data into a SQLJ iterator.</p>
</td>
<td class="cellalignment4017" headers="r2c1-t16 r1c3-t16">
<p><a href="#i1006767">&#34;Multirow Query Results: SQLJ Iterators&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r3c1-t16" headers="r1c1-t16">
<p>Function clause</p>
</td>
<td class="cellalignment4017" headers="r3c1-t16 r1c2-t16">
<p>Call a stored function.</p>
</td>
<td class="cellalignment4017" headers="r3c1-t16 r1c3-t16">
<p><a href="#i1007546">&#34;Calling Stored Functions&#34;</a></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r4c1-t16" headers="r1c1-t16">
<p>Iterator conversion clause</p>
</td>
<td class="cellalignment4017" headers="r4c1-t16 r1c2-t16">
<p>Convert a JDBC result set to a SQLJ iterator.</p>
</td>
<td class="cellalignment4017" headers="r4c1-t16 r1c3-t16">
<p><a href="alangfea.htm#i1007234">&#34;Converting from Result Sets to Named or Positional Iterators&#34;</a></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
A SQLJ statement is referred to by the same name as the clause that makes up the body of that statement. For example, an executable statement consisting of <code>#sql</code> followed by a <code>SELECT INTO</code> clause is referred to as a <code>SELECT INTO</code> statement.</div>
</div>
<!-- class="sect2" -->
<a id="i1006054"></a>
<div id="JSQLJ287" class="sect2">
<h3 class="sect2">Specifying Connection <a id="sthref183"></a><a id="sthref184"></a><a id="sthref185"></a>Context Instances and Execution Context Instances</h3>
<p>If you have defined multiple database connections and want to specify a particular connection context instance for an executable statement, then use the following syntax:</p>
<pre>#sql [<span class="italic">conn_context_instance</span>] { <span class="italic">SQL operation</span> };
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1005714">&#34;Connection Considerations&#34;</a></div>
<p>If you have defined one or more execution context instances of the <code>sqlj.runtime.ExecutionContext</code> class and want to specify one of them for use with an executable statement, then use the following syntax:</p>
<pre>#sql [<span class="italic">exec_context_instance</span>] { <span class="italic">SQL operation</span> };
</pre>
<p>You can use an execution context instance to provide status or control of the SQL operation of a SQLJ executable statement. For example, you can use execution context instances in multithreading situations where multiple operations are occurring on the same connection.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006207">&#34;Execution Contexts&#34;</a></div>
<p>You can also specify both a connection context instance and an execution context instance:</p>
<pre>#sql [<span class="italic">conn_context_instance</span>, <span class="italic">exec_context_instance</span>] { <span class="italic">SQL operation</span> };
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Include the square brackets around connection context instances and execution context instances. They are part of the syntax.</p>
</li>
<li>
<p>If you specify both a connection context instance and an execution context instance, then the connection context instance must come first.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDIEEHH"></a>
<div id="JSQLJ288" class="sect2">
<h3 class="sect2">Executable Statement <a id="sthref186"></a>Examples</h3>
<p>This section provides examples of elementary SQLJ executable statements.</p>
<p class="subhead2"><a id="JSQLJ289"></a>Elementary INSERT</p>
<p>The following example demonstrates a basic <code>INSERT</code>. The statement clause does not require any syntax specific to SQLJ.</p>
<p>Consider an employee table <code>EMP</code> with the following rows:</p>
<pre>CREATE TABLE EMP (
   ENAME VARCHAR2(10),
   SAL NUMBER(7,2) );
</pre>
<p>Use the following SQLJ executable statement, which uses only standard SQL syntax, to insert Joe as a new employee into the <code>EMP</code> table, specifying his name and salary:</p>
<pre>#sql { INSERT INTO emp (ename, sal) VALUES (&#39;Joe&#39;, 43000) };
</pre>
<p class="subhead2"><a id="JSQLJ290"></a>Elementary INSERT with Connection Context or Execution Context Instances</p>
<p>The following examples use <code>ctx</code> as a connection context instance, which is an instance of either the default <code>sqlj.runtime.ref.DefaultContext</code> or a class that you have previously declared in a connection context declaration, and <code>execctx</code> as an execution context instance:</p>
<pre>#sql [ctx] { INSERT INTO emp (ename, sal) VALUES (&#39;Joe&#39;, 43000) };

#sql [execctx] { INSERT INTO emp (ename, sal) VALUES (&#39;Joe&#39;, 43000) };

#sql [ctx, execctx] { INSERT INTO emp (ename, sal) VALUES (&#39;Joe&#39;, 43000) };
</pre>
<p class="subhead2"><a id="JSQLJ291"></a>A Simple SQLJ Method</p>
<p>This example demonstrates a simple method using SQLJ code, demonstrating how SQLJ statements interrelate with and are interspersed with Java statements. The SQLJ statement uses standard <code>INSERT INTO</code> <code><span class="codeinlineitalic">table</span></code> <code>VALUES</code> syntax supported by the Oracle SQL implementation. The statement also uses Java host expressions, marked by colons (:), to define the values. Host expressions are used to pass data between the Java code and SQL instructions.</p>
<pre>public static void writeSalesData (int[] itemNums, String[] itemNames)
       throws SQLException
{
  for (int i =0; i &lt; itemNums.length; i++)
    #sql { INSERT INTO sales VALUES(:(itemNums[i]), :(itemNames[i]), SYSDATE) };
}
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The <code>throws SQLException</code> <span class="italic">is</span> required.</p>
</li>
<li>
<p>SQLJ function calls also use a <code>VALUES</code> token, but these situations are not related semantically.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006136"></a>
<div id="JSQLJ292" class="sect2">
<h3 class="sect2">PL/SQL Blocks in <a id="sthref187"></a><a id="sthref188"></a><a id="sthref189"></a>Executable Statements</h3>
<p>PL/SQL blocks can be used within the curly braces of a SQLJ executable statement just as SQL operations can, as in the following example:</p>
<pre>#sql {
   DECLARE
      n NUMBER;
   BEGIN
      n := 1;
      WHILE n &lt;= 100 LOOP
         INSERT INTO emp (empno) VALUES(2000 + n);
         n := n + 1;
      END LOOP;
   END
};
</pre>
<p>This example goes through a loop that inserts new employees in the <code>emp</code> table, creating employee numbers <code>2001</code> through <code>2100</code>. It presumes data other than the employee number will be filled in later.</p>
<p>Simple PL/SQL blocks can also be coded in a single line as follows:</p>
<pre>#sql { &lt;DECLARE ...&gt; BEGIN ... END; };
</pre>
<p>Using PL/SQL anonymous blocks within SQLJ statements is one way to use dynamic SQL in your application. You can also use dynamic SQL directly through SQLJ extensions provided by Oracle or through JDBC code within a SQLJ application.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1007348">&#34;Support for Dynamic SQL&#34;</a> and <a href="alangfea.htm#i1007059">&#34;SQLJ and JDBC Interoperability&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Remember that using PL/SQL in your SQLJ code would prevent portability to other platforms, because PL/SQL is Oracle-specific.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006176"></a>
<div id="JSQLJ293" class="sect1">
<h2 class="sect1">Java Host, Context, and Result Expressions</h2>
<p>This section discusses three categories of Java expressions used in SQLJ code: host expressions, context expressions, and result expressions. Host expressions are the most frequently used Java expressions. Another category of expressions, called meta bind expressions, are used specifically for dynamic SQL operations and use syntax similar to that of host expressions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1007348">&#34;Support for Dynamic SQL&#34;</a></div>
<p>SQLJ uses Java host expressions to pass arguments between Java code and SQL operations. This is how you pass information between Java and SQL. Host expressions are interspersed within the embedded SQL operations in the SQLJ source code.</p>
<p>The most basic kind of host expression, consisting of only a Java identifier, is referred to as a host variable. A context expression specifies a connection context instance or execution context instance to be used for a SQLJ statement. A result expression specifies an output variable for query results or a function return.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDEEDGH">Overview of Host Expressions</a></p>
</li>
<li>
<p><a href="#CHDICJCF">Basic Host Expression Syntax</a></p>
</li>
<li>
<p><a href="#CHDIFIFI">Examples of Host Expressions</a></p>
</li>
<li>
<p><a href="#CHDFCIJC">Overview of Result Expressions and Context Expressions</a></p>
</li>
<li>
<p><a href="#i1006346">Evaluation of Java Expressions at Run Time</a></p>
</li>
<li>
<p><a href="#i1006398">Examples of Evaluation of Java Expressions at Run Time (ISO Code Generation)</a></p>
</li>
<li>
<p><a href="#i1006663">Restrictions on Host Expressions</a></p>
</li>
</ul>
<a id="CHDEEDGH"></a>
<div id="JSQLJ294" class="sect2">
<h3 class="sect2">Overview of <a id="sthref190"></a>Host Expressions</h3>
<p>Any valid Java expression can be used as a host expression. In the simplest case, the expression consists of just a single Java variable. Other kinds of host expressions include the following:</p>
<ul>
<li>
<p>Arithmetic expressions</p>
</li>
<li>
<p>Java method calls with return values</p>
</li>
<li>
<p>Java class field values</p>
</li>
<li>
<p>Array elements</p>
</li>
<li>
<p>Conditional expressions (<code>a ? b : c</code>)</p>
</li>
<li>
<p>Logical expressions</p>
</li>
<li>
<p>Bitwise expressions</p>
</li>
</ul>
<p>Java identifiers used as host variables or in host expressions can represent any of the following:</p>
<ul>
<li>
<p>Local variables</p>
</li>
<li>
<p>Declared parameters</p>
</li>
<li>
<p>Class fields</p>
</li>
<li>
<p>Static or instance method calls</p>
</li>
</ul>
<p>Local variables used in host expressions can be declared anywhere that other Java variables can be declared. Fields can be inherited from a superclass.</p>
<p>Java variables that are legal in the Java scope where the SQLJ executable statement appears can be used in a host expression in a SQL statement, presuming its type is convertible to or from a SQL data type. Host expressions can be input, output, or input-output.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="typesupp.htm#i1005568">&#34;Supported Types for Host Expressions&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDICJCF"></a>
<div id="JSQLJ295" class="sect2">
<h3 class="sect2">Basic Host <a id="sthref191"></a>Expression Syntax</h3>
<p>A host expression is preceded by a colon (:). If the desired mode of the host expression is not the default, then the colon must be followed by <code>IN</code>, <code>OUT</code>, or <code>INOUT</code>, as appropriate, before the host expression itself. These are referred to as mode specifiers. The default is <code>OUT</code> if the host expression is part of an <code>INTO</code>-list or is the assignment expression in a <code>SET</code> statement. Otherwise, the default is <code>IN</code>. Any <code>OUT</code> or <code>INOUT</code> host expression must be assignable.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When using the default, you can still include the mode specifier if desired.</div>
<p>The SQL code that surrounds a host expression can use any vendor-specific SQL syntax. Therefore, no assumptions can be made about the syntax when parsing the SQL operations and determining the host expressions. To avoid any possible ambiguity, any host expression that is not a simple host variable (in other words, that is more complex than a nondotted Java identifier) must be enclosed in parentheses.</p>
<p>To summarize the basic syntax:</p>
<ul>
<li>
<p>For a simple host variable without a mode specifier, put the host variable after the colon, as in the following example:</p>
<pre>:hostvar
</pre></li>
<li>
<p>For a simple host variable with a mode specifier, put the mode specifier after the colon and put white space (space, tab, newline, or comment) between the mode specifier and the host variable, as in the following example:</p>
<pre>:INOUT hostvar
</pre>
<p>The white space is required to distinguish between the mode specifier and the variable name.</p>
</li>
<li>
<p>For any other host expression, enclose the expression in parentheses and place it after the mode specifier or after the colon, if there is no mode specifier, as in the following examples:</p>
<pre>:IN(hostvar1+hostvar2)
:(hostvar3*hostvar4)
:(index--)
</pre>
<p>White space is not required after the mode specifier in this example, because the parenthesis is a suitable separator. However, a white space after the mode specifier is allowed.</p>
<p>An outer set of parentheses is needed even if the expression already starts with a begin-parenthesis, as in the following examples:</p>
<pre>:((x+y).z)
:(((y)x).myOutput())
</pre></li>
</ul>
<p class="subhead2"><a id="JSQLJ296"></a>Syntax Notes</p>
<p>Keep the following in mind regarding the host expression syntax:</p>
<ul>
<li>
<p>White space is always allowed after the colon as well as after the mode specifier. Wherever white space is allowed, you can also have a comment.</p>
<p>You can have any of the following in the SQL namespace:</p>
<ul>
<li>
<p>SQL comments after the colon and before the mode specifier</p>
</li>
<li>
<p>SQL comments after the colon and before the host expression if there is no mode specifier</p>
</li>
<li>
<p>SQL comments after the mode specifier and before the host expression</p>
</li>
</ul>
<p>You can have the following in the Java namespace:</p>
<ul>
<li>
<p>Java comments within the host expression (inside the parentheses)</p>
</li>
</ul>
</li>
<li>
<p>The <code>IN</code>, <code>OUT</code>, and <code>INOUT</code> syntax used for host variables and expressions are not case-sensitive. These tokens can be in uppercase, lowercase, or mixed.</p>
</li>
<li>
<p>Do not confuse the <code>IN</code>, <code>OUT</code>, and <code>INOUT</code> syntax of SQLJ host expressions with similar <code>IN</code>, <code>OUT</code>, and <code>IN OUT</code> syntax used in PL/SQL declarations to specify the mode of parameters passed to PL/SQL stored functions and procedures.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ297"></a>Usage Notes</p>
<p>Keep the following in mind regarding the usage of host expressions:</p>
<ul>
<li>
<p>A simple host variable can appear multiple times in the same SQLJ statement, as follows:</p>
<ul>
<li>
<p>If the host variable appears only as an input variable, then there are no restrictions or complications.</p>
</li>
<li>
<p>If at least one appearance of the host variable is as an output variable in a PL/SQL block, then you will receive a portability warning if the translator <code>-warn=portability</code> flag is set. SQLJ run-time behavior in this situation is vendor-specific. Oracle SQLJ run time uses value semantics, as opposed to reference semantics, for all occurrences of the host variable.</p>
</li>
<li>
<p>If at least one appearance of the host variable is as an output variable in a stored procedure call, stored function call, <code>SET</code> statement, or <code>INTO</code>-list, then you will <span class="italic">not</span> receive any warning. SQLJ run-time behavior in this situation is standardized, using value semantics.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The term output refers to <code>OUT</code> or <code>INOUT</code> variables, as applicable.</div>
</li>
<li>
<p>If a host expression that is a simple host variable appears multiple times in a SQLJ statement, then by default each appearance is treated completely independently of the other appearances, using value semantics. However, if you use the SQLJ translator <code>-bind-by-identifier=true</code> setting, then this is not the case. With a <code>true</code> setting, multiple appearances of the same host variable in a given SQLJ statement or PL/SQL block are treated as a single bind occurrence.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1008034">&#34;Binding Host Expressions by Identifier (-bind-by-identifier)&#34;</a></div>
</li>
<li>
<p>When binding a string host expression into a <code>WHERE</code> clause for comparison against <code>CHAR</code> data, be aware that there is a SQLJ option, <code>-fixedchar</code>, that accounts for blank padding in the <code>CHAR</code> column when the comparison is made.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007700">&#34;CHAR Comparisons with Blank Padding (-fixedchar)&#34;</a></div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDIFIFI"></a>
<div id="JSQLJ298" class="sect2">
<h3 class="sect2">Examples of <a id="sthref192"></a>Host Expressions</h3>
<p>The following examples will help clarify the preceding syntax discussion.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Some of these examples use <code>SELECT INTO</code> statements, which are described in <a href="#i1006673">&#34;Single-Row Query Results: SELECT INTO Statements&#34;</a>.</div>
<p class="subhead2"><a id="JSQLJ299"></a>Example 1</p>
<p>In this example, two input host variables are used, one as a test value for a <code>WHERE</code> clause and one to contain new data to be sent to the database.</p>
<p>Presume you have a database employee table <code>emp</code> with an <code>ename</code> column for employee names and a <code>sal</code> column for employee salaries. The relevant Java code that defines the host variables is as follows:</p>
<pre>String empname = &#34;SMITH&#34;;
double salary = 25000.0;
...
#sql { UPDATE emp SET sal = :salary WHERE ename = :empname };
</pre>
<p><code>IN</code> is the default, but you can state it explicitly as well:</p>
<pre>#sql { UPDATE emp SET sal = :IN salary WHERE ename = :IN empname };
</pre>
<p>As you can see, the colon (:) can immediately precede the variable when not using the <code>IN</code> token, but <code>:IN</code> must be followed by white space before the host variable.</p>
<p class="subhead2"><a id="JSQLJ300"></a>Example 2</p>
<p>This example uses an output host variable in a <code>SELECT INTO</code> statement, where you want to find out the name of the employee whose employee number 28959.</p>
<pre>String empname;
...
#sql { SELECT ename INTO :empname FROM emp WHERE empno = 28959 };
</pre>
<p><code>OUT</code> is the default for an <code>INTO</code>-list, but you can state it explicitly as well:</p>
<pre>#sql { SELECT ename INTO :OUT empname FROM emp WHERE empno = 28959 };
</pre>
<p>This statement looks in the <code>empno</code> column of the <code>emp</code> table for employee number 28959, selects the name in the <code>ename</code> column of that row, and outputs it to the <code>empname</code> output host variable, which is a Java <code>String</code>.</p>
<p class="subhead2"><a id="JSQLJ301"></a>Example 3</p>
<p>This example uses an arithmetic expression as an input host expression. The Java variables <code>balance</code> and <code>minPmtRatio</code> are multiplied, and the result is used to update the <code>minPayment</code> column of the <code>creditacct</code> table for account number 537845.</p>
<pre>float balance = 12500.0;
float minPmtRatio = 0.05;
...
#sql { UPDATE creditacct SET minPayment = :(balance * minPmtRatio) 
       WHERE acctnum = 537845 };
</pre>
<p>Alternatively, to use the <code>IN</code> token:</p>
<pre>#sql { UPDATE creditacct SET minPayment = :IN (balance * minPmtRatio) 
       WHERE acctnum = 537845 };
</pre>
<p class="subhead2"><a id="JSQLJ302"></a>Example 4</p>
<p>This example shows the use of the output of a method call as an input host expression and also uses an input host variable. This statement uses the value returned by <code>getNewSal()</code> to update the <code>sal</code> column in the <code>emp</code> table for the employee who is specified by the Java <code>empname</code> variable. Java code initializing the host variables is also shown.</p>
<pre>String empname = &#34;SMITH&#34;;
double raise = 0.1;
...
#sql {UPDATE emp SET sal = :(getNewSal(raise, empname)) 
      WHERE ename = :empname};
</pre></div>
<!-- class="sect2" -->
<a id="CHDFCIJC"></a>
<div id="JSQLJ303" class="sect2">
<h3 class="sect2">Overview of <a id="sthref193"></a>Result Expressions and <a id="sthref194"></a>Context Expressions</h3>
<p>A context expression is an input expression that specifies the name of a connection context instance or an execution context instance to be used in a SQLJ executable statement. Any legal Java expression that yields such a name can be used.</p>
<p>A result expression is an output expression used for query results or a function return. It can be any legal Java expression that is assignable, meaning that it can logically appear on the left side of an equals sign. This is sometimes referred to as an l-value.</p>
<p>The following examples can be used for either result expressions or context expressions:</p>
<ul>
<li>
<p>Local variables</p>
</li>
<li>
<p>Declared parameters</p>
</li>
<li>
<p>Class fields</p>
</li>
<li>
<p>Array elements</p>
</li>
</ul>
<p>Result expressions and context expressions appear lexically in the SQLJ space, unlike host expressions, which appear lexically in the SQL space, that is, inside the curly brackets of a SQLJ executable statement. Therefore, a result expression or context expression must <span class="italic">not</span> be preceded by a colon.</p>
</div>
<!-- class="sect2" -->
<a id="i1006346"></a>
<div id="JSQLJ304" class="sect2">
<h3 class="sect2">Evaluation of <a id="sthref195"></a><a id="sthref196"></a><a id="sthref197"></a>Java Expressions at Run Time</h3>
<p>This section discusses the evaluation of Java host expressions, connection context expressions, execution context expressions, and result expressions when your application executes.</p>
<p>Following is a simplified representation of a SQLJ executable statement that uses all these kinds of expressions:</p>
<pre>#sql [<span class="italic">connctxt_exp</span>, <span class="italic">execctxt_exp</span>] <span class="italic">result_exp</span> = { <span class="italic">SQL</span> <span class="italic">with host expression</span> };
</pre>
<p>Java expressions can be used as any of the following, as appropriate:</p>
<ul>
<li>
<p>Connection context expression: Evaluated to specify the connection context instance to be used</p>
</li>
<li>
<p>Execution context expression: Evaluated to specify the execution context instance to be used</p>
</li>
<li>
<p>Result expression: To receive results, for example, from a stored function</p>
</li>
<li>
<p>Host expression</p>
</li>
</ul>
<p>For ISO standard code generation, the evaluation of Java expressions is well-defined, even for the use of any side effects that depend on the order in which expressions are evaluated.</p>
<p>For Oracle-specific code generation, evaluation of Java expressions follows the ISO standard when there are no side effects, except when the <code>-bind-by-identifier</code> option is enabled, but is implementation-specific and subject to change when there are side effects.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following discussion and the related examples later do <span class="italic">not</span> apply to Oracle-specific code generation. If you use side effects as described here, then request ISO code generation during translation.</div>
<p>The following is a summary, for ISO code, of the overall order of evaluation, execution, and assignment of Java expressions for each statement that executes during run time.</p>
<ol>
<li>
<p>If there is a connection context expression, then it is evaluated immediately, before any other Java expressions are evaluated.</p>
</li>
<li>
<p>If there is an execution context expression, then it is evaluated after any connection context expression, but before any result expression.</p>
</li>
<li>
<p>If there is a result expression, then it is evaluated after any context expressions, but before any host expressions.</p>
</li>
<li>
<p>After evaluation of any context or result expressions, host expressions are evaluated from left to right as they appear in the SQL operation. As each host expression is encountered and evaluated, its value is saved to be passed to SQL.</p>
<p>Each host expression is evaluated once and only once.</p>
</li>
<li>
<p><code>IN</code> and <code>INOUT</code> parameters are passed to SQL, and the SQL operation is executed.</p>
</li>
<li>
<p>After execution of the SQL operation, the output parameters, Java <code>OUT</code> and <code>INOUT</code> host expressions, are assigned output in order from left to right as they appear in the SQL operation.</p>
<p>Each output host expression is assigned once and only once.</p>
</li>
<li>
<p>The result expression, if there is one, is assigned output last.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
Host expressions inside a PL/SQL block are all evaluated together before any statements within the block are executed. They are evaluated in the order in which they appear, regardless of the control flow within the block.</div>
<p>Once the expressions in a statement have been evaluated, input and input-output host expressions are passed to SQL, and then the SQL operation is executed. After execution of the SQL operation, assignments are made to Java output host expressions, input-output host expressions, and result expressions as follows:</p>
<ol>
<li>
<p><code>OUT</code> and <code>INOUT</code> host expressions are assigned output in order from left to right.</p>
</li>
<li>
<p>The result expression, if there is one, is assigned output last.</p>
</li>
</ol>
<p>Note that during run time, all host expressions are treated as distinct values, even if they share the same name or reference the same object. The execution of each SQL operation is treated as if invoking a remote method, and each host expression is taken as a distinct parameter. Each input or input-output parameter is evaluated and passed as it is first encountered, before any output assignments are made for that statement, and each output parameter is also taken as distinct and is assigned exactly once.</p>
<p>It is also important to remember that each host expression is evaluated only once. An <code>INOUT</code> expression is evaluated when it is first encountered. When the output assignment is made, the expression itself is not reevaluated nor are any side-effects repeated.</p>
</div>
<!-- class="sect2" -->
<a id="i1006398"></a>
<div id="JSQLJ305" class="sect2">
<h3 class="sect2">Examples of <a id="sthref198"></a>Evaluation of Java Expressions at Run Time (ISO Code Generation)</h3>
<p>This section discusses, for ISO code generation, how Java expressions are evaluated when your application executes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do <span class="italic">not</span> count on these effects if you use Oracle-specific code generation. Request ISO code generation during translation if you depend on such effects.</div>
<p class="subhead2"><a id="JSQLJ306"></a>Evaluation of Prefix and Postfix Operators</p>
<p>When a Java expression contains a Java postfix increment or decrement operator, the incrementing or decrementing occurs <span class="italic">after</span> the expression has been evaluated. Similarly, when a Java expression contains a Java prefix increment or decrement operator, the incrementing or decrementing occurs <span class="italic">before</span> the expression is evaluated. This is equivalent to how these operators are handled in standard Java code.</p>
<p>The following is an example of postfix operator:</p>
<pre>int indx = 1;
...
#sql { ... :OUT (array[indx]) ... :IN (indx++) ... };
</pre>
<p>This example is evaluated as follows:</p>
<pre>#sql { ... :OUT (array[1]) ... :IN (1) ... };
</pre>
<p>The <code>indx</code> variable is incremented to 2 and will have that value the next time it is encountered, but not until after <code>:IN (indx++)</code> has been evaluated.</p>
<p>The following is the example of postfix operator:</p>
<pre>int indx = 1;
...
#sql { ... :OUT (array[indx++]) ... :IN (indx++) ... };
</pre>
<p>This example is evaluated as follows:</p>
<pre>#sql { ... :OUT (array[1]) ... :IN (2) ... };
</pre>
<p>The variable <code>indx</code> is incremented to 2 after the first expression is evaluated, but before the second expression is evaluated. It is incremented to 3 after the second expression is evaluated and will have that value the next time it is encountered.</p>
<p>The following example consists of both prefix and postfix operators:</p>
<pre>int indx = 1;
...
#sql { ... :OUT (array[++indx]) ... :IN (indx++) ... };
</pre>
<p>This example is evaluated as follows:</p>
<pre>#sql { ... :OUT (array[2]) ... :IN (2) ... };
</pre>
<p>The variable <code>indx</code> is incremented to 2 before the first expression is evaluated. It is incremented to 3 after the second expression is evaluated and will have that value the next time it is encountered.</p>
<p class="subhead2"><a id="JSQLJ307"></a>Evaluation Order of IN, INOUT, and OUT Host Expressions</p>
<p>Host expressions are evaluated from left to right. Whether an expression is <code>IN</code>, <code>INOUT</code>, or <code>OUT</code> makes no difference when it is evaluated. All that matters is its position in the left-to-right order.</p>
<p>Consider the following example:</p>
<pre>int[5] arry;
int n = 0;
...
#sql { SET :OUT (arry[n]) = :(++n) };
</pre>
<p>This example is evaluated as follows:</p>
<pre>#sql { SET :OUT (arry[0]) = 1 };
</pre>
<p>One might expect input expressions to be evaluated before output expressions, but that is not the case. The expression <code>:OUT (arry[n])</code> is evaluated first because it is the left-most expression. Then <code>n</code> is incremented prior to evaluation of <code>++n</code>, because it is being operated on by a prefix operator. Then <code>++n</code> is evaluated as 1. The result will be assigned to <code>arry[0]</code>, not <code>arry[1]</code>, because <code>0</code> was the value of <code>n</code> when it was originally encountered.</p>
<p class="subhead2"><a id="JSQLJ308"></a>Expressions in PL/SQL Blocks Are Evaluated Before Statements Are Executed</p>
<p>Host expressions in a PL/SQL block are all evaluated in one sequence, before any have been executed. Consider the following example:</p>
<pre>int x=3;
int z=5;
...
#sql { BEGIN :OUT x := 10; :OUT z := :x; END };
System.out.println(&#34;x=&#34; + x + &#34;, z=&#34; + z);
</pre>
<p>This example is evaluated as follows:</p>
<pre>#sql { BEGIN :OUT x := 10; :OUT z := 3; END };
</pre>
<p>Therefore, it would print <code>x=10, z=3</code>.</p>
<p>All expressions in a PL/SQL block are evaluated before any are executed. In this example, the host expressions in the second statement, <code>:OUT z</code> and <code>:x</code>, are evaluated before the first statement is executed. In particular, the second statement is evaluated while <code>x</code> still has its original value of <code>3</code>, before it has been assigned the value <code>10</code>.</p>
<p>Consider another example of how expressions are evaluated within a PL/SQL block:</p>
<pre>int x=1, y=4, z=3;
...
#sql { BEGIN
         :OUT x := :(y++) + 1;
         :OUT z := :x;
       END };
</pre>
<p>This example is evaluated as follows:</p>
<pre>#sql { BEGIN
          :OUT x := 4 + 1;
          :OUT z := 1;
       END };
</pre>
<p>The postfix increment operator is executed after <code>:(y++)</code> is evaluated, so the expression is evaluated as <code>4</code>, which is the initial value of <code>y</code>. The second statement, <code>:OUT z := :x</code>, is evaluated before the first statement is executed. Therefore, <code>x</code> still has its initialized value of <code>1</code>. After execution of this block, <code>x</code> will have the value <code>5</code> and <code>z</code> will have the value <code>1</code>.</p>
<p>The following example demonstrates the difference between two statements appearing in a PL/SQL block in one SQLJ executable statement, and the same statements appearing in separate (consecutive) SQLJ executable statements.</p>
<p>First, consider the following, where two statements are in a PL/SQL block.</p>
<pre>int y=1;
...
#sql { BEGIN :OUT y := :y + 1; :OUT x := :y + 1; END };
</pre>
<p>This example is evaluated as follows:</p>
<pre>#sql { BEGIN :OUT y := 1 + 1; :OUT x := 1 + 1; END };
</pre>
<p>The <code>:y</code> in the second statement is evaluated before either statement is executed. Therefore, <code>y</code> has not yet received its output from the first statement. After execution of this block, both <code>x</code> and <code>y</code> have the value <code>2</code>.</p>
<p>Now, consider the situation where the same two statements are in PL/SQL blocks in separate SQLJ executable statements.</p>
<pre>int y=1;
#sql { BEGIN :OUT y := :y + 1; END };
#sql { BEGIN :OUT x := :y + 1; END };
</pre>
<p>The first statement is evaluated as follows:</p>
<pre>#sql { BEGIN :OUT y := 1 + 1; END };
</pre>
<p>Then, it is executed and <code>y</code> is assigned the value <code>2</code>.</p>
<p>After execution of the first statement, the second statement is evaluated as follows:</p>
<pre>#sql { BEGIN :OUT x := 2 + 1; END };
</pre>
<p>This time, as opposed to the previous PL/SQL block example, <code>y</code> has already received the value <code>2</code> from execution of the previous statement. Therefore, x is assigned the value <code>3</code> after execution of the second statement.</p>
<p class="subhead2"><a id="JSQLJ309"></a>Expressions in PL/SQL Blocks Are Always Evaluated Once Only</p>
<p>Each host expression is evaluated once, and only once, regardless of program flow and logic.</p>
<p>Consider the following example of evaluation of host expression in a loop:</p>
<pre>int count = 0;
...
#sql {
   DECLARE
      n NUMBER
   BEGIN
      n := 1;
      WHILE n &lt;= 100 LOOP
         :IN (count++);
         n := n + 1;
      END LOOP;
   END
};
</pre>
<p>The Java <code>count</code> variable will have the value <code>0</code> when it is passed to SQL, because it is operated on by a postfix operator, as opposed to a prefix operator. It will then be incremented to <code>1</code> and will hold that value throughout execution of this PL/SQL block. It is evaluated only once as the SQLJ executable statement is parsed and then is replaced by the value <code>1</code> prior to SQL execution.</p>
<p>Consider the following example that illustrates the evaluation of host expressions in conditional blocks. This example demonstrates how each expression is always evaluated, regardless of the program flow. As the block is executed, only one branch of the <code>IF...THEN...ELSE</code> construct can be executed. However, before the block is executed, all expressions in the block are evaluated in the order that the statements appear.</p>
<pre>int x;
...
(operations on x)
...
#sql {
   DECLARE
      n NUMBER
   BEGIN
      n := :x;
      IF n &lt; 10 THEN
         n := :(x++);
      ELSE
         n := :x * :x;
      END LOOP;
   END
};
</pre>
<p>Say the operations performed on <code>x</code> resulted in <code>x</code> having a value of <code>15</code>. When the PL/SQL block is executed, the <code>ELSE</code> branch will be executed and the <code>IF</code> branch will not. However, all expressions in the PL/SQL block are evaluated before execution, regardless of program logic or flow. Therefore, <code>x++</code> is evaluated, then <code>x</code> is incremented, and then each <code>x</code> is evaluated in the <code>(x * x)</code> expression. The <code>IF...THEN...ELSE</code> block is evaluated as follows:</p>
<pre>IF n &lt; 10 THEN
   n := 15;
ELSE
   n := :16 * :16;
END LOOP;
</pre>
<p>After execution of this block, given an initial value of <code>15</code> for <code>x</code>, <code>n</code> will have the value <code>256</code>.</p>
<p class="subhead2"><a id="JSQLJ310"></a>Output Host Expressions Are Assigned Left to Right, Before Result Expression</p>
<p>Remember that <code>OUT</code> and <code>INOUT</code> host expressions are assigned in order from left to right, and then the result expression, if any, is assigned last. If the same variable is assigned more than once, then it will be overwritten according to this order, with the last assignment taking precedence.</p>
<p>The following example contains multiple output host expressions referencing the same variable:</p>
<pre>#sql { CALL foo(:OUT x, :OUT x) };
</pre>
<p>If <code>foo()</code> outputs the values <code>2</code> and <code>3</code>, respectively, then <code>x</code> will have the value <code>3</code> after the SQLJ executable statement has finished executing. The right-hand assignment will be performed last, thereby taking precedence.</p>
<p>The following example contains multiple output host expressions referencing the same object:</p>
<pre>MyClass x = new MyClass();
MyClass y = x;
...
#sql { ... :OUT (x.field):=1 ... :OUT (y.field):=2 ... };
</pre>
<p>After execution of the SQLJ executable statement, <code>x.field</code> will have a value of <code>2</code>, and not <code>1</code>, because <code>x</code> is the same object as <code>y</code>, and <code>field</code> was assigned the value of <code>2</code> after it was assigned the value of <code>1</code>.</p>
<p>The following example demonstrates the difference between having the output results of a function assigned to a result expression and having the results assigned to an <code>OUT</code> host expression. Consider the following function, with the <code>invar</code> input parameter, the <code>outvar</code> output parameter, and a return value:</p>
<pre>CREATE FUNCTION fn(invar NUMBER, outvar OUT NUMBER)
   RETURN NUMBER AS BEGIN
      outvar := invar + invar;
      return (invar * invar);
   END fn;
</pre>
<p>Now consider an example where the output of the function is assigned to a result expression:</p>
<pre>int x = 3;
#sql x = { VALUES(fn(:x, :OUT x)) };
</pre>
<p>The function will take <code>3</code> as the input, will calculate <code>6</code> as the output, and will return <code>9</code>. After execution, the <code>:OUT x</code> will be assigned first, giving <code>x</code> a value of <code>6</code>. But finally the result expression is assigned, giving <code>x</code> the return value of <code>9</code> and overwriting the value of <code>6</code> previously assigned to <code>x</code>. So <code>x</code> will have the value <code>9</code> the next time it is encountered.</p>
<p>Now consider an example where the output of the function is assigned to an <code>OUT</code> host variable instead of a result expression:</p>
<pre>int x = 3;
#sql { BEGIN :OUT x := fn(:x, :OUT x); END };
</pre>
<p>In this case, there is no result expression and the <code>OUT</code> variables are simply assigned left to right. After execution, the first <code>:OUT x</code>, on the left side of the equation, is assigned first, giving <code>x</code> the function return value of <code>9</code>. However, proceeding left to right, the second <code>:OUT x</code>, on the right side of the equation, is assigned last, giving <code>x</code> the output value of <code>6</code> and overwriting the value of <code>9</code> previously assigned to <code>x</code>. Therefore, <code>x</code> will have the value <code>6</code> the next time it is encountered.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Some unlikely cases have been used in these examples to explain the concepts of how host expressions are evaluated. In practice, it is not advisable to use the same variable in both an <code>OUT</code> or <code>INOUT</code> host expression or in an <code>IN</code> host expression inside a single statement or PL/SQL block. The behavior in such cases is well defined in the Oracle SQLJ implementation, but this practice is not covered in the SQLJ specification. Therefore, code written in this manner will not be portable. Such code will generate a warning from the SQLJ translator if the <code>portable</code> flag is set during semantics-checking.</div>
</div>
<!-- class="sect2" -->
<a id="i1006663"></a>
<div id="JSQLJ311" class="sect2">
<h3 class="sect2">Restrictions on Host <a id="sthref199"></a>Expressions</h3>
<p>Do not use <code>in</code>, <code>out</code>, and <code>inout</code> as identifiers in host expressions unless they are enclosed in parentheses. Otherwise, they might be mistaken for mode specifiers. This is not case-sensitive.</p>
<p>For example, you could use an input host variable called <code>in</code>, as follows:</p>
<pre>:(in)
</pre>
<p>or:</p>
<pre>:IN(in)
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006673"></a>
<div id="JSQLJ312" class="sect1">
<h2 class="sect1">Single-Row Query Results: SELECT INTO Statements</h2>
<p>When only a single row of data is being returned, SQLJ enables you to assign selected items directly to Java host expressions inside SQL syntax. This is done using the <code>SELECT INTO</code> statement. This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDJJCII">SELECT INTO Syntax</a></p>
</li>
<li>
<p><a href="#i1006708">Examples of SELECT INTO Statements</a></p>
</li>
<li>
<p><a href="#CHDCJJEF">Examples with Host Expressions in SELECT-List</a></p>
</li>
<li>
<p><a href="#CHDHBFFD">SELECT INTO Error Conditions</a></p>
</li>
</ul>
<a id="CHDJJCII"></a>
<div id="JSQLJ313" class="sect2">
<h3 class="sect2">SEL<a id="sthref200"></a>ECT INTO Syntax</h3>
<p>The syntax for a <code>SELECT INTO</code> statement is as follows:</p>
<pre>#sql { SELECT <span class="italic">expression1,..., expressionN </span> INTO :<span class="italic">host_exp1,..., </span>:<span class="italic">host_expN </span> 
       FROM <span class="italic">table </span>&lt;<span class="italic">optional_clauses</span>&gt; };
</pre>
<p>Keep in mind the following:</p>
<ul>
<li>
<p>The items <code><span class="codeinlineitalic">expression1</span></code> through <code><span class="codeinlineitalic">expressionN</span></code> are expressions specifying what is to be selected from the database. These can be any expressions valid for any <code>SELECT</code> statement. This list of expressions is referred to as the <code>SELECT</code>-list. In a simple case, these would be names of columns from a database table. It is also legal to include a host expression in the <code>SELECT</code>-list.</p>
</li>
<li>
<p>The items <code><span class="codeinlineitalic">host_exp1</span></code> through <code><span class="codeinlineitalic">host_expN</span></code> are target host expressions, such as variables or array elements. This list of host expressions is referred to as the <code>INTO</code>-list.</p>
</li>
<li>
<p>The item <code><span class="codeinlineitalic">table</span></code> is the name of the database table, view, or snapshot from which you are selecting the data.</p>
</li>
<li>
<p>The item <code><span class="codeinlineitalic">optional_clauses</span></code> is for any additional clauses you want to include that are valid in a <code>SELECT</code> statement, such as a <code>WHERE</code> clause.</p>
</li>
</ul>
<p>A <code>SELECT INTO</code> statement must return one, and only one, row of data, otherwise an error will be generated at run time.</p>
<p>The default is <code>OUT</code> for a host expression in an <code>INTO</code>-list, but you can optionally state this explicitly:</p>
<pre>#sql { SELECT <span class="italic">column_name1, column_name2 </span> INTO :OUT <span class="italic">host_exp1, </span>:OUT <span class="italic">host_exp2 </span> 
       FROM <span class="italic">table </span>WHERE <span class="italic">condition</span> };
</pre>
<p>Trying to use an <code>IN</code> or <code>INOUT</code> token in the <code>INTO</code>-list will result in an error at translation time.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Permissible syntax for <code><span class="codeinlineitalic">expression1</span></code> through <code><span class="codeinlineitalic">expressionN</span></code>, the <code><span class="codeinlineitalic">table</span></code>, and the optional clauses is the same as for any SQL <code>SELECT</code> statement.</p>
</li>
<li>
<p>There can be any number of <code>SELECT</code>-list and <code>INTO</code>-list items, as long as they match. That is, one INTO-list item per SELECT-list item, with compatible types.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006708"></a>
<div id="JSQLJ314" class="sect2">
<h3 class="sect2">Exa<a id="sthref201"></a>mples of SELECT INTO Statements</h3>
<p>The examples in this section use an employee table <code>EMP</code> with the following rows:</p>
<pre>CREATE TABLE EMP (
   EMPNO NUMBER(4),
   ENAME VARCHAR2(10),
   HIREDATE DATE );
</pre>
<p>The following is an example of a <code>SELECT INTO</code> statement with a single host expression in the <code>INTO</code>-list:</p>
<pre>String empname;
#sql { SELECT ename INTO :enpname FROM emp WHERE empno=28959 };
</pre>
<p>The following is an example of a <code>SELECT INTO</code> statement with multiple host expressions in the <code>INTO</code>-list:</p>
<pre>String empname;
Date hdate;
#sql { SELECT ename, hiredate INTO :empname, :hdate FROM emp 
       WHERE empno=28959 };
</pre></div>
<!-- class="sect2" -->
<a id="CHDCJJEF"></a>
<div id="JSQLJ315" class="sect2">
<h3 class="sect2">Exa<a id="sthref202"></a>mples with Host Expressions in SELECT-List</h3>
<p>It is legal to use Java host expressions in the <code>SELECT</code>-list as well as in the <code>INTO</code>-list. For example, you can select directly from one host expression into another, though this is of limited usefulness, as follows:</p>
<pre>...
#sql { SELECT :name1 INTO :name2 FROM emp WHERE empno=28959 };
...
</pre>
<p>More realistically, you may want to perform an operation or concatenation on the data selected, as in the following examples. Assume Java variables were previously declared and assigned, as necessary.</p>
<pre>...
#sql { SELECT sal + :raise INTO :newsal FROM emp WHERE empno=28959 };
...

...
#sql { SELECT :(firstname + &#34; &#34;) || emp_last_name INTO :name FROM myemp 
       WHERE empno=28959 };
...
</pre>
<p>In the second example, presume <code>myemp</code> is a table much like the <code>emp</code> table but with an <code>emp_last_name</code> column instead of an <code>ename</code> column. In the <code>SELECT</code> statement, <code>firstname</code> is prepended to a single space (&#34; &#34;), using a Java host expression and the Java string concatenation operator (<code>+</code>). This result is then passed to the SQL engine, which uses SQL string concatenation operator (<code>||</code>) to append the last name.</p>
</div>
<!-- class="sect2" -->
<a id="CHDHBFFD"></a>
<div id="JSQLJ316" class="sect2">
<h3 class="sect2">SELE<a id="sthref203"></a>CT INTO Error Conditions</h3>
<p>Remember that <code>SELECT INTO</code> statements are intended for queries that return exactly one row of data only. A <code>SELECT INTO</code> query that finds zero rows or multiple rows will result in an exception, as follows:</p>
<ul>
<li>
<p>A <code>SELECT INTO</code> finding no rows will return an exception with a SQL state of <code>2000</code>, representing a &#34;no data&#34; condition.</p>
</li>
<li>
<p>A <code>SELECT INTO</code> finding multiple rows will return an exception with a SQL state of <code>21000</code>, representing a cardinality violation.</p>
</li>
</ul>
<p>You can retrieve the SQL state through the <code>getSQLState()</code> method of the <code>java.sql.SQLException</code> class.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1006260">&#34;Retrieving SQL States and Error Codes&#34;</a></div>
<p>This is vendor-independent behavior that is specified in the ISO SQLJ standard. There is no vendor-specific error code in these cases. The error code is always <code>0</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006767"></a>
<div id="JSQLJ317" class="sect1">
<h2 class="sect1">Multirow Query Results: <a id="sthref204"></a>SQLJ Iterators</h2>
<p>A large number of SQL operations are multirow queries. Processing multirow query results in SQLJ requires a SQLJ iterator. A SQLJ iterator is a strongly typed version of a JDBC result set and is associated with the underlying database cursor. SQLJ iterators are primarily used to take query results from a <code>SELECT</code> statement.</p>
<p>Additionally, Oracle offers SQLJ extensions that enable you to use SQLJ iterators and result sets in the following ways:</p>
<ul>
<li>
<p>As <code>OUT</code> host variables in executable SQL statements</p>
</li>
<li>
<p>As <code>INTO</code>-list targets, such as in a <code>SELECT INTO</code> statement</p>
</li>
<li>
<p>As a return type from a stored function call</p>
</li>
<li>
<p>As column types in iterator declarations (essentially, nested iterators)</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
To use a SQLJ iterator in any of these ways, its class must be declared as <code>public</code>. If you declared it at the class level or nested-class level, then it might be advisable to declare it as <code>public static</code>.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDCBBDJ">Iterator Concepts</a></p>
</li>
<li>
<p><a href="#CHDIGAJJ">General Steps in Using an Iterator</a></p>
</li>
<li>
<p><a href="#CHDICJJD">Named, Positional, and Result Set Iterators</a></p>
</li>
<li>
<p><a href="#i1006968">Using Named Iterators</a></p>
</li>
<li>
<p><a href="#i1007114">Using Positional Iterators</a></p>
</li>
<li>
<p><a href="#i1007245">Using Iterators and Result Sets as Host Variables</a></p>
</li>
<li>
<p><a href="#CHDHGCDB">Using Iterators and Result Sets as Iterator Columns</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006593">&#34;Iterator Class Implementation and Advanced Functionality&#34;</a></div>
<a id="CHDCBBDJ"></a>
<div id="JSQLJ318" class="sect2">
<h3 class="sect2">Iterator <a id="sthref205"></a>Concepts</h3>
<p>Using a SQLJ iterator declaration results in a strongly typed iterator. This is the typical usage for iterators and takes particular advantage of SQLJ semantics-checking features during translation. It is also possible, and at times advantageous, to use weakly typed iterators. There are generic classes you can instantiate in order to use a weakly typed iterator.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDEAICG">Overview of Strongly Typed Iterators</a></p>
</li>
<li>
<p><a href="#CHDBBGFA">Overview of Weakly Typed Iterators</a></p>
</li>
</ul>
<a id="CHDEAICG"></a>
<div id="JSQLJ319" class="sect3">
<h4 class="sect3">Overview <a id="sthref206"></a><a id="sthref207"></a>of Strongly Typed Iterators</h4>
<p>Before using a strongly typed iterator object, you must declare an iterator class. An iterator declaration specifies a Java class that SQLJ constructs for you, where the class attributes define the type and, optionally, the name of the columns of data in the iterator.</p>
<p>A SQLJ iterator object is an instance of such a specifically declared iterator class, with a fixed number of columns of predefined type. This is as opposed to a JDBC result set object, which is a standard <code>java.sql.ResultSet</code> instance and can, in principle, contain any number of columns of any type.</p>
<p>When you declare an iterator, you specify either just the data type of the selected columns, or both the data type and the name of the selected columns:</p>
<ul>
<li>
<p>Specifying the names and data types defines a named iterator class.</p>
</li>
<li>
<p>Specifying just the data types defines a positional iterator class.</p>
</li>
</ul>
<p>The data types and names, if applicable, that you declare determine how query results will be stored in iterator objects you instantiate from that class. SQL data retrieved into an iterator object are converted to the Java types specified in the iterator declaration.</p>
<p>When you query to populate a named iterator object, the name and data type of the columns in the <code>SELECT</code> statement must match the name and data type of the iterator columns. However, this is not case-sensitive. The order of the columns in the <code>SELECT</code> statement is irrelevant. All that matters is that each column name in the <code>SELECT</code> statement matches an iterator column name. In the simplest case, the database column names directly match the iterator column names.</p>
<p>For example, data from an <code>ENAME</code> column in a database table can be selected and put into an iterator <code>ename</code> column. Alternatively, you can use an alias to map a database column name to an iterator column name if the names differ. Also, in a more complicated query, you can perform an operation between two columns and alias the result to match the corresponding iterator column name.</p>
<p>Because SQLJ iterators are strongly typed, they offer the benefit of Java type-checking during the SQLJ semantics-checking phase.</p>
<p>As an example, consider the following table:</p>
<pre>CREATE TABLE EMPSAL (
   EMPNO NUMBER(4),
   ENAME VARCHAR2(10),
   OLDSAL NUMBER(10),
   RAISE NUMBER(10) );
</pre>
<p>Given this table, you can declare a named iterator as follows.</p>
<pre>#sql iterator SalNamedIter (int empno, String ename, float raise);
</pre>
<p>Once declared, you can use this named iterator as follows:</p>
<pre>class MyClass {
   void func() throws SQLException {
      ...
      SalNamedIter niter;
      #sql niter = { SELECT ename, empno, raise FROM empsal };
    
      ... <span class="italic">process niter</span> ...
   }
}
</pre>
<p>This is a simple case where the iterator column names match the table column names. Note that the order of items in the <code>SELECT</code> statement does not matter when you use a named iterator. Data is matched by name, not position.</p>
<p>When you query to populate a positional iterator object, the data is retrieved according to the order in which you select the columns. Data from the first column selected from the database table is placed into the first column of the iterator, and so on. The data types of the table columns must be convertible to the types of the iterator columns, but the names of the database columns are irrelevant, as the iterator columns have no names.</p>
<p>Given the <code>EMPSAL</code> table, you can declare a positional iterator as follows:</p>
<pre>#sql iterator SalPosIter (int, String, float);
</pre>
<p>You can use this positional iterator as follows:</p>
<pre>class MyClass {
   void func() throws SQLException {
      ...
      SalPosIter piter;
      #sql piter = { SELECT empno, ename, raise FROM empsal };
    
      ... <span class="italic">process piter</span> ...
   }
}
</pre>
<p>Note that the order of the data items in the <code>SELECT</code> statement must be the same as in the iterator. The processing differs between named iterators and positional iterators.</p>
<p class="subhead2"><a id="JSQLJ320"></a>General Iterator Notes</p>
<p>In addition to the preceding concepts, be aware of the following general notes about iterators:</p>
<ul>
<li>
<p>The <code>SELECT *</code> syntax is allowed in populating an iterator, but is not recommended. In the case of a positional iterator, this requires that the number of columns in the table be equal to the number of columns in the iterator, and that the data types match in order. In the case of a named iterator, this requires that the number of columns in the table be greater than or equal to the number of columns in the iterator and that the name and data type of each iterator column match a database table column. However, if the number of columns in the table is greater, then a warning will be generated unless the translator <code>-warn=nostrict</code> flag is set.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007284">&#34;Translator Warnings (-warn)&#34;</a></div>
</li>
<li>
<p>Positional and named iterators are distinct and incompatible kinds of Java classes. An iterator object of one kind cannot be cast to an iterator object of the other kind.</p>
</li>
<li>
<p>Unlike a SQL cursor, an iterator instance is a first-class Java object. That is, it can be passed and returned as a method parameter, for example. Also, an iterator instance can be declared using Java class modifiers, such as <code>public</code> or <code>private</code>.</p>
</li>
<li>
<p>SQLJ supports interoperability and conversion between SQLJ iterators and JDBC result sets.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1007230">&#34;SQLJ Iterator and JDBC Result Set Interoperability&#34;</a></div>
</li>
<li>
<p>Generally speaking, the contents of an iterator is determined only by the state of the database at the time of execution of the <code>SELECT</code> statement that populated it. Subsequent <code>UPDATE</code>, <code>INSERT</code>, <code>DELETE</code>, <code>COMMIT</code>, or <code>ROLLBACK</code> operations have no effect on the iterator or its contents. The exception to this is if you declare an iterator to be scrollable and sensitive to changes in the data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1006416">&#34;Effect of Commits and Rollbacks on Iterators and Result Sets&#34;</a>, <a href="alangfea.htm#i1006761">&#34;Declaring Scrollable Iterators&#34;</a>, and <a href="alangfea.htm#i1006775">&#34;Scrollable Iterator Sensitivity&#34;</a>.</div>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CHDBBGFA"></a>
<div id="JSQLJ321" class="sect3">
<h4 class="sect3">Overview of <a id="sthref208"></a><a id="sthref209"></a>Weakly Typed Iterators</h4>
<p>In case you do not want to declare an iterator class, the Oracle SQLJ implementation enables you to use a weakly typed iterator. Such iterators are known as result set iterators. To use a plain, that is, nonscrollable result set iterator, instantiate the <code>sqlj.runtime.ResultSetIterator</code> class. To use a scrollable result set iterator, instantiate the <code>sqlj.runtime.ScrollableResultSetIterator</code> class.</p>
<p>The drawback to using result set iterators, compared to strongly typed iterators, is that SQLJ cannot perform as much semantics-checking for your queries.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006751">&#34;Scrollable Iterators&#34;</a> and <a href="alangfea.htm#i1006712">&#34;Result Set Iterators&#34;</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDIGAJJ"></a>
<div id="JSQLJ322" class="sect2">
<h3 class="sect2">General Steps in <a id="sthref210"></a>Using an Iterator</h3>
<p>You must follow the following general steps to use SQLJ named or positional iterator:</p>
<ol>
<li>
<p>Use a SQLJ declaration to define the iterator class (in other words, to define the iterator type).</p>
</li>
<li>
<p>Declare a variable of the iterator class.</p>
</li>
<li>
<p>Populate the iterator variable with the results from a SQL query, using a <code>SELECT</code> statement.</p>
</li>
<li>
<p>Access the query columns in the iterator. How to accomplish this differs between named iterators and positional iterators.</p>
</li>
<li>
<p>When you finish processing the results of the query, close the iterator to release its resources.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CHDICJJD"></a>
<div id="JSQLJ323" class="sect2">
<h3 class="sect2">Named, <a id="sthref211"></a>Positional, and Result Set Iterators</h3>
<p>There are advantages and appropriate situations for each kind of SQLJ iterator.</p>
<p>Named iterators enable greater flexibility. Because data selection into a named iterator matches the columns in the <code>SELECT</code> statement to iterator columns by name, you need not be concerned about the order in your query. This is less prone to error, as it is not possible for data to be placed into the wrong column. If the names do not match, then the SQLJ translator will generate an error when it checks the SQL statements against the database.</p>
<p>Positional iterators offer a familiar paradigm and syntax to developers who have experience with other embedded-SQL languages. With named iterators you use a <code>next()</code> method to retrieve data, while with positional iterators you use <code>FETCH INTO</code> syntax similar to that of Pro*C, for example. Each fetch implicitly advances to the next available row of the iterator before retrieving the next set of values.</p>
<p>However, positional iterators do offer less flexibility than named iterators, because you are selecting data into iterator columns by position, instead of by name. You must be certain of the order of items in your <code>SELECT</code> statement. Also, you must select data into all columns of the iterator. It is possible to have data written into the wrong iterator column, if the data type of that column happens to match the data type of the table column being selected.</p>
<p>Access to individual data elements is also less convenient with positional iterators. Named iterators, because they store data by name, are able to have convenient accessor methods for each column. For example, there would be an <code>ename()</code> method to retrieve data from an <code>ename</code> iterator column. With positional iterators, you must fetch data directly into Java host expressions with the <code>FETCH INTO</code> statement, and the host expressions must be in the correct order.</p>
<p>If you do not want to declare strongly typed iterator classes for your queries, then you can choose the alternative of using weakly typed result set iterators. Result set iterators are most convenient when converting JDBC code to SQLJ code. You must balance this consideration against the fact that result set iterators, either <code>ResultSetIterator</code> instances or <code>ScrollableResultSetIterator</code> instances, do not allow complete SQLJ semantics-checking during translation. With named or positional iterators, SQLJ verifies that the data types of columns in the <code>SELECT</code> statement match the Java types into which the data will be materialized. With result set iterators, this is not possible.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006712">&#34;Result Set Iterators&#34;</a></div>
<p class="subhead2"><a id="JSQLJ324"></a>Comparative Iterator Notes</p>
<p>Be aware of the following notes regarding SQLJ iterators:</p>
<ul>
<li>
<p>In populating a positional iterator, the number of columns you select from the database must equal the number of columns in the iterator. In populating a named iterator, the number of columns you select from the database can never be less than the number of columns in the iterator, but can be greater than the number of columns in the iterator if you have the translator <code>-warn=nostrict</code> flag set. Unmatched columns are ignored in this case.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007284">&#34;Translator Warnings (-warn)&#34;</a></div>
</li>
<li>
<p>Although the term &#34;fetching&#34; often refers to fetching data from a database, remember that a <code>FETCH INTO</code> statement for a positional iterator does not necessarily involve a round trip to the server. This depends on the row-prefetch value. This is because you are fetching data from the iterator, and not the database. However, if the row-prefetch value is <code>1</code>, then each fetch does involve a separate trip to the database. The row-prefetch value determines how many rows are retrieved with each trip to the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apppfdbg.htm#i1005601">&#34;Row Prefetching&#34;</a></div>
</li>
<li>
<p>Result set iterators use the same <code>FETCH INTO</code> syntax that is used with positional iterators and are subject to the same restriction at run time. That is, the number of data items in the <code>SELECT</code>-list must match the number of variables that are assigned data in the <code>FETCH</code> statement.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006968"></a>
<div id="JSQLJ325" class="sect2">
<h3 class="sect2">Using Named <a id="sthref212"></a><a id="sthref213"></a>Iterators</h3>
<p>When you declare a named iterator class, you declare the name as well as the data type of each column of the iterator. When you select data into a named iterator, the columns in the <code>SELECT</code> statement must match the iterator columns in two ways:</p>
<ul>
<li>
<p>The name of each data item in the <code>SELECT</code> statement, either a table column name or an alias, must match an iterator column name. However, this is not case-sensitive. That is, <code>ename</code> or <code>Ename</code> would match <code>ENAME</code>).</p>
</li>
<li>
<p>The data type of each iterator column must be compatible with the data type of the corresponding data item in the <code>SELECT</code> statement according to standard JDBC type mappings.</p>
</li>
</ul>
<p>The order in which attributes are declared in the named iterator class declaration is irrelevant. Data is selected into the iterator based on name alone.</p>
<p>A named iterator has a <code>next()</code> method to retrieve data row by row and an accessor method for each column to retrieve the individual data items. The accessor method names are identical to the column names. Unlike most accessor method names in Java, accessor method names in named iterator classes do not start with <code>get</code>. For example, a named iterator object with a column <code>sal</code> would have a <code>sal()</code> accessor method.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following restrictions apply in naming the columns of a named iterator:
<ul>
<li>
<p>Column names cannot use Java reserved words.</p>
</li>
<li>
<p>Column names cannot have the same name as utility methods provided in named iterator classes, such as the <code>next()</code>, <code>close()</code>, <code>getResultSet()</code>, and <code>isClosed()</code> methods. For scrollable named iterators, this includes additional methods such as <code>previous()</code>, <code>first()</code>, and <code>last()</code>.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JSQLJ326"></a>Declaring <a id="sthref214"></a><a id="sthref215"></a>Named Iterator Classes</p>
<p>Use the following syntax to declare a named iterator class:</p>
<pre>#sql &lt;<span class="italic">modifiers</span>&gt; iterator <span class="italic">classname</span> &lt;<span class="italic">implements clause</span>&gt; &lt;<span class="italic">with clause</span>&gt; 
     ( <span class="italic">type-name-list</span> );
</pre>
<p>In this syntax, <code><span class="codeinlineitalic">modifiers</span></code> is an optional sequence of legal Java class modifiers, <code><span class="codeinlineitalic">classname</span></code> is the desired class name for the iterator, and <code><span class="codeinlineitalic">type-name-list</span></code> is a list of the Java types and names equivalent to or compatible with the column types and column names in a database table.</p>
<p>The <code>implements</code> clause and <code>with</code> clause are optional, specifying interfaces to implement and variables to define and initialize, respectively.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005681">&#34;Declaration IMPLEMENTS Clause&#34;</a> and <a href="#CBBBBJEC">&#34;Declaration WITH Clause&#34;</a></div>
<p>Consider the following table:</p>
<pre>CREATE TABLE PROJECTS (
   ID NUMBER(4),
   PROJNAME VARCHAR(30),
   START_DATE DATE,
   DURATION NUMBER(3) );
</pre>
<p>You can declare the following named iterator to use with this table:</p>
<pre>#sql public iterator ProjIter (String projname, int id, Date deadline);
</pre>
<p>This will result in an iterator class with columns of data accessible, using the following provided accessor methods: <code>projname()</code>, <code>id()</code>, and <code>deadline()</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
As with standard Java, any public class should be declared in one of the following ways:
<ul>
<li>
<p>Declare it in a separate source file. The base name of the file should be the same as the class name.</p>
</li>
<li>
<p>Declare it at class-level scope or nested-class-level scope, with <code>public static</code> modifiers.</p>
</li>
</ul>
<p>This is a requirement if you are using the standard <code>javac</code> compiler provided with the Sun Microsystems JDK.</p>
</div>
<p class="subhead2"><a id="i1007035"></a><a id="JSQLJ327"></a>Instantiating and <a id="sthref216"></a><a id="sthref217"></a>Populating Named Iterators</p>
<p>Continuing to use the <code>PROJECTS</code> table and <code>ProjIter</code> iterator defined in the preceding section, note that there are columns in the table whose names and data types match the <code>id</code> and <code>projname</code> columns of the iterator. However, you must use an alias and perform an operation to populate the <code>deadline</code> column of the iterator. Following is an example:</p>
<pre>ProjIter projsIter;

#sql projsIter = { SELECT start_date + duration AS deadline, projname, id 
                   FROM projects WHERE start_date + duration &gt;= sysdate };
</pre>
<p>This calculates a deadline for each project by adding its duration to its start date, then aliases the results as <code>deadline</code> to match the <code>deadline</code> iterator column. It also uses a <code>WHERE</code> clause so that only future deadlines are processed, that is, deadlines beyond the current system date in the database.</p>
<p>Similarly, you must create an alias if you want to use a function call. Suppose you have a <code>MAXIMUM()</code> function that takes a <code>DURATION</code> entry and an integer as input and returns the maximum of the two. For example, you could input the value <code>3</code> to ensure that each project has at least a three-month duration in your application.</p>
<p>Now, presume you are declaring your iterator as follows:</p>
<pre>#sql public iterator ProjIter2 (String projname, int id, float duration);
</pre>
<p>You could use the <code>MAXIMUM()</code> function in your query, with an alias for the result, as follows:</p>
<pre>ProjIter2 projsIter2;

#sql projsIter2 = { SELECT id, projname, maximum(duration, 3) AS duration 
                    FROM projects };
</pre>
<p>Generally, you must use an alias in your query for any data item in the <code>SELECT</code> statement whose name is not a legal Java identifier or does not match a column name in the iterator.</p>
<p>Remember that in populating a named iterator, the number of columns you select from the database can never be less than the number of columns in the iterator. The number of columns you select can be greater than the number of columns in the iterator, because unmatched columns are ignored. However, this will generate a warning, unless you have the SQLJ <code>-warn=nostrict</code> option set.</p>
<p class="subhead2"><a id="i1007058"></a><a id="JSQLJ328"></a>Accessing <a id="sthref218"></a><a id="sthref219"></a>Named Iterators</p>
<p>Use the <code>next()</code> method of the named iterator object to step through the data that was selected into it. To access each column of each row, use the accessor methods generated by SQLJ, typically inside a <code>while</code> loop.</p>
<p>Whenever <code>next()</code> is called:</p>
<ul>
<li>
<p>If there is another row to retrieve from the iterator, then <code>next()</code> retrieves the row and returns <code>true</code>.</p>
</li>
<li>
<p>If there are no more rows to retrieve, <code>next()</code> returns <code>false</code>.</p>
</li>
</ul>
<p>The following is an example of how to access the data of a named iterator, repeating the declaration, instantiation, and population code illustrated in the preceding section.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Each iterator has a <code>close()</code> method that you must always call when you finish retrieving data from the iterator. This is necessary to close the iterator and free its resources.</div>
<p>Presume the following iterator class declaration:</p>
<pre>#sql public iterator ProjIter (String projname, int id, Date deadline);
</pre>
<p>Populate and then access an instance of this iterator class as follows:</p>
<pre>// Declare the iterator variable
ProjIter projsIter;

// Instantiate and populate iterator; order of SELECT doesn&#39;t matter
#sql projsIter = { SELECT start_date + duration AS deadline, projname, id 
                   FROM projects WHERE start_date + duration &gt;= sysdate };

// Process the results
while (projsIter.next()) {
   System.out.println(&#34;Project name is &#34; + projsIter.projname());
   System.out.println(&#34;Project ID is &#34; + projsIter.id());
   System.out.println(&#34;Project deadline is &#34; + projsIter.deadline());
}  

// Close the iterator
projsIter.close();
...
</pre>
<p>Note the convenient use of the <code>projname()</code>, <code>id()</code>, and <code>deadline()</code> accessor methods to retrieve the data. Note also that the order of the <code>SELECT</code> items does not matter, nor does the order in which the accessor methods are used.</p>
<p>However, remember that accessor method names are created with the case exactly as in your declaration of the iterator class. The following will generate compilation errors.</p>
<p>Consider the following declaration of the iterator:</p>
<pre>#sql iterator Cursor1 (String NAME);
</pre>
<p>The code for using the iterator is as follows:</p>
<pre>...
Cursor1 c1;
#sql c1 = { SELECT NAME FROM TABLE };
while (c1.next()) {
   System.out.println(&#34;The name is &#34; + c1.name());
}
...
</pre>
<p>The <code>Cursor1</code> class has a method called <code>NAME()</code>, and not <code>name()</code>. You will have to use <code>c1.NAME()</code> in the <code>System.out.println</code> statement.</p>
</div>
<!-- class="sect2" -->
<a id="i1007114"></a>
<div id="JSQLJ329" class="sect2">
<h3 class="sect2">Using Positional <a id="sthref220"></a><a id="sthref221"></a>Iterators</h3>
<p>When you declare a positional iterator class, you declare the data type of each column but not the column name. The Java types into which the columns of the SQL query results are selected must be compatible with the data types of the SQL data. The names of the database columns or data items in the <code>SELECT</code> statement are irrelevant. Because names are not used, the order in which you declare your positional iterator Java types must exactly match the order in which the data is selected.</p>
<p>To retrieve data from a positional iterator once data has been selected into it, use a <code>FETCH INTO</code> statement followed by an <code>endFetch()</code> method call to determine if you have reached the end of the data.</p>
<p class="subhead2"><a id="i1007126"></a><a id="JSQLJ330"></a>Declaring <a id="sthref222"></a><a id="sthref223"></a>Positional Iterator Classes</p>
<p>Use the following syntax to declare a positional iterator class:</p>
<pre>#sql &lt;<span class="italic">modifiers</span>&gt; iterator <span class="italic">classname</span> &lt;<span class="italic">implements clause</span>&gt; &lt;<span class="italic">with clause</span>&gt; 
     ( <span class="italic">position-list</span> );
</pre>
<p>In this syntax, <code><span class="codeinlineitalic">modifiers</span></code> is an optional sequence of legal Java class modifiers and the <code><span class="codeinlineitalic">position-list</span></code> is a list of Java types compatible with the column types in a database table.</p>
<p>The <code>implements</code> clause and <code>with</code> clause are optional, specifying interfaces to implement and variables to define and initialize, respectively.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005681">&#34;Declaration IMPLEMENTS Clause&#34;</a> and <a href="#CBBBBJEC">&#34;Declaration WITH Clause&#34;</a></div>
<p>Now consider an employee table <code>EMP</code> with the following rows:</p>
<pre>CREATE TABLE EMP (
   EMPNO NUMBER(4),
   ENAME VARCHAR2(10), 
   SAL NUMBER(7,2) );
</pre>
<p>And consider the following positional iterator declaration:</p>
<pre>#sql public iterator EmpIter (String, int, float);
</pre>
<p>This example defines the <code>EmpIter</code> Java class with unnamed <code>String</code>, <code>int</code>, and <code>float</code> columns. Note that the table columns and iterator columns are in a different order, with the <code>String</code> corresponding to <code>ENAME</code> and the <code>int</code> corresponding to <code>EMPNO</code>. The order of the iterator columns determines the order in which you must select the data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
As with standard Java, any public class should be declared in one of the following ways:
<ul>
<li>
<p>Declare it in a separate source file. The base name of the file should be the same as the class name.</p>
</li>
<li>
<p>Declare it at class-level scope or nested-class-level scope, with <code>public static</code> modifiers.</p>
</li>
</ul>
<p>This is a requirement if you are using the standard <code>javac</code> compiler provided with the Sun Microsystems JDK.</p>
</div>
<p class="subhead2"><a id="i1007169"></a><a id="JSQLJ331"></a>Instantiating and <a id="sthref224"></a><a id="sthref225"></a>Populating Positional Iterators</p>
<p>Instantiating and populating a positional iterator is no different than doing so for a named iterator, except that you must be certain that the data items in the <code>SELECT</code> statement are in the proper order.</p>
<p>The three data types in the <code>EmpIter</code> iterator class are compatible with the types of the <code>EMP</code> table, but be careful how you select the data, because the order is different. The following will work, because the data items in the <code>SELECT</code> statement are in the same order as the iterator columns:</p>
<pre>EmpIter empsIter;

#sql empsIter = { SELECT ename, empno, sal FROM emp };
</pre>
<p>Remember that in populating a positional iterator, the number of columns you select from the database must equal the number of columns in the iterator.</p>
<p class="subhead2"><a id="i1007183"></a><a id="JSQLJ332"></a>Accessing <a id="sthref226"></a><a id="sthref227"></a>Positional Iterators</p>
<p>Access the columns defined by a positional iterator using SQL <code>FETCH INTO</code> syntax. The <code>INTO</code> part of the command specifies Java host variables that receive the results columns. The host variables must be in the same order as the corresponding iterator columns. Use the <code>endFetch()</code> method provided with all positional iterator classes to determine whether the last fetch reached the end of the data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The <code>endFetch()</code> method initially returns <code>true</code> before any rows have been fetched, then returns <code>false</code> once a row has been successfully retrieved, and then returns <code>true</code> again when a <code>FETCH</code> finds no more rows to retrieve. Therefore, you must perform the <code>endFetch()</code> test <span class="italic">after</span> the <code>FETCH INTO</code> statement. If your <code>endFetch()</code> test precedes the <code>FETCH INTO</code> statement, then you will never retrieve any rows, because <code>endFetch()</code> would be true before your first <code>FETCH</code> and you would immediately break out of the <code>while</code> loop.</p>
</li>
<li>
<p>The <code>endFetch()</code> test must be <span class="italic">before</span> the results are processed, however, because the <code>FETCH</code> does not throw a SQL exception when it reaches the end of the data, it just triggers the next <code>endFetch()</code> call to return <code>true</code>. If there is no <code>endFetch()</code> test before results are processed, then your code will try to process <code>NULL</code> or invalid data from the first <code>FETCH</code> attempt after the end of the data had been reached.</p>
</li>
<li>
<p>Each iterator has a <code>close()</code> method that you must always call once you finish retrieving data from it. This is necessary to close the iterator and free its resources.</p>
</li>
</ul>
</div>
<p>The following is an example, repeating the declaration, instantiation, and population code illustrated in the preceding section. Note that the Java host variables in the <code>SELECT</code> statement are in the same order as the columns of the positional iterator, which is mandatory.</p>
<p>First, presume the following iterator class declaration:</p>
<pre>#sql public iterator EmpIter (String, int, float);
</pre>
<p>Populate and then access an instance of this iterator class as follows:</p>
<pre>// Declare and initialize host variables
int empnum=0;
String empname=null;
float salary=0.0f;

// Declare an iterator instance
EmpIter empsIter;

#sql empsIter = { SELECT first_name, employee_id, salary FROM employees };

while (true) {
   #sql { FETCH :empsIter INTO :empnum, :empname, :salary };
   if (empsIter.endFetch()) break;  // This test must be AFTER fetch,
                                    // but before results are processed.
   System.out.println(&#34;Name is &#34; + empname);
   System.out.println(&#34;Employee number is &#34; + empnum);
   System.out.println(&#34;Salary is &#34; + salary);
}

// Close the iterator
empsIter.close();
...
</pre>
<p>The <code>empname</code>, <code>empnum</code>, and <code>salary</code> variables are Java host variables whose types must match the types of the iterator columns.</p>
<p>Do not use the <code>next()</code> method for a positional iterator. A <code>FETCH</code> operation calls it implicitly to move to the next row.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Host variables in a <code>FETCH INTO</code> statement must always be initialized because they are assigned in one branch of a conditional statement. Otherwise, you will get a compiler error indicating they may never be assigned. <code>FETCH</code> can assign the variables only if there was a row to be fetched.</div>
<p class="subhead2"><a id="JSQLJ333"></a>Positional Ite<a id="sthref228"></a><a id="sthref229"></a>rator Navigation with the next() Method</p>
<p>The positional iterator <code>FETCH</code> clause discussed in the preceding section performs a movement, an implicit <code>next()</code> call, before it populates the host variables, if any. As an alternative, the Oracle SQLJ implementation supports a special <code>FETCH</code> syntax in conjunction with explicit <code>next()</code> calls in order to use the same movement logic as with JDBC result sets and SQLJ named iterators. Using this special <code>FETCH</code> syntax, the semantics differ. There is no implicit <code>next()</code> call before the <code>INTO</code>-list is populated.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1006889">&#34;FETCH CURRENT Syntax: from JDBC Result Sets to SQLJ Iterators&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1007245"></a>
<div id="JSQLJ334" class="sect2">
<h3 class="sect2">Using <a id="sthref230"></a><a id="sthref231"></a><a id="sthref232"></a>Iterators and Result Sets as Host Variables</h3>
<p>SQLJ supports SQLJ iterators and JDBC result sets as host variables. Using iterators and result sets is fundamentally the same, with differences in declarations and in accessor methods to retrieve the data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Additionally, SQLJ supports iterators and result sets as return variables for stored functions.</p>
</li>
<li>
<p>Oracle JDBC drivers currently do <span class="italic">not</span> support result sets as input host variables. There is a <code>setCursor()</code> method in the <code>OraclePreparedStatement</code> class, but it raises an exception at run time, if called.</p>
</li>
</ul>
</div>
<p>For the examples in this section, consider the following department and employee tables:</p>
<pre>CREATE TABLE DEPT (
   DEPTNO NUMBER(2),
   DNAME VARCHAR2(14) );

CREATE TABLE EMP (
   EMPNO NUMBER(4),
   ENAME VARCHAR2(10), 
   SAL NUMBER(7,2), 
   DEPTNO NUMBER(2) );
</pre>
<p class="subhead2"><a id="JSQLJ335"></a>Example: Use of Result Set as OUT Host Variable</p>
<p>This example uses a JDBC result set as an output host variable.</p>
<pre>...
ResultSet rs;
...
#sql { BEGIN
          OPEN :OUT rs FOR SELECT ename, empno FROM emp;
       END };

while (rs.next())
{
   String empname = rs.getString(1);
   int empnum = rs.getInt(2);
}
rs.close();
...
</pre>
<p>This example opens the result set <code>rs</code> in a PL/SQL block to receive data from a <code>SELECT</code> statement, selects data from the <code>ENAME</code> and <code>EMPNO</code> columns of the <code>EMP</code> table, and then loops through the result set to retrieve data into local variables.</p>
<p class="subhead2"><a id="JSQLJ336"></a>Example: Use of Iterator as OUT Host Variable</p>
<p>This example uses a named iterator as an output host variable.</p>
<p>The iterator can be declared as follows:</p>
<pre>#sql public &lt;static&gt; iterator EmpIter (String ename, int empno);
</pre>
<p>The <code>public</code> modifier is required, and the <code>static</code> modifier may be advisable if your declaration is at class level or nested-class level.</p>
<p>This iterator can be used as follows:</p>
<pre>...
EmpIter iter;
...
#sql { BEGIN
          OPEN :OUT iter FOR SELECT ename, empno FROM emp;
       END };

while (iter.next())
{
   String empname = iter.ename();
   int empnum = iter.empno();
   
   ...<span class="italic">process/output empname and empnum</span>...
}
iter.close();
...
</pre>
<p>This example opens the iterator <code>iter</code> in a PL/SQL block to receive data from a <code>SELECT</code> statement, selects data from the <code>ENAME</code> and <code>EMPNO</code> columns of the <code>EMP</code> table, and then loops through the iterator to retrieve data into local variables.</p>
<p class="subhead2"><a id="JSQLJ337"></a>Example: Use of Iterator as OUT Host Variable for SELECT INTO</p>
<p>This example uses a named iterator as an output host variable, taking data through a <code>SELECT INTO</code> statement. <code>OUT</code> is the default for host variables in an <code>INTO</code>-list.</p>
<p>The iterator can be declared as follows:</p>
<pre>#sql public &lt;static&gt; iterator ENameIter (String ename);
</pre>
<p>The <code>public</code> modifier is required, and the <code>static</code> modifier may be advisable if your declaration is at class level or nested-class level.</p>
<p>This iterator can be used as follows:</p>
<pre>...
ENameIter enamesIter;
String deptname;
...

#sql { SELECT dname, cursor 
      (SELECT ename FROM emp WHERE deptno = dept.deptno)
       INTO :deptname, :enamesIter FROM dept WHERE deptno = 20 };

System.out.println(deptname);
while (enamesIter.next())
{
   System.out.println(enamesIter.ename());
}
enamesIter.close();
... 
</pre>
<p>This example uses nested <code>SELECT</code> statements to accomplish the following:</p>
<ul>
<li>
<p>Select the name of department number 20 from the <code>DEPT</code> table, selecting it into the <code>deptname</code> output host variable.</p>
</li>
<li>
<p>Query the <code>EMP</code> table to select all employees whose department number is 20, selecting the resulting cursor into the <code>enamesIter</code> output host variable, which is a named iterator.</p>
</li>
<li>
<p>Print the department name.</p>
</li>
<li>
<p>Loop through the named iterator printing employee names. This prints the names of all employees in the department.</p>
</li>
</ul>
<p>In most cases, using <code>SELECT INTO</code> is more convenient than using nested iterators if you are retrieving a single row in the outer <code>SELECT</code>, although that option is also available. Also, with nested iterators, you would have to process the data to determine how many rows there are in the outer <code>SELECT</code>. With <code>SELECT INTO</code> you are assured of just one row.</p>
</div>
<!-- class="sect2" -->
<a id="CHDHGCDB"></a>
<div id="JSQLJ338" class="sect2">
<h3 class="sect2">Using <a id="sthref233"></a><a id="sthref234"></a>Iterators and Result Sets as Iterator Columns</h3>
<p>The Oracle SQLJ implementation includes extensions that allow iterator declarations to specify columns of <code>ResultSet</code> type or columns of other iterator types declared within the current scope. In other words, iterators and result sets can exist within iterators. These column types are used to retrieve a column in the form of a cursor. This is useful for nested <code>SELECT</code> statements that return nested table information.</p>
<p>The following examples are functionally identical. Each uses a nested result set or iterator, that is, result sets or iterators in a column within an iterator, to print all the employees in each department in the <code>DEPT</code> table. The first example uses result sets within a named iterator, the second example uses named iterators within a named iterator, and the third example uses named iterators within a positional iterator.</p>
<p>Following are the steps:</p>
<ol>
<li>
<p>Select each department name (<code>DNAME</code>) from the <code>DEPT</code> table.</p>
</li>
<li>
<p>Do a nested <code>SELECT</code> into a cursor to get all employees from the <code>EMP</code> table for each department.</p>
</li>
<li>
<p>Put the department names and sets of employees into the outer iterator (<code>iter</code>), which has a name column and an iterator column. The cursor with the employee information for any given department goes into the iterator column of the row of the outer iterator corresponding to the department.</p>
</li>
<li>
<p>Go through a nested loop that, for each department, prints the department name and then loops through the inner iterator to print all employee names for that department.</p>
</li>
</ol>
<p class="subhead2"><a id="JSQLJ339"></a>Example: Result Set Column in a Named Iterator</p>
<p>This example uses a column of type <code>ResultSet</code> in a named iterator.</p>
<p>The iterator can be declared as follows:</p>
<pre>#sql iterator DeptIter (String dname, ResultSet emps);
</pre>
<p>The code that uses the iterator is as follows:</p>
<pre>...
DeptIter iter;
...
#sql iter = { SELECT dname, cursor 
             (SELECT ename FROM emp WHERE deptno = dept.deptno) 
              AS emps FROM dept };

while (iter.next())
{
   System.out.println(iter.dname());
   ResultSet enamesRs = iter.emps();
   while (enamesRs.next())
   {
      String empname = enamesRs.getString(1);
      System.out.println(empname);
   }
   enamesRs.close();
}
iter.close();
...
</pre>
<p class="subhead2"><a id="JSQLJ340"></a>Example: Named Iterator Column in a Named Iterator</p>
<p>This example uses a named iterator that has a column whose type is that of a previously defined named iterator (nested iterators).</p>
<p>The iterator declaration is as follows:</p>
<pre>#sql iterator ENameIter (String ename);
#sql iterator DeptIter (String dname, ENameIter emps);
</pre>
<p>The code that uses this iterator is as follows:</p>
<pre>...
DeptIter iter;
...
#sql iter = { SELECT dname, cursor 
             (SELECT ename FROM emp WHERE deptno = dept.deptno) 
              AS emps FROM dept };

while (iter.next())
{
   System.out.println(iter.dname());
   ENameIter enamesIter = iter.emps();
   while (enamesIter.next())
   {
      System.out.println(enamesIter.ename());
   }
   enamesIter.close();
}
iter.close();
...
</pre>
<p class="subhead2"><a id="JSQLJ341"></a>Example: Named Iterator Column in a Positional Iterator</p>
<p>This example uses a positional iterator that has a column whose type is that of a previously defined named iterator (nested iterators). This uses the <code>FETCH INTO</code> syntax of positional iterators. This example is functionally equivalent to the previous two.</p>
<p>Note that because the outer iterator is a positional iterator, there does not have to be an alias to match a column name, as was required when the outer iterator was a named iterator in the previous example.</p>
<p>The iterator declaration is as follows:</p>
<pre>#sql iterator ENameIter (String ename);
#sql iterator DeptIter (String, ENameIter);
</pre>
<p>The code that uses this iterator is as follows:</p>
<pre>...
DeptIter iter;
...
#sql iter = { SELECT dname, cursor 
             (SELECT ename FROM emp WHERE deptno = dept.deptno) 
              FROM dept };

while (true)
{
   String dname = null;
   ENameIter enamesIter = null;
   #sql { FETCH :iter INTO :dname, :enamesIter };
   if (iter.endFetch()) break;
   System.out.println(dname);
   while (enamesIter.next())
   {
      System.out.println(enamesIter.ename());
   }
   enamesIter.close();
}
iter.close();
...
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007454"></a>
<div id="JSQLJ342" class="sect1">
<h2 class="sect1">Assignment <a id="sthref235"></a><a id="sthref236"></a>Statements (SET)</h2>
<p>SQLJ enables you to assign a value to a Java host expression inside a SQL operation. This is known as an assignment statement and is accomplished using the following syntax:</p>
<pre>#sql { SET :<span class="italic">host_exp</span> = <span class="italic">expression</span> };
</pre>
<p>The <code><span class="codeinlineitalic">host_exp</span></code> is the target host expression, such as a variable or array index. The <code><span class="codeinlineitalic">expression</span></code> could be a number, host expression, arithmetic expression, function call, or other construct that yields a valid result into the target host expression.</p>
<p>The default is <code>OUT</code> for a target host expression in an assignment statement, but you can optionally state this explicitly:</p>
<pre>#sql { SET :OUT <span class="italic">host_exp</span> = <span class="italic">expression</span> };
</pre>
<p>Trying to use an <code>IN</code> or <code>INOUT</code> token in an assignment statement will result in an error at translation time.</p>
<p>The preceding statements are functionally equivalent to the following PL/SQL code:</p>
<pre>#sql { BEGIN :OUT <span class="italic">host_exp</span> := <span class="italic">expression</span>; END };
</pre>
<p>Here is a simple example of an assignment statement:</p>
<pre>#sql { SET :x = foo1() + foo2() };
</pre>
<p>This statement assigns to <code>x</code> the sum of the return values of <code>foo1()</code> and <code>foo2()</code> and assumes that the type of <code>x</code> is compatible with the type of the sum of the outputs of these functions.</p>
<p>Consider the following additional examples:</p>
<pre>int i2;
java.sql.Date dat;
...
#sql { SET :i2 = TO_NUMBER(substr(&#39;750 etc.&#39;, 1, 3)) +
        TO_NUMBER(substr(&#39;250 etc.&#39;, 1, 3)) };
...
#sql { SET :dat = sysdate };
...
</pre>
<p>The first statement will assign to <code>i2</code> the value <code>1000</code>. The <code>substr()</code> calls takes the first three characters of the strings, that is, &#34;750&#34; and &#34;250&#34;. The <code>TO_NUMBER()</code> calls convert the strings to the numbers 750 and 250.</p>
<p>The second statement will read the database system date and assign it to <code>dat</code>.</p>
<p>An assignment statement is especially useful when you are performing operations on return variables from functions stored in the database. You do not need an assignment statement to simply assign a function result to a variable, because you can accomplish this using standard function call syntax. You also do not need an assignment statement to manipulate output from Java functions, because you can accomplish that in a typical Java statement. So you can presume that <code>foo1()</code> and <code>foo2()</code> are stored functions in the database, not Java functions.</p>
</div>
<!-- class="sect1" -->
<a id="i1007491"></a>
<div id="JSQLJ343" class="sect1">
<h2 class="sect1">Stored Procedure and Function Calls</h2>
<p>SQLJ provides convenient syntax for calling stored procedures and stored functions in the database. These procedures and functions could be written in Java, PL/SQL, or any other language supported by the database.</p>
<p>A stored function requires a result expression in your SQLJ executable statement to accept the return value and, optionally, can take input, output, or input-output parameters as well.</p>
<p>A stored procedure does not have a return value. Optionally, it can take input, output, or input-output parameters. A stored procedure can return output through any output or input-output parameter.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Remember that instead of using the following procedure-call and function-call syntax, you can optionally use JPublisher to create Java wrappers for PL/SQL stored procedures and functions, and then call the Java wrappers as you would call any other Java methods. JPublisher is discussed in <a href="objcoll.htm#i1006402">&#34;JPublisher and the Creation of Custom Java Classes&#34;</a>. For additional information, refer to the <a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a>.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1007512">Calling Stored Procedures</a></p>
</li>
<li>
<p><a href="#i1007546">Calling Stored Functions</a></p>
</li>
<li>
<p><a href="#i1007586">Using Iterators and Result Sets as Stored Function Returns</a></p>
</li>
</ul>
<a id="i1007512"></a>
<div id="JSQLJ344" class="sect2">
<h3 class="sect2">Calling <a id="sthref237"></a><a id="sthref238"></a><a id="sthref239"></a><a id="sthref240"></a>Stored Procedures</h3>
<p>Stored procedures do not have a return value but can take a list with input, output, and input-output parameters. Stored procedure calls use the <code>CALL</code> token. The <code>CALL</code> token is followed by white space and then the procedure name. There must be a space after the <code>CALL</code> token to differentiate it from the procedure name. There <span class="italic">cannot</span> be a set of outer parentheses around the procedure call. This differs from the syntax for function calls. The syntax for the <code>CALL</code> token is as follows:</p>
<pre>#sql { CALL <span class="italic">PROC</span>(&lt;<span class="italic">PARAM_LIST&gt;</span>) };
</pre>
<p><code><span class="codeinlineitalic">PROC</span></code> is the name of the stored procedure, which can optionally take a list of input, output, and input-output parameters. <code><span class="codeinlineitalic">PROC</span></code> can include a schema or package name as well, such as <code>HR.MYPROC()</code>.</p>
<p>Presume that you have defined the following PL/SQL stored procedure:</p>
<pre>CREATE OR REPLACE PROCEDURE MAX_DEADLINE (deadline OUT DATE) IS
   BEGIN
      SELECT MAX(start_date + duration) INTO deadline FROM projects;
   END;
</pre>
<p>This reads the <code>PROJECTS</code> table, looks at the <code>START_DATE</code> and <code>DURATION</code> columns, calculates <code>start_date + duration</code> in each row, then takes the maximum <code>START_DATE + DURATION</code> total, and assigns it to <code>DEADLINE</code>, which is an output parameter of type <code>DATE</code>.</p>
<p>In SQLJ, you can call this <code>MAX_DEADLINE</code> procedure as follows:</p>
<pre>java.sql.Date maxDeadline;
...
#sql { CALL MAX_DEADLINE(:out maxDeadline) };
</pre>
<p>For any parameters, you must use the host expression tokens <code>IN</code>, <code>OUT</code>, and <code>INOUT</code> appropriately, to match the input, output, and input-output designations of the stored procedure. Additionally, the types of the host variables you use in the parameter list must be compatible with the parameter types of the stored procedure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you want your application to be compatible with Oracle7 Database, then do <span class="italic">not</span> include empty parentheses for the parameter list if the procedure takes no parameters. For example:
<pre>#sql { CALL MAX_DEADLINE };
</pre>
<p>not:</p>
<pre>#sql { CALL MAX_DEADLINE() };
</pre></div>
</div>
<!-- class="sect2" -->
<a id="i1007546"></a>
<div id="JSQLJ345" class="sect2">
<h3 class="sect2">Calling Stored <a id="sthref241"></a><a id="sthref242"></a><a id="sthref243"></a><a id="sthref244"></a>Functions</h3>
<p>Stored functions have a return value and can also take a list of input, output, and input-output parameters. Stored function calls use the <code>VALUES</code> token. The <code>VALUES</code> token is followed by the function call. In standard SQLJ, the function call must be enclosed in a set of outer parentheses. In the Oracle SQLJ implementation, the outer parentheses are optional. When using the outer parentheses, it does not matter if there is white space between the <code>VALUES</code> token and the begin-parenthesis. The syntax for the <code>VALUES</code> token is as follows:</p>
<pre>#sql <span class="italic">result</span> = { VALUES(<span class="italic">FUNC</span>(<span class="italic">PARAM_LIST</span>)) };
</pre>
<p>In this syntax, <code><span class="codeinlineitalic">result</span></code> is the result expression, which takes the function return value. <code><span class="codeinlineitalic">FUNC</span></code> is the name of the stored function, which can optionally take a list of input, output, and input-output parameters. <code><span class="codeinlineitalic">FUNC</span></code> can include a schema or package name, such as <code>HR.MYFUNC()</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A <code>VALUES</code> token can also be used in <code>INSERT INTO</code> <code><span class="codeinlineitalic">table</span></code> <code>VALUES</code> syntax supported by the Oracle SQL implementation, but these situations are unrelated semantically and syntactically.</div>
<p>Referring back to the example in <a href="#i1007512">&#34;Calling Stored Procedures&#34;</a>, consider defining the stored procedure as a stored function instead, as follows:</p>
<pre>CREATE OR REPLACE FUNCTION GET_MAX_DEADLINE RETURN DATE IS
   deadline DATE;
   BEGIN
      SELECT MAX(start_date + duration) INTO deadline FROM projects;
      RETURN deadline;
   END;
</pre>
<p>In SQLJ, you can call this <code>GET_MAX_DEADLINE</code> function as follows:</p>
<pre>java.sql.Date maxDeadline;
...
#sql maxDeadline = { VALUES(GET_MAX_DEADLINE) };
</pre>
<p>The result expression must have a type compatible with the return type of the function.</p>
<p>In the Oracle SQLJ implementation, the following syntax is also allowed:</p>
<pre>#sql maxDeadline = { VALUES GET_MAX_DEADLINE };
</pre>
<p>Note that the outer parentheses is omitted.</p>
<p>For stored function calls, as with stored procedures, you must use the host expression tokens <code>IN</code>, <code>OUT</code>, and <code>INOUT</code> appropriately, to match the input, output, and input-output parameters of the stored function. Additionally, the types of the host variables you use in the parameter list must be compatible with the parameter types of the stored function.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you want your stored function to be portable to non-Oracle environments, then you should use only input parameters in the calling sequence, not output or input-output parameters.</div>
</div>
<!-- class="sect2" -->
<a id="i1007586"></a>
<div id="JSQLJ346" class="sect2">
<h3 class="sect2">Using <a id="sthref245"></a><a id="sthref246"></a>Iterators and Result Sets as Stored Function Returns</h3>
<p>SQLJ supports assigning the return value of a stored function to an iterator or result set variable, if the function returns a REF CURSOR type.</p>
<p>The following example uses an iterator to take a stored function return. Using a result set is similar.</p>
<p class="subhead2"><a id="JSQLJ347"></a>Example: Iterator as Stored Function Return</p>
<p>This example uses an iterator as a return type for a stored function, using a <code>REF CURSOR</code> type in the process.</p>
<p>Presume the following function definition:</p>
<pre>CREATE OR REPLACE PACKAGE sqlj_refcursor AS
   TYPE EMP_CURTYPE IS REF CURSOR;
   FUNCTION job_listing (j varchar2) RETURN EMP_CURTYPE;
END sqlj_refcursor;

CREATE OR REPLACE PACKAGE BODY sqlj_refcursor AS 
   FUNCTION job_listing (j varchar) RETURN EMP_CURTYPE IS 
   DECLARE
      rc EMP_CURTYPE;
   BEGIN
      OPEN rc FOR SELECT ename, empno FROM emp WHERE job = j;
      RETURN rc;
   END;
END sqlj_refcursor;
</pre>
<p>Declare the iterator as follows:</p>
<pre>#sql public &lt;static&gt; iterator EmpIter (String ename, int empno);
</pre>
<p>The <code>public</code> modifier is required, and the <code>static</code> modifier may be advisable if your declaration is at class level or nested-class level.</p>
<p>The code that uses the iterator and the function is as follows:</p>
<pre>EmpIter iter;
...
#sql iter = { VALUES(sqlj_refcursor.job_listing(&#39;SALES&#39;)) };

while (iter.next())
{
   String empname = iter.ename();
   int empnum = iter.empno();

   ... <span class="italic">process empname and empnum</span> ...
}
iter.close();
...
</pre>
<p>This example calls the <code>job_listing()</code> function to return an iterator that contains the name and employee number of each employee whose job title is SALES. It then retrieves this data from the iterator.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4010">
<tr>
<td class="cellalignment4017">
<table class="cellalignment4015">
<tr>
<td class="cellalignment4014"><a href="keyprog.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4014"><a href="typesupp.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4019">
<table class="cellalignment4013">
<tr>
<td class="cellalignment4014"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4014"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4014"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4014"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4014"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4014"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>