<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-72381"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Type%20Support"></a><title>Type Support</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743"/>
<meta name="dcterms.created" content="2013-12-02T6:55:14Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SQLJ Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17660-12"/>
<meta name="dcterms.isVersionOf" content="JSQLJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="blangfea.htm" title="Previous" type="text/html"/>
<link rel="Next" href="objcoll.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E17660-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/20</span> <!-- End Header -->
<div id="JSQLJ348" class="chapter"><a id="BCEIIDCF"></a> <a id="i1008624"></a>
<h1 class="chapter"><span class="secnum">5</span> Type Support</h1>
<p>This chapter documents data types supported by the Oracle SQLJ implementation, listing supported SQL types and the Java types that correspond to them. This is followed by details about support for streams and Oracle type extensions. SQLJ support of Java types refers to types that can be used in host expressions.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>
<p><a href="#i1005568">Supported Types for Host Expressions</a></p>
</li>
<li>
<p><a href="#i1006420">Support for Streams</a></p>
</li>
<li>
<p><a href="#i1006820">Support for JDBC 2.0 LOB Types and Oracle Type Extensions</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="objcoll.htm#CIHEBGGC">Chapter 6, &#34;Objects, Collections, and OPAQUE Types&#34;</a></div>
<a id="i1005568"></a>
<div id="JSQLJ349" class="sect1">
<h2 class="sect1">Supported Types for Host Expressions</h2>
<p>This section summarizes the types supported by the Oracle SQLJ implementation, including information about new support for Java Database Connectivity (JDBC) 2.0 types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for a complete list of legal Java mappings for each Oracle SQL type</div>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
SQLJ performs implicit conversions between SQL and Java types. Although this is generally useful and helpful, it can produce unexpected results. Do not rely on translation-time type-checking alone to ensure the correctness of your code.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDHDAHI">Summary of Supported Types</a></p>
</li>
<li>
<p><a href="#CHDGDEEG">Supported Types and Requirements for JDBC 2.0</a></p>
</li>
<li>
<p><a href="#CHDHFHHD">Using PL/SQL BOOLEAN, RECORD Types, and TABLE Types</a></p>
</li>
</ul>
<a id="CHDHDAHI"></a>
<div id="JSQLJ350" class="sect2">
<h3 class="sect2">Summary of Supported <a id="sthref247"></a><a id="sthref248"></a>Types</h3>
<p><a href="#BCECCCFI">Table 5-1</a> lists the Java types that you can use in host expressions when employing Oracle JDBC drivers. This table also documents the correlation between Java types, SQL types whose type codes are defined in the <code>oracle.jdbc.OracleTypes</code> class, and data types in Oracle Database 12<span class="italic">c</span> Release 1 (12.1).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>OracleTypes</code> class simply defines a type code, which is an integer constant, for each Oracle data type. For standard JDBC types, the <code>OracleTypes</code> value is identical to the standard <code>java.sql.Types</code> value.</div>
<p>SQL data output to a Java variable is converted to the corresponding Java type. A Java variable input to SQL is converted to the corresponding Oracle data type.</p>
<div id="JSQLJ351" class="tblformal">
<p class="titleintable"><a id="sthref249"></a><a id="BCECCCFI"></a>Table 5-1 Type Mappings for Supported Host Expression Types</p>
<table class="cellalignment4020" title="Type Mappings for Supported Host Expression Types" summary="Summary" dir="ltr">
<thead>
<tr class="cellalignment4011">
<th class="cellalignment4021" id="r1c1-t6">Java Type</th>
<th class="cellalignment4021" id="r1c2-t6">OracleTypes Definition</th>
<th class="cellalignment4021" id="r1c3-t6">Oracle SQL Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r2c1-t6" headers="r1c1-t6">
<p><span class="bold">STANDARD JDBC 1.x TYPES</span></p>
</td>
<td class="cellalignment4017" headers="r2c1-t6 r1c2-t6">
<p>&nbsp;</p>
</td>
<td class="cellalignment4017" headers="r2c1-t6 r1c3-t6">
<p>&nbsp;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r3c1-t6" headers="r1c1-t6">
<p><code>boolean</code></p>
</td>
<td class="cellalignment4017" headers="r3c1-t6 r1c2-t6">
<p><code>BIT</code></p>
</td>
<td class="cellalignment4017" headers="r3c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r4c1-t6" headers="r1c1-t6">
<p><code>byte</code></p>
</td>
<td class="cellalignment4017" headers="r4c1-t6 r1c2-t6">
<p><code>TINYINT</code></p>
</td>
<td class="cellalignment4017" headers="r4c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r5c1-t6" headers="r1c1-t6">
<p><code>short</code></p>
</td>
<td class="cellalignment4017" headers="r5c1-t6 r1c2-t6">
<p><code>SMALLINT</code></p>
</td>
<td class="cellalignment4017" headers="r5c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r6c1-t6" headers="r1c1-t6">
<p><code>int</code></p>
</td>
<td class="cellalignment4017" headers="r6c1-t6 r1c2-t6">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment4017" headers="r6c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r7c1-t6" headers="r1c1-t6">
<p><code>long</code></p>
</td>
<td class="cellalignment4017" headers="r7c1-t6 r1c2-t6">
<p><code>BIGINT</code></p>
</td>
<td class="cellalignment4017" headers="r7c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r8c1-t6" headers="r1c1-t6">
<p><code>float</code></p>
</td>
<td class="cellalignment4017" headers="r8c1-t6 r1c2-t6">
<p><code>REAL</code></p>
</td>
<td class="cellalignment4017" headers="r8c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r9c1-t6" headers="r1c1-t6">
<p><code>double</code></p>
</td>
<td class="cellalignment4017" headers="r9c1-t6 r1c2-t6">
<p><code>FLOAT</code>, <code>DOUBLE</code></p>
</td>
<td class="cellalignment4017" headers="r9c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r10c1-t6" headers="r1c1-t6">
<p><code>java.lang.String</code></p>
</td>
<td class="cellalignment4017" headers="r10c1-t6 r1c2-t6">
<p><code>CHAR</code><code>VARCHAR</code><code>LONGVARCHAR</code></p>
</td>
<td class="cellalignment4017" headers="r10c1-t6 r1c3-t6">
<p><code>CHAR</code><code>VARCHAR2</code><code>LONG</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r11c1-t6" headers="r1c1-t6">
<p><code>byte[]</code></p>
</td>
<td class="cellalignment4017" headers="r11c1-t6 r1c2-t6">
<p><code>BINARY</code><code>VARBINARY</code><code>LONGVARBINARY</code></p>
</td>
<td class="cellalignment4017" headers="r11c1-t6 r1c3-t6">
<p><code>RAW</code><code>RAW</code><code>LONGRAW</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r12c1-t6" headers="r1c1-t6">
<p><code>java.sql.Date</code></p>
</td>
<td class="cellalignment4017" headers="r12c1-t6 r1c2-t6">
<p><code>DATE</code></p>
</td>
<td class="cellalignment4017" headers="r12c1-t6 r1c3-t6">
<p><code>DATE</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r13c1-t6" headers="r1c1-t6">
<p><code>java.sql.Time</code></p>
</td>
<td class="cellalignment4017" headers="r13c1-t6 r1c2-t6">
<p><code>TIME</code></p>
</td>
<td class="cellalignment4017" headers="r13c1-t6 r1c3-t6">
<p><code>DATE</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r14c1-t6" headers="r1c1-t6">
<p><code>java.sql.Timestamp</code></p>
</td>
<td class="cellalignment4017" headers="r14c1-t6 r1c2-t6">
<p><code>TIMESTAMP</code><code>TIMESTAMP</code></p>
</td>
<td class="cellalignment4017" headers="r14c1-t6 r1c3-t6">
<p><code>DATE</code><code>TIMESTAMP</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r15c1-t6" headers="r1c1-t6">
<p><code>java.math.BigDecimal</code></p>
</td>
<td class="cellalignment4017" headers="r15c1-t6 r1c2-t6">
<p><code>NUMERIC</code><code>DECIMAL</code></p>
</td>
<td class="cellalignment4017" headers="r15c1-t6 r1c3-t6">
<p><code>NUMBER</code><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r16c1-t6" headers="r1c1-t6">
<p><span class="bold">STANDARD JDBC 2.0 TYPES</span></p>
</td>
<td class="cellalignment4017" headers="r16c1-t6 r1c2-t6">
<p>&nbsp;</p>
</td>
<td class="cellalignment4017" headers="r16c1-t6 r1c3-t6">
<p>&nbsp;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r17c1-t6" headers="r1c1-t6">
<p><code>java.sql.Blob</code></p>
</td>
<td class="cellalignment4017" headers="r17c1-t6 r1c2-t6">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment4017" headers="r17c1-t6 r1c3-t6">
<p><code>BLOB</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r18c1-t6" headers="r1c1-t6">
<p><code>java.sql.Clob</code></p>
</td>
<td class="cellalignment4017" headers="r18c1-t6 r1c2-t6">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment4017" headers="r18c1-t6 r1c3-t6">
<p><code>CLOB</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r19c1-t6" headers="r1c1-t6">
<p><code>java.sql.Struct</code></p>
</td>
<td class="cellalignment4017" headers="r19c1-t6 r1c2-t6">
<p><code>STRUCT</code></p>
</td>
<td class="cellalignment4017" headers="r19c1-t6 r1c3-t6">
<p>Object types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r20c1-t6" headers="r1c1-t6">
<p><code>java.sql.Ref</code></p>
</td>
<td class="cellalignment4017" headers="r20c1-t6 r1c2-t6">
<p><code>REF</code></p>
</td>
<td class="cellalignment4017" headers="r20c1-t6 r1c3-t6">
<p>Reference types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r21c1-t6" headers="r1c1-t6">
<p><code>java.sql.Array</code></p>
</td>
<td class="cellalignment4017" headers="r21c1-t6 r1c2-t6">
<p><code>ARRAY</code></p>
</td>
<td class="cellalignment4017" headers="r21c1-t6 r1c3-t6">
<p>Collection types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r22c1-t6" headers="r1c1-t6">
<p>Custom object classes implementing <code>java.sql.SQLData</code></p>
</td>
<td class="cellalignment4017" headers="r22c1-t6 r1c2-t6">
<p><code>STRUCT</code></p>
</td>
<td class="cellalignment4017" headers="r22c1-t6 r1c3-t6">
<p>Object types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r23c1-t6" headers="r1c1-t6">
<p><span class="bold">JAVA WRAPPER CLASSES</span></p>
</td>
<td class="cellalignment4017" headers="r23c1-t6 r1c2-t6">
<p>&nbsp;</p>
</td>
<td class="cellalignment4017" headers="r23c1-t6 r1c3-t6">
<p>&nbsp;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r24c1-t6" headers="r1c1-t6">
<p><code>java.lang.Boolean</code></p>
</td>
<td class="cellalignment4017" headers="r24c1-t6 r1c2-t6">
<p><code>BIT</code></p>
</td>
<td class="cellalignment4017" headers="r24c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r25c1-t6" headers="r1c1-t6">
<p><code>java.lang.Byte</code></p>
</td>
<td class="cellalignment4017" headers="r25c1-t6 r1c2-t6">
<p><code>TINYINT</code></p>
</td>
<td class="cellalignment4017" headers="r25c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r26c1-t6" headers="r1c1-t6">
<p><code>java.lang.Short</code></p>
</td>
<td class="cellalignment4017" headers="r26c1-t6 r1c2-t6">
<p><code>SMALLINT</code></p>
</td>
<td class="cellalignment4017" headers="r26c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r27c1-t6" headers="r1c1-t6">
<p><code>java.lang.Integer</code></p>
</td>
<td class="cellalignment4017" headers="r27c1-t6 r1c2-t6">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment4017" headers="r27c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r28c1-t6" headers="r1c1-t6">
<p><code>java.lang.Long</code></p>
</td>
<td class="cellalignment4017" headers="r28c1-t6 r1c2-t6">
<p><code>BIGINT</code></p>
</td>
<td class="cellalignment4017" headers="r28c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r29c1-t6" headers="r1c1-t6">
<p><code>java.lang.Float</code></p>
</td>
<td class="cellalignment4017" headers="r29c1-t6 r1c2-t6">
<p><code>REAL</code></p>
</td>
<td class="cellalignment4017" headers="r29c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r30c1-t6" headers="r1c1-t6">
<p><code>java.lang.Double</code></p>
</td>
<td class="cellalignment4017" headers="r30c1-t6 r1c2-t6">
<p><code>FLOAT</code>, <code>DOUBLE</code></p>
</td>
<td class="cellalignment4017" headers="r30c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r31c1-t6" headers="r1c1-t6">
<p><span class="bold">SQLJ STREAM CLASSES</span></p>
</td>
<td class="cellalignment4017" headers="r31c1-t6 r1c2-t6">
<p>&nbsp;</p>
</td>
<td class="cellalignment4017" headers="r31c1-t6 r1c3-t6">
<p>&nbsp;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r32c1-t6" headers="r1c1-t6">
<p><code>sqlj.runtime.BinaryStream</code></p>
</td>
<td class="cellalignment4017" headers="r32c1-t6 r1c2-t6">
<p><code>LONGVARBINARY</code></p>
</td>
<td class="cellalignment4017" headers="r32c1-t6 r1c3-t6">
<p><code>LONG RAW</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r33c1-t6" headers="r1c1-t6">
<p><code>sqlj.runtime.CharacterStream</code></p>
</td>
<td class="cellalignment4017" headers="r33c1-t6 r1c2-t6">
<p><code>LONGVARCHAR</code></p>
</td>
<td class="cellalignment4017" headers="r33c1-t6 r1c3-t6">
<p><code>LONG</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r34c1-t6" headers="r1c1-t6">
<p><code>sqlj.runtime.AsciiStream</code> (Deprecated; use <code>CharacterStream</code>.)</p>
</td>
<td class="cellalignment4017" headers="r34c1-t6 r1c2-t6">
<p><code>LONGVARCHAR</code></p>
</td>
<td class="cellalignment4017" headers="r34c1-t6 r1c3-t6">
<p><code>LONG</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r35c1-t6" headers="r1c1-t6">
<p><code>sqlj.runtime.UnicodeStream</code> (Deprecated; use <code>CharacterStream</code>.)</p>
</td>
<td class="cellalignment4017" headers="r35c1-t6 r1c2-t6">
<p><code>LONGVARCHAR</code></p>
</td>
<td class="cellalignment4017" headers="r35c1-t6 r1c3-t6">
<p><code>LONG</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r36c1-t6" headers="r1c1-t6">
<p><span class="bold">ORACLE EXTENSIONS</span></p>
</td>
<td class="cellalignment4017" headers="r36c1-t6 r1c2-t6">
<p>&nbsp;</p>
</td>
<td class="cellalignment4017" headers="r36c1-t6 r1c3-t6">
<p>&nbsp;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r37c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.NUMBER</code></p>
</td>
<td class="cellalignment4017" headers="r37c1-t6 r1c2-t6">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment4017" headers="r37c1-t6 r1c3-t6">
<p><code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r38c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.CHAR</code></p>
</td>
<td class="cellalignment4017" headers="r38c1-t6 r1c2-t6">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment4017" headers="r38c1-t6 r1c3-t6">
<p><code>CHAR</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r39c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.RAW</code></p>
</td>
<td class="cellalignment4017" headers="r39c1-t6 r1c2-t6">
<p><code>RAW</code></p>
</td>
<td class="cellalignment4017" headers="r39c1-t6 r1c3-t6">
<p><code>RAW</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r40c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.DATE</code></p>
</td>
<td class="cellalignment4017" headers="r40c1-t6 r1c2-t6">
<p><code>DATE</code></p>
</td>
<td class="cellalignment4017" headers="r40c1-t6 r1c3-t6">
<p><code>DATE</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r41c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.TIMESTAMP</code></p>
</td>
<td class="cellalignment4017" headers="r41c1-t6 r1c2-t6">
<p><code>TIMESTAMP</code></p>
</td>
<td class="cellalignment4017" headers="r41c1-t6 r1c3-t6">
<p><code>TIMESTAMP</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r42c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.TIMESTAMPTZ</code></p>
</td>
<td class="cellalignment4017" headers="r42c1-t6 r1c2-t6">
<p><code>TIMESTAMPTZ</code></p>
</td>
<td class="cellalignment4017" headers="r42c1-t6 r1c3-t6">
<p><code>TIMESTAMP-WITH- TIMEZONE</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r43c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.TIMESTAMPLTZ</code></p>
</td>
<td class="cellalignment4017" headers="r43c1-t6 r1c2-t6">
<p><code>TIMESTAMPLTZ</code></p>
</td>
<td class="cellalignment4017" headers="r43c1-t6 r1c3-t6">
<p><code>TIMESTAMP-WITH- LOCAL-TIMEZONE</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r44c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.ROWID</code></p>
</td>
<td class="cellalignment4017" headers="r44c1-t6 r1c2-t6">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment4017" headers="r44c1-t6 r1c3-t6">
<p><code>ROWID</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r45c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.BLOB</code></p>
</td>
<td class="cellalignment4017" headers="r45c1-t6 r1c2-t6">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment4017" headers="r45c1-t6 r1c3-t6">
<p><code>BLOB</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r46c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.CLOB</code></p>
</td>
<td class="cellalignment4017" headers="r46c1-t6 r1c2-t6">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment4017" headers="r46c1-t6 r1c3-t6">
<p><code>CLOB</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r47c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.BFILE</code></p>
</td>
<td class="cellalignment4017" headers="r47c1-t6 r1c2-t6">
<p><code>BFILE</code></p>
</td>
<td class="cellalignment4017" headers="r47c1-t6 r1c3-t6">
<p><code>BFILE</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r48c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.STRUCT</code></p>
</td>
<td class="cellalignment4017" headers="r48c1-t6 r1c2-t6">
<p><code>STRUCT</code></p>
</td>
<td class="cellalignment4017" headers="r48c1-t6 r1c3-t6">
<p>Object types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r49c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.REF</code></p>
</td>
<td class="cellalignment4017" headers="r49c1-t6 r1c2-t6">
<p><code>REF</code></p>
</td>
<td class="cellalignment4017" headers="r49c1-t6 r1c3-t6">
<p>Reference types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r50c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.ARRAY</code></p>
</td>
<td class="cellalignment4017" headers="r50c1-t6 r1c2-t6">
<p><code>ARRAY</code></p>
</td>
<td class="cellalignment4017" headers="r50c1-t6 r1c3-t6">
<p>Collection types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r51c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.OPAQUE</code></p>
</td>
<td class="cellalignment4017" headers="r51c1-t6 r1c2-t6">
<p><code>OPAQUE</code></p>
</td>
<td class="cellalignment4017" headers="r51c1-t6 r1c3-t6">
<p><code>OPAQUE</code> types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r52c1-t6" headers="r1c1-t6">
<p>Custom object classes implementing <code>oracle.sql.ORAData</code></p>
</td>
<td class="cellalignment4017" headers="r52c1-t6 r1c2-t6">
<p><code>STRUCT</code></p>
</td>
<td class="cellalignment4017" headers="r52c1-t6 r1c3-t6">
<p>Object types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r53c1-t6" headers="r1c1-t6">
<p>Custom reference classes implementing <code>oracle.sql.ORAData</code></p>
</td>
<td class="cellalignment4017" headers="r53c1-t6 r1c2-t6">
<p><code>REF</code></p>
</td>
<td class="cellalignment4017" headers="r53c1-t6 r1c3-t6">
<p>Reference types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r54c1-t6" headers="r1c1-t6">
<p>Custom collection classes implementing <code>oracle.sql.ORAData</code></p>
</td>
<td class="cellalignment4017" headers="r54c1-t6 r1c2-t6">
<p><code>ARRAY</code></p>
</td>
<td class="cellalignment4017" headers="r54c1-t6 r1c3-t6">
<p>Collection types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r55c1-t6" headers="r1c1-t6">
<p>Custom classes implementing <code>oracle.sql.ORAData</code> for <code>OPAQUE</code> types (for example, <code>oracle.xdb.XMLType</code>)</p>
</td>
<td class="cellalignment4017" headers="r55c1-t6 r1c2-t6">
<p><code>OPAQUE</code></p>
</td>
<td class="cellalignment4017" headers="r55c1-t6 r1c3-t6">
<p><code>OPAQUE</code> types</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r56c1-t6" headers="r1c1-t6">
<p>Other custom Java classes implementing <code>oracle.sql.ORAData</code> (to wrap any <code>oracle.sql</code> type)</p>
</td>
<td class="cellalignment4017" headers="r56c1-t6 r1c2-t6">
<p>Any</p>
</td>
<td class="cellalignment4017" headers="r56c1-t6 r1c3-t6">
<p>Any</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r57c1-t6" headers="r1c1-t6">
<p>SQLJ object Java types (can implement either <code>SQLData</code> or <code>ORAData</code>)</p>
</td>
<td class="cellalignment4017" headers="r57c1-t6 r1c2-t6">
<p><code>JAVA_STRUCT</code></p>
</td>
<td class="cellalignment4017" headers="r57c1-t6 r1c3-t6">
<p>SQLJ object SQL types (<code>JAVA_STRUCT</code> behind the scenes; automatic conversion to an appropriate Java class)</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r58c1-t6" headers="r1c1-t6">
<p><span class="bold">JAVA TYPES FOR PL/SQL TYPES</span></p>
</td>
<td class="cellalignment4017" headers="r58c1-t6 r1c2-t6">
<p>&nbsp;</p>
</td>
<td class="cellalignment4017" headers="r58c1-t6 r1c3-t6">
<p>&nbsp;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r59c1-t6" headers="r1c1-t6">
<p>Scalar indexed-by table represented by a Java numeric array or an array of <code>String</code>, <code>oracle.sql.CHAR</code>, or <code>oracle.sql.NUMBER</code></p>
</td>
<td class="cellalignment4017" headers="r59c1-t6 r1c2-t6">
<p>NA</p>
</td>
<td class="cellalignment4017" headers="r59c1-t6 r1c3-t6">
<p>NA</p>
<p><span class="bold">Note</span>: There is a <code>PLSQL_INDEX_TABLE</code> type, but it does not appear to be used externally.</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r60c1-t6" headers="r1c1-t6">
<p><span class="bold">GLOBALIZ<a id="sthref250"></a>ATION SUPPORT</span></p>
</td>
<td class="cellalignment4017" headers="r60c1-t6 r1c2-t6">
<p>&nbsp;</p>
</td>
<td class="cellalignment4017" headers="r60c1-t6 r1c3-t6">
<p>&nbsp;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r61c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.NCHAR</code></p>
</td>
<td class="cellalignment4017" headers="r61c1-t6 r1c2-t6">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment4017" headers="r61c1-t6 r1c3-t6">
<p><code>CHAR</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r62c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.NString</code></p>
</td>
<td class="cellalignment4017" headers="r62c1-t6 r1c2-t6">
<p><code>CHAR</code><code>VARCHAR</code><code>LONGVARCHAR</code></p>
</td>
<td class="cellalignment4017" headers="r62c1-t6 r1c3-t6">
<p><code>CHAR</code><code>VARCHAR2</code><code>LONG</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r63c1-t6" headers="r1c1-t6">
<p><code>oracle.sql.NCLOB</code></p>
</td>
<td class="cellalignment4017" headers="r63c1-t6 r1c2-t6">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment4017" headers="r63c1-t6 r1c3-t6">
<p><code>CLOB</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r64c1-t6" headers="r1c1-t6">
<p><code>oracle.sqlj.runtime.NcharCharacterStream</code></p>
</td>
<td class="cellalignment4017" headers="r64c1-t6 r1c2-t6">
<p><code>LONGVARCHAR</code></p>
</td>
<td class="cellalignment4017" headers="r64c1-t6 r1c3-t6">
<p><code>LONG</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r65c1-t6" headers="r1c1-t6">
<p><code>oracle.sqlj.runtime. NcharAsciiStream</code> (Deprecated; use <code>NcharCharacterStream</code>.)</p>
</td>
<td class="cellalignment4017" headers="r65c1-t6 r1c2-t6">
<p><code>LONGVARCHAR</code></p>
</td>
<td class="cellalignment4017" headers="r65c1-t6 r1c3-t6">
<p><code>LONG</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r66c1-t6" headers="r1c1-t6">
<p><code>oracle.sqlj.runtime. NcharUnicodeStream</code> (Deprecated; use <code>NcharCharacterStream</code>.)</p>
</td>
<td class="cellalignment4017" headers="r66c1-t6 r1c2-t6">
<p><code>LONGVARCHAR</code></p>
</td>
<td class="cellalignment4017" headers="r66c1-t6 r1c3-t6">
<p><code>LONG</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r67c1-t6" headers="r1c1-t6">
<p><span class="bold">QUERY RESULT OBJECTS</span></p>
</td>
<td class="cellalignment4017" headers="r67c1-t6 r1c2-t6">
<p>&nbsp;</p>
</td>
<td class="cellalignment4017" headers="r67c1-t6 r1c3-t6">
<p>&nbsp;</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r68c1-t6" headers="r1c1-t6">
<p><code>java.sql.ResultSet</code></p>
</td>
<td class="cellalignment4017" headers="r68c1-t6 r1c2-t6">
<p><code>CURSOR</code></p>
</td>
<td class="cellalignment4017" headers="r68c1-t6 r1c3-t6">
<p><code>CURSOR</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r69c1-t6" headers="r1c1-t6">
<p>SQLJ iterator objects</p>
</td>
<td class="cellalignment4017" headers="r69c1-t6 r1c2-t6">
<p><code>CURSOR</code></p>
</td>
<td class="cellalignment4017" headers="r69c1-t6 r1c3-t6">
<p><code>CURSOR</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for more information about Oracle type support.</div>
<p>The following points relate to type support for standard features:</p>
<ul>
<li>
<p>JDBC and SQLJ do not support Java <code>char</code> and <code>Character</code> types. Instead, use the Java <code>String</code> type to represent character data.</p>
</li>
<li>
<p>Do not confuse the supported <code>java.sql.Date</code> type with <code>java.util.Date</code>, which is not directly supported. The <code>java.sql.Date</code> class is a wrapper for <code>java.util.Date</code> that enables JDBC to identify the data as a SQL <code>DATE</code> and adds formatting and parsing operations to support JDBC escape syntax for date values.</p>
</li>
<li>
<p>Remember that all numeric types in Oracle Database 12<span class="italic">c</span> Release 1 (12.1) are stored as <code>NUMBER</code>. Although you can specify additional precision when you declare a <code>NUMBER</code> during table creation, this precision may be lost when retrieving the data through Oracle JDBC drivers, depending on the Java type that you use to receive the data. An <code>oracle.sql.NUMBER</code> instance would preserve full information.</p>
</li>
<li>
<p>The Java wrapper classes, such as <code>Integer</code> and <code>Float</code>, are useful in cases where <code>NULL</code> may be returned by the SQL statement. Primitive types, such as <code>int</code> and <code>float</code>, cannot contain null values.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1006100">&#34;NULL-Handling&#34;</a></div>
</li>
<li>
<p>The SQLJ stream classes are required in using streams as host variables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006420">&#34;Support for Streams&#34;</a></div>
</li>
<li>
<p>Weak types cannot be used for <code>OUT</code> or <code>INOUT</code> parameters. This applies to the <code>Struct</code>, <code>Ref</code>, and <code>Array</code> standard JDBC 2.0 types, as well as to corresponding Oracle extended types.</p>
</li>
<li>
<p>A new set of interfaces, in the <code>oracle.jdbc</code> package, was first added in the Oracle9<span class="italic">i</span> JDBC implementation in place of classes of the <code>oracle.jdbc.driver</code> package. These interfaces provide a more generic way for users to access Oracle-specific features using Oracle JDBC drivers. Specifically, when creating programs for the middle tier, you should use the <code>oracle.jdbc</code> application programming interface (API). However, SQLJ programmers will not typically use these interfaces directly. They are used transparently by the SQLJ run time or in Oracle-specific generated code.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="objcoll.htm#i1005718">&#34;Custom Java Class Interface Specifications&#34;</a></div>
</li>
<li>
<p>For information about SQLJ support for result set and iterator host variables, refer to <a href="blangfea.htm#i1007245">&#34;Using Iterators and Result Sets as Host Variables&#34;</a>.</p>
</li>
</ul>
<p>The following points relate to Oracle extensions:</p>
<ul>
<li>
<p>The Oracle SQLJ implementation requires any class that implements <code>oracle.sql.ORAData</code> to set the static <code>_SQL_TYPECODE</code> parameter according to values defined in the <code>OracleTypes</code> class. In some cases, an additional parameter must be set as well, such as <code>_SQL_NAME</code> for objects and <code>_SQL_BASETYPE</code> for object references. This occurs automatically if you use Oracle JPublisher utility to generate the class.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="objcoll.htm#i1005846">&#34;Oracle Requirements for Classes Implementing ORAData&#34;</a></div>
</li>
<li>
<p>The <code>oracle.sql</code> classes are wrappers for SQL data for each of the Oracle data types. The <code>ARRAY</code>, <code>STRUCT</code>, <code>REF</code>, <code>BLOB</code>, and <code>CLOB</code> classes correspond to standard JDBC 2.0 interfaces.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for information about these classes and Oracle extensions</div>
</li>
<li>
<p>Custom Java classes can map to Oracle objects, which implement <code>ORAData</code> or <code>SQLData</code>, references, which implement <code>ORAData</code> only, collections, which implement <code>ORAData</code> only, <code>OPAQUE</code> types, which implement <code>ORAData</code> only, or other SQL types for customized handling, which implement <code>ORAData</code> only. You can use Oracle JPublisher utility to automatically generate custom Java classes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="objcoll.htm#i1005685">&#34;Custom Java Classes&#34;</a> and <a href="objcoll.htm#i1006402">&#34;JPublisher and the Creation of Custom Java Classes&#34;</a></div>
</li>
<li>
<p>The Oracle SQLJ implementation has functionality for automatic blank padding when comparing a string to a <code>CHAR</code> column value for a <code>WHERE</code> clause. Otherwise the string would have to be padded to match the number of characters in the database column. This is available as a SQLJ translator option for Oracle-specific code generation, or as an Oracle customizer option for ISO standard code generation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007700">&#34;CHAR Comparisons with Blank Padding (-fixedchar)&#34;</a> and <a href="profcust.htm#i635168">&#34;Oracle Customizer CHAR Comparisons with Blank Padding (fixedchar)&#34;</a></div>
</li>
<li>
<p>Weak types cannot be used for <code>OUT</code> or <code>INOUT</code> parameters. This applies to the <code>STRUCT</code>, <code>REF</code>, and <code>ARRAY</code> Oracle extended types and corresponding standard JDBC 2.0 types, as well as to Oracle <code>OPAQUE</code> types.</p>
</li>
<li>
<p>Using any of the Oracle extensions requires the following:</p>
<ul>
<li>
<p>Oracle JDBC driver</p>
</li>
<li>
<p>Oracle-specific code generation or Oracle customization during translation</p>
</li>
<li>
<p>Oracle SQLJ run time when your application runs</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDGDEEG"></a>
<div id="JSQLJ352" class="sect2">
<h3 class="sect2">Supported Ty<a id="sthref251"></a><a id="sthref252"></a><a id="sthref253"></a>pes and Requirements for JDBC 2.0</h3>
<p>As indicated in <a href="#BCECCCFI">Table 5-1</a>, the Oracle JDBC and SQLJ implementations support JDBC 2.0 types in the standard <code>java.sql</code> package. This section lists JDBC 2.0 supported types and related Oracle extensions.</p>
<p><a href="#BCEDBCDJ">Table 5-2</a> lists the JDBC 2.0 types supported by the Oracle SQLJ implementation. You can use them wherever you can use the corresponding Oracle extensions, summarized in the table.</p>
<p>The Oracle extensions have been available in prior releases and are still available as well. These <code>oracle.sql.*</code> classes provide functionality to wrap raw SQL data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<div id="JSQLJ353" class="tblformal">
<p class="titleintable"><a id="sthref254"></a><a id="BCEDBCDJ"></a>Table 5-2 Correlation between Oracle Extensions and JDBC 2.0 Types</p>
<table class="cellalignment4020" title="Correlation between Oracle Extensions and JDBC 2.0 Types " summary="summary" dir="ltr">
<thead>
<tr class="cellalignment4011">
<th class="cellalignment4021" id="r1c1-t16">JDBC 2.0 Type</th>
<th class="cellalignment4021" id="r1c2-t16">Oracle Extension</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r2c1-t16" headers="r1c1-t16">
<p><code>java.sql.Blob</code></p>
</td>
<td class="cellalignment4017" headers="r2c1-t16 r1c2-t16">
<p><code>oracle.sql.BLOB</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r3c1-t16" headers="r1c1-t16">
<p><code>java.sql.Clob</code></p>
</td>
<td class="cellalignment4017" headers="r3c1-t16 r1c2-t16">
<p><code>oracle.sql.CLOB</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r4c1-t16" headers="r1c1-t16">
<p><code>java.sql.Struct</code></p>
</td>
<td class="cellalignment4017" headers="r4c1-t16 r1c2-t16">
<p><code>oracle.sql.STRUCT</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r5c1-t16" headers="r1c1-t16">
<p><code>java.sql.Ref</code></p>
</td>
<td class="cellalignment4017" headers="r5c1-t16 r1c2-t16">
<p><code>oracle.sql.REF</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r6c1-t16" headers="r1c1-t16">
<p><code>java.sql.Array</code></p>
</td>
<td class="cellalignment4017" headers="r6c1-t16 r1c2-t16">
<p><code>oracle.sql.ARRAY</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r7c1-t16" headers="r1c1-t16">
<p><code>java.sql.SQLData</code></p>
</td>
<td class="cellalignment4017" headers="r7c1-t16 r1c2-t16">
<p>NA</p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r8c1-t16" headers="r1c1-t16">
<p>NA</p>
</td>
<td class="cellalignment4017" headers="r8c1-t16 r1c2-t16">
<p><code>oracle.sql.ORAData (_SQL_TYPECODE = OracleTypes.STRUCT)</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><code>ORAData</code> functionality is an Oracle-specific alternative to standard <code>SQLData</code> functionality for Java support of user-defined types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="objcoll.htm#i1005685">&#34;Custom Java Classes&#34;</a>, <a href="#i1006871">&#34;Support for BLOB, CLOB, and BFILE&#34;</a>, and <a href="objcoll.htm#i1008091">&#34;Support for Weakly Typed Objects, References, and Collections&#34;</a></div>
<p>The following JDBC 2.0 types are currently <span class="italic">not</span> supported in the Oracle JDBC and SQLJ implementations:</p>
<ul>
<li>
<p><code>JAVA_OBJECT</code>: Represents an instance of a Java type in a SQL column.</p>
</li>
<li>
<p><code>DISTINCT</code>: A distinct SQL type represented in or retrievable from a basic SQL type. For example, <code>SHOESIZE</code> --&gt; <code>NUMBER</code>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Begin<a id="sthref255"></a><a id="sthref256"></a>ning with Oracle Database 11<span class="italic">g</span>, the Oracle SQLJ implementation supports the ISO SQLJ feature of allowing array types for iterator columns. You can declare an iterator that uses <code>java.sql.Array</code> or <code>oracle.sql.ARRAY</code> columns. For example, suppose the following database table is defined:
<pre>CREATE OR REPLACE TYPE arr_type IS VARRAY(20) OF NUMBER;
CREATE TABLE arr_type (arr_col1 arr_type, arr_col2
                       arr_type);
</pre>
<p>You could define a corresponding iterator type as follows:</p>
<pre>#sql static iterator MyIter (oracle.sql.ARRAY arr_col1,
                             java.sql.Array arr_col2);
</pre></div>
</div>
<!-- class="sect2" -->
<a id="CHDHFHHD"></a>
<div id="JSQLJ354" class="sect2">
<h3 class="sect2">Using <a id="sthref257"></a><a id="sthref258"></a><a id="sthref259"></a><a id="sthref260"></a><a id="sthref261"></a><a id="sthref262"></a>PL/SQL BOOLEAN, RECORD Types, and TABLE Types</h3>
<p>The Oracle SQLJ and JDBC implementations do not support calling arguments or return values of the PL/SQL <code>BOOLEAN</code> type or RECORD types.</p>
<p class="subhead2"><a id="JSQLJ355"></a>Support for TABLE Types</p>
<p>Oracle JDBC drivers support scalar PL/SQL indexed-by tables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<p>The Oracle SQLJ implementation simplifies the process of writing and retrieving data in scalar indexed-by tables. The following array types are supported:</p>
<ul>
<li>
<p>Numeric types: <code>int[]</code>, <code>long[]</code>, <code>float[]</code>, <code>double[]</code>, <code>short[]</code>, <code>java.math.BigDecimal[]</code>, <code>oracle.sql.NUMBER[]</code></p>
</li>
<li>
<p>Character types: <code>java.lang.String[]</code>, <code>oracle.sql.CHAR[]</code></p>
</li>
</ul>
<p>The following is an example of writing indexed-by table data to the database:</p>
<pre>int[] vals = {1,2,3};
#sql { call procin(:vals) };
</pre>
<p>The following is an example of retrieving indexed-by table data from the database:</p>
<pre>oracle.sql.CHAR[] outvals;
#sql { call procout(:OUT outvals/*[111](22)*/) };
</pre>
<p>You must specify the maximum length of the output array being retrieved, using the <code>[xxx]</code> syntax inside the <code>/*...*/</code> syntax, as shown. Also, for character-like binds, you can optionally include the <code>(xx)</code> syntax, as shown, to specify the maximum length of an array element in bytes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>oracle.sql.Datum</code> class is not supported directly. You must use an appropriate subclass, such as <code>oracle.sql.CHAR</code> or <code>oracle.sql.NUMBER</code>.</div>
<p class="subhead2"><a id="JSQLJ356"></a>Workarounds for Unsupported Types</p>
<p>As a workaround for an unsupported type, you can create wrapper procedures that process the data using supported types. For example, to wrap a stored procedure that uses PL/SQL boolean values, you can create a stored procedure that takes a character or number from JDBC and passes it to the original procedure as <code>BOOLEAN</code>, or for an output parameter, accepts a <code>BOOLEAN</code> argument from the original procedure and passes it as a <code>CHAR</code> or <code>NUMBER</code> to JDBC. Similarly, to wrap a stored procedure that uses PL/SQL records, you can create a stored procedure that handles a record in its individual components, such as <code>CHAR</code> and <code>NUMBER</code>. To wrap a stored procedure that uses PL/SQL TABLE types, you can break the data into components or perhaps use Oracle collection types.</p>
<p>The following is an example of a PL/SQL wrapper procedure <code>MY_PROC</code> for a stored procedure <code>PROC</code> that takes a <code>BOOLEAN</code> as input:</p>
<pre>PROCEDURE MY_PROC (n NUMBER) IS
BEGIN
   IF n=0
      THEN proc(false);
      ELSE proc(true);
   END IF;
END;

PROCEDURE PROC (b BOOLEAN) IS
BEGIN
...
END;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
When using these unsupported PL/SQL types in method signatures in PL/SQL packages or SQL objects, consider using the Oracle Database 12<span class="italic">c</span> Release 1 (12.1) JPublisher utility. This facilitates the creation of Java types to call such methods. Refer to <a href="objcoll.htm#i1006402">&#34;JPublisher and the Creation of Custom Java Classes&#34;</a> for an overview of JPublisher, and the <a class="olink JJPUB" href="../JJPUB/toc.htm"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a> for more information.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006420"></a>
<div id="JSQLJ359" class="sect1">
<h2 class="sect1">Support for <a id="sthref263"></a>Streams</h2>
<p>Standard SQLJ provides the following specialized classes for convenient processing of long data in streams:</p>
<ul>
<li>
<p><code>sqlj.runtime.BinaryStream</code></p>
</li>
<li>
<p><code>sqlj.runtime.CharacterStream</code></p>
</li>
</ul>
<p>These stream types can be used for iterator columns to retrieve data from the database or for input host variables to send data to the database. As with Java streams in general, these classes allow the convenience of processing and transferring large data items in manageable chunks.</p>
<p>This section discusses general use of these classes, Oracle SQLJ extended functionality, and stream class methods. It covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDDFGAC">General Use of SQLJ Streams</a></p>
</li>
<li>
<p><a href="#CHDBDCIG">Key Aspects of Stream Support Classes</a></p>
</li>
<li>
<p><a href="#i1006482">Using SQLJ Streams to Send Data</a></p>
</li>
<li>
<p><a href="#i1006561">Retrieving Data into Streams: Precautions</a></p>
</li>
<li>
<p><a href="#CHDBCIDD">Using SQLJ Streams to Retrieve Data</a></p>
</li>
<li>
<p><a href="#i1006645">Stream Class Methods</a></p>
</li>
<li>
<p><a href="#i1006678">Examples of Retrieving and Processing Stream Data</a></p>
</li>
<li>
<p><a href="#CHDDJACF">SQLJ Stream Objects as Output Parameters and Function Return Values</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from JDBC 2.0, the <code>CharacterStream</code> class replaces the <code>AsciiStream</code> and <code>UnicodeStream</code> classes. <code>CharacterStream</code> shelters users from unnecessary logistics regarding encoding.</div>
<a id="CHDDFGAC"></a>
<div id="JSQLJ360" class="sect2">
<h3 class="sect2">General <a id="sthref264"></a>Use of SQLJ Streams</h3>
<p><a href="#BCECCCFI">Table 5-1</a> lists the data types you would typically process using these stream classes. To summarize:</p>
<ul>
<li>
<p><code>BinaryStream</code> is typically used for <code>LONG RAW</code> (<code>Types.LONGVARBINARY</code>), but might also be used for <code>RAW</code> (<code>Types.BINARY</code> or <code>Types.VARBINARY</code>).</p>
</li>
<li>
<p><code>CharacterStream</code> is typically used for <code>LONG</code> (<code>java.sql.Types.LONGVARCHAR</code>), but might also be used for <code>VARCHAR2</code> (<code>Types.VARCHAR</code>).</p>
</li>
</ul>
<p>Of course, any use of streams is at your discretion. You can use the SQLJ stream types for host variables to either send or retrieve data.</p>
<p>As <a href="#BCECCCFI">Table 5-1</a> documents, <code>LONG</code> and <code>VARCHAR2</code> data can also be manifested in Java <code>String</code>, while <code>RAW</code> and <code>LONGRAW</code> data can also be manifested in Java <code>byte[]</code> arrays. Also, if your database supports large object types, such as <code>BLOB</code> and <code>CLOB</code>, then you may find these to be preferable to types like <code>LONG</code> and <code>LONG RAW</code>, although streams might still be used in extracting data from large objects. The Oracle SQLJ and JDBC implementations support large object types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006871">&#34;Support for BLOB, CLOB, and BFILE&#34;</a></div>
<p>Both SQLJ stream classes are subclasses of standard Java classes, <code>java.io.InputStream</code> for <code>BinaryStream</code> and <code>java.io.Reader</code> for <code>CharacterStream</code>, and act as wrappers to provide the functionality required by SQLJ. This functionality is to communicate to SQLJ the type and length of the underlying data so that it can be processed and formatted properly.</p>
</div>
<!-- class="sect2" -->
<a id="CHDBDCIG"></a>
<div id="JSQLJ361" class="sect2">
<h3 class="sect2">Key Aspects of Stream Support Classes</h3>
<p>The following abbreviated code illustrates key aspects of the <code>BinaryStream</code> class, such as what it extends, constructor signatures, and key method signatures:</p>
<pre>public class sqlj.runtime.BinaryStream extends sqlj.runtime.StreamWrapper
{   public sqlj.runtime.BinaryStream(java.io.InputStream);
    public sqlj.runtime.BinaryStream(java.io.InputStream,int);
    public java.io.InputStream getInputStream();
    public int getLength();
    public void setLength(int);
}
</pre>
<p>The following abbreviated code illustrates key aspects of the <code>CharacterStream</code> class:</p>
<pre>public class sqlj.runtime.CharacterStream extends java.io.FilterReader
{   public sqlj.runtime.CharacterStream(java.io.Reader);
    public sqlj.runtime.CharacterStream(java.io.Reader,int);
    public int getLength();
    public java.io.Reader getReader();
    public void setLength(int);
}
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The <code>int</code> parameters in the constructors are for data length, in bytes or characters as applicable.</p>
</li>
<li>
<p>For any method that takes a <code>java.io.InputStream</code> object as input, you can use a <code>BinaryStream</code> object instead. Similarly, for any method that takes a <code>java.io.Reader</code> object as input, you can use a <code>CharacterStream</code> object instead.</p>
</li>
<li>
<p>The deprecated <code>AsciiStream</code> and <code>UnicodeStream</code> classes have the same key aspects and signatures as <code>BinaryStream</code>.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006482"></a>
<div id="JSQLJ362" class="sect2">
<h3 class="sect2">Using SQLJ <a id="sthref265"></a>Streams to Send Data</h3>
<p>Standard SQLJ enables you to use streams as host variables to update the database. A key point in sending a SQLJ stream to the database is that you must somehow determine the length of the data and specify that length to the constructor of the SQLJ stream.</p>
<p>You can use a SQLJ stream to send data to the database as follows:</p>
<ol>
<li>
<p>Determine the length of the data.</p>
</li>
<li>
<p>Create an appropriate standard Java data object for input. For <code>BinaryStream</code>, this would be an input stream, an instance of <code>java.io.InputStream</code> or some subclass. For <code>CharacterStream</code>, this would be a reader object, an instance of <code>java.io.Reader</code> or some subclass.</p>
</li>
<li>
<p>Create an instance of the appropriate SQLJ stream class depending on the type of data, passing the data object and length to the constructor.</p>
</li>
<li>
<p>Use the SQLJ stream instance as a host variable in a suitable SQL operation in a SQLJ executable statement.</p>
</li>
<li>
<p>Close the stream.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although not required, it is recommended that you close the stream after using it.</div>
<p class="subhead2"><a id="JSQLJ363"></a>Updating LONG or LONG RAW from a File</p>
<p>This section illustrates how to create a <code>CharacterStream</code> object or a <code>BinaryStream</code> object from a <code>File</code> object and use it to update the database. The code example at the end uses a <code>CharacterStream</code> for a <code>LONG</code> column.</p>
<p>In updating a database column from a file, a step is needed to determine the length. You can do this by creating a <code>java.io.File</code> object before you create your input stream.</p>
<p>Following are the steps for updating the database from a file:</p>
<ol>
<li>
<p>Create a <code>java.io.File</code> object from your file. You can specify the file path name to the <code>File</code> class constructor.</p>
</li>
<li>
<p>Use the <code>length()</code> method of the <code>File</code> object to determine the length of the data. This method returns a <code>long</code> value, which you must cast to an <code>int</code> for input to the SQLJ stream class constructor.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Before performing this cast, test the <code>long</code> value to ensure that it is not too big to fit into an <code>int</code> variable. The static constant <code>MAX_VALUE</code> in the class <code>java.lang.Integer</code> indicates the largest possible Java <code>int</code> value.</div>
</li>
<li>
<p>For character data, create a <code>java.io.FileReader</code> object from the <code>File</code> object. You can pass the <code>File</code> object to the <code>FileReader</code> constructor.</p>
<p>For binary data, create a <code>java.io.FileInputStream</code> object from the <code>File</code> object. You can pass the <code>File</code> object to the <code>FileInputStream</code> constructor.</p>
</li>
<li>
<p>Create an appropriate SQLJ stream object. This would be a <code>CharacterStream</code> object for a character file or a <code>BinaryStream</code> object for a binary file. Pass the <code>FileReader</code> or <code>FileInputStream</code> object, as applicable, and the data length as an <code>int</code> to the SQLJ stream class constructor.</p>
</li>
<li>
<p>Use the SQLJ stream object as a host variable in an appropriate SQL operation in a SQLJ executable statement.</p>
</li>
</ol>
<p>The following is an example of writing <code>LONG</code> data to the database from a file. Presume you have an HTML file in <code>/private/mydir/myfile.html</code> and want to insert the file contents into a <code>LONG</code> column, <code>chardata</code>, in the <code>filetable</code> database table.</p>
<pre>import java.io.*;
import sqlj.runtime.*;

...
File myfile = new File (&#34;/private/mydir/myfile.html&#34;);
int length = (int)myfile.length();     // Must cast long output to int.
FileReader filereader = new FileReader(myfile);
CharacterStream charstream = new CharacterStream(filereader, length);
#sql { INSERT INTO filetable (chardata) VALUES (:charstream) };
charstream.close();
...
</pre>
<p class="subhead2"><a id="JSQLJ364"></a>Updating LONG RAW from a Byte Array</p>
<p>This section illustrates how to create a <code>BinaryStream</code> object from a byte array and uses it to update the database.</p>
<p>You must determine the length of the data before updating the database from a byte array. This is more trivial for arrays than for files, though, because all Java arrays have functionality to return the length.</p>
<p>Following are the steps in updating the database from a byte array:</p>
<ol>
<li>
<p>Use the <code>length</code> functionality of the array to determine the length of the data. This returns an <code>int</code>, which is what you will need for the constructor of any of the SQLJ stream classes.</p>
</li>
<li>
<p>Create a <code>java.io.ByteArrayInputStream</code> object from your array. You can pass the byte array to the <code>ByteArrayInputStream</code> constructor.</p>
</li>
<li>
<p>Create a <code>BinaryStream</code> object. Pass the <code>ByteArrayInputStream</code> object and data length as an <code>int</code> to the <code>BinaryStream</code> class constructor.</p>
<p>The constructor signature is as follows:</p>
<pre>BinaryStream (InputStream in, int length)
</pre>
<p>You can use an instance of <code>java.io.InputStream</code> or of any subclass, such as the <code>ByteArrayInputStream</code> class.</p>
</li>
<li>
<p>Use the SQLJ stream object as a host variable in an appropriate SQL operation in a SQLJ executable statement.</p>
</li>
</ol>
<p>The following is an example of writing <code>LONG RAW</code> data to the database from a byte array. Presume you have a byte array, <code>bytearray[]</code>, and you want to insert its contents into a <code>LONG RAW</code> column, <code>BINDATA</code>, in the <code>BINTABLE</code> database table.</p>
<pre>import java.io.*;
import sqlj.runtime.*;

...
byte[] bytearray = new byte[100];

(<span class="italic">Populate </span>bytearray<span class="italic"> somehow</span>.)
...
int length = bytearray.length;
ByteArrayInputStream arraystream = new ByteArrayInputStream(bytearray);
BinaryStream binstream = new BinaryStream(arraystream, length);
#sql { INSERT INTO bintable (bindata) VALUES (:binstream) };
binstream.close();
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is not necessary to use a stream as in this example. Alternatively, you can update the database directly from a byte array.</div>
</div>
<!-- class="sect2" -->
<a id="i1006561"></a>
<div id="JSQLJ365" class="sect2">
<h3 class="sect2">Retrieving <a id="sthref266"></a>Data into Streams: Precautions</h3>
<p>You can also use the SQLJ stream classes to retrieve data, but the logistics of using streams make certain precautions necessary with some database products. When reading long data and writing it to a stream using Oracle Database 12<span class="italic">c</span> Release 1 (12.1) and an Oracle JDBC driver, you must be careful in how you access and process the stream data.</p>
<p>As Oracle JDBC drivers access data from an iterator row, they must flush any stream item from the communications pipe before accessing the next data item. Even though the stream data is written to a local stream while the iterator row is processed, this stream data will be lost if you do not read it from the local stream before the JDBC driver accesses the next data item. This is because of the manner in which streams must be processed, which is due to their potentially large size and unknown length.</p>
<p>Therefore, as soon as your Oracle JDBC driver has accessed a stream item and written it to a local stream variable, you must read and process the local stream before anything else is accessed from the iterator.</p>
<p>This is especially problematic in using positional iterators, with their requisite <code>FETCH INTO</code> syntax. With each fetch, all columns are read before any are processed. Therefore, there can be only one stream item and it must be the last item accessed.</p>
<p>The precautions you must take can be summarized as follows:</p>
<ul>
<li>
<p>When using a positional iterator, you can have only one stream column and it must be the last column. As soon as you have fetched each row of the iterator, writing the stream item to a local input stream variable in the process, you must read and process the local stream variable before advancing to the next row of the iterator.</p>
</li>
<li>
<p>When using a named iterator, you can have multiple stream columns. However, as you process each iterator row, each time you access a stream field, writing the data to a local stream variable in the process, you must read and process the local stream immediately, before reading anything else from the iterator.</p>
<p>Furthermore, in processing each row of a named iterator, you must call the column accessor methods in the same order in which the database columns were selected in the query that populated the iterator. As mentioned in the preceding discussion, this is because stream data remains in the communications pipe after the query. If you try to access columns out of order, then the stream data may be skipped over and lost in the course of accessing other columns.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Oracle Database 12<span class="italic">c</span> Release 1 (12.1) and Oracle JDBC drivers do not support use of streams in <code>SELECT INTO</code> statements.</p>
</li>
<li>
<p>Input streams, by default, do not support <code>mark</code> and <code>reset</code> methods. If you pass any arbitrary input stream to the constructor, then the <code>reset</code> method of <code>InputStream</code> class will throw an <code>IOException</code>. So, always ensure that the input stream is in the proper state when passed to the <code>NcharAsciiStream</code> constructor. For example, reset the stream before passing it to <code>NcharAsciiStream</code> if the stream has no more data or if the stream is closed.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDBCIDD"></a>
<div id="JSQLJ366" class="sect2">
<h3 class="sect2">Using SQLJ <a id="sthref267"></a>Streams to Retrieve Data</h3>
<p>To retrieve data as a stream, standard SQLJ enables you to select data into a named or positional iterator that has a column of the appropriate SQLJ stream type.</p>
<p>This section covers the basic steps in retrieving data into a SQLJ stream using a positional iterator or a named iterator, taking into account the precautions documented in the preceding section.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006645">&#34;Stream Class Methods&#34;</a> and <a href="#i1006678">&#34;Examples of Retrieving and Processing Stream Data&#34;</a></div>
<p class="subhead2"><a id="JSQLJ367"></a>Using a SQLJ Stream Column in a Positional Iterator</p>
<p>Use the following steps to retrieve data into a SQLJ stream using a positional iterator:</p>
<ol>
<li>
<p>Declare a positional iterator class with the last column being of the appropriate SQLJ stream type.</p>
</li>
<li>
<p>Declare a local variable of your iterator type.</p>
</li>
<li>
<p>Declare a local variable of the appropriate SQLJ stream type. This will be used as a host variable to receive data from each row of the SQLJ stream column of the iterator.</p>
</li>
<li>
<p>Execute a query to populate the iterator you declared in Step 2.</p>
</li>
<li>
<p>Process the iterator as usual. Because the host variables in the <code>INTO</code>-list of the <code>FETCH INTO</code> statement must be in the same order as the columns of the positional iterator, the local input stream variable is the last host variable in the list.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="blangfea.htm#i1007114">&#34;Using Positional Iterators&#34;</a></div>
</li>
<li>
<p>In the iterator processing loop, after each iterator row is accessed, immediately read and process the local input stream, storing or printing the stream data as desired.</p>
</li>
<li>
<p>Close the local input stream each time through the iterator processing loop.</p>
</li>
<li>
<p>Close the iterator.</p>
</li>
</ol>
<p class="subhead2"><a id="JSQLJ368"></a>Using SQLJ Stream Columns in a Named Iterator</p>
<p>Use the following steps to retrieve data into one or more SQLJ streams using a named iterator:</p>
<ol>
<li>
<p>Declare a named iterator class with one or more columns of appropriate SQLJ stream type.</p>
</li>
<li>
<p>Declare a local variable of your iterator type.</p>
</li>
<li>
<p>Declare a local variable of some input stream or reader type for each SQLJ stream column in the iterator. These will be used to receive data from the stream-column accessor methods. These local stream variables need not be of the SQLJ stream types. They can be standard <code>java.io.InputStream</code> or <code>java.io.Reader</code>, as applicable.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The local stream variables need not be of the SQLJ stream types, because the data was already correctly formatted as a result of the iterator columns being of appropriate SQLJ stream types.</div>
</li>
<li>
<p>Execute a query to populate the iterator you declared in Step 2.</p>
</li>
<li>
<p>Process the iterator as usual. In processing each row of the iterator, as each stream-column accessor method returns the stream data, write it to the corresponding local input stream variable you declared in Step 3.</p>
<p>To ensure that stream data will not be lost, call the column accessor methods in the same order in which columns were selected in the query in Step 4.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="blangfea.htm#i1007114">&#34;Using Positional Iterators&#34;</a></div>
</li>
<li>
<p>In the iterator processing loop, immediately after calling the accessor method for any stream column and writing the data to a local input stream variable, read and process the local input stream, storing or printing the stream data as desired.</p>
</li>
<li>
<p>Close the local input stream each time through the iterator processing loop.</p>
</li>
<li>
<p>Close the iterator.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>When you populate a SQLJ stream object with data, the length attribute of the stream will not be meaningful. This attribute is meaningful only when you set it explicitly, either using the <code>setLength()</code> method that each SQLJ stream class provides or specifying the length to the constructor.</p>
</li>
<li>
<p>Although not required, it is recommended that you close the local input stream each time through the iterator processing loop.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006645"></a>
<div id="JSQLJ369" class="sect2">
<h3 class="sect2">Stream Cla<a id="sthref268"></a>ss Methods</h3>
<p>In processing a SQLJ stream column in a named or positional iterator, the local stream variable used to receive the stream data can be either a SQLJ stream type or the standard <code>java.io.InputStream</code> or <code>java.io.Reader</code> type, as applicable. In either case, standard methods of the input data object are supported.</p>
<p>If the local stream variable is a SQLJ stream type, <code>BinaryStream</code> or <code>CharacterStream</code>, you have the option of either reading data directly from the SQLJ stream object or retrieving the underlying <code>InputStream</code> or <code>Reader</code> object and reading data from that.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This is just a matter of preference. The former approach is simpler. However, the latter approach involves more direct and efficient data access.</div>
<p class="subhead2"><a id="i1006650"></a><a id="JSQLJ370"></a>Binary Stream Methods</p>
<p>The <code>BinaryStream</code> class is a subclass of the <code>sqlj.runtime.StreamWrapper</code> class. The <code>StreamWrapper</code> class provides the following key methods:</p>
<ul>
<li>
<p><code>InputStream getInputStream()</code>: You can optionally use this method to get the underlying <code>java.io.InputStream</code> object. However, this is not required, because you can also process SQLJ stream objects directly.</p>
</li>
<li>
<p><code>void setLength(int length)</code>: You can use this to set the <code>length</code> attribute of a SQLJ stream object. This is not necessary if you have already set <code>length</code> in constructing the stream object, unless you want to change it for some reason.</p>
<p>The <code>length</code> attribute must be set to an appropriate value before you send a SQLJ stream to the database.</p>
</li>
<li>
<p><code>int getLength()</code>: This method returns the value of the <code>length</code> attribute of a SQLJ stream. This value is meaningful only if you explicitly set it using the stream object constructor or the <code>setLength()</code> method. When you retrieve data into a stream, the <code>length</code> attribute is not set automatically.</p>
</li>
</ul>
<p>The <code>sqlj.runtime.StreamWrapper</code> class is a subclass of the <code>java.io.FilterInputStream</code> class, which is a subclass of the <code>java.io.InputStream</code> class. The following important methods of the <code>InputStream</code> class are supported by the SQLJ <code>BinaryStream</code> class as well:</p>
<ul>
<li>
<p><code>int read ()</code>: Reads the next byte of data from the input stream. The byte of data is returned as an <code>int</code> value in the range 0 to 255. If the end of the stream has already been reached, then the value <code>-1</code> is returned. This method blocks program execution until one of the following:</p>
<ul>
<li>
<p>Input data is available</p>
</li>
<li>
<p>The end of the stream is detected</p>
</li>
<li>
<p>An exception is thrown</p>
</li>
</ul>
</li>
<li>
<p><code>int read (byte b[])</code>: Reads up to <code>b.length</code> bytes of data from the input stream, writing the data into the specified <code>b[]</code> byte array. It returns an <code>int</code> value indicating how many bytes were read, or <code>-1</code> if the end of the stream has already been reached. This method blocks program execution until input is available.</p>
</li>
<li>
<p><code>int read (byte b[], int off, int len)</code>: Reads up to <code>len</code> bytes of data from the input stream, starting at the byte specified by the offset, <code>off</code>, and writing the data into the specified <code>b[]</code> byte array. It returns an <code>int</code> value indicating how many bytes were read, or <code>-1</code> if the end of the stream has already been reached. This method blocks until input is available.</p>
</li>
<li>
<p><code>long skip (long n)</code>: Skips over and discards <code>n</code> bytes of data from the input stream. However, in some circumstances, this method will actually skip a smaller number of bytes. It returns a <code>long</code> value indicating the actual number of bytes skipped.</p>
</li>
<li>
<p><code>void close()</code>: Closes the stream and releases any associated resources.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ371"></a>Character Stream Methods</p>
<p>The <code>CharacterStream</code> class provides the following key methods:</p>
<ul>
<li>
<p><code>Reader getReader()</code>: You can optionally use this method to get the underlying <code>java.io.Reader</code> object. However, this is not required, because you can also process SQLJ stream objects directly.</p>
</li>
<li>
<p><code>void setLength(int length)</code>: You can use this method to set the length of the stream object.</p>
</li>
<li>
<p><code>int getLength()</code>: You can use this method to get the length of the stream object.</p>
</li>
</ul>
<p>The <code>sqlj.runtime.CharacterStream</code> class is a subclass of the <code>java.io.FilterReader</code> class, which is a subclass of the <code>java.io.Reader</code> class. The following important methods of the <code>Reader</code> class are supported by the SQLJ <code>CharacterStream</code> class as well:</p>
<ul>
<li>
<p><code>int read ()</code>: Reads the next character of data from the reader. The data is returned as an <code>int</code> value in the range 0 to 65535. If the end of the data has already been reached, then the value <code>-1</code> is returned. This method blocks program execution until one of the following:</p>
<ul>
<li>
<p>Input data is available</p>
</li>
<li>
<p>The end of the data is detected</p>
</li>
<li>
<p>An exception is thrown</p>
</li>
</ul>
</li>
<li>
<p><code>int read (char cbuf[])</code>: Reads characters into an array, writing the data into the specified <code>cbuf[]</code> char array. It returns an <code>int</code> value indicating how many characters were read, or <code>-1</code> if the end of the data has already been reached. This method blocks program execution until input is available.</p>
</li>
<li>
<p><code>int read (char cbuf[], int off, int len)</code>: Reads up to <code>len</code> characters of data from the input, starting at the character specified by the offset, <code>off</code>, and writing the data into the specified <code>char[]</code> char array. It returns an <code>int</code> value indicating how many characters were read, or <code>-1</code> if the end of the data has already been reached. This method blocks until input is available.</p>
</li>
<li>
<p><code>long skip (long n)</code>: Skips over and discards <code>n</code> characters of data from the input. However, in some circumstances, this method will actually skip a smaller number of characters. It returns a <code>long</code> value indicating the actual number of characters skipped.</p>
</li>
<li>
<p><code>void close()</code>: Closes the stream and releases any associated resources.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006678"></a>
<div id="JSQLJ372" class="sect2">
<h3 class="sect2">Examples of Retrieving and Processing <a id="sthref269"></a>Stream Data</h3>
<p>This section provides examples of various scenarios of retrieving stream data, as follows:</p>
<ul>
<li>
<p>Using a <code>SELECT</code> statement to select data from a <code>LONG</code> column and populate a SQLJ <code>CharacterStream</code> column in a named iterator, as shown in <a href="#CHDBFGEJ">Example 5-1</a></p>
</li>
<li>
<p>Using a <code>SELECT</code> statement to select data from a <code>LONG RAW</code> column and populate a SQLJ <code>BinaryStream</code> column in a positional iterator, as shown in <a href="#CHDIBIFI">Example 5-2</a></p>
</li>
</ul>
<div id="JSQLJ373" class="example">
<p class="titleinexample"><a id="CHDBFGEJ"></a>Example 5-1 Selecting LONG Data into CharacterStream Column of Named Iterator</p>
<p>This example selects data from a <code>LONG</code> database column, populating a SQLJ <code>CharacterStream</code> column in a named iterator.</p>
<p>Assume there is a table named <code>FILETABLE</code> with a <code>VARCHAR2</code> column called <code>FILENAME</code> that contains file names and a <code>LONG</code> column called <code>FILECONTENTS</code> that contains file contents in character format. The code is as follows:</p>
<pre>import sqlj.runtime.*;
import java.io.*;
...
#sql iterator MyNamedIter (String filename, CharacterStream filecontents);

...
MyNamedIter namediter = null;
String fname;
CharacterStream charstream;
#sql namediter = { SELECT filename, filecontents FROM filetable };
while (namediter.next()) {
   fname = namediter.filename();
   charstream = namediter.filecontents();
   System.out.println(&#34;Contents for file &#34; + fname + &#34;:&#34;);
   printStream(charstream);
   charstream.close();
}

namediter.close();
...
public void printStream(Reader in) throws IOException
{
   int character;
   while ((character = in.read()) != -1) {
      System.out.print((char)character);
   }
}
</pre>
<p>Remember that you can pass a SQLJ character stream to any method that takes a standard <code>java.io.Reader</code> as an input parameter.</p>
</div>
<!-- class="example" -->
<div id="JSQLJ374" class="example">
<p class="titleinexample"><a id="CHDIBIFI"></a>Example 5-2 : Selecting LONG RAW Data into BinaryStream Column of Positional Iterator</p>
<p>This example selects data from a <code>LONG RAW</code> column, populating a SQLJ <code>BinaryStream</code> column in a positional iterator.</p>
<p>As explained in the preceding section, there can be only one stream column in a positional iterator and it must be the last column. Assume there is a table named <code>BINTABLE</code> with a <code>NUMBER</code> column called <code>IDENTIFIER</code> and a <code>LONG RAW</code> column called <code>BINDATA</code> that contains binary data associated with the identifier. The code is as follows:</p>
<pre>import sqlj.runtime.*;
...
#sql iterator MyPosIter (int, BinaryStream);

...
MyPosIter positer = null;
int id=0;
BinaryStream binstream=null;
#sql positer = { SELECT identifier, bindata FROM bintable };
while (true) {
   #sql { FETCH :positer INTO :id, :binstream };
   if (positer.endFetch()) break;
   
   (...<span class="italic">process data as desired</span>...)
   
   binstream.close();
}
positer.close();
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDDJACF"></a>
<div id="JSQLJ375" class="sect2">
<h3 class="sect2">SQLJ Stream Objects as Output Parameters and Function Return Values</h3>
<p>As described in the preceding sections, standard SQLJ supports the use of the <code>BinaryStream</code> and <code>CharacterStream</code> classes in the <code>sqlj.runtime</code> package for retrieval of stream data into iterator columns.</p>
<p>In addition, the Oracle SQLJ implementation enables the following uses of the SQLJ stream types if you use Oracle9<span class="italic">i</span> Database or later version, an Oracle JDBC driver, Oracle-specific code generation or Oracle customizer, and Oracle SQLJ run time:</p>
<ul>
<li>
<p>They can appear as <code>OUT</code> or <code>INOUT</code> host variables from a stored procedure or function call.</p>
</li>
<li>
<p>They can appear as the return value from a stored function call.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ376"></a>Streams as Stored <a id="sthref270"></a>Procedure Output Parameters</p>
<p>You can use the <code>BinaryStream</code> and <code>CharacterStream</code> types as the assignment type for a stored procedure or stored function <code>OUT</code> or <code>INOUT</code> parameter.</p>
<p>Assume the following table definition:</p>
<pre>CREATE TABLE streamexample (name VARCHAR2 (256), data LONG);
INSERT INTO streamexample (data, name)
   VALUES
   (&#39;0000000000111111111112222222222333333333344444444445555555555&#39;,
   &#39;StreamExample&#39;);
</pre>
<p>Also, presume the following stored procedure definition, which uses the <code>STREAMEXAMPLE</code> table:</p>
<pre>CREATE OR REPLACE PROCEDURE out_longdata 
                            (dataname VARCHAR2, longdata OUT LONG) IS
BEGIN
   SELECT data INTO longdata FROM streamexample WHERE name = dataname;
END out_longdata;
</pre>
<p>The following sample code uses a call to the <code>out_longdata</code> stored procedure to read the long data:</p>
<pre>import sqlj.runtime.*;

...
CharacterStream data;
#sql { CALL out_longdata(&#39;StreamExample&#39;, :OUT data) };
int c;
while ((c = data.read ()) != -1)
   System.out.print((char)c);
System.out.flush();
data.close();
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Closing the stream is recommended, but not required.</div>
<p class="subhead2"><a id="JSQLJ377"></a>Streams as Stored <a id="sthref271"></a>Function Results</p>
<p>You can use the <code>BinaryStream</code> and <code>CharacterStream</code> types as the assignment type for a stored function return result.</p>
<p>Assume the same <code>STREAMEXAMPLE</code> table definition as in the preceding stored procedure example. Also, assume the following stored function definition, which uses the <code>STREAMEXAMPLE</code> table:</p>
<pre>CREATE OR REPLACE FUNCTION get_longdata (dataname VARCHAR2) RETURN long
   IS longdata LONG;
BEGIN
   SELECT data INTO longdata FROM streamexample WHERE name = dataname;
   RETURN longdata;
END get_longdata;
</pre>
<p>The following sample code uses a call to the <code>get_longdata</code> stored function to read the long data:</p>
<pre>import sqlj.runtime.*;

...
CharacterStream data;
#sql data = { VALUES(get_longdata(&#39;StreamExample&#39;)) };
int c;
while ((c = data.read ()) != -1)
   System.out.print((char)c);
System.out.flush();
data.close();
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Closing the stream is recommended, but not required.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006820"></a>
<div id="JSQLJ378" class="sect1">
<h2 class="sect1">Support for JDBC 2.0 LOB Types and Oracle <a id="sthref272"></a><a id="sthref273"></a><a id="sthref274"></a><a id="sthref275"></a>Type Extensions</h2>
<p>The Oracle SQLJ implementation offers extended functionality for the following JDBC 2.0 and Oracle-specific data types:</p>
<ul>
<li>
<p>JDBC 2.0 large object (LOB) types (<code>BLOB</code> and <code>CLOB</code>)</p>
</li>
<li>
<p>Oracle <code>BFILE</code> type</p>
</li>
<li>
<p>Oracle <code>ROWID</code> type</p>
</li>
<li>
<p>Oracle REF CURSOR types</p>
</li>
<li>
<p>Other Oracle Database 12<span class="italic">c</span> Release 1 (12.1) data types, such as <code>NUMBER</code> and <code>RAW</code></p>
</li>
</ul>
<p>These data types are supported by classes in the <code>oracle.sql</code> package. LOBs and binary files (BFILEs) are handled similarly in many ways, so are discussed together. Additionally, the Oracle SQLJ implementation offers extended support for the standard BigDecimal JDBC type.</p>
<p>JDBC 2.0 functionality for user-defined SQL objects, object references, and collections are also supported.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="objcoll.htm#CIHEBGGC">Chapter 6, &#34;Objects, Collections, and OPAQUE Types&#34;</a></div>
<p>Note that using Oracle extensions in your code requires the following:</p>
<ul>
<li>
<p>Use one of Oracle JDBC drivers.</p>
</li>
<li>
<p>Use Oracle-specific code generation or for ISO code generation, customize the profiles appropriately. The default customizer, <code>oracle.sqlj.runtime.util.OraCustomizer</code>, is recommended.</p>
</li>
<li>
<p>Use Oracle SQLJ run time when your application runs.</p>
</li>
</ul>
<p>Oracle SQLJ run time and an Oracle JDBC driver are required whenever you use Oracle customizer, even if you do not actually use Oracle extensions in your code.</p>
<p>For Oracle-specific semantics-checking, you must use an appropriate checker. The default checker, <code>oracle.sqlj.checker.OracleChecker</code>, acts as a front end and will run the appropriate checker based on your environment. This will be one of the Oracle specific checkers if you are using an Oracle JDBC driver.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1006846">Package oracle.sql</a></p>
</li>
<li>
<p><a href="#i1006871">Support for BLOB, CLOB, and BFILE</a></p>
</li>
<li>
<p><a href="#CHDCFEJA">Support for Oracle ROWID</a></p>
</li>
<li>
<p><a href="#i1007184">Support for Oracle REF CURSOR Types</a></p>
</li>
<li>
<p><a href="#CHDECDHA">Support for Other Oracle Database 11<span class="italic">g</span> Data Types</a></p>
</li>
<li>
<p><a href="#CHDEJIAG">Extended Support for BigDecimal</a></p>
</li>
</ul>
<a id="i1006846"></a>
<div id="JSQLJ379" class="sect2">
<h3 class="sect2">Package <a id="sthref276"></a>oracle.sql</h3>
<p>SQLJ users, as well as JDBC users, should be aware of the <code>oracle.sql</code> package, which includes classes to support all the Oracle Database 12<span class="italic">c</span> Release 1 (12.1) data types, such as <code>oracle.sql.ROWID</code>, <code>oracle.sql.CLOB</code>, and <code>oracle.sql.NUMBER</code>. The <code>oracle.sql</code> classes are wrappers for the raw SQL data and provide appropriate mappings and conversion methods to Java formats. An <code>oracle.sql.*</code> object contains a binary representation of the corresponding SQL data in the form of a byte array. Each <code>oracle.sql.*</code> data type class is a subclass of the <code>oracle.sql.Datum</code> class.</p>
<p>For Oracle-specific semantics-checking, you must use an appropriate checker. The default checker, <code>oracle.sqlj.checker.OracleChecker</code>, acts as a front end and will run the appropriate checker based on your environment. This will be one of the Oracle specific checkers if you are using an Oracle JDBC driver.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="transopt.htm#i1006917">&#34;Connection Options&#34;</a></p>
</li>
<li>
<p><a href="transopt.htm#i1008060">&#34;Semantics-Checking and Offline-Parsing Options&#34;</a></p>
</li>
<li>
<p><a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006871"></a>
<div id="JSQLJ380" class="sect2">
<h3 class="sect2">Support for <a id="sthref277"></a><a id="sthref278"></a><a id="sthref279"></a><a id="sthref280"></a>BLOB, CLOB, and BFILE</h3>
<p>The Oracle SQLJ and JDBC implementations support JDBC 2.0 LOB types and provide similar support for the Oracle specific <code>BFILE</code> type (read-only binary files stored outside the database). These data types are supported by the following classes:</p>
<ul>
<li>
<p><code>oracle.sql.BLOB</code></p>
</li>
<li>
<p><code>oracle.sql.CLOB</code></p>
</li>
<li>
<p><code>oracle.sql.BFILE</code></p>
</li>
</ul>
<p>These classes can be used in Oracle-specific SQLJ applications in the following ways:</p>
<ul>
<li>
<p>As <code>IN</code>, <code>OUT</code>, or <code>INOUT</code> host variables in executable SQLJ statements and in <code>INTO</code>-lists</p>
</li>
<li>
<p>As return values from stored function calls</p>
</li>
<li>
<p>As column types in iterator declarations</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for more information about LOBs and BFILEs and use of supported stream APIs<span class="italic">.</span></div>
<p><a id="sthref281"></a>You can manipulate LOBs by using methods defined in the <code>BLOB</code> and <code>CLOB</code> classes, which is recommended, or by using the procedures and functions defined in the <code>DBMS_LOB</code> PL/SQL package. All procedures and functions defined in this package can be called by SQLJ programs.</p>
<p>You can manipulate BFILEs by using methods defined in the <code>BFILE</code> class, which is recommended, or by using the file-handling routines of the <code>DBMS_LOB</code> package.</p>
<p>Using methods of the <code>BLOB</code>, <code>CLOB</code>, and <code>BFILE</code> classes in a Java application is more convenient than using the <code>DBMS_LOB</code> package and may also lead to faster execution in some cases.</p>
<p>Note that the type of the chunk being read or written depends on the kind of LOB being manipulated. For example, character large objects (CLOBs) contain character data and, therefore, Java strings are used to hold chunks of data. Binary large objects (BLOBs) contain binary data and, therefore, Java byte arrays are used to hold chunks of data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>DBMS_LOB</code> package requires a round trip to the server. Methods in the <code>BLOB</code>, <code>CLOB</code>, and <code>BFILE</code> classes may also result in a round trip to the server.</div>
<p class="subhead2"><a id="JSQLJ381"></a>BFILE Class versus DBMS_LOB Functionality for BFILEs</p>
<p><a href="#CHDFAIDC">Example 5-3</a> and <a href="#CHDCEIED">Example 5-4</a> contrast use of the <code>oracle.sql</code> methods with use of the <code>DBMS_LOB</code> package for BFILEs:</p>
<div id="JSQLJ382" class="example">
<p class="titleinexample"><a id="CHDFAIDC"></a>Example 5-3 Use of oracle.sql.BFILE File-Handling Methods with BFILE</p>
<p>This example manipulates a BFILE using file-handling methods of the <code>oracle.sql.BFILE</code> class.</p>
<pre>BFILE openFile (BFILE file) throws SQLException 
{ 
  String dirAlias, name; 
  dirAlias = file.getDirAlias(); 
  name = file.getName(); 
  System.out.println(&#34;name: &#34; + dirAlias + &#34;/&#34; + name); 
   
  if (!file.isFileOpen())  
  { 
    file.openFile(); 
  } 
  return file; 
} 
</pre>
<p>The <code>BFILE</code> <code>getDirAlias()</code> and <code>getName()</code> methods construct the full path and file name. The <code>openFile()</code> method opens the file. You cannot manipulate BFILEs until they have been opened.</p>
</div>
<!-- class="example" -->
<div id="JSQLJ383" class="example">
<p class="titleinexample"><a id="CHDCEIED"></a>Example 5-4 Use of DBMS_LOB File-Handling Routines with BFILE</p>
<p>This example manipulates a BFILE using file-handling routines of the <code>DBMS_LOB</code> package.</p>
<pre>BFILE openFile(BFILE file) throws SQLException 
{
   String dirAlias, name;
   #sql { CALL dbms_lob.filegetname(:file, :out dirAlias, :out name) };
   System.out.println(&#34;name: &#34; + dirAlias + &#34;/&#34; + name);

   boolean isOpen;
   #sql isOpen = { VALUES(dbms_lob.fileisopen(:file)) };
   if (!isOpen) 
   {
      #sql { CALL dbms_lob.fileopen(:inout file) };
   }
   return file;
}
</pre>
<p>The <code>openFile()</code> method prints the name of a file object and then returns an opened version of the file. Note that BFILEs can be manipulated only after being opened with a call to <code>DBMS_LOB.FILEOPEN</code> or equivalent method in the <code>BFILE</code> class.</p>
</div>
<!-- class="example" -->
<p class="subhead2"><a id="JSQLJ384"></a>BLOB and CLOB Classes versus DBMS_LOB Functionality for LOBs</p>
<p><a href="#CHDBABAB">Example 5-5</a> and <a href="#CHDHJJII">Example 5-6</a> contrast use of the <code>oracle.sql</code> methods with use of the <code>DBMS_LOB</code> package for BLOBs, and <a href="#CHDGABAC">Example 5-7</a> and <a href="#CHDEJAJJ">Example 5-8</a> contrast use of the <code>oracle.sql</code> methods with use of the <code>DBMS_LOB</code> package for CLOBs.</p>
<div id="JSQLJ385" class="example">
<p class="titleinexample"><a id="CHDBABAB"></a>Example 5-5 Example: Use of oracle.sql.CLOB Read Methods with CLOB</p>
<p>This example reads data from a CLOB using methods of the <code>oracle.sql.CLOB</code> class.</p>
<pre>void readFromClob(CLOB clob) throws SQLException 
{ 
  long clobLen, readLen; 
  String chunk; 
 
  clobLen = clob.length(); 
 
  for (long i = 0; i &lt; clobLen; i+= readLen) { 
    chunk = clob.getSubString(i, 10); 
    readLen = chunk.length(); 
    System.out.println(&#34;read &#34; + readLen + &#34; chars: &#34; + chunk); 
  } 
} 
</pre>
<p>This method contains a loop that reads from the CLOB and returns a 10-character Java string each time. The loop continues until the entire CLOB has been read.</p>
</div>
<!-- class="example" -->
<div id="JSQLJ386" class="example">
<p class="titleinexample"><a id="CHDHJJII"></a>Example 5-6 Example: Use of DBMS_LOB Read Routines with CLOB</p>
<p>This example uses routines of the <code>DBMS_LOB</code> package to read from a CLOB.</p>
<pre>void readFromClob(CLOB clob) throws SQLException
{
   long clobLen, readLen;
   String chunk;

   #sql clobLen = { VALUES(dbms_lob.getlength(:clob)) };

   for (long i = 1; i &lt;= clobLen; i += readLen) {
       readLen = 10;
       #sql { CALL dbms_lob.read(:clob, :inout readLen, :i, :out chunk) };
       System.out.println(&#34;read &#34; + readLen + &#34; chars: &#34; + chunk);
   }
}
</pre>
<p>This method reads the contents of a CLOB in chunks of 10 characters at a time. Note that the chunk host variable is of the <code>String</code> type.</p>
</div>
<!-- class="example" -->
<div id="JSQLJ387" class="example">
<p class="titleinexample"><a id="CHDGABAC"></a>Example 5-7 Example: Use of oracle.sql.BLOB Write Routines with BLOB</p>
<p>This example writes data to a BLOB using methods of the <code>oracle.sql.BLOB</code> class. Input a BLOB and specified length.</p>
<pre>void writeToBlob(BLOB blob, long blobLen) throws SQLException 
{ 
  byte[] chunk = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; 
  long chunkLen = (long)chunk.length; 
   
  for (long i = 0; i &lt; blobLen; i+= chunkLen) { 
    if (blobLen &lt; chunkLen) chunkLen = blobLen; 
    chunk[0] = (byte)(i+1); 
    chunkLen = blob.putBytes(i, chunk); 
  } 
} 
</pre>
<p>This method goes through a loop that writes to the BLOB in 10-byte chunks until the specified BLOB length has been reached.</p>
</div>
<!-- class="example" -->
<div id="JSQLJ388" class="example">
<p class="titleinexample"><a id="CHDEJAJJ"></a>Example 5-8 Example: Use of DBMS_LOB Write Routines with BLOB</p>
<p>This example uses routines of the <code>DBMS_LOB</code> package to write to a BLOB.</p>
<pre>void writeToBlob(BLOB blob, long blobLen) throws SQLException
{
   byte[] chunk = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
   long chunkLen = (long)chunk.length;

   for (long i = 1; i &lt;= blobLen; i += chunkLen) {
      if ((blobLen - i + 1) &lt; chunkLen) chunkLen = blobLen - i + 1;
      chunk[0] = (byte)i;       
      #sql { CALL dbms_lob.write(:INOUT blob, :chunkLen, :i, :chunk) };
   }
} 
</pre>
<p>This method fills the contents of a BLOB in 10-byte chunks. Note that the chunk host variable is of the <code>byte[]</code> type.</p>
</div>
<!-- class="example" -->
<p class="subhead2"><a id="JSQLJ389"></a>LOB and BFILE St<a id="sthref282"></a><a id="sthref283"></a>ored Function Results</p>
<p>Host variables of the <code>BLOB</code>, <code>CLOB</code>, and <code>BFILE</code> type can be assigned to the result of a stored function call. The following example is for a CLOB, but code for BLOBs and BFILEs would be functionally the same.</p>
<p>First, presume the following function definition:</p>
<pre>CREATE OR REPLACE FUNCTION longer_clob (c1 CLOB, c2 CLOB) RETURN CLOB IS 
   result CLOB;
BEGIN
   IF dbms_lob.getLength(c2) &gt; dbms_lob.getLength(c1) THEN
      result := c2;
   ELSE 
      result := c1;
   END IF;
   RETURN result; 
END longer_clob;
</pre>
<p>The following example uses a CLOB as the assignment type for a return value from the <code>longer_clob</code> function:</p>
<pre>void readFromLongest(CLOB c1, CLOB c2) throws SQLException
{
   CLOB longest;
   #sql longest = { VALUES(longer_clob(:c1, :c2)) };
   readFromClob(longest);
}
</pre>
<p>The <code>readFromLongest()</code> method prints the contents of the longer passed CLOB, using the <code>readFromClob()</code> method defined previously.</p>
<p class="subhead2"><a id="JSQLJ390"></a>LOB and BFILE Ho<a id="sthref284"></a>st Variables and SELECT INTO Targets</p>
<p>Host variables of the <code>BLOB</code>, <code>CLOB</code>, and <code>BFILE</code> type can appear in the <code>INTO</code>-list of a <code>SELECT INTO</code> executable statement. The following example is for a BLOB and CLOB, but code for BFILEs would be functionally the same.</p>
<p>Assume the following table definition:</p>
<pre>CREATE TABLE basic_lob_table(x VARCHAR2(30), b BLOB, c CLOB);
INSERT INTO basic_lob_table 
   VALUES(&#39;one&#39;, &#39;010101010101010101010101010101&#39;, &#39;onetwothreefour&#39;);
INSERT INTO basic_lob_table 
   VALUES(&#39;two&#39;, &#39;020202020202020202020202020202&#39;, &#39;twothreefourfivesix&#39;);
</pre>
<p>The following example uses a BLOB and a CLOB as host variables that receive data from the table defined, using a <code>SELECT INTO</code> statement:</p>
<pre>...
BLOB blob;
CLOB clob; 
#sql { SELECT one.b, two.c INTO :blob, :clob 
     FROM basic_lob_table one, basic_lob_table two 
     WHERE one.x=&#39;one&#39; AND two.x=&#39;two&#39; };
#sql { INSERT INTO basic_lob_table VALUES(&#39;three&#39;, :blob, :clob) };
...
</pre>
<p>This example selects the BLOB from the first row and the CLOB from the second row of <code>BASIC_LOB_TABLE</code>. It then inserts a third row into the table using the BLOB and CLOB selected in the previous operation.</p>
<p class="subhead2"><a id="JSQLJ391"></a>LOBs and BFILEs in Ite<a id="sthref285"></a>rator Declarations</p>
<p>The <code>BLOB</code>, <code>CLOB</code>, and <code>BFILE</code> types can be used as column types for SQLJ positional and named iterators. Such iterators can be populated as a result of compatible executable SQLJ operations.</p>
<p>Following are sample declarations:</p>
<pre>#sql iterator NamedLOBIter(CLOB c);
#sql iterator PositionedLOBIter(BLOB);
#sql iterator NamedFILEIter(BFILE bf);
</pre>
<p class="subhead2"><a id="JSQLJ392"></a>LOB and BFILE Host Variables and Named Iterator Results</p>
<p>The following example uses the <code>BASIC_LOB_TABLE</code> table and the <code>readFromLongest()</code> method defined in previous examples and a CLOB in a named iterator. Similar code could be written for BLOBs and BFILEs.</p>
<pre>#sql iterator NamedLOBIter(CLOB c);

...
NamedLOBIter iter;  
#sql iter = { SELECT c FROM basic_lob_table };
if (iter.next())
   CLOB c1 = iter.c();
if (iter.next())
   CLOB c2 = iter.c();
iter.close();
readFromLongest(c1, c2);
...
</pre>
<p>This example uses an iterator to select two CLOBs from the first two rows of <code>BASIC_LOB_TABLE</code>, then prints the larger of the two using the <code>readFromLongest()</code> method.</p>
<p class="subhead2"><a id="JSQLJ393"></a>LOB and BFILE Host Variables and <a id="sthref286"></a>Positional Iterator FETCH INTO Targets</p>
<p>Host variables of the <code>BLOB</code>, <code>CLOB</code>, and <code>BFILE</code> type can be used with positional iterators and appear in the <code>INTO</code>-list of the associated <code>FETCH INTO</code> statement if the corresponding column attribute in the iterator is of the identical type.</p>
<p>The following example uses the <code>BASIC_LOB_TABLE</code> table and the <code>writeToBlob()</code> method defined in previous examples. Similar code could be written for CLOBs and BFILEs.</p>
<pre>#sql iterator PositionedLOBIter(BLOB);

...
PositionedLOBIter iter;
BLOB blob = null;
#sql iter = { SELECT b FROM basic_lob_table };
for (long rowNum = 1; ; rowNum++) 
{
    #sql { FETCH :iter INTO :blob };
    if (iter.endFetch()) break;
    writeToBlob(blob, 512*rowNum); 
}
iter.close();
...
</pre>
<p>This example calls <code>writeToBlob()</code> for each BLOB in <code>BASIC_LOB_TABLE</code>. Each row writes an additional 512 bytes of data.</p>
</div>
<!-- class="sect2" -->
<a id="CHDCFEJA"></a>
<div id="JSQLJ394" class="sect2">
<h3 class="sect2">Support for <a id="sthref287"></a>Oracle ROWID</h3>
<p>The Oracle specific <code>ROWID</code> type stores the unique address for each row in a database table. The <code>oracle.sql.ROWID</code> class wraps ROWID information and is used to bind and define variables of the <code>ROWID</code> type.</p>
<p>Variables of the <code>oracle.sql.ROWID</code> type can be used in SQLJ applications connecting to Oracle Database 12<span class="italic">c</span> Release 1 (12.1) in the following ways:</p>
<ul>
<li>
<p>As <code>IN</code>, <code>OUT</code> or <code>INOUT</code> host variables in SQLJ executable statements and in <code>INTO</code>-lists</p>
</li>
<li>
<p>As a return value from a stored function call</p>
</li>
<li>
<p>As column types in iterator declarations</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ395"></a>ROWIDs in Iterator Declarations</p>
<p>You can use <code>oracle.sql.ROWID</code> as a column type for SQLJ positional and named iterators, as shown in the following declarations:</p>
<pre>#sql iterator NamedRowidIter (String ename, ROWID rowid);

#sql iterator PositionedRowidIter (String, ROWID);
</pre>
<p class="subhead2"><a id="JSQLJ396"></a>ROWID Host Variables and Named-Iterator SELECT Results</p>
<p>You can use <code>ROWID</code> objects as <code>IN</code>, <code>OUT</code> and <code>INOUT</code> parameters in SQLJ executable statements. In addition, you can populate iterators whose columns include <code>ROWID</code> types. This code example uses the preceding example declarations.</p>
<pre>#sql iterator NamedRowidIter (String ename, ROWID rowid);

...
NamedRowidIter iter; 
ROWID rowid;
#sql iter = { SELECT first_name, rowid FROM employees };
while (iter.next())
{
   if (iter.first_name().equals(&#34;Peter Hall&#34;))
   {
       rowid = iter.rowid();
       #sql { UPDATE employees SET salary = salary + 500 WHERE rowid = :rowid };
   }
}
iter.close();
...
</pre>
<p>This example increases the salary of the employee named Peter Hall by $500 according to the ROWID.</p>
<p class="subhead2"><a id="JSQLJ397"></a>ROWID <a id="sthref288"></a>Stored Function Results</p>
<p>Consider the following function:</p>
<pre>CREATE OR REPLACE FUNCTION get_rowid (name VARCHAR2) RETURN ROWID IS
   rid ROWID;
BEGIN
   SELECT rowid INTO rid FROM employees WHERE first_name = name;
   RETURN rid;
END get_rowid;
</pre>
<p>Given the preceding stored function, the following example indicates how a <code>ROWID</code> object is used as the assignment type for the function return result:</p>
<pre>ROWID rowid;
#sql rowid = { values(get_rowid(&#39;AMY FEINER&#39;)) };
#sql { UPDATE employees SET salary = salary + 500 WHERE rowid = :rowid };
</pre>
<p>This example increases the salary of the employee named Amy Feiner by $500 according to the <code>ROWID</code>.</p>
<p class="subhead2"><a id="JSQLJ398"></a>ROWID <a id="sthref289"></a>SELECT INTO Targets</p>
<p>Host variables of the <code>ROWID</code> type can appear in the <code>INTO</code>-list of a <code>SELECT INTO</code> statement.</p>
<pre>ROWID rowid;
#sql { SELECT rowid INTO :rowid FROM employees WHERE first_name=&#39;PETER HALL&#39; };
#sql { UPDATE employees SET salary = salary + 500 WHERE rowid = :rowid };
</pre>
<p>This example increases the salary of the employee named Peter Hall by $500 according to the <code>ROWID</code>.</p>
<p class="subhead2"><a id="JSQLJ399"></a>ROWID <a id="sthref290"></a>Host Variables and Positional Iterator FETCH INTO Targets</p>
<p>Host variables of the <code>ROWID</code> type can appear in the <code>INTO</code>-list of a <code>FETCH INTO</code> statement if the corresponding column attribute in the iterator is of the identical type.</p>
<pre>#sql iterator PositionedRowidIter (String, ROWID);

...
PositionedRowidIter iter;
ROWID rowid = null;
String ename = null;
#sql iter = { SELECT first_name, rowid FROM employees };
while (true)
{
   #sql { FETCH :iter INTO :ename, :rowid };
   if (iter.endFetch()) break;
   if (ename.equals(&#34;PETER HALL&#34;))
   {
       #sql { UPDATE employees SET salary = salary + 500 WHERE rowid = :rowid };
   }
}
iter.close();
...
</pre>
<p>This example is similar to the previous named iterator example, but uses a positional iterator with its customary <code>FETCH INTO</code> syntax.</p>
<p class="subhead2"><a id="JSQLJ400"></a>Positioned Update and Delete<a id="sthref291"></a><a id="sthref292"></a><a id="sthref293"></a></p>
<p>Since Oracle Database 11<span class="italic">g</span> Release 1, SQLJ supports positioned update and delete operations. A positioned update or delete operation can be done using an iterator. The iterator used for positioned update or delete should implement the <code>sqlj.runtime.ForUpdate</code> interface. You can use a named iterator, positional iterator, or scrollable iterator.</p>
<p>The following code illustrates a positioned update:</p>
<pre>...
#sql iterator iter implements sqlj.runtime.ForUpdate(String str)
...
#sql iter = {SELECT first_name FROM employees WHERE department_id=10};
...
while(iter.next())
{
 #sql {UPDATE employees SET salary=salary+5000 <a id="sthref294"></a>WHERE CURRENT OF :iter};
}
...
</pre>
<p>In the preceding code, an iterator <code>iter</code> is created and used to update the <code>employees</code> table.</p>
<p>You can similarly perform a positioned delete. For example:</p>
<pre>...
#sql {DELETE FROM employees WHERE CURRENT OF :iter}
...
</pre>
<p>In the preceding example, <code>iter</code> is an iterator used to perform positioned delete.</p>
<p>The iterators that can be used with the <code>WHERE CURRENT OF</code> clause have the following limitations:</p>
<ul>
<li>
<p>The query used to populate the iterator should not operate on multiple tables.</p>
</li>
<li>
<p>You <span class="italic">cannot</span> use a PL/SQL procedure returning a <code>REF CURSOR</code> with the iterator.</p>
</li>
<li>
<p>You <span class="italic">cannot</span> use an iterator that has been populated from a result set. That is, an iterator populated using the following statement, where <code>rs</code> is a result set:</p>
<pre>#sql iter = {cast :rs}
</pre></li>
</ul>
<p class="subhead2"><a id="JSQLJ401"></a>for_update Option</p>
<p>If <code>for_update</code> option is set at translation time, then <code>&#34;FOR UPDATE</code>&#34; is appended to the SELECT statements, which in turn return results into a <code>ForUpdate</code> iterator as follows:</p>
<pre>% sqlj &ndash;for_update abc.sqlj
 
/* abc.sqlj */
#sql iterator  SalByName (double sal, String ename)  implements sqlj.runtime.ForUpdate;
 
public class abc {
&hellip;..
  void func1()
  {
    SalByName salbn;
    #sql salbn = {select salary, first_name from employees };
  }
&hellip;..
}
</pre>
<p>Now, &#34;<code>FOR UPDATE</code>&#34; is appended to the SELECT statement returning the <code>ForUpdate</code> iterator <code>salbn</code> in the following way:</p>
<pre>&hellip;&hellip;&hellip;
String theSqlTS = &rdquo;SELECT rowid sjT_rowid,first_name, salary FROM employees WHERE first_name =  :1 FOR UPDATE&#34;;
&hellip;&hellip;&hellip;
</pre>
<p><a href="#BCEFAHIE">Table 5-3</a> shows the plausible values for the <code>for_update</code> option and the corresponding SQL statement for the preceding example:</p>
<div id="JSQLJ402" class="tblhruleformal">
<p class="titleintable"><a id="sthref295"></a><a id="BCEFAHIE"></a>Table 5-3 Plausible values for the for_update option and the corresponding SQL statement</p>
<table class="cellalignment4024" title="Plausible values for the for_update option and the corresponding SQL statement" summary="Table showing plausible values for the for_update option and the corresponding SQL statement" dir="ltr">
<thead>
<tr class="cellalignment4011">
<th class="cellalignment4021" id="r1c1-t41">for_update option</th>
<th class="cellalignment4021" id="r1c2-t41">SQLJ Statement</th>
<th class="cellalignment4021" id="r1c3-t41">SQL Statement</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r2c1-t41" headers="r1c1-t41">
<p>none</p>
</td>
<td class="cellalignment4017" headers="r2c1-t41 r1c2-t41">
<p><code>sqlj -for_update abc.sqlj</code></p>
</td>
<td class="cellalignment4017" headers="r2c1-t41 r1c3-t41">
<p><code>SELECT rowid sjT_rowid,first_name, salary FROM employees WHERE first_name = :1 FOR UPDATE</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r3c1-t41" headers="r1c1-t41">
<p><code>nowait</code></p>
</td>
<td class="cellalignment4017" headers="r3c1-t41 r1c2-t41">
<p><code>sqlj -P-for_update=nowait QueryDemo.sqlj</code></p>
</td>
<td class="cellalignment4017" headers="r3c1-t41 r1c3-t41">
<p><code>SELECT rowid sjT_rowid,first_name, salary FROM employees WHERE first_name = :1 FOR UPDATE nowait</code></p>
</td>
</tr>
<tr class="cellalignment4011">
<td class="cellalignment4017" id="r4c1-t41" headers="r1c1-t41">
<p><code>number</code></p>
</td>
<td class="cellalignment4017" headers="r4c1-t41 r1c2-t41">
<p><code>sqlj -P-for_update=10 QueryDemo.sqlj</code></p>
</td>
<td class="cellalignment4017" headers="r4c1-t41 r1c3-t41">
<p><code>SELECT rowid sjT_rowid,first_name, salary FROM employees WHERE first_name = :1 FOR UPDATE wait 10</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
If the application already has <code>FOR UPDATE</code> in the select query, then using these new translator options will throw warnings during online check at translation time. If offline parsing is chosen during translation, then errors are not detected at translation time.</div>
</div>
<!-- class="sect2" -->
<a id="i1007184"></a>
<div id="JSQLJ403" class="sect2">
<h3 class="sect2">Support for Oracle REF CURSOR Types</h3>
<p>Oracle PL/SQL and the Oracle SQLJ implementation support the use of cursor variables that represent database cursors.</p>
<p class="subhead2"><a id="JSQLJ404"></a>Overview of <a id="sthref296"></a>REF CURSOR Types</p>
<p>Cursor variables are functionally equivalent to JDBC result sets, essentially encapsulating the results of a query. A cursor variable is often referred to as a REF CURSOR, but <code>REF CURSOR</code> itself is a type specifier, and not a type name. Instead, named REF CURSOR types must be specified. The following example shows a REF CURSOR type specification:</p>
<pre>TYPE EmpCurType IS REF CURSOR;
</pre>
<p>Stored procedures and stored functions can return parameters of Oracle REF CURSOR types. You must use PL/SQL to return a REF CURSOR parameter. You cannot accomplish this using SQL alone. A PL/SQL stored procedure or function can declare a variable of some named REF CURSOR type, execute a <code>SELECT</code> statement, and return the results in the REF CURSOR variable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></div>
<p class="subhead2"><a id="JSQLJ405"></a>REF CURSOR <a id="sthref297"></a>Types in SQLJ</p>
<p>In the Oracle SQLJ implementation, a REF CURSOR type can be mapped to iterator columns or host variables of any iterator class type or of the <code>java.sql.ResultSet</code> type, but host variables can be <code>OUT</code> only. Support for REF CURSOR types can be summarized as follows:</p>
<ul>
<li>
<p>As result expressions for stored function returns</p>
</li>
<li>
<p>As output host expressions for stored procedure or function output parameters</p>
</li>
<li>
<p>As output host expressions in <code>INTO</code>-lists</p>
</li>
<li>
<p>As iterator columns</p>
</li>
</ul>
<p>You can use the SQL <code>CURSOR</code> operator for a nested <code>SELECT</code> within an outer <code>SELECT</code> statement. This is how you can write a REF CURSOR object to an iterator column or <code>ResultSet</code> column in an iterator, or write a REF CURSOR object to an iterator host variable or <code>ResultSet</code> host variable in an <code>INTO</code>-list.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="blangfea.htm#i1007245">&#34;Using Iterators and Result Sets as Host Variables&#34;</a> for examples illustrating the use of implicit REF CURSOR variables, including an example of the <code>CURSOR</code> operator.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Use the type code <code>OracleTypes.CURSOR</code> for REF CURSOR types.</p>
</li>
<li>
<p>There is no <code>oracle.sql</code> class for REF CURSOR types. Use either <code>java.sql.ResultSet</code> or an iterator class. Close the result set or iterator to release resources when you are done processing it.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JSQLJ406"></a>REF CURSOR <a id="sthref298"></a>Example</p>
<p>The following sample method shows a REF CURSOR type being retrieved from an anonymous block:</p>
<pre>private static EmpIter refCursInAnonBlock(String name, int no) 
  throws java.sql.SQLException {
  EmpIter emps = null;    

  System.out.println(&#34;Using anonymous block for ref cursor..&#34;); 
  #sql { begin
           INSERT INTO employees (first_name, employee_id) VALUES (:name, :no);
           OPEN :out emps FOR SELECT first_name, employee_id FROM employees ORDER BY employee_id;
         end
       };
  return emps;
}
</pre></div>
<!-- class="sect2" -->
<a id="CHDECDHA"></a>
<div id="JSQLJ407" class="sect2">
<h3 class="sect2">Support for Other Oracle Database 11<span class="italic">g</span> Data Types</h3>
<p>All <code>oracle.sql</code> classes can be used for iterator columns or for input, output, or input-output host variables in the same way that any standard Java type can be used. This includes the classes mentioned in the preceding sections and others, such as the <code>oracle.sql.NUMBER</code>, <code>oracle.sql.CHAR</code>, and <code>oracle.sql.RAW</code> classes.</p>
<p>Because the <code>oracle.sql.*</code> classes do not require conversion to Java type format, they offer greater efficiency and precision than equivalent Java types. You would have to convert the data to standard Java types, however, to use it with standard Java programs or to display it to end users.</p>
</div>
<!-- class="sect2" -->
<a id="CHDEJIAG"></a>
<div id="JSQLJ408" class="sect2">
<h3 class="sect2">Extended <a id="sthref299"></a>Support for BigDecimal</h3>
<p>SQLJ supports <code>java.math.BigDecimal</code> in the following situations:</p>
<ul>
<li>
<p>As host variables in SQLJ executable statements</p>
</li>
<li>
<p>As return values from stored function calls</p>
</li>
<li>
<p>As iterator column types</p>
</li>
</ul>
<p>Standard SQLJ has the limitation that a value can be retrieved as <code>BigDecimal</code> only if that is the JDBC default mapping, which is the case only for numeric and decimal data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCECCCFI">Table 5-1, &#34;Type Mappings for Supported Host Expression Types&#34;</a></div>
<p>In the Oracle SQLJ implementation, however, you can map to nondefault types as long as the data type is convertible from numeric and you use Oracle9<span class="italic">i</span> Database or later version, an Oracle JDBC driver, Oracle-specific code generation or Oracle customizer, and Oracle SQLJ run time. The <code>CHAR</code>, <code>VARCHAR2</code>, <code>LONG</code>, and <code>NUMBER</code> types are convertible. For example, you can retrieve data from a <code>CHAR</code> column into a <code>BigDecimal</code> variable. However, to avoid errors, you must be careful that the character data consists only of numbers.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>BigDecimal</code> class is in the standard <code>java.math</code> package.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4010">
<tr>
<td class="cellalignment4017">
<table class="cellalignment4015">
<tr>
<td class="cellalignment4014"><a href="blangfea.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4014"><a href="objcoll.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4019">
<table class="cellalignment4013">
<tr>
<td class="cellalignment4014"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4014"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4014"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4014"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4014"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4014"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>