<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-72360"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Performance%20and%20Debugging"></a><title>Performance and Debugging</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743"/>
<meta name="dcterms.created" content="2013-12-02T6:55:15Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SQLJ Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17660-12"/>
<meta name="dcterms.isVersionOf" content="JSQLJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="transrun.htm" title="Previous" type="text/html"/>
<link rel="Next" href="inserver.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E17660-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">17/20</span> <!-- End Header -->
<div id="JSQLJ740" class="chapter"><a id="BHCCHECE"></a> <a id="i1008861"></a>
<h1 class="chapter"><span class="secnum">10</span> Performance and Debugging</h1>
<p>This chapter discusses features, utilities, and tips to enhance performance of your SQLJ application and to debug your SQLJ source code at run time. The following topics are discussed:</p>
<ul>
<li>
<p><a href="#i1005559">Performance Enhancement Features</a></p>
</li>
<li>
<p><a href="#i1006314">SQLJ Debugging Features</a></p>
</li>
<li>
<p><a href="#i1007063">SQLJ Support for Oracle Performance Monitoring</a></p>
</li>
</ul>
<a id="i1005559"></a>
<div id="JSQLJ741" class="sect1">
<h2 class="sect1">Performance <a id="sthref842"></a><a id="sthref843"></a><a id="sthref844"></a>Enhancement Features</h2>
<p>The Oracle SQLJ implementation includes features to enhance performance by making data access more efficient. These include the following:</p>
<ul>
<li>
<p><a href="#i1005601">Row Prefetching</a></p>
</li>
<li>
<p><a href="#i1005618">Statement Caching</a></p>
</li>
<li>
<p><a href="#i1005806">Update Batching</a></p>
</li>
<li>
<p><a href="#i1006199">Column Definitions</a></p>
</li>
<li>
<p><a href="#i1006237">Parameter Size Definitions</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<p>Your application will likely benefit from the default Oracle-specific code generation. The generated code will be optimized with direct calls to Oracle Java Database Connectivity (JDBC) driver, eliminating the overhead of intermediate calls to the SQLJ run time, which in turn would call JDBC.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="keyprog.htm#i1006746">&#34;Oracle-Specific Code Generation (No Profiles)&#34;</a></div>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
The Oracle SQLJ implementation does <span class="italic">not</span> support batch fetches, which is the fetching of sets of rows into arrays of values. However, you may be able to use Oracle row prefetching to obtain some of the benefits of batch fetching.</div>
<p>In addition to the preceding SQLJ performance enhancements, you can use optimizer hints in the SQL operations within a SQLJ program, as you can in any Oracle SQL operations.</p>
<p>The Ora<a id="sthref845"></a><a id="sthref846"></a><a id="sthref847"></a><a id="sthref848"></a><a id="sthref849"></a><a id="sthref850"></a>cle SQL implementation enables you to tune your SQL statements by using &#34;<code>/*+</code>&#34; or &#34;<code>--+</code>&#34; comment notation to pass hints to Oracle SQL optimizer. The SQLJ translator recognizes and supports these optimizer hints, passing them at run time as part of your SQL statement.</p>
<p>You can also define cost and selectivity information for a SQLJ stored function, as for any other stored function, using the extensibility features for SQL optimization in Oracle Database 12<span class="italic">c</span> Release 1 (12.1). During SQL execution, the optimizer invokes the cost and selectivity methods for the stored function, evaluates alternate strategies for execution, and chooses an efficient execution plan.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information</div>
<p>Note that using Oracle performance extensions in your code requires the following:</p>
<ul>
<li>
<p>Use one of Oracle JDBC drivers.</p>
</li>
<li>
<p>Use the default Oracle-specific code generation, or customize profiles appropriately.</p>
<p>For ISO standard code generation, the default customizer, <code>oracle.sqlj.runtime.util.OraCustomizer</code>, is recommended.</p>
</li>
<li>
<p>Use Oracle SQLJ run time when your application runs.</p>
</li>
</ul>
<p>Oracle SQLJ run time and an Oracle JDBC driver are required by your application whenever you customize profiles with Oracle customizer, even if you do not actually use Oracle extensions in your code.</p>
<a id="i1005601"></a>
<div id="JSQLJ742" class="sect2">
<h3 class="sect2">Row <a id="sthref851"></a><a id="sthref852"></a>Prefetching</h3>
<p>Standard JDBC receives the results of a query one row at a time, with each row requiring a separate round trip to the database. Row prefetching enables you to receive the results more efficiently, in groups of multiple rows each.</p>
<p>Use the <code>setFetchSize()</code> method of an <code>ExecutionContext</code> instance to set the number of rows to be prefetched whenever you execute a <code>SELECT</code> statement (for SQLJ statements using the particular <code>ExecutionContext</code> instance).</p>
<p>The <code>getFetchSize()</code> method of an <code>ExecutionContext</code> instance returns the current prefetch size, as an <code>int</code> value.</p>
<p>The following is an example of setting the prefetch size to 20 by getting the default execution context instance of the default connection context instance and calling the <code>setFetchSize()</code> method:</p>
<pre>DefaultContext.getDefaultContext().getExecutionContext().setFetchSize(20);
</pre>
<p>It is also possible to set the prefetch size directly on the underlying <code>OracleConnection</code> object using the JDBC application programming interface (API), but in SQLJ this is discouraged.</p>
<p>To specify the number of rows to prefetch for queries that use a given connection context instance, use the underlying JDBC connection, cast to an Oracle<code>Connection</code> instance. Following is an example that sets the prefetch value to 20 for your default connection:</p>
<pre>((OracleConnection)DefaultContext.getDefaultContext().getConnection()).setDefaultRowPrefetch(20);
</pre>
<p>Also, please note that the prefetch size set on the SQLJ connection context overrides the prefetch size set on the underlying JDBC connection.</p>
<p>The prefetch value needs to be setup on each individual connection context. For example, if <code>ctx</code> is an instance of a declared connection context class, set its prefetch value as follows:</p>
<pre>ctx.getExecutionContext().setFetchSize(20);
</pre>
<p>There is no maximum row-prefetch value. The default is 10 in JDBC, and this is inherited by SQLJ. This value is effective in typical circumstances, although you might want to increase it if you receive a large number of rows.</p>
</div>
<!-- class="sect2" -->
<a id="i1005618"></a>
<div id="JSQLJ743" class="sect2">
<h3 class="sect2">Statem<a id="sthref853"></a><a id="sthref854"></a>ent Caching</h3>
<p>SQLJ offers a statement caching feature that improves performance by saving executable statements that are used repeatedly, such as in a loop or in a method that is called repeatedly. When a statement is cached before it is reexecuted, the code does not have to be reparsed (either on the server or on the client), the statement object does not have to be recreated, and the parameter size definitions do not have to be recalculated. Without this feature, repeated statements would have to be reparsed on the client, and perhaps in the server as well, depending on whether a statement is still available in the general server-side SQL cache when it is encountered again.</p>
<p>For Oracle-specific code generation, SQLJ statement caching relies on Oracle JDBC driver, using the JDBC explicit caching mechanism. This is distinct from the JDBC implicit caching mechanism, although there are interdependencies. With Oracle-specific code, statement caching is controlled through connection methods.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<p>For ISO code generation, SQLJ has its own statement caching mechanism through functionality of the SQLJ run time. With ISO code, statement caching is controlled through the Oracle customizer <code>stmtcache</code> option.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For Oracle-specific code generation, explicit caching is the only statement caching mechanism that can be manipulated through SQLJ APIs. For the discussion in this document, it will be referred to as SQLJ/explicit statement caching.</div>
<p>In Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the default statement cache size is set to 5, provided the JDBC connection is being created by the connection context. If a connection context is created using an already available JDBC connection or data source, then the statement cache size will be set to that of the JDBC connection or the data source.</p>
<p class="subhead2"><a id="i1005665"></a><a id="JSQLJ744"></a>Connection Context Methods for Statement Caching (Oracle-Specific Code)</p>
<p>If you use Oracle-specific code generation, which is the case with the SQLJ translator default <code>-codegen=oracle</code> setting, use connection context methods for statement caching functionality. Note that any statement cache size greater than 0 results in SQLJ/explicit statement caching being enabled. By default, it is enabled with a cache size of 5, that is, five statements.</p>
<p>The following Oracle-specific (nonstandard) static methods have been added to the <code>sqlj.runtime.ref.DefaultContext</code> class, and are also included in any connection context classes you declare:</p>
<ul>
<li>
<p><code>static void setDefaultStmtCacheSize(int)</code></p>
<p>This sets the default statement cache size for <span class="italic">all</span> connection contexts. This becomes the initial statement cache size for any subsequently created instance of <span class="italic">any</span> connection context class, not just the class upon which you call the method. The method call does not affect connection context instances that already exist.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>setDefaultStmtCacheSize(int)</code> affects the statement cache size only for the connections that are created using the SQLJ connection contexts. It does not affect the statement cache size for the connections that are created using JDBC connections.
<p>Consider the following two code snippets:</p>
<p>Example 1:</p>
<pre>...
MyContext.setDefaultStmtCacheSize(10); 
OracleConnection conn = DriverManager.getConnection(url, user, passwd); 
myctx = new MyContext(conn); 
</pre>
<p>Example 2:</p>
<pre>...
MyContext.setDefaultStmtCacheSize(10); 
myctx = new MyContext(url, user, passwd,true);

</pre>
<p>In the preceding two examples, the statement cache size will be set to 10 only in the second example. In the first example, the statement cache size corresponding to this connection will not be affected because the connection is created using the <code>getConnection</code> method of the <code>DriverManager</code> interface from JDBC specification.</p>
</div>
</li>
<li>
<p><code>static int getDefaultStmtCacheSize()</code></p>
<p>This retrieves the current default statement cache size for connection contexts.</p>
</li>
</ul>
<p>And the following Oracle-specific instance methods have also been added to the <code>DefaultContext</code> class and are included in any other connection context classes:</p>
<ul>
<li>
<p><code>void setStmtCacheSize(int) throws java.sql.SQLException</code></p>
<p>This sets the statement cache size for the underlying connection of the particular connection context instance (overrides the default).</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If SQLJ/explicit caching is already disabled, then setting the size to 0 leaves it disabled. If it is already enabled, then setting the size to 0 leaves it enabled, but renders it nonfunctional.</div>
<ul>
<li>
<p><code>int getStmtCacheSize()</code></p>
<p>This verifies whether SQLJ/explicit statement caching is enabled for the underlying connection of the connection context. If so, it returns the current statement cache size. It can also return either of the following integer constants:</p>
<pre>static int STMT_CACHE_NOT_ENABLED
static int STMT_CACHE_EXCEPTION
</pre>
<p>It is possible for a <code>getStmtCacheSize()</code> call to cause a SQL exception. However, for backward compatibility, this method does not throw the exception directly. When an exception occurs, the method returns the constant <code>STMT_CACHE_EXCEPTION</code>. In this case, you can call the <code>getStmtCacheException()</code> method to find out what exception occurred.</p>
<p>If you call <code>getStmtCacheSize()</code> when SQLJ/explicit caching is disabled, then the method returns the constant <code>STMT_CACHE_NOT_ENABLED</code>. This is distinguished from a cache size of 0. Technically, it is possible for SQLJ/explicit caching to be enabled (though useless) with a cache size of 0.</p>
</li>
<li>
<p><code>java.sql.Exception getStmtCacheException()</code></p>
<p>See if there is a statement caching exception. There are two scenarios for using this method:</p>
<ul>
<li>
<p>Call it if a <code>getStmtCacheSize()</code> call returns <code>STMT_CACHE_EXCEPTION</code>.</p>
</li>
<li>
<p>Call it whenever you create a connection context instance with which you want to use statement caching. This is because of automatic manipulation that occurs with respect to statement cache size whenever you create a connection context instance. If you care about statement caching for the connection context instance, call <code>getStmtCacheException()</code> after creating the instance, to verify there were no problems.</p>
</li>
</ul>
</li>
</ul>
<p class="subhead2"><a id="i1005700"></a><a id="JSQLJ745"></a>Enabling and Disabling Statement Caching (Oracle-Specific Code)</p>
<p>With Oracle-specific code, to reiterate what was stated earlier, any nonzero statement cache size results in SQLJ/explicit caching being enabled. Because the default size is 5, statement caching is enabled by default.</p>
<p>You cannot explicitly disable SQLJ/explicit statement caching through SQLJ APIs, although you can effectively disable it (render it nonfunctional) by setting the statement cache size to 0. In this case, the connection context <code>getStmtCacheSize()</code> method might return 0, <span class="italic">not</span> <code>STMT_CACHE_NOT_ENABLED</code>.</p>
<p>You <span class="italic">can</span> explicitly disable SQLJ/explicit statement caching or JDBC implicit caching, through JDBC connection APIs. Because SQLJ/explicit caching and JDBC implicit caching use the same cache size, there might sometimes be reason to do so. The following methods are available through the <code>OracleConnection</code> class:</p>
<ul>
<li>
<p><code>void setExplicitCachingEnabled(boolean)</code></p>
</li>
<li>
<p><code>boolean getExplicitCachingEnabled()</code></p>
</li>
<li>
<p><code>void setImplicitCachingEnabled(boolean)</code></p>
</li>
<li>
<p><code>boolean getImplicitCachingEnabled()</code></p>
</li>
</ul>
<p>You have access to these methods if you retrieve the <code>OracleConnection</code> instance from within a SQLJ connection context instance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="alangfea.htm#i1007079">&#34;SQLJ Connection Context and JDBC Connection Interoperability&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
In SQLJ, JDBC implicit caching is disabled by default and remains disabled unless you explicitly enable it through the <code>setImplicitCachingEnabled()</code> method.</div>
<p class="subhead2"><a id="i1005728"></a><a id="JSQLJ746"></a>Key Interactions Between SQLJ/Explicit Caching and JDBC Implicit Caching</p>
<p>With regard to statement caching in Oracle-specific code, this document naturally emphasizes SQLJ/explicit caching rather than JDBC implicit caching. If you do not use JDBC code in your application, SQLJ/explicit caching is the only statement caching that is relevant. However, there are situations where you might want to use both SQLJ and JDBC code in your application, and in these circumstances you might also want to use implicit caching.</p>
<p>SQLJ/explicit caching and JDBC implicit caching are enabled independently of each other. Furthermore, you do not have access to the implicit cache through SQLJ. However, there is a key interaction between the two, in that they share the same cache size. If, for example, the statement cache size is 5, then you can have a maximum of five statements cached for SQLJ/explicit caching and implicit caching combined.</p>
<p>An important point related to this is that if you choose to effectively disable SQLJ/explicit statement caching by setting the cache size to 0, then you have also effectively disabled implicit caching.</p>
<p>Also be aware that if SQLJ/explicit caching is disabled, changing the cache size to a value greater than 0 will enable it, but this does not affect whether implicit caching is enabled.</p>
<p class="subhead2"><a id="i1005735"></a><a id="JSQLJ747"></a>JDBC Support for Statement Caching (ISO Code)</p>
<p>With ISO standard code generation, specified through the SQLJ translator <code>-codegen=iso</code> setting, statement caching is a standard SQLJ feature that does not require any particular JDBC driver. However, using a driver that implements the <code>sqlj.runtime.profile.ref.ClientDataSupport</code> interface enables more robust caching. Oracle Database 12<span class="italic">c</span> Release 1 (12.1) JDBC drivers implement this interface, providing the following features:</p>
<ul>
<li>
<p>A separate cache for each database connection, instead of a single static cache for the entire application</p>
</li>
<li>
<p>The ability to share cached statements between multiple instances of a connection context class that share the same underlying connection</p>
</li>
</ul>
<p>When a single cache is used, as is the case with a generic JDBC driver that does not implement <code>ClientDataSupport</code>, a statement executed in one connection can cause a cached statement from another connection to be flushed (if the statement cache size, the maximum number of statements that can be cached, is exceeded).</p>
<p class="subhead2"><a id="i1005741"></a><a id="JSQLJ748"></a>Oracle Customizer Option for Statement Cache Size (ISO Code)</p>
<p>With ISO standard code generation, statement caching is enabled in your application by default with a cache size of 5 (the same default size as with Oracle-specific code) when you use Oracle customizer, which is typically executed as part of Oracle SQLJ translation.</p>
<p>You can alter the statement cache size as desired, or effectively disable statement caching with a cache size of 0, through the Oracle customizer <code>stmtcache</code> option. This is set as <code>-P-Cstmtcache=</code><code><span class="codeinlineitalic">n</span></code>, where <code><span class="codeinlineitalic">n</span></code> is an integer.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="profcust.htm#i636682">&#34;Oracle Customizer Statement Cache Size Option (stmtcache)&#34;</a></div>
<p>If you use multiple connection context classes and, therefore, have multiple profiles, you can set their statement cache sizes individually by running SQLJ (actually, the customizer) separately for each profile.</p>
<p>At run time, the appropriate SQLJ profile determines the statement cache size for a connection. This would be the profile that corresponds to the first connection context class instantiated for this connection. Its statement cache size setting, if any, is determined according to how you set the Oracle customizer <code>stmtcache</code> option when you customized the profile. The run-time statement cache size for a connection is set when the first statement on that connection is executed.</p>
<p class="subhead2"><a id="i1005753"></a><a id="JSQLJ749"></a>Additional Statement Caching Behavior</p>
<p>When a SQLJ connection context object is instantiated, if the statement cache size on the underlying JDBC connection is smaller than the default size for the connection context class, then the SQLJ run time will attempt to increase the JDBC statement cache size to the connection context default value. This manipulation occurs even with ISO code generation, enabling explicit statement caching in the process, although this is actually of no relevance in the ISO code case.</p>
<p>If, on the other hand, the actual JDBC statement cache size is larger, then the SQLJ run time will not attempt to perform a change in the cache size. The SQLJ run time checks the actual JDBC cache size against the default size set whenever it creates a SQLJ connection context instance.</p>
<p>It is important to note that these methods have the same effect regardless of the context class on which they are issued, because they modify or report the same underlying static field.</p>
<p>As an example, assume the following connection context class declarations:</p>
<pre>#sql context CtxtA;
#sql context CtxtB;
</pre>
<p>In this case, each of the following three code instructions has the effect that whenever a new SQLJ connection context instance is subsequently created, it will <span class="italic">not</span> try to enable SQLJ/explicit statement caching:</p>
<pre>sqlj.runtime.ref.DefaultContext.setDefaultStmtCacheSize(0);
</pre>
<pre>CtxtA.setDefaultStmtCacheSize(0);
</pre>
<pre>CtxtB.setDefaultStmtCacheSize(0);
</pre>
<div class="infobox-note">
<p class="notep1">Important:</p>
If a SQLJ connection context instance is created on an underlying JDBC pooled connection, then SQLJ will not be able to change the JDBC statement cache size. For Oracle-specific code, you can retrieve the resulting exception through the connection context <code>getStmtCacheException()</code> method. In this case, the desired JDBC statement cache size must be set explicitly on the underlying physical connections. For data sources, the cache size is set through vendor-specific data source attributes.</div>
<p>SQLJ/explicit caching and JDBC implicit caching functionality have different semantics and behaviors. As noted earlier, SQLJ statement caching applies only to single statements used repeatedly, such as in a loop or through repeated calls to the same method. Consider the following example:</p>
<pre>...
#sql { <span class="italic">same SQL operaton</span> }; // occurrence #1
...
<span class="italic">Java code</span>
...
#sql { <span class="italic">same SQL operaton</span> }; // occurrence #2
...
<span class="italic">Java code</span>
...
#sql { <span class="italic">same SQL operaton</span> }; // occurrence #3
...
</pre>
<p>Assume the three SQL operations are identical, including white space.</p>
<p>SQLJ caching would consider these three occurrences of the same SQL operation to be three different statements. They will occupy three separate slots in the cache. JDBC implicit caching, however, would recognize these as identical statements, using only a single cache slot for all three. The statement would be reused for occurrence #2 and occurrence #3.</p>
<p class="subhead2"><a id="i1005794"></a><a id="JSQLJ750"></a>Statement Caching Limitations and Notes</p>
<p>Using a statement cache, even of size 1, will improve the performance of almost any SQLJ application. Be aware of the following, however:</p>
<ul>
<li>
<p>There is no benefit if each statement is executed only once.</p>
</li>
<li>
<p>Try to avoid interleaving statements executed once with statements executed multiple times. The statements being executed only once would needlessly take up space in the statement cache, which becomes an issue when you reach the statement cache size limit. As an alternative, if you use ISO code generation you can use a separate connection context class for statements that are executed only once and disable statement caching for that connection context class.</p>
</li>
<li>
<p>Distinct statements with identical SQL operations are treated the same way as any distinct statements. Each is processed and cached separately. As an alternative, put the SQL operation in a method and call the method repeatedly, instead of using distinct statements.</p>
</li>
<li>
<p>Be careful in choosing an appropriate statement cache size. If it is too small, then the cache might fill up resulting in statements being flushed before they are reexecuted. If it is too large, then database resources or program resources may be exhausted.</p>
</li>
</ul>
<p>Also be aware of the following general notes regarding statement caching:</p>
<ul>
<li>
<p>With Oracle-specific code generation, using separate SQLJ connection context instances to have separate statement caching behavior will not work if the connection contexts share the same underlying JDBC connection instance. This is because under Oracle-specific code generation, SQLJ uses the JDBC statement cache.</p>
</li>
</ul>
<ul>
<li>
<p>For Oracle applications, the statement cache size plus the maximum number of open JDBC statements in your application, both directly and through SQLJ, should be less than the maximum number of cursors available for a session. This is because the maximum number of cursors defines the maximum number of statements that can be open simultaneously.</p>
</li>
<li>
<p>Using a statement cache generally does not change the execution semantics of an operation itself, although there are some scenarios where it does. For example, if you have a statement that throws an exception when its resources are released, then using a cache would mean that the exception would not be thrown until the connection is closed or the statement is flushed from the cache, which happens when the cache size is exceeded.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1005806"></a>
<div id="JSQLJ751" class="sect2">
<h3 class="sect2">Update B<a id="sthref855"></a><a id="sthref856"></a>atching</h3>
<p>Update batching, referred to as batch updates in the Sun Microsystems JDBC 2.0 specification, allows <code>UPDATE</code>, <code>DELETE</code>, and <code>INSERT</code> statements that are batchable and compatible to be collected into a batch and sent to the database for execution at once, saving round trips to the database. This feature is included in the JDBC and SQLJ specifications and is supported by the Oracle JDBC and SQLJ implementations. Update batching is typically used for an operation that is executed repeatedly within a loop.</p>
<p>In SQLJ, update batching is tied to execution context usage. This feature is enabled or disabled in each execution context, independently of any other execution context, and each execution context instance maintains its own batch.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Be aware of the following for update batching:
<ul>
<li>
<p>You must use the default Oracle-specific code generation or, for ISO code generation, customize your application with Oracle customizer.</p>
</li>
<li>
<p>It is highly advisable to disable auto-commit mode. This gives you control of what to commit and what to roll back in case of an error during batch execution.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="i1005863"></a><a id="JSQLJ752"></a>Batchab<a id="sthref857"></a><a id="sthref858"></a>le and Compatible Statements</p>
<p>Two criteria determine whether a statement can be added to an existing batch of statements:</p>
<ul>
<li>
<p>Is it batchable? You cannot batch some kinds of statements under any circumstances.</p>
</li>
<li>
<p>Is it compatible with statements in the existing batch?</p>
</li>
</ul>
<p>For SQLJ, the following kinds of statements are batchable:</p>
<ul>
<li>
<p><code>UPDATE</code></p>
</li>
<li>
<p><code>INSERT</code></p>
</li>
<li>
<p><code>DELETE</code></p>
</li>
</ul>
<p>However <code>UPDATE</code> and <code>INSERT</code> statements with one or more stream host expressions are <span class="italic">not</span> batchable.</p>
<p>In SQLJ, only multiple instances of the same statement are compatible. This can occur in either of two circumstances:</p>
<ul>
<li>
<p>A statement is executed repeatedly in a loop.</p>
</li>
<li>
<p>A statement is executed in a method, and the method is called repeatedly.</p>
</li>
</ul>
<p class="subhead2"><a id="i1005882"></a><a id="JSQLJ753"></a>Enab<a id="sthref859"></a><a id="sthref860"></a>ling and Disabling Update Batching</p>
<p>SQLJ performs update batching separately for each execution context instance. Each one can have update batching enabled independently of your other execution context instances, and each maintains its own batch.</p>
<p>To enable or disable update batching for a particular execution context instance, use the <code>setBatching()</code> method of that execution context instance. This method takes boolean input, as follows:</p>
<pre>...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
</pre>
<p>or:</p>
<pre>...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(false);
...
</pre>
<p>Update batching is disabled by default.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>setBatching()</code> method does not affect an existing statement batch. Neither enabling nor disabling update batching causes an existing batch to be executed or canceled.</div>
<p>Use the <code>isBatching()</code> method of an execution context instance to determine if update batching is enabled for that execution context:</p>
<pre>ExecutionContext ec = new ExecutionContext();
...
boolean batchingOn = ec.isBatching();
</pre>
<p>This does not, however, indicate whether a batch is currently pending.</p>
<p class="subhead2"><a id="i1005910"></a><a id="JSQLJ754"></a>Expli<a id="sthref861"></a><a id="sthref862"></a>cit and Implicit Batch Execution</p>
<p>You can explicitly execute a pending update batch as desired, but it might also be implicitly executed under certain circumstances.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is important to be aware of what happens when an exception occurs in the middle of a batch execution. Refer to <a href="#i1006173">&#34;Error Conditions During Batch Execution&#34;</a>.</div>
<p>Use the <code>executeBatch()</code> method of the execution context instance to explicitly execute an update batch. This method returns an <code>int</code> array of update counts.</p>
<p>Following is an example of explicitly executing a batch:</p>
<pre>...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
double[] sals = ...;
String[] empnos = ...;
for (int i = 0; i &lt; empnos.length; i++)
{
   #sql [ec] { UPDATE employees SET salary = :(sals[i]) WHERE employee_id = :(empnos[i]) };
}
int[] updateCounts = ec.executeBatch();
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you invoke <code>executeBatch()</code> when the execution context instance has no pending batch, then the method returns <code>null</code>.</div>
<p>When a pending update batch exists, it is implicitly executed in the following circumstances:</p>
<ul>
<li>
<p>An executable statement is encountered that is not batchable. In this case the existing batch is executed first, then the nonbatchable statement is executed.</p>
</li>
<li>
<p>An update statement is encountered that is batchable, but is not compatible with the statements in the existing batch, in other words, is not an instance of the same statement. In this case the batch is executed, then a new batch is created, starting with the incompatible statement.</p>
</li>
<li>
<p>A predefined batch limit, that is, a specified number of statements, is reached.</p>
</li>
</ul>
<p>Following is an example. First one batch is created and executed implicitly when an unbatchable statement is encountered, then a new batch is created and executed implicitly when a batchable, but incompatible, statement is encountered:</p>
<pre>ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
/* Statements in the following loop will be placed in a batch */
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec] { UPDATE employees SET salary = :(sals[i]) WHERE employee_id = :(empnos[i]) };
}

/* a SELECT is unbatchable so causes the batch to be executed */
double avg;
#sql [ec] { SELECT avg(salary) INTO :avg FROM employees };

/* Statements in the following loop will be placed in a new batch */
double[] comms = ...;
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec] { UPDATE employees SET commission_pct = :(comms[i]) WHERE employee_id = :(empnos[i]) };
}

/* the following update is incompatible with the second batch, so causes it to be executed */
int smithdeptno = ...;
#sql [ec] { UPDATE employees SET department_no = :deptno WHERE first_name = &#39;Smith&#39; };
</pre>
<p>To obtain the update count array for a batch executed implicitly, invoke the <code>getBatchUpdateCounts()</code> method of the execution context instance. This returns the update counts for the last batch to be executed successfully in this execution context instance. The following code statement could be inserted after the <code>SELECT</code> and after the last <code>UPDATE</code>:</p>
<pre>int[] updateCounts = ec.getBatchUpdateCounts();
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If no update batch has been executed successfully for the execution context instance, then <code>getBatchUpdateCounts()</code> returns <code>null</code>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006039">&#34;Execution Context Update Counts&#34;</a></div>
<p class="subhead2"><a id="i1006005"></a><a id="JSQLJ755"></a>Can<a id="sthref863"></a><a id="sthref864"></a>celing a Batch</p>
<p>To cancel the batch that is pending in an execution context, use the <code>cancel()</code> method of the execution context instance. You can, for example, cancel a batch that has been executed, but not yet committed, in the event that an exception occurred during batch execution. Following is an example:</p>
<pre>...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
double[] sals = ...;
String[] empnos = ...;
for (int i = 0; i &lt; empnos.length; i++)
{
   #sql [ec] { UPDATE employees SET salary = :(sals[i]) WHERE employee_id = :(empnos[i]) };
   if (!check(sals[i], empnos[i])) //assume &#34;check&#34; is a user-supplied function
   {
      ec.cancel();
      throw new SQLException(&#34;Process canceled.&#34;);
   }
}

try 
{ 
   int[] updateCounts = ec.executeBatch();
} catch ( SQLException exception) { ec.cancel(); }
...
</pre>
<p>When you cancel a batch, the next batchable statement will start a new batch.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Calling <code>cancel()</code> will also cancel any statement currently executing.</p>
</li>
<li>
<p>Canceling a batch does <span class="italic">not</span> disable update batching.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="i1006039"></a><a id="JSQLJ756"></a>Execu<a id="sthref865"></a><a id="sthref866"></a>tion Context Update Counts</p>
<p>In the Oracle Database 12<span class="italic">c</span> Release 1 (12.1) SQLJ implementation, the array of update counts returned by the <code>executeBatch()</code> or <code>getBatchUpdateCounts()</code> method of an execution context instance does <span class="italic">not</span> contain counts of the number of rows updated by the batched statements, but simply values indicating whether each statement was successful. So its functionality differs from that of the single update count returned by the <code>getUpdateCount()</code> method of the execution context instance when batching is not enabled. As statements are batched, and after batch execution, the single update count returned by <code>getUpdateCount()</code> is also affected.</p>
<p>In a batch-enabled environment, the value available from the <code>getUpdateCount()</code> method of the execution context instance is modified after each statement is encountered. It will be updated with one of several <code>ExecutionContext</code> class static <code>int</code> constant values, as follows:</p>
<ul>
<li>
<p><code>NEW_BATCH_COUNT</code>: Indicates that a new batch was created for the last statement encountered.</p>
</li>
<li>
<p><code>ADD_BATCH_COUNT</code>: Indicates that the last statement encountered was added to an existing batch.</p>
</li>
<li>
<p><code>EXEC_BATCH_COUNT</code>: Indicates that the pending batch was executed, either explicitly or implicitly, after the last statement was encountered.</p>
</li>
</ul>
<p>If you want to refer to these constants, then use the following qualified names:</p>
<pre>ExecutionContext.NEW_BATCH_COUNT
ExecutionContext.ADD_BATCH_COUNT
ExecutionContext.EXEC_BATCH_COUNT
</pre>
<p>After a batch has been executed, either explicitly or implicitly, the array of values returned by <code>executeBatch()</code> or <code>getBatchUpdateCounts()</code> indicates only whether the statements executed successfully. There is an array element for each batched statement. In accordance with the JDBC 2.0 specification, a value of <code>-2</code> for an array element indicates that the corresponding statement completed successfully, but that the number of rows it affected is unknown.</p>
<p>Checking all the array values after execution of a batch would not be meaningful. As currently implemented, the only useful test of this array would be to verify the number of statements that were in the batch prior to execution, by checking the number of elements in the array after a successful execution (essentially, after a batch execution that does not produce an exception).</p>
<p>Note that the update counts array is not modified as statements are batched, only as the batch is executed.</p>
<p class="subhead2"><a id="i1006064"></a><a id="JSQLJ757"></a>Set<a id="sthref867"></a><a id="sthref868"></a>ting a Batch Limit</p>
<p>You can specify that each update batch be executed after a predefined number of statements have been batched, before the next statement would be added. Use the <code>setBatchLimit()</code> method of the execution context instance, inputting a positive, nonzero integer as follows:</p>
<pre>...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
ec.setBatchLimit(10);
...
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; 20; i++) 
{
   #sql [ec] { UPDATE emp1 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
}
</pre>
<p>This loop is executed 20 times, with the statements being batched and the batch being executed during the 11th time through the loop, before the 11th statement would be added to the batch. Note that the batch would not be executed a second time in the loop, however. When your application exits the loop, the last ten statements would still be in the batch and would not be executed until another statement is encountered or you execute the batch explicitly.</p>
<p>You can use two special static <code>int</code> constants of the <code>ExecutionContext</code> class as input to the <code>setBatchLimit()</code> method:</p>
<ul>
<li>
<p><code>AUTO_BATCH</code>: Enables the SQLJ run time to determine the batch limit.</p>
</li>
<li>
<p><code>UNLIMITED_BATCH</code> (default): Specifies that there is no batch limit.</p>
</li>
</ul>
<p>For example:</p>
<pre>...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
ec.setBatchLimit(ExecutionContext.AUTO_BATCH);
...
</pre>
<p>or:</p>
<pre>ec.setBatchLimit(ExecutionContext.UNLIMITED_BATCH);
...
</pre>
<p>To check the current batch limit, use the <code>getBatchLimit()</code> method of the execution context instance.</p>
<p class="subhead2"><a id="i1006096"></a><a id="JSQLJ758"></a>Batch<a id="sthref869"></a><a id="sthref870"></a>ing Incompatible Statements</p>
<p>If you want to batch a statement that is incompatible with statements in an existing batch, without implicitly executing the existing batch, then you will have to use a separate execution context instance. Following is an example:</p>
<pre>...
ExecutionContext ec1 = new ExecutionContext();
ec1.setBatching(true);
ExecutionContext ec2 = new ExecutionContext();
ec2.setBatching(true);
...
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec1] { UPDATE emp1 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
   #sql [ec2] { UPDATE emp2 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
}
int[] updateCounts1 = ec1.executeBatch();
int[] updateCounts2 = ec2.executeBatch();
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example assumes that the two <code>UPDATE</code> statements are completely independent of each other. Do not batch interdependent statements in different execution contexts because you cannot completely assure the order in which they will be executed.</div>
<p>An alternative is to use a single execution context and separate loops so that all the <code>EMP1</code> updates are batched and executed prior to the <code>EMP2</code> updates:</p>
<pre>...
ExecutionContext ec = new ExecutionContext();
ec.setBatching(true);
...
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec] { UPDATE emp1 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
}
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql [ec] { UPDATE emp2 SET sal = :(sals[i]) WHERE empno = :(empnos[i]) };
}
ec.executeBatch();
...
</pre>
<p>This example executes the first batch implicitly and the second batch explicitly.</p>
<p class="subhead2"><a id="i1006140"></a><a id="JSQLJ759"></a>Using Implicit E<a id="sthref871"></a><a id="sthref872"></a>xecution Contexts for Update Batching</p>
<p>All the update batching examples so far have created and specified explicit execution context instances. This is not necessary, however, given that every connection context instance has an implicit execution context instance. For example, you can access the implicit execution context instance of the default connection as follows:</p>
<pre>DefaultContext.getDefaultContext().getExecutionContext().setBatching(true);
...
double[] sals = ...;
String[] empnos = ...; 
for (int i = 0; i &lt; empnos.length; i++) 
{
   #sql { UPDATE employees SET salary = :(sals[i]) WHERE employee_id = :(empnos[i]) };
}
// implicitly execute the batch and commit
#sql { COMMIT };
</pre>
<p>Or, you could execute the batch explicitly, as follows:</p>
<pre>DefaultContext.getDefaultContext().getExecutionContext().executeBatch();
</pre>
<p class="subhead2"><a id="i1006158"></a><a id="JSQLJ760"></a>General C<a id="sthref873"></a><a id="sthref874"></a>autions Regarding Update Batching</p>
<p>If you use update batching, especially if you mix statements using an unbatched execution context instance with statements using a batched execution context instance, then remember the following points:</p>
<ul>
<li>
<p>If an unbatched statement depends on a batched statement, then be sure the batch is executed prior to the unbatched statement.</p>
</li>
<li>
<p>A JDBC <code>COMMIT</code> or <code>ROLLBACK</code> operation, that is, an auto-commit or any explicit use of the <code>commit()</code> or <code>rollback()</code> method of a JDBC <code>Connection</code> instance, does not execute pending statements in a batch.</p>
<p>It is important to note, however, that using a SQLJ <code>COMMIT</code> or <code>ROLLBACK</code> statement, such as follows, <span class="italic">will</span> execute pending statements in a batch:</p>
<pre>#sql { COMMIT };
</pre>
<p>or:</p>
<pre>#sql { ROLLBACK };
</pre>
<p>This is another reason that you should always commit or roll back changes using <code>#sql</code> syntax, which cleans up both SQLJ resources and JDBC resources.</p>
</li>
<li>
<p>When a batch is implicitly executed as a result of an unbatchable or incompatible statement being encountered, the batch is executed <span class="italic">before</span> the unbatchable or incompatible statement is executed, but <span class="italic">after</span> the input parameters of that statement have been evaluated and passed to the statement.</p>
</li>
<li>
<p>If you no longer intend to use a particular batch-enabled execution context instance, then explicitly execute or cancel its pending batch to free resources.</p>
</li>
</ul>
<p class="subhead2"><a id="i1006173"></a><a id="JSQLJ761"></a>Error C<a id="sthref875"></a><a id="sthref876"></a>onditions During Batch Execution</p>
<p>In the event that a statement causes an exception in the middle of a batch execution, be aware of the following:</p>
<ul>
<li>
<p>Batched statements following the statement that caused the exception are <span class="italic">not</span> executed.</p>
</li>
<li>
<p>Batched statements that had already been executed prior to the exception are <span class="italic">not</span> rolled back.</p>
</li>
<li>
<p>If the batch where the exception occurred was executed implicitly as the result of another (unbatchable or incompatible) statement being encountered, that statement is <span class="italic">not</span> executed.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Presumably you have disabled auto-commit mode when using update batching. This gives you commit/rollback control in case of an error during batch execution.</div>
<p>When an exception occurs during batch execution under JDBC 2.0 or later, it is typically an instance of the standard <code>java.sql.BatchUpdateException</code> class, a subclass of the <code>java.sql.SQLException</code> class. The <code>BatchUpdateException</code> class has a <code>getUpdateCounts()</code> method that, for batched statements successfully executed before the exception occurred, returns an array of update counts equivalent to what would be returned by the <code>executeBatch()</code> or <code>getBatchUpdateCounts()</code> method of the <code>ExecutionContext</code> class.</p>
<p class="subhead2"><a id="i1006187"></a><a id="JSQLJ762"></a>Recur<a id="sthref877"></a><a id="sthref878"></a>sive Call-ins and Update Batching</p>
<p>Execution of SQLJ stored procedures, where one calls the other, can result in situations where the two procedures are simultaneously using the same execution context instance. The update-batching flag, set using the <code>setBatching()</code> method of the execution context instance, would act in the same way as other execution context attributes. Regardless of which stored procedure sets it, it would affect the next executable statement in either stored procedure.</p>
<p>For this reason, update batching is automatically disabled in the server whenever a recursive call-in occurs. The pending batch is executed, and no batching occurs in the recursively invoked procedure. To avoid this behavior, use explicit execution context instances in batch-enabled stored procedures.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="inserver.htm#CCHJFGCB">&#34;Recursive SQLJ Calls in the Server&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006199"></a>
<div id="JSQLJ763" class="sect2">
<h3 class="sect2">Colum<a id="sthref879"></a><a id="sthref880"></a><a id="sthref881"></a>n Definitions</h3>
<p>The Oracle SQLJ implementation reflects Oracle JDBC support for column type and size definitions. Depending on the driver implementation, which differs somewhat among the different Oracle JDBC drivers, registering column types and sizes can save a trip to the database for each query. In particular, this is true for Oracle JDBC Thin driver and use of positional iterators.</p>
<p class="subhead2"><a id="JSQLJ764"></a>Oracle Implementation of Column Definitions</p>
<p>If you enable column definitions, then the Oracle SQLJ implementation takes the following steps to automatically register column types and sizes:</p>
<ul>
<li>
<p>During customization or during translation when the default Oracle-specific code generation is used, SQLJ connects to a specified database schema to determine types and sizes of columns being retrieved. With ISO standard SQLJ code generation, the column defaults become part of the SQLJ profile. This can be accomplished during the customization step of source code translation or during separate customization of an existing profile.</p>
</li>
<li>
<p>When your application executes, the SQLJ run time will use the column information to register the column types and sizes with the JDBC driver, using a call to the <code>defineColumnType()</code> method available in the Oracle JDBC statement classes.</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ765"></a>Customizer and Translator Options for Column Definitions</p>
<p>To enable column definitions, set SQLJ options as follows:</p>
<ul>
<li>
<p>Enable the <code>optcols</code> flag. For Oracle-specific code generation, use the SQLJ translator <code>-optcols</code> option. For ISO standard code generation, use either the translator option or the Oracle customizer option (<code>-P-Coptcols</code> on the SQLJ command line).</p>
</li>
<li>
<p>Set the user, password, and URL for a database connection. For Oracle-specific code generation, this is through the SQLJ translator <code>-user</code>, <code>-password</code>, and <code>-url</code> options. For ISO standard code generation, this can be through the translator options or you can separately use the customizer options (<code>-P-user</code>, <code>-P-password</code>, and <code>-P-url</code> on the SQLJ command line). In addition, set the JDBC driver class (<code>-P-driver</code> on the SQLJ command line) if you are not using the default <code>OracleDriver</code> class.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007528">&#34;Column Definitions (-optcols)&#34;</a> and <a href="transopt.htm#i1006917">&#34;Connection Options&#34;</a></div>
<p>For information about the customizer options, refer to the <code>optcols</code> section under <a href="profcust.htm#i634872">&#34;Overview of Customizer-Specific Options&#34;</a>, and the <code>user</code>, <code>password</code>, <code>url</code>, and <code>driver</code> sections under <a href="profcust.htm#i634472">&#34;Overview of Customizer Harness Options&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i1006237"></a>
<div id="JSQLJ766" class="sect2">
<h3 class="sect2">Param<a id="sthref882"></a><a id="sthref883"></a><a id="sthref884"></a>eter Size Definitions</h3>
<p>The Oracle JDBC and SQLJ implementations enable you to optimize JDBC resource allocation by defining parameter sizes (sizes of Java host variables) used as any of the following:</p>
<ul>
<li>
<p>Input or output parameters in stored procedure or function calls</p>
</li>
<li>
<p>Return values from stored function calls</p>
</li>
<li>
<p>Input or output parameters in SET statements</p>
</li>
<li>
<p>Input or output parameters in PL/SQL blocks</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ767"></a>Oracle Implementation of Parameter Size Definitions</p>
<p>Oracle implements parameter size definitions through option settings, in combination with hints embedded in source code comments. For ISO standard SQLJ code generation, Oracle customizer options are available. For the default Oracle-specific code generation, equivalent SQLJ translator options are available.</p>
<p>Use options and hints as follows:</p>
<ul>
<li>
<p>Enable parameter size definitions through the SQLJ translator or Oracle customizer parameter definition flag.</p>
</li>
<li>
<p>Specify default sizes for particular data types through the SQLJ translator or Oracle customizer parameter default size option.</p>
</li>
<li>
<p>Override data type default sizes for particular parameters by embedding hints in source code comments, following a prescribed format.</p>
</li>
</ul>
<p>For any given host variable, when parameter size definitions are enabled, resources are allocated according to the source code hint if there is one. If there is no source code hint, then the default size for the corresponding data type is used if one was specified. If there is no source code hint or appropriate default size, then maximum resources are allocated according to the JDBC implementation.</p>
<p>When your application executes, the parameter sizes are registered through calls to the <code>defineParameterType()</code> and <code>registerOutParameter()</code> methods available in the Oracle JDBC statement classes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you do not enable the parameter definition flag, then parameter size defaults and source code hints will be ignored and maximum or default resources will be allocated according to the JDBC implementation.</div>
<p class="subhead2"><a id="JSQLJ768"></a>Customizer and Translator Options for Parameter Size Definitions</p>
<p>Use the following SQLJ options for parameter size definitions:</p>
<ul>
<li>
<p>Use the <code>optparams</code> flag to enable parameter size definitions. For Oracle-specific code generation, use the SQLJ translator <code>-optparams</code> option. For ISO standard code generation, use either the translator option or the Oracle customizer option, <code>-P-Coptparams</code> on the SQLJ command line.</p>
</li>
<li>
<p>Use <code>optparamdefaults</code> to set default sizes for particular data types. For Oracle-specific code generation, use the SQLJ translator <code>-optparamdefaults=</code><code><span class="codeinlineitalic">xxxx</span></code> option. For ISO standard code generation, use either the translator option or the Oracle customizer option, <code>-P-Coptparamdefaults=</code><code><span class="codeinlineitalic">xxxx</span></code> on the SQLJ command line.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="transopt.htm#i1007582">&#34;Parameter Definitions (-optparams)&#34;</a></p>
</li>
<li>
<p><a href="transopt.htm#i1007635">&#34;Parameter Default Size (-optparamdefaults)&#34;</a></p>
</li>
<li>
<p><a href="profcust.htm#i634872">&#34;Overview of Customizer-Specific Options&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JSQLJ769"></a>Source Code H<a id="sthref885"></a>ints for Parameter Size Definitions</p>
<p>Embed source code hints for parameter size definitions within your SQLJ statements in the following format (you can add white space within the comment, as desired):</p>
<pre>/*(<span class="italic">size</span>)*/
</pre>
<p>The size is in bytes. Hints are ignored if the <code>optparams</code> flag is disabled.</p>
<p>You can override the default parameter size, without specifying a new size (leaving size allocation to the JDBC implementation), as follows:</p>
<pre>/*()*/
</pre>
<p>Here is an example:</p>
<pre>byte[] hash;
String name=Tyrone;
String street=2020 Meryl Street;
String city=Wichita;
String state=Kansas;
String zipcode=77777;
#sql hash = { /* (5) */ VALUES (ADDR_HASH(:name /* (20) */, :street /* () */, 
                               :city, :state, :INOUT zipcode /* (10) */ )) };
</pre>
<p>A hint for a result expression, such as the result expression <code>hash</code> in the example, must be the first item appearing inside the brackets of the SQLJ statement, as shown. Hints for input and output host variables must immediately follow the variables, as shown.</p>
<p>The example sets parameter sizes as follows:</p>
<ul>
<li>
<p><code>hash</code>: 5 bytes</p>
</li>
<li>
<p><code>name</code>: 20 bytes</p>
</li>
<li>
<p><code>street</code>: override default, but with no setting (leave allocation up to JDBC)</p>
</li>
<li>
<p><code>city</code>: none (use appropriate data type default, if any)</p>
</li>
<li>
<p><code>state</code>: none (use appropriate data type default, if any)</p>
</li>
<li>
<p><code>zipcode</code>: 10 bytes</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If any parameter size is altered such that its actual size exceeds its registered size at run time, then a SQL exception will be thrown.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006314"></a>
<div id="JSQLJ770" class="sect1">
<h2 class="sect1">SQLJ Debugging Features</h2>
<p>This section summarizes debugging features in the Oracle SQLJ implementation. It covers the following topics:</p>
<ul>
<li>
<p><a href="#BABIEADF">SQLJ -linemap Flag for Debugging</a></p>
</li>
<li>
<p><a href="#BABJDGDA">Server-Side debug Option</a></p>
</li>
<li>
<p><a href="#BABDIGAF">Overview of the AuditorInstaller Specialized Customizer</a></p>
</li>
<li>
<p><a href="#BABCFHFG">Overview of Developing and Debugging in Oracle10<span class="italic">g</span> JDeveloper</a></p>
</li>
</ul>
<a id="BABIEADF"></a>
<div id="JSQLJ771" class="sect2">
<h3 class="sect2">SQLJ -linemap Flag for Debugging</h3>
<p>The <code>-linemap</code> flag instructs SQLJ to map line numbers from a SQLJ source code file to locations in the corresponding <code>.class</code> file. This will be the <code>.class</code> file created during compilation of the <code>.java</code> file generated by the SQLJ translator. As a result of this, when Java run-time errors occur, the line number reported by the Java virtual machine (JVM) is the line number in the SQLJ source code, making it much easier to debug.</p>
<p>If you are using the Sun Microsystems <code>jdb</code> debugger, then use the <code>-jdblinemap</code> option instead of the <code>-linemap</code> option. The options are equivalent, except that <code>-jdblinemap</code> does some special processing, necessitated by the fact that <code>jdb</code> does not support Java source files with file name extensions other than the <code>.java</code> extension.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1007436">&#34;Line-Mapping to SQLJ Source File (-linemap)&#34;</a> and <a href="transopt.htm#i1007465">&#34;Line-Mapping to SQLJ Source File for jdb Debugger (-jdblinemap)&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are translating in the server, then class schema objects created during server-side translation automatically reference line numbers that map to the SQLJ source code. This is equivalent to enabling the <code>-linemap</code> option when you translate on a client.</div>
</div>
<!-- class="sect2" -->
<a id="BABJDGDA"></a>
<div id="JSQLJ772" class="sect2">
<h3 class="sect2">Server-Side debug Option</h3>
<p>If you are loading SQLJ source into the server and using the server-side embedded translator to translate it, then the server-side <code>debug</code> option instructs the server-side compiler to output debugging information when a <code>.sqlj</code> or <code>.java</code> source file is compiled in the server. This is equivalent to using the <code>-g</code> option when running the standard <code>javac</code> compiler on a client. This does not aid in debugging your SQLJ code in particular, but aids in debugging your Java code in general.</p>
<p>Refer to <a href="inserver.htm#CCHBGEBD">&#34;Option Support in the Server Embedded Translator&#34;</a> for more information about this option and information about how to set options in the server.</p>
<p>For general information about debugging in Oracle JVM, refer to the <a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABDIGAF"></a>
<div id="JSQLJ773" class="sect2">
<h3 class="sect2">Overview of the AuditorInstaller Specialized Customizer</h3>
<p>For ISO code generation, SQLJ provides a special customizer, <code>AuditorInstaller</code>. This customizer will insert sets of debugging statements, known as auditors, into profiles specified on the SQLJ command line. These profiles must already exist from previous customization. The debugging statements will execute during SQLJ run time (when someone runs your application), displaying a trace of method calls and values returned.</p>
<p>Use the customizer harness <code>debug</code> option, preceded by <code>-P-</code> as with any general customization option, to insert the debugging statements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="profcust.htm#i635528">&#34;AuditorInstaller Customizer for Debugging&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="BABCFHFG"></a>
<div id="JSQLJ774" class="sect2">
<h3 class="sect2">Overview of Developing and <a id="sthref886"></a><a id="sthref887"></a>Debugging in Oracle10<span class="italic">g</span> JDeveloper</h3>
<p>The Oracle SQLJ product is fully integrated into the Oracle10<span class="italic">g</span> JDeveloper visual programming tool.</p>
<p>JDeveloper also includes an integrated debugger that supports SQLJ. SQLJ statements, as with standard Java statements, can be debugged in-line as your application executes. Reported line numbers are according to the line numbers in your SQLJ source code (as opposed to in the generated Java code).</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007063"></a>
<div id="JSQLJ775" class="sect1">
<h2 class="sect1">SQLJ Sup<a id="sthref888"></a><a id="sthref889"></a>port for Oracle Performance Monitoring</h2>
<p>The following sections discuss Oracle SQLJ implementation support for Oracle Dynamic Monitoring Service (DMS):</p>
<ul>
<li>
<p><a href="#i1007488">Overview of SQLJ DMS Support</a></p>
</li>
<li>
<p><a href="#i1007493">Summary of SQLJ Command-Line Options for DMS</a></p>
</li>
<li>
<p><a href="#i1007498">SQLJ Run-Time Commands and Properties File Settings for DMS</a></p>
</li>
<li>
<p><a href="#BHCGFHJA">SQLJ DMS Sensors and Metrics</a></p>
</li>
<li>
<p><a href="#i1007478">SQLJ DMS Examples</a></p>
</li>
</ul>
<a id="i1007488"></a>
<div id="JSQLJ776" class="sect2">
<h3 class="sect2">Overv<a id="sthref890"></a>iew of SQLJ DMS Support</h3>
<p>DMS enables users to measure performance statistics for SQLJ programs. SQLJ support for DMS focuses on the overall performance per SQL statement, such as its execution time, but can also provide method-level or class-level performance information, such as with Oracle JDBC support for DMS. You can choose a client-side perspective, such as the overall performance of each <code>#sql</code> statement, a server-side perspective, such as server-side tracing of each SQL operation, or both.</p>
<p>Instrumenting a program, which is specified at translation time through SQLJ options, is required in order to enable DMS setup. Specifically, instrumenting is the process of inserting DMS calls into system or application code for measuring its performance.</p>
<p>At run time, any components that were instrumented during translation can be monitored during execution, according to instructions in a SQLJ DMS properties file. During run time, statistics are sent to DMS through DMS APIs. This requires a running DMS system in your environment. You can then access the statistics through DMS tools.</p>
<p>The statistics are intended to help you track and understand SQL statement performance and are reported according to the following hierarchy (from top to bottom):</p>
<ol>
<li>
<p>Application: The application, in this context, is defined to consist of the SQLJ and Java components specified in the SQLJ command line for translation. However, only the SQLJ components can be instrumented.</p>
</li>
<li>
<p>Module: A module corresponds to a Java package.</p>
</li>
<li>
<p>Action: An action maps to a Java class defined in a SQLJ program.</p>
</li>
<li>
<p>Statement: A statement is a SQL statement in a SQLJ program.</p>
</li>
</ol>
<p>The following DMS statistics are measured for client-side monitoring:</p>
<ul>
<li>
<p>Elapsed time for each <code>#sql</code> statement, including parsing and execution</p>
</li>
<li>
<p>Get-next time, the time to execute each <code>next()</code> call</p>
</li>
<li>
<p>Get-XXX time, the time to extract a database column through each <code>get</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> call</p>
</li>
</ul>
<p>These statistics require the DMS library to be in your classpath at both translation time and run time, so are not supported on the server, where the DMS library is not available. Server-side SQLJ code cannot be monitored in the way that client-side code can.</p>
<p>The following statistics are measured for server-side SQL monitoring of your SQLJ client program:</p>
<ul>
<li>
<p>Parsing time</p>
</li>
<li>
<p>Execution time</p>
</li>
<li>
<p>Fetching time</p>
</li>
</ul>
<p>These statistics are available from the Oracle Database 12<span class="italic">c</span> Release 1 (12.1) trace file, through SQL tracing functionality. This is independent of DMS, but you can enable it through the SQLJ DMS properties file <code>sqlmonitor.servertracing</code> setting.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007498">&#34;SQLJ Run-Time Commands and Properties File Settings for DMS&#34;</a></div>
<p>For a client-side SQLJ program, you can use both DMS statistics and server-side tracing. For example, from DMS you can get the total time required for a <code>#sql</code> statement that consists of a query, then from server-side tracing you can find out how much of that time was actually spent executing the SQL query in the server.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>DMS support currently requires Oracle-specific code generation, which is enabled by default.</p>
</li>
<li>
<p>In Oracle Database 12<span class="italic">c</span> Release 1 (12.1), instrumented code requires Java Development Kit (JDK) 6.</p>
</li>
<li>
<p>Only SQLJ declarations and statements are instrumented.</p>
</li>
<li>
<p>The DMS library is in the file <code>dms.jar</code>, in <code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/oc4j/lib</code> in Oracle Database 12<span class="italic">c</span> Release 1 (12.1)</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007493"></a>
<div id="JSQLJ777" class="sect2">
<h3 class="sect2">Summary of SQLJ Com<a id="sthref891"></a>mand-Line Options for DMS</h3>
<p>The Oracle SQLJ implementation provides following translator front-end options to support DMS:</p>
<ul>
<li>
<p><code>-instrument</code>: Enable instrumentation and designate a name for the application (the collective of the components being translated).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1011944">&#34;Instrumentation for DMS (-instrument)&#34;</a></div>
</li>
<li>
<p><code>-components</code>: Specify the components (packages and classes) to be instrumented.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="transopt.htm#i1011945">&#34;Components to Instrument for DMS (-components)&#34;</a></div>
</li>
</ul>
<p>Typically you would enable instrumentation by specifying a desired application name in the <code>-instrument</code> setting, optionally specifying a package as well. Or specify a setting of <code>true</code> to use the default application, <code>defaultApp</code>. For DMS instrumentation, the term application refers to all the SQLJ and Java components specified for translation in the SQLJ command line.</p>
<p>If instrumentation is enabled, a SQLJ DMS properties file is created according to the <code>-instrument</code> setting, starting from the current directory, and also according to any setting of the SQLJ <code>-d</code> option. For a setting of <code>true</code>, the properties file is named <code>sqlmonitor.properties</code> in the current directory.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A setting of <code>-instrument</code> is equivalent to <code>-instrument=true</code>. A setting of <code>-instrument=false</code> (the default) disables instrumentation.</div>
<p>As a simple example, a setting of <code>-instrument=myapp</code> will result in creation of the properties file <code>myapp.properties</code>. Now consider the following example, for an application name of <code>stock</code> and a package name of <code>com.acme</code>:</p>
<pre>% sqlj -instrument=com.acme/stock -d /home Stock.sqlj Trading.sqlj
</pre>
<p>Because of the <code>-d</code> option, the <code>/home/com/acme/stock.properties</code> file is created.</p>
<p>When instrumentation is enabled through the <code>-instrument</code> option, use the <code>-components</code> option to specify the subset of translated components to be instrumented for DMS monitoring, typically most or all of them to allow flexibility in what you can monitor during run time. Specify a comma-delimited list of packages (to instrument all classes in each package) or specific classes, or use the default <code>all</code> setting to instrument all components being translated.</p>
<p>For example, to instrument the classes <code>Stock</code> and <code>Trading</code>:</p>
<pre>% sqlj ... -components=com.acme.Stock,com.acme.Trading
</pre>
<p>At run time, instrumented components are monitored according to what is specified in the SQLJ DMS properties file. Any components that are not instrumented during translation cannot be monitored during run time, regardless of what is specified in the properties file.</p>
</div>
<!-- class="sect2" -->
<a id="i1007498"></a>
<div id="JSQLJ778" class="sect2">
<h3 class="sect2">SQLJ Run<a id="sthref892"></a><a id="sthref893"></a><a id="sthref894"></a>-Time Commands and Properties File Settings for DMS</h3>
<p>While the SQLJ <code>-instrument</code> option specifies whether the SQLJ translator instruments files for monitoring capability, it is the SQLJ DMS properties file that actually determines what is monitored and how, at run time.</p>
<p>This properties file is created by SQLJ during translation, and then you can modify it as desired. Be aware that if you run SQLJ again, however, SQLJ overwrites the properties file. Any changes that you made are lost.</p>
<p>Settings in the SQLJ DMS properties file are as follows:</p>
<ul>
<li>
<p><code>sqlmonitor.components</code>: This is a comma-delimited list of components (packages or classes) that have been instrumented. This is set automatically by the translator to reflect the setting of the SQLJ <code>-components</code> option.</p>
</li>
<li>
<p><code>sqlmonitor.monitorcomp</code>: This is a comma-delimited list of components (packages or classes) to be monitored and denotes a subset of the components in the <code>sqlmonitor.components</code> setting. The setting for <code>sqlmonitor.monitorcomp</code> is initially determined during translation to reflect the <code>sqlmonitor.components</code> setting, but you can then adjust it as desired. A setting of <code>all</code> means to monitor all components listed in the <code>sqlmonitor.components</code> setting.</p>
</li>
<li>
<p><code>sqlmonitor.dms</code>: This boolean flag, with a default value of <code>true</code>, specifies whether to deliver collected statistics to DMS. This requires a running Oracle Application Server 10<span class="italic">g</span> instance where you can use DMS tools. Statistics can be accessed through a Web browser or written into a file.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A setting of <code>sqlmonitor.dms=false</code> is not currently supported.</div>
</li>
<li>
<p><code>sqlmonitor.sysurl</code>: For server-side tracing, this specifies the database URL.</p>
</li>
<li>
<p><code>sqlmonitor.sysuser</code>: For server-side tracing, this specifies the database user. This user must have <code>sysdba</code> privileges.</p>
</li>
<li>
<p><code>sqlmonitor.syspassword</code>: For server-side tracing, this specifies the password for the <code>sysuser</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For <code>sysurl</code>, <code>sysuser</code>, and <code>syspassword</code>, default values are according to the <code>user</code>, <code>password</code>, and <code>url</code> values supplied to SQLJ, either through the SQLJ command line or through the SQLJ properties file.</div>
</li>
<li>
<p><code>sqlmonitor.servertracing</code>: Use this to enable server-side tracing, to collect performance statistics in the server, such as for SQL operations. Supported settings are <code>true</code> or <code>false</code> (the default).</p>
</li>
<li>
<p><code>sqlmonitor.dumpfile</code>: If delivering statistics to DMS, then you can use this option to specify a file into which the DMS tool writes the statistics. The default is <code><span class="codeinlineitalic">application_name</span></code><code>.mtr</code>, where <code><span class="codeinlineitalic">application_name</span></code> is according to the <code>-instrument</code> option setting (or is <code>defaultApp</code> by default).</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BHCGFHJA"></a>
<div id="JSQLJ779" class="sect2">
<h3 class="sect2">SQLJ DM<a id="sthref895"></a>S Sensors and Metrics</h3>
<p>Sensors are used by DMS to calculate performance metrics during the execution of instrumented SQLJ programs and delivered to DMS. They are organized as a hierarchy, with each sensor having a path name. Here are typical sensor formats:</p>
<pre>/SQLJ/<span class="italic">application_name</span>/<span class="italic">sensor_name</span>
/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">sensor_name</span>
/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">sensor_name</span>
/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/<span class="italic">sensor_name</span>
</pre>
<p>A sensor is an instance of the <code>oracle.dms.instrument.Sensor</code> class, which has methods for calculating and organizing performance statistics. For example, there are methods to instruct the sensor to derive additional metrics and to get the value of one of the metrics.</p>
<p>Be aware that before the end of an instrumented application, there must be a call to the <code>close()</code> method of the <code>oracle.sqlj.runtime.sqlmonitor.SQLMonitor</code> class, such as in the following example (which also uses the <code>Oracle</code> class <code>close()</code> method to close the connection context):</p>
<pre>try
{
   Oracle.close();
   oracle.sqlj.runtime.sqlmonitor.SQLMonitor.close();
} 
catch( Throwable e ) { ... }
</pre>
<p>Note the following terms:</p>
<ul>
<li>
<p>The <code><span class="codeinlineitalic">application_name</span></code> is the name of the application according to the SQLJ <code>-instrument</code> option, or <code>defaultApp</code> by default.</p>
</li>
<li>
<p>If a sensor is associated with a package, then the item <code><span class="codeinlineitalic">module</span></code> is the package name. The setting <code>*TopLevel*</code> is used if the package name is empty.</p>
</li>
<li>
<p>If a sensor is associated with a class, then <code><span class="codeinlineitalic">class</span></code> is the class name.</p>
</li>
<li>
<p>If a sensor is associated with a SQL statement, then <code><span class="codeinlineitalic">linenum</span></code> denotes the line number of the SQL statement in the SQLJ program being instrumented. If multiple SQL statements appear in the same line, then their starting column positions are used to distinguish them. For example, a <code><span class="codeinlineitalic">linenum</span></code> value of 8.13 indicates that 8 is the line number and 13 is the column number.</p>
</li>
</ul>
<p>The following sensors and associated metrics are typically of particular interest:</p>
<ul>
<li>
<p>Sensor name: <code>ContextType</code></p>
<pre>/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/ContextType
</pre>
<p>Metrics:</p>
<ul>
<li>
<p><code>value</code>: A string indicating the connection context type</p>
</li>
</ul>
</li>
<li>
<p>Sensor name: <code>SQLString</code></p>
<pre>/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/SQLString
</pre>
<p>Metrics:</p>
<ul>
<li>
<p><code>value</code>: A string consisting of the SQL statement</p>
<p>This is the exact string that is passed to JDBC, including any transformations made from the original <code>#sql</code> statement.</p>
</li>
</ul>
</li>
<li>
<p>Sensor name: <code>Execute</code></p>
<pre>/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/Execute
</pre>
<p>Metrics:</p>
<ul>
<li>
<p><code>time</code>: The total time, in milliseconds, of all the executions of the JDBC <code>execute()</code> method for this statement</p>
<p>If the statement executes five times, for example, then <code>time</code> would be the total time spent in the <code>execute()</code> method for the five executions.</p>
</li>
<li>
<p><code>completed</code>: The number of executions completed (such as 5)</p>
</li>
<li>
<p><code>minTime</code>: The shortest time of any single execution</p>
</li>
<li>
<p><code>maxTime</code>: The longest time of any single execution</p>
</li>
<li>
<p><code>avg</code>: The average execution time, which is <code>time</code> divided by <code>completed</code></p>
</li>
<li>
<p><code>active</code>: The number of threads executing the statement at the end of program execution, typically 0.</p>
</li>
<li>
<p><code>maxActive</code>: The maximum number of threads that executed the statement during program execution</p>
</li>
</ul>
<p>To measure the execution time of a JDBC statement, the clock is started immediately before the statement is executed and stopped when a result set is obtained or the statement otherwise finishes executing, or when an exception is caught.</p>
</li>
<li>
<p>Sensor name: <code>ServerExecute</code></p>
<pre>/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/ServerExecute
</pre>
<p>Metrics:</p>
<ul>
<li>
<p><code>value</code>: The total execution time in the server, in milliseconds, for all executions of this SQL statement</p>
</li>
<li>
<p><code>count</code>: The number of executions completed</p>
</li>
<li>
<p><code>minValue</code>: The shortest time of any single execution</p>
</li>
<li>
<p><code>maxValue</code>: The longest time of any single execution</p>
</li>
</ul>
</li>
<li>
<p>Sensor name: <code>ServerFetch</code></p>
<pre>/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/ServerFetch
</pre>
<p>Metrics:</p>
<ul>
<li>
<p><code>value</code>: The total fetch time in the server, in milliseconds, for all executions of this SQL statement</p>
</li>
<li>
<p><code>count</code>: The number of executions completed</p>
</li>
<li>
<p><code>minValue</code>: The shortest time of any single execution</p>
</li>
<li>
<p><code>maxValue</code>: The longest time of any single execution</p>
</li>
</ul>
</li>
<li>
<p>Sensor name: <code>ServerParse</code></p>
<pre>/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/ServerParse
</pre>
<p>Metrics:</p>
<ul>
<li>
<p><code>value</code>: The total time spent parsing the SQL statement in the server, in milliseconds, for all executions of this SQL statement</p>
</li>
<li>
<p><code>count</code>: The number of executions completed</p>
</li>
<li>
<p><code>minValue</code>: The shortest time of any single execution</p>
</li>
<li>
<p><code>maxValue</code>: The longest time of any single execution</p>
</li>
</ul>
</li>
<li>
<p>Sensor name: <code>Next</code></p>
<pre>/SQLJ/<span class="italic">application_name</span>/<span class="italic">module</span>/<span class="italic">class</span>/<span class="italic">linenum</span>/Next
</pre>
<p>Metrics:</p>
<ul>
<li>
<p><code>time</code>: The total time, in milliseconds, spent in the <code>next()</code> method of the result set iterator for all executions of this SQL statement</p>
</li>
<li>
<p><code>completed</code>: The number of executions completed (such as 5)</p>
</li>
<li>
<p><code>minTime</code>: The shortest time of any single execution</p>
</li>
<li>
<p><code>maxTime</code>: The longest time of any single execution</p>
</li>
<li>
<p><code>avg</code>: The average execution time, which is <code>time</code> divided by <code>count</code>.</p>
</li>
<li>
<p><code>active</code>: The number of threads executing the statement at the end of program execution, typically 0.</p>
</li>
<li>
<p><code>maxActive</code>: The maximum number of threads that executed the statement during program execution</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1007478"></a>
<div id="JSQLJ780" class="sect2">
<h3 class="sect2">SQLJ D<a id="sthref896"></a>MS Examples</h3>
<p>Following is a sample command line (a single wraparound line) to instrument the SQLJ program <code>ExprDemo.sqlj</code>:</p>
<pre>% sqlj -dir=. -instrument=a.b.c/app -components=all 
       -user=HR -url=jdbc:oracle:oci:@ ExprDemo.sqlj
Password: <span class="italic">password</span>
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Ensure that <code>dms.jar</code> is in your classpath.</div>
<p>This command results in generation of the following files:</p>
<ul>
<li>
<p><code>./a/b/c/ExprDemo.java</code> (due to the <code>-dir</code> option setting and because package <code>a.b.c</code> is declared in <code>ExprDemo.sqlj</code>)</p>
</li>
<li>
<p><code>./a/b/c/app.properties</code> (due to the <code>-instrument</code> option setting)</p>
</li>
</ul>
<p class="subhead2"><a id="JSQLJ781"></a>Sample SQLJ DMS Properties File</p>
<p>The following is sample content for <code>app.properties</code>. This assumes you edited the file after SQLJ created it, given that some of the settings here are nondefault.</p>
<pre>sqlmonitor.components=all
sqlmonitor.monitorcomp=all
sqlmonitor.dms=true
sqlmonitor.servertracing=true
sqlmonitor.sysurl=jdbc:oracle:oci:@
sqlmonitor.sysuser=HR
sqlmonitor.syspassword=hr
sqlmonitor.dumpfile=a/b/c/app.mtr
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you run the SQLJ translator again, then <code>app.properties</code> is overwritten and you will lose any changes you made.</div>
<p class="subhead2"><a id="JSQLJ782"></a>Sample Statistics</p>
<p>The <code>sqlmonitor.dms=true</code> setting specifies that monitoring statistics are to be delivered to DMS. Given the <code>sqlmonitor.dumpfile</code> value, the DMS tool writes the statistics to the <code>./a/b/c/app.mtr</code> file when you compile and run the program.</p>
<p>To examine statistics for a particular code sample, here is a segment of <code>ExprDemo.sqlj</code>:</p>
<pre>     #sql
     {
       DECLARE
         n NUMBER;
         s NUMBER;
       BEGIN
         n := 0;
         s := 0;
         WHILE n &lt; 100 LOOP
           n := n + 1;
           s := s + :IN (indx++);
         END LOOP;
         :OUT total := s;
       END;
     };
</pre>
<p>And here is a segment of statistics from <code>app.mtr</code>, relating to the preceding code example and showing the execution time and server execution times:</p>
<pre>       SQLString.value:      DECLARE         n NUMBER;        s NUMBER;
       BEGIN         n :=  0;         s := 0;       WHILE n &lt; 100 LOOP 
             n := n + 1;
             s := s +  :1 ;         
       END LOOP;          :2  := s;       END; statement SQL string
            ServerExecute.maxValue:       20.0 server_execute_time
            ServerExecute.minValue:       20.0 server_execute_time
            ServerExecute.count:  0 ops
            ServerExecute.value:  20.0 server execute time
            ServerFetch.maxValue: 0.0 server_fetch_time
            ServerFetch.minValue: 0.0 server_fetch_time
            ServerFetch.count:    0 ops
            ServerFetch.value:    0.0 server fetch time
            ServerParse.maxValue: 0.0 server_parse_time
            ServerParse.minValue: 0.0 server_parse_time
            ServerParse.count:    0 ops
            ServerParse.value:    0.0 server parse time
           193.5
            ContextType.value:    class sqlj.runtime.ref.DefaultContext
       statement connection context
            Execute.maxActive:    1 threads
            Execute.active:       0 threads
            Execute.avg:  37.0 msecs
            Execute.maxTime:      37 msecs
            Execute.minTime:      37 msecs
            Execute.completed:    1 ops
            Execute.time: 37 msecs
</pre>
<p>These statistics indicate that the total execution time at the JDBC client was 37 milliseconds (in one execution), while the execution time in the server was 20 milliseconds.</p>
<p class="subhead2"><a id="JSQLJ783"></a>Sample Statistics for Iterators</p>
<p><code>ExprDemo.sqlj</code> also defines and executes an iterator type, <code>Iter</code>, as follows:</p>
<pre>   #sql public static iterator Iter(String ename);

      ....

     Iter iter;
     #sql iter = { select first_name from employees};
     while (iter.next())
     {
      System.out.println(iter.ename());
     }
</pre>
<p>For iterators, DMS collects the execution time for the <code>next()</code> operation. Here is a sample DMS result for the iterator type <code>Iter</code>:</p>
<pre>         Iter
          Next.time:    5 msecs
</pre>
<p>This shows that the total time spent on the <code>next()</code> operation while iterating through the <code>Iter</code> instance was 5 milliseconds.</p>
<p class="subhead2"><a id="JSQLJ784"></a>Sample Statistics for Connection Contexts</p>
<p>The <code>#sql</code> statements in <code>ExprDemo.sqlj</code> use the default connection context. For the <code>DefaultContext</code> instance used throughout the program, DMS returns the following statistics:</p>
<pre>         class_sqlj.runtime.ref.DefaultContext
         StmtCacheSize.value:  5 statement cache size
         StmtsExecuted.count:  7 ops
         StmtsCacheExecuted.count:     7 ops
</pre>
<p>This shows that the context has a statement cache size of five statements. Altogether, seven SQL statements are executed.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4010">
<tr>
<td class="cellalignment4017">
<table class="cellalignment4015">
<tr>
<td class="cellalignment4014"><a href="transrun.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4014"><a href="inserver.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4019">
<table class="cellalignment4013">
<tr>
<td class="cellalignment4014"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4014"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4014"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4014"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4014"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4014"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>