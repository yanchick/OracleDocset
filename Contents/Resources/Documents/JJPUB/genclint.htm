<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-71096"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Generated%20Classes%20and%20Interfaces"></a><title>Generated Classes and Interfaces</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-07T6:1:46Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database JPublisher User&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49873-02"/>
<meta name="dcterms.isVersionOf" content="JJPUB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="adfeacon.htm" title="Previous" type="text/html"/>
<link rel="Next" href="optinfil.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49873-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">10/14</span> <!-- End Header -->
<div id="JJPUB24138" class="chapter"><a id="g1015570"></a> <a id="i1009571"></a>
<h1 class="chapter"><span class="secnum">5</span> Generated Classes and Interfaces</h1>
<p>This chapter describes the classes, interfaces, and subclasses that JPublisher generates in the following sections:</p>
<ul>
<li>
<p><a href="#i1009229">Treatment of Output Parameters</a></p>
</li>
<li>
<p><a href="#i1009182">Translation of Overloaded Methods</a></p>
</li>
<li>
<p><a href="#i1006415">Generation of SQLJ Classes</a></p>
</li>
<li>
<p><a href="#i1006600">Generation of Non-SQLJ Classes</a></p>
</li>
<li>
<p><a href="#i1009070">Generation of Java Interfaces</a></p>
</li>
<li>
<p><a href="#i1006644">JPublisher Subclasses</a></p>
</li>
<li>
<p><a href="#i1006786">Support for Inheritance</a></p>
</li>
</ul>
<a id="i1009229"></a>
<div id="JJPUB24139" class="sect1">
<h2 class="sect1"><a id="sthref155"></a><a id="sthref156"></a>Treatment of Output Parameters</h2>
<p>Stored procedures called through Java Database Connectivity (JDBC) do not pass parameters in the same way as ordinary Java methods. This affects the code that you write when you call a wrapper method that JPublisher generates.</p>
<p>When you call an ordinary Java method, parameters that are Java objects are passed as object references. The method can modify the object.</p>
<p>However, when you call a stored procedure through JDBC, a copy of each parameter is passed to the stored procedure. If the procedure modifies any parameters, then a copy of the modified parameter is returned to the caller. Therefore, the <span class="italic">before</span> and <span class="italic">after</span> values of a modified parameter appear in separate objects.</p>
<p>A wrapper method that JPublisher generates contains JDBC statements to call the corresponding stored procedure. The parameters to the stored procedure, as declared in your <code>CREATE TYPE</code> or <code>CREATE PACKAGE</code> declaration, have the following possible parameter modes: <code>IN</code>, <code>OUT</code>, and <code>IN OUT</code>. Parameters that are <code>IN OUT</code> or <code>OUT</code> are returned to the wrapper method in newly created objects. These new values must be returned to the caller somehow, but assignment to the formal parameter within the wrapper method does not affect the actual parameter visible to the caller.</p>
<p>In Ja<a id="sthref157"></a><a id="sthref158"></a>va, there are no <code>OUT</code> or <code>IN OUT</code> designations, but values can be returned through holders. In JPublisher, you can specify one of the following alternatives for holders that handle PL/SQL <code>OUT</code> or <code>IN OUT</code> parameters:</p>
<ul>
<li>
<p>Arrays</p>
</li>
<li>
<p>Java API for XML-based Remote Procedure Call (JAX-RPC) holder types</p>
</li>
<li>
<p>Function returns</p>
</li>
</ul>
<p>The <code>-outarguments</code> option enables you to specify which mechanism to use. This feature is particularly useful for Web services.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#i1016801">&#34;Holder Types for Output Arguments&#34;</a></div>
<p>The following sections describe the three mechanisms:</p>
<ul>
<li>
<p><a href="#i1009331">Passing Output Parameters in Arrays</a></p>
</li>
<li>
<p><a href="#i1009336">Passing Output Parameters in JAX-RPC Holders</a></p>
</li>
<li>
<p><a href="#i1009341">Passing Output Parameters in Function Returns</a></p>
</li>
</ul>
<a id="i1009331"></a>
<div id="JJPUB24140" class="sect2">
<h3 class="sect2">Pa<a id="sthref159"></a>ssing Output Parameters in Arrays</h3>
<p>One way to solve the problem of returning output values in Java is to pass an <code>OUT</code> or <code>IN OUT</code> parameter to the wrapper method in a single-element array. Think of the array as a container that holds the parameter. This mechanism works as follows:</p>
<ol>
<li>
<p>You assign the <span class="italic">before</span> value of the parameter to element <code>[0]</code> of an array.</p>
</li>
<li>
<p>You pass the array to your wrapper method.</p>
</li>
<li>
<p>The wrapper method assigns the <span class="italic">after</span> value of the parameter to element <code>[0]</code> of the array.</p>
</li>
<li>
<p>After running the method, you extract the <span class="italic">after</span> value from the array.</p>
</li>
</ol>
<p>A setting of <code>-outarguments=array</code>, which is the default, instructs JPublisher to use this single-element array mechanism to publish any <code>OUT</code> or <code>IN OUT</code> argument.</p>
<p>For example:</p>
<pre>Person [] pa = {p}; 
x.f(pa); 
p = pa[0]; 
</pre>
<p>Assume that <code>x</code> is an instance of a JPublisher-generated class that has the <code>f()</code> method, which is a wrapper method for a stored procedure that uses a SQL <code>PERSON</code> object as an <code>IN OUT</code> parameter. The <code>PERSON</code> type maps to the <code>Person</code> Java class. <code>p</code> is a <code>Person</code> instance, and <code>pa[]</code> is a single-element <code>Person</code> array.</p>
<p>This mechanism for passing <code>OUT</code> or <code>IN OUT</code> parameters requires you to add a few extra lines of code to your program for each parameter. As another example, consider the PL/SQL function created by the following SQL*Plus command:</p>
<pre>SQL&gt; CREATE OR REPLACE FUNCTION g (
            a0 NUMBER, 
            a1 OUT NUMBER, 
            a2 IN OUT NUMBER,
            a3 CLOB, 
            a4 OUT CLOB, 
            a5 IN OUT CLOB) 
     RETURN CLOB IS 
     BEGIN
            RETURN NULL;
     END;
</pre>
<p>With <code>-outarguments=array</code>, this is published as follows:</p>
<pre>public oracle.sql.CLOB g (
     java.math.BigDecimal a0,
     java.math.BigDecimal a1[],
     java.math.BigDecimal a2[],
     oracle.sql.CLOB a3,
     oracle.sql.CLOB a4[],
     oracle.sql.CLOB a5[])
</pre>
<p>Problems similar to those described earlier arise when the <code>this</code> object of an instance method is modified.</p>
<p>The <code>this</code> object is an additional parameter, which is passed in a different way. Its mode, as declared in the <code>CREATE TYPE</code> statement, may be <code>IN</code> or <code>IN OUT</code>. If you do not explicitly declare the mode of the <code>this</code> object, then its mode is <code>IN OUT</code>, if the stored procedure does not return a result, or <code>IN</code>, if it does.</p>
<p>If the mode of the <code>this</code> object is <code>IN OUT</code>, then the wrapper method must return the new value of <code>this</code>. The code generated by JPublisher implements this functionality in different ways, depending on the situation, as follows:</p>
<ul>
<li>
<p>For a stored procedure that does not return a result, the new value of <code>this</code> is returned as the result of the wrapper method.</p>
<p>As an example, assume that the SQL object type <code>MYTYPE</code> has the following member procedure:</p>
<pre>MEMBER PROCEDURE f1(y IN OUT INTEGER);
</pre>
<p>Also, assume that JPublisher generates a corresponding Java class, <code>MyJavaType</code>. This class defines the following method:</p>
<pre>MyJavaType f1(int[] y)
</pre>
<p>The <code>f1()</code> method returns the modified <code>this</code> object value as a <code>MyJavaType</code> instance.</p>
</li>
<li>
<p>For a stored function, which is a stored procedure that returns a result, the wrapper method returns the result of the stored function as its result. The new value of <code>this</code> is returned in a single-element array, passed as an extra argument, which is the last argument, to the wrapper method.</p>
<p>Assume that the SQL object type <code>MYTYPE</code> has the following member function:</p>
<pre>MEMBER FUNCTION f2(x IN INTEGER) RETURNS VARCHAR2;
</pre>
<p>Then the corresponding Java class, <code>MyJavaType</code>, defines the following method:</p>
<pre>String f2(int x, MyJavaType[] newValue)
</pre>
<p>The <code>f2()</code> method returns the <code>VARCHAR2</code> value as a Java string and the modified <code>this</code> object value as an array element in the <code>MyJavaType</code> array.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For PL/SQL static procedures or functions, JPublisher generates instance methods, and not static methods, in the wrapper class. This is the logistic for associating a database connection with each wrapper class instance. The connection instance is used in initializing the wrapper class instance so that you are not subsequently required to explicitly provide a connection or connection context instance when calling wrapper methods.</div>
</div>
<!-- class="sect2" -->
<a id="i1009336"></a>
<div id="JJPUB24141" class="sect2">
<h3 class="sect2">Pas<a id="sthref160"></a><a id="sthref161"></a><a id="sthref162"></a>sing Output Parameters in JAX-RPC Holders</h3>
<p>The JAX-RPC specification explicitly specifies holder classes in the <code>javax.xml.rpc.holders</code> package for the Java mapping of simple XML data types and other types. Typically, <code>Holder</code> is appended to the type name for the holder class name. For example, <code>BigDecimalHolder</code> is the holder class for <code>BigDecimal</code>.</p>
<p>Given a setting of <code>-outarguments=holder</code>, JPublisher uses holder instances to publish <code>OUT</code> and <code>IN OUT</code> arguments from stored procedures. Holder settings are specified in a JPublisher style file. The settings are specified in the <code>HOLDER</code> subtag inside the <code>TARGETTYPE</code> section for appropriate mapping. If no holder class is specified, then JPublisher chooses one according to defaults.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="datamap.htm#i1010336">&#34;JPublisher Styles and Style Files&#34;</a></div>
<p>For general information about JAX-RPC and holders, refer to the <span class="italic">Java API for XML-based RPC, JAX-RPC 1.0</span> specification, available at:</p>
<p><code><a href="http://jcp.org/aboutJava/communityprocess/final/jsr101/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr101/index.html</a></code></p>
<p>As an example, consider the PL/SQL function created by the following SQL*Plus command:</p>
<pre>SQL&gt; CREATE OR REPLACE FUNCTION g (
            a0 NUMBER, 
            a1 OUT NUMBER, 
            a2 IN OUT NUMBER,
            a3 CLOB, 
            a4 OUT CLOB, 
            a5 IN OUT CLOB) 
     RETURN CLOB IS 
     BEGIN
            RETURN NULL;
     END;
</pre>
<p>Assume that the <code>webservices10</code> style file contains an entry for <code>-outarguments=holder</code> and the following JPublisher command is used to publish the function, <code>g()</code>:</p>
<pre>% jpub -u hr  -s toplevel&#34;(g)&#34;:ToplevelG -style=webservices10
Enter hr password: <span class="italic">password</span>
</pre>
<p>The published interface is:</p>
<pre>public java.lang.String g
              (java.math.BigDecimal a0,
               javax.xml.rpc.holders.BigDecimalHolder _xa1_out_x,
               javax.xml.rpc.holders.BigDecimalHolder _xa2_inout_x,
               java.lang.String a3,
               javax.xml.rpc.holders.StringHolder _xa4_out_x,
               javax.xml.rpc.holders.StringHolder _xa5_inout_x)
throws java.rmi.RemoteException;
</pre>
<p>In this case, there is an extra level of abstraction. Because <code>oracle.sql.CLOB</code> is not supported by Web services, it is mapped to <code>String</code>, the JAX-RPC holder class for which is <code>StringHolder</code>.</p>
</div>
<!-- class="sect2" -->
<a id="i1009341"></a>
<div id="JJPUB24142" class="sect2">
<h3 class="sect2">Pas<a id="sthref163"></a>sing Output Parameters in Function Returns</h3>
<p>You can use the <code>-outarguments=return</code> setting as a workaround for supporting method signatures in Web services that do not use JAX-RPC holder types or arrays. If there is no support for JAX-RPC holders, the <code>-outarguments=return</code> setting allows <code>OUT</code> or <code>IN OUT</code> data to be returned in function results.</p>
<p>Consider the PL/SQL function created by the following SQL*Plus command:</p>
<pre>SQL&gt; CREATE OR REPLACE FUNCTION g (
            a0 NUMBER, 
            a1 OUT NUMBER, 
            a2 IN OUT NUMBER,
            a3 CLOB, 
            a4 OUT CLOB, 
            a5 IN OUT CLOB) 
     RETURN CLOB IS 
     BEGIN
            RETURN NULL;
     END;
</pre>
<p>Assume the following JPublisher command to publish the function, <code>g()</code>. Although the <code>webservices10</code> style file specifies <code>-outarguments=holder</code>, the <code>-outarguments=return</code> setting comes after the <code>-style</code> setting and, therefore, takes precedence.</p>
<pre>% jpub -u hr  -s toplevel&#34;(g)&#34;:ToplevelG -style=webservices10 -outarguments=return
Enter hr password: <span class="italic">password</span>
</pre>
<p>The JPublisher output is as follows:</p>
<pre>HR.<span class="italic">top_level_scope</span>
ToplevelGUser_g_Out
</pre>
<p>The JPublisher output acknowledges that it is processing the <code>HR</code> top level and also indicates the creation of the <code>ToplevelGUser_g_Out</code> Java class to support output values of the <code>g()</code> function through return data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The <code>_g_Out</code> appended to the user class name is according to the JPublisher naming convention used when creating a class to contain the output data in the scenario of passing output parameters in function returns. The <code>_g</code> reflects the name of the function being processed and the <code>_Out</code> reflects the <code>OUT</code> modifier in the corresponding PL/SQL call specification. Therefore, <code>ToplevelGUser_g_Out</code> is the Java type created for the output data of the <code>g()</code> method in the <code>ToplevelGUser</code> class. The user class name is according to the naming convention specified in the <code>webservices10</code> style file.</p>
</li>
<li>
<p>Typically, JPublisher output reflects only the names of SQL or PL/SQL entities being processed, but there is no such entity that directly corresponds to <code>ToplevelGUser_g_Out</code>.</p>
</li>
</ul>
</div>
<p>JPublisher generates the following interface to take input parameters and return output parameters:</p>
<pre>public ToplevelGUser_g_Out g
            (java.math.BigDecimal a0,
             java.math.BigDecimal xxa2_inoutxx,
             java.lang.String a3,
             java.lang.String xxa5_inoutxx)
throws java.rmi.RemoteException;
</pre>
<p>JPublisher generates the <code>TopLevelGUser_g_Out</code> class as follows:</p>
<pre>public class ToplevelGUser_g_Out{
  public ToplevelGUser_g_Out() { }
  public java.math.BigDecimal getA1Out()  { return a1_out; }
  public void setA1Out(java.math.BigDecimal a1_out) { this.a1_out = a1_out; }
  public java.math.BigDecimal getA2Inout()   { return a2_inout; }
  public void setA2Inout(java.math.BigDecimal a2_inout) 
                          { this.a2_inout = a2_inout; }
  public java.lang.String getA4Out()   { return a4_out; }}
</pre>
<p>The <code>ToplevelGUser_g_Out</code> return type encapsulates the values of the <code>OUT</code> and <code>IN&nbsp;OUT</code> parameters to be passed back to the caller of the function. As in the preceding section, <code>oracle.sql.CLOB</code> is mapped to <code>String</code> by the <code>webservices10</code> style file.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009182"></a>
<div id="JJPUB24143" class="sect1">
<h2 class="sect1">Tra<a id="sthref164"></a><a id="sthref165"></a><a id="sthref166"></a>nslation of Overloaded Methods</h2>
<p>PL/SQL, like Java, lets you create overloaded methods, meaning two or more methods with the same name but different signatures. However, overloaded methods with different signatures in PL/SQL may have identical signatures in Java, especially in user subclasses. As an example, consider the following PL/SQL stored procedures:</p>
<pre>PROCEDURE foo(x CLOB);
PROCEDURE foo(x NCHAR);
</pre>
<p>If you process these with a JPublisher setting of <code>-style=webservices-common</code>, then they will all have the same signature in Java:</p>
<pre>void foo(String x);
void foo(String x);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="datamap.htm#i1009949">&#34;Style File Specifications and Locations&#34;</a></div>
<p>JPublisher solves such naming conflicts by appending the first letter of the return type and the first letter of each argument type, as applicable, to the method name. If conflicts still remain, then a number is also appended. JPublisher solves the preceding conflict as follows:</p>
<pre>void foo(String x);
void fooS(String x);
</pre>
<p>Note that PL/SQL does <span class="italic">not</span> allow overloading for types from the same family. The following, for example, is illegal:</p>
<pre>PROCEDURE foo(x DECIMAL);
PROCEDURE foo(x INT);
PROCEDURE foo(x INTEGER);
</pre>
<p>Now, consider the procedures as functions instead, with return types from the same family. The following example is allowed because the argument types are different:</p>
<pre>FUNCTION foo(x FLOAT) RETURN DECIMAL;
FUNCTION foo(x VARCHAR2) RETURN INT;
FUNCTION foo(x Student_T) RETURN INTEGER;
</pre>
<p>By default, these are mapped to Java methods as follows:</p>
<pre>java.math.BigDecimal foo(Float x);
java.math.BigDecimal foo(String x);
java.math.BigDecimal foo(StudentT x);
</pre>
<p>JPublisher allows them all to be named <code>foo()</code> because now the signatures differ. However, if you want all method names to be unique, as is required for Web services, use the <code>unique</code> setting of the JPublisher <code>-methods</code> option. With <code>-methods=unique</code>, JPublisher publishes the methods as follows, using the naming mechanism described earlier:</p>
<pre>java.math.BigDecimal foo(Float x);
java.math.BigDecimal fooBS(String x);
java.math.BigDecimal fooBS1(StudentT x);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#i1009664">&#34;Generation of Package Classes and Wrapper Methods&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="i1006415"></a>
<div id="JJPUB24144" class="sect1">
<h2 class="sect1">Gen<a id="sthref167"></a><a id="sthref168"></a>eration of SQLJ Classes</h2>
<p>For the <code>-methods=all</code> setting, which is the default, or the <code>-methods=true</code> setting, JPublisher typically generates SQLJ classes for PL/SQL packages and object types, using both <code>ORAData</code> and <code>SQLData</code> implementations. An exception is that a SQLJ class is not generated if an object type does not define any methods, in which case the generated Java class does not require the SQLJ run time.</p>
<p>SQLJ classes include wrapper methods that invoke the server methods, or stored procedures, of object types and packages. This section describes how to use these classes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="intro.htm#BHCCICEJ">&#34;JPublisher Usage of the SQLJ Implementation&#34;</a> and <a href="optinfil.htm#i1010532">&#34;Backward Compatibility Option&#34;</a></div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1006420">Important Notes About Generation of SQLJ Classes</a></p>
</li>
<li>
<p><a href="#i1006438">Use of SQLJ Classes for PL/SQL Packages</a></p>
</li>
<li>
<p><a href="#i1008534">Use of SQLJ Classes for Object Types</a></p>
</li>
<li>
<p><a href="#i1006511">Connection Contexts and Instances in SQLJ Classes</a></p>
</li>
<li>
<p><a href="#i1006769">The setFrom(), setValueFrom(), and setContextFrom() Methods</a></p>
</li>
</ul>
<a id="i1006420"></a>
<div id="JJPUB24145" class="sect2">
<h3 class="sect2">Important Notes About Generation of SQLJ Classes</h3>
<p>Note the following for JPublisher-generated SQLJ classes:</p>
<ul>
<li>
<p>If you are generating Java wrapper classes for a SQL type hierarchy and any of the types contains stored procedures, then by default, JPublisher generates SQLJ classes for all the SQL types and not just the types that have stored procedures.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You have the option of explicitly suppressing the generation of SQLJ classes through the JPublisher <code>-methods=false</code> setting. This results in all non-SQLJ classes.</div>
</li>
<li>
<p>Classes produced by JPublisher include a <code>rel<a id="sthref169"></a><a id="sthref170"></a>ease()</code> method. If an instance of a JPublisher-generated wrapper class implicitly constructs a <code>DefaultContext</code> instance, then you should use the <code>release()</code> method to release this connection context instance when it is no longer needed. However, you can avoid this scenario by adhering to at least one of the following suggestions in creating and using the wrapper class instance:</p>
<ul>
<li>
<p>Construct the wrapper class instance with an explicitly provided SQLJ connection context.</p>
</li>
<li>
<p>Associate the wrapper class instance explicitly with a SQLJ connection context instance through the <code>setConnectionContext()</code> method.</p>
</li>
<li>
<p>Use the static SQLJ default connection context instance implicitly for the wrapper class instance. This occurs if you do not supply any connection information.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006511">&#34;Connection Contexts and Instances in SQLJ Classes&#34;</a></div>
</li>
<li>
<p>In Oracle8<span class="italic">i</span> compatibility mode, instead of the constructor taking a <code>DefaultContext</code> instance or an instance of a user-specified class, there is a constructor that simply takes a <code>ConnectionContext</code> instance. This could be an instance of any class that implements the standard <code>sqlj.runtime.ConnectionContext</code> interface, including the <code>DefaultContext</code> class.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006438"></a>
<div id="JJPUB24146" class="sect2">
<h3 class="sect2">Use of SQLJ Clas<a id="sthref171"></a>ses for PL/SQL Packages</h3>
<p>Take the following steps to use a class that JPublisher generates for a PL/SQL package:</p>
<ol>
<li>
<p>Construct an instance of the class.</p>
</li>
<li>
<p>Call the wrapper methods of the class.</p>
</li>
</ol>
<p>The constructors for the class associate a database connection with an instance of the class. One constructor takes a SQLJ <code>DefaultContext</code> instance or an instance of a class specified through the <code>-context</code> option when you run JPublisher. Another constructor takes a JDBC <code>Connection</code> instance. One constructor has no arguments. Calling the no-argument constructor is equivalent to passing the SQLJ default context to the constructor that takes a <code>DefaultContext</code> instance. JPublisher provides the constructor that takes a <code>Connection</code> instance for the convenience of JDBC programmers unfamiliar with SQLJ concepts, such as connection contexts and the default context.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006420">&#34;Important Notes About Generation of SQLJ Classes&#34;</a></div>
<p>The wrapper methods are all instance methods, because the connection context in the <code>this</code> object is used in the wrapper methods.</p>
<p>Because a class generated for a PL/SQL package has no instance data other than the connection context, you typically construct one class instance for each connection context that you use. If the default context is the only one you use, then you can call the no-argument constructor once.</p>
<p>An instance of a class generated for a PL/SQL package does not contain copies of the PL/SQL package variables. It is not an <code>ORAData</code> class or a <code>SQLData</code> class, and you cannot use it as a host variable.</p>
</div>
<!-- class="sect2" -->
<a id="i1008534"></a>
<div id="JJPUB24147" class="sect2">
<h3 class="sect2">Use of SQLJ Classes <a id="sthref172"></a>for Object Types</h3>
<p>To use an instance of a Java class that JPublisher generates for a SQL object type or a SQL <code>OPAQUE</code> type, you must first initialize the Java object. You can accomplish this in one of the following ways:</p>
<ul>
<li>
<p>Assign an already initialized Java object to your Java object.</p>
</li>
</ul>
<ul>
<li>
<p>Retrieve a copy of a SQL object into your Java object. You can do this by using the SQL object as an <code>OUT</code> argument or as the function return of a JPublisher-generated wrapper method. You can also do this by retrieving the SQL object through JDBC calls that you write. If you are in a backward-compatibility mode and use SQLJ source files directly, then you can retrieve a copy of a SQL object through the SQLJ <code>#sql</code> statements.</p>
</li>
</ul>
<ul>
<li>
<p>Construct the Java object with the no-argument constructor and set its attributes by using the <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> methods, or construct the Java object with the constructor that accepts values for all the object attributes. Subsequently, you must use the <code>setConnection()</code> or <code>setConnectionContext()</code> method to associate the object with a database connection before calling any of its wrapper methods. If you do not explicitly associate the object with a JDBC or SQLJ connection before calling a method on it, then it becomes implicitly associated with the SQLJ default context.</p>
<p>Other constructors for the class associate a connection with the class instance. One constructor takes a <code>DefaultContext</code> instance or an instance of a class specified through the <code>-context</code> option when you run JPublisher, and one constructor takes a <code>Connection</code> instance. The constructor that takes a <code>Connection</code> instance is provided for the convenience of JDBC programmers unfamiliar with SQLJ concepts, such as connection contexts and the default context.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006420">&#34;Important Notes About Generation of SQLJ Classes&#34;</a></div>
<p>Once you have initialized your Java object, you can do the following:</p>
<ul>
<li>
<p>Call the accessor methods of the object.</p>
</li>
<li>
<p>Call the wrapper methods of the object.</p>
</li>
<li>
<p>Pass the object to other wrapper methods.</p>
</li>
<li>
<p>Use the object as a host variable in JDBC calls. If you are in a backward-compatibility mode and use SQLJ source files directly, then you can use the object as a host variable in the SQLJ <code>#sql</code> statements.</p>
</li>
</ul>
<p>There is a Java attribute for each attribute of the corresponding SQL object type, with the <code>get</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> accessor methods for each attribute. JPublisher does not generate fields for the attributes. For example, for an attribute called <code>foo</code>, there is a corresponding Java attribute called <code>foo</code> and the accessor methods, <code>getFoo()</code> and <code>setFoo()</code>.</p>
<p>By default, the class includes wrapper methods that call the associated Oracle object methods, which reside and run on the server. Irrespective of what the server methods are, the wrapper methods are all instance methods. The <code>DefaultContext</code> in the <code>this</code> object is used in the wrapper methods.</p>
<p>With Oracle mapping, JPublisher generates the following methods for Oracle JDBC driver to use:</p>
<ul>
<li>
<p><code>create()</code></p>
</li>
<li>
<p><code>toDatum()</code></p>
</li>
</ul>
<p>These methods are specified in the <code>ORAData</code> and <code>ORADataFactory</code> interfaces and are generally not intended for your direct use. In addition, JPublisher generates the <code>setFrom(</code><code><span class="codeinlineitalic">otherObject</span></code><code>)</code>, <code>setValueFrom(</code><code><span class="codeinlineitalic">otherObject</span></code><code>)</code>, and <code>setContextFrom(</code><code><span class="codeinlineitalic">otherObject</span></code><code>)</code> methods that you can use to copy values or connection information from one object instance to another.</p>
</div>
<!-- class="sect2" -->
<a id="i1006511"></a>
<div id="JJPUB24148" class="sect2">
<h3 class="sect2">Connection Co<a id="sthref173"></a><a id="sthref174"></a>ntexts and Instances in SQLJ Classes</h3>
<p>The class that JPublisher uses in creating SQLJ connection context instances depends on how you set the <code>-context</code> option when you run JPublisher. The following classes can be used:</p>
<ul>
<li>
<p>A setting of <code>-context=DefaultContext</code>, which is the default setting, results in JPublisher using instances of the standard <code>sqlj.runtime.ref.DefaultContext</code> class.</p>
</li>
<li>
<p>A setting of a user-defined class that is in <code>CLASSPATH</code> and implements the standard <code>sqlj.runtime.ConnectionContext</code> interface results in JPublisher using instances of that class.</p>
</li>
<li>
<p>A setting of <code>-context=generated</code> results in the declaration of the static <code>_Ctx</code> connection context class in the JPublisher-generated class. JPublisher uses instances of this class for connection context instances. This is appropriate for Oracle8<span class="italic">i</span> compatibility mode, but generally not recommended.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#CIHEAGEA">&#34;SQLJ Connection Context Classes&#34;</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is no longer a routine, as it was in Oracle8<span class="italic">i</span> Database, for JPublisher to declare a <code>_ctx</code> connection context instance. However, this is used in Oracle8<span class="italic">i</span> compatibility mode, with <code>_ctx</code> being declared as a <code>protected</code> instance of the static <code>_Ctx</code> connection context class.
<p>Unless you have legacy code that depends on <code>_ctx</code>, it is preferable to use the <code>getConnectionContext()</code> and <code>setConnectionContext()</code> methods to retrieve and manipulate connection context instances in JPublisher-generated classes.</p>
</div>
<p>Consider the following points in using SQLJ connection context instances or JDBC connection instances in instances of JPublisher-generated wrapper classes:</p>
<ul>
<li>
<p>Wrapper classes generated by JPublisher provide a <code>setConnectionContext()</code> method that you can use to explicitly specify a SQLJ connection context instance. The method is defined as follows:</p>
<pre>void setCo<a id="sthref175"></a>nnectionContext(<span class="italic">conn_ctxt_instance</span>);
</pre>
<p>This installs the passed connection context instance as the SQLJ connection context in the wrapper class instance. The connection context instance must be an instance of the class specified through the <code>-context</code> setting for JPublisher connection contexts, typically <code>DefaultContext</code>.</p>
<p>Note that the underlying JDBC connection must be compatible with the connection used to materialize the database object in the first place. Specifically, some objects may have attributes that are valid only for a particular connection, such as object reference types or BLOBs.</p>
<p>If you have already specified a connection context instance through the constructor, then you need not set it again using the <code>setConnectionContext()</code> method.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Using the <code>setConnectionContext()</code> method to explicitly set a connection context instance avoids the problem of the connection context not being closed properly. This problem occurs only with implicitly created connection context instances.</div>
<ul>
<li>
<p>Use either of the following methods of a wrapper class instance, as appropriate, to retrieve a connection or connection context instance:</p>
<ul>
<li>
<p><code>Connection get<a id="sthref176"></a>Connection()</code></p>
</li>
<li>
<p><code><span class="codeinlineitalic">ConnCtxtType</span></code> <code>getConnec<a id="sthref177"></a>tionContext()</code></p>
</li>
</ul>
<p>The <code>getConnectionContext()</code> method returns an instance of the connection context class specified through the JPublisher <code>-context</code> setting, typically <code>DefaultContext</code>.</p>
<p>The returned connection context instance may be either an explicitly set instance or one that was created implicitly by JPublisher.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
These methods are available only in the generated SQLJ classes. If necessary, you can use the setting <code>-methods=always</code> to ensure that SQLJ classes are produced.</div>
<ul>
<li>
<p>If no connection context instance is explicitly set for a JPublisher-generated SQLJ class, then one will be created implicitly from the JDBC connection instance when the <code>getConnectionContext()</code> method is called.</p>
<p>In this circumstance, at the end of processing, you must use the <code>release()</code> method to free resources in the SQLJ run time. This prevents a possible memory leak.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006769"></a>
<div id="JJPUB24149" class="sect2">
<h3 class="sect2">The setFrom(), setValu<a id="sthref178"></a><a id="sthref179"></a><a id="sthref180"></a>eFrom(), and setContextFrom() Methods</h3>
<p>JPublisher provides the following utility methods in the generated SQLJ classes:</p>
<ul>
<li>
<p><code>setFrom(</code><code><span class="codeinlineitalic">anotherObject</span></code><code>)</code></p>
<p>This method initializes the calling object from another object of the same base type, including connection and connection context information. An existing, implicitly created connection context object on the calling object is freed.</p>
</li>
<li>
<p><code>setValueFrom(</code><code><span class="codeinlineitalic">anotherObject</span></code><code>)</code></p>
<p>This method initializes the underlying field values of the calling object from another object of the same base type. This method does not transfer connection or connection context information.</p>
</li>
<li>
<p><code>setContextFrom(</code><code><span class="codeinlineitalic">anotherObject</span></code><code>)</code></p>
<p>This method initializes the connection and connection context information about the calling object from the connection setting of another object of the same base type. An existing, implicitly created, connection context object on the calling object is freed. This method does not transfer any information related to the object value.</p>
</li>
</ul>
<p>Note that there is semantic equivalence between the <code>setFrom()</code> method and the combination of the <code>setValueFrom()</code> and <code>setContextFrom()</code> methods.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006600"></a>
<div id="JJPUB24150" class="sect1">
<h2 class="sect1">Gene<a id="sthref181"></a>ration of No<a id="sthref182"></a>n-SQLJ Classes</h2>
<p>For a <code>-methods=false</code> setting, or when SQL object types do not define any methods, JPublisher does not generate wrapper methods for object types. In this case, the generated class does not require the SQLJ run time during execution. Therefore, JPublisher generates non-SQLJ classes, meaning classes that do not call the SQLJ run time application programming interfaces (APIs). All this is true regardless of whether you use an <code>ORAData</code> implementation or an <code>SQLData</code> implementation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>For the <code>-methods=false</code> setting, JPublisher does not generate code for PL/SQL packages, because they are not useful without wrapper methods.</p>
</li>
<li>
<p>JPublisher generates the same Java code for reference, <code>VARRAY</code>, and nested table types regardless of whether the <code>-methods</code> option is set to <code>false</code> or <code>true</code>.</p>
</li>
</ul>
</div>
<p>To use an instance of a class that JPublisher generates for an object type with the <code>-methods=false</code> setting or for a reference, <code>VARRAY</code>, or nested table type, you must first initialize the object.</p>
<p>You can initialize your object in one of the following ways:</p>
<ul>
<li>
<p>Assign an already initialized Java object to your Java object.</p>
</li>
<li>
<p>Retrieve a copy of a SQL object into your Java object. You can do this by using the SQL object as an <code>OUT</code> argument or as the function return accessed through a JPublisher-generated wrapper method in some other class. You can also do this by retrieving the SQL object through JDBC calls that you write. If you are in a backward-compatibility mode and using SQLJ source files directly, then you can retrieve a copy of a SQL object through the SQLJ <code>#sql</code> statements.</p>
</li>
<li>
<p>Construct the Java object with a no-argument constructor and initialize its data, or construct the Java object based on its attribute values.</p>
</li>
</ul>
<p>Unlike the constructors generated in SQLJ classes, the constructors generated in non-SQLJ classes do not take a connection argument. Instead, when your object is passed to or returned from a JDBC <code>Statement</code>, <code>CallableStatement</code>, or <code>PreparedStatement</code> object, JPublisher applies the connection it uses to construct the <code>Statement</code>, <code>CallableStatement</code>, or <code>PreparedStatement</code> object.</p>
<p>This does not mean you can use the same object with different connections at different times, which is not always possible. An object may have a subcomponent that is valid only for a particular connection, such as a reference or a <code>BLOB</code>.</p>
<p>To initialize the object data, use the <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> methods, if your class represents an object type, or the <code>setArray()</code> or <code>setElement()</code> method, if your class represents a <code>VARRAY</code> or nested table type. If your class represents a reference type, then you can construct only a null reference. All non-null references come from the database.</p>
<p>Once you have initialized your object, you can do the following:</p>
<ul>
<li>
<p>Pass the object to wrapper methods in other classes.</p>
</li>
<li>
<p>Use the object as a host variable in JDBC calls. If you are in a backward-compatibility mode and use SQLJ source files directly, then you can use the object in the SQLJ <code>#sql</code> statements.</p>
</li>
<li>
<p>Call the methods that read and write the state of the object. These methods operate on the Java object in your program and do not affect data in the database. You can read and write the state of the object in the following ways:</p>
<ul>
<li>
<p>For a class that represents an object type, call the <code>get</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> accessor methods.</p>
</li>
<li>
<p>For a class that represents a <code>VARRAY</code> or nested table, call the <code>getArray()</code>, <code>setArray()</code>, <code>getElement()</code>, and <code>setElement()</code> methods.</p>
<p>The <code>getArray()</code> and <code>setArray()</code> methods return or modify an array as a whole. The <code>getElement()</code> and <code>setElement()</code> methods return or modify individual elements of the array.</p>
<p>If you want to update the data in the database, then you must re-insert the Java array into the database.</p>
</li>
</ul>
</li>
<li>
<p>You cannot modify an object reference, because it is an immutable entity. However, you can read and write the SQL object that it references by using the <code>getValue()</code> and <code>setValue()</code> methods.</p>
<p>The <code>getValue()</code> method returns a copy of the SQL object that is being referenced by the object reference. The <code>setValue()</code> method updates a SQL object type instance in the database by taking an instance of the Java class that represents the object type as input. Unlike the <code>get</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> accessor methods of a class generated for an object type, the <code>getValue()</code> and <code>setValue()</code> methods read and write SQL objects.</p>
<p>Note that both <code>getValue()</code> and <code>setValue()</code> result in a database round trip to read or write the value of the underlying database object that the reference points to.</p>
</li>
</ul>
<p>You can use the <code>getORADataFactory()</code> method in the JDBC code to return an <code>ORADataFactory</code> object. You can pass this <code>ORADataFactory</code> object to the <code>getORAData()</code> method in the <code>ArrayDataResultSet</code>, <code>OracleCallableStatement</code>, and <code>OracleResultSet</code> classes in the <code>oracle.jdbc</code> package. Oracle JDBC driver uses the <code>ORADataFactory</code> object to create instances of your JPublisher-generated class.</p>
<p>In addition, classes representing <code>VARRAY</code> and nested table types have methods that implement features of the <code><a id="sthref183"></a>oracle.sql.ARRAY</code> class. These methods are:</p>
<ul>
<li>
<p><code>getBaseTypeName()</code></p>
</li>
<li>
<p><code>getBaseType()</code></p>
</li>
<li>
<p><code>getDescriptor()</code></p>
</li>
</ul>
<p>However, JPublisher-generated classes for <code>VARRAY</code> and nested table types do not extend the <code>oracle.sql.ARRAY</code> class.</p>
<p>With Oracle mapping, JPublisher generates the following methods for Oracle JDBC driver to use:</p>
<ul>
<li>
<p><code>create()</code></p>
</li>
<li>
<p><code>toDatum()</code></p>
</li>
</ul>
<p>These methods are specified in the <code>ORAData</code> and <code>ORADataFactory</code> interfaces and are not generally intended for direct use. However, you may want to use them if converting from one object reference Java wrapper type to another.</p>
</div>
<!-- class="sect1" -->
<a id="i1009070"></a>
<div id="JJPUB24151" class="sect1">
<h2 class="sect1">Gen<a id="sthref184"></a><a id="sthref185"></a>eration of Java Interfaces</h2>
<p>JPublisher has the ability to generate interfaces as well as classes. This feature is especially useful for Web services, because it eliminates the necessity to manually create Java interfaces that represent the API from which WSDL content is generated.</p>
<p>The <code>-sql</code> option supports the following syntax:</p>
<pre>-sql=<span class="italic">sql_package_or_type</span>:<span class="italic">JavaClass</span>#<span class="italic">JavaInterface</span>
</pre>
<p>or:</p>
<pre>-sql=<span class="italic">sql_package_or_type</span>:<span class="italic">JavaClass</span>:<span class="italic">JavaUserSubclass</span>#<span class="italic">JavaSubInterface</span>
</pre>
<p>Whenever an interface name is specified in conjunction with a class, then the public attributes or wrapper methods or both of that class are provided in the interface, and the generated class implements the interface.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="usejpub.htm#i1007505">&#34;Publishing User-Defined SQL Types&#34;</a> and <a href="usejpub.htm#i1007510">&#34;Publishing PL/SQL Packages&#34;</a></div>
<p>You can specify an interface for either the generated class or the user subclass, but not both. The difference between an interface for a generated base class and one for a user subclass involves Java-to-Java type transformations. Method signatures in the subclass may be different from signatures in the base class because of Java-to-Java mappings.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="datamap.htm#i1010336">&#34;JPublisher Styles and Style Files&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="i1006644"></a>
<div id="JJPUB24152" class="sect1">
<h2 class="sect1">JPublisher Subclas<a id="sthref186"></a>ses</h2>
<p>In translating a SQL user-defined type, you may want to enhance the functionality of the custom Java class generated by JPublisher.</p>
<p>One way to accomplish this is to manually add methods to the class generated by JPublisher. However, this is not advisable if you anticipate running JPublisher in the future to regenerate the class. If you regenerate a class that you have modified in this way, then your changes, such as the methods you have added, will be overwritten. Even if you direct JPublisher output to a separate file, you still must merge your changes into the file.</p>
<p>The preferred way to enhance the functionality of a generated class is to extend the class. JPublisher has a mechanism for this, where it will generate the original base class along with a stub subclass, which you can customize as desired. Wherever the SQL type is referenced in code, such as when it is used as an argument, the SQL type will be mapped to the subclass rather than to the base class.</p>
<p>There is also a scenario for JPublisher-generated subclasses for Java-to-Java type transformations. You may have situations in which JPublisher mappings from SQL types to Java types use Java types unsuitable for your purposes; for example, types unsupported by Web services. JPublisher uses a mechanism of styles and style files to allow an additional Java-to-Java transformation step, to use a Java type that is suitable.</p>
<p>The following topics are covered in this section:</p>
<ul>
<li>
<p><a href="#i1006652">Extending JPublisher-Generated Classes</a></p>
</li>
</ul>
<a id="i1006652"></a>
<div id="JJPUB24153" class="sect2">
<h3 class="sect2">Extendi<a id="sthref187"></a><a id="sthref188"></a>ng JPublisher-Generated Classes</h3>
<p>Suppose you want JPublisher to generate the <code>JAddress</code> class from the <code>ADDRESS</code> SQL object type. You also want to write a class, <code>MyAddress</code>, to represent <code>ADDRESS</code> objects, where <code>MyAddress</code> extends the functionality that <code>JAddress</code> provides.</p>
<p>Under this scenario, you can use JPublisher to generate both a base Java class, <code>JAddress</code>, and an initial version of a subclass, <code>MyAddress</code>, to which you can add the desired functionality. You then use JPublisher to map <code>ADDRESS</code> objects to the <code>MyAddress</code> class instead of the <code>JAddress</code> class.</p>
<p>To do this, JPublisher alters the code it generates in the following ways:</p>
<ul>
<li>
<p>It generates the <code>MyAddressRef</code> reference class instead of <code>JAddressRef</code>.</p>
</li>
<li>
<p>It uses the <code>MyAddress</code> class, instead of the <code>JAddress</code> class, to represent attributes with the SQL type <code>ADDRESS</code> or to represent <code>VARRAY</code> and nested table elements with the SQL type <code>ADDRESS</code>.</p>
</li>
<li>
<p>It uses the <code>MyAddress</code> factory, instead of the <code>JAddress</code> factory, when the <code>ORADataFactory</code> interface is used to construct Java objects with the SQL type <code>ADDRESS</code>.</p>
</li>
<li>
<p>It generates or regenerates the code for the <code>JAddress</code> class. In addition, it generates an initial version of the code for the <code>MyAddress</code> class, which you can then modify to insert your own additional functionality. However, if the source file for the <code>MyAddress</code> class already exists, then it is left untouched by JPublisher.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adfeacon.htm#CHDGBIEF">&#34;Changes in JPublisher Behavior Between Oracle8<span class="italic">i</span> Database and Oracle9<span class="italic">i</span> Database&#34;</a></div>
<div id="JJPUB24154" class="sect3"><a id="sthref189"></a>
<h4 class="sect3">Syntax for Map<a id="sthref190"></a>ping to Alternative Classes</h4>
<p>JPublisher has the functionality to streamline the process of mapping to alternative classes. Use the following syntax in your <code>-sql</code> command-line option setting:</p>
<pre>-sql=<span class="italic">object_type</span>:<span class="italic">generated_base_class</span>:<span class="italic">map_class</span>
</pre>
<p>For the <code>MyAddress</code>/<code>JAddress</code> example, it is:</p>
<pre>-sql=ADDRESS:JAddress:MyAddress
</pre>
<p>If you were to enter the line in the <code>INPUT</code> file instead of on the command line, it would look like this:</p>
<pre>SQL ADDRESS GENERATE JAddress AS MyAddress
</pre>
<p>In this syntax, <code>JAddress</code> is the name of the base class that JPublisher generates, in <code>JAddress.java</code>, but <code>MyAddress</code> is the name of the class that actually maps to <code>ADDRESS</code>. You are ultimately responsible for the code in <code>MyAddress.java</code>. Update this as necessary to add your custom functionality. If you retrieve an object that has an <code>ADDRESS</code> attribute, then this attribute is created as an instance of <code>MyAddress</code>. Or, if you retrieve an <code>ADDRESS</code> object directly, then it is retrieved into an instance of <code>MyAddress</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#i1009889">&#34;Declaration of Object Types and Packages to Translate&#34;</a> and <a href="optinfil.htm#i1007010">&#34;INPUT File Structure and Syntax&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="i1006695"></a>
<div id="JJPUB24155" class="sect3">
<h4 class="sect3">For<a id="sthref191"></a>mat of the Class that Extends the Generated Class</h4>
<p>For convenience, an initial version of the user subclass is automatically generated by JPublisher, unless it already exists. This subclass is where you place your custom code. For example, the <code>MyAddress.java</code> file generated by JPublisher in the preceding example.</p>
<p>Note the following:</p>
<ul>
<li>
<p>The class has a no-argument constructor. The easiest way to construct a properly initialized object is to invoke the constructor of the superclass, either explicitly or implicitly.</p>
</li>
<li>
<p>The class implements the <code>ORAData</code> interface or the <code>SQLData</code> interface. This happens implicitly by inheriting the necessary methods from the superclass.</p>
</li>
<li>
<p>When extending an <code>ORAData</code> class, the subclass also implements the <code>ORADataFactory</code> interface, with an implementation of the <code>create()</code> method, as shown:</p>
<pre>public ORAData create(Datum d, int sqlType) throws SQLException
{
   return create(new UserClass(),d,sqlType);
}
</pre>
<p>However, when the class is part of an inheritance hierarchy, the generated method changes to <code>protected ORAData createExact()</code>, with the same signature and body as <code>create()</code>.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006786"></a>
<div id="JJPUB24157" class="sect1">
<h2 class="sect1">Support for Inh<a id="sthref192"></a><a id="sthref193"></a>eritance</h2>
<p>This section describes the inheritance support for the <code>ORAData</code> types and explains the following related topics:</p>
<ul>
<li>
<p>How JPublisher implements support for inheritance</p>
</li>
<li>
<p>Why a reference class for a subtype does not extend the reference class for the base type, and how you can convert from one reference type to another reference type, typically a subclass or superclass</p>
</li>
</ul>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1006793">ORAData Object Types and Inheritance</a></p>
</li>
<li>
<p><a href="#CIHCFEDH">ORAData Reference Types and Inheritance</a></p>
</li>
<li>
<p><a href="#CIHGDEFG">SQLData Object Types and Inheritance</a></p>
</li>
<li>
<p><a href="#CIHHIAJB">Effects of Using SQL FINAL, NOT FINAL, NOT INSTANTIABLE</a></p>
</li>
</ul>
<a id="i1006793"></a>
<div id="JJPUB24158" class="sect2">
<h3 class="sect2">ORAD<a id="sthref194"></a><a id="sthref195"></a>ata Object Types and Inheritance</h3>
<p>Consider the following SQL object types:</p>
<pre>CREATE TYPE PERSON AS OBJECT (
...
) NOT FINAL;

CREATE TYPE STUDENT UNDER PERSON (
...
);

CREATE TYPE INSTRUCTOR UNDER PERSON (
...
);
</pre>
<p>Consider the following JPublisher command to create corresponding Java classes:</p>
<pre>% jpub -user=hr -sql=PERSON:Person,STUDENT:Student,INSTRUCTOR:Instructor -usertypes=oracle
Enter hr password: <span class="italic">password</span>
</pre>
<p>In this example, JPublisher generates a <code>Person</code> class, a <code>Student</code> class, and an <code>Instructor</code> class. The <code>Student</code> and <code>Instructor</code> classes extend the <code>Person</code> class, because <code>STUDENT</code> and <code>INSTRUCTOR</code> are subtypes of <code>PERSON</code>.</p>
<p>The class at the root of the inheritance hierarchy, <code>Person</code> in this example, contains full information for the entire inheritance hierarchy and automatically initializes its type map with the required information. As long as you use JPublisher to generate all the required classes of a class hierarchy together, no additional action is required. The type map of the class hierarchy is appropriately populated.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CIHDECDF">Precautions when Combining Partially Generated Type Hierarchies</a></p>
</li>
<li>
<p><a href="#CIHBCFEC">Mapping of Type Hierarchies in JPublisher-Generated Code</a></p>
</li>
</ul>
<a id="CIHDECDF"></a>
<div id="JJPUB24159" class="sect3">
<h4 class="sect3">Precautions when Combining Partially Generated Type Hierarchies</h4>
<p>If you run JPublisher several times on a SQL type hierarchy, each time generating only part of the corresponding Java wrapper classes, then you must take precautions in the user application to ensure that the type map at the root of the class hierarchy is properly initialized.</p>
<p>In our previous example, you may have run the following JPublisher commands:</p>
<pre>% jpub -user=hr -sql=PERSON:Person,STUDENT:Student -usertypes=oracle
Enter hr password: <span class="italic">password</span>
% jpub -user=hr -sql=PERSON:Person,INSTRUCTOR:Instructor -usertypes=oracle
Enter hr password: <span class="italic">password</span>
</pre>
<p>In this case, you should create instances of the generated classes, at least of the leaf classes, before using these mapped types in your code. For example:</p>
<pre>new Instructor(); // required
new Student();    // required
new Person();     // optional
</pre></div>
<!-- class="sect3" -->
<a id="CIHBCFEC"></a>
<div id="JJPUB24160" class="sect3">
<h4 class="sect3">Mapping of Type Hierarchies in JPublisher-Generated Code</h4>
<p>The <code>Person</code> class includes the following method:</p>
<pre>Person create(oracle.sql.Datum d, int sqlType)
</pre>
<p>This method converts a <code>Datum</code> instance to its representation as a custom Java object. It is called by Oracle JDBC driver whenever a SQL object declared to be a <code>PERSON</code> is retrieved into a <code>Person</code> variable. The SQL object, however, may actually be a <code>STUDENT</code> object. In this case, the <code>create()</code> method must create a <code>Student</code> instance rather than a <code>Person</code> instance.</p>
<p>To handle this kind of situation, the <code>create()</code> method of a custom Java class must be able to create instances of any subclass that represents a subtype of the SQL object type corresponding to the <code>oracle.sql.Datum</code> argument. This ensures that the actual type of the created Java object matches the actual type of the SQL object. The custom Java class may or may not be created by JPublisher.</p>
<p>However, the code for the <code>create()</code> method in the root class of a custom Java class hierarchy need not mention the subclasses. In fact, if it <span class="italic">did</span> mention the subclasses, then you would have to modify the code for the base class whenever you write or create a new subclass. The base class is modified automatically if you use JPublisher to regenerate the entire class hierarchy. But regenerating the hierarchy may not always be possible. For example, you may not have access to the source code for the Java classes being extended.</p>
<p>Instead, code generated by JPublisher permits incremental extension of a class hierarchy by creating a static initialization block in each subclass of the custom Java class hierarchy. This static initialization block initializes a data structure declared in the root-level Java class, giving the root class the information it needs about the subclass. When an instance of a subclass is created at run time, the type is registered in the data structure. Because of this implicit mapping mechanism, no explicit type map, such as those required in the <code>SQLData</code> scenarios, is required.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This implementation makes it possible to extend existing classes without having to modify them, but it also carries a penalty. The static initialization blocks of the subclasses must be processed before the class hierarchy can be used to read objects from the database. This occurs if you instantiate an object of each subclass by calling <code>new()</code>. It is sufficient to instantiate just the leaf classes, because the constructor for a subclass invokes the constructor for its immediate superclass.
<p>As an alternative, you can generate or regenerate the entire class hierarchy, if it is feasible.</p>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHCFEDH"></a>
<div id="JJPUB24161" class="sect2">
<h3 class="sect2">ORAD<a id="sthref196"></a><a id="sthref197"></a>ata Reference Types and Inheritance</h3>
<p>This section shows how to convert from one custom reference class to another and also explains why a custom reference class generated by JPublisher for a subtype does not extend the reference classes of the base type.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CIHCCFBB">Casting a Reference Type Instance into Another Reference Type</a></p>
</li>
<li>
<p><a href="#CIHDEIBH">Why Reference Type Inheritance Does Not Follow Object Type Inheritance</a></p>
</li>
<li>
<p><a href="#i1006885">Manually Converting Between Reference Types</a></p>
</li>
<li>
<p><a href="#i1006912">Example: Manually Converting Between Reference Types</a></p>
</li>
</ul>
<a id="CIHCCFBB"></a>
<div id="JJPUB24162" class="sect3">
<h4 class="sect3">Casting a Reference Type Instance into Another Reference Type</h4>
<p>Revisiting the example in <a href="#i1006793">&#34;ORAData Object Types and Inheritance&#34;</a>, <code>PersonRef</code>, <code>StudentRef</code>, and <code>InstructorRef</code> are obtained for strongly typed references, in addition to the underlying object type wrapper classes.</p>
<p>There may be situations in which you have a <code>StudentRef</code> instance, but you want to use it in a context that requires a <code>PersonRef</code> instance. In this case, use the static method, <code>cast()</code>, generated in strongly typed reference classes:</p>
<pre>StudentRef s_ref = ...;  
PersonRef p_ref = PersonRef.cast(s_ref);
</pre>
<p>Conversely, you may have a <code>PersonRef</code> instance and know that you can narrow it to an <code>InstructorRef</code> instance:</p>
<pre>PersonRef pr = ...; 
InstructorRef ir = InstructorRef.cast(pr);
</pre></div>
<!-- class="sect3" -->
<a id="CIHDEIBH"></a>
<div id="JJPUB24163" class="sect3">
<h4 class="sect3">Why Reference Type Inheritance Does Not Follow Object Type Inheritance</h4>
<p>The example here helps explain why it is not desirable for reference types to follow the hierarchy of their related object types. Consider again a subset of the example given in the previous section (repeated here for convenience):</p>
<pre>CREATE TYPE PERSON AS OBJECT (
...
) NOT FINAL;

CREATE TYPE STUDENT UNDER PERSON (
...
);
</pre>
<p>And consider the following JPublisher command:</p>
<pre>% jpub -user=hr -sql=PERSON:Person,STUDENT:Student -usertypes=oracle
Enter hr password: <span class="italic">password</span>
</pre>
<p>In addition to generating the <code>Person</code> and <code>Student</code> Java types, JPublisher generates <code>PersonRef</code> and <code>StudentRef</code> types.</p>
<p>Because the <code>Student</code> class extends the <code>Person</code> class, you may expect <code>StudentRef</code> to extend <code>PersonRef</code>. However, this is not the case, because the <code>StudentRef</code> class can provide more compile-time type safety as an independent class than as a subtype of <code>PersonRef</code>. Additionally, a <code>PersonRef</code> object can perform something that a <code>StudentRef</code> object cannot, such as modifying a <code>Person</code> object in the database.</p>
<p>The most important methods of the <code>PersonRef</code> class are the following:</p>
<ul>
<li>
<p><code>Person getValue()</code></p>
</li>
<li>
<p><code>void setValue(Person c)</code></p>
</li>
</ul>
<p>The corresponding methods of the <code>StudentRef</code> class are as follows:</p>
<ul>
<li>
<p><code>Student getValue()</code></p>
</li>
<li>
<p><code>void setValue(Student c)</code></p>
</li>
</ul>
<p>If the <code>StudentRef</code> class extended the <code>PersonRef</code> class, then the following problems would occur:</p>
<ul>
<li>
<p>Java would not permit the <code>getValue()</code> method in <code>StudentRef</code> to return a <code>Student</code> object when the method it overrides in the <code>PersonRef</code> class returns a <code>Person</code> object, even though this is arguably a sensible thing to do.</p>
</li>
<li>
<p>The <code>setValue()</code> method in <code>StudentRef</code> would not override the <code>setValue()</code> method in <code>PersonRef</code>, because the two methods have different signatures.</p>
</li>
</ul>
<p>You cannot remedy these problems by giving the <code>StudentRef</code> methods the same signatures and result types as the <code>PersonRef</code> methods, because the additional type safety provided by declaring an object as a <code>StudentRef</code>, rather than as a <code>PersonRef</code>, would be lost.</p>
</div>
<!-- class="sect3" -->
<a id="i1006885"></a>
<div id="JJPUB24164" class="sect3">
<h4 class="sect3">Manually Converting Between Reference Types</h4>
<p>You cannot convert one reference type to another directly, because reference types do not follow the hierarchy of their related object types. This is a limitation of JPublisher. For background information, this section explains how the generated <code>cast()</code> methods work to convert from one reference type to another.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is <span class="italic">not</span> recommended that you follow these manual steps. They are presented here for illustration only. You can use the <code>cast()</code> method instead.</div>
<p>The following example outlines the code that could be used to convert from the <code>XxxxRef</code> reference type to the <code>YyyyRef</code> reference type:</p>
<pre>java.sql.Connection conn = ...;  // get underlying JDBC connection
XxxxRef xref = ...;
YyyyRef yref = (YyyyRef) YyyyRef.getORADataFactory().
                create(xref.toDatum(conn),oracle.jdbc.OracleTypes.REF);
</pre>
<p>This conversion consists of two steps, each of which can be useful in its own right.</p>
<ol>
<li>
<p>Convert <code>xref</code> from its strong <code>XxxxRef</code> type to the weak <code>oracle.sql.REF</code> type:</p>
<pre>oracle.sql.REF ref  = (oracle.sql.REF) xref.toDatum(conn);
</pre></li>
<li>
<p>Convert from the <code>oracle.sql.REF</code> type to the target <code>YyyyRef</code> type:</p>
<pre>YyyyRef yref = (YyyyRef) YyyyRef.getORADataFactory().
                          create(ref,oracle.jdbc.OracleTypes.REF);
</pre></li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
This conversion does not include any type-checking. Whether this conversion is actually permitted depends on your application and on the SQL schema you are using.</div>
</div>
<!-- class="sect3" -->
<a id="i1006912"></a>
<div id="JJPUB24165" class="sect3">
<h4 class="sect3">Example: Manually Converting Between Reference Types</h4>
<p>The following example, including the SQL definitions and Java code, illustrates the points of the preceding discussion.</p>
<p><a id="JJPUB24166"></a><span class="subhead3">SQL Definitions&nbsp;</span>Consider the following SQL definitions:</p>
<pre>CREATE TYPE person_t AS OBJECT (ssn NUMBER, name VARCHAR2(30), dob DATE) NOT FINAL;
/
SHOW ERRORS

CREATE TYPE instructor_t UNDER person_t (title VARCHAR2(20)) NOT FINAL;
/
SHOW ERRORS

CREATE TYPE instructorPartTime_t UNDER instructor_t (num_hours NUMBER);
/
SHOW ERRORS

CREATE TYPE student_t UNDER person_t (deptid NUMBER, major VARCHAR2(30)) NOT FINAL;
/
SHOW ERRORS

CREATE TYPE graduate_t UNDER student_t (advisor instructor_t);
/
SHOW ERRORS

CREATE TYPE studentPartTime_t UNDER student_t (num_hours NUMBER);
/
SHOW ERRORS

CREATE TABLE person_tab OF person_t;

INSERT INTO person_tab VALUES (1001, &#39;Larry&#39;, TO_DATE(&#39;11-SEP-60&#39;));

INSERT INTO person_tab VALUES (instructor_t(1101, &#39;Smith&#39;, TO_DATE(&#39;09-OCT-1940&#39;), &#39;Professor&#39;));

INSERT INTO person_tab VALUES (instructorPartTime_t(1111, &#39;Myers&#39;, TO_DATE(&#39;10-OCT-65&#39;), &#39;Adjunct Professor&#39;, 20));

INSERT INTO person_tab VALUES (student_t(1201, &#39;John&#39;, To_DATE(&#39;01-OCT-78&#39;), 11, &#39;EE&#39;));

INSERT INTO person_tab VALUES (graduate_t(1211, &#39;Lisa&#39;, TO_DATE(&#39;10-OCT-75&#39;), 12, &#39;ICS&#39;, 
instructor_t(1101, &#39;Smith&#39;, TO_DATE (&#39;09-OCT-40&#39;), &#39;Professor&#39;)));

INSERT INTO person_tab VALUES (studentPartTime_t(1221, &#39;Dave&#39;, TO_DATE(&#39;11-OCT-70&#39;), 13, &#39;MATH&#39;, 20));
</pre>
<p><a id="JJPUB24167"></a><span class="subhead3">JPublisher Mappings&nbsp;</span>Assume the following mappings when you run JPublisher:</p>
<pre>Person_t:Person,instructor_t:Instructor,instructorPartTime_t:InstructorPartTime,
graduate_t:Graduate,studentPartTime_t:StudentPartTime
</pre>
<p><a id="JJPUB24168"></a><span class="subhead3">SQLJ Class&nbsp;</span>Here is a SQLJ class with an example of reference type conversion:</p>
<pre>import java.sql.*; 
import oracle.jdbc.*; 
import oracle.sql.*; 

public class Inheritance 
{ 
  public static void main(String[] args) throws SQLException 
  { 
    System.out.println(&#34;Connecting.&#34;); 
    java.sql.DriverManager.registerDriver(new oracle.jdbc.OracleDriver()); 
    oracle.jdbc.OracleConnection conn = 
              (oracle.jdbc.OracleConnection) java.sql.DriverManager.getConnection
              (&#34;jdbc:oracle:oci8:@&#34;, &#34;hr&#34;, &#34;hr&#34;);
    // The following is only required in 9.0.1 
    // or if the Java class hierarchy was created piecemeal 
    System.out.println(&#34;Initializing type system.&#34;); 
    new Person(); 
    new Instructor(); 
    new InstructorPartTime(); 
    new StudentT(); 
    new StudentPartTime(); 
    new Graduate(); 
    PersonRef p_ref; 
    InstructorRef i_ref; 
    InstructorPartTimeRef ipt_ref; 
    StudentTRef s_ref; 
    StudentPartTimeRef spt_ref; 
    GraduateRef g_ref; 
    OraclePreparedStatement stmt =
                (OraclePreparedStatement)conn.prepareStatement
                (&#34;select ref(p) FROM PERSON_TAB p WHERE p.NAME=:1&#34;); 
    OracleResultSet rs; 

    System.out.println(&#34;Selecting a person.&#34;); 
    stmt.setString(1, &#34;Larry&#34;); 
    rs = (OracleResultSet) stmt.executeQuery(); 
    rs.next(); 
    p_ref = (PersonRef) rs.getORAData(1, PersonRef.getORADataFactory()); 
    rs.close(); 

    System.out.println(&#34;Selecting an instructor.&#34;); 
    stmt.setString(1, &#34;Smith&#34;); 
    rs = (OracleResultSet) stmt.executeQuery(); 
    rs.next(); 
    i_ref = (InstructorRef) rs.getORAData(1, InstructorRef.getORADataFactory()); 
    rs.close(); 

    System.out.println(&#34;Selecting a part time instructor.&#34;); 
    stmt.setString(1, &#34;Myers&#34;); 
    rs = (OracleResultSet) stmt.executeQuery(); 
    rs.next(); 
    ipt_ref = (InstructorPartTimeRef) rs.getORAData
              (1, InstructorPartTimeRef.getORADataFactory()); 
    rs.close(); 

    System.out.println(&#34;Selecting a student.&#34;); 
    stmt.setString(1, &#34;John&#34;); 
    rs = (OracleResultSet) stmt.executeQuery(); 
    rs.next(); 
    s_ref = (StudentTRef) rs.getORAData(1, StudentTRef.getORADataFactory()); 
    rs.close(); 

    System.out.println(&#34;Selecting a part time student.&#34;); 
    stmt.setString(1, &#34;Dave&#34;); 
    rs = (OracleResultSet) stmt.executeQuery(); 
    rs.next(); 
    spt_ref = (StudentPartTimeRef) rs.getORAData
              (1, StudentPartTimeRef.getORADataFactory()); 
    rs.close(); 

    System.out.println(&#34;Selecting a graduate student.&#34;); 
    stmt.setString(1, &#34;Lisa&#34;); 
    rs = (OracleResultSet) stmt.executeQuery(); 
    rs.next(); 
    g_ref = (GraduateRef) rs.getORAData(1, GraduateRef.getORADataFactory()); 
    rs.close(); 
    stmt.close(); 

    // Assigning a part-time instructor ref to a person ref 
    System.out.println(&#34;Assigning a part-time instructor ref to a person ref&#34;); 
    oracle.sql.Datum ref = ipt_ref.toDatum(conn); 
    PersonRef pref = (PersonRef) PersonRef.getORADataFactory(). 
                                           create(ref,OracleTypes.REF); 
    // or just use: PersonRef pref = PersonRef.cast(ipt_ref); 
    // Assigning a person ref to an instructor ref 
    System.out.println(&#34;Assigning a person ref to an instructor ref&#34;); 
    InstructorRef iref = (InstructorRef) InstructorRef.getORADataFactory(). 
                                     create(pref.toDatum(conn), OracleTypes.REF); 
    // or just use: InstructorRef iref = InstructorRef.cast(pref); 
    // Assigning a graduate ref to an part time instructor ref. 
    // This should produce an error, demonstrating that refs 
    // are type safe. 
    System.out.println (&#34;Assigning a graduate ref to a part time instructor ref&#34;); 
    InstructorPartTimeRef iptref = 
                (InstructorPartTimeRef) InstructorPartTimeRef.getORADataFactory(). 
                create(g_ref.toDatum(conn), OracleTypes.REF); 
    // or just use: InstructorPartTimeRef iptref = 
    // InstructorPartTimeRef.cast(g_ref); 
    conn.close(); 
  } 
} 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHGDEFG"></a>
<div id="JJPUB24169" class="sect2">
<h3 class="sect2">SQLData Obj<a id="sthref198"></a>ect Types and Inheritance</h3>
<p>If you use the JPublisher <code>-usertypes=jdbc</code> setting instead of <code>-usertypes=oracle</code>, then the custom Java class generated by JPublisher implements the standard <code>SQLData</code> interface instead of the Oracle <code>ORAData</code> interface. The standard <code>SQLData</code> methods, <code>readSQL()</code> and <code>writeSQL()</code>, provide functionality equivalent to the <code>ORAData</code>/<code>ORADataFactory</code> methods, <code>create()</code> and <code>toDatum()</code>, for reading and writing data.</p>
<p>When JPublisher generates <code>SQLData</code> classes corresponding to a SQL hierarchy, the Java types follow the same hierarchy as the SQL types. This is similar to the case when JPublisher generates <code>ORAData</code> classes corresponding to a hierarchy of SQL object types. However, <code>SQLData</code> implementations do not offer the implicit mapping intelligence that JPublisher automatically generates in <code>ORAData</code> classes.</p>
<p>In a <code>SQLData</code> scenario, you must manually provide a type map to ensure correct mapping between SQL object types and Java types. In a JDBC application, you can properly initialize the default type map for your connection or you can explicitly provide a type map as a <code>getObject()</code> input parameter.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
<p>In addition, note that there is no support for strongly typed object references in an <code>SQLData</code> implementation. All object references are weakly typed <code>java.sql.Ref</code> instances.</p>
</div>
<!-- class="sect2" -->
<a id="CIHHIAJB"></a>
<div id="JJPUB24170" class="sect2">
<h3 class="sect2">Effects of Using SQL FINAL, NOT FINAL, NOT INSTANTIABLE</h3>
<p>This section discusses the effect of using the SQL modifiers <code>FINAL</code>, <code>NOT FINAL</code>, or <code>NOT INSTANTIABLE</code> on JPublisher-generated wrapper classes.</p>
<p>Using the SQL modifier <code>FINAL</code> or <code>NOT FINAL</code> on a SQL type or on a method of a SQL type has no effect on the generated Java wrapper code. This ensures that, in all cases, JPublisher users are able to customize generated Java wrapper classes by extending the classes and overriding the generated behavior.</p>
<p>Using the <code>NOT INSTANTIABLE</code> SQL modifier on a method of a SQL type results in no code being generated for that method in the Java wrapper class. Therefore, to call such a method, you must cast to some wrapper class that corresponds to an instantiable SQL subtype.</p>
<p>Using <code>NOT INSTANTIABLE</code> on a SQL type results in the corresponding wrapper class being generated with <code>protected</code> constructors. This will remind you that instances of that class can be created only through subclasses that correspond to the instantiable SQL types.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5684">
<tr>
<td class="cellalignment5693">
<table class="cellalignment5689">
<tr>
<td class="cellalignment5688"><a href="adfeacon.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5688"><a href="optinfil.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5696">
<table class="cellalignment5687">
<tr>
<td class="cellalignment5688"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5688"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5688"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5688"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5688"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5688"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>