<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-71095"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Data%20Type%20and%20Java-to-Java%20Type%20Mappings"></a><title>Data Type and Java-to-Java Type Mappings</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-07T6:1:45Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database JPublisher User&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49873-02"/>
<meta name="dcterms.isVersionOf" content="JJPUB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="usejpub.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adfeacon.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49873-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/14</span> <!-- End Header -->
<div id="JJPUB24087" class="chapter"><a id="g1018224"></a> <a id="i1009188"></a>
<h1 class="chapter"><span class="secnum">3</span> Data Type and Java-to-Java Type Mappings</h1>
<p>This chapter discusses the JPublisher support for data type mapping, including a section on JPublisher styles and style files for Java-to-Java type mappings. These style files are primarily used to provide Web services support. The chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#i1005585">JPublisher Data Type Mappings</a></p>
</li>
<li>
<p><a href="#i1005880">Support for PL/SQL Data Types</a></p>
</li>
<li>
<p><a href="#i1010336">JPublisher Styles and Style Files</a></p>
</li>
</ul>
<a id="i1005585"></a>
<div id="JJPUB24088" class="sect1">
<h2 class="sect1">JPublisher Data Type Mappings</h2>
<p>This section covers the JPublisher functionality for mapping from SQL and PL/SQL to Java in the following topics:</p>
<ul>
<li>
<p><a href="#CHDCAECG">Overview of JPublisher Data Type Mappings</a></p>
</li>
<li>
<p><a href="#CHDBJAGH">SQL and PL/SQL Mappings to Oracle and JDBC Types</a></p>
</li>
<li>
<p><a href="#i1011295">JPublisher User Type Map and Default Type Map</a></p>
</li>
<li>
<p><a href="#CHDDEACA">JPublisher Logical Progression for Data Type Mappings</a></p>
</li>
<li>
<p><a href="#CHDGIEEI">Object Attribute Types</a></p>
</li>
<li>
<p><a href="#CHDIGIHC">REF CURSOR Types and Result Sets Mapping</a></p>
</li>
<li>
<p><a href="#CHDIAEDF">Connection in JDBC Mapping</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005880">&#34;Support for PL/SQL Data Types&#34;</a></div>
<a id="CHDCAECG"></a>
<div id="JJPUB24089" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Ove<a id="sthref96"></a>rview of JPublisher Data Type Mappings</h3>
<p>When you use the <code>-builtintypes</code>, <code>-lobtypes</code>, <code>-numbertypes</code>, and <code>-usertypes</code> type mapping options, you can specify one of the following settings for data type mappings:</p>
<ul>
<li>
<p><code>oracle</code></p>
</li>
<li>
<p><code>jdbc</code></p>
</li>
<li>
<p><code>objectjdbc</code></p>
</li>
<li>
<p><code>bigdecimal</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>objectjdbc</code> and <code>bigdecimal</code> settings are for the <code>-numbertypes</code> options only.</div>
<p>These mappings affect the argument and result types that JPublisher uses in the methods it generates.</p>
<p>The class that JPublisher generates for an object type has the <code>get</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> accessor methods for the object attributes. The class that JPublisher generates for a <code>VARRAY</code> or nested table type has the <code>get</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> methods, which access the elements of the array or nested table. When generation of wrapper methods is enabled, the class that JPublisher generates for an object type or PL/SQL package has wrapper methods. These wrapper methods invoke server methods, or stored procedures, of the object type or package. The mapping options control the argument and result types that these methods use.</p>
<p>The Java Database Connectivity (JDBC) and Object JDBC mappings use familiar Java types that can be manipulated using standard Java operations. The Oracle mapping is the most efficient mapping. The <code>oracle.sql</code> types match Oracle internal data types as closely as possible so that little or no data conversion is required between the Java and SQL formats. You do not lose any information and have greater flexibility in how you process and unpack the data. If you are manipulating data or moving data within the database, then Oracle mappings for standard SQL types are the most convenient representations. For example, performing <code>SELECT</code> and <code>INSERT</code> operations from one existing table to another. When data format conversion is necessary, you can use methods in the <code>oracle.sql.*</code> classes to convert to Java native types.</p>
</div>
<!-- class="sect2" -->
<a id="CHDBJAGH"></a>
<div id="JJPUB24090" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQL and PL/SQL Map<a id="sthref97"></a>pings to Oracle and JDBC Types</h3>
<p><a href="#CHDFJDIC">Table 3-1</a> lists the mappings from SQL and PL/SQL data types to Java types. You can use all the supported data types listed in this table as argument or result types for PL/SQL methods. You can also use a subset of the data types as object attribute types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDGIEEI">&#34;Object Attribute Types&#34;</a></div>
<p>The SQL and PL/SQL Data Type column contains all possible data types.</p>
<p>Ora<a id="sthref98"></a>cle Mapping column lists the corresponding Java types that JPublisher uses when all the type mapping options are set to <code>oracle</code>. These types are found in the <code>oracle.sql</code> package provided by Oracle and are designed to minimize the overhead incurred when converting Oracle data types to Java types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a> for more information about the <code>oracle.sql</code> package</div>
<p>The JDBC Map<a id="sthref99"></a>ping column lists the corresponding Java types that JPublisher uses when all the type mapping options are set to <code>jdbc</code>. For standard SQL data types, JPublisher uses Java types specified in the JDBC specification. For SQL data types that are Oracle extensions, JPublisher uses the <code>oracle.sql.*</code> types. When you set the <code>-numbertypes</code> option to <code>objectjdbc</code>, the corresponding types are the same as in the JDBC Mapping column, except that primitive Java types, such as <code>int</code>, are replaced with their object counterparts, such as <code>java.lang.Integer</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Type correspondences explicitly defined in the JPublisher type map, such as PL/SQL <code>BOOLEAN</code> to SQL <code>NUMBER</code> to Java <code>boolean</code>, are not affected by the mapping option settings.</div>
<p>A few data types are not directly supported by JPublisher, in particular those types that pertain only to PL/SQL. You can overcome these limitations by providing equivalent SQL and Java types, as well as PL/SQL conversion functions between PL/SQL and SQL representations. The annotations and subsequent sections explain these conversions further.</p>
<div id="JJPUB24091" class="tblformalwide">
<p class="titleintable"><a id="sthref100"></a><a id="CHDFJDIC"></a>Table 3-1 SQL and PL/SQL Data Type to Oracle and JDBC Mapping Classes</p>
<table class="cellalignment5691" title="SQL and PL/SQL Data Type to Oracle and JDBC Mapping Classes " summary="This table lists the Oracle mapping type and the JDBC mapping type for each SQL and PL/SQL datatype." dir="ltr">
<thead>
<tr class="cellalignment5685">
<th class="cellalignment5692" id="r1c1-t7">SQL and PL/SQL Data Type</th>
<th class="cellalignment5692" id="r1c2-t7">Oracle Mapping</th>
<th class="cellalignment5692" id="r1c3-t7">JDBC Mapping</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r2c1-t7" headers="r1c1-t7">
<p><code>CHAR</code>, <code>CHARACTER</code>, <code>LONG</code>, <code>STRING</code>, <code>VARCHAR</code>, <code>VARCHAR2</code></p>
</td>
<td class="cellalignment5693" headers="r2c1-t7 r1c2-t7">
<p><code>oracle.sql.CHAR</code></p>
</td>
<td class="cellalignment5693" headers="r2c1-t7 r1c3-t7">
<p><code>java.lang.String</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r3c1-t7" headers="r1c1-t7">
<p><code>NCHAR</code>, <code>NVARCHAR2</code></p>
</td>
<td class="cellalignment5693" headers="r3c1-t7 r1c2-t7">
<p><code>oracle.sql.NCHAR</code> (note 1)</p>
</td>
<td class="cellalignment5693" headers="r3c1-t7 r1c3-t7">
<p><code>oracle.sql.NString</code> (note 1)</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r4c1-t7" headers="r1c1-t7">
<p><code>NCLOB</code></p>
</td>
<td class="cellalignment5693" headers="r4c1-t7 r1c2-t7">
<p><code>oracle.sql.NCLOB</code> (note 1)</p>
</td>
<td class="cellalignment5693" headers="r4c1-t7 r1c3-t7">
<p><code>oracle.sql.NCLOB</code> (note 1)</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r5c1-t7" headers="r1c1-t7">
<p><code>RAW</code>, <code>LONG RAW</code></p>
</td>
<td class="cellalignment5693" headers="r5c1-t7 r1c2-t7">
<p><code>oracle.sql.RAW</code></p>
</td>
<td class="cellalignment5693" headers="r5c1-t7 r1c3-t7">
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r6c1-t7" headers="r1c1-t7">
<p><code>BINARY_INTEGER</code>, <code>NATURAL</code>, <code>NATURALN</code>, <code>PLS_INTEGER</code>, <code>POSITIVE</code>, <code>POSITIVEN</code>, <code>SIGNTYPE</code>, <code>INT</code>, <code>INTEGER</code></p>
</td>
<td class="cellalignment5693" headers="r6c1-t7 r1c2-t7">
<p><code>oracle.sql.NUMBER</code></p>
</td>
<td class="cellalignment5693" headers="r6c1-t7 r1c3-t7">
<p><code>int</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r7c1-t7" headers="r1c1-t7">
<p><code>DEC</code>, <code>DECIMAL</code>, <code>NUMBER</code>, <code>NUMERIC</code></p>
</td>
<td class="cellalignment5693" headers="r7c1-t7 r1c2-t7">
<p><code>oracle.sql.NUMBER</code></p>
</td>
<td class="cellalignment5693" headers="r7c1-t7 r1c3-t7">
<p><code>java.math.BigDecimal</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r8c1-t7" headers="r1c1-t7">
<p><code>DOUBLE PRECISION</code>, <code>FLOAT</code></p>
</td>
<td class="cellalignment5693" headers="r8c1-t7 r1c2-t7">
<p><code>oracle.sql.NUMBER</code></p>
</td>
<td class="cellalignment5693" headers="r8c1-t7 r1c3-t7">
<p><code>double</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r9c1-t7" headers="r1c1-t7">
<p><code>SMALLINT</code></p>
</td>
<td class="cellalignment5693" headers="r9c1-t7 r1c2-t7">
<p><code>oracle.sql.NUMBER</code></p>
</td>
<td class="cellalignment5693" headers="r9c1-t7 r1c3-t7">
<p><code>int</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r10c1-t7" headers="r1c1-t7">
<p><code>REAL</code></p>
</td>
<td class="cellalignment5693" headers="r10c1-t7 r1c2-t7">
<p><code>oracle.sql.NUMBER</code></p>
</td>
<td class="cellalignment5693" headers="r10c1-t7 r1c3-t7">
<p><code>float</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r11c1-t7" headers="r1c1-t7">
<p><code>DATE</code></p>
</td>
<td class="cellalignment5693" headers="r11c1-t7 r1c2-t7">
<p><code>oracle.sql.DATE</code></p>
</td>
<td class="cellalignment5693" headers="r11c1-t7 r1c3-t7">
<p><code>java.sql.Timestamp</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r12c1-t7" headers="r1c1-t7">
<p><code>TIMESTAMP</code></p>
<p><code>TIMESTAMP WITH TZ</code></p>
<p><code>TIMESTAMP WITH LOCAL TZ</code></p>
</td>
<td class="cellalignment5693" headers="r12c1-t7 r1c2-t7">
<p><code>oracle.sql.TIMESTAMP</code></p>
<p><code>oracle.sql.TIMESTAMPTZ</code></p>
<p><code>oracle.sql.TIMESTAMPLTZ</code></p>
</td>
<td class="cellalignment5693" headers="r12c1-t7 r1c3-t7">
<p><code>java.sql.Timestamp</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r13c1-t7" headers="r1c1-t7">
<p><code>INTERVAL YEAR TO MONTH</code></p>
<p><code>INTERVAL DAY TO SECOND</code></p>
</td>
<td class="cellalignment5693" headers="r13c1-t7 r1c2-t7">
<p><code>String</code> (note 2)</p>
</td>
<td class="cellalignment5693" headers="r13c1-t7 r1c3-t7">
<p><code>String</code> (note 2)</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r14c1-t7" headers="r1c1-t7">
<p><code>ROWID</code>, <code>UROWID</code></p>
</td>
<td class="cellalignment5693" headers="r14c1-t7 r1c2-t7">
<p><code>oracle.sql.ROWID</code></p>
</td>
<td class="cellalignment5693" headers="r14c1-t7 r1c3-t7">
<p><code>oracle.sql.ROWID</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r15c1-t7" headers="r1c1-t7">
<p><code>BOOLEAN</code></p>
</td>
<td class="cellalignment5693" headers="r15c1-t7 r1c2-t7">
<p><code>boolean</code> (note 3)</p>
</td>
<td class="cellalignment5693" headers="r15c1-t7 r1c3-t7">
<p><code>boolean</code> (note 3)</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r16c1-t7" headers="r1c1-t7">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment5693" headers="r16c1-t7 r1c2-t7">
<p><code>oracle.sql.CLOB</code></p>
</td>
<td class="cellalignment5693" headers="r16c1-t7 r1c3-t7">
<p><code>java.sql.Clob</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r17c1-t7" headers="r1c1-t7">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment5693" headers="r17c1-t7 r1c2-t7">
<p><code>oracle.sql.BLOB</code></p>
</td>
<td class="cellalignment5693" headers="r17c1-t7 r1c3-t7">
<p><code>java.sql.Blob</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r18c1-t7" headers="r1c1-t7">
<p><code>BFILE</code></p>
</td>
<td class="cellalignment5693" headers="r18c1-t7 r1c2-t7">
<p><code>oracle.sql.BFILE</code></p>
</td>
<td class="cellalignment5693" headers="r18c1-t7 r1c3-t7">
<p><code>oracle.sql.BFILE</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r19c1-t7" headers="r1c1-t7">
<p>Object types</p>
</td>
<td class="cellalignment5693" headers="r19c1-t7 r1c2-t7">
<p>Generated class</p>
</td>
<td class="cellalignment5693" headers="r19c1-t7 r1c3-t7">
<p>Generated class</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r20c1-t7" headers="r1c1-t7">
<p>SQLJ object types</p>
</td>
<td class="cellalignment5693" headers="r20c1-t7 r1c2-t7">
<p>Java class defined at type creation</p>
</td>
<td class="cellalignment5693" headers="r20c1-t7 r1c3-t7">
<p>Java class defined at type creation</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r21c1-t7" headers="r1c1-t7">
<p><code>OPAQUE</code> types</p>
</td>
<td class="cellalignment5693" headers="r21c1-t7 r1c2-t7">
<p>Generated or predefined class (note 4)</p>
</td>
<td class="cellalignment5693" headers="r21c1-t7 r1c3-t7">
<p>Generated or predefined class (note&nbsp;4)</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r22c1-t7" headers="r1c1-t7">
<p><code>RECORD</code> types</p>
</td>
<td class="cellalignment5693" headers="r22c1-t7 r1c2-t7">
<p>Through mapping to SQL object type (note 5)</p>
</td>
<td class="cellalignment5693" headers="r22c1-t7 r1c3-t7">
<p>Through mapping to SQL object type (note 5)</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r23c1-t7" headers="r1c1-t7">
<p>Nested table, <code>VARRAY</code></p>
</td>
<td class="cellalignment5693" headers="r23c1-t7 r1c2-t7">
<p>Generated class implemented using <code>oracle.sql.ARRAY</code></p>
</td>
<td class="cellalignment5693" headers="r23c1-t7 r1c3-t7">
<p><code>java.sql.Array</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r24c1-t7" headers="r1c1-t7">
<p>Reference to object type</p>
</td>
<td class="cellalignment5693" headers="r24c1-t7 r1c2-t7">
<p>Generated class implemented using <code>oracle.sql.REF</code></p>
</td>
<td class="cellalignment5693" headers="r24c1-t7 r1c3-t7">
<p><code>java.sql.Ref</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r25c1-t7" headers="r1c1-t7">
<p><code>REF CURSOR</code></p>
</td>
<td class="cellalignment5693" headers="r25c1-t7 r1c2-t7">
<p><code>java.sql.ResultSet</code></p>
</td>
<td class="cellalignment5693" headers="r25c1-t7 r1c3-t7">
<p><code>java.sql.ResultSet</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r26c1-t7" headers="r1c1-t7">
<p>Index-by tables</p>
</td>
<td class="cellalignment5693" headers="r26c1-t7 r1c2-t7">
<p>Through mapping to SQL collection (note 6)</p>
</td>
<td class="cellalignment5693" headers="r26c1-t7 r1c3-t7">
<p>Through mapping to SQL collection (note 6)</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r27c1-t7" headers="r1c1-t7">
<p>Scalar (numeric or character)</p>
<p>Index-by tables</p>
</td>
<td class="cellalignment5693" headers="r27c1-t7 r1c2-t7">
<p>Through mapping to Java array (note 7)</p>
</td>
<td class="cellalignment5693" headers="r27c1-t7 r1c3-t7">
<p>Through mapping to Java array (note&nbsp;7)</p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r28c1-t7" headers="r1c1-t7">
<p>User-defined subtypes</p>
</td>
<td class="cellalignment5693" headers="r28c1-t7 r1c2-t7">
<p>Same as for base type</p>
</td>
<td class="cellalignment5693" headers="r28c1-t7 r1c3-t7">
<p>Same as for base type</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" -->
<p><a id="JJPUB24092"></a><span class="subhead3">Data Type Mapping Notes&nbsp;</span>The following notes correspond to the entries in the preceding table:</p>
<ol>
<li>
<p>The Java classes <code>oracle.sql.NCHAR</code>, <code>oracle.sql.NCLOB</code>, and <code>oracle.sql.NString</code> are not part of JDBC but are distributed with the JPublisher run time. JPublisher uses these classes to represent the <code>NCHAR</code> form of use of the corresponding classes, <code>oracle.sql.CHAR</code>, <code>oracle.sql.CLOB</code>, and <code>java.lang.String</code>.</p>
</li>
<li>
<p>Mappings of SQL <code>INTERVAL</code> types to the Java <code>String</code> type are defined in the JPublisher default type map. Functions from the <code>SYS.SQLJUTL</code> package are used for the conversions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1011295">&#34;JPublisher User Type Map and Default Type Map&#34;</a></div>
</li>
<li>
<p>Mapping of PL/SQL <code>BOOLEAN</code> to SQL <code>NUMBER</code> and Java <code>boolean</code> is defined in the default JPublisher type map. This process uses conversion functions from the <code>SYS.SQLJUTL</code> package.</p>
</li>
<li>
<p>Mapping of the <code>SYS.XMLTYPE</code> SQL <code>OPAQUE</code> type to the <code>oracle.xdb.XMLType</code> Java class is defined in the default JPublisher type map. For other <code>OPAQUE</code> types, the vendor typically provides a corresponding Java class. In this case, you must specify a JPublisher type map entry that defines the correspondence between the SQL <code>OPAQUE</code> type and the corresponding Java wrapper class. If JPublisher encounters an <code>OPAQUE</code> type that does not have a type map entry, then it generates a Java wrapper class for that <code>OPAQUE</code> type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005908">&#34;Type Mapping Support for OPAQUE Types&#34;</a></div>
</li>
<li>
<p>To supp<a id="sthref101"></a>ort a PL/SQL <code>RECORD</code> type, JPublisher maps the <code>RECORD</code> type to a SQL object type and then to a Java type corresponding to the SQL object type. JPublisher generates two SQL scripts. One script is to create the SQL object type and to create a PL/SQL package containing the conversion functions between the SQL type and the <code>RECORD</code> type. The other script is used to drop the SQL type and the PL/SQL package created by the first script.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1010202">&#34;Type Mapping Support for PL/SQL RECORD and Index-By Table Types&#34;</a></div>
</li>
<li>
<p>To support a PL/S<a id="sthref102"></a>QL index-by table type, JPublisher first maps the index-by table type into a SQL collection type and then maps it into a Java class corresponding to that SQL collection type. JPublisher generates two SQL scripts. One to create the SQL collection type and to create a PL/SQL package containing conversion functions between the SQL collection type and the index-by table type. The other to drop the collection type and the PL/SQL package created by the first script.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1010202">&#34;Type Mapping Support for PL/SQL RECORD and Index-By Table Types&#34;</a></div>
</li>
<li>
<p>If you us<a id="sthref103"></a>e the JDBC driver to call PL/SQL stored procedures or object methods, then you have direct support for scalar index-by tables, also known as PL/SQL <code>TABLE</code> types. In this case, you must use a type map entry for JPublisher that specifies the PL/SQL scalar index-by table type and a corresponding Java array type. JPublisher can then automatically publish PL/SQL or object method signatures that use this scalar index-by type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005939">&#34;Type Mapping Support for Scalar Index-by Tables&#34;</a></div>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1011295"></a>
<div id="JJPUB24093" class="sect2">
<h3 class="sect2">JPublisher User Ty<a id="sthref104"></a><a id="sthref105"></a><a id="sthref106"></a><a id="sthref107"></a>pe Map and Default Type Map</h3>
<p>JPublisher has a user type map, which is controlled by the <code>-typemap</code> and <code>-addtypemap</code> options and starts out empty. It also has a default type map, which is controlled by the <code>-defaulttypemap</code> and <code>-adddefaulttypemap</code> options and starts with entries such as the following:</p>
<pre>jpub.defaulttypemap=SYS.XMLTYPE:oracle.xdb.XMLType
jpub.adddefaulttypemap=BOOLEAN:boolean:INTEGER:
SYS.SQLJUTL.INT2BOOL:SYS.SQLJUTL.BOOL2INT
jpub.adddefaulttypemap=INTERVAL DAY TO SECOND:String:CHAR:
SYS.SQLJUTL.CHAR2IDS:SYS.SQLJUTL.IDS2CHAR
jpub.adddefaulttypemap=INTERVAL YEAR TO MONTH:String:CHAR:
SYS.SQLJUTL.CHAR2IYM:SYS.SQLJUTL.IYM2CHAR
</pre>
<p>These commands, which include some wraparound lines, indicate mappings between PL/SQL types, Java types, and SQL types. Where applicable, they also specify conversion functions to convert between PL/SQL types and SQL types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#CIHIFGIB">&#34;Type Map Options&#34;</a></div>
<p>JPublisher checks the default type map first. If you attempt in the user type map to redefine a mapping that is in the default type map, JPublisher generates a warning message and ignores the redefinition. Similarly, attempts to add mappings through <code>-adddefaulttypemap</code> or <code>-addtypemap</code> settings that conflict with previous mappings are ignored and generate warnings.</p>
<p>There are typically two scenarios for using the type maps:</p>
<ul>
<li>
<p>Specify type mappings for PL/SQL data types that are unsupported by JDBC.</p>
</li>
<li>
<p>Avoid regenerating a Java class to map to a user-defined type. For example, assume you have a user-defined SQL object type, <code>STUDENT</code>, and have already generated a <code>Student</code> class to map to it. If you specify the <code>STUDENT:Student</code> mapping in the user type map, then JPublisher finds the <code>Student</code> class and uses it for mapping without regenerating it.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDCCHGG">&#34;Example: Using the Type Map to Avoid Regeneration&#34;</a></div>
</li>
</ul>
<p>To use custom mappings, it is recommended that you clear the default type map, as follows:</p>
<pre>-defaulttypemap=
</pre>
<p>Then use the <code>-addtypemap</code> option to put any required mappings into the user type map.</p>
<p>The predefined default type map defines a correspondence between the <code>SYS.XMLTYPE</code> SQL <code>OPAQUE</code> type and the <code>oracle.xdb.XMLType</code> Java wrapper class. In addition, it maps the PL/SQL <code>BOOLEAN</code> type to the Java <code>boolean</code> type and the SQL <code>INTEGER</code> type through two conversion functions defined in the <code>SYS.SQLJUTL</code> package. Also, the default type map provides mappings between the SQL <code>INTERVAL</code> type and the Java <code>String</code> type.</p>
<p>However, you may prefer mapping the PL/SQL <code>BOOLEAN</code> type to the Java object type <code>Boolean</code> to capture the SQL <code>NULL</code> values in addition to the <code>true</code> and <code>false</code> values. You can accomplish this by resetting the default type map, as shown by the following:</p>
<pre>-defaulttypemap=BOOLEAN:Boolean:INTEGER:SYS.SQLJUTL.INT2BOOL:SYS.SQLJUTL.BOOL2INT
</pre>
<p>This changes the designated Java type from <code>boolean</code> to <code>Boolean</code>, as well as eliminating any other existing default type map entries. The rest of the conversion remains valid.</p>
<p><a id="CHDCCHGG"></a><a id="JJPUB24094"></a><span class="subhead3">Example: Using the Type Map to Avoid Regeneration&nbsp;</span>The following example uses the JPublisher type map to avoid the mapping of regenerated Java classes. Assume the following type declarations, noting that the <code>CITY</code> type is an attribute of the <code>TRIP</code> type:</p>
<pre>SQL&gt; CREATE TYPE city AS OBJECT (name VARCHAR2(20), state VARCHAR2(10));
/
SQL&gt; CREATE OR REPLACE TYPE trip AS OBJECT (leave DATE, place city);
/
</pre>
<p>Now assume that you invoke JPublisher as follows:</p>
<pre>% jpub -u hr -s TRIP:Trip
Enter hr password: <span class="italic">password</span>
</pre>
<p>The JPublisher output is:</p>
<pre>HR.TRIP
HR.CITY
</pre>
<p>Only <code>TRIP</code> is specified for processing. However, the command produces the source files <code>City.java</code>, <code>CityRef.java</code>, <code>Trip.java</code>, and <code>TripRef.java</code>, because <code>CITY</code> is an attribute.</p>
<p>If you want to regenerate the classes for <code>TRIP</code> without regenerating the classes for <code>CITY</code>, then you can rerun JPublisher as follows:</p>
<pre>% jpub -u hr -addtypemap=CITY:City -s TRIP:Trip HR.TRIP
Enter hr password: <span class="italic">password</span>
</pre>
<p>As you can see from the output line, the <code>CITY</code> type is not reprocessed and, therefore, the <code>City.java</code> and <code>CityRef.java</code> files are not regenerated. This is because of the addition of the <code>CITY:City</code> relationship to the type map, which informs JPublisher that the existing <code>City</code> class is to be used for mapping.</p>
</div>
<!-- class="sect2" -->
<a id="CHDDEACA"></a>
<div id="JJPUB24095" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">JPublisher Lo<a id="sthref108"></a>gical Progression for Data Type Mappings</h3>
<p>To map a given SQL or PL/SQL type to Java, JPublisher uses the following logical progression:</p>
<ol>
<li>
<p>Checks the type maps to see if the mapping is already specified.</p>
</li>
<li>
<p>Checks the predefined Java mappings for SQL and PL/SQL types.</p>
</li>
<li>
<p>Checks whether the data type to be mapped is a PL/SQL <code>RECORD</code> type or an index-by table type. If it is a PL/SQL <code>RECORD</code> type, JPublisher generates a corresponding SQL object type that it can then map to Java. If it is an index-by table type, JPublisher generates a corresponding SQL collection type that it can then map to Java.</p>
</li>
<li>
<p>If none of steps 1 through 3 apply, then the data type must be a user-defined type. JPublisher generates an <code>ORAData</code> or <code>SQLData</code> class to map it according to the JPublisher option settings.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CHDGIEEI"></a>
<div id="JJPUB24096" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Obje<a id="sthref109"></a><a id="sthref110"></a>ct Attribute Types</h3>
<p>You can use a subset of the SQL data types in <a href="#CHDFJDIC">Table 3-1</a> as object attribute types. The types that can be used are listed here:</p>
<ul>
<li>
<p><code>CHAR</code>, <code>VARCHAR</code>, <code>VARCHAR2</code>, <code>CHARACTER</code></p>
</li>
<li>
<p><code>NCHAR</code>, <code>NVARCHAR2</code></p>
</li>
<li>
<p><code>DATE</code></p>
</li>
<li>
<p><code>DECIMAL</code>, <code>DEC</code>, <code>NUMBER</code>, <code>NUMERIC</code></p>
</li>
<li>
<p><code>DOUBLE PRECISION</code>, <code>FLOAT</code></p>
</li>
<li>
<p><code>INTEGER</code>, <code>SMALLINT</code>, <code>INT</code></p>
</li>
<li>
<p><code>REAL</code></p>
</li>
<li>
<p><code>RAW</code>, <code>LONG RAW</code></p>
</li>
<li>
<p><code>CLOB</code></p>
</li>
<li>
<p><code>BLOB</code></p>
</li>
<li>
<p><code>BFILE</code></p>
</li>
<li>
<p><code>NCLOB</code></p>
</li>
<li>
<p>Object type, <code>OPAQUE</code> type, SQLJ object type</p>
</li>
<li>
<p>Nested table, <code>VARRAY</code> type</p>
</li>
<li>
<p>Object reference type</p>
</li>
</ul>
<p>JPublisher supports the following TIMESTAMP types as object attributes:</p>
<ul>
<li>
<p><code>TIMESTAMP</code></p>
</li>
<li>
<p><code>TIMESTAMP WITH TIMEZONE</code></p>
</li>
<li>
<p><code>TIMESTAMP WITH LOCAL TIMEZONE</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle JDBC implementation does not support the TIMESTAMP types.</div>
</div>
<!-- class="sect2" -->
<a id="CHDIGIHC"></a>
<div id="JJPUB24097" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref111"></a><a id="sthref112"></a><a id="sthref113"></a>REF CURSOR Types and Result Sets Mapping</h3>
<p>If a PL/SQL stored procedure or function or a SQL query returns a <code>REF CURSOR</code>, then JPublisher generates a method, by default, to map the <code>REF CURSOR</code> to <code>java.sql.ResultSet</code>.</p>
<p>In addition, for a SQL query, but not for a <code>REF CURSOR</code> returned by a stored procedure or function, JPublisher generates a method to map the <code>REF CURSOR</code> to an array of rows. In this array, each row is represented by a JavaBean instance.</p>
<p>In addition, with a setting of <code>-style=</code><code>webservices-common</code>, if the following classes are available in the classpath, then JPublisher generates methods to map the <code>REF CURSOR</code> to the following types:</p>
<ul>
<li>
<p><code>javax.xml.transform.Source</code></p>
</li>
<li>
<p><code>oracle.jdbc.rowset.OracleWebRowSet</code></p>
</li>
<li>
<p><code>org.w3c.dom.Document</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The dependency of having the class in the classpath in order to generate the mapping is specified by a <code>CONDITION</code> statement in the style file. The <code>CONDITION</code> statement lists required classes.</p>
</li>
<li>
<p>The <code>webservices9</code> and <code>webservices10</code> style files include <code>webservices-common</code>, but override these mappings. Therefore, JPublisher will <span class="italic">not</span> produce these mappings with a setting of <code>-style=webservices9</code> or <code>-style=webservices10</code>.</p>
</li>
</ul>
</div>
<p>If required, you must perform the following actions to ensure that JPublisher can find the classes:</p>
<ol>
<li>
<p>Ensure that the libraries <code>translator.jar</code>, <code>runtime12.jar</code>, and <code>ojdbc5.jar</code> are in the classpath. These files contain JPublisher and SQLJ translator classes, SQLJ run time classes, and JDBC classes, respectively.</p>
</li>
<li>
<p>Use Java Development Kit (JDK) 1.4, for mapping to <code>Source</code>. This class is not defined in earlier JDK versions.</p>
</li>
<li>
<p>Add <code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/jdbc/lib/rowset-jsr114.jar</code> to the classpath, for mapping to <code>OracleWebRowSet</code>.</p>
</li>
<li>
<p>Add <code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/lib/xmlparsev2.jar</code> to the classpath, for mapping to <code>Document</code>.</p>
</li>
</ol>
<p>Consider the following PL/SQL stored procedure:</p>
<pre>TYPE curtype1 IS REF CURSOR RETURN emp%rowtype;
FUNCTION get1 RETURN curtype1;
</pre>
<p>If the <code>OracleWebRowSet</code> class is found in the classpath during publishing, but <code>Document</code> and <code>Source</code> are not, then JPublisher generates the following methods for the <code>get1</code> function:</p>
<pre>public oracle.jdbc.rowset.OracleWebRowSet get1WebRowSet()
                                 throws java.sql.SQLException;
public java.sql.ResultSet get1() throws java.sql.SQLException;
</pre>
<p>The names of methods returning <code>Document</code> and <code>Source</code> would be <code>get1XMLDocument()</code> and <code>get1XMLSource()</code>, respectively.</p>
<p class="subhead2"><a id="JJPUB24098"></a>Disabling Mapping to Source, OracleWebRowSet, or Document</p>
<p>There is currently no JPublisher option to explicitly enable or disable mapping to <code>Source</code>, <code>OracleWebRowSet</code>, or <code>Document</code>. The only condition in the <code>webservices-common</code> style file is whether the classes exist in the classpath. However, you can copy and edit your own style file if you want more control over how JPublisher maps <code>REF CURSOR</code>. The following code is an excerpt from the <code>webservices-common</code> file that has been copied and edited as an example. Descriptions of the edits follow the code.</p>
<pre>BEGIN_TRANSFORMATION
MAPPING
SOURCETYPE java.sql.ResultSet
TARGETTYPE java.sql.ResultSet
RETURN
%2 = %1;
END_RETURN;
END_MAPPING

MAPPING
#CONDITION oracle.jdbc.rowset.OracleWebRowSet
SOURCETYPE java.sql.ResultSet
TARGETTYPE oracle.jdbc.rowset.OracleWebRowSet
TARGETSUFFIX WebRowSet
RETURN
%2 = null;
if (%1!=null)
{
  %2 = new oracle.jdbc.rowset.OracleWebRowSet();
  %2.populate(%1);
}
END_RETURN
END_MAPPING
 
#MAPPING
#CONDITION org.w3c.dom.Document oracle.xml.sql.query.OracleXMLQuery
#SOURCETYPE java.sql.ResultSet
#TARGETTYPE org.w3c.dom.Document
#TARGETSUFFIX XMLDocument
#RETURN
#%2 = null;
#if (%1!=null)
#  %2= (new oracle.xml.sql.query.OracleXMLQuery
#                                 (_getConnection(), %1)).getXMLDOM();
#END_RETURN
#END_MAPPING

MAPPING
CONDITION org.w3c.dom.Document oracle.xml.sql.query.OracleXMLQuery
          javax.xml.transform.Source javax.xml.transform.dom.DOMSource
SOURCETYPE java.sql.ResultSet
TARGETTYPE javax.xml.transform.Source
TARGETSUFFIX XMLSource
RETURN
%2 = null;
if (%1!=null)
  %2= new javax.xml.transform.dom.DOMSource
      ((new oracle.xml.sql.query.OracleXMLQuery
       (new oracle.xml.sql.dataset.OracleXMLDataSetExtJdbc(_getConnection(),
       (oracle.jdbc.OracleResultSet) %1))).getXMLDOM());
END_RETURN
END_MAPPING
END_TRANSFORMATION
</pre>
<p>Assume that you copy this file into <code>myrefcursormaps.properties</code>. There are four <code>MAPPING</code> sections intended for mapping <code>REF CURSOR</code> to <code>ResultSet</code>, <code>OracleWebRowSet</code>, <code>Document</code>, and <code>Source</code> according to the <code>SOURCETYPE</code> and <code>TARGETTYPE</code> entries. For this example, lines are commented out using the &#34;#&#34; character to accomplish the following:</p>
<ul>
<li>
<p>The <code>CONDITION</code> statement is commented out for the <code>OracleWebRowSet</code> mapping. Because of this, JPublisher will generate a method for this mapping regardless of whether <code>OracleWebRowSet</code> is in the classpath.</p>
</li>
<li>
<p>The entire <code>MAPPING</code> section is commented out for the <code>Document</code> mapping. JPublisher will not generate a method for this mapping.</p>
</li>
</ul>
<p>Run JPublisher with the following options to use your custom mappings:</p>
<pre>% jpub -u hr -style=myrefcursormaps -s MYTYPE:MyType
Enter hr password: <span class="italic">password</span>
</pre></div>
<!-- class="sect2" -->
<a id="CHDIAEDF"></a>
<div id="JJPUB24099" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Connection in JDBC Mapping</h3>
<p>With the <code>-usertypes=jdbc</code> setting, JPublisher generates <code>SQLData</code> for a SQL object type. The underlying JDBC connection for a <code>SQLData</code> instance is not automatically set by the JDBC driver. Therefore, before accessing attributes in a <code>SQLData</code> instance, you must set a JDBC connection using the <code>setConnectionContext()</code> method.</p>
<p>Consider <code>Address</code> is a <code>SQLData</code> class generated by JPublisher with <code>-usertypes=jdbc</code>. The following code segment accesses the attribute of an <code>Address</code> instance. Note that the <code>setConnectionContext</code> call explicitly initializes the underlying JDBC connection.</p>
<pre>...
ResultSet rset = stmt.executeQuery();
Address address = (Address) rset.getObject(1);
address.setConnectionContext(new sqlj.runtime.ref.DefaultContext(connection));
String addr = address.getAddress();
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Other <code>-usertypes</code> settings do not require setting the connection, as described in the preceding code example.</div>
<p>On the other hand, for <code>ORAData</code> types that JPublisher generates with the <code>-usertypes=oracle</code> setting or by default, connection initialization is not required. The underlying JDBC connection for <code>ORAData</code> is already assigned at the time it is read from <code>ResultSet</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005880"></a>
<div id="JJPUB24100" class="sect1">
<h2 class="sect1">Sup<a id="sthref114"></a><a id="sthref115"></a>port for PL/SQL Data Types</h2>
<p>There are three scenarios if JPublisher encounters a PL/SQL stored procedure or function, including method of a SQL object type, which uses a PL/SQL type that is unsupported by JDBC:</p>
<ul>
<li>
<p>If you specify a mapping for the PL/SQL type in the default type map or user type map, then JPublisher uses that mapping.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1011295">&#34;JPublisher User Type Map and Default Type Map&#34;</a></div>
</li>
<li>
<p>If there is no mapping in the type maps, and the PL/SQL type is a <code>RECORD</code> type or an index-by table type, then JPublisher generates a corresponding SQL type that JDBC supports. For a PL/SQL <code>RECORD</code> type, JPublisher generates a SQL object type to bridge between the <code>RECORD</code> type and Java. For an index-by table type, JPublisher generates a SQL collection type for the bridge.</p>
</li>
<li>
<p>If neither of the first two scenarios applies, then JPublisher issues a warning message and uses <code>&lt;unsupported type&gt;</code> in the generated code to represent the unsupported PL/SQL type.</p>
</li>
</ul>
<p>The following sections discuss further details of JPublisher type mapping features for PL/SQL types unsupported by JDBC:</p>
<ul>
<li>
<p><a href="#i1005908">Type Mapping Support for OPAQUE Types</a></p>
</li>
<li>
<p><a href="#i1005939">Type Mapping Support for Scalar Index-by Tables</a></p>
</li>
<li>
<p><a href="#i1006009">Type Mapping Support Through PL/SQL Conversion Functions</a></p>
</li>
<li>
<p><a href="#i1010202">Type Mapping Support for PL/SQL RECORD and Index-By Table Types</a></p>
</li>
<li>
<p><a href="#CHDDCADC">Direct Use of PL/SQL Conversion Functions Versus Use of Wrapper Functions</a></p>
</li>
<li>
<p><a href="#i1011376">Other Alternatives for Data Types Unsupported by JDBC</a></p>
</li>
</ul>
<a id="i1005908"></a>
<div id="JJPUB24101" class="sect2">
<h3 class="sect2">Type Mapping Support for OPAQUE Types</h3>
<p>This section describes JPublisher type mapping support for SQL <code>OPAQUE</code> types in general.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you want JPublisher to generate wrapper classes for SQL <code>OPAQUE</code> types, then you must use an Oracle9<span class="italic">i</span> Database release 2 (9.2) or later installation and JDBC driver.</div>
<p>The Oracle JDBC and SQLJ implementations support SQL <code>OPAQUE</code> types published as Java classes implementing the <code>oracle.sql.ORAData</code> interface. Such classes must contain the following public, static fields and methods:</p>
<pre>public static String _SQL_NAME = &#34;<span class="italic">SQL_name_of_OPAQUE_type</span>&#34;;
public static int _SQL_TYPECODE = OracleTypes.OPAQUE;
public static ORADataFactory getORADataFactory() { ... }
</pre>
<p>If you have a Java wrapper class to map to a SQL <code>OPAQUE</code> type, and the class meets this requirement, then you can specify the mapping through the JPublisher user type map. Use the <code>-addtypemap</code> option with the following syntax to append the mapping to the user type map:</p>
<pre>-addtypemap=<span class="italic">sql_opaque_type</span>:<span class="italic">java_wrapper_class</span>
</pre>
<p>In Oracle Database 12<span class="italic">c</span>, the <code>SYS.XMLTYPE</code> SQL <code>OPAQUE</code> type is mapped to the <code>oracle.xdb.XMLType</code> Java class through the JPublisher default type map. You could accomplish the same thing explicitly through the user type map, as follows:</p>
<pre>-addtypemap=SYS.XMLTYPE:oracle.xdb.XMLType
</pre>
<p>Whenever JPublisher encounters a SQL <code>OPAQUE</code> type for which no type correspondence has been provided, it publishes a Java wrapper class. Consider the following SQL type defined in the <code>HR</code> schema:</p>
<pre>CREATE TYPE X_TYP AS OBJECT (xml SYS.XMLTYPE);
</pre>
<p>The following command publishes <code>X_TYP</code> as a Java class <code>XTyp</code>:</p>
<pre>% jpub -u hr -s X_TYP:XTyp
Enter hr password: <span class="italic">password</span>
</pre>
<p>By default, the <code>xml</code> attribute is published using <code>oracle.xdb.XMLType</code>, which is the predefined type mapping for <code>SYS.XMLTYPE</code>. If you clear the JPublisher default type map, then a wrapper class, <code>Xmltype</code>, will automatically be generated for the <code>SYS.XMLTYPE</code> attribute. You can verify this by invoking JPublisher as follows:</p>
<pre>% jpub -u hr -s X_TYP:XTyp -defaulttypemap=
Enter hr password: <span class="italic">password</span>
</pre>
<p>The <code>-defaulttypemap</code> option is for setting the JPublisher default type map. Giving it no value, as in the preceding example, clears it.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1011295">&#34;JPublisher User Type Map and Default Type Map&#34;</a> and <a href="optinfil.htm#CIHIFGIB">&#34;Type Map Options&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1005939"></a>
<div id="JJPUB24103" class="sect2">
<h3 class="sect2">Type Mapping Sup<a id="sthref116"></a><a id="sthref117"></a>port for Scalar Index-by Tables</h3>
<p>The term <a id="sthref118"></a><span class="bold">scalar PL/SQL index-by table</span> refers to a PL/SQL index-by table with elements of <code>VARCHAR</code> and numerical types. Starting 10<span class="italic">g</span> Release 2, JPublisher can map a simple PL/SQL index-by table into a Java array, as an alternative to mapping PL/SQL index-by tables into custom JDBC types. The option <code>plsqlindextable</code> specifies how a simple PL/SQL index-by table is mapped.</p>
<pre>-plsqlindextable=custom|array|<span class="italic">int</span>
</pre>
<p>If <code>-plsqlindextable=custom</code> is set, all indexby tables are mapped to custom JDBC types, such as <code>SQLData</code>, <code>CustomDatum</code>, or <code>ORAData</code>. If <code>-plsqlindextable=array</code> or <code>-plsqlindextable=</code><code><span class="codeinlineitalic">int</span></code> is set, a simple index-by table will be mapped to a Java array. With <code>-plsqlindextable=</code><code><span class="codeinlineitalic">int</span></code>, the <code><span class="codeinlineitalic">int</span></code> value specifies the array capacity, which is 32768 by default. The default setting for this option is <code>custom</code>.</p>
<p>Consider the following PL/SQL package:</p>
<pre>CREATE OR REPLACE PACKAGE indexbytable_package AS
  TYPE index_tbl1 IS TABLE OF VARCHAR2(111) INDEX BY binary_integer;
  TYPE index_tbl2 IS TABLE OF NUMBER INDEX BY binary_integer;
  TYPE varray_tbl3 IS VARRAY(100) OF VARCHAR2(20);
  TYPE nested_tbl4 IS TABLE OF VARCHAR2(20);
  FUNCTION echo_index_tbl1(a index_tbl1) RETURN index_tbl1;
  FUNCTION echo_index_tbl2(a index_tbl2) RETURN index_tbl2;
  FUNCTION echo_varray_tbl3(a varray_tbl3) RETURN varray_tbl3;
  FUNCTION echo_nested_tbl4(a nested_tbl4) RETURN nested_tbl4;
END;
/
</pre>
<p>Run the following command:</p>
<pre>% jpub -u hr -sql=indexbytable_package:IndexbyTablePackage#IndexbyTableIntf -plsqlindextable=32
Enter hr password: <span class="italic">password</span>
</pre>
<p>The <code>-plsqlindextable=32</code> setting specifies that simple index-by tables are mapped to Java arrays, with a capacity of 32. The following interface is generated in <code>IndexbyTableIntf.java</code>:</p>
<pre>public interface IndexbyTableIntf
{
 public String[] echoIndexTbl1(String[] a);
 public java.math.BigDecimal[] echoIndexTbl2(java.math.BigDecimal[] a);
 public IndexbytableintfVarrayTbl3 echoVarrayTbl4(IndexbytableintfVarrayTbl3 a);
 public IndexbytableintfNestedTbl4 echoVarrayTbl4(IndexbytableintfNestedTbl4 a);
}
</pre>
<p>In the generated code, the simple index-by table types, <code>index_tbl1</code> and <code>index_tb2</code>, are mapped to <code>String[]</code> and <code>BigDecimal[]</code> respectively. The nested table and varray table, however, are still mapped to custom JDBC types, because they are not index-by tables and their mappings are not affected by the <code>-plsqlindextable</code> setting.</p>
<p>The limitation of mapping PL/SQL index-by table to an array is that the table must be indexed by integer. If a PL/SQL package contains both tables indexed by integer and by <code>VARCHAR</code>, you cannot use the setting <code>-plsqlindexbytable=array</code> or <code>-plsqlindexbytable=</code><code><span class="codeinlineitalic">int</span></code>. Otherwise the mapping for the table indexed by <code>VARCHAR</code> will encounter run-time errors. Instead, one must use <code>-plsqlindexbytable=custom</code>.</p>
<p>Mapping of the index-by table elements follows the JDBC type mappings. For example, with JDBC mapping, <code>SMALLINT</code> is mapped to the Java <code>int</code> type. Therefore, an index-by table of <code>SMALLINT</code> is mapped to <code>int[]</code>. The <code>-plsqlindexbytable=array</code> or <code>-plsqlindexbytable=</code><code><span class="codeinlineitalic">int</span></code> setting will be ignored if Oracle mappings are turned on for numbers, that is, <code>-numbertypes=oracle</code>. The reason is that the Java array mapped to the index-by table must have string or numerical Java types as elements, while Oracle mappings map SQL numbers into <code>oracle.sql</code> types.</p>
<p>Oracle JDBC drivers directly support PL/SQL scalar index-by tables with numeric or character elements. An index-by table with numeric elements can be mapped to the following Java array types:</p>
<ul>
<li>
<p><code>int[]</code></p>
</li>
<li>
<p><code>double[]</code></p>
</li>
<li>
<p><code>float[]</code></p>
</li>
<li>
<p><code>java.math.BigDecimal[]</code></p>
</li>
<li>
<p><code>oracle.sql.NUMBER[]</code></p>
</li>
</ul>
<p>An index-by table with character elements can be mapped to the following Java array types:</p>
<ul>
<li>
<p><code>String[]</code></p>
</li>
<li>
<p><code>oracle.sql.CHAR[]</code></p>
</li>
</ul>
<p>In the following circumstances, you must convey certain information for an index-by table type, as described:</p>
<ul>
<li>
<p>Whenever you use the index-by table type in an <code>OUT</code> or <code>IN OUT</code> parameter, you must specify the maximum number of elements, which is otherwise optional. You can specify the maximum number of elements using the customary syntax for Java array allocation. For example, you could specify <code>int[100]</code> to denote a type that can accommodate up to 100 elements or <code>oracle.sql.CHAR[20]</code> for up to 20 elements.</p>
</li>
<li>
<p>For index-by tables with character elements, you can optionally specify the maximum size of an individual element, in bytes. This setting is defined using the SQL-like size syntax. For example, for an index-by table used for <code>IN</code> arguments, you could specify <code>String[](30)</code>. You could also specify <code>oracle.sql.CHAR[20](255)</code> for an index-by table of maximum length 20, the elements of which will not exceed 255 bytes each.</p>
</li>
</ul>
<p>Use the JPublisher <code>-addtypemap</code> option to add instructions to the user type map to specify correspondences between PL/SQL types, which are scalar index-by tables, and the corresponding Java array types. The size hints that are given using the syntax outlined earlier are embedded into the generated SQLJ class and thus conveyed to JDBC at run time.</p>
<p>As an example, consider the following code fragment from the definition of the <code>INDEXBY</code> PL/SQL package in the <code>HR</code> schema. Assume this is available in a file called <code>indexby.sql</code>.</p>
<pre>CREATE OR REPLACE PACKAGE indexby AS

--  jpub.addtypemap=HR.INDEXBY.VARCHAR_ARY:String[1000](4000)
--  jpub.addtypemap=HR.INDEXBY.INTEGER_ARY:int[1000]
--  jpub.addtypemap=HR.INDEXBY.FLOAT_ARY:double[1000]

 TYPE varchar_ary IS TABLE OF VARCHAR2(4000) INDEX BY BINARY_INTEGER;
 TYPE integer_ary IS TABLE OF INTEGER        INDEX BY BINARY_INTEGER;
 TYPE float_ary   IS TABLE OF NUMBER         INDEX BY BINARY_INTEGER;

 FUNCTION get_float_ary RETURN float_ary;
 PROCEDURE pow_integer_ary(x integer_ary, y OUT integer_ary);
 PROCEDURE xform_varchar_ary(x IN OUT varchar_ary);

END indexby;
/
CREATE OR REPLACE PACKAGE BODY indexby IS ...
/
</pre>
<p>The following are the required <code>-addtypemap</code> directives for mapping the three index-by table types:</p>
<pre>-addtypemap=HR.INDEXBY.VARCHAR_ARY:String[1000](4000)
-addtypemap=HR.INDEXBY.INTEGER_ARY:int[1000]
-addtypemap=HR.INDEXBY.FLOAT_ARY:double[1000]
</pre>
<p>Note that depending on the operating system shell you are using, you may have to quote options that contain square brackets <code><span class="codeinlinebold">[</span></code>...<code><span class="codeinlinebold">]</span></code> or parentheses <code><span class="codeinlinebold">(</span></code>...<code><span class="codeinlinebold">)</span></code>. You can avoid this by placing such options into a JPublisher properties file, as follows:</p>
<pre>jpub.addtypemap=HR.INDEXBY.VARCHAR_ARY:String[1000](4000)
jpub.addtypemap=HR.INDEXBY.INTEGER_ARY:int[1000]
jpub.addtypemap=HR.INDEXBY.FLOAT_ARY:double[1000]
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#i1006954">&#34;Properties File Structure and Syntax&#34;</a> and <a href="optinfil.htm#i1010260">&#34;Additional Entry to the User Type Map&#34;</a></div>
<p>Additionally, as a feature of convenience, JPublisher directives in a properties file are recognized when placed behind a &#34;<code>--</code>&#34; prefix (two dashes), whereas any entry that does not start with <code>&#34;jpub.&#34;</code> or with <code>&#34;-- jpub.</code>&#34; is ignored. So, you can place JPublisher directives into SQL scripts and reuse the same SQL scripts as JPublisher properties files. Thus, after invoking the <code>indexby.sql</code> script to define the <code>INDEXBY</code> package, you can now run JPublisher to publish this package as a Java class, <code>IndexBy</code>, as follows:</p>
<pre>% jpub -u hr -s INDEXBY:IndexBy -props=indexby.sql
Enter hr password: <span class="italic">password</span>
</pre>
<p>As mentioned previously, you can use this mapping of scalar index-by tables only with Oracle JDBC drivers. If you are using another driver or if you want to create driver-independent code, then you must define SQL types that correspond to the index-by table types, as well as defining conversion functions that map between the two.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1010202">&#34;Type Mapping Support for PL/SQL RECORD and Index-By Table Types&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006009"></a>
<div id="JJPUB24104" class="sect2">
<h3 class="sect2">Type Map<a id="sthref119"></a><a id="sthref120"></a>ping Support Through PL/SQL Conversion Functions</h3>
<p>This section discusses the mechanism that JPublisher uses for supporting PL/SQL types in Java code, through PL/SQL conversion functions that convert between each PL/SQL type and a corresponding SQL type to allow access by JDBC.</p>
<p>In general, Java programs do not support the binding of PL/SQL-specific types. The only way you can use such types from Java is to use PL/SQL code to map them to SQL types, and then access these SQL types from Java. However, one exception is the scalar index-by table type.</p>
<p>JPublisher makes this task more convenient through the use of its type maps. For a particular PL/SQL type, specify the following information in a JPublisher type map entry:</p>
<ul>
<li>
<p>Name of the PL/SQL type, typically of the form:</p>
<pre><span class="italic">SCHEMA.PACKAGE.TYPE</span>
</pre></li>
<li>
<p>Name of the corresponding Java wrapper class</p>
</li>
<li>
<p>Name of the SQL type that corresponds to the PL/SQL type</p>
<p>You must be able to directly map this type to the Java wrapper type. For example, if the SQL type is <code>NUMBER</code>, then the corresponding Java type could be <code>int</code>, <code>double</code>, <code>Integer</code>, <code>Double</code>, <code>java.math.BigDecimal</code>, or <code>oracle.sql.NUMBER</code>. If the SQL type is an object type, then the corresponding Java type would be an object wrapper class that implements the <code>oracle.sql.ORAData</code> or <code>java.sql.SQLData</code> interface. The object wrapper class is typically generated by JPublisher.</p>
</li>
<li>
<p>Name of a PL/SQL conversion function that maps the SQL type to the PL/SQL type</p>
</li>
<li>
<p>Name of a PL/SQL conversion function that maps the PL/SQL type to the SQL type</p>
</li>
</ul>
<p>The <code>-addtypemap</code> specification for this has the following form:</p>
<pre>-addtypemap=<span class="italic">plsql_type</span>:<span class="italic">java_type</span>:<span class="italic">sql_type</span>:<span class="italic">sql_to_plsql_fun</span>:<span class="italic">plsql_to_sql_fun</span>
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#CIHIFGIB">&#34;Type Map Options&#34;</a></div>
<p>As an example, consider a type map entry for supporting the PL/SQL <code>BOOLEAN</code> type. It consists of the following specifications:</p>
<ul>
<li>
<p>Name of the PL/SQL type: <code>BOOLEAN</code></p>
</li>
<li>
<p>Specification to map it to Java <code>boolean</code></p>
</li>
<li>
<p>Corresponding SQL type: <code>INTEGER</code></p>
<p>JDBC considers <code>boolean</code> values as special numeric values.</p>
</li>
<li>
<p>Name of the PL/SQL function that maps from SQL to PL/SQL: <code>INT2BOOL</code></p>
<p>The code for the function is:</p>
<pre>FUNCTION int2bool(i INTEGER) RETURN BOOLEAN IS
BEGIN IF i IS NULL THEN RETURN NULL;
      ELSE RETURN i&lt;&gt;0;
      END IF;
END int2bool;
</pre></li>
<li>
<p>Name of the PL/SQL function that maps from PL/SQL to SQL: <code>BOOL2INT</code></p>
<p>The code for the function is:</p>
<pre>FUNCTION bool2int(b BOOLEAN) RETURN INTEGER IS
BEGIN IF b IS NULL THEN RETURN NULL;
      ELSIF b THEN RETURN 1;
      ELSE RETURN 0; 
      END IF;
END bool2int;
</pre></li>
</ul>
<p>You can put all this together in the following type map entry:</p>
<pre>-addtypemap=BOOLEAN:boolean:INTEGER:INT2BOOL:BOOL2INT
</pre>
<p>Such a type map entry assumes that the SQL type, the Java type, and both conversion functions have been defined in SQL, Java, and PL/SQL, respectively. Note that there is already an entry for PL/SQL <code>BOOLEAN</code> in the JPublisher default type map. If you want to try the preceding type map entry, you will have to override the default type map. You can use the JPublisher <code>-defaulttypemap</code> option to accomplish this, as follows:</p>
<pre>% jpub -u hr -s SYS.SQLJUTL:SQLJUtl -defaulttypemap=BOOLEAN:boolean:INTEGER:INT2BOOL:BOOL2INT
Enter hr password: <span class="italic">password</span>
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>In some cases, such as with <code>INT2BOOL</code> and <code>BOOL2INT</code> in the preceding example, JPublisher has conversion functions that are predefined, typically in the <code>SYS.SQLJUTL</code> package. In other cases, such as for <code>RECORD</code> types and index-by table types, JPublisher generates conversion functions during execution.</p>
</li>
<li>
<p>Although this manual describes conversions as mapping between SQL and PL/SQL types, there is no intrinsic restriction to PL/SQL in this approach. You could also map between different SQL types. In fact, this is done in the JPublisher default type map to support SQL <code>INTERVAL</code> types, which are mapped to <code>VARCHAR2</code> values and back.</p>
</li>
</ul>
</div>
<p>Be aware that under some circumstances, PL/SQL wrap<a id="sthref121"></a>per functions are also created by JPublisher. Each wrapper function wraps a stored procedure that uses PL/SQL types. It calls this original stored procedure and processes its PL/SQL input or output through the appropriate conversion functions so that only the corresponding SQL types are exposed to Java. The following JPublisher options control how JPublisher creates code for invocation of PL/SQL stored procedures that use PL/SQL types, including the use of conversion functions and possibly the use of wrapper functions:</p>
<ul>
<li>
<p><code>-plsqlpackage=</code><code><span class="codeinlineitalic">plsql_package</span></code></p>
<p>This option determines the name of the PL/SQL package into which JPublisher generates the PL/SQL conversion functions: a function to convert each unsupported PL/SQL type to the corresponding SQL type and a function to convert from each corresponding SQL type back to the PL/SQL type. Optionally, depending on how you set the <code>-plsqlmap</code> option, the package also contains wrapper functions for the original stored procedures, with each wrapper function invoking the appropriate conversion function.</p>
<p>If you do not specify a package name, then JPublisher uses <code>JPUB_PLSQL_WRAPPER</code>.</p>
</li>
<li>
<p><code>-plsqlfile=</code><code><span class="codeinlineitalic">plsql_wrapper_script</span></code><code>,</code><code><span class="codeinlineitalic">plsql_dropper_script</span></code></p>
<p>This option determines the name of the wrapper script and dropper script that JPublisher creates. The wrapper script creates necessary SQL types that map to unsupported PL/SQL types and also creates the PL/SQL package. The dropper script drops these SQL types and the PL/SQL package.</p>
<p>If the files already exist, then they will be overwritten. If you do not specify any file names, then JPublisher will write to the files named <code>plsql_wrapper.sql</code> and <code>plsql_dropper.sql</code>.</p>
</li>
<li>
<p><code>-plsqlmap=</code><code><span class="codeinlineitalic">flag</span></code></p>
<p>This option specifies whether JPublisher generates wrapper functions for stored procedures that use PL/SQL types. Each wrapper function calls the corresponding stored procedure and the appropriate PL/SQL conversion functions for PL/SQL input or output of the stored procedure. Only the corresponding SQL types are exposed to Java. The <code><span class="codeinlineitalic">flag</span></code> setting can be any of the following:</p>
<ul>
<li>
<p><code>true</code></p>
<p>This is the default setting. JPublisher generates PL/SQL wrapper functions only as needed. For any given stored procedure, if the Java code to call it and convert its PL/SQL types directly is simple enough, and if PL/SQL types are used only as <code>IN</code> parameters or for the function return, then the generated code calls the stored procedure directly instead. The code then processes the PL/SQL input or output through the appropriate conversion functions.</p>
<p>If a PL/SQL type is used as an <code>OUT</code> or <code>IN OUT</code> parameter, then wrapper functions are required, because conversions between PL/SQL and SQL representations may be necessary either before or after calling the original stored procedure.</p>
</li>
<li>
<p><code>false</code></p>
<p>JPublisher does not generate PL/SQL wrapper functions. If it encounters a PL/SQL type in a signature that cannot be supported by a direct call and conversion, then it skips the generation of Java code for the particular stored procedure.</p>
</li>
<li>
<p><code>always</code></p>
<p>JPublisher generates a PL/SQL wrapper function for every stored procedure that uses a PL/SQL type. This setting is useful for generating a <span class="italic">proxy</span> PL/SQL package that complements an original PL/SQL package, providing JDBC-accessible signatures for those functions or procedures that were not accessible through JDBC in the original package.</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDDCADC">&#34;Direct Use of PL/SQL Conversion Functions Versus Use of Wrapper Functions&#34;</a> and <a href="optinfil.htm#CIHFGBHH">&#34;PL/SQL Code Generation Options&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1010202"></a>
<div id="JJPUB24105" class="sect2">
<h3 class="sect2">Type Mapping Sup<a id="sthref122"></a><a id="sthref123"></a><a id="sthref124"></a><a id="sthref125"></a>port for PL/SQL RECORD and Index-By Table Types</h3>
<p>JPublisher automatically publishes a PL/SQL <code>RECORD</code> type whenever it publishes a PL/SQL stored procedure or function that uses that type as an argument or return type. The same is true for PL/SQL index-by table types. This is the only way that a <code>RECORD</code> type or index-by table type can be published. There is no way to explicitly request any such types to be published through JPublisher option settings.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following are limitations to the JPublisher support for PL/SQL <code>RECORD</code> and index-by table types:
<ul>
<li>
<p>An intermediate wrapper layer is required to map a <code>RECORD</code> or index-by-table argument to a SQL type that JDBC can support. In addition, JPublisher cannot fully support the semantics of index-by tables. An index-by table is similar in structure to a Java hashtable, but information is lost when JPublisher maps this to a SQL <code>TABLE</code> type.</p>
</li>
<li>
<p>If you use the JDBC OCI driver and require only the publishing of scalar index-by tables, then you can use the direct mapping between Java and these types.</p>
</li>
</ul>
</div>
<p>The following sections demonstrate JPublisher support for PL/SQL <code>RECORD</code> types and index-by table types:</p>
<ul>
<li>
<p><a href="#i1010737">Sample Package for RECORD Type and Index-By Table Type Support</a></p>
</li>
<li>
<p><a href="#i1010692">Support for RECORD Types</a></p>
</li>
<li>
<p><a href="#i1010631">Support for Index-By Table Types</a></p>
</li>
</ul>
<a id="i1010737"></a>
<div id="JJPUB24106" class="sect3">
<h4 class="sect3">Sample Package for RECORD Type and Index-By Table Type Support</h4>
<p>The following PL/SQL package is used to illustrate JPublisher support for PL/SQL <code>RECORD</code> and index-by table types:</p>
<pre>CREATE OR REPLACE PACKAGE company IS
  TYPE emp_rec IS RECORD (empno NUMBER, ename VARCHAR2(10));
  TYPE emp_tbl IS TABLE OF emp_rec INDEX BY binary_integer;
  PROCEDURE set_emp_rec(er emp_rec);
  FUNCTION get_emp_rec(empno number) RETURN emp_rec;
  FUNCTION get_emp_tbl RETURN emp_tbl;
END;
</pre>
<p>This package defines a PL/SQL <code>RECORD</code> type, <code>EMP_REC</code>, and a PL/SQL index-by table type, <code>EMP_TBL</code>. Use the following command to publish the <code>COMPANY</code> package:</p>
<pre>% jpub -u hr -s COMPANY:Company -plsqlpackage=WRAPPER1
  -plsqlfile=wrapper1.sql,dropper1.sql
Enter hr password: <span class="italic">password</span>
</pre>
<p>The JPublisher output is:</p>
<pre>HR.COMPANY
HR.&#34;COMPANY.EMP_REC&#34;
HR.&#34;COMPANY.EMP_TBL&#34;
J2T-138, NOTE: Wrote PL/SQL package WRAPPER1 to file wrapper1.sql.
Wrote the dropping script to file dropper1.sql
</pre>
<p>In this example, JPublisher generates <code>Company.java</code> for the Java wrapper class for the <code>COMPANY</code> package, as well as the following SQL and Java entities:</p>
<ul>
<li>
<p>The <code>wrapper1.sql</code> script that creates the SQL types corresponding to the PL/SQL <code>RECORD</code> and index-by table types, and also creates the conversion functions between the SQL types and the PL/SQL types</p>
</li>
<li>
<p>The <code>dropper1.sql</code> script that removes the SQL types and conversion functions created by <code>wrapper1.sql</code></p>
</li>
<li>
<p>The <code>CompanyEmpRec.java</code> source file for the Java wrapper class for the SQL object type that is generated for the PL/SQL <code>RECORD</code> type</p>
</li>
<li>
<p>The <code>CompanyEmpTbl.java</code> source file for the Java wrapper class for the SQL collection type that is generated for the PL/SQL index-by table type</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1010692"></a>
<div id="JJPUB24107" class="sect3">
<h4 class="sect3">Support for RECORD Types</h4>
<p>This section continues the example from <a href="#i1010737">Sample Package for RECORD Type and Index-By Table Type Support</a>. For the PL/SQL <code>RECORD</code> type, <code>EMP_REC</code>, JPublisher generates the corresponding <code>COMPANY_EMP_REC</code> SQL object type. JPublisher also generates the conversion functions between the two. In this example, the following is generated in <code>wrapper1.sql</code> for <code>EMP_REC</code>:</p>
<pre>CREATE OR REPLACE TYPE COMPANY_EMP_REC AS OBJECT (
                       EMPNO NUMBER(22),
                       ENAME VARCHAR2(10)
);
/
-- Declare package containing conversion functions between SQL and PL/SQL types
CREATE OR REPLACE PACKAGE WRAPPER1 AS
   -- Declare the conversion functions the PL/SQL type COMPANY.EMP_REC
        FUNCTION PL2COMPANY_EMP_REC(aPlsqlItem COMPANY.EMP_REC)
        RETURN COMPANY_EMP_REC;
        FUNCTION COMPANY_EMP_REC2PL(aSqlItem COMPANY_EMP_REC)
        RETURN COMPANY.EMP_REC;
END WRAPPER1;
/
</pre>
<p>In addition, JPublisher publishes the <code>COMPANY_EMP_REC</code> SQL object type into the <code>CompanyEmpRec.java</code> Java source file.</p>
<p>Once the PL/SQL <code>RECORD</code> type is published, you can add the mapping to the type map. The following is an entry in a sample JPublisher properties file, <code>done.properties</code>:</p>
<pre>jpub.addtypemap=HR.COMPANY.EMP_REC:CompanyEmpRec:COMPANY_EMP_REC:
WRAPPER1.COMPANY_EMP_REC2PL:WRAPPER1.PL2COMPANY_EMP_REC
</pre>
<p>Use this type map entry whenever you publish a package or type that refers to the <code>RECORD</code> type, <code>EMP_REC</code>. For example, the following JPublisher invocation uses <code>done.properties</code> with this type map entry:</p>
<pre>% jpub -u hr -p done.properties -s COMPANY -plsqlpackage=WRAPPER2
       -plsqlfile=wrapper2.sql,dropper2.sql
Enter hr password: <span class="italic">password</span>
</pre>
<p>The JPublisher output is:</p>
<pre>HR.COMPANY
HR.&#34;COMPANY.EMP_TBL&#34;
J2T-138, NOTE: Wrote PL/SQL package WRAPPER2 to file wrapper2.sql. 
Wrote the dropping script to file dropper2.sql
</pre></div>
<!-- class="sect3" -->
<a id="i1010631"></a>
<div id="JJPUB24108" class="sect3">
<h4 class="sect3">Support for Index-By Table Types</h4>
<p>This section continues the example from <a href="#i1010737">Sample Package for RECORD Type and Index-By Table Type Support</a>.</p>
<p>To support an index-by table type, a SQL collection type must be defined that permits conversion to and from the PL/SQL index-by table type. JPublisher also supports PL/SQL nested tables and VARRAYs in the same fashion. Therefore, JPublisher generates the same code for the following three definitions of <code>EMP_TBL</code>:</p>
<pre>TYPE emp_tbl IS TABLE OF emp_rec INDEX BY binary_integer;
TYPE emp_tbl IS TABLE OF emp_rec;
TYPE emp_tbl IS VARRAY OF emp_rec;
</pre>
<p>For the PL/SQL index-by table type <code>EMP_TBL</code>, JPublisher generates a SQL collection type, and conversion functions between the index-by table type and the SQL collection type.</p>
<p>In addition to what was shown for the <code>RECORD</code> type earlier, JPublisher generates the following:</p>
<pre>-- Declare the SQL type for the PL/SQL type COMPANY.EMP_TBL
CREATE OR REPLACE TYPE COMPANY_EMP_TBL AS TABLE OF COMPANY_EMP_REC; 
/
-- Declare package containing conversion functions between SQL and PL/SQL types
CREATE OR REPLACE PACKAGE WRAPPER1 AS
   -- Declare the conversion functions for the PL/SQL type COMPANY.EMP_TBL
        FUNCTION PL2COMPANY_EMP_TBL(aPlsqlItem COMPANY.EMP_TBL)
        RETURN COMPANY_EMP_TBL;
        FUNCTION COMPANY_EMP_TBL2PL(aSqlItem COMPANY_EMP_TBL)
        RETURN COMPANY.EMP_TBL;
...
END WRAPPER1;
</pre>
<p>JPublisher further publishes the SQL collection type into <code>CompanyEmpTbl.java</code>.</p>
<p>As with a PL/SQL <code>RECORD</code> type, once a PL/SQL index-by table type is published, the published result, including the Java wrapper classes, the SQL collection type, and the conversion functions, can be used in the future for publishing PL/SQL packages involving that PL/SQL index-by table type. For example, if you add the following entry into a properties file that you use in invoking JPublisher, say <code>done.properties</code>, then JPublisher will use the provided type map and avoid republishing that index-by table type:</p>
<pre>jpub.addtypemap=HR.COMPANY.EMP_TBL:CompanyEmpTbl:COMPANY_EMP_TBL:
WRAPPER1.COMPANY_EMP_TBL2PL:WRAPPER1.PL2COMPANY_EMP_TBL
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1011295">&#34;JPublisher User Type Map and Default Type Map&#34;</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDDCADC"></a>
<div id="JJPUB24109" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Direct Use of PL/SQL Conve<a id="sthref126"></a><a id="sthref127"></a>rsion Functions Versus Use of Wrapper Functions</h3>
<p>In generating Java code to invoke a stored procedure that uses a PL/SQL type, JPublisher can use either of the following modes of operation:</p>
<ul>
<li>
<p>Invoke the stored procedure directly, which processes the PL/SQL input or output through the appropriate conversion functions.</p>
</li>
</ul>
<ul>
<li>
<p>Invoke a PL/SQL wrapper function, which in turn calls the stored procedure and processes its PL/SQL input or output through the appropriate conversion functions. The wrapper function that is generated by JPublisher uses the corresponding SQL types for input or output.</p>
</li>
</ul>
<p>The <code>-plsqlmap</code> option determines whether JPublisher uses the first mode, the second mode, or possibly either mode, depending on circumstances.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#CIHHGFEC">&#34;Generation of PL/SQL Wrapper Functions&#34;</a></div>
<p>As an example, consider the <code>HR.COMPANY.GET_EMP_TBL</code> PL/SQL stored procedure that returns the <code>EMP_TBL</code> PL/SQL index-by table type. Assume that the <code>COMPANY</code> package, introduced in <a href="#i1010737">&#34;Sample Package for RECORD Type and Index-By Table Type Support&#34;</a>, is processed by JPublisher through the following command:</p>
<pre>% jpub -u hr -s COMPANY:Company -plsqlpackage=WRAPPER1
       -plsqlfile=wrapper1.sql,dropper1.sql -plsqlmap=false
Enter hr password: <span class="italic">password</span>
</pre>
<p>The JPublisher output is:</p>
<pre>HR.COMPANY
HR.&#34;COMPANY.EMP_REC&#34;
HR.&#34;COMPANY.EMP_TBL&#34;
J2T-138, NOTE: Wrote PL/SQL package WRAPPER1 to file wrapper1.sql.
Wrote the dropping script to file dropper1.sql
</pre>
<p>With this command, JPublisher creates the following:</p>
<ul>
<li>
<p>SQL object type <code>COMPANY_EMP_REC</code> to map to the PL/SQL <code>RECORD</code> type <code>EMP_REC</code></p>
</li>
<li>
<p>SQL collection type <code>COMPANY_EMP_TBL</code> to map to the PL/SQL index-by table type <code>EMP_TBL</code></p>
</li>
<li>
<p>Java classes to map to <code>COMPANY</code>, <code>COMPANY_EMP_REC</code>, and <code>COMPANY_EMP_TBL</code></p>
</li>
<li>
<p>PL/SQL package <code>WRAPPER1</code>, which includes the PL/SQL conversion functions to convert between the PL/SQL index-by table type and the SQL collection type</p>
</li>
</ul>
<p>In this example, assume that the conversion function <code>PL2COMPANY_EMP_TBL</code> converts from the PL/SQL <code>EMP_TBL</code> type to the SQL <code>COMPANY_EMP_TBL</code> type. Because of the setting <code>-plsqlmap=false</code>, no wrapper functions are created. The stored procedure is called with the following JDBC statement in generated Java code:</p>
<pre>conn.prepareOracleCall = 
(&#34;BEGIN :1 := WRAPPER1.PL2COMPANY_EMP_TBL(HR.COMPANY.GET_EMP_TBL()) \n; END;&#34;);
</pre>
<p><code>HR.COMPANY.GET_EMP_TBL</code> is called directly, with its <code>EMP_TBL</code> output being processed through the <code>PL2COMPANY_EMP_TBL</code> conversion function to return the desired <code>COMPANY_EMP_TBL</code> SQL type.</p>
<p>By contrast, if you run JPublisher with the setting <code>-plsqlmap=always</code>, then <code>WRAPPER1</code> also includes a PL/SQL wrapper function for every PL/SQL stored procedure that uses a PL/SQL type. In this case, for any given stored procedure, the generated Java code calls the wrapper function instead of the stored procedure. The wrapper function, in this example <code>WRAPPER1.GET_EMP_TBL</code>, calling the original stored procedure and processing its output through the conversion function is as follows:</p>
<pre>FUNCTION  GET_EMP_TBL()
   BEGIN 
      RETURN WRAPPER1.PL2COMPANY_EMP_TBL(HR.COMPANY.GET_EMP_TBL()) 
   END;
</pre>
<p>In the generated Java code, the JDBC statement calling the wrapper function is:</p>
<pre>conn.prepareOracleCall(&#34;BEGIN :1=HR.WRAPPER1.GET_EMP_TBL() \n; END;&#34;);
</pre>
<p>If <code>-plsqlmap=true</code>, then JPublisher uses direct calls to the original stored procedure wherever possible. However, in the case of any stored procedure for which the Java code for direct invocation and conversion is too complex or any stored procedure that uses PL/SQL types as <code>OUT</code> or <code>IN OUT</code> parameters, JPublisher generates a wrapper function and calls that function in the generated code.</p>
</div>
<!-- class="sect2" -->
<a id="i1011376"></a>
<div id="JJPUB24110" class="sect2">
<h3 class="sect2">Other Alternatives for Data Types Unsupported by JDBC</h3>
<p>The preceding sections describe the mechanisms that JPublisher employs to access PL/SQL types unsupported by JDBC. As an alternative to using JPublisher in this way, you can try one of the following:</p>
<ul>
<li>
<p>Rewrite the PL/SQL method to avoid using the type</p>
</li>
<li>
<p>Write an anonymous block that does the following:</p>
<ul>
<li>
<p>Converts input types that JDBC supports into the input types used by the PL/SQL stored procedure</p>
</li>
<li>
<p>Converts output types used by the PL/SQL stored procedure into output types that JDBC supports</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1010336"></a>
<div id="JJPUB24111" class="sect1">
<h2 class="sect1">JPublish<a id="sthref128"></a><a id="sthref129"></a>er Styles and Style Files</h2>
<p>JPublisher style files allow you to specify Java-to-Java type mappings. This is to ensure that generated classes can be used in Web services. As an example, <code>CLOB</code> types, such as <code>java.sql.Clob</code> and <code>oracle.sql.CLOB</code>, cannot be used in Web services, but the data can be used if it is converted to a type that is supported by Web services, such as <code>java.lang.String</code>. JPublisher must generate user subclasses to implement its use of style files and Java-to-Java type transformations.</p>
<p>Typically, style files are provided by Oracle, but there may be situations in which you may want to edit or create your own.</p>
<p>The following sections discuss features and usage of styles and style files:</p>
<ul>
<li>
<p><a href="#i1009949">Style File Specifications and Locations</a></p>
</li>
<li>
<p><a href="#i1009325">Style File Format</a></p>
</li>
<li>
<p><a href="#CHDGJBJG">Summary of Key Java-to-Java Type Mappings in Oracle Style Files</a></p>
</li>
<li>
<p><a href="#i1010477">Use of Multiple Style Files</a></p>
</li>
</ul>
<a id="i1009949"></a>
<div id="JJPUB24112" class="sect2">
<h3 class="sect2">Style File Sp<a id="sthref130"></a>ecifications and Locations</h3>
<p>Use the JPublisher <code>-style</code> option to specify the base name of a style file:</p>
<pre>-style=<span class="italic">stylename</span>
</pre>
<p>Based on the <code><span class="codeinlineitalic">stylename</span></code> you specify, JPublisher looks for a style file as follows, and uses the first file that it finds:</p>
<ol>
<li>
<p>It looks for the following resource in the classpath:</p>
<pre>/oracle/jpub/mesg/<span class="italic">stylename</span>.properties
</pre></li>
<li>
<p>It takes <code><span class="codeinlineitalic">stylename</span></code> as a resource name, possibly qualified, and looks for the following in the classpath:</p>
<pre>/<span class="italic">stylename</span>-dir/<span class="italic">stylename</span>-base.properties
</pre></li>
<li>
<p>It takes <code><span class="codeinlineitalic">stylename</span></code> as a name, possibly qualified, and looks for the following file in the current directory:</p>
<pre><span class="italic">stylename</span>.properties
</pre>
<p>In this case, <code><span class="codeinlineitalic">stylename</span></code> can optionally include a directory path. If you use the setting <code>-style=mydir/foo</code>, for example, then JPublisher looks for <code>mydir/foo.properties</code> relative to the current directory.</p>
</li>
</ol>
<p>If no matching file is found, JPublisher generates an exception.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#CIHCHICI">&#34;Style File for Java-to-Java Type Mappings&#34;</a></div>
<p>As an example of the first scenario, if the resource <code>/oracle/jpub/mesg/webservices.properties</code> exists in <code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/sqlj/lib/translator.jar</code> and <code>translator.jar</code> is found in the classpath, then the <code>-style=webservices</code> setting uses <code>/oracle/jpub/mesg/webservices.properties</code> from <code>translator.jar</code>, even if there is a <code>webservices.properties</code> file in the current directory.</p>
<p>However, if you specify <code>-style=mystyle</code> and a <code>mystyle.properties</code> resource is <span class="italic">not</span> found in <code>/oracle/jpub/mesg</code>, but there is a <code>mystyle.properties</code> file in the current directory, then that is used.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle currently provides three style files:
<pre>/oracle/jpub/mesg/webservices-common.properties
/oracle/jpub/mesg/webservices10.properties
/oracle/jpub/mesg/webservices9.properties
</pre>
<p>These are in the <code>translator.jar</code> file, which must be included in your classpath. Each file maps Oracle JDBC types to Java types supported by Web services. Note that the <code>webservices-common.properties</code> file is for general use and is included by both <code>webservices10.properties</code> and <code>webservices9.properties</code>.</p>
<p>To use Web services in Oracle Database 12<span class="italic">c</span>, specify the following style file:</p>
<pre>-style=webservices10
</pre>
<p>To use Web services in Oracle9<span class="italic">i</span>, specify <code>-style=webservices9</code>.</p>
</div>
</div>
<!-- class="sect2" -->
<a id="i1009325"></a>
<div id="JJPUB24113" class="sect2">
<h3 class="sect2">Style File Fo<a id="sthref131"></a>rmat</h3>
<p>The key portion of a style file is the <code>TRANSFORMATION</code> section. This section comprises everything between the <code>TRANSFORMATION</code> tag and <code>END_TRANSFORMATION</code> tag. It describes the type transformations, or Java-to-Java mappings, to be applied to types used for object attributes or in method signatures.</p>
<p>For convenience, there is an <code>OPTIONS</code> section in which you can specify any other JPublisher option settings. Because of this section, a style file can replace the functionality of any other JPublisher properties file, in addition to specifying mappings.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CHDIFHEH">Style File TRANSFORMATION Section</a></p>
</li>
<li>
<p><a href="#CHDHFIFF">Style File OPTIONS Section</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following details about style files are provided for general information. This information is subjected to change.</div>
<a id="CHDIFHEH"></a>
<div id="JJPUB24114" class="sect3">
<h4 class="sect3">Style File TRANSFORMATION Section</h4>
<p>This section provides a template for a style file <code>TRANSFORMATION</code> section, with comments. Within the <code>TRANSFORMATION</code> section, there is a <code>MAPPING</code> section for each mapping that you specify. The <code>MAPPING</code> section starts at a <code>MAPPING</code> tag and ends with an <code>END_MAPPING</code> tag. Each <code>MAPPING</code> section includes a number of subtags with additional information. In the <code>MAPPING</code> section, the <code>SOURCETYPE</code> and <code>TARGETTYPE</code> tags are the required subtags. Within each <code>TARGETTYPE</code> section, you should generally provide information for at least the <code>RETURN</code>, <code>IN</code>, and <code>OUT</code> cases, using the corresponding tags. The following code illustrates the structure of a typical <code>TRANSFORMATION</code> section:</p>
<pre>TRANSFORMATION

 IMPORT
 # Packages to be imported by the generated classes
 END_IMPORT

 # THE FOLLOWING OPTION ONLY APPLIES TO PL/SQL PACKAGES
 # This interface should be implemented/extended by
 # the methods in the user subclasses and interfaces
 # This option takes no effect when subclass is not generated.
 SUBCLASS_INTERFACE <span class="italic">java_interface</span>

 # THE FOLLOWING OPTION ONLY APPLIES TO PL/SQL PACKAGES
 # Each method in the interface and the user subclass should
 # throw this exception (the default SQLException will be caught
 # and re-thrown as an exception specified here)
 # This option takes no effect when subclass is not generated.
 SUBCLASS_EXCEPTION <span class="italic">Java_exception_type</span>

 STATIC
 # Any code provided here is inserted at the
 # top level of the generated subclass regardless
 # of the actual types used.
 END_STATIC

 # Enumerate as many MAPPING sections as needed.

 MAPPING
 SOURCETYPE <span class="italic">Java_source_type</span>
 # Can be mapped to several target types.
 TARGETTYPE <span class="italic">Java_target_type</span>

 # With CONDITION specified, the source-to-target
 # mapping is carried out only when the listed Java
 # classes are present during publishing. 
 # The CONDITION section is optional.
 CONDITION <span class="italic">list_of_java_classes</span>

 IN
 # Java code for performing the transformation
 # from source type argument %1 to the target
 # type, assigning it to %2.
 END_IN
 IN_AFTER_CALL
 # Java code for processing IN parameters
 # after procedure call.
 END_IN_AFTER_CALL
 OUT
 # Java code for performaing the transformation
 # from a target type instance %2 to the source
 # type, assigning it to %1.
 END_OUT
 RETURN
 # Java code for performing the transformation
 # from source type argument %1 to the target
 # type and returning the target type.
 END_RETURN

 # Include the code given by a DEFINE...END_DEFINE block
 # at the end of this template file.
 USE <span class="italic">defined_name</span>

 # Holder for OUT/INOUT of the type defined by SOURCETYPE.
 HOLDER <span class="italic">Java_holder_type</span>
 END_TARGETTYPE

 # More TARGETTYPE sections, as needed

 END_MAPPING

 DEFAULT_HOLDER
 # JPublisher will generate holders for types that do
 # not have HOLDER entries defined in this template.
 # This section includes a template for class definitions
 # from which JPublisher will generate .java files for
 # holder classes.
 END_DEFAULT_HOLDER

 # More MAPPING sections, as needed

 DEFINE <span class="italic">defined_name</span>
 # Any code provided here is inserted at the
 # top level of the generated class if the
 # source type is used.
 END_DEFINE
 # More DEFINE sections, as needed

END_TRANSFORMATION
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Style files use <code>ISO8859_1</code> encoding. Any characters that cannot be represented directly in this encoding must be represented in Unicode escape sequences.</p>
</li>
<li>
<p>It is permissible to have multiple <code>MAPPING</code> sections with the same <code>SOURCETYPE</code> specification. For argument type, JPublisher uses the last of these <code>MAPPING</code> sections that it encounters.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="genclint.htm#i1009336">&#34;Passing Output Parameters in JAX-RPC Holders&#34;</a> for a discussion of holders</div>
</div>
<!-- class="sect3" -->
<a id="CHDHFIFF"></a>
<div id="JJPUB24115" class="sect3">
<h4 class="sect3">Style File OPTIONS Section</h4>
<p>For convenience, you can specify any desired JPublisher option settings in the <code>OPTIONS</code> section of a style file, in the standard format for JPublisher properties files. The syntax for the same is as follows:</p>
<pre>OPTIONS
 # Comments
 jpub.<span class="italic">option1</span>=<span class="italic">value1</span>
 jpub.<span class="italic">option2</span>=<span class="italic">value2</span>
 ...
END_OPTIONS
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDGJBJG"></a>
<div id="JJPUB24116" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Sum<a id="sthref132"></a>mary of Key Java-to-Java Type Mappings in Oracle Style Files</h3>
<p>The Oracle style files <code>webservices-common.properties</code>, <code>webservices9.properties</code>, and <code>webservices10.properties</code>, through their <code>SOURCETYPE</code> and <code>TARGETTYPE</code> specifications, have a number of important Java-to-Java type mappings to support Web services and <code>REF CURSOR</code> mappings. These mappings are summarized in <a href="#CHDDABAA">Table 3-2</a>.</p>
<div id="JJPUB24117" class="tblformal">
<p class="titleintable"><a id="sthref133"></a><a id="CHDDABAA"></a>Table 3-2 Summary of Java-to-Java Type Mappings in Oracle Style Files</p>
<table class="cellalignment5694" title="Summary of Java-to-Java Type Mappings in Oracle Style Files" summary="Summary of Java-to-Java type mappings in Oracle style files." dir="ltr">
<thead>
<tr class="cellalignment5685">
<th class="cellalignment5692" id="r1c1-t34">Source Type</th>
<th class="cellalignment5692" id="r1c2-t34">Target Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r2c1-t34" headers="r1c1-t34">
<p><code>oracle.sql.NString</code></p>
</td>
<td class="cellalignment5693" headers="r2c1-t34 r1c2-t34">
<p><code>java.lang.String</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r3c1-t34" headers="r1c1-t34">
<p><code>oracle.sql.CLOB</code></p>
</td>
<td class="cellalignment5693" headers="r3c1-t34 r1c2-t34">
<p><code>java.lang.String</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r4c1-t34" headers="r1c1-t34">
<p><code>oracle.sql.BLOB</code></p>
</td>
<td class="cellalignment5693" headers="r4c1-t34 r1c2-t34">
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r5c1-t34" headers="r1c1-t34">
<p><code>oracle.sql.BFILE</code></p>
</td>
<td class="cellalignment5693" headers="r5c1-t34 r1c2-t34">
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r6c1-t34" headers="r1c1-t34">
<p><code>java.sql.Timestamp</code></p>
</td>
<td class="cellalignment5693" headers="r6c1-t34 r1c2-t34">
<p><code>java.util.Date</code></p>
</td>
</tr>
<tr class="cellalignment5685">
<td class="cellalignment5693" id="r7c1-t34" headers="r1c1-t34">
<p><code>java.sql.ResultSet</code></p>
</td>
<td class="cellalignment5693" headers="r7c1-t34 r1c2-t34">
<p><code>oracle.jdbc.rowset.OracleWebRowSet</code></p>
<p><code>org.w3c.dom.Document</code></p>
<p><code>javax.xml.transform.Source</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDIGIHC">&#34;REF CURSOR Types and Result Sets Mapping&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1010477"></a>
<div id="JJPUB24118" class="sect2">
<h3 class="sect2">Use of Multiple Style Files</h3>
<p>JPublisher allows multiple <code>-style</code> options on the command line, with the following behavior:</p>
<ul>
<li>
<p>The <code>OPTIONS</code> sections are concatenated.</p>
</li>
<li>
<p>The <code>TRANSFORMATION</code> sections are concatenated, except that the entries in the <code>MAPPING</code> sections are overridden, as applicable. A <code>MAPPING</code> entry from a style file specified later on the command line overrides a <code>MAPPING</code> entry with the same <code>SOURCETYPE</code> specification from a style file specified earlier on the command line.</p>
</li>
</ul>
<p>This functionality is useful if you want to overwrite type mappings defined earlier or add new type mappings. For example, if you want to map <code>SYS.XMLTYPE</code> to <code>java.lang.String</code>, then you can append the setting <code>-style=xml2string</code> to the JPublisher command line. This example assumes that the <code>./xml2string.properties</code> style file will be accessed. This style file is defined as follows:</p>
<pre>      OPTIONS
       jpub.defaulttypemap=SYS.XMLTYPE:oracle.xdb.XMLType
      END_OPTIONS
      TRANSFORM
      MAPPING
      SOURCETYPE oracle.xdb.XMLType
      TARGETTYPE java.lang.String
      # XMLType =&gt; String
      OUT
      %2 = null;
      if (%1!=null) %2=%1.getStringVal();
      END_OUT
      # String =&gt; XMLType
      IN
      %1 = null;
      if (%2!=null)
      {
        %1 = new %p.%c(_getConnection());
        %1 = %1.createXML(%2);
      }
      END_IN
      END_TARGETTYPE
      END_MAPPING
      END_TRANSFORM
</pre>
<p>Continuing this example, assume the following PL/SQL stored procedure definition:</p>
<pre>PROCEDURE foo (arg XMLTYPE);
</pre>
<p>JPublisher maps this as follows in the base class:</p>
<pre>void foo (arg oracle.xdb.XMLType);
</pre>
<p>And JPublisher maps it as follows in the user subclass:</p>
<pre>void foo (arg String);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
By default, JPublisher maps <code>SYS.XMLTYPE</code> to <code>oracle.xdb.XMLType</code>.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5684">
<tr>
<td class="cellalignment5693">
<table class="cellalignment5689">
<tr>
<td class="cellalignment5688"><a href="usejpub.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5688"><a href="adfeacon.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5696">
<table class="cellalignment5687">
<tr>
<td class="cellalignment5688"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5688"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5688"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5688"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5688"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5688"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>