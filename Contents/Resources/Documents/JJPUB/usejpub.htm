<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-71114"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Using%20JPublisher"></a><title>Using JPublisher</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-07T6:1:45Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database JPublisher User&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49873-02"/>
<meta name="dcterms.isVersionOf" content="JJPUB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="intro.htm" title="Previous" type="text/html"/>
<link rel="Next" href="datamap.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49873-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/14</span> <!-- End Header -->
<div id="JJPUB24073" class="chapter"><a id="CHDJFBEC"></a>
<h1 class="chapter"><span class="secnum">2</span> Using JPublisher</h1>
<p>This chapter describes how you can use JPublisher for:</p>
<ul>
<li>
<p><a href="#i1007505">Publishing User-Defined SQL Types</a></p>
</li>
<li>
<p><a href="#i1007510">Publishing PL/SQL Packages</a></p>
</li>
<li>
<p><a href="#BHCBIIDA">Publishing Oracle Streams AQ</a></p>
</li>
<li>
<p><a href="#i1008686">Publishing Server-Side Java Classes Through Native Java Interface</a></p>
</li>
<li>
<p><a href="#CHDDJJGB">Publishing Server-Side Java Classes Through PL/SQL Wrappers</a></p>
</li>
<li>
<p><a href="#CHDCIEIB">Publishing Server-Side Java Classes to PL/SQL</a></p>
</li>
<li>
<p><a href="#CHDJBCFB">Publishing Server-Side Java Classes to Table Functions</a></p>
</li>
<li>
<p><a href="#CHDGCHCA">Publishing Web Services Client into PL/SQL</a></p>
</li>
</ul>
<a id="i1007505"></a>
<div id="JJPUB24074" class="sect1">
<h2 class="sect1">Publish<a id="sthref80"></a><a id="sthref81"></a>ing User-Defined SQL Types</h2>
<p>Using JPublisher to publish SQL objects or collections as Java classes is straightforward. This section provides examples of this for the Order Entry (<code>OE</code>) schema, which is part of Oracle Database sample schema. If you do not have the sample schema installed, but have your own object types that you would like to publish, then replace the user name, password, and object names accordingly.</p>
<p>Assuming that the password for the <code>OE</code> schema is <code>OE</code>, use the following command to publish the <code>CATEGORY_TYP</code> SQL object type, where <code>%</code> is the system prompt:</p>
<pre>% jpub -user=OE -sql=CATEGORY_TYP:CategoryTyp
Enter OE password: <span class="italic">password</span>
</pre>
<p>The JPublisher <code>-user</code> option specifies the user name. The <code>-sql</code> option specifies the types to be published. The SQL type and Java class is separated by a colon (<code>:</code>). <code>CATEGORY_TYP</code> is the name of the SQL type, and <code>CategoryTyp</code> is the name of the corresponding Java class that is to be generated.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#i1009889">&#34;Declaration of Object Types and Packages to Translate&#34;</a>.</div>
<p>JPublisher echoes the names of the SQL types that it publishes to the standard output:</p>
<pre>OE.CATEGORY_TYP
</pre>
<p>In addition to the <code>CategoryTyp.java</code> file, JPublisher also generates the <code>CategoryTypeRef.java</code> file. This is a strongly typed wrapper class for SQL object references to <code>OE.CATEGORY_TYP</code>. Both these files can be compiled with the Java compiler, <code>javac</code>.</p>
<p>Another example of publishing SQL object types, in this case the <code>CUSTOMER_TYP</code> type, by using the shorthand <code>-u</code> for <code>&#34;-user=</code>&#34; and <code>-s</code> for &#34;<code>-sql=</code>&#34; is:</p>
<pre>% jpub -u OE -s CUSTOMER_TYP:CustomerTyp
Enter OE password: <span class="italic">password</span>
</pre>
<p>The options <code>-u</code> and <code>-s</code> are followed by a space and then the value.</p>
<p>JPublisher reports a list of SQL object types. Whenever it encounters an object type for the first time, whether through an attribute, an object reference, or a collection that has element types as objects or collections, it automatically generates a wrapper class for that type as well. The list of SQL object types for the <code>OE</code> schema are:</p>
<pre>OE.CUSTOMER_TYP
OE.CORPORATE_CUSTOMER_TYP
OE.CUST_ADDRESS_TYP
OE.PHONE_LIST_TYP
OE.ORDER_LIST_TYP
OE.ORDER_TYP
OE.ORDER_ITEM_LIST_TYP
OE.ORDER_ITEM_TYP
OE.PRODUCT_INFORMATION_TYP
OE.INVENTORY_LIST_TYP
OE.INVENTORY_TYP
OE.WAREHOUSE_TYP
</pre>
<p>Two source files are generated for each object type in this example: one for a Java class, such as <code>CustomerTyp</code>, to represent instances of the object type, and one for a reference class, such as <code>CustomerTypeRef</code>, to represent references to the object type.</p>
<p>Notice the naming scheme that JPublisher uses by default. For example, the <code>OE.PRODUCT_INFORMATION_TYP</code> SQL type is converted to a Java class, <code>ProductInformationTyp</code>.</p>
<p>Although JPublisher automatically generates wrapper classes for embedded types, it does not do so for subtypes of given object types. In this case, you have to explicitly enumerate all the subtypes that you want to have published. The <code>CATEGORY_TYP</code> type has three subtypes: <code>LEAF_CATEGORY_TYP</code>, <code>COMPOSITE_CATEGORY_TYP</code>, and <code>CATALOG_TYP</code>. The following is a single, wraparound JPublisher command line to publish the subtypes of the object type:</p>
<pre>% jpub  -u OE  -s COMPOSITE_CATEGORY_TYP:CompositeCategoryTyp
        -s LEAF_CATEGORY_TYP:LeafCategoryTyp,CATALOG_TYP:CatalogTyp
Enter OE password: <span class="italic">password</span>
</pre>
<p>JPublisher lists the processed types as output, as follows:</p>
<pre>OE.COMPOSITE_CATEGORY_TYP
OE.SUBCATEGORY_REF_LIST_TYP
OE.LEAF_CATEGORY_TYP
OE.CATALOG_TYP
OE.CATEGORY_TYP
OE.PRODUCT_REF_LIST_TYP
</pre>
<p>Keep in mind the following information:</p>
<ul>
<li>
<p>If you want to unparse several types, then you can list them all together in the <code>-sql</code> or <code>-s</code> option, each separated by a comma, or you can supply several <code>-sql</code> options on the command line.</p>
</li>
<li>
<p>Although JPublisher does not automatically generate wrapper classes for all subtypes, it <span class="italic">does</span> generate them for all supertypes.</p>
</li>
<li>
<p>For SQL objects with methods, such as <code>CATALOG_TYP</code>, JPublisher uses SQLJ classes to implement the wrapper methods. In Oracle Database 12<span class="italic">c</span>, the use of SQLJ classes, as opposed to regular Java classes, is invisible to you unless you use one of the backward-compatibility modes.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prior to Oracle Database 10<span class="italic">g</span>, the generation of SQLJ classes resulted in the creation of visible <code>.sqlj</code> source files. Starting from Oracle Database 10<span class="italic">g</span>, if you set the JPublisher <code>-compatible</code> flag to a value of <code>8i</code>, <code>both8i</code>, <code>9i</code>, or <code>sqlj</code>, then visible <code>.sqlj</code> source files will be generated.
<p>In any of these modes, you can use the JPublisher <code>-sqlj</code> option as an alternative to using the <code>sqlj</code> command-line utility to translate <code>.sqlj</code> files.</p>
</div>
<p>If the code that JPublisher generates does not provide the functionality or behavior you want, then you can extend generated wrapper classes to override or complement their functionality. Consider the following example:</p>
<pre>% jpub -u OE -s WAREHOUSE_TYP:JPubWarehouse:MyWarehouse
Enter OE password: <span class="italic">password</span>
</pre>
<p>The JPublisher output is:</p>
<pre>OE.WAREHOUSE_TYP
</pre>
<p>With this command, JPublisher generates both <code>JPubWarehouse.java</code> and <code>MyWarehouse.java</code>. The <code>JPubWarehouse.java</code> file is regenerated every time you rerun this command. The <code>MyWarehouse.java</code> generated file can be customized by you and will not be overwritten by future runs of this command. You can add new methods in <code>MyWarehouse.java</code> and override the method implementations from <code>JPubWarehouse.java</code>.</p>
<p>The class that is used to materialize <code>WAREHOUSE_TYP</code> instances in Java is the specialized <code>MyWarehouse</code> class. If you want user-specific subclasses for all types in an object type hierarchy, then you must specify <span class="italic">triplets</span> of the form <code><span class="codeinlineitalic">SQL_TYPE</span></code><code>:</code><code><span class="codeinlineitalic">JPubClass</span></code><code>:</code><code><span class="codeinlineitalic">UserClass</span></code>, for all members of the hierarchy, as shown in the preceding JPublisher command.</p>
<p>Once you have generated and compiled Java wrapper classes with JPublisher, you can use the object wrappers directly.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The preceding examples using the <code>OE</code> schema are for illustrative purposes only and may not be completely up-to-date regarding the composition of the schema.</div>
<p>The following SQLJ class calls a PL/SQL stored procedure. Assume that <code>register_warehouse</code> takes a <code>WAREHOUSE_TYP</code> instance as an <code>IN OUT</code> parameter. Code comments show the corresponding <code>#sql</code> command. By default, JPublisher generates and translates the SQLJ code automatically.</p>
<pre>java.math.BigDecimal location = new java.math.BigDecimal(10); 
java.math.BigDecimal warehouseId = new java.math.BigDecimal(10); 
MyWarehouse w = new MyWarehouse(warehouseId,&#34;Industrial Park&#34;,location); 
//  ************************************************************
//  #sql { call register_warehouse(:INOUT w) };
//  ************************************************************
//
// declare temps 
oracle.jdbc.OracleCallableStatement __sJT_st = null;
sqlj.runtime.ref.DefaultContext __sJT_cc = 
     sqlj.runtime.ref.DefaultContext.getDefaultContext();
if (__sJT_cc==null)
  sqlj.runtime.error.RuntimeRefErrors.raise_NULL_CONN_CTX(); 
sqlj.runtime.ExecutionContext.OracleContext __sJT_ec = 
     ((__sJT_cc.getExecutionContext()==null) ? 
          sqlj.runtime.ExecutionContext.raiseNullExecCtx() :
               __sJT_cc.getExecutionContext().getOracleContext()); 
try
{ 
  String theSqlTS = &#34;BEGIN register_warehouse( :1 ) \n; END;&#34;; 
  __sJT_st = __sJT_ec.prepareOracleCall(__sJT_cc,&#34;0RegisterWarehouse&#34;,theSqlTS); 
  if (__sJT_ec.isNew()) 
  { 
    __sJT_st.registerOutParameter(1,2002,&#34;OE.WAREHOUSE_TYP&#34;); 
  } 
  // set IN parameters 
  if (w==null) 
    __sJT_st.setNull(1,2002,&#34;OE.WAREHOUSE_TYP&#34;); 
  else __sJT_st.setORAData(1,w); 
    // execute statement 
    __sJT_ec.oracleExecuteUpdate(); 
  // retrieve OUT parameters 
  w = (MyWarehouse)__sJT_st.getORAData(1,MyWarehouse.getORADataFactory()); 
}
finally
{
  __sJT_ec.oracleClose();
} 
</pre>
<p>In Java Database Connectivity (JDBC), you typically register the relationship between the SQL type name and the corresponding Java class in the type map for your connection instance. This is required once for each connection. This type mapping can be done as shown in the following example:</p>
<pre>java.util.Map typeMap = conn.getTypeMap();
typeMap.put(&#34;OE.WAREHOUSE_TYP&#34;, MyWarehouse.class);
conn.setTypeMap(typeMap);
</pre>
<p>The following JDBC code is equivalent to the JPublisher output, that is, the translated SQLJ code, shown previously:</p>
<pre>CallableStatement cs = conn.prepareCall(&#34;{call register_warehouse(?)}&#34;);
((OracleCallableStatement)cs).registerOutParameter
                 (1,oracle.jdbc.OracleTypes.STRUCT,&#34;OE.WAREHOUSE_TYP&#34;);
cs.setObject(w);
cs.executeUpdate();
w = cs.getObject(1);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007510">&#34;Publishing PL/SQL Packages&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="i1007510"></a>
<div id="JJPUB24075" class="sect1">
<h2 class="sect1">Publis<a id="sthref82"></a><a id="sthref83"></a>hing PL/SQL Packages</h2>
<p>In addition to mapping SQL objects, you may want to encapsulate entire PL/SQL packages as Java classes. JPublisher offers functionality to create Java wrapper methods for the stored procedures of a PL/SQL package.</p>
<p>However, the concept of representing PL/SQL stored procedures as Java methods presents a problem. Arguments to the PL/SQL functions and procedures may use the PL/SQL <code>OUT</code> or <code>IN OUT</code> mode, but there are no equivalent modes for passing arguments in Java. A method that takes an <code>int</code> argument, for example, is not able to modify this argument in such a way that its callers can receive a new value for it. As a workaround, JPublisher can generate single-element arrays for <code>OUT</code> and <code>IN OUT</code> arguments. For example, consider an integer array <code>int[] abc</code>. The input value is provided in <code>abc[0]</code>, and the modified output value is also returned in <code>abc[0]</code>. JPublisher also uses a similar pattern when generating code for SQL object type methods.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If your stored procedures use types that are specific to PL/SQL and are not supported by Java, then special steps are required to map these arguments to SQL and then to Java.</div>
<p>The following command publishes the <code>SYS.DBMS_LOB</code> package into Java:</p>
<pre>% jpub -u hr -s SYS.DBMS_LOB:DbmsLob
Enter hr password: <span class="italic">password</span>
</pre>
<p>The JPublisher output is:</p>
<pre>SYS.DBMS_LOB
</pre>
<p>Because <code>DBMS_LOB</code> is publicly visible, you can access it from a different schema, such as <code>HR</code>. Note that this JPublisher invocation creates a SQLJ class in <code>DbmsLob.java</code> that contains the calls to the PL/SQL package. The generated Java methods are actually the instance methods. The idea is that you create an instance of the package using a JDBC connection or a SQLJ connection context and then call the methods on that instance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="genclint.htm#i1009229">&#34;Treatment of Output Parameters&#34;</a> and <a href="datamap.htm#i1005880">&#34;Support for PL/SQL Data Types&#34;</a></div>
<p class="subhead2"><a id="JJPUB24076"></a>Use of Object Types Instead of Java Primitive Numbers</p>
<p>When you examine the generated code, notice that JPublisher has generated <code>java.lang.Integer</code> as arguments to various methods. Using Java object types, such as <code>Integer</code>, instead of Java primitive types, such as <code>int</code>, permits you to represent SQL <code>NULL</code> values directly as Java <code>null</code>s, and JPublisher generates these by default. However, for the <code>DBMS_LOB</code> package, <code>int</code> is preferable over the <code>Integer</code> object type. The following modified JPublisher invocation accomplishes this through the <code>-numbertypes</code> option:</p>
<pre>% jpub -numbertypes=jdbc  -u hr  -s SYS.DBMS_LOB:DbmsLob
Enter hr password: <span class="italic">password</span>
</pre>
<p>The JPublisher output is:</p>
<pre>SYS.DBMS_LOB
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#i1010729">&#34;Mappings for Numeric Types&#34;</a></div>
<p class="subhead2"><a id="JJPUB24077"></a>Wrapper Class for Procedures at the SQL Top Level</p>
<p>JPublisher also enables you to generate a wrapper class for the functions and procedures at the SQL top level. Use the special package name <code>TOPLEVEL</code>, as in the following example:</p>
<pre>% jpub  -u hr  -s TOPLEVEL:SQLTopLevel
Enter hr password: <span class="italic">password</span>
</pre>
<p>The JPublisher output is:</p>
<pre>HR.<span class="italic">top-level_scope</span>
</pre>
<p>A warning appears if there are no stored functions or procedures in the SQL top-level scope.</p>
</div>
<!-- class="sect1" -->
<a id="BHCBIIDA"></a>
<div id="JJPUB24078" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Publishing <a id="sthref84"></a><a id="sthref85"></a>Oracle Streams AQ</h2>
<p>Publishing Oracle Streams Advanced Queue (AQ) as Java classes is similar to publishing PL/SQL stored procedures. JPublisher exposes a queue as a Java program using AQ Java Message Service (JMS) application programming interfaces (APIs). This Java program can be further published into Web services by the Web services assembler. You can perform the following:</p>
<ul>
<li>
<p><a href="#BHCIAJEF">Publishing a Queue as a Java Class</a></p>
</li>
<li>
<p><a href="#CHDIEAEB">Publishing a Topic as a Java Class</a></p>
</li>
<li>
<p><a href="#BHCFCHHG">Publishing a Stream as a Java Class</a></p>
</li>
</ul>
<p>Oracle Streams AQ can be categorized into queue, topic, and stream. A queue is a one-to-one message channel with a declared payload type. A topic is a one to many message channel with a declared payload type. A stream is a queue or topic with <code>SYS.ANYDATA</code> as the payload type.</p>
<p>You can publish a queue, topic, or stream using the <code>-sql</code> option as follows:</p>
<pre>%jpub -user=hr -sql=<span class="italic">AQNAME</span>:<span class="italic">javaName</span>
Enter hr password: <span class="italic">password</span>
</pre>
<p><code><span class="codeinlineitalic">AQNAME</span></code> is the name of a queue table, queue, topic, or stream. <code><span class="codeinlineitalic">javaName</span></code> is the name of the corresponding Java class.</p>
<p>In Microsoft Windows, you must add the following Java Archive (JAR) files to <code>CLASSPATH</code> for JPublisher to publish a queue. These two files are required for the running of the JPublisher-generated code for Oracle Streams AQ.</p>
<pre><span class="italic">ORACLE_HOME</span>/rdbms/jlib/jmscommon.jar
<span class="italic">ORACLE_HOME</span>/rdbms/jlib/aqapi.jar
</pre>
<p>On UNIX systems, the <code>jpub</code> script distributed with Oracle Database 12<span class="italic">c</span> Release 1 includes these JAR files.</p>
<p>For Oracle Streams AQ, the usage of the <code>-sql</code> option is the same as SQL types and PL/SQL stored procedures. You can specify subclasses and interfaces. Other options available to SQL types and PL/SQL packages, such as <code>-genpattern</code>, <code>-style</code>, <code>-builtintypes</code>, and <code>-compatible</code>, are also available with Oracle Streams AQ.</p>
<a id="BHCIAJEF"></a>
<div id="JJPUB24079" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Publishing<a id="sthref86"></a> a Queue as a Java Class</h3>
<p>You can publish a queue using the same settings that are used for publishing a SQL type or PL/SQL stored procedure.</p>
<p>Consider a queue, <code>toy_queue</code>, declared as follows:</p>
<pre>CREATE TYPE hr.queue_message AS OBJECT (
  Subject VARCHAR2(30),
  Text VARCHAR2(80)
);
dbms_aqadm.create_queue_table (
  Queue_table =&gt; &#39;hr.queue_queue_table&#39;,
  Queue_payload_type =&gt; &#39;hr.queue_message&#39;
);
dbms_aqadm.create_queue (
  queue_name  =&gt; &#39;hr.toy_queue&#39;,
  queue_table =&gt; &#39;hr.queue_queue_table&#39;
);
dbms_aqadm.start_queue (
  queue_name =&gt; &#39;hr.toy_queue&#39;
);
</pre>
<p>The following command publishes <code>toy_queue</code> as a Java program:</p>
<pre>% jpub  -user=hr  -sql=toy_queue:ToyQueue
Enter hr password: <span class="italic">password</span>
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
When creating a queue or topic, you can specify a SQL type as the payload type. The payload type is transformed into and from the JMS message types.</div>
<p>The command generates <code>ToyQueue.java</code>, with the following APIs:</p>
<pre>public class ToyQueue
{
   public ToyQueue();
   public ToyQueue(java.sql.Connection conn);
   public ToyQueue(javax.sql.DataSource dataSource);
   public void setConnection(java.sql.Connection conn);
   public void setDataSource(javax.sql.DataSource ds);
   public void addTypeMap(String sqlName, String javaName);
   public void send(QueueMessage payload);
   public QueueMessage receive();
   public QueueMessage receiveNoWait();
   public QueueMessage receive(java.lang.String selector, boolean noWait);
}
</pre>
<p>Like for PL/SQL stored procedures, JPublisher generates connection and data source management APIs, such as <code>setConnection()</code> and <code>setDataSource()</code>. The <code>addTypeMap()</code> method enables you to specify type mapping if the payload type is a SQL type hierarchy. The <code>send()</code> method enqueues a message. The <code>receive()</code> method dequeues a message from the queue. This method blocks until a message is available to dequeue. The <code>receiveNoWait()</code> method dequeues a message and returns <code>null</code> if no message is available. The last <code>receive()</code> method in the <code>ToyQueue</code> class dequeues a message satisfying the selector. The selector is a condition specified in the AQ convention. For example, consider the condition:</p>
<pre>priority &gt; 3 and Subject IN (&#39;spider&#39;,&#39;tank&#39;) 
</pre>
<p>This selects messages with priority higher than <code>3</code> and with <code>spider</code> and <code>tank</code> as the <code>Subject</code> attribute.</p>
<p><code>QueueMessage</code> is a subclass of <code>ORAData</code> and is generated for the <code>queue_message</code> payload type, which is a SQL type published as the result of publishing the queue.The following sample client code uses the generated <code>ToyQueue</code> class. The client code sends a message to the queue, dequeues the queue using the block operator <code>receive()</code>, and continues dequeuing messages using <code>receiveNoWait()</code>, until all messages in the queue are dequeued.</p>
<pre>...
ToyQueue q = new ToyQueue(getConnection());
QueueMessage m = new QueueMessage(&#34;scooby doo&#34;, &#34;lights out&#34;);
q.send(m);
System.out.println(&#34;Message sent: &#34; + m.getSubject() + &#34; &#34; + m.getText());
m = new QueueMessage(&#34;dalmatian&#34;, &#34;solve the puzzle&#34;);
q.send(m);
System.out.println(&#34;Message sent: &#34; + m.getSubject() + &#34; &#34; + m.getText());
m = q.receive();
while (m!=null)
{
  System.out.println(&#34;Message received: &#34; + m.getSubject() + &#34; &#34; + m.getText());
  m = q.receiveNoWait();
}
...
</pre></div>
<!-- class="sect2" -->
<a id="CHDIEAEB"></a>
<div id="JJPUB24080" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Publishing<a id="sthref87"></a> a Topic as a Java Class</h3>
<p>Consider a topic declared as follows:</p>
<pre>CREATE TYPE hr.topic_message AS OBJECT (
  Subject VARCHAR2(30),
  Text VARCHAR2(80)
);
dbms_aqadm.create_queue_table (
  Queue_table =&gt; &#39;hr.topic_queue_table&#39;,
  Multiple_consumers =&gt; TRUE,
  Queue_payload_type =&gt; &#39;hr.topic_message&#39;
);
dbms_aqadm.create_queue (
  queue_name  =&gt; &#39;hr.toy_topic&#39;,
  queue_table =&gt; &#39;hr.topic_queue_table&#39;
);
dbms_aqadm.start_queue (
  queue_name =&gt; &#39;hr.toy_topic&#39;
);
</pre>
<p>The queue table, <code>topic_queue_table</code>, has the <code>Multiple_consumers</code> property set to <code>TRUE</code>, indicating that the queue table hosts topics instead of queues.</p>
<p>You can publish the topic as follows:</p>
<pre>% jpub -user=hr -sql=toy_topic:ToyTopic
Enter hr password: <span class="italic">password</span>
</pre>
<p>The command generates <code>ToyTopic.java</code> with the following APIs:</p>
<pre>public class ToyTopic
{
  public ToyTopic(javax.sql.DataSource dataSource);
  public void setConnection(java.sql.Connection conn);
  public void setDataSource(javax.sql.DataSource ds);
  public void addTypeMap(String sqlName,String javaName);
  public void publish(TopicMessage payload);
  public void publish(TopicMessage payload, java.lang.String[] recipients);
  public void publish(TopicMessage payload, int deliveryMode, int priority,
        long timeToLive);
  public void subscribe(java.lang.String subscriber);
  public void unsubscribe(java.lang.String subscriber);
  public TopicMessage receiveNoWait(java.lang.String receiver);
  public TopicMessage receive(java.lang.String receiver);
  public TopicMessage receive(java.lang.String receiver,
        java.lang.String selector);
}
</pre>
<p>The <code>publish</code> methods enqueue a message addressed to all the subscribers or a list of subscribers. The <code>deleveryMode</code> parameter takes the value <code>javax.jms.DeliveryMode.PERSISTENT</code> or <code>javax.jms.DeliveryMode.NON_PERSISTENT</code>. However, only <code>DeliveryMode.PERSISTENT</code> is supported in Oracle Database 10<span class="italic">g</span> release 2 (10.2). The <code>priority</code> parameter specifies the priority of the message. The <code>timeToLive</code> parameter specifies the time in milliseconds after which the message will be timed out. A value of <code>0</code> indicates the message is not timed out.The <code>receive</code> methods dequeue a message addressed to the specified receiver.The following sample client code uses the generated <code>ToyTopic</code> class. The client sends a message to two receivers, <code>ToyParty</code> and <code>ToyFactory</code>, and then dequeues the topic as <code>ToyParty</code>, <code>ToyLand</code>, and <code>ToyFactory</code> respectively.</p>
<pre>...
ToyTopic topic = new ToyTopic(getConnection());
TopicMessage m = new TopicMessage(&#34;scooby doo&#34;, &#34;lights out&#34;);

topic.publish(m, new String[]{&#34;ToyParty&#34;, &#34;ToyFactory&#34;});
System.out.println(&#34;Message broadcasted: &#34; + m.getSubject() + &#34; &#34; + m.getText());
m = new TopicMessage(&#34;dalmatian&#34;, &#34;solve the puzzle&#34;);
topic.publish(m, new String[]{&#34;ToyParty&#34;, &#34;ToyLand&#34;});
System.out.println(&#34;Message broadcasted: &#34; + m.getSubject() + &#34; &#34; + m.getText());

m = topic.receive(&#34;ToyParty&#34;);
System.out.println(&#34;ToyParty receive &#34; + m.getSubject() + &#34; &#34; + m.getText());
m = topic.receive(&#34;ToyParty&#34;);
System.out.println(&#34;ToyParty receive &#34; + m.getSubject() + &#34; &#34; + m.getText());

m = topic.receiveNoWait(&#34;ToyLand&#34;);
System.out.println(&#34;ToyFactory receive &#34; + m.getSubject() + &#34; &#34; + m.getText());
m = topic.receiveNoWait(&#34;ToyFactory&#34;);
System.out.println(&#34;ToyFactory receive &#34; + m.getSubject() + &#34; &#34; + m.getText());
m = topic.receiveNoWait(&#34;ToyFactory&#34;);
...
</pre></div>
<!-- class="sect2" -->
<a id="BHCFCHHG"></a>
<div id="JJPUB24081" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Publishing<a id="sthref88"></a> a Stream as a Java Class</h3>
<p>A stream is a special case of AQ. It can have only <code>SYS.ANYDATA</code> as the payload type. As a limitation, JPublisher-generated code for streams requires the JDBC Oracle Call Interface (OCI) driver. However, the code generated for queue and topic run on both the JDBC Thin and JDBC OCI driver.</p>
<p>Publishing a stream is similar to publishing an AQ. The following command will publish the stream, <code>toy_stream</code>:</p>
<pre>% jpub  -user=hr  -sql=toy_stream:ToyStream
Enter hr password: <span class="italic">password</span>
</pre>
<p>This command generates the <code>ToyStream.java</code> file.</p>
<p>The difference between publishing a stream and an AQ or a topic is that when a stream is published, the payload type will always be <code>SYS.ANYDATA</code>, which is mapped to <code>java.lang.Object</code>.</p>
<p>The <code>ToyStream.java</code> file contains the following APIs:</p>
<pre>public class ToyStream
{
  public ToyStream();
  public ToyStream(java.sql.Connection conn);
  public ToyStream(javax.sql.DataSource dataSource);
  public void setConnection(java.sql.Connection conn);
  public void setDataSource(javax.sql.DataSource ds);
  public void addTypeMap(String sqlName, String javaName);
  public void publish(Object payload);
  public void publish(Object payload, java.lang.String[] recipients);
  public void publish(Object payload, int deliveryMode, 
         int priority, long timeToLive);
  public void subscribe(java.lang.String subscriber);
  public void unsubscribe(java.lang.String subscriber);
  public Object receiveNoWait(java.lang.String receiver);
  public Object receive(java.lang.String receiver);
  public Object receive(java.lang.String receiver, java.lang.String selector);
  public Object receive(java.lang.String receiver, java.lang.String selector, 
         long timeout);
}
</pre>
<p>Here is a sample code that uses the generated <code>ToyStream</code> class:</p>
<pre>...
System.out.println(&#34;*** testStream with an OCI connection&#34;);
Object response = null;
ToyStream stream = new ToyStream(getOCIConnection());

stream.publish(&#34;Seaside news&#34;, new String[]{&#34;ToyParty&#34;});
response = stream.receive(&#34;ToyParty&#34;);
System.out.println(&#34;Received: &#34; + response);

stream.publish(new Integer(333), new String[]{&#34;ToyParty&#34;});
response = stream.receive(&#34;ToyParty&#34;);
System.out.println(&#34;Received: &#34; + response);

stream.publish(new Float(3.33), new String[]{&#34;ToyParty&#34;});
response = stream.receive(&#34;ToyParty&#34;);
System.out.println(&#34;Received: &#34; + response);

stream.publish(&#34;Science Monitor&#34;.getBytes(), new String[]{&#34;ToyParty&#34;});
response = stream.receive(&#34;ToyParty&#34;);
System.out.println(&#34;Received: &#34; + new String((byte[])response));

stream.publish(new String[]{&#34;gamma&#34;, &#34;beta&#34;}, new String[]{&#34;ToyParty&#34;});
response = stream.receive(&#34;ToyParty&#34;);
System.out.println(&#34;Received: &#34; + ((String[]) response)[0]);

HashMap map = new HashMap();
map.put(&#34;US&#34;, &#34;dollar&#34;);
map.put(&#34;Japan&#34;, &#34;yen&#34;);
map.put(&#34;Austrilia&#34;, &#34;dollar&#34;);
map.put(&#34;Britian&#34;, &#34;pound&#34;);
stream.publish(map, new String[]{&#34;ToyParty&#34;});
response = stream.receive(&#34;ToyParty&#34;);
map = (HashMap) response;
System.out.println(&#34;Message received: &#34; + map.get(&#34;Britian&#34;) + &#34;, &#34; + map.get(&#34;US&#34;) + &#34;, &#34; + map.get(&#34;Austrilia&#34;));

stream.addTypeMap(&#34;HR.QUEUE_MESSAGE&#34;, &#34;queue.wrapper.simple.QueueMessage&#34;);
stream.addTypeMap(&#34;QUEUE_MESSAGE&#34;, &#34;queue.wrapper.simple.QueueMessage&#34;);
QueueMessage m = new QueueMessage(&#34;Knowing&#34;, &#34;world currency&#34;);
stream.publish(m, new String[]{&#34;ToyParty&#34;});
response = stream.receive(&#34;ToyParty&#34;);
System.out.println(response);
m = (QueueMessage) response;
System.out.println(&#34;Message received: &#34; + m.getSubject() + &#34; &#34; + m.getText());
...
</pre>
<p>The sample code sends messages of various types, such as <code>String</code>, <code>Integer</code>, and <code>java.util.Map</code>. For the <code>QueueMessage</code> JDBC custom type, the <code>addTypeMap()</code> method is called to specify SQL type to Java type mapping.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008686"></a>
<div id="JJPUB24000" class="sect1">
<h2 class="sect1"><a id="sthref89"></a><a id="sthref90"></a>Publishing Server-Side Java Classes Through Native Java Interface</h2>
<p>Prior to Oracle Database 10<span class="italic">g</span>, calling Java stored procedures and functions from a database client required JDBC calls to the associated PL/SQL wrappers. Each PL/SQL wrapper had to be manually published with a SQL signature and a Java implementation. This process had the following disadvantages:</p>
<ul>
<li>
<p>The signatures permitted only Java types that had direct SQL equivalents.</p>
</li>
<li>
<p>Exceptions issued in Java were not properly returned.</p>
</li>
</ul>
<p>Starting from Oracle Database 10<span class="italic">g</span>, you can use the <a id="sthref91"></a>native Java interface feature for calls to server-side Java code. The JPublisher <code>-java</code> option provides functionality to overcome these disadvantages.</p>
<p>To remedy the deficiencies of JDBC calls to associated PL/SQL wrappers, the <code>-java</code> option makes use of an API for direct invocation of static Java methods. This functionality is also useful for Web services.</p>
<p>The functionality of the <code>-java</code> option mirrors that of the <code>-sql</code> option, creating a client-side Java stub class to access a server-side Java class. This is in contrast to creating a client-side Java class to access a server-side SQL object or PL/SQL package. The client-side stub class uses SQL code that mirrors the server-side class and includes the following features:</p>
<ul>
<li>
<p>Methods corresponding to the public, static methods of the server class</p>
</li>
<li>
<p>Two constructors, one that takes a JDBC connection and one that takes the SQLJ default connection context instance</p>
</li>
</ul>
<p>At run time, the stub class is instantiated with a JDBC connection. Calls to its methods result in calls to the corresponding methods of the server-side class. Any Java types used in these published methods must be primitive or serializable.</p>
<p>You can use the <code>-java</code> option to publish a server-side Java class, as follows:</p>
<pre>-java=<span class="italic">className</span>
</pre>
<p>Consider the <code>oracle.sqlj.checker.JdbcVersion</code> server-side Java class, with the following APIs:</p>
<pre>public class oracle.sqlj.checker.JdbcVersion
{
  public oracle.sqlj.checker.JdbcVersion();
  public static int getDriverMajorVersion();
  public static int getDriverMinorVersion();
  public static java.lang.String getDriverName();
  public static java.lang.String getDriverVersion();
  public static java.lang.String getJdbcLibraryName();
  public static java.lang.String getRecommendedRuntimeZip();
  public static java.lang.String getRuntimeVersion();
  public static java.lang.String getSqljLibraryName();
  public static boolean hasNewStatementCache();
  public static boolean hasOracleContextIsNew();
  public static boolean hasOracleSavepoint();
  public static void main(java.lang.String[]);
  public java.lang.String toString();
  public static java.lang.String to_string();
}
</pre>
<p>As an example, assume that you want to call the following method on the server:</p>
<pre>public String oracle.sqlj.checker.JdbcVersion.to_string();
</pre>
<p>Use the following command to publish <code>JdbcVersion</code> for client-side invocation:</p>
<pre>% jpub -sql=hr -java=oracle.sqlj.checker.JdbcVersion:JdbcVersionClient
Enter hr password: <span class="italic">password</span>
</pre>
<p>This command generates the client-side Java class, <code>JdbcVersionClient</code>, which contains the following APIs:</p>
<pre>public class JdbcVersionClient
{
  public long newInstance();
  public JdbcVersionClient();
  public JdbcVersionClient(java.sql.Connection conn);
  public JdbcVersionClient(sqlj.runtime.ref.DefaultContext ctx);
  public java.lang.String toString(long _handle);
  public int getDriverMajorVersion();
  public int getDriverMinorVersion();
  public java.lang.String getDriverName();
  public java.lang.String getDriverVersion();
  public java.lang.String getJdbcLibraryName();
  public java.lang.String getRecommendedRuntimeZip();
  public java.lang.String getRuntimeVersion();
  public java.lang.String getSqljLibraryName();
  public boolean hasNewStatementCache();
  public boolean hasOracleContextIsNew();
  public boolean hasOracleSavepoint();
  public void main(java.lang.String[] p0);
  public java.lang.String to_string();
}
</pre>
<p>Compare <code>oracle.sqlj.checker.JdbcVersion</code> with <code>JdbcVersionClient</code>. All static methods are mapped to instance methods in the client-side code. A instance method in the server-side class, <code>toString()</code> for example, is mapped to a method with an extra handle. A handle represents an instance of <code>oracle.sqlj.checker.JdbcVersion</code> in the server. The handle is used to call the instance method on the server-side. The extra method in <code>JdbcVersionClient</code> is <code>newInstance()</code>, which creates a new instance of <code>oracle.sqlj.checker.JdbcVersion</code> in the server and returns its handle.</p>
<p>Publishing the server-side Java class has the following constraints:</p>
<ul>
<li>
<p>Instance methods can be published only if the class to be published has a <code>public</code> empty constructor.</p>
</li>
<li>
<p>Only serializable parameter and return types are supported. Methods with nonserializable types will not be published.</p>
</li>
<li>
<p>Oracle Database 12<span class="italic">c</span> or Oracle Database 10<span class="italic">g</span> is required.</p>
</li>
</ul>
<p>Starting Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.2), the -java feature requires the following reparation step:</p>
<p>Load sqljutl.jar and sqljutls.sql into the user schema where the server-side Java classes are present.</p>
<pre>% loadjava -u scott/tiger -r -v -f sqlj/lib/sqljutl.jar
% sqlplus scott/tiger @jpub/sql/sqljutl2.sql
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#i1012848">&#34;Declaration of Server-Side Java Classes to Publish&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="CHDDJJGB"></a>
<div id="JJPUB24082" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Publishing Server-Side Java Classes Through PL/SQL Wrappers</h2>
<p>Since Oracle Database 10<span class="italic">g</span> release 2 (10.2), JPublisher provides a new approach to publish server-side Java classes. It generates the following to call server-side Java:</p>
<ul>
<li>
<p>Java stored procedure wrapper for the server-side class</p>
</li>
<li>
<p>PL/SQL wrapper for the Java stored procedure wrapper</p>
</li>
<li>
<p>Client-side Java code to call the PL/SQL wrapper</p>
</li>
</ul>
<p>The Java stored procedure wraps the server-side Java code, which accomplishes the following:</p>
<ul>
<li>
<p>Wraps an instance method into a static method. Each method in the server-side Java code is wrapped by a static method. An instance method can be mapped in a single or multiple-instance fashion.</p>
</li>
<li>
<p>Converts Java types into types that can be exposed to the PL/SQL call specification. For example, the Java type <code>byte[]</code> is converted into <code>oracle.sql.BLOB</code>.</p>
</li>
</ul>
<p>The PL/SQL wrapper calls the Java stored procedure. The client-side Java code calls the PL/SQL wrapper through JDBC calls. The <code>-java</code> option requires that the class to be exposed is already loaded into the database.</p>
<p>The supported Java types are:</p>
<ul>
<li>
<p>JDBC supported types</p>
</li>
<li>
<p>Java beans</p>
</li>
<li>
<p>Arrays of supported types</p>
</li>
<li>
<p>Serializable types</p>
</li>
</ul>
<p>To publish a server-side class, use the <code>-dbjava</code> option, as follows:</p>
<pre>-dbjava=<span class="italic">server-sideClassName</span>:<span class="italic">client-sideClassName</span>
</pre>
<p>The <code><span class="codeinlineitalic">client-sideClassName</span></code> setting must be specified. Otherwise, JPublisher will not generate client-side Java class. To publish <code>oracle.sqlj.checker.JdbcVersion</code>, use the following command:</p>
<pre>% jpub -user=hr -dbjava=oracle.sqlj.checker.JdbcVersion:JdbcVersionClient
Enter hr password: <span class="italic">password</span>
</pre>
<p>The command generates the following output:</p>
<pre>oracle/sqlj/checker/JdbcVersionJPub.java
plsql_wrapper.sql
plsql_dropper.sql
HR.JPUBTBL_VARCHAR2
HR.JPUB_PLSQL_WRAPPER
Executing plsql_dropper.sql
Executing plsql_wrapper.sql
Loading JdbcVersionJPub.java
</pre>
<p>The command generates the <code>JdbcVersionJPub</code> Java stored procedure, the PL/SQL wrapper, and the client-side <code>JdbcVersionClient</code> class. <code>JdbcVersionJPub.java</code> and <code>plsql_wrapper.sql</code> are automatically loaded into the database. <code>JdbcVersionClient</code> has the following APIs:</p>
<pre>public class JdbcVersionClient
{
  public JdbcVersionClient();
  public JdbcVersionClient(java.sql.Connection conn);
  public void setConnection(java.sql.Connection conn);
  public void setDataSource(javax.sql.DataSource ds);
  public String toString0();
  public java.math.BigDecimal getDriverMajorVersion();
  public java.math.BigDecimal getDriverMinorVersion();
  public String getDriverName();
  public String getDriverVersion();
  public String getJdbcLibraryName();
  public String getRecommendedRuntimeZip();
  public String getRuntimeVersion();
  public String getSqljLibraryName();
  public java.math.BigDecimal hasNewStatementCache();
  public java.math.BigDecimal hasOracleContextIsNew();
  public java.math.BigDecimal hasOracleSavepoint();
  public void main0(JpubtblVarchar2 arg0);
  public String to_string();
}
</pre>
<p>Compare <code>JdbcVersion</code> and <code>JdbcVersionClient</code>. It shows a limitation of JPublisher-generated code. The generated client-side APIs are not exactly the same as the original server-side APIs. To illustrate this limitation, the following is a list of several inconsistencies between <code>JdbcVersion</code> and <code>JdbcVersionClient</code>:</p>
<ul>
<li>
<p>The static methods are all mapped to instance methods, because a client-side method requires a JDBC connection to run.</p>
</li>
<li>
<p>A client-side method always throws <code>java.sql.SQLException</code>, while exceptions thrown from the server-side class will be passed to the client wrapped with <code>SQLException</code>.</p>
</li>
<li>
<p>The <code>toString()</code> method is renamed to <code>toString0()</code>. This is a limitation imposed by the stored procedure wrapper, where any method overwriting <code>java.lang.Object</code> methods has to be renamed to avoid conflicts.</p>
</li>
<li>
<p>The parameter and return types may be different. Numeric types in the server-side are mapped to <code>java.math.BigDecimal</code>. Array types, such as <code>String[]</code>, are mapped to JDBC custom types. For example, the parameter of <code>main()</code> is mapped to <code>JpubtblVarchar2</code>, a subclass of <code>ORAData</code>, which the JPublisher command generates to represent an array of strings.</p>
</li>
<li>
<p>The <code>main()</code> method in the server-side Java class will be renamed to <code>main0()</code>, due to the Java stored procedure limitation.</p>
</li>
</ul>
<p>Compared to <code>-java</code>, the advantage of <code>-dbjava</code> is the support for more types and working with pre-10<span class="italic">g</span> database versions. However, the disadvantages are extra PL/SQL and Java stored procedure layers at run time and the increased possibility of change in the method signature in the client-side Java class.</p>
<p>Starting Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.2), the -dbjava feature requires the following preparation step:</p>
<p>Load sqljutl.jar and sqljutls.sql into the user schema where the server-side java classes are present.</p>
<pre>% loadjava -u scott/tiger -r -v -f sqlj/lib/sqljutl.jar
% sqlplus scott/tiger @jpub/sql/sqljutl2.sql
</pre></div>
<!-- class="sect1" -->
<a id="CHDCIEIB"></a>
<div id="JJPUB24083" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Publishing Server-Side Java Classes to PL/SQL</h2>
<p>JPublisher can generate PL/SQL wrappers for server-side Java classes. A Java class is mapped to a PL/SQL package. Each PL/SQL method corresponds to a Java method. This feature relieves the customer from writing the PL/SQL call specification and creating SQL types used in the call specification.</p>
<p>You can use the <code>-dbjava</code> option to generate the PL/SQL wrapper for a server-side Java class as follows:</p>
<pre>-dbjava=<span class="italic">server-sideJavaClass</span>
</pre>
<p>Do <span class="italic">not</span> specify a name after <code><span class="codeinlineitalic">server-sideJavaClass</span></code>. Otherwise, JPublisher will map the server-side Java class to a client-side Java class.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDDJJGB">&#34;Publishing Server-Side Java Classes Through PL/SQL Wrappers&#34;</a></div>
<p>As an example, generate the PL/SQL wrapper for <code>oracle.sqlj.checker.JdbcVersion</code> using the following command:</p>
<pre>% java -dbjava=oracle.sqlj.checker.JdbcVersion
</pre>
<p>The command generates the following output:</p>
<pre>oracle/sqlj/checker/JdbcVersionJPub.java
plsql_wrapper.sql
plsql_dropper.sql
Executing plsql_dropper.sql
Executing plsql_wrapper.sql
Loading JdbcVersionJPub.java
</pre>
<p>The command generates and loads the Java stored procedure wrapper, <code>JdbcVersionJPub.java</code>, and also its PL/SQL wrapper, <code>plsql_wrapper.sql</code>, which declares the package <code>JPUB_PLSQL_WRAPPER</code>. The <code>JPUB_PLSQL_WRAPPER</code> package can be used to call the methods of <code>oracle.sqlj.checker.JdbcVersion</code>.</p>
<p>It often makes sense to specify <code>-plsqlfile</code> and <code>-plsqlpackage</code> with <code>-dbjava</code>. Consider the following command:</p>
<pre>% java -dbjava=oracle.sqlj.checker.JdbcVersion -plsqlfile=jdbcversion.sql -plsqlpackage=jdbcversion
</pre>
<p>The command generates the following output:</p>
<pre>oracle/sqlj/checker/JdbcVersionJPub.java
jdbcversion.sql
jdbcversion_dropper.sql
Executing jdbcversion_dropper.sql
Executing jdbcversion.sql
Loading JdbcVersionJPub.java
</pre>
<p>The command generates <code>jdbcversion.sql</code>, which declares the <code>jdbcversion</code> PL/SQL package as the wrapper for <code>oracle.sqlj.checker.JdbcVersion</code>. The package is declared as follows:</p>
<pre>CREATE OR REPLACE PACKAGE jdbcversion AS
  FUNCTION toString0 RETURN VARCHAR2;
  FUNCTION getDriverMajorVersion RETURN NUMBER;
  FUNCTION getDriverMinorVersion RETURN NUMBER;
  FUNCTION getDriverName RETURN VARCHAR2;
  FUNCTION getDriverVersion RETURN VARCHAR2;
  FUNCTION getJdbcLibraryName RETURN VARCHAR2;
  FUNCTION getRecommendedRuntimeZip RETURN VARCHAR2;
  FUNCTION getRuntimeVersion RETURN VARCHAR2;
  FUNCTION getSqljLibraryName RETURN VARCHAR2;
  FUNCTION hasNewStatementCache RETURN NUMBER;
  FUNCTION hasOracleContextIsNew RETURN NUMBER;
  FUNCTION hasOracleSavepoint RETURN NUMBER;
  PROCEDURE main0(arg0 JPUBTBL_VARCHAR2);
  FUNCTION to_string RETURN VARCHAR2;
END jdbcversion;
</pre>
<p>Note that the methods <code>toString()</code> and <code>main()</code> are renamed to <code>toString0()</code> and <code>main0()</code>, because of the Java stored procedure limitation.</p>
<p>You can run the PL/SQL stored procedures in the <code>jdbcversion</code> package as follows:</p>
<pre>SQL&gt; SELECT jdbcversion.toString0 FROM DUAL;
 
TOSTRING0
--------------------------------------------------------------------------------
Oracle JDBC driver version 10.2 (10.2.0.0.0)
SQLJ runtime: Oracle 9.2.0 for JDBC SERVER/JDK 1.2.x - Built on Oct 10, 2004
</pre>
<p>The <code>-dbjava</code> command publishes both static and instance methods. To publish the static method only, use the following setting:</p>
<pre>-proxyopts=static
</pre>
<p>If the server-side class has a <code>public</code> empty constructor, then its instance methods can be published. Instance methods can be called in two ways, through a default single instance inside the server, or through individual instances. The following option determines the approach used to call instance methods inside the server:</p>
<pre>-proxyopts=single|multiple
</pre>
<p>The default setting is:</p>
<pre>-proxyopts=single
</pre>
<p>The preceding SQL statement calls the <code>toString0()</code> method using the single instance.</p>
<p>You can publish <code>oracle.sqlj.checker.JdbcVersion</code> using <code>-proxyopts=multiple</code>, as follows:</p>
<pre>% jpub -user=hr -dbjava=oracle.sqlj.checker.JdbcVersion -plsqlfile=jdbcversion.sql -plsqlpackage=jdbcversion 
-proxyopts=multiple
Enter hr password: <span class="italic">password</span>
</pre>
<p>This command generates the <code>jdbcversion</code> PL/SQL package, with the following methods different from the previous example:</p>
<pre>CREATE OR REPLACE PACKAGE jdbcversion AS
  FUNCTION toString0(handleJdbcVersion NUMBER) RETURN VARCHAR2;
  ...
  FUNCTION newJdbcVersion RETURN NUMBER;
END jdbcversion;
</pre>
<p>Starting from Oracle Database 10<span class="italic">g</span> Release 2, an extra method, <code>newJdbcVersion()</code>, is created. You can create an instance using this method and use the instance to call the <code>toString0()</code> method. Run the following script in SQL*Plus:</p>
<pre>set serveroutput on
DECLARE
  text varchar2(1000);
  inst number;
BEGIN
  inst := jdbcversion.newJdbcVersion;
  text := jdbcversion.toString0(inst);
  dbms_output.put_line(text);
END;
/
</pre>
<p>This script returns:</p>
<pre>Oracle JDBC driver version 10.2 (10.2.0.0.0)
SQLJ runtime: Oracle 9.2.0 for JDBC
SERVER/JDK 1.2.x - Built on Oct 10, 2004

PL/SQL procedure successfully completed.
</pre>
<p>The following parameter and return types are supported:</p>
<ul>
<li>
<p>JDBC supported types</p>
</li>
<li>
<p>Java beans</p>
</li>
<li>
<p>Arrays of supported types</p>
</li>
</ul>
<p>Java beans are mapped to the generic JDBC <code>struct</code> class, <code>oracle.sql.STRUCT</code> at the Java stored procedure layer, and SQL object types and SQL table types at the PL/SQL layer. The following option determines how array parameters are handled:</p>
<pre>-proxyopts=arrayin|arrayout|arrayinout|arrayall
</pre>
<p>The default setting is:</p>
<pre>-proxyopts=arrayin
</pre>
<p>With <code>-proxyopts=arrayall</code>, a method containing array parameters is mapped to three PL/SQL methods. For example, consider the <code>foo(int[])</code> method. This method is mapped to the following methods:</p>
<pre>PROCEDURE foo(n NUMBERTBL);
PRECEDURE foo_o(n IN NUMBER);
PROCEDURE foo_io(n IN OUT NUMBER);
</pre>
<p>The first method treats the array argument as an input, the second treats the array as a holder for an output value, and the third treats the array as a holder for both input and output values. With <code>-proxyopts=arrayin</code>, which is the default setting, the <code>foo(int[])</code> method is mapped to the first method. With <code>-proxyopts=arrayout</code>, the <code>foo(int[])</code> method is mapped to the second method. With <code>-proxyopts=arrayinout</code>, the <code>foo(int[])</code> method is mapped to the third method.</p>
<p>Consider a more complex example that uses two classes. The <code>Add</code> class uses <code>Total</code> and arrays in the methods. <code>Total</code> is a Java Bean and is therefore supported by server-side classes publishing. The two classes are defined as follows:</p>
<pre>public class Add
{
  public static int add(int i, int j)
  {
      i = i + j;
    return i;
  }
  public int add(Total arg)
  {
    total = total + arg.getTotal();
    return total;
  }
}
</pre>
<pre>public class Total
{
  public void setTotal(int total)
  {
    this.total = total;
  }
  public int getTotal()
  {
    return total;
  }
  private int total;
}
</pre>
<p>Load the two classes into the database, as follows:</p>
<pre>% loadjava -u hr -r -v -f Add.java Total.java
Password: <span class="italic">password</span>
</pre>
<p>Run JPublisher using the following command:</p>
<pre>% jpub -user=hr -dbjava=Add  -proxyopts=arrayall
</pre>
<p>The command generates the following output:</p>
<pre>AddJPub.java
plsql_wrapper.sql
plsql_dropper.sql
Executing plsql_dropper.sql
Executing plsql_wrapper.sql
Loading AddJPub.java
</pre>
<p>The generated PL/SQL wrapper, <code>plsql_wrapper.sql</code>, will have the following declaration:</p>
<pre>CREATE OR REPLACE TYPE JPUBOBJ_Total AS OBJECT (total_ NUMBER);
CREATE OR REPLACE TYPE JPUBTBL_NUMBER AS TABLE OF NUMBER;
CREATE OR REPLACE PACKAGE JPUB_PLSQL_WRAPPER AS
  FUNCTION add(arg0  JPUBOBJ_Total) RETURN NUMBER;
  FUNCTION add_io(arg0  JPUBOBJ_Total) RETURN NUMBER;
  FUNCTION add(arg0  JPUBTBL_NUMBER,arg1  JPUBTBL_NUMBER) RETURN JPUBTBL_NUMBER;
  FUNCTION add_o(arg0 OUT  NUMBER,arg1 OUT  NUMBER) RETURN JPUBTBL_NUMBER;
  FUNCTION add_io(arg0 IN OUT  NUMBER,arg1 IN OUT NUMBER) RETURN JPUBTBL_NUMBER;
END JPUB_PLSQL_WRAPPER;
</pre>
<p>The following SQL script, when run in SQL*Plus, uses the generated PL/SQL wrapper:</p>
<pre>SQL&gt; set serveroutput on
SQL&gt; 
DECLARE
  totalx JPUBOBJ_Total;
  n NUMBER;
  n1 NUMBER;
  n2 NUMBER;
  add1 JPUBTBL_NUMBER;
  add2 JPUBTBL_NUMBER;
  add3 JPUBTBL_NUMBER;
BEGIN
  totalx := JPUBOBJ_Total(2004);
  n := JPUB_PLSQL_WRAPPER.add(totalx);
  n := JPUB_PLSQL_WRAPPER.add(totalx);
  DBMS_OUTPUT.PUT(&#39;total &#39;);
  DBMS_OUTPUT.PUT_LINE(n);
 
  add1 := JPUBTBL_NUMBER(10, 20);
  add2 := JPUBTBL_NUMBER(100, 200);
  add3 := JPUB_PLSQL_WRAPPER.add(add1, add2);
  DBMS_OUTPUT.PUT(&#39;add &#39;);
  DBMS_OUTPUT.PUT(add3(1));
  DBMS_OUTPUT.PUT(&#39; &#39;);
  DBMS_OUTPUT.PUT_LINE(add3(2));
 
  n1 := 99;
  n2 := 199;
  add3 := JPUB_PLSQL_WRAPPER.add_io(n1, n2);
  DBMS_OUTPUT.PUT(&#39;add_io &#39;);
  DBMS_OUTPUT.PUT_LINE(n1);
END; 
/
</pre>
<p>The script generates the following output:</p>
<pre>total 4008
add 110 220
add_io 298
PL/SQL procedure successfully completed.
</pre>
<p>The <code>-dbjava</code> option requires the classes being published to be present in the database. You can use <code>-proxyclasses</code> instead, which requires the classes being published to be specified in the classpath. Compile <code>Add.java</code> and <code>Total.java</code>, and include <code>Add</code> and <code>Total</code> in the classpath. You can use the following command to publish <code>Add</code>, instead of the <code>-dbjava</code> option:</p>
<pre>% jpub -proxyclasses=Add
</pre>
<p>The command generates the following output:</p>
<pre>AddJPub.java
plsql_wrapper.sql
plsql_dropper.sql
Executing plsql_dropper.sql
Executing plsql_wrapper.sql
</pre>
<p>The <code>-proxyclasses</code> option loads the generated PL/SQL wrapper. However, it does not load the generated Java stored procedure, <code>AddJPub.java</code>, because this procedure requires the published classes to exist on the server. You must load the Java stored procedure together with the published classes.</p>
<p>For example, on UNIX systems, you can load <code>Add.java</code>, <code>Total.java</code>, and <code>AddJPub.java</code> using the following command:</p>
<pre>% loadjava -u hr -r -v -f Add.java Total.java AddJPub.java
Password: <span class="italic">password</span>
</pre>
<p>Once <code>Add.java</code>, <code>Total.java</code>, and <code>AddJPub.java</code> are loaded, the PL/SQL wrapper is ready for use.</p>
<p>Starting Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.2), the -proxyclasses feature, and the -java feature require the following preparation step:</p>
<p>Load sqljutl.jar and sqljutls.sql into the user schema where the server-side java classes are present.</p>
<pre>% loadjava -u scott/tiger -r -v -f sqljutl.jar
% sqlplus scott/tiger @jpub/sql/sqljutl2.sql
</pre>
<p class="subhead2"><a id="JJPUB24084"></a>Mechanisms Used in Exposing Java to PL/SQL</p>
<p>JPublisher supports easy access to server-side Java classes by generating PL/SQL wrappers, otherwise known as PL/SQL call specifications. A <a id="sthref92"></a>PL/SQL wrapper is a PL/SQL package that can invoke methods of one or more given Java classes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a> for information about PL/SQL wrappers</div>
<p>PL/SQL supports only static methods. Java classes with only static methods or classes for which you want to expose only static methods can be wrapped in a straightforward manner. However, for Java classes that have instance methods that you want to expose, an intermediate wrapper class is necessary to expose the instance methods as static methods for use by PL/SQL.</p>
<p>A wrapper class is also required if the Java class to be wrapped uses anything other than Java primitive types in its method calling sequences.</p>
<p>For instance methods in a class that is to be wrapped, JPublisher can use either or both of the following mechanisms in the wrapper class:</p>
<ul>
<li>
<p>Each wrapped class can be treated as a <span class="bold">sing<a id="sthref93"></a>leton</span>, meaning that a single default instance is used. This instance is created the first time a method is called and is reused for each subsequent method call. Handles are not necessary and are not used. This mechanism is referred to as the <span class="bold">singleton mechanism</span> and is the default behavior when JPublisher provides wrapper classes for Web services client proxy classes.</p>
<p>A <code>release</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> method is provided to remove the reference to the default instance and permit it to be garbage-collected.</p>
</li>
<li>
<p>Instances of the wrapped class can be identified through <span class="bold">ha<a id="sthref94"></a>ndles</span>, also known as ID numbers. JPublisher uses <code>long</code> numbers as handles and creates static methods in the wrapper class. The method signatures of these methods are modified to include the handle of the instance on which to invoke a method. This allows the PL/SQL wrapper to use the handles in accessing instances of the wrapped class. In this scenario, you must create an instance of each wrapped class to obtain a handle. Then you provide a handle for each subsequent instance method invocation. This mechanism is referred to as the <span class="bold">handle mechanism</span>.</p>
<p>A <code>release</code><code><span class="codeinlineitalic">XXX</span></code><code>(long)</code> method is provided for releasing an individual instance according to the specified handle. A <code>releaseAll</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> method is provided for releasing all existing instances.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDJBCFB"></a>
<div id="JJPUB24085" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Publishing Server-Side Java Classes to Table Functions</h2>
<p>The <code>-dbjava</code> option can generate table functions from the generated PL/SQL wrapper. Table functions are used if you want to expose data through database tables, rather than through stored function returns or stored procedure output values. A table function returns a database table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about table functions.</div>
<p>For a table function to be generated for a given method, the following must be true:</p>
<ul>
<li>
<p>For wrapping instance methods, the singleton mechanism must be enabled. This is the default setting for <code>-dbjava</code> and <code>-proxyclasses</code>.</p>
</li>
<li>
<p>The wrapped Web service method must correspond to a stored procedure with <code>OUT</code> arguments or to a stored function.</p>
</li>
</ul>
<p>When used with the <code>-dbjava</code> or <code>-proxyclasses</code> option, the JPublisher <code>-proxyopts=tabfun</code> setting requests a table function created for each PL/SQL function in the generated PL/SQL wrapper. Consider the <code>Add</code> class example discussed earlier. Run the following command:</p>
<pre>% jpub -user=hr -dbjava=Add  -proxyopts=arrayall,tabfun
Enter hr password: <span class="italic">password</span>
</pre>
<p>The command generates the following output:</p>
<pre>AddJPub.java
plsql_wrapper.sql
plsql_dropper.sql
Executing plsql_dropper.sql
Executing plsql_wrapper.sql
Loading AddJPub.java
</pre>
<p>This command generates the following extra table functions, in addition to the PL/SQL methods generated in the earlier example:</p>
<pre>CREATE OR REPLACE PACKAGE JPUB_PLSQL_WRAPPER AS
   FUNCTION add(arg0 JPUBOBJ_Total) RETURN NUMBER;
   FUNCTION TO_TABLE_add(cur SYS_REFCURSOR) RETURN GRAPH_TAB_add_JPUBOBJ_Total PIPELINED;
   FUNCTION add(arg0 JPUBTBL_NUMBER,arg1  JPUBTBL_NUMBER) RETURN JPUBTBL_NUMBER;
   FUNCTION TO_TABLE_add0(cur SYS_REFCURSOR) RETURN GRAPH_TAB_add_JPUBTBL_NUMBER PIPELINED;
   FUNCTION add_o(arg0 OUT NUMBER, arg1 OUT NUMBER) RETURN JPUBTBL_NUMBER;
   FUNCTION TO_TABLE_add_o(cur SYS_REFCURSOR) RETURN GRAPH_TAB_add_o_JPUBTBL_NUMBER PIPELINED;
   FUNCTION add_io(arg0 IN OUT NUMBER, arg1 IN OUT NUMBER) RETURN JPUBTBL_NUMBER;
   FUNCTION TO_TABLE_add_io(cur SYS_REFCURSOR) RETURN GRAPH_TAB_add_io_JPUBTBL_NUMB PIPELINED;
END JPUB_PLSQL_WRAPPER;
/
</pre>
<p>The term, graph, is used with table functions. In this usage, a graph is a SQL object that defines the schema of the database table returned by a table function. There are three levels of functionality: a graph object, a table of graph objects, and a table function that returns the table of graph objects. The table of graph objects contains the input to a function and the output from that function.</p>
<p>As an example, consider the following declarations in <code>plsql_wrapper.sql</code>, which define the <code>GRAPH_add_io_JPUBTBL_NUMBER_J</code> graph object and the <code>GRAPH_TAB_add_io_JPUBTBL_NUMB</code> table of graph objects. These two types are generated for the <code>TO_TABLE_add_io</code> table function.</p>
<pre>CREATE OR REPLACE TYPE GRAPH_add_io_JPUBTBL_NUMBER_J AS OBJECT(arg0 NUMBER, 
arg1 NUMBER, arg0_out NUMBER, arg1_out NUMBER, res JPUBTBL_NUMBER);
/

CREATE OR REPLACE TYPE GRAPH_TAB_add_io_JPUBTBL_NUMB AS TABLE OF GRAPH_add_io_JPUBTBL_NUMBER_J;
/
</pre>
<p>Also note that a table function always takes a <code>REF CURSOR</code> as input. For the <code>TO_TABLE_add_io</code> table function, the <code>REF CURSOR</code> expects two arguments, <code>arg0</code> and <code>arg1</code>. The table function returns an instance of <code>GRAPH_TAB_add_io_JPUBTBL_NUMB</code>.</p>
<p>Run the following SQL script:</p>
<pre>SQL&gt; CREATE TABLE tabfun_input(arg0 NUMBER, arg1 NUMBER);
SQL&gt; BEGIN
  INSERT INTO tabfun_input VALUES(97, 106);
  INSERT INTO tabfun_input VALUES(67, 3);
  INSERT INTO tabfun_input VALUES(19, 23);
  INSERT INTO tabfun_input VALUES(98, 271);
  INSERT INTO tabfun_input VALUES(83, 281);
END;
/
</pre>
<pre>SQL&gt;  SELECT * FROM TABLE(JPUB_PLSQL_WRAPPER.TO_TABLE_add_io(CURSOR(SELECT * FROM tabfun_input)));
</pre>
<p>The query calls <code>TO_TABLE_add_io</code>, which shows the input and output of that table function.</p>
<pre>    ARG0     ARG1 ARG0_OUT ARG1_OUT RES
-------- -------- -------- -------- -------------------------
      97      106      203      106 JPUBTBL_NUMBER(203)
      67        3       70        3 JPUBTBL_NUMBER(70)
      19       23       42       23 JPUBTBL_NUMBER(42)
      98      271      369      271 JPUBTBL_NUMBER(369)
      83      281      364      281 JPUBTBL_NUMBER(364)
</pre></div>
<!-- class="sect1" -->
<a id="CHDGCHCA"></a>
<div id="JJPUB24086" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Publishing Web Services Client into PL/SQL</h2>
<p>JPublisher can publish a Web Service Description Language (WSDL) file into a PL/SQL package, to allow a database user to call a Web service from PL/SQL. This feature is called as <a id="sthref95"></a><span class="bold">Web services call-out</span>. Given a WSDL file, JPublisher generates a Java-based Web services client proxy, and further generates PL/SQL wrapper for the client proxy. The client proxy is generated by the Oracle Database Web services assembler tool, which is started by JPublisher. Before starting the tool, the following have to be present in the database:</p>
<ul>
<li>
<p>The client proxy generated by JPublisher</p>
</li>
<li>
<p>The PL/SQL wrapper generated by JPublisher</p>
</li>
<li>
<p>The Java stored procedure wrapper generated by JPublisher</p>
</li>
<li>
<p>The Java API for XML-based Remote Procedure Call (JAX-RPC) Web services client run time or Oracle Simple Object Access Protocol (SOAP) Web services client run time.</p>
</li>
</ul>
<p>These components can be loaded automatically by JPublisher or manually by the user. At run time, a Web services call-out works as follows:</p>
<ol>
<li>
<p>The user calls the PL/SQL wrapper, which in turn calls the Java stored procedure wrapper.</p>
</li>
<li>
<p>The Java stored procedure calls the client proxy.</p>
</li>
<li>
<p>The client proxy uses the Web services client run time to call the Web services.</p>
</li>
</ol>
<p>The Java stored procedure wrapper is a required intermediate layer to publish instance methods of the client proxy class as static methods, because PL/SQL supports only static methods.</p>
<p>Web services call-out requires the following JAR files, which are included in Database Web Services Callout Utility 10<span class="italic">g</span> release 2:</p>
<ul>
<li>
<p><code>dbwsa.jar</code></p>
</li>
<li>
<p><code>dbwsclientws.jar</code></p>
</li>
<li>
<p><code>dbwsclientdb101.jar</code></p>
</li>
<li>
<p><code>dbwsclientdb102.jar</code></p>
</li>
</ul>
<p>These files can be downloaded from:</p>
<pre><a href="http://download.oracle.com/technology/sample_code/tech/java/jsp/dbws-callout-utility-10131.zip">http://download.oracle.com/technology/sample_code/tech/java/jsp/dbws-callout-utility-10131.zip</a>
</pre>
<p>All the JAR files should be copied to the <code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/sqlj/lib</code> directory. The <code>dbwsa.jar</code> file is required in the classpath when JPublisher publishes a WSDL file. On UNIX systems, the <code>jpub</code> command-line script includes the <code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/sqlj/lib/dbwsa.jar</code>. Therefore, you do not have to include it in the classpath.</p>
<p>The <code>dbwsclientws.jar</code> file contains webservice client classes, irrespective of the version of Oracle Database. The <code>dbwsclientdb101.jar</code> file contains webservice client classes that are specific to Oracle Database 10<span class="italic">g</span> Release 1 release. The <code>dbwsclientdb102.jar</code> file contains webservice client classes that are specific to Oracle Database 10<span class="italic">g</span> Release 2 or Oracle Database 11<span class="italic">g</span>.</p>
<p>For Oracle9<span class="italic">i</span> Database, only Oracle SOAP Web services client is supported. To load Oracle SOAP Web services client run time into a pre-9.2 Oracle Database, run the following command:</p>
<pre>% loadjava -u sys -r -v -s -f -grant public \
                  ${J2EE_HOME}/lib/activation.jar \
                  ${J2EE_HOME}/lib/http_client.jar \
                  ${ORACLE_HOME}/lib/xmlparserv2.jar \
                  ${ORACLE_HOME}/soap/lib/soap.jar \
                  ${J2EE_HOME}/lib/mail.jar
Password: <span class="italic">password</span>
</pre>
<p>The commands are in the format of UNIX systems. However, it gives an idea to Microsoft Windows users about the JAR files that are required for Oracle SOAP Web services client. The JAR files involved are distributed with Oracle9<span class="italic">i</span> Application Server releases.</p>
<p>To load Oracle SOAP Web services client into Oracle Database 9.2, run the following command:</p>
<pre>% loadjava -u hr -r -v -f -genmissing
 ${ORACLE_HOME}/j2ee/home/lib/jssl-1_2.jar
 ${ORACLE_HOME}/soap/lib/soap.jar
 ${ORACLE_HOME}/dms/lib/dms.jar
 ${ORACLE_HOME}/j2ee/home/lib/servlet.jar 
${ORACLE_HOME}/j2ee/home/lib/ejb.jar 
${ORACLE_HOME}/j2ee/home/lib/mail.jar
Password: <span class="italic">password</span>
</pre>
<p>To load Oracle SOAP Web services client into Oracle Database 10<span class="italic">g</span>, run the following command:</p>
<pre>% loadjava -u hr -r -f -v -genmissing 
${ORACLE_HOME}/soap/lib/soap.jar 
${ORACLE_HOME}/lib/dms.jar 
${ORACLE_HOME}/jlib/javax-ssl-1_1.jar 
${ORACLE_HOME}/j2ee/home/lib/servlet.jar 
${ORACLE_HOME}/j2ee/home/lib/mail.jar 
${ORACLE_HOME}/j2ee/home/lib/activation.jar
${ORACLE_HOME}/j2ee/home/lib/http_client.jar 
${ORACLE_HOME}/j2ee/home/lib/ejb.jar
Password: <span class="italic">password</span>
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the user has <code>Grant</code> <code>Public</code> privileges, then add <code>-grant public</code> to the command above to make the loaded classes visible to other schemas.</div>
<p>To load Oracle JAX-RPC client into Oracle 10<span class="italic">g</span> Release 1 Database, use any one of the following two options:</p>
<ul>
<li>
<p>Load the Web service client into the <code>SYS</code> schema using the following command:</p>
<pre>% loadjava -u sys -r -v -f -genmissing -s -grant public dbwsclientws.jar dbwsclientdb101.jar
Password: <span class="italic">password</span>
</pre></li>
<li>
<p>Load the Web service client into a user schema using the following command:</p>
<pre>% loadjava -u hr -r -v -f -genmissing dbwsclientws.jar dbwsclientdb101.jar
Password: <span class="italic">password</span>
</pre></li>
</ul>
<p>To load Oracle JAX-RPC client into Oracle 12<span class="italic">c</span> Release 1 Database or Oracle Database 11<span class="italic">g</span>, use any one of the following two options:</p>
<ul>
<li>
<p>Load the Web service client into the <code>SYS</code> schema using the following command:</p>
<pre>% loadjava -u sys -r -v -f -genmissing -s -grant public dbwsclientws.jar dbwsclientdb102.jar
Password: <span class="italic">password</span>
</pre></li>
<li>
<p>Load the Web service client into a user schema using the command:</p>
<pre>% loadjava -u hr -r -v -f -genmissing dbwsclientws.jar dbwsclientdb102.jar
Password: <span class="italic">password</span>
</pre></li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the user has <code>Grant</code> <code>Public</code> privileges, then add <code>-grant public</code> to the command above to make the loaded classes visible to other schemas.</div>
<p>Web services call-outs require that JPublisher runs on JDK 1.4 or later. The following JPublisher options are related to Web services call-outs:</p>
<pre>-proxywsdl=<span class="italic">url</span>
-httpproxy=<span class="italic">host</span>:<span class="italic">port</span>
-endpoint=<span class="italic">url</span>
-proxyopts=soap|jaxrpc|noload|tabfun. Default: -proxyopts=jaxrpc|tabfun.
-sysuser=<span class="italic">user</span>/<span class="italic">password</span>
</pre>
<p>where,</p>
<ul>
<li>
<p>The <code>-proxywsdl</code> option specifies the URL or path of a WSDL file, which describes the Web services being published.</p>
</li>
<li>
<p>The <code>-httpproxy</code> option specifies the HTTP proxy that is used to access the WSDL file, if the file is outside a firewall.</p>
</li>
<li>
<p>The <code>-endpoint</code> option redirects the client to the specified endpoint, rather than the endpoint specified in the WSDL file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="optinfil.htm#CIHJDHJE">&#34;WSDL Document for Java and PL/SQL Wrapper Generation&#34;</a> and <a href="optinfil.htm#CIHBCECC">&#34;Web Services Endpoint&#34;</a></div>
</li>
<li>
<p>The <code>-proxyopts=soap</code> setting specifies that the PL/SQL wrapper will use Oracle SOAP Web services client run time to call the Web services.</p>
<p>The <code>-proxyopts=jaxrpc</code> setting specifies that the PL/SQL wrapper will use Oracle JAX-RPC Web services client run time to call the Web services.</p>
<p>The <code>-proxyopts=tabfun</code> setting specifies that table functions be generated for applicable Web services operations.</p>
</li>
<li>
<p>The <code>-sysuser</code> setting is recommended for <code>-proxywsdl</code>. It specifies a database user with <code>SYS</code> privileges. The <code>-sysuser</code> setting allows JPublisher to assign appropriate access privileges to run the generated PL/SQL wrappers. The <code>-sysuser</code> setting also allows JPublisher to load Web services client run time, if the run time is not present in the database.</p>
</li>
</ul>
<p>For example, assume that a JAX-RPC Web service, called <code>HelloService</code>, is deployed to the following endpoint:</p>
<pre>http://localhost:8888/javacallout/javacallout
</pre>
<p>The WSDL document for this Web service is at the following location:</p>
<pre>http://localhost:8888/javacallout/javacallout?WSDL
</pre>
<p>The Web service provides an operation called <code>getProperty</code> that takes a Java string specifying the name of a system property, and returns the value of that property. For example, <code>getProperty(&#34;os.name&#34;)</code> may return <code>SunOS</code>.</p>
<p>Based on the WSDL description of the Web service, JPublisher can direct the generation of a Web service client proxy, and generate Java and PL/SQL wrappers for the client proxy. Use the following command to perform these functions:</p>
<pre>% jpub -user=hr -sysuser=sys/<span class="italic">sys_password</span>
       -url=jdbc:oracle:thin:@localhost:1521:orcl
       -proxywsdl=http://localhost:8888/javacallout/javacallout?WSDL
       -package=javacallout -dir=genproxy
Enter hr password: <span class="italic">password</span>
</pre>
<p>The command gives the following output:</p>
<pre>genproxy/HelloServiceJPub.java
genproxy/plsql_wrapper.sql
genproxy/plsql_dropper.sql
genproxy/plsql_grant.sql
genproxy/plsql_revoke.sql
Executing genproxy/plsql_wrapper.sql
Executing genproxy/plsql_grant.sql
Loading genproxy/plsql_proxy.jar
</pre>
<p>The <code>-proxyopts</code> setting directs the generation of the JAX-RPC client proxy and wrappers, and the use of a table function to wrap the Web service operation. The <code>-url</code> setting indicates the database, and the <code>-user</code> setting indicates the schema, where JPublisher loads the generated Java and PL/SQL wrappers. The <code>-sysuser</code> setting specifies the <code>SYS</code> account that has the privileges to grant permissions to run the wrapper script.</p>
<p>The <code>plsql_grant.sql</code> and <code>plsql_revoke.sql</code> scripts are generated by JPublisher. These scripts are used to create the PL/SQL wrapper in the database schema, grant permission to run it, revoke that permission, and drop the PL/SQL wrapper from the database schema.</p>
<p>The contents of the WSDL file is as follows:</p>
<pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
 
&lt;definitions name=&#34;HelloService&#34;
             targetNamespace=&#34;http://oracle.j2ee.ws/javacallout/Hello&#34;
             xmlns:tns=&#34;http://oracle.j2ee.ws/javacallout/Hello&#34;
             xmlns=&#34;http://schemas.xmlsoap.org/wsdl/&#34;
             xmlns:xsd=&#34;http://www.w3.org/2001/XMLSchema&#34;
             xmlns:soap=&#34;http://schemas.xmlsoap.org/wsdl/soap/&#34;&gt;
  &lt;types/&gt;
  &lt;message name=&#34;HelloServiceInf_getProperty&#34;&gt;
    &lt;part name=&#34;String_1&#34; type=&#34;xsd:string&#34;/&gt;
  &lt;/message&gt;
  &lt;message name=&#34;HelloServiceInf_getPropertyResponse&#34;&gt;
    &lt;part name=&#34;result&#34; type=&#34;xsd:string&#34;/&gt;
  &lt;/message&gt;
  &lt;portType name=&#34;HelloServiceInf&#34;&gt;
    &lt;operation name=&#34;getProperty&#34; parameterOrder=&#34;String_1&#34;&gt;
      &lt;input message=&#34;tns:HelloServiceInf_getProperty&#34;/&gt;
      &lt;output message=&#34;tns:HelloServiceInf_getPropertyResponse&#34;/&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;binding name=&#34;HelloServiceInfBinding&#34; type=&#34;tns:HelloServiceInf&#34;&gt;
    &lt;operation name=&#34;getProperty&#34;&gt;
      &lt;input&gt;
        &lt;soap:body encodingStyle=&#34;http://schemas.xmlsoap.org/soap/encoding/&#34;
                   use=&#34;encoded&#34;
                   namespace=&#34;http://oracle.j2ee.ws/javacallout/Hello&#34;/&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body encodingStyle=&#34;http://schemas.xmlsoap.org/soap/encoding/&#34;
                   use=&#34;encoded&#34;
                   namespace=&#34;http://oracle.j2ee.ws/javacallout/Hello&#34;/&gt;
      &lt;/output&gt;
      &lt;soap:operation soapAction=&#34;&#34;/&gt;
    &lt;/operation&gt;
    &lt;soap:binding transport=&#34;http://schemas.xmlsoap.org/soap/http&#34; style=&#34;rpc&#34;/&gt;
  &lt;/binding&gt;
  &lt;service name=&#34;HelloService&#34;&gt;
    &lt;port name=&#34;HelloServiceInfPort&#34; binding=&#34;tns:HelloServiceInfBinding&#34;&gt;
      &lt;soap:address location=&#34;/javacallout&#34;/&gt;
    &lt;/port&gt;
  &lt;/service&gt;
&lt;/definitions&gt;
</pre>
<p><code>HelloServiceInf</code> in the <code>&lt;message&gt;</code> element is the name of the service bean and determines the name of the interface that is generated and implemented by the generated JAX-RPC client proxy stub class. The <code>HelloServiceInf</code> interface has the following signature:</p>
<pre>public interface HelloServiceInf extends java.rmi.Remote
{
  public String getProperty(String prop) throws java.rmi.RemoteException;
}
</pre>
<p>The method <code>getProperty()</code> corresponds to the <code>getProperty</code> operation specified in the WSDL document. It returns the value of a specified system property, <code><span class="codeinlineitalic">prop</span></code>. For example, specify the property <code>os.version</code> to return the operating system version.</p>
<p>The <code>plsql_wrapper.sql</code> file defines the <code>JPUB_PLSQL_WRAPPER</code> PL/SQL wrapper package. This package is created for calling the Web service from PL/SQL. It includes the definition of a table function from the Web service operation <code>getProperty</code>. The script in the <code>plsql_wrapper.sql</code> file is as follows:</p>
<pre>CREATE OR REPLACE TYPE GRAPH_getProperty AS OBJECT(
  p0 VARCHAR2(32767),
  res VARCHAR2(32767)
);
/
CREATE OR REPLACE TYPE GRAPH_TAB_getProperty AS TABLE OF GRAPH_getProperty;
/
-- PL/SQL procedures that invoke webserviecs
CREATE OR REPLACE PACKAGE JPUB_PLSQL_WRAPPER AS
  FUNCTION getProperty(p0 VARCHAR2) RETURN VARCHAR2;
  FUNCTION TO_TABLE_getProperty(cur SYS_REFCURSOR) RETURN GRAPH_TAB_getProperty PIPELINED;
END JPUB_PLSQL_WRAPPER;
/
</pre>
<p>Because the <code>-user</code> and <code>-sysuser</code> settings are specified in the JPublisher command line to publish this Web service, JPublisher will load the generated Java code and PL/SQL wrapper into the database. Once everything is loaded, you can use the PL/SQL wrapper to invoke the Web service.</p>
<p>The PL/SQL wrapper consists of two functions: <code>getProperty</code> and <code>TO_TABLE_getProperty</code>. The <code>getProperty</code> function directly wraps the <code>getProperty()</code> method in the generated client proxy class. For example, the following SQL*Plus command uses <code>getProperty</code> to determine the operating system where the Web service is running:</p>
<pre>SQL&gt; SELECT JPUB_PLSQL_WRAPPER.getProperty(&#39;os.name&#39;) FROM DUAL;
JPUB_PLSQL_WRAPPER.GETPROPERTY(&#39;OS.NAME&#39;)
-----------------------------------------
SunOS
</pre>
<p><code>TO_TABLE_getProperty</code> is a table function based on the <code>getProperty</code> function. It takes a <code>REF CURSOR</code> as input and returns a table. The schema of the table returned is defined by <code>GRAPH_getProperty</code>. In this example, <code>TO_TABLE_getProperty</code> is called with a <code>REF CURSOR</code> obtained from a one-column table of <code>VARCHAR2</code> data, where each data item is the name of a system property, such as <code>os.version</code>. <code>TO_TABLE_getProperty</code> returns a table in which each row contains an item from the input <code>REF CURSOR</code>, and the result of a <code>getProperty</code> call taking that item as input. The following code is a sample usage of <code>TO_TABLE_getProperty</code>:</p>
<pre>SQL&gt; -- Test Table Function
SQL&gt; CREATE TABLE props (name VARCHAR2(50));
SQL&gt; BEGIN
INSERT INTO props VALUES(&#39;os.version&#39;);
INSERT INTO props VALUES(&#39;java.version&#39;);
INSERT INTO props VALUES(&#39;file.separator&#39;);
INSERT INTO props VALUES(&#39;file.encoding.pkg&#39;);
INSERT INTO props VALUES(&#39;java.vm.info&#39;);
END;
/
SQL&gt; SELECT * FROM
TABLE(JPUB_PLSQL_WRAPPER.TO_TABLE_getProperty(CURSOR(SELECT * FROM props)));
P0 RES
------------------------------
os.version 5.8
java.version 1.4.1_03
file.separator /
file.encoding.pkg sun.io
java.vm.info mixed mode
</pre>
<p>This example creates a one-column table of <code>VARCHAR2</code>, populates it with system property names, and uses <code>TO_TABLE_getProperty</code> to find out the values of those system properties. In this example, you can see that the operating system is Sun Microsystems Solaris 5.8.</p>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5684">
<tr>
<td class="cellalignment5693">
<table class="cellalignment5689">
<tr>
<td class="cellalignment5688"><a href="intro.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5688"><a href="datamap.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5696">
<table class="cellalignment5687">
<tr>
<td class="cellalignment5688"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5688"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5688"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5688"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5688"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5688"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>