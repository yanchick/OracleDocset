<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114099"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Using%20Oracle%20ODBC%20Driver"></a><title>Using Oracle ODBC Driver</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1093"/>
<meta name="dcterms.created" content="2017-07-25T3:25:33Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Administrator&#39;s Reference"/>
<meta name="dcterms.identifier" content="E10638-27"/>
<meta name="dcterms.isVersionOf" content="UNXAR"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2006, 2017,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="appb_hpux.htm" title="Previous" type="text/html"/>
<link rel="Next" href="appg_db_lmts.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E10638-27.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">17/20</span> <!-- End Header -->
<div id="UNXAR014" class="appendix"><a id="CIHGCJBK"></a>
<h1 class="appendix"><span class="secnum">E</span> Using Oracle ODBC Driver</h1>
<p><a id="sthref492"></a>This appendix provides information related to using Oracle ODBC Driver.</p>
<p>It contains the following sections:</p>
<ul>
<li>
<p><a href="#CIHBFHCG">Oracle ODBC Features Not Supported</a></p>
</li>
<li>
<p><a href="#CIHDFDJH">Implementation of Data Types</a></p>
</li>
<li>
<p><a href="#CIHBCIHI">Limitations on Data Types</a></p>
</li>
<li>
<p><a href="#i1093897">Format of the Connection String for the SQLDriverConnect Function</a></p>
</li>
<li>
<p><a href="#CIHIJCJB">Reducing Lock Timeout in a Program</a></p>
</li>
<li>
<p><a href="#CIHIDDGI">Linking ODBC Applications</a></p>
</li>
<li>
<p><a href="#CIHEHDCH">Obtaining Information About ROWIDs</a></p>
</li>
<li>
<p><a href="#CIHBBFBF">ROWIDs in a WHERE Clause</a></p>
</li>
<li>
<p><a href="#CIHFEACE">Enabling Result Sets</a></p>
</li>
<li>
<p><a href="#CIHFJCCE">Enabling EXEC Syntax</a></p>
</li>
<li>
<p><a href="#CIHDFDDF">Supported Functionality</a></p>
</li>
<li>
<p><a href="#CIHFCAII">Unicode Support</a></p>
</li>
<li>
<p><a href="#CIHICDCE">Performance and Tuning</a></p>
</li>
<li>
<p><a href="#CIHIEHDC">Error Messages</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink GINST" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=GINST"><span class="italic">Oracle Database Installation Guide</span></a> for your respective platform for the ODBC driver certification information.</div>
<a id="CIHBFHCG"></a>
<div id="UNXAR352" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.1</span> Oracle ODBC Features Not Supported</h2>
<p>Oracle ODBC Driver does not support the following Oracle ODBC 3.0 features:</p>
<ul>
<li>
<p>Interval data types</p>
</li>
<li>
<p><code dir="ltr">SQL_C_UBIGINT</code> and <code dir="ltr">SQL_C_SBIGINT</code> C data type identifiers</p>
</li>
<li>
<p>Shared connections</p>
</li>
<li>
<p>Shared environments</p>
</li>
<li>
<p>The <code dir="ltr">SQL_LOGIN_TIMEOUT</code> attribute of <code dir="ltr">SQLSetConnectAttr</code></p>
</li>
<li>
<p>The expired password option</p>
</li>
</ul>
<p>Oracle ODBC Driver does not support the SQL functions listed in the following table:</p>
<div class="inftblinformal">
<table class="cellalignment5721" title="Unsupported SQL functions" summary="table" dir="ltr">
<thead>
<tr class="cellalignment5712">
<th class="cellalignment5722" id="r1c1-t3">String Functions</th>
<th class="cellalignment5722" id="r1c2-t3">Numeric Functions</th>
<th class="cellalignment5722" id="r1c3-t3">Time, Date, and Interval Functions</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r2c1-t3" headers="r1c1-t3"><code dir="ltr">BIT_LENGTH</code></td>
<td class="cellalignment5718" headers="r2c1-t3 r1c2-t3"><code dir="ltr">ACOS</code></td>
<td class="cellalignment5718" headers="r2c1-t3 r1c3-t3"><code dir="ltr">CURRENT_DATE</code></td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r3c1-t3" headers="r1c1-t3"><code dir="ltr">CHAR_LENGTH</code></td>
<td class="cellalignment5718" headers="r3c1-t3 r1c2-t3"><code dir="ltr">ASIN</code></td>
<td class="cellalignment5718" headers="r3c1-t3 r1c3-t3"><code dir="ltr">CURRENT_TIME</code></td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r4c1-t3" headers="r1c1-t3"><code dir="ltr">CHARACTER_LENGTH</code></td>
<td class="cellalignment5718" headers="r4c1-t3 r1c2-t3"><code dir="ltr">ATAN</code></td>
<td class="cellalignment5718" headers="r4c1-t3 r1c3-t3"><code dir="ltr">CURRENT_TIMESTAMP</code></td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r5c1-t3" headers="r1c1-t3"><code dir="ltr">DIFFERENCE</code></td>
<td class="cellalignment5718" headers="r5c1-t3 r1c2-t3"><code dir="ltr">ATAN2</code></td>
<td class="cellalignment5718" headers="r5c1-t3 r1c3-t3"><code dir="ltr">EXTRACT</code></td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r6c1-t3" headers="r1c1-t3"><code dir="ltr">OCTET_LENGTH</code></td>
<td class="cellalignment5718" headers="r6c1-t3 r1c2-t3"><code dir="ltr">COT</code></td>
<td class="cellalignment5718" headers="r6c1-t3 r1c3-t3"><code dir="ltr">TIMESTAMPDIFF</code></td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r7c1-t3" headers="r1c1-t3"><code dir="ltr">POSITION</code></td>
<td class="cellalignment5718" headers="r7c1-t3 r1c2-t3"><code dir="ltr">DEGREES</code>
<p><code dir="ltr">RADIANS</code></p>
<p><code dir="ltr">RAND</code></p>
<p><code dir="ltr">ROUND</code></p>
</td>
<td class="cellalignment5718" headers="r7c1-t3 r1c3-t3">&nbsp;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect1" -->
<a id="CIHDFDJH"></a>
<div id="UNXAR353" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.2</span> Implementation of Data Types</h2>
<p>This section discusses the <code dir="ltr">DATE</code>, <code dir="ltr">TIMESTAMP</code>, and floating point data types.</p>
<p class="subhead2"><a id="UNXAR354"></a>DATE and TIMESTAMP</p>
<p>The semantics of Oracle <code dir="ltr">DATE</code> and <code dir="ltr">TIMESTAMP</code> data types do not correspond exactly with the ODBC data types with the same names. The Oracle <code dir="ltr">DATE</code> data type contains both date and time information. The <code dir="ltr">SQL_DATE</code> data type contains only date information. The Oracle <code dir="ltr">TIMESTAMP</code> data type also contains date and time information, but it has greater precision in fractional seconds. Oracle ODBC Driver reports the data types of both Oracle <code dir="ltr">DATE</code> and <code dir="ltr">TIMESTAMP</code> columns as <code dir="ltr">SQL_TIMESTAMP</code> to prevent information loss. Similarly, Oracle ODBC Driver binds <code dir="ltr">SQL_TIMESTAMP</code> parameters as Oracle <code dir="ltr">TIMESTAMP</code> values.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CIHJHIAC">&#34;DATE and TIMESTAMP Data Types&#34;</a> for information about <code dir="ltr">DATE</code> and <code dir="ltr">TIMESTAMP</code> data types related to performance and tuning</div>
<p class="subhead2"><a id="UNXAR355"></a>Floating Point Data Types</p>
<p>When connected to an Oracle Database 12<span class="italic">c</span> Release 1 (12.1) or later, Oracle ODBC Driver maps the Oracle floating point data types <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> to the ODBC data types <code dir="ltr">SQL_REAL</code> and <code dir="ltr">SQL_DOUBLE</code>, respectively. In earlier releases, <code dir="ltr">SQL_REAL</code> and <code dir="ltr">SQL_DOUBLE</code> mapped to the generic Oracle numeric data type.</p>
</div>
<!-- class="sect1" -->
<a id="CIHBCIHI"></a>
<div id="UNXAR356" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.3</span> Limitations on Data Types</h2>
<p>Oracle ODBC Driver and Oracle Database impose limitations on data types. The following table describes these limitations:</p>
<div class="inftblinformal">
<table class="cellalignment5721" title="Limitations on Data Types" summary="tbl" dir="ltr">
<thead>
<tr class="cellalignment5712">
<th class="cellalignment5722" id="r1c1-t5">Limited Data Type</th>
<th class="cellalignment5722" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r2c1-t5" headers="r1c1-t5">Literals</td>
<td class="cellalignment5718" headers="r2c1-t5 r1c2-t5">Oracle Database limits literals in SQL statements to 4000 bytes.</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r3c1-t5" headers="r1c1-t5"><code dir="ltr">SQL_LONGVARCHAR</code> and <code dir="ltr">SQL_WLONGVARCHAR</code></td>
<td class="cellalignment5718" headers="r3c1-t5 r1c2-t5">The Oracle limit for <code dir="ltr">SQL_LONGVARCHAR</code> data, where the column type is <code dir="ltr">LONG</code>, is 2,147,483,647 bytes. The Oracle limit for <code dir="ltr">SQL_LONGVARCHAR</code> data, where the column type is <code dir="ltr">CLOB</code>, is 4 gigabytes. The limiting factor is the client workstation memory.</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r4c1-t5" headers="r1c1-t5"><code dir="ltr">SQL_LONGVARCHAR</code> and <code dir="ltr">SQL_LONGVARBINARY</code></td>
<td class="cellalignment5718" headers="r4c1-t5 r1c2-t5">Oracle Database permits only a single long data column in each table. The long data types are <code dir="ltr">SQL_LONGVARCHAR</code> (<code dir="ltr">LONG</code>) and <code dir="ltr">SQL_LONGVARBINARY</code> (<code dir="ltr">LONG RAW</code>). Oracle recommends that you use <code dir="ltr">CLOB</code> and <code dir="ltr">BLOB</code> columns instead. There is no restriction on the number of <code dir="ltr">CLOB</code> and <code dir="ltr">BLOB</code> columns in a table.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect1" -->
<a id="i1093897"></a>
<div id="UNXAR357" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.4</span> Format of the Connection String for the SQLDriverConnect Function</h2>
<p>The <code dir="ltr">SQLDriverConnect</code> function is one of the functions implemented by Oracle ODBC Driver. The following table describes the keywords that you can include in the connection string argument of the <code dir="ltr">SQLDriverConnect</code> function call:</p>
<div class="inftblinformal">
<table class="cellalignment5721" title="Keywords for the SQLDriverConnect function" summary="This table lists keywords for the SQLDriverConnect function" dir="ltr">
<thead>
<tr class="cellalignment5712">
<th class="cellalignment5722" id="r1c1-t6">Keyword</th>
<th class="cellalignment5722" id="r1c2-t6">Meaning</th>
<th class="cellalignment5722" id="r1c3-t6">Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r2c1-t6" headers="r1c1-t6"><code dir="ltr">DSN</code></td>
<td class="cellalignment5718" headers="r2c1-t6 r1c2-t6">ODBC data source name</td>
<td class="cellalignment5718" headers="r2c1-t6 r1c3-t6">User-supplied name
<p>This is a mandatory keyword.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r3c1-t6" headers="r1c1-t6"><code dir="ltr">DBQ</code></td>
<td class="cellalignment5718" headers="r3c1-t6 r1c2-t6">TNS service name</td>
<td class="cellalignment5718" headers="r3c1-t6 r1c3-t6">User-supplied name
<p>This is a mandatory keyword.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r4c1-t6" headers="r1c1-t6"><code dir="ltr">UID</code></td>
<td class="cellalignment5718" headers="r4c1-t6 r1c2-t6">User ID or user name</td>
<td class="cellalignment5718" headers="r4c1-t6 r1c3-t6">User-supplied name
<p>This is a mandatory keyword.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r5c1-t6" headers="r1c1-t6"><code dir="ltr">PWD</code></td>
<td class="cellalignment5718" headers="r5c1-t6 r1c2-t6">Password</td>
<td class="cellalignment5718" headers="r5c1-t6 r1c3-t6">User-supplied name
<p>Specify <code dir="ltr">PWD=;</code> for an empty password.</p>
<p>This is a mandatory keyword.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r6c1-t6" headers="r1c1-t6"><code dir="ltr">DBA</code></td>
<td class="cellalignment5718" headers="r6c1-t6 r1c2-t6">Database attribute</td>
<td class="cellalignment5718" headers="r6c1-t6 r1c3-t6"><code dir="ltr">W</code> implies write access
<p><code dir="ltr">R</code> implies read-only access</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r7c1-t6" headers="r1c1-t6"><code dir="ltr">APA</code></td>
<td class="cellalignment5718" headers="r7c1-t6 r1c2-t6">Applications attributes</td>
<td class="cellalignment5718" headers="r7c1-t6 r1c3-t6"><code dir="ltr">T</code> implies that thread safety is to be enabled.
<p><code dir="ltr">F</code> implies that thread safety is to be disabled.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r8c1-t6" headers="r1c1-t6"><code dir="ltr">RST</code></td>
<td class="cellalignment5718" headers="r8c1-t6 r1c2-t6">Result sets</td>
<td class="cellalignment5718" headers="r8c1-t6 r1c3-t6"><code dir="ltr">T</code> implies that result sets are to be enabled.
<p><code dir="ltr">F</code> implies that result sets are to be disabled.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r9c1-t6" headers="r1c1-t6"><code dir="ltr">QTO</code></td>
<td class="cellalignment5718" headers="r9c1-t6 r1c2-t6">Query timeout option</td>
<td class="cellalignment5718" headers="r9c1-t6 r1c3-t6"><code dir="ltr">T</code> implies that query timeout is to be enabled.
<p><code dir="ltr">F</code> implies that query timeout is to be disabled.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r10c1-t6" headers="r1c1-t6"><code dir="ltr">CSR</code></td>
<td class="cellalignment5718" headers="r10c1-t6 r1c2-t6">Close cursor</td>
<td class="cellalignment5718" headers="r10c1-t6 r1c3-t6"><code dir="ltr">T</code> implies that close cursor is to be enabled.
<p><code dir="ltr">F</code> implies that close cursor is to be disabled.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r11c1-t6" headers="r1c1-t6"><code dir="ltr">BAM</code></td>
<td class="cellalignment5718" headers="r11c1-t6 r1c2-t6">Batch autocommit mode</td>
<td class="cellalignment5718" headers="r11c1-t6 r1c3-t6"><code dir="ltr">IfAllSuccessful</code> implies commit only if all statements are successful (old behavior).
<p><code dir="ltr">UpToFirstFailure</code> implies commit up to first failing statement. This is ODBC version 7 behavior.</p>
<p><code dir="ltr">AllSuccessful</code> implies commit all successful statements.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r12c1-t6" headers="r1c1-t6"><code dir="ltr">FBS</code></td>
<td class="cellalignment5718" headers="r12c1-t6 r1c2-t6">Fetch buffer size</td>
<td class="cellalignment5718" headers="r12c1-t6 r1c3-t6">User-supplied numeric value (specify a value in bytes of 0 or greater).The default is 60,000 bytes.</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r13c1-t6" headers="r1c1-t6"><code dir="ltr">FEN</code></td>
<td class="cellalignment5718" headers="r13c1-t6 r1c2-t6">Failover</td>
<td class="cellalignment5718" headers="r13c1-t6 r1c3-t6"><code dir="ltr">T</code> implies failover is to be enabled.
<p><code dir="ltr">F</code> implies failover is to be disabled.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r14c1-t6" headers="r1c1-t6"><code dir="ltr">FRC</code></td>
<td class="cellalignment5718" headers="r14c1-t6 r1c2-t6">Failover retry count</td>
<td class="cellalignment5718" headers="r14c1-t6 r1c3-t6">User-supplied numeric value.
<p>The default is 10.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r15c1-t6" headers="r1c1-t6"><code dir="ltr">FDL</code></td>
<td class="cellalignment5718" headers="r15c1-t6 r1c2-t6">Failover delay</td>
<td class="cellalignment5718" headers="r15c1-t6 r1c3-t6">User-supplied numeric value.
<p>The default is 10.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r16c1-t6" headers="r1c1-t6"><code dir="ltr">LOB</code></td>
<td class="cellalignment5718" headers="r16c1-t6 r1c2-t6">LOB writes</td>
<td class="cellalignment5718" headers="r16c1-t6 r1c3-t6"><code dir="ltr">T</code> implies LOBs are to be enabled.
<p><code dir="ltr">F</code> implies LOBs are to be disabled.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r17c1-t6" headers="r1c1-t6"><code dir="ltr">FWC</code></td>
<td class="cellalignment5718" headers="r17c1-t6 r1c2-t6">Force <code dir="ltr">SQL_WCHAR</code> support</td>
<td class="cellalignment5718" headers="r17c1-t6 r1c3-t6"><code dir="ltr">T</code> implies <code dir="ltr">Force SQL_WCHAR</code> is to be enabled.
<p><code dir="ltr">F</code> implies <code dir="ltr">Force SQL_WCHAR</code> is to be disabled.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r18c1-t6" headers="r1c1-t6"><code dir="ltr">EXC</code></td>
<td class="cellalignment5718" headers="r18c1-t6 r1c2-t6"><code dir="ltr">EXEC</code> syntax</td>
<td class="cellalignment5718" headers="r18c1-t6 r1c3-t6"><code dir="ltr">T</code> implies <code dir="ltr">EXEC</code> syntax is to be enabled.
<p><code dir="ltr">F</code> implies <code dir="ltr">EXEC</code> syntax is to be disabled.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r19c1-t6" headers="r1c1-t6"><code dir="ltr">XSM</code></td>
<td class="cellalignment5718" headers="r19c1-t6 r1c2-t6">Schema field</td>
<td class="cellalignment5718" headers="r19c1-t6 r1c3-t6"><code dir="ltr">Default</code> implies that the default value is to be used.
<p><code dir="ltr">Database</code> implies that the database name is to be used.</p>
<p><code dir="ltr">Owner</code> implies that the name of the owner is to be used.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r20c1-t6" headers="r1c1-t6"><code dir="ltr">MDI</code></td>
<td class="cellalignment5718" headers="r20c1-t6 r1c2-t6">Set metadata ID default</td>
<td class="cellalignment5718" headers="r20c1-t6 r1c3-t6"><code dir="ltr">T</code> implies that the default value of <code dir="ltr">SQL_ATTR_METADATA_ID</code> is <code dir="ltr">SQL_TRUE</code>.
<p><code dir="ltr">F</code> implies that the default value of <code dir="ltr">SQL_ATTR_METADATA_ID</code> is <code dir="ltr">SQL_FALSE</code>.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r21c1-t6" headers="r1c1-t6"><code dir="ltr">DPM</code></td>
<td class="cellalignment5718" headers="r21c1-t6 r1c2-t6">Disable <code dir="ltr">SQLDescribeParam</code></td>
<td class="cellalignment5718" headers="r21c1-t6 r1c3-t6"><code dir="ltr">T</code> implies that <code dir="ltr">SQLDescribeParam</code> is to be disabled.
<p><code dir="ltr">F</code> implies that <code dir="ltr">SQLDescribeParam</code> is to be enabled.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r22c1-t6" headers="r1c1-t6"><code dir="ltr">BTD</code></td>
<td class="cellalignment5718" headers="r22c1-t6 r1c2-t6">Bind <code dir="ltr">TIMESTAMP</code> as <code dir="ltr">DATE</code></td>
<td class="cellalignment5718" headers="r22c1-t6 r1c3-t6"><code dir="ltr">T</code> implies that <code dir="ltr">SQL_TIMESTAMP</code> is to be bound as Oracle <code dir="ltr">DATE</code>.
<p><code dir="ltr">F</code> implies that <code dir="ltr">SQL_TIMESTAMP</code> is to be bound as Oracle <code dir="ltr">TIMESTAMP</code>.</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r23c1-t6" headers="r1c1-t6"><code dir="ltr">NUM</code></td>
<td class="cellalignment5718" headers="r23c1-t6 r1c2-t6">Numeric settings</td>
<td class="cellalignment5718" headers="r23c1-t6 r1c3-t6"><code dir="ltr">NLS</code> implies that the Globalization Support numeric settings are to be used (to determine the decimal and group separator).</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect1" -->
<a id="CIHIJCJB"></a>
<div id="UNXAR358" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.5</span> Reducing Lock Timeout in a Program</h2>
<p>Oracle Database waits indefinitely for lock conflicts between transactions to be resolved. However, you can limit the amount of time that Oracle Database waits for locks to be resolved. To do this, set the <code dir="ltr">SQL_ATTR_QUERY_TIMEOUT</code> attribute of the ODBC <code dir="ltr">SQLSetStmtAttr</code> function while calling this function before connecting to the data source.</p>
</div>
<!-- class="sect1" -->
<a id="CIHIDDGI"></a>
<div id="UNXAR359" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.6</span> Linking ODBC Applications</h2>
<p>When you link the program, you must link it with the Driver Manager library, <code dir="ltr">libodbc.so</code>.</p>
</div>
<!-- class="sect1" -->
<a id="CIHEHDCH"></a>
<div id="UNXAR360" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.7</span> Obtaining Information About ROWIDs</h2>
<p>The ODBC <code dir="ltr">SQLSpecialColumns</code> function returns information about the columns in a table. When used with Oracle ODBC Driver, it returns information about the Oracle ROWIDs associated with an Oracle table.</p>
</div>
<!-- class="sect1" -->
<a id="CIHBBFBF"></a>
<div id="UNXAR361" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.8</span> ROWIDs in a WHERE Clause</h2>
<p>ROWIDs may be used in the <code dir="ltr">WHERE</code> clause of an SQL statement. However, the ROWID value must be presented in a parameter marker.</p>
</div>
<!-- class="sect1" -->
<a id="CIHFEACE"></a>
<div id="UNXAR362" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.9</span> Enabling Result Sets</h2>
<p>Oracle reference cursors, also known as result sets, enable an application to retrieve data using stored procedures and stored functions. The following information describes how to use reference cursors to enable result sets through ODBC:</p>
<ul>
<li>
<p>You must use the ODBC syntax for calling stored procedures. Native PL/SQL is not supported through ODBC. The following code sample identifies how to call the procedure or function without a package and within a package. The package name in this case is <code dir="ltr">RSET</code>.</p>
<pre dir="ltr">Procedure call:
{CALL Example1(?)}
{CALL RSET.Example1(?)}
Function Call:
{? = CALL Example1(?)}
{? = CALL RSET.Example1(?)} 
</pre></li>
<li>
<p>The PL/SQL reference cursor parameters are omitted when calling the procedure. For example, assume procedure <code dir="ltr">Example2</code> is defined to have four parameters. Parameters 1 and 3 are reference cursor parameters and parameters 2 and 4 are character strings. The call is specified as:</p>
<pre dir="ltr">{CALL RSET.Example2(&#34;Literal 1&#34;, &#34;Literal 2&#34;)}
</pre></li>
</ul>
<p>The following sample application shows how to return a result set by using Oracle ODBC Driver:</p>
<pre dir="ltr">/*
* Sample Application using Oracle reference cursors through ODBC
*
* Assumptions:
*
* 1) Oracle Sample database is present with data loaded for the EMP table.
*
* 2) Two fields are referenced from the EMP table, ename and mgr.
*
* 3) A data source has been setup to access the sample database.
*
*
* Program Description:
*
* Abstract:
*
* This program demonstrates how to return result sets using
* Oracle stored procedures
*
* Details:
*
* This program:
* Creates an ODBC connection to the database.
* Creates a Packaged Procedure containing two result sets.
* Executes the procedure and retrieves the data from both result sets.
* Displays the data to the user.
* Deletes the package then logs the user out of the database.
*
*
* The following is the actual PL/SQL this code generates to
* create the stored procedures.
*  
DROP PACKAGE   ODBCRefCur;
CREATE PACKAGE ODBCRefCur AS
     TYPE ename_cur IS REF CURSOR;
     TYPE mgr_cur   IS REF CURSOR;
PROCEDURE EmpCurs(Ename IN OUT ename_cur, Mgr IN OUT mgr_cur, pjob IN VARCHAR2); 

END; 

/
CREATE PACKAGE BODY ODBCRefCur AS
PROCEDURE EmpCurs(Ename IN OUT ename_cur, Mgr IN OUT mgr_cur, pjob IN VARCHAR2)
     AS
       BEGIN
          IF NOT Ename%ISOPEN
          THEN
              OPEN Ename for SELECT ename from emp;
          END IF; 

          IF NOT Mgr%ISOPEN
          THEN
              OPEN Mgr for SELECT mgr from emp where job = pjob;
          END IF;
       END;
END;
/ 


*
*  End PL/SQL for Reference Cursor. 
*/

/*
 * Include Files
 */
#include &lt;stdio.h&gt;
#include &lt;sql.h&gt;
#include &lt;sqlext.h&gt;
/*
 * Defines
 */
#define JOB_LEN 9
#define DATA_LEN 100
#define SQL_STMT_LEN 500
/*
 * Procedures
 */
void DisplayError( SWORD HandleType, SQLHANDLE hHandle, char *Module );
/*
 * Main Program
 */
int main()
{
SQLHENV hEnv;
SQLHDBC hDbc;
SQLHSTMT hStmt;
SQLRETURN rc;
char *DefUserName =&#34;jones&#34;;
char *DefPassWord =&#34;<span class="italic">password</span>&#34;;
SQLCHAR ServerName[DATA_LEN];
SQLCHAR *pServerName=ServerName;
SQLCHAR UserName[DATA_LEN];
SQLCHAR *pUserName=UserName;
SQLCHAR PassWord[DATA_LEN];
SQLCHAR *pPassWord=PassWord;
char Data[DATA_LEN];
SQLINTEGER DataLen;
char error[DATA_LEN];
char *charptr;
SQLCHAR SqlStmt[SQL_STMT_LEN];
SQLCHAR *pSqlStmt=SqlStmt;
char *pSalesMan = &#34;SALESMAN&#34;;
SQLINTEGER sqlnts=SQL_NTS;
/*
 * Allocate the Environment Handle
 */
rc = SQLAllocHandle( SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;hEnv );
if (rc != SQL_SUCCESS)
{
  printf( &#34;Cannot Allocate Environment Handle\n&#34;);
  printf( &#34;\nHit Return to Exit\n&#34;);
  charptr = gets ((char *)error);
  exit(1);
}
/*
 * Set the ODBC Version
 */
rc = SQLSetEnvAttr( hEnv,SQL_ATTR_ODBC_VERSION,(void *)SQL_OV_ODBC3,0);
if (rc != SQL_SUCCESS)
{
  printf( &#34;Cannot Set ODBC Version\n&#34;);
  printf( &#34;\nHit Return to Exit\n&#34;);
  charptr = gets ((char *)error);
  exit(1);
}
/*
 * Allocate the Connection handle
 */
rc = SQLAllocHandle( SQL_HANDLE_DBC, hEnv, &amp;hDbc );
if (rc != SQL_SUCCESS)
{
  printf( &#34;Cannot Allocate Connection Handle\n&#34;);
  printf( &#34;\nHit Return to Exit\n&#34;);
  charptr = gets ((char *)error);
  exit(1);
}
/*
 * Get User Information
 */
strcpy ((char *) pUserName, DefUserName );
strcpy ((char *) pPassWord, DefPassWord );
/*
 * Data Source name
 */
printf( &#34;\nEnter the ODBC Data Source Name\n&#34; );
charptr = gets ((char *) ServerName);
/*
 * User Name
 */
printf ( &#34;\nEnter User Name Default [%s]\n&#34;, pUserName);
charptr = gets ((char *) UserName);
if (*charptr == &#39;\0&#39;)
{
  strcpy ((char *) pUserName, (char *) DefUserName );
}
/*
 * Password
 */
printf ( &#34;\nEnter Password Default [%s]\n&#34;, pPassWord);
charptr = gets ((char *)PassWord);
if (*charptr == &#39;\0&#39;)
{
  strcpy ((char *) pPassWord, (char *) DefPassWord );
}
/*
 * Connection to the database
 */
rc = SQLConnect( hDbc,pServerName,(SQLSMALLINT) strlen((char  *)pServerName),pUserName,(SQLSMALLINT) strlen((char *)pUserName),pPassWord,(SQLSMALLINT) strlen((char *)pPassWord));
if (rc != SQL_SUCCESS)
{
  DisplayError(SQL_HANDLE_DBC, hDbc, &#34;SQLConnect&#34;);
}
/*
 * Allocate a Statement
 */
rc = SQLAllocHandle( SQL_HANDLE_STMT, hDbc, &amp;hStmt );
if (rc != SQL_SUCCESS)
{
  printf( &#34;Cannot Allocate Statement Handle\n&#34;);
  printf( &#34;\nHit Return to Exit\n&#34;);
  charptr = gets ((char *)error);
  exit(1);
}
/*
 * Drop the Package
 */
strcpy( (char *) pSqlStmt, &#34;DROP PACKAGE ODBCRefCur&#34;);
rc = SQLExecDirect(hStmt, pSqlStmt, strlen((char *)pSqlStmt));
/*
 * Create the Package Header
 */
strcpy( (char *) pSqlStmt, &#34;CREATE PACKAGE ODBCRefCur AS\n&#34;);
strcat( (char *) pSqlStmt, &#34; TYPE ename_cur IS REF CURSOR;\n&#34;);
strcat( (char *) pSqlStmt, &#34; TYPE mgr_cur IS REF CURSOR;\n\n&#34;);
strcat( (char *) pSqlStmt, &#34; PROCEDURE EmpCurs (Ename IN OUT ename_cur,&#34;);
strcat( (char *) pSqlStmt, &#34;Mgr IN OUT mgr_cur,pjob IN VARCHAR2);\n\n&#34;);
strcat( (char *) pSqlStmt, &#34;END;\n&#34;);
rc = SQLExecDirect(hStmt, pSqlStmt, strlen((char *)pSqlStmt));
if (rc != SQL_SUCCESS)
{
  DisplayError(SQL_HANDLE_STMT, hStmt, &#34;SQLExecDirect&#34;);
}
/*
 * Create the Package Body
 */
strcpy( (char *) pSqlStmt, &#34;CREATE PACKAGE BODY ODBCRefCur AS\n&#34;);
strcat( (char *) pSqlStmt, &#34; PROCEDURE EmpCurs (Ename IN OUT ename_cur,&#34;);
strcat( (char *) pSqlStmt, &#34;Mgr IN OUT mgr_cur, pjob IN VARCHAR2)\n AS\n  BEGIN\n&#34;);
strcat( (char *) pSqlStmt, &#34; IF NOT Ename%ISOPEN\n THEN\n&#34;);
strcat( (char *) pSqlStmt, &#34; OPEN Ename for SELECT ename from emp;\n&#34;);
strcat( (char *) pSqlStmt, &#34; END IF;\n\n&#34;);
strcat( (char *) pSqlStmt, &#34; IF NOT Mgr%ISOPEN\n THEN\n&#34;);
strcat( (char *) pSqlStmt, &#34; OPEN Mgr for SELECT mgr from emp where job = pjob;\n&#34;);
strcat( (char *) pSqlStmt, &#34; END IF;\n&#34;);
strcat( (char *) pSqlStmt, &#34; END;\n&#34;);
strcat( (char *) pSqlStmt, &#34;END;\n&#34;);
rc = SQLExecDirect(hStmt, pSqlStmt, strlen((char *)pSqlStmt));
if (rc != SQL_SUCCESS)
{
  DisplayError(SQL_HANDLE_STMT, hStmt, &#34;SQLExecDirect&#34;);
}
/*
 * Bind the Parameter
 */
rc = SQLBindParameter(hStmt,1,SQL_PARAM_INPUT,SQL_C_CHAR,SQL_CHAR,JOB_LEN,0,pSalesMan,0,&amp;sqlnts);
/*
 * Call the Store Procedure which executes the Result Sets
 */
strcpy( (char *) pSqlStmt, &#34;{CALL ODBCRefCur.EmpCurs(?)}&#34;);
rc = SQLExecDirect(hStmt, pSqlStmt, strlen((char *)pSqlStmt));
if (rc != SQL_SUCCESS)
{
  DisplayError(SQL_HANDLE_STMT, hStmt, &#34;SQLExecDirect&#34;);
}
/*
 * Bind the Data
 */
rc = SQLBindCol( hStmt,1,SQL_C_CHAR,Data,sizeof(Data),&amp;DataLen);
if (rc != SQL_SUCCESS)
{
  DisplayError(SQL_HANDLE_STMT, hStmt, &#34;SQLBindCol&#34;);
}
/*
 * Get the data for Result Set 1
 */
printf( &#34;\nEmployee Names\n\n&#34;);
while ( rc == SQL_SUCCESS )
{
  rc = SQLFetch( hStmt );
  if ( rc == SQL_SUCCESS )
  {
    printf(&#34;%s\n&#34;, Data);
  }
  else
  {
    if (rc != SQL_NO_DATA)
    {
      DisplayError(SQL_HANDLE_STMT, hStmt, &#34;SQLFetch&#34;);
    }
  }
}
printf( &#34;\nFirst Result Set - Hit Return to Continue\n&#34;);
charptr = gets ((char *)error);
/*
 * Get the Next Result Set
 */
rc = SQLMoreResults( hStmt );
if (rc != SQL_SUCCESS)
{
  DisplayError(SQL_HANDLE_STMT, hStmt, &#34;SQLMoreResults&#34;);
}
/*
 * Get the data for Result Set 2
 */
printf( &#34;\nManagers\n\n&#34;);
while ( rc == SQL_SUCCESS )
{
  rc = SQLFetch( hStmt );
  if ( rc == SQL_SUCCESS )
  {
    printf(&#34;%s\n&#34;, Data);
  }
  else
  {
    if (rc != SQL_NO_DATA)
    {
    DisplayError(SQL_HANDLE_STMT, hStmt, &#34;SQLFetch&#34;);
    }
  }
}
printf( &#34;\nSecond Result Set - Hit Return to Continue\n&#34;);
charptr = gets ((char *)error);
/*
 * Should Be No More Results Sets
 */
rc = SQLMoreResults( hStmt );
if (rc != SQL_NO_DATA)
{
  DisplayError(SQL_HANDLE_STMT, hStmt, &#34;SQLMoreResults&#34;);
}
/*
 * Drop the Package
 */
strcpy( (char *) pSqlStmt, &#34;DROP PACKAGE ODBCRefCur&#34;);
rc = SQLExecDirect(hStmt, pSqlStmt, strlen((char *)pSqlStmt));
/*
 * Free handles close connections to the database
 */
SQLFreeHandle( SQL_HANDLE_STMT, hStmt );
SQLDisconnect( hDbc );
SQLFreeHandle( SQL_HANDLE_DBC, hDbc );
SQLFreeHandle( SQL_HANDLE_ENV, hEnv );
printf( &#34;\nAll Done - Hit Return to Exit\n&#34;);
charptr = gets ((char *)error);
return(0);
}
/*
 * Display Error Messages
 */
void DisplayError( SWORD HandleType, SQLHANDLE hHandle, char *Module )
{
SQLCHAR MessageText[255];
SQLCHAR SQLState[80];
SQLRETURN rc=SQL_SUCCESS;
long NativeError;
SWORD RetLen;
SQLCHAR error[25];
char *charptr;
rc =
SQLGetDiagRec(HandleType,hHandle,1,SQLState,&amp;NativeError,MessageText,255,&amp;RetLen);
printf( &#34;Failure Calling %s\n&#34;, Module );
if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
{
  printf( &#34;\t\t\t State: %s\n&#34;, SQLState);
  printf( &#34;\t\t\t Native Error: %d\n&#34;, NativeError );
  printf( &#34;\t\t\t Error Message: %s\n&#34;, MessageText );
}
printf( &#34;\nHit Return to Exit\n&#34;);
charptr = gets ((char *)error);
exit(1);
}
</pre></div>
<!-- class="sect1" -->
<a id="CIHFJCCE"></a>
<div id="UNXAR363" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.10</span> Enabling EXEC Syntax</h2>
<p>If the syntax of the SQL Server <code dir="ltr">EXEC</code> statement can be readily translated to an equivalent Oracle procedure call without requiring any change to it, then Oracle ODBC Driver can translate it if you enable this option.</p>
<p>The complete name of a SQL Server procedure consists of up to four identifiers:</p>
<ul>
<li>
<p>Server name</p>
</li>
<li>
<p>Database name</p>
</li>
<li>
<p>Owner name</p>
</li>
<li>
<p>Procedure name</p>
</li>
</ul>
<p>The format for the name is:</p>
<pre dir="ltr">[[[server.][database].][owner_name].]procedure_name
</pre>
<p>During the migration of Microsoft SQL Server database to Oracle Database, the definition of each SQL Server procedure or function is converted to its equivalent Oracle Database syntax and is defined in a schema in Oracle Database. Migrated procedures are often reorganized (and created in schemas) in one of the following ways:</p>
<ul>
<li>
<p>All procedures are migrated to one schema (the default option).</p>
</li>
<li>
<p>All procedures defined in one SQL Server database are migrated to the schema named with that database name.</p>
</li>
<li>
<p>All procedures owned by one user are migrated to the schema named with that user&#39;s name.</p>
</li>
</ul>
<p>To support these three ways of organizing migrated procedures, you can specify one of these schema name options for translating procedure names. Object names in the translated Oracle procedure call are not case-sensitive.</p>
</div>
<!-- class="sect1" -->
<a id="CIHDFDDF"></a>
<div id="UNXAR364" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.11</span> Supported Functionality</h2>
<p>This section provides information about the functionality supported by Oracle ODBC Driver. It contains the following sections:</p>
<ul>
<li>
<p><a href="#CIHEFDCH">API Conformance</a></p>
</li>
<li>
<p><a href="#CIHIJAAG">Implementation of ODBC API Functions</a></p>
</li>
<li>
<p><a href="#CIHGGCEJ">Implementation of the ODBC SQL Syntax</a></p>
</li>
<li>
<p><a href="#CIHFAFJG">Implementation of Data Types</a></p>
</li>
</ul>
<a id="CIHEFDCH"></a>
<div id="UNXAR365" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.11.1</span> API Conformance</h3>
<p>Oracle ODBC Driver release 10.2.0.1.0 and higher supports all Core, Level 2, and Level 1 functions.</p>
</div>
<!-- class="sect2" -->
<a id="CIHIJAAG"></a>
<div id="UNXAR366" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.11.2</span> Implementation of ODBC API Functions</h3>
<p>The following table describes how Oracle ODBC Driver implements specific functions:</p>
<div class="inftblinformal">
<table class="cellalignment5721" title="Implementation of ODBC API functions" summary="tbl" dir="ltr">
<thead>
<tr class="cellalignment5712">
<th class="cellalignment5722" id="r1c1-t7">Function</th>
<th class="cellalignment5722" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r2c1-t7" headers="r1c1-t7"><code dir="ltr">SQLConnect</code></td>
<td class="cellalignment5718" headers="r2c1-t7 r1c2-t7"><code dir="ltr">SQLConnect</code> requires only a <code dir="ltr">DBQ</code>, user ID, and password.</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r3c1-t7" headers="r1c1-t7"><code dir="ltr">SQLDriverConnect</code></td>
<td class="cellalignment5718" headers="r3c1-t7 r1c2-t7"><code dir="ltr">SQLDriverConnect</code> uses the <code dir="ltr">DSN</code>, <code dir="ltr">DBQ</code>, <code dir="ltr">UID</code>, and <code dir="ltr">PWD</code> keywords.</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r4c1-t7" headers="r1c1-t7"><code dir="ltr">SQLSpecialColumns</code></td>
<td class="cellalignment5718" headers="r4c1-t7 r1c2-t7">If <code dir="ltr">SQLSpecialColumns</code> is called with the <code dir="ltr">SQL_BEST_ROWID</code> attribute, then it always returns the ROWID column.</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r5c1-t7" headers="r1c1-t7"><code dir="ltr">SQLProcedures</code> and <code dir="ltr">SQLProcedureColumns</code></td>
<td class="cellalignment5718" headers="r5c1-t7 r1c2-t7">Refer to the information in the following row.</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r6c1-t7" headers="r1c1-t7">All catalog functions</td>
<td class="cellalignment5718" headers="r6c1-t7 r1c2-t7">If the <code dir="ltr">SQL_ATTR_METADATA_ID</code> statement attribute is set to <code dir="ltr">SQL_TRUE</code>, then a string argument is treated as an identifier argument, and its case is not significant. In this case, the underscore (_) and the percent sign (%) are treated as the actual character, and not as a search pattern character. In contrast, if this attribute is set to <code dir="ltr">SQL_FALSE</code>, then it is either an ordinary argument or a pattern value argument and is treated literally, and its case is significant.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p class="subhead2"><a id="UNXAR367"></a>SQLProcedures and SQLProcedureColumns</p>
<p>The <code dir="ltr">SQLProcedures</code> and <code dir="ltr">SQLProcedureColumns</code> calls have been modified to locate and return information about all procedures and functions even if they are contained within a package. In earlier releases, the calls only found procedures and functions that were outside of packages. The following examples and scenarios show what procedures or functions are returned if the <code dir="ltr">SQL_ATTR_METADATA_ID</code> attribute is set to <code dir="ltr">SQL_FALSE</code>.</p>
<p>Suppose that you have the following stored procedures:</p>
<pre dir="ltr">&#34;BAR&#34;
&#34;BARX&#34;
&#34;XBAR&#34;
&#34;XBARX&#34;
&#34;SQLPROCTEST.BAR&#34; 
&#34;SQLPROCTEST.BARX&#34; 
&#34;SQLPROCTEST.XBAR&#34; 
&#34;SQLPROCTEST.XBARX&#34; 
</pre>
<p>When you look for <code dir="ltr">%</code> or <code dir="ltr">%%%%%%</code>, you get all eight procedures.</p>
<p>When you look for <code dir="ltr">%_</code> or <code dir="ltr">_%</code>, you get the following:</p>
<pre dir="ltr">BAR 
BARX 
XBAR 
XBARX 
</pre>
<p>When you look for <code dir="ltr">.</code> or <code dir="ltr">.%</code> or <code dir="ltr">%.%</code> or <code dir="ltr">SQLPROC%.</code> or <code dir="ltr">SQLPROC%.%</code>, you get the following:</p>
<pre dir="ltr">SQLPROCTEST.BAR
SQLPROCTEST.BARX 
SQLPROCTEST.XBAR 
SQLPROCTEST.XBARX 
</pre>
<p>When you look for <code dir="ltr">%BAR</code>, you get the following:</p>
<pre dir="ltr">BAR
XBAR
</pre>
<p>When you look for <code dir="ltr">.%BAR</code> or <code dir="ltr">%.%BAR</code>, you get the following:</p>
<pre dir="ltr">SQLPROCTEST.BAR
SQLPROCTEST.XBAR 
</pre>
<p>When you look for <code dir="ltr">SQLPROC%</code> or <code dir="ltr">.SQLPROC%</code>, you get the following:</p>
<pre dir="ltr">nothing (0 rows)
</pre></div>
<!-- class="sect2" -->
<a id="CIHGGCEJ"></a>
<div id="UNXAR368" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.11.3</span> Implementation of the ODBC SQL Syntax</h3>
<p>If a comparison predicate has a parameter marker as the second expression in the comparison and the value of that parameter is set to <code dir="ltr">SQL_NULL_DATA</code> with <code dir="ltr">SQLBindParameter</code>, then the comparison fails. This is consistent with the null predicate syntax in ODBC SQL.</p>
</div>
<!-- class="sect2" -->
<a id="CIHFAFJG"></a>
<div id="UNXAR369" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.11.4</span> Implementation of Data Types</h3>
<p>For programmers, the most important part of the implementation of the data types concerns the <code dir="ltr">CHAR</code>, <code dir="ltr">VARCHAR</code>, and <code dir="ltr">VARCHAR2</code> data types.</p>
<p>For an <code dir="ltr">fSqlType</code> value of <code dir="ltr">SQL_VARCHAR</code>, <code dir="ltr">SQLGetTypeInfo</code> returns the Oracle Database data type <code dir="ltr">VARCHAR2</code>. For an <code dir="ltr">fSqlType</code> value of <code dir="ltr">SQL_CHAR</code>, <code dir="ltr">SQLGetTypeInfo</code> returns the Oracle Database data type <code dir="ltr">CHAR</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHFCAII"></a>
<div id="UNXAR370" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.12</span> Unicode Support</h2>
<p>This section provide information about Unicode support. It contains the following topics:</p>
<ul>
<li>
<p><a href="#CIHCGABD">Unicode Support Within the ODBC Environment</a></p>
</li>
<li>
<p><a href="#CIHFBHAI">Unicode Support in ODBC API</a></p>
</li>
<li>
<p><a href="#CIHEGIHH">SQLGetData Performance</a></p>
</li>
<li>
<p><a href="#CIHBBBCG">Unicode Samples</a></p>
</li>
</ul>
<a id="CIHCGABD"></a>
<div id="UNXAR371" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.12.1</span> Unicode Support Within the ODBC Environment</h3>
<p>ODBC Driver Manager makes all ODBC drivers, regardless of whether they support Unicode, appear as if they are Unicode compliant. This allows ODBC applications to be written independent of the Unicode capabilities of underlying ODBC drivers.</p>
<p>The extent to which the Driver Manager can emulate Unicode support for ANSI ODBC drivers is limited by the conversions possible between the Unicode data and the local code page. Data loss is possible when the Driver Manager is converting from Unicode to the local code page. Full Unicode support is not possible unless the underlying ODBC driver supports Unicode. Oracle ODBC Driver provides full Unicode support.</p>
</div>
<!-- class="sect2" -->
<a id="CIHFBHAI"></a>
<div id="UNXAR372" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.12.2</span> Unicode Support in ODBC API</h3>
<p>The ODBC API supports both Unicode and ANSI entry points using the <code dir="ltr">W</code> and <code dir="ltr">A</code> suffix convention. An ODBC application developer does not explicitly call entry points with the suffix. An ODBC application that is compiled with the <code dir="ltr">UNICODE</code> and <code dir="ltr">_UNICODE</code> preprocessor definitions generates the appropriate calls. For example, a call to <code dir="ltr">SQLPrepare</code> compiles as <code dir="ltr">SQLPrepareW</code>.</p>
<p>The C data type, <code dir="ltr">SQL_C_WCHAR</code>, was added to the ODBC interface to allow applications to specify that an input parameter is encoded as Unicode or to request column data returned as Unicode. The macro <code dir="ltr">SQL_C_TCHAR</code> is useful for applications that must be built as both Unicode and ANSI. The <code dir="ltr">SQL_C_TCHAR</code> macro compiles as <code dir="ltr">SQL_C_WCHAR</code> for Unicode applications and as <code dir="ltr">SQL_C_CHAR</code> for ANSI applications.</p>
<p>The SQL data types, <code dir="ltr">SQL_WCHAR</code>, <code dir="ltr">SQL_WVARCHAR</code>, and <code dir="ltr">SQL_WLONGVARCHAR</code>, have been added to the ODBC interface to represent columns defined in a table as Unicode. Potentially, these values are returned from calls to <code dir="ltr">SQLDescribeCol</code>, <code dir="ltr">SQLColAttribute</code>, <code dir="ltr">SQLColumns</code>, and <code dir="ltr">SQLProcedureColumns</code>.</p>
<p>Unicode encoding is supported for SQL column types NCHAR, NVARCHAR2, and NCLOB. In addition, Unicode encoding is also supported for SQL column types CHAR and VARCHAR2 if the character semantics are specified in the column definition.</p>
<p>Oracle ODBC Driver supports these SQL column types and maps them to ODBC SQL data types. The following table lists the supported SQL data types and the equivalent ODBC SQL data type:</p>
<div class="inftblinformal">
<table class="cellalignment5721" title="Supported SQL data types" summary="tbl" dir="ltr">
<thead>
<tr class="cellalignment5712">
<th class="cellalignment5722" id="r1c1-t8">SQL Data Types</th>
<th class="cellalignment5722" id="r1c2-t8">ODBC SQL Data Types</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r2c1-t8" headers="r1c1-t8"><code dir="ltr">CHAR</code></td>
<td class="cellalignment5718" headers="r2c1-t8 r1c2-t8"><code dir="ltr">SQL_CHAR</code> or <code dir="ltr">SQL_WCHAR</code></td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r3c1-t8" headers="r1c1-t8"><code dir="ltr">VARCHAR2</code></td>
<td class="cellalignment5718" headers="r3c1-t8 r1c2-t8"><code dir="ltr">SQL_VARCHAR</code> or <code dir="ltr">SQL_WVARCHAR</code></td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r4c1-t8" headers="r1c1-t8"><code dir="ltr">NCHAR</code></td>
<td class="cellalignment5718" headers="r4c1-t8 r1c2-t8"><code dir="ltr">SQL_WCHAR</code></td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r5c1-t8" headers="r1c1-t8"><code dir="ltr">NVARCHAR2</code></td>
<td class="cellalignment5718" headers="r5c1-t8 r1c2-t8"><code dir="ltr">SQL_WVARCHAR</code></td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r6c1-t8" headers="r1c1-t8"><code dir="ltr">NCLOB</code></td>
<td class="cellalignment5718" headers="r6c1-t8 r1c2-t8"><code dir="ltr">SQL_WLONGVARCHAR</code></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<a id="CIHEGIHH"></a>
<div id="UNXAR373" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.12.3</span> SQLGetData Performance</h3>
<p>The <code dir="ltr">SQLGetData</code> function allows an ODBC application to specify the data type to receive a column after the data has been fetched. OCI requires Oracle ODBC Driver to specify the data type before it is fetched. In this case, Oracle ODBC Driver uses information about the data type of the column (as defined in the database) to determine how to best default to fetching the column through OCI.</p>
<p>If a column that contains character data is not bound by <code dir="ltr">SQLBindCol</code>, then Oracle ODBC Driver must determine if it should fetch the column as Unicode or as the local code page. The driver could always default to receiving the column as Unicode. However, this may result in as many as two unnecessary conversions. For example, if the data were encoded in the database as ANSI, then there would be an ANSI to Unicode conversion to fetch the data into Oracle ODBC Driver. If the ODBC application then requested the data as <code dir="ltr">SQL_C_CHAR</code>, then there would be an additional conversion to revert the data to its original encoding.</p>
<p>The default encoding of Oracle Database Client is used when fetching data. However, an ODBC application may overwrite this default and fetch the data as Unicode by binding the column or the parameter as the <code dir="ltr">WCHAR</code> data type.</p>
</div>
<!-- class="sect2" -->
<a id="CIHBBBCG"></a>
<div id="UNXAR374" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.12.4</span> Unicode Samples</h3>
<p>Because Oracle ODBC Driver itself was implemented using <code dir="ltr">TCHAR</code> macros, it is recommended that ODBC application programs use <code dir="ltr">TCHAR</code> to take advantage of the driver.</p>
<p>The following examples show how to use <code dir="ltr">TCHAR</code>, which becomes the <code dir="ltr">WCHAR</code> data type if you compile with <code dir="ltr">UNICODE</code> and <code dir="ltr">_UNICODE</code>:</p>
<div id="UNXAR375" class="example">
<p class="titleinexample"><a id="sthref493"></a>Example E-1 Connection to Database</p>
<p>To use this code, you only must specify the Unicode literals for <code dir="ltr">SQLConnect</code>.</p>
<pre dir="ltr">HENV         envHnd;
HDBC         conHnd;
HSTMT        stmtHnd;
RETCODE      rc;

rc  = SQL_SUCCESS;

// ENV is allocated
rc = SQLAllocEnv(&amp;envHnd);
// Connection Handle is allocated
rc = SQLAllocConnect(envHnd, &amp;conHnd);
rc = SQLConnect(conHnd, _T(&#34;stpc19&#34;), SQL_NTS, _T(&#34;jones&#34;), SQL_NTS, _T(&#34;<span class="italic">password</span>&#34;), SQL_NTS);
.
.
.
if (conHnd)
  SQLFreeConnect(conHnd);
if (envHnd)
  SQLFreeEnv(envHnd);
</pre></div>
<!-- class="example" -->
<div id="UNXAR376" class="example">
<p class="titleinexample"><a id="sthref494"></a>Example E-2 Simple Retrieval</p>
<p>The following example retrieves the employee names and the job tiles from the <code dir="ltr">EMP</code> table. With the exception that you must specify <code dir="ltr">TCHAR</code> compliant data to every ODBC function, there is no difference to the ANSI case. If the case is a Unicode application, then you must specify the length of the buffer to the <code dir="ltr">BYTE</code> length when you call <code dir="ltr">SQLBindCol</code>. For example, <code dir="ltr">sizeof(ename)</code>.</p>
<pre dir="ltr">/*
** Execute SQL, bind columns, and Fetch.
** Procedure:
**
**   SQLExecDirect
**   SQLBindCol
**   SQLFetch
** 
*/
static SQLTCHAR *sqlStmt = _T(&#34;SELECT ename, job FROM emp&#34;);
SQLTCHAR   ename[50];
SQLTCHAR     job[50];
SQLINTEGER enamelen, joblen;
 
_tprintf(_T(&#34;Retrieve ENAME and JOB using SQLBindCol 1.../n[%s]/n&#34;), sqlStmt);
 
// Step 1: Prepare and Execute
rc = SQLExecDirect(stmtHnd, sqlStmt, SQL_NTS); // select
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
// Step 2: Bind Columns
rc = SQLBindCol(stmtHnd,
                1,
                SQL_C_TCHAR,
                ename,
                sizeof(ename),
                &amp;enamelen);
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
rc = SQLBindCol(stmtHnd,
                2,
                SQL_C_TCHAR,
                job,
                sizeof(job),
                &amp;joblen);
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
do 
{
  // Step 3: Fetch Data
  rc = SQLFetch(stmtHnd);
  if (rc == SQL_NO_DATA)
    break;
  checkSQLErr(envHnd, conHnd, stmtHnd, rc);
  _tprintf(_T(&#34;ENAME = %s, JOB = %s/n&#34;), ename, job);
} while (1);
_tprintf(_T(&#34;Finished Retrieval/n/n&#34;));
</pre></div>
<!-- class="example" -->
<div id="UNXAR377" class="example">
<p class="titleinexample"><a id="sthref495"></a>Example E-3 Retrieval Using SQLGetData (Binding After Fetch)</p>
<p>This example shows how to use <code dir="ltr">SQLGetData</code>. There is no difference to the ANSI application in terms of Unicode-specific issues.</p>
<pre dir="ltr">/*
** Execute SQL, bind columns, and Fetch.
** Procedure:
**
**   SQLExecDirect
**   SQLFetch
**   SQLGetData
*/
static SQLTCHAR *sqlStmt = _T(&#34;SELECT ename,job FROM emp&#34;); // same as Case 1.
SQLTCHAR         ename[50];
SQLTCHAR         job[50];
 
_tprintf(_T(&#34;Retrieve ENAME and JOB using SQLGetData.../n[%s]/n&#34;), sqlStmt);
if (rc != SQL_SUCCESS)
{
  _tprintf(_T(&#34;Failed to allocate STMT/n&#34;));
  goto exit2;
}
 
// Step 1: Prepare and Execute
rc = SQLExecDirect(stmtHnd, sqlStmt, SQL_NTS); // select
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
do 
{
 
  // Step 2: Fetch
  rc = SQLFetch(stmtHnd);
  if (rc == SQL_NO_DATA)
    break;
  checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
  // Step 3: GetData
  rc = SQLGetData(stmtHnd, 
    1,
    SQL_C_TCHAR,
    (SQLPOINTER)ename,
    sizeof(ename), 
    NULL);
  checkSQLErr(envHnd, conHnd, stmtHnd, rc);
  rc = SQLGetData(stmtHnd, 
    2,
    SQL_C_TCHAR, 
    (SQLPOINTER)job,
    sizeof(job), 
    NULL);
  checkSQLErr(envHnd, conHnd, stmtHnd, rc);
  _tprintf(_T(&#34;ENAME = %s, JOB = %s/n&#34;), ename, job);
} while (1);
_tprintf(_T(&#34;Finished Retrieval/n/n&#34;));
</pre></div>
<!-- class="example" -->
<div id="UNXAR378" class="example">
<p class="titleinexample"><a id="sthref496"></a>Example E-4 Simple Update</p>
<p>This example shows how to update data. The length of data for <code dir="ltr">SQLBindParameter</code> has to be specified with the BYTE length, even in Unicode application.</p>
<pre dir="ltr">/*
** Execute SQL, bind columns, and Fetch.
** Procedure:
**
**   SQLPrepare
**   SQLBindParameter
**   SQLExecute
*/
static SQLTCHAR *sqlStmt = _T(&#34;INSERT INTO emp(empno,ename,job) VALUES(?,?,?)&#34;);
static SQLTCHAR *empno   = _T(&#34;9876&#34;);      // Emp No
static SQLTCHAR *ename   = _T(&#34;ORACLE&#34;);    // Name
static SQLTCHAR *job     = _T(&#34;PRESIDENT&#34;); // Job
 
_tprintf(_T(&#34;Insert User ORACLE using SQLBindParameter.../n[%s]/n&#34;), sqlStmt);
 
// Step 1: Prepare
rc = SQLPrepare(stmtHnd, sqlStmt, SQL_NTS); // select
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
// Step 2: Bind Parameter
rc = SQLBindParameter(stmtHnd, 
                      1, 
                      SQL_PARAM_INPUT,
                      SQL_C_TCHAR,
                      SQL_DECIMAL,
                      4,               // 4 digit
                      0,
                      (SQLPOINTER)empno,
                      0,
                      NULL);
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
rc = SQLBindParameter(stmtHnd, 
                      2, 
                      SQL_PARAM_INPUT,
                      SQL_C_TCHAR,
                      SQL_CHAR,
                      lstrlen(ename)*sizeof(TCHAR),
                      0,
                      (SQLPOINTER)ename,
                      lstrlen(ename)*sizeof(TCHAR),
                      NULL);
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
rc = SQLBindParameter(stmtHnd, 
                      3, 
                      SQL_PARAM_INPUT,
                      SQL_C_TCHAR,
                      SQL_CHAR,
                      lstrlen(job)*sizeof(TCHAR),
                      0,
                      (SQLPOINTER)job,
                      lstrlen(job)*sizeof(TCHAR),
                      NULL);
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
// Step 3: Execute
rc = SQLExecute(stmtHnd);
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
</pre></div>
<!-- class="example" -->
<div id="UNXAR379" class="example">
<p class="titleinexample"><a id="sthref497"></a>Example E-5 Update and Retrieval for Long Data (CLOB)</p>
<p>This example may be the most complicated case to update and retrieve data for long data, like <code dir="ltr">CLOB</code>, in Oracle Database. Because the length of data should always be the <code dir="ltr">BYTE</code> length, the expression <code dir="ltr">lstrlen(TCHAR data)*sizeof(TCHAR)</code> is needed to derive the <code dir="ltr">BYTE</code> length.</p>
<pre dir="ltr">/*
** Execute SQL, bind columns, and Fetch.
** Procedure:
**
**   SQLPrepare
**   SQLBindParameter
**   SQLExecute
**   SQLParamData
**   SQLPutData
**
**   SQLExecDirect
**   SQLFetch
**   SQLGetData
*/
static SQLTCHAR *sqlStmt1  = _T(&#34;INSERT INTO clobtbl(clob1) VALUES(?)&#34;);
static SQLTCHAR *sqlStmt2  = _T(&#34;SELECT clob1 FROM clobtbl&#34;);
SQLTCHAR         clobdata[1001];
SQLTCHAR         resultdata[1001];
SQLINTEGER       ind = SQL_DATA_AT_EXEC;
SQLTCHAR        *bufp;
int              clobdatalen, chunksize, dtsize, retchklen;
 
_tprintf(_T(&#34;Insert CLOB1 using SQLPutData.../n[%s]/n&#34;), sqlStmt1);
 
// Set CLOB Data
{
  int i;
  SQLTCHAR ch;
  for (i=0, ch=_T(&#39;A&#39;); i&lt; sizeof(clobdata)/sizeof(SQLTCHAR); ++i, ++ch)
  {
    if (ch &gt; _T(&#39;Z&#39;))
      ch = _T(&#39;A&#39;);
    clobdata[i] = ch;
  }
  clobdata[sizeof(clobdata)/sizeof(SQLTCHAR)-1] = _T(&#39;/0&#39;);
}
clobdatalen = lstrlen(clobdata);  // length of characters
chunksize   = clobdatalen / 7;    // 7 times to put

// Step 1: Prepare
rc = SQLPrepare(stmtHnd, sqlStmt1, SQL_NTS);
checkSQLErr(envHnd, conHnd, stmtHnd, rc); 
// Step 2: Bind Parameter with SQL_DATA_AT_EXEC
rc = SQLBindParameter(stmtHnd, 
                      1, 
                      SQL_PARAM_INPUT,
                      SQL_C_TCHAR,
                      SQL_LONGVARCHAR,
                      clobdatalen*sizeof(TCHAR),
                      0,
                      (SQLPOINTER)clobdata,
                      clobdatalen*sizeof(TCHAR),
                      &amp;ind);
checkSQLErr(envHnd, conHnd, stmtHnd, rc); 
// Step 3: Execute
rc = SQLExecute(stmtHnd);
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
// Step 4: ParamData (initiation)
rc = SQLParamData(stmtHnd, (SQLPOINTER*)&amp;bufp); // set value
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
for (dtsize=0, bufp = clobdata;
     dtsize &lt; clobdatalen;
     dtsize += chunksize, bufp += chunksize)
{
  int len;
  if (dtsize+chunksize&lt;clobdatalen)
    len = chunksize;
  else
    len = clobdatalen-dtsize;
 
  // Step 5: PutData
  rc = SQLPutData(stmtHnd, (SQLPOINTER)bufp, len*sizeof(TCHAR));
  checkSQLErr(envHnd, conHnd, stmtHnd, rc);
}
 
// Step 6: ParamData (temination)
rc = SQLParamData(stmtHnd, (SQLPOINTER*)&amp;bufp);
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
rc = SQLFreeStmt(stmtHnd, SQL_CLOSE);
_tprintf(_T(&#34;Finished Update/n/n&#34;));
rc = SQLAllocStmt(conHnd, &amp;stmtHnd);
if (rc != SQL_SUCCESS)
{
  _tprintf(_T(&#34;Failed to allocate STMT/n&#34;));
  goto exit2;
}
 
// Clear Result Data
memset(resultdata, 0, sizeof(resultdata));
chunksize   = clobdatalen / 15;   // 15 times to put
 
// Step 1: Prepare
rc = SQLExecDirect(stmtHnd, sqlStmt2, SQL_NTS); // select
checkSQLErr(envHnd, conHnd, stmtHnd, rc);
 
// Step 2: Fetch
rc = SQLFetch(stmtHnd);
checkSQLErr(envHnd, conHnd, stmtHnd, rc); 
for(dtsize=0, bufp = resultdata;
    dtsize &lt; sizeof(resultdata)/sizeof(TCHAR) &amp;&amp; rc != SQL_NO_DATA;
    dtsize += chunksize-1, bufp += chunksize-1)
{
  int len; // len should contain the space for NULL termination
  if (dtsize+chunksize&lt;sizeof(resultdata)/sizeof(TCHAR))
    len = chunksize;
  else
    len = sizeof(resultdata)/sizeof(TCHAR)-dtsize;
 
  // Step 3: GetData
  rc = SQLGetData(stmtHnd, 
    1,
    SQL_C_TCHAR,
    (SQLPOINTER)bufp,
    len*sizeof(TCHAR), 
    &amp;retchklen);
}
if (!_tcscmp(resultdata, clobdata))
{
  _tprintf(_T(&#34;Succeeded!!/n/n&#34;));
}
else
{
  _tprintf(_T(&#34;Failed!!/n/n&#34;));
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHICDCE"></a>
<div id="UNXAR380" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.13</span> Performance and Tuning</h2>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CIHHHJJI">General ODBC Programming Guidelines</a></p>
</li>
<li>
<p><a href="#CIHGAAHJ">Data Source Configuration Options</a></p>
</li>
<li>
<p><a href="#CIHJHIAC">DATE and TIMESTAMP Data Types</a></p>
</li>
</ul>
<a id="CIHHHJJI"></a>
<div id="UNXAR381" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.13.1</span> General ODBC Programming Guidelines</h3>
<p>Apply the following programming guidelines to improve the performance of an ODBC application:</p>
<ul>
<li>
<p>Enable connection pooling if the application frequently connects and disconnects from a data source. Reusing pooled connections is extremely efficient compared to reestablishing a connection.</p>
</li>
<li>
<p>Minimize the number of times a statement must be prepared. Where possible, use bind parameters to make a statement reusable for different parameter values. Preparing a statement once and running it several times is much more efficient than preparing the statement for every <code dir="ltr">SQLExecute</code>.</p>
</li>
<li>
<p>Do not include columns in a <code dir="ltr">SELECT</code> statement of which you know the application does not retrieve; especially <code dir="ltr">LONG</code> columns. Because of the nature of the database server protocols, Oracle ODBC Driver must fetch the entire contents of a <code dir="ltr">LONG</code> column if it is included in the <code dir="ltr">SELECT</code> statement, regardless of whether the application binds the column or performs a <code dir="ltr">SQLGetData</code> operation.</p>
</li>
<li>
<p>If you are performing transactions that do not update the data source, then set the <code dir="ltr">SQL_ATTR_ACCESS_MODE</code> attribute of the ODBC <code dir="ltr">SQLSetConnectAttr</code> function to <code dir="ltr">SQL_MODE_READ_ONLY</code>.</p>
</li>
<li>
<p>If you are not using ODBC escape clauses, then set the <code dir="ltr">SQL_ATTR_NOSCAN</code> attribute of the ODBC <code dir="ltr">SQLSetConnectAttr</code> function or the ODBC <code dir="ltr">SQLSetStmtAttr</code> function to true.</p>
</li>
<li>
<p>Use the ODBC <code dir="ltr">SQLFetchScroll</code> function instead of the ODBC <code dir="ltr">SQLFetch</code> function for retrieving data from tables that have a large number of rows.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIHGAAHJ"></a>
<div id="UNXAR382" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.13.2</span> Data Source Configuration Options</h3>
<p>This section discusses the performance implications of the following ODBC data source configuration options:</p>
<ul>
<li>
<p>Enable Result Sets</p>
<p>This option enables the support of returning result sets (for example, <code dir="ltr">RefCursor</code>) from procedure calls. The default is enabling the returning of result sets.</p>
<p>Oracle ODBC Driver must query the database server to determine the set of parameters for a procedure and their data types in order to determine if there are any <code dir="ltr">RefCursor</code> parameters. This query incurs an additional network round trip the first time any procedure is prepared and executed.</p>
</li>
<li>
<p>Enable LOBs</p>
<p>This option enables the support of inserting and updating LOBs. The default is enabled.</p>
<p>Oracle ODBC Driver must query the database server to determine the data types of each parameter in an <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> statement to determine if there are any LOB parameters. This query incurs an additional network round trip the first time any <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> is prepared and run.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a> for more information about LOBs</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
LOB data compression enables you to compress SecureFiles to gain disk, Input-Output, and redo logging savings. This reduces costs as compression utilizes space most efficiently and improves the performance of SecureFiles as compression reduces Input-Output and redo logging.
<p>LOB data encryption provides enhanced database security. While the encrypted data is available for random reads and writes, the data is more secure.</p>
<p>Data compression and encryption consumes some additional memory.</p>
</div>
</li>
<li>
<p>Bind <code dir="ltr">TIMESTAMP</code> as <code dir="ltr">DATE</code></p>
<p>Binds <code dir="ltr">SQL_TIMESTAMP</code> parameters as the appropriate Oracle Database data type. If this option is set to <code dir="ltr">TRUE</code>, then <code dir="ltr">SQL_TIMESTAMP</code> binds as the Oracle <code dir="ltr">DATE</code> data type. If this option is set to <code dir="ltr">FALSE</code>, then <code dir="ltr">SQL_TIMESTAMP</code> binds as the Oracle <code dir="ltr">TIMESTAMP</code> data type, which is the default.</p>
</li>
<li>
<p>Enable Closing Cursors</p>
<p>The <code dir="ltr">SQL_CLOSE</code> option of the ODBC function, <code dir="ltr">SQLFreeStmt</code>, is supposed to close associated cursors with a statement and discard all pending results. The application can reopen the cursor by running the statement again without doing a SQLPrepare again. A typical scenario for this would be an application that expects to be idle for a while but reuses the same SQL statement again. While the application is idle, it may want to free up any associated server resources.</p>
<p>The OCI, on which Oracle ODBC Driver is layered, does not support the functionality of closing cursors. Therefore, by default, the <code dir="ltr">SQL_CLOSE</code> option has no effect in Oracle ODBC Driver. The cursor and associated resources remain open on the database.</p>
<p>Enabling this option causes the associated cursor to be closed on the database server. However, this results in the parse context of the SQL statement being lost. The ODBC application can run the statement again without calling <code dir="ltr">SQLPrepare</code>. However, internally, Oracle ODBC Driver must prepare and run the statement all over. Enabling this option has a severe performance impact on applications that prepare a statement once and run it repeatedly.</p>
<p>This option should only be enabled if freeing the resources on the server is necessary.</p>
</li>
<li>
<p>Fetch Buffer Size</p>
<p>Set the Fetch Buffer Size (<code dir="ltr">FetchBufferSize</code>) in the <code dir="ltr">odbc.ini</code> file to a value specified in bytes. This value is the amount of memory needed that determines how many rows of data Oracle ODBC Driver pre-fetches at a time from an Oracle Database to the client&#39;s cache regardless of the number of rows the application program requests in a single query, thus improving performance.</p>
<p>There is an improvement in the response time of applications that typically fetch fewer than 20 rows of data at a time, particularly over slow network connections or from heavily loaded servers. Setting this too high can have an adverse effect on response time or consume large amounts of memory. The default is 64,000 bytes. You should choose an optimal value for the application.</p>
<p>When the <code dir="ltr">LONG</code> and <code dir="ltr">LOB</code> data types are present, the number of rows pre-fetched by Oracle ODBC Driver is not determined by the Fetch Buffer Size. The inclusion of the <code dir="ltr">LONG</code> and <code dir="ltr">LOB</code> data types minimizes the performance improvement and could result in excessive memory use. Oracle ODBC Driver ignores the Fetch Buffer Size and only pre-fetches a set number of rows in the presence of the <code dir="ltr">LONG</code> and <code dir="ltr">LOB</code> data types.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1093897">&#34;Format of the Connection String for the SQLDriverConnect Function&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="CIHJHIAC"></a>
<div id="UNXAR383" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">E.13.3</span> DATE and TIMESTAMP Data Types</h3>
<p>If a <code dir="ltr">DATE</code> column in the database is used in a <code dir="ltr">WHERE</code> clause and the column has an index, then there can be an impact on performance. For example:</p>
<pre dir="ltr">SELECT * FROM EMP WHERE HIREDATE = ?
</pre>
<p>In this example, an index on the <code dir="ltr">HIREDATE</code> column could be used to make the query run quickly. However, because <code dir="ltr">HIREDATE</code> is a <code dir="ltr">DATE</code> value and Oracle ODBC Driver is supplying the parameter value as <code dir="ltr">TIMESTAMP</code>, the query optimizer of Oracle Database must apply a conversion function. To prevent incorrect results (as might happen if the parameter value had nonzero fractional seconds), the optimizer applies the conversion to the <code dir="ltr">HIREDATE</code> column resulting in the following statement:</p>
<pre dir="ltr">SELECT * FROM EMP WHERE TO_TIMESTAMP(HIREDATE) = ?
</pre>
<p>However, this has the effect of disabling the use of the index on the <code dir="ltr">HIREDATE</code> column. Instead, the server performs a sequential scan of the table. If the table has many rows, then this can take a long time. As a workaround for this situation, Oracle ODBC Driver has the connection option to bind <code dir="ltr">TIMESTAMP</code> as <code dir="ltr">DATE</code>. When this option is enabled, Oracle ODBC Driver binds <code dir="ltr">SQL_TIMESTAMP</code> parameters as the Oracle <code dir="ltr">DATE</code> data type instead of the Oracle <code dir="ltr">TIMESTAMP</code> data type. This enables the query optimizer to use any index on the <code dir="ltr">DATE</code> columns.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This option is intended only for use with Microsoft Access or other similar programs that bind <code dir="ltr">DATE</code> columns as <code dir="ltr">TIMESTAMP</code> columns. It should not be used when there are actual <code dir="ltr">TIMESTAMP</code> columns present or when data loss may occur. Microsoft Access runs such queries using whatever columns are selected as the primary key.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHIEHDC"></a>
<div id="UNXAR384" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">E.14</span> Error Messages</h2>
<p>When an error occurs, Oracle ODBC Driver returns the native error number, the <code dir="ltr">SQLSTATE</code> (an ODBC error code), and an error message. The driver derives this information both from errors detected by the driver and errors returned by Oracle Database.</p>
<p class="subhead2"><a id="UNXAR385"></a>Native Error</p>
<p>For errors that occur in the data source, Oracle ODBC Driver returns the native error returned to it by Oracle Database. When Oracle ODBC Driver or the Driver Manager detects an error, Oracle ODBC Driver returns a native error of zero.</p>
<p class="subhead2"><a id="UNXAR386"></a>SQLSTATE</p>
<p>For errors that occur in the data source, Oracle ODBC Driver maps the returned native error to the appropriate <code dir="ltr">SQLSTATE</code>. When Oracle ODBC Driver or the Driver Manager detects an error, it generates the appropriate <code dir="ltr">SQLSTATE</code>.</p>
<p class="subhead2"><a id="UNXAR387"></a>Error Message</p>
<p>For errors that occur in the data source, Oracle ODBC Driver returns an error message based on the message returned by Oracle Database. For errors that occur in Oracle ODBC Driver or the Driver Manager, Oracle ODBC Driver returns an error message based on the text associated with the <code dir="ltr">SQLSTATE</code>.</p>
<p>Error messages have the following format:</p>
<pre dir="ltr">[vendor] [ODBC-component] [data-source] error-message
</pre>
<p>The prefixes in brackets ([ ]) identify the source of the error. The following table shows the values of these prefixes returned by Oracle ODBC Driver. When the error occurs in the data source, the <code dir="ltr">vendor</code> and <code dir="ltr">ODBC-component</code> prefixes identify the vendor and name of the ODBC component that received the error from the data source.</p>
<div class="inftblinformal">
<table class="cellalignment5721" title="Error Source Prefixes Returned by Oracle ODBC Driver" summary="This table lists the values of the error source prefixes returned by Oracle ODBC Driver" dir="ltr">
<thead>
<tr class="cellalignment5712">
<th class="cellalignment5722" id="r1c1-t13">Error Source</th>
<th class="cellalignment5722" id="r1c2-t13">Prefix</th>
<th class="cellalignment5722" id="r1c3-t13">Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r2c1-t13" headers="r1c1-t13">Driver Manager</td>
<td class="cellalignment5718" headers="r2c1-t13 r1c2-t13">[vendor]
<p>[ODBC-component]</p>
<p>[data-source]</p>
</td>
<td class="cellalignment5718" headers="r2c1-t13 r1c3-t13">[unixODBC]
<p>[Driver Manager]</p>
<p>Not applicable</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r3c1-t13" headers="r1c1-t13">Oracle ODBC Driver</td>
<td class="cellalignment5718" headers="r3c1-t13 r1c2-t13">[vendor]
<p>[ODBC-component]</p>
<p>[data-source]</p>
</td>
<td class="cellalignment5718" headers="r3c1-t13 r1c3-t13">[ORACLE]
<p>[Oracle ODBC Driver]</p>
<p>Not applicable</p>
</td>
</tr>
<tr class="cellalignment5712">
<td class="cellalignment5718" id="r4c1-t13" headers="r1c1-t13">Oracle Database</td>
<td class="cellalignment5718" headers="r4c1-t13 r1c2-t13">[vendor]
<p>[ODBC-component]</p>
<p>[data-source]</p>
</td>
<td class="cellalignment5718" headers="r4c1-t13 r1c3-t13">[ORACLE]
<p>[Oracle ODBC Driver]</p>
<p>[Oracle OCI]</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>For example, if the error message does not contain the <code dir="ltr">Ora</code> prefix shown in the following format, then error is an Oracle ODBC Driver error and should be self-explanatory.</p>
<pre dir="ltr">[Oracle][ODBC]<span class="italic">Error message text here</span>
</pre>
<p>If the error message contains the <code dir="ltr">Ora</code> prefix shown in the following format, then it is not an Oracle ODBC Driver error.</p>
<pre dir="ltr">[Oracle][ODBC][Ora]<span class="italic">Error message text here</span>
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although the error message contains the <code dir="ltr">ORA-</code> prefix, the actual error may originate from one of several sources.</div>
<p>If the error message text starts with the <code dir="ltr">ORA-</code> prefix, then you can obtain more information about the error in Oracle Database documentation.</p>
</div>
<!-- class="sect1" --></div>
<!-- class="appendix" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5711">
<tr>
<td class="cellalignment5718">
<table class="cellalignment5716">
<tr>
<td class="cellalignment5715"><a href="appb_hpux.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5715"><a href="appg_db_lmts.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2006, 2017,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5720">
<table class="cellalignment5714">
<tr>
<td class="cellalignment5715"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5715"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5715"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5715"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5715"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5715"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>