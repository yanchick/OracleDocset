<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78003"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Database%20Concepts"></a><title>Database Concepts</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:36Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_02prc.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_04dat.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/35</span> <!-- End Header -->
<div id="LNPCC3108" class="chapter"><a id="g18485"></a> <a id="i1360"></a>
<h1 class="chapter"><span class="secnum">3</span> Database Concepts</h1>
<p>This chapter explains some basic database concepts and how to perform transaction processing. You learn the basic techniques that safeguard the consistency of your database, including how to control if changes to Oracle data are made permanent or undone.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i5880">Connect to the Database</a></p>
</li>
<li>
<p><a href="#i5996">Advanced Connection Options</a></p>
</li>
<li>
<p><a href="#i6337">Definitions of Transactions Terms</a></p>
</li>
<li>
<p><a href="#i7394">How Transactions Guard Your Database</a></p>
</li>
<li>
<p><a href="#i1546">How to Begin and End Transactions</a></p>
</li>
<li>
<p><a href="#i1509">Using the COMMIT Statement</a></p>
</li>
<li>
<p><a href="#i1522">Using the SAVEPOINT Statement</a></p>
</li>
<li>
<p><a href="#i1526">The ROLLBACK Statement</a></p>
</li>
<li>
<p><a href="#i1556">The RELEASE Option</a></p>
</li>
<li>
<p><a href="#i1699">The SET TRANSACTION Statement</a></p>
</li>
<li>
<p><a href="#i1704">Override Default Locking</a></p>
</li>
<li>
<p><a href="#i1553">Fetch Across COMMITs</a></p>
</li>
<li>
<p><a href="#i1713">Distributed Transactions Handling</a></p>
</li>
<li>
<p><a href="#i1718">Guidelines</a></p>
</li>
</ul>
<a id="i5880"></a>
<div id="LNPCC3109" class="sect1">
<h2 class="sect1">Connect to the Database</h2>
<p>The complete syntax of the CONNECT statement will be discussed in the next few sections. Here it is:</p>
<pre>EXEC SQL CONNECT { :user IDENTIFIED BY :oldpswd | :usr_psw }
   [[ AT { dbname | :host_variable }] USING :connect_string ]
      [ {ALTER AUTHORIZATION :newpswd  |  IN { SYSDBA | SYSOPER } MODE} ] ;
</pre>
<p>Your Pro*C/C++ program must connect to the database before querying or manipulating data. To log on, simply use the CONNECT statement<a id="sthref201"></a><a id="sthref202"></a><a id="sthref203"></a></p>
<pre>EXEC SQL CONNECT :username IDENTIFIED BY :password ; 
</pre>
<p>where <span class="italic">username</span> and <span class="italic">password</span> are <span class="bold">char</span> or VARCHAR host variables.</p>
<p>Or, you can use the statement</p>
<pre>EXEC SQL CONNECT :usr_pwd; 
</pre>
<p>where the host variable <span class="italic">usr_pwd</span> contains your username and password separated by a slash character (/).</p>
<p>These are simplified subsets of the CONNECT statement.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a href="pc_afemb.htm#CHEIJAAG">&#34;CONNECT (Executable Embedded SQL Extension)&#34;</a></div>
<p>The CONNECT statement must be the first SQL statement executed by the program. That is, other SQL statements can physically but not logically precede the CONNECT statement in the precompilation unit. <a id="sthref204"></a><a id="sthref205"></a></p>
<p>To supply the Oracle username and password separately, you define two host variables as character strings or VARCHARs. (If you supply a username containing both username and password, only one host variable is needed.)<a id="sthref206"></a><a id="sthref207"></a></p>
<p>Make sure to set the username and password variables before the CONNECT is executed, or it will fail. Your program can prompt for the values, or you can hard-code them as follows:<a id="sthref208"></a></p>
<pre>char *username = &#34;SCOTT&#34;; 
char *password = &#34;TIGER&#34;; 
... 
EXEC SQL WHENEVER SQLERROR ... 
EXEC SQL CONNECT :username IDENTIFIED BY :password; 
</pre>
<p>However, you cannot hard-code a username and password into the CONNECT statement. You also cannot use quoted literals. For example, both of the following statements are <span class="italic">invalid</span>:</p>
<pre>EXEC SQL CONNECT SCOTT IDENTIFIED BY TIGER; 
EXEC SQL CONNECT &#39;SCOTT&#39; IDENTIFIED BY &#39;TIGER&#39;; 
</pre>
<p>Hard coding usernames and passwords is not recommended practise.</p>
<a id="i5922"></a>
<div id="LNPCC3110" class="sect2">
<h3 class="sect2">Using the ALTER AUTHORIZATION Clause to Change Passwords</h3>
<p>Pro*C/C++ provides client applications with a convenient way to change a user password at runtime through a simple extension to the EXEC SQL CONNECT statement.</p>
<p>This section describes the possible outcomes of different variations of the ALTER AUTHORIZATION clause.</p>
<div id="LNPCC3111" class="sect3"><a id="sthref209"></a>
<h4 class="sect3">Standard CONNECT</h4>
<p>If an application issues the following statement</p>
<pre>EXEC SQL CONNECT ..;   /* No ALTER AUTHORIZATION clause */
</pre>
<p>it performs a normal connection attempt. The possible results include the following:</p>
<ul>
<li>
<p>The application will connect without issue.</p>
</li>
<li>
<p>The application will connect, but will receive a password warning. The warning indicates that the password has expired but is in a grace period which will allow Logons. At this point, the user is encouraged to change the password before the account becomes locked.</p>
</li>
<li>
<p>The application will fail to connect. Possible causes include the following:</p>
<ul>
<li>
<p>The password is incorrect.</p>
</li>
<li>
<p>The account has expired, and is possibly in a locked state.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="LNPCC3112" class="sect3"><a id="sthref210"></a>
<h4 class="sect3">Change Password on CONNECT</h4>
<p>The following CONNECT statement</p>
<pre>EXEC SQL CONNECT .. ALTER AUTHORIZATION :newpswd;
</pre>
<p>indicates that the application wants to change the account password to the value indicated by <code>newpswd</code>. After the change is made, an attempt is made to connect as <code>user</code>/<code>newpswd</code>. This can have the following results:</p>
<ul>
<li>
<p>The application will connect without issue</p>
</li>
<li>
<p>The application will fail to connect. This could be due to either of the following:</p>
<ul>
<li>
<p>Password verification failed for some reason. In this case the password remains unchanged.</p>
</li>
<li>
<p>The account is locked. Changes to the password are not permitted.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3113" class="sect2"><a id="sthref211"></a>
<h3 class="sect2">Connecting Using Oracle Net Services <a id="sthref212"></a></h3>
<p>To connect using an Oracle Net Services driver, substitute a service name, as defined in your <code>tnsnames.ora</code> configuration file or in Oracle Names.</p>
<p>If you are using Oracle Names, the name server obtains the service name from the network definition database.</p>
<p>See <span class="italic">Oracle Net Services Administrator&#39;s Guide</span> for more information about Oracle Net Services.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3114" class="sect2"><a id="sthref213"></a>
<h3 class="sect2">Automatic Connects</h3>
<p>You can automatically connect to Oracle with the username <a id="sthref214"></a><a id="sthref215"></a></p>
<pre>CLUSTER$username 
</pre>
<p>where <span class="italic">username</span> is the current operating system username, and CLUSTER$<span class="italic">username</span> is a valid Oracle database username. (The actual value for CLUSTER$ is defined in the INIT.ORA parameter file.) You simply pass to the Pro*C/C++ Precompiler a slash character, as follows:</p>
<pre>... 
char  *oracleid = &#34;/&#34;; 
... 
EXEC SQL CONNECT :oracleid; 
</pre>
<p>This automatically connects you as user CLUSTER$<span class="italic">username</span>. For example, if your operating system username is RHILL, and CLUSTER$RHILL is a valid Oracle username, connecting with &#39;/&#39; automatically logs you on to Oracle as user CLUSTER$RHILL.</p>
<p>You can also pass a &#39;/&#39; in a string to the precompiler. However, the string cannot contain trailing blanks. For example, the following CONNECT statement will fail:</p>
<pre>... 
char oracleid[10] = &#34;/    &#34;;
... 
EXEC SQL CONNECT :oracleid; 
</pre>
<div id="LNPCC3115" class="sect3"><a id="sthref216"></a>
<h4 class="sect3">The AUTO_CONNECT Precompiler Option <a id="sthref217"></a></h4>
<p>If AUTO_CONNECT=YES, and the application is not already connected to a database when it processes the first executable SQL statement, it attempts to connect using the userid</p>
<pre>CLUSTER$&lt;username&gt;
</pre>
<p>where <span class="italic">username</span> is your current operating system user or task name and CLUSTER$username is a valid Oracle userid. The default value of AUTO_CONNECT is NO.</p>
<p>When AUTO_CONNECT=NO, you must use the CONNECT statement in your program to connect to Oracle.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3116" class="sect3"><a id="sthref218"></a>
<h4 class="sect3">SYSDBA or SYSOPER System Privileges</h4>
<p>Append the following optional string after all other clauses to log on with either SYSDBA or SYSOPER system privileges:</p>
<pre>[IN { SYSDBA | SYSOPER } MODE]
</pre>
<p>For example:</p>
<pre>EXEC SQL CONNECT ... IN SYSDBA MODE ;
</pre>
<p>Here are the restrictions that apply to this option:</p>
<ul>
<li>
<p>This option is not permitted when using the AUTO_CONNECT=YES precompiler option setting.</p>
</li>
<li>
<p>This option is not permitted when using the ALTER AUTHORIZATION keywords in the CONNECT statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i5922">&#34;Using the ALTER AUTHORIZATION Clause to Change Passwords&#34;</a></div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5996"></a>
<div id="LNPCC3117" class="sect1">
<h2 class="sect1">Advanced Connection Options</h2>
<p>This section describes the available options for advanced connections.</p>
<div id="LNPCC3118" class="sect2"><a id="sthref219"></a>
<h3 class="sect2">Some Preliminaries</h3>
<p>The communicating points in a network are called <span class="italic">nodes</span>. Oracle Net lets you transmit information (SQL statements, data, and status codes) over the network from one node to another.<a id="sthref220"></a><a id="sthref221"></a><a id="sthref222"></a><a id="sthref223"></a></p>
<p>A <span class="italic">protocol</span> is a set of rules for accessing a network. The rules establish such things as procedures for recovering after a failure and formats for transmitting data and checking errors. <a id="sthref224"></a></p>
<p>The Oracle Net syntax for connecting to the default database in the local domain is simply to use the service name for the database.<a id="sthref225"></a></p>
<p>If the service name is not in the default (local) domain, you must use a global specification (all domains specified). For example:</p>
<pre>HR.US.ORACLE.COM
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3119" class="sect2"><a id="sthref226"></a>
<h3 class="sect2">Concurrent Logons</h3>
<p><a id="sthref227"></a><a id="sthref228"></a><a id="sthref229"></a><a id="sthref230"></a>Pro*C/C++ supports distributed processing through Oracle Net. Your application can concurrently access any combination of local and remote databases or make multiple connections to the same database. In <a href="#i6015">Figure 3-1</a>, an application program communicates with one local and three remote Oracle databases. ORA2, ORA3, and ORA4 are simply logical names used in CONNECT statements.</p>
<div id="LNPCC3120" class="figure">
<p class="titleinfigure"><a id="i6015"></a>Figure 3-1 Connecting through Oracle Net</p>
<img width="605" height="320" src="img/lnpcc004.gif" alt="Description of Figure 3-1 follows"/><br/>
<a id="sthref231" href="img_text/lnpcc004.htm">Description of &#34;Figure 3-1 Connecting through Oracle Net&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>By eliminating the boundaries in a network between different machines and operating systems, Oracle Net provides a distributed processing environment for Oracle tools. This section shows you how Pro*C/C++ supports distributed processing through Oracle Net. You learn how your application can<a id="sthref232"></a><a id="sthref233"></a><a id="sthref234"></a></p>
<ul>
<li>
<p>Directly or indirectly access other databases</p>
</li>
<li>
<p>Concurrently access any combination of local and remote databases</p>
</li>
<li>
<p>Make multiple connections to the same database</p>
</li>
</ul>
<p>For details on installing Oracle Net and identifying available databases, refer to the <a class="olink NETAG" href="../NETAG/toc.htm"><span class="italic">Oracle Database Net Services Administrator&#39;s Guide</span></a> and your system-specific Oracle documentation. <a id="sthref235"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3121" class="sect2"><a id="sthref236"></a>
<h3 class="sect2">Default Databases and Connections</h3>
<p>Each node has a <span class="italic">default</span> database. If you specify a database name, but no domain in your CONNECT statement, you connect to the default database on the named local or remote node.<a id="sthref237"></a><a id="sthref238"></a></p>
<p>A <span class="italic">default</span> connection is made by a CONNECT statement that has no AT clause. The connection can be to any default or nondefault database at any local or remote node. SQL statements without an AT clause are executed against the default connection. Conversely, a <span class="italic">nondefault</span> connection is made by a CONNECT statement that has an AT clause. SQL statements with an AT clause are executed against the nondefault connection.<a id="sthref239"></a><a id="sthref240"></a></p>
<p>All database names must be unique, but two or more database names can specify the same connection. That is, you can have multiple connections to any database on any node.<a id="sthref241"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3122" class="sect2"><a id="sthref242"></a>
<h3 class="sect2">Explicit Connections<a id="sthref243"></a></h3>
<p>Usually, you establish a connection to Oracle as follows:</p>
<pre>EXEC SQL CONNECT :username IDENTIFIED BY :password<span class="bold">; </span>
</pre>
<p>You can also use</p>
<pre>EXEC SQL CONNECT :usr_pwd; 
</pre>
<p>where <span class="italic">usr_pwd</span> contains <span class="italic">username</span>/<span class="italic">password</span>.</p>
<p>You can automatically connect to Oracle with the userid<a id="sthref244"></a></p>
<pre>CLUSTER$username 
</pre>
<p>where <span class="italic">username</span> is your current operating system user or task name and CLUSTER$<span class="italic">username</span> is a valid Oracle userid. You simply pass to the precompiler a slash (/) character, as follows:</p>
<pre>char oracleid = &#39;/&#39;; 
...
EXEC SQL CONNECT :oracleid; 
</pre>
<p>This automatically connects you as user CLUSTER$<span class="italic">username</span>.</p>
<p>If you do not specify a database and node, you are connected to the default database at the current node. If you want to connect to a different database, you must explicitly identify that database.</p>
<p>With <span class="italic">explicit connections</span>, you connect to another database directly, giving the connection a name that will be referenced in SQL statements. You can connect to several databases at the same time and to the same database multiple times.<a id="sthref245"></a><a id="sthref246"></a><a id="sthref247"></a></p>
<a id="i6071"></a>
<div id="LNPCC3123" class="sect3">
<h4 class="sect3">Single Explicit Connection</h4>
<p>In the following example, you connect to a single nondefault database at a remote node:<a id="sthref248"></a></p>
<pre>/* declare needed host variables */
char  username[10]  = &#34;scott&#34;; 
char  password[10]  = &#34;tiger&#34;;
char  db_string[20] = &#34;NYNON&#34;; 

/* give the database connection a unique name */ 
EXEC SQL DECLARE DB_NAME DATABASE; 

/* connect to the nondefault database  */
EXEC SQL CONNECT :username IDENTIFIED BY :password 
   AT DB_NAME USING :db_string; 
</pre>
<p>The identifiers in this example serve the following purposes:</p>
<ul>
<li>
<p>The host variables <span class="italic">username</span> and <span class="italic">password</span> identify a valid user.</p>
</li>
<li>
<p>The host variable <span class="italic">db_string</span> contains the Oracle Net syntax for connecting to a nondefault database at a remote node.</p>
</li>
<li>
<p>The undeclared identifier DB_NAME names a nondefault connection; it is an identifier used by Oracle, <span class="italic">not</span> a host or program variable.</p>
</li>
</ul>
<p>The USING clause specifies the network, machine, and database associated with DB_NAME. Later, SQL statements using the AT clause (with DB_NAME) are executed at the database specified by <span class="italic">db_string</span>.<a id="sthref249"></a><a id="sthref250"></a><a id="sthref251"></a><a id="sthref252"></a></p>
<p>Alternatively, you can use a character host variable in the AT clause, as the following example shows:</p>
<pre>/* declare needed host variables */ 
char  username[10]  = &#34;scott&#34;; 
char  password[10]  = &#34;tiger&#34;;
char  db_name[10]   = &#34;oracle1&#34;; 
char  db_string[20] = &#34;NYNON&#34;; 

/* connect to the nondefault database using db_name */
EXEC SQL CONNECT :username IDENTIFIED BY :password 
   AT :db_name USING :db_string; 
... 
</pre>
<p>If <span class="italic">db_name</span> is a host variable, the DECLARE DATABASE statement is not needed. Only if DB_NAME is an undeclared identifier must you execute a DECLARE DB_NAME DATABASE statement before executing a CONNECT ... AT DB_NAME statement.</p>
<div id="LNPCC3124" class="sect4"><a id="sthref253"></a>
<h5 class="sect4">SQL Operations</h5>
<p>If granted the privilege, you can execute any SQL data manipulation statement at the nondefault connection. For example, you might execute the following sequence of statements:</p>
<pre>EXEC SQL AT DB_NAME SELECT ... 
EXEC SQL AT DB_NAME INSERT ... 
EXEC SQL AT DB_NAME UPDATE ... 
</pre>
<p>In the next example, <span class="italic">db_name</span> is a host variable:</p>
<pre>EXEC SQL AT :db_name DELETE ... 
</pre>
<p>If <span class="italic">db_name</span> is a host variable, all database tables referenced by the SQL statement must be defined in DECLARE TABLE statements. Otherwise, the precompiler issues a warning.<a id="sthref254"></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_adchk.htm#BEJJDIIH">&#34;Using DECLARE TABLE&#34;</a></p>
</li>
<li>
<p><a href="pc_afemb.htm#CHECADIB">&#34;DECLARE TABLE (Oracle Embedded SQL Directive)&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<div id="LNPCC3125" class="sect4"><a id="sthref255"></a>
<h5 class="sect4">PL/SQL Blocks</h5>
<p>You can execute a PL/SQL block using the AT clause. The following example shows the syntax:</p>
<pre>EXEC SQL AT :db_name EXECUTE
    begin
        /* PL/SQL block here */
    end;
END-EXEC;<a id="sthref256"></a>
</pre></div>
<!-- class="sect4" -->
<div id="LNPCC3126" class="sect4"><a id="sthref257"></a>
<h5 class="sect4">Cursor Control</h5>
<p>Cursor control statements such as OPEN, FETCH, and CLOSE are exceptions&mdash;they never use an AT clause. If you want to associate a cursor with an explicitly identified database, use the AT clause in the DECLARE CURSOR statement, as follows:<a id="sthref258"></a><a id="sthref259"></a><a id="sthref260"></a></p>
<pre>EXEC SQL AT :db_name DECLARE emp_cursor CURSOR FOR ... 
EXEC SQL OPEN emp_cursor ... 
EXEC SQL FETCH emp_cursor ... 
EXEC SQL CLOSE emp_cursor; 
</pre>
<p>If <span class="italic">db_name</span> is a host variable, its declaration must be within the scope of all SQL statements that refer to the DECLAREd cursor. For example, if you OPEN the cursor in one subprogram, then FETCH from it in another subprogram, you must declare <span class="italic">db_name</span> globally.</p>
<p>When OPENing, CLOSing, or FETCHing from the cursor, you do not use the AT clause. The SQL statements are executed at the database named in the AT clause of the DECLARE CURSOR statement or at the default database if no AT clause is used in the cursor declaration.</p>
<p>The AT :<span class="italic">host_variable</span> clause provides the ability to change the connection associated with a cursor. However, you cannot change the association while the cursor is open. Consider the following example:<a id="sthref261"></a><a id="sthref262"></a></p>
<pre>EXEC SQL AT :db_name DECLARE emp_cursor CURSOR FOR ... 
strcpy(db_name, &#34;oracle1&#34;); 
EXEC SQL OPEN emp_cursor; 
EXEC SQL FETCH emp_cursor INTO ... 
strcpy(db_name, &#34;oracle2&#34;); 
EXEC SQL OPEN emp_cursor;   /*  illegal, cursor still open */ 
EXEC SQL FETCH emp_cursor INTO ... 
</pre>
<p>This is illegal because <span class="italic">emp_cursor</span> is still open when you try to execute the second OPEN statement. Separate cursors are not maintained for different connections; there is only one <span class="italic">emp_cursor</span>, which must be closed before it can be reopened for another connection. To debug the last example, simply close the cursor before reopening it, as follows:</p>
<pre>... 
EXEC SQL CLOSE emp_cursor;  -- close cursor first 
strcpy(db_name, &#34;oracle2&#34;); 
EXEC SQL OPEN emp_cursor; 
EXEC SQL FETCH emp_cursor INTO ... 
</pre></div>
<!-- class="sect4" -->
<div id="LNPCC3127" class="sect4"><a id="sthref263"></a>
<h5 class="sect4">Dynamic SQL</h5>
<p>Dynamic SQL statements are similar to cursor control statements in that some never use the AT clause.</p>
<p>For dynamic SQL Method 1, you must use the AT clause if you want to execute the statement at a nondefault connection. An example follows:<a id="sthref264"></a><a id="sthref265"></a><a id="sthref266"></a></p>
<pre>EXEC SQL AT :db_name EXECUTE IMMEDIATE :sql_stmt; 
</pre>
<p>For Methods 2, 3, and 4, you use the AT clause only in the DECLARE STATEMENT statement if you want to execute the statement at a nondefault connection. All other dynamic SQL statements such as PREPARE, DESCRIBE, OPEN, FETCH, and CLOSE never use the AT clause. The next example shows Method 2:<a id="sthref267"></a><a id="sthref268"></a></p>
<pre>EXEC SQL AT :db_name DECLARE sql_stmt STATEMENT; 
EXEC SQL PREPARE sql_stmt FROM :sql_string; 
EXEC SQL EXECUTE sql_stmt; 
</pre>
<p>The following example shows Method 3:</p>
<pre>EXEC SQL AT :db_name DECLARE sql_stmt STATEMENT; 
EXEC SQL PREPARE sql_stmt FROM :sql_string; 
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt; 
EXEC SQL OPEN emp_cursor ... 
EXEC SQL FETCH emp_cursor INTO ... 
EXEC SQL CLOSE emp_cursor;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNPCC3128" class="sect3"><a id="sthref269"></a>
<h4 class="sect3">Multiple Explicit Connections</h4>
<p>You can use the AT <span class="italic">db_name</span> clause for multiple explicit connections, just as you can for a single explicit connection. In the following example, you connect to two nondefault databases concurrently:<a id="sthref270"></a><a id="sthref271"></a></p>
<pre>/* declare needed host variables */ 
char  username[10]   = &#34;scott&#34;; 
char  password[10]   = &#34;tiger&#34;; 
char  db_string1[20] = &#34;NYNON1&#34;; 
char  db_string2[20] = &#34;CHINON&#34;; 
... 
/* give each database connection a unique name */ 
EXEC SQL DECLARE DB_NAME1 DATABASE; 
EXEC SQL DECLARE DB_NAME2 DATABASE; 
/* connect to the two nondefault databases */ 
EXEC SQL CONNECT :username IDENTIFIED BY :password 
   AT DB_NAME1 USING :db_string1; 
EXEC SQL CONNECT :username IDENTIFIED BY :password 
   AT DB_NAME2 USING :db_string2; 
</pre>
<p>The identifiers DB_NAME1 and DB_NAME2 are declared and then used to name the default databases at the two nondefault nodes so that later SQL statements can refer to the databases by name.</p>
<p>Alternatively, you can use a host variable in the AT clause, as the following example shows:</p>
<pre>/* declare needed host variables */ 
char  username[10]   = &#34;scott&#34;;
char  password[10]   = &#34;tiger&#34;;
char  db_name[20];
char  db_string[20];
int   n_defs = 3;    /* number of connections to make */
...
for (i = 0; i &lt; n_defs; i++)
{
    /* get next database name and OracleNet string */
    printf(&#34;Database name: &#34;);
    gets(db_name);
    printf(&#34;OracleNet) string: &#34;);
    gets(db_string);
    /* do the connect */
    EXEC SQL CONNECT :username IDENTIFIED BY :password
        AT :db_name USING :db_string;
}
</pre>
<p>You can also use this method to make multiple connections to the same database, as the following example shows:</p>
<pre>strcpy(db_string, &#34;NYNON&#34;);
for (i = 0; i &lt; ndefs; i++)
{
    /* connect to the nondefault database */
    printf(&#34;Database name: &#34;);
    gets(db_name);
    EXEC SQL CONNECT :username IDENTIFIED BY :password 
       AT :db_name USING :db_string;
}
... 
</pre>
<p>You must use different database names for the connections, even though they use the same OracleNet string. However, you can connect twice to the same database using just one database name because that name identifies both the default and nondefault databases.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3129" class="sect3"><a id="sthref272"></a>
<h4 class="sect3">Ensuring Data Integrity</h4>
<p>Your application program must ensure the integrity of transactions that manipulate data at two or more remote databases. That is, the program must commit or roll back <span class="italic">all</span> SQL statements in the transactions. This might be impossible if the network fails or one of the systems crashes.<a id="sthref273"></a></p>
<p>For example, suppose you are working with two accounting databases. You debit an account on one database and credit an account on the other database, then issue a COMMIT at each database. It is up to your program to ensure that both transactions are committed or rolled back.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3130" class="sect2"><a id="sthref274"></a>
<h3 class="sect2">Implicit Connections</h3>
<p>Implicit connections are supported through the Oracle distributed query facility, which does not require explicit connections, but only supports the SELECT statement. A distributed query allows a single SELECT statement to access data on one or more nondefault databases.</p>
<p>The distributed query facility depends on database links, which assign a name to a CONNECT <span class="italic">statement</span> rather than to the connection itself. <a id="sthref275"></a> At run time, the embedded SELECT statement is executed by the specified Oracle Server, which <span class="italic">implicitly</span> connects to the nondefault database(s) to get the required data.<a id="sthref276"></a></p>
<div id="LNPCC3131" class="sect3"><a id="sthref277"></a>
<h4 class="sect3">Single Implicit Connections</h4>
<p>In the next example, you connect to a single nondefault database. First, your program executes the following statement to define a database link (database links are usually established interactively by the DBA or user):<a id="sthref278"></a><a id="sthref279"></a><a id="sthref280"></a></p>
<pre>EXEC SQL CREATE DATABASE LINK db_link 
    CONNECT TO username IDENTIFIED BY password 
    USING &#39;NYNON&#39;; 
</pre>
<p>Then, the program can query the nondefault EMP table using the database link, as follows:<a id="sthref281"></a></p>
<pre>EXEC SQL SELECT ENAME, JOB INTO :emp_name, :job_title 
    FROM emp@db_link 
    WHERE DEPTNO = :dept_number; 
</pre>
<p>The database link is not related to the database name used in the AT clause of an embedded SQL statement. It simply tells Oracle where the nondefault database is located, the path to it, and what Oracle username and password to use. The database link is stored in the data dictionary until it is explicitly dropped.<a id="sthref282"></a></p>
<p>In our example, the default Oracle Server logs on to the nondefault database through Oracle Net using the database link <span class="italic">db_link</span>. The query is submitted to the default Server, but is &#34;forwarded&#34; to the nondefault database for execution.<a id="sthref283"></a></p>
<p>To make referencing the database link easier, you can interactively create a synonym as follows:<a id="sthref284"></a></p>
<pre>EXEC SQL CREATE SYNONYM emp FOR emp@db_link; 
</pre>
<p>Then, your program can query the nondefault EMP table, as follows:</p>
<pre>EXEC SQL SELECT ENAME, JOB INTO :emp_name, :job_title 
    FROM emp 
    WHERE DEPTNO = :dept_number; 
</pre>
<p>This provides location transparency for <span class="italic">emp</span>.<a id="sthref285"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3132" class="sect3"><a id="sthref286"></a>
<h4 class="sect3">Multiple Implicit Connections</h4>
<p>In the following example, you connect to two nondefault databases concurrently. First, you execute the following sequence of statements to define two database links and create two synonyms:<a id="sthref287"></a></p>
<pre>EXEC SQL CREATE DATABASE LINK db_link1 
    CONNECT TO username1 IDENTIFIED BY password1 
        USING &#39;NYNON&#39;; 
EXEC SQL CREATE DATABASE LINK db_link2 
    CONNECT TO username2 IDENTIFIED BY password2 
        USING &#39;CHINON&#39;; 
EXEC SQL CREATE SYNONYM emp FOR emp@db_link1; 
EXEC SQL CREATE SYNONYM dept FOR dept@db_link2; 
</pre>
<p>Then, your program can query the nondefault EMP and DEPT tables, as follows:</p>
<pre>EXEC SQL SELECT ENAME, JOB, SAL, LOC 
    FROM emp, dept 
    WHERE emp.DEPTNO = dept.DEPTNO AND DEPTNO = :dept_number; 
</pre>
<p>Oracle executes the query by performing a join between the nondefault EMP table at <span class="italic">db_link1</span> and the nondefault DEPT table at <span class="italic">db_link2</span>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i6337"></a>
<div id="LNPCC3133" class="sect1">
<h2 class="sect1">Definitions of Transactions Terms</h2>
<p>Before delving into the subject of transactions, you should know the terms defined in this section.</p>
<p>The jobs or tasks that Oracle manages are called <span class="italic">sessions</span>. A <span class="italic">user session</span> is invoked when you run an application program or a tool such as SQL*Forms, and connect to the database.<a id="sthref288"></a><a id="sthref289"></a></p>
<p>Oracle allows user sessions to work simultaneously and share computer resources. To do this, Oracle must control <span class="italic">concurrency</span>, the accessing of the same data by many users. Without adequate concurrency controls, there might be a loss of <span class="italic">data integrity</span>. That is, changes to data or structures might be made in the wrong order. <a id="sthref290"></a> <a id="sthref291"></a></p>
<p>Oracle uses <span class="italic">locks</span> (sometimes called <span class="italic">enqueues</span>) to control concurrent access to data. A lock gives you temporary ownership of a database resource such as a table or row of data. Thus, data cannot be changed by other users until you finish with it.<a id="sthref292"></a><a id="sthref293"></a></p>
<p>You need never explicitly lock a resource, because default locking mechanisms protect Oracle data and structures. However, you can request <span class="italic">data locks</span> on tables or rows when it is to your advantage to override default locking. You can choose from several <span class="italic">modes</span> of locking such as <span class="italic">row share</span> and <span class="italic">exclusive</span>.<a id="sthref294"></a><a id="sthref295"></a></p>
<p>A <span class="italic">deadlock</span> can occur when two or more users try to access the same database object. For example, two users updating the same table might wait if each tries to update a row currently locked by the other. Because each user is waiting for resources held by another user, neither can continue until Oracle breaks the deadlock. Oracle signals an error to the participating transaction that had completed the least amount of work, and the &#34;deadlock detected while waiting for resource&#34; Oracle error code is returned to <span class="italic">sqlcode</span> in the SQLCA.<a id="sthref296"></a></p>
<p>When a table is being queried by one user and updated by another at the same time, Oracle generates a <span class="italic">read-consistent</span> view of the table&#39;s data for the query. That is, once a query begins and as it proceeds, the data read by the query does not change. As update activity continues, Oracle takes <span class="italic">snapshots</span> of the table&#39;s data and records changes in a <span class="italic">rollback segment</span>. Oracle uses information in the rollback segment to build read-consistent query results and to undo changes if necessary.</p>
</div>
<!-- class="sect1" -->
<a id="i7394"></a>
<div id="LNPCC3134" class="sect1">
<h2 class="sect1">How Transactions Guard Your Database</h2>
<p>Oracle is transaction oriented. That is, Oracle uses transactions to ensure data integrity. A transaction is a series of one or more logically related SQL statements you define to accomplish some task. Oracle treats the series of SQL statements as a unit so that all the changes brought about by the statements are either <span class="italic">committed</span> (made permanent) or <span class="italic">rolled back</span> (undone) at the same time. If your application program fails in the middle of a transaction, the database is automatically restored to its former (pre-transaction) state.<a id="sthref297"></a><a id="sthref298"></a><a id="sthref299"></a><a id="sthref300"></a></p>
<p>The coming sections show you how to define and control transactions. Specifically, you learn how to:<a id="sthref301"></a></p>
<ul>
<li>
<p>Connect to the database.</p>
</li>
<li>
<p>Make concurrent connections.</p>
</li>
<li>
<p>Begin and end transactions.</p>
</li>
<li>
<p>Use the COMMIT statement to make transactions permanent.</p>
</li>
<li>
<p>Use the SAVEPOINT statement with the ROLLBACK TO statement to undo parts of transactions.</p>
</li>
<li>
<p>Use the ROLLBACK statement to undo whole transactions.</p>
</li>
<li>
<p>Specify the RELEASE option to free resources and log off the database.</p>
</li>
<li>
<p>Use the SET TRANSACTION statement to set read-only transactions.</p>
</li>
<li>
<p>Use the FOR UPDATE clause or LOCK TABLE statement to override default locking.</p>
</li>
</ul>
<p>For details about the SQL statements discussed in this chapter, see <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="i1546"></a>
<div id="LNPCC3135" class="sect1">
<h2 class="sect1">How to Begin and End Transactions</h2>
<p>You begin a transaction with the first executable SQL statement (other than CONNECT) in your program. When one transaction ends, the next executable SQL statement automatically begins another transaction. Thus, every executable statement is part of a transaction. Because they cannot be rolled back and need not be committed, declarative SQL statements are not considered part of a transaction.<a id="sthref302"></a><a id="sthref303"></a><a id="sthref304"></a></p>
<p>You end a transaction in one of the following ways:<a id="sthref305"></a></p>
<ul>
<li>
<p>Code a COMMIT or ROLLBACK statement, with or without the RELEASE option. This <span class="italic">explicitly</span> makes permanent or undoes changes to the database.</p>
</li>
<li>
<p>Code a data definition statement (ALTER, CREATE, or GRANT, for example), which issues an automatic COMMIT before <span class="italic">and</span> after executing. This <span class="italic">implicitly</span> makes permanent changes to the database.<a id="sthref306"></a><a id="sthref307"></a><a id="sthref308"></a></p>
</li>
</ul>
<p>A transaction also ends when there is a system failure or your user session stops unexpectedly because of software problems, hardware problems, or a forced interrupt. Oracle rolls back the transaction.<a id="sthref309"></a></p>
<p>If your program fails in the middle of a transaction, Oracle detects the error and rolls back the transaction. If your operating system fails, Oracle restores the database to its former (pre-transaction) state.<a id="sthref310"></a><a id="sthref311"></a></p>
</div>
<!-- class="sect1" -->
<a id="i1509"></a>
<div id="LNPCC3136" class="sect1">
<h2 class="sect1">Using the COMMIT Statement</h2>
<p>If you do not subdivide your program with the COMMIT or ROLLBACK statement, Oracle treats the whole program as a single transaction (unless the program contains data definition statements, which issue automatic COMMITS).</p>
<p>You use the COMMIT statement to make changes to the database permanent. Until changes are COMMITted, other users cannot access the changed data; they see it as it was before your transaction began. Specifically, the COMMIT statement<a id="sthref312"></a><a id="sthref313"></a><a id="sthref314"></a></p>
<ul>
<li>
<p>Makes permanent all changes made to the database during the current transaction</p>
</li>
<li>
<p>Makes these changes visible to other users</p>
</li>
<li>
<p>Erases all savepoints (see the next section)</p>
</li>
<li>
<p>Releases all row and table locks, but not parse locks</p>
</li>
<li>
<p>Closes cursors referenced in a CURRENT OF clause or, when MODE=ANSI, closes <span class="italic">all</span> explicit cursors for the connection specified in the COMMIT statement</p>
</li>
<li>
<p>Ends the transaction</p>
</li>
</ul>
<p>The COMMIT statement has no effect on the values of host variables or on the flow of control in your program.</p>
<p>When MODE=ORACLE, explicit cursors that are not referenced in a CURRENT OF clause remain open across COMMITs. This can boost performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1553">&#34;Fetch Across COMMITs&#34;</a></div>
<p>Because they are part of normal processing, COMMIT statements should be placed inline, on the main path through your program. Before your program terminates, it must explicitly COMMIT pending changes. Otherwise, Oracle rolls them back. In the following example, you commit your transaction and disconnect from Oracle: <a id="sthref315"></a><a id="sthref316"></a><a id="sthref317"></a><a id="sthref318"></a></p>
<pre>EXEC SQL COMMIT WORK RELEASE; 
</pre>
<p>The optional keyword WORK provides ANSI compatibility. The RELEASE option frees all Oracle resources (locks and cursors) held by your program and logs off the database.<a id="sthref319"></a><a id="sthref320"></a><a id="sthref321"></a></p>
<p>You need not follow a data definition statement with a COMMIT statement because data definition statements issue an automatic COMMIT before <span class="italic">and</span> after executing. So, whether they succeed or fail, the prior transaction is committed.</p>
<a id="i4014"></a>
<div id="LNPCC3137" class="sect2">
<h3 class="sect2">WITH HOLD Clause in DECLARE CURSOR Statements</h3>
<p>Any cursor that has been declared with the clause WITH HOLD after the word CURSOR remains open after a COMMIT. The following example shows how to use this clause:</p>
<pre>     EXEC SQL 
         DECLARE C1 CURSOR WITH HOLD
         FOR SELECT ENAME FROM EMP
         WHERE EMPNO BETWEEN 7600 AND 7700
     END-EXEC.
</pre>
<p>The cursor must not be declared for UPDATE. The WITH HOLD clause is used in DB2 to override the default, which is to close all cursors on commit. Pro*COBOL provides this clause in order to ease migrations of applications from DB2 to Oracle. When MODE=ANSI, Oracle uses the DB2 default, but all host variables must be declared in a Declare Section. To avoid having a Declare Section, use the precompiler option <span class="italic">CLOSE_ON_COMMIT</span> described next. See <a href="pc_afemb.htm#CHEEADJJ">&#34;DECLARE CURSOR (Embedded SQL Directive)&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i4365"></a>
<div id="LNPCC3138" class="sect2">
<h3 class="sect2"><a id="sthref322"></a>CLOSE_ON_COMMIT Precompiler Option</h3>
<p>The precompiler option CLOSE_ON_COMMIT is available to override the default behavior of MODE=ANSI (if you specify MODE=ANSI on the command line, any cursors not declared with the WITH HOLD clause are closed on commit):</p>
<pre>CLOSE_ON_COMMIT = {YES | NO} 
</pre>
<p>The default is NO. This option must be entered only on the command line or in a configuration file.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Use this option carefully; applications may be slowed if cursors are opened and closed many times because of the need to re-parse for each OPEN statement. See <a href="pc_10opt.htm#i9360">&#34;CLOSE_ON_COMMIT&#34;</a>.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1522"></a>
<div id="LNPCC3139" class="sect1">
<h2 class="sect1">Using the SAVEPOINT Statement</h2>
<p>You use the SAVEPOINT statement to mark and name the current point in the processing of a transaction. Each marked point is called a <span class="italic">savepoint</span>. For example, the following statement marks a savepoint named <span class="italic">start_delete</span>:<a id="sthref323"></a><a id="sthref324"></a><a id="sthref325"></a></p>
<pre>EXEC SQL SAVEPOINT start_delete; 
</pre>
<p>Savepoints let you divide long transactions, giving you more control over complex procedures. For example, if a transaction performs several functions, you can mark a savepoint before each function. Then, if a function fails, you can easily restore the Oracle data to its former state, recover, then reexecute the function.<a id="sthref326"></a><a id="sthref327"></a></p>
<p>To undo part of a transaction, you use savepoints with the ROLLBACK statement and its TO SAVEPOINT clause. In the following example, you access the table MAIL_LIST to insert new listings, update old listings, and delete (a few) inactive listings. After the delete, you check the third element of <span class="italic">sqlerrd</span> in the SQLCA for the number of rows deleted. If the number is unexpectedly large, you roll back to the savepoint <span class="italic">start_delete</span>, undoing just the delete.<a id="sthref328"></a></p>
<pre>... 
for (;;) 
{ 
   printf(&#34;Customer number? &#34;); 
   gets(temp);
   cust_number = atoi(temp);
   printf(&#34;Customer name? &#34;); 
   gets(cust_name); 
  EXEC SQL INSERT INTO mail_list (custno, cname, stat) 
     VALUES (:cust_number, :cust_name, &#39;ACTIVE&#39;); 
... 
} 
 
for (;;) 
{ 
   printf(&#34;Customer number? &#34;); 
   gets(temp);
   cust_number = atoi(temp);
   printf(&#34;New status? &#34;); 
   gets(new_status); 
   EXEC SQL UPDATE mail_list 
     SET stat = :new_status 
     WHERE custno = :cust_number; 
} 
/* mark savepoint */ 
EXEC SQL SAVEPOINT start_delete; 
 
EXEC SQL DELETE FROM mail_list 
    WHERE stat = &#39;INACTIVE&#39;; 
if (sqlca.sqlerrd[2] &lt; 25)  /* check number of rows deleted */ 
    printf(&#34;Number of rows deleted is  %d\n&#34;, sqlca.sqlerrd[2]); 
else 
{ 
    printf(&#34;Undoing deletion of %d rows\n&#34;, sqlca.sqlerrd[2]); 
    EXEC SQL WHENEVER SQLERROR GOTO sql_error; 
    EXEC SQL ROLLBACK TO SAVEPOINT start_delete; 
} 
 
EXEC SQL WHENEVER SQLERROR CONTINUE; 
EXEC SQL COMMIT WORK RELEASE; 
exit(0); 
sql_error: 
EXEC SQL WHENEVER SQLERROR CONTINUE; 
EXEC SQL ROLLBACK WORK RELEASE; 
printf(&#34;Processing error\n&#34;); 
exit(1); 
</pre>
<p>Rolling back to a savepoint erases any savepoints marked after that savepoint. The savepoint to which you roll back, however, is not erased. For example, if you mark five savepoints, then roll back to the third, only the fourth and fifth are erased.<a id="sthref329"></a></p>
<p>If you give two savepoints the same name, the earlier savepoint is erased. A COMMIT or ROLLBACK statement erases all savepoints.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_09err.htm#i12340">&#34;Using the WHENEVER Directive&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="i1526"></a>
<div id="LNPCC3140" class="sect1">
<h2 class="sect1">The ROLLBACK Statement</h2>
<p>You use the ROLLBACK statement to undo pending changes made to the database. For example, if you make a mistake, such as deleting the wrong row from a table, you can use ROLLBACK to restore the original data. The TO SAVEPOINT clause lets you roll back to an intermediate statement in the current transaction, so you do not have to undo all your changes.<a id="sthref330"></a><a id="sthref331"></a><a id="sthref332"></a><a id="sthref333"></a><a id="sthref334"></a></p>
<p>If you start a transaction that does not complete (a SQL statement might not execute successfully, for example), ROLLBACK lets you return to the starting point, so that the database is not left in an inconsistent state. Specifically, the ROLLBACK statement<a id="sthref335"></a></p>
<ul>
<li>
<p>Undoes all changes made to the database during the current transaction</p>
</li>
<li>
<p>Erases all savepoints</p>
</li>
<li>
<p>Ends the transaction</p>
</li>
<li>
<p>Releases all row and table locks, but not parse locks</p>
</li>
<li>
<p>Closes cursors referenced in a CURRENT OF clause or, when MODE=ANSI, closes <span class="italic">all</span> explicit cursors</p>
</li>
</ul>
<p>The ROLLBACK statement has no effect on the values of host variables or on the flow of control in your program.</p>
<p>When MODE=ORACLE, explicit cursors not referenced in a CURRENT OF clause remain open across ROLLBACKs.</p>
<p>Specifically, the ROLLBACK TO SAVEPOINT statement</p>
<ul>
<li>
<p>Undoes changes made to the database since the specified savepoint was marked</p>
</li>
<li>
<p>Erases all savepoints marked after the specified savepoint</p>
</li>
<li>
<p>Releases all row and table locks acquired since the specified savepoint was marked</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot specify the RELEASE option in a ROLLBACK TO SAVEPOINT statement.<a id="sthref336"></a><a id="sthref337"></a></div>
</li>
</ul>
<p>Because they are part of exception processing, ROLLBACK statements should be placed in error handling routines, off the main path through your program. In the following example, you roll back your transaction and disconnect from Oracle: <a id="sthref338"></a> <a id="sthref339"></a></p>
<pre>EXEC SQL ROLLBACK WORK RELEASE; 
</pre>
<p>The optional keyword WORK provides ANSI compatibility. The RELEASE option frees all resources held by your program and disconnects from the database. <a id="sthref340"></a> <a id="sthref341"></a></p>
<p>If a WHENEVER SQLERROR GOTO statement branches to an error handling routine that includes a ROLLBACK statement, your program might enter an infinite loop if the ROLLBACK fails with an error. You can avoid this by coding WHENEVER SQLERROR CONTINUE before the ROLLBACK statement, as shown in the following example: <a id="sthref342"></a> <a id="sthref343"></a></p>
<pre>EXEC SQL WHENEVER SQLERROR GOTO sql_error; 
 
for (;;) 
{ 
   printf(&#34;Employee number? &#34;); 
    gets(temp);
    emp_number = atoi(temp);
   printf(&#34;Employee name? &#34;); 
   gets(emp_name); 
   EXEC SQL INSERT INTO emp (empno, ename) 
       VALUES (:emp_number, :emp_name); 
... 
} 
... 
sql_error: 
EXEC SQL WHENEVER SQLERROR CONTINUE; 
EXEC SQL ROLLBACK WORK RELEASE; 
printf(&#34;Processing error\n&#34;); 
exit(1); 
</pre>
<p>Oracle automatically rolls back transactions if your program terminates abnormally.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1556">&#34;The RELEASE Option&#34;</a>.<a id="sthref344"></a><a id="sthref345"></a><a id="sthref346"></a></div>
<div id="LNPCC3141" class="sect2"><a id="sthref347"></a>
<h3 class="sect2">Statement-Level Rollbacks</h3>
<p>Before executing any SQL statement, Oracle marks an implicit savepoint (not available to you). Then, if the statement fails, Oracle automatically rolls it back and returns the applicable error code to <span class="italic">sqlcode</span> in the SQLCA. For example, if an INSERT statement causes an error by trying to insert a duplicate value in a unique index, the statement is rolled back.<a id="sthref348"></a><a id="sthref349"></a></p>
<p>Oracle can also roll back single SQL statements to break deadlocks. Oracle signals an error to one of the participating transactions and rolls back the current statement in that transaction.<a id="sthref350"></a><a id="sthref351"></a></p>
<p>Only work started by the failed SQL statement is lost; work done before that statement in the current transaction is saved. Thus, if a data definition statement fails, the automatic commit that precedes it is not undone.<a id="sthref352"></a></p>
<p>Before executing a SQL statement, Oracle must parse it, that is, examine it to make sure it follows syntax rules and refers to valid database objects. Errors detected while executing a SQL statement cause a rollback, but errors detected while parsing the statement do not.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1556"></a>
<div id="LNPCC3142" class="sect1">
<h2 class="sect1">The RELEASE Option</h2>
<p>Oracle automatically rolls back changes if your program terminates abnormally. Abnormal termination occurs when your program does not explicitly commit or roll back work and disconnect from Oracle using the RELEASE option. Normal termination occurs when your program runs its course, closes open cursors, explicitly commits or rolls back work, disconnects from Oracle, and returns control to the user.<a id="sthref353"></a><a id="sthref354"></a><a id="sthref355"></a></p>
<p>Your program will exit gracefully if the last SQL statement it executes is either</p>
<pre>EXEC SQL COMMIT WORK RELEASE; 
</pre>
<p>or</p>
<pre>EXEC SQL ROLLBACK WORK RELEASE;
 
</pre>
<p>where the token WORK is optional. Otherwise, locks and cursors acquired by your user session are held after program termination until Oracle recognizes that the user session is no longer active. This might cause other users in a multiuser environment to wait longer than necessary for the locked resources.<a id="sthref356"></a></p>
</div>
<!-- class="sect1" -->
<a id="i1699"></a>
<div id="LNPCC3143" class="sect1">
<h2 class="sect1">The SET TRANSACTION Statement</h2>
<p>You use the SET TRANSACTION statement to begin a read-only transaction. Because they allow &#34;repeatable reads,&#34; read-only transactions are useful for running multiple queries against one or more tables while other users update the same tables. An example of the SET TRANSACTION statement follows: <a id="sthref357"></a> <a id="sthref358"></a></p>
<pre>EXEC SQL SET TRANSACTION READ ONLY;
 
</pre>
<p>The SET TRANSACTION statement must be the first SQL statement in a read-only transaction and can appear only once in a transaction. The READ ONLY parameter is required. Its use does not affect other transactions. <a id="sthref359"></a> <a id="sthref360"></a> <a id="sthref361"></a></p>
<p>Only the SELECT, COMMIT, and ROLLBACK statements are allowed in a read-only transaction. For example, including an INSERT, DELETE, or SELECT FOR UPDATE OF statement causes an error. <a id="sthref362"></a> <a id="sthref363"></a></p>
<p>During a read-only transaction, all queries refer to the same snapshot of the database, providing a multitable, multiquery, read-consistent view. Other users can continue to query or update data as usual. <a id="sthref364"></a> <a id="sthref365"></a></p>
<p>A COMMIT, ROLLBACK, or data definition statement ends a read-only transaction. (Recall that data definition statements issue an implicit COMMIT.)<a id="sthref366"></a></p>
<p>In the following example, as a store manager, you check sales activity for the day, the past week, and the past month by using a read-only transaction to generate a summary report. The report is unaffected by other users updating the database during the transaction.<a id="sthref367"></a></p>
<pre>EXEC SQL SET TRANSACTION READ ONLY; 
EXEC SQL SELECT sum(saleamt) INTO :daily FROM sales 
    WHERE saledate = SYSDATE; 
EXEC SQL SELECT sum(saleamt) INTO :weekly FROM sales 
    WHERE saledate &gt; SYSDATE - 7; 
EXEC SQL SELECT sum(saleamt) INTO :monthly FROM sales 
    WHERE saledate &gt; SYSDATE - 30; 
EXEC SQL COMMIT WORK; 
    /* simply ends the transaction since there are no changes 
       to make permanent */ 
/* format and print report */ 
</pre></div>
<!-- class="sect1" -->
<a id="i1704"></a>
<div id="LNPCC3144" class="sect1">
<h2 class="sect1">Override Default Locking</h2>
<p>By default, Oracle automatically locks many data structures for you. However, you can request specific data locks on rows or tables when it is to your advantage to override default locking. Explicit locking lets you share or deny access to a table for the duration of a transaction or ensure multitable and multiquery read consistency.<a id="sthref368"></a><a id="sthref369"></a><a id="sthref370"></a><a id="sthref371"></a></p>
<p>With the SELECT FOR UPDATE OF statement, you can explicitly lock specific rows of a table to make sure they do not change before an UPDATE or DELETE is executed. However, Oracle automatically obtains row-level locks at UPDATE or DELETE time. So, use the FOR UPDATE OF clause only if you want to lock the rows <span class="italic">before</span> the UPDATE or DELETE.<a id="sthref372"></a><a id="sthref373"></a><a id="sthref374"></a><a id="sthref375"></a></p>
<p>You can explicitly lock entire tables using the LOCK TABLE statement.</p>
<a id="i1362"></a>
<div id="LNPCC3145" class="sect2">
<h3 class="sect2">Using FOR UPDATE OF</h3>
<p>When you DECLARE a cursor that is referenced in the CURRENT OF clause of an UPDATE or DELETE statement, you use the FOR UPDATE OF clause to acquire exclusive row locks. SELECT FOR UPDATE OF identifies the rows that will be updated or deleted, then locks each row in the active set. This is useful, for example, when you want to base an update on the existing values in a row. You must make sure the row is not changed by another user before your update.<a id="sthref376"></a><a id="sthref377"></a></p>
<p>The FOR UPDATE OF clause is optional. For example, instead of coding</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
    SELECT ename, job, sal FROM emp WHERE deptno = 20 
        FOR UPDATE OF sal; 
</pre>
<p>you can drop the FOR UPDATE OF clause and simply code</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
    SELECT ename, job, sal FROM emp WHERE deptno = 20; 
</pre>
<p>The CURRENT OF clause signals the precompiler to add a FOR UPDATE clause if necessary. You use the CURRENT OF clause to refer to the latest row FETCHed from a cursor.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_06sql.htm#i6550">&#34;The CURRENT OF Clause&#34;</a></div>
<div id="LNPCC3146" class="sect3"><a id="sthref378"></a>
<h4 class="sect3">Restrictions</h4>
<p>If you use the FOR UPDATE OF clause, you cannot reference multiple tables.</p>
<p>An explicit FOR UPDATE OF or an implicit FOR UPDATE acquires exclusive row locks. All rows are locked at the OPEN, not as they are FETCHed. Row locks are released when you COMMIT or ROLLBACK (except when you ROLLBACK to a savepoint). Therefore, you cannot FETCH from a FOR UPDATE cursor after a COMMIT. <a id="sthref379"></a> <a id="sthref380"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1361"></a>
<div id="LNPCC3147" class="sect2">
<h3 class="sect2">Using LOCK TABLE</h3>
<p>You use the LOCK TABLE statement to lock one or more tables in a specified lock mode. For example, the statement in the following section, locks the EMP table in <span class="italic">row share</span> mode. Row share locks allow concurrent access to a table; they prevent other users from locking the entire table for exclusive use.<a id="sthref381"></a><a id="sthref382"></a><a id="sthref383"></a><a id="sthref384"></a><a id="sthref385"></a><a id="sthref386"></a></p>
<pre>EXEC SQL LOCK TABLE EMP IN ROW SHARE MODE NOWAIT; 
</pre>
<p>The lock mode determines what other locks can be placed on the table. For example, many users can acquire row share locks on a table at the same time, but only one user at a time can acquire an <span class="italic">exclusive</span> lock. While one user has an exclusive lock on a table, no other users can INSERT, UPDATE, or DELETE rows in that table.</p>
<p>For more information about lock modes, see <a class="olink CNCPT" href="../CNCPT/toc.htm"><span class="italic">Oracle Database Concepts</span></a>.</p>
<p>The optional keyword NOWAIT tells Oracle not to wait for a table if it has been locked by another user. Control is immediately returned to your program, so it can do other work before trying again to acquire the lock. (You can check <span class="italic">sqlcode</span> in the SQLCA to see if the LOCK TABLE failed.) If you omit NOWAIT, Oracle waits until the table is available; the wait has no set limit.<a id="sthref387"></a><a id="sthref388"></a><a id="sthref389"></a><a id="sthref390"></a></p>
<p>A table lock never keeps other users from querying a table, and a query never acquires a table lock. So, a query never blocks another query or an update, and an update never blocks a query. Only if two different transactions try to update the same row will one transaction wait for the other to complete.<a id="sthref391"></a></p>
<p><a id="sthref392"></a>Any LOCK TABLE statement implicitly closes all cursors.</p>
<p>Table locks are released when your transaction issues a COMMIT or ROLLBACK.<a id="sthref393"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1553"></a>
<div id="LNPCC3148" class="sect1">
<h2 class="sect1">Fetch Across COMMITs</h2>
<p>If you want to intermix COMMITs and FETCHes, do not use the CURRENT OF clause. Instead, SELECT the ROWID of each row, then use that value to identify the current row during the update or delete. An example follows:<a id="sthref394"></a><a id="sthref395"></a><a id="sthref396"></a></p>
<pre>... 
EXEC SQL DECLARE emp_cursor CURSOR FOR 
    SELECT ename, sal, ROWID FROM emp WHERE job = &#39;CLERK&#39;; 
... 
EXEC SQL OPEN emp_cursor; 
EXEC SQL WHENEVER NOT FOUND GOTO ... 
for (;;) 
{ 
    EXEC SQL FETCH emp_cursor INTO :emp_name, :salary, :row_id; 
    ... 
    EXEC SQL UPDATE emp SET sal = :new_salary 
        WHERE ROWID = :row_id; 
    EXEC SQL COMMIT; 
... 
} 
</pre>
<p>Note, however, that the FETCHed rows are <span class="italic">not</span> locked. So, you might get inconsistent results if another user modifies a row after you read it but before you update or delete it.</p>
</div>
<!-- class="sect1" -->
<a id="i1713"></a>
<div id="LNPCC3149" class="sect1">
<h2 class="sect1">Distributed Transactions Handling</h2>
<p>A <span class="italic">distributed database</span> is a single logical database comprising multiple physical databases at different nodes. A <span class="italic">distributed statement</span> is any SQL statement that accesses a remote node using a database link. A <span class="italic">distributed transaction</span> includes at least one distributed statement that updates data at multiple nodes of a distributed database. If the update affects only one node, the transaction is non-distributed.</p>
<p>When you issue a COMMIT, changes to each database affected by the distributed transaction are made permanent. If instead you issue a ROLLBACK, all the changes are undone. However, if a network or machine fails during the commit or rollback, the state of the distributed transaction might be unknown or <span class="italic">in doubt</span>. In such cases, if you have FORCE TRANSACTION system privileges, you can manually commit or roll back the transaction at your local database by using the FORCE clause. The transaction must be identified by a quoted literal containing the transaction ID, which can be found in the data dictionary view DBA_2PC_PENDING. Some examples follow:<a id="sthref397"></a></p>
<pre>EXEC SQL COMMIT FORCE &#39;22.31.83&#39;; 
... 
EXEC SQL ROLLBACK FORCE &#39;25.33.86&#39;; 
</pre>
<p>FORCE commits or rolls back only the specified transaction and does not affect your current transaction. You cannot manually roll back in-doubt transactions to a savepoint.</p>
<p>The COMMENT clause in the COMMIT statement lets you specify a Comment to be associated with a distributed transaction. If ever the transaction is in doubt, Oracle stores the text specified by COMMENT in the data dictionary view DBA_2PC_PENDING along with the transaction ID. The text must be a quoted literal 50 characters in length. An example follows:</p>
<pre>EXEC SQL COMMIT COMMENT &#39;In-doubt trans; notify Order Entry&#39;; 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The COMMENT clause will be deprecated in a future release. Oracle recommends that you use transaction naming instead.</div>
<p>For more information about distributed transactions, see <a class="olink CNCPT" href="../CNCPT/toc.htm"><span class="italic">Oracle Database Concepts</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="i1718"></a>
<div id="LNPCC3150" class="sect1">
<h2 class="sect1">Guidelines</h2>
<p>The following guidelines will help you avoid some common problems.</p>
<div id="LNPCC3151" class="sect2"><a id="sthref398"></a>
<h3 class="sect2">Designing Applications</h3>
<p>When designing your application, group logically related actions together in one transaction. A well-designed transaction includes all the steps necessary to accomplish a given task&mdash;no more and no less.</p>
<p>Data in the tables you reference must be left in a consistent state. So, the SQL statements in a transaction should change the data in a consistent way.<a id="sthref399"></a><a id="sthref400"></a> For example, a transfer of funds between two bank accounts should include a debit to one account and a credit to another. Both updates should either succeed or fail together. An unrelated update, such as a new deposit to one account, should not be included in the transaction.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3152" class="sect2"><a id="sthref401"></a>
<h3 class="sect2">Obtaining Locks</h3>
<p>If your application programs include SQL locking statements, make sure the Oracle users requesting locks have the privileges needed to obtain the locks. Your DBA can lock any table. Other users can lock tables they own or tables for which they have a privilege, such as ALTER, SELECT, INSERT, UPDATE, or DELETE.<a id="sthref402"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3153" class="sect2"><a id="sthref403"></a>
<h3 class="sect2">Using PL/SQL</h3>
<p>If a PL/SQL block is part of a transaction, COMMITs and ROLLBACKs inside the block affect the whole transaction. In the following example, the ROLLBACK undoes changes made by the UPDATE <span class="italic">and</span> the INSERT: <a id="sthref404"></a> <a id="sthref405"></a></p>
<pre>EXEC SQL INSERT INTO EMP ... 
EXEC SQL EXECUTE 
    BEGIN 
        UPDATE emp ... 
        ... 
    EXCEPTION 
        WHEN DUP_VAL_ON_INDEX THEN 
            ROLLBACK; 
        ... 
    END; 
END-EXEC; 
... 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_02prc.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_04dat.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>