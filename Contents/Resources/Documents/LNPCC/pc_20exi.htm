<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78020"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/User%20Exits"></a><title>User Exits</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:55Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_19ott.htm" title="Previous" type="text/html"/>
<link rel="Next" href="partpage3.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">26/35</span> <!-- End Header -->
<div id="LNPCC4492" class="chapter"><a id="g11748"></a> <a id="i8396"></a>
<h1 class="chapter"><span class="secnum">20</span> User Exits</h1>
<p>This chapter focuses on writing user exits for your Oracle Tools applications. You learn how C subroutines can do certain jobs more quickly and easily than SQL*Forms and Oracle Forms. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i1842">What Is a User Exit?</a></p>
</li>
<li>
<p><a href="#i8171">Why Write a User Exit?</a></p>
</li>
<li>
<p><a href="#i1853">Developing a User Exit</a></p>
</li>
<li>
<p><a href="#i1858">Writing a User Exit</a></p>
</li>
<li>
<p><a href="#i1736">EXEC TOOLS Statements</a></p>
</li>
<li>
<p><a href="#i1863">Calling a User Exit</a></p>
</li>
<li>
<p><a href="#i1868">Passing Parameters to a User Exit</a></p>
</li>
<li>
<p><a href="#i1873">Returning Values to a Form</a></p>
</li>
<li>
<p><a href="#i1878">An Example</a></p>
</li>
<li>
<p><a href="#i1883">Precompiling and Compiling a User Exit</a></p>
</li>
<li>
<p><a href="#i1888">Example Program: A User Exit</a></p>
</li>
<li>
<p><a href="#i1893">Using the GENXTB Utility</a></p>
</li>
<li>
<p><a href="#i1898">Linking a User Exit into SQL*Forms</a></p>
</li>
<li>
<p><a href="#i1740">Guidelines</a></p>
</li>
</ul>
<p>This chapter is supplemental. For more information about user exits, refer to the <span class="italic">SQL*Forms Designer&#39;s Reference</span>, the <span class="italic">Oracle Forms Reference Manual, Vol. 2</span>, and your system-specific Oracle documentation. <a id="sthref2300"></a></p>
<a id="i1842"></a>
<div id="LNPCC4493" class="sect1">
<h2 class="sect1">What Is a User Exit?</h2>
<p>A <span class="italic">user exit</span> is a C subroutine written by you and called by Oracle Forms to do special-purpose processing. You can embed SQL statements and PL/SQL blocks in your user exit, then precompile it as you would a host program.</p>
<p>When called by an Oracle Forms V3 trigger, the user exit runs, then returns a status code to Oracle Forms. Your exit can display messages on the Oracle Forms status line, get and set field values, do high-speed computations and table lookups, and manipulate Oracle data.</p>
</div>
<!-- class="sect1" -->
<a id="i8171"></a>
<div id="LNPCC4494" class="sect1">
<h2 class="sect1">Why Write a User Exit?</h2>
<p>SQL*Forms provides the ability to use PL/SQL blocks in triggers. So, in most cases, instead of calling a user exit, you can use the procedural power of PL/SQL. If the need arises, you can call user exits from a PL/SQL block with the USER_EXIT function. User exits are harder to write and implement than SQL, PL/SQL, or SQL*Forms commands. So, you will probably use them only to do processing that is beyond the scope of SQL, PL/SQL, and SQL*Forms. Some common uses follow:<a id="sthref2301"></a></p>
<ul>
<li>
<p>Operations more quickly or easily done in a third generation languages like C (numerical integration, for instance)</p>
</li>
<li>
<p>Controlling real time devices or processes (issuing a sequence of instructions to a printer or graphics device, for example)</p>
</li>
<li>
<p>Data manipulations that need extended procedural capabilities (recursive sorting, for example)</p>
</li>
<li>
<p>Special file I/O operations</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1853"></a>
<div id="LNPCC4495" class="sect1">
<h2 class="sect1">Developing a User Exit</h2>
<p>This section outlines the way to develop a SQL*Forms user exit; later sections go into more detail.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1736">&#34;EXEC TOOLS Statements&#34;</a> for more information about the EXEC TOOLS options available with Oracle Forms, V4.</div>
<p>To incorporate a user exit into a form, you take the following steps:</p>
<ul>
<li>
<p>Write the user exit in Pro*C.</p>
</li>
<li>
<p>Precompile the source code.</p>
</li>
<li>
<p>Compile the. c file from step 2.</p>
</li>
<li>
<p>Use the GENXTB utility to create a database table, IAPXTB.</p>
</li>
<li>
<p>Use the GENXTB form in SQL*Forms to insert your user exit information into the table.</p>
</li>
<li>
<p>Use the GENXTB utility to read the information from the table and create an IAPXIT source code module. Then compile the source code module.</p>
</li>
<li>
<p>Create a new SQL*Forms executable by linking the standard SQL*Forms modules, your user exit object, and the IAPXIT object created in step 6.</p>
</li>
<li>
<p>In the form, define a trigger to call the user exit.</p>
</li>
<li>
<p>Instruct operators to use the new IAP when running the form. This is unnecessary if the new IAP replaces the standard one. For details, see the Oracle installation or user&#39;s guide for your system.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1858"></a>
<div id="LNPCC4496" class="sect1">
<h2 class="sect1">Writing a User Exit</h2>
<p>You can use the following kinds of statements to write your SQL*Forms user exit:<a id="sthref2302"></a></p>
<ul>
<li>
<p>C code</p>
</li>
<li>
<p>EXEC SQL</p>
</li>
<li>
<p>EXEC ORACLE</p>
</li>
<li>
<p>EXEC TOOLS</p>
</li>
</ul>
<p>This section focuses on the EXEC TOOLS statements, which let you pass values between SQL*Forms and a user exit.</p>
<div id="LNPCC4497" class="sect2"><a id="sthref2303"></a>
<h3 class="sect2">Requirements for Variables</h3>
<p>The variables used in EXEC TOOLS statements must correspond to field names used in the form definition. <a id="sthref2304"></a><a id="sthref2305"></a><a id="sthref2306"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1736"></a>
<div id="LNPCC4498" class="sect1">
<h2 class="sect1">EXEC TOOLS Statements <a id="sthref2307"></a><a id="sthref2308"></a><a id="sthref2309"></a><a id="sthref2310"></a></h2>
<p>EXEC TOOLS statements support the basic Oracle Toolset by providing a generic way to handle get, set, and exception callbacks from user exits. The following discussion focuses on Oracle Forms but the same concepts apply to Oracle Report.</p>
<div id="LNPCC4499" class="sect2"><a id="sthref2311"></a>
<h3 class="sect2">Writing a Toolset User Exit</h3>
<p>Besides EXEC SQL, EXEC ORACLE, and host language statements, you can use the following EXEC TOOLS statements to write an Oracle Forms user exit:</p>
<ul>
<li>
<p>SET</p>
</li>
<li>
<p>GET</p>
</li>
<li>
<p>SET CONTEXT</p>
</li>
<li>
<p>GET CONTEXT</p>
</li>
<li>
<p>MESSAGE</p>
</li>
</ul>
<p>The EXEC TOOLS GET and SET statements replace the EXEC IAF GET and PUT statements used with earlier versions of Oracle Forms. Unlike IAF GET and PUT, however, TOOLS GET and SET accept indicator variables. The EXEC TOOLS MESSAGE statement replaces the message-handling function <span class="italic">sqliem</span>. Now, let us take a brief look at all the EXEC TOOLS statements. For more information, see the <span class="italic">Oracle Forms Reference Manual, Vol 2</span>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4500" class="sect2"><a id="sthref2312"></a>
<h3 class="sect2">EXEC TOOLS SET <a id="sthref2313"></a></h3>
<p>The EXEC TOOLS SET statement passes values from a user exit to Oracle Forms. Specifically, it assigns the values of host variables and constants to Oracle Forms variables and items. Values passed to form items display after the user exit returns control to the form. To code the EXEC TOOLS SET statement, you use the syntax</p>
<pre>EXEC TOOLS SET form_variable[, ...] 
     VALUES ({:host_variable :indicator | constant}[, ...]); 
</pre>
<p>where <span class="italic">form_variable</span> is an Oracle Forms field, block.field, system variable, or global variable, or a host variable (prefixed with a colon) containing the value of one of the foregoing items. In the following example, a user exit passes an employee name to Oracle Forms:</p>
<pre>char ename[20];
short ename_ind;

...

    strcpy(ename, &#34;MILLER&#34;);
    ename_ind = 0;
    EXEC TOOLS SET emp.ename VALUES (:ename :ename_ind);
</pre>
<p>In this example, <span class="italic">emp.ename</span> is an Oracle Forms block.field.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4501" class="sect2"><a id="sthref2314"></a>
<h3 class="sect2">EXEC TOOLS GET <a id="sthref2315"></a></h3>
<p>The EXEC TOOLS GET statement passes values from Oracle Forms to a user exit. Specifically, it assigns the values of Oracle Forms variables and items to host variables. As soon as the values are passed, the user exit can use them for any purpose. To code the EXEC TOOLS GET statement, you use the syntax</p>
<pre>EXEC TOOLS GET form_variable[, ...] 
    INTO :host_variable:indicator[, ...]; 
</pre>
<p>where <span class="italic">form_variable</span> is an Oracle Forms field, block.field, system variable, or global variable, or a host variable (prefixed with a colon) containing the value of one of the foregoing items. In the following example, Oracle Forms passes an item name from a block to your user exit:</p>
<pre>...
char     name_buff[20];
VARCHAR  name_fld[20];
 
strcpy(name_fld.arr, &#34;EMP.NAME&#34;);
name_fld.len = strlen(name_fld.arr);
EXEC TOOLS GET :name_fld INTO :name_buff;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4502" class="sect2"><a id="sthref2316"></a>
<h3 class="sect2">EXEC TOOLS SET CONTEXT <a id="sthref2317"></a></h3>
<p>The EXEC TOOLS SET CONTEXT statement saves context information from a user exit for later use in another user exit. A pointer variable points to a block of memory in which the context information is stored. With SET CONTEXT, you need not declare a global variable to hold the information. To code the EXEC TOOLS SET CONTEXT statement, you use the syntax</p>
<pre>EXEC TOOLS SET CONTEXT :host_pointer_variable 
    IDENTIFIED BY context_name; 
</pre>
<p>where <span class="italic">context_name</span> is an undeclared identifier or a character host variable (prefixed with a colon) that names the context area.</p>
<pre>... 
char  *context_ptr; 
char  context[20]; 
 
strcpy(context, &#34;context1&#34;) 
EXEC TOOLS SET CONTEXT :context IDENTIFIED BY application1; 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4503" class="sect2"><a id="sthref2318"></a>
<h3 class="sect2">EXEC TOOLS GET CONTEXT <a id="sthref2319"></a></h3>
<p>The EXEC TOOLS GET CONTEXT statement retrieves context information (saved earlier by SET CONTEXT) into a user exit. A host-language pointer variable points to a block of memory in which the context information is stored. To code the EXEC TOOLS GET CONTEXT statement, you use the syntax</p>
<pre>EXEC TOOLS GET CONTEXT context_name 
    INTO :host_pointer_variable; 
</pre>
<p>where <span class="italic">context_name</span> is an undeclared identifier or a character host variable (prefixed with a colon) that names the context area. In the following example, your user exit retrieves context information 1saved earlier:</p>
<pre>... 
char  *context_ptr; 
 
EXEC TOOLS GET CONTEXT application1 INTO :context_ptr;  
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4504" class="sect2"><a id="sthref2320"></a>
<h3 class="sect2">EXEC TOOLS MESSAGE <a id="sthref2321"></a></h3>
<p>The EXEC TOOLS MESSAGE statement passes a message from a user exit to Oracle Forms. The message is displayed on the Oracle Forms message line after the user exit returns control to the form. To code the EXEC TOOLS MESSAGE statement, you use the syntax</p>
<pre>EXEC TOOLS MESSAGE message_text [severity_code]; 
</pre>
<p>where <span class="italic">message_text</span> is a quoted string or a character host variable (prefixed with a colon), and the optional <span class="italic">severity_code</span> is an integer constant or an integer host variable (prefixed with a colon). The MESSAGE statement does <span class="italic">not</span> accept indicator variables. In the following example, your user exit passes an error message to Oracle Forms:</p>
<pre>EXEC TOOLS MESSAGE &#39;Bad field name! Please reenter.&#39;; 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1863"></a>
<div id="LNPCC4505" class="sect1">
<h2 class="sect1">Calling a User Exit</h2>
<p>You call a user exit from a SQL*Forms trigger using a packaged procedure named USER_EXIT (supplied with SQL*Forms). The syntax you use is</p>
<pre>USER_EXIT(user_exit_string [, error_string]); <a id="sthref2322"></a> 
</pre>
<p>where <span class="italic">user_exit_string</span> contains the name of the user exit plus optional parameters and <span class="italic">error_string</span> contains an error message issued by SQL*Forms if the user exit fails. For example, the following trigger command calls a user exit named LOOKUP:</p>
<pre>USER_EXIT(&#39;LOOKUP&#39;); 
</pre>
<p>Notice that the user exit string is enclosed by single (not double) quotes.</p>
</div>
<!-- class="sect1" -->
<a id="i1868"></a>
<div id="LNPCC4506" class="sect1">
<h2 class="sect1">Passing Parameters to a User Exit</h2>
<p><a id="sthref2323"></a>When you call a user exit, SQL*Forms passes it the following parameters automatically:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="parameters passed on a user exit" summary="Passing Parameters to a User Exit" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t3">Parameters</th>
<th class="cellalignment832" id="r1c2-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t3" headers="r1c1-t3">Command Line</td>
<td class="cellalignment833" headers="r2c1-t3 r1c2-t3">Is the user exit string.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t3" headers="r1c1-t3">Command Line Length</td>
<td class="cellalignment833" headers="r3c1-t3 r1c2-t3">Is the length (in characters) of the user exit string.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t3" headers="r1c1-t3">Error Message</td>
<td class="cellalignment833" headers="r4c1-t3 r1c2-t3">Is the error string (failure message) if one is defined.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t3" headers="r1c1-t3">Error Message Length</td>
<td class="cellalignment833" headers="r5c1-t3 r1c2-t3">Is the length of the error string.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t3" headers="r1c1-t3">In-Query</td>
<td class="cellalignment833" headers="r6c1-t3 r1c2-t3">Is a Boolean value indicating whether the exit was called in normal or query mode.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>However, the user exit string provides the ability to pass additional parameters to the user exit. For example, the following trigger command passes two parameters and an error message to the user exit LOOKUP:</p>
<p>Notice that the user exit string is enclosed by single (not double) quotes.</p>
<pre>USER_EXIT(&#39;LOOKUP 2025 A&#39;, &#39;Lookup failed&#39;);
 
</pre>
<p>You can use this feature to pass field names to the user exit, as the following example shows:</p>
<pre>USER_EXIT(&#39;CONCAT firstname, lastname, address&#39;);
 
</pre>
<p>However, it is up to the user exit, not SQL*Forms, to parse the user exit string.</p>
</div>
<!-- class="sect1" -->
<a id="i1873"></a>
<div id="LNPCC4507" class="sect1">
<h2 class="sect1">Returning Values to a Form</h2>
<p><a id="sthref2324"></a><a id="sthref2325"></a><a id="sthref2326"></a>When a user exit returns control to SQL*Forms, it must also return a code indicating whether it succeeded, failed, or suffered a fatal error. The return code is an integer constant defined by SQL*Forms (see the next section). The three results have the following meanings:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="descriptions of possible results" summary="descriptions of possible results" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t4"><span class="bold">Results</span></th>
<th class="cellalignment832" id="r1c2-t4">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t4" headers="r1c1-t4">success</td>
<td class="cellalignment833" headers="r2c1-t4 r1c2-t4">The user exit encountered no errors. SQL*Forms proceeds to the <span class="italic">success</span> label or the next step, unless the Reverse Return Code switch is set by the calling trigger step. <a id="sthref2327"></a></td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t4" headers="r1c1-t4">failure</td>
<td class="cellalignment833" headers="r3c1-t4 r1c2-t4">The user exit detected an error, such as an invalid value in a field. An optional message passed by the exit appears on the message line at the bottom of the SQL*Forms screen and on the Display Error screen. SQL*Forms responds as it does to a SQL statement that affects no rows.<a id="sthref2328"></a></td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t4" headers="r1c1-t4">fatal error</td>
<td class="cellalignment833" headers="r4c1-t4 r1c2-t4">The user exit detected a condition that makes further processing impossible, such as an execution error in a SQL statement. An optional error message passed by the exit appears on the SQL*Forms Display Error screen. SQL*Forms responds as it does to a fatal SQL error. If a user exit changes the value of a field, then returns a <span class="italic">failure</span> or <span class="italic">fatal error</span> code, SQL*Forms does <span class="italic">not</span> discard the change. Nor does SQL*Forms discard changes when the Reverse Return Code switch is set and a <span class="italic">success</span> code is returned.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<div id="LNPCC4508" class="sect2"><a id="sthref2329"></a>
<h3 class="sect2">The IAP Constants</h3>
<p>SQL*Forms defines three symbolic constants for use as return codes. Depending on the host language, they are prefixed with IAP or SQL. For example, they might be IAPSUCC, IAPFAIL, and IAPFTL.<a id="sthref2330"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4509" class="sect2"><a id="sthref2331"></a>
<h3 class="sect2">Using WHENEVER</h3>
<p>You can use the WHENEVER statement in an exit to detect invalid datatype conversions (SQLERROR), truncated values PUT into form fields (SQLWARNING), and queries that return no rows (NOT FOUND). <a id="sthref2332"></a><a id="sthref2333"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1878"></a>
<div id="LNPCC4510" class="sect1">
<h2 class="sect1">An Example</h2>
<p>The following example shows how a user exit that uses the EXEC TOOLS GET and PUT routines, as well as the <span class="italic">EXEC TOOLS MESSAGE</span> function, is coded.<a id="sthref2334"></a></p>
<pre>int
myexit()
{
    char field1[20], field2[20], value1[20], value2[20];
    char result_value[20];
    char errmsg[80];
    int errlen;

    #include sqlca.h
    EXEC SQL WHENEVER SQLERROR GOTO sql_error;
    /* get field values into form */
    EXEC TOOLS GET :field1, :field2 INTO :value1, :value2;
    /* manipulate the values to obtain result_val */
    ...
    /* put result_val into form field result */
    EXEC TOOLS PUT result VALUES (:result_val);
    return IAPSUCC;   /* trigger step succeeded */

sql_error:
    strcpy(errmsg, CONCAT(&#34;MYEXIT&#34;, sqlca.sqlerrm.sqlerrmc);
    errlen = strlen(errmsg);
    EXEC TOOLS MESSAGE :errmsg ; /* send error msg to Forms */
    return IAPFAIL;
</pre></div>
<!-- class="sect1" -->
<a id="i1883"></a>
<div id="LNPCC4511" class="sect1">
<h2 class="sect1">Precompiling and Compiling a User Exit</h2>
<p>User exits are precompiled like standalone host programs. For instructions on compiling a user exit, see the Oracle installation or user&#39;s guide for your system.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#g30455">Chapter 10, &#34; Precompiler Options&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="i1888"></a>
<div id="LNPCC4512" class="sect1">
<h2 class="sect1">Example Program: A User Exit<a id="sthref2335"></a></h2>
<p>The following example shows a user exit.</p>
<pre>/**************************************************************
Sample Program 5:  SQL*Forms User Exit

This user exit concatenates form fields.  To call the user 
exit from a SQL*Forms trigger, use the syntax

   user_exit(&#39;CONCAT field1, field2, ..., result_field&#39;);

where user_exit is a packaged procedure supplied with SQL*Forms
and CONCAT is the name of the user exit.  A sample form named
CONCAT invokes the user exit.
**************************************************************/

#define min(a, b) ((a &lt; b) ? a : b)
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* Include the SQL Communications Area, a structure through which
 * Oracle makes runtime status information such as error
 * codes, warning flags, and diagnostic text available to the
 * program.
 */
#include &lt;sqlca.h&gt;

/* All host variables used in embedded SQL in this example
 * appear in the Declare Section.
 */
EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR   field[81];
    VARCHAR   value[81];
    VARCHAR   result[241];
EXEC SQL END DECLARE SECTION;


/* Define the user exit, called &#34;concat&#34;. */
int concat(cmd, cmdlen, msg, msglen, query)
char *cmd;     /* command line in trigger step (&#34;CONCAT...&#34;) */
int  *cmdlen;  /* length of command line */
char *msg;     /* trigger step failure message from form */
int  *msglen;  /* length of failure message */
int  *query;   /* TRUE if invoked by post-query trigger,
                  FALSE otherwise */
{
    char *cp = cmd + 7;    /* pointer to field list in
                              cmd string; 7 characters
                              are needed for &#34;CONCAT &#34; */
    char *fp = (char*)&amp;field.arr[0];  /* pointer to a field name in
                                         cmd string */
    char  errmsg[81];      /* message returned to SQL*Forms
                              on error */
    int   errlen;          /* length of message returned
                              to SQL*Forms */

/* Branch to label sqlerror if an ORACLE error occurs. */
    EXEC SQL WHENEVER SQLERROR GOTO sqlerror;

    result.arr[0] = &#39;\0&#39;;

/* Parse field names from cmd string. */
    for (; *cp != &#39;\0&#39;; cp++)
    {
       if (*cp != &#39;,&#39; &amp;&amp; *cp != &#39; &#39;)
           /* Copy a field name into field.arr from cmd. */
       {
           *fp = *cp;
           fp++;
       }
       else
           if (*cp == &#39; &#39;)
           {   /* Have whole field name now. */
               *fp = &#39;\0&#39;;
               field.len = strlen((char *) field.arr);
               /* Get field value from form. */
               EXEC TOOLS GET :field INTO :value;
               value.arr[value.len] = &#39;\0&#39;;
               strcat((char *) result.arr, (char *) value.arr);
               fp = (char *)&amp;field.arr[0];  /* Reset field pointer. */
           }
    }

/* Have last field name now. */
    *fp = &#39;\0&#39;;
    field.len = strlen((char *) field.arr);
    result.len = strlen((char *) result.arr);

/* Put result into form. */
    EXEC TOOLS PUT :field VALUES (:result);

/* Trigger step succeeded. */
    return(IAPSUCC);

sqlerror:
    strcpy(errmsg, &#34;CONCAT: &#34;);
    strncat(errmsg, sqlca.sqlerrm.sqlerrmc, min(72,
        sqlca.sqlerrm.sqlerrml));
    errlen = strlen(errmsg);
/* Pass error message to SQL*Forms status line. */
     EXEC TOOLS MESSAGE :errmsg ;
    return(IAPFAIL);  /* Trigger step failed. */
}
</pre></div>
<!-- class="sect1" -->
<a id="i1893"></a>
<div id="LNPCC4513" class="sect1">
<h2 class="sect1">Using the GENXTB Utility</h2>
<p>The IAP program table IAPXTB in module IAPXIT contains an entry for each user exit linked into IAP. IAPXTB tells IAP the name, location, and host language of each user exit. When you add a new user exit to IAP, you must add a corresponding entry to IAPXTB. IAPXTB is derived from a database table, also named IAPXTB. You can modify the database table by running the GENXTB form on the operating system command line, as follows:<a id="sthref2336"></a><a id="sthref2337"></a><a id="sthref2338"></a></p>
<pre>RUNFORM GENXTB username/password 
</pre>
<p>A form is displayed for you to enter the following information for each user exit you define:</p>
<ul>
<li>
<p>Exit name</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1740">&#34;Guidelines&#34;</a></div>
</li>
<li>
<p>C-language code</p>
</li>
<li>
<p>Date created</p>
</li>
<li>
<p>Date last modified</p>
</li>
<li>
<p>Comments</p>
</li>
</ul>
<p>After modifying the IAPXTB database table, use the GENXTB utility to read the table and create an Assembler or C source program that defines the module IAPXIT and the IAPXTB program table it contains. The source language used depends on your operating system. The syntax you use to run the GENXTB utility is</p>
<pre>GENXTB username/password outfile 
</pre>
<p>where <span class="italic">outfile</span> is the name you give the Assembler or C source program that GENXTB creates. <a id="sthref2339"></a><a id="sthref2340"></a><a id="sthref2341"></a></p>
</div>
<!-- class="sect1" -->
<a id="i1898"></a>
<div id="LNPCC4514" class="sect1">
<h2 class="sect1">Linking a User Exit into SQL*Forms</h2>
<p>Before running a form that calls a user exit, you must link the user exit into IAP, the SQL*Forms component that runs a form. The user exit can be linked into your standard version of IAP or into a special version for those forms that call the exit. <a id="sthref2342"></a><a id="sthref2343"></a></p>
<p>To produce a new executable copy of IAP, link your user exit object module, the standard IAP modules, the IAPXIT module, and any modules needed from the Oracle and C link libraries.</p>
<p>The details of linking are system-dependent. Check the Oracle installation or user&#39;s guide for your system.</p>
</div>
<!-- class="sect1" -->
<a id="i1740"></a>
<div id="LNPCC4515" class="sect1">
<h2 class="sect1">Guidelines</h2>
<p>The guidelines in this section will help you avoid some common problems.</p>
<div id="LNPCC4516" class="sect2"><a id="sthref2344"></a>
<h3 class="sect2">Naming the Exit</h3>
<p>The name of your user exit cannot be an Oracle reserved word. Also avoid using names that conflict with the names of SQL*Forms commands, function codes, and externally defined names used by SQL*Forms. The name of the user exit entry point in the source code becomes the name of the user exit itself. The exit name must be a valid C function name, and a valid filename for your operating system.</p>
<p>SQL*Forms converts the name of a user exit to upper case before searching for the exit. Therefore, the exit name must be in upper case in your source code.<a id="sthref2345"></a><a id="sthref2346"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4517" class="sect2"><a id="sthref2347"></a>
<h3 class="sect2">Connecting to Oracle</h3>
<p>User exits communicate with Oracle using the connection made by SQL*Forms. However, a user exit can establish additional connections to any database using Oracle Net Services.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_03dbc.htm#i5996">&#34;Advanced Connection Options&#34;</a></div>
</div>
<!-- class="sect2" -->
<div id="LNPCC4518" class="sect2"><a id="sthref2348"></a>
<h3 class="sect2">Issuing I/O Calls</h3>
<p>File I/O is supported but screen I/O is not.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4519" class="sect2"><a id="sthref2349"></a>
<h3 class="sect2">Using Host Variables</h3>
<p>Restrictions on the use of host variables in a standalone program also apply to user exits. Host variables must be prefixed with a colon in EXEC SQL and EXEC TOOLS statements. The use of host arrays is not allowed in EXEC TOOLS statements.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4520" class="sect2"><a id="sthref2350"></a>
<h3 class="sect2">Updating Tables</h3>
<p>Generally, a user exit should not UPDATE database tables associated with a form. For example, suppose an operator updates a record in the SQL*Forms work space, then a user exit UPDATEs the corresponding row in the associated database table. When the transaction is COMMITted, the record in the SQL*Forms work space is applied to the table, overwriting the user exit UPDATE.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4521" class="sect2"><a id="sthref2351"></a>
<h3 class="sect2">Issuing Commands</h3>
<p>Avoid issuing a COMMIT or ROLLBACK command from your user exit because Oracle will commit or roll back work begun by the SQL*Forms operator, not just work done by the user exit. Instead, issue the COMMIT or ROLLBACK from the SQL*Forms trigger. This also applies to data definition commands (such as ALTER, CREATE, and GRANT) because they issue an implicit COMMIT before and after executing.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_19ott.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="partpage3.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>