<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78002"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Precompiler%20Concepts"></a><title>Precompiler Concepts</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:35Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_01int.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_03dbc.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/35</span> <!-- End Header -->
<div id="LNPCC3059" class="chapter"><a id="g15170"></a> <a id="i1829"></a>
<h1 class="chapter"><span class="secnum">2</span> Precompiler Concepts</h1>
<p>This chapter explains how embedded SQL programs do their work. You examine the special environment in which they operate and the impact of this environment on the design of your applications. After covering the key concepts of embedded SQL programming and the steps you take in developing an application, this chapter uses a simple program to illustrate the main points.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i1838">Key Concepts of Embedded SQL Programming</a></p>
</li>
<li>
<p><a href="#i2103">Steps in Developing an Embedded SQL Application</a></p>
</li>
<li>
<p><a href="#i4944">Guidelines for Programming</a></p>
</li>
<li>
<p><a href="#i5721">Example Tables</a></p>
</li>
<li>
<p><a href="#CIHFIFFJ">Example Program: A Simple Query</a></p>
</li>
<li>
<p><a href="#i2123">Example Program: A Simple Query using SQL99 Syntax</a></p>
</li>
</ul>
<a id="i1838"></a>
<div id="LNPCC3060" class="sect1">
<h2 class="sect1">Key Concepts of Embedded SQL Programming <a id="sthref62"></a></h2>
<p>This section lays the conceptual foundation on which later chapters build. This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1797">Embedded SQL Statements</a></p>
</li>
<li>
<p><a href="#i10149">Embedded SQL Syntax</a></p>
</li>
<li>
<p><a href="#i2279">Static Versus Dynamic SQL Statements</a></p>
</li>
<li>
<p><a href="#i1996">Embedded PL/SQL Blocks</a></p>
</li>
<li>
<p><a href="#i2000">Host and Indicator Variables</a></p>
</li>
<li>
<p><a href="#i2004">Oracle Datatypes</a></p>
</li>
<li>
<p><a href="#i2008">Arrays</a></p>
</li>
<li>
<p><a href="#i2012">Datatype Equivalencing</a></p>
</li>
<li>
<p><a href="#i2016">Private SQL Areas, Cursors, and Active Sets</a></p>
</li>
<li>
<p><a href="#i2020">Transactions</a></p>
</li>
<li>
<p><a href="#i2024">Errors and Warnings</a></p>
</li>
<li>
<p><a href="#CHDIHDFI">SQL99 Syntax Support</a></p>
</li>
</ul>
<a id="i1797"></a>
<div id="LNPCC3061" class="sect2">
<h3 class="sect2"><a id="sthref63"></a><a id="sthref64"></a><a id="sthref65"></a>Embedded SQL Statements <a id="sthref66"></a></h3>
<p>The term <span class="italic">embedded SQL</span> refers to SQL statements placed within an application program. Because it houses the SQL statements, the application program is called a <span class="italic">host program</span>, and the language in which it is written is called the <span class="italic">host language</span>. For example, Pro*C/C++ provides the ability to embed certain SQL statements in a C or C++ host program.</p>
<p>To manipulate and query Oracle data, you use the INSERT, UPDATE, DELETE, and SELECT statements. INSERT adds rows of data to database tables, UPDATE modifies rows, DELETE removes unwanted rows, and SELECT retrieves rows that meet your search condition.</p>
<p>The powerful SET ROLE statement lets you dynamically manage database privileges. A <span class="italic">role</span> is a named group of related system and object privileges, or a named group of related system or object privileges granted to users or other roles. Role definitions are stored in the Oracle data dictionary. Your applications can use the SET ROLE statement to enable and disable roles as needed.</p>
<p>Only SQL statements&mdash;not SQL*Plus statements&mdash;are valid in an application program. (SQL*Plus has additional statements for setting environment parameters, editing, and report formatting.)</p>
<div id="LNPCC3062" class="sect3"><a id="sthref67"></a>
<h4 class="sect3"><a id="sthref68"></a>Executable Statements and Directives</h4>
<p>Embedded SQL includes all the interactive SQL statements plus others that allow you to transfer data between Oracle and a host program. There are two types of embedded SQL statements: <span class="italic">executable statements</span> and <span class="italic">directives</span>. Executable statements result in calls to the runtime library SQLLIB. You use them to connect to Oracle, to define, query, and manipulate Oracle data, to control access to Oracle data, and to process transactions. They can be placed wherever C or C++ language executable statements can be placed. <a id="sthref69"></a><a id="sthref70"></a><a id="sthref71"></a><a id="sthref72"></a></p>
<p>Directives, on the other hand, do not result in calls to SQLLIB and do not operate on Oracle data. You use them to declare Oracle objects, communications areas, and SQL variables. They can be placed wherever C or C++ variable declarations can be placed.</p>
<p><a href="#g11256">Table 2-1</a> groups the various embedded SQL statements (not a complete list):</p>
<div id="LNPCC3063" class="tblformal">
<p class="titleintable"><a id="sthref73"></a><a id="g11256"></a>Table 2-1 Embedded SQL Statements</p>
<table class="cellalignment831" title="Embedded SQL Statements" summary="Directive" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t2">DIRECTIVE</th>
<th class="cellalignment832" id="r1c2-t2">PURPOSE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t2" headers="r1c1-t2">
<p>ARRAYLEN*</p>
</td>
<td class="cellalignment833" headers="r2c1-t2 r1c2-t2">
<p>To use host arrays with PL/SQL</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t2" headers="r1c1-t2">
<p>BEGIN DECLARE SECTION*</p>
<p>END DECLARE SECTION*</p>
</td>
<td class="cellalignment833" headers="r3c1-t2 r1c2-t2">
<p>To declare host variables (optional)</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t2" headers="r1c1-t2">
<p>DECLARE*</p>
</td>
<td class="cellalignment833" headers="r4c1-t2 r1c2-t2">
<p>To name Oracle schema objects</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t2" headers="r1c1-t2">
<p>INCLUDE*</p>
</td>
<td class="cellalignment833" headers="r5c1-t2 r1c2-t2">
<p>To copy in files</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t2" headers="r1c1-t2">
<p>TYPE*</p>
</td>
<td class="cellalignment833" headers="r6c1-t2 r1c2-t2">
<p>To equivalence datatypes</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t2" headers="r1c1-t2">
<p>VAR*</p>
</td>
<td class="cellalignment833" headers="r7c1-t2 r1c2-t2">
<p>To equivalence variables</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t2" headers="r1c1-t2">
<p>WHENEVER*</p>
</td>
<td class="cellalignment833" headers="r8c1-t2 r1c2-t2">
<p>To handle runtime errors</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="LNPCC3064" class="tblformal">
<p class="titleintable"><a id="sthref74"></a><a id="sthref75"></a>Table 2-2 <span class="bolditalic">Embedded SQL Statements</span></p>
<table class="cellalignment831" title="Embedded SQL Statements" summary="embedded" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t3">EXECUTABLE STATEMENT</th>
<th class="cellalignment832" id="r1c2-t3">PURPOSE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t3" headers="r1c1-t3">
<p>ALLOCATE*</p>
</td>
<td class="cellalignment833" headers="r2c1-t3 r1c2-t3">
<p>To define and control Oracle data</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t3" headers="r1c1-t3">
<p>ALTER</p>
</td>
<td class="cellalignment833" headers="r3c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t3" headers="r1c1-t3">
<p>ANALYZE</p>
</td>
<td class="cellalignment833" headers="r4c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t3" headers="r1c1-t3">
<p>DELETE</p>
</td>
<td class="cellalignment833" headers="r5c1-t3 r1c2-t3">
<p>DML</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t3" headers="r1c1-t3">
<p>INSERT</p>
</td>
<td class="cellalignment833" headers="r6c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t3" headers="r1c1-t3">
<p>SELECT</p>
</td>
<td class="cellalignment833" headers="r7c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t3" headers="r1c1-t3">
<p>UPDATE</p>
</td>
<td class="cellalignment833" headers="r8c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t3" headers="r1c1-t3">
<p>COMMIT</p>
</td>
<td class="cellalignment833" headers="r9c1-t3 r1c2-t3">
<p>To process transactions</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t3" headers="r1c1-t3">
<p>ROLLBACK</p>
</td>
<td class="cellalignment833" headers="r10c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t3" headers="r1c1-t3">
<p>SAVEPOINT</p>
</td>
<td class="cellalignment833" headers="r11c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t3" headers="r1c1-t3">
<p>SET TRANSACTION</p>
</td>
<td class="cellalignment833" headers="r12c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r13c1-t3" headers="r1c1-t3">
<p>DESCRIBE*</p>
</td>
<td class="cellalignment833" headers="r13c1-t3 r1c2-t3">
<p>To use dynamic SQL</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r14c1-t3" headers="r1c1-t3">
<p>EXECUTE*</p>
</td>
<td class="cellalignment833" headers="r14c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r15c1-t3" headers="r1c1-t3">
<p>PREPARE*</p>
</td>
<td class="cellalignment833" headers="r15c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r16c1-t3" headers="r1c1-t3">
<p>ALTER SESSION</p>
</td>
<td class="cellalignment833" headers="r16c1-t3 r1c2-t3">
<p>To control sessions</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r17c1-t3" headers="r1c1-t3">
<p>SET ROLE</p>
</td>
<td class="cellalignment833" headers="r17c1-t3 r1c2-t3">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r18c1-t3" headers="r1c1-t3">
<p>*Has no interactive counterpart</p>
</td>
<td class="cellalignment833" headers="r18c1-t3 r1c2-t3">&nbsp;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i10149"></a>
<div id="LNPCC3065" class="sect2">
<h3 class="sect2">Embedded SQL Syntax</h3>
<p>In your application program, you can freely mix complete SQL statements with complete C statements and use C variables or structures in SQL statements. The only special requirement for building SQL statements into your host program is that you begin them with the keywords EXEC SQL and end them with a semicolon. Pro*C/C++ translates all EXEC SQL statements into calls to the runtime library SQLLIB.<a id="sthref76"></a><a id="sthref77"></a><a id="sthref78"></a><a id="sthref79"></a><a id="sthref80"></a><a id="sthref81"></a></p>
<p>Many embedded SQL statements differ from their interactive counterparts only through the addition of a new clause or the use of program variables. The following example compares interactive and embedded ROLLBACK statements:<a id="sthref82"></a></p>
<pre>ROLLBACK WORK:           -- interactive
EXEC SQL ROLLBACK WORK;  -- embedded
</pre>
<p>These statements have the same effect, but you would use the first in an interactive SQL environment (such as when running SQL*Plus), and the second in a Pro*C/C++ program.</p>
</div>
<!-- class="sect2" -->
<a id="i2279"></a>
<div id="LNPCC3066" class="sect2">
<h3 class="sect2">Static Versus Dynamic SQL Statements</h3>
<p>Most application programs are designed to process static SQL statements and fixed transactions. In this case, you know the makeup of each SQL statement and transaction before runtime; that is, you know which SQL commands will be issued, which database tables might be changed, which columns will be updated, and so on.</p>
<p>However, some applications might be required to accept and process any valid SQL statement at runtime. So, you might not know until runtime all the SQL commands, database tables, and columns involved.</p>
<p><span class="italic">Dynamic SQL</span> is an advanced programming technique that lets your program accept or build SQL statements at run time and take explicit control over datatype conversion.<a id="sthref83"></a><a id="sthref84"></a></p>
</div>
<!-- class="sect2" -->
<a id="i1996"></a>
<div id="LNPCC3067" class="sect2">
<h3 class="sect2">Embedded PL/SQL Blocks <a id="sthref85"></a></h3>
<p>Pro*C/C++ treats a PL/SQL block like a single embedded SQL statement. You can place a PL/SQL block anywhere in an application program that you can place a SQL statement. To embed PL/SQL in your host program, you simply declare the variables to be shared with PL/SQL and bracket the PL/SQL block with the keywords EXEC SQL EXECUTE and END-EXEC.</p>
<p>From embedded PL/SQL blocks, you can manipulate Oracle data flexibly and safely because PL/SQL supports all SQL data manipulation and transaction processing commands.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_07pls.htm#g27962">Chapter 7, &#34; Embedded PL/SQL&#34;</a>.<a id="sthref86"></a></div>
</div>
<!-- class="sect2" -->
<a id="i2000"></a>
<div id="LNPCC3068" class="sect2">
<h3 class="sect2">Host and Indicator Variables</h3>
<p>Host variables are the key to communication between Oracle and your program. A <span class="italic">host variable</span> is a scalar or aggregate variable declared in C and shared with Oracle, meaning that both your program and Oracle can reference its value.<a id="sthref87"></a><a id="sthref88"></a><a id="sthref89"></a></p>
<p>Your program uses <span class="italic">input</span> host variables to pass data to Oracle. Oracle uses <span class="italic">output</span> host variables to pass data and status information to your program. The program assigns values to input host variables; Oracle assigns values to output host variables.<a id="sthref90"></a></p>
<p>Host variables can be used anywhere a SQL expression can be used. In SQL statements, host variables must be prefixed with a colon (:) to set them apart from the SQL keywords.</p>
<p>You can also use a C <span class="italic">struct</span> to contain a number of host variables. When you name the structure in an embedded SQL statement, prefixed with a colon, Oracle uses each of the components of the struct as a host variable.</p>
<p>You can associate any host variable with an optional indicator variable. An <span class="italic">indicator variable</span> is a short integer variable that &#34;indicates&#34; the value or condition of its host variable. You use indicator variables to assign NULLs to input host variables and to detect NULLs or truncated values in output host variables. A <span class="italic">NULL</span> is a missing, unknown, or inapplicable value.<a id="sthref91"></a><a id="sthref92"></a></p>
<p>In SQL statements, an indicator variable must be prefixed with a colon and immediately follow its associated host variable. The keyword INDICATOR can be placed between the host variable and its indicator for additional clarity.</p>
<p>If the host variables are packaged in a struct, and you want to use indicator variables, you simply create a struct that has an indicator variable for each host variable in the host structure, and name the indicator struct in the SQL statement, immediately following the host variable struct, and prefixed with a colon. You can also use the INDICATOR keyword to separate a host structure and its associated indicator structure.</p>
</div>
<!-- class="sect2" -->
<a id="i2004"></a>
<div id="LNPCC3069" class="sect2">
<h3 class="sect2">Oracle Datatypes</h3>
<p>Typically, a host program inputs data to Oracle, and Oracle outputs data to the program. Oracle stores input data in database tables and stores output data in program host variables. To store a data item, Oracle must know its <span class="italic">datatype</span>, which specifies a storage format and valid range of values.<a id="sthref93"></a><a id="sthref94"></a></p>
<p>Oracle recognizes two kinds of datatypes: <span class="italic">internal</span> and <span class="italic">external</span>. Internal datatypes specify how Oracle stores data in database columns. Oracle also uses internal datatypes to represent database pseudocolumns, which return specific data items but are not actual columns in a table.<a id="sthref95"></a><a id="sthref96"></a></p>
<p>External datatypes specify how data is stored in host variables. When your host program inputs data to Oracle, if necessary, Oracle converts between the external datatype of the input host variable and the internal datatype of the target database column. When Oracle outputs data to your host program, if necessary, Oracle converts between the internal datatype of the source database column and the external datatype of the output host variable.<a id="sthref97"></a></p>
</div>
<!-- class="sect2" -->
<a id="i2008"></a>
<div id="LNPCC3070" class="sect2">
<h3 class="sect2">Arrays</h3>
<p>Pro*C/C++ lets you define array host variables (called <span class="italic">host arrays)</span> and arrays of structures and operate on them with a single SQL statement. Using the array SELECT, FETCH, DELETE, INSERT, and UPDATE statements, you can query and manipulate large volumes of data with ease. You can also use host arrays inside a host variable <span class="bold">struct</span>.<a id="sthref98"></a><a id="sthref99"></a></p>
</div>
<!-- class="sect2" -->
<a id="i2012"></a>
<div id="LNPCC3071" class="sect2">
<h3 class="sect2">Datatype Equivalencing</h3>
<p>Pro*C/C++ adds flexibility to your applications by letting you <span class="italic">equivalence</span> datatypes. That means you can customize the way Oracle interprets input data and formats output data.<a id="sthref100"></a><a id="sthref101"></a><a id="sthref102"></a></p>
<p>On a variable-by-variable basis, you can equivalence supported C datatypes to the Oracle external datatypes. You can also equivalence user-defined datatypes to Oracle external datatypes.</p>
</div>
<!-- class="sect2" -->
<a id="i2016"></a>
<div id="LNPCC3072" class="sect2">
<h3 class="sect2">Private SQL Areas, Cursors, and Active Sets</h3>
<p>To process a SQL statement, Oracle opens a work area called a <span class="italic">private SQL area</span>. The private SQL area stores information needed to execute the SQL statement. An identifier called a <span class="italic">cursor</span> lets you name a SQL statement, access the information in its private SQL area, and, to some extent, control its processing.<a id="sthref103"></a><a id="sthref104"></a><a id="sthref105"></a><a id="sthref106"></a></p>
<p>For static SQL statements, there are two types of cursors: <span class="italic">implicit</span> and <span class="italic">explicit</span>. Oracle implicitly declares a cursor for all data definition and data manipulation statements, including SELECT statements (queries) that return only one row. However, for queries that return more than one row, to process beyond the first row, you must explicitly declare a cursor (or use host arrays).</p>
<p>The set of rows returned is called the <span class="italic">active set</span>; its size depends on how many rows meet the query search condition. You use an explicit cursor to identify the row currently being processed, called the <span class="italic">current row</span>.<a id="sthref107"></a><a id="sthref108"></a><a id="sthref109"></a><a id="sthref110"></a></p>
<p>Imagine the set of rows being returned to a terminal screen. A screen cursor can point to the first row to be processed, then the next row, and so on. In the same way, an explicit cursor &#34;points&#34; to the current row in the active set. This allows your program to process the rows one at a time.<a id="sthref111"></a></p>
</div>
<!-- class="sect2" -->
<a id="i2020"></a>
<div id="LNPCC3073" class="sect2">
<h3 class="sect2">Transactions</h3>
<p>A <span class="italic">transaction</span> is a series of logically related SQL statements (two UPDATEs that credit one bank account and debit another, for example) that Oracle treats as a unit, so that all changes brought about by the statements are made permanent or undone at the same time.<a id="sthref112"></a><a id="sthref113"></a></p>
<p>All the data manipulation statements executed since the last data definition, COMMIT, or ROLLBACK statement was executed make up the current transaction.<a id="sthref114"></a></p>
<p>To help ensure the consistency of your database, Pro*C/C++ lets you define transactions using the COMMIT, ROLLBACK, and SAVEPOINT statements.<a id="sthref115"></a></p>
<p>COMMIT makes permanent any changes made during the current transaction. ROLLBACK ends the current transaction and undoes any changes made since the transaction began. SAVEPOINT marks the current point in the processing of a transaction; used with ROLLBACK, it undoes part of a transaction.</p>
</div>
<!-- class="sect2" -->
<a id="i2024"></a>
<div id="LNPCC3074" class="sect2">
<h3 class="sect2">Errors and Warnings</h3>
<p>When you execute an embedded SQL statement, it either succeeds or fails, and might result in an error or warning. You need a way to handle these results. Pro*C/C++ provides two error handling mechanisms: the SQL Communications Area (SQLCA) and the WHENEVER statement.<a id="sthref116"></a></p>
<p>The SQLCA is a data structure that you include (or hard-code) in your host program. It defines program variables used by Oracle to pass runtime status information to the program. With the SQLCA, you can take different actions based on feedback from Oracle about work just attempted. For example, you can check to see if a DELETE statement succeeded and, if so, how many rows were deleted. <a id="sthref117"></a> <a id="sthref118"></a></p>
<p>With the WHENEVER statement, you can specify actions to be taken automatically when Oracle detects an error or warning condition. These actions are: continuing with the next statement, calling a function, branching to a labeled statement, or stopping.<a id="sthref119"></a></p>
</div>
<!-- class="sect2" -->
<a id="CHDIHDFI"></a>
<div id="LNPCC3075" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQL99 Syntax Support</h3>
<p>The SQL standard enables the portability of SQL applications across all conforming software products. Oracle features are compliant with the ANSI/ISO SQL99 standard, including ANSI compliant joins. Pro*C/C++ supports all SQL99 features that are supported by Oracle database, which means that the SQL99 syntax for the SELECT, INSERT, DELETE, and UPDATE statements and the body of the cursor in a DECLARE CURSOR statement are supported.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2103"></a>
<div id="LNPCC3076" class="sect1">
<h2 class="sect1">Steps in Developing an Embedded SQL Application<a id="sthref120"></a></h2>
<p><a href="#i4691">Figure 2-1</a> shows the embedded SQL application development process.</p>
<div id="LNPCC3077" class="figure">
<p class="titleinfigure"><a id="i4691"></a>Figure 2-1 Embedded SQL Application Development Process</p>
<img width="600" height="460" src="img/lnpcc003.gif" alt="Description of Figure 2-1 follows"/><br/>
<a id="sthref121" href="img_text/lnpcc003.htm">Description of &#34;Figure 2-1 Embedded SQL Application Development Process&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>As you can see, precompiling results in a modified source file that can be compiled normally. Though precompiling adds a step to the traditional development process, that step lets you write very flexible applications.</p>
</div>
<!-- class="sect1" -->
<a id="i4944"></a>
<div id="LNPCC3078" class="sect1">
<h2 class="sect1">Guidelines for Programming</h2>
<p>This section deals with embedded SQL syntax, coding conventions, and C-specific features and restrictions. Topics are arranged alphabetically for quick reference.<a id="sthref122"></a><a id="sthref123"></a></p>
<a id="i9946"></a>
<div id="LNPCC3079" class="sect2">
<h3 class="sect2">Comments <a id="sthref124"></a><a id="sthref125"></a></h3>
<p>You can place C-style Comments (/* ... */) in a SQL statement wherever blanks can be placed (except between the keywords EXEC SQL). Also, you can place ANSI-style Comments (-- ...) <span class="italic">within</span> SQL statements at the end of a line, as the following example shows:</p>
<pre>EXEC SQL SELECT ENAME, SAL 
    INTO :emp_name, :salary  -- output host variables 
    FROM EMP 
    WHERE DEPTNO = :dept_number; 
</pre>
<p>You can use C++ style Comments (//) in your Pro*C/C++ source if you precompile using the CODE=CPP precompiler option.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3080" class="sect2"><a id="sthref126"></a>
<h3 class="sect2">Constants</h3>
<p>An <span class="italic">L</span> or <span class="italic">l</span> suffix specifies a <span class="bold">long</span> integer constant, a <span class="italic">U</span> or <span class="italic">u</span> suffix specifies an <span class="bold">unsigned</span> integer constant, a <span class="italic">0X</span> or <span class="italic">0x</span> prefix specifies a hexadecimal integer constant, and an <span class="italic">F</span> or <span class="italic">f</span> suffix specifies a <span class="bold">float</span> floating-point constant. These forms are <span class="italic">not</span> allowed in SQL statements.<a id="sthref127"></a></p>
</div>
<!-- class="sect2" -->
<a id="i5480"></a>
<div id="LNPCC3081" class="sect2">
<h3 class="sect2">Declare Section<a id="sthref128"></a><a id="sthref129"></a></h3>
<p>A <span class="italic">Declare Section</span> contains the host variable declarations and is of the form:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
/* Declare all host variables inside this section:  */
    char *uid = &#34;<span class="italic">username</span>/<span class="italic">password</span>&#34;;
    ...
EXEC SQL END DECLARE SECTION;
</pre>
<p>A Declare Section begins with the statement<a id="sthref130"></a><a id="sthref131"></a><a id="sthref132"></a>:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
</pre>
<p>and ends with the statement:</p>
<pre>EXEC SQL END DECLARE SECTION;
</pre>
<p>Between these two statements only the following are allowed:<a id="sthref133"></a><a id="sthref134"></a></p>
<ul>
<li>
<p>Host-variable and indicator-variable declarations</p>
</li>
<li>
<p>Non-host C/C++ variables</p>
</li>
<li>
<p>EXEC SQL DECLARE statements</p>
</li>
<li>
<p>EXEC SQL INCLUDE statements</p>
</li>
<li>
<p>EXEC SQL VAR statements</p>
</li>
<li>
<p>EXEC SQL TYPE statements</p>
</li>
<li>
<p>EXEC ORACLE statements</p>
</li>
<li>
<p>C/C++ comments</p>
</li>
</ul>
<p>A Declare Section is required when MODE=ANSI or CODE=CPP (in a C++ application) or PARSE=NONE or PARTIAL. For details of the PARSE option, see also <a href="pc_12cpl.htm#i864">&#34;Parsing Code&#34;</a>.</p>
<p>More than one Declare Section is allowed. They can be in different code modules.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3082" class="sect2"><a id="sthref135"></a>
<h3 class="sect2">Delimiters</h3>
<p>While C uses single quotes to delimit single characters, as in <a id="sthref136"></a></p>
<pre>ch = getchar(); 
switch (ch)
{ 
case &#39;U&#39;: update();  break; 
case &#39;I&#39;: insert();  break; 
... 
</pre>
<p>SQL uses single quotes to delimit character strings, as in<a id="sthref137"></a></p>
<pre>EXEC SQL SELECT ENAME, SAL FROM EMP WHERE JOB = &#39;MANAGER&#39;; 
</pre>
<p>While C uses double quotes to delimit character strings, as in</p>
<pre>printf(&#34;\nG&#39;Day, mate!&#34;); 
</pre>
<p>SQL uses double quotes to delimit identifiers containing special or lowercase characters, as in<a id="sthref138"></a></p>
<pre>EXEC SQL CREATE TABLE &#34;Emp2&#34; (empno  number(4), ...); 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3083" class="sect2"><a id="sthref139"></a>
<h3 class="sect2">File Length</h3>
<p>Pro*C/C++ cannot process arbitrarily long source files. There is a limit to the number of lines allowed. The following aspects of the source file are contributing factors to the file-size constraint:</p>
<ul>
<li>
<p>Complexity of the embedded SQL statements (for example, the number of bind and define variables).</p>
</li>
<li>
<p>Whether a database name is used (for example, connecting to a database with an AT clause).</p>
</li>
<li>
<p>Number of embedded SQL statements.</p>
</li>
</ul>
<p>To prevent problems related to this limitation, use multiple program units to sufficiently reduce the size of the source files.</p>
</div>
<!-- class="sect2" -->
<a id="i4816"></a>
<div id="LNPCC3084" class="sect2">
<h3 class="sect2">Function Prototyping</h3>
<p>The ANSI C standard (X3.159-1989) provides for function prototyping. A <span class="italic">function prototype</span> declares a function and the data types of its arguments, so that the C compiler can detect missing or mismatched arguments.</p>
<p>The CODE option, which you can enter on the command line or in a configuration file, determines the way that the precompiler generates C or C++ code.</p>
<div id="LNPCC3085" class="sect3"><a id="sthref140"></a>
<h4 class="sect3">ANSI_C</h4>
<p>When you precompile your program with CODE=ANSI_C, the precompiler generates fully prototyped function declarations. For example:</p>
<pre>extern void sqlora(long *, void *); 
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC3086" class="sect3"><a id="sthref141"></a>
<h4 class="sect3">KR_C</h4>
<p>When you precompile with the option CODE=KR_C (KR for &#34;Kernighan and Ritchie&#34;), the precompiler generates function prototypes in the same way that it does for ANSI_C, except that function parameter lists are commented out. For example:</p>
<pre>extern void sqlora(/*_ long *, void *  _*/);
</pre>
<p>So, make sure to set the precompiler option CODE to KR_C if you use a C compiler that does not support ANSI C. When the CODE option is set to ANSI_C, the precompiler can also generate other ANSI-specific constructs; for example, the <span class="bold">const</span> type qualifier.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3087" class="sect3"><a id="sthref142"></a>
<h4 class="sect3">CPP</h4>
<p>When you compile with CODE=CPP you will generate C++ compatible function prototypes. Use this option setting with C++ compilers.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_12cpl.htm#g12549">Chapter 12, &#34;C++ Applications&#34;</a>, for more information on using C++.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3088" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref143"></a>
<h3 class="sect2">Hint Length</h3>
<p>Maximum length of a sql hint in an embedded sql statement is limited to 256 characters. Any hint exceeding this limit will be truncated.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3089" class="sect2"><a id="sthref144"></a>
<h3 class="sect2">Host Variable Names</h3>
<p>Host variable names can consist of upper or lowercase letters, digits, and underscores, but must begin with a letter. They can be any length, but only the first 31 characters are significant to Pro*C/C++. Your C compiler or linker might require a shorter maximum length, so check your C compiler user&#39;s guide. <a id="sthref145"></a></p>
<p>For portability, you may wish to restrict the length of host variable names to 18 or fewer characters (the length mandated by the SQL standard).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_abres.htm#CJACFAAC">Appendix A, &#34; Reserved Words, Keywords, and Namespaces&#34;</a> for a list of words that have restrictions on their use in applications.</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3090" class="sect2"><a id="sthref146"></a>
<h3 class="sect2">Line Continuation<a id="sthref147"></a></h3>
<p>You can continue SQL statements from one line to the next. You must use a backslash (\) to continue a string literal from one line to the next, as the following example shows:</p>
<pre>EXEC SQL INSERT INTO dept (deptno, dname) VALUES (50, &#39;PURCHAS\ 
ING&#39;); 
</pre>
<p>In this context, the precompiler treats the backslash as a continuation character.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3091" class="sect2"><a id="sthref148"></a>
<h3 class="sect2">Line Length<a id="sthref149"></a></h3>
<p>The maximum line length is 1299 for lines consisting of only ASCII characters, or 324 for multibyte characters.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3092" class="sect2"><a id="sthref150"></a>
<h3 class="sect2">MAXLITERAL Default Value</h3>
<p>The precompiler option MAXLITERAL lets you specify the maximum length of string literals generated by the precompiler. The MAXLITERAL default value is 1024. Specify a smaller value if required. For example, if your C compiler cannot handle string literals longer than 512 characters, you then specify MAXLITERAL=512. Check your C compiler user&#39;s guide.<a id="sthref151"></a><a id="sthref152"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3093" class="sect2"><a id="sthref153"></a>
<h3 class="sect2">Operators</h3>
<p>The logical operators and the &#34;equal to&#34; relational operator are different in C and SQL, as the following list shows. These C operators are <span class="italic">not</span> allowed in SQL statements<a id="sthref154"></a>:<a id="sthref155"></a></p>
<div class="inftblinformal">
<table class="cellalignment834" title="sql operators and corresponding c operators" summary="sql" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t7">SQL Operator</th>
<th class="cellalignment832" id="r1c2-t7">C Operator</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t7" headers="r1c1-t7">NOT</td>
<td class="cellalignment833" headers="r2c1-t7 r1c2-t7">!</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t7" headers="r1c1-t7">AND</td>
<td class="cellalignment833" headers="r3c1-t7 r1c2-t7">&amp;&amp;</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t7" headers="r1c1-t7">OR</td>
<td class="cellalignment833" headers="r4c1-t7 r1c2-t7">||</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t7" headers="r1c1-t7">=</td>
<td class="cellalignment833" headers="r5c1-t7 r1c2-t7">==</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>The following C operators also <span class="italic">not</span> allowed in SQL statements:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="c operators not allowed in sql statements" summary="C Operators not Allowed" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t8">Type</th>
<th class="cellalignment832" id="r1c2-t8">C Operator</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t8" headers="r1c1-t8">address</td>
<td class="cellalignment833" headers="r2c1-t8 r1c2-t8">&amp;</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t8" headers="r1c1-t8">bitwise</td>
<td class="cellalignment833" headers="r3c1-t8 r1c2-t8">&amp;, |, ^, ~</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t8" headers="r1c1-t8">compound assignment</td>
<td class="cellalignment833" headers="r4c1-t8 r1c2-t8">+=, -=, *=, and so on.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t8" headers="r1c1-t8">conditional</td>
<td class="cellalignment833" headers="r5c1-t8 r1c2-t8">?:</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t8" headers="r1c1-t8">decrement</td>
<td class="cellalignment833" headers="r6c1-t8 r1c2-t8">--</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t8" headers="r1c1-t8">increment</td>
<td class="cellalignment833" headers="r7c1-t8 r1c2-t8">++</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t8" headers="r1c1-t8">indirection</td>
<td class="cellalignment833" headers="r8c1-t8 r1c2-t8">*</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t8" headers="r1c1-t8">modulus</td>
<td class="cellalignment833" headers="r9c1-t8 r1c2-t8">%</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t8" headers="r1c1-t8">shift</td>
<td class="cellalignment833" headers="r10c1-t8 r1c2-t8">&gt;&gt;,&lt;&lt;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<div id="LNPCC3094" class="sect2"><a id="sthref156"></a>
<h3 class="sect2">Statement Terminator</h3>
<p>Embedded SQL statements are always terminated by a semicolon, as the following example shows:<a id="sthref157"></a></p>
<pre>EXEC SQL DELETE FROM emp WHERE deptno = :dept_number;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5283"></a>
<div id="LNPCC3095" class="sect1">
<h2 class="sect1">Conditional Precompilation</h2>
<p>Conditional precompilation includes (or excludes) sections of code in your host program based on certain conditions. For example, you might want to include one section of code when precompiling under UNIX and another section when precompiling under VMS. Conditional precompilation lets you write programs that can run in different environments.<a id="sthref158"></a><a id="sthref159"></a></p>
<p>Conditional sections of code are marked by statements that define the environment and actions to take. You can code C or C++ statements as well as EXEC SQL statements in these sections. The following statements let you exercise conditional control over precompilation:<a id="sthref160"></a><a id="sthref161"></a><a id="sthref162"></a><a id="sthref163"></a><a id="sthref164"></a></p>
<pre>EXEC ORACLE DEFINE symbol;        -- define a symbol
EXEC ORACLE IFDEF symbol;         -- if symbol is defined
EXEC ORACLE IFNDEF symbol;        -- if symbol is not defined
EXEC ORACLE ELSE;                 -- otherwise
EXEC ORACLE ENDIF;                -- end this control block
</pre>
<p>All EXEC ORACLE statements must be terminated with a semi-colon.</p>
<div id="LNPCC3096" class="sect2"><a id="sthref165"></a>
<h3 class="sect2">Symbol Definition<a id="sthref166"></a><a id="sthref167"></a><a id="sthref168"></a></h3>
<p>You can define a symbol in two ways. Either include the statement:</p>
<pre>EXEC ORACLE DEFINE symbol;
</pre>
<p>in your host program or define the symbol on the command line using the syntax:</p>
<pre>... DEFINE=symbol ...
</pre>
<p>where <code>symbol</code> is not case-sensitive.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The #define preprocessor directive is not the same as the EXEC ORACLE DEFINE statement.</div>
<p>Some port-specific symbols are predefined for you when Pro*C/C++ is installed on your system. For example, predefined operating symbols include CMS, MVS, MS-DOS, UNIX, and VMS.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3097" class="sect2"><a id="sthref169"></a>
<h3 class="sect2">Example<a id="sthref170"></a> SELECT Statement</h3>
<p>In the following example, the SELECT statement is precompiled only when the symbol <code>site2</code> is defined:</p>
<pre>EXEC ORACLE IFDEF site2;
   EXEC SQL SELECT DNAME
       INTO :dept_name
       FROM DEPT
       WHERE DEPTNO= :dept_number;
EXEC ORACLE ENDIF;
</pre>
<p>You can &#34;comment out&#34; C, C++, or embedded SQL code by placing it between IFDEF and ENDIF and <span class="bold">not</span> defining the symbol.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5023"></a>
<div id="LNPCC3098" class="sect1">
<h2 class="sect1">Precompile Separately<a id="sthref171"></a></h2>
<p>You can precompile several C or C++ program modules separately, then link them into one executable program. This supports modular programming, which is required when the functional components of a program are written and debugged by different programmers. The individual program modules need not be written in the same language.<a id="sthref172"></a></p>
<div id="LNPCC3099" class="sect2"><a id="sthref173"></a>
<h3 class="sect2">Guidelines</h3>
<p>The following guidelines will help you avoid some common problems.<a id="sthref174"></a><a id="sthref175"></a></p>
<div id="LNPCC3100" class="sect3"><a id="sthref176"></a>
<h4 class="sect3">Referencing Cursors</h4>
<p>Cursor names are SQL identifiers, whose scope is the precompilation unit. Hence, cursor operations cannot span precompilation units (files). That is, you cannot DECLARE a cursor in one file, and OPEN or FETCH from it in another file. So, when doing a separate precompilation, make sure all definitions and references to a given cursor are in one file. <a id="sthref177"></a><a id="sthref178"></a><a id="sthref179"></a><a id="sthref180"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3101" class="sect3"><a id="sthref181"></a>
<h4 class="sect3">Specifying MAXOPENCURSORS</h4>
<p>When you precompile the program module that CONNECTs to Oracle, specify a value for MAXOPENCURSORS that is high enough for any of the program modules. If you use MAXOPENCURSORS for another program module, one that does not do a CONNECT, then that value for MAXOPENCURSORS is ignored. Only the value in effect for the CONNECT is used at runtime.<a id="sthref182"></a><a id="sthref183"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3102" class="sect3"><a id="sthref184"></a>
<h4 class="sect3">Use a Single SQLCA</h4>
<p>If you want to use just one SQLCA, you must declare it as global in one of the program modules and as external in the other modules. Use the <span class="italic">extern</span> storage class, and the following define in your code: <a id="sthref185"></a></p>
<pre>#define SQLCA_STORAGE_CLASS extern 
</pre>
<p>which tells the precompiler to look for the SQLCA in another program module. Unless you declare the SQLCA as external, each program module uses its own local SQLCA.<a id="sthref186"></a><a id="sthref187"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
All source files in an application must be uniquely named, or else an error will be generated.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5008"></a>
<div id="LNPCC3103" class="sect1">
<h2 class="sect1">Compile and Link</h2>
<p>To get an executable program, you must compile the output <code>.c</code> source files produced by the precompiler, then link the resulting object modules with modules needed from SQLLIB and system-specific Oracle libraries. If you are mixing precompiler code and OCI calls, be sure to also link in the OCI runtime library (<code>liboci.a</code> on UNIX systems).<a id="sthref188"></a><a id="sthref189"></a></p>
<p>The linker resolves symbolic references in the object modules. If these references conflict, the link fails. This can happen when you try to link third-party software into a precompiled program. Not all third-party software is compatible with Oracle. So, linking your program <span class="italic">shared</span> might cause an obscure problem. In some cases, linking <span class="italic">standalone</span> or <span class="italic">two-task</span> might solve the problem. <a id="sthref190"></a><a id="sthref191"></a></p>
<p>Compiling and linking are system dependent. On most platforms, example <span class="italic">makefiles</span> or batch files are supplied that you can use to precompile, compile, and link a Pro*C/C++ application. See your system-specific documentation.<a id="sthref192"></a></p>
</div>
<!-- class="sect1" -->
<a id="i5721"></a>
<div id="LNPCC3104" class="sect1">
<h2 class="sect1">Example Tables</h2>
<p>Most programming examples in this guide use two example database tables: DEPT and EMP. Their definitions follow: <a id="sthref193"></a><a id="sthref194"></a><a id="sthref195"></a><a id="sthref196"></a></p>
<pre>CREATE TABLE DEPT
    (DEPTNO    NUMBER(2) NOT NULL,
     DNAME     VARCHAR2(14),
     LOC       VARCHAR2(13))

CREATE TABLE EMP
    (EMPNO     NUMBER(4) NOT NULL,
     ENAME     VARCHAR2(10),
     JOB       VARCHAR2(9),
     MGR       NUMBER(4),
     HIREDATE  DATE,
     SAL       NUMBER(7,2),
     COMM      NUMBER(7,2),
     DEPTNO    NUMBER(2))
</pre>
<div id="LNPCC3105" class="sect2"><a id="sthref197"></a>
<h3 class="sect2">Example Data</h3>
<p>Respectively, the DEPT and EMP tables contain the following rows</p>
<p>of data:</p>
<pre>DEPTNO  DNAME      LOC
------- ---------- ---------
10      ACCOUNTING NEW YORK
20      RESEARCH   DALLAS
30      SALES      CHICAGO
40      OPERATIONS BOSTON

EMPNO ENAME   JOB          MGR  HIREDATE    SAL   COMM  DEPTNO
----- ------- --------- ------ --------- ------ ------ -------
 7369 SMITH   CLERK       7902 17-DEC-80    800             20
 7499 ALLEN   SALESMAN    7698 20-FEB-81   1600    300      30
 7521 WARD    SALESMAN    7698 22-FEB-81   1250    500      30
 7566 JONES   MANAGER     7839 02-APR-81   2975             20
 7654 MARTIN  SALESMAN    7698 28-SEP-81   1250   1400      30
 7698 BLAKE   MANAGER     7839 01-MAY-81   2850             30
 7782 CLARK   MANAGER     7839 09-JUN-81   2450             10
 7788 SCOTT   ANALYST     7566 19-APR-87   3000             20
 7839 KING    PRESIDENT        17-NOV-81   5000             10
 7844 TURNER  SALESMAN    7698 08-SEP-81   1500             30
 7876 ADAMS   CLERK       7788 23-MAY-87   1100             20
 7900 JAMES   CLERK       7698 03-DEC-81    950             30
 7902 FORD    ANALYST     7566 03-DEC-81   3000             20
 7934 MILLER  CLERK       7782 23-JAN-82   1300             10
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHFIFFJ"></a>
<div id="LNPCC3106" class="sect1">
<h2 class="sect1">Example Program: A Simple Query<a id="sthref198"></a></h2>
<p>One way to get acquainted with Pro*C/C++ and embedded SQL is to study a program example. The following program is also available on-line in the file <code>sample1.pc</code> in your Pro*C/C++ <code>demo</code> directory.</p>
<p>The program connects to Oracle, then loops, prompting the user for an employee number. It queries the database for the employee&#39;s name, salary, and commission, displays the information, and then continues the loop. The information is returned to a host structure. There is also a parallel indicator structure to signal whether any of the output values SELECTed might be NULL.</p>
<p>Precompile example programs using the precompiler option MODE=ORACLE. <a id="sthref199"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For simplicity in demonstrating this feature, this example does not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <a class="olink DBSEG50053" href="../DBSEG/app_devs.htm#DBSEG50053"><span class="italic">Oracle Database Security Guide</span></a> for password management guidelines and other security recommendations.</div>
<pre>/*
 *  sample1.pc
 *
 *  Prompts the user for an employee number,
 *  then queries the emp table for the employee&#39;s
 *  name, salary and commission.  Uses indicator
 *  variables (in an indicator struct) to determine
 *  if the commission is NULL.
 *
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;


/* Define constants for VARCHAR lengths. */
#define     UNAME_LEN      20
#define     PWD_LEN        40

/* Declare variables. No declare section is needed if MODE=ORACLE.*/
VARCHAR     username[UNAME_LEN];  
/* VARCHAR is an Oracle-supplied struct */
varchar     password[PWD_LEN];    
/* varchar can be in lower case also. */
/*
Define a host structure for the output values of a SELECT statement.
*/
struct {
    VARCHAR   emp_name[UNAME_LEN];
    float     salary;
    float     commission;
} emprec;
/* 
Define an indicator struct to correspond to the host output struct. */
struct
{
    short     emp_name_ind;
    short     sal_ind;
    short     comm_ind;
} emprec_ind;

/*  Input host variable. */
int         emp_number;
int         total_queried;
/* Include the SQL Communications Area.
   You can use #include or EXEC SQL INCLUDE. */
#include &lt;sqlca.h&gt;

/* Declare error handling function. */
void sql_error();

main()
{
    char temp_char[32];

/* Connect to ORACLE--
 * Copy the username into the VARCHAR.
 */
    strncpy((char *) username.arr, &#34;SCOTT&#34;, UNAME_LEN);
/* Set the length component of the VARCHAR. */
    username.len = strlen((char *) username.arr);
/* Copy the password. */
    strncpy((char *) password.arr, &#34;TIGER&#34;, PWD_LEN);
    password.len = strlen((char *) password.arr);
/* Register sql_error() as the error handler. */
    EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;ORACLE error--\n&#34;);

/* Connect to ORACLE.  Program will call sql_error()
 * if an error occurs when connecting to the default database.
 */
    EXEC SQL CONNECT :username IDENTIFIED BY :password;
    printf(&#34;\nConnected to ORACLE as user: %s\n&#34;, username.arr);
/* Loop, selecting individual employee&#39;s results */
    total_queried = 0;
    for (;;)
    {
/* Break out of the inner loop when a
 * 1403 (&#34;No data found&#34;) condition occurs.
 */
        EXEC SQL WHENEVER NOT FOUND DO break;
        for (;;)
        {
            emp_number = 0;
            printf(&#34;\nEnter employee number (0 to quit): &#34;);
            gets(temp_char);
            emp_number = atoi(temp_char);
            if (emp_number == 0)
                break;
            EXEC SQL SELECT ename, sal, NVL(comm, 0)
                INTO :emprec INDICATOR :emprec_ind
                FROM EMP
                WHERE EMPNO = :emp_number;
/* Print data. */
            printf(&#34;\n\nEmployee\tSalary\t\tCommission\n&#34;);
            printf(&#34;--------\t------\t\t----------\n&#34;);
/* Null-terminate the output string data. */
            emprec.emp_name.arr[emprec.emp_name.len] = &#39;\0&#39;;
            printf(&#34;%-8s\t%6.2f\t\t&#34;,
                emprec.emp_name.arr, emprec.salary);
            if (emprec_ind.comm_ind == -1)
                printf(&#34;NULL\n&#34;);
            else
                printf(&#34;%6.2f\n&#34;, emprec.commission);

            total_queried++;
        }  /* end inner for (;;) */
        if (emp_number == 0) break;
        printf(&#34;\nNot a valid employee number - try again.\n&#34;);
    } /* end outer for(;;) */

    printf(&#34;\n\nTotal rows returned was %d.\n&#34;, total_queried); 
    printf(&#34;\nG&#39;day.\n\n\n&#34;);

/* Disconnect from ORACLE. */
    EXEC SQL COMMIT WORK RELEASE;
    exit(0);
}
void sql_error(msg)
char *msg;
{
    char err_msg[128];
    int buf_len, msg_len;

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    printf(&#34;\n%s\n&#34;, msg);
    buf_len = sizeof (err_msg);
    sqlglm(err_msg, &amp;buf_len, &amp;msg_len);
    if (msg_len &gt; buf_len)
    msg_len = buf_len;
    printf(&#34;%.*s\n&#34;, msg_len, err_msg);
    EXEC SQL ROLLBACK RELEASE;
    exit(1);
}
</pre></div>
<!-- class="sect1" -->
<a id="i2123"></a>
<div id="LNPCC3107" class="sect1">
<h2 class="sect1">Example Program: A Simple Query using SQL99 Syntax</h2>
<p>This program is similar to the previous example, but uses SQL99 syntax for SELECT, INSERT, DELETE and UPDATE statements and the body of the cursor in a DECLARE CURSOR statement is supported.</p>
<p>Precompile example programs using the precompiler option MODE=ORACLE. <a id="sthref200"></a></p>
<pre>/*
 *  sql99.pc
 *
 *  Prompts the user for an employee number,
 *  then queries the emp table for the employee&#39;s
 *  name, salary and department. 
 *
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlda.h&gt;
#include &lt;sqlcpr.h&gt;
.
/* Define constants for VARCHAR lengths. */
#define     UNAME_LEN     30
#define     PWD_LEN        40
/* Declare variables.  No declare section is needed if MODE=ORACLE. */
 
VARCHAR     username[UNAME_LEN]; 
 /* VARCHAR is an Oracle-supplied struct */
 varchar     password[PWD_LEN];  
 /* varchar can be in lower case also. */
/* Define a host structure for the output values of a SELECT statement.  */
 
struct{ 
   VARCHAR   emp_name[UNAME_LEN];   
   float     salary;  
   VARCHAR  dept_name[UNAME_LEN] ;
  } emprec;
/* Define an indicator struct to correspond to the host output struct. */
struct{ 
   short     emp_name_ind;  
   short     sal_ind;   
   short     dept_name;
  } emprec_ind;
 
/*  Input host variable. */
int         emp_number;
int         total_queried;
/* Include the SQL Communications Area. You can use #include or EXEC SQL 
INCLUDE. */
 
#include &lt;sqlca.h&gt;
/* Declare error handling function. */
void sql_error(msg)   
   char *msg;
   {   
    char err_msg[128];    
    size_t buf_len, msg_len;    
    EXEC SQL WHENEVER SQLERROR CONTINUE;    
    printf(&#34;\n%s\n&#34;, msg); 
    buf_len = sizeof (err_msg);
    sqlglm(err_msg, &amp;buf_len, &amp;msg_len);  
    printf(&#34;%.*s\n&#34;, msg_len, err_msg); 
    EXEC SQL ROLLBACK RELEASE;  
  exit(EXIT_FAILURE);
  }
 
void main(){  
   char temp_char[32];
  /* Connect to ORACLE-- * Copy the username into the VARCHAR. */
    strncpy((char *) username.arr, &#34;scott&#34;, UNAME_LEN);
  /* Set the length component of the VARCHAR. */   
    username.len = (unsigned short) strlen((char *) username.arr);
   /* Copy the password. */   
     strncpy((char *) password.arr, &#34;tiger&#34;, PWD_LEN);   
     password.len = (unsigned short) strlen((char *) password.arr);
  /* Register sql_error() as the error handler. */    
    EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;ORACLE error--\n&#34;);
  /* Connect to ORACLE.  Program will call sql_error() * if an error occurs 
when connecting to the default database. */    
     EXEC SQL CONNECT :username IDENTIFIED BY :password; 
    printf(&#34;\nConnected to ORACLE as user: %s\n&#34;, username.arr);
  /* Loop, selecting individual employee&#39;s results */   
     total_queried = 0;   
     for (;;)    {
                  emp_number = 0;       
                  printf(&#34;\nEnter employee number (0 to quit): &#34;); 
                  gets(temp_char);    
                  emp_number = atoi(temp_char);      
                  if (emp_number == 0)            
                        break;
  /* Branch to the notfound label when the * 1403 (&#34;No data found&#34;) condition 
occurs. */     
   EXEC SQL WHENEVER NOT FOUND GOTO notfound;
 
<span class="bold">  /* The following query uses SQL99 syntax - RIGHT OUTER JOIN */</span>
    EXEC SQL SELECT e.ename, e.sal, d.dname        
    INTO :emprec INDICATOR :emprec_ind       
    FROM EMP e RIGHT OUTER JOIN dept d   
    ON e.deptno = d.deptno  
    WHERE e.EMPNO = :emp_number;
  /* Print data. */      
  printf(&#34;\n\nEmployee   Salary    Department Name\n&#34;);    
  printf(&#34;--------   -------   ------------------\n&#34;);
  /* Null-terminate the output string data. */    
    emprec.emp_name.arr[emprec.emp_name.len] = &#39;\0&#39;;  
    emprec.dept_name.arr[emprec.dept_name.len]=&#39;\0&#39;;   
    printf(&#34;%s      %7.2f          %s &#34;,            emprec.emp_name.arr, 
  emprec.salary, emprec.dept_name.arr);
    total_queried++;   
     continue;
  
  notfound:        
     printf(&#34;\nNot a valid employee number - try again.\n&#34;);  
  }
  
 printf(&#34;\n\nTotal rows returned was %d.\n&#34;, total_queried); 
 printf(&#34;\nG&#39;day.\n\n\n&#34;);
/* Disconnect from ORACLE. */ 
   EXEC SQL ROLLBACK WORK RELEASE;   
 exit(EXIT_SUCCESS);
}
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_01int.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_03dbc.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>