<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78017"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Objects"></a><title>Objects</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:51Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_16lob.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_18col.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">23/35</span> <!-- End Header -->
<div id="LNPCC017" class="chapter"><a id="g480794"></a> <a id="i447107"></a>
<h1 class="chapter"><span class="secnum">17</span> Objects<a id="sthref2033"></a><a id="sthref2034"></a></h1>
<p>This chapter describes the support in Pro*C/C++ for user-defined objects. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i420200">Introduction to Objects</a></p>
</li>
<li>
<p><a href="#i457014">Using Object Types in Pro*C/C++</a></p>
</li>
<li>
<p><a href="#i449450">The Object Cache</a></p>
</li>
<li>
<p><a href="#i449455">Associative Interface</a></p>
</li>
<li>
<p><a href="#i447871">Navigational Interface</a></p>
</li>
<li>
<p><a href="#i449464">Converting Object Attributes and C Types</a></p>
</li>
<li>
<p><a href="#i453930">Object Options Set/Get</a></p>
</li>
<li>
<p><a href="#i449469">New Precompiler Options for Objects</a></p>
</li>
<li>
<p><a href="#i449474">An Object Example in Pro*C/C++</a></p>
</li>
<li>
<p><a href="#i457195">Example Code for Type Inheritance</a></p>
</li>
<li>
<p><a href="#i457199">Example Code for Navigational Access</a></p>
</li>
<li>
<p><a href="#i449483">Using C Structures</a></p>
</li>
<li>
<p><a href="#i444272">Using REFs</a></p>
</li>
<li>
<p><a href="#i444281">Using OCIDate, OCIString, OCINumber, and OCIRaw</a></p>
</li>
<li>
<p><a href="#i444286">Summarizing the New Database Types in Pro*C/C++</a></p>
</li>
<li>
<p><a href="#i436920">Restrictions on Using Oracle Datatypes in Dynamic SQL</a></p>
</li>
</ul>
<a id="i420200"></a>
<div id="LNPCC4315" class="sect1">
<h2 class="sect1">Introduction to Objects<a id="sthref2035"></a></h2>
<p>In addition to the Oracle relational datatypes supported since Oracle8, Pro*C/C++ supports user-defined datatypes, which are:</p>
<ul>
<li>
<p>Object types</p>
</li>
<li>
<p>REFs to object types</p>
</li>
<li>
<p>Collection object types</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_18col.htm#g1023189">Chapter 18, &#34;Collections&#34;</a></div>
</li>
<li>
<p>Type inheritance</p>
</li>
</ul>
<div id="LNPCC4316" class="sect2"><a id="sthref2036"></a>
<h3 class="sect2">Object Types<a id="sthref2037"></a></h3>
<p>An object type is a user-defined datatype that has <span class="italic">attributes</span>, the variables that form the datatype defined by a CREATE TYPE SQL statement, and <span class="italic">methods</span>, functions and procedures that are the set of allowed behaviors of the object type. We consider object types with only attributes in this guide.</p>
<p>For example:</p>
<pre>--Defining an object type...
CREATE TYPE employee_type AS OBJECT(
    name    VARCHAR2(20),
    id      NUMBER,
    MEMBER FUNCTION get_id(name VARCHAR2) RETURN NUMBER);
/
--
--Creating an object table...
CREATE TABLE employees OF employee_type;
--Instantiating an object, using a constructor...
INSERT INTO employees VALUES (
        employee_type(&#39;JONES&#39;, 10042));
</pre>
<p>LONG, LONG RAW, NCLOB, NCHAR and NCHAR Varying are <span class="italic">not</span> allowed as datatypes in attributes of objects.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4317" class="sect2"><a id="sthref2038"></a>
<h3 class="sect2">REFs to Object Types<a id="sthref2039"></a><a id="sthref2040"></a></h3>
<p>REF (short for &#34;reference&#34;) is a reference to an object stored in a database table, instead of the object itself. REF types can occur in relational columns and also as datatypes of an object type. For example, a table <span class="italic">employee_tab</span> can have a column that is a REF to an object type <span class="italic">employee_t</span> itself:</p>
<pre>CREATE TYPE employee_t AS OBJECT(
   empname         CHAR(20),
   empno           INTEGER,
   manager         REF employee_t);
/
CREATE TABLE employee_tab OF employee_t;
</pre></div>
<!-- class="sect2" -->
<a id="i468338"></a>
<div id="LNPCC4318" class="sect2">
<h3 class="sect2">Type Inheritance</h3>
<p><a id="sthref2041"></a>Oracle supports type inheritance of objects. This enables sharing of attributes and methods between similar object types, as well as extending the characteristics of an object type.</p>
<p>Pro*C/C++ supports type inheritance of object types with the following SQL operators:</p>
<ul>
<li>
<p>IS<a id="sthref2042"></a> OF <span class="italic">type</span></p>
</li>
<li>
<p>TRE<a id="sthref2043"></a>AT</p>
</li>
</ul>
<p>The IS OF <span class="italic">type</span> operator is used to test an object instance for specific <span class="italic">type</span> information.</p>
<p>The following code example returns the references to all <code>p</code> objects where <code>p</code> is of type <code>Employee_t</code> and <code>Student_t</code>.</p>
<pre>SELECT <a id="sthref2044"></a>REF(p)
   FROM person_tab p
   WHERE VALUE(p) IS OF (Employee_t, Student_t);
</pre>
<p>The following code example returns all rows where <code>p</code> is of type <code>Student_t</code> only.</p>
<pre>SELECT <a id="sthref2045"></a>VALUE(p)
   FROM person_tab p
   WHERE VALUE(p) IS OF (ONLY Student_t);
</pre>
<p>The TREAT operator is used to modify the declared type of an expression.</p>
<p>The following code example returns all rows where <code>p</code> is of type <code>Student_t</code>. For all instances of <code>p</code> that are not of type <code>Student_t</code>, null is returned.</p>
<pre>SELECT TR<a id="sthref2046"></a>EAT(VALUE(p) AS Student_t)
   FROM person_tab p;
</pre>
<p>The following code example returns the references to all <code>p</code> objects of type <code>Student_t</code> and any objects of subtype <code>PartTimeStudent_t</code>.</p>
<pre>SELECT TREAT(REP<a id="sthref2047"></a>(p) AS REF Student_t) 
   FROM person_tab p
   WHERE VALUE(p) IS OF (Student_t);
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i457014"></a>
<div id="LNPCC4319" class="sect1">
<h2 class="sect1">Using Object Types in Pro*C/C++<a id="sthref2048"></a></h2>
<p>Declare pointers to C structures generated by the OTT (Object Type Translator) as host and indicator variables in your Pro*C/C++ application. Use of an indicator variable is optional for an object type, but Oracle recommends it.</p>
<p>Represent object types in a Pro*C/C++ program as C structures generated from the database objects using OTT. You must</p>
<ul>
<li>
<p>Include in the Pro*C/C++ program the OTT-generated header file with structure definitions and the associated NULL indicator structures, and the C type for a REF to the object type.</p>
</li>
<li>
<p>Enter the typefile generated by OTT as an INTYPE Pro*C/C++ command-line option. This typefile encodes the correspondence between the OTT-generated C structures and the associated object types in the database, as well as schema and type version information.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_19ott.htm#g464850">Chapter 19, &#34;The Object Type Translator&#34;</a></div>
</li>
</ul>
<div id="LNPCC4320" class="sect2"><a id="sthref2049"></a>
<h3 class="sect2">NULL Indicators</h3>
<p>C structures representing the NULL status of object types are generated by the Object Type Translator. You must use these generated structure types in declaring indicator variables for object types.</p>
<p>Other Oracle types do not require special treatment for NULL indicators.</p>
<div class="infoboxnotealso">
<p class="notep1">Se Also:</p>
<a href="pc_04dat.htm#g52211">&#34;Datatypes and Host Variables&#34;</a> for more information about NULL indicators.</div>
<p>Because object types have internal structure, NULL indicators for object types also have internal structure. A NULL indicator structure for a non-collection object type provides atomic (single) NULL status for the object type as a whole, as well as the NULL status of every attribute. OTT generates a C structure to represent the NULL indicator structure for the object type. The name of the NULL indicator structure is <span class="italic">Object_typename</span>_ind where <span class="italic">Object_typename</span> is the name of the C structure for the user-defined type in the database.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i449450"></a>
<div id="LNPCC4321" class="sect1">
<h2 class="sect1">The <a id="sthref2050"></a><a id="sthref2051"></a>Object Cache</h2>
<p>The object cache is an area of memory on the client that is allocated for your program&#39;s use in interfacing with database objects. There are two interfaces to working with objects. The associative interface manipulates &#34;transient&#34; copies of the objects and the navigational interface manipulates &#34;persistent&#34; objects.</p>
<div id="LNPCC4322" class="sect2"><a id="sthref2052"></a>
<h3 class="sect2"><a id="sthref2053"></a><a id="sthref2054"></a>Persistent Versus<a id="sthref2055"></a><a id="sthref2056"></a> Transient Copies of Objects<a id="sthref2057"></a><a id="sthref2058"></a><a id="sthref2059"></a></h3>
<p>Objects that you allocated in the cache with EXEC SQL ALLOCATE statements in Pro*C/C++ are <span class="italic">transient copies</span> of persistent objects in the Oracle database. As such, you can update these copies in the cache after they are fetched in, but in order to make these changes persistent in the database, you must use explicit SQL commands. This &#34;transient copy&#34; or &#34;value-based&#34; object caching model is an extension of the relational model, in which scalar columns of relational tables can be fetched into host variables, updated in place, and the updates communicated to the server.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i449455"></a>
<div id="LNPCC4323" class="sect1">
<h2 class="sect1"><a id="sthref2060"></a>Associative Interface</h2>
<p>The associative interface manipulates transient copies of objects. Memory is allocated in the object cache with the EXEC SQL ALLOCATE statement.</p>
<p>One object cache is created for each SQLLIB runtime context.</p>
<p>Objects are retrieved by the EXEC SQL SELECT or EXEC SQL FETCH statements. These statements set values for the attributes of the host variable. If a NULL indicator is provided, it is also set.</p>
<p>Objects are inserted, updated, or deleted using EXEC SQL INSERT, EXEC SQL UPDATE, and EXEC SQL DELETE statements. The attributes of the object host variable must be set before the statement is executed.</p>
<p>Transactional statements EXEC SQL COMMIT and EXEC SQL ROLLBACK are used to write the changes permanently on the server or to cancel the changes.</p>
<p>You explicitly free memory in the cache for the objects by use of the EXEC SQL FREE statement. When a connection is terminated, Oracle implicitly frees its allocated memory.</p>
<div id="LNPCC4324" class="sect2"><a id="sthref2061"></a>
<h3 class="sect2">When to Use the <a id="sthref2062"></a>Associative Interface</h3>
<p>Use in these cases:</p>
<ul>
<li>
<p>To access large collections of objects where explicit joins between tables are not expensive.</p>
</li>
<li>
<p>To access objects that are not referenceable; they do not have object identity. For example, an object type in a relational column.</p>
</li>
<li>
<p>When an operation such as UPDATE or INSERT is applied to a set of objects. For example, add a bonus of $1000 to all employees in a department.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCC4325" class="sect2"><a id="sthref2063"></a>
<h3 class="sect2"><a id="sthref2064"></a>ALLOCATE</h3>
<p>You allocate space in the object cache with this statement. The syntax is:</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] ALLOCATE :<span class="italic">host_ptr</span> [[INDICATOR]:<span class="italic">ind_ptr</span>] ;
</pre>
<p>Variables entered are:</p>
<p>database (IN)</p>
<p>a zero-terminated string containing the name of the database connection, as established previously through the statement:</p>
<pre>EXEC SQL CONNECT :<span class="italic">user </span>[AT [:]<span class="italic">database</span>];
</pre>
<p>If the AT clause AT is omitted, or if <span class="italic">database</span> is an empty string, the default database connection is assumed.</p>
<p>host_ptr (IN)</p>
<p>a pointer to a host structure generated by OTT for object types, collection object types, or REFs, or a pointer to one of the new C datatypes: OCIDate, OCINumber, OCIRaw, or OCIString.</p>
<p>ind_ptr (IN)</p>
<p>The indicator variable, <span class="italic">ind_ptr</span>, is optional, as is the keyword INDICATOR. Only pointers to struct-typed indicators can be used in the ALLOCATE and FREE statements.</p>
<p><span class="italic">host_ptr</span> and <span class="italic">ind_ptr</span> can be host arrays.</p>
<p>The duration of allocation is the session. Any instances will be freed when the session (connection) is terminated, even if not explicitly freed by a FREE statement.</p>
<p>For more details, see <a href="pc_afemb.htm#CHEHGEEG">&#34;ALLOCATE (Executable Embedded SQL Extension)&#34;</a> and <a href="pc_afemb.htm#CHEBBHBC">&#34;FREE (Executable Embedded SQL Extension)&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i449255"></a>
<div id="LNPCC4326" class="sect2">
<h3 class="sect2"><a id="sthref2065"></a>FREE</h3>
<pre>EXEC SQL [AT[:]<span class="italic">database</span>] [OBJECT] FREE :<span class="italic">host_ptr</span> [[INDICATOR]:<span class="italic">ind_ptr</span>];
</pre>
<p>You de-allocate the space for an object that is placed in the object cache using the FREE statement. Variables used are the same as in the ALLOCATE statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Pointers to host and indicator variables are <span class="italic">not</span> set to null.</div>
</div>
<!-- class="sect2" -->
<a id="i449256"></a>
<div id="LNPCC4327" class="sect2">
<h3 class="sect2"><a id="sthref2066"></a>CACHE FREE ALL<a id="sthref2067"></a><a id="sthref2068"></a></h3>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [OBJECT] CACHE FREE ALL;
</pre>
<p>Use the earlier statement to free all object cache memory for the specified database connection.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_afemb.htm#CHEBFJIE">&#34;CACHE FREE ALL (Executable Embedded SQL Extension)&#34;</a></div>
</div>
<!-- class="sect2" -->
<div id="LNPCC4328" class="sect2"><a id="sthref2069"></a>
<h3 class="sect2">Accessing Objects Using the Associative Interface</h3>
<p>When accessing objects using SQL, Pro*C/C++ applications manipulate transient copies of the persistent objects. This is a direct extension of the relational access interface, which uses SELECT, UPDATE and DELETE statements.</p>
<p>In <a href="#i449766">Figure 17-1</a>, you allocate memory in the cache for a transient copy of the persistent object with the ALLOCATE statement. The allocated object does not contain data, but it has the form of the struct generated by the OTT.</p>
<pre>person *per_p;
...
EXEC SQL ALLOCATE :per_p;
</pre>
<p>You can execute a SELECT statement to populate the cache. Or, use a FETCH statement or a C assignment to populate the cache with data.</p>
<pre>EXEC SQL SELECT ... INTO :per_p FROM person_tab WHERE ...
</pre>
<p>Make changes to the server objects with INSERT, UPDATE or DELETE statements, as shown in the illustration. You can insert the data is into the table by the INSERT statement:</p>
<pre>EXEC SQL INSERT INTO person_tab VALUES(:per_p);
</pre>
<p>Finally, free memory associated with the copy of the object with the FREE statement:</p>
<pre>EXEC SQL FREE :per_p;
</pre>
<div id="LNPCC4329" class="figure">
<p class="titleinfigure"><a id="i449766"></a>Figure 17-1 Accessing Objects Using SQL</p>
<img width="600" height="432" src="img/lnpcc069.gif" alt="Description of Figure 17-1 follows"/><br/>
<a id="sthref2070" href="img_text/lnpcc069.htm">Description of &#34;Figure 17-1 Accessing Objects Using SQL &#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i447871"></a>
<div id="LNPCC4330" class="sect1">
<h2 class="sect1">Navigational Interface</h2>
<p>Use the navigational interface to access the same schema as the associative interface. The navigational interface accesses objects, both persistent and transient) by dereferencing REFs to objects and traversing (&#34;navigating&#34;) from one object to another. Some definitions follow.</p>
<p><span class="italic">Pinning</span> an object is the term used to mean dereferencing the object, allowing the program to access it.</p>
<p><span class="italic">Unpinning</span> means indicating to the cache that the object is no longer needed.</p>
<p><span class="italic">Dereferencing</span> can be defined as the server using the REF to create a version of the object in the client. While the cache maintains the association between objects in the cache and the corresponding server objects, it does not provide automatic coherency. You have the responsibility to ensure correctness and consistency of the contents of the objects in the cache.</p>
<p><span class="italic">Releasing</span> an object copy indicates to the cache that the object is not currently being used. To free memory, release objects when they are no longer needed to make them eligible for implicit freeing.</p>
<p><span class="italic">Freeing</span> an object copy removes it from the cache and releases its memory area.</p>
<p><span class="italic">Marking</span> an object tells the cache that the object copy has been updated in the cache and the corresponding server object must be updated when the object copy is flushed.</p>
<p><span class="italic">Un-marking</span> an object removes the indication that the object has been updated.</p>
<p><span class="italic">Flushing</span> an object writes local changes made to marked copies in the cache to the corresponding objects in the server. The object copies in the cache are also unmarked at this time.</p>
<p><span class="italic">Refreshing</span> an object copy in the cache replaces it with the latest value of the corresponding object in the server.</p>
<p>The navigational and associative interfaces can be used together.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i457199">&#34;Example Code for Navigational Access&#34;</a> for an illustration of using the navigational and associative interfaces together</div>
<p>Use the EXEC SQL OBJECT statements, the navigational interface, to update, delete, and flush cache copies (write changes in the cache to the server).</p>
<div id="LNPCC4331" class="sect2"><a id="sthref2071"></a>
<h3 class="sect2">When to Use the Navigational Interface</h3>
<p>Use the navigational interface:</p>
<ul>
<li>
<p>To access a single or small set of objects where explicit joins between tables are expensive. When you use dereferencing to navigate between objects, you perform implicit joins which are less expensive than an explicit join across two entire tables.</p>
</li>
<li>
<p>To make many small changes to many different objects. It is more convenient to fetch all objects to the client, make changes, mark them as updated, and flush all the changes back to the server.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCC4332" class="sect2"><a id="sthref2072"></a>
<h3 class="sect2">Rules Used in the Navigational Statements</h3>
<p>Embedded SQL OBJECT statements are described later with these assumptions:</p>
<ul>
<li>
<p>If an AT clause is absent, the default (unnamed) connection is assumed.</p>
</li>
<li>
<p>Host variables can be arrays, except where specifically noted.</p>
</li>
<li>
<p>Use the FOR clause to explicitly specify the array dimension. If absent, the minimum dimension of the pertinent host variables is used.</p>
</li>
<li>
<p>After execution of the statement, if the SQLCA is provided as a status variable, the number of elements processed is returned in sqlca.sqlerrd[2].</p>
</li>
<li>
<p>Parameters have IN or OUT (or both) specified to signify input or output.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_afemb.htm#CHEJCBII">Appendix E, &#34; Embedded SQL Statements and Directives&#34;</a> for SQL OBJECT statements and syntax diagrams</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i449257"></a>
<div id="LNPCC4333" class="sect2">
<h3 class="sect2"><a id="sthref2073"></a>OBJECT CREATE</h3>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [FOR [:]<span class="italic">count</span>] OBJECT CREATE :<span class="italic">obj </span>[INDICATOR]:
<span class="italic">obj_ind</span> [TABLE <span class="italic">tab</span>] [RETURNING REF INTO :<span class="italic">ref</span>] ;
</pre>
<p>where tab is:</p>
<p>{:hv | [schema.]table}</p>
<p>Use this statement to create a referenceable object in the object cache. The type of the object corresponds to the host variable <span class="italic">obj</span>. When optional type host variables (<code>:obj_ind,:ref,:ref_ind</code>) are supplied, they must all correspond to the same type.</p>
<p>The referenceable object can be either persistent (TABLE clause is supplied) or transient (TABLE clause is absent). Persistent objects are implicitly pinned and marked as updated. Transient objects are implicitly pinned.</p>
<p>The host variables are:</p>
<p>obj (OUT)</p>
<p>The object instance host variable, <span class="italic">obj,</span> must be a pointer to a structure generated by OTT. This variable is used to determine the referenceable object that is created in the object cache. After a successful execution, <span class="italic">obj</span> will point to the newly created object.</p>
<p>obj_ind (OUT)</p>
<p>This variable points to an OTT-generated indicator structure. Its type must match that of the object instance host variable. After a successful execution, <span class="italic">obj_ind</span> will be a pointer to the parallel indicator structure for the referenceable object.</p>
<p>tab (IN)</p>
<p>Use the table clause to create persistent objects. The table name can be specified as a host variable, <span class="italic">hv</span>, or as an undeclared SQL identifier. It can be qualified with a schema name. Do not use trailing spaces in host variables containing the table name.</p>
<p>hv (IN)</p>
<p>A host variable specifying a table. If a host variable is used, <span class="italic">it must not</span> be an array. It must not be blank-padded. It is case-sensitive. When an array of persistent objects is created, they are all associated with the same table.</p>
<p>table (IN)</p>
<p>An undeclared SQL identifier which is case-sensitive.</p>
<p>ref (OUT)</p>
<p>The reference host variable must be a pointer to the OTT-generated reference type. The type of <span class="italic">ref</span> must match that of the object instance host variable. After execution, <span class="italic">ref</span> contains a pointer to the ref for the newly created object.</p>
<p>Attributes are initially set to null. Creating new objects for object views is not currently supported.</p>
<p>Creating new objects for object views is <span class="italic">not</span> currently supported.</p>
</div>
<!-- class="sect2" -->
<a id="i449258"></a>
<div id="LNPCC4334" class="sect2">
<h3 class="sect2"><a id="sthref2074"></a>OBJECT DEREF</h3>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [FOR [:]<span class="italic">count</span>] OBJECT DEREF :ref INTO :<span class="italic">obj</span> [[INDICATOR]:<span class="italic">obj_ind</span>
] [FOR UPDATE [NOWAIT]] ;
</pre>
<p>Given an object reference, <span class="italic">ref</span>, the OBJECT DEREF statement pins the corresponding object or array of objects in the object cache. Pointers to these objects are returned in the variables <span class="italic">obj</span> and <span class="italic">obj_ind</span>.</p>
<p>The host variables are:</p>
<p>ref (IN)</p>
<p>This is the object reference variable, which must be a pointer to the OTT-generated reference type. This variable (or array of variables) is dereferenced, returning a pointer to the corresponding object in the cache.</p>
<p>obj (OUT)</p>
<p>The object instance host variable, <span class="italic">obj</span>, must be a pointer to an OTT-generated structure. Its type must match that of the object reference host variable. After successful execution, <span class="italic">obj</span> contains a pointer to the pinned object in the object cache.</p>
<p>obj_ind (OUT)</p>
<p>The object instance indicator variable, <span class="italic">obj_ind</span>, must be a pointer to an OTT-generated indicator structure. Its type must match that of the object reference indicator variable. After successful execution, <span class="italic">obj_ind</span> contains a pointer to the parallel indicator structure for the referenceable object.</p>
<p>FOR UPDATE</p>
<p>If this clause is present, an exclusive lock is obtained for the corresponding object in the server.</p>
<p>NOWAIT</p>
<p>If this optional keyword is present, an error is immediately returned if another user has already locked the object.</p>
</div>
<!-- class="sect2" -->
<a id="i449262"></a>
<div id="LNPCC4335" class="sect2">
<h3 class="sect2">OBJECT RELEASE</h3>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [FOR [:]<span class="italic">count</span>] OBJECT RELEASE :<span class="italic">obj</span> ;
</pre>
<p>This statement unpins the object in the object cache. When an object is not pinned and not updated, it is eligible for implicit freeing.</p>
<p>If an object has been dereferenced n times, it must be released n times to be eligible for implicit freeing from the object cache. Oracle advises releasing all objects that are no longer needed.</p>
</div>
<!-- class="sect2" -->
<a id="i449259"></a>
<div id="LNPCC4336" class="sect2">
<h3 class="sect2"><a id="sthref2075"></a>OBJECT DELETE</h3>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [FOR [:]<span class="italic">count</span>] OBJECT DELETE :<span class="italic">obj</span> ;
</pre>
<p>For persistent objects, this statement marks an object or array of objects as deleted in the object cache. The object is deleted in the server when the object is flushed or when the cache is flushed. The memory reserved in the object cache is not freed.</p>
<p>For transient objects, the object is marked as deleted. The memory for the object is not freed.</p>
</div>
<!-- class="sect2" -->
<a id="i449397"></a>
<div id="LNPCC4337" class="sect2">
<h3 class="sect2"><a id="sthref2076"></a>OBJECT UPDATE</h3>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [FOR [:]<span class="italic">count</span>] OBJECT UPDATE :<span class="italic">obj</span> ;
</pre>
<p>For persistent objects, this statement marks them as updated in the object cache. The changes are written to the server when the object is flushed or when the cache is flushed.</p>
<p>For transient objects, this statement is a no-op.</p>
</div>
<!-- class="sect2" -->
<a id="i449260"></a>
<div id="LNPCC4338" class="sect2">
<h3 class="sect2"><a id="sthref2077"></a>OBJECT FLUSH</h3>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [FOR [:]<span class="italic">count</span>] OBJECT FLUSH :<span class="italic">obj</span> ;
</pre>
<p>This statement flushes persistent objects that have been marked as updated, deleted, or created, to the server.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An exclusive lock is implicitly obtained when the object is flushed. After the statement successfully completes, the objects are unmarked. If the object version is LATEST (see next section), then the object will be implicitly refreshed.</div>
</div>
<!-- class="sect2" -->
<a id="i453951"></a>
<div id="LNPCC4339" class="sect2">
<h3 class="sect2">Navigational Access to Objects</h3>
<p>See <a href="#i449836">Figure 17-2</a> for an illustration of the navigational interface.</p>
<p>Use the ALLOCATE statement to allocate memory in the object cache for a copy of the REF to the <span class="italic">person</span> object. The allocated REF does not contain data.</p>
<pre>person *per_p;
person_ref *per_ref_p;
...
EXEC SQL ALLOCATE :per_p;
</pre>
<p>Populate the allocated memory by using a SELECT statement to retrieve the REF of the <span class="italic">person</span> object (exact format depends on the application):</p>
<pre>EXEC SQL SELECT ... INTO :per_ref_p;
</pre>
<p>The DEREF statement is then used to pin the object in the cache, so that changes can be made in the object. The DEREF statement takes the pointer <span class="italic">per_ref_p</span> and creates an instance of the <span class="italic">person</span> object in the client-side cache. The pointer <span class="italic">per_p</span> to the <span class="italic">person</span> object is returned.</p>
<pre>EXEC SQL OBJECT DEREF :per_ref_p INTO :per_p;
</pre>
<div id="LNPCC4340" class="figure">
<p class="titleinfigure"><a id="i449836"></a>Figure 17-2 Navigational Access</p>
<img width="600" height="358" src="img/lnpcc070.gif" alt="Description of Figure 17-2 follows"/><br/>
<a id="sthref2078" href="img_text/lnpcc070.htm">Description of &#34;Figure 17-2 Navigational Access&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Make changes to the object in the cache by using C assignment statements, or by using data conversions with the OBJECT SET statement.</p>
<p>Then you must mark the object as updated. See <a href="#i449886">Figure 17-3</a>. To mark the object in the cache as updated, and eligible to be flushed to the server:</p>
<pre>EXEC SQL OBJECT UPDATE :per_p;
</pre>
<p>You send changes to the server by the FLUSH statement:</p>
<pre>EXEC SQL OBJECT FLUSH :per_p;
</pre>
<p>You release the object:</p>
<pre>EXEC SQL OBJECT RELEASE :per_p;
</pre>
<div id="LNPCC4341" class="figure">
<p class="titleinfigure"><a id="i449886"></a>Figure 17-3 Navigational Access (continued)</p>
<img width="600" height="328" src="img/lnpcc071.gif" alt="Description of Figure 17-3 follows"/><br/>
<a id="sthref2079" href="img_text/lnpcc071.htm">Description of &#34;Figure 17-3 Navigational Access (continued)&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The statements in the next section are used to make the conversions between object attributes and C types.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i449464"></a>
<div id="LNPCC4342" class="sect1">
<h2 class="sect1">Converting Object Attributes and C Types</h2>
<p>This section covers issues relating to attribute and type conversion.</p>
<a id="i449507"></a>
<div id="LNPCC4343" class="sect2">
<h3 class="sect2"><a id="sthref2080"></a>OBJECT SET</h3>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] 
  OBJECT SET  [ {&#39;*&#39; | {<span class="italic">attr</span>[,<span class="italic"> attr</span>]} } OF] 
    :<span class="italic">obj</span> [[INDICATOR]:<span class="italic">obj_ind</span>] 
       TO {:<span class="italic">hv</span> [[INDICATOR]:<span class="italic">hv_ind</span>] 
          [, :<span class="italic">hv</span> [INDICATOR]:<span class="italic">hv_ind</span>]]} ;
</pre>
<p>Use this statement with objects created by both the associative and the navigational interfaces. This statement updates the attributes of the object. For persistent objects, the changes will be written to the server when the object is updated and flushed. Flushing the cache writes all changes made to updated objects to the server.</p>
<p>The OF clause is optional. If absent, all the attributes of <span class="italic">obj</span> are set. The same result is achieved by writing:</p>
<pre>... OBJECT SET * OF ...
</pre>
<p>The host variable list can include structures that are exploded to provide values for the attributes. However, the number of attributes in <span class="italic">obj</span> must match the number of elements in the exploded variable list.</p>
<p>Host variables and attributes are:</p>
<p>attr</p>
<p>The attributes are not host variables, but rather simple identifiers that specify which attributes of the object will be updated. The first attribute in the list is paired with the first expression in the list, and so on. The attribute must be one of either OCIString, OCINumber, OCIDate, or OCIRef.</p>
<p>obj (IN/OUT)</p>
<p><span class="italic">obj</span> specifies the object to be updated. The bind variable <span class="italic">obj</span> must not be an array. It must be a pointer to an OTT-generated structure.</p>
<p>obj_ind (IN/OUT)</p>
<p>The parallel indicator structure that will be updated. It must be a pointer to an OTT-generated indicator structure.</p>
<p>hv (IN)</p>
<p>This is the bind variable used as input to the OBJECT SET statement. <span class="italic">hv</span> must be an int, float, OCIRef *, a one-dimensional char array, or a structure of these types.</p>
<p>hv_ind (IN)</p>
<p>This is the associated indicator that is used as input to the OBJECT SET statement. <span class="italic">hv_ind</span> must be a 2-byte integer scalar or a structure of 2-byte integer scalars.</p>
<p>Using Indicator Variables:</p>
<p>If a host variable indicator is present, then an object indicator must also be present.</p>
<p>If hv_ind is set to -1, the associated field in the obj_ind is set to -1.</p>
<p>The following implicit conversions are permitted:</p>
<ul>
<li>
<p>[OCIString | STRING | VARCHAR | CHARZ] to OCIString</p>
</li>
<li>
<p>OCIRef to OCIRef</p>
</li>
<li>
<p>[OCINumber | int | float | double] to OCINumber</p>
</li>
<li>
<p>[OCIDate | STRING | VARCHAR | CHARZ ] to OCIDate</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Nested structures are not allowed.</p>
</li>
<li>
<p>This statement cannot be used to set a referenceable object to be atomically NULL. Set the appropriate field of the NULL indicator instead.</p>
</li>
<li>
<p>Conversions between the OCIDateTime or OCIInterval datatypes and OCIString are not supported.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i449298"></a>
<div id="LNPCC4344" class="sect2">
<h3 class="sect2"><a id="sthref2081"></a>OBJECT GET</h3>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] 
   OBJECT GET [ { &#39;*&#39; | {<span class="italic">attr</span>[, <span class="italic">attr</span>]} } FROM]
     :<span class="italic">obj</span> [[INDICATOR]:<span class="italic">obj_ind</span>] 
        INTO {:<span class="italic">hv</span> [[INDICATOR]:<span class="italic">hv_ind</span>]
          [, :<span class="italic">hv</span> [[INDICATOR]:<span class="italic">hv_ind</span>]]} ;
</pre>
<p>This statement converts the attributes of an object into native C types.</p>
<p>The FROM clause is optional. If absent, all the attributes of <span class="italic">obj</span> are converted. The same result is achieved by writing:</p>
<pre>... OBJECT GET * FROM ...
</pre>
<p>The host variable list may include structures that are exploded to receive the values of the attributes. However, the number of attributes in <span class="italic">obj</span> must match the number of elements in the exploded host variable list.</p>
<p>Host variables and attributes:</p>
<p>attr</p>
<p>The attributes are not host variables, but simple identifiers that specify which attributes of the object will be retrieved. The first attribute in the list is paired with the first host variable in the list, and so on. The attribute must represent a base type. It must be OCIString, OCINumber, OCIRef, or OCIDate.</p>
<p>obj (IN)</p>
<p>This specifies the object that serves as the source for the attribute retrieval. The bind variable <span class="italic">obj</span> must not be an array.</p>
<p>hv (OUT)</p>
<p>This is the bind variable used to hold output from the OBJECT GET statement. It can be an int, float, double, a one-dimensional char array, or a structure containing those types. The statement returns the converted attribute value in this host variable.</p>
<p>hv_ind (OUT)</p>
<p>This is the associated indicator variable for the attribute value. It is a 2-byte integer scalar or a structure of 2-byte integer scalars.</p>
<p>Using Indicator Variables:</p>
<p>If no object indicator is specified, it is assumed that the attribute is valid. <span class="italic">It is a program error</span> to convert object attributes to C types if the object is atomically NULL or if the requested attribute is NULL and no object indicator variable is supplied. <span class="italic">It may not be possible to raise an Oracle error in this situation.</span></p>
<p>If the object variable is atomically NULL or the requested attribute is NULL, and a host variable indicator (<span class="italic">hv_ind</span>) is supplied, then it is set to -1.</p>
<p>If the object is atomically NULL or the requested attribute is NULL, and no host variable indicator is supplied, then an error is raised.</p>
<p>The following implicit conversions are permitted:</p>
<ul>
<li>
<p>OCIString to [STRING | VARCHAR | CHARZ | OCIString]</p>
</li>
<li>
<p>OCINumber to [int | float | double | OCINumber]</p>
</li>
<li>
<p>OCIRef to OCIRef</p>
</li>
<li>
<p>OCIDate to [STRING | VARCHAR | CHARZ | OCIDate]</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Nested structures are not allowed</p>
</li>
<li>
<p>Conversions between the OCIDateTime or OCIInterval datatypes and OCIString are not supported</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i453930"></a>
<div id="LNPCC4345" class="sect1">
<h2 class="sect1">Object Options Set/Get</h2>
<p>The runtime context has options which are set to default values when the runtime context is created and allocated. You can then set these options with this embedded SQL directive:</p>
<a id="i453203"></a>
<div id="LNPCC4346" class="sect2">
<h3 class="sect2"><a id="sthref2082"></a>CONTEXT OBJECT OPTION SET</h3>
<pre>EXEC SQL CONTEXT OBJECT OPTION SET {<span class="italic">option</span>[, <span class="italic">option</span>]} TO {:<span class="italic">hv</span>[, :<span class="italic">hv</span>]} ;
</pre>
<p>where the variables are:</p>
<p>:hv(IN) ...</p>
<p>The input bind variables <span class="italic">hv ...</span>, are of type STRING, VARCHAR, or CHARZ.</p>
<p>option ...</p>
<p>Simple identifiers that specify which option of the runtime context to update. The first option is paired with the first input bind variable, and so on. Here are the values supported at this time:</p>
<div id="LNPCC4347" class="tblformal">
<p class="titleintable"><a id="sthref2083"></a><a id="g470077"></a>Table 17-1 Valid Choices for CONTEXT OBJECT OPTION Values</p>
<table class="cellalignment831" title="Valid Choices for CONTEXT OBJECT OPTION Values" summary="Valid Choices for CONTEXT OBJECT OPTION Values" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t12">Option Value</th>
<th class="cellalignment832" id="r1c2-t12">Specifies</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t12" headers="r1c1-t12">
<p>DATEFORMAT</p>
</td>
<td class="cellalignment833" headers="r2c1-t12 r1c2-t12">
<p>Format for Date attributes and collection elements.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t12" headers="r1c1-t12">
<p>DATELANG</p>
</td>
<td class="cellalignment833" headers="r3c1-t12 r1c2-t12">
<p>Globalization Support language for all Date and Datetime types.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>An example is:</p>
<pre>char *new_format = &#34;DD-MM-YYYY&#34;;
char *new_lang = &#34;French&#34;;
char *new_date = &#34;14-07-1789&#34;;
/* One of the attributes of the license type is dateofbirth */
license *aLicense; 
...
/* Declaration and allocation of context ... */
EXEC SQL CONTEXT OBJECT OPTION SET DATEFORMAT, DATELANG TO :new_format,   :new_lang;
/* Navigational object obtained  */
...
EXEC SQL OBJECT SET dateofbirth OF :aLicense TO :new_date;
...
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for a complete list of allowed formats</p>
</li>
<li>
<p><a href="pc_afemb.htm#CHEIIBDG">&#34;CONTEXT OBJECT OPTION SET (Executable Embedded SQL Ext)&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i453202"></a>
<div id="LNPCC4348" class="sect2">
<h3 class="sect2"><a id="sthref2084"></a>CONTEXT OBJECT OPTION GET</h3>
<p>The context affected is understood to be the context in use at the time. To determine the values of these options, use this directive:</p>
<pre>EXEC SQL CONTEXT OBJECT OPTION GET {<span class="italic">option</span>[, <span class="italic">option</span>]} INTO {:<span class="italic">hv</span>[, :<span class="italic">hv</span>]} ;
</pre>
<p>Where the values of <span class="italic">option</span> are found in <a href="#g470077">Table 17-1, &#34;Valid Choices for CONTEXT OBJECT OPTION Values&#34;</a>.</p>
<p>The bind variables, <span class="italic">hv</span> ... are used as output, and are of type STRING, VARCHAR, or CHARZ. The context affected is understood to be the context in use at the time.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for a complete list of the allowed formats</p>
</li>
<li>
<p><a href="pc_afemb.htm#CHEDGBJB">&#34;CONTEXT OBJECT OPTION GET (Executable Embedded SQL Extension)&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i449469"></a>
<div id="LNPCC4349" class="sect1">
<h2 class="sect1">New Precompiler Options for Objects</h2>
<p>To support objects, use these precompiler options:</p>
<div id="LNPCC4350" class="sect2"><a id="sthref2085"></a>
<h3 class="sect2"><a id="sthref2086"></a>VERSION</h3>
<p>This option determines which version of the object is returned by the EXEC SQL OBJECT DEREF statement. This gives you varying levels of consistency between cache objects and server objects.</p>
<p>Use the EXEC ORACLE OPTION statement to set it inline. Permitted values are:</p>
<dl>
<dt>RECENT (default)</dt>
<dd>
<p>If the object has been selected into the object cache in the current transaction, then return that object. If the object has not been selected, it is retrieved from the server. For transactions that are running in serializable mode, this option has the same behavior as VERSION=LATEST without incurring as many network round trips. This value can be safely used with most Pro*C/C++ applications.</p>
</dd>
<dt>LATEST</dt>
<dd>
<p>If the object does not reside in the object cache, it is retrieved from the database. If it does reside in the object cache, it is refreshed from the server. Use this value with caution because it will incur the greatest number of network round trips. Use it only when it is imperative that the object cache be kept as coherent as possible with the server-side buffer.</p>
</dd>
<dt>ANY</dt>
<dd>
<p>If the object already resides in the object cache, then return that object. If the object does not reside in the object cache, retrieve it from the server. This value will incur the fewest number of network round trips. Use in applications that access read-only objects or when a user will have exclusive access to the objects.</p>
</dd>
</dl>
</div>
<!-- class="sect2" -->
<div id="LNPCC4351" class="sect2"><a id="sthref2087"></a>
<h3 class="sect2"><a id="sthref2088"></a>DURATION</h3>
<p>Use this precompiler option to set the pin duration used by subsequent EXEC SQL OBJECT CREATE and EXEC SQL OBJECT DEREF statements. Objects in the cache are implicitly unpinned at the end of the duration.</p>
<p>Use with navigational interface only.</p>
<p>You can set this option in the EXEC ORACLE OPTION statement. Permitted values are:</p>
<dl>
<dt>TRANSACTION (default)</dt>
<dd>
<p>Objects are implicitly unpinned when the transaction completes.</p>
</dd>
<dt>SESSION</dt>
<dd>
<p>Objects are implicitly unpinned when the connection is terminated.</p>
</dd>
</dl>
</div>
<!-- class="sect2" -->
<div id="LNPCC4352" class="sect2"><a id="sthref2089"></a>
<h3 class="sect2"><a id="sthref2090"></a>OBJECTS</h3>
<p>This precompiler option provides the ability to use the object cache.</p>
<p>The OBJECTS default value, for DBMS=NATIVE | V8, is YES. The default size of the object cache is the same as the OCI default cache size, 8 Mbytes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#i5481">&#34;OBJECTS&#34;</a></div>
</div>
<!-- class="sect2" -->
<div id="LNPCC4353" class="sect2"><a id="sthref2091"></a>
<h3 class="sect2">INTYPE</h3>
<p>If your program uses any object types, collection object types, or REFs, you must give the INTYPE files in this command-line option.</p>
<p>Specify the INTYPE option using the syntax:</p>
<pre>   INTYPE=<span class="italic">filename1</span> INTYPE=<span class="italic">filename2</span> ...
</pre>
<p>where <span class="italic">filename1</span>, and so on., is the name of the typefiles generated by OTT. These files are meant to be a read-only input to Pro*C/C++. The information in it, though in plain-text form, might be encoded, and might not necessarily be interpretable by you, the user.</p>
<p>You can provide more than one INTYPE file as input to a single Pro*C/C++ precompilation unit.</p>
<p>This option cannot be used inline in EXEC ORACLE statements.</p>
<p>OTT generates C structure declarations for object types created in the database, and writes type names and version information to a file called the <span class="italic">typefile.</span></p>
<p>An object type may not necessarily have the same name as the C structure type or C++ class type that represents it. This could arise for the following reasons:</p>
<ul>
<li>
<p>The name of the object type specified in the server includes characters not legal in a C or C++ identifier</p>
</li>
<li>
<p>The user asked OTT to use a different name for the structure or class</p>
</li>
<li>
<p>The user asked OTT to change the case of names</p>
</li>
</ul>
<p>Under these circumstances, it is impossible to infer from the structure or class declaration which object type it matches. This information, which is required by Pro*C/C++, is generated by OTT in the type file.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4354" class="sect2"><a id="sthref2092"></a>
<h3 class="sect2"><a id="sthref2093"></a>ERRTYPE</h3>
<pre>   ERRTYPE=<span class="italic">filename</span>
</pre>
<p>Writes errors to the file specified, as well as to the screen. If omitted, errors are directed to the screen only. Only one ERRTYPE is allowed. As is usual with other single-valued command-line options, if you enter multiple values for ERRTYPE on the command line, the last one supersedes the earlier values.</p>
<p>This option cannot be used inline in EXEC ORACLE statements.</p>
</div>
<!-- class="sect2" -->
<a id="i437341"></a>
<div id="LNPCC4355" class="sect2">
<h3 class="sect2"><a id="sthref2094"></a>SQLCHECK Support for Objects<a id="sthref2095"></a><a id="sthref2096"></a></h3>
<p>Object types and their attributes are represented in a C program according to the C binding of Oracle types. If the precompiler command-line option SQLCHECK is set to SEMANTICS or FULL, Pro*C/C++ verifies during precompilation that host variable types conform to the mandated C bindings for the types in the database schema. In addition, runtime checks are always performed to verify that Oracle types are mapped correctly during program execution.</p>
<p>Relational datatypes are checked in the usual manner.</p>
<p>A relational SQL datatype is compatible with a host variable type if the two types are the same, or if a conversion is permitted between the two. Object types, on the other hand, are compatible only if they are the same type. They must</p>
<ul>
<li>
<p>Have the same name</p>
</li>
<li>
<p>Be in the same schema (if a schema is explicitly specified)</p>
</li>
</ul>
<p>When you specify the option SQLCHECK=SEMANTICS or FULL, during precompilation Pro*C/C++ logs onto the database using the specified userid and password, and verifies that the object type from which a structure declaration was generated is identical to the object type used in the embedded SQL statement.</p>
</div>
<!-- class="sect2" -->
<a id="i443585"></a>
<div id="LNPCC4356" class="sect2">
<h3 class="sect2"><a id="sthref2097"></a><a id="sthref2098"></a>Type Checking at Runtime</h3>
<p>Pro*C/C++ gathers the type name, version, and possibly schema information for Object, collection Object, and REF host variables, for a type from the input INTYPE file, and stores this information in the code that it generates. This enables access to the type information for Object and REF bind variables at runtime. Appropriate errors are returned for type mismatches.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i449474"></a>
<div id="LNPCC4357" class="sect1">
<h2 class="sect1">An Object Example in Pro*C/C++</h2>
<p>Let us examine a simple object example. You create a type <span class="italic">person</span> and a table <span class="italic">person_tab,</span> which has a column that is also an object type, <span class="italic">address</span>:</p>
<pre>create type person as object (
        lastname        varchar2(20),
        firstname       char(20),
        age             int,
        addr            address
)
/
create table person_tab of person;
</pre>
<p>Insert data in the table, and proceed.</p>
<div id="LNPCC4358" class="sect2"><a id="sthref2099"></a>
<h3 class="sect2">Associative Access</h3>
<p>Consider the case of how to change a <span class="italic">lastname</span> value from &#34;Smith&#34; to &#34;Smythe&#34;, using Pro*C/C++.</p>
<p>Run the OTT to generate C structures which map to <span class="italic">person</span>. In your Pro*C/C++ program you must include the header file generated by OTT.</p>
<p>In your application, declare a pointer, <span class="italic">person_p</span>, to the persistent memory in the client-side cache. Then allocate memory and use the returned pointer:</p>
<pre>char *new_name = &#34;Smythe&#34;;
person *person_p;
...
EXEC SQL ALLOCATE :person_p;
</pre>
<p>Memory is now allocated for a copy of the persistent object. The allocated object does not yet contain data.</p>
<p>Populate data in the cache either by C assignment statements or by using SELECT or FETCH to retrieve an existing object:</p>
<pre>EXEC SQL SELECT VALUE(p) INTO :person_p FROM person_tab p WHERE lastname = &#39;Smith&#39;;
</pre>
<p>Changes made to the copy in the cache are transmitted to the server database by use of INSERT, UPDATE, and DELETE statements:</p>
<pre>EXEC SQL OBJECT SET lastname OF :person_p TO :new_name;
EXEC SQL INSERT INTO person_tab VALUES(:person_p);
</pre>
<p>Free cache memory in this way:</p>
<pre>EXEC SQL FREE :person_p;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4359" class="sect2"><a id="sthref2100"></a>
<h3 class="sect2">Navigational Access</h3>
<p>Allocate memory in the object cache for a copy of the REF to the object <span class="italic">person</span>. The ALLOCATE statement returns a pointer to the REF:</p>
<pre>person *person_p;
person_ref *per_ref_p;
...
EXEC SQL ALLOCATE :per_ref_p;
</pre>
<p>The allocated REF contains no data. To populate it with data, retrieve the REF of the object:</p>
<pre>EXEC SQL SELECT ... INTO :per_ref_p;
</pre>
<p>Then dereference the REF to put an instance of object in the client-side cache. The dereference command takes the <span class="italic">per_ref_p</span> and creates an instance of the corresponding object in the cache:</p>
<pre>EXEC SQL OBJECT DEREF :per_ref_p INTO :person_p;
</pre>
<p>Make changes to data in the cache by using C assignments, or by using OBJECT GET statements:</p>
<pre>/* lname is a C variable to hold the result */
EXEC SQL OBJECT GET lastname FROM :person_p INTO :lname;
...
EXEC SQL OBJECT SET lastname OF :person_p TO :new_name;
/* Mark the changed object as changed with OBJECT UPDATE command */;
EXEC SQL OBJECT UPDATE :person_p;
EXEC SQL FREE :per_ref_p;
</pre>
<p>To make the changes permanent in the database, use FLUSH:</p>
<pre>EXEC SQL OBJECT FLUSH :person_p;
</pre>
<p>Changes have been made to the server; the object can now be released. Objects that are released are not necessarily freed from the object cache memory immediately. They are placed on a least-recently used stack. When the cache is full, the objects are swapped out of memory.</p>
<p>Only the object is released; the REF to the object remains in the cache. To release the REF, use the RELEASE statement. for the REF. To release the object pointed to by <code>person_p</code>:</p>
<pre>EXEC SQL OBJECT RELEASE :person_p;
</pre>
<p>Or, issue a transaction commit and all objects in the cache are released, provided the pin duration has been set appropriately.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i457195"></a>
<div id="LNPCC4360" class="sect1">
<h2 class="sect1">Example Code for Type Inheritance</h2>
<p><a id="sthref2101"></a>The following code example creates four object types:</p>
<ul>
<li>
<p>Person_t</p>
</li>
<li>
<p><code>Employee_t</code> as a subtype of <code>Person_t</code></p>
</li>
<li>
<p><code>Student_t</code> as a subtype of <code>Person_t</code></p>
</li>
<li>
<p><code>PartTimeStudent_t</code> as a subtype of <code>Student_t</code></p>
</li>
</ul>
<p>and one table:</p>
<ul>
<li>
<p><code>person_tab</code> to hold <code>Person_t</code> and its subtype objects</p>
</li>
</ul>
<p>The SQL file, <code>inhdemo1.sql</code>, that creates the object types and table, and then inserts values into the table, is:</p>
<pre>connect scott/tiger;

rem ** Always drop your objects in reverse dependency order
drop table person_tab;
drop type PartTimeStudent_t;
drop type Student_t;
drop type Employee_t;
drop type Person_t;

rem ** Create the TYPES, TYPED TABLES and TABLES we need

rem ** Create a Person_t ADT
CREATE TYPE Person_t AS OBJECT
( ssn NUMBER,
  name VARCHAR2(30),
  address VARCHAR2(100)) NOT FINAL;
/

rem ** Create a Person_t subtype Employee_t
CREATE TYPE Employee_t UNDER Person_t
( empid NUMBER, 
  mgr VARCHAR2(30));
/

rem ** Create a Person_t subtype Student_t
CREATE TYPE Student_t UNDER Person_t 
( deptid NUMBER,
   major VARCHAR2(30)) NOT FINAL;
/

rem ** Create a Student_t subtype PartTimeStudent_t
CREATE TYPE PartTimeStudent_t UNDER Student_t
( numhours NUMBER);
/

rem ** Create a typed table for person_t objects
CREATE table person_tab of person_t;

rem ** Insert 2 Employee_t objects into the person_t typed table
insert into person_tab values
  (Employee_t(123456, &#39;Alison Laurence&#39;, &#39;100 Geary Street, San Francisco, CA 94013&#39;,
1001, &#39;CEO&#39;));
insert into person_tab values
  (Employee_t(234567, &#39;William Bates&#39;, &#39;123 Main Street, Anytown, WA 97818&#39;,
1002,&#39;CFO&#39;));

rem ** Insert 2 Student_t objects into the person_t typed table
insert into person_tab values
  (Student_t(20001, &#39;Van Gates&#39;, &#39;1825 Aikido Way, Los Angeles, CA, 45300&#39;, 20,
&#39;English&#39;));
insert into person_tab values
  (Student_t(20002, &#39;Bill Wallace&#39;, &#39;12 Shugyo Blvd, Los Angeles, CA, 95100&#39;, 30,
&#39;Computer Science&#39;));

rem ** Insert 1 PartTimeStudent_t object into the person_t typed table
insert into person_tab values
  (PartTimeStudent_t(20003, &#39;Jean Claude&#39;, &#39;874 Richmond Street, New York, NY 45100&#39;,
40, &#39;Music&#39;,20));

commit;
</pre>
<p>Here is the listing of the intype file for our example, <code>inhdemo1.typ</code>:</p>
<pre>case=same
type person_t
type employee_t
type student_t
type parttimestudent_t
</pre>
<p>Here is the listing of the precompiler file, <code>inhdemo1.pc</code>:</p>
<pre>/*****************************************************************************
 *
 * This is a simple Pro*C/C++ program designed to illustrate how to
 * access type inheritance objects.
 *
 * To build the executable:
 *
 *   1. Execute the SQL script, inhdemo1.sql in SQL*Plus to create:
 *   - 4 object types person_t, employee_t as a subtype of person_t,
 *              student_t as a subtype of person_t and parttimestudent_t as
 *              a subtype of student_t.
 *   - 1 typed table person_tab to hold &#34;person_t&#34; and its subtype objects
 *
 *   2. Run OTT: (The following command should appear on one line)
 *        ott intype=inhdemo1.typ hfile=inhdemo1.h outtype=out.typ
 *            code=c userid=scott/tiger
 *
 *   3. Precompile using Pro*C/C++:
 *        proc inhdemo1 intype=out.typ
 *   4. Compile/Link (This step is platform specific)
 *
 ****************************************************************************/

/* Include files */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sqlda.h&gt;

#include &lt;sqlca.h&gt;                                /* SQL Communications Area */
#include &lt;sql2oci.h&gt;         /* SQLLIB interoperability routines for OCI8 */
#include &#34;inhdemo1.h&#34;        /* OTT-generated header with C typedefs for the */
                                    /* database types &#34;person&#34; and &#34;address&#34; */
/* Macros */
#define ARRAY_SIZE 10
#define NAME_LENGTH 31
#define ADDR_LENGTH 101

/* Global variables */

  char *uid=&#34;scott/tiger&#34;;
  int i;
  int count;
  VARCHAR  dynstmt[100];

main()
{

  printf(&#34;\n*** STARTING OBJECT TYPE INHERITANCE DEMO ***\n&#34;);

  EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;ORACLE error--\n&#34;);

  EXEC SQL connect :uid;
  printf(&#34;Connected successfully.\n&#34;);
  
  exec sql select count(*) into :count from person_tab;
  printf(&#34;\nThere are %d entries in table person_tab.\n&#34;, count);

  do_fetch_all();                                  /* Fetch person_t objects */
  do_fetch_employee();                           /* Fetch employee_t objects */
  do_fetch_student();                        /* Fetch only student_t objects */
  do_fetch_parttimestudent();              /* Fetch parttimestuden_t objects */
  do_fetch_student_employee();     /* Fetch student_t and employee_t objects */

  printf(&#34;\nFetching only student_t objects with dynamic sql:\n&#34;);
  strcpy((char *)dynstmt.arr,
   &#34;SELECT value(p) from person_tab p where value(p) is of (only student_t)&#34;);
  do_dynamic_fetch();             /* Fetch student_t object with dynamic sql */

  printf(&#34;\nFetching student_t and its subtype objects with dynamic sql:\n&#34;);
  strcpy((char *)dynstmt.arr,
   &#34;SELECT treat(value(p) as student_t) from person_tab p where value(p) is
of(student_t)&#34;);
  do_dynamic_fetch();             /* Fetch student_t object with dynamic sql */

  printf(&#34;\n*** END OF OBJECT TYPE INHERITANCE DEMO ***\n&#34;);
  exit(EXIT_SUCCESS);

}

void printPerson(person)
  person_t *person;
{
  int writtenSSN=-1;
  text writtenName[NAME_LENGTH];
  text writtenAddr[ADDR_LENGTH];

  EXEC SQL OBJECT GET SSN, NAME, ADDRESS FROM :person INTO
     :writtenSSN, :writtenName, :writtenAddr;
  printf(&#34;\nSSN=%10d\nNAME=%s\nAddr=%s\n&#34;, writtenSSN, writtenName,
          writtenAddr);
}

void printEmployee(employee)
  employee_t *employee;
{
  int writtenID=-1;
  text writtenMgr[NAME_LENGTH];

  printPerson(employee);
  EXEC SQL OBJECT GET EMPID, MGR FROM :employee INTO :writtenID, :writtenMgr;
  printf(&#34;EMPID=%10d\nMGR=%s\n&#34;, writtenID, writtenMgr);
}

void printStudent(student)
  student_t *student;
{
  int writtendeptid=-1;
  text writtenMajor[NAME_LENGTH];

  printPerson(student);
  EXEC SQL OBJECT GET DEPTID, MAJOR FROM :student INTO :writtendeptid, :writtenMajor;
  printf(&#34;DEPTID=%10d\nMAJOR=%s\n&#34;, writtendeptid, writtenMajor);
}

void printPartTimeStudent(parttimes)
  parttimestudent_t *parttimes;
{
  int written_numhours=-1;

  printStudent(parttimes);
  EXEC SQL OBJECT GET NUMHOURS FROM :parttimes INTO :written_numhours;
  printf(&#34;NUMHOURS=%10d\n&#34;, written_numhours);
}

/* Declare error handling function. */
sql_error(msg)
    char *msg;
{
    char err_msg[128];
    size_t buf_len, msg_len;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    printf(&#34;\n%s\n&#34;, msg);
    buf_len = sizeof (err_msg);
    sqlglm(err_msg, &amp;buf_len, &amp;msg_len);
    printf(&#34;%.*s\n&#34;, msg_len, err_msg);

    EXEC SQL ROLLBACK RELEASE;
    exit(EXIT_FAILURE);
}

/*****************************************************************************
 * The following function shows how to select person_t objects
 ****************************************************************************/

do_fetch_all()
{
person_t *personArray[ARRAY_SIZE];
person_t_ind *personArray_ind[ARRAY_SIZE];

  printf(&#34;\nFetching person_t objects:\n&#34;);

  exec sql declare c1 cursor for
    select value(p) from person_tab p;

  exec sql allocate :personArray:personArray_ind;

  exec sql open c1;

  exec sql whenever not found goto :done;
  while(sqlca.sqlcode==0)
    {
      exec sql fetch c1 into :personArray:personArray_ind;
      if (sqlca.sqlcode == 1403) goto done;
      for (i=0; i &lt; ARRAY_SIZE; i++ )
        printPerson(personArray[i]);
    }

 done:
  for (i=0; i &lt; sqlca.sqlerrd[2] % ARRAY_SIZE; i++)
    printPerson(personArray[i]);

  printf(&#34;Total number of person_t objects fetched: %d.\n&#34;,
          sqlca.sqlerrd[2]);

  exec sql close c1;
  exec sql free :personArray:personArray_ind;
}

/*****************************************************************************
 * The following function shows how to select person_t subtype employee_t
 * objects
 ****************************************************************************/

do_fetch_employee()
{
employee_t *empArray[ARRAY_SIZE];
employee_t_ind *empArray_ind[ARRAY_SIZE];

  printf(&#34;\nFetching employee_t objects:\n&#34;);

  exec sql allocate :empArray:empArray_ind;

  exec sql declare c2 cursor for
    select value(p) from person_tab p
      where value(p) is of (employee_t);

  exec sql open c2;

  exec sql whenever not found goto :done_emp;
  while(sqlca.sqlcode==0)
    {
      exec sql fetch c2 into :empArray:empArray_ind;
      for (i=0; i &lt; ARRAY_SIZE; i++ )
        printEmployee(empArray[i]);
    }

 done_emp:
   for (i=0; i &lt; sqlca.sqlerrd[2] % ARRAY_SIZE; i++)
     printEmployee(empArray[i]);

   printf(&#34;Total number of employee_t objects fetched: %d.\n&#34;,
          sqlca.sqlerrd[2]);

  exec sql close c2;
  exec sql free :empArray:empArray_ind;
}

/*****************************************************************************
 * The following function shows how to select person_t subtype student_t 
 * objects
 ****************************************************************************/

do_fetch_student()
{
student_t *studentArray[ARRAY_SIZE];
student_t_ind *studentArray_ind[ARRAY_SIZE];

  printf(&#34;\nFetching student_t objects:\n&#34;);

  exec sql declare c3 cursor for
    select value(p) from person_tab p
      where value(p) is of (student_t);

  exec sql allocate :studentArray:studentArray_ind;

  exec sql open c3;

  exec sql whenever not found goto :done_student;
  for (;;)
    {
      exec sql fetch c3 into :studentArray:studentArray_ind;
      for (i=0; i &lt; ARRAY_SIZE; i++ )
        printStudent(studentArray[i]);
    }

 done_student:
  for (i=0; i &lt; sqlca.sqlerrd[2] % ARRAY_SIZE; i++)
    printStudent(studentArray[i]);

  printf(&#34;Total number of student_t objects fetched: %d.\n&#34;,
          sqlca.sqlerrd[2]);

  exec sql close c3;
  exec sql free :studentArray:studentArray_ind;
}

/*****************************************************************************
 * The following function shows how to select student_t subtype
 * parttimestudent objects
 ****************************************************************************/

do_fetch_parttimestudent()
{
parttimestudent_t *parttimestudentArrayArray[ARRAY_SIZE];
parttimestudent_t_ind *parttimestudentArrayArray_ind[ARRAY_SIZE];

  printf(&#34;\nFetching parttimestudent_t objects:\n&#34;);

  exec sql declare c4 cursor for
    select value(p) from person_tab p
      where value(p) is of (parttimestudent_t);

  exec sql allocate :parttimestudentArrayArray:parttimestudentArrayArray_ind;

  exec sql open c4;

  exec sql whenever not found goto :done_parttimestudent;
  while(sqlca.sqlcode==0)
    {
      exec sql fetch c4 into :parttimestudentArrayArray:parttimestudentArrayArray_ind;
      for (i=0; i &lt; ARRAY_SIZE; i++ )
        printPartTimeStudent(parttimestudentArrayArray[i]);
    }

 done_parttimestudent:
  for (i=0; i &lt; sqlca.sqlerrd[2] % ARRAY_SIZE; i++)
    printPartTimeStudent(parttimestudentArrayArray[i]);

  printf(&#34;Total number of parttimestudent_t objects fetched: %d.\n&#34;,
          sqlca.sqlerrd[2]);

  exec sql close c4;
  exec sql free :parttimestudentArrayArray:parttimestudentArrayArray_ind;
}

/*****************************************************************************
 * The following function shows how to select person_t subtypes student_t 
 * and employee_t objects
 ****************************************************************************/

do_fetch_student_employee()
{
person_t *personArray[ARRAY_SIZE];
person_t_ind *personArray_ind[ARRAY_SIZE];

  printf(&#34;\nFetching only student_t and employee_t objects:\n&#34;);

  exec sql declare c5 cursor for
    select value(p) from person_tab p
      where value(p) is of (only student_t, employee_t);

  exec sql allocate :personArray:personArray_ind;

  exec sql open c5;

  exec sql whenever not found goto :done_student_employee;
  while(sqlca.sqlcode==0)
    {
      exec sql fetch c5 into :personArray:personArray_ind;
      for (i=0; i &lt; ARRAY_SIZE; i++ )
        printPerson(personArray[i]);
    }

 done_student_employee:
  for (i=0; i &lt; sqlca.sqlerrd[2] % ARRAY_SIZE; i++)
        printPerson(personArray[i]);

  printf(&#34;Total number of stuent_t and employee_t objects fetched: %d.\n&#34;,
sqlca.sqlerrd[2]);

  exec sql close c5;
  exec sql free :personArray:personArray_ind;
}

/*****************************************************************************
 * The following function shows how to select person_t subtype student_t 
 * objects using dynamic sql.
 ****************************************************************************/

do_dynamic_fetch()
{
student_t *student;
student_t_ind  *student_ind;

  exec sql allocate :student:student_ind;

  dynstmt.len = (unsigned short)strlen((char *)dynstmt.arr);
  EXEC SQL PREPARE S FROM :dynstmt;
  EXEC SQL DECLARE C CURSOR FOR S;
  EXEC SQL OPEN C;

  exec sql whenever not found do break;
  for (;;)
  {
     EXEC SQL FETCH C INTO :student:student_ind;
     printStudent(student);
  }

  printf(&#34;\nQuery returned %d row%s.\n&#34;, sqlca.sqlerrd[2],
         (sqlca.sqlerrd[2] == 1) ? &#34;&#34; : &#34;s&#34;);

  EXEC SQL CLOSE C;
  exec sql free :student:student_ind;
}
</pre></div>
<!-- class="sect1" -->
<a id="i457199"></a>
<div id="LNPCC4361" class="sect1">
<h2 class="sect1"><a id="sthref2102"></a>Example Code for Navigational Access<a id="sthref2103"></a><a id="sthref2104"></a></h2>
<p>The example object code creates three object types; <span class="italic">budoka</span> is a martial arts expert:</p>
<ul>
<li>
<p>Customer</p>
</li>
<li>
<p>Budoka</p>
</li>
<li>
<p>Location</p>
</li>
</ul>
<p>and two tables:</p>
<ul>
<li>
<p><code>person_tab</code></p>
</li>
<li>
<p><code>customer_tab</code></p>
</li>
</ul>
<p>The SQL file, <code>navdemo1.sql</code>, which creates the types and tables, and then inserts values into the tables, is:</p>
<pre>connect scott/tiger

drop table customer_tab;
drop type customer;
drop table person_tab;
drop type budoka;
drop type location;

create type location as object (
        num     number,
        street  varchar2(60),
        city    varchar2(30),
        state   char(2),
        zip     char(10)
);
/

create type budoka as object (
        lastname        varchar2(20),
        firstname       varchar(20),
        birthdate       date,
        age             int,
        addr            location
);
/

create table person_tab of budoka;

create type customer as object (
        account_number varchar(20),
        aperson ref budoka
);
/

create table customer_tab of customer;

insert into person_tab values (
        budoka(&#39;Seagal&#39;, &#39;Steven&#39;, &#39;14-FEB-1963&#39;, 34,
                location(1825, &#39;Aikido Way&#39;, &#39;Los Angeles&#39;, &#39;CA&#39;, 45300)));
insert into person_tab values (
        budoka(&#39;Norris&#39;, &#39;Chuck&#39;, &#39;25-DEC-1952&#39;, 45,
                location(291, &#39;Grant Avenue&#39;, &#39;Hollywood&#39;, &#39;CA&#39;, 21003)));
insert into person_tab values (
        budoka(&#39;Wallace&#39;, &#39;Bill&#39;, &#39;29-FEB-1944&#39;, 53,
                location(874, &#39;Richmond Street&#39;, &#39;New York&#39;, &#39;NY&#39;, 45100)));
insert into person_tab values (
        budoka(&#39;Van Damme&#39;, &#39;Jean Claude&#39;, &#39;12-DEC-1964&#39;, 32,
                location(12, &#39;Shugyo Blvd&#39;, &#39;Los Angeles&#39;, &#39;CA&#39;, 95100)));

insert into customer_tab
        select &#39;AB123&#39;, ref(p)
          from person_tab p where p.lastname = &#39;Seagal&#39;;
insert into customer_tab
        select &#39;DD492&#39;, ref(p)
          from person_tab p where p.lastname = &#39;Norris&#39;;
insert into customer_tab 
        select &#39;SM493&#39;, ref(p)
          from person_tab p where p.lastname = &#39;Wallace&#39;;
insert into customer_tab
        select &#39;AC493&#39;, ref(p)
          from person_tab p where p.lastname = &#39;Van Damme&#39;;
        
commit work;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_19ott.htm#i427005">&#34;The OTT Command Line&#34;</a> for a description of the format for the intype file</div>
<p>Here is a listing of the intype file for our example, <code>navdemo1.typ</code>:</p>
<pre>case=lower
type location
type budoka
type customer
</pre>
<p>The header file produced by the OTT, <code>navdemo1.h</code>, is included in the precompiler code with the <code>#include</code> preprocessor directive.</p>
<p>Read the comments throughout the precompiler code. The program adds one new budoka object (for Jackie Chan), then prints out all the customers in the <span class="italic">customer_tab</span> table.</p>
<p>Here is a listing of the precompiler file, <code>navdemo1.pc</code>:</p>
<pre>/*************************************************************************
 *
 * This is a simple Pro*C/C++ program designed to illustrate the
 * Navigational access to objects in the object cache.
 *
 * To build the executable:
 *
 *   1. Execute the SQL script, navdemo1.sql in SQL*Plus
 *   2. Run OTT: (The following command should appear on one line)
 *        ott intype=navdemo1.typ hfile=navdemo1.h outtype=navdemo1_o.typ
 *            code=c user=scott/tiger
 *   3. Precompile using Pro*C/C++:
 *        proc navdemo1 intype=navdemo1_o.typ
 *   4. Compile/Link (This step is platform specific)
 *
 *************************************************************************/

#include &#34;navdemo1.h&#34;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sqlca.h&gt;

void whoops(errcode, errtext, errtextlen)
  int   errcode;
  char *errtext;
  int   errtextlen;
{
  printf(&#34;ERROR! sqlcode=%d: text = %.*s&#34;, errcode, errtextlen, errtext);
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK RELEASE;
  exit(EXIT_FAILURE);
}

void main()
{
  char *uid = &#34;scott/tiger&#34;;

       /* The following types are generated by OTT and defined in navdemo1.h */
  customer *cust_p;                            /* Pointer to customer object */
  customer_ind *cust_ind;        /* Pointer to indicator struct for customer */
  customer_ref *cust_ref;            /* Pointer to customer object reference */
  budoka *budo_p;                                /* Pointer to budoka object */
  budoka_ref *budo_ref;                /* Pointer to budoka object reference */
  budoka_ind *budo_ind;            /* Pointer to indicator struct for budoka */

    /* These are data declarations to be used to insert/retrieve object data */
  VARCHAR acct[21];
  struct { char lname[21], fname[21]; int age; } pers;
  struct { int num; char street[61], city[31], state[3], zip[11]; } addr;

  EXEC SQL WHENEVER SQLERROR DO whoops(
    sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);

  EXEC SQL CONNECT :uid;

  EXEC SQL ALLOCATE :budo_ref;

  /* Create a new budoka object with an associated indicator
   * variable returning a REF to that budoka as well.
   */
  EXEC SQL OBJECT CREATE :budo_p:budo_ind TABLE PERSON_TAB
                  RETURNING REF INTO :budo_ref;

  /* Create a new customer object with an associated indicator */
  EXEC SQL OBJECT CREATE :cust_p:cust_ind TABLE CUSTOMER_TAB;

  /* Set all budoka indicators to NOT NULL.  We
   * will be setting all attributes of the budoka.
   */
  budo_ind-&gt;_atomic = budo_ind-&gt;lastname = budo_ind-&gt;firstname = 
    budo_ind-&gt;age = OCI_IND_NOTNULL;

  /* We will also set all address attributes of the budoka */
  budo_ind-&gt;addr._atomic = budo_ind-&gt;addr.num = budo_ind-&gt;addr.street = 
    budo_ind-&gt;addr.city = budo_ind-&gt;addr.state = budo_ind-&gt;addr.zip = 
      OCI_IND_NOTNULL;

  /* All customer attributes will likewise be set */
  cust_ind-&gt;_atomic = cust_ind-&gt;account_number = cust_ind-&gt;aperson =
    OCI_IND_NOTNULL;

  /* Set the default CHAR semantics to type 5 (STRING) */
  EXEC ORACLE OPTION (char_map=string);

  strcpy((char *)pers.lname, (char *)&#34;Chan&#34;);
  strcpy((char *)pers.fname, (char *)&#34;Jackie&#34;);
  pers.age = 38;

  /* Convert native C types to OTS types */
  EXEC SQL OBJECT SET lastname, firstname, age OF :budo_p TO :pers;

  addr.num = 1893;
  strcpy((char *)addr.street, (char *)&#34;Rumble Street&#34;);
  strcpy((char *)addr.city, (char *)&#34;Bronx&#34;);
  strcpy((char *)addr.state, (char *)&#34;NY&#34;);
  strcpy((char *)addr.zip, (char *)&#34;92510&#34;);
  
  /* Convert native C types to OTS types */
  EXEC SQL OBJECT SET :budo_p-&gt;addr TO :addr;

  acct.len = strlen(strcpy((char *)acct.arr, (char *)&#34;FS926&#34;));

  /* Convert native C types to OTS types - Note also the REF type */
  EXEC SQL OBJECT SET account_number, aperson OF :cust_p TO :acct, :budo_ref;

  /* Mark as updated both the new customer and the budoka */
  EXEC SQL OBJECT UPDATE :cust_p;
  EXEC SQL OBJECT UPDATE :budo_p;

  /* Now flush the changes to the server, effectively
   * inserting the data into the respective tables.
   */
  EXEC SQL OBJECT FLUSH :budo_p;
  EXEC SQL OBJECT FLUSH :cust_p;

  /* Associative access to the REFs from CUSTOMER_TAB */
  EXEC SQL DECLARE ref_cur CURSOR FOR 
    SELECT REF(c) FROM customer_tab c;

  EXEC SQL OPEN ref_cur;

  printf(&#34;\n&#34;);

  /* Allocate a REF to a customer for use in the following */
  EXEC SQL ALLOCATE :cust_ref;

  EXEC SQL WHENEVER NOT FOUND DO break;
  while (1)
  {
    EXEC SQL FETCH ref_cur INTO :cust_ref;
    
    /* Pin the customer REF, returning a pointer to a customer object */
    EXEC SQL OBJECT DEREF :cust_ref INTO :cust_p:cust_ind;

    /* Convert the OTS types to native C types */
    EXEC SQL OBJECT GET account_number FROM :cust_p INTO :acct;
    printf(&#34;Customer Account is %.*s\n&#34;, acct.len, (char *)acct.arr);
    
    /* Pin the budoka REF, returning a pointer to a budoka object */
    EXEC SQL OBJECT DEREF :cust_p-&gt;aperson INTO :budo_p:budo_ind;

    /* Convert the OTS types to native C types */
    EXEC SQL OBJECT GET lastname, firstname, age FROM :budo_p INTO :pers;
    printf(&#34;Last Name: %s\nFirst Name: %s\nAge: %d\n&#34;,
           pers.lname, pers.fname, pers.age);

    /* Do the same for the address attributes as well */
    EXEC SQL OBJECT GET :budo_p-&gt;addr INTO :addr;
    printf(&#34;Address:\n&#34;);
    printf(&#34;  Street: %d %s\n  City: %s\n  State: %s\n  Zip: %s\n\n&#34;,
           addr.num, addr.street, addr.city, addr.state, addr.zip);

    /* Unpin the customer object and budoka objects */
    EXEC SQL OBJECT RELEASE :cust_p;
    EXEC SQL OBJECT RELEASE :budo_p;
  }

  EXEC SQL CLOSE ref_cur;
  
  EXEC SQL WHENEVER NOT FOUND DO whoops(
    sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);

  /* Associatively select the newly created customer object */
  EXEC SQL SELECT VALUE(c) INTO :cust_p FROM customer_tab c
            WHERE c.account_number = &#39;FS926&#39;;

  /* Mark as deleted the new customer object */
  EXEC SQL OBJECT DELETE :cust_p;

  /* Flush the changes, effectively deleting the customer object */
  EXEC SQL OBJECT FLUSH :cust_p;

  /* Associatively select a REF to the newly created budoka object */
  EXEC SQL SELECT REF(p) INTO :budo_ref FROM person_tab p
            WHERE p.lastname = &#39;Chan&#39;;

  /* Pin the budoka REF, returning a pointer to the budoka object */
  EXEC SQL OBJECT DEREF :budo_ref INTO :budo_p;

  /* Mark the new budoka object as deleted in the object cache */
  EXEC SQL OBJECT DELETE :budo_p;

  /* Flush the changes, effectively deleting the budoka object */
  EXEC SQL OBJECT FLUSH :budo_p;

  /* Finally, free all object cache memory and log off */
  EXEC SQL OBJECT CACHE FREE ALL;

  EXEC SQL COMMIT WORK RELEASE;

  exit(EXIT_SUCCESS);
}
</pre>
<p>When the program is executed, the result is:</p>
<pre>Customer Account is AB123
Last Name: Seagal
First Name: Steven
Birthdate: 02-14-1963
Age: 34
Address:
  Street: 1825 Aikido Way
  City: Los Angeles
  State: CA
  Zip: 45300     

Customer Account is DD492
Last Name: Norris
First Name: Chuck
Birthdate: 12-25-1952
Age: 45
Address:
  Street: 291 Grant Avenue
  City: Hollywood
  State: CA
  Zip: 21003     

Customer Account is SM493
Last Name: Wallace
First Name: Bill
Birthdate: 02-29-1944
Age: 53
Address:
  Street: 874 Richmond Street
  City: New York
  State: NY
  Zip: 45100     

Customer Account is AC493
Last Name: Van Damme
First Name: Jean Claude
Birthdate: 12-12-1965
Age: 32
Address:
  Street: 12 Shugyo Blvd
  City: Los Angeles
  State: CA
  Zip: 95100     

Customer Account is FS926
Last Name: Chan
First Name: Jackie
Birthdate: 10-10-1959
Age: 38
Address:
  Street: 1893 Rumble Street
  City: Bronx
  State: NY
  Zip: 92510
</pre></div>
<!-- class="sect1" -->
<a id="i449483"></a>
<div id="LNPCC4362" class="sect1">
<h2 class="sect1"><a id="sthref2105"></a>Using C Structures<a id="sthref2106"></a><a id="sthref2107"></a></h2>
<p>Before Oracle8, Pro*C/C++ allowed you to specify a C structure as a single host variable in a SQL SELECT statement. In such cases, each member of the structure is taken to correspond to a single database column in a relational table; that is, each member represents a single item in the select list returned by the query.</p>
<p>In Oracle8<span class="italic">i</span> and later versions, an object type in the database is a single entity and can be selected as a single item. This introduces an ambiguity with the Oracle7 notation: is the structure for a group of scalar variables, or for an object?</p>
<p>Pro*C/C++ uses the following rule to resolve the ambiguity:</p>
<p>A host variable that is a C structure is considered to represent an object type only if its C declaration was generated using OTT, and therefore its type description appears in a typefile specified in an INTYPE option to Pro*C/C++. All other host structures are assumed to be uses of the Oracle7 syntax, even if a datatype of the same name resides in the database.</p>
<p>Thus, if you use new object types that have the same names as existing structure host variable types, be aware that Pro*C/C++ uses the object type definitions in the INTYPE file. This can lead to compilation errors. To correct this, you might rename the existing host variable types, or use OTT to choose a new name for the object type.</p>
<p>The preceding rule extends <span class="italic">transitively</span> to user-defined datatypes that are aliased to OTT-generated datatypes. To illustrate, let <span class="italic">emptype</span> be a structure generated by OTT in a header file <code>dbtypes.h</code> and you have the following statements in your Pro*C/C++ program:</p>
<pre>#include &lt;dbtypes.h&gt;
typedef emptype myemp;
myemp *employee;
</pre>
<p>The typename <span class="italic">myemp</span> for the variable <span class="italic">employee</span> is aliased to the OTT-generated typename <span class="italic">emptype</span> for some object type defined in the database. Therefore, Pro*C/C++ considers the variable <span class="italic">employee</span> to represent an object type.</p>
<p>The preceding rules do not imply that a C structure having or aliased to an OTT-generated type cannot be used for fetches of non-object type data. The only implication is that Pro*C/C++ will not automatically expand such a structure -- the user is free to employ the &#34;longhand syntax&#34; and use individual fields of the structure for selecting or updating single database columns.</p>
</div>
<!-- class="sect1" -->
<a id="i444272"></a>
<div id="LNPCC4363" class="sect1">
<h2 class="sect1"><a id="sthref2108"></a><a id="sthref2109"></a>Using REFs<a id="sthref2110"></a><a id="sthref2111"></a></h2>
<p>The REF type denotes a reference to an object, instead of the object itself. REF types may occur in relational columns and also in attributes of an object type.</p>
<div id="LNPCC4364" class="sect2"><a id="sthref2112"></a>
<h3 class="sect2"><a id="sthref2113"></a>Generating a C Structure for a REF<a id="sthref2114"></a><a id="sthref2115"></a></h3>
<p>The C representation for a REF to an object type is generated by OTT during type translation. For example, a reference to a user-defined PERSON type in the database may be represented in C as the type &#34;Person_ref&#34;. The exact type name is determined by the OTT options in effect during type translation. The OTT-generated typefile must be specified in the INTYPE option to Pro*C/C++ and the OTT-generated header #included in the Pro*C/C++ program. This scheme ensures that the proper type-checking for the REF can be performed by Pro*C/C++ during precompilation.</p>
<p>A REF type does not require a special indicator structure to be generated by OTT; a scalar signed 2-byte indicator is used instead.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4365" class="sect2"><a id="sthref2116"></a>
<h3 class="sect2"><a id="sthref2117"></a>Declaring REFs<a id="sthref2118"></a><a id="sthref2119"></a></h3>
<p>A host variable representing a REF in Pro*C/C++ must be declared as a pointer to the appropriate OTT-generated type.</p>
<p>Unlike object types, the indicator variable for a REF is declared as the signed 2-byte scalar type <code>OCIInd</code>. As always, the indicator variable is optional, but it is a good programming practice to use one for each host variable declared.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4366" class="sect2"><a id="sthref2120"></a>
<h3 class="sect2"><a id="sthref2121"></a>Using REFs in Embedded SQL<a id="sthref2122"></a><a id="sthref2123"></a><a id="sthref2124"></a></h3>
<p>REFs reside in the object cache. However, indicators for REFs are scalars and cannot be allocated in the cache. They generally reside in the user stack.</p>
<p>Prior to using the host structure for a REF in embedded SQL, allocate space for it in the object cache by using the EXEC SQL ALLOCATE command. After use, free using the EXEC SQL FREE or EXEC SQL CACHE FREE ALL commands.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i447871">&#34;Navigational Interface&#34;</a> for a description of these statements</div>
<p>Memory for scalar indicator variables is not allocated in the object cache, and hence indicators are not permitted to appear in the ALLOCATE and FREE commands for REF types. Scalar indicators declared as <code>OCIInd</code> reside on the program stack. At runtime, the ALLOCATE statement causes space to be allocated in the object cache for the specified host variable. For the navigational interface, use EXEC SQL GET and EXEC SQL SET, not C assignments.</p>
<p>Pro*C/C++ supports REF host variables in associative SQL statements and in embedded PL/SQL blocks.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i444281"></a>
<div id="LNPCC4367" class="sect1">
<h2 class="sect1">Using OCIDate, OCIString, OCINumber, and OCIRaw<a id="sthref2125"></a><a id="sthref2126"></a><a id="sthref2127"></a><a id="sthref2128"></a><a id="sthref2129"></a><a id="sthref2130"></a><a id="sthref2131"></a><a id="sthref2132"></a></h2>
<p>These OCI types are new C representations for a date, a varying-length zero-terminated string, an Oracle number, and varying-length binary data respectively. In certain cases, these types provide more functionality than earlier C representations of these quantities. For example, the OCIDate type provides client-side routines to perform DATE arithmetic, which in earlier releases required SQL statements at the server.</p>
<div id="LNPCC4368" class="sect2"><a id="sthref2133"></a>
<h3 class="sect2">Declaring OCIDate, OCIString, OCINumber, OCIRaw<a id="sthref2134"></a><a id="sthref2135"></a><a id="sthref2136"></a><a id="sthref2137"></a><a id="sthref2138"></a></h3>
<p>The OCI* types appear as object type attributes in OTT-generated structures, and you use them as part of object types in Pro*C/C++ programs. Other than their use in object types, Oracle recommends that the beginner-level C and Pro*C/C++ user avoid declaring individual host variables of these types. An experienced Pro*C/C++ user may wish to declare C host variables of these types to take advantage of the advanced functionality these types provide. The host variables must be declared as pointers to these types, for example, <code>OCIString *s</code>. The associated (optional) indicators are scalar signed 2-byte quantities, declared, for example, <code>OCIInd s_ind</code>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4369" class="sect2"><a id="sthref2139"></a>
<h3 class="sect2">Use of the OCI Types in Embedded SQL<a id="sthref2140"></a><a id="sthref2141"></a></h3>
<p>Space for host variables of these types may be allocated in the object cache using EXEC SQL ALLOCATE. Scalar indicator variables are not permitted to appear in the ALLOCATE and FREE commands for these types. You allocate such indicators statically on the stack, or dynamically on the heap. De-allocation of space can be done using the statement EXEC SQL FREE, EXEC SQL CACHE FREE ALL, or automatically at the end of the session.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i447871">&#34;Navigational Interface&#34;</a> for a description of these statements</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC4370" class="sect2"><a id="sthref2142"></a>
<h3 class="sect2">Manipulating the OCI Types<a id="sthref2143"></a></h3>
<p>Except for <code>OCIDate</code>, which is a structure type with individual fields for various date components: year, month, day, hour and so on., the other OCI types are encapsulated, and are meant to be opaque to an external user. In contrast to the way existing C types like VARCHAR are currently handled in Pro*C/C++, you include the OCI header file <code>oci.h</code> and employ its functions to perform DATE arithmetic, and to convert these types to and from native C types such as <span class="italic">int</span>, <span class="italic">char</span>, and so on.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i444286"></a>
<div id="LNPCC4371" class="sect1">
<h2 class="sect1">Summarizing the New Database Types in Pro*C/C++<a id="sthref2144"></a><a id="sthref2145"></a></h2>
<p><a href="#BAJDEAAI">Table 17-2</a> lists the new database types for Object support:</p>
<div id="LNPCC4372" class="tblformal">
<p class="titleintable"><a id="sthref2146"></a><a id="BAJDEAAI"></a>Table 17-2 Using New Database Types in Pro*C/C++</p>
<table class="cellalignment831" title="Using New Database Types in Pro*C/C++" summary="Using New Database Types in Pro*C/C++" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t19"><span class="bold">Operations Database Type</span></th>
<th class="cellalignment832" id="r1c2-t19"><span class="bold">DECLARE</span></th>
<th class="cellalignment832" id="r1c3-t19"><span class="bold">ALLOCATE</span></th>
<th class="cellalignment832" id="r1c4-t19"><span class="bold">FREE</span></th>
<th class="cellalignment832" id="r1c5-t19"><span class="bold">MANIPULATE</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t19" headers="r1c1-t19">
<p>Object type</p>
</td>
<td class="cellalignment833" headers="r2c1-t19 r1c2-t19">
<p><span class="bold">Host</span>: Pointer to OTT-generated C struct</p>
<p><span class="bold">Indicator</span>: Pointer to OTT-generated indicator struct</p>
</td>
<td class="cellalignment833" headers="r2c1-t19 r1c3-t19">
<p>Associative interface:</p>
<p>EXEC SQL ALLOCATE</p>
<p>Navigational interface:</p>
<p>EXEC SQL OBJECT CREATE ...</p>
<p>EXEC SQL OBJECT DEREF</p>
<p>allocates memory for host var and indicator in object cache</p>
</td>
<td class="cellalignment833" headers="r2c1-t19 r1c4-t19">
<p>Freed by EXEC SQL FREE, or EXEC SQL CACHE FREE ALL, or automatically at end of session.</p>
</td>
<td class="cellalignment833" headers="r2c1-t19 r1c5-t19">
<p>Dereference the C pointer to get each attribute. Manipulation method depends on type of attribute (see later).</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t19" headers="r1c1-t19">
<p>COLLECTION Object type</p>
<p>(NESTED TABLE AND VARYING ARRAY)</p>
</td>
<td class="cellalignment833" headers="r3c1-t19 r1c2-t19">
<p><span class="bold">Host</span>: Pointer to OTT-generated C struct</p>
<p><span class="bold">Indicator</span>: OCIInd</p>
</td>
<td class="cellalignment833" headers="r3c1-t19 r1c3-t19">
<p>EXEC SQL ALLOCATE</p>
<p>allocates memory for host var in object cache.</p>
</td>
<td class="cellalignment833" headers="r3c1-t19 r1c4-t19">
<p>Freed by EXEC SQL FREE, or EXEC SQL CACHE FREE ALL, or automatically at end of session.</p>
</td>
<td class="cellalignment833" headers="r3c1-t19 r1c5-t19">
<p>Use OCIColl* functions (defined in oci.h) to get/set elements. See also <a href="pc_18col.htm#g1023189">Chapter 18, &#34;Collections&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t19" headers="r1c1-t19">
<p>REF</p>
</td>
<td class="cellalignment833" headers="r4c1-t19 r1c2-t19">
<p><span class="bold">Host:</span> Pointer to OTT-generated C struct</p>
<p><span class="bold">Indicator:</span> OCIInd</p>
</td>
<td class="cellalignment833" headers="r4c1-t19 r1c3-t19">
<p>EXEC SQL ALLOCATE</p>
<p>allocates memory for host var in object cache.</p>
</td>
<td class="cellalignment833" headers="r4c1-t19 r1c4-t19">
<p>Freed by EXEC SQL FREE, or EXEC SQL CACHE FREE ALL, or automatically at end of session.</p>
</td>
<td class="cellalignment833" headers="r4c1-t19 r1c5-t19">
<p>Use EXEC SQL OBJECT DEREF</p>
<p>Use EXEC SQL OBJECT SET/GET for navigational interface.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t19" headers="r1c1-t19">
<p>LOB</p>
</td>
<td class="cellalignment833" headers="r5c1-t19 r1c2-t19">
<p><span class="bold">Host:</span></p>
<p>OCIBlobLocator *, OCIClobLocator *, or OCIBfileLocator *.</p>
<p><span class="bold">Indicator:</span> OCIInd</p>
</td>
<td class="cellalignment833" headers="r5c1-t19 r1c3-t19">
<p>EXEC SQL ALLOCATE</p>
<p>allocates memory for the host var in user heap using</p>
<p>malloc().</p>
</td>
<td class="cellalignment833" headers="r5c1-t19 r1c4-t19">
<p>Freed by EXEC SQL FREE, or automatically when all Pro*C/C++ connections are closed. EXEC SQL CACHE FREE ALL frees only LOB attributes of objects.</p>
</td>
<td class="cellalignment833" headers="r5c1-t19 r1c5-t19">
<p>Or use embedded PL/SQL stored procedures in the dbms_lob package, or</p>
<p>Use OCILob* functions defined in oci.h.</p>
<p>See also <a href="pc_16lob.htm#g1029071">&#34;LOBs&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t19" headers="r1c1-t19">
<p><span class="bold">Note:</span></p>
<p>Host arrays of these types may be declared and used in bulk fetch/insert SQL operations in Pro*C/C++.</p>
</td>
<td class="cellalignment833" headers="r6c1-t19 r1c2-t19">
<p>-</p>
</td>
<td class="cellalignment833" headers="r6c1-t19 r1c3-t19">
<p>-</p>
</td>
<td class="cellalignment833" headers="r6c1-t19 r1c4-t19">
<p>-</p>
</td>
<td class="cellalignment833" headers="r6c1-t19 r1c5-t19">
<p>-</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><a href="#BAJDBAEC">Table 17-3</a> shows how to use the new C datatypes in Pro*C/C++:</p>
<div id="LNPCC4373" class="tblformal">
<p class="titleintable"><a id="sthref2147"></a><a id="BAJDBAEC"></a>Table 17-3 Using New C Datatypes in Pro*C/C++</p>
<table class="cellalignment831" title="Using New C Datatypes in Pro*C/C++" summary="Using New C Datatypes in Pro*C/C++" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t20">OperationsC Type</th>
<th class="cellalignment832" id="r1c2-t20">DECLARE</th>
<th class="cellalignment832" id="r1c3-t20">ALLOCATE</th>
<th class="cellalignment832" id="r1c4-t20">FREE</th>
<th class="cellalignment832" id="r1c5-t20">MANIPULATE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t20" headers="r1c1-t20">
<p>OCIDate</p>
</td>
<td class="cellalignment833" headers="r2c1-t20 r1c2-t20">
<p><span class="bold">Host:</span> OCIDate *</p>
<p><span class="bold">Indicator:</span> OCIInd</p>
</td>
<td class="cellalignment833" headers="r2c1-t20 r1c3-t20">
<p>EXEC SQL ALLOCATE</p>
<p>allocates memory for host var in object cache</p>
</td>
<td class="cellalignment833" headers="r2c1-t20 r1c4-t20">
<p>Freed by EXEC SQL FREE, or EXEC SQL CACHE FREE ALL, or automatically at end of session.</p>
</td>
<td class="cellalignment833" headers="r2c1-t20 r1c5-t20">
<p>(1) Use OCIDate* functions defined in oci.h.</p>
<p>(2) Use EXEC SQL OBJECT GET/SET, or</p>
<p>(3) Use OCINumber* functions defined in oci.h.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t20" headers="r1c1-t20">
<p>OCINumber</p>
</td>
<td class="cellalignment833" headers="r3c1-t20 r1c2-t20">
<p><span class="bold">Host:</span> OCINumber *</p>
<p><span class="bold">Indicator:</span> OCIInd</p>
</td>
<td class="cellalignment833" headers="r3c1-t20 r1c3-t20">
<p>EXEC SQL ALLOCATE</p>
<p>allocates memory for host var in object cache</p>
</td>
<td class="cellalignment833" headers="r3c1-t20 r1c4-t20">
<p>Freed by EXEC SQL FREE, or EXEC SQL CACHE FREE ALL, or automatically at end of session.</p>
</td>
<td class="cellalignment833" headers="r3c1-t20 r1c5-t20">
<p>(1) Use EXEC SQL OBJECT GET/SET, or</p>
<p>(2) Use OCINumber* functions defined in oci.h.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t20" headers="r1c1-t20">
<p>OCIRaw</p>
</td>
<td class="cellalignment833" headers="r4c1-t20 r1c2-t20">
<p><span class="bold">Host:</span> OCIRaw *</p>
<p><span class="bold">Indicator:</span> OCIInd</p>
</td>
<td class="cellalignment833" headers="r4c1-t20 r1c3-t20">
<p>EXEC SQL ALLOCATE</p>
<p>allocates memory for host var in object cache</p>
</td>
<td class="cellalignment833" headers="r4c1-t20 r1c4-t20">
<p>Freed by EXEC SQL FREE, or EXEC SQL CACHE FREE ALL, or automatically at end of session.</p>
</td>
<td class="cellalignment833" headers="r4c1-t20 r1c5-t20">
<p>Use OCIRaw* functions defined in oci.h.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t20" headers="r1c1-t20">
<p>OCIString</p>
</td>
<td class="cellalignment833" headers="r5c1-t20 r1c2-t20">
<p><span class="bold">Host:</span> OCIString *</p>
<p><span class="bold">Indicator:</span> OCIInd</p>
</td>
<td class="cellalignment833" headers="r5c1-t20 r1c3-t20">
<p>EXEC SQL ALLOCATE</p>
<p>allocates memory for host var in object cache</p>
</td>
<td class="cellalignment833" headers="r5c1-t20 r1c4-t20">
<p>EXEC SQL FREE, or EXEC SQL CACHE FREE ALL, or automatically at end of session.</p>
</td>
<td class="cellalignment833" headers="r5c1-t20 r1c5-t20">
<p>(1) Use EXEC SQL OBJECT GET/SET, or</p>
<p>(2) use OCIString* functions defined in oci.h.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t20" headers="r1c1-t20">
<p><span class="bold">Note:</span></p>
<p>Host arrays of these types may not be used in bulk fetch/insert SQL operations in Pro*C/C++.</p>
</td>
<td class="cellalignment833" headers="r6c1-t20 r1c2-t20">
<p>-</p>
</td>
<td class="cellalignment833" headers="r6c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment833" headers="r6c1-t20 r1c4-t20">
<p>-</p>
</td>
<td class="cellalignment833" headers="r6c1-t20 r1c5-t20">
<p>-</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The new datatypes for Oracle8 were Ref, BLOB, NCLOB, CLOB, and BFILE. These types may be used in objects or in relational columns. In either case, they are mapped to host variables according to the C bindings.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i444286">&#34;Summarizing the New Database Types in Pro*C/C++&#34;</a> for a description of the C bindings</div>
</div>
<!-- class="sect1" -->
<a id="i436920"></a>
<div id="LNPCC4374" class="sect1">
<h2 class="sect1">Restrictions on Using Oracle Datatypes in<a id="sthref2148"></a> Dynamic SQL<a id="sthref2149"></a><a id="sthref2150"></a></h2>
<p>Pro*C/C++ currently supports these different types of dynamic SQL methods: methods 1, 2, 3, and 4 (ANSI and Oracle).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_13dyn.htm#g19220">Chapter 13, &#34;Oracle Dynamic SQL&#34;</a></p>
</li>
<li>
<p><a href="pc_14ady.htm#i1011699">Chapter 14, &#34; ANSI Dynamic SQL&#34;</a></p>
</li>
<li>
<p><a href="pc_15ody.htm#i22863">Chapter 15, &#34;Oracle Dynamic SQL: Method 4&#34;</a></p>
</li>
</ul>
</div>
<p>The dynamic methods 1, 2, and 3 will handle all Pro*C/C++ extensions mentioned earlier, including the new object types, REF, Nested Table, Varying Array, NCHAR, NCHAR Varying and LOB types.</p>
<p>The older Dynamic SQL method 4 is generally restricted to the Oracle types supported by Pro*C/C++ prior to release 8.0. It does allow host variables of the NCHAR, NCHAR Varying and LOB datatypes. Dynamic method 4 is not available for object types, Nested Table, Varying Array, and REF types.</p>
<p>Instead, use ANSI Dynamic SQL Method 4 for all new applications, because it supports all datatypes introduced in Oracle8<span class="italic">i</span>.</p>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_16lob.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_18col.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>