<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78018"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Collections"></a><title>Collections</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:53Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_17obj.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_19ott.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">24/35</span> <!-- End Header -->
<div id="LNPCC4375" class="chapter"><a id="g1023189"></a>
<h1 class="chapter"><span class="secnum">18</span> Collections</h1>
<p>This chapter describes other kinds of object types, known as <span class="italic">collections</span>, and the ways of using them in Pro*C/C++. We present methods to access collections and their elements. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i997692">Collections</a></p>
</li>
<li>
<p><a href="#i1000443">Descriptors for Collections</a></p>
</li>
<li>
<p><a href="#i1002319">OBJECT GET and SET</a></p>
</li>
<li>
<p><a href="#i1001404">Collection Statements</a></p>
</li>
<li>
<p><a href="#i999718">Collection Example Code</a></p>
</li>
</ul>
<a id="i997692"></a>
<div id="LNPCC4376" class="sect1">
<h2 class="sect1">Collections</h2>
<p>There are two kinds of collection object types: <span class="italic">nested tables</span> and <span class="italic">varrays</span>.</p>
<p>Collections may occur both in relational columns and also as attributes within an object type. All collections must be <span class="italic">named</span> object types in the database. In the case of varrays, you must first create a named type in the database, specifying the desired array element type and maximum array dimension.</p>
<p>With Oracle, you are no longer limited to a single level of nesting. Oracle supports multilevel collections of objects enabling multiple levels of nested tables and varrays.</p>
<div id="LNPCC4377" class="sect2"><a id="sthref2151"></a>
<h3 class="sect2"><a id="sthref2152"></a><a id="sthref2153"></a>Nested Tables<a id="sthref2154"></a><a id="sthref2155"></a></h3>
<p>A nested table is a collection of rows, called elements, within a column. For each row of the database table there are many such elements. A simple example is the list of tasks that each employee is working on. Thus many-to-one relationships can be stored in one table, without needing to join employee and task tables.</p>
<p>Nested tables differ from C and C++ arrays in these ways:</p>
<ul>
<li>
<p>Arrays have a fixed upper bound; nested tables are unbounded (have no maximum index).</p>
</li>
<li>
<p>Arrays have consecutive subscripts (are <span class="italic">dense</span>); nested tables can be either dense or <span class="italic">sparse</span>. When a nested table is retrieved into an array in a program, the gaps are skipped, resulting in a filled array that has no gaps.</p>
</li>
</ul>
<p>Use the CREATE TYPE statement to define a table type that can be nested within other object types in one or more columns of a relational table.</p>
<p>For example:, to store several projects in each department of an organization:</p>
<pre>CREATE TYPE project_type AS OBJECT (
    pno            CHAR(5),
    pname          CHAR(20),
    budget         NUMBER(7,2)) ;

CREATE TYPE project_table AS TABLE OF project_type ;

CREATE TABLE depts (
    dno            CHAR(5),
    dname          CHAR(20),
    budgets_limit  NUMBER(15,2),
    projects       project_table)
    NESTED TABLE projects STORE AS depts_projects ;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4378" class="sect2"><a id="sthref2156"></a>
<h3 class="sect2"><a id="sthref2157"></a><a id="sthref2158"></a>Varrays<a id="sthref2159"></a><a id="sthref2160"></a></h3>
<p>Unlike nested tables, you must specify the maximum number of elements when you create a VARRAY type. Varrays are only dense, unlike nested tables, which can be dense or sparse. The elements of a varray and a nested table are both numbered from 0.</p>
<p>You create a varray with CREATE TYPE statements such as:</p>
<pre>CREATE TYPE employee AS OBJECT 
(
  name   VARCHAR2(10),
  salary NUMBER(8,2)
) ;
CREATE TYPE employees AS VARRAY(15) OF employee ;
CREATE TYPE department AS OBJECT
(
  name VARCHAR2(15),
  team employees
) ;
</pre>
<p>Use VARRAY as a datatype of a column of a relational table, or as the attribute of an object type. This saves storage space compared to a relational table that has up to 15 records for each team, each containing the team&#39;s name.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4379" class="sect2"><a id="sthref2161"></a>
<h3 class="sect2"><a id="sthref2162"></a>C and Collections</h3>
<p>In a C or C++ program a nested table is read in starting from index value 0 of the collection. When you write the nested table into an array, the elements of the nested table are stored starting at array index 0. When a nested table which is sparse (has gaps in its index) is stored into an array, the gaps are skipped. When reading the array back into the nested table, the gaps are re-created.</p>
<p>In a C or C++ program varrays are written into an array, starting at index 0. When read back into the varray, the elements are restored starting at index 0 in the same order. Thus, arrays are easily used to access collections.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1000443"></a>
<div id="LNPCC4380" class="sect1">
<h2 class="sect1"><a id="sthref2163"></a>Descriptors for Collections<a id="sthref2164"></a><a id="sthref2165"></a></h2>
<p>The C type for a nested table is a pointer to OCITable. For varrays, it is a pointer to OCIArray. (Both are subtypes of a pointer to OCIColl). Use the OTT (Object Type Translator) utility to generate typedefs in header files that you then include in your application code. See also <a href="pc_19ott.htm#g464850">Chapter 19, &#34;The Object Type Translator&#34;</a>.</p>
<p>The host structure for a collection is a <span class="italic">descriptor</span> through which the elements in the collection may be accessed. These descriptors do not hold the actual elements of the collection, but instead contain the pointers to them. Memory for both the descriptor and its associated elements come from the object cache.</p>
<p>Following the usual procedure for object types, the OTT-generated typefile must be specified in the INTYPE precompiler option to Pro*C/C++ and the OTT-generated headers included in the Pro*C/C++ program using the #include preprocessor directive. This ensures that the proper type-checking for the collection object type can be performed during precompilation.</p>
<p>Unlike other object types, however, a collection object type does not require a special indicator structure to be generated by OTT; a scalar indicator is used instead. This is because an atomic NULL indicator is sufficient to denote whether a collection as a whole is NULL. The NULL status of each individual element in a collection may (optionally) be represented in separate indicators associated to each element.</p>
<div id="LNPCC4381" class="sect2"><a id="sthref2166"></a>
<h3 class="sect2"><a id="sthref2167"></a><a id="sthref2168"></a>Declarations for Host and Indicator Variables<a id="sthref2169"></a><a id="sthref2170"></a><a id="sthref2171"></a><a id="sthref2172"></a></h3>
<p>As for the other object types, a host variable representing a collection object type must be declared as a pointer to the appropriate OTT-generated typedef.</p>
<p>Unlike other object types, however, the indicator variable for a collection object type as a whole is declared as a scalar signed 2-byte type, <code>OCIInd</code>. The indicator variable is optional, but it is a good programming practice to use one for each host variable declared in Pro*C/C++.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4382" class="sect2"><a id="sthref2173"></a>
<h3 class="sect2"><a id="sthref2174"></a>Manipulating Collections<a id="sthref2175"></a></h3>
<p>There are two ways to manipulate a collection: the collection is treated as an autonomous entity without access to its elements, or its elements are accessed, appended to, truncated, and so on.</p>
<div id="LNPCC4383" class="sect3"><a id="sthref2176"></a>
<h4 class="sect3"><a id="sthref2177"></a>Autonomous Collection Access</h4>
<p>Using a C collection descriptor (OCITable or OCIArray) allows only assignment of the collection as a whole. The OBJECT GET embedded SQL statement binds the collection to a C host variable descriptor. The opposite occurs in an OBJECT SET statement which binds the C host descriptor to the collection.</p>
<p>It is possible to bind more than one collection to a compatible C descriptor in the same statement, or include bindings of other scalars in the same statement where binding of a collection to a C descriptor occurs.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_17obj.htm#i449464">&#34;Converting Object Attributes and C Types&#34;</a></div>
</div>
<!-- class="sect3" -->
<div id="LNPCC4384" class="sect3"><a id="sthref2178"></a>
<h4 class="sect3"><a id="sthref2179"></a>Collection Element Access</h4>
<p>The C collection descriptor is used to access elements of a collection. The descriptor contains the internal attributes of the collection such as its start and end points, and other information.</p>
<p>A <span class="italic">slice</span> of elements are bound to a host array that has a compatible data type. A slice of a collection is defined as the contents between a starting index and an ending index. The slice maps to an array, which can have a dimension larger than the number of slice elements.</p>
<p>Binding a scalar is the same as having a host array of dimension one, or having an optional FOR clause evaluated to one.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC4385" class="sect2"><a id="sthref2180"></a>
<h3 class="sect2">Rules for Access</h3>
<p>Access rules are different for autonomous and element access.</p>
<div id="LNPCC4386" class="sect3"><a id="sthref2181"></a>
<h4 class="sect3">Autonomous Access</h4>
<ul>
<li>
<p>The FOR clause is not allowed since the collection is treated as a whole.</p>
</li>
<li>
<p>Because nested tables and varrays are defined differently, assignments between them are not possible.</p>
</li>
<li>
<p>Multiple assignments of several collections to C descriptors are allowed in the same statement. You can assign a collection to a C descriptor and also bind other scalar datatypes in the same statement.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="LNPCC4387" class="sect3"><a id="sthref2182"></a>
<h4 class="sect3">Element Access</h4>
<ul>
<li>
<p>FOR clauses are permitted. If omitted, the smallest array dimension gives the number of iterations to perform.</p>
</li>
<li>
<p>Only one collection can be accessed at a time.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The FOR clause variable specifies the number of array elements to be processed. Make sure the number does not exceed the smallest array dimension. Internally, the value is treated as an unsigned quantity. An attempt to pass a negative value through the use of a signed host variable will result in unpredictable behavior.</div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC4388" class="sect2"><a id="sthref2183"></a>
<h3 class="sect2">Indicator Variables</h3>
<p>Each access method has its own way of using indicator variables.</p>
<div id="LNPCC4389" class="sect3"><a id="sthref2184"></a>
<h4 class="sect3">Autonomous Bindings</h4>
<p>The single indicator variable holds the NULL status of the collection as a single entity. This says nothing about the NULL status in the elements.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4390" class="sect3"><a id="sthref2185"></a>
<h4 class="sect3">Element Bindings</h4>
<p>The indicator variables show whether an element is NULL or not. If a slice of collection data is bound to a host array which has its own indicator array, that indicator array will contain the NULL status of each element in the slice.</p>
<p>When the collection element type is a user-defined object type, the indicator variable associated with the host variable contains the NULL status of the object and of its attributes.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1002319"></a>
<div id="LNPCC4391" class="sect1">
<h2 class="sect1"><a id="sthref2186"></a>OBJECT GET and <a id="sthref2187"></a>SET</h2>
<p>The navigational statements OBJECT SET and OBJECT GET permit you to retrieve and update collection attributes as well as object types defined by you.</p>
<p>For elements that are object types, the OBJECT GET statement retrieves all attributes of the object into the host variables when either the</p>
<pre> &#39;*&#39; | {<span class="italic">attr</span> [, <span class="italic">attr</span>]}  FROM 
</pre>
<p>clause is omitted, or &#39;OBJECT GET * FROM &#39; is used:</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] 
   OBJECT GET [  &#39;*&#39; | {<span class="italic">attr</span> [,<span class="italic">attr</span>]}  FROM]
      :<span class="italic">object </span>[[INDICATOR] :<span class="italic">object_ind</span>]
         INTO {:<span class="italic">hv</span> [[INDICATOR] :<span class="italic">hv_ind</span>]
            [,:<span class="italic">hv</span> [[INDICATOR] :<span class="italic">hv_ind</span>]]} ;
</pre>
<p>The OBJECT SET statement causes all attributes of the object to be updated using the host variables when either the</p>
<pre> &#39;*&#39; | {<span class="italic">attr</span>, [, <span class="italic">attr</span>]}  OF
</pre>
<p>clause is omitted or &#39;OBJECT SET * OF&#39; is used:</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] 
   OBJECT SET [  &#39;*&#39; | {<span class="italic">attr</span> [, <span class="italic">attr</span>]} OF]
     :<span class="italic">object</span> [INDICATOR] :<span class="italic">object_ind</span>]
        TO {:<span class="italic">hv</span> [[INDICATOR] :<span class="italic">hv_ind</span>]
            [,:<span class="italic">hv</span> [[INDICATOR] :<span class="italic">hv_ind</span>]]} ;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_17obj.htm#i449464">&#34;Converting Object Attributes and C Types&#34;</a> for complete details of the OBJECT GET and OBJECT SET statements.</div>
<p>This table shows how object and collection types are mapped by these two statements:</p>
<div id="LNPCC4392" class="tblformal">
<p class="titleintable"><a id="sthref2188"></a><a id="sthref2189"></a>Table 18-1 Object and Collection Attributes</p>
<table class="cellalignment831" title="Object and Collection Attributes" summary="Object and Collection Attributes" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t5">Attribute Type</th>
<th class="cellalignment832" id="r1c2-t5">Representation</th>
<th class="cellalignment832" id="r1c3-t5">Host Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t5" headers="r1c1-t5">
<p>Object</p>
</td>
<td class="cellalignment833" headers="r2c1-t5 r1c2-t5">
<p>OTT-Generated Structure</p>
</td>
<td class="cellalignment833" headers="r2c1-t5 r1c3-t5">
<p>Pointer to OTT Structure</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t5" headers="r1c1-t5">
<p>Collection</p>
</td>
<td class="cellalignment833" headers="r3c1-t5 r1c2-t5">
<p>OCIArray, OCITable (OCIColl)</p>
</td>
<td class="cellalignment833" headers="r3c1-t5 r1c3-t5">
<p>OCIArray *, OCITable * (OCIColl *)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The object or collection must be type compatible with the attribute to which it is bound. Collection attributes are type compatible if and only if they are both either varray or nested table, and their element types are compatible.</p>
<p>This next table shows how type compatibility for the elements of two collection types is obtained.</p>
<div id="LNPCC4393" class="tblformal">
<p class="titleintable"><a id="sthref2190"></a><a id="sthref2191"></a>Table 18-2 Collection and Host Array Allowable Type Conversions</p>
<table class="cellalignment831" title="Collection and Host Array Allowable Type Conversions" summary="Collection and Host Array Allowable Type Conversions" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t6">Collection Element Type</th>
<th class="cellalignment832" id="r1c2-t6">Representation</th>
<th class="cellalignment832" id="r1c3-t6">Host Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t6" headers="r1c1-t6">
<p>CHAR, VARCHAR, VARCHAR2</p>
</td>
<td class="cellalignment833" headers="r2c1-t6 r1c2-t6">
<p>OCIString</p>
</td>
<td class="cellalignment833" headers="r2c1-t6 r1c3-t6">
<p>string, VARCHAR, CHARZ, OCIString</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t6" headers="r1c1-t6">
<p>REF</p>
</td>
<td class="cellalignment833" headers="r3c1-t6 r1c2-t6">
<p>OCIRef</p>
</td>
<td class="cellalignment833" headers="r3c1-t6 r1c3-t6">
<p>OCIRef</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t6" headers="r1c1-t6">
<p>INTEGER, SMALLINT, INT</p>
</td>
<td class="cellalignment833" headers="r4c1-t6 r1c2-t6">
<p>OCINumber</p>
</td>
<td class="cellalignment833" headers="r4c1-t6 r1c3-t6">
<p>int, short, OCINumber</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t6" headers="r1c1-t6">
<p>NUMBER, NUMERIC, REAL, FLOAT, DOUBLE PRECISION</p>
</td>
<td class="cellalignment833" headers="r5c1-t6 r1c2-t6">
<p>OCINumber</p>
</td>
<td class="cellalignment833" headers="r5c1-t6 r1c3-t6">
<p>int, float, double, OCINumber</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t6" headers="r1c1-t6">
<p>DATE</p>
</td>
<td class="cellalignment833" headers="r6c1-t6 r1c2-t6">
<p>OCIDate</p>
</td>
<td class="cellalignment833" headers="r6c1-t6 r1c3-t6">
<p>string, VARCHAR, CHARZ, OCIDate</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The object to which the REF refers must be type compatible with the REF to which it is bound.</p>
<p>In both tables OBJECT GET converts database types from the type on the left, using the format specified in the Representation column to an internal datatype using the format in the Host Data Type column. OBJECT SET converts in the opposite direction.</p>
<p class="subhead1"><a id="LNPCC4394"></a>No Explicit Type Checking</p>
<p>The precompiler does not support explicit type checking on the bindings between collection element datatypes and host variable datatypes. Type-checking is done at runtime.</p>
</div>
<!-- class="sect1" -->
<a id="i1001404"></a>
<div id="LNPCC4395" class="sect1">
<h2 class="sect1">Collection Statements</h2>
<p>This section includes descriptions of the collection statements.</p>
<a id="i998976"></a>
<div id="LNPCC4396" class="sect2">
<h3 class="sect2"><a id="sthref2192"></a>COLLECTION GET</h3>
<p class="subhead1"><a id="LNPCC4397"></a>Purpose</p>
<p>The COLLECTION GET statement is analogous to the OBJECT GET statement, but is designed for collections. It retrieves the elements of a collection, sets the current slice, and converts elements to C types where appropriate.</p>
<p class="subhead1"><a id="LNPCC4398"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [FOR :<span class="italic">num</span>]
   COLLECTION GET :<span class="italic">collect</span> [[INDICATOR] :<span class="italic">collect_ind</span>]
      INTO :<span class="italic">hv</span> [[INDICATOR] :<span class="italic">hv_ind</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4399"></a>Variables</p>
<p>num (IN)</p>
<p>The number of elements requested. If this clause is omitted, the array size of the host variable (scalar has 1) determines the number of elements retrieved from the collection.</p>
<p>collect (IN)</p>
<p>A host variable C collection descriptor.</p>
<p>collect_ind (IN)</p>
<p>An optional indicator variable returning the NULL status of the collection.</p>
<p>hv (OUT)</p>
<p>The host variable that receives the collection element values.</p>
<p>hv_ind (OUT)</p>
<p>An optional indicator variable returning the NULL status of <code>hv</code> if it is a scalar, or an array holding the status of each element in the slice.</p>
<p class="subhead1"><a id="LNPCC4400"></a>Usage Notes</p>
<p>The number of elements actually returned in the last COLLECTION GET is set in sqlca.sqlerrd[2] (not the cumulative total of all GETs). See also <a href="pc_09err.htm#g30970">&#34;<span class="italic">sqlerrd</span>&#34;</a>.</p>
<p>The number returned can be less than the number requested when one or both of the slice endpoints exceed the collection bounds. This can occur when:</p>
<ul>
<li>
<p>The collection descriptor has not been initialized in a syntactically correct ALLOCATE statement, is NULL, or invalid for any other reason.</p>
</li>
<li>
<p>The collection is NULL. Its associated indicator is -1.</p>
</li>
<li>
<p>The collection is empty (has no elements).</p>
</li>
<li>
<p>More elements were requested than are remaining in the collection.</p>
</li>
<li>
<p>A COLLECTION TRIM statement has been executed, resulting in the endpoint index being below the starting index of the current slice.</p>
</li>
</ul>
<p>An improperly initialized C collection descriptor results in an error. All other situations in the list will raise an <code>ORA-01403: no data found</code> error condition. In this case, the total number of elements successfully retrieved before the error occurs is still stored in sqlca.sqlerrd[2].</p>
<p>The initial GET or the first GET after a RESET affects the slice as follows:</p>
<ul>
<li>
<p>The ending index of the slice will be the index where the final element was found; it depends on how many elements are requested. If there were not enough elements in the remaining portion of the collection to satisfy the request, then the ending index will be the last index in the collection.</p>
</li>
</ul>
<p>Subsequent GETs affect the slice indexes as follows:</p>
<ul>
<li>
<p>The index of the start-point is the index where the first element was found after the end-point of the previous slice. If no more elements are left after the end-point of the previous slice, the starting index is that of the last element in the collection.</p>
</li>
<li>
<p>The ending index of the next slice will be the index where the final element was found; it depends on how many elements are requested. If there were not enough elements in the remaining portion of the collection to satisfy the request given the position of the previous slice, then the ending index will be the last index in the collection.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1002288"></a>
<div id="LNPCC4401" class="sect2">
<h3 class="sect2"><a id="sthref2193"></a>COLLECTION SET</h3>
<p class="subhead1"><a id="LNPCC4402"></a>Purpose</p>
<p>The COLLECTION SET statement is analogous to the OBJECT SET statement; it is used for updating element values of collections. Elements in the current slice are converted from the native C types to Oracle datatypes.</p>
<p class="subhead1"><a id="LNPCC4403"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [FOR :<span class="italic">num</span>]
   COLLECTION SET :<span class="italic">collect</span> [[INDICATOR] :<span class="italic">collect_ind</span>]
      TO :<span class="italic">hv</span> [[INDICATOR] :<span class="italic">hv_ind</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4404"></a>Variables</p>
<p>num (IN)</p>
<p>This optional scalar value is the maximum number of elements to be updated in the slice. If this clause is omitted, the array size of the host variable (scalar has 1) determines the number of elements updated from the collection.</p>
<p>collect (OUT)</p>
<p>A host variable C collection descriptor.</p>
<p>collect_ind (OUT)</p>
<p>An optional indicator variable which determines the NULL status of the collection.</p>
<p>hv (IN)</p>
<p>A host variable that contains the values to be updated in the collection.</p>
<p>hv_ind (IN)</p>
<p>An associated indicator variable representing the NULL status of the host variable.</p>
<p class="subhead1"><a id="LNPCC4405"></a>Usage Notes</p>
<p>The following restrictions apply:</p>
<ul>
<li>
<p>A COLLECTION GET must be executed before a COLLECTION SET.</p>
</li>
<li>
<p>The starting and ending indexes of the slice <span class="italic">always</span> remain unchanged. This is true even if less elements are placed in the collection than can be stored in the current slice. A SET statement <span class="italic">never</span> changes the endpoints of the slice. It only changes elements in the current slice.</p>
</li>
<li>
<p>The COLLECTION SET is intended only to update those elements <span class="italic">in the current slice</span>. You cannot append new elements to a collection using the COLLECTION SET statement.</p>
</li>
<li>
<p>If an attempt is made to SET more elements than the current slice contains, only those elements that fit in the existing slice are updated. Remaining elements beyond the end of the slice are unaffected and any extra values supplied by the host variable are unused.</p>
</li>
</ul>
<p>The dimension of the host variable or the value <code>num</code> specified in an optional FOR clause gives the maximum number of elements requested to be updated in the collection.</p>
<p>The variable sqlca.sqlerrd[2] returns the number of elements successfully updated by the previous SET statement (not a cumulative total), which can be less than the number requested to be set (as for the GET), for these cases:</p>
<ul>
<li>
<p>The C collection descriptor has not been correctly initialized in a syntactically correct ALLOCATE statement, or is NULL, or otherwise invalid.</p>
</li>
<li>
<p>The collection is empty.</p>
</li>
<li>
<p>There were fewer elements in the remaining portion of the collection than were requested to be set given the position of the current slice in the collection.</p>
</li>
<li>
<p>The end of the current slice was breached. This can happen only when an attempt is made to set more elements than are in the existing slice.</p>
</li>
<li>
<p>A TRIM has been performed on the collection, bringing the maximum endpoint index value of the collection below the starting index of the current slice.</p>
</li>
</ul>
<p>Issuing a COLLECTION SET immediately after a COLLECTION GET or SET will only update the values of the elements in the <span class="italic">existing</span> slice. A COLLECTION GET that immediately follows a COLLECTION SET will advance the slice as already described.</p>
</div>
<!-- class="sect2" -->
<a id="i1002287"></a>
<div id="LNPCC4406" class="sect2">
<h3 class="sect2"><a id="sthref2194"></a>COLLECTION RESET</h3>
<p class="subhead1"><a id="LNPCC4407"></a>Purpose</p>
<p>Reset the collection slice endpoints back to the beginning of the collection.</p>
<p class="subhead1"><a id="LNPCC4408"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>]
   COLLECTION RESET :<span class="italic">collect</span> 
      [ [INDICATOR] :<span class="italic">collect_ind</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4409"></a>Variables</p>
<p>collect (IN/OUT)</p>
<p>The collection whose endpoints are to be reset.</p>
<p>collect_ind</p>
<p>Optional indicator variable determining NULL status of the collection.</p>
<p class="subhead1"><a id="LNPCC4410"></a>Usage Notes</p>
<p>An error occurs if the given collection is NULL, or otherwise invalid.</p>
<p>COLLETION RESET does not affect the size or contents of the collection.</p>
</div>
<!-- class="sect2" -->
<a id="i1002285"></a>
<div id="LNPCC4411" class="sect2">
<h3 class="sect2"><a id="sthref2195"></a>COLLECTION APPEND</h3>
<p class="subhead1"><a id="LNPCC4412"></a>Purpose</p>
<p>This statement appends a set of elements (one or more) to the end of a collection, increasing the size of the collection.</p>
<p class="subhead1"><a id="LNPCC4413"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] [FOR :<span class="italic">num</span>]
   COLLECTION APPEND :<span class="italic">src</span> [[INDICATOR] :<span class="italic">src_ind</span>]
      TO :<span class="italic">collect</span> [[INDICATOR] :<span class="italic">collect_ind</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4414"></a>Variables</p>
<p>num (IN)</p>
<p>A scalar that contains the number of elements to be appended. If absent, the array size of <code>src</code> is the number of elements to be appended.</p>
<p>src (IN)</p>
<p>Scalar or array of elements to be appended to the collection.</p>
<p>src_ind (IN)</p>
<p>An optional indicator variable (scalar or array) determining the NULL status of the elements appended.</p>
<p>collect (IN OUT)</p>
<p>The collection to which elements are appended.</p>
<p>collect_ind (IN)</p>
<p>An optional indicator variable determining the NULL status of the collection.</p>
<p class="subhead1"><a id="LNPCC4415"></a>Usage Notes</p>
<p>Elements are appended one at a time (the collection is increased in size by one, the data is copied to that element, and so on).</p>
<p>The variable <code>sqlca.sqlerrd[2]</code> returns the number of elements successfully appended by the latest APPEND (not a cumulative total). An error results if there is an attempt to add elements beyond the upper bound of the collection, or to append to a NULL collection. Only the elements that fit will be appended.</p>
</div>
<!-- class="sect2" -->
<a id="i1002289"></a>
<div id="LNPCC4416" class="sect2">
<h3 class="sect2"><a id="sthref2196"></a>COLLECTION TRIM</h3>
<p class="subhead1"><a id="LNPCC4417"></a>Purpose</p>
<p>This statement removes elements from the end of a collection.</p>
<p class="subhead1"><a id="LNPCC4418"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>]
   COLLECTION TRIM :<span class="italic">num</span>
      FROM :<span class="italic">collect</span> [[INDICATOR] :<span class="italic">collect_ind</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4419"></a>Variables</p>
<p>num (IN)</p>
<p>A host scalar variable which is how many elements are to be removed. The maximum permitted value is two Gigabytes.</p>
<p>collect (IN OUT)</p>
<p>The collection to be trimmed.</p>
<p>collect_ind (IN)</p>
<p>An optional indicator variable determining the NULL status of the collection.</p>
<p class="subhead1"><a id="LNPCC4420"></a>Usage Notes</p>
<p>Restrictions applied:</p>
<ul>
<li>
<p>The FOR clause is not allowed.</p>
</li>
<li>
<p>The maximum value of <code>num</code> is 2 Gigabytes (the largest number in a 4-byte signed binary variable.</p>
</li>
<li>
<p>No indicator is allowed with <code>num</code>.</p>
</li>
</ul>
<p>If <code>num</code> is greater than the size of the collection, an error is returned. A warning is returned if a TRIM removes any elements from the current slice.</p>
</div>
<!-- class="sect2" -->
<a id="i1002286"></a>
<div id="LNPCC4421" class="sect2">
<h3 class="sect2"><a id="sthref2197"></a>COLLECTION DESCRIBE</h3>
<p class="subhead1"><a id="LNPCC4422"></a>Purpose</p>
<p>This statement returns information about a collection.</p>
<p class="subhead1"><a id="LNPCC4423"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] 
   COLLECTION DESCRIBE :<span class="italic">collect</span> [[INDICATOR] :<span class="italic">collect_ind</span>]
      GET <span class="italic">attribute1</span> [{, <span class="italic">attributeN</span>}]
         INTO :<span class="italic">hv1</span> [[INDICATOR] :<span class="italic">hv_ind1</span>] [{, <span class="italic">hvN </span>[[INDICATOR] :<span class="italic">hv_indN</span>]}] ;
</pre>
<p>where <code>attributeN</code> is:</p>
<pre>DATA_SIZE | TYPECODE | DATA_TYPE | NUM_ELEMENTS
   | PRECISION | SCALE | TYPE_NAME | TYPE_SCHEMA | SIZE | TABLE_SIZE
</pre>
<p class="subhead1"><a id="LNPCC4424"></a>Variables</p>
<p>collect (IN)</p>
<p>The host variable C collection descriptor.</p>
<p>collect_ind (IN)</p>
<p>An optional indicator variable containing the NULL status of the collection.</p>
<p>hv1 .. hvN (OUT)</p>
<p>Output host variables where the information is to be stored.</p>
<p>hv_ind1 .. hv_indN (OUT)</p>
<p>Indicator variables for the output host variables.</p>
<p class="subhead1"><a id="LNPCC4425"></a>Usage Notes</p>
<p>These restrictions are in effect:</p>
<ul>
<li>
<p>The collection cannot be NULL.</p>
</li>
<li>
<p>Host variable types should be compatible with the types of the returned attributes.</p>
</li>
<li>
<p>Indicator variables for the attributes are only required for TYPE_NAME and TYPE_SCHEMA attribute values where text truncation can occur.</p>
</li>
<li>
<p>A FOR clause is not allowed.</p>
</li>
<li>
<p>The variable sqlca.sqlerrd[2] returns the number of successful attributes retrieved with no errors. If the DESCRIBE statement incurs an error, then sqlca.sqlqerrd[2] contains the number of attributes returned before that error, and is one less than the attribute where the error occurred.</p>
</li>
</ul>
<p>The following table gives attributes, descriptions, and C types for the attributes retrieved:<a id="sthref2198"></a><a id="sthref2199"></a><a id="sthref2200"></a></p>
<div id="LNPCC4426" class="tblformalwide">
<p class="titleintable"><a id="sthref2201"></a><a id="sthref2202"></a>Table 18-3 Attributes of a COLLECTION DESCRIBE</p>
<table class="cellalignment834" title="Attributes of a COLLECTION DESCRIBE" summary="Attributes of a COLLECTION DESCRIBE" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t7">Attribute</th>
<th class="cellalignment832" id="r1c2-t7">Description</th>
<th class="cellalignment832" id="r1c3-t7">C Type</th>
<th class="cellalignment832" id="r1c4-t7">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t7" headers="r1c1-t7">
<p>DATA_SIZE</p>
</td>
<td class="cellalignment833" headers="r2c1-t7 r1c2-t7">
<p>The maximum size of the type attribute. The returned length is in bytes for strings. It is 22 for NUMBERs.</p>
</td>
<td class="cellalignment833" headers="r2c1-t7 r1c3-t7">
<p>unsigned short</p>
</td>
<td class="cellalignment833" headers="r2c1-t7 r1c4-t7">
<p>Not valid for object or object REF elements.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t7" headers="r1c1-t7">
<p>TYPECODE</p>
</td>
<td class="cellalignment833" headers="r3c1-t7 r1c2-t7">
<p>OCI type code.</p>
</td>
<td class="cellalignment833" headers="r3c1-t7 r1c3-t7">
<p>OCITypeCode</p>
</td>
<td class="cellalignment833" headers="r3c1-t7 r1c4-t7">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t7" headers="r1c1-t7">
<p>DATA_TYPE</p>
</td>
<td class="cellalignment833" headers="r4c1-t7 r1c2-t7">
<p>The internal numeric type code of the collection items.</p>
</td>
<td class="cellalignment833" headers="r4c1-t7 r1c3-t7">
<p>unsigned short</p>
</td>
<td class="cellalignment833" headers="r4c1-t7 r1c4-t7">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t7" headers="r1c1-t7">
<p>NUM_ELEMENTS</p>
</td>
<td class="cellalignment833" headers="r5c1-t7 r1c2-t7">
<p>The maximum number of elements in the varray.</p>
</td>
<td class="cellalignment833" headers="r5c1-t7 r1c3-t7">
<p>unsigned int</p>
</td>
<td class="cellalignment833" headers="r5c1-t7 r1c4-t7">
<p>Only valid for type VARRAY.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t7" headers="r1c1-t7">
<p>PRECISION</p>
</td>
<td class="cellalignment833" headers="r6c1-t7 r1c2-t7">
<p>The precision of numeric type attributes. When the returned value is 0 the item being described is not initialized and is NULL in the data dictionary.</p>
</td>
<td class="cellalignment833" headers="r6c1-t7 r1c3-t7">
<p>unsigned char</p>
</td>
<td class="cellalignment833" headers="r6c1-t7 r1c4-t7">
<p>Only valid for elements of type NUMBER.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t7" headers="r1c1-t7">
<p>SCALE</p>
</td>
<td class="cellalignment833" headers="r7c1-t7 r1c2-t7">
<p>The scale of numeric type attributes. When the returned value is -127 the item being described is not initialized and is NULL in the data dictionary.</p>
</td>
<td class="cellalignment833" headers="r7c1-t7 r1c3-t7">
<p>signed char</p>
</td>
<td class="cellalignment833" headers="r7c1-t7 r1c4-t7">
<p>Only valid for elements of type NUMBER.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t7" headers="r1c1-t7">
<p>TYPE_NAME</p>
</td>
<td class="cellalignment833" headers="r8c1-t7 r1c2-t7">
<p>A string containing the name of the type. For an object type, its name is returned. For a REF the name of the data type pointed to by the REF is returned. External data types allowed are CHARZ, STRING, and VARCHAR.</p>
</td>
<td class="cellalignment833" headers="r8c1-t7 r1c3-t7">
<p>char *</p>
</td>
<td class="cellalignment833" headers="r8c1-t7 r1c4-t7">
<p>Only valid for object and object REF elements.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t7" headers="r1c1-t7">
<p>TYPE_SCHEMA</p>
</td>
<td class="cellalignment833" headers="r9c1-t7 r1c2-t7">
<p>The schema name where the type was created. External data types allowed are CHARZ, STRING, and VARCHAR.</p>
</td>
<td class="cellalignment833" headers="r9c1-t7 r1c3-t7">
<p>char *</p>
</td>
<td class="cellalignment833" headers="r9c1-t7 r1c4-t7">
<p>Only valid for object and object REF elements.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t7" headers="r1c1-t7">
<p>SIZE</p>
</td>
<td class="cellalignment833" headers="r10c1-t7 r1c2-t7">
<p>The number of elements actually stored in the collection. For nested tables, SIZE includes the empty elements. A TRIM statement decrements the SIZE of the collection by the number of elements trimmed.</p>
</td>
<td class="cellalignment833" headers="r10c1-t7 r1c3-t7">
<p>signed int</p>
</td>
<td class="cellalignment833" headers="r10c1-t7 r1c4-t7">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t7" headers="r1c1-t7">
<p>TABLE_SIZE</p>
</td>
<td class="cellalignment833" headers="r11c1-t7 r1c2-t7">
<p>The number of elements in the nested table. It does not include the gaps.</p>
</td>
<td class="cellalignment833" headers="r11c1-t7 r1c3-t7">
<p>signed int</p>
</td>
<td class="cellalignment833" headers="r11c1-t7 r1c4-t7">
<p>Only valid for nested tables.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" -->
<div id="LNPCC4427" class="sect3"><a id="sthref2203"></a>
<h4 class="sect3">Notes on the Table</h4>
<p>Pro*C/C++ only supports the external datatypes CHARZ, STRING, and VARCHAR for the attributes TYPE_NAME and TYPE_SCHEMA.</p>
<p>All the DESCRIBE attributes, except for SIZE and TABLE_SIZE, depend on the element type of the collection and are independent of any one particular instance of the collection. The SIZE and TABLE_SIZE attributes, on the other hand, are attributes whose values strictly depend on a specific instance of the collection. The SIZE or TABLE_SIZE values will change from one collection instance to another in cases where an allocated collection descriptor is being reused to refer to different instances of the same collection. NUM_ELEMENTS is an attribute of the collection type (a VARRAY in this case), not the collection element type, and is independent of any one particular instance of the collection.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC4428" class="sect2"><a id="sthref2204"></a>
<h3 class="sect2">Rules for the Use of Collections</h3>
<ul>
<li>
<p>A host variable collection descriptor must always be explicitly allocated.</p>
</li>
<li>
<p><a id="sthref2205"></a>The metadata (internal Oracle data from the database about a collection and its element type) is collected during an ALLOCATE. That metadata becomes invalid when the connection in which the ALLOCATE was made is closed or if the type changes after the ALLOCATE.</p>
</li>
<li>
<p>Use the ALLOCATE and FREE statements to begin and end use of each C collection descriptor.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i999718"></a>
<div id="LNPCC4429" class="sect1">
<h2 class="sect1">Collection Example Code</h2>
<p>Here are examples of SQL and Pro*C/C++ code that illustrates the use of the COLLECTION SQL statements:</p>
<div id="LNPCC4430" class="sect2"><a id="sthref2206"></a>
<h3 class="sect2">Type and Table Creation</h3>
<p>Assuming a connection as scott/tiger, we create the following types using SQL:</p>
<pre>CREATE TYPE employee AS OBJECT 
(
  name   VARCHAR2(10),
  salary NUMBER(8,2)
) ;
CREATE TYPE employees AS VARRAY(15) OF employee ;
CREATE TYPE department AS OBJECT
(
  name VARCHAR2(15),
  team employees
) ;
</pre>
<p>Now for the header file generated by the Object Type Translator. The following intype file (called in.typ) will be used as input to OTT:</p>
<pre>case=lower
type employee
type employees
type department
</pre>
<p>The following command will generate the header file:</p>
<pre>ott intype=in.typ outtype=out.typ hfile=example.h user=scott/tiger code=c
</pre>
<p>This header file, <code>example.h,</code> is produced by OTT:</p>
<pre>#ifndef EXAMPLE_ORACLE
# define EXAMPLE_ORACLE

#ifndef OCI_ORACLE
# include &lt;oci.h&gt;
#endif

typedef OCIRef employee_ref ;
typedef OCIArray employees ;
typedef OCIRef department_ref ;

struct employee
{
   OCIString * name ;
   OCINumber salary ;
} ;
typedef struct employee employee ;

struct employee_ind
{
   OCIInd _atomic ;
   OCIInd name ;
   OCIInd salary ;
} ;
typedef struct employee_ind employee_ind ;
struct department_ind
{
   OCIInd _atomic ;
   OCIInd name ;
   OCIInd team ;
} ;
typedef struct department_ind department_ind ;

#endif
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>oci.h</code> file includes orl.h which has a typedef that defines OCIArray. That typedef looks like the following &#39;typedef OCIColl OCIArray;&#39; where OCIColl is an opaque structure representing a generic collection.</div>
<p>Now create a simple table that has one column as follows:</p>
<pre>CREATE TABLE division ( subdivision department ) ;
</pre>
<p>Now we will insert a few rows into that table:</p>
<pre>INSERT INTO division (subdivision) VALUES
(department(&#39;Accounting&#39;,
            employees(employee(&#39;John&#39;, 75000),
                      employee(&#39;Jane&#39;, 75000)))
);
INSERT INTO division (subdivision) VALUES
(department(&#39;Development&#39;,
            employees(employee(&#39;Peter&#39;, 80000),
                      employee(&#39;Paula&#39;, 80000)))
) ;
INSERT INTO division (subdivision) VALUES
(department(&#39;Research&#39;,
            employees(employee(&#39;Albert&#39;, 95000),
                      employee(&#39;Alison&#39;, 95000)))
);
</pre>
<p>We can now use these type definitions and table information in the examples to follow.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4431" class="sect2"><a id="sthref2207"></a>
<h3 class="sect2"><a id="sthref2208"></a>GET and <a id="sthref2209"></a>SET Example</h3>
<p>Suppose we want to retrieve the values from the collection attribute of an example object, modify them in some simple way and place them back into the collection.</p>
<p>First, we need to include example.h and declare a variable for the object type:</p>
<pre>#include &lt;example.h&gt;
department *dept_p ;
</pre>
<p>Now we will select the &#39;Development&#39; department from the division table:</p>
<pre>       EXEC SQL ALLOCATE :dept_p ;
       EXEC SQL SELECT subdivision INTO :dept_p
          FROM division WHERE name = &#39;Development&#39; ;
</pre>
<p>We also need a variable for the team varray of employee object types and one to represent a single employee object. We will be giving all team members of the &#39;Development&#39; department a raise so we need a variable for that also:</p>
<pre>       employees *emp_array ;
       employee *emp_p ;
       double salary ;
</pre>
<p>Now we must ALLOCATE our varray C Collection and employee object descriptors. We will retrieve the actual collection from the object using the navigational interface:</p>
<pre>       EXEC SQL ALLOCATE :emp_array ;
       EXEC SQL ALLOCATE :emp_p ;
       EXEC SQL OBJECT GET team FROM :dept_p INTO :emp_array ;
</pre>
<p>We will use a loop to iterate through the varray elements, controlling loop termination by using the WHENEVER directive:</p>
<pre>       EXEC SQL WHENEVER NOT FOUND DO break ;
       while (TRUE)
         {
</pre>
<p>First, retrieve the element from the collection so that we can alter it. The actual element type is an employee object:</p>
<pre>            EXEC SQL COLLECTION GET :emp_array INTO :emp_p ;
</pre>
<p>Now that we have the actual object element, we can then proceed to change an attribute&#39;s value using the existing navigational interface. In this case, we give a 10% salary increase to everyone:</p>
<pre>            EXEC SQL OBJECT GET salary FROM :emp_p INTO :salary ;
            salary += (salary * .10) ;
            EXEC SQL OBJECT SET salary OF :emp_p TO :salary ;
</pre>
<p>Once we are done making our changes, we can update the value of the attribute of the object element we are currently at in the collection:</p>
<pre>            EXEC SQL COLLECTION SET :emp_array TO :emp_p ;
         }
</pre>
<p>Once we are done iterating through all of the collection elements, we must then update the column of the table that stores the object that contains the collection we just finished modifying:</p>
<pre>     EXEC SQL UPDATE division SET subdivision = :dept_p ;
</pre>
<p>We can then FREE all of our resources and COMMIT our work thus terminating this sequence of operations:</p>
<pre>     EXEC SQL FREE :emp_array ;
     EXEC SQL FREE :emp_p ;
     EXEC SQL FREE :dept_p ;
     EXEC SQL COMMIT WORK ;
</pre>
<p>Although this is a fairly small and simple example, it is quite comprehensive. It clearly demonstrates how a collection attribute can be retrieved from an object into a C Collection Descriptor using the semantic extensions to the navigational OBJECT GET statement. Using that C Descriptor we then saw how to use the new COLLECTION GET and SET statements to retrieve and update the actual elements of that collection. We used the navigational interface to modify the attribute values of the collection object element type.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4432" class="sect2"><a id="sthref2210"></a>
<h3 class="sect2"><a id="sthref2211"></a>DESCRIBE Example</h3>
<p>This example illustrates a simple use of the DESCRIBE SQL statement. We want to find out some basic information about a given collection.</p>
<p>First we need our example header file, an object pointer and a SQL Collection Descriptor:</p>
<pre>#include &lt;example.h&gt;
department *dept_p ;
</pre>
<p>Now we ALLOCATE the object pointer and retrieve our object from the table as before:</p>
<pre>EXEC SQL ALLOCATE :dept_p ;
EXEC SQL SELECT subdivision INTO :dept_p
   FROM division WHERE name = &#39;Research&#39; ;
</pre>
<p>Declare Pro*C/C++ variables to store the collection attribute information we want:</p>
<pre>int size ;
char type_name[9] ;
employees *emp_array ;
</pre>
<p>Allocate the collection descriptor, then use the navigational interface to get the collection attribute from the object:</p>
<pre>EXEC SQL ALLOCATE :emp_array ;
EXEC SQL OBJECT GET team FROM :dept_p INTO :emp_array ;
</pre>
<p>Finally, we can use the new COLLECTION DESCRIBE statement to extract the desired collection attribute information:</p>
<pre>EXEC SQL COLLECTION DESCRIBE :emp_array
   GET SIZE, TYPE_NAME INTO :size, :type_name ;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You are permitted to use host variable names that are the same as the desired collection attribute name, as in this example.</div>
<p>Because the type <code>employees</code> is a VARRAY of object employee, we can extract the type name.</p>
<p>After successful completion of the DESCRIBE, the value of <code>size</code> should be 2 (there are 2 elements, Albert and Alison, in this collection instance, Research). The <code>type_name</code> variable should read &#34;EMPLOYEE\0&#34; (it is a CHARZ by default).</p>
<p>Once we are finished with the SQL Descriptor and the object pointer we can FREE their resources:</p>
<pre>EXEC SQL FREE :emp_array ;
EXEC SQL FREE :dept_p ;
</pre>
<p>We have just illustrated that the DESCRIBE mechanism is used to extract useful information from a C Collection Descriptor about the underlying collection to which the descriptor refers.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4433" class="sect2"><a id="sthref2212"></a>
<h3 class="sect2"><a id="sthref2213"></a>RESET Example</h3>
<p>Now suppose that instead of giving just the employees in Development a raise, as in the GET and SET example, we give raises to everybody in the entire division.</p>
<p>We start off as before, including our example header file generated by the Object Type Translator. This time, however, we will be using a cursor to iterate through all departments in the division, one at a time:</p>
<pre>#include &lt;example.h&gt;
EXEC SQL DECLARE c CURSOR FOR SELECT subdivision FROM division ;
</pre>
<p>We will need some local variables to manipulate our data:</p>
<pre>department *dept_p ;
employees *emp_array ;
employee *emp_p ;
double salary ;
int size ;
</pre>
<p>Before we can use the object and collection variables, we must first initialize them by using this ALLOCATE statement:</p>
<pre>EXEC SQL ALLOCATE :emp_array ;
EXEC SQL ALLOCATE :emp_p ;
</pre>
<p>Now we are ready to use our cursor to iterate through all of the departments in the division:</p>
<pre>EXEC SQL OPEN c ;
EXEC SQL WHENEVER NOT FOUND DO break ;
while (TRUE)
    {
         EXEC SQL FETCH c INTO :dept_p ;
</pre>
<p>At this point, we have a department object. We need to use the Navigational Interface to extract the &#39;team&#39; VARRAY attribute from the department:</p>
<pre>         EXEC SQL OBJECT GET team FROM :dept_p INTO :emp_array ;
</pre>
<p>Before we can start referring to the collection, we need to guarantee that the slice endpoints are set to the beginning of the <span class="italic">current</span> collection instance (not the end of a previous instance) by use of the RESET statement:</p>
<pre>         EXEC SQL COLLECTION RESET :emp_array ;
</pre>
<p>Now we will iterate through all elements of the varray and update the salaries as we did before. The existing WHENEVER directive remains in effect for this loop as well:</p>
<pre>        while (TRUE)
           {
            EXEC SQL COLLECTION GET :emp_array INTO :emp_p ;
            EXEC SQL OBJECT GET salary FROM :emp_p INTO :salary ;
            salary += (salary * .05) ;
            EXEC SQL OBJECT SET salary OF :emp_p TO :salary ;
</pre>
<p>When we are finished, we&#39;ll update the collection attribute:</p>
<pre>            EXEC SQL COLLECTION SET :emp_array TO :emp_p ;
           }
</pre>
<p>As before, we need to update the column of the table that stores the object that contains the collection that we just finished modifying:</p>
<pre>        EXEC SQL UPDATE division SET subdivision = :dept_p ;
    }
</pre>
<p>Loop termination signifies the end of processing. We can now FREE all of our resources and COMMIT our work:</p>
<pre>EXEC SQL CLOSE c ;
EXEC SQL FREE :emp_p ;
EXEC SQL FREE :emp_array ;
EXEC SQL FREE :dept_p ;
EXEC SQL COMMIT WORK ;
</pre>
<p>This example demonstrates how it is possible to reuse an ALLOCATEd Collection Descriptor for different instances of the same collection type. The COLLECTION RESET statement ensures the slice endpoints are set back to the beginning of the <span class="italic">current</span> collection instance. They do not remain in their existing positions after being moved during the referencing of a previous collection instance.</p>
<p>By using the COLLECTION RESET statement in this fashion, application developers need not explicitly FREE and reALLOCATE a Collection Descriptor with each new instance of the same collection type.</p>
</div>
<!-- class="sect2" -->
<a id="i1004773"></a>
<div id="LNPCC4434" class="sect2">
<h3 class="sect2">Example Program:coldemo1.pc</h3>
<p>The following program, coldemo1.pc, is in the demo directory.<a id="sthref2214"></a></p>
<p>This example demonstrates three ways for the Pro*C client to navigate through collection-typed database columns. Although the examples presented use nested tables, they also apply to varrays.</p>
<p>Here is the SQL*Plus file, coldemo1.sql, that sets up the table using the inserts and data contained in calidata.sql:</p>
<pre>REM ************************************************************************
REM ** This is a SQL*Plus script to demonstrate collection manipulation
REM ** in Pro*C/C++.
REM ** Run this script before executing OTT for the coldemo1.pc program
REM ************************************************************************

connect scott/tiger;

set serveroutput on;

REM Make sure database has no old version of the table and types

DROP TABLE county_tbl;
DROP TYPE citytbl_t;
DROP TYPE city_t;

REM ABSTRACTION:
REM The counties table contains census information about each of the
REM counties in a particular U.S. state (California is used here).  
REM Each county has a name, and a collection of cities.  
REM Each city has a name and a population.

REM IMPLEMENTATION:
REM Our implementation follows this abstraction
REM Each city is implemented as a &#34;city&#34; OBJECT, and the
REM collection of cities in the county is implemented using 
REM a NESTED TABLE of &#34;city&#34; OBJECTS.

CREATE TYPE city_t AS OBJECT (name CHAR(30), population NUMBER);
/

CREATE TYPE citytbl_t AS TABLE OF city_t;
/

CREATE TABLE county_tbl (name CHAR(30), cities citytbl_t)
  NESTED TABLE cities STORE AS citytbl_t_tbl;

REM Load the counties table with data.  This example uses estimates of
REM California demographics from Janurary 1, 1996.

@calidata.sql;

REM Commit to save
COMMIT;
</pre>
<p>See the comments at the beginning of the following program for explanations of how to set up the table, and then the functionality demonstrated by this program.</p>
<pre>            /* ***************************************** */
            /*   Demo program for Collections in Pro*C   */
            /* ***************************************** */

/*****************************************************************************
 
   In SQL*Plus, run the SQL script coldemo1.sql to create:
     - 2 types: city_t (OBJECT) and citytbl_t (NESTED TABLE)
     - 1 relational table county_tbl which contains a citytbl_t nested table
  
   Next, run the Object Type Translator (OTT) to generate typedefs of C structs
   corresponding to the city_t and citytbl_t types in the databases:
     ott int=coldemo1.typ outt=out.typ hfile=coldemo1.h code=c user=scott/tiger
  
   Then, run the Pro*C/C++ Precompiler as follows:
     proc coldemo1 intype=out.typ
  
   Finally, link the generated code using the Pro*C Makefile:
     (Compiling and Linking applications is a platform dependent step).
  
 ****************************************************************************
 
   Scenario: 
     We consider the example of a database used to store census 
     information for the state of California.  The database has a table
     representing the counties of California.  Each county has a name 
     and a collection of cities.  Each city has a name and a population.

   Application Overview:
     This example demonstrates three ways for the Pro*C client to 
     navigate through collection-typed database columns.  Although the
     examples presented use nested tables, they also apply to varrays.
     Collections-specific functionality is demonstrated in three
     different functions, as described in the following section.
        
     PrintCounties shows examples of 
     * Declaring collection-typed host variables and arrays
     * Allocating and freeing collection-typed host variables
     * Using SQL to load a collection-typed host variable
     * Using indicators for collection-typed host variables
     * Using OCI to examine a collection-typed host variables

     PrintCounty shows examples of 
     * Binding a ref cursor host variable to a nested table column
     * Allocating and freeing a ref cursor
     * Using the SQL &#34;CURSOR&#34; clause

     CountyPopulation shows examples of 
     * Binding a &#34;DECLARED&#34; cursor to a nested table column
     * Using the SQL &#34;THE&#34; clause

****************************************************************************/

/* Include files */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlca.h&gt;                                /* SQL Communications Area */
#include &lt;coldemo1.h&gt;        /* OTT-generated header with C typedefs for the */
                                      /* database types city_t and citytbl_t */
#ifndef EXIT_SUCCESS
# define EXIT_SUCCESS   0
#endif
#ifndef EXIT_FAILURE
# define EXIT_FAILURE   1
#endif 

#define CITY_NAME_LEN    30
#define COUNTY_NAME_LEN  30
#define MAX_COUNTIES     60

/* Function prototypes */

#if defined(__STDC__)
 void OptionLoop( void );
 boolean GetCountyName( char *countyName );
 void PrintCounties( void );
 long CountyPopulation( CONST char *countyName );
 void PrintCounty( CONST char *countyName );
 void PrintSQLError( void );
 void PrintCountyHeader( CONST char *county );
 void PrintCity( city_t *city );
#else
 void OptionLoop();
 boolean GetCountyName(/*_ char *countyName _*/);
 void PrintCounties();
 long CountyPopulation(/*_ CONST char *countyName _*/);
 void PrintCounty(/*_ CONST char *countyName _*/);
 void PrintSQLError(/*_ void _*/);
 void PrintCountyHeader(/*_ CONST char *county _*/);
 void PrintCity(/*_ city_t *city _*/);
#endif

/* 
 * NAME
 *   main
 * COLLECTION FEATURES
 *   none
 */
int main()
{
  char * uid = &#34;scott/tiger&#34;;
  
  EXEC SQL WHENEVER SQLERROR DO PrintSQLError();

  printf(&#34;\nPro*Census: Release California - Jan 1 1996.\n&#34;);
  EXEC SQL CONNECT :uid;
  
  OptionLoop();

  printf(&#34;\nGoodbye\n\n&#34;);
  EXEC SQL ROLLBACK RELEASE;
  return(EXIT_SUCCESS);
}

/* 
 * NAME
 *   OptionLoop
 * DESCRIPTION
 *   A command dispatch routine.
 * COLLECTION FEATURES
 *   none
 */
void OptionLoop()
{
  char choice[30];
  boolean done = FALSE;
  char countyName[COUNTY_NAME_LEN + 1];

  while (!done)
  {
    printf(&#34;\nPro*Census options:\n&#34;);
    printf(&#34;\tlist information for (A)ll counties\n&#34;);
    printf(&#34;\tlist information for one (C)ounty\n&#34;);
    printf(&#34;\tlist (P)opulation total for one county\n&#34;);
    printf(&#34;\t(Q)uit\n&#34;);
    printf(&#34;Choice? &#34;);

    fgets(choice, 30, stdin);
    switch(toupper(choice[0]))
    {
    case &#39;A&#39;:
      PrintCounties();
      break;
    case &#39;C&#39;:
      if (GetCountyName(countyName)) 
        PrintCounty(countyName);
      break;
    case &#39;P&#39;:
      if (GetCountyName(countyName)) 
        printf(&#34;\nPopulation for %s county: %ld\n&#34;, 
               countyName, CountyPopulation(countyName));
      break;
    case &#39;Q&#39;:
      done = TRUE;
      break;
    default:
      break;
    }
  }
}


/* 
 * NAME
 *   GetCountyName
 * DESCRIPTION
 *   Fills the passed buffer with a client-supplied county name.
 *   Returns TRUE if the county is in the database, and FALSE otherwise.
 * COLLECTION FEATURES
 *   none
 */
boolean GetCountyName(countyName)
  char *countyName;
{
  int   count;
  int   i;

  printf(&#34;County name? &#34;);
  fgets(countyName, COUNTY_NAME_LEN + 1, stdin);

  /* Convert the name to uppercase and remove the trailing &#39;\n&#39; */
  for (i = 0; countyName[i] != &#39;\0&#39;; i++)
    {
      countyName[i] = (char)toupper(countyName[i]);
      if (countyName[i] == &#39;\n&#39;) countyName[i] = &#39;\0&#39;;
    }

  EXEC SQL SELECT COUNT(*) INTO :count 
    FROM county_tbl WHERE name = :countyName;

  if (count != 1)
    {
      printf(&#34;\nUnable to find %s county.\n&#34;, countyName);
      return FALSE;
    }
  else
    return TRUE;
}


/* 
 * NAME
 *   PrintCounties
 * DESCRIPTION
 *   Prints the population and name of each city of every county 
 *   in the database.
 * COLLECTION FEATURES
 *   The following features correspond to the inline commented numbers
 *   1) Host variables for collection-typed objects are declared using 
 *      OTT-generated types.  Both array and scalar declarations are allowed.
 *      Scalar declarations must be of type pointer-to-collection-type, and
 *      array declarations must of type array-of-pointer-to-collection-type.
 *   2) SQL ALLOCATE should be used to allocate space for the collection.
 *      SQL FREE should be used to free the memory once the collection is
 *      no longer needed.  The host variable being allocated or free&#39;d 
 *      can be either array or scalar.
 *   3) SQL is used to load into or store from collection-typed host variables
 *      and arrays.  No special syntax is needed.
 *   4) The type of an indicator variable for a collection is OCIInd.
 *      An indicators for a collections is declared and used just like
 *      an indicator for an int or string.
 *   5) The COLLECTION GET Interface is used to access and manipulate the
 *      contents of collection-typed host variables.  Each member of the
 *      collection used here has type city_t, as generated by OTT.
 */
void PrintCounties()
{
  citytbl_t *cityTable[MAX_COUNTIES];                                 /* 1 */
  OCIInd     cityInd[MAX_COUNTIES];                                   /* 4 */
  char       county[MAX_COUNTIES][COUNTY_NAME_LEN + 1];
  int        i, numCounties;
  city_t    *city;

  EXEC SQL ALLOCATE :cityTable;                                       /* 2 */
  EXEC SQL ALLOCATE :city;
  
  EXEC SQL SELECT name, cities
    INTO :county, :cityTable:cityInd FROM county_tbl;              /* 3, 4 */

  numCounties = sqlca.sqlerrd[2];

  for (i = 0; i &lt; numCounties; i++) 
  {
    if (cityInd[i] == OCI_IND_NULL)                                   /* 4 */
      {
        printf(&#34;Unexpected NULL city table for %s county\n&#34;, county[i]);
      }
    else
      {                                                               /* 5 */
        PrintCountyHeader(county[i]);
        EXEC SQL WHENEVER NOT FOUND DO break;
        while (TRUE)
          {
            EXEC SQL COLLECTION GET :cityTable[i] INTO :city;
            PrintCity(city);
          }
        EXEC SQL WHENEVER NOT FOUND CONTINUE;
      }
  }

  EXEC SQL FREE :city;
  EXEC SQL FREE :cityTable;                                           /* 2 */
}


/* 
 * NAME
 *   PrintCountyHeader
 * COLLECTION FEATURES
 *   none
 */
void PrintCountyHeader(county)
  CONST char *county;
{
  printf(&#34;\nCOUNTY: %s\n&#34;, county);
}

/* 
 * NAME
 *   PrintCity
 * COLLECTION FEATURES
 *   none
 */
void PrintCity(city)
  city_t *city;
{
  varchar newCITY[CITY_NAME_LEN];
  int newPOP;

  EXEC SQL OBJECT GET NAME, POPULATION from :city INTO :newCITY, :newPOP;
  printf(&#34;CITY: %.*s POP: %d\n&#34;, CITY_NAME_LEN, newCITY.arr, newPOP);
}

/* 
 * NAME
 *   PrintCounty
 * DESCRIPTION
 *   Prints the population and name of each city in a particular county.
 * COLLECTION FEATURES
 *   The following features correspond to the inline commented numbers
 *   1) A ref cursor host variable may be used to scroll through the 
 *      rows of a collection. 
 *   2) Use SQL ALLOCATE/FREE to create and destroy the ref cursor.
 *   3) The &#34;CURSOR&#34; clause in SQL can be used to load a ref cursor 
 *      host variable.  In such a case, the SELECT ... INTO does an
 *      implicit &#34;OPEN&#34; of the ref cursor.
 * IMPLEMENTATION NOTES 
 *   In the case of SQL SELECT statements which contain an embedded 
 *   CURSOR(...) clause, the Pro*C &#34;select_error&#34; flag must be &#34;no&#34;
 *   to prevent cancellation of the parent cursor.
 */
void PrintCounty(countyName)
  CONST char *countyName;
{
  sql_cursor cityCursor;                                              /* 1 */
  city_t *city;

  EXEC SQL ALLOCATE :cityCursor;                                      /* 2 */
  EXEC SQL ALLOCATE :city;                                        
  
  EXEC ORACLE OPTION(select_error=no);
  EXEC SQL SELECT 
    CURSOR(SELECT VALUE(c) FROM TABLE(county_tbl.cities) c)
      INTO :cityCursor 
      FROM county_tbl
      WHERE county_tbl.name = :countyName;                            /* 3 */
  EXEC ORACLE OPTION(select_error=yes);
  
  PrintCountyHeader(countyName);

  EXEC SQL WHENEVER NOT FOUND DO break;
  while (TRUE)
    {
      EXEC SQL FETCH :cityCursor INTO :city;
      PrintCity(city);
    }
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL CLOSE :cityCursor;

  EXEC SQL FREE :cityCursor;                                         /* 2 */
  EXEC SQL FREE :city; 
}


/* 
 * NAME
 *   CountyPopulation
 * DESCRIPTION
 *   Returns the number of people living in a particular county.
 * COLLECTION FEATURES
 *   The following features correspond to the inline commented numbers
 *   1) A &#34;DECLARED&#34; cursor may be used to scroll through the 
 *      rows of a collection. 
 *   2) The &#34;THE&#34; clause in SQL is used to convert a single nested-table
 *      column into a table.
 */
long CountyPopulation(countyName)
  CONST char *countyName;
{
  long population;
  long populationTotal = 0;

  EXEC SQL DECLARE cityCursor CURSOR FOR
    SELECT c.population 
    FROM THE(SELECT cities FROM county_tbl 
              WHERE name = :countyName) AS c;                     /* 1, 2 */

  EXEC SQL OPEN cityCursor;

  EXEC SQL WHENEVER NOT FOUND DO break;
  while (TRUE)
    {
      EXEC SQL FETCH cityCursor INTO :population;
      populationTotal += population;
    }
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL CLOSE cityCursor;
  return populationTotal;
}


/* 
 * NAME
 *   PrintSQLError
 * DESCRIPTION
 *   Prints an error message using info in sqlca and calls exit.
 * COLLECTION FEATURES
 *   none
 */ 
void PrintSQLError()
{
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  printf(&#34;SQL error occurred...\n&#34;);
  printf(&#34;%.*s\n&#34;, (int)sqlca.sqlerrm.sqlerrml,
         (CONST char *)sqlca.sqlerrm.sqlerrmc);
  EXEC SQL ROLLBACK RELEASE;
  exit(EXIT_FAILURE);
}
           
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_17obj.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_19ott.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>