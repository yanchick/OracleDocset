<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78008"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Host%20Arrays"></a><title>Host Arrays</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:39Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_07pls.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_09err.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/35</span> <!-- End Header -->
<div id="LNPCC3433" class="chapter"><a id="g20885"></a>
<h1 class="chapter"><span class="secnum">8</span> Host Arrays</h1>
<p><a id="sthref1031"></a>This chapter looks at using arrays to simplify coding and improve program performance. You will learn how to manipulate Oracle data using arrays, how to operate on all the elements of an array with a single SQL statement, and how to limit the number of array elements processed. The chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i1748">Why Use Arrays?</a></p>
</li>
<li>
<p><a href="#i1752">Declaring Host Arrays</a></p>
</li>
<li>
<p><a href="#i1756">Using Arrays in SQL Statements</a></p>
</li>
<li>
<p><a href="#i1869">Selecting into Arrays</a></p>
</li>
<li>
<p><a href="#i1874">Inserting with Arrays</a></p>
</li>
<li>
<p><a href="#i1879">Updating with Arrays</a></p>
</li>
<li>
<p><a href="#i13737">Deleting with Arrays</a></p>
</li>
<li>
<p><a href="#i1775">Using the FOR Clause</a></p>
</li>
<li>
<p><a href="#i1770">Using the WHERE Clause</a></p>
</li>
<li>
<p><a href="#i2257">Arrays of Structs</a></p>
</li>
<li>
<p><a href="#i1776">Mimicking CURRENT OF</a></p>
</li>
<li>
<p><a href="#i5620">Using sqlca.sqlerrd[2]</a></p>
</li>
<li>
<p><a href="#BGBDJCBA">Using Additional Array Insert/Select Syntax</a></p>
</li>
<li>
<p><a href="#CHDEFGAC">Using Implicit Buffered Insert</a></p>
</li>
</ul>
<a id="i1748"></a>
<div id="LNPCC3434" class="sect1">
<h2 class="sect1">Why Use Arrays?</h2>
<p>Arrays reduce programming time and result in improved performance.<a id="sthref1032"></a></p>
<p>With arrays, you manipulate an entire array with a single SQL statement. Thus, Oracle communication overhead is reduced markedly, especially in a networked environment. A major portion of runtime is spent on network round trips between the client program and the server database. Arrays reduce the round trips.</p>
<p>For example, suppose you want to insert information about 300 employees into the EMP table. Without arrays your program must do 300 individual INSERTs&mdash;one for each employee. With arrays, only one INSERT needs to be done.</p>
</div>
<!-- class="sect1" -->
<a id="i1752"></a>
<div id="LNPCC3435" class="sect1">
<h2 class="sect1">Declaring Host Arrays</h2>
<p>The following example declares three host arrays, each with a maximum of 50 elements:<a id="sthref1033"></a><a id="sthref1034"></a><a id="sthref1035"></a><a id="sthref1036"></a></p>
<pre>char  emp_name[50][10]; 
int   emp_number[50]; 
float salary[50]; 
</pre>
<p>Arrays of VARCHARs are also allowed. The following declaration is a valid host language declaration: <a id="sthref1037"></a></p>
<pre>VARCHAR v_array[10][30];
</pre>
<div id="LNPCC3436" class="sect2"><a id="sthref1038"></a>
<h3 class="sect2">Restrictions</h3>
<p>You cannot declare host arrays of pointers, except for object types. <a id="sthref1039"></a></p>
<p>Except for character arrays (strings), host arrays that might be referenced in a SQL statement are limited to one dimension. So, the two-dimensional array declared in the following example is <span class="italic">invalid</span>:<a id="sthref1040"></a><a id="sthref1041"></a></p>
<pre>int hi_lo_scores[25][25];   /* not allowed */ 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3437" class="sect2"><a id="sthref1042"></a>
<h3 class="sect2">Maximum Size of Arrays</h3>
<p>The maximum number of array elements in a SQL statement that is accessible in one fetch is 32K (or possibly greater, depending on the platform and the available memory). If you try to access a number that exceeds the maximum, you get a &#34;parameter out of range&#34; runtime error. If the statement is an anonymous PL/SQL block, the number of array elements accessible is limited to 32512 divided by the size of the datatype.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1756"></a>
<div id="LNPCC3438" class="sect1">
<h2 class="sect1">Using Arrays in SQL Statements</h2>
<p>You can use host arrays as input variables in the INSERT, UPDATE, and DELETE statements and as output variables in the INTO clause of SELECT and FETCH statements. <a id="sthref1043"></a> <a id="sthref1044"></a></p>
<p>The embedded SQL syntax used for host arrays and simple host variables is nearly the same. One difference is the optional FOR clause, which lets you control array processing. Also, there are restrictions on mixing host arrays and simple host variables in a SQL statement.</p>
<p>The following sections illustrate the use of host arrays in data manipulation statements.</p>
<div id="LNPCC3439" class="sect2"><a id="sthref1045"></a>
<h3 class="sect2">Referencing Host Arrays</h3>
<p>If you use multiple host arrays in a single SQL statement, their number of elements should be the same. Otherwise, an &#34;array size mismatch&#34; warning message is issued at precompile time. If you ignore this warning, the precompiler uses the <span class="italic">smallest</span> number of elements for the SQL operation.<a id="sthref1046"></a></p>
<p>In this example, only 25 rows are <a id="sthref1047"></a><a id="sthref1048"></a>Inserted<a id="sthref1049"></a></p>
<pre>int    emp_number[50]; 
char   emp_name[50][10]; 
int    dept_number[25]; 
/* Populate host arrays here. */ 

EXEC SQL INSERT INTO emp (empno, ename, deptno) 
    VALUES (:emp_number, :emp_name, :dept_number);
 
</pre>
<p>It is possible to subscript host arrays in SQL statements, and use them in a loop to INSERT or fetch data. For example, you could INSERT every fifth element in an array using a loop such as:</p>
<pre>for (i = 0; i &lt; 50; i += 5) 
    EXEC SQL INSERT INTO emp (empno, deptno) 
        VALUES (:emp_number[i], :dept_number[i]);
</pre>
<p>However, if the array elements that you need to process are contiguous, you should not process host arrays in a loop. Simply use the non-scripted array names in your SQL statement. Oracle treats a SQL statement containing host arrays of element number <span class="italic">n</span> like the same statement executed <span class="italic">n</span> times with <span class="italic">n</span> different scalar variables.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3440" class="sect2"><a id="sthref1050"></a>
<h3 class="sect2"><a id="sthref1051"></a>Using Indicator Arrays</h3>
<p>You can use indicator arrays to assign NULLs to input host arrays, and to detect NULL or truncated values (character columns only) in output host arrays. The following example shows how to INSERT with indicator arrays:<a id="sthref1052"></a><a id="sthref1053"></a></p>
<pre>int    emp_number[50]; 
int    dept_number[50]; 
float  commission[50]; 
short  comm_ind[50];       /* indicator array */ 

/* Populate the host and indicator arrays.  To insert a null 
   into the comm column, assign -1 to the appropriate 
   element in the indicator array. */ 
    EXEC SQL INSERT INTO emp (empno, deptno, comm) 
        VALUES (:emp_number, :dept_number, 
        :commission INDICATOR :comm_ind); 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3441" class="sect2"><a id="sthref1054"></a>
<h3 class="sect2">Oracle Restrictions</h3>
<p>Mixing scalar host variables with host arrays in the VALUES, SET, INTO, or WHERE clause is <span class="italic">not</span> allowed. If any of the host variables is an array, all must be arrays.<a id="sthref1055"></a><a id="sthref1056"></a></p>
<p>You cannot use host arrays with the <a id="sthref1057"></a><a id="sthref1058"></a>CURRENT OF clause in an UPDATE or DELETE statement.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3442" class="sect2"><a id="sthref1059"></a>
<h3 class="sect2">ANSI Restriction and Requirements</h3>
<p>The array interface is an Oracle extension to the ANSI/ISO embedded SQL standard. However, when you precompile with MODE=ANSI, array SELECTs and FETCHes are still allowed. The use of arrays can be flagged using the FIPS flagger precompiler option, if desired. <a id="sthref1060"></a></p>
<p>When doing array SELECTs and FETCHes, always use indicator arrays. That way, you can test for NULLs in the associated output host array.</p>
<p>If <code>DBMS=V7</code> or <code>DBMS=v8</code> and you <code>SELECT</code> or <code>FETCH</code> a <code>NULL</code> column value into a host array that is not associated with an indicator array, then Oracle stops processing, sets <code>sqlerrd[2]</code> to the number of rows processed, and returns an error message. When <code>DBMS=V7</code> or <code>DBMS=v8</code>, Oracle does not consider truncation to be an error.</p>
<p>Also, if your <code>SELECT</code> or <code>FETCH</code> results in any warning such as <code>ORA-24347</code> due to usage of <code>NULL</code>, and if any column does not have an indicator array, Oracle stops processing.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<p>Use indicator variables for all the columns in the <code>SELECT</code> or <code>FETCH</code>. If all columns do not have indicators, then the precompiler option <code>unsafe_null=yes</code> can be used as an alternative.</p>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1869"></a>
<div id="LNPCC3443" class="sect1">
<h2 class="sect1">Selecting into Arrays</h2>
<p>You can use host arrays as output variables in the SELECT statement. If you know the maximum number of rows the SELECT will return, simply declare the host arrays with that number of elements. In the following example, you select directly into three host arrays. Knowing the SELECT will return no more than 50 rows, you declare the arrays with 50 elements: <a id="sthref1061"></a> <a id="sthref1062"></a></p>
<pre>char   emp_name[50][20]; 
int    emp_number[50]; 
float  salary[50]; 
 
EXEC SQL SELECT ENAME, EMPNO, SAL 
    INTO :emp_name, :emp_number, :salary 
    FROM EMP 
    WHERE SAL &gt; 1000; 
</pre>
<p>In the preceding example, the SELECT statement returns up to 50 rows. If there are fewer than 50 eligible rows or you want to retrieve only 50 rows, this method will suffice. However, if there are more than 50 eligible rows, you cannot retrieve all of them this way. If you reexecute the SELECT statement, it just returns the first 50 rows again, even if more are eligible. You must either declare a larger array or declare a cursor for use with the FETCH statement.</p>
<p>If a SELECT INTO statement returns more rows than the number of elements you declared, Oracle issues an error message unless you specify SELECT_ERROR=NO.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#i5749">&#34;Precompiler Options&#34;</a> for more information about the SELECT_ERROR option, see the section</div>
<div id="LNPCC3444" class="sect2"><a id="sthref1063"></a>
<h3 class="sect2">Cursor Fetches</h3>
<p>If you do not know the maximum number of rows a SELECT will return, you can declare and open a cursor, then fetch from it in &#34;batches.&#34;</p>
<p>Batch fetches within a loop let you retrieve a large number of rows with ease. Each FETCH returns the next batch of rows from the current active set. In the following example, you fetch in 20-row batches: <a id="sthref1064"></a><a id="sthref1065"></a><a id="sthref1066"></a><a id="sthref1067"></a></p>
<pre> 
int   emp_number[20]; 
float salary[20]; 
 
EXEC SQL DECLARE emp_cursor CURSOR FOR 
    SELECT empno, sal FROM emp; 
 
EXEC SQL OPEN emp_cursor; 
 
EXEC SQL WHENEVER NOT FOUND do break; 
for (;;) 
{ 
    EXEC SQL FETCH emp_cursor 
        INTO :emp_number, :salary; 
    /* process batch of rows */ 
    ... 
} 
...
</pre>
<p>Do not forget to check how many rows were actually returned in the last fetch, and process them.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i5521">&#34;Number of Rows Fetched&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i5620"></a>
<div id="LNPCC3445" class="sect2">
<h3 class="sect2">Using sqlca.sqlerrd[2]</h3>
<p>For INSERT, UPDATE, DELETE, and SELECT INTO statements, <code>sqlca.sqlerrd[2]</code> records the number of rows processed. For FETCH statements, it records the cumulative sum of rows processed.<a id="sthref1068"></a></p>
<p>When using host arrays with FETCH, to find the number of rows returned by the most recent iteration, subtract the current value of <code>sqlca.sqlerrd[2]</code> from its previous value (stored in another variable). In the following example, you determine the number of rows returned by the most recent fetch:</p>
<pre>int  emp_number[100]; 
char emp_name[100][20]; 
 
int rows_to_fetch, rows_before, rows_this_time; 
EXEC SQL DECLARE emp_cursor CURSOR FOR 
    SELECT empno, ename 
    FROM emp 
    WHERE deptno = 30; 
EXEC SQL OPEN emp_cursor; 
EXEC SQL WHENEVER NOT FOUND CONTINUE; 
/* initialize loop variables */ 
rows_to_fetch = 20;   /* number of rows in each &#34;batch&#34; */ 
rows_before = 0;      /* previous value of sqlerrd[2]  */ 
rows_this_time = 20; 
 
while (rows_this_time == rows_to_fetch) 
{ 
    EXEC SQL FOR :rows_to_fetch 
    FETCH emp_cursor 
        INTO :emp_number, :emp_name; 
    rows_this_time = sqlca.sqlerrd[2] - rows_before; 
    rows_before = sqlca.sqlerrd[2]; 
} 
... 
</pre>
<p><code>sqlca.sqlerrd[2]</code> is also useful when an error occurs during an array operation. Processing stops at the row that caused the error, so <code>sqlerrd[2]</code> gives the number of rows processed successfully.</p>
</div>
<!-- class="sect2" -->
<a id="i5521"></a>
<div id="LNPCC3446" class="sect2">
<h3 class="sect2">Number of Rows Fetched</h3>
<p>Each FETCH returns, at most, the total number of rows in the array. Fewer rows are returned in the following cases:<a id="sthref1069"></a></p>
<ul>
<li>
<p>The end of the active set is reached. The &#34;no data found&#34; Oracle error code is returned to SQLCODE in the SQLCA. For example, this happens if you fetch into an array of number of elements 100 but only 20 rows are returned.</p>
</li>
<li>
<p>Fewer than a full batch of rows remain to be fetched. For example, this happens if you fetch 70 rows into an array of 20 number elements because after the third FETCH, only 10 rows remain to be fetched.</p>
</li>
<li>
<p>An error is detected while processing a row. The FETCH fails and the applicable Oracle error code is returned to SQLCODE.</p>
</li>
</ul>
<p>The cumulative number of rows returned can be found in the third element of <span class="italic">sqlerrd</span> in the SQLCA, called <code>sqlerrd[2]</code> in this guide. This applies to each open cursor. In the following example, notice how the status of each cursor is maintained separately:<a id="sthref1070"></a></p>
<pre>EXEC SQL OPEN cursor1; 
EXEC SQL OPEN cursor2; 
EXEC SQL FETCH cursor1 INTO :array_of_20; 
/* now running total in sqlerrd[2] is 20 */ 
EXEC SQL FETCH cursor2 INTO :array_of_30; 
/* now running total in sqlerrd[2] is 30, not 50 */ 
EXEC SQL FETCH cursor1 INTO :array_of_20; 
/* now running total in sqlerrd[2] is 40 (20 + 20) */ 
EXEC SQL FETCH cursor2 INTO :array_of_30; 
/* now running total in sqlerrd[2] is 60 (30 + 30) */
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3447" class="sect2"><a id="sthref1071"></a>
<h3 class="sect2">Scrollable Cursor Fetches</h3>
<p>You can also use host arrays with scrollable cursors. With scrollable cursors <code>sqlca.sqlerrd[2]</code> represents the maximum (absolute) row number processed. Since an application can arbitrarily position the fetches in scrollable mode, it need not be the total number of rows processed.</p>
<p>While using host arrays with the FETCH statement in scrollable mode, you cannot subtract the current value of <code>sqlca.sqlerrd[2]</code> from its previous value to find the number of rows returned by the most recent iteration. The application program determines the total number of rows in the result set by executing a FETCH LAST. The value of <code>sqlca.sqlerrd[2]</code> provides the total number of rows in the result set. Refer to <a href="#i7463">&#34;Sample Program: Host Arrays Using Scrollable Cursor&#34;</a> for an example illustrating the use of host arrays with scrollable cursors</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3448" class="sect2"><a id="sthref1072"></a>
<h3 class="sect2">Sample Program 3: Host Arrays <a id="sthref1073"></a></h3>
<p>The demonstration program in this section shows how you can use host arrays when writing a query in Pro*C/C++. Pay particular attention to the use of the &#34;rows processed count&#34; in the SQLCA (<code>sqlca.sqlerrd[2]</code>). This program is available on-line in the file <code>sample3.pc</code> in your <code>demo</code> directory.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_09err.htm#g35612">&#34;Handling Runtime Errors&#34;</a> for more information about the SQLCA</div>
<pre>/*
 *  sample3.pc
 *  Host Arrays
 *
 *  This program connects to ORACLE, declares and opens a cursor,
 *  fetches in batches using arrays, and prints the results using
 *  the function print_rows().
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;sqlca.h&gt;

#define NAME_LENGTH   20
#define ARRAY_LENGTH   5
/* Another way to connect. */
char *username = &#34;SCOTT&#34;;
char *password = &#34;TIGER&#34;;

/* Declare a host structure tag. */
struct
{
    int    emp_number[ARRAY_LENGTH];
    char   emp_name[ARRAY_LENGTH][NAME_LENGTH];
    float  salary[ARRAY_LENGTH];
} emp_rec;

/* Declare this program&#39;s functions. */
void print_rows();              /* produces program output */
void sql_error();          /* handles unrecoverable errors */


main()
{
    int  num_ret;               /* number of rows returned */
  
/* Connect to ORACLE. */
    EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;Connect error:&#34;);

    EXEC SQL CONNECT :username IDENTIFIED BY :password;
    printf(&#34;\nConnected to ORACLE as user: %s\n&#34;, username);


    EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;Oracle error:&#34;);
/* Declare a cursor for the FETCH. */
    EXEC SQL DECLARE c1 CURSOR FOR
        SELECT empno, ename, sal FROM emp;

    EXEC SQL OPEN c1;

/* Initialize the number of rows. */
    num_ret = 0;

/* Array fetch loop - ends when NOT FOUND becomes true. */
    EXEC SQL WHENEVER NOT FOUND DO break;

    for (;;)
    {
        EXEC SQL FETCH c1 INTO :emp_rec;

/* Print however many rows were returned. */
        print_rows(sqlca.sqlerrd[2] - num_ret);
        num_ret = sqlca.sqlerrd[2];        /* Reset the number. */
    }
/* Print remaining rows from last fetch, if any. */
    if ((sqlca.sqlerrd[2] - num_ret) &gt; 0)
        print_rows(sqlca.sqlerrd[2] - num_ret);

    EXEC SQL CLOSE c1;
    printf(&#34;\nAu revoir.\n\n\n&#34;);

/* Disconnect from the database. */
    EXEC SQL COMMIT WORK RELEASE;
    exit(0);
}


void
print_rows(n)
int n;
{
    int i;

    printf(&#34;\nNumber   Employee         Salary&#34;);
    printf(&#34;\n------   --------         ------\n&#34;);

    for (i = 0; i &lt; n; i++)
        printf(&#34;%-9d%-15.15s%9.2f\n&#34;, emp_rec.emp_number[i],
               emp_rec.emp_name[i], emp_rec.salary[i]);

}


void
sql_error(msg)
char *msg;
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;

    printf(&#34;\n%s&#34;, msg);
    printf(&#34;\n% .70s \n&#34;, sqlca.sqlerrm.sqlerrmc);

    EXEC SQL ROLLBACK WORK RELEASE;
    exit(1);
}
</pre></div>
<!-- class="sect2" -->
<a id="i7463"></a>
<div id="LNPCC3449" class="sect2">
<h3 class="sect2">Sample Program: Host Arrays Using Scrollable Cursor</h3>
<p>This program describes how to use host arrays with scrollable cursors. This program is available on-line in the file <code>scdemo2.pc</code> in your demo directory.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Note that we do a FETCH LAST to determine the number of rows in the result set.</div>
<div id="LNPCC3450" class="sect3"><a id="sthref1074"></a>
<h4 class="sect3">scdemo2.pc</h4>
<pre>/*
 *  A Sample program to demonstrate the use of scrollable 
 *  cursors with host arrays.
 * 
 *  This program uses the hr/hr schema.Make sure
 *  that this schema exists before executing this program
 */


#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlca.h&gt;

#define ARRAY_LENGTH   4

/* user and passwd */
char *username = &#34;hr&#34;;
char *password = &#34;hr&#34;;

/* Declare a host structure tag. */
struct emp_rec_array
{
    int    emp_number;
    char   emp_name[20];
    float  salary;
} emp_rec[ARRAY_LENGTH];


/* Print the result of the query */

void print_rows()
{
    int i;

    for (i=0; i&lt;ARRAY_LENGTH; i++)
        printf(&#34;%d    %s  %8.2f\n&#34;, emp_rec[i].emp_number,
             emp_rec[i].emp_name, emp_rec[i].salary);

}

/*  Oracle error handler */

void sql_error(char *msg)
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;

    printf(&#34;\n%s&#34;, msg);
    printf(&#34;\n% .70s \n&#34;, sqlca.sqlerrm.sqlerrmc);

    EXEC SQL ROLLBACK WORK RELEASE;
    exit(EXIT_FAILURE);
}

void main()
{
    int noOfRows; /* Number of rows in the result set */

    /* Error handler */
    EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;Connect error:&#34;);

    /* Connect to the data base */
    EXEC SQL CONNECT :username IDENTIFIED BY :password;

    /* Error handle */
    EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;Oracle error:&#34;);

    /* declare the cursor in scrollable mode */
    EXEC SQL DECLARE c1 SCROLL CURSOR FOR
        SELECT employee_id, first_name, salary FROM employees;

    EXEC SQL OPEN c1;

    EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;Fetch Error:&#34;);

    /* This is a dummy fetch to find out the number of rows
       in the result set */
    EXEC SQL FETCH LAST c1 INTO :emp_rec;

    /* The number of rows in the result set is given by 
       the value of sqlca.sqlerrd[2] */

    noOfRows = sqlca. sqlerrd[2];
    printf(&#34;Total number of rows in the result set %d:\n&#34;, 
             noOfRows);

    /* Fetch the first ARRAY_LENGTH number of rows */
    EXEC SQL FETCH FIRST c1 INTO :emp_rec;
    printf(&#34;******************** DEFAULT : \n&#34;);
    print_rows();

    /* Fetch the next set of ARRAY_LENGTH rows */
    EXEC SQL FETCH NEXT c1 INTO :emp_rec;
    printf(&#34;******************** NEXT  : \n&#34;);
    print_rows();

    /* Fetch a set of ARRAY_LENGTH rows from the 3rd row onwards */
    EXEC SQL FETCH ABSOLUTE 3 c1 INTO :emp_rec;
    printf(&#34;******************** ABSOLUTE 3 : \n&#34;);
    print_rows();

    /* Fetch the current ARRAY_LENGTH set of rows */
    EXEC SQL FETCH CURRENT c1 INTO :emp_rec;
    printf(&#34;******************** CURRENT : \n&#34;);
    print_rows();

    /* Fetch a set of ARRAY_LENGTH rows from the 2nd offset
       from the current cursor position */
    EXEC SQL FETCH RELATIVE 2 c1 INTO :emp_rec;
    printf(&#34;******************** RELATIVE 2 : \n&#34;);
    print_rows();

    /* Again Fetch the first ARRAY_LENGTH number of rows */
    EXEC SQL FETCH ABSOLUTE 0 c1 INTO :emp_rec;
    printf(&#34;******************** ABSOLUTE 0 : \n&#34;);
    print_rows();

    /* close the cursor */
    EXEC SQL CLOSE c1;

/* Disconnect from the database. */
    EXEC SQL COMMIT WORK RELEASE;
    exit(EXIT_SUCCESS);
}
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3451" class="sect2"><a id="sthref1075"></a>
<h3 class="sect2">Host Array Restrictions</h3>
<p>Using host arrays in the WHERE clause of a SELECT statement is <span class="italic">not</span> allowed except in a subquery. For an example, see <a href="#i1770">&#34;Using the WHERE Clause&#34;</a>.</p>
<p>Also, you cannot mix simple host variables with host arrays in the INTO clause of a SELECT or FETCH statement. If any of the host variables is an array, all must be arrays. <a id="sthref1076"></a> <a id="sthref1077"></a></p>
<p><a href="#g14498">Table 8-1</a> shows which uses of host arrays are valid in a SELECT INTO statement:</p>
<div id="LNPCC3452" class="tblformal">
<p class="titleintable"><a id="sthref1078"></a><a id="g14498"></a>Table 8-1 Valid Host Arrays for SELECT INTO</p>
<table class="cellalignment831" title="Valid Host Arrays for SELECT INTO" summary="Valid Arrays for SELECT INTO" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t7">INTO Clause</th>
<th class="cellalignment832" id="r1c2-t7">WHERE Clause</th>
<th class="cellalignment832" id="r1c3-t7">Valid?</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t7" headers="r1c1-t7">
<p>array</p>
</td>
<td class="cellalignment833" headers="r2c1-t7 r1c2-t7">
<p>array</p>
</td>
<td class="cellalignment833" headers="r2c1-t7 r1c3-t7">
<p>no</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t7" headers="r1c1-t7">
<p>scalar</p>
</td>
<td class="cellalignment833" headers="r3c1-t7 r1c2-t7">
<p>scalar</p>
</td>
<td class="cellalignment833" headers="r3c1-t7 r1c3-t7">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t7" headers="r1c1-t7">
<p>array</p>
</td>
<td class="cellalignment833" headers="r4c1-t7 r1c2-t7">
<p>scalar</p>
</td>
<td class="cellalignment833" headers="r4c1-t7 r1c3-t7">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t7" headers="r1c1-t7">
<p>scalar</p>
</td>
<td class="cellalignment833" headers="r5c1-t7 r1c2-t7">
<p>array</p>
</td>
<td class="cellalignment833" headers="r5c1-t7 r1c3-t7">
<p>no</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNPCC3453" class="sect2"><a id="sthref1079"></a>
<h3 class="sect2">Fetching NULLs</h3>
<p>When doing array SELECTs and FETCHes, always use indicator arrays. That way, you can test for NULLs in the associated output host array.</p>
<p>When DBMS = V7 or DBMS=v8, if you SELECT or FETCH a NULL column value into a host array that is not associated with an indicator array, Oracle stops processing, sets <code>sqlerrd[2]</code> to the number of rows processed, and issues an error message.</p>
<p>Also, if your SELECT or FETCH results in any warning such as <span class="italic">ORA-24347</span> due to usage of NULL, and if any column does not have an indicator array, Oracle stops processing. Use indicator variables in all the columns in the SELECT or FETCH.If all columns do not have indicators, the precompiler option <code>unsafe_null=yes</code> could be used as an alternative.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3454" class="sect2"><a id="sthref1080"></a>
<h3 class="sect2">Fetching Truncated Values</h3>
<p>When DBMS=V7, truncation results in a warning message, but Oracle continues processing.</p>
<p>Again, when doing array SELECTs and FETCHes, always use indicator arrays. That way, if Oracle assigns one or more truncated column values to an output host array, you can find the original lengths of the column values in the associated indicator array.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1874"></a>
<div id="LNPCC3455" class="sect1">
<h2 class="sect1">Inserting with Arrays</h2>
<p>You can use host arrays as input variables in an INSERT statement. Just make sure your program populates the arrays with data before executing the INSERT statement.</p>
<p>If some elements in the arrays are irrelevant, you can use the FOR clause to control the number of rows inserted. See also <a href="#i1775">&#34;Using the FOR Clause&#34;</a>.<a id="sthref1081"></a><a id="sthref1082"></a></p>
<p>An example of inserting with host arrays follows:</p>
<pre>char   emp_name[50][20]; 
int    emp_number[50]; 
float  salary[50]; 
/* populate the host arrays */ 
... 
EXEC SQL INSERT INTO EMP (ENAME, EMPNO, SAL) 
    VALUES (:emp_name, :emp_number, :salary); 
</pre>
<p>The cumulative number of rows inserted can be found in the rows-processed count, <code>sqlca.sqlerrd[2]</code>.</p>
<p>In the following example, the INSERT is done one row at a time. This is much less efficient than the previous example, since a call to the server must be made for each row inserted.</p>
<pre>for (i = 0; i &lt; array_size; i++) 
    EXEC SQL INSERT INTO emp (ename, empno, sal) 
        VALUES (:emp_name[i], :emp_number[i], :salary[i]); 
</pre>
<div id="LNPCC3456" class="sect2"><a id="sthref1083"></a>
<h3 class="sect2">Inserting with Arrays Restrictions</h3>
<p>You cannot use an array of pointers in the VALUES clause of an INSERT statement; all array elements must be data items.<a id="sthref1084"></a><a id="sthref1085"></a></p>
<p>Mixing scalar host variables with host arrays in the VALUES clause of an INSERT statement is <span class="italic">not</span> allowed. If any of the host variables is an array, all must be arrays.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1879"></a>
<div id="LNPCC3457" class="sect1">
<h2 class="sect1">Updating with Arrays</h2>
<p>You can also use host arrays as input variables in an UPDATE statement, as the following example shows:<a id="sthref1086"></a><a id="sthref1087"></a></p>
<pre>int   emp_number[50]; 
float salary[50]; 
/* populate the host arrays */ 
EXEC SQL UPDATE emp SET sal = :salary 
    WHERE EMPNO = :emp_number; 
</pre>
<p>The cumulative number of rows updated can be found in <code>sqlerrd[2]</code>. This number does <span class="italic">not</span> include rows processed by an update cascade.</p>
<p>If some elements in the arrays are irrelevant, you can use the embedded SQL FOR clause to limit the number of rows updated.</p>
<p>The last example showed a typical update using a unique key (EMP_NUMBER). Each array element qualified just one row for updating. In the following example, each array element qualifies multiple rows:</p>
<pre>char  job_title [10][20]; 
float commission[10]; 
 
... 
 
EXEC SQL UPDATE emp SET comm = :commission 
    WHERE job = :job_title;
</pre>
<div id="LNPCC3458" class="sect2"><a id="sthref1088"></a>
<h3 class="sect2">Updating with Arrays Restrictions</h3>
<p>Mixing simple host variables with host arrays in the SET or WHERE clause of an UPDATE statement is <span class="italic">not</span> recommended. If any of the host variables is an array, all should be arrays.<a id="sthref1089"></a><a id="sthref1090"></a> Furthermore, if you use a host array in the SET clause, use one of equal number of elements in the WHERE clause.</p>
<p>You cannot use host arrays with the CURRENT OF clause in an UPDATE statement.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a href="#i1776">&#34;Mimicking CURRENT OF&#34;</a> for an alternative.</div>
<p><a href="#g14454">Table 8-2</a> shows which uses of host arrays are valid in an UPDATE statement:</p>
<div id="LNPCC3459" class="tblformal">
<p class="titleintable"><a id="sthref1091"></a><a id="g14454"></a>Table 8-2 Host Arrays Valid in an UPDATE</p>
<table class="cellalignment831" title="Host Arrays Valid in an UPDATE" summary="Host Arrays Valid in an UPDATE" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t9">SET Clause</th>
<th class="cellalignment832" id="r1c2-t9">WHERE Clause</th>
<th class="cellalignment832" id="r1c3-t9">Valid?</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t9" headers="r1c1-t9">
<p>array</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c2-t9">
<p>array</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c3-t9">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t9" headers="r1c1-t9">
<p>scalar</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c2-t9">
<p>scalar</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c3-t9">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t9" headers="r1c1-t9">
<p>array</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c2-t9">
<p>scalar</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c3-t9">
<p>no</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t9" headers="r1c1-t9">
<p>scalar</p>
</td>
<td class="cellalignment833" headers="r5c1-t9 r1c2-t9">
<p>array</p>
</td>
<td class="cellalignment833" headers="r5c1-t9 r1c3-t9">
<p>no</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i13737"></a>
<div id="LNPCC3460" class="sect1">
<h2 class="sect1">Deleting with Arrays</h2>
<p>You can also use host arrays as input variables in a DELETE statement. It is like executing the DELETE statement repeatedly using successive elements of the host array in the WHERE clause. Thus, each execution might delete zero, one, or more rows from the table.<a id="sthref1092"></a><a id="sthref1093"></a></p>
<p>An example of deleting with host arrays follows:</p>
<pre>... 
int emp_number[50]; 
 
/* populate the host array */ 
... 
EXEC SQL DELETE FROM emp 
    WHERE empno = :emp_number; 
</pre>
<p>The cumulative number of rows deleted can be found in <code>sqlerrd[2]</code>. The number does <span class="italic">not</span> include rows processed by a delete cascade.</p>
<p>The last example showed a typical delete using a unique key (EMP_NUMBER). Each array element qualified just one row for deletion. In the following example, each array element qualifies multiple rows:</p>
<pre>... 
char job_title[10][20]; 
 
/* populate the host array  */ 
... 
EXEC SQL DELETE FROM emp 
    WHERE job = :job_title;
...
</pre>
<div id="LNPCC3461" class="sect2"><a id="sthref1094"></a>
<h3 class="sect2">Deleting with Arrays Restrictions</h3>
<p>Mixing simple host variables with host arrays in the WHERE clause of a DELETE statement is <span class="italic">not</span> allowed. If any of the host variables is an array, all must be arrays.<a id="sthref1095"></a><a id="sthref1096"></a></p>
<p>You cannot use host arrays with the CURRENT OF clause in a DELETE statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1776">&#34;Mimicking CURRENT OF&#34;</a> for an alternative.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1775"></a>
<div id="LNPCC3462" class="sect1">
<h2 class="sect1">Using the FOR Clause</h2>
<p>You can use the optional embedded SQL FOR clause to set the number of array elements processed by any of the following SQL statements:</p>
<ul>
<li>
<p>DELETE</p>
</li>
<li>
<p>EXECUTE</p>
</li>
<li>
<p>FETCH</p>
</li>
<li>
<p>INSERT</p>
</li>
<li>
<p>OPEN</p>
</li>
<li>
<p>UPDATE</p>
</li>
</ul>
<p>The FOR clause is especially useful in UPDATE, INSERT, and DELETE statements. With these statements you might not want to use the entire array. The FOR clause lets you limit the elements used to just the number you need, as the following example shows:<a id="sthref1097"></a><a id="sthref1098"></a><a id="sthref1099"></a><a id="sthref1100"></a></p>
<pre>char  emp_name[100][20]; 
float salary[100]; 
int   rows_to_insert; 
 
/* populate the host arrays */ 
rows_to_insert = 25;             /* set FOR-clause variable */ 
EXEC SQL FOR :rows_to_insert   /* will process only 25 rows */ 
    INSERT INTO emp (ename, sal) 
    VALUES (:emp_name, :salary); 
</pre>
<p>The FOR clause can use an integer host variable to count array elements, or an integer literal. A complex C expression that resolves to an integer <span class="italic">cannot</span> be used. For example, the following statement that uses an integer expression is illegal: <a id="sthref1101"></a></p>
<pre>EXEC SQL FOR :rows_to_insert + 5                 /* illegal */ 
    INSERT INTO emp (ename, empno, sal) 
        VALUES (:emp_name, :emp_number, :salary); 
</pre>
<p>The FOR clause variable specifies the number of array elements to be processed. Make sure the number does not exceed the smallest array dimension. Internally, the value is treated as an unsigned quantity. An attempt to pass a negative value through the use of a signed host variable will result in unpredictable behavior.<a id="sthref1102"></a></p>
<div id="LNPCC3463" class="sect2"><a id="sthref1103"></a>
<h3 class="sect2">FOR Clause Restrictions</h3>
<p>Two restrictions keep FOR clause semantics clear: you cannot use the FOR clause in a SELECT statement or with the CURRENT OF clause.<a id="sthref1104"></a><a id="sthref1105"></a></p>
<div id="LNPCC3464" class="sect3"><a id="sthref1106"></a>
<h4 class="sect3">In a SELECT Statement</h4>
<p>If you use the FOR clause in a SELECT statement, you get an error message.</p>
<p>The FOR clause is not allowed in SELECT statements because its meaning is unclear. Does it mean &#34;execute this SELECT statement <span class="italic">n</span> times&#34;? Or, does it mean &#34;execute this SELECT statement once, but return <span class="italic">n</span> rows&#34;? The problem in the former case is that each execution might return multiple rows. In the latter case, it is better to declare a cursor and use the FOR clause in a FETCH statement, as follows:</p>
<pre>EXEC SQL FOR :limit FETCH emp_cursor INTO ... 
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC3465" class="sect3"><a id="sthref1107"></a>
<h4 class="sect3">With the CURRENT OF Clause</h4>
<p>You can use the CURRENT OF clause in an UPDATE or DELETE statement to refer to the latest row returned by a FETCH statement, as the following example shows:</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
    SELECT ename, sal FROM emp WHERE empno = :emp_number; 
... 
EXEC SQL OPEN emp_cursor; 
... 
EXEC SQL FETCH emp_cursor INTO :emp_name, :salary; 
... 
EXEC SQL UPDATE emp SET sal = :new_salary 
WHERE CURRENT OF emp_cursor; 
</pre>
<p>However, you cannot use the FOR clause with the CURRENT OF clause. The following statements are invalid because the only logical value of <span class="italic">limit</span> is 1 (you can only update or delete the current row once):</p>
<pre>EXEC SQL FOR :limit UPDATE emp SET sal = :new_salary 
WHERE CURRENT OF emp_cursor; 
... 
EXEC SQL FOR :limit DELETE FROM emp 
WHERE CURRENT OF emp_cursor; 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1770"></a>
<div id="LNPCC3466" class="sect1">
<h2 class="sect1">Using the WHERE Clause</h2>
<p>Oracle treats a SQL statement containing host arrays of number of elements <span class="italic">n</span> like the same SQL statement executed <span class="italic">n</span> times with <span class="italic">n</span> different scalar variables (the individual array elements). The precompiler issues an error message only when such treatment would be ambiguous.<a id="sthref1108"></a><a id="sthref1109"></a></p>
<p>For example, assuming the declarations</p>
<pre>int  mgr_number[50]; 
char job_title[50][20]; 
</pre>
<p>it would be ambiguous if the statement</p>
<pre>EXEC SQL SELECT mgr INTO :mgr_number FROM emp 
WHERE job = :job_title; 
</pre>
<p>were treated like the imaginary statement</p>
<pre>for (i = 0; i &lt; 50; i++) 
    SELECT mgr INTO :mgr_number[i] FROM emp 
        WHERE job = :job_title[i]; 
</pre>
<p>because multiple rows might meet the WHERE-clause search condition, but only one output variable is available to receive data. Therefore, an error message is issued.</p>
<p>On the other hand, it would not be ambiguous if the statement</p>
<pre>EXEC SQL UPDATE emp SET mgr = :mgr_number 
    WHERE empno IN (SELECT empno FROM emp 
        WHERE job = :job_title); 
</pre>
<p>were treated like the imaginary statement</p>
<pre>for (i = 0; i &lt; 50; i++) 
    UPDATE emp SET mgr = :mgr_number[i] 
        WHERE empno IN (SELECT empno FROM emp 
            WHERE job = :job_title[i]); 
</pre>
<p>because there is a <span class="italic">mgr_number</span> in the SET clause for each row matching <span class="italic">job_title</span> in the WHERE clause, even if each <span class="italic">job_title</span> matches multiple rows. All rows matching each <span class="italic">job_title</span> can be SET to the same <span class="italic">mgr_number</span>. Therefore, no error message is issued.</p>
</div>
<!-- class="sect1" -->
<a id="i2257"></a>
<div id="LNPCC3467" class="sect1">
<h2 class="sect1">Arrays of Structs<a id="sthref1110"></a><a id="sthref1111"></a></h2>
<p>Using arrays of scalars, you can perform multirow operations involving a single column only. Using structs of scalars allows users to perform single row operations involving multiple columns.</p>
<p>In order to perform multirow operations involving multiple columns, however, you previously needed to allocate several parallel arrays of scalars either separately or encapsulated within a single struct. In many cases, it is easier to reorganize this data structure more conveniently as a single array of structs instead.</p>
<p>Pro*C/C++ supports the use of <span class="italic">arrays of structs</span> which enable an application programmer to perform multirow, multicolumn operations using an array of C structs. With this enhancement, Pro*C/C++ can handle simple arrays of structs of scalars as bind variables in embedded SQL statements for easier processing of user data. This makes programming more intuitive, and allows users greater flexibility in organizing their data.</p>
<p>In addition to supporting arrays of structs as bind variables, Pro*C/C++ also supports arrays of indicator structs when used in conjunction with an array of structs declaration.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Binding structs to PL/SQL records and binding arrays of structs to PL/SQL tables of records are <span class="italic">not</span> part of this new functionality. Arrays of structs may also not be used within an embedded PL/SQL block. See also <a href="#i2013">&#34;Restrictions on Arrays of Structs&#34;</a>.</div>
<p>Since arrays of structs are intended to be used when performing multirow operations involving multiple columns, it is generally anticipated that they will be used in the following ways.</p>
<ul>
<li>
<p>As output bind variables in SELECT statements or FETCH statements.</p>
</li>
<li>
<p>As input bind variables in the VALUES clause of an INSERT statement.</p>
</li>
</ul>
<div id="LNPCC3468" class="sect2"><a id="sthref1112"></a>
<h3 class="sect2">Arrays of Structs Usage</h3>
<p>The notion of an array of structs is not new to C programmers. It does, however, present a conceptual difference for data storage when it is compared to a struct of parallel arrays.</p>
<p>In a struct of parallel arrays, the data for the individual columns is stored contiguously. In an array of structs, on the other hand, the column data is <span class="bolditalic">interleaved</span>, whereby each occurrence of a column in the array is separated by the space required by the other columns in the struct. This space is known as a <span class="bolditalic">stride</span>.</p>
</div>
<!-- class="sect2" -->
<a id="i2013"></a>
<div id="LNPCC3469" class="sect2">
<h3 class="sect2">Restrictions on Arrays of Structs</h3>
<p>The following restrictions apply to the use of arrays of structs in Pro*C/C++:</p>
<ul>
<li>
<p>Arrays of structs (just as with ordinary structs) are not permitted inside an embedded PL/SQL block.</p>
</li>
<li>
<p>Use of arrays of structs in WHERE or FROM clauses is prohibited.</p>
</li>
<li>
<p>Arrays of structs are not permitted with Oracle Dynamic SQL Method 4. They are permitted with ANSI Dynamic SQL. See also <a href="pc_14ady.htm#i1011699">&#34; ANSI Dynamic SQL&#34;</a>.</p>
</li>
<li>
<p>Arrays of structs are not permitted in the SET clause of an UPDATE statement.</p>
</li>
</ul>
<p>The syntax for declaring an array of structs does not change. There are, however, a few things to keep in mind when using an array of structs.</p>
</div>
<!-- class="sect2" -->
<a id="i2026"></a>
<div id="LNPCC3470" class="sect2">
<h3 class="sect2">Declaring an Array of Structs</h3>
<p>When declaring an array of structs which will be used in a Pro*C/C++ application, the programmer must keep in mind the following important points:</p>
<ul>
<li>
<p>The struct must have a structure tag. For example, in the following code segment</p>
</li>
</ul>
<pre>    struct person {
       char name[15];
       int  age;
    } people[10];
</pre>
<p>the <code>person</code> variable is the structure tag. This is so the precompiler can use the name of the struct to compute the size of the stride.</p>
<ul>
<li>
<p>The members of the struct must not be arrays. The only exception to this rule is for character types such as <span class="bold">char</span> or <span class="bold">VARCHAR</span> since array syntax is used when declaring variables of these types.</p>
</li>
<li>
<p><span class="bold">char</span> and <span class="bold">VARCHAR</span> members may not be two-dimensional.</p>
</li>
<li>
<p>Nested structs are not permitted as members of an array of structs. This is not a new restriction, since nested structs have not been supported by previous releases of Pro*C/C++.</p>
</li>
<li>
<p>The size of just the struct may not exceed the maximum value that a signed 4-byte quantity may represent. This is typically two gigabytes.</p>
</li>
</ul>
<p>Given these restrictions regarding the use of arrays of structs, the following declaration is legal in Pro*C/C++</p>
<pre>struct department {
   int deptno;
   char dname[15];
   char loc[14];
} dept[4];
</pre>
<p>while the following declaration is illegal.</p>
<pre>struct {              /* the struct is missing a structure tag */
  int empno[15];      /* struct members may not be arrays */
  char ename[15][10]; /* character types may not be 2-dimensional */
  struct nested {
    int salary;   /* nested struct not permitted in array of structs */
  } sal_struct;
} bad[15];
</pre>
<p>It is also important to note that you cannot apply datatype equivalencing to either the array of structs itself or to any of the individual fields within the struct. For example, assuming <code>empno</code> is not declared as an array in the earlier illegal struct, the following is illegal:</p>
<pre>exec sql var bad[3].empno is integer(4);
</pre>
<p>The precompiler has no way to keep track of individual structure elements within the array of structs. One could do the following, on the other hand, to achieve the desired effect.</p>
<pre>typedef int myint;
exec sql type myint is integer(4);

struct equiv {
  myint empno; /* now legally considered an integer(4) datatype */
   ...
} ok[15];
</pre>
<p>This should come as no surprise since equivalencing individual array items has not been supported by previous releases of Pro*C/C++. For example, the following scalar array declarations illustrate what is legal and what is not.</p>
<pre>int empno[15];
exec sql var empno[3] is integer(4); /* illegal */

myint empno[15]; /* legal */
</pre>
<p>In summary, you may not equivalence any individual array item.</p>
</div>
<!-- class="sect2" -->
<a id="i2048"></a>
<div id="LNPCC3471" class="sect2">
<h3 class="sect2">Variables Guidelines</h3>
<p>Indicator variables for an array of structs declaration work in much the same way as a normal struct declaration. An indicator array of structs declaration must abide by the rules for an array of structs as follows:</p>
<ul>
<li>
<p>The number of fields in the indicator struct must be less than or equal to the number of fields in the corresponding array of structs.</p>
</li>
<li>
<p>The order of the fields must match the order of the corresponding members of the array of structs.</p>
</li>
<li>
<p>The datatype for all elements in the indicator struct must be <span class="bold">short</span>.</p>
</li>
<li>
<p>The size of the indicator array must be at least the same size as the host variable declaration. It may be larger, but it may not be smaller.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2026">&#34;Declaring an Array of Structs&#34;</a></div>
</li>
</ul>
<p>These rules generally reflect the rules for using structs as implemented in prior releases of Pro*C/C++. The array restriction is also the same as that previously used for arrays of scalars.</p>
<p>Given these rules, assume the following struct declaration:</p>
<pre>struct department {
   int deptno;
   char dname[15];
   char loc[14];
} dept[4];
</pre>
<p>The following is a legal indicator variable struct declaration:</p>
<pre>struct department_ind {
   short deptno_ind;
   short dname_ind;
   short loc_ind;
} dept_ind[4];
</pre>
<p>while the following is illegal as an indicator variable</p>
<pre>struct{               /* missing indicator structure tag */
  int deptno_ind;     /* indicator variable not of type short */
  short dname_ind[15];/* array element forbidden in indicator struct */
  short loc_ind[14];  /* array element forbidden in indicator struct */
} bad_ind[2];     /* indicator array size is smaller than host array */
</pre></div>
<!-- class="sect2" -->
<a id="i2066"></a>
<div id="LNPCC3472" class="sect2">
<h3 class="sect2">Declaring a Pointer to an Array of Structs</h3>
<p>In some cases, it may be desirable to declare a pointer to an array of structs. This allows pointers to arrays of structs to be passed to other functions or used directly in an embedded SQL statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The length of the array referenced by a pointer to an array of structs cannot be known during precompilation. For this reason, an explicit FOR clause must be used when a bind variable whose type is a pointer to an array of structs is used in any embedded SQL statement.</div>
<p>Remember that FOR clauses may not be used in an embedded SQL SELECT statement. Therefore, to retrieve data into a pointer to an array of structs, an explicit cursor and FETCH statement must be used with the FOR clause.</p>
</div>
<!-- class="sect2" -->
<a id="i2072"></a>
<div id="LNPCC3473" class="sect2">
<h3 class="sect2">Examples</h3>
<p>The following examples demonstrate different uses of the array of structs functionality in Pro*C/C++.</p>
<div id="LNPCC3474" class="sect3"><a id="sthref1113"></a>
<h4 class="sect3">Example 1: A Simple Array of Structs of Scalars</h4>
<p>Given the following structure declaration,</p>
<pre>struct department {
   int deptno;
   char dname[15];
   char loc[14];
} my_dept[4];
</pre>
<p>a user could then select the <code>dept</code> data into <code>my_dept</code> as follows:</p>
<pre>exec sql select * into :my_dept from dept;
</pre>
<p>or the user could populate <code>my_dept</code> first and then bulk insert it into the <code>dept</code> table:</p>
<pre>exec sql insert into dept values (:my_dept);
</pre>
<p>To use an indicator variable, a parallel indicator array of structs could be declared.</p>
<pre>struct deptartment_ind {
   short deptno_ind;
   short dname_ind;
   short loc_ind;
} my_dept_ind[4];
</pre>
<p>Data is then be selected using the same query except for the addition of the indicator variable:</p>
<pre>exec sql select * into :my_dept indicator :my_dept_ind from dept;
</pre>
<p>Similarly, the indicator could be used when inserting the data as well:</p>
<pre>exec sql insert into dept values (:my_dept indicator :my_dept_ind);
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC3475" class="sect3"><a id="sthref1114"></a>
<h4 class="sect3">Example 2: Using Mixed Scalar Arrays with An Array of Structs</h4>
<p>As in prior releases of Pro*C/C++, when using multiple arrays for bulk handling of user data, the size of the arrays must be the same. If they are not, the smallest array size is chosen leaving the remaining portions of the arrays unaffected.</p>
<p>Given the following declarations,</p>
<pre>struct employee {
   int empno;
   char ename[11];
} emp[14];

float sal[14];
float comm[14];
</pre>
<p>it is possible to select multiple rows for all columns in one simple query:</p>
<pre>exec sql select empno, ename, sal, comm into :emp, :sal, :comm from emp;
</pre>
<p>We also want to know whether the column values for the commissions are NULL or not. A single indicator array could be used given the following declaration:</p>
<pre>short comm_ind[14];
...
exec sql select empno, ename, sal, comm
   into :emp, :sal, :comm indicator :comm_ind from emp;
</pre>
<p>You cannot declare a single indicator array of structs that encapsulate all indicator information from the query. Therefore:</p>
<pre>struct employee_ind {   /* example of illegal usage */
   short empno_ind;
   short ename_ind;
   short sal_ind;
   short comm_ind;
} illegal_ind[15];

exec sql select empno, ename, sal, comm
   into :emp, :sal, :comm indicator :illegal_ind from emp;
</pre>
<p>is illegal (as well as undesirable). The earlier statement associates the indicator array with the <code>comm</code> column only, not the entire SELECT...INTO list.</p>
<p>Assuming the array of structs and the <code>sal</code>, <code>comm</code> and <code>comm_ind</code> arrays were populated with the desired data, insertion is straightforward:</p>
<pre>exec sql insert into emp (empno, ename, sal, comm)
   values (:emp, :sal, :comm indicator :comm_ind);
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC3476" class="sect3"><a id="sthref1115"></a>
<h4 class="sect3">Example 3: Using Multiple Arrays of Structs with a Cursor</h4>
<p>For this example, we make the following declarations:</p>
<pre>struct employee {
   int empno;
   char ename[11];
   char job[10];
} emp[14];

struct compensation {
   int sal;
   int comm;
} wage[14];

struct compensation_ind {
   short sal_ind;
   short comm_ind;
} wage_ind[14];
</pre>
<p>Our program could then make use of these arrays of structs as follows:</p>
<pre>exec sql declare c cursor for 
   select empno, ename, job, sal, comm from emp;

exec sql open c;

exec sql whenever not found do break;
while(1)
{
  exec sql fetch c into :emp, :wage indicator :wage_ind;
  ... process batch rows returned by the fetch ...
}

printf(&#34;%d rows selected.\n&#34;, sqlca.sqlerrd[2]);

exec sql close c;
</pre>
<div id="LNPCC3477" class="sect4"><a id="sthref1116"></a>
<h5 class="sect4">Using the FOR clause</h5>
<p>Alternatively, we could have used the FOR clause to instruct the fetch on how many rows to retrieve. Recall that the FOR clause is prohibited when using the SELECT statement, but not the INSERT or FETCH statements.</p>
<p>We add the following to our original declarations</p>
<pre>int limit = 10;
</pre>
<p>and code our example accordingly.</p>
<pre>   exec sql for :limit
      fetch c into :emp, :wage indicator :wage_ind;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNPCC3478" class="sect3"><a id="sthref1117"></a>
<h4 class="sect3">Example 4: Individual Array and Struct Member Referencing</h4>
<p>Prior releases of Pro*C/C++ allowed array references to single structures in an array of structs. The following is therefore legal since the bind expression resolves to a simple struct of scalars.</p>
<pre>exec sql select * into :dept[3] from emp;
</pre>
<p>Users can reference an individual scalar member of a specific struct in an array of structs as the following example shows.</p>
<pre>exec sql select dname into :dept[3].dname from dept where ...;
</pre>
<p>Naturally, this requires that the query be a single row query so only one row is selected into the variable represented by this bind expression.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3479" class="sect3"><a id="sthref1118"></a>
<h4 class="sect3">Example 5: Using Indicator Variables, a Special Case</h4>
<p>Prior releases of Pro*C/C++ required that an indicator struct have the same number of fields as its associated bind struct. This restriction has been relaxed when using structs in general. By following the previously mentioned guidelines for indicator arrays of structs it is possible to construct the following example.</p>
<pre>struct employee {
    float comm;
    float sal;
    int empno;
    char ename[10];
} emp[14];

struct employee_ind {
    short comm;
} emp_ind[14];

exec sql select comm, sal, empno, ename 
   into :emp indicator :emp_ind from emp;
</pre>
<p>The mapping of indicator variables to bind values is one-to-one. They map in associative sequential order starting with the first field.</p>
<p>Be aware, however, that if any of the other fields has a fetched value of NULL and no indicator is provided, the following error is raised:</p>
<pre>ORA-1405: fetched column value is NULL
</pre>
<p>As an example, such is the case if <code>sal</code> was nullable because there is no indicator for <code>sal</code>.</p>
<p>Suppose we change the array of structs as follows,</p>
<pre>struct employee {
   int empno;
   char ename[10];
   float sal;
   float comm;
} emp[15];
</pre>
<p>but still used the same indicator array of structs.</p>
<p>Because the indicators map in associative sequential order, the <code>comm</code> indicator maps to the <code>empno</code> field leaving the <code>comm</code> bind variable without an indicator once again leading to the ORA-1405 error.</p>
<p>To avoid the ORA-1405 when using indicator structs that have fewer fields than their associative bind variable structs, the nullable attributes should appear first and in sequential order.</p>
<p>We could easily change this into a single-row fetch involving multiple columns by using non-array structs and expect it to work as though the indicator struct was declared as follows.</p>
<pre>struct employee_ind {
   short comm;
   short sal;
   short empno;
   short ename;
} emp_ind;
</pre>
<p>Because Pro*C/C++ no longer requires that the indicator struct have the same number of fields as its associated value struct, the earlier example is now legal in Pro*C/C++ whereas previously it was not.</p>
<p>Our indicator struct could now look like the following simple struct.</p>
<pre>struct employee_ind {
   short comm;
} emp_ind;
</pre>
<p>Using the non-array <code>emp</code> and <code>emp_ind</code> structs we are able to perform a single row fetch as follows.</p>
<pre>exec sql fetch comm, sal, empno, ename
   into :emp indicator :emp_ind from emp;
</pre>
<p>Note once again how the <code>comm</code> indicator maps to the <code>comm</code> bind variable in this case as well.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3480" class="sect3"><a id="sthref1119"></a>
<h4 class="sect3">Example 6: Using a Pointer to an Array of Structs</h4>
<p>This example demonstrates how to use a pointer to an array of structs.</p>
<p>Given the following type declaration:</p>
<pre>typedef struct dept {
   int deptno;
   char dname[15];
   char loc[14];
} dept;
</pre>
<p>we can perform a variety of things, manipulating a pointer to an array of structs of that type. For example, we can pass pointers to arrays of structs to other functions.</p>
<pre>void insert_data(d, n)
   dept *d;
   int n;
{
    exec sql for :n insert into dept values (:d);
}

void fetch_data(d, n)
   dept *d;
   int n;
{
   exec sql declare c cursor for select deptno, dname, loc from dept;
   exec sql open c;
   exec sql for :n fetch c into :d;
   exec sql close c;
}
</pre>
<p>Such functions are invoked by passing the address of the array of structs as these examples indicate.</p>
<pre>dept d[4];
dept *dptr = &amp;d[0];
const int n = 4;

fetch_data(dptr, n);
insert_data(d, n); /* We are treating &#39;&amp;d[0]&#39; as being equal to &#39;d&#39; */
</pre>
<p>Or we can simply use such pointers to arrays of structs directly in some embedded SQL statement.</p>
<pre>exec sql for :n insert into dept values (:dptr);
</pre>
<p>The most important thing to remember is the use of the FOR clause.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1776"></a>
<div id="LNPCC3481" class="sect1">
<h2 class="sect1">Mimicking CURRENT OF</h2>
<p>You use the CURRENT OF <span class="italic">cursor</span> clause in a DELETE or UPDATE statement to refer to the latest row FETCHed from the cursor. However, you cannot use CURRENT OF with host arrays. Instead, select the ROWID of each row, then use that value to identify the current row during the update or delete.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_06sql.htm#i6550">&#34;The CURRENT OF Clause&#34;</a></div>
<p>For example:<a id="sthref1120"></a><a id="sthref1121"></a></p>
<pre>char  emp_name[20][10]; 
char  job_title[20][10]; 
char  old_title[20][10]; 
char  row_id[20][19]; 
... 
EXEC SQL DECLARE emp_cursor CURSOR FOR 
SELECT ename, job, rowid FROM emp FOR UPDATE; 
... 
EXEC SQL OPEN emp_cursor; 
EXEC SQL WHENEVER NOT FOUND do break; 
for (;;) 
{ 
    EXEC SQL FETCH emp_cursor 
        INTO :emp_name, :job_title, :row_id; 
    ... 
    EXEC SQL DELETE FROM emp 
        WHERE job = :old_title AND rowid = :row_id; 
    EXEC SQL COMMIT WORK; 
} 
</pre></div>
<!-- class="sect1" -->
<a id="BGBDJCBA"></a>
<div id="LNPCC3482" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Additional Array Insert/Select Syntax</h2>
<p>The Oracle precompiler also supports the DB2 insert and fetch syntax for the host tables. The supported additional array insert and fetch syntax are shown in the following figures, respectively.</p>
<div class="figure">
<p class="titleinfigure"><a id="sthref1122"></a>Figure 8-1 Additional Insert Syntax</p>
<img width="720" height="256" src="img/insert2.gif" alt="Description of Figure 8-1 follows"/><br/>
<a id="sthref1123" href="img_text/insert2.htm">Description of &#34;Figure 8-1 Additional Insert Syntax&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="LNPCC3484" class="figure">
<p class="titleinfigure"><a id="sthref1124"></a>Figure 8-2 Additional Fetch Syntax</p>
<img width="720" height="218" src="img/ch8fetch.gif" alt="Description of Figure 8-2 follows"/><br/>
<a id="sthref1125" href="img_text/ch8fetch.htm">Description of &#34;Figure 8-2 Additional Fetch Syntax&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The optional ROWSET and ROWSET STARTING AT clauses are used in the fetch-orientation (FIRST, PRIOR, NEXT, LAST, CURRENT, RELATIVE and ABSOLUTE). Consider the following examples:</p>
<ul>
<li>
<p>FIRST ROWSET</p>
</li>
<li>
<p>PRIOR ROWSET</p>
</li>
<li>
<p>NEXT ROWSET</p>
</li>
<li>
<p>LAST ROWSET</p>
</li>
<li>
<p>CURRENT ROWSET</p>
</li>
<li>
<p>ROWSET STARTING AT RELATIVEn</p>
</li>
<li>
<p>ROWSET STARTING AT ABSOLUTEn</p>
</li>
</ul>
<p>Examples of the DB2 array insert/fetch syntax and their comparison with the corresponding Oracle precompiler syntax are shown in <a href="#BABHDBHI">Table 8-3</a>:</p>
<div id="LNPCC3485" class="tblformal">
<p class="titleintable"><a id="sthref1126"></a><a id="BABHDBHI"></a>Table 8-3 DB2 Array Syntax vs. Oracle Precompiler Syntax</p>
<table class="cellalignment831" title="DB2 Array Syntax vs. Oracle Precompiler Syntax" summary="DB2 vs. Oracle Precompiler syntax" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t15">DB2 Array Syntax</th>
<th class="cellalignment832" id="r1c2-t15">Oracle Precompiler Syntax</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t15" headers="r1c1-t15">
<pre>EXEC SQL
  INSERT INTO dsn8810.act 
  (actno, actkwd, actdesc) 
  VALUES (:hva1, :hva2, :hva3)
  FOR :NUM_ROWS ROWS;
</pre></td>
<td class="cellalignment833" headers="r2c1-t15 r1c2-t15">
<pre>EXEC SQL FOR :num_rows
  INSERT INTO dsn8810.act
  (actno, actkwd, actdesc)
  VALUES (:hva1, :hva2, :hva3);
</pre></td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t15" headers="r1c1-t15">
<pre>EXEC SQL
  FETCH NEXT ROWSET FROM c1 
  FOR 20 ROWS 
  INTO :hva_empno, :hva_lastname,
       :hva_salary;
</pre></td>
<td class="cellalignment833" headers="r3c1-t15 r1c2-t15">
<pre>EXEC SQL
   FOR :twenty
   FETCH c1 
   INTO :hva_empno, :hva_lastname,
        :hva_salary;
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>In DB2 syntax, a row-set positioned cursor should be first declared before retrieving row sets of data. To enable a cursor to fetch row sets, the &#39;WITH ROWSET POSITIONING&#39; clause has to be used in the DECLARE CURSOR statement, which is not required and relevant in the Oracle precompiler syntax, as shown in the following table.</p>
<div class="inftblinformal">
<table class="cellalignment834" title="table for difference between DB2 and Oracle precompiler syntax" summary="table for difference between DB2 and Oracle precompiler syntax" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t16">DB2 Array Syntax</th>
<th class="cellalignment832" id="r1c2-t16">Oracle Precompiler Syntax</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t16" headers="r1c1-t16">
<pre>EXEC SQL
 DECLARE c1 CURSOR
  WITH ROWSET POSITIONING FOR
  SELECT empno, lastname, salary
      FROM dsn8810.emp;
</pre></td>
<td class="cellalignment833" headers="r2c1-t16 r1c2-t16">
<pre>EXEC SQL
   DECLARE c1 CURSOR FOR
   SELECT empno, lastname, salary
        FROM dsn8810.emp;
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>This DB2 array syntax support can be enabled with the precompiler option <code>db2_array</code>, whose default option is <code>no</code>. The DB2 array syntax support cannot be used together with the Oracle precompiler syntax; only one of the syntax, only on of the syntax, either Oracle precompiler or DB2 syntax, is supported at a time.</p>
<div id="LNPCC3486" class="example">
<p class="titleinexample"><a id="sthref1127"></a>Example 8-1 Inserting and Fetching Rows by Using the DB2 Array Syntax</p>
<p>This program inserts INSCNT rows into the EMP table by using the DB2 array insert syntax, and then fetches the inserted rows by using the DB2 array fetch syntax.</p>
<pre>/* 
 * db2arrdemo.pc 
 */
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlda.h&gt;
#include &lt;sqlcpr.h&gt;
#include &lt;sqlca.h&gt;
 
/* Number of rows to be inserted in one shot */
#define INSCNT 100
/* Number of rows to be fetched in one shot */
#define FETCHCNT 20
 
/* Define a host structure
   for inserting data into the table 
   and for fetching data from the table */
struct emprec
{
  int     empno;
  varchar ename[10];
  varchar job[9];
  int mgr;
  char hiredate[10];
  float sal;
  float comm;
  int deptno;
};
typedef struct emprec empdata;
 
/* Function prototypes */
void sql_error(char *);
void insertdata();
void fetchdata();
void printempdata(empdata *);
 
void main()
{
 
  exec sql begin declare section;
    char *uid = &#34;scott/tiger&#34;;
  exec sql end declare section;
 
  exec sql whenever sqlerror do sql_error(&#34;ORACLE error--\n&#34;);
  exec sql connect :uid;
 
  printf(&#34;Inserting %d rows into EMP table using DB2 array insert syntax.\n&#34;,
         INSCNT);
  insertdata();
  printf(&#34;\nFetching data using DB2 array fetch syntax.\n&#34;);
  fetchdata();
 
  exec sql rollback work release;
  exit(EXIT_SUCCESS);
}
 
/* Inserting data into the table using DB2 array insert syntax*/
void insertdata() 
{
  int i, cnt;
  char *str;
  empdata emp_in[INSCNT];
 
  /* To store temporary strings */
  str = (char *)malloc (25 * sizeof(char));
 
  /* Fill the array elements to insert */ 
  for (i = 0; i &lt; INSCNT; i++)
  {
    emp_in[i].empno = i+1;
    sprintf(str, &#34;EMP_%03d&#34;, i+1);
    strcpy (emp_in[i].ename.arr, str);
    emp_in[i].ename.len = strlen (emp_in[i].ename.arr);
    sprintf(str, &#34;JOB_%03d&#34;, i+1);
    strcpy (emp_in[i].job.arr, str);
    emp_in[i].job.len = strlen (emp_in[i].job.arr);
    emp_in[i].mgr = i+1001;
    sprintf(str, &#34;%02d-MAY-06&#34;, (i%30)+1);
    strcpy (emp_in[i].hiredate, str);
    emp_in[i].sal = (i+1) * 10;
    emp_in[i].comm = (i+1) * 0.1;
    emp_in[i].deptno = 10;
  }
 
  free (str);
 
  /* Inserting data using DB2 array insert syntax */
  exec sql insert into emp values (:emp_in) FOR :INSCNT rows;
 
  exec sql select count(*) into :cnt from emp where ename like &#39;EMP_%&#39;;
  printf (&#34;Number of rows successfully inserted into emp table: %d\n&#34;, cnt);
}
 
/* Fetches data from the table using DB2 array fetch syntax*/
void fetchdata()
{
  empdata emp_out[FETCHCNT];
 
  /* Declares scrollable cursor to fetch data */
  exec sql declare c1 scroll cursor with rowset positioning for
         select empno, ename, job, mgr, hiredate, sal, comm, deptno
         from emp where ename like &#39;EMP_%&#39; order by empno;
  
  exec sql open c1;
 
  exec sql whenever not found do break;
  while(1)
  {
    /* Fetches data using DB2 array fetch syntax */
    exec sql fetch next rowset from c1 for :FETCHCNT rows into :emp_out;
    printempdata(emp_out);
  }
  exec sql whenever not found do sql_error(&#34;ORACLE ERROR&#34;);
 
  exec sql close c1;
}
 
/* Prints the fetched employee data */
void printempdata(empdata *emp_out)
{
  int i;
  for (i=0; i&lt;FETCHCNT; i++)
  {
    emp_out[i].ename.arr[emp_out[i].ename.len] = &#39;\0&#39;;
    emp_out[i].job.arr[emp_out[i].job.len] = &#39;\0&#39;;
    printf(&#34;Empno=%d, Ename=%s, Job=%s, Mgr=%d, Hiredate=%s, Sal=%6.2f,\n&#34;
           &#34;Comm=%5.2f, Deptno=%d\n&#34;, emp_out[i].empno, emp_out[i].ename.arr,
 emp_out[i].job.arr, emp_out[i].mgr, emp_out[i].hiredate,
 emp_out[i].sal, emp_out[i].comm, emp_out[i].deptno);
  }
}
 
/* Error handling function. */
void sql_error(char *msg)
{
  exec sql whenever sqlerror continue;
 
  printf(&#34;\n%s\n&#34;, msg);
  printf(&#34;%.70s\n&#34;, sqlca.sqlerrm.sqlerrmc); 
  exec sql rollback release;
 
  exit(EXIT_FAILURE);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="CHDEFGAC"></a>
<div id="LNPCC3487" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Implicit Buffered Insert</h2>
<p>For improved performance, Pro*C/C++ application developers can reference host arrays in their embedded SQL statements. This provides a means to execute an array of SQL statements with a single round-trip to the database. Despite the significant performance improvements afforded by array execution, some developers choose not to use this capability because it is not ANSI standard. For example, an application written to exploit array execution in Oracle cannot be precompiled using IBM&#39;s precompiler.</p>
<p>One workaround is to use buffered INSERT statements, which enable you to gain performance benefits while retaining ANSI standard embedded SQL syntax.</p>
<p>The command line option &#34;max_row_insert&#34; controls the number of rows to be buffered before executing the INSERT statement. By default it is zero and the feature is disabled. To enable this feature, specify any number greater than zero.</p>
<p>If insert bufering is enabled, precompiler runtime will flag the corresponding cursor and:</p>
<ul>
<li>
<p>Allocate or re-allocate extra memory to hold bind values (first execute only).</p>
</li>
<li>
<p>Copy bind values from program host variables to internal runtime bind structures.</p>
</li>
<li>
<p>Increment the rows buffered count.</p>
</li>
<li>
<p>Flush the buffered INSERT statements if MAX_INSERT_ROWS have been buffered.</p>
</li>
<li>
<p>If MAX_INSERT_ROWS has not been hit, then return after copying the values to the internal bind buffers without flushing.</p>
</li>
</ul>
<p>If a new embedded SQL statement is executed and results in a flush of the buffered insert statements:</p>
<ul>
<li>
<p>Flush the buffers.</p>
</li>
<li>
<p>Continue with the call that prompted the flush.</p>
</li>
</ul>
<p>The application is informed of the error through the standard precompiler error mechanisms such as the sqlca in Pro*C.</p>
<p>The &#34;implicit_svpt&#34; option controls whether an implicit savepoint is taken prior to the start of a new batched insert.</p>
<ul>
<li>
<p>If yes, a savepoint is taken prior to the start of a new batch of rows. If an error occurs on the insert, an implicit &#34;rollback to savepoint&#34; is executed.</p>
</li>
<li>
<p>If no, there is no implicit savepoint taken. If an error occurs on the buffered insert, then it is reported back to the application, but no rollback is executed. Errors are reported asynchronously for buffer inserts. Errors for inserted rows are not reported when the INSERT statement is executed in the application.</p>
<ul>
<li>
<p>Some errors for inserted rows are reported later, when the first statement other than the INSERT is executed. This may include DELETE, UPDATE, INSERT (into different tables), COMMIT, and ROLLBACK. Any statement that closes the buffered insert statement can report an error. In such cases, the statement that reports the error is not executed. You need to first handle the error and also reexecute the statement on which the buffered insert error is reported. Otherwise, you may rollback the transaction and reexecute it.</p>
<p>For example, consider using a COMMIT statement to close a buffered insert loop. COMMIT can report an error because of a duplicate key from an earlier insert. In this scenario, the commit is not executed. You should first handle the error and then reexecute COMMIT. Otherwise, you can rollback the transaction and reexecute it.</p>
</li>
<li>
<p>Some errors are reported on the insert itself, and may reflect an error of a previously inserted row. In such cases, no further inserts are executed. You need to handle the errors of the previously inserted row and continue inserting the current insert, which is a long process. Instead, you may rollback and reexecute the transaction.</p>
<p>For example, consider that the limit of internal buffer is 10 rows and the application is inserting 15 rows in a loop. Suppose there is an error on the 8th row. The error is reported when the 11th row insert happens and the insert is no more executed further.</p>
</li>
</ul>
</li>
</ul>
<p>The following are some of the possible errors that you might face during buffered insert:</p>
<ul>
<li>
<p>ORA-00001: duplicate key in index</p>
</li>
<li>
<p>ORA-01400: mandatory (not null) column is missing or Null during insert</p>
</li>
<li>
<p>ORA-01401: inserted value too large for column</p>
</li>
<li>
<p>ORA-01438: value larger than specified precision allows for this column</p>
</li>
</ul>
<div id="LNPCC3488" class="example">
<p class="titleinexample"><a id="sthref1128"></a>Example 8-2 Inserting Buffered Rows into a Table</p>
<p>This program inserts LOOPCNT number of rows into the EMP table. At loop counter=5, this program attempts to insert an invalid empno. Without the max_row_insert option, the program inserts all rows except the invalid row. When the max_row_insert option is set to LOOPCNT, only the first four rows are inserted.</p>
<p>Using the max_row_insert option, when the erroneous statement is removed, the program performs the same way an array insert program would.</p>
<pre>/* 
 * bufinsdemo.pc 
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlda.h&gt;
#include &lt;sqlcpr.h&gt;
#include &lt;sqlca.h&gt;

/* Number of rows to be inserted into the table */
#define LOOPCNT 100

/* Define a host structure
   for inserting data into the table 
   and for fetching data from the table */
struct emprec
{
  int empno;
  varchar ename[10];
  varchar job[9];
  int mgr;
  char hiredate[10];
  float sal;
  float comm;
  int deptno;
};
typedef struct emprec buffinstyp;

/* Function prototypes */
void sql_error();
void insertdata();
void fetchdata();
void printempdata(buffinstyp);

void main()
{

  exec sql begin declare section;
    char *uid = &#34;scott/tiger&#34;;
  exec sql end declare section;

  exec sql whenever sqlerror do sql_error();
  exec sql connect :uid;

  printf(&#34;\nInserting %d rows into EMP table.\n&#34;, LOOPCNT);
  insertdata();
  printf(&#34;\nFetching inserted data from EMP table.\n&#34;);
  fetchdata();

  exec sql delete from emp where empno &lt; 1000;

  exec sql commit work release;
  exit(EXIT_SUCCESS);
}

/* Inserting data into the table */
void insertdata() 
{
  int i, cnt;
  char *str;
  buffinstyp emp_in;

  /* To store temporary strings */
  str = (char *)malloc (25 * sizeof(char));

  /*
   * When max_row_insert option is set to LOOPCNT and when the errorneous
   * statement is removed, all the rows will be inserted into the database in
   * one stretch and hence maximum performance gain will be achieved.
 */
  for (i = 1; i &lt;= LOOPCNT; i++)
  {
    if (i != 5)
      emp_in.empno = i;
    else
    /* Errorneous statement. In emp table, empno is defined as number(4). */
      emp_in.empno = 10000;

    sprintf(str, &#34;EMP_%03d&#34;, i);
    strcpy (emp_in.ename.arr, str);
    emp_in.ename.len = strlen (emp_in.ename.arr);
    sprintf(str, &#34;JOB_%03d&#34;, i);
    strcpy (emp_in.job.arr, str);
    emp_in.job.len = strlen (emp_in.job.arr);
    emp_in.mgr = i+1001;
    sprintf(str, &#34;%02d-MAY-06&#34;, (i%30));
    strcpy (emp_in.hiredate, str);
    emp_in.sal = (i) * 10;
    emp_in.comm = (i) * 0.1;
    emp_in.deptno = 10;

    exec sql insert into emp values (:emp_in);
  }

  free (str);

  exec sql commit;

  exec sql select count(*) into :cnt from emp where ename like &#39;EMP_%&#39;;
  printf (&#34;Number of rows successfully inserted into emp table: %d\n&#34;, cnt);
}

/* Fetches data from the table*/
void fetchdata()
{
  buffinstyp emp_out;

  /* Declares cursor to fetch only the rows that are inserted */
  exec sql declare c1 cursor for
         select empno, ename, job, mgr, hiredate, sal, comm, deptno
         from emp where ename like &#39;EMP_%&#39; order by empno;
  
  exec sql open c1;

  exec sql whenever not found do break;
  while(1)
  {
    /* Fetches single row at each call */
    exec sql fetch c1 into :emp_out;
    printempdata(emp_out);
  }
  exec sql whenever not found do sql_error();

  exec sql close c1;
}

/* Prints the fetched employee data */
void printempdata(buffinstyp emp_out)
{
  emp_out.ename.arr[emp_out.ename.len] = &#39;\0&#39;;
  emp_out.job.arr[emp_out.job.len] = &#39;\0&#39;;
  printf(&#34;Empno=%d, Ename=%s, Job=%s, Mgr=%d, Hiredate=%s, Sal=%6.2f,\n&#34;
         &#34;Comm=%5.2f, Deptno=%d\n&#34;, emp_out.empno, emp_out.ename.arr,
 emp_out.job.arr, emp_out.mgr, emp_out.hiredate, emp_out.sal,
 emp_out.comm, emp_out.deptno);
}

/* Error handling function. */
void sql_error()
{
   printf(&#34;Error %s\n&#34;, sqlca.sqlerrm.sqlerrmc);
   printf(&#34; Rows Processed: %d\n&#34;, sqlca.sqlerrd[2]);
   printf(&#34; Rows Rolled Back: %d\n&#34;, sqlca.sqlerrd[0]);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<div id="LNPCC3489" class="sect1"><!-- infolevel="all" infotype="General" --><a id="sthref1129"></a>
<h2 class="sect1">Scrollable Cursors</h2>
<p>A scrollable cursor is a work area where Oracle executes SQL statements and stores information that is processed during execution.When a cursor is executed, the results of the query are placed into a a set of rows called the result set. The result set can be fetched either sequentially or non-sequentially. Non-sequential result sets are called scrollable cursors. A scrollable cursor enables users to access the rows of a database result set in a forward, backward, and random manner. This enables the program to fetch any row in the result set.</p>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_07pls.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_09err.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>