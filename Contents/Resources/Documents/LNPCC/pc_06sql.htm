<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78006"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Embedded%20SQL"></a><title>Embedded SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:38Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_05adv.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_07pls.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/35</span> <!-- End Header -->
<div id="LNPCC3339" class="chapter"><a id="g19457"></a>
<h1 class="chapter"><span class="secnum">6</span> Embedded SQL</h1>
<p>This chapter helps you to understand and apply the basic techniques of embedded SQL programming. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i8115">Host Variables</a></p>
</li>
<li>
<p><a href="#i2144">Indicator Variables</a></p>
</li>
<li>
<p><a href="#i2167">The Basic SQL Statements</a></p>
</li>
<li>
<p><a href="#i5385">The DML Returning Clause</a></p>
</li>
<li>
<p><a href="#i2201">Cursors</a></p>
</li>
<li>
<p><a href="#i13177">Scrollable Cursors</a></p>
</li>
<li>
<p><a href="#i6874">Optimizer Hints</a></p>
</li>
<li>
<p><a href="#CHDHCGEI">Fix Execution Plan</a></p>
</li>
<li>
<p><a href="#i6550">The CURRENT OF Clause</a></p>
</li>
<li>
<p><a href="#i2235">The Cursor Statements</a></p>
</li>
<li>
<p><a href="#i2240">A Complete Example Using Non-Scrollable Cursor</a></p>
</li>
<li>
<p><a href="#i8106">A Complete Example Using Scrollable Cursor</a></p>
</li>
</ul>
<a id="i8115"></a>
<div id="LNPCC3340" class="sect1">
<h2 class="sect1">Host Variables</h2>
<p>Oracle uses host variables to pass data and status information to your program; your program uses host variables to pass data to Oracle.<a id="sthref785"></a></p>
<div id="LNPCC3341" class="sect2"><a id="sthref786"></a>
<h3 class="sect2">Output versus Input Host Variables</h3>
<p>Depending on how they are used, host variables are called output or input host variables.<a id="sthref787"></a><a id="sthref788"></a></p>
<p>Host variables in the INTO clause of a SELECT or FETCH statement are called <span class="italic">output</span> host variables because they hold column values output by Oracle. Oracle assigns the column values to corresponding output host variables in the INTO clause.<a id="sthref789"></a><a id="sthref790"></a><a id="sthref791"></a></p>
<p>All other host variables in a SQL statement are called <span class="italic">input</span> host variables because your program inputs their values to Oracle. For example, you use input host variables in the VALUES clause of an INSERT statement and in the SET clause of an UPDATE statement. They are also used in the WHERE, HAVING, and FOR clauses. Input host variables can appear in a SQL statement wherever a value or expression is allowed.<a id="sthref792"></a><a id="sthref793"></a><a id="sthref794"></a></p>
<div class="infobox-note">
<p class="notep1">Attention:</p>
In an ORDER BY clause, you <span class="italic">can</span> use a host variable, but it is treated as a constant or literal, and hence the contents of the host variable have no effect. For example, the SQL statement
<pre>EXEC SQL SELECT ename, empno INTO :name,:number FROM emp ORDER BY :ord;
</pre>
<p>appears to contain an input host variable <span class="italic">:ord</span>. However, the host variable in this case is treated as a constant, and regardless of the value of <span class="italic">:ord</span>, no ordering is done.</p>
</div>
<p>You cannot use input host variables to supply SQL keywords or the names of database objects. Thus, you cannot use input host variables in data definition statements such as ALTER, CREATE, and DROP. In the following example, the DROP TABLE statement is <span class="italic">invalid</span>:<a id="sthref795"></a><a id="sthref796"></a></p>
<pre>char table_name[30]; 
 
printf(&#34;Table name? &#34;); 
gets(table_name); 
 
EXEC SQL DROP TABLE :table_name;  -- host variable not allowed 
</pre>
<p>If you need to change database object names at runtime, use dynamic SQL. See also <a href="pc_13dyn.htm#g19220">Chapter 13, &#34;Oracle Dynamic SQL&#34;</a>.</p>
<p>Before Oracle executes a SQL statement containing input host variables, your program must assign values to them. An example follows:<a id="sthref797"></a></p>
<pre>int     emp_number; 
char    temp[20];
VARCHAR emp_name[20]; 

/* get values for input host variables */ 
printf(&#34;Employee number? &#34;); 
gets(temp);
emp_number = atoi(temp);
printf(&#34;Employee name? &#34;); 
gets(emp_name.arr); 
emp_name.len = strlen(emp_name.arr); 
 
EXEC SQL INSERT INTO EMP (EMPNO, ENAME) 
    VALUES (:emp_number, :emp_name); 
</pre>
<p>Notice that the input host variables in the VALUES clause of the INSERT statement are prefixed with colons.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2144"></a>
<div id="LNPCC3342" class="sect1">
<h2 class="sect1">Indicator Variables</h2>
<p>You can associate any host variable with an optional indicator variable. Each time the host variable is used in a SQL statement, a result code is stored in its associated indicator variable. Thus, indicator variables let you monitor host variables.<a id="sthref798"></a><a id="sthref799"></a><a id="sthref800"></a><a id="sthref801"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot use multiple indicator variables with a single host variable within PL/SQL blocks. Doing so results in a &#34;not all variables bound&#34; error.</div>
<p>You use indicator variables in the VALUES or SET clauses to assign NULLs to input host variables. Use indicator variables in the INTO clause to detect NULLs or truncated values in output host variables.</p>
<p class="subhead1"><a id="LNPCC3343"></a>On Input</p>
<p>The values your program can assign to an indicator variable have the following meanings:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="meanings for input indicator variable values" summary="Variables" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t4">Variable</th>
<th class="cellalignment832" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t4" headers="r1c1-t4">-1</td>
<td class="cellalignment833" headers="r2c1-t4 r1c2-t4">Oracle will assign a NULL to the column, ignoring the value of the host variable.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t4" headers="r1c1-t4">&gt;=0</td>
<td class="cellalignment833" headers="r3c1-t4 r1c2-t4">Oracle will assign the value of the host variable to the column.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="LNPCC3344"></a>On Output</p>
<p>The values Oracle can assign to an indicator variable have the following meanings:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="meanings for output indicator variable values" summary="variables" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t5"><span class="bold">Variable</span></th>
<th class="cellalignment832" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t5" headers="r1c1-t5">-1</td>
<td class="cellalignment833" headers="r2c1-t5 r1c2-t5">The column value is NULL, so the value of the host variable is indeterminate.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t5" headers="r1c1-t5">0</td>
<td class="cellalignment833" headers="r3c1-t5 r1c2-t5">Oracle assigned an intact column value to the host variable.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t5" headers="r1c1-t5">&gt;0</td>
<td class="cellalignment833" headers="r4c1-t5 r1c2-t5">Oracle assigned a truncated column value to the host variable. The integer returned by the indicator variable is the original length of the column value, and SQLCODE in SQLCA is set to zero.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t5" headers="r1c1-t5">-2</td>
<td class="cellalignment833" headers="r5c1-t5 r1c2-t5">Oracle assigned a truncated column variable to the host variable, but the original column value could not be determined (a LONG column, for example).</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>Remember, an indicator variable must be defined as a 2-byte integer and, in SQL statements, must be prefixed with a colon and must immediately follow its host variable.<a id="sthref802"></a><a id="sthref803"></a><a id="sthref804"></a><a id="sthref805"></a><a id="sthref806"></a></p>
<div id="LNPCC3345" class="sect2"><a id="sthref807"></a>
<h3 class="sect2">Insert NULLs</h3>
<p>You can use indicator variables to INSERT NULLs. Before the INSERT, for each column you want to be NULL, set the appropriate indicator variable to -1, as shown in the following example:<a id="sthref808"></a><a id="sthref809"></a></p>
<pre>set ind_comm = -1; 
 
EXEC SQL INSERT INTO emp (empno, comm) 
     VALUES (:emp_number, :commission:ind_comm); 
</pre>
<p>The indicator variable <span class="italic">ind_comm</span> specifies that a NULL is to be stored in the COMM column.</p>
<p>You can hard code the NULL instead, as follows:<a id="sthref810"></a></p>
<pre>EXEC SQL INSERT INTO emp (empno, comm) 
     VALUES (:emp_number, NULL); 
</pre>
<p>While this is less flexible, it might be more readable. Typically, you insert NULLs conditionally, as the next example shows:</p>
<pre>printf(&#34;Enter employee number or 0 if not available: &#34;); 
scanf(&#34;%d&#34;, &amp;emp_number); 
 
if (emp_number == 0) 
    ind_empnum = -1; 
else 
    ind_empnum = 0; 
 
EXEC SQL INSERT INTO emp (empno, sal) 
     VALUES (:emp_number:ind_empnum, :salary); 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3346" class="sect2"><a id="sthref811"></a>
<h3 class="sect2">Returned NULLs</h3>
<p>You can also use indicator variables to manipulate returned NULLs, as the following example shows:<a id="sthref812"></a><a id="sthref813"></a></p>
<pre>EXEC SQL SELECT ename, sal, comm 
    INTO :emp_name, :salary, :commission:ind_comm 
    FROM emp 
    WHERE empno = :emp_number; 
 if (ind_comm == -1) 
    pay = salary;   /* commission is NULL; ignore it */ 
else 
    pay = salary + commission; 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3347" class="sect2"><a id="sthref814"></a>
<h3 class="sect2">Fetch NULLs</h3>
<p>When DBMS=V7 or DBMS=V8, if you SELECT or FETCH NULLs into a host variable not associated with an indicator variable, Oracle issues the following error message:</p>
<pre>ORA-01405: fetched column value is NULL 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#i4752">&#34;DBMS&#34;</a></div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3348" class="sect2"><a id="sthref815"></a>
<h3 class="sect2">Test for NULLs</h3>
<p>You can use indicator variables in the WHERE clause to test for NULLs, as the following example shows:</p>
<pre>EXEC SQL SELECT ename, sal 
INTO :emp_name, :salary 
FROM emp 
WHERE :commission INDICATOR :ind_comm IS NULL ... 
</pre>
<p>However, you cannot use a relational operator to compare NULLs with each other or with other values. For example, the following SELECT statement fails if the COMM column contains one or more NULLs:<a id="sthref816"></a><a id="sthref817"></a><a id="sthref818"></a><a id="sthref819"></a></p>
<pre>EXEC SQL SELECT ename, sal 
INTO :emp_name, :salary 
FROM emp 
WHERE comm = :commission; 
</pre>
<p>The next example shows how to compare values for equality when some of them might be NULLs:</p>
<pre>EXEC SQL SELECT ename, sal 
     INTO :emp_name, :salary 
     FROM emp 
     WHERE (comm = :commission) OR ((comm IS NULL) AND 
          (:commission INDICATOR :ind_comm IS NULL)); 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3349" class="sect2"><a id="sthref820"></a>
<h3 class="sect2">Truncated Values</h3>
<p>When DBMS=V7 or V8, if you SELECT or FETCH a truncated column value into a host variable not associated with an indicator variable, a warning is generated instead of an error.<a id="sthref821"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2167"></a>
<div id="LNPCC3350" class="sect1">
<h2 class="sect1">The Basic SQL Statements</h2>
<p>Executable SQL statements let you query, manipulate, and control Oracle data and create, define, and maintain Oracle objects such as tables, views, and indexes. This chapter focuses on the statements that query and manipulate data.<a id="sthref822"></a></p>
<p>When executing a data manipulation statement such as INSERT, UPDATE, or DELETE, your only concern, besides setting the values of any input host variables, is whether the statement succeeds or fails. To find out, you simply check the SQLCA. (Executing any SQL statement sets the SQLCA variables.) You can check in the following two ways:<a id="sthref823"></a></p>
<ul>
<li>
<p>Implicit checking with the WHENEVER statement</p>
</li>
<li>
<p>Explicit checking of SQLCA variables</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_09err.htm#g35612">Chapter 9, &#34;Handling Runtime Errors&#34;</a> for more information about the SQLCA and the WHENEVER statement</div>
</li>
</ul>
<p>When executing a SELECT statement (query), however, you must also deal with the rows of data it returns. Queries can be classified as follows:<a id="sthref824"></a></p>
<ul>
<li>
<p>Queries that return no rows (that is, merely check for existence)</p>
</li>
<li>
<p>Queries that return only one row</p>
</li>
<li>
<p>Queries that return more than one row</p>
</li>
</ul>
<p>Queries that return more than one row require explicitly declared cursors or the use of <span class="italic">host arrays</span> (host variables declared as arrays). <a id="sthref825"></a> <a id="sthref826"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Host arrays let you process &#34;batches&#34; of rows.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_08arr.htm#g20885">Chapter 8, &#34;Host Arrays&#34;</a></div>
<p>This chapter assumes the use of scalar host variables.</p>
<p>The following embedded SQL statements let you query and manipulate Oracle data:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="4 sql statements and their descriptions" summary="Embedded SQL statements" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t10">Embedded SQL Statements</th>
<th class="cellalignment832" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t10" headers="r1c1-t10">SELECT</td>
<td class="cellalignment833" headers="r2c1-t10 r1c2-t10">Returns rows from one or more tables.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t10" headers="r1c1-t10">INSERT</td>
<td class="cellalignment833" headers="r3c1-t10 r1c2-t10">Adds new rows to a table.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t10" headers="r1c1-t10">UPDATE</td>
<td class="cellalignment833" headers="r4c1-t10 r1c2-t10">Modifies rows in a table.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t10" headers="r1c1-t10">DELETE</td>
<td class="cellalignment833" headers="r5c1-t10 r1c2-t10">Removes unwanted rows from a table.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>The following embedded SQL statements let you define and manipulate an explicit cursor:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="4 sql statements and their descriptions" summary="Embedded SQL statements" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t11">Embedded SQL Statements</th>
<th class="cellalignment832" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t11" headers="r1c1-t11">DECLARE</td>
<td class="cellalignment833" headers="r2c1-t11 r1c2-t11">Names the cursor and associates it with a query.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t11" headers="r1c1-t11">OPEN</td>
<td class="cellalignment833" headers="r3c1-t11 r1c2-t11">Executes the query and identifies the active set.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t11" headers="r1c1-t11">FETCH</td>
<td class="cellalignment833" headers="r4c1-t11 r1c2-t11">Advances the cursor and retrieves each row in the active set, one by one.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t11" headers="r1c1-t11">CLOSE</td>
<td class="cellalignment833" headers="r5c1-t11 r1c2-t11">Disables the cursor (the active set becomes undefined).</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p><a id="sthref827"></a>The following sections, you first learn how to code INSERT, UPDATE, DELETE, and single-row SELECT statements. Then, you progress to multirow SELECT statements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_afemb.htm#CHEJCBII">Appendix E, &#34; Embedded SQL Statements and Directives&#34;</a> for a detailed discussion of each statement and its clauses.</p>
</li>
<li>
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
</ul>
</div>
<a id="i5829"></a>
<div id="LNPCC3351" class="sect2">
<h3 class="sect2">The SELECT Statement</h3>
<p>Querying the database is a common SQL operation. To issue a query you use the SELECT statement. In the following example, you query the EMP table:<a id="sthref828"></a><a id="sthref829"></a><a id="sthref830"></a></p>
<pre>EXEC SQL SELECT ename, job, sal + 2000 
INTO :emp_name, :job_title, :salary 
FROM emp 
WHERE empno = :emp_number; 
</pre>
<p>The column names and expressions following the keyword SELECT make up the <span class="italic">select list</span>. The select list in our example contains three items. Under the conditions specified in the WHERE clause (and following clauses, if present), Oracle returns column values to the host variables in the INTO clause.<a id="sthref831"></a><a id="sthref832"></a><a id="sthref833"></a><a id="sthref834"></a><a id="sthref835"></a></p>
<p>The number of items in the select list should equal the number of host variables in the INTO clause, so there is a place to store every returned value.<a id="sthref836"></a></p>
<p>In the simplest case, when a query returns one row, its form is that shown in the last example. However, if a query can return more than one row, you must FETCH the rows using a cursor or SELECT them into a host-variable array. Cursors and the FETCH statement are discussed later in this chapter. See also <a href="pc_08arr.htm#g20885">&#34;Host Arrays&#34;</a><a id="sthref837"></a>for information on array processing.</p>
<p>If a query is written to return only one row but might actually return several rows, the result of the SELECT is indeterminate. Whether this causes an error depends on how you specify the SELECT_ERROR option. The default value, YES, generates an error if more than one row is returned.<a id="sthref838"></a><a id="sthref839"></a></p>
<div id="LNPCC3352" class="sect3"><a id="sthref840"></a>
<h4 class="sect3">Available Clauses</h4>
<p>You can use all of the following standard SQL clauses in your</p>
<p>SELECT statements:<a id="sthref841"></a></p>
<ul>
<li>
<p>INTO</p>
</li>
<li>
<p>FROM</p>
</li>
<li>
<p>WHERE</p>
</li>
<li>
<p>CONNECT BY</p>
</li>
<li>
<p>START WITH</p>
</li>
<li>
<p>GROUP BY</p>
</li>
<li>
<p>HAVING</p>
</li>
<li>
<p>ORDER BY</p>
</li>
<li>
<p>FOR UPDATE OF</p>
</li>
</ul>
<p>Except for the INTO clause, the text of embedded SELECT statements can be executed and tested interactively using SQL*Plus. In SQL*Plus, you use substitution variables or constants instead of input host variables.<a id="sthref842"></a><a id="sthref843"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i2177"></a>
<div id="LNPCC3353" class="sect2">
<h3 class="sect2">The INSERT Statement</h3>
<p>Use the INSERT statement to add rows to a table or view. In the following example, you add a row to the EMP table:<a id="sthref844"></a><a id="sthref845"></a></p>
<pre>EXEC SQL INSERT INTO emp (empno, ename, sal, deptno) 
VALUES (:emp_number, :emp_name, :salary, :dept_number); 
</pre>
<p>Each column you specify in the <span class="italic">column list</span> must belong to the table named in the INTO clause. The VALUES clause specifies the row of values to be inserted. The values can be those of constants, host variables, SQL expressions, SQL functions such as USER and SYSDATE, or user-defined PL/SQL functions.</p>
<p>The number of values in the VALUES clause must equal the number of names in the column list. However, you can omit the column list if the VALUES clause contains a value for each column in the table, in the order that they are defined in the table.<a id="sthref846"></a><a id="sthref847"></a><a id="sthref848"></a><a id="sthref849"></a><a id="sthref850"></a><a id="sthref851"></a><a id="sthref852"></a><a id="sthref853"></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_afemb.htm#CHEDDEJD">&#34;INSERT (Executable Embedded SQL)&#34;</a></div>
<a id="i5040"></a>
<div id="LNPCC3354" class="sect3">
<h4 class="sect3">Using Subqueries</h4>
<p>A <span class="italic">subquery</span> is a nested SELECT statement. Subqueries let you conduct multipart searches. They can be used to<a id="sthref854"></a><a id="sthref855"></a></p>
<ul>
<li>
<p>Supply values for comparison in the WHERE, HAVING, and START WITH clauses of SELECT, UPDATE, and DELETE statements</p>
</li>
<li>
<p>Define the set of rows to be inserted by a CREATE TABLE or INSERT statement</p>
</li>
<li>
<p>Define values for the SET clause of an UPDATE statement</p>
</li>
</ul>
<p>The following example uses a subquery in an INSERT statement to copy rows from one table to another:<a id="sthref856"></a><a id="sthref857"></a><a id="sthref858"></a></p>
<pre>EXEC SQL INSERT INTO emp2 (empno, ename, sal, deptno) 
SELECT empno, ename, sal, deptno FROM emp <a id="sthref859"></a><a id="sthref860"></a> 
WHERE job= :job_title ;
</pre>
<p>This INSERT statement uses the subquery to obtain intermediate results.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i4525"></a>
<div id="LNPCC3355" class="sect2">
<h3 class="sect2">The UPDATE Statement</h3>
<p>Use the UPDATE statement to change the values of specified columns in a table or view. In the following example, we update the <code>SAL</code> and <code>COMM</code> columns in the <code>EMP</code> table:</p>
<pre>EXEC SQL UPDATE emp 
SET sal = :salary, comm = :commission 
WHERE empno = :emp_number;
</pre>
<p>Use the optional WHERE clause to specify the conditions under which rows are updated. See also <a href="#i2139">&#34;The WHERE Clause&#34;</a>.<a id="sthref861"></a><a id="sthref862"></a></p>
<p>The SET clause lists the names of one or more columns for which you must provide values. You can use a subquery to provide the values, as the following example shows:<a id="sthref863"></a><a id="sthref864"></a><a id="sthref865"></a><a id="sthref866"></a><a id="sthref867"></a><a id="sthref868"></a></p>
<pre>EXEC SQL UPDATE emp 
SET sal = (SELECT AVG(sal)*1.1 FROM emp WHERE deptno = 20) 
WHERE empno = :emp_number; 
</pre>
<p><a id="sthref869"></a>The UPDATE statement has an optional <code>returning clause</code>, like the INSERT and DELETE statements. It is only allowed after the optional WHERE condition.</p>
<p>For more details, see also <a href="pc_afemb.htm#CHEGDJBF">&#34;UPDATE (Executable Embedded SQL)&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i2192"></a>
<div id="LNPCC3356" class="sect2">
<h3 class="sect2">The DELETE Statement</h3>
<p>Use the DELETE statement to remove rows from a table or view. In the following example, you delete all employees in a given department from the EMP table:<a id="sthref870"></a><a id="sthref871"></a></p>
<pre>EXEC SQL DELETE FROM emp 
WHERE deptno = :dept_number ; 
</pre>
<p>We have used the optional WHERE clause to specify the condition under which rows are deleted. <a id="sthref872"></a><a id="sthref873"></a></p>
<p><a id="sthref874"></a>The <code>returning clause</code> option can be used in DELETE statements also. It is allowed after the optional WHERE condition. In the earlier example, it is good practice to record the field values of each employee that is deleted.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_afemb.htm#CHEFICFE">&#34;DELETE (Executable Embedded SQL)&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i2139"></a>
<div id="LNPCC3357" class="sect2">
<h3 class="sect2">The WHERE Clause</h3>
<p>Use the WHERE clause to SELECT, UPDATE, or DELETE only those rows in a table or view that meet your search condition. The WHERE-clause <span class="italic">search condition</span> is a Boolean expression, which can include scalar host variables, host arrays (not in SELECT statements), subqueries, and user-defined stored functions.<a id="sthref875"></a><a id="sthref876"></a><a id="sthref877"></a><a id="sthref878"></a><a id="sthref879"></a></p>
<p>If you omit the WHERE clause, all rows in the table or view are processed. If you omit the WHERE clause in an UPDATE or DELETE statement, Oracle sets <code>sqlwarn[4]</code> in the SQLCA to &#39;W&#39; to warn that all rows were processed.<a id="sthref880"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5385"></a>
<div id="LNPCC3358" class="sect1">
<h2 class="sect1">The DML Returning Clause<a id="sthref881"></a><a id="sthref882"></a></h2>
<p>The INSERT, UPDATE, and DELETE statements can have an optional <a id="sthref883"></a><span class="italic">DML returning clause</span> which returns column value expressions <span class="italic">expr</span>, into host variables <span class="italic">hv</span>, with host indicator variables <span class="italic">iv.</span> The DML returning clause looks like this:</p>
<pre>{RETURNING | RETURN} {expr [,expr]}
    INTO {:hv [[INDICATOR]:iv] [, :hv [[INDICATOR]:iv]]}
</pre>
<p>The number of expressions must equal the number of host variables. This clause eliminates the need for selecting the rows after an INSERT or UPDATE, and before a DELETE when you need to record that information for your application. The <code>returning clause</code> eliminates inefficient network round trips, extra processing, and server memory.</p>
<p>Oracle Dynamic SQL Method 4 does not support the DML returning clause; but ANSI Dynamic SQL Method 4 does. Support for DML statements with a DML returning clause that affects more than a single row is not supported by ANSI DYNAMIC SQL.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_14ady.htm#i1011699">Chapter 14, &#34; ANSI Dynamic SQL&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="i2201"></a>
<div id="LNPCC3359" class="sect1">
<h2 class="sect1">Cursors</h2>
<p>When a query returns multiple rows, you can explicitly define a cursor to<a id="sthref884"></a><a id="sthref885"></a></p>
<ul>
<li>
<p>Process beyond the first row returned by the query</p>
</li>
<li>
<p>Keep track of which row is currently being processed</p>
</li>
</ul>
<p>Or, you can use host arrays.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_08arr.htm#g20885">Chapter 8, &#34;Host Arrays&#34;</a></div>
<p>A cursor identifies the current row in the set of rows returned by the query. This allows your program to process the rows one at a time. The following statements let you define and manipulate a cursor:<a id="sthref886"></a><a id="sthref887"></a></p>
<ul>
<li>
<p>DECLARE CURSOR</p>
</li>
<li>
<p>OPEN</p>
</li>
<li>
<p>FETCH</p>
</li>
<li>
<p>CLOSE</p>
</li>
</ul>
<p>First you use the DECLARE CURSOR statement to name the cursor and associate it with a query.<a id="sthref888"></a><a id="sthref889"></a><a id="sthref890"></a><a id="sthref891"></a></p>
<p>The OPEN statement executes the query and identifies all the rows that meet the query search condition. These rows form a set called the active set of the cursor. After OPENing the cursor, you can use it to retrieve the rows returned by its associated query.<a id="sthref892"></a><a id="sthref893"></a></p>
<p>Rows of the active set are retrieved one by one (unless you use host arrays). You use a FETCH statement to retrieve the current row in the active set. You can execute FETCH repeatedly until all rows have been retrieved.<a id="sthref894"></a><a id="sthref895"></a></p>
<p>When done FETCHing rows from the active set, you disable the cursor with a CLOSE statement, and the active set becomes undefined.<a id="sthref896"></a><a id="sthref897"></a></p>
<p>The following sections show you how to use these cursor control statements in your application program.</p>
<a id="i2206"></a>
<div id="LNPCC3360" class="sect2">
<h3 class="sect2">The DECLARE CURSOR Statement</h3>
<p>You use the DECLARE CURSOR statement to define a cursor by giving it a name and associating it with a query, as the following example shows:<a id="sthref898"></a><a id="sthref899"></a><a id="sthref900"></a></p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
     SELECT ename, empno, sal 
     FROM emp 
     WHERE deptno = :dept_number; 
</pre>
<p>The cursor name is an identifier used by the precompiler, <span class="italic">not</span> a host or program variable, and should not be defined in the Declare Section. Therefore, cursor names cannot be passed from one precompilation unit to another. Cursor names cannot be hyphenated. They can be any length, but only the first 31 characters are significant. For ANSI compatibility, use cursor names no longer than 18 characters.<a id="sthref901"></a><a id="sthref902"></a></p>
<p>The precompiler option CLOSE_ON_COMMIT is provided for use in the command line or in a configuration file. Any cursor not declared with the WITH HOLD clause is closed after a COMMIT or ROLLBACK when CLOSE_ON_COMMIT=YES. See <a href="pc_03dbc.htm#i4014">&#34;WITH HOLD Clause in DECLARE CURSOR Statements&#34;</a>, and <a href="pc_10opt.htm#i9360">&#34;CLOSE_ON_COMMIT&#34;</a>.<a id="sthref903"></a><a id="sthref904"></a></p>
<p>If MODE is specified at a higher level than CLOSE_ON_COMMIT, then MODE takes precedence. The defaults are MODE=ORACLE and CLOSE_ON_COMMIT=NO. If you specify MODE=ANSI then any cursors not using the WITH HOLD clause will be closed on COMMIT. The application will run more slowly because cursors are closed and re-opened many times. Setting CLOSE_ON_COMMIT=NO when MODE=ANSI results in performance improvement. To see how macro options such as MODE affect micro options such as CLOSE_ON_COMMIT, see <a href="pc_10opt.htm#i9362">&#34;Precedence of Option Values&#34;</a>.</p>
<p>The SELECT statement associated with the cursor cannot include an INTO clause. Rather, the INTO clause and list of output host variables are part of the FETCH statement.<a id="sthref905"></a></p>
<p>Because it is declarative, the DECLARE CURSOR statement must physically (not just logically) precede all other SQL statements referencing the cursor. That is, forward references to the cursor are not allowed. In the following example, the OPEN statement is misplaced:<a id="sthref906"></a><a id="sthref907"></a></p>
<pre>... 
EXEC SQL OPEN emp_cursor; 
*    -- MISPLACED OPEN STATEMENT
EXEC SQL DECLARE emp_cursor CURSOR FOR 
SELECT ename, empno, sal 
    FROM emp 
    WHERE ename = :emp_name; 
</pre>
<p>The cursor control statements (DECLARE, OPEN, FETCH, CLOSE) must all occur within the same precompiled unit. For example, you cannot DECLARE a cursor in file A, then OPEN it in file B.<a id="sthref908"></a><a id="sthref909"></a></p>
<p>Your host program can DECLARE as many cursors as it needs. However, in a given file, every DECLARE statement must be unique. That is, you cannot DECLARE two cursors with the same name in one precompilation unit, even across blocks or procedures, because the scope of a cursor is global within a file.<a id="sthref910"></a><a id="sthref911"></a></p>
<p><a id="sthref912"></a>For users of MODE=ANSI or CLOSE_ON_COMMIT=YES, the WITH HOLD clause can be used in a DECLARE section to override the behavior defined by the two options. With these options set, the behavior will be for all cursors to be closed when a COMMIT is issued. This can have performance implications due to the overhead of re-opening the cursor to continue processing. The careful use of WITH HOLD can speed up programs that need to conform to the ANSI standard for precompilers in most respects.</p>
<p>If you will be using many cursors, you might want to specify the MAXOPENCURSORS option.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_10opt.htm#i5749">&#34;Precompiler Options&#34;</a></p>
</li>
<li>
<p><a href="pc_actun.htm#CHEBGDGB">Appendix B, &#34; Performance Tuning&#34;</a><a id="sthref913"></a><a id="sthref914"></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i2211"></a>
<div id="LNPCC3361" class="sect2">
<h3 class="sect2">The OPEN Statement</h3>
<p>You use the OPEN statement to execute the query and identify the active set. In the following example, you OPEN a cursor named <span class="italic">emp_cursor</span>:<a id="sthref915"></a><a id="sthref916"></a></p>
<pre>EXEC SQL OPEN emp_cursor;
 
</pre>
<p>OPEN zeroes the rows-processed count kept by the third element of SQLERRD in the SQLCA. However, none of the rows are visible to the application at this point. That is handled by the FETCH statement.</p>
<p>OPEN positions the cursor just before the first row of the active set. It also zeroes the rows-processed count kept by the third element of SQLERRD in the SQLCA. However, none of the rows is actually retrieved at this point. That will be done by the FETCH statement.<a id="sthref917"></a></p>
<p>Once you OPEN a cursor, the query&#39;s input host variables are not re-examined until you reOPEN the cursor. Thus, the active set does not change. To change the active set, you must reOPEN the cursor.<a id="sthref918"></a><a id="sthref919"></a></p>
<p>Generally, you should CLOSE a cursor before reOPENing it. However, if you specify MODE=ORACLE (the default), you need not CLOSE a cursor before reOPENing it. This can increase performance.</p>
<p>The amount of work done by OPEN depends on the values of three precompiler options: HOLD_CURSOR, RELEASE_CURSOR, and MAXOPENCURSORS.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#i5560">&#34;Using the Precompiler Options&#34;</a>.<a id="sthref920"></a><a id="sthref921"></a></div>
</div>
<!-- class="sect2" -->
<a id="i2216"></a>
<div id="LNPCC3362" class="sect2">
<h3 class="sect2">The FETCH Statement</h3>
<p>You use the FETCH statement to retrieve rows from the active set and specify the output host variables that will contain the results. Recall that the SELECT statement associated with the cursor cannot include an INTO clause. Rather, the INTO clause and list of output host variables are part of the FETCH statement. In the following example, you FETCH INTO three host variables:<a id="sthref922"></a><a id="sthref923"></a><a id="sthref924"></a><a id="sthref925"></a></p>
<pre>EXEC SQL FETCH emp_cursor 
INTO :emp_name, :emp_number, :salary;
 
</pre>
<p>The cursor must have been previously DECLAREd and OPENed. The first time you execute FETCH, the cursor moves from before the first row in the active set to the first row. This row becomes the current row. Each subsequent execution of FETCH advances the cursor to the next row in the active set, changing the current row. The cursor can only move forward in the active set. To return to a row that has already been FETCHed, you must reOPEN the cursor, then begin again at the first row of the active set.<a id="sthref926"></a><a id="sthref927"></a><a id="sthref928"></a><a id="sthref929"></a></p>
<p>If you want to change the active set, you must assign new values to the input host variables in the query associated with the cursor, then reOPEN the cursor. When MODE=ANSI, you must CLOSE the cursor before reOPENing it.<a id="sthref930"></a></p>
<p>As the next example shows, you can FETCH from the same cursor using different sets of output host variables. However, corresponding host variables in the INTO clause of each FETCH statement must have the same datatype.</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
SELECT ename, sal FROM emp WHERE deptno = 20; 
... 
EXEC SQL OPEN emp_cursor; 
 
EXEC SQL WHENEVER NOT FOUND GOTO ... 
for (;;) 
{ 
    EXEC SQL FETCH emp_cursor INTO :emp_name1, :salary1; 
    EXEC SQL FETCH emp_cursor INTO :emp_name2, :salary2; 
    EXEC SQL FETCH emp_cursor INTO :emp_name3, :salary3; 
    ... 
} 
</pre>
<p>If the active set is empty or contains no more rows, FETCH returns the &#34;no data found&#34; error code to <span class="italic">sqlcode</span> in the SQLCA, or to the SQLCODE or SQLSTATE status variables. The status of the output host variables is indeterminate. (In a typical program, the WHENEVER NOT FOUND statement detects this error.) To reuse the cursor, you must reOPEN it. <a id="sthref931"></a><a id="sthref932"></a></p>
<p>It is an error to FETCH on a cursor under the following conditions:</p>
<ul>
<li>
<p>Before OPENing the cursor</p>
</li>
<li>
<p>After a &#34;no data found&#34; condition</p>
</li>
<li>
<p>After CLOSEing it</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i2221"></a>
<div id="LNPCC3363" class="sect2">
<h3 class="sect2">The CLOSE Statement</h3>
<p>When done FETCHing rows from the active set, you CLOSE the cursor to free the resources, such as storage, acquired by OPENing the cursor. When a cursor is closed, parse locks are released. What resources are freed depends on how you specify the HOLD_CURSOR and RELEASE_CURSOR options. In the following example, you CLOSE the cursor named <span class="italic">emp_cursor</span>:<a id="sthref933"></a><a id="sthref934"></a><a id="sthref935"></a></p>
<pre>EXEC SQL CLOSE emp_cursor; 
</pre>
<p>You cannot FETCH from a closed cursor because its active set becomes undefined. If necessary, you can reOPEN a cursor (with new values for the input host variables, for example).</p>
<p>When MODE=ORACLE, issuing a COMMIT or ROLLBACK closes cursors referenced in a CURRENT OF clause. Other cursors are unaffected by COMMIT or ROLLBACK and if open, remain open. However, when MODE=ANSI, issuing a COMMIT or ROLLBACK closes <span class="italic">all</span> explicit cursors.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_03dbc.htm#g18485">Chapter 3, &#34;Database Concepts&#34;</a> for more information about COMMIT and ROLLBACK</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i13177"></a>
<div id="LNPCC3364" class="sect1">
<h2 class="sect1">Scrollable Cursors<a id="sthref936"></a></h2>
<p>A scrollable cursor is a work area where Oracle executes SQL statements and stores information that is processed during execution.</p>
<p>When a cursor is executed, the results of the query are placed into a a set of rows called the result set. The result set can be fetched either sequentially or non-sequentially. Non-sequential result sets are called scrollable cursors.</p>
<p>A scrollable cursor enables users to access the rows of a database result set in a forward, backward, and random manner. This enables the program to fetch any row in the result set. See <span class="italic">Oracle Call Interface Programmer&#39;s Guide</span>, Release 9.2.0.</p>
<div id="LNPCC3365" class="sect2"><a id="sthref937"></a>
<h3 class="sect2">Using Scrollable Cursors</h3>
<p>The following statements let you define and manipulate a scrollable cursor.</p>
<div id="LNPCC3366" class="sect3"><a id="sthref938"></a>
<h4 class="sect3">DECLARE SCROLL CURSOR</h4>
<p>You can use the DECLARE &lt;cursor name&gt; SCROLL CURSOR statement to name the scrollable cursor and associate it with a query.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3367" class="sect3"><a id="sthref939"></a>
<h4 class="sect3">OPEN</h4>
<p>You can use the OPEN statement in the same way as in the case of a non-scrollable cursor.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3368" class="sect3"><a id="sthref940"></a>
<h4 class="sect3">FETCH</h4>
<p>You can use the FETCH statement to fetch required rows in a random manner. An application can fetch rows up or down, first or last row directly, or fetch any single row in a random manner.</p>
<p>The following options are available with the FETCH statement.</p>
<ol>
<li>
<p>FETCH FIRST</p>
<p>Fetches the first row from the result set.</p>
</li>
<li>
<p>FETCH PRIOR</p>
<p>Fetches the row prior to the current row.</p>
</li>
<li>
<p>FETCH NEXT</p>
<p>Fetches the next row from the current position. This is same as the non-scrollable cursor FETCH.</p>
</li>
<li>
<p>FETCH LAST</p>
<p>Fetches the last row from the result set.</p>
</li>
<li>
<p>FETCH CURRENT</p>
<p>Fetches the current row.</p>
</li>
<li>
<p>FETCH RELATIVE <span class="italic">n</span></p>
<p>Fetches the <span class="italic">n</span>th row relative to the current row, where <span class="italic">n</span> is the offset.</p>
</li>
<li>
<p>FETCH ABSOLUTE <span class="italic">n</span></p>
<p>Fetches the <span class="italic">n</span>th row, where <span class="italic">n</span> is the offset from the start of the result set.</p>
</li>
</ol>
<p>The following example describes how to FETCH the last record from a result set.</p>
<pre>EXEC SQL DECLARE emp_cursor SCROLL CURSOR FOR
SELECT ename, sal FROM emp WHERE deptno=20;
...
EXEC SQL OPEN emp_cursor;
EXEC SQL FETCH LAST emp_cursor INTO :emp_name, :sal;
EXEC SQL CLOSE emp_cursor;
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC3369" class="sect3"><a id="sthref941"></a>
<h4 class="sect3">CLOSE</h4>
<p>You can use the CLOSE statement in the same way as in the case of a non-scrollable cursor.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot use scrollable cursors for REF cursors.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3370" class="sect2"><a id="sthref942"></a>
<h3 class="sect2">The CLOSE_ON_COMMIT Precompiler Option<a id="sthref943"></a></h3>
<p>The CLOSE_ON_COMMIT micro precompiler option provides the ability to choose whether or not to close all cursors when a COMMIT is executed and the macro option MODE=ANSI. When MODE=ANSI, CLOSE_ON_COMMIT has the default value YES. Explicitly setting CLOSE_ON_COMMIT=NO results in better performance because cursors will not be closed when a COMMIT is executed, removing the need to re-open the cursors and incur extra parsing.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_10opt.htm#i9359">&#34;Macro and Micro Options&#34;</a> for a discussion of how micro options affect macro options.</p>
</li>
<li>
<p><a href="pc_10opt.htm#i9360">&#34;CLOSE_ON_COMMIT&#34;</a> for a complete discussion of this option.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i4711"></a>
<div id="LNPCC3371" class="sect2">
<h3 class="sect2">The <a id="sthref944"></a>PREFETCH Precompiler Option</h3>
<p>The precompiler option PREFETCH allows for more efficient queries by pre-fetching a given number of rows. This decreases the number of server round trips needed and reduces overall memory usage. The number of rows set by the PREFETCH option value is used for all queries involving explicit cursors, subject to the standard precedence rules. When used inline, the PREFETCH option must precede any of these cursor statements:</p>
<ul>
<li>
<p>EXEC SQL OPEN <span class="italic">cursor</span></p>
</li>
<li>
<p>EXEC SQL OPEN <span class="italic">cursor</span> USING <span class="italic">host_var_list</span></p>
</li>
<li>
<p>EXEC SQL OPEN <span class="italic">cursor</span> USING DESCRIPTOR <span class="italic">desc_name</span></p>
</li>
</ul>
<p>When an OPEN is executed, the value of PREFETCH gives the number of rows to be pre-fetched when the query is executed. You can set the value from 0 (no pre-fetching) to 65535. The default value is 1.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The default value of the PREFETCH option is 1 - return a single row for each round-trip. If you choose not to use the PREFETCH option, using the command line, you must explicitly disable it by setting the PREFETCH option to 0.
<p>PREFETCH is automatically disabled when LONG or LOB columns are being retrieved.</p>
</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
PREFETCH is used primarily to enhance the performance of single row fetches. PREFETCH has no effect when array fetches are used.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The PREFETCH option should be used wisely, and on a case-by-case basis. Select an appropriate PREFETCH value that will optimize performance of a specific FETCH statement. To accomplish this, use the inline prefetch option instead of the command line prefetch option.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The performance of many large applications can be improved simply by using indicator variables with host variables in FETCH statements.
<p>To enable precompiler applications to obtain the maximum advantage from the use of the PREFETCH option on single row fetches, it is strongly recommended that you use indicator variables.</p>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i6874"></a>
<div id="LNPCC3372" class="sect1">
<h2 class="sect1">Optimizer Hints<a id="sthref945"></a><a id="sthref946"></a></h2>
<p>The Pro*C/C++ Precompiler supports optimizer hints in SQL statements. An <span class="italic">optimizer hint</span> is a suggestion to the Oracle SQL optimizer that can override the optimization approach that would normally be taken. You can use hints to specify the</p>
<ul>
<li>
<p>Optimization approach for a SQL statement</p>
</li>
<li>
<p>Access path for each referenced table</p>
</li>
<li>
<p>Join order for a join</p>
</li>
<li>
<p>Method used to join tables</p>
</li>
</ul>
<p>Hints allow you to choose between rule-based and cost-based optimization. With cost-based optimization, you can use further hints to maximize throughput or response time.</p>
<div id="LNPCC3373" class="sect2"><a id="sthref947"></a>
<h3 class="sect2">Issuing Hints <a id="sthref948"></a></h3>
<p>You can issue an optimizer hint inside a C or C++ style comment, immediately after a SELECT, DELETE, or UPDATE command. You indicate that the comment contains one or more hints by following the comment opener with a plus sign, leaving no space between the opener and the &#39;+&#39;. For example, the following statement uses the ALL_ROWS hint to let the cost-based approach optimize the statement for the goal of best throughput:</p>
<pre>EXEC SQL SELECT /*+ ALL_ROWS (cost-based) */ empno, ename, sal, job 
    INTO :emp_rec FROM emp 
    WHERE deptno = :dept_number; 
</pre>
<p>As shown in this statement, the comment can contain optimizer hints as well as other comments.</p>
<p>For more information about the cost-based optimizer, and optimizer hints, see <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDHCGEI"></a>
<div id="LNPCC3374" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Fix Execution Plan</h2>
<p>In application development environments where modules are developed in one environment, and then integrated and deployed into another, the performance of the applications are affected. At times, the performance of the precompiler applications are affected by changes in the database environment. These may include changes in the optimizer statistics, changes to the optimizer settings, or changes to parameters affecting the sizes of memory structures.</p>
<p>To fix execution plans for SQL&#39;s used in Pro*C/C++ in the development environment, you need to use the outline feature of Oracle at the time of precompiling. An outline is implemented as a set of optimizer hints that are associated with the SQL statement. If you enable the use of the outline for the statement, Oracle automatically considers the stored hints and tries to generate an execution plan in accordance with those hints. In this way, you can ensure that the performance is not affected when the modules are integrated or deployed into different environments.</p>
<p>You can use the following SQL statements to create outlines in Pro*C/C++:</p>
<ul>
<li>
<p><code>SELECT</code></p>
</li>
<li>
<p><code>DELETE</code></p>
</li>
<li>
<p><code>UPDATE</code></p>
</li>
<li>
<p><code>INSERT ... SELECT</code></p>
</li>
<li>
<p><code>CREATE TABLE ... AS SELECT</code></p>
</li>
</ul>
<p>If the outline option is set, then the precompiler generates two files, a SQL file and a LOG file at the end of successful precompilation. Command line options <code>outline</code> and <code>outlnprefix</code> control the generation of the outlines.</p>
<p>Each generated outline name is unique. Because the file names used in the application are unique, this information is used in generating the outline name. In addition, the category name is also prefixed.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Oracle allows only 30 bytes for the outline name. If you exceed the limit, the precompiler will flag an error. You can restrict the length of the outline name by using the <code>outlnprefix</code> option.</div>
<div id="LNPCC3375" class="example">
<p class="titleinexample"><a id="sthref949"></a>Example 6-1 Generating a SQL File Containing Outlines</p>
<p>You need to precompile the following program by using the outline option to generate SQL files containing the outlines for all the outline-supported SQL statements in this program.</p>
<pre>/* 
 * outlndemo.pc 
 *
 * Outlines will be created for the following SQL operations,
 * 1. CREATE ... SELECT
 * 2. INSERT ... SELECT
 * 3. UPDATE
 * 4. DELETE
 * 5. SELECT
 */
 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlda.h&gt;
#include &lt;sqlcpr.h&gt;
#include &lt;sqlca.h&gt;
 
/* Error handling function. */
void sql_error(char *msg)
{
  exec sql whenever sqlerror continue;
 
  printf(&#34;\n%s\n&#34;, msg);
  printf(&#34;%.70s\n&#34;, sqlca.sqlerrm.sqlerrmc); 
  exec sql rollback release;
 
  exit(EXIT_FAILURE);
}
 
int main()
{
  varchar ename[10];
  varchar job[9];
  float sal, comm;
 
  exec sql begin declare section;
    char *uid = &#34;scott/tiger&#34;;
  exec sql end declare section;
 
  exec sql whenever sqlerror do sql_error(&#34;ORACLE error--\n&#34;);
  exec sql connect :uid;
 
  exec sql insert into bonus 
           select ename, job, sal, comm from emp where job like &#39;SALESMAN&#39;;
 
  exec sql update bonus set sal = sal * 1.1 where sal &lt; 1500;
 
  exec sql declare c1 cursor for
           select ename, job, sal, comm from bonus order by sal;
  exec sql open c1;
  printf (&#34;Contents of updated BONUS table\n\n&#34;);
  printf (&#34;ENAME       JOB        SALARY   COMMISSION\n\n&#34;);
  exec sql whenever not found do break;
  while (1)
  {
    exec sql fetch c1 into :ename, :job, :sal, :comm;
    ename.arr[ename.len]=&#39;\0&#39;;
    job.arr[job.len]=&#39;\0&#39;;
    printf (&#34;%-9s %-9s   %8.2f    %8.2f\n&#34;, ename.arr,
            job.arr, sal, comm);
  }
  exec sql close c1;
  exec sql whenever not found do sql_error(&#34;ORACLE error--\n&#34;);
 
  exec sql delete from bonus;
 
  exec sql create table outlndemo_tab as
           select empno, ename, sal from emp where deptno = 10;
 
  /* Outline will not be created for this DDL statement */
  exec sql drop table outlndemo_tab;
 
  exec sql rollback work release;
  exit(EXIT_SUCCESS);
}
</pre></div>
<!-- class="example" -->
<div id="LNPCC3376" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref950"></a>
<h3 class="sect2">SQL File</h3>
<p>The generated file name has the following format:</p>
<pre>&lt;filename&gt;_&lt;filetype&gt;.sql
</pre>
<p>In Pro*C, for the file &#34;abc.pc&#34;, the generated SQL file will be abc_pc.sql.</p>
<p class="subhead2"><a id="LNPCC3377"></a>Generated file format</p>
<p>If the outlnprefix option is not used, then the format of the unique identifier used as outline name and comment is:</p>
<pre>&lt;category_name&gt;_&lt;filename&gt;_&lt;filetype&gt;_&lt;sequence no.&gt;
</pre>
<p>If the outlnprefix option is used (outlnprefix=&lt;prefix_name&gt;), then the format of the unique identifier used as outline name and comment is:</p>
<pre>&lt;prefix_name&gt;_&lt;sequence no.&gt;
</pre>
<p>If outline=yes, which is the default category, then &lt;category_name&gt; will be DEFAULT and outline name will be:</p>
<pre>DEFAULT_&lt;filename&gt;_&lt;filetype&gt;_&lt;sequence no.&gt;
</pre>
<p>or</p>
<pre>&lt;prefix_name&gt;_&lt;sequence no.&gt;
</pre>
<p>The allowed range for <code>&lt;sequence no.&gt;</code> is 0000 to 9999.</p>
<p>SQL in the generated precompiled file will have the comment appended to it as it appears in the outline for that SQL.</p>
<div id="LNPCC3378" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref951"></a>
<h4 class="sect3">Examples</h4>
<p>Consider the following examples.</p>
<p class="subhead2"><a id="LNPCC3379"></a>Example 1</p>
<p>If abc.pc has the statements</p>
<pre>EXEC SQL select * from emp where empno=:var;
EXEC SQL select * from dept;
</pre>
<p>and if outline=mycat1 and outlnprefix is not used, then:</p>
<p class="subhead2"><a id="LNPCC3380"></a>Contents of abc_pc.sql</p>
<p>create or replace outline mycat1_abc_pc_0000 for category mycat1 on <code>select * from emp where empno=:b1 /* mycat1_abc_pc_0000 */</code><code>;</code></p>
<p>create or replace outline mycat1_abc_pc_0001 for category mycat1 on <code>select * from dept /* mycat1_abc_pc_0001 */;</code></p>
<p class="subhead2"><a id="LNPCC3381"></a>Contents of abc.c</p>
<pre>sqlstm.stmt = select * from emp where empno=:b1 /* mycat1_abc_pc_0000 */;

sqlstm.stmt = select * from dept /* mycat1_abc_pc_0001 */;
</pre>
<p class="subhead2"><a id="LNPCC3382"></a>Example 2</p>
<p>If abc.pc has the statements</p>
<pre>EXEC SQL select * from emp where empno=:var;
EXEC SQL select * from dept;
</pre>
<p>and if outline=mycat1 and outlnprefix=myprefix, then:</p>
<p class="subhead2"><a id="LNPCC3383"></a>Contents of abc_pc.sql</p>
<p>create or replace outline myprefix_0000 for category mycat1 on <code>select * from emp where empno=:b1 /* myprefix_0000 */;</code></p>
<p>create or replace outline myprefix_0001 for category mycat1 on <code>select * from dept /* myprefix_0001 */;</code></p>
<p class="subhead2"><a id="LNPCC3384"></a>Contents of abc.c</p>
<pre>sqlstm.stmt = select * from emp where empno=:b1 /* myprefix_0000 */;

sqlstm.stmt = select * from dept /* myprefix_0001 */;
</pre>
<p class="subhead2"><a id="LNPCC3385"></a>Example 3</p>
<p>If abc.pc has the statements</p>
<pre>EXEC SQL select * from emp where empno=:var;
EXEC SQL select * from dept;
</pre>
<p>and if outline=yes and outlnprefix=myprefix, then:</p>
<p class="subhead2"><a id="LNPCC3386"></a>Contents of abc_pc.sql</p>
<p>create or replace outline myprefix_0000 on <code>select * from emp where empno=:b1 /* myprefix_0000 */;</code></p>
<p>create or replace outline myprefix_0001 on <code>select * from dept /* myprefix_0001 */;</code></p>
<p class="subhead2"><a id="LNPCC3387"></a>Contents of abc.c</p>
<pre>sqlstm.stmt = &#34;select * from emp where empno=:b1 /* myprefix_0000 */;

sqlstm.stmt = &#34;select * from dept /* myprefix_0001 */&#34;;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3388" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref952"></a>
<h3 class="sect2">LOG File</h3>
<p>The generated file name has the following format:</p>
<pre>&lt;filename&gt;_&lt;filetype&gt;.log
</pre>
<p>In Pro*C, for the file &#34;abc.pc&#34;, the generated LOG file will be abc_pc.log.</p>
<p>Consider the following example.</p>
<p class="subhead2"><a id="LNPCC3389"></a>Example 1</p>
<p>If abc.pc has the statements</p>
<pre>EXEC SQL select * from emp;
</pre>
<p class="subhead2"><a id="LNPCC3390"></a>Contents of abc_pc.log</p>
<pre>CATEGORY &lt;Category_name&gt; 
     Source SQL_0
        SELECT * FROM emp
     OUTLINE NAME
        abc_pc_0000
     OUTLINE SQL_0
        Select * from emp /* abc_pc_0000 */
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i6550"></a>
<div id="LNPCC3391" class="sect1">
<h2 class="sect1">The CURRENT OF Clause</h2>
<p>You use the CURRENT OF <span class="italic">cursor_name</span> clause in a DELETE or UPDATE statement to refer to the latest row FETCHed from the named cursor. The cursor must be open and positioned on a row. If no FETCH has been done or if the cursor is not open, the CURRENT OF clause results in an error and processes no rows.<a id="sthref953"></a><a id="sthref954"></a></p>
<p>The FOR UPDATE OF clause is optional when you DECLARE a cursor that is referenced in the CURRENT OF clause of an UPDATE or DELETE statement. The CURRENT OF clause signals the precompiler to add a FOR UPDATE clause if necessary.</p>
<p>In the following example, you use the CURRENT OF clause to refer to the latest row FETCHed from a cursor named <span class="italic">emp_cursor</span>:<a id="sthref955"></a></p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR 
     SELECT ename, sal FROM emp WHERE job = &#39;CLERK&#39; 
     FOR UPDATE OF sal; 
... 
EXEC SQL OPEN emp_cursor; 
EXEC SQL WHENEVER NOT FOUND GOTO ... 
for (;;) {
    EXEC SQL FETCH emp_cursor INTO :emp_name, :salary; 
    ... 
    EXEC SQL UPDATE emp SET sal = :new_salary 
         WHERE CURRENT OF emp_cursor; 
} 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_03dbc.htm#i1362">&#34;Using FOR UPDATE OF&#34;</a> for more information</div>
<div id="LNPCC3392" class="sect2"><a id="sthref956"></a>
<h3 class="sect2">Restrictions</h3>
<p>You cannot use CURRENT OF clause on an index-organized table.</p>
<p>Explicit FOR UPDATE OF clauses or implicit FOR UPDATE clauses acquire exclusive row locks. All rows are locked at the OPEN, not as they are FETCHed, and are released when you COMMIT or ROLLBACK. Therefore, you cannot FETCH from a FOR UPDATE cursor after a COMMIT. If you try to do this, Oracle returns a 1002 error code.<a id="sthref957"></a><a id="sthref958"></a></p>
<p>Also, you cannot use host arrays with the CURRENT OF clause. For an alternative, see also <a href="pc_08arr.htm#i1776">&#34;Mimicking CURRENT OF&#34;</a>.</p>
<p>Furthermore, you cannot reference multiple tables in an associated FOR UPDATE OF clause, which means that you cannot do joins with the CURRENT OF clause.<a id="sthref959"></a></p>
<p>Finally, you cannot use dynamic SQL with the CURRENT OF clause.<a id="sthref960"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2235"></a>
<div id="LNPCC3393" class="sect1">
<h2 class="sect1">The Cursor Statements</h2>
<p>The following example shows the typical sequence of cursor control statements in an application program:<a id="sthref961"></a></p>
<pre>   ...
/* define a cursor */ 
   EXEC SQL DECLARE emp_cursor CURSOR FOR 
        SELECT ename, job 
        FROM emp 
        WHERE empno = :emp_number 
        FOR UPDATE OF job; 
 
/* open the cursor and identify the active set */ 
   EXEC SQL OPEN emp_cursor; 
 
/* break if the last row was already fetched */ 
   EXEC SQL WHENEVER NOT FOUND DO break; 
 
/* fetch and process data in a loop */ 
   for (;;) 
   { 
      EXEC SQL FETCH emp_cursor INTO :emp_name, :job_title; 
 
/* optional host-language statements that operate on 
   the FETCHed data */ 
 
      EXEC SQL UPDATE emp 
           SET job = :new_job_title 
           WHERE CURRENT OF emp_cursor; 
   } 
... 
/* disable the cursor */ 
   EXEC SQL CLOSE emp_cursor; 
   EXEC SQL COMMIT WORK RELEASE; 
   ... 
</pre></div>
<!-- class="sect1" -->
<a id="i2240"></a>
<div id="LNPCC3394" class="sect1">
<h2 class="sect1">A Complete Example Using Non-Scrollable Cursor</h2>
<p>The following complete program illustrates the use of a cursor and the FETCH statement. The program prompts for a department number, then displays the names of all employees in that department.</p>
<p>All FETCHes except the final one return a row and, if no errors were detected during the FETCH, a success status code. The final FETCH fails and returns the &#34;no data found&#34; Oracle error code to <span class="italic">sqlca.sqlcode</span>. The cumulative number of rows actually FETCHed is found in <code>sqlerrd[2]</code> in the SQLCA.</p>
<pre>#include &lt;stdio.h&gt; 

/* declare host variables */ 
char userid[12] = &#34;SCOTT/TIGER&#34;;
char emp_name[10];
int  emp_number;
int  dept_number; 
char temp[32];
void sql_error();
 
/* include the SQL Communications Area */ 
#include &lt;sqlca.h&gt; 
 
main() 
{  emp_number = 7499;
/* handle errors */ 
   EXEC SQL WHENEVER SQLERROR do sql_error(&#34;Oracle error&#34;);
 
/* connect to Oracle */ 
   EXEC SQL CONNECT :userid; 
   printf(&#34;Connected.\n&#34;); 
 
/* declare a cursor */ 
   EXEC SQL DECLARE emp_cursor CURSOR FOR 
   SELECT ename 
      FROM emp 
      WHERE deptno = :dept_number; 
 
   printf(&#34;Department number? &#34;); 
   gets(temp);
   dept_number = atoi(temp); 
 
/* open the cursor and identify the active set */ 
   EXEC SQL OPEN emp_cursor; 

   printf(&#34;Employee Name\n&#34;); 
   printf(&#34;-------------\n&#34;);
/* fetch and process data in a loop
   exit when no more data */
   EXEC SQL WHENEVER NOT FOUND DO break;
   while (1) 
   { 
      EXEC SQL FETCH emp_cursor INTO :emp_name; 
      printf(&#34;%s\n&#34;, emp_name); 
   } 
   EXEC SQL CLOSE emp_cursor; 
   EXEC SQL COMMIT WORK RELEASE; 
   exit(0); 
}

void 
sql_error(msg)
char *msg;
{
   char buf[500];
   int buflen, msglen;

   EXEC SQL WHENEVER SQLERROR CONTINUE; 
   EXEC SQL ROLLBACK WORK RELEASE; 
   buflen = sizeof (buf);
   sqlglm(buf, &amp;buflen, &amp;msglen);
   printf(&#34;%s\n&#34;, msg); 
   printf(&#34;%*.s\n&#34;, msglen, buf); 
   exit(1); 
}
</pre></div>
<!-- class="sect1" -->
<a id="i8106"></a>
<div id="LNPCC3395" class="sect1">
<h2 class="sect1">A Complete Example Using Scrollable Cursor</h2>
<p>The following program illustrates the use of scrollable cursor and the various options used by the FETCH statement.</p>
<pre><a id="g18821"></a>
#include &lt;stdio.h&gt; 

/* declare host variables */ 
char userid[12]=&#34;SCOTT/TIGER&#34;; 
char emp_name[10]; 
void sql_error(); 

/*  include the SQL Communications Area */ 
#include&lt;sqlca.h&gt; 

main() 
{ 
/* handle errors */ 
    EXEC SQL WHENEVER SQLERROR do sql_error(&#34;Oracle error&#34;); 

/* connect to Oracle */ 
    EXEC SQL CONNECT :userid; 
    printf(&#34;Connected.\n&#34;); 

/* declare a scrollable cursor */ 
    EXEC SQL DECLARE emp_cursor SCROLL CURSOR FOR 
    SELECT ename FROM emp; 

/* open the cursor and identify the active set */ 
     EXEC SQL OPEN emp_cursor; 

 /* Fetch the last row */ 
     EXEC SQL FETCH LAST emp_cursor INTO :emp_name; 

 /* Fetch row number 5 */ 
      EXEC SQL FETCH ABSOLUTE 5 emp_cursor INTO :emp_name; 

/*  Fetch row number 10 */ 
       EXEC SQL FETCH RELATIVE 5 emp_cursor INTO :emp_name; 

/*  Fetch row number 7 */ 
       EXEC SQl FETCH RELATIVE -3 emp_cursor INTO :emp_name; 

/*  Fetch the first row */ 
       EXEC SQL FETCH FIRST emp_cursor INTO :emp_name; 

/*  Fetch row number 2*/ 
       EXEC SQL FETCH my_cursor INTO :emp_name; 

/*  Fetch row number 3 */ 
       EXEC SQL FETCH NEXT my_cursor INTO :emp_name; 

/*  Fetch row number 3 */ 
       EXEC SQL FETCH CURRENT my_cursor INTO :emp_name; 

/*  Fetch row number 2 */ 
        EXEC SQL FETCH PRIOR my_cursor INTO :emp_name; 
} 

void 
sql_error(msg) 
char *msg; 
{ 
     char buf[500]; 
     int buflen , msglen; 

     EXEC SQL WHENEVER SQLERROR  CONTINUE; 
     EXEC SQL ROLLBACK TRANSACTION; 
     buflen = sizeof (buf); 
     sqlglm(buf, &amp;buflen, &amp;mesglen); 
     printf(&#34;%s\n&#34;,msg); 
     printf(&#34;%*.s\n&#34;,msglen,buf); 
     exit(1); 
<a id="i8053"></a>}
</pre></div>
<!-- class="sect1" -->
<a id="i5843"></a>
<div id="LNPCC3396" class="sect1">
<h2 class="sect1">Positioned Update</h2>
<p>The following skeletal example demonstrates positioned update using the universal ROWID. See also <a href="pc_04dat.htm#i23634">&#34;Universal ROWIDs&#34;</a>:</p>
<pre>#include &lt;oci.h&gt;
...
OCIRowid *urowid;
...
EXEC SQL ALLOCATE :urowid;
EXEC SQL DECLARE cur CURSOR FOR
    SELECT rowid, ... FROM my_table FOR UPDATE OF ...;
EXEC SQL OPEN cur;
EXEC SQL FETCH cur INTO :urowid, ...;
/* Process data */
...
EXEC SQL UPDATE my_table SET ... WHERE CURRENT OF cur;
EXEC SQL CLOSE cur;
EXEC SQL FREE :urowid;
...

</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_05adv.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_07pls.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>