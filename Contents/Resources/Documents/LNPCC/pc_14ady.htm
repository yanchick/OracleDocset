<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78014"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/ANSI%20Dynamic%20SQL"></a><title>ANSI Dynamic SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:46Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_13dyn.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_15ody.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">20/35</span> <!-- End Header -->
<div id="LNPCC014" class="chapter"><a id="i1011699"></a>
<h1 class="chapter"><span class="secnum">14</span> ANSI Dynamic SQL</h1>
<p>This chapter describes Oracle&#39;s implementation of <a id="sthref1762"></a>ANSI dynamic SQL (also known as SQL standard dynamic SQL) which should be used for new Method 4 applications. It has enhancements over the older Oracle dynamic SQL Method 4, described in the previous chapter.</p>
<p>The ANSI Method 4 supports all Oracle types, while the older Oracle Method 4 does <span class="italic">not</span> support object types, cursor variables, arrays of structs, DML returning clauses, Unicode variables, and LOBs.</p>
<p>In ANSI dynamic SQL, descriptors are internally maintained by Oracle, while in the older Oracle dynamic SQL Method 4, descriptors are defined in the user&#39;s Pro*C/C++ program. In both cases, Method 4 means that your Pro*C/C++ program accepts or builds SQL statements that contain a varying number of host variables.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i1000792">Basics of ANSI Dynamic SQL</a></p>
</li>
<li>
<p><a href="#i1007240">Overview of ANSI SQL Statements</a></p>
</li>
<li>
<p><a href="#i1001031">Oracle Extensions</a></p>
</li>
<li>
<p><a href="#i1001093">ANSI Dynamic SQL Precompiler Options</a></p>
</li>
<li>
<p><a href="#i1001175">Full Syntax of the Dynamic SQL Statements</a></p>
</li>
<li>
<p><a href="#i1006299">Example Programs</a></p>
</li>
</ul>
<a id="i1000792"></a>
<div id="LNPCC4033" class="sect1">
<h2 class="sect1"><a id="sthref1763"></a>Basics of ANSI Dynamic SQL</h2>
<p>Consider the SQL statement:</p>
<pre>SELECT ename, empno FROM emp WHERE deptno = :deptno_data 
</pre>
<p>The steps you follow to use ANSI dynamic SQL are:</p>
<ul>
<li>
<p>Declare variables, including a string to hold the statement to be executed.</p>
</li>
<li>
<p>Allocate descriptors for input and output variables.</p>
</li>
<li>
<p>Prepare the statement.</p>
</li>
<li>
<p>Describe input for the input descriptor.</p>
</li>
<li>
<p>Set the input descriptor (in our example the one input host bind variable, <code>deptno_data)</code>.</p>
</li>
<li>
<p>Declare and open a dynamic cursor.</p>
</li>
<li>
<p>Set the output descriptors (in our example, the output host variables <code>ename</code> and <code>empno)</code>.</p>
</li>
<li>
<p>Repeatedly fetch data, using GET DESCRIPTOR to retrieve the <code>ename</code> and <code>empno</code> data fields from each row.</p>
</li>
<li>
<p>Do something with the data retrieved (output it, for instance).</p>
</li>
<li>
<p>Close the dynamic cursor and deallocate the input and output descriptors.</p>
</li>
</ul>
<a id="i1010328"></a>
<div id="LNPCC4034" class="sect2">
<h3 class="sect2"><a id="sthref1764"></a>Precompiler Options</h3>
<p>Set the micro precompiler option DYNAMIC to ANSI, or set the macro option MODE to ANSI, which causes the default value of DYNAMIC to be ANSI. The other setting of DYNAMIC is ORACLE.</p>
<p>In order to use ANSI type codes, set the precompiler micro option TYPE_CODE to ANSI, or set the macro option MODE to ANSI which makes the default setting of TYPE_CODE to ANSI. To set TYPE_CODE to ANSI, DYNAMIC must also be ANSI.</p>
<p>Oracle&#39;s implementation of the ANSI SQL types in <a href="#g1022936">Table 14-1, &#34;ANSI SQL Datatypes&#34;</a> does not exactly match the ANSI standard. For example, a describe of a column declared as INTEGER will return the code for NUMERIC. As Oracle moves closer to the ANSI standard, small changes in behavior may be required. Use the ANSI types with precompiler option TYPE_CODE set to ANSI if you want your application to be portable across database platforms and as ANSI compliant as possible. Do not use TYPE_CODE set to ANSI if such changes are not acceptable.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007240"></a>
<div id="LNPCC4035" class="sect1">
<h2 class="sect1"><a id="sthref1765"></a>Overview of ANSI SQL Statements</h2>
<p>Allocate a descriptor area first before using it in a dynamic SQL statement.</p>
<p>The ALLOCATE DESCRIPTOR statement syntax is:</p>
<pre>EXEC SQL ALLOCATE DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam</span> | <span class="italic">string_literal</span>} 
  [WITH MAX {<span class="italic">:occurrences</span> | <span class="italic">numeric_literal</span>}];
</pre>
<p>A global descriptor can be used in any module in the program. A local descriptor can be accessed only in the file in which it is allocated. Local is the default.</p>
<p>The descriptor name, <code>desc_nam,</code> can be a literal in single quotes or a character value stored in a host variable.</p>
<p><code>occurrences</code> is the maximum number of bind variables or columns that the descriptor can hold. This must be a numeric literal. The default is 100.</p>
<p>When a descriptor is no longer needed, deallocate it to conserve memory. Otherwise, deallocation is done automatically when there are no more active database connections.</p>
<p>The deallocate statement is:</p>
<pre>EXEC SQL DEALLOCATE DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam</span> | <span class="italic">string_literal</span>};
</pre>
<p>Use the DESCRIBE statement to obtain information on a prepared SQL statement. DESCRIBE INPUT describes bind variables for the dynamic statement that has been prepared. DESCRIBE OUTPUT (the default) can give the number, type, and length of the output columns. The simplified syntax is:</p>
<pre>EXEC SQL DESCRIBE [INPUT | OUTPUT] <span class="italic">sql_statement</span> 
    USING [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam</span> | <span class="italic">string_literal</span>};

</pre>
<p>If your SQL statement has input and output values, you must allocate two descriptors: one for input and one for output values. If there are no input values, for example:</p>
<pre>SELECT ename, empno FROM emp ;
</pre>
<p>then the input descriptor is not needed.</p>
<p>Use the SET DESCRIPTOR statement to specify input values for INSERTS, UPDATES, DELETES and the WHERE clauses of SELECT statements. Use SET DESCRIPTOR to set the number of input bind variables (stored in <code>COUNT</code>) when you have not done a DESCRIBE into your input descriptor:</p>
<pre>EXEC SQL SET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
   COUNT = {:<span class="italic">kount </span>|<span class="italic"> numeric_literal</span>};
</pre>
<p><code>kount</code> can be a host variable or a numeric literal, such as 5. Use a SET DESCRIPTOR statement for each host variable, giving at least the data source of the variable:</p>
<pre>EXEC SQL SET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} 
   VALUE <span class="italic">item_number</span> DATA = :<span class="italic">hv3</span>;
</pre>
<p>You can also set the type and length of the input host variable:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When TYPE_CODE=ORACLE, if you do not set TYPE and LENGTH, either explicitly using the SET statement or implicitly by doing a DESCRIBE OUTPUT, the precompiler will use values for them derived from the host variable itself. When TYPE_CODE=ANSI, you must set TYPE using the values in <a href="#g1022936">Table 14-1, &#34;ANSI SQL Datatypes&#34;</a>. You should also set LENGTH because the ANSI default lengths may not match those of your host variables.</div>
<pre>EXEC SQL SET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} 
   VALUE <span class="italic">item_number</span> TYPE = :<span class="italic">hv1</span>, LENGTH = :<span class="italic">hv2</span>, DATA = :<span class="italic">hv3</span>;
</pre>
<p>We use the identifiers <code>hv1</code>, <code>hv2</code>, and <code>hv3</code> to remind us that the values must be supplied by host variables. <span class="italic">item_number</span> is the position of the input variable in the SQL statement.</p>
<p>TYPE is the Type Code selected from the following table, if TYPE_CODE is set to ANSI:</p>
<div id="LNPCC4036" class="tblformal">
<p class="titleintable"><a id="sthref1766"></a><a id="g1022936"></a>Table 14-1 ANSI SQL Datatypes</p>
<table class="cellalignment831" title="ANSI SQL Datatypes" summary="ANSI SQL Datatypes" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t3">Datatype</th>
<th class="cellalignment832" id="r1c2-t3">Type Code</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t3" headers="r1c1-t3">
<p>CHARACTER</p>
</td>
<td class="cellalignment833" headers="r2c1-t3 r1c2-t3">
<p>1</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t3" headers="r1c1-t3">
<p>CHARACTER VARYING</p>
</td>
<td class="cellalignment833" headers="r3c1-t3 r1c2-t3">
<p>12</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t3" headers="r1c1-t3">
<p>DATE</p>
</td>
<td class="cellalignment833" headers="r4c1-t3 r1c2-t3">
<p>9</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t3" headers="r1c1-t3">
<p>DECIMAL</p>
</td>
<td class="cellalignment833" headers="r5c1-t3 r1c2-t3">
<p>3</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t3" headers="r1c1-t3">
<p>DOUBLE PRECISION</p>
</td>
<td class="cellalignment833" headers="r6c1-t3 r1c2-t3">
<p>8</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t3" headers="r1c1-t3">
<p>FLOAT</p>
</td>
<td class="cellalignment833" headers="r7c1-t3 r1c2-t3">
<p>6</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t3" headers="r1c1-t3">
<p>INTEGER</p>
</td>
<td class="cellalignment833" headers="r8c1-t3 r1c2-t3">
<p>4</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t3" headers="r1c1-t3">
<p>NUMERIC</p>
</td>
<td class="cellalignment833" headers="r9c1-t3 r1c2-t3">
<p>2</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t3" headers="r1c1-t3">
<p>REAL</p>
</td>
<td class="cellalignment833" headers="r10c1-t3 r1c2-t3">
<p>7</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t3" headers="r1c1-t3">
<p>SMALLINT</p>
</td>
<td class="cellalignment833" headers="r11c1-t3 r1c2-t3">
<p>5</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_15ody.htm#g34096">Figure 15-1, &#34;Oracle External Datatypes and Datatype Codes&#34;</a> for the Oracle type codes</div>
<p>DATA is the value of the host variable that is to be input</p>
<p>You can also set other input values such as indicator, precision and scale.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1001420">&#34;SET DESCRIPTOR&#34;</a> for a complete discussion of all the possible descriptor item names</div>
<p>The numeric values in the SET DESCRIPTOR statement must be declared as either <code>int</code> or <code>short int</code>, except for indicator and returned length values which you must declare as <code>short int</code>.</p>
<p>For example, in the following example, when you want to retrieve an <code>empno</code>, set these values: VALUE = 2, because <code>empno</code> is the second output host variable in the dynamic SQL statement. The host variable <code>empno_typ</code> is set to 3 (Oracle Type for integer). The length of a host integer, <code>empno_len</code>, is set to 4, which is the size of the host variable. The DATA is equated to the host variable <code>empno_data</code> which will receive the value from the database table. The code fragment is as follows:</p>
<pre>...
char *dyn_statement = &#34;SELECT ename, empno FROM emp 
   WHERE deptno = :deptno_number&#34; ;
int empno_data ;
int empno_typ = 3 ;
int empno_len = 4 ;
...
EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 2  TYPE = :empno_typ, LENGTH = :empno_len,
   DATA = :empno_data ;
</pre>
<p>After setting the input values, execute or open your statement using the input descriptor. If there are output values in your statement, set them before doing a FETCH. If you have performed a DESCRIBE OUTPUT, you may have to test the actual type and length of your host variables. The DESCRIBE execution produces internal types and lengths that differ from your host variable external types and length.</p>
<p>After the FETCH of the output descriptor, use GET DESCRIPTOR to access the returned data. Again we show a simplified syntax with details later in this chapter:</p>
<pre>EXEC SQL GET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
   VALUE <span class="italic">item_number </span>:<span class="italic">hv1</span> = DATA, :<span class="italic">hv2</span> = INDICATOR, :<span class="italic">hv3</span> = RETURNED_LENGTH ;
</pre>
<p><code>desc_nam</code> and <code>item_number</code> can be literals or host variables. A descriptor name can be a literal such as &#39;out&#39;. An item number can be a numeric literal such as 2.</p>
<p><code>hv1, hv2, and hv3</code> are host variables. They must be host variables, not literals. Only three are shown in the example.</p>
<p>Use either <span class="bold">long</span><span class="bold">,</span> <span class="bold">int</span> or <span class="bold">short</span> for all numeric values, except for indicator and returned length variables, which must be <code>short</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1022893">Table 14-4</a> for a list of all possible items of returned data that you can get</div>
<a id="i1000986"></a>
<div id="LNPCC4037" class="sect2">
<h3 class="sect2">Example Code</h3>
<p>The following example demonstrates the use of ANSI Dynamic SQL. It allocates an input descriptor (&#39;in&#39;) and an output descriptor (&#39;out&#39;) to execute a SELECT statement. Input values are set using the SET DESCRIPTOR statement. The cursor is opened and fetched from and the resulting output values are retrieved using a GET DESCRIPTOR statement.</p>
<pre>...
char* dyn_statement = &#34;SELECT ename, empno FROM emp WHERE deptno = :deptno_data&#34; ;
int deptno_type = 3, deptno_len = 2, deptno_data = 10 ;
int ename_type = 97, ename_len = 30 ;
char ename_data[31] ;
int empno_type = 3, empno_len = 4 ;
int empno_data ;
long SQLCODE = 0 ;
...
main ()
{
/* Place preliminary code, including connection, here. */
...
EXEC SQL ALLOCATE DESCRIPTOR &#39;in&#39; ;
EXEC SQL ALLOCATE DESCRIPTOR &#39;out&#39; ;
EXEC SQL PREPARE s FROM :dyn_statement ;
EXEC SQL DESCRIBE INPUT s USING DESCRIPTOR &#39;in&#39; ;
EXEC SQL SET DESCRIPTOR &#39;in&#39; VALUE 1 TYPE = :deptno_type,
   LENGTH = :deptno_len, DATA = :deptno_data ;
EXEC SQL DECLARE c CURSOR FOR s ;
EXEC SQL OPEN c USING DESCRIPTOR &#39;in&#39; ;
EXEC SQL DESCRIBE OUTPUT s USING DESCRIPTOR &#39;out&#39; ;
EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 1 TYPE = :ename_type, 
    LENGTH = :ename_len, DATA = :ename_data ;
EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 2 TYPE = :empno_type, 
    LENGTH = :empno_len, DATA = :empno_data ;

EXEC SQL WHENEVER NOT FOUND DO BREAK ;
while (SQLCODE == 0) 
{
   EXEC SQL FETCH c INTO DESCRIPTOR &#39;out&#39; ;
   EXEC SQL GET DESCRIPTOR &#39;out&#39; VALUE 1 :ename_data = DATA ;
   EXEC SQL GET DESCRIPTOR &#39;out&#39; VALUE 2 :empno_data = DATA ;
   printf(&#34;\nEname = %s Empno = %s&#34;, ename_data, empno_data) ;
}
EXEC SQL CLOSE c ;
EXEC SQL DEALLOCATE DESCRIPTOR &#39;in&#39; ;
EXEC SQL DEALLOCATE DESCRIPTOR &#39;out&#39; ;
...
}
</pre>
<p>Scrollable cursors can also be used with ANSI Dynamic SQL. In order to use ANSI dynamic SQL with scrollable cursors, we DECLARE the cursor in SCROLL mode. Use the various fetch orientation modes with the FETCH statement to access the result set.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1001031"></a>
<div id="LNPCC4038" class="sect1">
<h2 class="sect1"><a id="sthref1767"></a>Oracle Extensions</h2>
<p>These extensions are described next:</p>
<ul>
<li>
<p>Reference semantics for data items in SET statements.</p>
</li>
<li>
<p>Arrays for bulk operations.</p>
</li>
<li>
<p>Support for object types, NCHAR columns, and LOBs.</p>
</li>
</ul>
<a id="i1001037"></a>
<div id="LNPCC4039" class="sect2">
<h3 class="sect2"><a id="sthref1768"></a>Reference Semantics<a id="sthref1769"></a><a id="sthref1770"></a></h3>
<p>The ANSI standard specifies <span class="italic">value</span> semantics. To improve performance, Oracle has extended this standard to include <span class="italic">reference</span> semantics.</p>
<p>Value semantics makes a copy of your host variables data. Reference semantics uses the addresses of your host variables, avoiding a copy. Thus, reference semantics can provide performance improvements for large amounts of data.</p>
<p>To help speed up fetches, use the REF keyword before the data clauses:</p>
<pre>EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 1 TYPE = :ename_type,
   LENGTH = :ename_len, REF DATA = :ename_data ;
EXEC SQL DESCRIPTOR &#39;out&#39; VALUE 2 TYPE = :empno_type,
   LENGTH = :empno_len, REF DATA = :empno_data ;
</pre>
<p>Then the host variables receive the results of the retrieves. The GET statement is not needed. The retrieved data is written directly into <code>ename_data</code> and <code>empno_data</code> after each FETCH.</p>
<p>Use of the REF keyword is allowed <span class="italic">only</span> before DATA, INDICATOR and RETURNED_LENGTH items (which can vary with each row fetched) as in this fragment of code:</p>
<pre>int indi, returnLen ;
...
EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 1 TYPE = :ename_type,
   LENGTH = :ename_len, REF DATA = :ename_data,
      REF INDICATOR = :indi, REF RETURNED_LENGTH = :returnLen ;
</pre>
<p>After each fetch, <code>returnLen</code> holds the actual retrieved length of the <code>ename</code> field, which is useful for <code>CHAR</code> or <code>VARCHAR2</code> data.</p>
<p><code>ename_len</code> will not receive the returned length. It will not be changed by the FETCH statement. Use a DESCRIBE statement, followed by a GET statement to find out the maximum column width before fetching rows of data.</p>
<p>REF keyword is also used for other types of SQL statements than SELECT, to speed them up. With reference semantics, the host variable is used rather than a value copied into the descriptor area. The host variable data at the time of execution of the SQL statement is used, not its data at the time of the SET. Here is an example:</p>
<pre>int x = 1 ;
EXEC SQL SET DESCRIPTOR &#39;value&#39; VALUE 1 DATA = :x ;
EXEC SQL SET DESCRIPTOR &#39;reference&#39; VALUE 1 REF DATA = :x ;
x = 2 ;
EXEC SQL EXECUTE s USING  DESCRIPTOR &#39;value&#39; ;    /* Will use  x = 1 */
EXEC SQL EXECUTE s USING DESCRIPTOR &#39;reference&#39; ; /* Will use x = 2 */
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1001420">&#34;SET DESCRIPTOR&#34;</a> for many more details on the differences</div>
</div>
<!-- class="sect2" -->
<a id="i1003925"></a>
<div id="LNPCC4040" class="sect2">
<h3 class="sect2"><a id="sthref1771"></a>Using <a id="sthref1772"></a>Arrays for Bulk Operations</h3>
<p>Oracle extends ANSI dynamic SQL by providing bulk operations. To use bulk operations, use the <code>FOR</code> clause with an array size to specify the amount of input data or the number of rows you want to process.</p>
<p>The <code>FOR</code> clause is used in the ALLOCATE statement to give the maximum amount of data or number of rows. For example, to use a maximum array size of 100:</p>
<pre>EXEC SQL FOR 100 ALLOCATE DESCRIPTOR &#39;out&#39; ;
</pre>
<p>or:</p>
<pre>int array_size = 100 ;
...
EXEC SQL FOR :array_size ALLOCATE DESCRIPTOR &#39;out&#39; ;
</pre>
<p>The <code>FOR</code> clause is then used in subsequent statements that access the descriptor. In an output descriptor the FETCH statement must have an array size equal to or less than the array size already used in the ALLOCATE statement:</p>
<pre>EXEC SQL FOR 20 FETCH c1 USING DESCRIPTOR &#39;out&#39; ;
</pre>
<p>Subsequent GET statements for the same descriptor, that get DATA, INDICATOR, or RETURNED_LENGTH values, must use the same array size as the FETCH statement.</p>
<pre>int val_data[20] ;
short val_indi[20] ;
...
EXEC SQL FOR 20 GET DESCRIPTOR &#39;out&#39; VALUE 1 :val_data = DATA,
  :val_indi = INDICATOR ;
</pre>
<p>However, GET statements that reference other items which do not vary from row to row, such as LENGTH, TYPE and COUNT, must <span class="italic">not</span> use the <code>FOR</code> clause:</p>
<pre>int cnt, len ;
...
EXEC SQL GET DESCRIPTOR &#39;out&#39; :cnt = COUNT ;
EXEC SQL GET DESCRIPTOR &#39;out&#39; VALUE 1 :len = LENGTH ;
</pre>
<p>The same holds true for SET statements with reference semantics. SET statements which precede the FETCH and employ reference semantics for DATA, INDICATOR, or RETURNED_LENGTH must have the same array size as the FETCH:</p>
<pre>int ref_data[20] ;
short ref_indi[20] ;
...
EXEC SQL FOR 20 SET DESCRIPTOR &#39;out&#39; VALUE 1 REF DATA = :ref_data,
   REF INDICATOR = :ref_indi ;
</pre>
<p>Similarly, for a descriptor that is used for input, to insert a batch of rows, for instance, the EXECUTE or OPEN statement must use an array size equal to or less than the size used in the ALLOCATE statement. The SET statement, for both value and reference semantics, that accesses DATA, INDICATOR, or RETURNED_LENGTH must use the same array size as in the EXECUTE statement.</p>
<p>The FOR clause is never used on the DEALLOCATE or PREPARE statements.</p>
<p>The following code example illustrates a bulk operation with no output descriptor (there is no output, only input to be inserted into the table <code>emp</code>). The value of <code>COUNT</code> is 2 (there are two host variables, <code>ename_arr</code> and <code>empno_arr</code>, in the INSERT statement). The data array <code>ename_arr</code> holds three character strings: &#34;Tom&#34;, &#34;Dick&#34; and &#34;Harry&#34;, in that order. The indicator array <code>ename_ind</code> has a value of -1 for the second element; so a NULL will be inserted instead of &#34;Dick&#34;. The data array <code>empno_arr</code> contains three employee numbers. A DML returning clause could be used to confirm the actual names inserted.</p>
<pre>...
char* dyn_statement = &#34;INSERT INTO emp (ename) VALUES (:ename_arr)&#34; ;
char ename_arr[3][6] = {Tom&#34;,&#34;Dick&#34;,&#34;Harry&#34;} ;
short ename_ind[3] = {0,-1,0} ;
int ename_len = 6, ename_type = 97, cnt = 2 ;
int empno_arr[3] = {8001, 8002, 8003} ;
int empno_len = 4 ;
int empno_type = 3 ;
int array_size = 3 ;
EXEC SQL FOR :array_size ALLOCATE DESCRIPTOR &#39;in&#39; ;
EXEC SQL SET DESCRIPTOR &#39;in&#39; COUNT = :cnt ;
EXEC SQL SET DESCRIPTOR &#39;in&#39; VALUE 1 TYPE = :ename_type, LENGTH = :ename_len ;
EXEC SQL SET DESCRIPTOR &#39;in&#39; VALUE 2 TYPE = :empno_type, LENGTH = :empno_len ;
EXEC SQL FOR :array_size SET DESCRIPTOR &#39;in&#39; VALUE 1
   DATA = :ename_arr, INDICATOR = :ename_ind ;
EXEC SQL FOR :array_size SET DESCRIPTOR &#39;in&#39; VALUE 2
   DATA = :empno_arr ;
EXEC SQL PREPARE s FROM :dyn_statement ;
EXEC SQL FOR :array_size EXECUTE s USING DESCRIPTOR &#39;in&#39; ;
...
</pre>
<p>The preceding code will insert these values:</p>
<pre>EMPNO   ENAME
 8001   Tom
 8002   
 8003   Harry
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_06sql.htm#i5385">&#34;The DML Returning Clause&#34;</a></p>
</li>
<li>
<p><a href="pc_08arr.htm#i1775">&#34;Using the FOR Clause&#34;</a> for a discussion of restrictions and cautions</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1001089"></a>
<div id="LNPCC4041" class="sect2">
<h3 class="sect2">Support for Arrays of Structs</h3>
<p>You must set the HOST_STRIDE_LENGTH to the size of the struct, and the INDICATOR_STRIDE_LENGTH to the size of the indicator struct, and the RETURNED_LENGTH_STRIDE to the size of your returned length struct.</p>
<p>Arrays of structs are supported by ANSI dynamic SQL, but are <span class="italic">not</span> supported by the older Oracle dynamic SQL.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1022973">Table 14-5, &#34;Oracle Extensions to Definitions of Descriptor Item Names for GET DESCRIPTOR&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1021676"></a>
<div id="LNPCC4042" class="sect2">
<h3 class="sect2">Support for Object Types</h3>
<p>For the object types that you have defined yourself, use Oracle TYPE equal to 108. For an object type column, use a DESCRIBE statement to obtain USER_DEFINED_TYPE_VERSION, USER_DEFINED_TYPE_NAME, USER_DEFINED_TYPE_NAME_LENGTH, USER_DEFINED_TYPE_SCHEMA, and USER_DEFINED_TYPE_SCHEMA_LENGTH.</p>
<p>If you do not employ the DESCRIBE statement to retrieve these values, you have to set them yourself through the SET DESCRIPTOR statement.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1001093"></a>
<div id="LNPCC4043" class="sect1">
<h2 class="sect1"><a id="sthref1773"></a>ANSI Dynamic SQL Precompiler Options</h2>
<p>The macro option <a id="sthref1774"></a>MODE sets ANSI compatibility characteristics and controls a number of functions. It can have the values ANSI or ORACLE. For individual functions there are micro options that override the MODE setting. See also <a href="pc_10opt.htm#i8247">&#34;MODE&#34;</a>.</p>
<p>The precompiler micro option <a id="sthref1775"></a><span class="italic">DYNAMIC</span> specifies the descriptor behavior in dynamic SQL. The precompiler micro option <a id="sthref1776"></a><span class="italic">TYPE_CODE</span> specifies whether ANSI or Oracle datatype codes are to be used.</p>
<p>When the macro option MODE is set to ANSI, the micro option DYNAMIC becomes ANSI automatically. When MODE is set to ORACLE, DYNAMIC becomes ORACLE.</p>
<p>DYNAMIC and TYPE_CODE cannot be used inline.</p>
<p>This table describes functionality and how the DYNAMIC setting affects them.</p>
<div id="LNPCC4044" class="tblformal">
<p class="titleintable"><a id="sthref1777"></a><a id="g1022849"></a>Table 14-2 DYNAMIC Option Settings</p>
<table class="cellalignment831" title="DYNAMIC Option Settings" summary="DYNAMIC Option Settings" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t10">Function</th>
<th class="cellalignment832" id="r1c2-t10">DYNAMIC = ANSI</th>
<th class="cellalignment832" id="r1c3-t10">DYNAMIC = ORACLE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t10" headers="r1c1-t10">
<p>Descriptor creation.</p>
</td>
<td class="cellalignment833" headers="r2c1-t10 r1c2-t10">
<p>Must use ALLOCATE statement.</p>
</td>
<td class="cellalignment833" headers="r2c1-t10 r1c3-t10">
<p>Must use function SQLSQLDAAlloc(). See<a href="pc_05adv.htm#i426817">&#34;New Names for SQLLIB Public Functions&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t10" headers="r1c1-t10">
<p>Descriptor destruction.</p>
</td>
<td class="cellalignment833" headers="r3c1-t10 r1c2-t10">
<p>May use DEALLOCATE statement.</p>
</td>
<td class="cellalignment833" headers="r3c1-t10 r1c3-t10">
<p>May use function SQLLDAFree(). See <a href="pc_05adv.htm#i426817">&#34;New Names for SQLLIB Public Functions&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t10" headers="r1c1-t10">
<p>Retrieving data.</p>
</td>
<td class="cellalignment833" headers="r4c1-t10 r1c2-t10">
<p>May use both FETCH and GET statements.</p>
</td>
<td class="cellalignment833" headers="r4c1-t10 r1c3-t10">
<p>Must use only FETCH statement.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t10" headers="r1c1-t10">
<p>Setting input data.</p>
</td>
<td class="cellalignment833" headers="r5c1-t10 r1c2-t10">
<p>May use DESCRIBE INPUT statement. Must use SET statement.</p>
</td>
<td class="cellalignment833" headers="r5c1-t10 r1c3-t10">
<p>Must set descriptor values in code. Must use DESCRIBE BIND VARIABLES statement.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t10" headers="r1c1-t10">
<p>Descriptor representation.</p>
</td>
<td class="cellalignment833" headers="r6c1-t10 r1c2-t10">
<p>Single quoted literal or host identifier which contains the descriptor name.</p>
</td>
<td class="cellalignment833" headers="r6c1-t10 r1c3-t10">
<p>Host variable, a pointer to SQLDA.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t10" headers="r1c1-t10">
<p>Data types available.</p>
</td>
<td class="cellalignment833" headers="r7c1-t10 r1c2-t10">
<p>All ANSI types except BIT and all Oracle types.</p>
</td>
<td class="cellalignment833" headers="r7c1-t10 r1c3-t10">
<p>Oracle types except objects, LOBs, arrays of structs and cursor variables.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The micro option TYPE_CODE is set by the precompiler to the same setting as the macro option MODE. TYPE_CODE can only equal ANSI if DYNAMIC equals ANSI.</p>
<p>Here is the functionality corresponding to the TYPE_CODE settings:</p>
<div id="LNPCC4045" class="tblformal">
<p class="titleintable"><a id="sthref1778"></a><a id="g1022881"></a>Table 14-3 TYPE_CODE Option Settings</p>
<table class="cellalignment831" title="TYPE_CODE Option Settings" summary="TYPE_CODE Option Settings" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t11">Function</th>
<th class="cellalignment832" id="r1c2-t11">TYPE_CODE = ANSI</th>
<th class="cellalignment832" id="r1c3-t11">TYPE_CODE = ORACLE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t11" headers="r1c1-t11">
<p>Data type code numbers input and returned in dynamic SQL.</p>
</td>
<td class="cellalignment833" headers="r2c1-t11 r1c2-t11">
<p>Use ANSI code numbers when ANSI type exists. Otherwise, use the negative of the Oracle code number.</p>
<p>Only valid when DYNAMIC = ANSI.</p>
</td>
<td class="cellalignment833" headers="r2c1-t11 r1c3-t11">
<p>Use Oracle code numbers.</p>
<p>May be used regardless of the setting of DYNAMIC.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect1" -->
<a id="i1001175"></a>
<div id="LNPCC4046" class="sect1">
<h2 class="sect1">Full Syntax of the Dynamic SQL Statements</h2>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_afemb.htm#CHEJCBII">Appendix E, &#34; Embedded SQL Statements and Directives&#34;</a> for more details on all these statements</div>
<a id="i1005236"></a>
<div id="LNPCC4047" class="sect2">
<h3 class="sect2"><a id="sthref1779"></a>ALLOCATE DESCRIPTOR</h3>
<p class="subhead1"><a id="LNPCC4048"></a>Purpose</p>
<p>Use this statement to allocate a SQL descriptor area. Supply a descriptor and the maximum number of occurrences of host bind items, and an array size. This statement is only for the ANSI dynamic SQL.</p>
<p class="subhead1"><a id="LNPCC4049"></a>Syntax</p>
<pre>EXEC SQL [FOR [:]<span class="italic">array_size</span>] ALLOCATE DESCRIPTOR [GLOBAL | LOCAL]
   {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} [WITH MAX <span class="italic">occurrences</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4050"></a>Variables</p>
<p>array_size</p>
<p>This is in an optional clause (it is an Oracle extension) that supports array processing. It tells the precompiler that the descriptor is usable for array processing.</p>
<p>GLOBAL | LOCAL</p>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
<p>desc_nam</p>
<p>Descriptor name. Local descriptors must be unique in the module. A runtime error is generated if the descriptor has been allocated, but not deallocated, previously. A global descriptor must be unique for the application, or a runtime error results.</p>
<p>occurrences</p>
<p>The maximum number of host variables possible in the descriptor. It must be an integer constant between 0 and 64K, or an error is returned. Default is 100. The clause is optional. A precompiler error results if it does not conform to these rules.</p>
<p class="subhead1"><a id="LNPCC4051"></a>Examples</p>
<pre>EXEC SQL ALLOCATE DESCRIPTOR &#39;SELDES&#39; WITH MAX 50 ;

EXEC SQL FOR :batch ALLOCATE DESCRIPTOR GLOBAL :binddes WITH MAX 25 ;
</pre></div>
<!-- class="sect2" -->
<a id="i1005237"></a>
<div id="LNPCC4052" class="sect2">
<h3 class="sect2"><a id="sthref1780"></a>DEALLOCATE DESCRIPTOR</h3>
<p class="subhead1"><a id="LNPCC4053"></a>Purpose</p>
<p>Use this statement to deallocate a SQL descriptor area that has been previously allocated, to free memory. This statement is only used for the ANSI dynamic SQL.</p>
<p class="subhead1"><a id="LNPCC4054"></a>Syntax</p>
<pre>EXEC SQL DEALLOCATE DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} ;
</pre>
<p class="subhead1"><a id="LNPCC4055"></a>Variable</p>
<p>GLOBAL | LOCAL</p>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
<p>desc_nam</p>
<p>A runtime error results when a descriptor with the same name and scope has not been allocated, or has been allocated and deallocated already.</p>
<p class="subhead1"><a id="LNPCC4056"></a>Examples</p>
<pre>EXEC SQL DEALLOCATE DESCRIPTOR GLOBAL &#39;SELDES&#39; ;

EXEC SQL DEALLOCATE DESCRIPTOR :binddes ;
</pre></div>
<!-- class="sect2" -->
<a id="i1007253"></a>
<div id="LNPCC4057" class="sect2">
<h3 class="sect2"><a id="sthref1781"></a>GET DESCRIPTOR</h3>
<p class="subhead1"><a id="LNPCC4058"></a>Purpose</p>
<p>Use to obtain information from a SQL descriptor area.</p>
<p class="subhead1"><a id="LNPCC4059"></a>Syntax</p>
<pre>EXEC SQL [FOR [:]<span class="italic">array_size</span>] GET DESCRIPTOR [GLOBAL | LOCAL] 
   {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} 
   { :<span class="italic">hv0</span>  = COUNT | VALUE <span class="italic">item_number </span>
      :<span class="italic">hv1</span> = <span class="italic">item_name1</span> [ {, :<span class="italic">hvN</span> = <span class="italic">item_nameN</span>}] } ;
</pre>
<p class="subhead1"><a id="LNPCC4060"></a>Variables</p>
<p>array_size</p>
<p>The <code>FOR array_size</code> is an optional Oracle extension. <code>array_size</code> has to be equal to the field <code>array_size</code> in the FETCH statement.</p>
<p>COUNT</p>
<p>The total number of bind variables.</p>
<p>desc_nam</p>
<p>Descriptor name.</p>
<p>GLOBAL | LOCAL</p>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
<p>VALUE item_number</p>
<p>The position of the item in the SQL statement. <code>item_number</code> can be a variable or a constant. If <code>item_number</code> is greater than <code>COUNT</code>, the &#34;no data found&#34; condition is returned. <code>item_number</code> must be greater than 0.</p>
<p>hv1 .. hvN</p>
<p>These are host variables to which values are transferred.</p>
<p>item_name1 .. item_nameN</p>
<p>The descriptor item names corresponding to the host variables. The possible ANSI descriptor item names are:</p>
<div id="LNPCC4061" class="tblformal">
<p class="titleintable"><a id="sthref1782"></a><a id="g1022893"></a>Table 14-4 Definitions of Descriptor Item Names for GET DESCRIPTOR</p>
<table class="cellalignment831" title="Definitions of Descriptor Item Names for GET DESCRIPTOR" summary="Definitions of Descriptor Item Names for GET DESC" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t13"><span class="bold">Descriptor Item Name</span></th>
<th class="cellalignment832" id="r1c2-t13"><span class="bold">Meaning</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t13" headers="r1c1-t13">
<p><code>TYPE</code></p>
</td>
<td class="cellalignment833" headers="r2c1-t13 r1c2-t13">
<p>Use the negative value of Oracle type code if the ANSI datatype is not in the table and TYPE_CODE=ANSI.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t13" headers="r1c1-t13">
<p><code>LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r3c1-t13 r1c2-t13">
<p>Length of data in the column: in characters for NCHAR; in bytes otherwise. Set by the DESCRIBE OUTPUT.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t13" headers="r1c1-t13">
<p><code>OCTET_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r4c1-t13 r1c2-t13">
<p>Length of data in bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t13" headers="r1c1-t13">
<p><code>RETURNED_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r5c1-t13 r1c2-t13">
<p>The actual data length after a FETCH.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t13" headers="r1c1-t13">
<p><code>RETURNED_OCTET_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r6c1-t13 r1c2-t13">
<p>Length of the returned data in bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t13" headers="r1c1-t13">
<p><code>PRECISION</code></p>
</td>
<td class="cellalignment833" headers="r7c1-t13 r1c2-t13">
<p>The number of digits.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t13" headers="r1c1-t13">
<p><code>SCALE</code></p>
</td>
<td class="cellalignment833" headers="r8c1-t13 r1c2-t13">
<p>For exact numeric types, the number of digits to the right of the decimal point.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t13" headers="r1c1-t13">
<p><code>NULLABLE</code></p>
</td>
<td class="cellalignment833" headers="r9c1-t13 r1c2-t13">
<p>If 1, the column can have NULL values. If 0,the column cannot have NULL values.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t13" headers="r1c1-t13">
<p><code>INDICATOR</code></p>
</td>
<td class="cellalignment833" headers="r10c1-t13 r1c2-t13">
<p>The associated indicator value.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t13" headers="r1c1-t13">
<p><code>DATA</code></p>
</td>
<td class="cellalignment833" headers="r11c1-t13 r1c2-t13">
<p>The data value.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t13" headers="r1c1-t13">
<p><code>NAME</code></p>
</td>
<td class="cellalignment833" headers="r12c1-t13 r1c2-t13">
<p>Column name.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r13c1-t13" headers="r1c1-t13">
<p><code>CHARACTER_SET_NAME</code></p>
</td>
<td class="cellalignment833" headers="r13c1-t13 r1c2-t13">
<p>Column&#39;s character set.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#g1022936">Table 14-1, &#34;ANSI SQL Datatypes&#34;</a> for the ANSI type codes</p>
</li>
<li>
<p><a href="pc_15ody.htm#g34096">&#34;Oracle External Datatypes and Datatype Codes&#34;</a> for the Oracle type codes</p>
</li>
</ul>
</div>
<p>The Oracle additional descriptor item names are:</p>
<div id="LNPCC4062" class="tblformal">
<p class="titleintable"><a id="sthref1783"></a><a id="g1022973"></a>Table 14-5 Oracle Extensions to Definitions of Descriptor Item Names for GET DESCRIPTOR</p>
<table class="cellalignment831" title="Oracle Extensions to Definitions of Descriptor Item Names for GET DESCRIPTOR" summary="Oracle Extensions to Definitions of Descriptor Item Names for GET DESCRIPTOR" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t15"><span class="bold">Descriptor Item Name</span></th>
<th class="cellalignment832" id="r1c2-t15"><span class="bold">Meaning</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t15" headers="r1c1-t15">
<p><code>NATIONAL_CHARACTER</code></p>
</td>
<td class="cellalignment833" headers="r2c1-t15 r1c2-t15">
<p>If 2, NCHAR or NVARCHAR2. If 1, character. If 0, non-character.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t15" headers="r1c1-t15">
<p><code>INTERNAL_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r3c1-t15 r1c2-t15">
<p>The internal length, in bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t15" headers="r1c1-t15">
<p><code>HOST_STRIDE_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r4c1-t15 r1c2-t15">
<p>The size of the host struct in bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t15" headers="r1c1-t15">
<p><code>INDICATOR_STRIDE_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r5c1-t15 r1c2-t15">
<p>The size of the indicator struct in bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t15" headers="r1c1-t15">
<p><code>RETURNED_LENGTH_STRIDE</code></p>
</td>
<td class="cellalignment833" headers="r6c1-t15 r1c2-t15">
<p>The size of the returned-length struct in bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t15" headers="r1c1-t15">
<p><code>USER_DEFINED_TYPE_VERSION</code></p>
</td>
<td class="cellalignment833" headers="r7c1-t15 r1c2-t15">
<p>Used for character representation of object type version.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t15" headers="r1c1-t15">
<p><code>USER_DEFINED_TYPE_NAME</code></p>
</td>
<td class="cellalignment833" headers="r8c1-t15 r1c2-t15">
<p>Name of object type.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t15" headers="r1c1-t15">
<p><code>USER_DEFINED_TYPE_NAME_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r9c1-t15 r1c2-t15">
<p>Length of name of object type.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t15" headers="r1c1-t15">
<p><code>USER_DEFINED_TYPE_SCHEMA</code></p>
</td>
<td class="cellalignment833" headers="r10c1-t15 r1c2-t15">
<p>Used for character representation of the object&#39;s schema.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t15" headers="r1c1-t15">
<p><code>USER_DEFINED_TYPE_SCHEMA_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r11c1-t15 r1c2-t15">
<p>Length of <code>USER_DEFINED_TYPE_SCHEMA</code>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t15" headers="r1c1-t15">
<p><code>NATIONAL_CHARACTER</code></p>
</td>
<td class="cellalignment833" headers="r12c1-t15 r1c2-t15">
<p>If 2, NCHAR or NVARCHAR2. If 1, character. If 0, non-character.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="subhead1"><a id="LNPCC4063"></a>Usage Notes</p>
<p>Use the FOR clause in GET DESCRIPTOR statements which contain DATA, INDICATOR, and RETURNED_LENGTH items only.</p>
<p>The internal type is provided by the DESCRIBE OUTPUT statement. For both input and output, you must set the type to be the external type of your host variable.</p>
<p>TYPE is the ANSI SQL Datatype code. Use the negative value of the Oracle type code if the ANSI type is not in the table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#g1022936">Table 14-1, &#34;ANSI SQL Datatypes&#34;</a></p>
</li>
<li>
<p><a href="pc_15ody.htm#g34096">&#34;Oracle External Datatypes and Datatype Codes&#34;</a></p>
</li>
</ul>
</div>
<p>LENGTH contains the column length in characters for fields that have fixed-width National Character Sets. It is in bytes for other character columns. It is set in DESCRIBE OUTPUT.</p>
<p>RETURNED_LENGTH is the actual data length set by the FETCH statement. It is in bytes or characters as described for LENGTH. The fields OCTET_LENGTH and RETURNED_OCTET_LENGTH are the lengths in bytes.</p>
<p>NULLABLE = 1 means that the column can have NULLS; NULLABLE = 0 means it cannot.</p>
<p>CHARACTER_SET_NAME only has meaning for character columns. For other types, it is undefined. The DESCRIBE OUTPUT statement obtains the value.</p>
<p>DATA and INDICATOR are the data value and the indicator status for that column. If data = NULL, but the indicator was not requested, an error is generated at runtime (&#34;DATA EXCEPTION, NULL VALUE, NO INDICATOR PARAMETER&#34;).</p>
<p><a id="LNPCC4064"></a><span class="subhead3">Oracle-Specific Descriptor Item Names&nbsp;</span></p>
<p>NATIONAL_CHARACTER = 2 if the column is an NCHAR or NVARCHAR2 column. If the column is a character (but not National Character) column, this item is set to 1. If a non-character column, this item becomes 0 after DESCRIBE OUTPUT is executed.</p>
<p>INTERNAL_LENGTH is for compatibility with Oracle dynamic Method 4. It has the same value as the length member of the Oracle SQL descriptor area.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_15ody.htm#i22863">Chapter 15, &#34;Oracle Dynamic SQL: Method 4&#34;</a></div>
<p>The following three items are not returned by a DESCRIBE OUTPUT statement.</p>
<ul>
<li>
<p>HOST_STRIDE_LENGTH is the size of the struct of host variables.</p>
</li>
<li>
<p>INDICATOR_STRIDE_LENGTH is the size of the struct of indicator variables.</p>
</li>
<li>
<p>RETURNED_LENGTH_STRIDE is the size of the struct of returned-length variables</p>
</li>
</ul>
<p>The following items apply only to object types when the precompiler option OBJECTS has been set to YES.</p>
<ul>
<li>
<p>USER_DEFINED_TYPE_VERSION contains the character representation of the type version.</p>
</li>
<li>
<p>USER_DEFINED_TYPE_NAME is the character representation of the name of the type.</p>
</li>
<li>
<p>USER_DEFINED_TYPE_NAME_LENGTH is the length of the type name in bytes.</p>
</li>
<li>
<p>USER_DEFINED_TYPE_SCHEMA is the character representation of the schema name of the type.</p>
</li>
<li>
<p>USER_DEFINED_TYPE_SCHEMA_LENGTH is the length in characters of the type&#39;s schema name.</p>
</li>
</ul>
<p class="subhead1"><a id="LNPCC4065"></a>Examples</p>
<pre>EXEC SQL GET DESCRIPTOR :binddes :n = COUNT ;

EXEC SQL GET DESCRIPTOR &#39;SELDES&#39; VALUE 1 :t = TYPE, :l = LENGTH ;

EXEC SQL FOR :batch GET DESCRIPTOR LOCAL &#39;SELDES&#39;
   VALUE :sel_item_no :i = INDICATOR, :v = DATA ; 
</pre></div>
<!-- class="sect2" -->
<a id="i1001420"></a>
<div id="LNPCC4066" class="sect2">
<h3 class="sect2"><a id="sthref1784"></a>SET DESCRIPTOR</h3>
<p class="subhead1"><a id="LNPCC4067"></a>Purpose</p>
<p>Use this statement to set information in the descriptor area from host variables. The SET DESCRIPTOR statement supports <span class="italic">only</span> host variables for the item names.</p>
<p class="subhead1"><a id="LNPCC4068"></a>Syntax</p>
<pre>EXEC SQL [FOR <span class="italic">array_size</span>] SET DESCRIPTOR [GLOBAL | LOCAL] 
   {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} {COUNT = :<span class="italic">hv0</span> | 
   VALUE <span class="italic">item_number</span>
   [REF] <span class="italic">item_name1</span> = :<span class="italic">hv1</span> 
   [{, [REF] <span class="italic">item_nameN</span> = :<span class="italic">hvN</span>}]} ;
</pre>
<p class="subhead1"><a id="LNPCC4069"></a>Variables</p>
<p>array_size</p>
<p>This optional Oracle clause permits using arrays when setting the descriptor items DATA, INDICATOR, and RETURNED_LENGTH only. You cannot use other items in a SET DESCRIPTOR that contains the FOR clause. All host variable array sizes must match. Use the same array size for the SET statement that you use for the FETCH statement.</p>
<p>GLOBAL | LOCAL</p>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
<p>desc_nam</p>
<p>The descriptor name. It follows the rules in ALLOCATE DESCRIPTOR.</p>
<p>COUNT</p>
<p>The number of bind (input) or define (output) variables.</p>
<p>VALUE item_number</p>
<p>Position in the dynamic SQL statement of a host variable.</p>
<p>hv1 .. hvN</p>
<p>The host variables (not constants) that you set.</p>
<p>item_nameI</p>
<p>In a similar way to the GET DESCRIPTOR syntax <code>desc_item_name</code> can take on these values.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a href="#i1007253">&#34;GET DESCRIPTOR&#34;</a></div>
<div id="LNPCC4070" class="tblformal">
<p class="titleintable"><a id="sthref1785"></a><a id="g1045758"></a>Table 14-6 Descriptor Item Names for SET DESCRIPTOR</p>
<table class="cellalignment831" title="Descriptor Item Names for SET DESCRIPTOR" summary="Descriptor Item Names for SET DESCRIPTOR" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t19"><span class="bold">Descriptor Item Name</span></th>
<th class="cellalignment832" id="r1c2-t19"><span class="bold">Meaning</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t19" headers="r1c1-t19">
<p><code>TYPE</code></p>
</td>
<td class="cellalignment833" headers="r2c1-t19 r1c2-t19">
<p>Use negative value of the Oracle type if there is no corresponding ANSI type.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t19" headers="r1c1-t19">
<p><code>LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r3c1-t19 r1c2-t19">
<p>Maximum length of data in the column.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t19" headers="r1c1-t19">
<p><code>INDICATOR</code></p>
</td>
<td class="cellalignment833" headers="r4c1-t19 r1c2-t19">
<p>The associated indicator value. Set for reference semantics.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t19" headers="r1c1-t19">
<p><code>DATA</code></p>
</td>
<td class="cellalignment833" headers="r5c1-t19 r1c2-t19">
<p>Value of the data to be set. Set for reference semantics.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t19" headers="r1c1-t19">
<p><code>CHARACTER_SET_NAME</code></p>
</td>
<td class="cellalignment833" headers="r6c1-t19 r1c2-t19">
<p>Column&#39;s character set.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t19" headers="r1c1-t19">
<p><code>TYPE</code></p>
</td>
<td class="cellalignment833" headers="r7c1-t19 r1c2-t19">
<p>Use negative value of the Oracle type if there is no corresponding ANSI type.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#g1022936">Table 14-1, &#34;ANSI SQL Datatypes&#34;</a> for the ANSI type codes</p>
</li>
<li>
<p><a href="pc_15ody.htm#g34096">&#34;Oracle External Datatypes and Datatype Codes&#34;</a> for the Oracle type codes</p>
</li>
</ul>
</div>
<p>The Oracle extensions to the descriptor item names are:</p>
<div id="LNPCC4071" class="tblformal">
<p class="titleintable"><a id="sthref1786"></a><a id="g1045970"></a>Table 14-7 Oracle Extensions to Descriptor Item Names for SET DESCRIPTOR</p>
<table class="cellalignment831" title="Oracle Extensions to Descriptor Item Names for SET DESCRIPTOR" summary="Oracle Extensions to Descriptor Item Names for SET DESCRIPTOR" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t21"><span class="bold">Descriptor Item Name</span></th>
<th class="cellalignment832" id="r1c2-t21"><span class="bold">Meaning</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t21" headers="r1c1-t21">
<p><code>RETURNED_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r2c1-t21 r1c2-t21">
<p>Length returned after a FETCH. Set if reference semantics is being used.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t21" headers="r1c1-t21">
<p><code>NATIONAL_CHARACTER</code></p>
</td>
<td class="cellalignment833" headers="r3c1-t21 r1c2-t21">
<p>Set to 2 when the input host variable is an NCHAR or NVARCHAR2 type.</p>
<p>Set to 0 when the National Character setting is clear.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t21" headers="r1c1-t21">
<p><code>HOST_STRIDE_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r4c1-t21 r1c2-t21">
<p>Size of the host variable struct in bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t21" headers="r1c1-t21">
<p><code>INDICATOR_STRIDE_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r5c1-t21 r1c2-t21">
<p>Size of the indicator variable in bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t21" headers="r1c1-t21">
<p><code>RETURNED_LENGTH_STRIDE</code></p>
</td>
<td class="cellalignment833" headers="r6c1-t21 r1c2-t21">
<p>Size of the returned-length struct in bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t21" headers="r1c1-t21">
<p><code>USER_DEFINED_TYPE_NAME</code></p>
</td>
<td class="cellalignment833" headers="r7c1-t21 r1c2-t21">
<p>Name of object type.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t21" headers="r1c1-t21">
<p><code>USER_DEFINED_TYPE_NAME_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r8c1-t21 r1c2-t21">
<p>Length of name of object type.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t21" headers="r1c1-t21">
<p><code>USER_DEFINED_TYPE_SCHEMA</code></p>
</td>
<td class="cellalignment833" headers="r9c1-t21 r1c2-t21">
<p>Used for character representation of the object&#39;s schema.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t21" headers="r1c1-t21">
<p><code>USER_DEFINED_TYPE_SCHEMA_LENGTH</code></p>
</td>
<td class="cellalignment833" headers="r10c1-t21 r1c2-t21">
<p>Length of <code>USER_DEFINED_TYPE_SCHEMA</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="subhead1"><a id="LNPCC4072"></a>Usage Notes</p>
<p>Reference semantics is another optional Oracle extension that speeds performance. Use the keyword REF before these descriptor items names only: DATA, INDICATOR, RETURNED_LENGTH. When you use the REF keyword you do not need to use a GET statement. Complex data types (object and collection types, arrays of structs, and the DML returning clause) all require the REF form of SET DESCRIPTOR.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_06sql.htm#i5385">&#34;The DML Returning Clause&#34;</a></div>
<p>If the program reuses DESCRIPTOR for another SQL, the old values of DESCRIPTOR remain.</p>
<p>When REF is used the associated host variable itself is used in the SET. The GET is not needed in this case. The RETURNED_LENGTH can only be set when you use the REF semantics, not the value semantics.</p>
<p>Use the same array size for the SET or GET statements that you use in the FETCH.</p>
<p>Set the NATIONAL_CHAR field to 2 for NCHAR host input values.</p>
<p>Set the NATIONAL_CHARACTER field to 0 when DESCRIPTOR is used for NCHAR host input values in the old SQL.</p>
<p>When setting an object type&#39;s characteristics, you must set USER_DEFINED_TYPE_NAME and USER_DEFINED_TYPE_NAME_LENGTH.</p>
<p>If omitted, USER_DEFINED_TYPE_SCHEMA and USER_DEFINED_TYPE_SCHEMA_LENGTH default to the current connection.</p>
<p>Set CHARACTER_SET_NAME to UTF16 for client-side Unicode support. The data will be in UCS2 encoding and the RETURNED_LENGTH is in CHARS.</p>
<p class="subhead1"><a id="LNPCC4073"></a>Example</p>
<pre>int bindno = 2 ;
short indi = -1 ;
char data = &#34;ignore&#34; ;
int batch = 1 ;

EXEC SQL FOR :batch ALLOCATE DESCRIPTOR &#39;binddes&#39; ;
EXEC SQL SET DESCRIPTOR GLOBAL :binddes COUNT = 3 ;
EXEC SQL FOR :batch SET DESCRIPTOR :bindes
   VALUE :bindno INDICATOR = :indi, DATA = :data ;
...
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1003925">&#34;Using Arrays for Bulk Operations&#34;</a> for examples of bulk arrays</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC4074" class="sect2"><a id="sthref1787"></a>
<h3 class="sect2">Use of<a id="sthref1788"></a> PREPARE</h3>
<p class="subhead1"><a id="LNPCC4075"></a>Purpose</p>
<p>The PREPARE statement used in this method is the same as the PREPARE statement used in the other dynamic SQL methods. An Oracle extension allows a quoted string for the SQL statement, as well as a variable.</p>
<p class="subhead1"><a id="LNPCC4076"></a>Syntax</p>
<pre>EXEC SQL PREPARE <span class="italic">statement_id</span> FROM :<span class="italic">sql_statement </span>;
</pre>
<p class="subhead1"><a id="LNPCC4077"></a>Variables</p>
<p>statement_id</p>
<p>This must not be declared; it is a undeclared SQL identifier.</p>
<p>sql_statement</p>
<p>A character string (a constant or a variable) holding the embedded SQL statement.</p>
<p class="subhead1"><a id="LNPCC4078"></a>Example</p>
<pre>char* statement = &#34;SELECT ENAME FROM emp WHERE deptno = :d&#34; ;
EXEC SQL PREPARE S1 FROM :statement ;
</pre></div>
<!-- class="sect2" -->
<a id="i1009239"></a>
<div id="LNPCC4079" class="sect2">
<h3 class="sect2"><a id="sthref1789"></a>DESCRIBE INPUT</h3>
<p class="subhead1"><a id="LNPCC4080"></a>Purpose</p>
<p>This statement returns information about the bind variables.</p>
<p class="subhead1"><a id="LNPCC4081"></a>Syntax</p>
<pre>EXEC SQL DESCRIBE INPUT <span class="italic">statement_id</span> USING [SQL] DESCRIPTOR 
   [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} ;
</pre>
<p class="subhead1"><a id="LNPCC4082"></a>Variables</p>
<p>statement_id</p>
<p>The same as used in PREPARE and DESCRIBE OUTPUT. This must not be declared; it is an undeclared SQL identifier.</p>
<p>GLOBAL | LOCAL</p>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
<p>desc_nam</p>
<p>The descriptor name.</p>
<p class="subhead1"><a id="LNPCC4083"></a>Usage Notes</p>
<p>DESCRIBE INPUT only sets COUNT and NAME items.</p>
<p class="subhead1"><a id="LNPCC4084"></a>Examples</p>
<pre>EXEC SQL DESCRIBE INPUT S1 USING SQL DESCRIPTOR GLOBAL :binddes ;
EXEC SQL DESCRIBE INPUT S2 USING DESCRIPTOR &#39;input&#39; ;
</pre></div>
<!-- class="sect2" -->
<a id="i1009240"></a>
<div id="LNPCC4085" class="sect2">
<h3 class="sect2"><a id="sthref1790"></a>DESCRIBE OUTPUT</h3>
<p class="subhead1"><a id="LNPCC4086"></a>Purpose</p>
<p>Use this statement to obtain information about the output columns in a PREPAREd statement. The ANSI syntax differs from the older Oracle syntax. The information which is stored in the SQL descriptor area is the number of values returned and associated information such as type, length, and name.</p>
<p class="subhead1"><a id="LNPCC4087"></a>Syntax</p>
<pre>EXEC SQL DESCRIBE [OUTPUT] <span class="italic">statement_id</span> USING [SQL] DESCRIPTOR
   [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}<span class="italic"> ;</span>
</pre>
<p class="subhead1"><a id="LNPCC4088"></a>Variables</p>
<p>statement_id</p>
<p>The same as used in PREPARE. This must not be declared; it is an undeclared SQL identifier.</p>
<p>GLOBAL | LOCAL</p>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
<p>desc_nam</p>
<p>The descriptor name.</p>
<p>OUTPUT is the default and can be omitted.</p>
<p class="subhead1"><a id="LNPCC4089"></a>Examples</p>
<pre>char* desname = &#34;SELDES&#34; ;
EXEC SQL DESCRIBE S1 USING SQL DESCRIPTOR &#39;SELDES&#39; ; /* Or, */
EXEC SQL DESCRIBE OUTPUT S1 USING DESCRIPTOR :desname ;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4090" class="sect2"><a id="sthref1791"></a>
<h3 class="sect2"><a id="sthref1792"></a>EXECUTE</h3>
<p class="subhead1"><a id="LNPCC4091"></a>Purpose</p>
<p>EXECUTE matches input and output variables in a prepared SQL statement and then executes the statement. This ANSI version of EXECUTE differs from the older EXECUTE statement by allowing two descriptors in one statement to support DML returning clause.</p>
<p class="subhead1"><a id="LNPCC4092"></a>Syntax</p>
<pre>EXEC SQL [FOR :<span class="italic">array_size</span>] EXECUTE <span class="italic">statement_id</span> 
    [USING [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}] 
        [INTO [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}] ;
</pre>
<p class="subhead1"><a id="LNPCC4093"></a>Variables</p>
<p>array_size</p>
<p>The number of rows the statement will process.</p>
<p>statement_id</p>
<p>The same as used in PREPARE. This must not be declared; it is an undeclared SQL identifier. It can be a literal.</p>
<p>GLOBAL | LOCAL</p>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
<p>desc_nam</p>
<p>The descriptor name.</p>
<p class="subhead1"><a id="LNPCC4094"></a>Usage Notes</p>
<p>The INTO clause implements the DML returning clause for INSERT, UPDATE and DELETE.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_06sql.htm#i5385">&#34;The DML Returning Clause&#34;</a></div>
<p class="subhead1"><a id="LNPCC4095"></a>Examples</p>
<pre>EXEC SQL EXECUTE S1 USING SQL DESCRIPTOR GLOBAL :binddes ;

EXEC SQL EXECUTE S2 USING DESCRIPTOR :bv1 INTO DESCRIPTOR &#39;SELDES&#39; ;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4096" class="sect2"><a id="sthref1793"></a>
<h3 class="sect2"><a id="sthref1794"></a>Use of EXECUTE IMMEDIATE</h3>
<p class="subhead1"><a id="LNPCC4097"></a>Purpose</p>
<p>Executes a literal or host variable character string containing the SQL statement.The ANSI SQL form of this statement is the same as in the older Oracle dynamic SQL:</p>
<p class="subhead1"><a id="LNPCC4098"></a>Syntax</p>
<pre>EXEC SQL EXECUTE IMMEDIATE {:<span class="italic">sql_statement </span>| <span class="italic">string_literal</span>}
</pre>
<p class="subhead1"><a id="LNPCC4099"></a>Variable</p>
<p>sql_statement</p>
<p>The SQL statement or PL/SQL block in a character string.</p>
<p class="subhead1"><a id="LNPCC4100"></a>Example</p>
<pre>EXEC SQL EXECUTE IMMEDIATE :statement ;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4101" class="sect2"><a id="sthref1795"></a>
<h3 class="sect2"><a id="sthref1796"></a>Use of DYNAMIC DECLARE CURSOR</h3>
<p class="subhead1"><a id="LNPCC4102"></a>Purpose</p>
<p>Declares a cursor that is associated with a statement which is a query. This is a form of the generic Declare Cursor statement.</p>
<p class="subhead1"><a id="LNPCC4103"></a>Syntax</p>
<pre>EXEC SQL DECLARE <span class="italic">cursor_name</span> CURSOR FOR <span class="italic">statement_id;</span>
</pre>
<p class="subhead1"><a id="LNPCC4104"></a>Variables</p>
<p>cursor_name</p>
<p>A cursor variable (a SQL identifier, not a host variable).</p>
<p>statement_id</p>
<p>An undeclared SQL identifier.</p>
<p class="subhead1"><a id="LNPCC4105"></a>Example</p>
<pre>EXEC SQL DECLARE C1 CURSOR FOR S1 ; 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4106" class="sect2"><a id="sthref1797"></a>
<h3 class="sect2"><a id="sthref1798"></a>OPEN Cursor</h3>
<p class="subhead1"><a id="LNPCC4107"></a>Purpose</p>
<p>The OPEN statement associates input parameters with a cursor and then opens the cursor.</p>
<p class="subhead1"><a id="LNPCC4108"></a>Syntax</p>
<pre>EXEC SQL [FOR :<span class="italic">array_size</span>] OPEN <span class="italic">dyn_cursor</span> 
    [[USING [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam1 </span>|<span class="italic"> string_literal</span>}]
    [INTO [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam2 </span>|<span class="italic"> string_literal</span>}]] ;
</pre>
<p class="subhead1"><a id="LNPCC4109"></a>Variables</p>
<p>array_size</p>
<p>This limit is less than or equal to number specified when the descriptor was allocated.</p>
<p>dyn_cursor</p>
<p>The cursor variable.</p>
<p>GLOBAL | LOCAL</p>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
<p>desc_nam</p>
<p>The descriptor name.</p>
<p class="subhead1"><a id="LNPCC4110"></a>Usage Notes</p>
<p>If the prepared statement associated with the cursor contains colons or question marks, a USING clause must be specified, or an error results at runtime. The DML returning clause is supported.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_06sql.htm#i5385">&#34;The DML Returning Clause&#34;</a></div>
<p class="subhead1"><a id="LNPCC4111"></a>Examples</p>
<pre>EXEC SQL OPEN C1 USING SQL DESCRIPTOR :binddes ;

EXEC SQL FOR :limit OPEN C2 USING DESCRIPTOR :b1, :b2 
   INTO SQL DESCRIPTOR :seldes ;
</pre></div>
<!-- class="sect2" -->
<a id="i1007038"></a>
<div id="LNPCC4112" class="sect2">
<h3 class="sect2"><a id="sthref1799"></a>FETCH</h3>
<p class="subhead1"><a id="LNPCC4113"></a>Purpose</p>
<p>Fetches a row for a cursor declared with a dynamic DECLARE statement.</p>
<p class="subhead1"><a id="LNPCC4114"></a>Syntax</p>
<pre>EXEC SQL [FOR :<span class="italic">array_size</span>] FETCH <span class="italic">cursor</span> INTO [SQL] DESCRIPTOR 
   [GLOBAL | LOCAL] {<span class="italic">:desc_nam | string_literal</span>} ;
</pre>
<p class="subhead1"><a id="LNPCC4115"></a>Variables</p>
<p>array_size</p>
<p>The number of rows the statement will process.</p>
<p>cursor</p>
<p>The dynamic cursor that was previously declared.</p>
<p>GLOBAL | LOCAL</p>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
<p>desc_nam</p>
<p>Descriptor name.</p>
<p class="subhead1"><a id="LNPCC4116"></a>Usage Notes</p>
<p>The optional <code>array_size</code> in the FOR clause must be less than or equal to the number specified in the ALLOCATE DESCRIPTOR statement.</p>
<p class="subhead1"><a id="LNPCC4117"></a>Examples</p>
<pre>EXEC SQL FETCH FROM C1 INTO DESCRIPTOR &#39;SELDES&#39; ;

EXEC SQL FOR :arsz FETCH C2 INTO DESCRIPTOR :desc ;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4118" class="sect2"><a id="sthref1800"></a>
<h3 class="sect2"><a id="sthref1801"></a>CLOSE a Dynamic Cursor</h3>
<p class="subhead1"><a id="LNPCC4119"></a>Purpose</p>
<p>Closes a dynamic cursor. Syntax has not changed from the older Oracle Method 4:</p>
<p class="subhead1"><a id="LNPCC4120"></a>Syntax</p>
<pre>EXEC SQL CLOSE <span class="italic">cursor</span> ;
</pre>
<p class="subhead1"><a id="LNPCC4121"></a>Variable</p>
<p>cursor</p>
<p>The dynamic cursor that was previously declared.</p>
<p class="subhead1"><a id="LNPCC4122"></a>Example</p>
<pre>EXEC SQL CLOSE C1 ;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4123" class="sect2"><a id="sthref1802"></a>
<h3 class="sect2"><a id="sthref1803"></a>Differences From Oracle Dynamic Method 4</h3>
<p>The ANSI dynamic SQL interface supports all the datatypes supported by the Oracle dynamic Method 4, with these additions:</p>
<ul>
<li>
<p>All datatypes, including object types, result sets, and LOB types are supported by ANSI Dynamic SQL.</p>
</li>
<li>
<p>The ANSI mode uses an internal <span class="italic">SQL descriptor area</span> which is an expansion of the external SQLDA used in Oracle older dynamic Method 4 to store its input and output information.</p>
</li>
<li>
<p>New embedded SQL statements are introduced: ALLOCATE DESCRIPTOR, DEALLOCATE DESCRIPTOR, DESCRIBE, GET DESCRIPTOR, and SET DESCRIPTOR.</p>
</li>
<li>
<p>The DESCRIBE statement does not return the names of indicator variables in ANSI Dynamic SQL.</p>
</li>
<li>
<p>ANSI Dynamic SQL does not allow you to specify the maximum size of the returned column name or expression. The default size is set at 128.</p>
</li>
<li>
<p>The descriptor name must be either an identifier in single-quotes or a host variable preceded by a colon.</p>
</li>
<li>
<p>For output, the optional SELECT LIST FOR clause in the DESCRIBE is replaced by the optional keyword OUTPUT. The INTO clause is replaced by the USING DESCRIPTOR clause, which can contain the optional keyword SQL.</p>
</li>
<li>
<p>For input, the optional BIND VARIABLES FOR clause of the DESCRIBE can be replaced by the keyword INPUT. The INTO clause is replaced by the USING DESCRIPTOR clause, which can contain the optional keyword SQL.</p>
</li>
<li>
<p>The optional keyword SQL can come before the keyword DESCRIPTOR in the USING clause of the EXECUTE, FETCH and OPEN statements.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCC4124" class="sect2"><a id="sthref1804"></a>
<h3 class="sect2">Restrictions</h3>
<p>Restrictions in effect on ANSI dynamic SQL are:</p>
<ul>
<li>
<p>You cannot mix ANSI and Oracle dynamic SQL methods in the same module.</p>
</li>
<li>
<p>The precompiler option DYNAMIC must be set to ANSI. The precompiler option TYPE_CODE can be set to ANSI only if DYNAMIC is set to ANSI.</p>
</li>
<li>
<p>The SET statement supports only host variables as item names.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006299"></a>
<div id="LNPCC4125" class="sect1">
<h2 class="sect1"><a id="sthref1805"></a>Example Programs</h2>
<p>The following two programs are in the demo directory.</p>
<div id="LNPCC4126" class="sect2"><a id="sthref1806"></a>
<h3 class="sect2">ansidyn1.pc<a id="sthref1807"></a></h3>
<p><a id="i1007767"></a>This program demonstrates using ANSI Dynamic SQL to process SQL statements which are not known until runtime. It is intended to demonstrate the simplest (though not the most efficient) approach to using ANSI Dynamic SQL. It uses ANSI compatible value semantics and ANSI type codes. ANSI SQLSTATE is used for error numbers. Descriptor names are literals. All input and output is through ANSI varying character type.</p>
<p>The program connects you to ORACLE using your username and password, then prompts you for a SQL statement. Enter legal SQL or PL/SQL statements using regular, not embedded, SQL syntax and terminate each statement with a semicolon. Your statement will be processed. If it is a query, the fetched rows are displayed.</p>
<p>You can enter multiline statements. The limit is 1023 characters. There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255. This program processes up to 40 bind variables and 40 select-list items. DML returning clauses and user defined types are not supported with value semantics.</p>
<p>Precompile the program with mode = ansi, for example:</p>
<pre>proc mode=ansi ansidyn1
</pre>
<p>Using <code>mode=ansi</code> will set dynamic and <code>type_code</code> to ansi.</p>
<pre>/*******************************************************************
ANSI Dynamic Demo 1:  ANSI Dynamic SQL with value semantics,
                                   literal descriptor names
                                   and ANSI type codes

This program demonstates using ANSI Dynamic SQL to process SQL
statements which are not known until runtime.  It is intended to
demonstrate the simplest (though not the most efficient) approach
to using ANSI Dynamic SQL.  It uses ANSI compatible value semantics
and ANSI type codes. ANSI Sqlstate is used for error numbers. 
Descriptor names are literals. All input and output is through ANSI the
varying character type.

The program connects you to ORACLE using your username and password,
then prompts you for a SQL statement.  Enter legal SQL or PL/SQL 
statements using regular, not embedded, SQL syntax and terminate each 
statement with a seimcolon.  Your statement will be processed.  If it
is a query, the fetched rows are displayed.  

You can enter multiline statements.  The limit is 1023 characters.
There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255.
This program processes up to 40 bind variables and 40 select-list items.
DML returning statments and user defined types are not supported with 
value semantics.

Precompile the program with mode=ansi, for example:
 
proc mode=ansi ansidyn1

Using mode=ansi will set dynamic and type_code to ansi.

*******************************************************************/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlcpr.h&gt;

#define MAX_OCCURENCES 40
#define MAX_VAR_LEN    255
#define MAX_NAME_LEN   31

#ifndef NULL
#define NULL  0
#endif


/* Prototypes */
#if defined(__STDC__)
  void sql_error(void);
  int oracle_connect(void);
  int get_dyn_statement(void);
  int process_input(void);
  int process_output(void);
  void help(void);
#else
  void sql_error(/*_ void _*/);
  int oracle_connect(/*_ void _*/);
  int get_dyn_statement(/* void _*/);
  int process_input(/*_ void _*/);
  int process_output(/*_ void _*/);
  void help(/*_ void _*/);
#endif

EXEC SQL INCLUDE sqlca;

char SQLSTATE[6];

/* global variables */
EXEC SQL BEGIN DECLARE SECTION;
 char    dyn_statement[1024];
 char SQLSTATE[6];
EXEC SQL END DECLARE SECTION;




/* Define a buffer to hold longjmp state info. */
jmp_buf jmp_continue;

/* A global flag for the error routine. */
int parse_flag = 0;
/* A global flag to indicate statement is a select */
int select_found;   

void main()
{

    /* Connect to the database. */
    if (oracle_connect() != 0)
        exit(1);

    EXEC SQL WHENEVER SQLERROR DO sql_error();

    /* Allocate the input and output descriptors. */
    EXEC SQL ALLOCATE DESCRIPTOR &#39;input_descriptor&#39;;
    EXEC SQL ALLOCATE DESCRIPTOR &#39;output_descriptor&#39;;

    /* Process SQL statements. */
    for (;;) 
    {
        (void) setjmp(jmp_continue);

        /* Get the statement.  Break on &#34;exit&#34;. */
        if (get_dyn_statement() != 0)
            break;

        /* Prepare the statement and declare a cursor. */
        parse_flag = 1;     /* Set a flag for sql_error(). */
        EXEC SQL PREPARE S FROM :dyn_statement;
        parse_flag = 0;     /* Unset the flag. */

        EXEC SQL DECLARE C CURSOR FOR S;

        /* Call the function that processes the input. */
        if (process_input())
            exit(1);
 
        /* Open the cursor and execute the statement. */
        EXEC SQL OPEN C USING DESCRIPTOR &#39;input_descriptor&#39;;

        /* Call the function that processes the output. */
        if (process_output())
            exit(1);

        /* Close the cursor. */
        EXEC SQL CLOSE C;

    }   /* end of for(;;) statement-processing loop */


    /* Deallocate the descriptors */
    EXEC SQL DEALLOCATE DESCRIPTOR &#39;input_descriptor&#39;;
    EXEC SQL DEALLOCATE DESCRIPTOR &#39;output_descriptor&#39;;

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL COMMIT WORK;
    puts(&#34;\nHave a good day!\n&#34;);

    EXEC SQL WHENEVER SQLERROR DO sql_error();
    return;
}



int get_dyn_statement()
{
    char *cp, linebuf[256];
    int iter, plsql;

    for (plsql = 0, iter = 1; ;)
    {
        if (iter == 1)
        {
            printf(&#34;\nSQL&gt; &#34;);
            dyn_statement[0] = &#39;\0&#39;;
            select_found = 0;
        }
        
        fgets(linebuf, sizeof linebuf, stdin);

        cp = strrchr(linebuf, &#39;\n&#39;);
        if (cp &amp;&amp; cp != linebuf)
            *cp = &#39; &#39;;
        else if (cp == linebuf)
            continue;

        if ((strncmp(linebuf, &#34;SELECT&#34;, 6) == 0) ||
            (strncmp(linebuf, &#34;select&#34;, 6) == 0))
        {
            select_found=1;;
        }

        if ((strncmp(linebuf, &#34;EXIT&#34;, 4) == 0) ||
            (strncmp(linebuf, &#34;exit&#34;, 4) == 0))
        {
            return -1;
        }

        else if (linebuf[0] == &#39;?&#39; ||
            (strncmp(linebuf, &#34;HELP&#34;, 4) == 0) ||
            (strncmp(linebuf, &#34;help&#34;, 4) == 0))
        {
            help();
            iter = 1;
            continue;
        }

        if (strstr(linebuf, &#34;BEGIN&#34;) ||
            (strstr(linebuf, &#34;begin&#34;)))
        {
            plsql = 1;
        }

        strcat(dyn_statement, linebuf);

        if ((plsql &amp;&amp; (cp = strrchr(dyn_statement, &#39;/&#39;))) ||
            (!plsql &amp;&amp; (cp = strrchr(dyn_statement, &#39;;&#39;))))
        {
            *cp = &#39;\0&#39;;
            break;
        }
        else
        {
            iter++;
            printf(&#34;%3d  &#34;, iter);
        }
    }
    return 0;
}


int process_input()
{
    int i;
    EXEC SQL BEGIN DECLARE SECTION;
      char name[31];
      int  input_count, input_len, occurs, ANSI_varchar_type;
      char input_buf[MAX_VAR_LEN];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR &#39;input_descriptor&#39;;
    EXEC SQL GET DESCRIPTOR &#39;input_descriptor&#39; :input_count = COUNT; 
       
    ANSI_varchar_type=12;
    for (i=0; i &lt; input_count; i++)
    {
        occurs = i +1;                       /* occurence is 1 based */
        EXEC SQL GET DESCRIPTOR &#39;input_descriptor&#39; 
                 VALUE :occurs :name = NAME;
        printf (&#34;\nEnter value for input variable %*.*s:  &#34;, 10,31, name);
        fgets(input_buf, sizeof(input_buf), stdin);
        input_len = strlen(input_buf) - 1;  /* get rid of new line */
        input_buf[input_len] = &#39;\0&#39;;        /* null terminate */
        EXEC SQL SET DESCRIPTOR &#39;input_descriptor&#39;
                 VALUE :occurs TYPE = :ANSI_varchar_type, 
                               LENGTH = :input_len,
                               DATA = :input_buf;
    }
    return(sqlca.sqlcode);
}


int process_output()
{
   int i, j;
   EXEC SQL BEGIN DECLARE SECTION;
     int output_count, occurs, type, len, col_len;
     short indi;
     char data[MAX_VAR_LEN], name[MAX_NAME_LEN];
   EXEC SQL END DECLARE SECTION;
   if (!select_found)
       return(0);   

   EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR &#39;output_descriptor&#39;;
   
   EXEC SQL GET DESCRIPTOR &#39;output_descriptor&#39; :output_count = COUNT;


   printf (&#34;\n&#34;);
   type = 12;            /* ANSI VARYING character type */
   len = MAX_VAR_LEN;    /* use the max allocated length */
   for (i = 0; i &lt; output_count; i++)
    {
        occurs = i + 1;
        EXEC SQL GET DESCRIPTOR &#39;output_descriptor&#39; VALUE :occurs
                 :name = NAME;
        printf(&#34;%-*.*s &#34;, 9,9, name);
        EXEC SQL SET DESCRIPTOR &#39;output_descriptor&#39; VALUE :occurs 
                 TYPE = :type, LENGTH = :len;
    }   
    printf(&#34;\n&#34;);

    /* FETCH each row selected and print the column values. */
    EXEC SQL WHENEVER NOT FOUND GOTO end_select_loop;

    for (;;)
    {
        EXEC SQL FETCH C INTO DESCRIPTOR &#39;output_descriptor&#39;;
        for (i=0; i &lt; output_count; i++)
          {
            occurs = i + 1;
            EXEC SQL GET DESCRIPTOR &#39;output_descriptor&#39; VALUE :occurs
                 :data = DATA, :indi = INDICATOR;
            if (indi == -1)       
              printf(&#34;%-*.*s &#34;, 9,9, &#34;NULL&#34;);
            else
              printf(&#34;%-*.*s &#34;, 9,9, data);  /* simplified output formatting */ 
                          /* truncation will occur, but columns will line up */
          }                             
         printf (&#34;\n&#34;);
    }
end_select_loop:
    return(0);
}



void help()
{
    puts(&#34;\n\nEnter a SQL statement or a PL/SQL block at the SQL&gt; prompt.&#34;);
    puts(&#34;Statements can be continued over several lines, except&#34;);
    puts(&#34;within string literals.&#34;);
    puts(&#34;Terminate a SQL statement with a semicolon.&#34;);
    puts(&#34;Terminate a PL/SQL block (which can contain embedded semicolons)&#34;);
    puts(&#34;with a slash (/).&#34;);
    puts(&#34;Typing \&#34;exit\&#34; (no semicolon needed) exits the program.&#34;);
    puts(&#34;You typed \&#34;?\&#34; or \&#34;help\&#34; to get this message.\n\n&#34;);
}


void sql_error()
{
    /* ORACLE error handler */
    printf(&#34;\n\nANSI sqlstate: %s: &#34;, SQLSTATE);
    printf (&#34;\n\n%.70s\n&#34;,sqlca.sqlerrm.sqlerrmc);
    if (parse_flag)
        printf
        (&#34;Parse error at character offset %d in SQL statement.\n&#34;,
           sqlca.sqlerrd[4]);

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK;
    longjmp(jmp_continue, 1);
}


int oracle_connect()
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR  username[128];
        VARCHAR  password[32];
    EXEC SQL END DECLARE SECTION;

    printf(&#34;\nusername: &#34;);
    fgets((char *) username.arr, sizeof username.arr, stdin);
    username.arr[strlen((char *) username.arr)-1] = &#39;\0&#39;;
    username.len = (unsigned short)strlen((char *) username.arr);

    printf(&#34;password: &#34;);
    fgets((char *) password.arr, sizeof password.arr, stdin);
    password.arr[strlen((char *) password.arr) - 1] = &#39;\0&#39;;
    password.len = (unsigned short)strlen((char *) password.arr);


    EXEC SQL WHENEVER SQLERROR GOTO connect_error;

    EXEC SQL CONNECT :username IDENTIFIED BY :password;

    printf(&#34;\nConnected to ORACLE as user %s.\n&#34;, username.arr);

    return 0;

connect_error:
    fprintf(stderr, &#34;Cannot connect to ORACLE as user %s\n&#34;, username.arr);
    return -1;
}
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4127" class="sect2"><a id="sthref1808"></a>
<h3 class="sect2"><a id="sthref1809"></a>ansidyn2.pc<a id="sthref1810"></a></h3>
<p><a id="i1007768"></a>This program demonstrates using ANSI Dynamic SQL to process SQL statements which are not known until runtime. It uses the Oracle extensions for batch processing and reference semantics.</p>
<p>The program connects you to ORACLE using your username and password, then prompts you for a SQL statement. Enter legal SQL or PL/SQL statement using interactive, not embedded, SQL syntax, terminating the statement with a semicolon. Your statement will be processed. If it is a query, the fetched rows are displayed.</p>
<p>You can enter multiline statements. The limit is 1023 characters. There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255. This program processes up to 40 bind variables and 40 select-list items.</p>
<p>Precompile the program with <code>dynamic = ansi</code>, for example:</p>
<pre>proc dynamic=ansi ansidyn2

/*******************************************************************
ANSI Dynamic Demo 2:  ANSI Dynamic SQL with reference semantics,
                           batch processing and global descriptor
                           names in host variables
                           
This program demonstates using ANSI Dynamic SQL to process SQL
statements which are not known until runtime.  It uses the Oracle
extensions for batch processing and reference semantics.

The program connects you to ORACLE using your username and password,
then prompts you for a SQL statement.  Enter legal SQL or PL/SQL 
statement using interactive, not embedded, SQL syntax, terminating the 
statement with a seimcolon.  Your statement will be processed.  If it
is a query, the fetched rows are displayed. 

If your statement has input bind variables (other than in a where clause),
the program will ask for an input array size and then allow you to enter 
that number of input values. If your statment has output, the program will
ask you for an output array size and will do array fetchng using that value.
It will also output the rows fetched in one batch together, so using a small
value for the output array size will improve the look of the output.  
For example, connected as scott/tiger, try select empno, ename from emp
with an output array size of 4;

You can enter multiline statements.  The limit is 1023 characters.
There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255.
This program processes up to 40 bind variables and 40 select-list items.

Precompile with program with dynamic=ansi, for example:
 
proc dynamic=ansi ansidyn2

*******************************************************************/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlcpr.h&gt;


#define MAX_OCCURENCES  40
#define MAX_ARRSZ      100
#define MAX_VAR_LEN    255
#define MAX_NAME_LEN    31

#ifndef NULL
#define NULL  0
#endif


/* Prototypes */
#if defined(__STDC__)
  void sql_error(void);
  int oracle_connect(void);
  int get_dyn_statement(void);
  int process_input(void);
  int process_output(void);
  void rows_processed(void);
  void help(void);
#else
  void sql_error(/*_ void _*/);
  int oracle_connect(/*_ void _*/);
  int get_dyn_statement(/* void _*/);
  int process_input(/*_ void _*/);
  int process_output(/*_ void _*/);
  void rows_processed(/*_ void _*/);
  void help(/*_ void _*/);
#endif

EXEC SQL INCLUDE sqlca;

/* global variables */
char    dyn_statement[1024];                      /* statement variable     */
EXEC SQL VAR dyn_statement IS STRING(1024);

char  indesc[]=&#34;input_descriptor&#34;;                /* descriptor names       */
char outdesc[]=&#34;output_descriptor&#34;;
char   input[MAX_OCCURENCES][MAX_ARRSZ][MAX_VAR_LEN +1 ],    /* data areas */
      output[MAX_OCCURENCES][MAX_ARRSZ][MAX_VAR_LEN + 1];

short outindi[MAX_OCCURENCES][MAX_ARRSZ];        /* output indicators      */
short *iptr;

int   in_array_size;     /* size of input batch, that is, number of rows */
int   out_array_size;    /* size of input batch, that is, number of rows */
int   max_array_size=MAX_ARRSZ;   /* maximum arrays size used for allocates */

char *dml_commands[] = {&#34;SELECT&#34;, &#34;select&#34;, &#34;INSERT&#34;, &#34;insert&#34;,
                        &#34;UPDATE&#34;, &#34;update&#34;, &#34;DELETE&#34;, &#34;delete&#34;};

int select_found, cursor_open = 0;

/* Define a buffer to hold longjmp state info. */
jmp_buf jmp_continue;

/* A global flag for the error routine. */
int parse_flag = 0;

void main()
{

    /* Connect to the database. */
    if (oracle_connect() != 0)
        exit(1);

    EXEC SQL WHENEVER SQLERROR DO sql_error();

    /* Allocate the input and output descriptors. */
    EXEC SQL FOR :max_array_size
             ALLOCATE DESCRIPTOR GLOBAL :indesc;
    EXEC SQL FOR :max_array_size
             ALLOCATE DESCRIPTOR GLOBAL :outdesc;

    /* Process SQL statements. */
    for (;;) 
    {
        (void) setjmp(jmp_continue);

        /* Get the statement.  Break on &#34;exit&#34;. */
        if (get_dyn_statement() != 0)
            break;

        /* Prepare the statement and declare a cursor. */
        parse_flag = 1;     /* Set a flag for sql_error(). */
        EXEC SQL PREPARE S FROM :dyn_statement;
        parse_flag = 0;     /* Unset the flag. */

        EXEC SQL DECLARE C CURSOR FOR S;

        /* Call the function that processes the input. */
        if (process_input())
            exit(1);

        /* Open the cursor and execute the statement. */
        EXEC SQL FOR :in_array_size
            OPEN C USING DESCRIPTOR GLOBAL :indesc;
        cursor_open = 1;
 
        /* Call the function that processes the output. */
        if (process_output())
            exit(1);

        /* Tell user how many rows were processed. */
        rows_processed();

    }   /* end of for(;;) statement-processing loop */

 
    /* Close the cursor. */
    if (cursor_open)
      EXEC SQL CLOSE C;

    /* Deallocate the descriptors */
    EXEC SQL DEALLOCATE DESCRIPTOR GLOBAL :indesc;
    EXEC SQL DEALLOCATE DESCRIPTOR GLOBAL :outdesc;

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL COMMIT WORK RELEASE;
    puts(&#34;\nHave a good day!\n&#34;);

    EXEC SQL WHENEVER SQLERROR DO sql_error();
    return;
}



int get_dyn_statement()
{
    char *cp, linebuf[256];
    int iter, plsql;

    for (plsql = 0, iter = 1; ;)
    {
        if (iter == 1)
        {
            printf(&#34;\nSQL&gt; &#34;);
            dyn_statement[0] = &#39;\0&#39;;
            select_found = 0;
        }
        
        fgets(linebuf, sizeof linebuf, stdin);

        cp = strrchr(linebuf, &#39;\n&#39;);
        if (cp &amp;&amp; cp != linebuf)
            *cp = &#39; &#39;;
        else if (cp == linebuf)
            continue;

        if ((strncmp(linebuf, &#34;SELECT&#34;, 6) == 0) ||
            (strncmp(linebuf, &#34;select&#34;, 6) == 0))
        {
            select_found=1;;
        }

        if ((strncmp(linebuf, &#34;EXIT&#34;, 4) == 0) ||
            (strncmp(linebuf, &#34;exit&#34;, 4) == 0))
        {
            return -1;
        }

        else if (linebuf[0] == &#39;?&#39; ||
            (strncmp(linebuf, &#34;HELP&#34;, 4) == 0) ||
            (strncmp(linebuf, &#34;help&#34;, 4) == 0))
        {
            help();
            iter = 1;
            continue;
        }

        if (strstr(linebuf, &#34;BEGIN&#34;) ||
            (strstr(linebuf, &#34;begin&#34;)))
        {
            plsql = 1;
        }

        strcat(dyn_statement, linebuf);

        if ((plsql &amp;&amp; (cp = strrchr(dyn_statement, &#39;/&#39;))) ||
            (!plsql &amp;&amp; (cp = strrchr(dyn_statement, &#39;;&#39;))))
        {
            *cp = &#39;\0&#39;;
            break;
        }
        else
        {
            iter++;
            printf(&#34;%3d  &#34;, iter);
        }
    }
    return 0;
}


int process_input()
{
    int i, j;
    char name[31];
    int  input_count, input_len= MAX_VAR_LEN;
    int  occurs, string_type = 5;
    int  string_len;
    char arr_size[3];

    EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR GLOBAL :indesc;
    EXEC SQL GET DESCRIPTOR GLOBAL :indesc :input_count = COUNT; 

    if (input_count &gt; 0 &amp;&amp; !select_found )
       {     /* get input array size */
          printf (&#34;\nEnter value for input array size (max is %d) :  &#34;, 
                           max_array_size);
        fgets(arr_size, 4, stdin);
        in_array_size = atoi(arr_size); 
       }
    else
       { 
         in_array_size = 1;
       }
    for (i=0; i &lt; input_count; i++)
    {
        occurs = i +1;                       /* occurence is 1 based */
        EXEC SQL GET DESCRIPTOR GLOBAL :indesc 
                 VALUE :occurs :name = NAME;

        for (j=0; j &lt; in_array_size; j++)
        {
          if (in_array_size == 1)
            printf (&#34;\nEnter value for input variable %*.*s:  &#34;,10,31, name);
          else 
            printf (&#34;\nEnter %d%s value for input variable %*.*s:  &#34;,
               j +1, ((j==0) ?  &#34;st&#34; :  (j==1) ? &#34;nd&#34; : (j==2) ? &#34;rd&#34; :&#34;th&#34;),
                      10,31, name);
          fgets(input[i][j], sizeof(input[i][j]), stdin);
          string_len = strlen(input[i][j]);
          input[i][j][string_len - 1 ] = &#39;\0&#39;;   /* change \n to \0 */
        }
        EXEC SQL SET DESCRIPTOR GLOBAL :indesc
                 VALUE :occurs TYPE = :string_type, LENGTH = :input_len;
        EXEC SQL FOR :in_array_size
                 SET DESCRIPTOR GLOBAL :indesc
                     VALUE :occurs  REF DATA = :input[i];
    }

    return(sqlca.sqlcode);
}


int process_output()
{
   int i, j;
   int output_count, occurs;
   int type, output_len= MAX_VAR_LEN;
   char name[MAX_OCCURENCES][MAX_NAME_LEN];
   int rows_this_fetch=0, cumulative_rows=0;
   char arr_size[3];
   if (!select_found)
      return(0);   
   EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR GLOBAL :outdesc;
   
   EXEC SQL GET DESCRIPTOR GLOBAL :outdesc :output_count = COUNT;
  
   if (output_count &gt; 0 )
      {
        printf (&#34;\nEnter value for output array size (max is %d) :  &#34;, 
                       max_array_size);
        fgets(arr_size, 4, stdin);
        out_array_size = atoi(arr_size); 
      }
   if (out_array_size &lt; 1)    /* must have at least one */
       out_array_size = 1;

   printf (&#34;\n&#34;);
   
   for (i = 0; i &lt; output_count; i++)
   {
      occurs = i + 1;
      EXEC SQL GET DESCRIPTOR GLOBAL :outdesc VALUE :occurs
               :type = TYPE, :name[i] = NAME;
      occurs = i + 1;                         /* occurence is one based */
      type = 5;  /* force all data to be null terminated character */
      EXEC SQL SET DESCRIPTOR GLOBAL :outdesc VALUE :occurs 
               TYPE = :type, LENGTH = :output_len;
   
      iptr = (short *)&amp;outindi[i]; /* no mult-dimension non-char host vars */
      EXEC SQL FOR :out_array_size
               SET DESCRIPTOR GLOBAL :outdesc VALUE :occurs 
               REF DATA = :output[i], REF INDICATOR = :iptr;
   }   
   
   
   
   EXEC SQL WHENEVER NOT FOUND GOTO end_select_loop;
   
   /* print the column headings */
   for (j=0; j &lt; out_array_size; j++)
      for (i=0; i &lt; output_count; i++)
         printf(&#34;%-*.*s &#34;, 9,9, name[i]);
   printf(&#34;\n&#34;);
   
   /* FETCH each row selected and print the column values. */
   for (;;)
   {
      EXEC SQL FOR :out_array_size 
              FETCH C INTO DESCRIPTOR GLOBAL :outdesc;
      rows_this_fetch = sqlca.sqlerrd[2] - cumulative_rows;
      cumulative_rows = sqlca.sqlerrd[2];
      if (rows_this_fetch)
      for (j=0; j &lt; out_array_size &amp;&amp; j &lt; rows_this_fetch; j++)
      {           /* output by columns using simplified formatting */
         for (i=0; i &lt; output_count; i++)
           {                              
                if (outindi[i][j] == -1)       
                   printf(&#34;%-*.*s &#34;, 9, 9, &#34;NULL&#34;);
               else
                  printf(&#34;%-*.*s &#34;, 9, 9, output[i][j]);  /* simplified */
                              /* output formatting may cause truncation */
                              /* but columns will line up */
           } 
      }
       printf (&#34;\n&#34;);
   }

end_select_loop:
   /* print any unprinted rows */
   rows_this_fetch = sqlca.sqlerrd[2] - cumulative_rows;
   cumulative_rows = sqlca.sqlerrd[2];
   if (rows_this_fetch)
     for (j=0; j &lt; out_array_size &amp;&amp; j &lt; rows_this_fetch; j++)
       {           /* output by columns using simplified formatting */
         for (i=0; i &lt; output_count; i++)
           {                              
              if (outindi[i][j] == -1)       
                   printf(&#34;%-*.*s &#34;,9, 9, &#34;NULL&#34;);
               else
                  printf(&#34;%-*.*s &#34;, 9, 9, output[i][j]); 
            } 
        }
   return(0);
}

void rows_processed()
{  
   int i;
   for (i = 0; i &lt; 8; i++)
     {
       if (strncmp(dyn_statement, dml_commands[i], 6) == 0)
         {
            printf(&#34;\n\n%d row%c processed.\n&#34;, sqlca.sqlerrd[2],
                       sqlca.sqlerrd[2] == 1 ? &#39; &#39; : &#39;s&#39;);
            break;
         }
     }
   return;
}


void help()
{
    puts(&#34;\n\nEnter a SQL statement or a PL/SQL block at the SQL&gt; prompt.&#34;);
    puts(&#34;Statements can be continued over several lines, except&#34;);
    puts(&#34;within string literals.&#34;);
    puts(&#34;Terminate a SQL statement with a semicolon.&#34;);
    puts(&#34;Terminate a PL/SQL block (which can contain embedded semicolons)&#34;);
    puts(&#34;with a slash (/).&#34;);
    puts(&#34;Typing \&#34;exit\&#34; (no semicolon needed) exits the program.&#34;);
    puts(&#34;You typed \&#34;?\&#34; or \&#34;help\&#34; to get this message.\n\n&#34;);
}


void sql_error()
{
    /* ORACLE error handler */
    printf (&#34;\n\n%.70s\n&#34;,sqlca.sqlerrm.sqlerrmc);
    if (parse_flag)
        printf
        (&#34;Parse error at character offset %d in SQL statement.\n&#34;,
           sqlca.sqlerrd[4]);

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK;
    longjmp(jmp_continue, 1);
}


int oracle_connect()
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR  username[128];
        VARCHAR  password[32];
    EXEC SQL END DECLARE SECTION;

    printf(&#34;\nusername: &#34;);
    fgets((char *) username.arr, sizeof username.arr, stdin);
    username.arr[strlen((char *) username.arr)-1] = &#39;\0&#39;;
    username.len = (unsigned short)strlen((char *) username.arr);

    printf(&#34;password: &#34;);
    fgets((char *) password.arr, sizeof password.arr, stdin);
    password.arr[strlen((char *) password.arr) - 1] = &#39;\0&#39;;
    password.len = (unsigned short)strlen((char *) password.arr);


    EXEC SQL WHENEVER SQLERROR GOTO connect_error;

    EXEC SQL CONNECT :username IDENTIFIED BY :password;

    printf(&#34;\nConnected to ORACLE as user %s.\n&#34;, username.arr);

    return 0;

connect_error:
    fprintf(stderr, &#34;Cannot connect to ORACLE as user %s\n&#34;, username.arr);
    return -1;
}

</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_13dyn.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_15ody.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>