<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78011"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Multithreaded%20Applications"></a><title>Multithreaded Applications</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:42Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_10opt.htm" title="Previous" type="text/html"/>
<link rel="Next" href="partpage2.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">16/35</span> <!-- End Header -->
<div id="LNPCC3942" class="chapter"><a id="g1021123"></a> <a id="i998992"></a>
<h1 class="chapter"><span class="secnum">11</span> Multithreaded Applications</h1>
<p>If your development platform does not support threads, ignore this chapter. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i1000132">What are Threads?</a></p>
</li>
<li>
<p><a href="#i997959">Runtime Contexts in Pro*C/C++</a></p>
</li>
<li>
<p><a href="#i998614">Runtime Context Usage Models</a></p>
</li>
<li>
<p><a href="#i998619">User Interface Features for Multithreaded Applications</a></p>
</li>
<li>
<p><a href="#i998635">Multithreaded Example</a></p>
</li>
<li>
<p><a href="#i1000292">Connection Pooling</a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When using XA with the Pro*C/C++ Precompiler, you must use multithreading provided by XA. Use of multithreading provided by Pro*C/C++ using the statement EXEC SQL ENABLE THREADS will result in an error.</div>
</li>
</ul>
<a id="i1000132"></a>
<div id="LNPCC3943" class="sect1">
<h2 class="sect1">What are Threads?</h2>
<p>Multithreaded applications have multiple threads executing in a shared address space. Threads are &#34;lightweight&#34; subprocesses that execute within a process. They share code and data segments, but have their own program counters, machine registers and stack. Global and static variables are common to all threads, and a mutual exclusivity mechanism is often required to manage access to these variables from multiple threads within an application. Mutexes are the synchronization mechanism to insure that data integrity is preserved.</p>
<p>For further discussion of mutexes, see texts on multithreading. For more detailed information about multithreaded applications, see the documentation of your threads functions.</p>
<p>Pro*C/C++ supports development of multithreaded Oracle Server applications (on platforms that support multithreaded applications) using the following:</p>
<ul>
<li>
<p>A command-line option to generate thread-safe code</p>
</li>
<li>
<p>Embedded SQL statements and directives to support multithreading</p>
</li>
<li>
<p>Thread-safe SQLLIB and other client-side Oracle libraries</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
While your platform may support a particular thread package, see your platform-specific Oracle documentation to determine whether Oracle supports it.</div>
</li>
</ul>
<p>The chapter&#39;s topics discuss how to use the preceding features to develop multithreaded Pro*C/C++ applications:</p>
<ul>
<li>
<p>Runtime contexts for multithreaded applications</p>
</li>
<li>
<p>Two models for using runtime contexts</p>
</li>
<li>
<p>User-interface features for multithreaded applications</p>
</li>
<li>
<p>Programming considerations for writing multithreaded applications with Pro*C/C++</p>
</li>
<li>
<p>An example multithreaded Pro*C/C++ application</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i997959"></a>
<div id="LNPCC3944" class="sect1">
<h2 class="sect1">Runtime Contexts in Pro*C/C++</h2>
<p>To loosely couple a thread and a connection, Pro*C/C++ introduces the notion of a runtime context. The runtime context includes the following resources and their current states:</p>
<ul>
<li>
<p>Zero or more connections to one or more Oracle Servers</p>
</li>
<li>
<p>Zero or more cursors used for the server connections</p>
</li>
<li>
<p>Inline options, such as MODE, HOLD_CURSOR, RELEASE_CURSOR, and SELECT_ERROR</p>
</li>
</ul>
<p>Rather than simply supporting a loose coupling between threads and connections, Pro*C/C++ provides the ability to loosely couple threads with runtime contexts. Pro*C/C++ allows your application to define a handle to a runtime context, and pass that handle from one thread to another.</p>
<p>For example, an interactive application spawns a thread, T1, to execute a query and return the first 10 rows to the application. T1 then terminates. After obtaining the necessary user input, another thread, T2, is spawned (or an existing thread is used) and the runtime context for T1 is passed to T2 so it can fetch the next 10 rows by processing the same cursor. See <a href="#i999536">Figure 11-1, &#34;Loosely Coupling Connections and Threads&#34;</a>.</p>
<div id="LNPCC3945" class="figure">
<p class="titleinfigure"><a id="i999536"></a>Figure 11-1 Loosely Coupling Connections and Threads</p>
<img width="605" height="524" src="img/lnpcc021.gif" alt="Description of Figure 11-1 follows"/><br/>
<a id="sthref1580" href="img_text/lnpcc021.htm">Description of &#34;Figure 11-1 Loosely Coupling Connections and Threads&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect1" -->
<a id="i998614"></a>
<div id="LNPCC3946" class="sect1">
<h2 class="sect1">Runtime Context Usage Models</h2>
<p>Two possible models for using runtime contexts in multithreaded Pro*C/C++ applications are shown here:</p>
<ul>
<li>
<p>Multiple threads sharing a single runtime context</p>
</li>
<li>
<p>Multiple threads using separate runtime contexts</p>
</li>
</ul>
<p>Regardless of the model you use for runtime contexts, you <span class="italic">cannot</span> share a runtime context between multiple threads <span class="italic">at the same time</span>. If two or more threads attempt to use the same runtime context simultaneously, a runtime error occurs.</p>
<div id="LNPCC3947" class="sect2"><a id="sthref1581"></a>
<h3 class="sect2">Multiple Threads Sharing a Single Runtime Context</h3>
<p><a href="#i997987">Figure 11-2</a> shows an application running in a multithreaded environment. The various threads share a single runtime context to process one or more SQL statements. Again, runtime contexts cannot be shared by multiple threads at the same time. The mutexes in <a href="#i997987">Figure 11-2</a> show how to prevent concurrent usage.</p>
<div id="LNPCC3948" class="figure">
<p class="titleinfigure"><a id="i997987"></a>Figure 11-2 Context Sharing Among Threads</p>
<img width="605" height="410" src="img/lnpcc023.gif" alt="Description of Figure 11-2 follows"/><br/>
<a id="sthref1582" href="img_text/lnpcc023.htm">Description of &#34;Figure 11-2 Context Sharing Among Threads&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCC3949" class="sect2"><a id="sthref1583"></a>
<h3 class="sect2">Multiple Threads Sharing Multiple Runtime Contexts</h3>
<p><a href="#i997998">Figure 11-3</a> shows an application that executes multiple threads using multiple runtime contexts. In this situation, the application does not require mutexes, because each thread has a dedicated runtime context.</p>
<div id="LNPCC3950" class="figure">
<p class="titleinfigure"><a id="i997998"></a>Figure 11-3 No Context Sharing Among Threads</p>
<img width="605" height="506" src="img/lnpcc022.gif" alt="Description of Figure 11-3 follows"/><br/>
<a id="sthref1584" href="img_text/lnpcc022.htm">Description of &#34;Figure 11-3 No Context Sharing Among Threads&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i998619"></a>
<div id="LNPCC3951" class="sect1">
<h2 class="sect1">User Interface Features for Multithreaded Applications</h2>
<p>The Pro*C/C++ Precompiler provides the following user-interface features to support multithreaded applications:</p>
<ul>
<li>
<p>Command-line option, THREADS=YES|NO</p>
</li>
<li>
<p>Embedded SQL statements and directives</p>
</li>
<li>
<p>Thread-safe SQLLIB public functions</p>
</li>
</ul>
<div id="LNPCC3952" class="sect2"><a id="sthref1585"></a>
<h3 class="sect2">THREADS Option<a id="sthref1586"></a><a id="sthref1587"></a></h3>
<p>With THREADS=YES specified on the command line, the Pro*C/C++ Precompiler ensures that the generated code is thread-safe, given that you follow the guidelines. With THREADS=YES specified, Pro*C/C++ verifies that all SQL statements execute within the scope of a user-defined runtime context. If your program does not meet this requirement, a precompiler error is returned.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i999517">&#34;Programming Considerations&#34;</a> for guidelines regarding the THREADS option</div>
</div>
<!-- class="sect2" -->
<a id="i998018"></a>
<div id="LNPCC3953" class="sect2">
<h3 class="sect2"><a id="sthref1588"></a>Embedded SQL Statements and Directives</h3>
<p>The following embedded SQL statements and directives support the definition and usage of runtime contexts and threads:</p>
<ul>
<li>
<p>EXEC SQL ENABLE THREADS;</p>
</li>
<li>
<p>EXEC SQL CONTEXT ALLOCATE :<span class="italic">context_var</span>;</p>
</li>
<li>
<p>EXEC SQL CONTEXT USE { :<span class="italic">context_var</span> | DEFAULT};</p>
</li>
<li>
<p>EXEC SQL CONTEXT FREE :<span class="italic">context_var</span>;</p>
</li>
</ul>
<p>For these EXEC SQL statements, <span class="italic">context_var</span> is the handle to the runtime context and must be declared of type <span class="bold">sql_context</span> as follows:</p>
<pre>sql_context &lt;context_variable&gt;;
</pre>
<p>Using DEFAULT means that the default (global) runtime context will be used in all embedded SQL statements that lexically follow until another CONTEXT USE statement overrides it.</p>
<a id="i998988"></a>
<div id="LNPCC3954" class="sect3">
<h4 class="sect3">EXEC SQL ENABLE THREADS<a id="sthref1589"></a><a id="sthref1590"></a><a id="sthref1591"></a><a id="sthref1592"></a></h4>
<p>This executable SQL statement initializes a process that supports multiple threads. This must be the first executable SQL statement in your multithreaded application.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When using XA with the Pro*C/C++ Precompiler, you must use multithreading provided by XA. Use of multithreading provided by Pro*C using the statement EXEC SQL ENABLE THREADS will result in an error.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_afemb.htm#CHEBHDCJ">&#34;ENABLE THREADS (Executable Embedded SQL Extension)&#34;</a></div>
</div>
<!-- class="sect3" -->
<div id="LNPCC3955" class="sect3"><a id="sthref1593"></a>
<h4 class="sect3">EXEC SQL CONTEXT ALLOCATE<a id="sthref1594"></a><a id="sthref1595"></a><a id="sthref1596"></a><a id="sthref1597"></a></h4>
<p>This executable SQL statement allocates and initializes memory for the specified runtime context; the runtime-context variable must be declared of type sql_context.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_afemb.htm#CHEFHAGC">&#34;CONTEXT ALLOCATE (Executable Embedded SQL Extension)&#34;</a></div>
</div>
<!-- class="sect3" -->
<div id="LNPCC3956" class="sect3"><a id="sthref1598"></a>
<h4 class="sect3">EXEC SQL CONTEXT USE</h4>
<p><a id="sthref1599"></a><a id="sthref1600"></a><a id="sthref1601"></a><a id="sthref1602"></a><a id="sthref1603"></a>This directive instructs the precompiler to use the specified runtime context for subsequent executable SQL statements. The runtime context specified must be previously allocated using an EXEC SQL CONTEXT ALLOCATE statement.</p>
<p>The EXEC SQL CONTEXT USE directive works similarly to the EXEC SQL WHENEVER directive in that it affects all executable SQL statements which positionally follow it in a given source file without regard to standard C scope rules. In the following example, the UPDATE statement in <code>function2()</code> uses the global runtime context, <span class="italic">ctx1</span>:</p>
<pre>sql_context ctx1;            /* declare global context ctx1     */

function1()
{
   sql_context :ctx1;         /* declare local context ctx1      */
   EXEC SQL CONTEXT ALLOCATE :ctx1;
   EXEC SQL CONTEXT USE :ctx1; 
   EXEC SQL INSERT INTO ...  /* local ctx1 used for this stmt   */
   ...
}

function2() 
{
   EXEC SQL UPDATE ...       /* global ctx1 used for this stmt */
}
</pre>
<p>To use the global context after using a local context, add this code to function1():</p>
<pre>function1()
{
   sql_context :ctx1;         /* declare local context ctx1      */
   EXEC SQL CONTEXT ALLOCATE :ctx1;
   EXEC SQL CONTEXT USE :ctx1; 
   EXEC SQL INSERT INTO ...  /* local ctx1 used for this stmt   */
   EXEC SQL CONTEXT USE DEFAULT;
   EXEC SQL INSERT INTO ... /* global ctx1 used for this stmt   */
   ...
}
</pre>
<p>In the next example, there is no global runtime context. The precompiler refers to the <span class="italic">ctx1</span> runtime context in the generated code for the UPDATE statement. However, there is no context variable in scope for <code>function2()</code>, so errors are generated at compile time.</p>
<pre>function1() 
{
   sql_context ctx1;         /* local context variable declared */
   EXEC SQL CONTEXT ALLOCATE :ctx1;
   EXEC SQL CONTEXT USE :ctx1; 
   EXEC SQL INSERT INTO ...     /* ctx1 used for this statement */
   ...
} 
function2() 
{
   EXEC SQL UPDATE ...   /* Error! No context variable in scope */
}
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_afemb.htm#CHEDGBJB">&#34;CONTEXT OBJECT OPTION GET (Executable Embedded SQL Extension)&#34;</a></p>
</li>
<li>
<p><a href="pc_afemb.htm#CHEFHAGC">&#34;CONTEXT ALLOCATE (Executable Embedded SQL Extension)&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="LNPCC3957" class="sect3"><a id="sthref1604"></a>
<h4 class="sect3">EXEC SQL CONTEXT FREE<a id="sthref1605"></a><a id="sthref1606"></a><a id="sthref1607"></a><a id="sthref1608"></a></h4>
<p>This executable SQL statement frees the memory associated with the specified runtime context and places a null pointer in the host program variable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_afemb.htm#CHEIEGBJ">&#34;CONTEXT FREE (Executable Embedded SQL Extension)&#34;</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3958" class="sect2"><a id="sthref1609"></a>
<h3 class="sect2">CONTEXT USE Examples</h3>
<p>The following code fragments show how to use embedded SQL statements and precompiler directives for two typical programming models; they use <span class="italic">thread_create()</span> to create threads.</p>
<p>The first example showing multiple threads using multiple runtime contexts:</p>
<pre>main() 
{
   sql_context ctx1,ctx2;           /* declare runtime contexts */
   EXEC SQL ENABLE THREADS;
   EXEC SQL CONTEXT ALLOCATE :ctx1;
   EXEC SQL CONTEXT ALLOCATE :ctx2;
   ...
/* spawn thread, execute function1 (in the thread) passing ctx1 */
   thread_create(..., function1, ctx1);  
/* spawn thread, execute function2 (in the thread) passing ctx2 */
   thread_create(..., function2, ctx2);
   ...
   EXEC SQL CONTEXT FREE :ctx1;
   EXEC SQL CONTEXT FREE :ctx2;
   ...
}

void function1(sql_context ctx)
{
   EXEC SQL CONTEXT USE :ctx;
/* execute executable SQL statements on runtime context ctx1!!! */
   ...
}
 
void function2(sql_context ctx) 
{
   EXEC SQL CONTEXT USE :ctx;
/* execute executable SQL statements on runtime context ctx2!!! */
   ...
}
</pre>
<p>The next example shows how to use multiple threads that share a common runtime context. Because the SQL statements executed in <code>function1()</code> and <code>function2()</code> potentially execute at the same time, you must place mutexes around every <span class="italic">executable</span> EXEC SQL statement to ensure serial, therefore safe, manipulation of the data.</p>
<pre>main() 
{
   sql_context ctx;                  /* declare runtime context */
   EXEC SQL CONTEXT ALLOCATE :ctx;
   ...
/* spawn thread, execute function1 (in the thread) passing ctx  */
   thread_create(..., function1, ctx);  
/* spawn thread, execute function2 (in the thread) passing ctx  */
   thread_create(..., function2, ctx);
   ...
} 
 
void function1(sql_context ctx)
{
   EXEC SQL CONTEXT USE :ctx;
/* Execute SQL statements on runtime context ctx.               */
   ...
}

void function2(sql_context ctx) 
{
   EXEC SQL CONTEXT USE :ctx;
/* Execute SQL statements on runtime context ctx.               */
   ...
}
</pre></div>
<!-- class="sect2" -->
<a id="i999517"></a>
<div id="LNPCC3959" class="sect2">
<h3 class="sect2">Programming Considerations</h3>
<p>While Oracle ensures that the SQLLIB code is thread-safe, you are responsible for ensuring that your Pro*C/C++ source code is designed to work properly with threads; for example, carefully consider your use of static and global variables.</p>
<p>In addition, multithreaded applications require design decisions regarding the following:</p>
<ul>
<li>
<p>Declaring the SQLCA as a thread-safe struct, typically an auto variable and one for each runtime context</p>
</li>
<li>
<p>Declaring the SQLDA as a thread-safe struct, like the SQLCA, typically an auto variable and one for each runtime context</p>
</li>
<li>
<p>Declaring host variables in a thread-safe fashion, in other words, carefully consider your use of static and global host variables.</p>
</li>
<li>
<p>Avoiding simultaneous use of a runtime context in multiple threads</p>
</li>
<li>
<p>Whether or not to use default database connections or to explicitly define them using the AT clause</p>
</li>
</ul>
<p>Also, no more than one executable embedded SQL statement, for example, EXEC SQL UPDATE, may be outstanding on a runtime context at a given time.</p>
<p>Existing requirements for precompiled applications also apply. For example, all references to a given cursor must appear in the same source file.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i998635"></a>
<div id="LNPCC3960" class="sect1">
<h2 class="sect1">Multithreaded Example<a id="sthref1610"></a></h2>
<p>The following program is one approach to writing a multithreaded embedded SQL application. The program creates as many sessions as there are threads. Each thread executes zero or more transactions, that are specified in a transient structure called &#34;records.&#34;</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This program was developed specifically for a Sun workstation running Solaris. Either the DCE or Solaris threads package is usable with this program. See your platform-specific documentation for the availability of threads packages.</div>
<pre>/*
 * Name:        Thread_example1.pc
 *
 * Description: This program illustrates how to use threading in
 *      conjunction with precompilers. The program creates as many
 *      sessions as there are threads. Each thread executes zero or
 *      more transactions, that are specified in a transient
 *      structure called &#39;records&#39;.
 * Requirements:
 *      The program requires a table &#39;ACCOUNTS&#39; to be in the schema
 *      scott/tiger. The description of ACCOUNTS is:
 *  SQL&gt; desc accounts
 *   Name                            Null?    Type
 *  ------------------------------- -------  ------
 *  ACCOUNT                                  NUMBER(36)
 *  BALANCE                                  NUMBER(36,2)
 *
 *  For proper execution, the table should be filled with the accounts
 *      10001 to 10008.
 *
 *
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sqlca.h&gt;

#define      _EXC_OS_        _EXC__UNIX
#define      _CMA_OS_        _CMA__UNIX

#ifdef DCE_THREADS
  #include &lt;pthread.h&gt;
#else
  #include &lt;thread.h&gt;
#endif

/* Function prototypes */
void   err_report();
#ifdef DCE_THREADS
void   do_transaction();
#else
void   *do_transaction();
#endif
void   get_transaction();
void   logon();
void   logoff();

#define CONNINFO &#34;scott/tiger&#34;
#define THREADS  3 

struct parameters 
{ sql_context * ctx;
  int thread_id;
};
typedef struct parameters parameters;

struct record_log
{  char action;
   unsigned int from_account;
   unsigned int to_account;
   float  amount;
};
typedef struct record_log record_log;

record_log records[]= { { &#39;M&#39;, 10001, 10002, 12.50 },
                        { &#39;M&#39;, 10001, 10003, 25.00 },
                        { &#39;M&#39;, 10001, 10003, 123.00 },
                        { &#39;M&#39;, 10001, 10003, 125.00 },
                        { &#39;M&#39;, 10002, 10006, 12.23 },
                        { &#39;M&#39;, 10007, 10008, 225.23 },
                        { &#39;M&#39;, 10002, 10008, 0.70 },
                        { &#39;M&#39;, 10001, 10003, 11.30 },
                        { &#39;M&#39;, 10003, 10002, 47.50 },
                        { &#39;M&#39;, 10002, 10006, 125.00 },
                        { &#39;M&#39;, 10007, 10008, 225.00 },
                        { &#39;M&#39;, 10002, 10008, 0.70 },
                        { &#39;M&#39;, 10001, 10003, 11.00 },
                        { &#39;M&#39;, 10003, 10002, 47.50 },
                        { &#39;M&#39;, 10002, 10006, 125.00 },
                        { &#39;M&#39;, 10007, 10008, 225.00 },
                        { &#39;M&#39;, 10002, 10008, 0.70 },
                        { &#39;M&#39;, 10001, 10003, 11.00 },
                        { &#39;M&#39;, 10003, 10002, 47.50 },
                        { &#39;M&#39;, 10008, 10001, 1034.54}};

static unsigned int trx_nr=0;
#ifdef DCE_THREADS
pthread_mutex_t mutex;
#else
mutex_t mutex;
#endif



/*********************************************************************
 *  Main
 ********************************************************************/
main()
{
  sql_context ctx[THREADS];
#ifdef DCE_THREADS
  pthread_t thread_id[THREADS];
  pthread_addr_t status;
#else
  thread_t thread_id[THREADS];
  int status;
#endif
  parameters params[THREADS];
  int i;
  
  EXEC SQL ENABLE THREADS;

  EXEC SQL WHENEVER SQLERROR DO err_report(sqlca);

  /* Create THREADS sessions by connecting THREADS times */
  for(i=0;i&lt;THREADS;i++)
  {
    printf(&#34;Start Session %d....&#34;,i);
    EXEC SQL CONTEXT ALLOCATE :ctx[i];
    logon(ctx[i],CONNINFO);
  }

  /*Create mutex for transaction retrieval */
#ifdef DCE_THREADS
  if (pthread_mutex_init(&amp;mutex,pthread_mutexattr_default))
#else
  if (mutex_init(&amp;mutex, USYNC_THREAD, NULL))
#endif
  {
     printf(&#34;Can&#39;t initialize mutex\n&#34;);
     exit(1);
  }

  /*Spawn threads*/
  for(i=0;i&lt;THREADS;i++)
  {
    params[i].ctx=ctx[i];
    params[i].thread_id=i;

    printf(&#34;Thread %d... &#34;,i);
#ifdef DCE_THREADS
    if (pthread_create(&amp;thread_id[i],pthread_attr_default,
        (pthread_startroutine_t)do_transaction,
        (pthread_addr_t) &amp;params[i]))
#else
    if (status = thr_create
    (NULL, 0, do_transaction, &amp;params[i], 0, &amp;thread_id[i]))
#endif
      printf(&#34;Cant create thread %d\n&#34;,i);
    else
      printf(&#34;Created\n&#34;);
  }


  /* Logoff sessions....*/
  for(i=0;i&lt;THREADS;i++)
  {
     /*wait for thread to end */
     printf(&#34;Thread %d ....&#34;,i);
#ifdef DCE_THREADS
     if (pthread_join(thread_id[i],&amp;status))
       printf(&#34;Error when waiting for thread % to terminate\n&#34;, i);
     else
      printf(&#34;stopped\n&#34;);

     printf(&#34;Detach thread...&#34;);
     if (pthread_detach(&amp;thread_id[i]))
       printf(&#34;Error detaching thread! \n&#34;);
     else
       printf(&#34;Detached!\n&#34;);
#else
     if (thr_join(thread_id[i], NULL, NULL))
       printf(&#34;Error waiting for thread to terminate\n&#34;);
#endif
     printf(&#34;Stop Session %d....&#34;,i);
     logoff(ctx[i]);
     EXEC SQL CONTEXT FREE :ctx[i];
  }


  /*Destroys mutex*/
#ifdef DCE_THREADS
  if (pthread_mutex_destroy(&amp;mutex))
#else
  if (mutex_destroy(&amp;mutex))
#endif
  {
    printf(&#34;Can&#39;t destroy mutex\n&#34;);
    exit(1);
  }
}

/*********************************************************************
 * Function: do_transaction
 *
 * Description:  This functions executes one transaction out of the 
 *               records array. The records array is &#39;managed&#39; by
 *               the get_transaction function.
 *
 *
 ********************************************************************/
#ifdef DCE_THREADS
void do_transaction(params)
#else
void *do_transaction(params)
#endif
parameters *params;
{
  struct sqlca sqlca;
  record_log *trx;
  sql_context ctx=params-&gt;ctx;

  /* Done all transactions ? */
  while (trx_nr &lt; (sizeof(records)/sizeof(record_log)))
  {
    get_transaction(&amp;trx);

    EXEC SQL WHENEVER SQLERROR DO err_report(sqlca);
    EXEC SQL CONTEXT USE :ctx;

    printf(&#34;Thread %d executing transaction\n&#34;,params-&gt;thread_id);
    switch(trx-&gt;action)
    {
      case &#39;M&#39;:  EXEC SQL UPDATE ACCOUNTS
                          SET    BALANCE=BALANCE+:trx-&gt;amount
                          WHERE  ACCOUNT=:trx-&gt;to_account;
                 EXEC SQL UPDATE ACCOUNTS
                          SET    BALANCE=BALANCE-:trx-&gt;amount
                          WHERE  ACCOUNT=:trx-&gt;from_account;
                 break;
       default:  break;
    }
    EXEC SQL COMMIT;
  }
}


/*****************************************************************
 * Function: err_report
 *
 * Description: This routine prints out the most recent error
 *
 ****************************************************************/
void      err_report(sqlca)
struct sqlca sqlca;
{
  if (sqlca.sqlcode &lt; 0)
   printf(&#34;\n%.*s\n\n&#34;,sqlca.sqlerrm.sqlerrml,sqlca.sqlerrm.sqlerrmc);
  exit(1);
}

/*****************************************************************
 * Function: logon
 *
 * Description: Logs on to the database as USERNAME/PASSWORD
 *
 *****************************************************************/
void      logon(ctx,connect_info)
sql_context ctx;
char * connect_info;
{
    EXEC SQL WHENEVER SQLERROR DO err_report(sqlca);
    EXEC SQL CONTEXT USE :ctx;
    EXEC SQL CONNECT :connect_info;
    printf(&#34;Connected!\n&#34;);

}

/******************************************************************
 * Function: logoff
 *
 * Description: This routine logs off the database
 *
 ******************************************************************/
void      logoff(ctx)
sql_context ctx;
{
    EXEC SQL WHENEVER SQLERROR DO err_report(sqlca);
    EXEC SQL CONTEXT USE :ctx;
    EXEC SQL COMMIT WORK RELEASE;
    printf(&#34;Logged off!\n&#34;);
}


/******************************************************************
 * Function: get_transaction
 *
 * Description: This routine returns the next transaction to process
 *
 ******************************************************************/
void get_transaction(trx)
record_log ** trx;
{
#ifdef DCE_THREADS
  if (pthread_mutex_lock(&amp;mutex))
#else
  if (mutex_lock(&amp;mutex))
#endif
    printf(&#34;Can&#39;t lock mutex\n&#34;);

  *trx=&amp;records[trx_nr];

  trx_nr++;

#ifdef DCE_THREADS
  if (pthread_mutex_unlock(&amp;mutex))
#else
  if (mutex_unlock(&amp;mutex))
#endif
    printf(&#34;Can&#39;t unlock mutex\n&#34;);
}
</pre></div>
<!-- class="sect1" -->
<a id="i1000292"></a>
<div id="LNPCC3961" class="sect1">
<h2 class="sect1">Connection Pooling<a id="sthref1611"></a></h2>
<p>A connection pool is a group of physical connections to a database that can be re-used by several connections. The objective of the connection pooling feature is to improve performance, and reduce resource use by avoiding usage of dedicated connections by each connection.</p>
<p><a href="#i1005251">Figure 11-4</a> illustrates functionality of the connection pooling feature. In this example, four threads of the application are interacting with the database using the connection pool. The connection pool has two physical connections. The connection pool handle is used by four threads using different runtime contexts.</p>
<div id="LNPCC3962" class="figure">
<p class="titleinfigure"><a id="i1005251"></a>Figure 11-4 Connection Pooling</p>
<img width="483" height="257" src="img/connection_pooling.gif" alt="Connection Pooling"/><br/></div>
<!-- class="figure" -->
<pre>thread1() 
{ 
EXEC SQL CONTEXT ALLOCATE :ctx1; 
EXEC SQL CONTEXT USE:ctxl;
EXEC SQL CONNECT :uid  AT :TC1 USING :db_string; 
... 

} 

thread2() 
{ 
EXEC SQL CONTEXT ALLOCATE :ctx2; 
EXEC SQL CONNECT :uid  AT :TC2 USING :db_string; 
... 

} 

thread3() 
{ 
EXEC SQL CONTEXT ALLOCATE :ctx3; 
EXEC SQL CONNECT :uid  AT :TC3 USING :db_string; 
EXEC SQL AT :TC3 SELECT count(*) into :count FROM emp; 
... 

} 

thread4() 
{ 
EXEC SQL CONTEXT ALLOCATE :ctx4; 
EXEC SQL CONNECT :uid  AT :TC4 USING :db_string; 
... 

}
</pre>
<p>In this example, four named connections TC1, TC2, TC3, and TC4 are virtual connections created by threads T1, T2, T3, and T4 respectively. Named connections TC1, TC2, TC3, and TC4 from different runtime contexts share the same connection pool, and share physical database connections available in the connection pool. Two physical connections, C1 and C2, serve four named connections and connect to the same database.</p>
<p>When the first connect request TC1 from thread T1 is received, SQLLIB creates a connection pool with one physical connection C1 to the database. When another connect request TC2 from thread T2 is sent to the same database, C1 serves the TC2 request to the database, if it is free. Otherwise, a new physical connection C2 is created to serve the request. If another connect request from thread T3 named TC3 comes in, TC3 either waits for a specified time or returns an error message, if both physical connections C1 and C2 are busy.</p>
<p>When thread T2 needs to select data using the TC2 named connection, it acquires any free physical connection, C1 or C2. After the request is served, the chosen connection will again be available in the connection pool, so that another named or virtual connection can utilize the same physical connection.</p>
<a id="i1000335"></a>
<div id="LNPCC3963" class="sect2">
<h3 class="sect2">Using the Connection Pooling Feature<a id="sthref1612"></a></h3>
<p>This section comprises the following topics:</p>
<ul>
<li>
<p><a href="#i1000591">How to Enable Connection Pooling</a></p>
</li>
<li>
<p><a href="#i1001477">Command Line Options for Connection Pooling</a></p>
</li>
<li>
<p><a href="#i1003604">Example</a></p>
</li>
<li>
<p><a href="#i1005205">Performance Tuning</a></p>
</li>
</ul>
<a id="i1000591"></a>
<div id="LNPCC3964" class="sect3">
<h4 class="sect3">How to Enable Connection Pooling</h4>
<p>To enable connection pooling while precompiling an application, the user must set the command line option <code>CPOOL=YES</code>. Based on <code>CPOOL=YES/NO</code>, the connection pool feature is enabled or disabled.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>By default, <code>CPOOL</code> is set to <code>NO</code> and hence the connection pool feature is disabled. This feature cannot be enabled or disabled inline.</p>
</li>
<li>
<p>Connection pool will not be created with external operating system authentication, even if <code>CPOOL</code> is set to <code>YES</code>.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i1001477"></a>
<div id="LNPCC3965" class="sect3">
<h4 class="sect3">Command Line Options for Connection Pooling</h4>
<p><a href="#g1014720">Table 11-1</a> lists the command line options for connection pooling:</p>
<div id="LNPCC3966" class="tblformalwide">
<p class="titleintable"><a id="sthref1613"></a><a id="g1014720"></a>Table 11-1 Command Line Options for Connection Pooling</p>
<table class="cellalignment834" title="Command Line Options for Connection Pooling" summary="Command Line Options for Connection Pooling" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t12"><span class="bold">Option</span></th>
<th class="cellalignment832" id="r1c2-t12">Valid Values</th>
<th class="cellalignment832" id="r1c3-t12">Default</th>
<th class="cellalignment832" id="r1c4-t12">Remarks</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t12" headers="r1c1-t12">
<p>CPOOL</p>
</td>
<td class="cellalignment833" headers="r2c1-t12 r1c2-t12">
<p>YES/NO</p>
</td>
<td class="cellalignment833" headers="r2c1-t12 r1c3-t12">
<p>NO</p>
</td>
<td class="cellalignment833" headers="r2c1-t12 r1c4-t12">
<p>Based on this option, the precompiler generates the appropriate code that directs SQLLIB to enable or disable the connection pool feature.</p>
<p><span class="bold">Note</span>: If this option is set to NO, other connection pooling options will be ignored by the precompiler.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t12" headers="r1c1-t12">
<p>CMAX</p>
</td>
<td class="cellalignment833" headers="r3c1-t12 r1c2-t12">
<p>Valid values are 1 to 65535.</p>
</td>
<td class="cellalignment833" headers="r3c1-t12 r1c3-t12">
<p>100</p>
</td>
<td class="cellalignment833" headers="r3c1-t12 r1c4-t12">
<p>Specifies the maximum number of physical connections that can be opened for the database. CMAX value must be at least CMIN+CINCR.</p>
<p><span class="bold">Note</span>: Once this value is reached, more physical connections cannot be opened.</p>
<p>In a typical application, running 100 concurrent database operations is more than sufficient. The user can set an appropriate value.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t12" headers="r1c1-t12">
<p>CMIN</p>
</td>
<td class="cellalignment833" headers="r4c1-t12 r1c2-t12">
<p>Valid values are 1 to (CMAX-CINCR).</p>
</td>
<td class="cellalignment833" headers="r4c1-t12 r1c3-t12">
<p>2</p>
</td>
<td class="cellalignment833" headers="r4c1-t12 r1c4-t12">
<p>Specifies the minimum number of physical connections in the connection pool. Initially, all physical connections as specified through CMIN are opened to the server. Subsequently, physical connections are opened only when necessary. Users should set CMIN to the total number of planned or expected concurrent statements to be run by the application to get optimum performance. The default value is set to 2.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t12" headers="r1c1-t12">
<p>CINCR</p>
</td>
<td class="cellalignment833" headers="r5c1-t12 r1c2-t12">
<p>Valid values are 1 to (CMAX-CMIN).</p>
</td>
<td class="cellalignment833" headers="r5c1-t12 r1c3-t12">
<p>1</p>
</td>
<td class="cellalignment833" headers="r5c1-t12 r1c4-t12">
<p>Allows the application to set the next increment for physical connections to be opened to the database, if the current number of physical connections is less than CMAX. To avoid creating unnecessary extra connections, the default value is set to 1.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t12" headers="r1c1-t12">
<p>CTIMEOUT</p>
</td>
<td class="cellalignment833" headers="r6c1-t12 r1c2-t12">
<p>Valid values are 1 to 65535.</p>
</td>
<td class="cellalignment833" headers="r6c1-t12 r1c3-t12">
<p>0 which means not set; hence will not time out.</p>
</td>
<td class="cellalignment833" headers="r6c1-t12 r1c4-t12">
<p>Physical connections that are idle for more than the specified time (in seconds) are terminated to maintain an optimum number of open physical connections. If this attribute is not set, the physical connections are never timed out. Hence, physical connections will not be closed until the connection pool is terminated.</p>
<p><span class="bold">Note</span>: Creating a new physical connection will cost a round trip to the server.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t12" headers="r1c1-t12">
<p>CNOWAIT</p>
</td>
<td class="cellalignment833" headers="r7c1-t12 r1c2-t12">
<p>Valid values are 1 to 65535.</p>
</td>
<td class="cellalignment833" headers="r7c1-t12 r1c3-t12">
<p>0 which means not set; hence waits for a free connection.</p>
</td>
<td class="cellalignment833" headers="r7c1-t12 r1c4-t12">
<p>This attribute determines if the application must repeatedly try for a physical connection when all other physical connections in the pool are busy, and the total number of physical connections has already reached its maximum. If physical connections are not available and no more physical connections can be opened, an error is thrown when this attribute is set. Otherwise, the call waits until it acquires another connection. By default, CNOWAIT is not to be set so a thread will wait until it can acquire a free connection, instead of returning an error.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" -->
<p>A typical multithreaded application creates a pool of &#39;n&#39; physical connections. The &#39;n&#39; value needs to be specified by providing the CMIN value during precompilation. A minimum number of physical connections (CMIN) to the database are created on the first connect call. For new incoming requests, the mapping from a virtual connection (named connection) to a physical connection is carried out as described in the following section:</p>
<p><span class="bold">Case 1:</span> If a physical connection is available (among the already opened connections), a new request will be served by this connection.</p>
<p><span class="bold">Case 2:</span> If all physical connections are in use then,</p>
<p><span class="bold">Case 2a:</span> If the number of opened connections has not reached the maximum limit (CMAX), new CINCR connections are created, and one of these connections is used to serve the request.</p>
<p><span class="bold">Case 2b:</span> If the number of opened connections has reached the maximum limit (CMAX) without the CNOWAIT being set, the request waits until it acquires a connection. Otherwise, the application displays an error message <span class="italic">ORA 24401: cannot open further connections</span>.</p>
</div>
<!-- class="sect3" -->
<a id="i1003604"></a>
<div id="LNPCC3967" class="sect3">
<h4 class="sect3">Example</h4>
<p>Refer to Figure 11-4 for an illustration of the following example.</p>
<pre>Let
CMIN be 1,
CMAX be 2, and
CINCR be 1.
</pre>
<p>Consider the following scenario. When the first request TC1 comes in, SQLLIB creates the connection pool with one physical connection C1. When another request TC2 comes in, the application checks if C1 is free. As C1 is used to serve the first request (Case 1), a new physical connection C2 is created to serve the request (Case 2a). If another request TC3 comes in, and if both C1 and C2 are busy, then TC3 either waits for a specified time or returns with an error message (Case 2b).</p>
</div>
<!-- class="sect3" -->
<a id="i1005205"></a>
<div id="LNPCC3968" class="sect3">
<h4 class="sect3">Performance Tuning</h4>
<p>Users can set the connection pooling parameters to get better performance, based on the application. The Performance Graph in <a href="#i1004633">Figure 11-5</a> illustrates performance gain by changing the CMIN value for the Pro*C/C++ <a href="#i1013841">Demo Program:1</a>. <a href="#i1013170">Demo Program:2</a> illustrates performance gain by changing the CMAX parameter.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1013841"></a>
<div id="LNPCC3969" class="sect2">
<h3 class="sect2">Demo Program:1<a id="sthref1614"></a></h3>
<p>The following connection pool parameters are used while precompiling the Demo Program:1.</p>
<pre>CMAX = 40
CINCR = 3
CMIN = varying values between 1 to 40
CPOOL = YES
CTIMEOUT - Do not set 
</pre>
<p>(indicates that physical connections never time out)</p>
<pre>CNOWAIT - Do not set 
</pre>
<p>(indicates that a thread waits until it gets a free connection; see <a href="#g1014720">Table 11-1, &#34;Command Line Options for Connection Pooling&#34;</a>, for more details)</p>
<p>Other command line options required for this example are provided in the following section:</p>
<pre>threads = yes 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
In this example, there are 40 threads and database operations are performed against the local database.</div>
<p>It was observed that with CPOOL=NO (without connection pooling), the time taken by the application was 6.1 seconds, whereas, with CPOOL=YES (with connection pooling), the minimum time taken by the application was 1.3 seconds (when CMIN was 2).</p>
<p>In both cases, the time taken for database query operations should remain the same since the connection pool only reduces the time taken for CONNECT statements. When CPOOL=NO the application will create 40 dedicated connections. When CPOOL=YES and CMIN=2 it will create 2 connections initially and, only if 2 threads access the connections concurrently, will it create more connections. Otherwise all threads will share those 2 connections. So the application potentially avoids 38 connections which in turn avoids 38 round trips to the server to establish those connections. This is where the three fold performance gain is seen.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
These results were observed on a Sparc Ultra60 single CPU, 256 MB RAM machine, running one Oracle server on a Solaris 2.6 operating system; the server and client were running on the same machine.</div>
<div id="LNPCC3970" class="figure">
<p class="titleinfigure"><a id="i1004633"></a>Figure 11-5 Performance Graph</p>
<img width="538" height="362" src="img/performance_graph.gif" alt="Performance Graph"/><br/></div>
<!-- class="figure" -->
<p>The CPOOL=YES curve represents the time taken by the application when connection pooling is enabled. The CPOOL=NO curve represents the time taken by the application when connection pooling is disabled.</p>
<div id="LNPCC3971" class="sect3"><a id="sthref1615"></a>
<h4 class="sect3">Example</h4>
<pre>/* 
*  cpdemo1.pc 
* 
* Description: 
*      The program creates as many sessions as there are threads. 
*      Each thread connects to the default database and executes the 
*      SELECT statement 5 times. Each thread has its own runtime context.
* 
*/ 

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt; 
#include &lt;sqlca.h&gt; 

#define      _EXC_OS_        _EXC__UNIX 
#define      _CMA_OS_        _CMA__UNIX 

#ifdef DCE_THREADS 
#include &lt;pthread.h&gt; 
#else 
#include &lt;pthread.h&gt; 
typedef void*       pthread_addr_t;
typedef void*      (*pthread_startroutine_t) (void*);
#define pthread_attr_default  (const pthread_attr_t *)NULL
#endif 

/* Function prototypes */ 
void   err_report(); 
void   do_transaction(); 
void   get_transaction(); 
void   logon(); 
void   logoff(); 

#define CONNINFO &#34;hr/hr&#34; 
#define THREADS  40 

struct parameters 
  { 
   sql_context * ctx; 
   int thread_id; 
  }; 
typedef struct parameters parameters; 

struct timeval tp1;
struct timeval tp2;

/*************************************** 
*  Main 
***************************************/ 

main() 
{ 
  sql_context ctx[THREADS]; 
  pthread_t thread_id[THREADS]; 
  pthread_addr_t status; 
  parameters params[THREADS]; 
  int i; 

  EXEC SQL ENABLE THREADS; 
  EXEC SQL WHENEVER SQLERROR DO err_report(sqlca); 

  if(gettimeofday(&amp;tp1, (void*)NULL) == -1)
  {
    perror(&#34;First: &#34;);
    exit(0);
  }

  /* Create THREADS sessions by connecting THREADS times */ 
  for(i=0;i&lt;THREADS;i++) 
  { 
    printf(&#34;Start Session %d....&#34;,i); 
    EXEC SQL CONTEXT ALLOCATE :ctx[i]; 
    logon(ctx[i],CONNINFO); 
  } 

  /*Spawn threads*/ 
  for(i=0;i&lt;THREADS;i++) 
  { 
    params[i].ctx=ctx[i]; 
    params[i].thread_id=i; 

    if (pthread_create(&amp;thread_id[i],pthread_attr_default, 
      (pthread_startroutine_t)do_transaction, 
      (pthread_addr_t) &amp;params[i])) 
      printf(&#34;Cant create thread %d\n&#34;,i); 
    else 
      printf(&#34;Created Thread %d\n&#34;, i); 
  } 

  /* Logoff sessions....*/ 
  for(i=0;i&lt;THREADS;i++) 
  { 
    /*wait for thread to end */ 
    if (pthread_join(thread_id[i],&amp;status)) 
      printf(&#34;Error when waiting for thread % to terminate\n&#34;, i); 
    else 
      printf(&#34;stopped\n&#34;); 

    if(i==THREADS-1) 
    {
      logoff(ctx[i]); 
      EXEC SQL CONTEXT FREE :ctx[i];
    } 
  } 

  if(gettimeofday(&amp;tp2, (void*)NULL) == -1)
  {
    perror(&#34;Second: &#34;);
    exit(0);
  }

    printf(&#34; \n\nTHE TOTAL TIME TAKEN FOR THE PROGRAM EXECUTION = %f \n\n&#34;,
    (float)(tp2.tv_sec - tp1.tv_sec) + ((float)(tp2.tv_usec -
    tp1.tv_usec)/1000000.0));


} 

/*********************************************************************** 
* Function: do_transaction 
* Description:  This functions executes SELECT 5 times and calls COMMIT.
***********************************************************************/ 
void do_transaction(params) 
parameters *params; 
{ 
  struct sqlca sqlca; 
  int src_count; 
  sql_context ctx=params-&gt;ctx; 

  EXEC SQL WHENEVER SQLERROR DO err_report(sqlca); 
  EXEC SQL CONTEXT USE :ctx; 
  printf(&#34;Thread %d executing transaction\n&#34;,params-&gt;thread_id); 
  EXEC SQL COMMIT; 
  EXEC SQL SELECT count(*) into :src_count from EMPLOYEES;
  EXEC SQL SELECT count(*) into :src_count from EMPLOYEES;
  EXEC SQL SELECT count(*) into :src_count from EMPLOYEES;
  EXEC SQL SELECT count(*) into :src_count from EMPLOYEES;
  EXEC SQL SELECT count(*) into :src_count from EMPLOYEES;
} 

/************************************************************** 
* Function: err_report 
* Description: This routine prints out the most recent error 
**************************************************************/ 
void      err_report(sqlca) 
struct sqlca sqlca; 
{ 
  if (sqlca.sqlcode &lt; 0) 
    printf(&#34;\n%.*s\n\n&#34;,sqlca.sqlerrm.sqlerrml,sqlca.sqlerrm.sqlerrmc); 
  exit(1); 
} 

/************************************************************ 
* Function: logon 
* Description: Logs on to the database as USERNAME/PASSWORD 
************************************************************/ 
void      logon(ctx,connect_info) 
sql_context ctx; 
char * connect_info; 
{ 
  EXEC SQL WHENEVER SQLERROR DO err_report(sqlca); 
  EXEC SQL CONTEXT USE :ctx; 
  EXEC SQL CONNECT :connect_info; 
  printf(&#34;Connected!\n&#34;); 
} 

/*************************************************** 
* Function: logoff 
* Description: This routine logs off the database 
***************************************************/ 
void      logoff(ctx) 
sql_context ctx; 
{ 
  EXEC SQL WHENEVER SQLERROR DO err_report(sqlca); 
  EXEC SQL CONTEXT USE :ctx; 
  EXEC SQL COMMIT WORK RELEASE; 
  printf(&#34;Logged off!\n&#34;);
}
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1013170"></a>
<div id="LNPCC3972" class="sect2">
<h3 class="sect2">Demo Prog<a id="sthref1616"></a>ram:2</h3>
<p>The following connection pool parameters are used while precompiling the Demo Program:2.</p>
<p>CMAX = varying values between 5 to 40</p>
<p>CINCR = 3</p>
<p>CMIN = varying values between 1 to 40</p>
<p>CPOOL = YES</p>
<p>CTIMEOUT - Do not set</p>
<p>(indicates that physical connections never time out)</p>
<p>CNOWAIT - Do not set</p>
<p>(indicates that a thread waits until it gets a free connection; see <a href="#g1014720">Table 11-1, &#34;Command Line Options for Connection Pooling&#34;</a>, for more details)</p>
<p>Other command line options required for this example are provided in the following section:</p>
<p><code>threads = yes</code></p>
<p>The following figure illustrates the performance graph for cpdemo2.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In this example there are 40 threads and database operations are performed against the local database.</div>
<p>In this example the best performance is observed with CMIN=5 and CMAX=14 when the program runs approximately 2.3 times faster compared to using CPOOL=NO.This is less of an improvement than &#34;cpdemo1&#34; though which ran faster with connection pooling enabled.The reason for this is because &#34;cpdemo1&#34; performs only simple SELECT statements whereas &#34;cpdemo2&#34; performs both UPDATE AND SELECT statements.Therefore &#34;cpdemo1&#34; spends more time creating connections than performing database operations.When connection pooling is enabled, time is saved as fewer connections are created. Hence overall performance improves. Since &#34;cpdemo2&#34; spends less time creating connections compared to performing database operations, the overall performance gain is less.</p>
<p>In the following graphs, the CPOOL=YES curve represents the time taken by the application when connection pooling is enabled. The CPOOL=NO curve represents the time taken by the application when connection pooling is disabled. The demo program &#34;cpdemo2&#34; creates 40 threads. With CPOOL=NO option, each thread establishes its own dedicated connection to the server. Hence 40 connections are created. The same demo program, when built with CPOOL=YES and CMAX=14, creates a maximum of 14 connections. These connections are shared across the 40 threads thus saving at least 26 connections and so avoiding 26 round-trips to the server.</p>
<p>The following two graphs show performance against varying CMIN and CMAX values respectively.</p>
<div id="LNPCC3973" class="sect3"><a id="sthref1617"></a>
<h4 class="sect3">Case 1: By varying CMIN</h4>
<div id="LNPCC3974" class="figure">
<p class="titleinfigure"><a id="sthref1618"></a>Figure 11-6 Performance Graph Case 1</p>
<img width="487" height="286" src="img/performgraph_case1.gif" alt="Performance Graph Case 1"/><br/></div>
<!-- class="figure" -->
<p>The application takes around 7.5 seconds for execution with CPOOL=NO. With CPOOL=YES, and CMIN=8 and CMAX=14, the execution time reduces to 4.5 seconds. So, the performance improvement is about 1.7 times. The difference in performance is because of different database operations (SELECT vs UPDATE) which is purely a server side activity and beyond the scope of connection pool feature which is a client side feature.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3975" class="sect3"><a id="sthref1619"></a>
<h4 class="sect3">Case 2: By varying CMAX</h4>
<div id="LNPCC3976" class="figure">
<p class="titleinfigure"><a id="sthref1620"></a>Figure 11-7 Performance Graph Case 2</p>
<img width="586" height="285" src="img/performgraph_case2.gif" alt="Performance Graph Case 2"/><br/></div>
<!-- class="figure" -->
<p>For the preceding graph the demo program was run with CMIN=5 and CINCR=3. The best performance was observed with CMAX=14. Execution takes around 7.4 seconds with CPOOL=NO. With CPOOL=YES, when CMAX=14 the execution time reduces to around 3.1 seconds, resulting in a 2.3 fold performance gain.</p>
<p>The performance improvement varies with CMAX.Therefore to obtain the best performance for a given application, the user should vary CMIN and CMAX until the optimal performance is achieved.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3977" class="sect3"><a id="sthref1621"></a>
<h4 class="sect3">Example<a id="sthref1622"></a></h4>
<pre>/* 
*  cpdemo2.pc 
  * Program to show the performance imcrement when the cpool option is used
  * Run this program with cpool=no. Record the time taken for the program to
  * execute
  *
  * Compare the execution time
  *
  * This program also demonstrates the impact of a properly tuned CMAX 
  * parameter on the performance
  *
  * Run the program with the following parameter values
  * 
  * CMIN=5
  * CINCR=2
  * CMAX=20
  *
  */

#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;

#ifdef DCE_THREADS 
#include &lt;pthread.h&gt; 
#else 
#include &lt;sys/time.h&gt;
#include &lt;pthread.h&gt; 
typedef void*       pthread_addr_t;
typedef void*      (*pthread_startroutine_t) (void*);
#define pthread_attr_default  (const pthread_attr_t *)NULL
#endif 


#define CONNINFO &#34;hr/hr&#34;
#define THREADS 40

/***** prototypes ************** */
void selectFunction();
void updateFunction();

void err_report(struct sqlca sqlca);
/* ************************* */

/***** parameter to the function selectFunction, updateFunction */
struct parameters 
{
  sql_context ctx;
  char connName[20];
  char dbName[20];
  int thread_id;
};
typedef struct parameters parameters;
/*******************************************/

parameters params[THREADS];

struct timeval tp1;
struct timeval tp2;

int main()
{
  int i;
  pthread_t thread_id[THREADS];
  pthread_addr_t status;

  int thrNos[THREADS];

  for(i=0; i&lt;THREADS; i++)
    thrNos[i] = i;

  EXEC SQL ENABLE THREADS;

  /* Time before executing the program */
  if(gettimeofday(&amp;tp1, (void*)NULL) == -1){
    perror(&#34;First: &#34;);
    exit(0);
  }

  EXEC SQL WHENEVER SQLERROR DO err_report(sqlca);
  /* connect THREADS times to the data base */
  for(i=0; i&lt;THREADS; i++)
  {
    strcpy(params[i].dbName, &#34;&#34;);
    sprintf(params[i].connName,&#34;conn%d&#34;, i);
    params[i].thread_id = i;

    /* logon to the data base */
    EXEC SQL CONTEXT ALLOCATE :params[i].ctx;
    EXEC SQL CONTEXT USE :params[i].ctx;
    EXEC SQL CONNECT :CONNINFO
      AT :params[i].connName USING :params[i].dbName;
  }


  /* create THREADS number of threads */
  for(i=0;i&lt;THREADS;i++)
  {
      printf(&#34;Creating thread %d \n&#34;, i);
      if(i%2)
      {
        /* do a select operation if the thread id is odd */
        if(pthread_create(&amp;thread_id[i],pthread_attr_default, 
            (pthread_startroutine_t)selectFunction, 
            (pthread_addr_t) &amp;params[i])) 
        printf(&#34;Cant create thread %d \n&#34;, i);
      }
      else
      {
        /* otherwise do an update operation */
        if(pthread_create(&amp;thread_id[i],pthread_attr_default, 
            (pthread_startroutine_t)updateFunction, 
            (pthread_addr_t) &amp;params[i])) 
        printf(&#34;Cant create thread %d \n&#34;, i);
      }
  }

  for(i=0; i&lt;THREADS; i++)
  {
    if(pthread_join(thread_id[i],&amp;status)) 
      printf(&#34;Error when waiting for thread % to terminate\n&#34;, i); 

  }

  if(gettimeofday(&amp;tp2, (void*)NULL) == -1){
  perror(&#34;Second: &#34;);
        exit(0);
  }

  printf(&#34; \n\nTHE TOTAL TIME TAKEN FOR THE PROGRAM EXECUTION = %f \n\n&#34;,
      (float)(tp2.tv_sec - tp1.tv_sec) + ((float)(tp2.tv_usec -
      tp1.tv_usec)/1000000.0));

  /* free the context */
  for(i=0; i&lt;THREADS; i++)
  {
    EXEC SQL CONTEXT USE :params[i].ctx;
    EXEC SQL AT :params[i].connName COMMIT WORK RELEASE;

    EXEC SQL CONTEXT FREE :params[i].ctx;
  }

  return 0;
}

void selectFunction(parameters *params)
{
  struct sqlca sqlca;
  char empName[110][21];
  printf(&#34;Thread %d selecting .... \n&#34;, params-&gt;thread_id);

  EXEC SQL CONTEXT USE :params-&gt;ctx;
  EXEC SQL AT : params-&gt;connName
    SELECT FIRST_NAME into empName from EMPLOYEES;
  printf(&#34;Thread %d selected ....\n&#34;, params-&gt;thread_id);
  return 0;
}

void updateFunction(parameters *params)
{
  struct sqlca sqlca;
  printf(&#34; Thread %d Updating ... \n&#34;, params-&gt;thread_id);

  EXEC SQL CONTEXT USE :params-&gt;ctx;
  EXEC SQL AT :params-&gt;connName update EMPLOYEES
    set SALARY = 4000 where DEPARTMENT_ID = 10;

  /* commit the changes */
  EXEC SQL AT :params-&gt;connName COMMIT;

  printf(&#34; Thread %d Updated ... \n&#34;, params-&gt;thread_id);
  return 0;
}

/*********** Oracle error ***********/
void err_report(struct sqlca sqlca)
{
  if (sqlca.sqlcode &lt; 0)
   printf(&#34;\n%.*s\n\n&#34;,sqlca.sqlerrm.sqlerrml,sqlca.sqlerrm.sqlerrmc);

  exit(0);
}

</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_10opt.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="partpage2.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>