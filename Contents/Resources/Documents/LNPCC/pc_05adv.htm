<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78005"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Advanced%20Topics"></a><title>Advanced Topics</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:37Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_04dat.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_06sql.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">10/35</span> <!-- End Header -->
<div id="LNPCC3253" class="chapter"><a id="g462796"></a> <a id="i432598"></a>
<h1 class="chapter"><span class="secnum">5</span> Advanced Topics</h1>
<p>This chapter discusses advanced techniques in Pro*C/C++ and contains the following topics:</p>
<ul>
<li>
<p><a href="#i431176">Character Data</a></p>
</li>
<li>
<p><a href="#i430172">Datatype Conversion</a></p>
</li>
<li>
<p><a href="#i430180">Datatype Equivalencing</a></p>
</li>
<li>
<p><a href="#i431189">The C Preprocessor</a></p>
</li>
<li>
<p><a href="#i433802">Precompiled Header Files</a></p>
</li>
<li>
<p><a href="#i432485">The Oracle Preprocessor</a></p>
</li>
<li>
<p><a href="#i429746">Evaluation of Numeric Constants</a></p>
</li>
<li>
<p><a href="#i431030">SQLLIB Extensions for OCI Release 8 Interoperability</a></p>
</li>
<li>
<p><a href="#i431046">Interface to OCI Release 8</a></p>
</li>
<li>
<p><a href="#i421486">Embedded OCI Release 7 Calls</a></p>
</li>
<li>
<p><a href="#i426817">New Names for SQLLIB Public Functions</a></p>
</li>
<li>
<p><a href="#i432871">X/Open Application Development</a></p>
</li>
</ul>
<a id="i431176"></a>
<div id="LNPCC3254" class="sect1">
<h2 class="sect1">Character Data<a id="sthref591"></a></h2>
<p>This section explains how the Pro*C/C++ Precompiler handles character host variables. There are four host variable character types:</p>
<ul>
<li>
<p>Character arrays</p>
</li>
<li>
<p>Pointers to strings</p>
</li>
<li>
<p>VARCHAR variables</p>
</li>
<li>
<p>Pointers to VARCHARs</p>
</li>
</ul>
<p>Do not confuse VARCHAR (a host variable data structure supplied by the precompiler) with VARCHAR2 (an Oracle internal datatype for variable-length character strings).</p>
<a id="i429858"></a>
<div id="LNPCC3255" class="sect2">
<h3 class="sect2">Precompiler Option CHAR_MAP<a id="sthref592"></a><a id="sthref593"></a></h3>
<p>The CHAR_MAP precompiler option is available to specify the default mapping of char[n] and char host variables. Oracle maps them to CHARZ. CHARZ implements the ANSI Fixed Character format. Strings are fixed-length, blank-padded and null-terminated. VARCHAR2 values (including nulls) are always fixed-length and blank-padded. <a href="#BABIDDHA">Table 5-1</a> shows the possible settings of CHAR_MAP:</p>
<div id="LNPCC3256" class="tblformal">
<p class="titleintable"><a id="sthref594"></a><a id="BABIDDHA"></a>Table 5-1 CHAR_MAP Settings</p>
<table class="cellalignment831" title="CHAR_MAP Settings" summary="CHAR_MAP Settings" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t2">CHAR_MAP Setting</th>
<th class="cellalignment832" id="r1c2-t2">Is Default for</th>
<th class="cellalignment832" id="r1c3-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t2" headers="r1c1-t2">
<p>VARCHAR2</p>
</td>
<td class="cellalignment833" headers="r2c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r2c1-t2 r1c3-t2">
<p>All values (including null) are fixed-length blank-padded.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t2" headers="r1c1-t2">
<p>CHARZ</p>
</td>
<td class="cellalignment833" headers="r3c1-t2 r1c2-t2">
<p>DBMS=V7, DBMS=V8</p>
</td>
<td class="cellalignment833" headers="r3c1-t2 r1c3-t2">
<p>Fixed-length blank-padded, then null-terminated. Conforms to the ANSI Fixed Character type.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t2" headers="r1c1-t2">
<p>STRING</p>
</td>
<td class="cellalignment833" headers="r4c1-t2 r1c2-t2">
<p>New format</p>
</td>
<td class="cellalignment833" headers="r4c1-t2 r1c3-t2">
<p>null-terminated. Conforms to ASCII format used in C programs.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t2" headers="r1c1-t2">
<p>CHARF</p>
</td>
<td class="cellalignment833" headers="r5c1-t2 r1c2-t2">
<p>Previously, only through VAR or TYPE declarations.</p>
</td>
<td class="cellalignment833" headers="r5c1-t2 r1c3-t2">
<p>Fixed-length blank-padded. null is left unpadded.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The default mapping is CHAR_MAP=CHARZ, which was the case in previous versions of Pro*C/C++.</p>
<p>Use CHAR_MAP=VARCHAR2 instead of the old DBMS=V6_CHAR, which is obsolete.</p>
</div>
<!-- class="sect2" -->
<a id="i429905"></a>
<div id="LNPCC3257" class="sect2">
<h3 class="sect2">Inline Usage of the CHAR_MAP Option</h3>
<p>Unless you declared a char or char[n] variable otherwise, the inline CHAR_MAP option determines its mapping. The following code fragment illustrates the results of setting this option inline in Pro*C/C++:</p>
<pre>char ch_array[5];

strncpy(ch_array, &#34;12345&#34;, 5);
/* char_map=charz is the default in Oracle7 and Oracle8 */
EXEC ORACLE OPTION (char_map=charz);
/* Select retrieves a string &#34;AB&#34; from the database */
SQL SELECT ... INTO :ch_array FROM ... WHERE ... ;
/* ch_array == { &#39;A&#39;, &#39;B&#39;, &#39; &#39;, &#39; &#39;, &#39;\0&#39; } */

strncpy (ch_array, &#34;12345&#34;, 5);
EXEC ORACLE OPTION (char_map=string) ;
/* Select retrieves a string &#34;AB&#34; from the database */
EXEC SQL SELECT ... INTO :ch_array FROM ... WHERE ... ;
/* ch_array == { &#39;A&#39;, &#39;B&#39;, &#39;\0&#39;, &#39;4&#39;, &#39;5&#39; } */

strncpy( ch_array, &#34;12345&#34;, 5);
EXEC ORACLE OPTION (char_map=charf);
/* Select retrieves a string &#34;AB&#34; from the database */
EXEC SQL SELECT ... INTO :ch_array FROM ... WHERE ... ;
/* ch_array == { &#39;A&#39;, &#39;B&#39;, &#39; &#39;, &#39; &#39;, &#39; &#39; } */ 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3258" class="sect2"><a id="sthref595"></a>
<h3 class="sect2">Effect of the DBMS and CHAR_MAP Options</h3>
<p>The DBMS and CHAR_MAP options determine how Pro*C/C++ treats data in character arrays and strings. These options allow your program to observe compatibility with ANSI fixed-length strings, or to maintain compatibility with previous releases of Oracle and Pro*C/C++ that use variable-length strings. See <a href="pc_10opt.htm#g30455">Chapter 10, &#34; Precompiler Options&#34;</a> for a complete description of the DBMS and CHAR_MAP options.</p>
<p>The DBMS option affects character data both on input (from your host variables to the Oracle table) and on output (from an Oracle table to your host variables).</p>
<p><span class="bold">Character Array and the CHAR_MAP Option</span></p>
<p>The mapping of character arrays can also be set by the CHAR_MAP option independent of the DBMS option. DBMS=V7 or DBMS=V8 both use CHAR_MAP=CHARZ, which can be overridden by specifying either CHAR_MAP=VARCHAR2 or STRING or CHARF.</p>
<div id="LNPCC3259" class="sect3"><a id="sthref596"></a>
<h4 class="sect3">On Input</h4>
<p><a id="LNPCC3260"></a><span class="subhead3">Character Array&nbsp;</span>On input, the DBMS option determines the format that a host variable character array must have in your program. When the CHAR_MAP=VARCHAR2, host variable character arrays must be blank padded, and should not be null-terminated. When the DBMS=V7 or V8, character arrays must be null-terminated (&#39;\0&#39;).</p>
<p>When the CHAR_MAP option is set to VARCHAR2 trailing blanks are removed up to the first non-blank character before the value is sent to the database. An un-initialized character array can contain null characters. To make sure that the nulls are not inserted into the table, you must blank-pad the character array to its length. For example, if you execute the statements:</p>
<pre>char emp_name[10]; 
... 
strcpy(emp_name, &#34;MILLER&#34;);     /* WRONG! Note no blank-padding */ 
EXEC SQL INSERT INTO emp (empno, ename, deptno) VALUES 
    (1234, :emp_name, 20); 
</pre>
<p>you will find that the string &#34;MILLER&#34; was inserted as &#34;MILLER\0\0\0\0&#34; (with four null bytes appended to it). This value does not meet the following search condition:</p>
<pre>. . . WHERE ename = &#39;MILLER&#39;; 
</pre>
<p>To INSERT the character array when CHAR_MAP is set to VARCHAR2, you should execute the statements</p>
<pre>strncpy(emp_name, &#34;MILLER    &#34;, 10); /* 4 trailing blanks */ 
EXEC SQL INSERT INTO emp (empno, ename, deptno) VALUES 
    (1234, :emp_name, 20); 
</pre>
<p>When DBMS=V7 or V8, input data in a character array must be null-terminated. So, make sure that your data ends with a null.</p>
<pre>char emp_name[11];  /* Note: one greater than column size of 10 */ 
... 
strcpy(emp_name, &#34;MILLER&#34;);        /* No blank-padding required */ 
EXEC SQL INSERT INTO emp (empno, ename, deptno) VALUES 
    (1234, :emp_name, 20); 
</pre>
<p><a id="LNPCC3261"></a><span class="subhead3">Character Pointer&nbsp;</span>The pointer must address a null-terminated buffer that is large enough to hold the input data. Your program must allocate enough memory to do this.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3262" class="sect3"><a id="sthref597"></a>
<h4 class="sect3">On Input</h4>
<p>The following example illustrates all possible combinations of the effects of the CHAR_MAP option settings on the value retrieved from a database into a character array.</p>
<p>Assume a database</p>
<pre>TABLE strdbase ( ..., strval VARCHAR2(6));
</pre>
<p>which contains the following strings in the column strval:</p>
<pre>&#34;&#34;        -- string of length 0
&#34;AB&#34;      -- string of length 2
&#34;KING&#34;    -- string of length 4
&#34;QUEEN&#34;   -- string of length 5
&#34;MILLER&#34;  -- string of length 6
</pre>
<p>In a Pro*C/C++ program, initialize the 5-character host array <span class="italic">str</span> with &#39;X&#39; characters and use for the retrieval of all the values in column strval:</p>
<pre>char  str[5] = {&#39;X&#39;, &#39;X&#39;, &#39;X&#39;,&#39;X&#39;, &#39;X&#39;} ;
short str_ind;
...
EXEC SQL SELECT strval INTO :str:str_ind WHERE ... ;
</pre>
<p>with the following results for the array, str, and the indicator variable, str_ind, as CHAR_MAP is set to VARCHAR2, CHARF, CHARZ and STRING:</p>
<pre>strval = &#34;&#34;         &#34;AB&#34;       &#34;KING&#34;     &#34;QUEEN&#34;    &#34;MILLER&#34;
---------------------------------------------------------------
VARCHAR2 &#34;     &#34; -1 &#34;AB   &#34; 0  &#34;KING &#34;  0 &#34;QUEEN&#34;  0 &#34;MILLE&#34;  6
CHARF    &#34;XXXXX&#34; -1 &#34;AB   &#34; 0  &#34;KING &#34;  0 &#34;QUEEN&#34;  0 &#34;MILLE&#34;  6
CHARZ    &#34;    0&#34; -1 &#34;AB  0&#34; 0  &#34;KING0&#34;  0 &#34;QUEE0&#34;  5 &#34;MILL0&#34;  6
STRING   &#34;0XXXX&#34; -1 &#34;AB0XX&#34; 0  &#34;KING0&#34;  0 &#34;QUEE0&#34;  5 &#34;MILL0&#34;  6
</pre>
<p>where 0 stands for the null character, &#39;\0&#39;.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3263" class="sect3"><a id="sthref598"></a>
<h4 class="sect3">On Output</h4>
<p><a id="LNPCC3264"></a><span class="subhead3">Character Array&nbsp;</span>On output, the DBMS and CHAR_MAP options determines the format that a host variable character array will have in your program. When CHAR_MAP=VARCHAR2, host variable character arrays are blank padded up to the length of the array, but never null-terminated. When DBMS=V7 or V8 (or CHAR_MAP=CHARZ), character arrays are blank padded, then null-terminated in the final position in the array.</p>
<p>Consider the following example of character output:</p>
<pre>CREATE TABLE test_char (C_col CHAR(10), V_col VARCHAR2(10)); 
 
INSERT INTO test_char VALUES (&#39;MILLER&#39;, &#39;KING&#39;); 
</pre>
<p>A precompiler program to select from this table contains the following embedded SQL:</p>
<pre>... 
char name1[10]; 
char name2[10]; 
... 
EXEC SQL SELECT C_col, V_col INTO :name1, :name2 
    FROM test_char; 
</pre>
<p>If you precompile the program with CHAR_MAP=VARCHAR2, <span class="italic">name1</span> will contain:</p>
<pre>&#34;MILLER####&#34; 
</pre>
<p>that is, the name &#34;MILLER&#34; followed by 4 blanks, with no null-termination. (If <span class="italic">name1</span> had been declared with a size of 15, there are 9 blanks following the name.)</p>
<p><span class="italic">name2</span> will contain:</p>
<pre>&#34;KING######&#34;      /* 6 trailing blanks */ 
</pre>
<p>If you precompile the program with DBMS=V7 or V8, <span class="italic">name1</span> will contain:</p>
<pre>&#34;MILLER###\0&#34; /* 3 trailing blanks, then a null-terminator */ 
</pre>
<p>that is, a string containing the name, blank-padded to the length of the column, followed by a null terminator. <span class="italic">name2</span> will contain:</p>
<pre>&#34;KING#####\0&#34; 
</pre>
<p>In summary, if CHAR_MAP=VARCHAR2, the output from either a CHARACTER column or a VARCHAR2 column is blank-padded to the length of the host variable array. If DBMS=V7 or V8, the output string is always null-terminated.</p>
<p><a id="LNPCC3265"></a><span class="subhead3">Character Pointer&nbsp;</span>The DBMS and CHAR_MAP options do not affect the way character data are output to a pointer host variable.</p>
<p>When you output data to a character pointer host variable, the pointer must point to a buffer large enough to hold the output from the table, plus one extra byte to hold a null terminator.</p>
<p>The precompiler runtime environment calls <code>strlen()</code> to determine the size of the output buffer, so make sure that the buffer does not contain any embedded nulls (&#39;\0&#39;). Fill allocated buffers with some value other than &#39;\0&#39;, then null-terminate the buffer, before fetching the data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
C pointers can be used in a Pro*C/C++ program that is precompiled with DBMS=V7 or V8 and MODE=ANSI. However, pointers are not legal host variable types in a SQL standard compliant program. The FIPS flagger warns you if you use pointers as host variables. <a id="sthref599"></a></div>
<p>The following code fragment uses the columns and table defined in the previous section, and shows how to declare and SELECT into character pointer host variables:</p>
<pre>... 
char *p_name1; 
char *p_name2; 
... 
p_name1 = (char *) malloc(11); 
p_name2 = (char *) malloc(11); 
strcpy(p_name1, &#34;          &#34;); 
strcpy(p_name2, &#34;0123456789&#34;); 
 
EXEC SQL SELECT C_col, V_col INTO :p_name1, :p_name2 
    FROM test_char; 
</pre>
<p>When the SELECT statement mentioned earlier is executed with any DBMS or CHAR_MAP setting, the value fetched is:</p>
<pre>&#34;MILLER####\0&#34;     /* 4 trailing blanks and a null terminator */ 
 
&#34;KING######\0&#34;    /* 6 blanks and null */ 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i434340"></a>
<div id="LNPCC3266" class="sect2">
<h3 class="sect2">VARCHAR Variables and Pointers</h3>
<p>The following example shows how VARCHAR host variables are declared: <a id="sthref600"></a></p>
<pre>VARCHAR   emp_name1[10];   /* VARCHAR variable   */ 
VARCHAR  *emp_name2;       /* pointer to VARCHAR */
</pre>
<div id="LNPCC3267" class="sect3"><a id="sthref601"></a>
<h4 class="sect3">On Input</h4>
<p><a id="LNPCC3268"></a><span class="subhead3">VARCHAR Variables&nbsp;</span>When you use a VARCHAR variable as an input host variable, your program need only place the desired string in the array member of the expanded VARCHAR declaration (<span class="italic">emp_name1.arr</span> in our example) and set the length member (<span class="italic">emp_name1.len</span>). There is no need to blank-pad the array. Exactly <span class="italic">emp_name1.len</span> characters are sent to Oracle, counting any blanks and nulls. In the following example, you set <span class="italic">emp_name1.len</span> to 8:</p>
<pre>strcpy((char *)emp_name1.arr, &#34;VAN HORN&#34;); 
emp_name1.len = strlen((char *)emp_name1.arr); 
</pre>
<p><a id="LNPCC3269"></a><span class="subhead3">Pointer to a VARCHAR&nbsp;</span>When you use a pointer to a VARCHAR as an input host variable, you must allocate enough memory for the expanded VARCHAR declaration. Then, you must place the desired string in the array member and set the length member, as shown in the following example:</p>
<pre>emp_name2 = malloc(sizeof(short) + 10)   /* len + arr */ 
strcpy((char *)emp_name2-&gt;arr, &#34;MILLER&#34;); 
emp_name2-&gt;len = strlen((char *)emp_name2-&gt;arr); 
</pre>
<p>Or, to make <span class="italic">emp_name2</span> point to an existing VARCHAR (<span class="italic">emp_name1</span> in this case), you could code the assignment</p>
<pre>emp_name2 = &amp;emp_name1;
 
</pre>
<p>then use the VARCHAR pointer in the usual way, as in</p>
<pre>EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO) 
    VALUES (:emp_number, :emp_name2, :dept_number); 
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC3270" class="sect3"><a id="sthref602"></a>
<h4 class="sect3">On Output</h4>
<p><a id="LNPCC3271"></a><span class="subhead3">VARCHAR Variables&nbsp;</span>When you use a VARCHAR variable as an output host variable, the program interface sets the length member but does <span class="italic">not</span> null-terminate the array member. As with character arrays, your program can null-terminate the <span class="italic">arr</span> member of a VARCHAR variable before passing it to a function such as <code>printf()</code> or <code>strlen()</code>. An example follows:</p>
<pre>emp_name1.arr[emp_name1.len] = &#39;\0&#39;; 
printf(&#34;%s&#34;, emp_name1.arr); 
</pre>
<p>Or, you can use the length member to limit the printing of the string, as in:</p>
<pre>printf(&#34;%.*s&#34;, emp_name1.len, emp_name1.arr); 
</pre>
<p>An advantage of VARCHAR variables over character arrays is that the length of the value returned by Oracle is available immediately. With character arrays, you might need to strip the trailing blanks yourself to get the actual length of the character string.<a id="sthref603"></a></p>
<p><a id="LNPCC3272"></a><span class="subhead3">VARCHAR Pointers&nbsp;</span>When you use a pointer to a VARCHAR as an output host variable, the program interface determines the variable&#39;s maximum length by checking the length member (<span class="italic">emp_name2-&gt;len</span> in our example). So, your program must set this member before <span class="italic">every</span> fetch. The fetch then sets the length member to the actual number of characters returned, as the following example shows:</p>
<pre>emp_name2-&gt;len = 10;  /* Set maximum length of buffer. */ 
EXEC SQL SELECT ENAME INTO :emp_name2 WHERE EMPNO = 7934; 
printf(&#34;%d characters returned to emp_name2&#34;, emp_name2-&gt;len);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i430087"></a>
<div id="LNPCC3273" class="sect2">
<h3 class="sect2">Unicode Variables<a id="sthref604"></a></h3>
<p>Pro*C/C++ allows fixed-width Unicode data (character set Unicode Standard Version 3.0, known simply as UCS-16) in host <code>char</code> variables. UCS-16 uses 2 bytes for each character, so it is an unsigned 2-byte datatype. SQL statement text in UCS-16 is not supported yet.</p>
<p>In the following example code a host variable, <code>employee</code>, of the Unicode type <span class="italic">utext</span> is declared to be 20 Unicode characters long. A table <code>emp</code> is created containing the column <code>ename</code>, which is 60 bytes long, so that database character sets in Asian languages, where multibyte characters are up to three bytes long, will be supported.</p>
<pre>utext employee[20] ;                               /* Unicode host variable   */
EXEC SQL CREATE TABLE emp (ename CHAR(60));
/* ename is in the current database character set  */                                        
EXEC SQL INSERT INTO emp (ename) VALUES (&#39;test&#39;) ; 
/* &#39;test&#39; in NLS_LANG encoding converted to database character set */
EXEC SQL SELECT * INTO :employee FROM emp ;       
/* Database character set converted to Unicode */
</pre>
<p>A public header file, sqlucs2.h, must be included in your application code. It does the following:</p>
<ul>
<li>
<p>Contains the statement:</p>
</li>
</ul>
<pre>    #include &lt;oratypes.h&gt;
</pre>
<ul>
<li>
<p>Defines a &#34;Unicode varchar&#34;, uvarchar, as:</p>
</li>
</ul>
<pre>    struct uvarchar
    {
       ub2 len;
       utext arr[1] ;
    };
    typedef struct uvarchar uvarchar ;
</pre>
<ul>
<li>
<p>Defines a &#34;Unicode long varchar&#34;, ulong_varchar, as:</p>
</li>
</ul>
<pre>    struct ulong_varchar
    {
       ub4 len ;
       utext arr[1] ;
    }
    typedef struct ulong_varchar ulong_varchar ;
</pre>
<p>The default datatype of utext is the same as the default for any character variables, CHARZ, which is blank-padded and null-terminated.</p>
<p>Use the CHAR_MAP precompiler option to change the default datatype, as follows:</p>
<pre>#include &lt;sqlca.h&gt;
#include &lt;sqlucs2.h&gt;

main()
{
   utext employee1[20] ;

/* Change to STRING datatype:    */
   EXEC ORACLE OPTION (CHAR_MAP=STRING) ;
   utext employee2[20] ;

   EXEC SQL CREATE TABLE emp (ename CHAR(60)) ;
   ...
/***********************************************************  
  Initializing employee1 or employee2 is compiler-dependent.   
 **********************************************************/
   EXEC SQL INSERT INTO emp (ename) VALUES (:employee1) ;
   ...
   EXEC SQL SELECT ename INTO :employee2 FROM emp;
/* employee2 is now not blank-padded and is null-terminated  */
   ...
</pre>
<div id="LNPCC3274" class="sect3"><a id="sthref605"></a>
<h4 class="sect3">Restrictions on Unicode Variable Usage</h4>
<ul>
<li>
<p>Static and dynamic SQL cannot contain Unicode in the SQL statement text. The following is <span class="italic">not</span> permitted:</p>
</li>
</ul>
<pre>#include oratypes.h
utext sqlstmt[100] ;
...
/* If sqlstmt contains a SQL statement: */
EXEC SQL PREPARE s1 FROM :sqlstmt ;
EXEC SQL EXECUTE IMMEDIATE :sqlstmt ;
...
</pre>
<ul>
<li>
<p>You cannot use type equivalencing for utext variables. The following code is <span class="italic">not</span> permitted:</p>
</li>
</ul>
<pre>    typedef utext utext_5 ;
    EXEC SQL TYPE utext_5 IS STRING ;
</pre>
<ul>
<li>
<p>CONVBUFSZ cannot be used as a conversion buffer size. Use the CHAR_MAP option instead.</p>
</li>
<li>
<p>Oracle dynamic SQL method 4 does not support Unicode.</p>
</li>
<li>
<p>Object types do not support Unicode.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_04dat.htm#i22733">&#34;CONVBUFSZ Clause in VAR&#34;</a></p>
</li>
<li>
<p><a href="pc_14ady.htm#i1011699">Chapter 14, &#34; ANSI Dynamic SQL&#34;</a> describes the ANSI dynamic SQL method 4</p>
</li>
<li>
<p><a href="pc_17obj.htm#g480794">Chapter 17, &#34;Objects&#34;</a> describes object types</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i430172"></a>
<div id="LNPCC3275" class="sect1">
<h2 class="sect1">Datatype Conversion <a id="sthref606"></a></h2>
<p>At precompile time, a default external datatype is assigned to each host variable. For example, the precompiler assigns the INTEGER external datatype to host variables of type <span class="bold">short int</span> and <span class="bold">int</span>.</p>
<p>At run time, the datatype code of every host variable used in a SQL statement is passed to Oracle. Oracle uses the codes to convert between internal and external datatypes.</p>
<p>Before assigning a SELECTed column (or pseudocolumn) value to an output host variable, Oracle must convert the internal datatype of the source column to the datatype of the host variable. Likewise, before assigning or comparing the value of an input host variable to a column, Oracle must convert the external datatype of the host variable to the internal datatype of the target column.<a id="sthref607"></a></p>
<p>Conversions between internal and external datatypes follow the usual data conversion rules. For example, you can convert a CHAR value of &#34;1234&#34; to a C <span class="italic">short</span> value. You cannot convert a CHAR value of &#34;65543&#34; (number too large) or &#34;10F&#34; (number not decimal) to a C <span class="italic">short</span> value. Likewise, you cannot convert a <code>char[n]</code> value that contains any alphabetic characters to a NUMBER value.</p>
</div>
<!-- class="sect1" -->
<a id="i430180"></a>
<div id="LNPCC3276" class="sect1">
<h2 class="sect1">Datatype Equivalencing <a id="sthref608"></a></h2>
<p>Datatype equivalencing lets you control the way Oracle interprets input data, and the way Oracle formats output data. It provides the ability to override the default external datatypes that the precompiler assigns. On a variable-by-variable basis, you can map (or make equivalent) supported C host variable datatypes to Oracle external datatypes. You can also map user-defined datatypes to Oracle external datatypes.</p>
<a id="i430184"></a>
<div id="LNPCC3277" class="sect2">
<h3 class="sect2">Host Variable Equivalencing</h3>
<p>By default, the Pro*C/C++ Precompiler assigns a specific external datatype to every host variable.</p>
<p><a href="#g449968">Table 5-2</a> lists the default assignments:</p>
<div id="LNPCC3278" class="tblformal">
<p class="titleintable"><a id="sthref609"></a><a id="g449968"></a>Table 5-2 Default Type Assignments</p>
<table class="cellalignment831" title=" Default Type Assignments" summary="Default Type Assignments" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t5">C Type, or Pseudotype</th>
<th class="cellalignment832" id="r1c2-t5">Oracle External Type</th>
<th class="cellalignment832" id="r1c3-t5">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t5" headers="r1c1-t5">
<p>char</p>
<p>char[n]</p>
<p>char*</p>
</td>
<td class="cellalignment833" headers="r2c1-t5 r1c2-t5">
<p>VARCHAR2</p>
<p>CHARZ</p>
<p>STRING</p>
<p>CHARF</p>
</td>
<td class="cellalignment833" headers="r2c1-t5 r1c3-t5">
<p>(CHAR_MAP=VARCHAR2)</p>
<p>(DBMS=V7, V8 default)</p>
<p>(CHAR_MAP=STRING)</p>
<p>(CHAR_MAP=CHARF)</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t5" headers="r1c1-t5">
<p>int, int*</p>
</td>
<td class="cellalignment833" headers="r3c1-t5 r1c2-t5">
<p>INTEGER</p>
</td>
<td class="cellalignment833" headers="r3c1-t5 r1c3-t5">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t5" headers="r1c1-t5">
<p>short, short*</p>
</td>
<td class="cellalignment833" headers="r4c1-t5 r1c2-t5">
<p>INTEGER</p>
</td>
<td class="cellalignment833" headers="r4c1-t5 r1c3-t5">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t5" headers="r1c1-t5">
<p>long, long*</p>
</td>
<td class="cellalignment833" headers="r5c1-t5 r1c2-t5">
<p>INTEGER</p>
</td>
<td class="cellalignment833" headers="r5c1-t5 r1c3-t5">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t5" headers="r1c1-t5">
<p>long long, long long*</p>
</td>
<td class="cellalignment833" headers="r6c1-t5 r1c2-t5">
<p>INTEGER</p>
</td>
<td class="cellalignment833" headers="r6c1-t5 r1c3-t5">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t5" headers="r1c1-t5">
<p>float, float*</p>
</td>
<td class="cellalignment833" headers="r7c1-t5 r1c2-t5">
<p>FLOAT</p>
</td>
<td class="cellalignment833" headers="r7c1-t5 r1c3-t5">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t5" headers="r1c1-t5">
<p>double, double*</p>
</td>
<td class="cellalignment833" headers="r8c1-t5 r1c2-t5">
<p>FLOAT</p>
</td>
<td class="cellalignment833" headers="r8c1-t5 r1c3-t5">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t5" headers="r1c1-t5">
<p>VARCHAR*, VARCHAR[n]</p>
</td>
<td class="cellalignment833" headers="r9c1-t5 r1c2-t5">
<p>VARCHAR</p>
</td>
<td class="cellalignment833" headers="r9c1-t5 r1c3-t5">
<p>-</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>With the VAR statement, you can override the default assignments by equivalencing host variables to Oracle external datatypes. The syntax you use is<a id="sthref610"></a></p>
<pre>EXEC SQL VAR host_variable IS type_name [ (length) ]; 
</pre>
<p>where <span class="italic">host_variable</span> is an input or output host variable (or host array) declared earlier, <span class="italic">type_name</span> is the name of a valid external datatype, and <span class="italic">length</span> is an integer literal specifying a valid length in bytes.</p>
<p>Host variable equivalencing is useful in several ways. For example, suppose you want to SELECT employee names from the EMP table, then pass them to a routine that expects null-terminated strings. You need not explicitly null-terminate the names. Simply equivalence a host variable to the STRING external datatype, as follows:</p>
<pre>... 
char  emp_name[11]; 
EXEC SQL VAR emp_name IS STRING(11); 
</pre>
<p>The length of the ENAME column in the EMP table is 10 characters, so you allot the new <span class="italic">emp_name</span> 11 characters to accommodate the null terminator. When you SELECT a value from the ENAME column into <span class="italic">emp_name</span>, the program interface null-terminates the value for you.</p>
<p>You can use any external datatypes except NUMBER (for example, VARNUM).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_04dat.htm#g39803">&#34;Oracle External Datatypes&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i430275"></a>
<div id="LNPCC3279" class="sect2">
<h3 class="sect2">User-Defined Type Equivalencing</h3>
<p>You can also map (or make equivalent) user-defined datatypes to Oracle external datatypes. First, define a new datatype structured like the external datatype that suits your needs. Then, map your new datatype to the external datatype using the TYPE statement.</p>
<p>With the TYPE statement, you can assign an Oracle external datatype to a whole class of host variables. The syntax you use is:<a id="sthref611"></a></p>
<pre>EXEC SQL TYPE user_type IS type_name [ (length) ] [REFERENCE]; 
</pre>
<p>Suppose you need a variable-length string datatype to hold graphics characters. First, declare a struct with a <span class="bold">short</span> length component followed by a 65533-byte data component. Second, use <span class="bold">typedef</span> to define a new datatype based on the struct. Then, equivalence your new user-defined datatype to the VARRAW external datatype, as shown in the following example:</p>
<pre>struct  screen 
{ 
    short  len; 
    char   buff[4000]; 
}; 
typedef struct screen graphics; 

EXEC SQL TYPE graphics IS VARRAW(4000); 
graphics  crt;  &mdash; host variable of type graphics 
    ... 
</pre>
<p>You specify a length of 4000 bytes for the new <span class="italic">graphics</span> type because that is the maximum length of the data component in your struct. The precompiler allows for the <span class="italic">len</span> component (and any padding) when it sends the length to the Oracle server.</p>
<div id="LNPCC3280" class="sect3"><a id="sthref612"></a>
<h4 class="sect3">REFERENCE Clause</h4>
<p>You can declare a user-defined type to be a pointer, either explicitly, as a pointer to a scalar or struct type, or implicitly, as an array, and use this type in an EXEC SQL TYPE statement. In this case, you must use the REFERENCE clause at the end of the statement, as shown in the following example: <a id="sthref613"></a></p>
<pre>typedef unsigned char *my_raw; 
 
EXEC SQL TYPE my_raw IS VARRAW(4000) REFERENCE; 
my_raw    graphics_buffer; 
... 
graphics_buffer = (my_raw) malloc(4004); 
</pre>
<p>In this example, you allocated additional memory over the type length (4000). This is necessary because the precompiler also returns the length (the size of a <span class="italic">short</span>), and can add padding after the length due to word alignment restrictions on your system. If you do not know the alignment practices on your system, make sure to allocate sufficient extra bytes for the length and padding (9 should usually be sufficient).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_04dat.htm#i24296">&#34;Example Program: Using sqlvcp()&#34;</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3281" class="sect2"><a id="sthref614"></a>
<h3 class="sect2">CHARF External Datatype</h3>
<p><a id="sthref615"></a>CHARF is a fixed-length character string. You can use this datatype in VAR and TYPE statements to equivalence C datatypes to the fixed-length SQL standard datatype CHAR, regardless of the setting of the DBMS or CHAR_MAP option.</p>
<p>When DBMS=V7 or V8, specifying the external datatype CHARACTER in a VAR or TYPE statement equivalences the C datatype to the fixed-length datatype CHAR (datatype code 96). However, when CHAR_MAP=VARCHAR2, the C datatype is equivalenced to the variable-length datatype VARCHAR2 (code 1).<a id="sthref616"></a><a id="sthref617"></a></p>
<p>Now, you can always equivalence C datatypes to the fixed-length SQL standard type CHARACTER by using the CHARF datatype in the VAR or TYPE statement. When you use CHARF, the equivalence is always made to the fixed-length character type, regardless of the setting of the DBMS or CHAR_MAP option.</p>
</div>
<!-- class="sect2" -->
<a id="i430313"></a>
<div id="LNPCC3282" class="sect2">
<h3 class="sect2">The EXEC SQL VAR and TYPE Directives</h3>
<p>You can code an EXEC SQL VAR ... or EXEC SQL TYPE ... statement anywhere in your program. These statements are treated as executable statements that change the datatype of any variable affected by them from the point that the TYPE or VAR statement was made to the end of the scope of the variable. If you precompile with MODE=ANSI, you must use Declare Sections. In this case, the TYPE or VAR statement must be in a Declare Section.<a id="sthref618"></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_afemb.htm#CHEJAJGB">&#34;TYPE (Oracle Embedded SQL Directive)&#34;</a></p>
</li>
<li>
<p><a href="pc_afemb.htm#CHEDHEEB">&#34;VAR (Oracle Embedded SQL Directive)&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3283" class="sect2"><a id="sthref619"></a>
<h3 class="sect2">Example: Datatype Equivalencing (sample4.pc)<a id="sthref620"></a>:</h3>
<p>The demonstration program in this section shows you how you can use datatype equivalencing in your Pro*C/C++ programs. This program is available as <code>sample4.pc</code> in the <code>dem</code>o directory.It demonstrates the use of type equivalencing using the LONG VARRAW external datatype. In order to provide a useful example that is portable across different systems, the program inserts binary files into and retrieves them from the database.</p>
<p>This program uses LOB embedded SQL statements. See also <a href="pc_16lob.htm#g1029071">Chapter 16, &#34;LOBs&#34;</a>.</p>
<p>Please read the introductory comments for an explanation of the program&#39;s purpose.</p>
<pre>/***************************************************************
sample4.pc
This program demonstrates the use of type equivalencing using the
LONG VARRAW external datatype. In order to provide a useful example
that is portable across different systems, the program inserts
binary files into and retrieves them from the database.  For
example, suppose you have a file called &#39;hello&#39; in the current
directory.  You can create this file by compiling the following
source code:

#include &lt;stdio.h&gt;

int main()
{
  printf(&#34;Hello World!\n&#34;);
}

When this program is run, we get:

$hello
Hello World!

Here is some sample output from a run of sample4:

$sample4
Connected.
Do you want to create (or re-create) the EXECUTABLES table (y/n)? y
EXECUTABLES table successfully dropped.  Now creating new table...
EXECUTABLES table created.

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: l

Executables           Length (bytes)
--------------------  --------------

Total Executables: 0

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: i
Enter the key under which you will insert this executable: hello
Enter the filename to insert under key &#39;hello&#39;.
If the file is not in the current directory, enter the full
path: hello
Inserting file &#39;hello&#39; under key &#39;hello&#39;...
Inserted.

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: l

Executables           Length (bytes)
--------------------  --------------
hello                           5508

Total Executables: 1

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: r
Enter the key for the executable you wish to retrieve: hello
Enter the file to write the executable stored under key hello into.  If you
don&#39;t want the file in the current directory, enter the
full path: h1
Retrieving executable stored under key &#39;hello&#39; to file &#39;h1&#39;...
Retrieved.

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: q

We now have the binary file &#39;h1&#39; created, and we can run it:

$h1
Hello World!
***************************************************************/

#include &lt;oci.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlcpr.h&gt;

/* Oracle error code for &#39;table or view does not exist&#39;. */
#define NON_EXISTENT  -942
#define NOT_FOUND     1403

/* This is the definition of the long varraw structure.
 * Note that the first field, len, is a long instead
 * of a short.  This is becuase the first 4
 * bytes contain the length, not the first 2 bytes.
 */
typedef struct long_varraw {
  ub4  len;
  text buf[1];
} long_varraw;


/* Type Equivalence long_varraw to LONG VARRAW.
 * All variables of type long_varraw from this point
 * on in the file will have external type 95 (LONG VARRAW)
 * associated with them.
 */
EXEC SQL TYPE long_varraw IS LONG VARRAW REFERENCE;


/* This program&#39;s functions declared. */
#if defined(__STDC__)
  void do_connect(void);
  void create_table(void);
  void sql_error(char *);
  void list_executables(void);
  void print_menu(void);
  void do_insert(varchar *, char *);
  void do_retrieve(varchar *, char *);
  void do_delete(varchar *);
  ub4  read_file(char *, OCIBlobLocator *);
  void write_file(char *, OCIBlobLocator *);
#else
  void do_connect(/*_ void _*/);
  void create_table(/*_ void _*/);
  void sql_error(/*_ char * _*/);
  void list_executables(/*_ void _*/);
  void print_menu(/*_ void _*/);
  void do_insert(/*_ varchar *, char * _*/);
  void do_retrieve(/*_ varchar *, char * _*/);
  void do_delete(/*_ varchar * _*/);
  ub4  read_file(/*_ char *, OCIBlobLocator * _*/);
  void write_file(/*_ char *, OCIBlobLocator * _*/);
#endif

void main()
{
  char reply[20], filename[100];
  varchar key[20];
  short ok = 1;

  /* Connect to the database. */
  do_connect();

  printf(&#34;Do you want to create (or re-create) the EXECUTABLES table (y/n)? &#34;);
  gets(reply);

  if ((reply[0] == &#39;y&#39;) || (reply[0] == &#39;Y&#39;))
    create_table();

  /* Print the menu, and read in the user&#39;s selection. */
  print_menu();
  gets(reply);

  while (ok)
  {
    switch(reply[0]) {
    case &#39;I&#39;: case &#39;i&#39;:
      /* User selected insert - get the key and file name. */
      printf(&#34;Enter the key under which you will insert this executable: &#34;);
      key.len = strlen(gets((char *)key.arr));
      printf(&#34;Enter the filename to insert under key &#39;%.*s&#39;.\n&#34;,
             key.len, key.arr);
      printf(&#34;If the file is not in the current directory, enter the full\n&#34;);
      printf(&#34;path: &#34;);
      gets(filename);
      do_insert((varchar *)&amp;key, filename);
      break;
    case &#39;R&#39;: case &#39;r&#39;:
      /* User selected retrieve - get the key and file name. */
      printf(&#34;Enter the key for the executable you wish to retrieve: &#34;);
      key.len = strlen(gets((char *)key.arr));
      printf(&#34;Enter the file to write the executable stored under key &#34;);
      printf(&#34;%.*s into.  If you\n&#34;, key.len, key.arr);
      printf(&#34;don&#39;t want the file in the current directory, enter the\n&#34;);
      printf(&#34;full path: &#34;);
      gets(filename);
      do_retrieve((varchar *)&amp;key, filename);
      break;
    case &#39;L&#39;: case &#39;l&#39;:
      /* User selected list - just call the list routine. */
      list_executables();
      break;
    case &#39;D&#39;: case &#39;d&#39;:
      /* User selected delete - get the key for the executable to delete. */
      printf(&#34;Enter the key for the executable you wish to delete: &#34;);
      key.len = strlen(gets((char *)key.arr));
      do_delete((varchar *)&amp;key);
      break;
    case &#39;Q&#39;: case &#39;q&#39;:
      /* User selected quit - just end the loop. */
      ok = 0;
      break;
    default:
      /* Invalid selection. */
      printf(&#34;Invalid selection.\n&#34;);
      break;
    }

    if (ok)
    {
      /* Print the menu again. */
      print_menu();
      gets(reply);
    }
  }

  EXEC SQL COMMIT WORK RELEASE;
}


/* Connect to the database. */
void do_connect()
{
  /* Note this declaration: uid is a char * pointer, so Oracle
     will do a strlen() on it at runtime to determine the length.
   */
  char *uid = &#34;scott/tiger&#34;;

  EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;do_connect():CONNECT&#34;);
  EXEC SQL CONNECT :uid;

  printf(&#34;Connected.\n&#34;);
}


/* Creates the executables table. */
void create_table()
{
  /* We are going to check for errors ourselves for this statement. */
  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL DROP TABLE EXECUTABLES;
  if (sqlca.sqlcode == 0)
    {
      printf(&#34;EXECUTABLES table successfully dropped.  &#34;);
      printf(&#34;Now creating new table...\n&#34;);
    }
  else if (sqlca.sqlcode == NON_EXISTENT)
    {
      printf(&#34;EXECUTABLES table does not exist.  &#34;);
      printf(&#34;Now creating new table...\n&#34;);
    }
  else
    sql_error(&#34;create_table()&#34;); 

  /* Reset error handler. */
  EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;create_table():CREATE TABLE&#34;);

  EXEC SQL CREATE TABLE EXECUTABLES
    ( name VARCHAR2(30), length NUMBER(10), binary BLOB ) ;

  printf(&#34;EXECUTABLES table created.\n&#34;);
}

/* Opens the binary file identified by &#39;filename&#39; for reading, and writes
   it into into a Binary LOB.  Returns the actual length of the file read.
 */
ub4 read_file(filename, blob)
  char *filename;
  OCIBlobLocator *blob;
{
  long_varraw *lvr;
  ub4      bufsize;
  ub4      amt;
  ub4      filelen, remainder, nbytes;
  ub4      offset = 1;
  boolean  last = FALSE;
  FILE    *in_fd;

  /* Open the file for reading. */
  in_fd = fopen(filename, &#34;r&#34;);
  if (in_fd == (FILE *)0)
    return (ub4)0;

  /* Determine Total File Length - Total Amount to Write to BLOB */
  (void) fseek(in_fd, 0L, SEEK_END);
  amt = filelen = (ub4)ftell(in_fd);

  /* Determine the Buffer Size and Allocate the LONG VARRAW Object */
  bufsize = 2048;
  lvr = (long_varraw *)malloc(sizeof(ub4) + bufsize);

  nbytes = (filelen &gt; bufsize) ? bufsize : filelen;
      
  /* Reset the File Pointer and Perform the Initial Read */
  (void) fseek(in_fd, 0L, SEEK_SET);
  lvr-&gt;len = fread((void *)lvr-&gt;buf, (size_t)1, (size_t)nbytes, in_fd);
  remainder = filelen - nbytes;

  EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;read_file():WRITE&#34;);

  if (remainder == 0)
    {
      /* Write the BLOB in a Single Piece */
      EXEC SQL LOB WRITE ONE :amt
         FROM :lvr WITH LENGTH :nbytes INTO :blob AT :offset;
    }
  else
    {
      /* Write the BLOB in Multiple Pieces using Standard Polling */
      EXEC SQL LOB WRITE FIRST :amt
         FROM :lvr WITH LENGTH :nbytes INTO :blob AT :offset;

      do {

        if (remainder &gt; bufsize)
          nbytes = bufsize;
        else
          {
            nbytes = remainder;
            last = TRUE;
          }

        if ((lvr-&gt;len = fread(
              (void *)lvr-&gt;buf, (size_t)1, (size_t)nbytes, in_fd)) != nbytes)
          last = TRUE;

        if (last)
          {
            /* Write the Final Piece */
            EXEC SQL LOB WRITE LAST :amt
               FROM :lvr WITH LENGTH :nbytes INTO :blob;
          }
        else
          {
            /* Write an Interim Piece - Still More to Write */
            EXEC SQL LOB WRITE NEXT :amt
               FROM :lvr WITH LENGTH :nbytes INTO :blob;  
          }

        remainder -= nbytes;

      } while (!last &amp;&amp; !feof(in_fd));
    }

  /* Close the file, and return the total file size. */
  fclose(in_fd);
  free(lvr);
  return filelen;
}


/* Generic error handler.  The &#39;routine&#39; parameter should contain the name
   of the routine executing when the error occured.  This would be specified
   in the &#39;EXEC SQL WHENEVER SQLERROR DO sql_error()&#39; statement.
 */
void sql_error(routine)
  char *routine;
{
  char message_buffer[512];
  size_t buffer_size;
  size_t message_length;

  /* Turn off the call to sql_error() to avoid a possible infinite loop */
  EXEC SQL WHENEVER SQLERROR CONTINUE;

  printf(&#34;\nOracle error while executing %s!\n&#34;, routine);

  /* Use sqlglm() to get the full text of the error message. */
  buffer_size = sizeof(message_buffer);
  sqlglm(message_buffer, &amp;buffer_size, &amp;message_length);
  printf(&#34;%.*s\n&#34;, message_length, message_buffer);

  EXEC SQL ROLLBACK WORK RELEASE;
  exit(1);
}


/* Opens the binary file identified by &#39;filename&#39; for writing, and copies
   the contents of the Binary LOB into it.
 */
void write_file(filename, blob)
  char *filename;
  OCIBlobLocator *blob;
{
  FILE        *out_fd;       /* File descriptor for the output file */
  ub4          amt;
  ub4          bufsize;
  long_varraw *lvr;

  /* Determine the Buffer Size and Allocate the LONG VARRAW Object */
  bufsize = 2048;
  lvr = (long_varraw *)malloc(sizeof(ub4) + bufsize);

  /* Open the output file for Writing */
  out_fd = fopen(filename, &#34;w&#34;);
  if (out_fd == (FILE *)0)
    return;

  amt = 0;             /* Initialize for Standard Polling (Possibly) */
  lvr-&gt;len = bufsize;                       /* Set the Buffer Length */

  EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;write_file():READ&#34;);

  /* READ the BLOB using a Standard Polling Loop */
  EXEC SQL WHENEVER NOT FOUND DO break;
  while (TRUE)
    {
      EXEC SQL LOB READ :amt FROM :blob INTO :lvr WITH LENGTH :bufsize;
      (void) fwrite((void *)lvr-&gt;buf, (size_t)1, (size_t)lvr-&gt;len, out_fd);
    }
  
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  /* Write the Final Piece (or First and Only Piece if not Polling) */
  (void) fwrite((void *)lvr-&gt;buf, (size_t)lvr-&gt;len, (size_t)1, out_fd);

  /* Close the Output File and Return */
  fclose(out_fd);
  free(lvr);
  return;
}



/* Inserts the binary file identified by file into the
 * executables table identified by key.
 */
void do_insert(key, file)
  varchar *key;
  char *file;
{
  OCIBlobLocator *blob;
  ub4 loblen, fillen;

  EXEC SQL ALLOCATE :blob;

  EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;do_insert():INSERT/SELECT&#34;);

  EXEC SQL SAVEPOINT PREINSERT;
  EXEC SQL INSERT
    INTO executables (name, length, binary) VALUES (:key, 0, empty_blob());

  EXEC SQL SELECT binary INTO :blob 
             FROM executables WHERE name = :key FOR UPDATE;

  printf(
    &#34;Inserting file &#39;%s&#39; under key &#39;%.*s&#39;...\n&#34;, file, key-&gt;len, key-&gt;arr); 

  fillen = read_file(file, blob);
  EXEC SQL LOB DESCRIBE :blob GET LENGTH INTO :loblen;

  if ((fillen == 0) || (fillen != loblen))
    {
      printf(&#34;Problem reading file &#39;%s&#39;\n&#34;, file);
      EXEC SQL ROLLBACK TO SAVEPOINT PREINSERT;
      EXEC SQL FREE :blob;
      return;
    }

  EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;do_insert():UPDATE&#34;);
  EXEC SQL UPDATE executables
    SET length = :loblen, binary = :blob WHERE name = :key;

  EXEC SQL COMMIT WORK;

  EXEC SQL FREE :blob;
  EXEC SQL COMMIT;
  printf(&#34;Inserted.\n&#34;);
}


/* Retrieves the executable identified by key into file */
void do_retrieve(key, file)
  varchar *key;
  char *file;
{
  OCIBlobLocator *blob;

  printf(&#34;Retrieving executable stored under key &#39;%.*s&#39; to file &#39;%s&#39;...\n&#34;,
         key-&gt;len, key-&gt;arr, file);

  EXEC SQL ALLOCATE :blob;

  EXEC SQL WHENEVER NOT FOUND continue;
  EXEC SQL SELECT binary INTO :blob FROM executables WHERE name = :key;

  if (sqlca.sqlcode == NOT_FOUND)
    printf(&#34;Key &#39;%.*s&#39; not found!\n&#34;, key-&gt;len, key-&gt;arr);
  else 
    {
      write_file(file, blob);
      printf(&#34;Retrieved.\n&#34;);
    }
 
  EXEC SQL FREE :blob;
}


/* Delete an executable from the database */
void do_delete(key)
  varchar *key;
{
  EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;do_delete():DELETE&#34;);
  EXEC SQL DELETE FROM executables WHERE name = :key;

  if (sqlca.sqlcode == NOT_FOUND)
    printf(&#34;Key &#39;%.*s&#39; not found!\n&#34;, key-&gt;len, key-&gt;arr);
  else
    printf(&#34;Deleted.\n&#34;);
}


/* List all executables currently stored in the database */
void list_executables()
{
  char key[21];
  ub4  length;

  EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;list_executables&#34;);

  EXEC SQL DECLARE key_cursor CURSOR FOR
    SELECT name, length FROM executables;

  EXEC SQL OPEN key_cursor;

  printf(&#34;\nExecutables           Length (bytes)\n&#34;);
  printf(&#34;--------------------  --------------\n&#34;);

  EXEC SQL WHENEVER NOT FOUND DO break;
  while (1)
  {
    EXEC SQL FETCH key_cursor INTO :key, :length;
    printf(&#34;%s      %10d\n&#34;, key, length);
  }

  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL CLOSE key_cursor;

  printf(&#34;\nTotal Executables: %d\n&#34;, sqlca.sqlerrd[2]);  
}


/* Prints the menu selections. */
void print_menu()
{
  printf(&#34;\nSample 4 Menu.  Would you like to:\n&#34;);
  printf(&#34;(I)nsert a new executable into the database\n&#34;);
  printf(&#34;(R)etrieve an executable from the database\n&#34;);
  printf(&#34;(L)ist the executables stored in the database\n&#34;);
  printf(&#34;(D)elete an executable from the database\n&#34;);
  printf(&#34;(Q)uit the program\n\n&#34;);
  printf(&#34;Enter i, r, l, or q: &#34;);
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i431189"></a>
<div id="LNPCC3284" class="sect1">
<h2 class="sect1">The C Preprocessor<a id="sthref621"></a><a id="sthref622"></a></h2>
<p>Pro*C/C++ supports most C preprocessor directives. Some of the things that you can do using the Pro*C/C++ preprocessor are:</p>
<ul>
<li>
<p>Define constants and macros using the <span class="bold">#define</span> directive, and use the defined entities to parameterize Pro*C/C++ datatype declarations, such as VARCHAR</p>
</li>
<li>
<p>Read files required by the precompiler, such as <code>sqlca.h</code>, using the <span class="bold">#include</span> directive</p>
</li>
<li>
<p>Define constants and macros in a separate file, and have the precompiler read this file using the <span class="bold">#include</span> directive</p>
</li>
</ul>
<div id="LNPCC3285" class="sect2"><a id="sthref623"></a>
<h3 class="sect2">How the Pro*C/C++ Preprocessor Works</h3>
<p>The Pro*C/C++ preprocessor recognizes most C preprocessor commands, and effectively performs the required macro substitutions, file inclusions, and conditional source text inclusions or exclusions. The Pro*C/C++ preprocessor uses the values obtained from preprocessing, and alters the source output text (the generated <code>.c</code> output file).</p>
<p>An example should clarify this point. Consider the following program fragment: <a id="sthref624"></a></p>
<pre>#include &#34;my_header.h&#34; 
... 
VARCHAR name[VC_LEN];              /* a Pro*C-supplied datatype */ 
char    another_name[VC_LEN];              /* a pure C datatype */
... 
</pre>
<p>Suppose the file <code>my_header.h</code> in the current directory contains, among other things, the line</p>
<pre>#define VC_LEN   20 
</pre>
<p>The precompiler reads the file <code>my_header.h</code>, and uses the defined value of VC_LEN (20), declares the structure of <span class="italic">name</span> as VARCHAR[20].</p>
<p><span class="bold">char</span> is a native type. The precompiler does not substitute 20 in the declaration of another_name[VC_LEN].</p>
<p>This does not matter, since the precompiler does not need to process declarations of C datatypes, even when they are used as host variables. It is left up to the C compiler&#39;s preprocessor to actually include the file <code>my_header.h</code>, and perform the substitution of 20 for VC_LEN in the declaration of <span class="italic">another_name</span>.<a id="sthref625"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3286" class="sect2"><a id="sthref626"></a>
<h3 class="sect2">Preprocessor Directives</h3>
<p>The preprocessor directives that Pro*C/C++ supports are:</p>
<ul>
<li>
<p><span class="bold">#define</span>, to create macros for use by the precompiler and the C or C++ compiler</p>
</li>
<li>
<p><span class="bold">#include</span>, to read other source files for use by the precompiler</p>
</li>
<li>
<p><span class="bold">#if</span>, to precompile and compile source text based on evaluation of a constant expression to 0</p>
</li>
<li>
<p><span class="bold">#ifdef</span>, to precompile and compile source text conditionally, depending on the existence of a defined constant</p>
</li>
<li>
<p><span class="bold">#ifndef</span>, to exclude source text conditionally</p>
</li>
<li>
<p><span class="bold">#endif</span>, to end an <span class="bold">#if</span> or <span class="bold">#ifdef</span> or <span class="bold">#ifndef</span> command</p>
</li>
<li>
<p><span class="bold">#else</span>, to select an alternative body of source text to be precompiled and compiled, in case an <span class="bold">#if</span> or <span class="bold">#ifdef</span> or <span class="bold">#ifndef</span> condition is not satisfied</p>
</li>
<li>
<p><span class="bold">#elif</span>, to select an alternative body of source text to be precompiled and compiled, depending on the value of a constant or a macro argument</p>
</li>
</ul>
<a id="i429549"></a>
<div id="LNPCC3287" class="sect3">
<h4 class="sect3">Directives Ignored</h4>
<p>Some C preprocessor directives are not used by the Pro*C/C++ preprocessor. Most of these directives are not relevant for the precompiler. For example, <span class="bold">#pragma</span> is a directive for the C compiler&mdash;the precompiler does not process it. The C preprocessor directives not processed by the precompiler are: <a id="sthref627"></a></p>
<ul>
<li>
<p><span class="bold">#</span>, to convert a preprocessor macro parameter to a string constant</p>
</li>
<li>
<p><span class="bold">##</span>, to merge two preprocessor tokens in a macro definition</p>
</li>
<li>
<p><span class="bold">#error</span>, to produce a compile-time error message</p>
</li>
<li>
<p><span class="bold">#pragma</span>, to pass implementation-dependent information to the C compiler</p>
</li>
<li>
<p><span class="bold">#line</span>, to supply a line number for C compiler messages</p>
</li>
</ul>
<p>While your C compiler preprocessor may support these directives, Pro*C/C++ does not use them. Most of these directives are not used by the precompiler. You can use these directives in your Pro*C/C++ program if your compiler supports them, but only in C or C++ code, not in embedded SQL statements or declarations of variables using datatypes supplied by the precompiler, such as VARCHAR.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3288" class="sect2"><a id="sthref628"></a>
<h3 class="sect2">ORA_PROC Macro</h3>
<p>Pro*C/C++ predefines a C preprocessor macro called ORA_PROC that you can use to avoid having the precompiler process unnecessary or irrelevant sections of code. Some applications include large header files, which provide information that is unnecessary when precompiling. By conditionally excluding such header files based on the ORA_PROC macro, the precompiler never reads the file.</p>
<p>The following example uses the ORA_PROC macro to exclude the <code>irrelevant.h</code> file:</p>
<pre>#ifndef  ORA_PROC
#include &lt;irrelevant.h&gt;
#endif
</pre>
<p>Because ORA_PROC is defined during precompilation, the <code>irrelevant.h</code> file is never included.</p>
<p>The ORA_PROC macro is available only for C preprocessor directives, such as <span class="bold">#ifdef</span> or <span class="bold">#ifndef</span>. The EXEC ORACLE conditional statements do <span class="italic">not</span> share the same namespaces as the C preprocessor macros. Therefore, the condition in the following example does <span class="italic">not</span> use the predefined ORA_PROC macro:</p>
<pre>EXEC ORACLE IFNDEF ORA_PROC;
   &lt;section of code to be ignored&gt;
EXEC ORACLE ENDIF;
</pre>
<p>ORA_PROC, in this case, must be set using either the DEFINE option or an EXEC ORACLE DEFINE statement for this conditional code fragment to work properly.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3289" class="sect2"><a id="sthref629"></a>
<h3 class="sect2">Location of Header File Specification</h3>
<p>The Pro*C/C++ Precompiler for each system assumes a standard location for header files to be read by the preprocessor, such as <code>sqlca.h</code>, <code>oraca.h</code>, and <code>sqlda.h</code>. For example, on most UNIX systems, the standard location is <code>$ORACLE_HOME/precomp/public</code>. For the default location on your system, see your system-specific Oracle documentation. If header files that you need to include are not in the default location, you must use the INCLUDE= option, on the command line or as an EXEC ORACLE option.</p>
<p>To specify the location of system header files, such as <code>stdio.h</code> or <code>iostream.h</code>, where the location might be different from that hard-coded into Pro*C/C++ use the SYS_INCLUDE precompiler option.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#g30455">Chapter 10, &#34; Precompiler Options&#34;</a> for information on the precompiler options, and about the EXEC ORACLE options. <a id="sthref630"></a><a id="sthref631"></a></div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3290" class="sect2"><a id="sthref632"></a>
<h3 class="sect2">Some Preprocessor Examples</h3>
<p>You can use the <span class="bold">#define</span> command to create named constants, and use them in place of &#34;magic numbers&#34; in your source code. You can use <span class="bold">#define</span>d constants for declarations that the precompiler requires, such as VARCHAR[const]. For example, instead of code with bugs, such as:</p>
<pre>... 
VARCHAR  emp_name[10]; 
VARCHAR  dept_loc[14]; 
... 
... 
/* much later in the code ... */ 
f42() 
{ 
    /* did you remember the correct size? */
    VARCHAR new_dept_loc[10]; 
   ... 
} 
</pre>
<p>you can code:</p>
<pre>#define ENAME_LEN     10 
#define LOCATION_LEN  14 
VARCHAR  new_emp_name[ENAME_LEN]; 
   ... 
/* much later in the code ... */ 
f42() 
{ 
    VARCHAR new_dept_loc[LOCATION_LEN]; 
   ... 
} 
</pre>
<p>You can use preprocessor macros with arguments for objects that the precompiler must process, just as you can for C objects. For example:</p>
<pre>#define ENAME_LEN    10 
#define LOCATION_LEN 14 
#define MAX(A,B)  ((A) &gt; (B) ? (A) : (B)) 
 
   ... 
f43() 
{ 
    /* need to declare a temporary variable to hold either an 
       employee name or a department location */ 
    VARCHAR  name_loc_temp[MAX(ENAME_LEN, LOCATION_LEN)]; 
   ... 
} 
</pre>
<p>You can use the <span class="bold">#include</span>, <span class="bold">#ifdef</span> and <span class="bold">#endif</span> preprocessor directives to conditionally include a file that the precompiler requires. For example:</p>
<pre>#ifdef ORACLE_MODE 
#include &lt;sqlca.h&gt; 
#else 
    long SQLCODE; 
#endif 
</pre>
<div id="LNPCC3291" class="sect3"><a id="sthref633"></a>
<h4 class="sect3">Using #define</h4>
<p>There are restrictions on the use of the <span class="bold">#define</span> preprocessor directive in Pro*C/C++ You cannot use the <span class="bold">#define</span> directive to create symbolic constants for use in <span class="italic">executable</span> SQL statements. The following <span class="italic">invalid</span> example demonstrates this: <a id="sthref634"></a></p>
<pre>#define RESEARCH_DEPT   40 
... 
EXEC SQL SELECT empno, sal 
    INTO :emp_number, :salary /* host arrays */
    FROM emp 
    WHERE deptno = RESEARCH_DEPT;  /* INVALID! */
</pre>
<p>The only declarative SQL statements where you can legally use a <span class="bold">#define</span>d macro are TYPE and VAR statements. So, for example, the following uses of a macro are legal in Pro*C/C++</p>
<pre>#define STR_LEN      40
...
typedef char asciiz[STR_LEN];
...
EXEC SQL TYPE asciiz IS STRING(STR_LEN) REFERENCE;
...
EXEC SQL VAR password IS STRING(STR_LEN);
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC3292" class="sect3"><a id="sthref635"></a>
<h4 class="sect3">Other Preprocessor Restrictions</h4>
<p>The preprocessor ignores directives <span class="bold">#</span> and <span class="bold">##</span> to create tokens that the precompiler must recognize. You can use these commands (if your compiler supports them) in pure C code that the precompiler does not have to process. Using the preprocessor command <span class="bold">##</span> is <span class="italic">not</span> valid in this example:</p>
<pre>#define MAKE_COL_NAME(A)    col ## A 
... 
EXEC SQL SELECT MAKE_COL_NAME(1), MAKE_COL_NAME(2) 
    INTO :x, :y 
    FROM table1; 
</pre>
<p>The example is incorrect because the precompiler ignores <span class="bold">##</span>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3293" class="sect2"><a id="sthref636"></a>
<h3 class="sect2">SQL Statements Not Allowed in #include</h3>
<p>Because of the way the Pro*C/C++ preprocessor handles the <span class="bold">#include</span> directive, as described in the previous section, you cannot use the <span class="bold">#include</span> directive to include files that contain embedded SQL statements. You use <span class="bold">#include</span> to include files that contain purely declarative statements and directives; for example, <span class="bold">#define</span>s, and declarations of variables and structures required by the precompiler, such as in <code>sqlca.h</code>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3294" class="sect2"><a id="sthref637"></a>
<h3 class="sect2">Include the SQLCA, ORACA, and SQLDA</h3>
<p>You can include the <code>sqlca.h</code>, <code>oraca.h</code>, and <code>sqlda.h</code> declaration header files in your Pro*C/C++ program using either the C/C++ preprocessor <span class="bold">#include</span> command, or the precompiler EXEC SQL INCLUDE command. For example, you use the following statement to include the SQL Communications Area structure (SQLCA) in your program with the EXEC SQL option:</p>
<pre>EXEC SQL INCLUDE sqlca; 
</pre>
<p>To include the SQLCA using the C/C++ preprocessor directive, add the following code:</p>
<pre>#include &lt;sqlca.h&gt; 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_09err.htm#g35612">Chapter 9, &#34;Handling Runtime Errors&#34;</a> for complete information on the content of the <code>sqlca.h</code>, <code>oraca.h</code>, and the <code>sqlda.h</code> header files.</div>
<p>When you use the preprocessor <span class="bold">#include</span> directive, you must specify the file extension (such as <code>.h</code>).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you need to include the SQLCA in multiple places, using the <span class="bold">#include</span> directive, you should precede the <span class="bold">#include</span> with the directive <span class="bold">#undef</span> SQLCA. This is because <code>sqlca.h</code> starts with the lines
<pre>      #ifndef SQLCA
      #define SQLCA 1
</pre>
<p>and then declares the SQLCA struct only in the case that SQLCA is not defined. <a id="sthref638"></a></p>
</div>
<p>When you precompile a file that contains a <span class="bold">#include</span> directive or an EXEC SQL INCLUDE statement, you have to tell the precompiler the location of all files to be included. You can use the INCLUDE= option, either in the command line, or in the system configuration file, or in the user configuration file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#g30455">Chapter 10, &#34; Precompiler Options&#34;</a> for more information about the INCLUDE precompiler option, the precedence of searches for included files, and configuration files.<a id="sthref639"></a></div>
<p>The default location for standard preprocessor header files, such as <code>sqlca.h</code>, <code>oraca.h</code>, and <code>sqlda.h</code>, is preset in the precompiler. The location varies from system to system. See your system-specific Oracle documentation for the default location on your system.</p>
<p>When you compile the <code>.c</code> output file that Pro*C/C++ generates, you must use the option provided by your compiler and operating system to identify the location of included files.</p>
<p>For example, on most UNIX systems, you can compile the generated C source file using the command</p>
<pre>cc -o progname -I$ORACLE_HOME/sqllib/public ... filename.c ... 
</pre>
<p>On VAX/OPENVMS systems, you pre-pend the include directory path to the value in the logical VAXC$INCLUDE.<a id="sthref640"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3295" class="sect2"><a id="sthref641"></a>
<h3 class="sect2">EXEC SQL INCLUDE and #include Summary</h3>
<p>When you use an EXEC SQL INCLUDE statement in your program, the precompiler includes the source text in the output (<code>.c</code>) file. Therefore, you can have declarative and executable embedded SQL statements in a file that is included using EXEC SQL INCLUDE.<a id="sthref642"></a></p>
<p>When you include a file using <span class="bold">#include</span>, the precompiler merely reads the file, and keeps track of <span class="bold">#define</span>d macros.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
VARCHAR declarations and SQL statements are <span class="italic">not</span> allowed in included (<code>#include</code>) files. For this reason, you cannot use SQL statements in files included using the Pro*C/C++ preprocessor <code>#include</code> directive.</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3296" class="sect2"><a id="sthref643"></a>
<h3 class="sect2">Defined Macros</h3>
<p>If you define macros on the C compiler&#39;s command line, you might also have to define these macros on the precompiler command line, depending on the requirements of your application. For example, if you compile with a UNIX command line such as<a id="sthref644"></a></p>
<pre>cc -DDEBUG ...
</pre>
<p>you should precompile using the DEFINE= option, namely</p>
<pre>proc DEFINE=DEBUG ...
</pre></div>
<!-- class="sect2" -->
<a id="i429704"></a>
<div id="LNPCC3297" class="sect2">
<h3 class="sect2">Include Files<a id="sthref645"></a></h3>
<p>The location of all included files that need to be precompiled must be specified on the command line, or in a configuration file.</p>
<p>For example, if you are developing under UNIX, and your application includes files in the directory <code>/home/project42/include</code>, you must specify this directory both on the Pro*C/C++ command line and on the <code>cc</code> command line. You use commands like these:</p>
<pre>proc iname=my_app.pc include=/home/project42/include ...
cc -I/home/project42/include ... my_app.c
</pre>
<p>or you include the appropriate macros in a <span class="italic">makefile</span>. For complete information about compiling and linking your Pro*C/C++ application, see your system-specific Oracle documentation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#i4754">&#34;INCLUDE&#34;</a>, for complete information about precompiler options and configuration files.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i433802"></a>
<div id="LNPCC3298" class="sect1">
<h2 class="sect1">Precompiled Header Files<a id="sthref646"></a></h2>
<p>Precompiled header files save time and resources by precompiling header files that contain many <code>#include</code> statements. The two steps in using this feature are:</p>
<ul>
<li>
<p>The precompiled header file is created first,</p>
</li>
<li>
<p>The precompiled header is then automatically used in subsequent precompilation of your application.</p>
</li>
</ul>
<p>Use this capability with large applications that have many modules.</p>
<p>The precompiler option, HEADER=<code>hdr</code>, specifies</p>
<ul>
<li>
<p>That precompiled headers are to be used,<a id="sthref647"></a></p>
</li>
<li>
<p>That the file extension for the output file to be generated is <code>hdr</code>.</p>
</li>
</ul>
<p>This option can only be entered in a configuration file or on the command line. There is no default value for HEADER, but the input header must have a <code>.h</code> extension.</p>
<div id="LNPCC3299" class="sect2"><a id="sthref648"></a>
<h3 class="sect2">Precompiled Header File Creation</h3>
<p>Assume that you have a header file called <code>top.h.</code>Then you can precompile it, specifying that HEADER=<code>hdr</code>:</p>
<pre>proc HEADER=hdr INAME=top.h
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must provide the &#39;.h&#39; extension. You cannot use an absolute path element or relative path elements such as &#39;/&#39;, &#39;..&#39;, and so on., in the INAME value.</div>
<p>Pro*C/C++ precompiles the given input file, <code>top.h</code>, and generates a new precompiled header file, <code>top.hdr</code>, in the same directory. The output file, <code>top.hdr</code>, can be moved to a directory that the <code>#include</code> statement will cause to be searched.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not use the ONAME option to name the output file; it is ignored when used with HEADER.</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3300" class="sect2"><a id="sthref649"></a>
<h3 class="sect2">Use of the Precompiled Header Files</h3>
<p>Use the same value of the HEADER option with an application file that is to be precompiled. If simple.pc contains:</p>
<pre>#include &lt;top.h&gt;
...
</pre>
<p>and top.h contains:</p>
<pre>#include &lt;a.h&gt;
#include &lt;b.h&gt;
#include &lt;c.h&gt;
...
</pre>
<p>then precompile this way:</p>
<pre>proc HEADER=hdr INAME=simple.pc
</pre>
<p>When Pro*C/C++ reads the <code>#include top.h</code> statement, it will search for a corresponding &#39;top.hdr&#39; file and instantiate the data from that file instead of precompiling &#39;top.h&#39; again.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A precompiled header file will always be used instead of its input header file even if the input (<code>.h</code>) file appears first in the standard search hierarchy of the include directories.</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3301" class="sect2"><a id="sthref650"></a>
<h3 class="sect2">Examples</h3>
<p>This section includes examples demonstrating several different cases.</p>
<div id="LNPCC3302" class="sect3"><a id="sthref651"></a>
<h4 class="sect3">Redundant File Inclusion</h4>
<p>The following two cases illustrate two possibilities for redundant file inclusion.</p>
<div id="LNPCC3303" class="sect4"><a id="sthref652"></a>
<h5 class="sect4">Case 1: Top-Level Header File Inclusion</h5>
<p>A precompiled header file will only be instantiated once regardless of how many times the file is included using a #include directive.</p>
<p>Suppose we precompile a top-level header file, top.h, with the value of HEADER set to &#39;hdr&#39; as before. Next, we code multiple #include directives for that header file in a program:</p>
<pre>#include &lt;top.h&gt;
#include &lt;top.h&gt;
main(){}
</pre>
<p>When the first #include for top.h is encountered, the precompiled header file, top.hdr, will be instantiated. The second inclusion of that same header file will be redundant and thus, will be ignored.</p>
</div>
<!-- class="sect4" -->
<div id="LNPCC3304" class="sect4"><a id="sthref653"></a>
<h5 class="sect4">Case 2: Nested Header File Inclusion</h5>
<p>Suppose the file a.h contains the following statement:</p>
<pre>#include &lt;b.h&gt;
</pre>
<p>and that we precompile that header file specifying HEADER as before. Pro*C/C++ will precompile both a.h and b.h generating a.hdr as a result.</p>
<p>Now suppose we precompile this Pro*C/C++ program:</p>
<pre>#include &lt;a.h&gt;
#include &lt;b.h&gt;
main(){}
</pre>
<p>When the #include for a.h is encountered, the a.hdr precompiled header file will be instantiated instead of precompiling a.h again. This instantiation will also contain the entire contents of b.h.</p>
<p>Now, because b.h was included in the precompilation of a.h, and a.hdr was instantiated, the subsequent #include of b.h in our program is redundant and thus, will be ignored.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNPCC3305" class="sect3"><a id="sthref654"></a>
<h4 class="sect3">Multiple Precompiled Header Files</h4>
<p>Pro*C/C++ is capable of instantiating more than one different precompiled header file in a single precompilation. However, one pitfall to avoid occurs when two or more precompiled header files share common header files.</p>
<p>For example, suppose topA.h contains the following lines:</p>
<pre>#include &lt;a.h&gt;
#include &lt;c.h&gt;
</pre>
<p>and that topB.h contains the following lines:</p>
<pre>#include &lt;b.h&gt;
#include &lt;c.h&gt;
</pre>
<p>Notice how topA.h and topB.h both include the same common header file, c.h. Precompiling topA.h and topB.h with the same HEADER value will yield topA.hdr and topB.hdr. Both, however, will contain the entire contents of c.h.</p>
<p>Now suppose we have a Pro*C/C++ program:</p>
<pre>#include &lt;topA.h&gt;
#include &lt;topB.h&gt;
main(){}
</pre>
<p>Both precompiled header files, topA.hdr and topB.hdr will be instantiated as before. However, because each shares the common header file, c.h, the contents of that file will be instantiated twice.</p>
<p>Pro*C/C++ cannot determine when such commonality is occurring among precompiled header files. Try to have each precompiled header file contain a unique set of included headers. Sharing headers should be avoided as much as possible because it will ultimately slow down precompilation and utilize more memory, thus undermining the basic intent of using precompiled header files.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006013"></a>
<div id="LNPCC3306" class="sect2">
<h3 class="sect2">List of Header Files<a id="sthref655"></a><a id="sthref656"></a></h3>
<p>The <code><span class="codeinlineitalic">ORACLE_BASE\ORACLE_HOME</span></code><code>\precomp\public</code> directory contains the Pro*C/C++ header files. <a href="#g1008185">Table 5-3</a> lists and describes the header files.</p>
<div id="LNPCC3307" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref657"></a><a id="g1008185"></a>Table 5-3 Header Files</p>
<table class="cellalignment834" title="Header Files" summary="Header files table" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t18">Header Files</th>
<th class="cellalignment832" id="r1c2-t18">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t18" headers="r1c1-t18">
<p><code><a id="sthref658"></a>oraca.h<a id="sthref659"></a></code></p>
</td>
<td class="cellalignment833" headers="r2c1-t18 r1c2-t18">
<p>Contains the Oracle Communications Area (ORACA), which helps you to diagnose runtime errors and to monitor your program&#39;s use of various Oracle Database 10<span class="italic">g</span> resources.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t18" headers="r1c1-t18">
<p><code><a id="sthref660"></a>sql2oci.h<a id="sthref661"></a></code></p>
</td>
<td class="cellalignment833" headers="r3c1-t18 r1c2-t18">
<p>Contains SQLLIB functions that enable the Oracle Call Interface (OCI) environment handle and OCI service context to be obtained in a Pro*C/C++ application.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t18" headers="r1c1-t18">
<p><code><a id="sthref662"></a>sqlapr.h<a id="sthref663"></a></code></p>
</td>
<td class="cellalignment833" headers="r4c1-t18 r1c2-t18">
<p>Contains ANSI prototypes for externalized functions that can be used in conjunction with OCI.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t18" headers="r1c1-t18">
<p><code><a id="sthref664"></a>sqlca.h<a id="sthref665"></a></code></p>
</td>
<td class="cellalignment833" headers="r5c1-t18 r1c2-t18">
<p>Contains the SQL Communications Area (SQLCA), which helps you to diagnose runtime errors. The SQLCA is updated after every executable SQL statement.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t18" headers="r1c1-t18">
<p><code><a id="sthref666"></a>sqlcpr.h<a id="sthref667"></a></code></p>
</td>
<td class="cellalignment833" headers="r6c1-t18 r1c2-t18">
<p>Contains platform-specific ANSI prototypes for SQLLIB functions that are generated by Pro*C/C++. By default, Pro*C/C++ does not support full-function prototyping of SQL programming calls. If you need this feature, include <code>sqlcpr.h</code> before any EXEC SQL statements in your application source file.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t18" headers="r1c1-t18">
<p><code><a id="sthref668"></a>oraca.h<a id="sthref669"></a></code></p>
</td>
<td class="cellalignment833" headers="r7c1-t18 r1c2-t18">
<p>Contains the Oracle Communications Area (ORACA), which helps you to diagnose runtime errors and to monitor your program&#39;s use of various Oracle Database 10<span class="italic">g</span> resources.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t18" headers="r1c1-t18">
<p><code><a id="sthref670"></a>sql2oci.h<a id="sthref671"></a></code></p>
</td>
<td class="cellalignment833" headers="r8c1-t18 r1c2-t18">
<p>Contains SQLLIB functions that enable the Oracle Call Interface (OCI) environment handle and OCI service context to be obtained in a Pro*C/C++ application.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t18" headers="r1c1-t18">
<p><code><a id="sthref672"></a>sqlapr.h<a id="sthref673"></a></code></p>
</td>
<td class="cellalignment833" headers="r9c1-t18 r1c2-t18">
<p>Contains ANSI prototypes for externalized functions that can be used in conjunction with OCI.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect2" -->
<div id="LNPCC3308" class="sect2"><a id="sthref674"></a>
<h3 class="sect2">Effects of Options</h3>
<p>The following precompiler options are used with the precompilation of the application.</p>
<div id="LNPCC3309" class="sect3"><a id="sthref675"></a>
<h4 class="sect3">DEFINE and INCLUDE Options</h4>
<p>During any precompilation using precompiled headers, you must use the same values for DEFINE and INCLUDE as when you created the precompiled header files. If the values of DEFINE or INCLUDE change, you must re-create the precompiled header files.</p>
<p>If development environments change, you must also re-create the precompiled header files.</p>
<div id="LNPCC3310" class="sect4"><a id="sthref676"></a>
<h5 class="sect4">Single User Scenario</h5>
<p>Consider a single user. If the values of either the DEFINE or the INCLUDE options were to change, then the contents of the precompiled header files may no longer be suitable for use in subsequent Pro*C/C++ precompilations.</p>
<p>Because the values of the DEFINE and INCLUDE; DEFINE or INCLUDE options have changed, the contents of the precompiled header file may no longer be consistent with what a standard precompilation would result in had the corresponding .h file in the #include directive been processed normally.</p>
<p>In short, if the values of the DEFINE and INCLUDE; DEFINE or INCLUDE options change, any precompiled header files must be re-created and Pro*C/C++ programs which use them re-precompiled.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_10opt.htm#i10027">&#34;DEFINE&#34;</a></p>
</li>
<li>
<p><a href="pc_10opt.htm#i4754">&#34;INCLUDE&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<div id="LNPCC3311" class="sect4"><a id="sthref677"></a>
<h5 class="sect4">Multiple User Scenario</h5>
<p>Consider two users, A and B, who develop in totally separate environments, thus having completely different values for their DEFINE and INCLUDE options.</p>
<p>User A precompiles a common header file, common.h, creating a precompiled header file common.hdrA. User B also precompiles the same header file creating common.hdrB. However, given that the two environments are different, specifically with respect to the values of the DEFINE and INCLUDE options used by both users, it is not guaranteed that both user A&#39;s and B&#39;s versions of common.hdr will be the same.</p>
<p>To summarize</p>
<pre>A&gt; proc HEADER=hdrA DEFINE=&lt;A macros&gt; INCLUDE=&lt;A dirs&gt; common.h

B&gt; proc HEADER=hdrB DEFINE=&lt;B macros&gt; INCLUDE=&lt;B dirs&gt; common.h
</pre>
<p>The generated precompiled header files common.hdrA may not equal common.hdrB because of the different environments in which they where created. This means that neither user A nor user B would be guaranteed that using the common.hdr created by the other user would result in correct precompilation of the Pro*C/C++ programs in their respective development environments.</p>
<p>Therefore, care should be taken when sharing or exchanging precompiled header files between different users and different users&#39; development environments.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNPCC3312" class="sect3"><a id="sthref678"></a>
<h4 class="sect3">CODE and PARSE Options<a id="sthref679"></a><a id="sthref680"></a><a id="sthref681"></a><a id="sthref682"></a></h4>
<p>Pro*C/C++ does not search for C++ header files with extensions such as <code>hpp</code> or <code>h++</code>. So do not use CODE=CPP when precompiling header files. You may use the CPP value when precompiling the application, as long as the source code only includes <code>.h</code> header files.</p>
<p>You can only use the values FULL or PARTIAL for the option PARSE when creating the precompiled header files, or when precompiling the modules. The value FULL is considered to be of higher value than PARTIAL. The value of PARSE used should be the same or lower when precompiling modules as when you created the precompiled header files.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Precompiling the precompiled header file with PARSE=FULL and then precompiling modules with PARSE=PARTIAL requires that the host variables be declared inside a Declare Section. C++ code will only be understood when PARSE=PARTIAL.</div>
<p>Suppose we precompile a header file with PARSE set to PARTIAL as follows:</p>
<pre>proc HEADER=hdr PARSE=PARTIAL file.h
</pre>
<p>and then try to precompile a program that includes that header file using PARSE set to FULL:</p>
<pre>proc HEADER=hdr PARSE=FULL program.pc
</pre>
<p>Because file.h was precompiled using a PARTIAL setting for the PARSE option, not all of the header file would have been processed. It would therefore be possible for an error to occur during the precompilation of the Pro*C/C++ program if a reference was made to something in the unprocessed portion.</p>
<p>To illustrate, suppose that file.h contained the following code:</p>
<pre>#define LENGTH 10
typedef int myint;
</pre>
<p>and that our program.pc contained the following short program:</p>
<pre>#include &lt;file.h&gt;
main()
{
     VARCHAR ename[LENGTH];
     myint empno = ...;
     EXEC SQL SELECT ename INTO :ename WHERE JOB = :empno;
}
</pre>
<p>Because PARSE was set to PARTIAL when precompiling file.h, only the LENGTH macro would have been processed leaving the typedef unseen.</p>
<p>The VARCHAR declaration and subsequent use as a host variable would succeed. However, the use of the empno host variable would not because the <code>myint</code> type declaration would never have been processed by Pro*C/C++.</p>
<p>Precompiling the header file with the PARSE option set to FULL and then precompiling the program with PARSE set to PARTIAL would work. However, the host variables would have to be declared inside an explicit DECLARE SECTION.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_10opt.htm#i10030">&#34;CODE&#34;</a></p>
</li>
<li>
<p><a href="pc_12cpl.htm#i864">&#34;Parsing Code&#34;</a></p>
</li>
<li>
<p><a href="pc_10opt.htm#i10029">&#34;PARSE&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC3313" class="sect2"><a id="sthref683"></a>
<h3 class="sect2">Usage Notes</h3>
<p>The file format of the generated output file of a precompiled header is not guaranteed to remain fixed from one release to the next. Pro*C/C++ has no way of determining which version of the precompiler was used to generate the precompiled header file output.</p>
<p>Because of this, it is strongly recommended that, in order to avoid the possibility of errors or other strange behavior during a precompilation that uses precompiled header files, those files be regenerated by re-precompiling the corresponding header files when upgrading to newer releases of Pro*C/C++.</p>
<p>The generated output from the precompilation of a header file is completely non-portable. This means that you cannot transfer the output file from the precompilation of a header file from one platform to another and use that file during the subsequent precompilation of another header file or Pro*C/C++ program.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i432485"></a>
<div id="LNPCC3314" class="sect1">
<h2 class="sect1">The Oracle Preprocessor<a id="sthref684"></a></h2>
<p>Conditional sections of code are marked by EXEC ORACLE directives that define the environment and actions to take. You can code C statements as well as embedded SQL statements and directives in these sections. The following EXEC ORACLE directives let you exercise conditional control over precompilation:<a id="sthref685"></a><a id="sthref686"></a><a id="sthref687"></a><a id="sthref688"></a><a id="sthref689"></a></p>
<pre>EXEC ORACLE DEFINE symbol;    -- define a symbol 
EXEC ORACLE IFDEF symbol;     -- if symbol is defined 
EXEC ORACLE IFNDEF symbol;    -- if symbol is not defined 
EXEC ORACLE ELSE;             -- otherwise 
EXEC ORACLE ENDIF;            -- end this block 
</pre>
<p>All EXEC ORACLE statements must be terminated with a semi-colon.</p>
<div id="LNPCC3315" class="sect2"><a id="sthref690"></a>
<h3 class="sect2">Symbol Definition</h3>
<p>You can define a symbol in two ways. Either include the statement<a id="sthref691"></a>:</p>
<pre>EXEC ORACLE DEFINE symbol;
</pre>
<p>in your host program or define the symbol on the command line using the syntax</p>
<pre>... INAME=filename ... DEFINE=symbol 
</pre>
<p>where <span class="italic">symbol</span> is not case-sensitive.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>#define</code> preprocessor directive is not the same as the EXEC ORACLE DEFINE command.</div>
<p>Some port-specific symbols are predefined for you when the Pro*C/C++ precompiler is installed on your system.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3316" class="sect2"><a id="sthref692"></a>
<h3 class="sect2"><a id="sthref693"></a>An Oracle Preprocessor Example</h3>
<p>In the following example, the SELECT statement is precompiled only when the symbol <span class="italic">site2</span> is defined:<a id="sthref694"></a></p>
<pre>EXEC ORACLE IFDEF site2; 
    EXEC SQL SELECT DNAME 
        INTO :dept_name 
        FROM DEPT 
        WHERE DEPTNO = :dept_number; 
EXEC ORACLE ENDIF; 
</pre>
<p>Blocks of conditions can be nested as shown in the following example:</p>
<pre>EXEC ORACLE IFDEF outer; 
    EXEC ORACLE IFDEF inner; 
    ... 
    EXEC ORACLE ENDIF; 
EXEC ORACLE ENDIF;
</pre>
<p>You can &#34;Comment out&#34; C or embedded SQL code by placing it between IFDEF and ENDIF and <span class="italic">not</span> defining the symbol.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i429746"></a>
<div id="LNPCC3317" class="sect1">
<h2 class="sect1">Evaluation of Numeric Constants</h2>
<p>Previously, Pro*C/C++ allowed only numeric literals and simple constant expressions involving numeric literals to be used when declaring the sizes of host variables (such as <code>char</code> or <code>VARCHAR</code>), as in the following examples:</p>
<pre>   #define LENGTH 10
   VARCHAR v[LENGTH];
   char c[LENGTH + 1];
</pre>
<p>You can now also use numeric constant declarations such as:</p>
<pre>   const int length = 10;
   VARCHAR v[length];
   char c[length + 1];
</pre>
<p>This is highly desirable, especially for programmers who use ANSI or C++ compilers that support such constant declarations.</p>
<p>Pro*C/C++ has always determined the values of constant expressions that can be evaluated, but it has never allowed the use of a numeric constant declaration in any constant expression.</p>
<p>Pro*C/C++ supports the use of numeric constant declarations anywhere that an ordinary numeric literal or macro is used, given the macro expands to some numeric literal.</p>
<p>This is used primarily for declaring the sizes of arrays for bind variables to be used in a SQL statement.</p>
<div id="LNPCC3318" class="sect2"><a id="sthref695"></a>
<h3 class="sect2">Numeric Constants in Pro*C/C++</h3>
<p>In Pro*C/C++, normal C scoping rules are used to find and locate the declaration of a numeric constant declaration.</p>
<pre>     const int g = 30;     /* Global declaration to both function_1()
                                                  and function_2() */
     void function_1()
     {
       const int a = 10;  /* Local declaration only to function_1() */
       char x[a];
       exec sql select ename into :x from emp where job = &#39;PRESIDENT&#39;;
     }

     void function_2()
     {
       const int a = 20;  /* Local declaration only to function_2() */
       VARCHAR v[a];
       exec sql select ename into :v from emp where job = &#39;PRESIDENT&#39;;
     }

     void main()
     {
       char m[g];                                   /* The global g */
       exec sql select ename into :m from emp where job = &#39;PRESIDENT&#39;;
     }
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3319" class="sect2"><a id="sthref696"></a>
<h3 class="sect2">Numeric Constant Rules and Examples</h3>
<p>Variables which are of specific static types need to be defined with <span class="bold">static</span> and initialized. The following rules must be kept in mind when declaring numeric constants in Pro*C/C++:</p>
<ul>
<li>
<p>The <span class="bold">const</span> qualifier must be used when declaring the constant<a id="sthref697"></a></p>
</li>
<li>
<p>An initializer must be used to initialize the value of the constant. This initializer must be precompile-time evaluable.</p>
</li>
</ul>
<p>Any attempt to use an identifier that does not resolve to a constant declaration with a valid initializer is considered an error.</p>
<p>The following shows examples of what is not permitted and why:</p>
<pre>int a;
int b = 10;
volatile c;
volatile d = 10;
const e;
const f = b;

VARCHAR v1[a]; /* No const qualifier, missing initializer */
VARCHAR v2[b];                      /* No const qualifier */
VARCHAR v3[c];     /* Not a constant, missing initializer */
VARCHAR v4[d];                          /* Not a constant */
VARCHAR v5[e];                     /* Missing initializer */
VARCHAR v6[f];   /* Bad initializer.. b is not a constant */
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i431030"></a>
<div id="LNPCC3320" class="sect1">
<h2 class="sect1">SQLLIB Extensions for OCI Release 8 Interoperability<a id="sthref698"></a><a id="sthref699"></a><a id="sthref700"></a></h2>
<p>An OCI environment handle will be tied to the Pro*C/C++ runtime context, which is of the <span class="italic">sql_context</span> type. That is, one Pro*C/C++ runtime context maintained by SQLLIB during application execution will be associated with at most one OCI environment handle. Multiple database connections are allowed for each Pro*C/C++ runtime context, which will be associated to the OCI environment handle for the runtime context.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Precompiler applications can extract OCI handles and call OCI functions directly. However, non-blocking mode is not supported because the precompilers are unable to handle the &#34;still executing&#34; error that might be returned.</div>
<a id="i448229"></a>
<div id="LNPCC3321" class="sect2">
<h3 class="sect2">Runtime Context in the OCI Release 8 Environment<a id="sthref701"></a><a id="sthref702"></a><a id="sthref703"></a></h3>
<p>An EXEC SQL CONTEXT USE statement specifies a runtime context to be used in a Pro*C/C++ program. This context applies to all executable SQL statements that positionally follow it in a given Pro*C/C++ file until another EXEC SQL CONTEXT USE statement occurs. If no EXEC SQL CONTEXT USE appears in a source file, the default &#34;global&#34; context is assumed. Thus, the current runtime context, and therefore the current OCI environment handle, is known at any point in the program.</p>
<p>The runtime context and its associated OCI environment handle are initialized when a database logon is performed using EXEC SQL CONNECT in Pro*C/C++.</p>
<p>When a Pro*C/C++ runtime context is freed using the EXEC SQL CONTEXT FREE statement, the associated OCI environment handle is terminated and all of its resources, such as space allocated for the various OCI handles and LOB locators, are de-allocated. This command releases all other memory associated with the Pro*C/C++ runtime context. An OCI environment handle that is established for the default &#34;global&#34; runtime remains allocated until the Pro*C/C++ program terminates.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3322" class="sect2"><a id="sthref704"></a>
<h3 class="sect2">Parameters in the OCI Release 8 Environment Handle<a id="sthref705"></a></h3>
<p>An OCI environment established through Pro*C/C++ will use the following parameters:</p>
<ul>
<li>
<p>The callback functions used by the environment for allocating memory, freeing memory, writing to a text file, and flushing the output buffer will be trivial functions that call malloc(), free(), fprintf(stderr, ...), and fflush(stderr) respectively.</p>
</li>
<li>
<p>The language will be obtained from the Globalization Support variable NLS_LANG.</p>
</li>
<li>
<p>The error message buffer will be allocated in thread-specific storage.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i431046"></a>
<div id="LNPCC3323" class="sect1">
<h2 class="sect1">Interface to OCI Release 8<a id="sthref706"></a></h2>
<p>SQLLIB library provides routines to obtain the OCI environment and service context handles for database connections established through a Pro*C/C++ program. Once the OCI handles are obtained, the user can call various OCI routines, for example, to perform client-side DATE arithmetic, execute navigational operations on objects and so on. These SQLLIB functions are described later, and their prototypes are available in the public header file <code>sql2oci.h</code>.</p>
<p><a id="i431053"></a>A Pro*C/C++ user who mixes embedded SQL and calls in the other Oracle programmatic interfaces must exercise reasonable care. For example, if a user terminates a connection directly using the OCI interface, SQLLIB state is out-of-sync; the behavior for subsequent SQL statements in the Pro*C/C++ program is undefined in such cases.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Pro*C/C++, the Oracle Call Interface (OCI) release 8, and XA are <span class="italic">not</span> compatible.</div>
<p>The new SQLLIB functions that provide interoperability with the Oracle OCI are declared in header file <code>sql2oci.h</code>:</p>
<ul>
<li>
<p><code>SQLEnvGet()</code>, to return a pointer to an OCI environment handle associated with a given SQLLIB runtime context. Used for both single and shared server environments.</p>
</li>
<li>
<p><code>SQLSvcCtxGet()</code>, to return an OCI service context handle for a Pro*C/C++ database connection. Used for both single and shared server environments.</p>
</li>
<li>
<p><a id="sthref707"></a>Pass the constant <code>SQL_SINGLE_RCTX</code>, defined as <code>(dvoid *)0</code>, when you include sql2oci.h, as the first parameter in either function, when using single threaded runtime contexts.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_17obj.htm#g480794">Chapter 17, &#34;Objects&#34;</a></div>
</li>
</ul>
<a id="i431059"></a>
<div id="LNPCC3324" class="sect2">
<h3 class="sect2"><a id="sthref708"></a><a id="sthref709"></a>SQLEnvGet()</h3>
<p>The SQLLIB library function <code>SQLEnvGet()</code> (SQLLIB OCI Environment Get) returns the pointer to the OCI environment handle associated with a given SQLLIB runtime context. The prototype for this function is:</p>
<pre>sword SQLEnvGet(dvoid *rctx, OCIEnv **oeh);
</pre>
<p>where:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="description, parameters, return values and notes for sqlenvget()" summary="Terms" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t26">Terms</th>
<th class="cellalignment832" id="r1c2-t26">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t26" headers="r1c1-t26">Description</td>
<td class="cellalignment833" headers="r2c1-t26 r1c2-t26">Sets <span class="italic">oeh</span> to the OCIEnv corresponding to the runtime context</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t26" headers="r1c1-t26">Parameters</td>
<td class="cellalignment833" headers="r3c1-t26 r1c2-t26"><span class="italic">rctx</span> (IN) pointer to a SQLLIB runtime context
<p><span class="italic">oeh</span> (OUT) pointer to OCIEnv</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t26" headers="r1c1-t26">Returns</td>
<td class="cellalignment833" headers="r4c1-t26 r1c2-t26">SQL_SUCCESS on success
<p>SQL_ERROR on failure</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t26" headers="r1c1-t26">Notes</td>
<td class="cellalignment833" headers="r5c1-t26 r1c2-t26">The usual error status variables in Pro*C/C++ such as SQLCA and SQLSTATE will not be affected by a call to this function</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<a id="i431085"></a>
<div id="LNPCC3325" class="sect2">
<h3 class="sect2"><a id="sthref710"></a><a id="sthref711"></a>SQLSvcCtxGet()</h3>
<p>The SQLLIB library function <code>SQLSvcCtxGet()</code> (SQLLIB OCI Service Context Get) returns the OCI service context for the Pro*C/C++ database connection. The OCI service context can then be used in direct calls to OCI functions. The prototype for this function is:</p>
<pre>sword SQLSvcCtxGet(dvoid *rctx, text *dbname,
       sb4 dbnamelen, OCISvcCtx **svc);
</pre>
<p>where:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="description, parameters, return values and notes for sqlsvcctxget()" summary="Terms" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t27">Terms</th>
<th class="cellalignment832" id="r1c2-t27">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t27" headers="r1c1-t27">Description</td>
<td class="cellalignment833" headers="r2c1-t27 r1c2-t27">Sets <span class="italic">svc</span> to the OCI Service Context corresponding to the runtime context</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t27" headers="r1c1-t27">Parameters</td>
<td class="cellalignment833" headers="r3c1-t27 r1c2-t27"><span class="italic">rctx</span> (IN) = pointer to a SQLLIB runtime context
<p><span class="italic">dbname</span> (IN) = buffer containing the &#34;logical&#34; name for this connection</p>
<p><span class="italic">dbnamelen</span> (IN) = length of the dbname buffer</p>
<p><span class="italic">svc</span> (OUT) = address of an OCISvcCtx pointer</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t27" headers="r1c1-t27">Returns</td>
<td class="cellalignment833" headers="r4c1-t27 r1c2-t27">SQL_SUCCESS on success
<p>SQL_ERROR on failure</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t27" headers="r1c1-t27">Notes</td>
<td class="cellalignment833" headers="r5c1-t27 r1c2-t27">1. The usual error status variables in Pro*C/C++ such as SQLCA and SQLSTATE will not be affected by a call to this function
<p><span class="italic">2. dbname</span> is the same identifier used in an AT clause in an embedded SQL statement.</p>
<p>3. If <span class="italic">dbname</span> is a null pointer or <span class="italic">dbnamelen</span> is 0, then the default database connection is assumed, as in a SQL statement with no AT clause.</p>
<p>4. A value of -1 for <span class="italic">dbnamelen</span> is used to indicate that <span class="italic">dbname</span> is a zero-terminated string.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<div id="LNPCC3326" class="sect2"><a id="sthref712"></a>
<h3 class="sect2"><a id="sthref713"></a>Embedded OCI Release 8 Calls</h3>
<p>To embed OCI release 8 calls in your Pro*C/C++ program:</p>
<p>1. Include the public header sql2oci.h</p>
<p>2. Declare an environment handle (type OCIEnv *) in your Pro*C/C++ program:</p>
<pre>OCIEnv *oeh;
</pre>
<p>3. Optionally, declare a service context handle (type OCISvcCtx *) in your Pro*C/C++ program if the OCI function you wish to call requires the Service Context handle.</p>
<pre>OCISvcCtx *svc;
</pre>
<p>4. Declare an error handle (type OCIError *) in your Pro*C/C++ program:</p>
<pre>OCIError *err;
</pre>
<p>5. Connect to Oracle using the embedded SQL statement CONNECT. Do not connect using OCI.</p>
<pre>EXEC SQL CONNECT ...
</pre>
<p>6. Obtain the OCI Environment handle that is associated with the desired runtime context using the SQLEnvGet function.</p>
<p>For single threaded applications:</p>
<pre>retcode = SQLEnvGet(SQL_SINGLE_RCTX, &amp;oeh);
</pre>
<p>or for shared server applications:</p>
<pre>sql_context ctx1;
...
EXEC SQL CONTEXT ALLOCATE :ctx1;
EXEC SQL CONTEXT USE :ctx1;
...
EXEC SQL CONNECT :uid IDENTIFIED BY :pwd;
...
retcode = SQLEnvGet(ctx1, &amp;oeh);
</pre>
<p>7. Allocate an OCI error handle using the retrieved environment handle:</p>
<pre>retcode = OCIHandleAlloc((dvoid *)oeh, (dvoid **)&amp;err, 
                    (ub4)OCI_HTYPE_ERROR, (ub4)0, (dvoid **)0);
</pre>
<p>8. Optionally, if needed by the OCI call you use, obtain the OCIServiceContext handle using the SQLSvcCtxGet call:</p>
<p>For single threaded applications:</p>
<pre>retcode = SQLSvcCtxGet(SQL_SINGLE_RCTX, (text *)dbname, (ub4)dbnlen, &amp;svc);
</pre>
<p>or, for shared server environment applications:</p>
<pre>sql_context ctx1;
...
EXEC SQL ALLOCATE :ctx1;
EXEC SQL CONTEXT USE :ctx1;
...
EXEC SQL CONNECT :uid IDENTIFIED BY :pwd AT :dbname
     USING :hst;
...
retcode = SQLSvcCtxGet(ctx1, (text *)dbname, (ub4)strlen(dbname), &amp;svc);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
A null pointer may be passed as the <span class="italic">dbname</span> if the Pro*C/C++ connection is not named with an AT clause.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i421486"></a>
<div id="LNPCC3327" class="sect1">
<h2 class="sect1">Embedded OCI Release 7 Calls<a id="sthref714"></a></h2>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Logon Data Area (LDA) is <span class="italic">no longer supported</span>. The ability to embed OCI Release 7 calls in your Pro*C/C++ program is not supported.</div>
<p>To embed OCI release 7 calls in your Pro*C/C++ program, take the following steps:<a id="sthref715"></a><a id="sthref716"></a><a id="sthref717"></a></p>
<ul>
<li>
<p>Declare an OCI Logon Data Area (LDA) in your Pro*C/C++ program (outside the Declare Section if you precompile with MODE=ANSI). The LDA is a structure defined in the OCI header file <code>oci.h</code>. For details, see the Oracle Call Interface programmer&#39;s Guide for Release 7.<span class="italic"><a id="sthref718"></a></span></p>
</li>
<li>
<p>Connect to Oracle using the embedded SQL statement CONNECT, not the OCI <code>orlon()</code> or <code>onblon()</code> calls.<a id="sthref719"></a><a id="sthref720"></a></p>
</li>
<li>
<p>Call the SQLLIB runtime library function <code>sqllda(</code>) to set up the LDA.SQLLIB function</p>
</li>
</ul>
<p>That way, the Pro*C/C++ Precompiler and the OCI &#34;know&#34; that they are working together. However, there is no sharing of Oracle cursors.</p>
<p>You need not worry about declaring the OCI Host Data Area (HDA) because the Oracle runtime library manages connections and maintains the HDA for you.</p>
<div id="LNPCC3328" class="sect2"><a id="sthref721"></a>
<h3 class="sect2">Set Up the LDA<a id="sthref722"></a></h3>
<p>You set up the LDA by issuing the OCI call</p>
<pre>sqllda(&amp;lda); 
</pre>
<p>where <span class="italic">lda</span> identifies the LDA data structure.</p>
<p>If the setup fails, the <span class="italic">lda_rc</span> field in the <span class="italic">lda</span> is set to 1012 to indicate the error.</p>
</div>
<!-- class="sect2" -->
<a id="i421510"></a>
<div id="LNPCC3329" class="sect2">
<h3 class="sect2">Remote and Multiple Connections<a id="sthref723"></a></h3>
<p>A call to <code>sqllda()</code> sets up an LDA for the connection used by the most recently executed SQL statement. To set up the different LDAs needed for additional connections, you <span class="italic">must</span> call <code>sqllda()</code> with a different LDA <span class="italic">immediately</span> after each CONNECT. In the following example, you connect to two nondefault databases concurrently:</p>
<pre>#include &lt;ocidfn.h&gt;
Lda_Def lda1;
Lda_Def lda2;

char username[10], password[10], db_string1[20], dbstring2[20];
...
strcpy(username, &#34;scott&#34;);
strcpy(password, &#34;tiger&#34;);
strcpy(db_string1, &#34;NYNON&#34;);
strcpy(db_string2, &#34;CHINON&#34;);
/* give each database connection a unique name */
EXEC SQL DECLARE DB_NAME1 DATABASE;
EXEC SQL DECLARE DB_NAME2 DATABASE;
/* connect to first nondefault database */
EXEC SQL CONNECT :username IDENTIFIED BY :password;
    AT DB_NAME1 USING :db_string1;
/* set up first LDA */
sqllda(&amp;lda1);
/* connect to second nondefault database */
EXEC SQL CONNECT :username IDENTIFIED BY :password;
    AT DB_NAME2 USING :db_string2;
/* set up second LDA */
sqllda(&amp;lda2);
</pre>
<p>DB_NAME1 and DB_NAME2 are <span class="italic">not</span> C variables; they are SQL identifiers. You use them only to name the default databases at the two nondefault nodes, so that later SQL statements can refer to the databases by name.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i426817"></a>
<div id="LNPCC3330" class="sect1">
<h2 class="sect1">New Names for SQLLIB Public Functions<a id="sthref724"></a></h2>
<p>The names of SQLLIB functions are listed in <a href="#g450022">Table 5-4</a>. You can use these SQLLIB functions for both threaded and nonthreaded applications. Previously, for example, <code>sqlglm()</code> was documented as the nonthreaded or default context version of this function, while <code>sqlglmt()</code> was the threaded or nondefault context version, with context as the first argument. The names <code>sqlglm()</code> and <code>sqlglmt()</code> are still available. The new function <code>SQLErrorGetText()</code> requires the same arguments as <code>sqlglmt()</code>. For nonthreaded or default context applications, pass the defined constant <a id="sthref725"></a>SQL_SINGLE_RCTX as the context.</p>
<p>Each standard SQLLIB public function is thread-safe and accepts the runtime context as the first argument. For example, the syntax for <code>SQLErrorGetText()</code> is:</p>
<pre>void SQLErrorGetText(dvoid *context,  char   *message_buffer, 
            size_t *buffer_size,
            size_t *message_length);
</pre>
<p>In summary, the old function names will continue to work in your existing applications. You can use the new function names in the new applications that you will write.</p>
<p><a href="#g450022">Table 5-4</a> lists all the SQLLIB public functions and their corresponding syntax. Cross-references to the nonthreaded or default-context usages are provided to help you find more complete descriptions.</p>
<div id="LNPCC3331" class="tblformalwide">
<p class="titleintable"><a id="sthref726"></a><a id="g450022"></a>Table 5-4 SQLLIB Public Functions -- New Names</p>
<table class="cellalignment834" title=" SQLLIB Public Functions -- New Names" summary="TSQLLIB Public Funcitons - New Names" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t30">Old Name</th>
<th class="cellalignment832" id="r1c2-t30">New Function Prototype</th>
<th class="cellalignment832" id="r1c3-t30">Cross-reference</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t30" headers="r1c1-t30">
<p><code>sqlaldt()</code></p>
</td>
<td class="cellalignment833" headers="r2c1-t30 r1c2-t30">
<pre>struct SQLDA *SQLSQLDAAlloc(dvoid *context,
unsigned int     maximum_variables,
unsigned int     maximum_name_length,
unsigned int     maximum_ind_name_length);<a id="sthref727"></a><a id="sthref728"></a><a id="sthref729"></a>
</pre></td>
<td class="cellalignment833" headers="r2c1-t30 r1c3-t30">
<p>See also <a href="pc_15ody.htm#i11411">&#34;Allocating a SQLDA&#34;</a> .</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t30" headers="r1c1-t30">
<p><code>sqlcdat()</code></p>
</td>
<td class="cellalignment833" headers="r3c1-t30 r1c2-t30">
<pre>void SQLCDAFromResultSetCursor(dvoid *context,
Cda_Def *cda,
void    *cursor,
sword   *return_value);<a id="sthref730"></a><a id="sthref731"></a><a id="sthref732"></a>
</pre></td>
<td class="cellalignment833" headers="r3c1-t30 r1c3-t30">
<p>See also <a href="pc_04dat.htm#i23020">&#34;Cursor Variables with the OCI (Release 7 Only)&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t30" headers="r1c1-t30">
<p><code>sqlclut()</code></p>
</td>
<td class="cellalignment833" headers="r4c1-t30 r1c2-t30">
<pre>void SQLSQLDAFree(dvoid  *context, 
struct SQLDA             *descriptor_name);<a id="sthref733"></a><a id="sthref734"></a><a id="sthref735"></a>
</pre></td>
<td class="cellalignment833" headers="r4c1-t30 r1c3-t30">
<p>See also<a href="pc_15ody.htm#i7044">&#34;Deallocate Storage&#34;</a> .</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t30" headers="r1c1-t30">
<p><code>sqlcurt()</code></p>
</td>
<td class="cellalignment833" headers="r5c1-t30 r1c2-t30">
<pre>void SQLCDAToResultSetCursor(dvoid  *context,
void    *cursor, 
Cda_Def *cda, 
sword   *return_value)<a id="sthref736"></a><a id="sthref737"></a><a id="sthref738"></a>
</pre></td>
<td class="cellalignment833" headers="r5c1-t30 r1c3-t30">
<p>See also <a href="pc_04dat.htm#i23020">&#34;Cursor Variables with the OCI (Release 7 Only)&#34;</a> .</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t30" headers="r1c1-t30">
<p><code>sqlglmt()</code></p>
</td>
<td class="cellalignment833" headers="r6c1-t30 r1c2-t30">
<pre>void SQLErrorGetText(dvoid  *context,
unsigned char *message_buffer, 
size_t  *buffer_size,
size_t  *message_length);<a id="sthref739"></a><a id="sthref740"></a><a id="sthref741"></a>
</pre></td>
<td class="cellalignment833" headers="r6c1-t30 r1c3-t30">
<p>See also <a href="pc_09err.htm#i6805">&#34;Getting the Full Text of Error Messages&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t30" headers="r1c1-t30">
<p><code>sqlglst()</code></p>
</td>
<td class="cellalignment833" headers="r7c1-t30 r1c2-t30">
<pre>void SQLStmtGetText(dvoid   *context, 
char    *statement_buffer, 
size_t  *statement_length, 
size_t  *sqlfc);<a id="sthref742"></a><a id="sthref743"></a><a id="sthref744"></a>
</pre></td>
<td class="cellalignment833" headers="r7c1-t30 r1c3-t30">
<p>See also <a href="pc_09err.htm#i6810">&#34;Obtaining the Text of SQL Statements&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t30" headers="r1c1-t30">
<p><code>sqlld2t()</code></p>
</td>
<td class="cellalignment833" headers="r8c1-t30 r1c2-t30">
<pre>void SQLLDAGetName(dvoid   *context, 
Lda_Def *lda,
text    *cname,
int     *cname_length);<a id="sthref745"></a><a id="sthref746"></a><a id="sthref747"></a>
</pre></td>
<td class="cellalignment833" headers="r8c1-t30 r1c3-t30">
<p>See also <a href="#i436066">&#34;OCI Calls (Release 7 Only)&#34;</a></p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t30" headers="r1c1-t30">
<p><code>sqlldat()</code></p>
</td>
<td class="cellalignment833" headers="r9c1-t30 r1c2-t30">
<pre>void SQLLDAGetCurrent(dvoid *context, 
Lda_Def   *lda);<a id="sthref748"></a><a id="sthref749"></a><a id="sthref750"></a>
</pre></td>
<td class="cellalignment833" headers="r9c1-t30 r1c3-t30">
<p>See also <a href="#i421510">&#34;Remote and Multiple Connections&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t30" headers="r1c1-t30">
<p><code>sqlnult()</code></p>
</td>
<td class="cellalignment833" headers="r10c1-t30 r1c2-t30">
<pre>void SQLColumnNullCheck(dvoid *context, 
unsigned short *value_type, 
unsigned short *type_code, 
int            *null_status);<a id="sthref751"></a><a id="sthref752"></a>
</pre></td>
<td class="cellalignment833" headers="r10c1-t30 r1c3-t30">
<p>See also <a href="pc_15ody.htm#i11254">&#34;Handling NULL/Not NULL Datatypes&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t30" headers="r1c1-t30">
<p><code>sqlprct()</code></p>
</td>
<td class="cellalignment833" headers="r11c1-t30 r1c2-t30">
<pre>void SQLNumberPrecV6(dvoid  *context, 
unsigned long   *length, 
int             *precision, 
int             *scale);<a id="sthref753"></a><a id="sthref754"></a><a id="sthref755"></a>
</pre></td>
<td class="cellalignment833" headers="r11c1-t30 r1c3-t30">
<p>See also <a href="pc_15ody.htm#i6993">&#34;Extracting Precision and Scale&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t30" headers="r1c1-t30">
<p><code>sqlpr2t()</code></p>
</td>
<td class="cellalignment833" headers="r12c1-t30 r1c2-t30">
<pre>void SQLNumberPrecV7(dvoid  *context, 
unsigned long   *length, 
int             *precision, 
int             *scale);<a id="sthref756"></a><a id="sthref757"></a><a id="sthref758"></a>
</pre></td>
<td class="cellalignment833" headers="r12c1-t30 r1c3-t30">
<p>See also <a href="pc_15ody.htm#i6993">&#34;Extracting Precision and Scale&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r13c1-t30" headers="r1c1-t30">
<p><code>sqlvcpt()</code></p>
</td>
<td class="cellalignment833" headers="r13c1-t30 r1c2-t30">
<pre>void SQLVarcharGetLength(dvoid  *context, 
unsigned long   *data_length, 
unsigned long   *total_length);<a id="sthref759"></a><a id="sthref760"></a><a id="sthref761"></a>
</pre></td>
<td class="cellalignment833" headers="r13c1-t30 r1c3-t30">
<p>See also <a href="pc_04dat.htm#i23400">&#34;Find the Length of the VARCHAR Array Component&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r14c1-t30" headers="r1c1-t30">
<p><code>N/A</code></p>
</td>
<td class="cellalignment833" headers="r14c1-t30 r1c2-t30">
<pre>sword <a id="sthref762"></a><a id="sthref763"></a>SQLEnvGet(dvoid *context,
OCIEnv          **oeh);
</pre></td>
<td class="cellalignment833" headers="r14c1-t30 r1c3-t30">
<p>See <a href="#i431059">&#34;SQLEnvGet()&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r15c1-t30" headers="r1c1-t30">
<p><code>N/A</code></p>
</td>
<td class="cellalignment833" headers="r15c1-t30 r1c2-t30">
<pre>sword <a id="sthref764"></a><a id="sthref765"></a>SQLSvcCtxGet(dvoid *context,
text            *dbname,
int             dbnamelen,
OCISvcCtx       **svc);
</pre></td>
<td class="cellalignment833" headers="r15c1-t30 r1c3-t30">
<p>See <a href="#i431085">&#34;SQLSvcCtxGet()&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r16c1-t30" headers="r1c1-t30">
<p><code>N/A</code></p>
</td>
<td class="cellalignment833" headers="r16c1-t30 r1c2-t30">
<pre>void <a id="sthref766"></a><a id="sthref767"></a>SQLRowidGet(dvoid *context,
OCIRowid        **urid);
</pre></td>
<td class="cellalignment833" headers="r16c1-t30 r1c3-t30">
<p>See <a href="pc_04dat.htm#i24935">&#34;SQLRowidGet()&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r17c1-t30" headers="r1c1-t30">
<p><code>N/A</code></p>
</td>
<td class="cellalignment833" headers="r17c1-t30 r1c2-t30">
<pre>void <a id="sthref768"></a><a id="sthref769"></a>SQLExtProcError(dvoid *context,
char            *msg,
size_t          msglen);
</pre></td>
<td class="cellalignment833" headers="r17c1-t30 r1c3-t30">
<p>See <a href="pc_07pls.htm#i9112">&#34;SQLExtProcError()&#34;</a> for a discussion of its use in external procedures.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
For the specific datatypes used in the argument lists for these functions, refer to your platform-specific version of the <code>sqlcpr.h</code> header file.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i431046">&#34;Interface to OCI Release 8&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="i432871"></a>
<div id="LNPCC3332" class="sect1">
<h2 class="sect1">X/Open Application Development</h2>
<p><a id="sthref770"></a><a id="sthref771"></a><a id="sthref772"></a>X/Open applications run in a distributed transaction processing (DTP) environment. In an abstract model, an X/Open application calls on <span class="italic">resource managers</span> (RMs) to provide a variety of services. For example, a database resource manager provides access to data in a database. Resource managers interact with a <span class="italic">transaction manager</span> (TM), which controls all transactions for the application.</p>
<div id="LNPCC3333" class="figure">
<p class="titleinfigure"><a id="i421811"></a>Figure 5-1 Hypothetical DTP Model</p>
<img width="605" height="341" src="img/lnpcc005.gif" alt="Description of Figure 5-1 follows"/><br/>
<a id="sthref773" href="img_text/lnpcc005.htm">Description of &#34;Figure 5-1 Hypothetical DTP Model&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p><a href="#i421811">Figure 5-1</a> shows one way that components of the DTP model can interact to provide efficient access to data in an Oracle database. The DTP model specifies the <span class="italic">XA interface</span> between resource managers and the transaction manager. Oracle supplies an XA-compliant library, which you must link to your X/Open application. Also, you must specify the <span class="italic">native interface</span> between your application program and the resource managers. <a id="sthref774"></a><a id="sthref775"></a><a id="sthref776"></a><a id="sthref777"></a><a id="sthref778"></a></p>
<p>The DTP model that specifies how a transaction manager and resource managers interact with an application program is described in the X/Open guide <span class="italic">Distributed Transaction Processing Reference Model</span> and related publications, which you can obtain by writing to<a id="sthref779"></a></p>
<dl>
<dd>The Open Group</dd>
<dd>1010 El Camino Real, Suite 380</dd>
<dd>Menlo Park, CA 94025-4345 USA</dd>
<dd><code><a href="http://www.opennc.org/">http://www.opennc.org/</a></code></dd>
</dl>
<p>For instructions on using the XA interface, see your Transaction Processing (TP) Monitor user&#39;s guide.</p>
<div id="LNPCC3334" class="sect2"><a id="sthref780"></a>
<h3 class="sect2">Oracle-Specific Issues</h3>
<p>You can use the precompiler to develop applications that comply with the X/Open standards. However, you must meet the following requirements.</p>
<a id="i421835"></a>
<div id="LNPCC3335" class="sect3">
<h4 class="sect3">Connecting to Oracle</h4>
<p>The X/Open application does not establish and maintain connections to a database. Instead, the transaction manager and the XA interface, which is supplied by Oracle, handle database connections and disconnections transparently. So, normally an X/Open-compliant application does not execute CONNECT statements.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3336" class="sect3"><a id="sthref781"></a>
<h4 class="sect3">Transaction Control</h4>
<p>The X/Open application must not execute statements such as COMMIT, ROLLBACK, SAVEPOINT, and SET TRANSACTION that affect the state of global transactions. For example, the application must not execute the COMMIT statement because the transaction manager handles commits. Also, the application must not execute SQL data definition statements such as CREATE, ALTER, and RENAME because they issue an implicit COMMIT.</p>
<p>The application can execute an internal ROLLBACK statement if it detects an error that prevents further SQL operations. However, this might change in later releases of the XA interface.</p>
</div>
<!-- class="sect3" -->
<a id="i436066"></a>
<div id="LNPCC3337" class="sect3">
<h4 class="sect3">OCI Calls (Release 7 Only)</h4>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Logon Data Area (LDA) is <span class="italic">no longer supported</span> in Oracle9<span class="italic">i</span>. The ability to embed OCI Release 7 calls in your Pro*C/C++ program will be phased out by the next major Oracle release.</div>
<p>If you want your X/Open application to issue OCI calls, you must use the runtime library routine <code>sqlld2()</code>, which sets up an LDA for a specified connection established through the XA interface. For a description of the <code>sqlld2()</code> call, see the Oracle Call Interface Programmer&#39;s Guide for Release 7<span class="italic">.</span></p>
<p>The following OCI calls cannot be issued by an X/Open application: OCOM, OCON, OCOF, ONBLON, ORLON, OLON, OLOGOF.</p>
<p>For a discussion of how to use OCI Release 8 calls in Pro*C/C++, see also <a href="#i431046">&#34;Interface to OCI Release 8&#34;</a>. <a id="sthref782"></a><a id="sthref783"></a></p>
</div>
<!-- class="sect3" -->
<a id="i421855"></a>
<div id="LNPCC3338" class="sect3">
<h4 class="sect3">Linking</h4>
<p>To get XA functionality, you must link the XA library to your X/Open application object modules. For instructions, see your system-specific Oracle documentation. <a id="sthref784"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_04dat.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_06sql.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>