<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78019"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/The%20Object%20Type%20Translator"></a><title>The Object Type Translator</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:53Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_18col.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_20exi.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">25/35</span> <!-- End Header -->
<div id="LNPCC019" class="chapter"><a id="g464850"></a> <a id="i454125"></a>
<h1 class="chapter"><span class="secnum">19</span> The Object Type Translator</h1>
<p>This chapter discusses the OTT (Object Type Translator)<a id="sthref2215"></a>, which maps database object types, LOB types, and collection types to C structs for use in Pro*C/C++ applications.</p>
<p>The chapter includes the following sections:</p>
<ul>
<li>
<p><a href="#i454250">OTT Overview</a></p>
</li>
<li>
<p><a href="#i439131">What is the Object Type Translator</a></p>
</li>
<li>
<p><a href="#i427628">Using OTT with OCI Applications</a></p>
</li>
<li>
<p><a href="#i420213">Using OTT with Pro*C/C++ Applications</a></p>
</li>
<li>
<p><a href="#i420217">OTT Reference</a></p>
</li>
</ul>
<a id="i454250"></a>
<div id="LNPCC4435" class="sect1">
<h2 class="sect1">OTT Overview</h2>
<p>OTT (The Object Type Translator) assists in the development of applications that make use of user-defined types in an Oracle server.</p>
<p>Through the use of SQL CREATE TYPE statements, you can create object types. The definitions of these types are stored in the database, and can be used in the creation of database tables. Once these tables are populated, an OCI, Pro*C/C++, or Java programmer can access objects stored in the tables.</p>
<p>An application that accesses object data must be able to represent the data in a host language format. This is accomplished by representing object types as C structs. It would be possible for a programmer to code struct declarations by hand to represent database object types, but this can be very time-consuming and error-prone if many types are involved. OTT simplifies this step by automatically generating appropriate struct declarations. For Pro*C/C++, the application only needs to include the header file generated by OTT. In OCI, the application also needs to call an initialization function generated by OTT.</p>
<p>In addition to creating structs that represent stored datatypes, OTT also generates parallel indicator structs which indicate whether an object type or its fields are NULL.</p>
<p>For detailed information about object types, refer to <a href="pc_16lob.htm#g1029071">Chapter 16, &#34;LOBs&#34;</a>, <a href="pc_17obj.htm#g480794">Chapter 17, &#34;Objects&#34;</a>, and <a href="pc_18col.htm#g1023189">Chapter 18, &#34;Collections&#34;</a>.</p>
</div>
<!-- class="sect1" -->
<a id="i439131"></a>
<div id="LNPCC4436" class="sect1">
<h2 class="sect1">What is the Object Type Translator<a id="sthref2216"></a></h2>
<p>The Object Type Translator (OTT) converts database definitions of object types and named collection types into C struct declarations which can be included in an OCI or Pro*C/C++ application.</p>
<p>Both OCI programmers and Pro*C/C++ programmers must explicitly invoke OTT to translate database types to C representations. OCI programmers must also initialize a data structure called the <span class="italic">Type Version Table</span> with information about the user-defined types required by the program. Code to perform this initialization is generated by OTT. In Pro*C/C++, the type version information is recorded in the <code>OUTTYPE</code> file which is passed as a parameter to Pro*C/C++.</p>
<p>On most operating systems, OTT is invoked on the command line. It takes as input an <code>INTYPE</code> file, and it generates an <code>OUTTYPE</code> file and one or more C header files and an optional implementation file (for OCI programmers). The following is an example of a command that invokes OTT:</p>
<pre>ott userid=scott/tiger intype=demoin.typ outtype=demoout.typ code=c hfile=demo.h
</pre>
<p>This command causes OTT to connect to the database with username <span class="italic">scott</span> and password <span class="italic">tiger</span>, and translate database types to C structs, based on instructions in the <code>INTYPE</code> file, <code><span class="codeinlineitalic">demoin.typ</span></code>. The resulting structs are output to the header file, <span class="italic">demo.h</span>, for the host language (C) specified by the <code>CODE</code> parameter. The <code>OUTTYPE</code> file, <code><span class="codeinlineitalic">demoout.typ</span></code>, receives information about the translation.</p>
<p>Each of these parameters is described in more detail in later sections of this chapter.</p>
<p>Sample <code>demoin.typ</code> file:</p>
<pre>CASE=LOWER
TYPE employee
</pre>
<p>Sample <code>demoout.typ</code> file:</p>
<pre>CASE = LOWER
TYPE SCOTT.EMPLOYEE AS employee
  VERSION = &#34;$8.0&#34;
  HFILE = demo.h
</pre>
<p>In this example, the <code>demoin.typ</code> file contains the type to be translated, preceded by TYPE (for example, TYPE employee). The structure of the <code>OUTTYPE</code> file is similar to the <code>INTYPE</code> file, with the addition of information obtained by OTT.</p>
<p>Once OTT has completed the translation, the header file contains a C struct representation of each type specified in the <code>INTYPE</code> file, and a NULL indicator struct corresponding to each type. For example, if the employee type listed in the <code>INTYPE</code> file was defined as</p>
<pre>CREATE TYPE employee AS OBJECT
(
    name       VARCHAR2(30),
    empno      NUMBER,
    deptno     NUMBER,
    hiredate   DATE,
    salary     NUMBER
);
</pre>
<p>the header file generated by OTT (<code>demo.h</code>) includes, among other items, the following declarations:</p>
<pre>struct employee
{
    OCIString * name;
    OCINumber empno;
    OCINumber deptno;
    OCIDate   hiredate;
    OCINumber salary;
};
typedef struct emp_type emp_type;

struct employee_ind
{
    OCIInd _atomic;
    OCIInd name;
    OCIInd empno;
    OCIInd deptno;
    OCIInd hiredate;
    OCIInd salary;
};
typedef struct employee_ind employee_ind;
</pre>
<p>The datatypes that appear in the struct declarations (for example, <span class="bold">OCIString</span> and <span class="bold">OCIInd</span>) are special datatypes which were new in Oracle8. For more information about these types, see <a href="#i426569">&#34;OTT Datatype Mappings&#34;</a>.</p>
<p>The following sections describe these aspects of using OTT:</p>
<ul>
<li>
<p><a href="#i426997">Creating Types in the Database</a></p>
</li>
<li>
<p><a href="#i434134">Invoking OTT</a></p>
</li>
<li>
<p><a href="#i427005">The OTT Command Line</a></p>
</li>
<li>
<p><a href="#i432196">The INTYPE File</a></p>
</li>
<li>
<p><a href="#i426569">OTT Datatype Mappings</a></p>
</li>
<li>
<p><a href="#i427012">NULL Indicator Structs</a></p>
</li>
<li>
<p><a href="#i441900">OTT Support for Type Inheritance</a></p>
</li>
</ul>
<p>The remaining sections of the chapter discuss the use of OTT with OCI and Pro*C/C++, followed by a reference section that describes command line syntax, parameters, <code>INTYPE</code> file structure, nested <code>#include</code> file generation, schema names usage, default name mapping, and restrictions.</p>
<a id="i426997"></a>
<div id="LNPCC4437" class="sect2">
<h3 class="sect2">Creating Types in the Database<a id="sthref2217"></a></h3>
<p>The first step in using OTT is to create object types or named collection types and store them in the database. This is accomplished through the use of the SQL CREATE TYPE statement.</p>
<p><span class="bold">See Also:</span> For information about creating object types and collections, refer to <a href="pc_17obj.htm#g480794">Chapter 17, &#34;Objects&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i434134"></a>
<div id="LNPCC4438" class="sect2">
<h3 class="sect2">Invoking OTT<a id="sthref2218"></a></h3>
<p>The next step is to invoke OTT.</p>
<p>You can specify OTT parameters on the command line, or in a file called a configuration file. Certain parameters can also be specified in the <code>INTYPE</code> file.</p>
<p>If you specify a parameter in more than one place, its value on the command line will take precedence over its value in the <code>INTYPE</code> file, which takes precedence over its value in a user-defined configuration file, which takes precedence over its value in the default configuration file.</p>
<p>For global options -- that is, options on the command line or options at the beginning of the <code>INTYPE</code> file before any TYPE statements -- the value on the command line overrides the value in the <code>INTYPE</code> file. (The options that can be specified globally in the <code>INTYPE</code> file are <code>CASE</code>, <code>CODE</code>, <code>INITFILE</code>, <code>OUTDIR</code>, and <code>INITFUNC</code>, but not <code>HFILE</code>.) Anything in the <code>INTYPE</code> file in a TYPE specification applies to a particular type only, and overrides anything on the command line that would otherwise apply to the type. So if you enter <code>TYPE person HFILE=p.h</code>, it applies to <code>person</code> only and overrides the <code>HFILE</code> on the command line. The statement is not considered a command-line parameter.</p>
<div id="LNPCC4439" class="sect3"><a id="sthref2219"></a>
<h4 class="sect3">Command Line</h4>
<p>Parameters (also called options) set on the command line override any set elsewhere.</p>
<p><span class="bold">See Also:</span> For information about creating object types and collections, refer to <a href="pc_17obj.htm#g480794">Chapter 17, &#34;Objects&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4440" class="sect3"><a id="sthref2220"></a>
<h4 class="sect3">Configuration File</h4>
<p>A configuration file is a text file that contains OTT parameters. Each non-blank line in the file contains one parameter, with its associated value or values. If more than one parameter is put on a line, only the first one will be used. No whitespace may occur on any non-blank line of a configuration file.</p>
<p>A configuration file can be named on the command line. In addition, a default configuration file is always read. This default configuration file must always exist, but can be empty. The name of the default configuration file is <code>ottcfg.cfg</code>, and the location of the file is system-specific. See your platform-specific documentation for further information.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4441" class="sect3"><a id="sthref2221"></a>
<h4 class="sect3">INTYPE File</h4>
<p>The <code>INTYPE</code> file gives a list of types for OTT to translate.</p>
<p>The parameters <code>CASE</code>, <code>HFILE</code>, <code>INITFUNC</code>, and <code>INITFILE</code> can appear in the <code>INTYPE</code> file. See <a href="#i432196">&#34;The INTYPE File&#34;</a> for more information.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i427005"></a>
<div id="LNPCC4442" class="sect2">
<h3 class="sect2">The OTT Command Line<a id="sthref2222"></a></h3>
<p>On most platforms, OTT is invoked on the command line. You can specify the input and output files and the database connection information, among other things. Consult your platform-specific documentation to see how to invoke OTT on your platform.</p>
<p>The following is an example (example 1) of an OTT invocation from the command line:</p>
<pre>ott userid=scott/tiger intype=demoin.typ outtype=demoout.typ code=c hfile=demo.h
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
No spaces are permitted around the equals sign (=).</div>
<p>The following sections describe the elements of the command line used in this example.</p>
<p>For a detailed discussion of the various OTT command line options, see <a href="#i420217">&#34;OTT Reference&#34;</a>.</p>
<div id="LNPCC4443" class="sect3"><a id="sthref2223"></a>
<h4 class="sect3">OTT</h4>
<p>Causes OTT to be invoked. It must be the first item on the command line.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4444" class="sect3"><a id="sthref2224"></a>
<h4 class="sect3">Userid</h4>
<p>Specifies the database connection information which OTT will use. In example one, OTT will attempt to connect with username <span class="italic">scott</span> and password <span class="italic">tiger</span>.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4445" class="sect3"><a id="sthref2225"></a>
<h4 class="sect3">INTYPE</h4>
<p>Specifies the name of the <code>INTYPE</code> file which will be used. In example 1, the name of the <code>INTYPE</code> file is specified as <code><span class="codeinlineitalic">demoin.typ</span></code>.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4446" class="sect3"><a id="sthref2226"></a>
<h4 class="sect3">OUTTYPE</h4>
<p>Specifies the name of the <code>OUTTYPE</code> file. When OTT generates the C header file, it also writes information about the translated types into the <code>OUTTYPE</code> file. This file contains an entry for each of the types that is translated, including its version string, and the header file to which its C representation was written.</p>
<p>In example one, the name of the OUTTYPE file is specified as <code><span class="codeinlineitalic">demoout.typ</span></code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the file specified by <code>OUTTYPE</code> already exists, it will be overwritten when OTT runs, with one exception: if the contents of the file as generated by OTT are identical to the previous contents of the file, OTT will not actually write to the file. This preserves the modification time of the file so that UNIX <span class="italic">make</span> and similar facilities on other platforms do not perform unnecessary recompilations.</div>
</div>
<!-- class="sect3" -->
<div id="LNPCC4447" class="sect3"><a id="sthref2227"></a>
<h4 class="sect3">CODE</h4>
<p>Specifies the target language for the translation. The following options are available:</p>
<ul>
<li>
<p>C (equivalent to ANSI_C)</p>
</li>
<li>
<p>ANSI_C (for ANSI C)</p>
</li>
<li>
<p>KR_C (for Kernighan &amp; Ritchie C)</p>
</li>
</ul>
<p>There is currently no default value, so this parameter is required.</p>
<p>Struct declarations are identical in both C dialects. The style in which the initialization function defined in the <code>INITFILE</code> file is defined depends on whether KR_C is used. If the <code>INITFILE</code> option is not used, all three options are equivalent.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4448" class="sect3"><a id="sthref2228"></a>
<h4 class="sect3">HFILE</h4>
<p>Specifies the name of the C header file to which the generated structs should be written. In example 1, the generated structs will be stored in a file called <code>demo.h</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the file specified by <code>HFILE</code> already exists, it will be overwritten when OTT runs, with one exception: if the contents of the file as generated by OTT are identical to the previous contents of the file, OTT will not actually write to the file. This preserves the modification time of the file so that UNIX <span class="italic">make</span> and similar facilities on other platforms do not perform unnecessary recompilations.</div>
</div>
<!-- class="sect3" -->
<div id="LNPCC4449" class="sect3"><a id="sthref2229"></a>
<h4 class="sect3">INITFILE</h4>
<p>Specifies the use of the C source file into which the type initialization function is to be written.</p>
<p>The initialization function is only needed in OCI programs. In Pro*C/C++ programs, the Pro*C/C++ runtime library initializes types for the user.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the file specified by <code>INITFILE</code> already exists, it will be overwritten when OTT runs, with one exception: if the contents of the file as generated by OTT are identical to the previous contents of the file, OTT will not actually write to the file. This preserves the modification time of the file so that UNIX <span class="italic">make</span> and similar facilities on other platforms do not perform unnecessary recompilations.</div>
</div>
<!-- class="sect3" -->
<div id="LNPCC4450" class="sect3"><a id="sthref2230"></a>
<h4 class="sect3">INITFUNC</h4>
<p>Specifies the name of the initialization function to be defined in the <code>INITFILE</code>.</p>
<p>If this parameter is not used and an initialization function is generated, the name of the initialization function will be the same as the base name of the <code>INITFILE</code>.</p>
<p>This function is only needed in OCI programs.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i432196"></a>
<div id="LNPCC4451" class="sect2">
<h3 class="sect2">The INTYPE File<a id="sthref2231"></a><a id="sthref2232"></a></h3>
<p>When you run OTT, the <code>INTYPE</code> file tells OTT which database types should be translated. It can also control the naming of the generated structs. You can create the <code>INTYPE</code> file, or use the <code>OUTTYPE</code> file of a previous invocation of OTT. If the <code>INTYPE</code> parameter is not used, all types in the schema to which OTT connects are translated.</p>
<p>The following is a simple example of a user-created <code>INTYPE</code> file:</p>
<pre>CASE=LOWER
TYPE employee
  TRANSLATE SALARY$ AS salary
            DEPTNO AS department
TYPE ADDRESS
TYPE item
TYPE &#34;Person&#34;
TYPE PURCHASE_ORDER AS p_o
</pre>
<p>The first line, with the <code>CASE</code> keyword, indicates that generated C identifiers should be in lower case. However, this <code>CASE</code> option is only applied to those identifiers that are not explicitly mentioned in the <code>INTYPE</code> file. Thus, <span class="italic">employee</span> and <span class="italic">ADDRESS</span> would always result in C structures <code>employee</code> and <code>ADDRESS</code>, respectively. The members of these structures would be named in lower case.</p>
<p>See <a href="#i428925">&#34;CASE&#34;</a> for further information regarding the <code>CASE</code> option.</p>
<p>The lines that begin with the TYPE keyword specify which types in the database should be translated. In this case, the <span class="italic">EMPLOYEE, ADDRESS, ITEM, PERSON,</span> and <span class="italic">PURCHASE_ORDER</span> types.</p>
<p>The TRANSLATE...AS keywords specify that the name of an object attribute should be changed when the type is translated into a C struct. In this case, the SALARY$ attribute of the <code>employee</code> type is translated to <code>salary</code>.</p>
<p>The AS keyword in the final line specifies that the name of an object type should be changed when it is translated into a struct. In this case, the <span class="italic">purchase_order</span> database type is translated into a struct called <span class="italic">p_o</span>.</p>
<p>If you do not use AS to translate a type or attribute name, the database name of the type or attribute will be used as the C identifier name, except that the <code>CASE</code> option will be observed, and any characters that cannot be mapped to a legal C identifier character will be replaced by an underscore. Reasons for translating a type or attribute name include:</p>
<ul>
<li>
<p>the name contains characters other than letters, digits, and underscores</p>
</li>
<li>
<p>the name conflicts with a C keyword</p>
</li>
<li>
<p>the type name conflicts with another identifier in the same scope. This can happen, for example, if the program uses two types with the same name from different schemas.</p>
</li>
<li>
<p>the programmer prefers a different name</p>
</li>
</ul>
<p>OTT may need to translate additional types that are not listed in the <code>INTYPE</code> file. This is because OTT analyzes the types in the <code>INTYPE</code> file for type dependencies before performing the translation, and translates other types as necessary. For example, if the <span class="italic">ADDRESS</span> type were not listed in the <code>INTYPE</code> file, but the <span class="italic">Person</span> type had an attribute of type <span class="italic">ADDRESS</span>, OTT would still translate <span class="italic">ADDRESS</span> because it is required to define the <span class="italic">Person</span> type.</p>
<div class="infoboxnotealso">
<p class="notep1">Note:</p>
As of Release 1 (9.0.1), users may specify TRANSITIVE = FALSE to <span class="italic">not</span> generate types that are not specified in the <code>INTYPE</code> file. TRANSITIVE is set to TRUE by default.</div>
<p>A normal case-insensitive SQL identifier can be spelled in any combination of upper and lower case in the <code>INTYPE</code> file, and is not quoted.</p>
<p>Use quotation marks, such as TYPE &#34;<span class="italic">Person</span>&#34; to reference SQL identifiers that have been created in a case-sensitive manner, for example, CREATE TYPE &#34;<span class="italic">Person</span>&#34;. A SQL identifier is case-sensitive if it was quoted when it was declared.</p>
<p>Quotation marks can also be used to refer to a SQL identifier that is also an OTT-reserved word, for example, TYPE &#34;CASE&#34;. In this case, the quoted name must be in upper case if the SQL identifier was created in a case-insensitive manner, for example, CREATE TYPE Case. If an OTT-reserved word is used to refer to the name of a SQL identifier but is not quoted, OTT will report a syntax error in the <code>INTYPE</code> file.</p>
<p><span class="bold">See Also:</span> For a more detailed specification of the structure of the <code>INTYPE</code> file and the available options, see <a href="#i420386">&#34;Structure of the INTYPE File&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i426569"></a>
<div id="LNPCC4452" class="sect2">
<h3 class="sect2">OTT Datatype Mappings<a id="sthref2233"></a></h3>
<p>When OTT generates a C struct from a database type, the struct contains one element corresponding to each attribute of the object type. The datatypes of the attributes are mapped to types that are used in Oracle object data types. The datatypes found in Oracle include a set of predefined, primitive types, and provide for the creation of user-defined types, like object types and collections.</p>
<p>The set of predefined types includes standard types that are familiar to most programmers, including number and character types. It also includes datatypes that were introduced with Oracle8 (for example, BLOB or CLOB).</p>
<p>Oracle also includes a set of predefined types that are used to represent object type attributes in C structs. As an example, consider the following object type definition, and its corresponding OTT-generated struct declarations:</p>
<pre>CREATE TYPE employee AS OBJECT
(   name       VARCHAR2(30),
    empno      NUMBER,
    deptno     NUMBER,
    hiredate   DATE,
    salary$    NUMBER);
</pre>
<p>The OTT output, assuming <code>CASE=LOWER</code> and no explicit mappings of type or attribute names, is:</p>
<pre>struct employee
{   OCIString * name;
    OCINumber empno;
    OCINumber department;
    OCIDate   hiredate;
    OCINumber salary_;
};
typedef struct emp_type emp_type;
struct employee_ind
{
    OCIInd _atomic;
    OCIInd name;
    OCIInd empno;
    OCIInd department;
    OCIInd hiredate;
    OCIInd salary_;
}
typedef struct employee_ind employee_ind;
</pre>
<p>The indicator struct <code>(struct employee_ind)</code> is explained in <a href="#i427012">&#34;NULL Indicator Structs&#34;</a>.</p>
<p>The datatypes in the struct declarations&mdash;<code>OCIString</code>, <code>OCINumber</code>, <code>OCIDate</code>, <code>OCIInd</code>&mdash;are C mappings of object types introduced in Oracle8. They are used here to map the datatypes of the object type attributes. The <code>NUMBER</code> datatype of the <code>empno</code> attribute, maps to the new <code>OCINumber</code> datatype, for example. These new datatypes can also be used as the types of bind and define variables.</p>
<p><span class="bold">See Also:</span> For further information about the use of datatypes, including object datatypes in OCI applications, refer to the <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span>.</a></p>
<a id="i426677"></a>
<div id="LNPCC4453" class="sect3">
<h4 class="sect3">Mapping Object Datatypes to C</h4>
<p>This section describes the mappings of object attribute types to C types generated by OTT. <a href="#i427342">&#34;OTT Type Mapping Example&#34;</a> includes examples of many of these different mappings. <a href="#CHDFGJDA">Table 19-1</a> lists the mappings from types that can be used as attributes of object datatypes that are generated by OTT.</p>
<div id="LNPCC4454" class="tblformal">
<p class="titleintable"><a id="sthref2234"></a><a id="CHDFGJDA"></a>Table 19-1 Object Datatype Mappings for Object Type Attributes</p>
<table class="cellalignment831" title="Object Datatype Mappings for Object Type Attributes" summary="Object Datatype Mappings for Object Type Attributes" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t7">Object Attribute Types</th>
<th class="cellalignment832" id="r1c2-t7">C Mapping</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t7" headers="r1c1-t7">
<p>VARCHAR2(N)</p>
</td>
<td class="cellalignment833" headers="r2c1-t7 r1c2-t7">
<p>OCIString *</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t7" headers="r1c1-t7">
<p>VARCHAR(N)</p>
</td>
<td class="cellalignment833" headers="r3c1-t7 r1c2-t7">
<p>OCIString *</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t7" headers="r1c1-t7">
<p>CHAR(N), CHARACTER(N)</p>
</td>
<td class="cellalignment833" headers="r4c1-t7 r1c2-t7">
<p>OCIString *</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t7" headers="r1c1-t7">
<p>NUMBER, NUMBER(N), NUMBER(N,N)</p>
</td>
<td class="cellalignment833" headers="r5c1-t7 r1c2-t7">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t7" headers="r1c1-t7">
<p>NUMERIC, NUMERIC(N), NUMERIC(N,N)</p>
</td>
<td class="cellalignment833" headers="r6c1-t7 r1c2-t7">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t7" headers="r1c1-t7">
<p>REAL</p>
</td>
<td class="cellalignment833" headers="r7c1-t7 r1c2-t7">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t7" headers="r1c1-t7">
<p>INT, INTEGER, SMALLINT</p>
</td>
<td class="cellalignment833" headers="r8c1-t7 r1c2-t7">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t7" headers="r1c1-t7">
<p>FLOAT, FLOAT(N), DOUBLE PRECISION</p>
</td>
<td class="cellalignment833" headers="r9c1-t7 r1c2-t7">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t7" headers="r1c1-t7">
<p>DEC, DEC(N), DEC(N,N)</p>
</td>
<td class="cellalignment833" headers="r10c1-t7 r1c2-t7">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t7" headers="r1c1-t7">
<p>DECIMAL, DECIMAL(N), DECIMAL(N,N)</p>
</td>
<td class="cellalignment833" headers="r11c1-t7 r1c2-t7">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t7" headers="r1c1-t7">
<p>DATE</p>
</td>
<td class="cellalignment833" headers="r12c1-t7 r1c2-t7">
<p>OCIDate *</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r13c1-t7" headers="r1c1-t7">
<p>BLOB</p>
</td>
<td class="cellalignment833" headers="r13c1-t7 r1c2-t7">
<p>OCIBlobLocator *</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r14c1-t7" headers="r1c1-t7">
<p>CLOB</p>
</td>
<td class="cellalignment833" headers="r14c1-t7 r1c2-t7">
<p>OCIClobLocator *</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r15c1-t7" headers="r1c1-t7">
<p>BFILE</p>
</td>
<td class="cellalignment833" headers="r15c1-t7 r1c2-t7">
<p>OCIBFileLocator *</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r16c1-t7" headers="r1c1-t7">
<p>Nested Object Type</p>
</td>
<td class="cellalignment833" headers="r16c1-t7 r1c2-t7">
<p>C name of the nested object type.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r17c1-t7" headers="r1c1-t7">
<p>REF</p>
</td>
<td class="cellalignment833" headers="r17c1-t7 r1c2-t7">
<p>Declared using typedef; equivalent to OCIRef *.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r18c1-t7" headers="r1c1-t7">
<p>RAW(N)</p>
</td>
<td class="cellalignment833" headers="r18c1-t7 r1c2-t7">
<p>OCIRaw *</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><a href="#g454458">Table 19-2</a> shows the mappings of named collection types to object datatypes generated by OTT:</p>
<div id="LNPCC4455" class="tblformal">
<p class="titleintable"><a id="sthref2235"></a><a id="g454458"></a>Table 19-2 Object Datatype Mappings for Collection Types</p>
<table class="cellalignment831" title="Object Datatype Mappings for Collection Types" summary="Object Datatype Mappings for Collection Types" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t8">Named Collection Type</th>
<th class="cellalignment832" id="r1c2-t8">C Mapping</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t8" headers="r1c1-t8">
<p>VARRAY</p>
</td>
<td class="cellalignment833" headers="r2c1-t8 r1c2-t8">
<p>Declared using typedef; equivalent to OCIArray *.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t8" headers="r1c1-t8">
<p>NESTED TABLE</p>
</td>
<td class="cellalignment833" headers="r3c1-t8 r1c2-t8">
<p>Declared using typedef; equivalent to OCITable *.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
For REF, VARRAY, and NESTED TABLE types, OTT generates a typedef. The type declared in the typedef is then used as the type of the data member in the struct declaration. For examples, see <a href="#i427342">&#34;OTT Type Mapping Example&#34;</a>.</div>
<p>If an object type includes an attribute of a REF or collection type, a typedef for the REF or collection type is first generated. Then the struct declaration corresponding to the object type is generated. The struct includes an element whose type is a pointer to the REF or collection type.</p>
<p>If an object type includes an attribute whose type is another object type, OTT first generates the nested type (if TRANSITIVE = TRUE.) It then maps the object type attribute to a nested struct of the type of the nested object type.</p>
<p>The C datatypes to which OTT maps non-object database attribute types are structures, which, except for OCIDate, are opaque.</p>
</div>
<!-- class="sect3" -->
<a id="i427342"></a>
<div id="LNPCC4456" class="sect3">
<h4 class="sect3">OTT Type Mapping Example</h4>
<p>The following example demonstrates the various type mappings created by OTT.</p>
<p>Given the following database types:</p>
<pre>CREATE TYPE my_varray AS VARRAY(5) of integer;

CREATE TYPE object_type AS OBJECT
(object_name    VARCHAR2(20));

CREATE TYPE my_table AS TABLE OF object_type;

CREATE TYPE many_types AS OBJECT
( the_varchar    VARCHAR2(30),
  the_char       CHAR(3),
  the_blob       BLOB,
  the_clob       CLOB,
  the_object     object_type,
  another_ref    REF other_type,
  the_ref        REF many_types,
  the_varray     my_varray,
  the_table      my_table,
  the_date       DATE,
  the_num        NUMBER,
  the_raw        RAW(255));
</pre>
<p>and an <code>INTYPE</code> file that includes:</p>
<pre>CASE = LOWER
TYPE many_types
</pre>
<p>OTT would generate the following C structs:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Comments are provided here to help explain the structs. These comments are not part of actual OTT output.</div>
<pre>#ifndef MYFILENAME_ORACLE
#define MYFILENAME_ORACLE

#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

typedef OCIRef many_types_ref;
typedef OCIRef object_type_ref;
typedef OCIArray my_varray;             /* part of many_types */
typedef OCITable my_table;              /* part of many_types*/
typedef OCIRef other_type_ref;
struct object_type                      /* part of many_types */
{
   OCIString * object_name;
};
typedef struct object_type object_type;

struct object_type_ind                  /*indicator struct for*/
{                                       /*object_types*/
   OCIInd _atomic;
   OCIInd object_name;
};
typedef struct object_type_ind object_type_ind;

struct many_types
{
   OCIString *        the_varchar;
   OCIString *        the_char;
   OCIBlobLocator *   the_blob;
   OCIClobLocator *   the_clob;
   struct object_type the_object;
   other_type_ref *   another_ref;
   many_types_ref *   the_ref;
   my_varray *        the_varray;
   my_table *         the_table; 
   OCIDate            the_date;
   OCINumber          the_num;
   OCIRaw *           the_raw;
};
typedef struct many_types many_types;

struct many_types_ind                   /*indicator struct for*/
{                                       /*many_types*/
   OCIInd _atomic;
   OCIInd the_varchar;
   OCIInd the_char;
   OCIInd the_blob;
   OCIInd the_clob;
   struct object_type_ind the_object;   /*nested*/
   OCIInd another_ref;
   OCIInd the_ref;
   OCIInd the_varray;
   OCIInd the_table;
   OCIInd the_date;
   OCIInd the_num;
   OCIInd the_raw;
};
typedef struct many_types_ind many_types_ind;

#endif
</pre>
<p>Notice that even though only one item was listed for translation in the <code>INTYPE</code> file, two object types and two named collection types were translated. This is because the OTT parameter <a href="#i441568">&#34;TRANSITIVE&#34;</a>, has the default value of TRUE. As described in that section, when TRANSITIVE=TRUE, OTT automatically translates any types which are used as attributes of a type being translated, in order to complete the translation of the listed type.</p>
<p>This is not the case for types that are only accessed by a pointer or REF in an object type attribute. For example, although the <span class="italic">many_types</span> <code>type contains the attribute</code> <span class="italic">another_ref</span> <span class="italic">REF other_type</span><code>, a declaration of struct other_type</code> was not generated.</p>
<p>This example also illustrates how typedefs are used to declare VARRAY, NESTED TABLE, and REF types.</p>
<p>The typedefs occur near the beginning:</p>
<pre>typedef OCIRef many_types_ref;
typedef OCIRef object_type_ref;
typedef OCIArray my_varray;    
typedef OCITable my_table; 
typedef OCIRef other_type_ref;
</pre>
<p>In the struct <code>many_types</code>, the VARRAY, NESTED TABLE, and REF attributes are declared:</p>
<pre>struct many_types
{
   ...
   other_type_ref *   another_ref;
   many_types_ref *   the_ref;
   my_varray *        the_varray;
   my_table *         the_table;
   ...
}
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i427012"></a>
<div id="LNPCC4457" class="sect2">
<h3 class="sect2">NULL Indicator Structs</h3>
<p>Each time OTT generates a C struct to represent a database object type, it also generates a corresponding NULL indicator struct. When an object type is selected into a C struct, NULL indicator information can be selected into a parallel struct.</p>
<p>For example, the following NULL indicator struct was generated in the example in the previous section:</p>
<pre>struct many_types_ind
{
OCIInd _atomic;
OCIInd the_varchar;
OCIInd the_char;
OCIInd the_blob;
OCIInd the_clob;
struct object_type_ind the_object;
OCIInd another_ref;
OCIInd the_ref;
OCIInd the_varray;
OCIInd the_table;
OCIInd the_date;
OCIInd the_num;
OCIInd the_raw;
};
typedef struct many_types_ind many_types_ind;
</pre>
<p>The layout of the NULL struct is important. The first element in the struct (<code>_atomic</code>) is the <span class="italic">atomic NULL indicator</span>. This value indicates the NULL status for the object type as a whole. The atomic NULL indicator is followed by an indicator element corresponding to each element in the OTT-generated struct representing the object type.</p>
<p>Notice that when an object type contains another object type as part of its definition (in the earlier example, it is the <span class="italic">object_type</span> attribute), the indicator entry for that attribute is the NULL indicator struct (<code>object_type_ind</code>) corresponding to the nested object type.</p>
<p>VARRAYs and NESTED TABLEs contain the NULL information for their elements. The datatype for all other elements of a NULL indicator struct is <code>OCIInd</code>.</p>
<p><span class="bold">See Also:</span> For more information about atomic NULLness, refer to the discussion of object types in <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span>.</a></p>
</div>
<!-- class="sect2" -->
<a id="i441900"></a>
<div id="LNPCC4458" class="sect2">
<h3 class="sect2">OTT Support for Type Inheritance</h3>
<p>To support type inheritance of objects, OTT generates a C struct to represent an object subtype by declaring the inherited attributes in an encapsulated struct with the special name &#39;_super&#39;, before declaring the new attributes. Thus, for an object subtype that inherits from a supertype, the first element in the struct is named &#39;_super&#39;, followed by elements corresponding to each attribute of the subtype.The type of the element named &#39;_super&#39; is the name of the supertype.</p>
<p>For example, given the type <code>Person_t</code>, with subtype <code>Student_t</code> and subtype <code>Employee_t,</code> which are created as follows:</p>
<pre>CREATE TYPE Person_t AS OBJECT
( ssn     NUMBER,
  name    VARCHAR2(30),
  address VARCHAR2(100)) NOT FINAL;

CREATE TYPE Student_t UNDER Person_t
( deptid NUMBER,
  major  VARCHAR2(30)) NOT FINAL;

CREATE TYPE Employee_t UNDER Person_t
( empid NUMBER,
  mgr   VARCHAR2(30));
</pre>
<p>and, given an <code>INTYPE</code> file which includes:</p>
<pre>CASE=SAME
TYPE EMPLOYEE_T
TYPE STUDENT_T
TYPE PERSON_T
</pre>
<p>OTT generates the following C structs for <code>Person_t</code>, <code>Student_t</code>, and <code>Employee_t</code> and their null indicator structs:</p>
<pre>#ifndef MYFILENAME_ORACLE
#define MYFILENAME_ORACLE

#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

typedef OCIRef EMPLOYEE_T_ref;
typedef OCIRef STUDENT_T_ref;
typedef OCIRef PERSON_T_ref;

struct PERSON_T
{
   OCINumber SSN;
   OCIString * NAME;
   OCIString * ADDRESS;
};
typedef struct PERSON_T PERSON_T;

struct PERSON_T_ind
{
   OCIInd _atomic;
   OCIInd SSN;
   OCIInd NAME;
   OCIInd ADDRESS;
};
typedef struct PERSON_T_ind PERSON_T_ind;

struct EMPLOYEE_T
{
   PERSON_T _super;
   OCINumber EMPID;
   OCIString * MGR;
};
typedef struct EMPLOYEE_T EMPLOYEE_T;

struct EMPLOYEE_T_ind
{
   PERSON_T _super;
   OCIInd EMPID;
   OCIInd MGR;
};
typedef struct EMPLOYEE_T_ind EMPLOYEE_T_ind;

struct STUDENT_T
{
   PERSON_T _super;
   OCINumber DEPTID;
   OCIString * MAJOR;
};
typedef struct STUDENT_T STUDENT_T;

struct STUDENT_T_ind
{
   PERSON_T _super;
   OCIInd DEPTID;
   OCIInd MAJOR;
};
typedef struct STUDENT_T_ind STUDENT_T_ind;

#endif
</pre>
<p>The earlier C mapping convention allows simple up-casting from an instance of a subtype to an instance of a supertype in C to work properly. For example:</p>
<pre>STUDENT_T *stu_ptr = some_ptr;               /* some STUDENT_T instance  */
PERSON_T  *pers_ptr = (PERSON_T *)stu_ptr;   /* up-casting */
</pre>
<p>The null indicator structs are generated similarly. Note that for the supertype <code>Person_t</code> null indicator struct, the first element is &#39;_atomic&#39;, and that for the subtypes <code>Employee_t</code> and <code>Student_t</code> null indicator structs, the first element is &#39;_super&#39; (no atomic element is generated for subtypes).</p>
<div id="LNPCC4459" class="sect3"><a id="sthref2236"></a>
<h4 class="sect3">Substitutable Object Attributes</h4>
<p>For attributes of NOT FINAL types (and therefore potentially substitutable), the embedded attribute is represented as a pointer.</p>
<p>Consider a type <code>Book_t</code> created as:</p>
<pre>CREATE TYPE Book_t AS OBJECT 
( title   VARCHAR2(30),
  author  Person_t     /* substitutable */);
</pre>
<p>The corresponding C struct generated by OTT contains a pointer to <code>Person_t</code>:</p>
<pre>struct Book_t
{
  OCIString  *title;
  Person_t   *author;    /* pointer to Person_t struct */
}
</pre>
<p>The null indicator struct corresponding to the earlier type is:</p>
<pre>struct Book_t_ind
{ 
  OCIInd  _atomic;
  OCIInd  title;
  OCIInd  author;
}
</pre>
<p>Note that the null indicator struct corresponding to the <code>author</code> attribute can be obtained from the <code>author</code> object itself. See <a href="pc_17obj.htm#i449298">OBJECT GET</a>.</p>
<p>If a type is defined to be FINAL, it cannot have any subtypes. An attribute of a FINAL type is therefore not substitutable. In such cases, the mapping is as before: the attribute struct is inline. Now, if the type is altered and defined to be NOT FINAL, the mapping will have to change. The new mapping is generated by running OTT again.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCC4460" class="sect2"><a id="sthref2237"></a>
<h3 class="sect2">The OUTTYPE File<a id="sthref2238"></a><a id="sthref2239"></a></h3>
<p>The <code>OUTTYPE</code> file is named on the OTT command line. When OTT generates the C header file, it also writes the results of the translation into the <code>OUTTYPE</code> file. This file contains an entry for each of the types that is translated, including its version string, and the header file to which its C representation was written.</p>
<p>The <code>OUTTYPE</code> file from one OTT run can be used as the <code>INTYPE</code> file for a subsequent OTT invocation.</p>
<p>For example, given the simple <code>INTYPE</code> file used earlier in this chapter</p>
<pre>CASE=LOWER
TYPE employee
  TRANSLATE SALARY$ AS salary
            DEPTNO AS department
TYPE ADDRESS
TYPE item
TYPE person
TYPE PURCHASE_ORDER AS p_o
</pre>
<p>the user has chosen to specify the case for OTT-generated C identifiers, and has provided a list of types that should be translated. In two of these types, naming conventions are specified.</p>
<p>The following example shows what the <code>OUTTYPE</code> file looks like after running OTT:</p>
<pre>CASE = LOWER
TYPE EMPLOYEE AS employee
  VERSION = &#34;$8.0&#34;
  HFILE = demo.h
  TRANSLATE SALARY$ AS salary
             DEPTNO AS department
TYPE ADDRESS AS ADDRESS
  VERSION = &#34;$8.0&#34;
  HFILE = demo.h
TYPE ITEM AS item
  VERSION = &#34;$8.0&#34;
  HFILE = demo.h
TYPE &#34;Person&#34; AS Person
  VERSION = &#34;$8.0&#34;
  HFILE = demo.h
TYPE PURCHASE_ORDER AS p_o
  VERSION = &#34;$8.0&#34;
  HFILE = demo.h
</pre>
<p>When examining the contents of the <code>OUTTYPE</code> file, you might discover types listed that were not included in the <code>INTYPE</code> specification. For example, if the <code>INTYPE</code> file only specified that the <span class="italic">person</span> type was to be translated:</p>
<pre>CASE = LOWER
TYPE PERSON
</pre>
<p>and the definition of the person type includes an attribute of type <span class="italic">address</span>, then the <code>OUTTYPE</code> file will include entries for both <code>PERSON</code> and <code>ADDRESS</code>. The <code>person</code> type cannot be translated completely without first translating <span class="italic">address</span>.</p>
<p>When the parameter TRANSITIVE has been set to TRUE (it is the default), OTT analyzes the types in the <code>INTYPE</code> file for type dependencies before performing the translation, and translates other types as necessary.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i427628"></a>
<div id="LNPCC4461" class="sect1">
<h2 class="sect1">Using OTT with OCI Applications<a id="sthref2240"></a></h2>
<p>C header and implementation files that have been generated by OTT can be used by an OCI application that accesses objects in a database server. Incorporate the header file into the OCI code with an <code>#include</code> statement.</p>
<p>Once the header file has been included, the OCI application can access and manipulate object data in the host language format.</p>
<p><a href="#i440389">Figure 19-1</a> shows the steps involved in using OTT with OCI.</p>
<ol>
<li>
<p>SQL is used to create type definitions in the database.</p>
</li>
<li>
<p>OTT generates a header file containing C representations of object types and named collection types. It also generates an implementation file, as named with the <code>INITFILE</code> option.</p>
</li>
<li>
<p>The application is written. User-written code in the OCI application declares and calls the <code>INITFUNC</code> function.</p>
</li>
<li>
<p>The header file is included in an OCI source code file.</p>
</li>
<li>
<p>The OCI application, including the implementation file generated by OTT, is compiled and linked with the OCI libraries.</p>
</li>
<li>
<p>The OCI executable is run against the Oracle Server.</p>
</li>
</ol>
<div id="LNPCC4462" class="figure">
<p class="titleinfigure"><a id="i440389"></a>Figure 19-1 Using OTT with OCI</p>
<img width="496" height="454" src="img/lnpcc072.gif" alt="Description of Figure 19-1 follows"/><br/>
<a id="sthref2241" href="img_text/lnpcc072.htm">Description of &#34;Figure 19-1 Using OTT with OCI&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<a id="i424522"></a>
<div id="LNPCC4463" class="sect2">
<h3 class="sect2">Accessing and Manipulating Objects with OCI<a id="sthref2242"></a><a id="sthref2243"></a><a id="sthref2244"></a></h3>
<p>Within the application, the OCI program can perform bind and define operations using program variables declared to be of types that appear in the OTT-generated header file.</p>
<p>For example, an application might fetch a REF to an object using a SQL SELECT statement and then pin that object using the appropriate OCI function. Once the object has been pinned, its attribute data can be accessed and manipulated with other OCI functions.</p>
<p>OCI includes a set of datatype mapping and manipulation functions specifically designed to work on attributes of object types and named collection types.</p>
<p>Some of the available functions follow:</p>
<ul>
<li>
<p><code>OCIStringSize()</code> gets the size of an <code>OCIString</code> string.</p>
</li>
<li>
<p><code>OCINumberAdd()</code> adds two <code>OCINumber</code> numbers together.</p>
</li>
<li>
<p><code>OCILobIsEqual()</code> compares two LOB locators for equality.</p>
</li>
<li>
<p><code>OCIRawPtr()</code> gets a pointer to an <code>OCIRaw</code> raw datatype.</p>
</li>
<li>
<p><code>OCICollAppend()</code> appends an element to a collection type (<code>OCIArray</code> or <code>OCITable</code>).</p>
</li>
<li>
<p><code>OCITableFirst()</code> returns the index for the first existing element of a nested table (<code>OCITable</code>).</p>
</li>
<li>
<p><code>OCIRefIsNull()</code> tests if a REF (<code>OCIRef)</code> is NULL</p>
</li>
</ul>
<p>These functions are described in detail in the following chapters of the <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a>:</p>
<ul>
<li>
<p>Chapter 2, which covers OCI concepts, including binding and defining</p>
</li>
<li>
<p>Chapter 6, which covers object access and navigation</p>
</li>
<li>
<p>Chapter 7, which covers datatype mapping and manipulation</p>
</li>
<li>
<p>Chapter 12, which lists datatype mapping and manipulation functions</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCC4464" class="sect2"><a id="sthref2245"></a>
<h3 class="sect2">Calling the Initialization Function<a id="sthref2246"></a></h3>
<p>OTT generates a C initialization function if requested. The initialization function tells the environment, for each object type used in the program, which version of the type is used. You can specify a name for the initialization function when invoking OTT with the <code>INITFUNC</code> option, or may allow OTT to select a default name based on the name of the implementation file (<code>INITFILE</code>) containing the function.</p>
<p>The initialization function takes two arguments, an environment handle pointer and an error handle pointer. There is typically a single initialization function, but this is not required. If a program has several separately compiled pieces requiring different types, you may want to execute OTT separately for each piece requiring, for each piece, one initialization file, containing an initialization function.</p>
<p>After you create an environment handle by an explicit OCI object call, for example, by calling <code>OCIEnvInit()</code>, you must also call the initialization functions explicitly for each environment handle. This gives each handle access to all the datatypes used in the entire program.</p>
<p>If an environment handle is implicitly created using embedded SQL statements, such as EXEC SQL CONTEXT USE and EXEC SQL CONNECT, the handle is initialized implicitly, and the initialization functions need not be called. This is relevant for Pro*C/C++ applications, or when Pro*C/C++ is being combined with OCI applications.</p>
<p>The following example shows an initialization function.</p>
<p>Given an <code>INTYPE</code> file, ex2c.typ, containing</p>
<pre>TYPE SCOTT.PERSON
TYPE SCOTT.ADDRESS
</pre>
<p>and the command line</p>
<pre>ott userid=scott/tiger intype=ex2c outtype=ex2co hfile=ex2ch.h initfile=ex2cv.c
</pre>
<p>OTT generates the following to the file ex2cv.c:</p>
<pre>#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

sword ex2cv(OCIEnv *env, OCIError *err)
{
   sword status = OCITypeVTInit(env, err);
   if (status == OCI_SUCCESS)
      status = OCITypeVTInsert(env, err,
          &#34;SCOTT&#34;, 5,
          &#34;PERSON&#34;, 6,
          &#34;$8.0&#34;, 4);
    if (status == OCI_SUCCESS)
        status = OCITypeVTInsert(env, err,
           &#34;SCOTT&#34;, 5,
           &#34;ADDRESS&#34;, 7,
           &#34;$8.0&#34;, 4);
    return status;
}
</pre>
<p>The function <span class="italic">ex2cv</span> creates the type version table and inserts the types SCOTT.PERSON and SCOTT.ADDRESS.</p>
<p>If a program explicitly creates an environment handle, all the initialization functions must be generated, compiled, and linked, because they must be called for each explicitly created handle. If a program does not explicitly create any environment handles, initialization functions are not required.</p>
<p>A program that uses an OTT-generated header file must also use the initialization function generated at the same time. More precisely, if a header file generated by OTT is included in a compilation that generates code that is linked into program P, and an environment handle is explicitly created somewhere in program P, the implementation file generated by the same invocation of OTT must also be compiled and linked into program P. Doing this correctly is your responsibility.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4465" class="sect2"><a id="sthref2247"></a>
<h3 class="sect2">Tasks of the Initialization Function<a id="sthref2248"></a></h3>
<p>The C initialization function supplies version information about the types processed by OTT. It adds to the type-version table the name and version identifier of every OTT-processed object datatype.</p>
<p>The type-version table is used by the Open Type Manager (OTM) to determine which version of a type a particular program uses. Different initialization functions generated by OTT at different times may add some of the same types to the type version table. When a type is added more than once, OTM ensures that the same version of the type is registered each time.</p>
<p>It is the OCI programmer&#39;s responsibility to declare a function prototype for the initialization function, and to call the function.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In the current release of Oracle, each type has only one version. Initialization of the type version table is required only for compatibility with future releases of Oracle.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i420213"></a>
<div id="LNPCC4466" class="sect1">
<h2 class="sect1">Using OTT with Pro*C/C++ Applications<a id="sthref2249"></a><a id="sthref2250"></a></h2>
<p>When building Pro*C/C++ applications, the type-translation process can be simpler than when building OCI-based applications. This is because precompiler-generated code will automatically initialize the type version table.</p>
<p>A C header file generated by OTT can be used by a Pro*C/C++ application to access objects in a database server. The header file is incorporated into the code with an <code>#include</code> statement. Once the header file has been included, the Pro*C/C++ application can access and manipulate object data in the host language format.</p>
<p><a href="#i440384">Figure 19-2</a> shows the steps involved in using OTT with Pro*C/C++.</p>
<ol>
<li>
<p>SQL is used to create type definitions in the database.</p>
</li>
<li>
<p>OTT generates a header file containing C representations of object types, REF types, and named collection types. It also generates an <code>OUTTYPE</code> file that is passed as the <code>INTYPE</code> parameter to Pro*C/C++.</p>
</li>
<li>
<p>The header file is included in a Pro*C/C++ source code file.</p>
</li>
<li>
<p>The Pro*C/C++ application is compiled and linked with the Pro*C/C++ run-time library SQLLIB.</p>
</li>
<li>
<p>The Pro*C/C++ executable is run against the Oracle Server.</p>
</li>
</ol>
<div id="LNPCC4467" class="figure">
<p class="titleinfigure"><a id="i440384"></a>Figure 19-2 Building an Object-oriented Pro*C/C++ Application</p>
<img width="496" height="447" src="img/lnpcc068.gif" alt="Description of Figure 19-2 follows"/><br/>
<a id="sthref2251" href="img_text/lnpcc068.htm">Description of &#34;Figure 19-2 Building an Object-oriented Pro*C/C++ Application&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>As noted in step 2, earlier, the <code>OUTTYPE</code> file generated by OTT serves a special purpose for Pro*C/C++ programmers. Pass the <code>OUTTYPE</code> file to the new <code>INTYPE</code> command line parameter when invoking Pro*C/C++. The contents of this file are used by the precompiler to determine which database types correspond to which OTT-generated structs. OCI programmers must make this association explicitly through the use of special bind, define, and type information access functions.</p>
<p>Also, the precompiler generates code to initialize the type version table with the types named in the OTT <code>OUTTYPE</code> (Pro*C/C++ <code>INTYPE</code>) file.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle recommends that the <code>OUTTYPE</code> file from OTT always serve as the <code>INTYPE</code> file to Pro*C/C++. It would be possible for you to write an <code>INTYPE</code> file for Pro*C/C++, but this is not recommended, due to the possibility of errors being introduced.</div>
<p>One way to manipulate the attributes of objects retrieved from the server is to call the OCI datatype mapping and manipulation functions. Before doing this, the application must first call <code>SQLEnvGet()</code> to obtain an OCI environment handle to pass to the OCI functions, and <code>SQLSvcCtxGet()</code> to obtain an OCI service context to pass to the OCI functions. There are also Pro*C facilities that can be used to manipulate object attributes. See <a href="pc_17obj.htm#g480794">Chapter 17, &#34;Objects&#34;</a> for more information.</p>
<p>The process of calling OCI functions from Pro*C/C++ is described briefly in <a href="#i424522">&#34;Accessing and Manipulating Objects with OCI&#34;</a>, and in more detail in Chapter 8 of <a class="olink LNOCI030" href="../LNOCI/oci03typ.htm#LNOCI030"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span>.</a></p>
</div>
<!-- class="sect1" -->
<a id="i420217"></a>
<div id="LNPCC4468" class="sect1">
<h2 class="sect1">OTT Reference<a id="sthref2252"></a></h2>
<p>Behavior of OTT is controlled by parameters which can appear on the OTT command line or in a CONFIG file. Certain parameters may also appear in the <code>INTYPE</code> file. This section provides detailed information about the following topics:</p>
<ul>
<li>
<p><a href="#i428059">OTT Command Line Syntax</a></p>
</li>
<li>
<p><a href="#i428064">OTT Parameters</a></p>
</li>
<li>
<p><a href="#i428069">Where OTT Parameters Can Appear</a></p>
</li>
<li>
<p><a href="#i420386">Structure of the INTYPE File</a></p>
</li>
<li>
<p><a href="#i432204">Nested #include File Generation</a></p>
</li>
<li>
<p><a href="#i432208">SCHEMA_NAMES Usage</a></p>
</li>
<li>
<p><a href="#i433388">Default Name Mapping</a></p>
</li>
<li>
<p><a href="#i432220">Restriction</a></p>
</li>
</ul>
<p>The following conventions are used in this chapter to describe OTT syntax:</p>
<ul>
<li>
<p>Italic strings are to be supplied by the user.</p>
</li>
<li>
<p>Strings in UPPERCASE are entered as shown, except that case is not significant.</p>
</li>
<li>
<p>Square brackets [...] enclose optional items.</p>
</li>
<li>
<p>An ellipsis (...) immediately following an item (or items enclosed in brackets) means that the item can be repeated any number of times.</p>
</li>
<li>
<p>Punctuation symbols other than those described earlier are entered as shown. These include &#39;.&#39;, &#39;@&#39;, and so on.</p>
</li>
</ul>
<a id="i428059"></a>
<div id="LNPCC4469" class="sect2">
<h3 class="sect2">OTT Command Line Syntax<a id="sthref2253"></a></h3>
<p>The OTT command-line interface is used when explicitly invoking OTT to translate database types into C structs. This is always required when developing OCI applications or Pro*C/C++ applications that use objects.</p>
<p>An OTT command-line statement consists of the keyword <code>OTT</code>, followed by a list of OTT parameters.</p>
<p>The parameters that can appear on an OTT command-line statement are as follows:</p>
<pre>   [USERID=<span class="italic">username</span>/<span class="italic">password</span>[@<span class="italic">db_name</span>]]
   [INTYPE=<span class="italic">in_filename</span>]
   OUTTYPE=<span class="italic">out_filename</span>
   CODE={C|ANSI_C|KR_C}
   [HFILE=<span class="italic">filename</span>]
   [ERRTYPE=<span class="italic">filename</span>]
   [CONFIG=<span class="italic">filename</span>]
   [INITFILE=<span class="italic">filename</span>]
   [INITFUNC=<span class="italic">filename</span>]
   [CASE={SAME|LOWER|UPPER|OPPOSITE}]
   [SCHEMA_NAMES={ALWAYS|IF_NEEDED|FROM_INTYPE}]
   [TRANSITIVE=TRUE|FALSE]
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Generally, the order of the parameters following the OTT command does not matter, and only the <code>OUTTYPE</code> and <code>CODE</code> parameters are always required.</div>
<p>The <code>HFILE</code> parameter is almost always used. If omitted, <code>HFILE</code> must be specified individually for each type in the <code>INTYPE</code> file. If OTT determines that a type not listed in the <code>INTYPE</code> file must be translated, an error will be reported. Therefore, it is safe to omit the <code>HFILE</code> parameter only if the <code>INTYPE</code> file was previously generated as an OTT <code>OUTTYPE</code> file.</p>
<p>If the <code>INTYPE</code> file is omitted, the entire schema will be translated. See the parameter descriptions in the following section for more information.</p>
<p>The following is an example of an OTT command line statement (enter it as one line):</p>
<pre>OTT userid=scott/tiger intype=in.typ outtype=out.typ code=c hfile=demo.h errtype=demo.tls case=lower
</pre>
<p>Each of the OTT command line parameters is described in the following sections.</p>
</div>
<!-- class="sect2" -->
<a id="i428064"></a>
<div id="LNPCC4470" class="sect2">
<h3 class="sect2">OTT Parameters<a id="ABC456197"></a></h3>
<p>Enter parameters on the OTT command line using the following format:</p>
<p><span class="italic">parameter</span>=<span class="italic">value</span></p>
<p>where <span class="italic">parameter</span> is the literal parameter string and <span class="italic">value</span> is a valid parameter setting. The literal parameter string is not case sensitive.</p>
<p>Separate command-line parameters using either spaces or tabs.</p>
<p>Parameters can also appear within a configuration file, but, in that case, no whitespace is permitted within a line, and each parameter must appear on a separate line. Additionally, the parameters <code>CASE</code>, <code>HFILE</code>, <code>INITFUNC</code>, and <code>INITFILE</code> can appear in the <code>INTYPE</code> file.</p>
<div id="LNPCC4471" class="sect3"><a id="sthref2254"></a>
<h4 class="sect3"><a id="sthref2255"></a><a id="sthref2256"></a>USERID</h4>
<p>The USERID parameter specifies the Oracle username, password, and optional database name (Oracle Net database specification string). If the database name is omitted, the default database is assumed. The syntax of this parameter is:</p>
<pre>USERID=<span class="italic">username</span>/<span class="italic">password</span>[@<span class="italic">db_name</span>]
</pre>
<p>If this is the first parameter, &#34;USERID=&#34; may be omitted as shown here:</p>
<pre>OTT <span class="italic">username</span>/<span class="italic">password...</span>
</pre>
<p>The USERID parameter is optional. If you omit it, OTT automatically attempts to connect to the default database as user CLUSTER$<span class="italic">username</span>, where <span class="italic">username</span> is the user&#39;s operating system user name.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4472" class="sect3"><a id="sthref2257"></a>
<h4 class="sect3">INTYPE<a id="sthref2258"></a><a id="sthref2259"></a></h4>
<p>The <code>INTYPE</code> parameter specifies the name of the file from which to read the list of object type specifications. OTT translates each type in the list. The syntax for this parameter is</p>
<pre>INTYPE=<span class="italic">filename</span>
</pre>
<p>&#34;<code>INTYPE=</code>&#34; may be omitted if USERID and <code>INTYPE</code> are the first two parameters, in that order, and &#34;USERID=&#34; is omitted. If <code>INTYPE</code> is not specified, all types in the user&#39;s schema will be translated.</p>
<pre>OTT <span class="italic">username</span>/<span class="italic">password filename...</span>
</pre>
<p>The <code>INTYPE</code> file can be thought of as a makefile for type declarations. It lists the types for which C struct declarations are needed. The format of the <code>INTYPE</code> file is described in <a href="#i420386">&#34;Structure of the INTYPE File&#34;</a>.</p>
<p>If the file name on the command line or in the <code>INTYPE</code> file does not include an extension, a platform-specific extension such as &#34;TYP&#34; or &#34;typ&#34; will be added.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4473" class="sect3"><a id="sthref2260"></a>
<h4 class="sect3">OUTTYPE<a id="sthref2261"></a><a id="sthref2262"></a></h4>
<p>The name of a file into which OTT will write type information for all the object datatypes it processes. This includes all types explicitly named in the <code>INTYPE</code> file, and may include additional types that are translated (if TRANSITIVE=TRUE) because they are used in the declarations of other types that need to be translated. This file may be used as an <code>INTYPE</code> file in a future invocation of OTT.</p>
<pre>OUTTYPE=<span class="italic">filename</span>
</pre>
<p>If the <code>INTYPE</code> and <code>OUTTYPE</code> parameters refer to the same file, the new <code>INTYPE</code> information replaces the old information in the <code>INTYPE</code> file. This provides a convenient way for the same <code>INTYPE</code> file to be used repeatedly in the cycle of altering types, generating type declarations, editing source code, precompiling, compiling, and debugging.</p>
<p><code>OUTTYPE</code> must be specified.</p>
<p>If the file name on the command line or in the <code>INTYPE</code> file does not include an extension, a platform-specific extension such as &#34;TYP&#34; or &#34;typ&#34; will be added.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4474" class="sect3"><a id="sthref2263"></a>
<h4 class="sect3">CODE<a id="sthref2264"></a><a id="sthref2265"></a></h4>
<pre>CODE= C|KR_C|ANSI_C
</pre>
<p>This is the desired host language for OTT output, that may be specified as <code>CODE=C</code>, <code>CODE=KR_C</code>, or <code>CODE=ANSI_C</code>. &#34;<code>CODE=C</code>&#34; is equivalent to &#34;<code>CODE=ANSI_C</code>&#34;.</p>
<p>There is no default value for this parameter; it must be supplied.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4475" class="sect3"><a id="sthref2266"></a>
<h4 class="sect3">INITFILE<a id="sthref2267"></a><a id="sthref2268"></a></h4>
<p>The <code>INITFILE</code> parameter specifies the name of the file where the OTT-generated initialization file is to be written. OTT does not generate the initialization function if you omit this parameter.</p>
<p>For Pro*C/C++ programs, the <code>INITFILE</code> is not necessary, because the SQLLIB run-time library performs the necessary initializations. An OCI program user must compile and link the <code>INITFILE</code> file(s), and must call the initialization function(s) when an environment handle is created.</p>
<p>If the file name of an <code>INITFILE</code> on the command line or in the <code>INTYPE</code> file does not include an extension, a platform-specific extension such as &#34;C&#34; or &#34;.c&#34; will be added.</p>
<pre>INITFILE=<span class="italic">filename</span>
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC4476" class="sect3"><a id="sthref2269"></a>
<h4 class="sect3">INITFUNC<a id="sthref2270"></a><a id="sthref2271"></a></h4>
<p>The <code>INITFUNC</code> parameter is used only in OCI programs. It specifies the name of the initialization function generated by OTT. If this parameter is omitted, the name of the initialization function is derived from the name of the <code>INITFILE</code>.</p>
<pre>INITFUNC=<span class="italic">filename</span>
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC4477" class="sect3"><a id="sthref2272"></a>
<h4 class="sect3">HFILE<a id="sthref2273"></a><a id="sthref2274"></a></h4>
<p>The name of the include (.h) file to be generated by OTT for the declarations of types that are mentioned in the <code>INTYPE</code> file but whose include files are not specified there. This parameter is required unless the include file for each type is specified individually in the <code>INTYPE</code> file. This parameter is also required if a type not mentioned in the <code>INTYPE</code> file must be generated because other types require it (if TRANSITIVE=TRUE), and these other types are declared in two or more different files.</p>
<p>If the file name of an <code>HFILE</code> on the command line or in the <code>INTYPE</code> file does not include an extension, a platform-specific extension such as &#34;H&#34; or &#34;.h&#34; will be added.</p>
<pre>HFILE=<span class="italic">filename</span>
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC4478" class="sect3"><a id="sthref2275"></a>
<h4 class="sect3">CONFIG<a id="sthref2276"></a><a id="sthref2277"></a></h4>
<p>The CONFIG parameter specifies the name of the OTT configuration file, that lists commonly used parameter specifications. Parameter specifications are also read from a system configuration file in a platform-dependent location. All remaining parameter specifications must appear on the command line, or in the <code>INTYPE</code> file.</p>
<pre>CONFIG=<span class="italic">filename</span> 
</pre>
<p><span class="bold">Note</span>: A CONFIG parameter is not allowed in the CONFIG file.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4479" class="sect3"><a id="sthref2278"></a>
<h4 class="sect3">ERRTYPE<a id="sthref2279"></a><a id="sthref2280"></a></h4>
<p>If you supply this parameter, a listing of the <code>INTYPE</code> file is written to the ERRTYPE file, along with all informational and error messages. Informational and error messages are sent to the standard output whether or not ERRTYPE is specified.</p>
<p>Essentially, the ERRTYPE file is a copy of the <code>INTYPE</code> file with error messages added. In most cases, an error message will include a pointer to the text that caused the error.</p>
<p>If the file name of an ERRTYPE on the command line or in the <code>INTYPE</code> file does not include an extension, a platform-specific extension such as &#34;TLS&#34; or &#34;tls&#34; will be added.</p>
<pre>ERRTYPE=<span class="italic">filename</span>
</pre></div>
<!-- class="sect3" -->
<a id="i428925"></a>
<div id="LNPCC4480" class="sect3">
<h4 class="sect3">CASE<a id="sthref2281"></a><a id="sthref2282"></a></h4>
<p>This parameter affects the case of certain C identifiers generated by OTT. The possible values of <code>CASE</code> are <code>SAME</code>, <code>LOWER</code>, <code>UPPER</code>, and <code>OPPOSITE</code>. If <code>CASE = SAME</code>, the case of letters is not changed when converting database type and attribute names to C identifiers. If <code>CASE=LOWER</code>, all uppercase letters are converted to lowercase. If <code>CASE=UPPER</code>, all lowercase letters are converted to uppercase. If <code>CASE=OPPOSITE</code>, all uppercase letters are converted to lower-case, and vice-versa.</p>
<pre>CASE=[SAME|LOWER|UPPER|OPPOSITE]
</pre>
<p>This parameter affects only those identifiers (attributes or types not explicitly listed) not mentioned in the <code>INTYPE</code> file. Case conversion takes place after a legal identifier has been generated.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The case of the C struct identifier for a type specifically mentioned in the <code>INTYPE</code> is the same as its case in the <code>INTYPE</code> file. For example, if the <code>INTYPE</code> file includes the following line</div>
<pre>TYPE Worker
</pre>
<p>then OTT will generate</p>
<pre>struct Worker {...};
</pre>
<p>On the other hand, if the <code>INTYPE</code> file were written as</p>
<pre>TYPE wOrKeR
</pre>
<p>OTT would generate</p>
<pre>struct wOrKeR {...};
</pre>
<p>following the case of the <code>INTYPE</code> file.</p>
<p>Case-insensitive SQL identifiers not mentioned in the <code>INTYPE</code> file will appear in upper case if <code>CASE=SAME</code>, and in lower case if <code>CASE=OPPOSITE</code>. A SQL identifier is case-insensitive if it was not quoted when it was declared.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4481" class="sect3"><a id="sthref2283"></a>
<h4 class="sect3">SCHEMA_NAMES<a id="sthref2284"></a><a id="sthref2285"></a></h4>
<p>This parameter offers control in qualifying the database name of a type from the default schema with a schema name in the <code>OUTTYPE</code> file. The <code>OUTTYPE</code> file generated by OTT contains information about the types processed by OTT, including the type names.<a id="sthref2286"></a></p>
<p>See <a href="#i432208">&#34;SCHEMA_NAMES Usage&#34;</a> for further information.</p>
</div>
<!-- class="sect3" -->
<a id="i441568"></a>
<div id="LNPCC4482" class="sect3">
<h4 class="sect3">TRANSITIVE<a id="sthref2287"></a><a id="sthref2288"></a></h4>
<p>Takes the values TRUE (the default) or FALSE. Indicates whether type dependencies not explicitly listed in the <code>INTYPE</code> file are to be translated, or not. If TRANSITIVE=FALSE is specified, then types <span class="italic">not</span> mentioned in the <code>INTYPE</code> file are not generated. This is the case even if they were used as attribute types of other generated types.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i428069"></a>
<div id="LNPCC4483" class="sect2">
<h3 class="sect2">Where OTT Parameters Can Appear<a id="sthref2289"></a></h3>
<p>Supply OTT parameters on the command line, in a CONFIG file named on the command line, or both. Some parameters are also allowed in the <code>INTYPE</code> file.</p>
<p>OTT is invoked as follows:</p>
<p>OTT <span class="italic">username/password</span> parameters</p>
<p>If one of the parameters on the command line is</p>
<p>CONFIG=<span class="italic">filename</span></p>
<p>additional parameters are read from the configuration file named <span class="italic">filename</span>.</p>
<p>In addition, parameters are also read from a default configuration file in a platform-dependent location. This file must exist, but can be empty. Each line in the configuration may contain one parameter, with no whitespace on the line.</p>
<p>If OTT is executed without any arguments, an on-line parameter reference is displayed.</p>
<p>The types for OTT to translate are named in the file specified by the <code>INTYPE</code> parameter. The parameters <code>CASE</code>, <code>INITFILE</code>, <code>INITFUNC</code>, and <code>HFILE</code> may also appear in the <code>INTYPE</code> file. <code>OUTTYPE</code> files generated by OTT include the <code>CASE</code> parameter, and include the <code>INITFILE</code>, and <code>INITFUNC</code> parameters if an initialization file was generated. The <code>OUTTYPE</code> file specifies the <code>HFILE</code> individually for each type.</p>
<p>The case of the OTT command is platform-dependent.</p>
</div>
<!-- class="sect2" -->
<a id="i420386"></a>
<div id="LNPCC4484" class="sect2">
<h3 class="sect2">Structure of the INTYPE File</h3>
<p>The <code>INTYPE</code> and <code>OUTTYPE</code> files<a id="sthref2290"></a><a id="sthref2291"></a><a id="sthref2292"></a> list the types translated by OTT and provide all the information needed to determine how a type or attribute name is translated to a legal C identifier. These files contain one or more type specifications. These files also may contain specifications of the following options:</p>
<ul>
<li>
<p><code>CASE</code></p>
</li>
<li>
<p><code>HFILE</code></p>
</li>
<li>
<p><code>INITFILE</code></p>
</li>
<li>
<p><code>INITFUNC</code></p>
</li>
</ul>
<p>If the <code>CASE</code>, <code>INITFILE</code>, or <code>INITFUNC</code> options are present, they must precede any type specifications. If these options appear both on the command line and in the <code>INTYPE</code> file, the value on the command line is used.</p>
<p>For an example of a simple user-defined <code>INTYPE</code> file, and of the full <code>OUTTYPE</code> file that OTT generates from it, see <a href="#i441900">&#34;OTT Support for Type Inheritance&#34;</a>.</p>
<div id="LNPCC4485" class="sect3"><a id="sthref2293"></a>
<h4 class="sect3">INTYPE File Type Specifications</h4>
<p>A type specification in the <code>INTYPE</code> names an object datatype that is to be translated. The following is an example of a user-created <code>INTYPE</code> file:</p>
<pre>TYPE employee
  TRANSLATE SALARY$ AS salary
            DEPTNO AS department
TYPE ADDRESS
TYPE PURCHASE_ORDER AS p_o
</pre>
<p>The structure of a type specification is as follows:</p>
<pre>TYPE type_name [AS type_identifier]
[VERSION [=] version_string]
[HFILE [=] hfile_name]
[TRANSLATE{member_name [AS identifier]}...]
</pre>
<p>The syntax of <span class="italic">type_name</span> is:</p>
<pre>[schema_name.]type_name
</pre>
<p>where <span class="italic">schema_name</span> is the name of the schema that owns the given object datatype, and <span class="italic">type_name</span> is the name of the type. The default schema is that of the user running OTT. The default database is the local database.</p>
<p>The components of a type specification are:</p>
<ul>
<li>
<p><span class="italic">type name</span> is the name of an object datatype.</p>
</li>
<li>
<p><span class="italic">type identifier</span> is the C identifier used to represent the type. If omitted, the default name mapping algorithm will be used. For further information, see <a href="#i433388">&#34;Default Name Mapping&#34;</a>.</p>
</li>
<li>
<p><span class="italic">version string</span> is the version string of the type that was used when the code was generated by a previous invocation of OTT. The version string is generated by OTT and written to the <code>OUTTYPE</code> file, that may later be used as the <code>INTYPE</code> file when OTT is later executed. The version string does not affect the OTT&#39;s operation, but will eventually be used to select which version of the object datatype should be used in the running program.</p>
</li>
<li>
<p><span class="italic">hfile name</span> is the name of the header file in which the declarations of the corresponding struct or class appears or will appear. If <span class="italic">hfile name</span> is omitted, the file named by the command-line <code>HFILE</code> parameter will be used if a declaration is generated.</p>
</li>
<li>
<p><span class="italic">member name</span> is the name of an attribute (data member) which is to be translated to the following <span class="italic">identifier</span>.</p>
</li>
<li>
<p><span class="italic">identifier</span> is the C identifier used to represent the attribute in the user program. You can specify identifiers in this way for any number of attributes. The default name mapping algorithm will be used for the attributes that are not mentioned.</p>
</li>
</ul>
<p>An object datatype may need to be translated for one of two reasons:</p>
<ul>
<li>
<p>It appears in the <code>INTYPE</code> file.</p>
</li>
<li>
<p>It is required to declare another type that must be translated, and TRANSITIVE = TRUE.</p>
</li>
</ul>
<p>If a type that is not mentioned explicitly is required by types declared in exactly one file, the translation of the required type is written to the same file(s) as the explicitly declared types that require it.</p>
<p>If a type that is not mentioned explicitly is required by types declared in two or more different files, the translation of the required type is written to the global <code>HFILE</code> file.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i432204"></a>
<div id="LNPCC4486" class="sect2">
<h3 class="sect2">Nested #include File Generation</h3>
<p>Every <code>HFILE</code> generated by OTT <code>#includes</code> other necessary files, and <code>#defines</code> a symbol constructed from the name of the file, that may be used to determine if the <code>HFILE</code> has already been included. Consider, for example, a database with the following types:</p>
<pre>create type px1 AS OBJECT (col1 number, col2 integer);
create type px2 AS OBJECT (col1 px1);
create type px3 AS OBJECT (col1 px1);
</pre>
<p>where the <code>INTYPE</code> file contains:</p>
<pre>CASE=lower
type pxl
  hfile tott95a.h
type px3
  hfile tott95b.h
</pre>
<p>If we invoke OTT with</p>
<pre>ott scott/tiger tott95i.typ outtype=tott95o.typ code=c
</pre>
<p>then it will generate the two following header files.</p>
<p>File tott95b.h is:</p>
<pre>#ifndef TOTT95B_ORACLE
#define TOTT95B_ORACLE
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
#ifndef TOTT95A_ORACLE
#include &#34;tott95a.h&#34;
#endif
typedef OCIRef px3_ref;
struct px3
{
   struct px1 col1;
};
typedef struct px3 px3;
struct px3_ind
{
   OCIInd _atomic;
   struct px1_ind col1
};
typedef struct px3_ind px3_ind;
#endif
</pre>
<p>File tott95a.h is:</p>
<pre>#ifndef TOTT95A_ORACLE
#define TOTT95A_ORACLE
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
typedef OCIRef px1_ref;
struct px1
{
   OCINumber col1;
   OCINumber col2;
}
typedef struct px1 px1;
struct px1_ind
{
   OCIInd _atomic;
   OCIInd col1;
   OCIInd col2;
}
typedef struct px1_ind px1_ind;
#endif
</pre>
<p>In this file, the symbol TOTT95B_ORACLE is defined first so that the programmer may conditionally include <code>tott95b.h</code> without having to worry whether <code>tott95b.h</code> depends on the include file using the following construct:</p>
<pre>#ifndef TOTT95B_ORACLE
#include &#34;tott95b.h&#34;
#endif
</pre>
<p>Using this technique, you can include &#34;tott95b.h&#34; from some file, say &#34;foo.h&#34;, without having to know whether some other file included by &#34;foo.h&#34; also includes &#34;tott95b.h&#34;.</p>
<p>After the definition of the symbol TOTT95B_ORACLE, the file <code>oci.h</code> is <code>#includ</code>ed. Every <code>HFILE</code> generated by OTT includes <code>oci.h</code>, that contains type and function declarations that the Pro*C/C++ or OCI programmer will find useful. This is the only case in which OTT uses angle brackets in an <code>#include</code>.</p>
<p>Next, the file <code>tott95a.h</code> is included because it contains the declaration of &#34;struct px1&#34;, that <code>tott95b.h</code> requires. When the <code>INTYPE</code> file requests that type declarations be written to more than one file, OTT will determine which other files each <code>HFILE</code> must include, and will generate the necessary <code>#includes</code>.</p>
<p>Note that OTT uses quotes in this <code>#include</code>. When a program including <code>tott95b.h</code> is compiled, the search for <code>tott95a.h</code> begins where the source program was found, and will thereafter follow an implementation-defined search rule. If <code>tott95a.h</code> cannot be found in this way, a complete file name (for example, a UNIX absolute path name beginning with /) should be used in the <code>INTYPE</code> file to specify the location of <code>tott95a.h</code>.</p>
</div>
<!-- class="sect2" -->
<a id="i432208"></a>
<div id="LNPCC4487" class="sect2">
<h3 class="sect2">SCHEMA_NAMES Usage<a id="sthref2294"></a></h3>
<p>This parameter affects whether the name of a type from the default schema to which OTT is connected is qualified with a schema name in the <code>OUTTYPE</code> file.</p>
<p>The name of a type from a schema other that the default schema is always qualified with a schema name in the <code>OUTTYPE</code> file.</p>
<p>The schema name, or its absence, determines in which schema the type is found during program execution.</p>
<p>There are three settings:</p>
<ul>
<li>
<p>SCHEMA_NAMES=ALWAYS(default)</p>
<p>All type names in the <code>OUTTYPE</code> file are qualified with a schema name.</p>
</li>
<li>
<p>SCHEMA_NAMES=IF_NEEDED</p>
<p>The type names in the <code>OUTTYPE</code> file that belong to the default schema are not qualified with a schema name. As always, type names belonging to other schemas are qualified with the schema name.</p>
</li>
<li>
<p>SCHEMA_NAMES=FROM_INTYPE</p>
<p>A type mentioned in the <code>INTYPE</code> file is qualified with a schema name in the <code>OUTTYPE</code> file if, and only if, it was qualified with a schema name in the <code>INTYPE</code> file. A type in the default schema that is not mentioned in the <code>INTYPE</code> file but that has to be generated because of type dependencies is written with a schema name only if the first type encountered by OTT that depends on it was written with a schema name. However, a type that is not in the default schema to which OTT is connected is always written with an explicit schema name.</p>
</li>
</ul>
<p>The <code>OUTTYPE</code> file generated by OTT is the Pro*C/C++ <code>INTYPE</code> file. This file matches database type names to C struct names. This information is used at run-time to make sure that the correct database type is selected into the struct. If a type appears with a schema name in the <code>OUTTYPE</code> file (Pro*C/C++ <code>INTYPE</code> file), the type will be found in the named schema during program execution. If the type appears without a schema name, the type will be found in the default schema to which the program connects, which may be different from the default schema OTT used.</p>
<p class="subhead1"><a id="LNPCC4488"></a>An Example</p>
<p>If <code>SCHEMA_NAMES</code> is set to <code>FROM_INTYPE</code>, and the <code>INTYPE</code> file reads:</p>
<pre>TYPE Person
TYPE joe.Dept
TYPE sam.Company
</pre>
<p>then the Pro*C/C++ application that uses the OTT-generated structs will use the types <span class="italic">sam.Company, joe.Dept, and Person. Person</span> without a schema name refers to the Person type in the schema to which the application is connected.</p>
<p>If OTT and the application both connect to schema joe, the application will use the same type (joe.Person) that OTT used. If OTT connected to schema <span class="italic">joe</span> but the application connects to schema mary, the application will use the type mary.Person. This behavior is appropriate only if the same &#34;CREATE TYPE Person&#34; statement has been executed in schema joe and schema mary.</p>
<p>On the other hand, the application will use type joe.Dept regardless of to which schema the application is connected. If this is the behavior you want, be sure to include schema names with your type names in the <code>INTYPE</code> file.</p>
<p>In some cases, OTT translates a type that the user did not explicitly name. For example, consider the following SQL declarations:</p>
<pre>CREATE TYPE Address AS OBJECT
(
street    VARCHAR2(40),
city      VARCHAR(30),
state     CHAR(2),
zip_code  CHAR(10)
);

CREATE TYPE Person AS OBJECT
(
name      CHAR(20),
age       NUMBER,
addr      ADDRESS
);
</pre>
<p>Now suppose that OTT connects to schema joe, <code>SCHEMA_NAMES=FROM_INTYPE</code> is specified, and the user&#39;s <code>INTYPE</code> files include either</p>
<pre>TYPE Person or TYPE joe.Person
</pre>
<p>but do not mention the type joe.Address, which is used as a nested object type in type <span class="italic">joe.Person</span>. If &#34;TYPE joe.Person&#34; appeared in the <code>INTYPE</code> file, &#34;TYPE joe.Person&#34; and &#34;TYPE joe.Address&#34; will appear in the <code>OUTTYPE</code> file. If &#34;Type Person&#34; appeared in the <code>INTYPE</code> file, &#34;TYPE Person&#34; and &#34;TYPE Address&#34; will appear in the <code>OUTTYPE</code> file.</p>
<p>If the <span class="italic">joe.Addres</span>s type is embedded in several types translated by OTT, but is not explicitly mentioned in the <code>INTYPE</code> file, the decision of whether to use a schema name is made the first time OTT encounters the embedded <span class="italic">joe.Address</span> type. If, for some reason, the user wants type <span class="italic">joe.Address</span> to have a schema name but does not want type <span class="italic">Person</span> to have one, you must explicitly request</p>
<pre>TYPE      joe.Address
</pre>
<p>in the <code>INTYPE</code> FILE.</p>
<p>In the usual case in which each type is declared in a single schema, it is safest for you to qualify all type names with schema names in the <code>INTYPE</code> file.</p>
</div>
<!-- class="sect2" -->
<a id="i433388"></a>
<div id="LNPCC4489" class="sect2">
<h3 class="sect2">Default Name Mapping<a id="sthref2295"></a><a id="sthref2296"></a><a id="sthref2297"></a></h3>
<p>When OTT creates a C identifier name for an object type or attribute, it translates the name from the database character set to a legal C identifier. First, the name is translated from the database character set to the character set used by OTT. Next, if a translation of the resulting name is supplied in the <code>INTYPE</code> file, that translation is used. Otherwise, OTT translates the name character-by-character to the compiler character set, applying the <code>CASE</code> option. The following describes this in more detail.</p>
<p>When OTT reads the name of a database entity, the name is automatically translated from the database character set to the character set used by OTT. In order for OTT to read the name of the database entity successfully, all the characters of the name must be found in the OTT character set, although a character may have different encodings in the two character sets.</p>
<p>The easiest way to guarantee that the character set used by OTT contains all the necessary characters is to make it the same as the database character set. Note, however, that the OTT character set must be a superset of the compiler character set. That is, if the compiler character set is 7-bit ASCII, the OTT character set must include 7-bit ASCII as a subset, and if the compiler character set is 7-bit EBCDIC, the OTT character set must include 7-bit EBCDIC as a subset. The user specifies the character set that OTT uses by setting the NLS_LANG environment variable, or by some other platform-specific mechanism.</p>
<p>Once OTT has read the name of a database entity, it translates the name from the character set used by OTT to the compiler&#39;s character set. If a translation of the name appears in the <code>INTYPE</code> file, OTT uses that translation.</p>
<p>Otherwise, OTT attempts to translate the name as follows:</p>
<ol>
<li>
<p>First, if the OTT character set is a multibyte character set, all multibyte characters in the name that have singlebyte equivalents are converted to those singlebyte equivalents.</p>
</li>
<li>
<p>Next, the name is converted from the OTT character set to the compiler character set. The compiler character set is a singlebyte character set such as US7ASCII.</p>
</li>
<li>
<p>Finally, the case of letters is set according to the <code>CASE</code> option in effect, and any character that is not legal in a C identifier, or that has no translation in the compiler character set, is replaced by an underscore. If at least one character is replaced by an underscore, OTT gives a warning message. If all the characters in a name are replaced by underscores, OTT gives an error message.</p>
</li>
</ol>
<p>Character-by-character name translation does not alter underscores, digits, or singlebyte letters that appear in the compiler character set, so legal C identifiers are not altered.</p>
<p>Name translation may, for example, translate accented singlebyte characters such as &#34;o&#34; with an umlaut or &#34;a&#34; with an accent grave to &#34;o&#34; or &#34;a&#34;, and may translate a multibyte letter to its singlebyte equivalent. Name translation will typically fail if the name contains multibyte characters that lack singlebyte equivalents. In this case, the user must specify name translations in the <code>INTYPE</code> file.</p>
<p>OTT will not detect a naming clash caused by two or more database identifiers being mapped to the same C name, nor will it detect a naming problem where a database identifier is mapped to a C keyword.</p>
</div>
<!-- class="sect2" -->
<a id="i432220"></a>
<div id="LNPCC4490" class="sect2">
<h3 class="sect2">Restriction<a id="sthref2298"></a></h3>
<p>The following restriction affects the use of OTT.</p>
<div id="LNPCC4491" class="sect3"><a id="sthref2299"></a>
<h4 class="sect3">File Name Comparison</h4>
<p>Currently, OTT determines if two files are the same by comparing the file names provided by the user on the command line or in the <code>INTYPE</code> file. But one potential problem can occur when OTT needs to know if two file names refer to the same file. For example, if the OTT-generated file foo.h requires a type declaration written to foo1.h, and another type declaration written to /private/smith/foo1.h, OTT should generate one <code>#include</code> if the two files are the same, and two <code>#includes</code> if the files are different. In practice, though, it concludes that the two files are different, and generates two <code>#includes</code>, as follows:</p>
<pre>#ifndef FOO1_ORACLE
#include &#34;foo1.h&#34;
#endif
#ifndef FOO1_ORACLE
#include &#34;/private/smith/foo1.h&#34;
#endif
</pre>
<p>If foo1.h and /private/smith/foo1.h are different files, only the first one will be included. If foo1.h and /private/smith/foo1.h are the same file, a redundant <code>#include</code> will be written.</p>
<p>Therefore, if a file is mentioned several times on the command line or in the <code>INTYPE</code> file, each mention of the file should use exactly the same file name.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_18col.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_20exi.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>