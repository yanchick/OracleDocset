<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78015"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Oracle%20Dynamic%20SQL%3A%20Method%204"></a><title>Oracle Dynamic SQL: Method 4</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:46Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_14ady.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_16lob.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">21/35</span> <!-- End Header -->
<div id="LNPCC015" class="chapter"><a id="i22863"></a>
<h1 class="chapter"><span class="secnum">15</span> Oracle Dynamic SQL: Method 4</h1>
<p>This chapter shows you how to implement Oracle dynamic SQL Method 4, which lets your program accept or build dynamic SQL statements that contain a varying number of host variables. Use this to support existing applications. Use ANSI Dynamic SQL Method 4 for all new applications.</p>
<p>Oracle Dynamic SQL Method 4 does not support object types, cursor variables, arrays of structs, DML returning clauses, Unicode variables, and LOBs. Use ANSI Dynamic SQL Method 4 instead. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i7381">Meeting the Special Requirements of Method 4</a></p>
</li>
<li>
<p><a href="#i7496">Understanding the SQLDA</a></p>
</li>
<li>
<p><a href="#i7388">Using the SQLDA Variables</a></p>
</li>
<li>
<p><a href="#i7392">Some Preliminaries</a></p>
</li>
<li>
<p><a href="#i7396">The Basic Steps</a></p>
</li>
<li>
<p><a href="#i7400">A Closer Look at Each Step</a></p>
</li>
<li>
<p><a href="#i7419">Example Program: Dynamic SQL Method 4</a></p>
</li>
<li>
<p><a href="#i33925">Sample Program : Dynamic SQL Method 4 using Scrollable Cursors</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_13dyn.htm#g19220">Chapter 13, &#34;Oracle Dynamic SQL&#34;</a> for a discussion of dynamic SQL Methods 1, 2, and 3, and an overview of Method 4</p>
</li>
<li>
<p><a href="pc_14ady.htm#i1011699">Chapter 14, &#34; ANSI Dynamic SQL&#34;</a></p>
</li>
</ul>
</div>
</li>
</ul>
<a id="i7381"></a>
<div id="LNPCC4128" class="sect1">
<h2 class="sect1">Meeting the Special Requirements of Method 4</h2>
<p>Before looking into the requirements of Method 4, you should feel comfortable with the terms select-list item and placeholder. Select-list items are the columns or expressions following the keyword SELECT in a query. For example, the following dynamic query contains three select-list items:</p>
<pre>SELECT ename, job, sal + comm FROM emp WHERE deptno = 20
 
</pre>
<p>Placeholders are dummy bind variables that hold places in a SQL statement for actual bind variables. You do not declare placeholders, and can name them anything you like.</p>
<p>Placeholders for bind variables are most often used in the SET, VALUES, and WHERE clauses. For example, the following dynamic SQL statements each contain two placeholders:</p>
<pre>INSERT INTO emp (empno, deptno) VALUES (:e, :d) 
DELETE FROM dept WHERE deptno = :num OR loc = :loc 
</pre>
<div id="LNPCC4129" class="sect2"><a id="sthref1811"></a>
<h3 class="sect2">What Makes Method 4 Special?</h3>
<p>Unlike Methods 1, 2, and 3, dynamic SQL Method 4 lets your program</p>
<ul>
<li>
<p>Accept or build dynamic SQL statements that contain an unknown number of select-list items or placeholders, and</p>
</li>
<li>
<p>Take explicit control over datatype conversion between Oracle and C types</p>
</li>
</ul>
<p>To add this flexibility to your program, you must give the Oracle runtime library additional information.<a id="sthref1812"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4130" class="sect2"><a id="sthref1813"></a>
<h3 class="sect2">What Information Does Oracle Need?</h3>
<p>The Pro*C/C++ Precompiler generates calls to Oracle for all executable dynamic SQL statements. If a dynamic SQL statement contains no select-list items or placeholders, Oracle needs no additional information to execute the statement. The following DELETE statement falls into this category:</p>
<pre>DELETE FROM emp WHERE deptno = 30 
</pre>
<p>However, most dynamic SQL statements contain select-list items or placeholders for bind variables, as does the following</p>
<p>UPDATE statement:</p>
<pre>UPDATE emp SET comm = :c WHERE empno = :e
 
</pre>
<p>To execute a dynamic SQL statement that contains placeholders for bind variables or select-list items, Oracle needs information about the program variables that hold the input (bind) values, and that will hold the FETCHed values when a query is executed. The information needed by Oracle is:</p>
<ul>
<li>
<p>The number of bind variables and select-list items</p>
</li>
<li>
<p>The length of each bind variable and select-list item</p>
</li>
<li>
<p>The datatype of each bind variable and select-list item</p>
</li>
<li>
<p>The address of each bind variable, and of the output variable that will receive each select-list item</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCC4131" class="sect2"><a id="sthref1814"></a>
<h3 class="sect2">Where Is the Information Stored?</h3>
<p>All the information Oracle needs about select-list items or placeholders for bind variables, except their values, is stored in a program data structure called the SQL Descriptor Area (SQLDA). The SQLDA struct is defined in the <code>sqlda.h</code> header file. <a id="sthref1815"></a></p>
<p>Descriptions of select-list items are stored in a <span class="italic">select descriptor</span>, and descriptions of placeholders for bind variables are stored in a <span class="italic">bind descriptor</span>.<a id="sthref1816"></a><a id="sthref1817"></a></p>
<p>The values of select-list items are stored in output variables; the values of bind variables are stored in input variables. You store the addresses of these variables in the select or bind SQLDA so that Oracle knows where to write output values and read input values.</p>
<p>How do values get stored in these data variables? Output values are FETCHed using a cursor, and input values are typically filled in by the program, usually from information entered interactively by the user.</p>
</div>
<!-- class="sect2" -->
<a id="i7161"></a>
<div id="LNPCC4132" class="sect2">
<h3 class="sect2">How is the SQLDA Referenced?</h3>
<p>The bind and select descriptors are usually referenced by pointer. A dynamic SQL program should declare a pointer to at least one bind descriptor, and a pointer to at least one select descriptor, in the following way:</p>
<pre>#include &lt;sqlda.h&gt;
... 
SQLDA *bind_dp; 
SQLDA *select_dp; 
</pre>
<p>You can then use the <code>SQLSQLDAAlloc()</code> function to allocate the descriptor, as follows:</p>
<pre>bind_dp = SQLSQLDAAlloc(runtime_context, size, name_length, ind_name_length); 
</pre>
<p>SQLSQLDAAlloc() was known as sqlaldt() before Oracle8.</p>
<p>The constant <code>SQL_SINGLE_RCTX</code> is defined as <code>(dvoid*)0</code>. Use it for <span class="italic">runtime_context</span> when your application is single-threaded.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#g34286">Table 15-3, &#34;Precision and Scale Values for SQL Datatypes&#34;</a>, for information on this and other SQLLIB functions</p>
</li>
<li>
<p><a href="#i11411">&#34;Allocating a SQLDA&#34;</a> for detailed information about <code>SQLSQLDAAlloc()</code> and its parameters</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC4133" class="sect2"><a id="sthref1818"></a>
<h3 class="sect2">How is the Information Obtained?</h3>
<p>You use the DESCRIBE statement to help obtain the information Oracle needs.</p>
<p>The DESCRIBE SELECT LIST statement examines each select-list item to determine its name and name length. It then stores this information in the select SQLDA for your use. For example, you might use select-list names as column headings in a printout. The total number of select-list items is also stored in the SQLDA by DESCRIBE.</p>
<p>The DESCRIBE BIND VARIABLES statement examines each placeholder to determine its name and length, then stores this information in an input buffer and bind SQLDA for your use. For example, you might use placeholder names to prompt the user for the values of bind variables.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7496"></a>
<div id="LNPCC4134" class="sect1">
<h2 class="sect1">Understanding the SQLDA</h2>
<p>This section describes the SQLDA data structure in detail. You learn how to declare it, what variables it contains, how to initialize them, and how to use them in your program.</p>
<div id="LNPCC4135" class="sect2"><a id="sthref1819"></a>
<h3 class="sect2">Purpose of the SQLDA</h3>
<p>Method 4 is required for dynamic SQL statements that contain an unknown number of select-list items or placeholders for bind variables. To process this kind of dynamic SQL statement, your program must explicitly declare SQLDAs, also called <span class="italic">descriptors</span>. Each descriptor is a <span class="bold">struct</span> which you must copy or code into your program.<a id="sthref1820"></a><a id="sthref1821"></a><a id="sthref1822"></a></p>
<p>A <span class="italic">select descriptor</span> holds descriptions of select-list items, and the addresses of output buffers where the names and values of select-list items are stored.<a id="sthref1823"></a><a id="sthref1824"></a><a id="sthref1825"></a><a id="sthref1826"></a><a id="sthref1827"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The &#34;name&#34; of a select-list item can be a column name, a column alias, or the text of an expression such as <span class="italic">sal + comm.<a id="sthref1828"></a></span></div>
<p>A <span class="italic">bind descriptor</span> holds descriptions of bind variables and indicator variables, and the addresses of input buffers where the names and values of bind variables and indicator variables are stored.<a id="sthref1829"></a><a id="sthref1830"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4136" class="sect2"><a id="sthref1831"></a>
<h3 class="sect2">Multiple SQLDAs</h3>
<p>If your program has more than one active dynamic SQL statement, each statement must have its own SQLDA(s). You can declare any number of SQLDAs with different names. For example, you might declare three select SQLDAs named <span class="italic">sel_desc1</span>, <span class="italic">sel_desc2</span>, and <span class="italic">sel_desc3</span>, so that you can FETCH from three concurrently OPEN cursors. However, non-concurrent cursors can reuse SQLDAs.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4137" class="sect2"><a id="sthref1832"></a>
<h3 class="sect2">Declaring a SQLDA</h3>
<p>To declare a SQLDA, include the <code>sqlda.h</code> header file. The contents of the SQLDA are:<a id="sthref1833"></a></p>
<pre>struct SQLDA 
{ 
    long    N;          /* Descriptor size in number of entries */ 
    char  **V;        Ptr to Arr of addresses of main variables */ 
    int   *L;              /* Ptr to Arr of lengths of buffers */ 
    short  *T;                /* Ptr to Arr of types of buffers */ 
    short **I;      * Ptr to Arr of addresses of indicator vars */ 
    long    F;         /* Number of variables found by DESCRIBE */ 
    char  **S;          /* Ptr to Arr of variable name pointers */ 
    short  *M;       /* Ptr to Arr of max lengths of var. names */ 
    short  *C;    * Ptr to Arr of current lengths of var. names */ 
    char  **X;         /* Ptr to Arr of ind. var. name pointers */ 
    short  *Y;  /* Ptr to Arr of max lengths of ind. var. names */ 
    short  *Z;  /* Ptr to Arr of cur lengths of ind. var. names */ 
}; 
</pre></div>
<!-- class="sect2" -->
<a id="i11411"></a>
<div id="LNPCC4138" class="sect2">
<h3 class="sect2">Allocating a SQLDA</h3>
<p>After declaring a SQLDA, you allocate storage space for it with the <code>SQLSQLDAAlloc()</code> library function (known as <code>sqlaldt()</code> before Oracle8), using the syntax<a id="sthref1834"></a><a id="sthref1835"></a><a id="sthref1836"></a>:</p>
<pre>descriptor_name = SQLSQLDAAlloc (runtime_context, max_vars, max_name, max_ind_name); 
</pre>
<p>where:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="descriptions of runtime_context, max_vars, max_name, and max_ind_name" summary="descriptions of runtime_context, max_vars, max_name, and max_ind_name" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t5">Syntax</th>
<th class="cellalignment832" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t5" headers="r1c1-t5"><span class="italic">runtime_context</span></td>
<td class="cellalignment833" headers="r2c1-t5 r1c2-t5">pointer to runtime context</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t5" headers="r1c1-t5"><span class="italic">max_vars</span></td>
<td class="cellalignment833" headers="r3c1-t5 r1c2-t5">Is the maximum number of select-list items or placeholders that the descriptor can describe.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t5" headers="r1c1-t5"><span class="italic">max_name</span></td>
<td class="cellalignment833" headers="r4c1-t5 r1c2-t5">Is the maximum length of select-list or placeholder names.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t5" headers="r1c1-t5"><span class="italic">max_ind_name</span></td>
<td class="cellalignment833" headers="r5c1-t5 r1c2-t5">Is the maximum length of indicator variable names, which are optionally appended to placeholder names. This parameter applies to bind descriptors only, so set it to zero when allocating a select descriptor.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>Besides the descriptor, <code>SQLSQLDAAlloc()</code> allocates data buffers to which descriptor variables point.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i7388">&#34;Using the SQLDA Variables&#34;</a> for information about <code>SQLSQLDAAlloc()</code></p>
</li>
<li>
<p><a href="#i6986">&#34;Allocate Storage Space for the Descriptors&#34;</a></p>
</li>
</ul>
</div>
<p><a href="#i7504">Figure 15-1</a> shows whether variables are set by <code>SQLSQLDAAlloc()</code> calls, DESCRIBE commands, FETCH commands, or program assignments.</p>
<div id="LNPCC4139" class="figure">
<p class="titleinfigure"><a id="i7504"></a>Figure 15-1 How Variables Are Set</p>
<img width="504" height="400" src="img/lnpcc010.gif" alt="Description of Figure 15-1 follows"/><br/>
<a id="sthref1837" href="img_text/lnpcc010.htm">Description of &#34;Figure 15-1 How Variables Are Set&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7388"></a>
<div id="LNPCC4140" class="sect1">
<h2 class="sect1">Using the SQLDA Variables</h2>
<p>This section explains the purpose and use of each variable in the SQLDA.<a id="sthref1838"></a></p>
<div id="LNPCC4141" class="sect2"><a id="sthref1839"></a>
<h3 class="sect2">The <span class="italic">N</span> Variable</h3>
<p><span class="bolditalic">N</span> specifies the maximum number of select-list items or placeholders that can be DESCRIBEd. Thus, <span class="italic">N</span> determines the number of elements in the descriptor arrays.<a id="sthref1840"></a><a id="sthref1841"></a><a id="sthref1842"></a></p>
<p>Before issuing the optional DESCRIBE command, you must set <span class="italic">N</span> to the dimension of the descriptor arrays using the <code>SQLSQLDAAlloc()</code> library function. After the DESCRIBE, you must reset <span class="italic">N</span> to the actual number of variables DESCRIBEd, which is stored in the <span class="italic">F</span> variable.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4142" class="sect2"><a id="sthref1843"></a>
<h3 class="sect2">The <span class="italic">V</span> Variable</h3>
<p><span class="italic">V</span> is a pointer to an array of addresses of data buffers that store select-list or bind-variable values.<a id="sthref1844"></a><a id="sthref1845"></a><a id="sthref1846"></a></p>
<p>When you allocate the descriptor, <code>SQLSQLDAAlloc()</code> zeros the elements <code>V[0]</code> through <code>V[N - 1]</code> in the array of addresses.</p>
<p><span class="bold">For select descriptors</span>, you must allocate data buffers and set this array before issuing the FETCH command. The statement</p>
<pre>EXEC SQL FETCH ... USING DESCRIPTOR ... 
</pre>
<p>directs Oracle to store FETCHed select-list values in the data buffers to which <code>V[0]</code> through <code>V[N - 1]</code> point. Oracle stores the <span class="italic">i</span>th select-list value in the data buffer to which <code>V[i]</code> points.</p>
<p><span class="bold">For bind descriptors</span>, you must set this array before issuing the OPEN command. The statement</p>
<pre>EXEC SQL OPEN ... USING DESCRIPTOR ...
 
</pre>
<p>directs Oracle to execute the dynamic SQL statement using the bind-variable values to which <code>V[0]</code> through <code>V[N - 1]</code> point. Oracle finds the <span class="italic">i</span>th bind-variable value in the data buffer to which <code>V[</code><span class="italic">i</span><code>]</code> points.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4143" class="sect2"><a id="sthref1847"></a>
<h3 class="sect2">The <span class="italic">L</span> Variable</h3>
<p><span class="italic">L</span> is a pointer to an array of lengths of select-list or bind-variable values stored in data buffers.<a id="sthref1848"></a><a id="sthref1849"></a><a id="sthref1850"></a></p>
<p><span class="bold">For select descriptors</span>, DESCRIBE SELECT LIST sets the array of lengths to the maximum expected for each select-list item. However, you might want to reset some lengths before issuing a FETCH command. FETCH returns at most <span class="italic">n</span> characters, where <span class="italic">n</span> is the value of <code>L[</code><span class="italic">i</span><code>]</code> before the FETCH.</p>
<p>The format of the length differs among Oracle datatypes. For CHAR or VARCHAR2 select-list items, DESCRIBE SELECT LIST sets <code>L[</code><span class="italic">i</span><code>]</code> to the maximum length of the select-list item. For NUMBER select-list items, scale and precision are returned respectively in the low and next-higher bytes of the variable. You can use the library function <code>SQLNumberPrecV6()</code> to extract precision and scale values from <code>L[</code><span class="italic">i</span><code>]</code>. See also <a href="#i6993">&#34;Extracting Precision and Scale&#34;</a>.</p>
<p>You must reset <code>L[</code><span class="italic">i</span><code>]</code> to the required length of the data buffer before the FETCH. For example, when coercing a NUMBER to a C <span class="bold">char</span> string, set <code>L[</code><span class="italic">i</span><code>]</code> to the precision of the number plus two for the sign and decimal point. When coercing a NUMBER to a C <span class="bold">float</span>, set <code>L[</code><span class="italic">i</span><code>]</code> to the length of <span class="bold">float</span>s on your system. For more information about the lengths of coerced datatypes, see also <a href="#i7000">&#34;Converting Data&#34;</a>.</p>
<p><span class="bold">For bind descriptors</span>, you must set the array of lengths before issuing the OPEN command. For example, you can use <code>strlen()</code> to get the lengths of bind-variable character strings entered by the user, then set the appropriate array elements.</p>
<p>Because Oracle accesses a data buffer indirectly, using the address stored in <code>V[</code><span class="italic">i</span><code>]</code>, it does not know the length of the value in that buffer. If you want to change the length Oracle uses for the <span class="italic">i</span>th select-list or bind-variable value, reset <code>L[</code><span class="italic">i</span><code>]</code> to the length you need. Each input or output buffer can have a different length.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4144" class="sect2"><a id="sthref1851"></a>
<h3 class="sect2">The <span class="italic">T</span> Variable</h3>
<p><span class="italic">T</span> is a pointer to an array of datatype codes of select-list or bind-variable values. These codes determine how Oracle data is converted when stored in the data buffers addressed by elements of the <span class="italic">V</span> array.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i7000">&#34;Converting Data&#34;</a><a id="sthref1852"></a><a id="sthref1853"></a><a id="sthref1854"></a></div>
<p><span class="bold">For select descriptors</span>, DESCRIBE SELECT LIST sets the array of datatype codes to the <span class="italic">internal</span> datatype (CHAR, NUMBER, or DATE, for example) of the items in the select list.</p>
<p>Before FETCHing, you might want to reset some datatypes because the internal format of Oracle datatypes can be difficult to handle. For display purposes, it is usually a good idea to coerce the datatype of select-list values to VARCHAR2 or STRING. For calculations, you might want to coerce numbers from Oracle to C format.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i7016">&#34;Coercing Datatypes&#34;</a></div>
<p>The high bit of <code>T[</code><span class="italic">i</span><code>]</code> is set to indicate the NULL/not NULL status of the <span class="italic">i</span>th select-list item. You must always clear this bit before issuing an OPEN or FETCH command. You use the library function <code>SQLColumnNullCheck()</code> to retrieve the datatype code and clear the NULL/not NULL bit.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i11254">&#34;Handling NULL/Not NULL Datatypes&#34;</a><a id="sthref1855"></a></div>
<p>You should change the Oracle NUMBER internal datatype to an external datatype compatible with that of the C data buffer to which <code>V[</code><span class="italic">i</span><code>]</code> points.</p>
<p><span class="bold">For bind descriptors</span>, DESCRIBE BIND VARIABLES sets the array of datatype codes to zeros. You must set the datatype code stored in each element before issuing the OPEN command. The code represents the external (C) datatype of the data buffer to which <code>V[</code><span class="italic">i</span><code>]</code> points. Often, bind-variable values are stored in character strings, so the datatype array elements are set to 1 (the VARCHAR2 datatype code). You can also use datatype code 5 (STRING).</p>
<p>To change the datatype of the <span class="italic">i</span>th select-list or bind-variable value, reset <code>T[</code><span class="italic">i</span><code>]</code> to the datatype you want.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4145" class="sect2"><a id="sthref1856"></a>
<h3 class="sect2">The <span class="italic">I</span> Variable</h3>
<p><span class="italic">I</span> is a pointer to an array of addresses of data buffers that store indicator-variable values.<a id="sthref1857"></a><a id="sthref1858"></a><a id="sthref1859"></a></p>
<p>You must set the elements <code>I[0]</code> through <code>I[N - 1]</code> in the array of addresses.</p>
<p><span class="bold">For select descriptors</span>, you must set the array of addresses before issuing the FETCH command. When Oracle executes the statement</p>
<pre>EXEC SQL FETCH ... USING DESCRIPTOR ... 
</pre>
<p>if the <span class="italic">i</span>th returned select-list value is NULL, the indicator-variable value to which <code>I[</code><span class="italic">i</span><code>]</code> points is set to -1. Otherwise, it is set to zero (the value is not NULL) or a positive integer (the value was truncated).</p>
<p><span class="bold">For bind descriptors</span>, you must set the array of addresses and associated indicator variables before issuing the OPEN command. When Oracle executes the statement</p>
<pre>EXEC SQL OPEN ... USING DESCRIPTOR ... 
</pre>
<p>the data buffer to which <code>I[</code><span class="italic">i</span><code>]</code> points determines whether the <span class="italic">i</span>th bind variable has a NULL value. If the value of an indicator variable is -1, the value of its associated bind variable is NULL.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4146" class="sect2"><a id="sthref1860"></a>
<h3 class="sect2">The <span class="italic">F</span> Variable</h3>
<p><span class="italic">F</span> is the actual number of select-list items or placeholders found by DESCRIBE.<a id="sthref1861"></a><a id="sthref1862"></a><a id="sthref1863"></a></p>
<p><span class="italic">F</span> is set by DESCRIBE. If <span class="italic">F</span> is less than zero, DESCRIBE has found too many select-list items or placeholders for the allocated size of the descriptor. For example, if you set <span class="italic">N</span> to 10 but DESCRIBE finds 11 select-list items or placeholders, <span class="italic">F</span> is set to -11. This feature lets you dynamically reallocate a larger storage area for select-list items or placeholders if necessary.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4147" class="sect2"><a id="sthref1864"></a>
<h3 class="sect2">The <span class="italic">S</span> Variable</h3>
<p><span class="italic">S</span> is a pointer to an array of addresses of data buffers that store select-list or placeholder names as they appear in dynamic SQL statements.<a id="sthref1865"></a><a id="sthref1866"></a><a id="sthref1867"></a></p>
<p>You use <code>SQLSQLDAAlloc()</code> to allocate the data buffers and store their addresses in the <span class="italic">S</span> array.</p>
<p>DESCRIBE directs Oracle to store the name of the <span class="italic">i</span>th select-list item or placeholder in the data buffer to which <code>S[</code><span class="italic">i</span><code>]</code> points.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4148" class="sect2"><a id="sthref1868"></a>
<h3 class="sect2">The <span class="italic">M</span> Variable</h3>
<p><span class="italic">M</span> is a pointer to an array of maximum lengths of data buffers that store select-list or placeholder names. The buffers are addressed by elements of the <span class="italic">S</span> array.<a id="sthref1869"></a><a id="sthref1870"></a><a id="sthref1871"></a></p>
<p>When you allocate the descriptor, <code>SQLSQLDAAlloc()</code> sets the elements <code>M[0]</code> through <code>M[N - 1]</code> in the array of maximum lengths. When stored in the data buffer to which <code>S[</code><span class="italic">i</span><code>]</code> points, the <span class="italic">i</span>th name is truncated to the length in <code>M[</code><span class="italic">i</span><code>]</code> if necessary.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4149" class="sect2"><a id="sthref1872"></a>
<h3 class="sect2">The <span class="italic">C</span> Variable</h3>
<p><span class="italic">C</span> is a pointer to an array of current lengths of select-list or placeholder names.<a id="sthref1873"></a><a id="sthref1874"></a><a id="sthref1875"></a></p>
<p>DESCRIBE sets the elements <code>C[0]</code> through <code>C[N - 1]</code> in the array of current lengths. After a DESCRIBE, the array contains the number of characters in each select-list or placeholder name.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4150" class="sect2"><a id="sthref1876"></a>
<h3 class="sect2">The <span class="italic">X</span> Variable</h3>
<p><span class="italic">X</span> is a pointer to an array of addresses of data buffers that store indicator-variable names. You can associate indicator-variable <span class="italic">values</span> with select-list items and bind variables. However, you can associate indicator-variable <span class="italic">names</span> only with bind variables. So, <span class="italic">X</span> applies only to bind descriptors.<a id="sthref1877"></a><a id="sthref1878"></a><a id="sthref1879"></a></p>
<p>Use <code>SQLSQLDAAlloc()</code> to allocate the data buffers and store their addresses in the <span class="italic">X</span> array.</p>
<p>DESCRIBE BIND VARIABLES directs Oracle to store the name of the <span class="italic">i</span>th indicator variable in the data buffer to which <code>X[</code><span class="italic">i</span><code>]</code> points.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4151" class="sect2"><a id="sthref1880"></a>
<h3 class="sect2">The <span class="italic">Y</span> Variable</h3>
<p><span class="italic">Y</span> is a pointer to an array of maximum lengths of data buffers that store indicator-variable names. Like <span class="italic">X</span>, <span class="italic">Y</span> applies only to bind descriptors.<a id="sthref1881"></a><a id="sthref1882"></a><a id="sthref1883"></a></p>
<p>You use <code>SQLSQLDAAlloc()</code> to set the elements <code>Y[0]</code> through <code>Y[N - 1]</code> in the array of maximum lengths. When stored in the data buffer to which <code>X[</code><span class="italic">i</span><code>]</code> points, the <span class="italic">i</span>th name is truncated to the length in <code>Y[</code><span class="italic">i</span><code>]</code> if necessary.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4152" class="sect2"><a id="sthref1884"></a>
<h3 class="sect2">The <span class="italic">Z</span> Variable</h3>
<p><span class="italic">Z</span> is a pointer to an array of current lengths of indicator-variable names. Like <span class="italic">X</span> and <span class="italic">Y</span>, <span class="italic">Z</span> applies only to bind descriptors.<a id="sthref1885"></a><a id="sthref1886"></a><a id="sthref1887"></a></p>
<p>DESCRIBE BIND VARIABLES sets the elements <code>Z[0]</code> through <code>Z[N - 1]</code> in the array of current lengths. After a DESCRIBE, the array contains the number of characters in each indicator-variable name.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7392"></a>
<div id="LNPCC4153" class="sect1">
<h2 class="sect1">Some Preliminaries</h2>
<p>You need a working knowledge of the following subjects to implement dynamic SQL Method 4:<a id="sthref1888"></a></p>
<ul>
<li>
<p><a href="#i7000">Converting Data</a></p>
</li>
<li>
<p><a href="#i7016">Coercing Datatypes</a></p>
</li>
<li>
<p><a href="#i11254">Handling NULL/Not NULL Datatypes</a></p>
</li>
</ul>
<a id="i7000"></a>
<div id="LNPCC4154" class="sect2">
<h3 class="sect2">Converting Data</h3>
<p>This section provides more detail about the <span class="italic">T</span> (datatype) descriptor array. In host programs that use neither datatype equivalencing nor dynamic SQL Method 4, the conversion between Oracle internal and external datatypes is determined at precompile time. By default, the precompiler assigns a specific external datatype to each host variable in the Declare Section. For example, the precompiler assigns the INTEGER external datatype to host variables of type <span class="italic">int</span>.</p>
<p>However, Method 4 lets you control data conversion and formatting. You specify conversions by setting datatype codes in the <span class="italic">T</span> descriptor array.</p>
<div id="LNPCC4155" class="sect3"><a id="sthref1889"></a>
<h4 class="sect3">Internal Datatypes</h4>
<p>Internal datatypes specify the formats used by Oracle to store column values in database tables, as well as the formats used to represent pseudocolumn values.</p>
<p>When you issue a DESCRIBE SELECT LIST command, Oracle returns the internal datatype code for each select-list item to the <span class="italic">T</span> descriptor array. For example, the datatype code for the <span class="italic">i</span>th select-list item is returned to <code>T[</code><span class="italic">i</span><code>]</code>.</p>
<p><a href="#BABEBHAF">Table 15-1</a> shows the Oracle internal datatypes and their codes:<a id="sthref1890"></a></p>
<div id="LNPCC4156" class="tblformal">
<p class="titleintable"><a id="sthref1891"></a><a id="BABEBHAF"></a>Table 15-1 Oracle Internal Datatypes</p>
<table class="cellalignment831" title=" Oracle Internal Datatypes" summary="Oracle Internal Datatypes" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t10">Oracle Internal Datatype</th>
<th class="cellalignment832" id="r1c2-t10">Code</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t10" headers="r1c1-t10">
<p>VARCHAR2</p>
</td>
<td class="cellalignment833" headers="r2c1-t10 r1c2-t10">
<p>1</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t10" headers="r1c1-t10">
<p>NUMBER</p>
</td>
<td class="cellalignment833" headers="r3c1-t10 r1c2-t10">
<p>2</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t10" headers="r1c1-t10">
<p>LONG</p>
</td>
<td class="cellalignment833" headers="r4c1-t10 r1c2-t10">
<p>8</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t10" headers="r1c1-t10">
<p>BINARY_FLOAT</p>
</td>
<td class="cellalignment833" headers="r5c1-t10 r1c2-t10">
<p>100</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t10" headers="r1c1-t10">
<p>BINARY_DOUBLE</p>
</td>
<td class="cellalignment833" headers="r6c1-t10 r1c2-t10">
<p>101</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t10" headers="r1c1-t10">
<p>ROWID</p>
</td>
<td class="cellalignment833" headers="r7c1-t10 r1c2-t10">
<p>11</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t10" headers="r1c1-t10">
<p>DATE</p>
</td>
<td class="cellalignment833" headers="r8c1-t10 r1c2-t10">
<p>12</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t10" headers="r1c1-t10">
<p>RAW</p>
</td>
<td class="cellalignment833" headers="r9c1-t10 r1c2-t10">
<p>23</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t10" headers="r1c1-t10">
<p>LONG RAW</p>
</td>
<td class="cellalignment833" headers="r10c1-t10 r1c2-t10">
<p>24</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t10" headers="r1c1-t10">
<p>CHARACTER (or CHAR)</p>
</td>
<td class="cellalignment833" headers="r11c1-t10 r1c2-t10">
<p>96</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t10" headers="r1c1-t10">
<p>Universal ROWID</p>
</td>
<td class="cellalignment833" headers="r12c1-t10 r1c2-t10">
<p>104</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="LNPCC4157" class="sect3"><a id="sthref1892"></a>
<h4 class="sect3">External Datatypes</h4>
<p>External datatypes specify the formats used to store values in input and output host variables.</p>
<p>The DESCRIBE BIND VARIABLES command sets the <span class="italic">T</span> array of datatype codes to zeros. So, you must reset the codes <span class="italic">before</span> issuing the OPEN command. The codes tell Oracle which external datatypes to expect for the various bind variables. For the <span class="italic">i</span>th bind variable, reset <code>T[</code><span class="italic">i</span><code>]</code> to the external datatype you want.</p>
<p><a href="#g34096">Table 15-2</a> shows the Oracle external datatypes and their codes, as well as the C datatype normally used with each external datatype.</p>
<div id="LNPCC4158" class="tblformal">
<p class="titleintable"><a id="sthref1893"></a><a id="g34096"></a>Table 15-2 Oracle External Datatypes and Datatype Codes</p>
<table class="cellalignment831" title=" Oracle External Datatypes and Datatype Codes" summary="Oracle External Datatypes and Datatype Codes" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t11">External Datatype</th>
<th class="cellalignment832" id="r1c2-t11">Code</th>
<th class="cellalignment832" id="r1c3-t11">C Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t11" headers="r1c1-t11">
<p>VARCHAR2</p>
</td>
<td class="cellalignment833" headers="r2c1-t11 r1c2-t11">
<p>1</p>
</td>
<td class="cellalignment833" headers="r2c1-t11 r1c3-t11">
<p>char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t11" headers="r1c1-t11">
<p>NUMBER</p>
</td>
<td class="cellalignment833" headers="r3c1-t11 r1c2-t11">
<p>2</p>
</td>
<td class="cellalignment833" headers="r3c1-t11 r1c3-t11">
<p>char[n] ( n &lt;= 22)</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t11" headers="r1c1-t11">
<p>INTEGER</p>
</td>
<td class="cellalignment833" headers="r4c1-t11 r1c2-t11">
<p>3</p>
</td>
<td class="cellalignment833" headers="r4c1-t11 r1c3-t11">
<p>int</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t11" headers="r1c1-t11">
<p>FLOAT</p>
</td>
<td class="cellalignment833" headers="r5c1-t11 r1c2-t11">
<p>4</p>
</td>
<td class="cellalignment833" headers="r5c1-t11 r1c3-t11">
<p>float</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t11" headers="r1c1-t11">
<p>STRING</p>
</td>
<td class="cellalignment833" headers="r6c1-t11 r1c2-t11">
<p>5</p>
</td>
<td class="cellalignment833" headers="r6c1-t11 r1c3-t11">
<p>char[n+1]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t11" headers="r1c1-t11">
<p>VARNUM</p>
</td>
<td class="cellalignment833" headers="r7c1-t11 r1c2-t11">
<p>6</p>
</td>
<td class="cellalignment833" headers="r7c1-t11 r1c3-t11">
<p>char[n] (n &lt;= 22)</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t11" headers="r1c1-t11">
<p>DECIMAL</p>
</td>
<td class="cellalignment833" headers="r8c1-t11 r1c2-t11">
<p>7</p>
</td>
<td class="cellalignment833" headers="r8c1-t11 r1c3-t11">
<p>float</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t11" headers="r1c1-t11">
<p>LONG</p>
</td>
<td class="cellalignment833" headers="r9c1-t11 r1c2-t11">
<p>8</p>
</td>
<td class="cellalignment833" headers="r9c1-t11 r1c3-t11">
<p>char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t11" headers="r1c1-t11">
<p>SQLT_BFLOAT</p>
</td>
<td class="cellalignment833" headers="r10c1-t11 r1c2-t11">
<p>21</p>
</td>
<td class="cellalignment833" headers="r10c1-t11 r1c3-t11">
<p>float</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t11" headers="r1c1-t11">
<p>SQLT_BDOUBLE</p>
</td>
<td class="cellalignment833" headers="r11c1-t11 r1c2-t11">
<p>22</p>
</td>
<td class="cellalignment833" headers="r11c1-t11 r1c3-t11">
<p>double</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t11" headers="r1c1-t11">
<p>VARCHAR</p>
</td>
<td class="cellalignment833" headers="r12c1-t11 r1c2-t11">
<p>9</p>
</td>
<td class="cellalignment833" headers="r12c1-t11 r1c3-t11">
<p>char[n+2]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r13c1-t11" headers="r1c1-t11">
<p>ROWID</p>
</td>
<td class="cellalignment833" headers="r13c1-t11 r1c2-t11">
<p>11</p>
</td>
<td class="cellalignment833" headers="r13c1-t11 r1c3-t11">
<p>char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r14c1-t11" headers="r1c1-t11">
<p>DATE</p>
</td>
<td class="cellalignment833" headers="r14c1-t11 r1c2-t11">
<p>12</p>
</td>
<td class="cellalignment833" headers="r14c1-t11 r1c3-t11">
<p>char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r15c1-t11" headers="r1c1-t11">
<p>VARRAW</p>
</td>
<td class="cellalignment833" headers="r15c1-t11 r1c2-t11">
<p>15</p>
</td>
<td class="cellalignment833" headers="r15c1-t11 r1c3-t11">
<p>char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r16c1-t11" headers="r1c1-t11">
<p>RAW</p>
</td>
<td class="cellalignment833" headers="r16c1-t11 r1c2-t11">
<p>23</p>
</td>
<td class="cellalignment833" headers="r16c1-t11 r1c3-t11">
<p>unsigned char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r17c1-t11" headers="r1c1-t11">
<p>LONG RAW</p>
</td>
<td class="cellalignment833" headers="r17c1-t11 r1c2-t11">
<p>24</p>
</td>
<td class="cellalignment833" headers="r17c1-t11 r1c3-t11">
<p>unsigned char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r18c1-t11" headers="r1c1-t11">
<p>UNSIGNED</p>
</td>
<td class="cellalignment833" headers="r18c1-t11 r1c2-t11">
<p>68</p>
</td>
<td class="cellalignment833" headers="r18c1-t11 r1c3-t11">
<p>unsigned int</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r19c1-t11" headers="r1c1-t11">
<p>DISPLAY</p>
</td>
<td class="cellalignment833" headers="r19c1-t11 r1c2-t11">
<p>91</p>
</td>
<td class="cellalignment833" headers="r19c1-t11 r1c3-t11">
<p>char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r20c1-t11" headers="r1c1-t11">
<p>LONG VARCHAR</p>
</td>
<td class="cellalignment833" headers="r20c1-t11 r1c2-t11">
<p>94</p>
</td>
<td class="cellalignment833" headers="r20c1-t11 r1c3-t11">
<p>char[n+4]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r21c1-t11" headers="r1c1-t11">
<p>LONG VARRAW</p>
</td>
<td class="cellalignment833" headers="r21c1-t11 r1c2-t11">
<p>95</p>
</td>
<td class="cellalignment833" headers="r21c1-t11 r1c3-t11">
<p>unsigned char[n+4]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r22c1-t11" headers="r1c1-t11">
<p>CHAR</p>
</td>
<td class="cellalignment833" headers="r22c1-t11 r1c2-t11">
<p>96</p>
</td>
<td class="cellalignment833" headers="r22c1-t11 r1c3-t11">
<p>char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r23c1-t11" headers="r1c1-t11">
<p>CHARF</p>
</td>
<td class="cellalignment833" headers="r23c1-t11 r1c2-t11">
<p>96</p>
</td>
<td class="cellalignment833" headers="r23c1-t11 r1c3-t11">
<p>char[n]</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r24c1-t11" headers="r1c1-t11">
<p>CHARZ</p>
</td>
<td class="cellalignment833" headers="r24c1-t11 r1c2-t11">
<p>97</p>
</td>
<td class="cellalignment833" headers="r24c1-t11 r1c3-t11">
<p>char[n+1]</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_04dat.htm#i15971">Chapter 4, &#34;Oracle Datatypes&#34;</a></p>
</li>
<li>
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference.</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i7016"></a>
<div id="LNPCC4159" class="sect2">
<h3 class="sect2">Coercing Datatypes</h3>
<p>For a select descriptor, DESCRIBE SELECT LIST can return any of the Oracle internal datatypes. Often, as in the case of character data, the internal datatype corresponds exactly to the external datatype you want to use. However, a few internal datatypes map to external datatypes that can be difficult to handle. So, you might want to reset some elements in the <span class="italic">T</span> descriptor array. For example, you might want to reset NUMBER values to FLOAT values, which correspond to <span class="bold">float</span> values in C. Oracle does any necessary conversion between internal and external datatypes at FETCH time. So, be sure to reset the datatypes <span class="italic">after</span> the DESCRIBE SELECT LIST but <span class="italic">before</span> the FETCH.<a id="sthref1894"></a><a id="sthref1895"></a><a id="sthref1896"></a></p>
<p>For a bind descriptor, DESCRIBE BIND VARIABLES does <span class="italic">not</span> return the datatypes of bind variables, only their number and names. Therefore, you must explicitly set the <span class="italic">T</span> array of datatype codes to tell Oracle the external datatype of each bind variable. Oracle does any necessary conversion between external and internal datatypes at OPEN time.</p>
<p>When you reset datatype codes in the <span class="italic">T</span> descriptor array, you are &#34;coercing datatypes.&#34; For example, to coerce the <span class="italic">i</span>th select-list value to STRING, you use the following statement:</p>
<pre>/* Coerce select-list value to STRING. */ 
select_des-&gt;T[i] = 5; 
</pre>
<p>When coercing a NUMBER select-list value to STRING for display purposes, you must also extract the precision and scale bytes of the value and use them to compute a maximum display length. Then, before the FETCH, you must reset the appropriate element of the <span class="italic">L</span> (length) descriptor array to tell Oracle the buffer length to use.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i6993">&#34;Extracting Precision and Scale&#34;</a><a id="sthref1897"></a></div>
<p>For example, if DESCRIBE SELECT LIST finds that the <span class="italic">i</span>th select-list item is of type NUMBER, and you want to store the returned value in a C variable declared as <span class="bold">float</span>, simply set <code>T[</code><span class="italic">i</span><code>]</code> to 4 and <code>L[</code><span class="italic">i</span><code>]</code> to the length of <span class="bold">float</span>s on your system.<a id="sthref1898"></a></p>
<div class="infoboxnotewarn">
<p class="notep1">Caution:</p>
<p class="warnsp">In some cases, the internal datatypes that DESCRIBE SELECT LIST returns might not suit your purposes. Two examples of this are DATE and NUMBER. When you DESCRIBE a DATE select-list item, Oracle returns the datatype code 12 to the <span class="italic">T</span> descriptor array. Unless you reset the code before the FETCH, the date value is returned in its 7-byte internal format. To get the date in character format (DD-MON-YY), you can change the datatype code from 12 to 1 (VARCHAR2) or 5 (STRING), and increase the <span class="italic">L</span> value from 7 to 9 or 10.</p>
<p class="warnsp">Similarly, when you DESCRIBE a NUMBER select-list item, Oracle returns the datatype code 2 to the <span class="italic">T</span> array. Unless you reset the code before the FETCH, the numeric value is returned in its internal format, which is probably not what you want. So, change the code from 2 to 1 (VARCHAR2), 3 (INTEGER), 4 (FLOAT), 5 (STRING) or some other appropriate datatype.</p>
</div>
<a id="i6993"></a>
<div id="LNPCC4160" class="sect3">
<h4 class="sect3">Extracting Precision and Scale</h4>
<p>The library function <code>SQLNumberPrecV6()</code> (previously known as <code>sqlprc()</code>) extracts precision and scale. Normally, it is used after the DESCRIBE SELECT LIST, and its first argument is <code>L[</code><span class="italic">i</span><code>]</code>. You call <code>SQLNumberPrecV6()</code> using the following syntax:<a id="sthref1899"></a><a id="sthref1900"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
See your platform-specific <code><span class="codeinlineitalic">SQLNumberPrecV6</span></code> header file for the correct prototype for your platform.</div>
<pre>SQLNumberPrecV6(dvoid *runtime_context, int *length, int *precision,
                int *scale); 
</pre>
<p>where:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="description of runtime_context, length, precision, and scale" summary="description of runtime_context, length, precision, and scale" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t16">Syntax</th>
<th class="cellalignment832" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t16" headers="r1c1-t16"><span class="italic">runtime_context</span></td>
<td class="cellalignment833" headers="r2c1-t16 r1c2-t16">Is the pointer to the runtime context</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t16" headers="r1c1-t16"><span class="italic">length</span></td>
<td class="cellalignment833" headers="r3c1-t16 r1c2-t16">Is a pointer to a long integer variable that stores the length of an Oracle NUMBER value; the length is stored in L[i]. The scale and precision of the value are stored respectively in the low and next-higher bytes.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t16" headers="r1c1-t16"><span class="italic">precision</span></td>
<td class="cellalignment833" headers="r4c1-t16 r1c2-t16">Is a pointer to an integer variable that returns the precision of the NUMBER value. Precision is the number of significant digits. It is set to zero if the select-list item refers to a NUMBER of unspecified size. In this case, because the size is unspecified, you might want to assume the maximum precision (38).<a id="sthref1901"></a><a id="sthref1902"></a><a id="sthref1903"></a></td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t16" headers="r1c1-t16"><span class="italic">scale</span></td>
<td class="cellalignment833" headers="r5c1-t16 r1c2-t16">Is a pointer to an integer variable that returns the scale of the NUMBER value. Scale specifies where rounding will occur. For example, a scale of 2 means the value is rounded to the nearest hundredth (3.456 becomes 3.46); a scale of -3 means the number is rounded to the nearest thousand (3456 becomes 3000).<a id="sthref1904"></a><a id="sthref1905"></a></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>When the scale is negative, add its absolute value to the length. For example, a precision of 3 and scale of -2 allow for numbers as large as 99900.<a id="sthref1906"></a></p>
<p>The following example shows how <code>SQLNumberPrecV6()</code> is used to compute maximum display lengths for NUMBER values that will be coerced to STRING:<a id="sthref1907"></a></p>
<pre>/* Declare variables for the function call. */ 
sqlda         *select_des;  /* pointer to select descriptor */ 
int            prec;        /* precision                    */ 
int            scal;        /* scale                        */ 
extern void SQLNumberPrecV6();  /* Declare library function. */ 
/* Extract precision and scale. */ 
SQLNumberPrecV6(SQL_SINGLE_RCTX, &amp;(select_des-&gt;L[i]), &amp;prec, &amp;scal); 
/* Allow for maximum size of NUMBER. */ 
if (prec == 0) 
    prec = 38; 
/* Allow for possible decimal point and sign. */ 
select_des-&gt;L[i] = prec + 2; 
/* Allow for negative scale. */ 
if (scal &lt; 0) 
    select_des-&gt;L[i] += -scal; 
</pre>
<p>Notice that the first argument in this function call points to the <span class="italic">i</span>th element in the array of lengths, and that all three parameters are addresses.</p>
<p>The <code>SQLNumberPrecV6()</code> function returns zero as the precision and scale values for certain SQL datatypes. The <code>SQLNumberPrecV7()</code> function is similar, having the same argument list, and returning the same values, except in the cases of these SQL datatypes: <a id="sthref1908"></a></p>
<div id="LNPCC4161" class="tblformal">
<p class="titleintable"><a id="sthref1909"></a><a id="g34286"></a>Table 15-3 Precision and Scale Values for SQL Datatypes</p>
<table class="cellalignment831" title="Precision and Scale Values for SQL Datatypes" summary="Precision and Scale Values for SQL Datatypes" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t17">SQL Datatype</th>
<th class="cellalignment832" id="r1c2-t17">Binary Precision</th>
<th class="cellalignment832" id="r1c3-t17">Scale</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t17" headers="r1c1-t17">
<p>FLOAT</p>
</td>
<td class="cellalignment833" headers="r2c1-t17 r1c2-t17">
<p>126</p>
</td>
<td class="cellalignment833" headers="r2c1-t17 r1c3-t17">
<p>-127</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t17" headers="r1c1-t17">
<p>FLOAT(N)</p>
</td>
<td class="cellalignment833" headers="r3c1-t17 r1c2-t17">
<p>N (range is 1 to 126)</p>
</td>
<td class="cellalignment833" headers="r3c1-t17 r1c3-t17">
<p>-127</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t17" headers="r1c1-t17">
<p>REAL</p>
</td>
<td class="cellalignment833" headers="r4c1-t17 r1c2-t17">
<p>63</p>
</td>
<td class="cellalignment833" headers="r4c1-t17 r1c3-t17">
<p>-127</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t17" headers="r1c1-t17">
<p>DOUBLE PRECISION</p>
</td>
<td class="cellalignment833" headers="r5c1-t17 r1c2-t17">
<p>126</p>
</td>
<td class="cellalignment833" headers="r5c1-t17 r1c3-t17">
<p>-127</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i11254"></a>
<div id="LNPCC4162" class="sect2">
<h3 class="sect2">Handling NULL/Not NULL Datatypes</h3>
<p>For every select-list column (not expression), DESCRIBE SELECT LIST returns a NULL/not NULL indication in the datatype array <span class="italic">T</span> of the select descriptor. If the <span class="italic">i</span>th select-list column is constrained to be not NULL, the high-order bit of <code>T[</code><span class="italic">i</span><code>]</code> is clear; otherwise, it is set.<a id="sthref1910"></a></p>
<p>Before using the datatype in an OPEN or FETCH statement, if the NULL/not NULL bit is set, you must clear it. (Never set the bit.)</p>
<p>You can use the library function <code>SQLColumnNullCheck()</code> (previously was called <code>sqlnul()</code>) to find out if a column allows NULLs, and to clear the datatype&#39;s NULL/not NULL bit. You call <code>SQLColumnNullCheck()</code> using the syntax<a id="sthref1911"></a><a id="sthref1912"></a><a id="sthref1913"></a>:</p>
<pre>SQLColumnNullCheck(dvoid *context, unsigned short *value_type, 
      unsigned short *type_code, int *null_status);
</pre>
<p>where:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="descriptions of context, value_type, type_code, and null_status" summary="descriptions of context, value_type, type_code, and null_status" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t18">Syntax</th>
<th class="cellalignment832" id="r1c2-t18">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t18" headers="r1c1-t18"><span class="italic">context</span></td>
<td class="cellalignment833" headers="r2c1-t18 r1c2-t18">Is a pointer to the runtime context</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t18" headers="r1c1-t18"><span class="italic">value_type</span></td>
<td class="cellalignment833" headers="r3c1-t18 r1c2-t18">Is a pointer to an unsigned short integer variable that stores the datatype code of a select-list column; the datatype is stored in T[i].</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t18" headers="r1c1-t18"><span class="italic">type_code</span></td>
<td class="cellalignment833" headers="r4c1-t18 r1c2-t18">Is a pointer to an unsigned short integer variable that returns the datatype code of the select-list column with the high-order bit cleared.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t18" headers="r1c1-t18"><span class="italic">null_status</span></td>
<td class="cellalignment833" headers="r5c1-t18 r1c2-t18">Is a pointer to an integer variable that returns the null status of the select-list column. 1 means the column allows nulls; 0 means it does not.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>The following example shows how to use <code>SQLColumnNullCheck()</code>:<a id="sthref1914"></a></p>
<pre>/* Declare variables for the function call. */ 
sqlda  *select_des;      /* pointer to select descriptor */ 
unsigned short   dtype;  /* datatype without null bit    */ 
int   nullok;            /* 1 = null, 0 = not null       */ 
extern void SQLColumnNullCheck();    /* Declare library function.    */ 
/* Find out whether column is not null. */ 
SQLColumnNUllCheck(SQL_SINGLE_RCTX, (unsigned short *)&amp;(select_des-&gt;T[i]), &amp;dtype, &amp;nullok); 
if (nullok) 
{ 
    /* Nulls are allowed. */ 
    ... 
    /* Clear the null/not null bit. */ 
SQLColumnNullCheck(SQL_SINGLE_RCTX, &amp;(select_des-&gt;T[i]), &amp;(select_des-&gt;T[i]), &amp;nullok); 
} 
</pre>
<p>Notice that the first and second arguments in the second call to the <code>SQLColumnNullCheck()</code> function point to the <span class="italic">i</span>th element in the array of datatypes, and that all three parameters are addresses.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7396"></a>
<div id="LNPCC4163" class="sect1">
<h2 class="sect1">The Basic Steps</h2>
<p>Method 4 can be used to process <span class="italic">any</span> dynamic SQL statement. In the coming example, a query is processed so you can see how both input and output host variables are handled.<a id="sthref1915"></a></p>
<p>To process the dynamic query, our example program takes the following steps:</p>
<ol>
<li>
<p>Declare a host string in the Declare Section to hold the query text.</p>
</li>
<li>
<p>Declare select and bind SQLDAs.</p>
</li>
<li>
<p>Allocate storage space for the select and bind descriptors.</p>
</li>
<li>
<p>Set the maximum number of select-list items and placeholders that can be DESCRIBEd.</p>
</li>
<li>
<p>Put the query text in the host string.</p>
</li>
<li>
<p>PREPARE the query from the host string.</p>
</li>
<li>
<p>DECLARE a cursor FOR the query.</p>
</li>
<li>
<p>DESCRIBE the bind variables INTO the bind descriptor.</p>
</li>
<li>
<p>Reset the number of placeholders to the number actually found by DESCRIBE.</p>
</li>
<li>
<p>Get values and allocate storage for the bind variables found by DESCRIBE.</p>
</li>
<li>
<p>OPEN the cursor USING the bind descriptor.</p>
</li>
<li>
<p>DESCRIBE the select list INTO the select descriptor.</p>
</li>
<li>
<p>Reset the number of select-list items to the number actually found by DESCRIBE.</p>
</li>
<li>
<p>Reset the length and datatype of each select-list item for display purposes.</p>
</li>
<li>
<p>FETCH a row from the database INTO the allocated data buffers pointed to by the select descriptor.</p>
</li>
<li>
<p>Process the select-list values returned by FETCH.</p>
</li>
<li>
<p>Deallocate storage space used for the select-list items, placeholders, indicator variables, and descriptors.</p>
</li>
<li>
<p>CLOSE the cursor.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
Some of these steps are unnecessary if the dynamic SQL statement contains a known number of select-list items or placeholders.</div>
</div>
<!-- class="sect1" -->
<a id="i7400"></a>
<div id="LNPCC4164" class="sect1">
<h2 class="sect1">A Closer Look at Each Step</h2>
<p>This section discusses each step in detail. At the end of this chapter is a Commented, full-length program illustrating Method 4.</p>
<p>With Method 4, you use the following sequence of embedded SQL statements: <a id="sthref1916"></a></p>
<pre>EXEC SQL PREPARE statement_name 
    FROM { :host_string | string_literal }; 
EXEC SQL DECLARE cursor_name CURSOR FOR statement_name; 
EXEC SQL DESCRIBE BIND VARIABLES FOR statement_name 
    INTO bind_descriptor_name; 
EXEC SQL OPEN cursor_name 
    [USING DESCRIPTOR bind_descriptor_name]; 
EXEC SQL DESCRIBE [SELECT LIST FOR] statement_name 
    INTO select_descriptor_name; 
EXEC SQL FETCH cursor_name 
    USING DESCRIPTOR select_descriptor_name; 
EXEC SQL CLOSE cursor_name; 
</pre>
<p>Scrollable cursors can also be used with Method 4. The following sequence of embedded SQL statements must be used for scrollable cursors.</p>
<pre> EXEC SQL PREPARE statement_name 
           FROM { :host_string | string_literal }; 
 EXEC SQL DECLARE cursor_name SCROLL CURSOR FOR statement_name; 
 EXEC SQL DESCRIBE BIND VARIABLES  FOR statement_name 
           INTO bind_descriptor_name; 
 EXEC SQL OPEN cusor_name 
           [ USING DESCRIPTOR bind_descriptor_name]; 
 EXEC SQL DESCRIBE [ SELECT LIST FOR] statement_name 
           INTO select_descriptor_name; 
 EXEC SQL FETCH  [ FIRST| PRIOR|NEXT|LAST|CURRENT | RELATIVE fetch_offset 
           |ABSOLUTE fetch_offset ]  cursor_name USING DESCRIPTOR
            select_descriptor_name; 
 EXEC SQL CLOSE cursor_name;
</pre>
<p>If the number of select-list items in a dynamic query is known, you can omit DESCRIBE SELECT LIST and use the following Method 3 FETCH statement:</p>
<pre>EXEC SQL FETCH cursor_name INTO host_variable_list; 
</pre>
<p>Or, if the number of placeholders for bind variables in a dynamic SQL statement is known, you can omit DESCRIBE BIND VARIABLES and use the following Method 3 OPEN statement:</p>
<pre>EXEC SQL OPEN cursor_name [USING host_variable_list];
 
</pre>
<p>Next, you see how these statements allow your host program to accept and process a dynamic SQL statement using descriptors.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Several figures accompany the following discussion. To avoid cluttering the figures, it was necessary to do the following:</div>
<ul>
<li>
<p>Confine descriptor arrays to 3 elements</p>
</li>
<li>
<p>Limit the maximum length of names to 5 characters</p>
</li>
<li>
<p>Limit the maximum length of values to 10 characters</p>
</li>
</ul>
<div id="LNPCC4165" class="sect2"><a id="sthref1917"></a>
<h3 class="sect2">Declare a Host String</h3>
<p>Your program needs a host variable to store the text of the dynamic SQL statement. The host variable (<span class="italic">select_stmt</span> in our example) must be declared as a character string.</p>
<pre>    ... 
    int      emp_number; 
    VARCHAR  emp_name[10]; 
    VARCHAR  select_stmt[120]; 
    float    bonus; 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4166" class="sect2"><a id="sthref1918"></a>
<h3 class="sect2">Declare the SQLDAs</h3>
<p>In our example, instead of hardcoding the SQLDA data structure, you use INCLUDE to copy it into your program, as follows:</p>
<pre>#include &lt;sqlda.h&gt;
</pre>
<p>Then, because the query might contain an unknown number of select-list items or placeholders for bind variables, you declare pointers to select and bind descriptors, as follows:</p>
<pre>sqlda  *select_des; 
sqlda  *bind_des; 
</pre></div>
<!-- class="sect2" -->
<a id="i6986"></a>
<div id="LNPCC4167" class="sect2">
<h3 class="sect2">Allocate Storage Space for the Descriptors</h3>
<p>Recall that you allocate storage space for a descriptor with the <code>SQLSQLDAAlloc()</code> library function. The syntax, using ANSI C notation, is:</p>
<pre>SQLDA *SQLSQLDAAlloc(dvoid *context, unsigned int max_vars, unsigned int
max_name, unsigned int max_ind_name);
</pre>
<p>The <code>SQLSQLDAAlloc()</code> function allocates the descriptor structure and the arrays addressed by the pointer variables <span class="italic">V</span>, <span class="italic">L</span>, <span class="italic">T</span>, and <span class="italic">I</span>.</p>
<p>If <span class="italic">max_name</span> is nonzero, arrays addressed by the pointer variables <span class="italic">S</span>, <span class="italic">M</span>, and <span class="italic">C</span> are allocated. If <span class="italic">max_ind_name</span> is nonzero, arrays addressed by the pointer variables <span class="italic">X</span>, <span class="italic">Y</span>, and <span class="italic">Z</span> are allocated. No space is allocated if <span class="italic">max_name</span> and <span class="italic">max_ind_name</span> are zero.</p>
<p>If <code>SQLSQLDAAlloc()</code> succeeds, it returns a pointer to the structure. If <code>SQLSQLDAAlloc()</code> fails, it returns a zero.</p>
<p>In our example, you allocate select and bind descriptors, as follows:<a id="sthref1919"></a></p>
<pre>select_des = SQLSQLDAAlloc(SQL_SINGLE_RCTX, 3, (size_t) 5, (size_t) 0); 
bind_des = SQLSQLDAAlloc(SQL_SINGLE_RCTX, 3, (size_t) 5, (size_t) 4); 
</pre>
<p>For select descriptors, always set <span class="italic">max_ind_name</span> to zero so that no space is allocated for the array addressed by <span class="italic">X</span>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4168" class="sect2"><a id="sthref1920"></a>
<h3 class="sect2">Set the Maximum Number to DESCRIBE</h3>
<p>Next, you set the maximum number of select-list items or placeholders that can be DESCRIBEd, as follows:</p>
<pre>select_des-&gt;N = 3; 
bind_des-&gt;N = 3; 
</pre>
<p><a href="#i12575">Figure 15-2</a> and <a href="#i12577">Figure 15-3</a> represent the resulting descriptors.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In the select descriptor (<a href="#i12575">Figure 15-2</a>), the section for indicator-variable names is crossed out to show that it is not used.</div>
<div id="LNPCC4169" class="figure">
<p class="titleinfigure"><a id="i12575"></a>Figure 15-2 Initialized Select Descriptor</p>
<img width="496" height="600" src="img/lnpcc011.gif" alt="Description of Figure 15-2 follows"/><br/>
<a id="sthref1921" href="img_text/lnpcc011.htm">Description of &#34;Figure 15-2 Initialized Select Descriptor&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="LNPCC4170" class="figure">
<p class="titleinfigure"><a id="i12577"></a>Figure 15-3 Initialized Bind Descriptor</p>
<img width="496" height="566" src="img/lnpcc012.gif" alt="Description of Figure 15-3 follows"/><br/>
<a id="sthref1922" href="img_text/lnpcc012.htm">Description of &#34;Figure 15-3 Initialized Bind Descriptor&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCC4171" class="sect2"><a id="sthref1923"></a>
<h3 class="sect2">Put the Query Text in the Host String</h3>
<p>Continuing our example, you prompt the user for a SQL statement, then store the input string in <span class="italic">select_stmt</span>, as follows:</p>
<pre>printf(&#34;\n\nEnter SQL statement: &#34;); 
gets(select_stmt.arr); 
select_stmt.len = strlen(select_stmt.arr); 
</pre>
<p>We assume the user entered the following string:</p>
<pre>&#34;SELECT ename, empno, comm FROM emp WHERE comm &lt; :bonus&#34; 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4172" class="sect2"><a id="sthref1924"></a>
<h3 class="sect2">PREPARE the Query from the Host String</h3>
<p>PREPARE parses the SQL statement and gives it a name. In our example, PREPARE parses the host string <span class="italic">select_stmt</span> and gives it the name <span class="italic">sql_stmt</span>, as follows:<a id="sthref1925"></a><a id="sthref1926"></a></p>
<pre>EXEC SQL PREPARE sql_stmt FROM :select_stmt; 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4173" class="sect2"><a id="sthref1927"></a>
<h3 class="sect2">DECLARE a Cursor</h3>
<p>DECLARE CURSOR defines a cursor by giving it a name and associating it with a specific SELECT statement.</p>
<p>To declare a cursor for <span class="italic">static</span> queries, you use the following syntax:<a id="sthref1928"></a><a id="sthref1929"></a></p>
<pre>EXEC SQL DECLARE cursor_name CURSOR FOR SELECT ... 
</pre>
<p>To declare a cursor for <span class="italic">dynamic</span> queries, the statement name given to the dynamic query by PREPARE is substituted for the static query. In our example, DECLARE CURSOR defines a cursor named <span class="italic">emp_cursor</span> and associates it with <span class="italic">sql_stmt</span>, as follows:</p>
<pre>EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt; 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can declare a cursor for all dynamic SQL statements, not just queries. With non-queries, OPENing the cursor executes the dynamic SQL statement.</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC4174" class="sect2"><a id="sthref1930"></a>
<h3 class="sect2">DESCRIBE the Bind Variables</h3>
<p>DESCRIBE BIND VARIABLES puts descriptions of placeholders into a bind descriptor. In our example, DESCRIBE readies <span class="italic">bind_des</span>, as follows:<a id="sthref1931"></a><a id="sthref1932"></a></p>
<pre>EXEC SQL DESCRIBE BIND VARIABLES FOR sql_stmt INTO bind_des; 
</pre>
<p>Note that <span class="italic">bind_des</span> must <span class="italic">not</span> be prefixed with a colon.</p>
<p>The DESCRIBE BIND VARIABLES statement must follow the PREPARE statement but precede the OPEN statement.</p>
<p><a href="#i12580">Figure 15-4</a> shows the bind descriptor in our example after the DESCRIBE. Notice that DESCRIBE has set <span class="italic">F</span> to the actual number of placeholders found in the processed SQL statement.</p>
<div id="LNPCC4175" class="figure">
<p class="titleinfigure"><a id="i12580"></a>Figure 15-4 Bind Descriptor after the DESCRIBE</p>
<img width="496" height="544" src="img/lnpcc013.gif" alt="Description of Figure 15-4 follows"/><br/>
<a id="sthref1933" href="img_text/lnpcc013.htm">Description of &#34;Figure 15-4 Bind Descriptor after the DESCRIBE&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCC4176" class="sect2"><a id="sthref1934"></a>
<h3 class="sect2">Reset Number of Placeholders</h3>
<p>Next, you must reset the maximum number of placeholders to the number actually found by DESCRIBE, as follows:</p>
<pre>bind_des-&gt;N = bind_des-&gt;F; 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4177" class="sect2"><a id="sthref1935"></a>
<h3 class="sect2">Get Values and Allocate Storage for Bind Variables</h3>
<p>Your program must get values for the bind variables found in the SQL statement, and allocate memory for them. How the program gets the values is up to you. For example, they can be hardcoded, read from a file, or entered interactively.</p>
<p>In our example, a value must be assigned to the bind variable that replaces the placeholder <span class="italic">bonus</span> in the query WHERE clause. So, you choose to prompt the user for the value, then process it as follows:</p>
<pre>for (i = 0; i &lt; bind_des-&gt;F; i++) 
{ 
    printf(&#34;\nEnter value of bind variable %.*s:\n? &#34;, 
        (int) bind_des-&gt;C[i], bind_des-&gt;S[i]); 
    gets(hostval); 
    /* Set length of value. */ 
    bind_des-&gt;L[i] = strlen(hostval); 
    /* Allocate storage for value and null terminator. */ 
    bind_des-&gt;V[i] = malloc(bind_des-&gt;L[i] + 1); 
    /* Allocate storage for indicator value. */ 
    bind_des-&gt;I[i] = (unsigned short *) malloc(sizeof(short)); 
    /* Store value in bind descriptor. */ 
    strcpy(bind_des-&gt;V[i], hostval); 
    /* Set value of indicator variable. */ 
    *(bind_des-&gt;I[i]) = 0;  /* or -1 if &#34;null&#34; is the value */ 
    /* Set datatype to STRING. */ 
    bind_des-&gt;T[i] = 5; 
} 
</pre>
<p>Assuming that the user supplied a value of 625 for <span class="italic">bonus</span>, <a href="#i12569">Figure 15-5</a> shows the resulting bind descriptor. Notice that the value is null-terminated.</p>
<div id="LNPCC4178" class="figure">
<p class="titleinfigure"><a id="i12569"></a>Figure 15-5 Bind Descriptor after Assigning Values</p>
<img width="496" height="599" src="img/lnpcc014.gif" alt="Description of Figure 15-5 follows"/><br/>
<a id="sthref1936" href="img_text/lnpcc014.htm">Description of &#34;Figure 15-5 Bind Descriptor after Assigning Values&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCC4179" class="sect2"><a id="sthref1937"></a>
<h3 class="sect2">OPEN the Cursor</h3>
<p>The OPEN statement used for dynamic queries is like that used for static queries except that the cursor is associated with a bind descriptor. Values determined at run time and stored in buffers addressed by elements of the bind descriptor arrays are used to evaluate the SQL statement. With queries, the values are also used to identify the active set.<a id="sthref1938"></a><a id="sthref1939"></a></p>
<p>In our example, OPEN associates <span class="italic">emp_cursor</span> with <span class="italic">bind_des</span>, as follows:</p>
<pre>EXEC SQL OPEN emp_cursor USING DESCRIPTOR bind_des; 
</pre>
<p>Remember, <span class="italic">bind_des</span> must <span class="italic">not</span> be prefixed with a colon.</p>
<p>Then, OPEN executes the SQL statement. With queries, OPEN also identifies the active set and positions the cursor at the first row.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4180" class="sect2"><a id="sthref1940"></a>
<h3 class="sect2">DESCRIBE the Select List</h3>
<p>If the dynamic SQL statement is a query, the DESCRIBE SELECT LIST statement must follow the OPEN statement but precede the FETCH statement.<a id="sthref1941"></a><a id="sthref1942"></a></p>
<p>DESCRIBE SELECT LIST puts descriptions of select-list items in a select descriptor. In our example, DESCRIBE readies <span class="italic">select_des</span>, as follows:</p>
<pre>EXEC SQL DESCRIBE SELECT LIST FOR sql_stmt INTO select_des;
 
</pre>
<p>Accessing the Oracle data dictionary, DESCRIBE sets the length and datatype of each select-list value.</p>
<p><a href="#i7565">Figure 15-6</a> shows the select descriptor in our example after the DESCRIBE. Notice that DESCRIBE has set <span class="italic">F</span> to the actual number of items found in the query select list. If the SQL statement is not a query, <span class="italic">F</span> is set to zero.</p>
<p>Also notice that the NUMBER lengths are not usable yet. For columns defined as NUMBER, you must use the library function <code>SQLNumberPrecV6()</code> to extract precision and scale.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i7016">&#34;Coercing Datatypes&#34;</a></div>
<div id="LNPCC4181" class="figure">
<p class="titleinfigure"><a id="i7565"></a>Figure 15-6 Select Descriptor after the DESCRIBE</p>
<img width="496" height="632" src="img/lnpcc015.gif" alt="Description of Figure 15-6 follows"/><br/>
<a id="sthref1943" href="img_text/lnpcc015.htm">Description of &#34;Figure 15-6 Select Descriptor after the DESCRIBE&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCC4182" class="sect2"><a id="sthref1944"></a>
<h3 class="sect2">Reset Number of Select-List Items</h3>
<p>Next, you must reset the maximum number of select-list items to the number actually found by DESCRIBE, as follows:</p>
<pre>select_des-&gt;N = select_des-&gt;F; 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4183" class="sect2"><a id="sthref1945"></a>
<h3 class="sect2">Reset Length/Datatype of Each Select-list Item</h3>
<p>In our example, before FETCHing the select-list values, you allocate storage space for them using the library function <code>malloc()</code>. You also reset some elements in the length and datatype arrays for display purposes.<a id="sthref1946"></a><a id="sthref1947"></a><a id="sthref1948"></a></p>
<pre>for (i=0; i&lt;select_des-&gt;F; i++) 
{ 
    /* Clear null bit. */ 
    SQLColumnNullCheck(SQL_SINGLE_RCTX, (unsigned short *)&amp;(select_des-&gt;T[i]),
         (unsigned short *)&amp;(select_des-&gt;T[i]), &amp;nullok); 
    /* Reset length if necessary. */ 
    switch(select_des-&gt;T[i]) 
    { 
        case  1: break; 
        case  2: SQLNumberPrecV6(SQL_SINGLE_RCTX, (unsigned long *)
                      &amp;(select_des-&gt;L[i]), &amp;prec, &amp;scal); 
                 if (prec == 0) prec = 40; 
                 select_des-&gt;L[i] = prec + 2; 
                 if (scal &lt; 0) select_des-&gt;L[i] += -scal; 
                 break; 
        case  8: select_des-&gt;L[i] = 240; 
                 break; 
        case 11: select_des-&gt;L[i] = 18; 
                 break; 
        case 12: select_des-&gt;L[i] = 9; 
                 break; 
        case 23: break; 
        case 24: select_des-&gt;L[i] = 240; 
                 break; 
    } 
    /* Allocate storage for select-list value. */ 
    select_des-&gt;V[i] = malloc(select_des-&gt;L[i]+1); 
    /* Allocate storage for indicator value. */ 
    select_des-&gt;I[i] = (short *)malloc(sizeof(short *)); 
    /* Coerce all datatypes except LONG RAW to STRING. */ 
    if (select_des-&gt;T[i] != 24) select_des-&gt;T[i] = 5; 
} 
</pre>
<p><a href="#i12571">Figure 15-7</a> shows the resulting select descriptor. Notice that the NUMBER lengths are now usable and that all the datatypes are STRING. The lengths in <code>L[1]</code> and <code>L[2]</code> are 6 and 9 because we increased the DESCRIBEd lengths of 4 and 7 by 2 to allow for a possible sign and decimal point.</p>
<div id="LNPCC4184" class="figure">
<p class="titleinfigure"><a id="i12571"></a>Figure 15-7 Select Descriptor before the FETCH</p>
<img width="496" height="616" src="img/lnpcc016.gif" alt="Description of Figure 15-7 follows"/><br/>
<a id="sthref1949" href="img_text/lnpcc016.htm">Description of &#34;Figure 15-7 Select Descriptor before the FETCH&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCC4185" class="sect2"><a id="sthref1950"></a>
<h3 class="sect2">FETCH Rows from the Active Set</h3>
<p>FETCH returns a row from the active set, stores select-list values in the data buffers, and advances the cursor to the next row in the active set. If there are no more rows, FETCH sets <span class="italic">sqlca.sqlcode</span> to the &#34;no data found&#34; Oracle error code. In our example, FETCH returns the values of columns ENAME, EMPNO, and COMM to <span class="italic">select_des</span>, as follows:<a id="sthref1951"></a><a id="sthref1952"></a></p>
<pre>EXEC SQL FETCH emp_cursor USING DESCRIPTOR select_des;
 
</pre>
<p><a href="#i12573">Figure 15-8</a> shows the select descriptor in our example after the FETCH. Notice that Oracle has stored the select-list and indicator values in the data buffers addressed by the elements of <span class="italic">V</span> and <span class="italic">I</span>.</p>
<p>For output buffers of datatype 1, Oracle, using the lengths stored in the <span class="italic">L</span> array, left-justifies CHAR or VARCHAR2 data and right-justifies NUMBER data. For output buffer of type 5 (STRING), Oracle left-justifies and null terminates CHAR, VARCHAR2, and NUMBER data.</p>
<p>The value &#39;MARTIN&#39; was retrieved from a VARCHAR2(10) column in the EMP table. Using the length in <code>L[0]</code>, Oracle left-justifies the value in a 10-byte field, filling the buffer.</p>
<p>The value 7654 was retrieved from a NUMBER(4) column and coerced to &#39;7654&#39;. However, the length in <code>L[1]</code> was increased by 2 to allow for a possible sign and decimal point. So, Oracle left-justifies and null terminates the value in a 6-byte field.</p>
<p>The value 482.50 was retrieved from a NUMBER(7,2) column and coerced to &#39;482.50&#39;. Again, the length in <code>L[2]</code> was increased by 2. So, Oracle left-justifies and null terminates the value in a 9-byte field.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4186" class="sect2"><a id="sthref1953"></a>
<h3 class="sect2">Get and Process Select-List Values</h3>
<p>After the FETCH, your program can process the returned values. In our example, values for columns ENAME, EMPNO, and COMM are processed.</p>
<div id="LNPCC4187" class="figure">
<p class="titleinfigure"><a id="i12573"></a>Figure 15-8 Selected Descriptor after the FETCH</p>
<img width="496" height="616" src="img/lnpcc017.gif" alt="Description of Figure 15-8 follows"/><br/>
<a id="sthref1954" href="img_text/lnpcc017.htm">Description of &#34;Figure 15-8 Selected Descriptor after the FETCH&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="i7044"></a>
<div id="LNPCC4188" class="sect2">
<h3 class="sect2">Deallocate Storage</h3>
<p>You use the <code>free()</code> library function to deallocate the storage space allocated by <code>malloc()</code>. The syntax is as follows:<a id="sthref1955"></a><a id="sthref1956"></a></p>
<pre>free(char *pointer); 
</pre>
<p>In our example, you deallocate storage space for the values of the select-list items, bind variables, and indicator variables, as follows:<a id="sthref1957"></a></p>
<pre>for (i = 0; i &lt; select_des-&gt;F; i++)   /* for select descriptor */ 
{ 
    free(select_des-&gt;V[i]); 
    free(select_des-&gt;I[i]); 
} 
for (i = 0; i &lt; bind_des-&gt;F; i++)   /* for bind descriptor */ 
{ 
    free(bind_des-&gt;V[i]); 
    free(bind_des-&gt;I[i]); 
} 
</pre>
<p>You deallocate storage space for the descriptors themselves with the <code>SQLSQLDAFree()</code> library function, using the following syntax: <a id="sthref1958"></a><a id="sthref1959"></a><a id="sthref1960"></a></p>
<pre>SQLSQLDAFree(context, descriptor_name); 
</pre>
<p>The descriptor must have been allocated using <code>SQLSQLDAAlloc()</code>. Otherwise, the results are unpredictable.</p>
<p>In our example, you deallocate storage space for the select and bind descriptors as follows:<a id="sthref1961"></a></p>
<pre>SQLSQLDAFree(SQL_SINGLE_RCTX, select_des); 
SQLSQLDAFree(SQL_SINGLE_RCTX, bind_des); 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4189" class="sect2"><a id="sthref1962"></a>
<h3 class="sect2">CLOSE the Cursor</h3>
<p>CLOSE disables the cursor. In our example, CLOSE disables <span class="italic">emp_cursor</span> as follows:<a id="sthref1963"></a><a id="sthref1964"></a></p>
<pre>EXEC SQL CLOSE emp_cursor; 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4190" class="sect2"><a id="sthref1965"></a>
<h3 class="sect2">Using Host Arrays</h3>
<p>To use input or output host arrays with Method 4, you must use the optional FOR clause to tell Oracle the size of your host array.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_08arr.htm#g20885">Chapter 8, &#34;Host Arrays&#34;</a><a id="sthref1966"></a><a id="sthref1967"></a><a id="sthref1968"></a><a id="sthref1969"></a> for more information on the FOR clause</div>
<p>You must set descriptor entries for the <span class="italic">i</span>th select-list item or bind variable using the syntax</p>
<pre>V[i] = array_address; 
L[i] = element_size; 
</pre>
<p>where <span class="italic">array_address</span> is the address of the host array, and <span class="italic">element_size</span> is the size of one array element.</p>
<p>Then, you must use a FOR clause in the EXECUTE or FETCH statement (whichever is appropriate) to tell Oracle the number of array elements you want to process. This procedure is necessary because Oracle has no other way of knowing the size of your host array.</p>
<p>In the complete program example later, three input host arrays are used to INSERT rows into the EMP table. EXECUTE can be used for Data Manipulation Language statements other than queries with Method 4.</p>
<pre>#include &lt;stdio.h&gt;
#include &lt;sqlcpr.h&gt;
#include &lt;sqlda.h&gt;
#include &lt;sqlca.h&gt;
 
#define NAME_SIZE    10
#define INAME_SIZE   10
#define ARRAY_SIZE    5
 
/* connect string */
char *username = &#34;scott/tiger&#34;;
 
char *sql_stmt =
&#34;INSERT INTO emp (empno, ename, deptno) VALUES (:e, :n, :d)&#34;;
int  array_size = ARRAY_SIZE;  /* must have a host variable too */
 
SQLDA   *binda;
 
char    names[ARRAY_SIZE][NAME_SIZE];
int     numbers[ARRAY_SIZE], depts[ARRAY_SIZE];

/* Declare and initialize indicator vars. for empno and deptno columns */
short   ind_empno[ARRAY_SIZE] = {0,0,0,0,0};
short   ind_dept[ARRAY_SIZE] = {0,0,0,0,0};
 
main() 
{ 
    EXEC SQL WHENEVER SQLERROR GOTO sql_error; 
 
/* Connect */ 
    EXEC SQL CONNECT :username; 
    printf(&#34;Connected.\n&#34;); 
 
/* Allocate the descriptors and set the N component. 
   This must be done before the DESCRIBE. */ 
    binda = SQLSQLDAAlloc(SQL_SINGLE_RCTX, 3, NAME_SIZE, INAME_SIZE); 
    binda-&gt;N = 3; 
 
/* Prepare and describe the SQL statement. */ 
    EXEC SQL PREPARE stmt FROM :sql_stmt; 
    EXEC SQL DESCRIBE BIND VARIABLES FOR stmt INTO binda; 
 
/* Initialize the descriptors. */ 
    binda-&gt;V[0] = (char *) numbers; 
    binda-&gt;L[0] = (long) sizeof (int); 
    binda-&gt;T[0] = 3; 
    binda-&gt;I[0] = ind_empno; 
 
    binda-&gt;V[1] = (char *) names; 
    binda-&gt;L[1] = (long) NAME_SIZE; 
    binda-&gt;T[1] = 1; 
    binda-&gt;I[1] = (short *)0;
 
    binda-&gt;V[2] = (char *) depts; 
    binda-&gt;L[2] = (long) sizeof (int); 
    binda-&gt;T[2] = 3; 
    binda-&gt;I[2] = ind_dept; 
 
/* Initialize the data buffers. */ 
    strcpy(&amp;names[0] [0], &#34;ALLISON&#34;); 
    numbers[0] = 1014; 
    depts[0] = 30; 
 
    strcpy(&amp;names[1] [0], &#34;TRUSDALE&#34;); 
    numbers[1] = 1015; 
    depts[1] = 30; 
 
    strcpy(&amp;names[2] [0], &#34;FRAZIER&#34;); 
    numbers[2] = 1016; 
    depts[2] = 30; 
 
    strcpy(&amp;names[3] [0], &#34;CARUSO&#34;); 
    numbers[3] = 1017; 
    ind_dept[3] = -1;       /* set indicator to -1 to insert NULL */
    depts[3] = 30;          /* value in depts[3] is ignored */ 
 
    strcpy(&amp;names[4] [0], &#34;WESTON&#34;); 
    numbers[4] = 1018;
    depts[4] = 30;
 
/* Do the INSERT. */
    printf(&#34;Adding to the Sales force...\n&#34;);
    
    EXEC SQL FOR :array_size
    EXECUTE stmt USING DESCRIPTOR binda;
 
/*  Print rows-processed count. */
    printf(&#34;%d rows inserted.\n\n&#34;, sqlca.sqlerrd[2]);
    EXEC SQL COMMIT RELEASE;
    exit(0);
 
sql_error: 
/* Print Oracle error message. */
    printf(&#34;\n%.70s&#34;, sqlca.sqlerrm.sqlerrmc);
    EXEC SQL WHENEVER SQLERROR CONTINUE; 
    EXEC SQL ROLLBACK RELEASE; 
    exit(1); 
} 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4191" class="sect2"><a id="sthref1970"></a>
<h3 class="sect2">sample12.pc<a id="sthref1971"></a></h3>
<p>A simple dynamic SQL example using array fetches is shown in file <code>sample12.pc</code> in the demo directory.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7419"></a>
<div id="LNPCC4192" class="sect1">
<h2 class="sect1">Example Program: Dynamic SQL Method 4<a id="sthref1972"></a><a id="sthref1973"></a></h2>
<p>This program shows the basic steps required to use dynamic SQL with Method 4. After connecting to Oracle, the program:</p>
<ul>
<li>
<p>Allocates memory for the descriptors using SQLSQLDAAlloc()</p>
</li>
<li>
<p>Prompts the user for a SQL statement</p>
</li>
<li>
<p>PREPAREs the statement</p>
</li>
<li>
<p>DECLAREs a cursor</p>
</li>
<li>
<p>Checks for any bind variables using DESCRIBE BIND</p>
</li>
<li>
<p>OPENs the cursor</p>
</li>
<li>
<p>DESCRIBEs any select-list items.</p>
</li>
</ul>
<p>If the input SQL statement is a query, the program FETCHes each row of data, then CLOSEs the cursor. This program is available on-line in the <code>demo</code> directory, in the file <code>sample10.pc</code>.</p>
<pre>/*******************************************************************
Sample Program 10:  Dynamic SQL Method 4

This program connects you to ORACLE using your username and
password, then prompts you for a SQL statement.  You can enter
any legal SQL statement.  Use regular SQL syntax, not embedded SQL.
Your statement will be processed.  If it is a query, the rows
fetched are displayed.
You can enter multiline statements.  The limit is 1023 characters.
This sample program only processes up to MAX_ITEMS bind variables and
MAX_ITEMS select-list items.  MAX_ITEMS is #defined to be 40.
*******************************************************************/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;sqlda.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlcpr.h&gt;

/* Maximum number of select-list items or bind variables. */
#define MAX_ITEMS         40

/* Maximum lengths of the _names_ of the
   select-list items or indicator variables. */
#define MAX_VNAME_LEN     30
#define MAX_INAME_LEN     30

#ifndef NULL
#define NULL  0
#endif

/* Prototypes */
#if defined(__STDC__)
  void sql_error(void);
  int oracle_connect(void);
  int alloc_descriptors(int, int, int);
  int get_dyn_statement(void);
  void set_bind_variables(void);
  void process_select_list(void);
  void help(void);
#else
  void sql_error(/*_ void _*/);
  int oracle_connect(/*_ void _*/);
  int alloc_descriptors(/*_ int, int, int _*/);
  int get_dyn_statement(/* void _*/);
  void set_bind_variables(/*_ void -*/);
  void process_select_list(/*_ void _*/);
  void help(/*_ void _*/);
#endif

char *dml_commands[] = {&#34;SELECT&#34;, &#34;select&#34;, &#34;INSERT&#34;, &#34;insert&#34;,
                        &#34;UPDATE&#34;, &#34;update&#34;, &#34;DELETE&#34;, &#34;delete&#34;};

EXEC SQL INCLUDE sqlda;
EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION;
    char    dyn_statement[1024];
    EXEC SQL VAR dyn_statement IS STRING(1024);
EXEC SQL END DECLARE SECTION;
 
SQLDA *bind_dp;
SQLDA *select_dp;

/* Define a buffer to hold longjmp state info. */
jmp_buf jmp_continue;

/* A global flag for the error routine. */
int parse_flag = 0;

void main()
{
    int i;

    /* Connect to the database. */
    if (oracle_connect() != 0)
        exit(1);

    /* Allocate memory for the select and bind descriptors. */
    if (alloc_descriptors(MAX_ITEMS, MAX_VNAME_LEN, MAX_INAME_LEN) != 0)
        exit(1);

    /* Process SQL statements. */
    for (;;) 
    {
        (void) setjmp(jmp_continue);

        /* Get the statement.  Break on &#34;exit&#34;. */
        if (get_dyn_statement() != 0)
            break;

        /* Prepare the statement and declare a cursor. */
        EXEC SQL WHENEVER SQLERROR DO sql_error();

        parse_flag = 1;     /* Set a flag for sql_error(). */
        EXEC SQL PREPARE S FROM :dyn_statement;
        parse_flag = 0;     /* Unset the flag. */

        EXEC SQL DECLARE C CURSOR FOR S;

        /* Set the bind variables for any placeholders in the
           SQL statement. */
        set_bind_variables();

        /* Open the cursor and execute the statement.
         * If the statement is not a query (SELECT), the
         * statement processing is completed after the
         * OPEN.
         */

        EXEC SQL OPEN C USING DESCRIPTOR bind_dp;

        /* Call the function that processes the select-list.
         * If the statement is not a query, this function
         * just returns, doing nothing.
         */
        process_select_list();

        /* Tell user how many rows processed. */
        for (i = 0; i &lt; 8; i++)
        {
           if (strncmp(dyn_statement, dml_commands[i], 6) == 0)
           {
               printf(&#34;\n\n%d row%c processed.\n&#34;, sqlca.sqlerrd[2],
                       sqlca.sqlerrd[2] == 1 ? &#39;\0&#39; : &#39;s&#39;);
               break;
           }
        }
    }       /* end of for(;;) statement-processing loop */

    /* When done, free the memory allocated for
       pointers in the bind and select descriptors. */
    for (i = 0; i &lt; MAX_ITEMS; i++)
    {    
        if (bind_dp-&gt;V[i] != (char *) 0)
            free(bind_dp-&gt;V[i]);
        free(bind_dp-&gt;I[i]);   /* MAX_ITEMS were allocated. */
        if (select_dp-&gt;V[i] != (char *) 0)
            free(select_dp-&gt;V[i]);
        free(select_dp-&gt;I[i]); /* MAX_ITEMS were allocated. */
    }

    /* Free space used by the descriptors themselves. */
    SQLSQLDAFree( SQL_SINGLE_RCTX, bind_dp);
    SQLSQLDAFree( SQL_SINGLE_RCTX, select_dp);

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    /* Close the cursor. */
    EXEC SQL CLOSE C;

    EXEC SQL COMMIT WORK RELEASE;
    puts(&#34;\nHave a good day!\n&#34;);

    EXEC SQL WHENEVER SQLERROR DO sql_error();
    return;
}


int oracle_connect()
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR  username[128];
        VARCHAR  password[32];
    EXEC SQL END DECLARE SECTION;

    printf(&#34;\nusername: &#34;);
    fgets((char *) username.arr, sizeof username.arr, stdin);
    username.arr[strlen((char *) username.arr)-1] = &#39;\0&#39;;
    username.len = (unsigned short)strlen((char *) username.arr);

    printf(&#34;password: &#34;);
    fgets((char *) password.arr, sizeof password.arr, stdin);
    password.arr[strlen((char *) password.arr) - 1] = &#39;\0&#39;;
    password.len = (unsigned short)strlen((char *) password.arr);


    EXEC SQL WHENEVER SQLERROR GOTO connect_error;

    EXEC SQL CONNECT :username IDENTIFIED BY :password;

    printf(&#34;\nConnected to ORACLE as user %s.\n&#34;, username.arr);

    return 0;

connect_error:
    fprintf(stderr, &#34;Cannot connect to ORACLE as user %s\n&#34;, username.arr);
    return -1;
}


/*
 *  Allocate the BIND and SELECT descriptors using SQLSQLDAAlloc().
 *  Also allocate the pointers to indicator variables
 *  in each descriptor.  The pointers to the actual bind
 *  variables and the select-list items are realloc&#39;ed in
 *  the set_bind_variables() or process_select_list()
 *  routines.  This routine allocates 1 byte for select_dp-&gt;V[i]
 *  and bind_dp-&gt;V[i], so the realloc will work correctly.
 */

alloc_descriptors(size, max_vname_len, max_iname_len)
int size;
int max_vname_len;
int max_iname_len;
{
    int i;

    /*
     * The first SQLSQLDAAlloc parameter is the runtime context.

     * The second parameter determines the maximum number of
     * array elements in each variable in the descriptor. In
     * other words, it determines the maximum number of bind
     * variables or select-list items in the SQL statement.
     *
     * The third parameter determines the maximum length of
     * strings used to hold the names of select-list items
     * or placeholders.  The maximum length of column 
     * names in ORACLE is 30, but you can allocate more or less
     * as needed.
     *
     * The fourth parameter determines the maximum length of
     * strings used to hold the names of any indicator
     * variables.  To follow ORACLE standards, the maximum
     * length of these should be 30.  But, you can allocate
     * more or less as needed.
     */

    if ((bind_dp =
       SQLSQLDAAlloc(SQL_SINGLE_RCTX, size, max_vname_len, max_iname_len)) == 
         (SQLDA *) 0)
    {
        fprintf(stderr,
            &#34;Cannot allocate memory for bind descriptor.&#34;);
        return -1;  /* Have to exit in this case. */
    }

    if ((select_dp =
        SQLSQLDAAlloc (SQL_SINGLE_RCTX, size, max_vname_len, max_iname_len)) == 
           (SQLDA *) 0)
    {
        fprintf(stderr,
            &#34;Cannot allocate memory for select descriptor.&#34;);
        return -1;
    }
    select_dp-&gt;N = MAX_ITEMS;

    /* Allocate the pointers to the indicator variables, and the
       actual data. */
    for (i = 0; i &lt; MAX_ITEMS; i++) {
        bind_dp-&gt;I[i] = (short *) malloc(sizeof (short));
        select_dp-&gt;I[i] = (short *) malloc(sizeof(short));
        bind_dp-&gt;V[i] = (char *) malloc(1);
        select_dp-&gt;V[i] = (char *) malloc(1);
    }
       
    return 0;
}


int get_dyn_statement()
{
    char *cp, linebuf[256];
    int iter, plsql;


    for (plsql = 0, iter = 1; ;)
    {
        if (iter == 1)
        {
            printf(&#34;\nSQL&gt; &#34;);
            dyn_statement[0] = &#39;\0&#39;;
        }
        
        fgets(linebuf, sizeof linebuf, stdin);

        cp = strrchr(linebuf, &#39;\n&#39;);
        if (cp &amp;&amp; cp != linebuf)
            *cp = &#39; &#39;;
        else if (cp == linebuf)
            continue;

        if ((strncmp(linebuf, &#34;EXIT&#34;, 4) == 0) ||
            (strncmp(linebuf, &#34;exit&#34;, 4) == 0))
        {
            return -1;
        }

        else if (linebuf[0] == &#39;?&#39; ||
            (strncmp(linebuf, &#34;HELP&#34;, 4) == 0) ||
            (strncmp(linebuf, &#34;help&#34;, 4) == 0))
        {
            help();
            iter = 1;
            continue;
        }

        if (strstr(linebuf, &#34;BEGIN&#34;) ||
            (strstr(linebuf, &#34;begin&#34;)))
        {
            plsql = 1;
        }

        strcat(dyn_statement, linebuf);

        if ((plsql &amp;&amp; (cp = strrchr(dyn_statement, &#39;/&#39;))) ||
            (!plsql &amp;&amp; (cp = strrchr(dyn_statement, &#39;;&#39;))))
        {
            *cp = &#39;\0&#39;;
            break;
        }
        else
        {
            iter++;
            printf(&#34;%3d  &#34;, iter);
        }
    }
    return 0;
}



void set_bind_variables()
{
    int i, n;
    char bind_var[64];

    /* Describe any bind variables (input host variables) */
    EXEC SQL WHENEVER SQLERROR DO sql_error();

    bind_dp-&gt;N = MAX_ITEMS;  /* Initialize count of array elements. */
    EXEC SQL DESCRIBE BIND VARIABLES FOR S INTO bind_dp;

    /* If F is negative, there were more bind variables
       than originally allocated by SQLSQLDAAlloc(). */
    if (bind_dp-&gt;F &lt; 0)
    {
        printf (&#34;\nToo many bind variables (%d), maximum is %d\n.&#34;,
                    -bind_dp-&gt;F, MAX_ITEMS);
        return;
    }

    /* Set the maximum number of array elements in the
       descriptor to the number found. */
    bind_dp-&gt;N = bind_dp-&gt;F;
 
    /* Get the value of each bind variable as a
     * character string.
     *   
     * C[i] contains the length of the bind variable
     *      name used in the SQL statement.
     * S[i] contains the actual name of the bind variable
     *      used in the SQL statement.
     *
     * L[i] will contain the length of the data value
     *      entered.
     *
     * V[i] will contain the address of the data value
     *      entered.
     *
     * T[i] is always set to 1 because in this sample program
     *      data values for all bind variables are entered
     *      as character strings.
     *      ORACLE converts to the table value from CHAR.
     *
     * I[i] will point to the indicator value, which is
     *      set to -1 when the bind variable value is &#34;null&#34;.
     */
    for (i = 0; i &lt; bind_dp-&gt;F; i++)
    {
        printf (&#34;\nEnter value for bind variable %.*s:  &#34;,
               (int)bind_dp-&gt;C[i], bind_dp-&gt;S[i]);
        fgets(bind_var, sizeof bind_var, stdin);

        /* Get length and remove the new line character. */
        n = strlen(bind_var) - 1;

        /* Set it in the descriptor. */
        bind_dp-&gt;L[i] = n;

        /* (re-)allocate the buffer for the value.
           SQLSQLDAAlloc() reserves a pointer location for
           V[i] but does not allocate the full space for
           the pointer. */

         bind_dp-&gt;V[i] = (char *) realloc(bind_dp-&gt;V[i],
                         (bind_dp-&gt;L[i] + 1));            

        /* And copy it in. */
        strncpy(bind_dp-&gt;V[i], bind_var, n);

        /* Set the indicator variable&#39;s value. */
        if ((strncmp(bind_dp-&gt;V[i], &#34;NULL&#34;, 4) == 0) ||
                (strncmp(bind_dp-&gt;V[i], &#34;null&#34;, 4) == 0))
            *bind_dp-&gt;I[i] = -1;
        else
            *bind_dp-&gt;I[i] = 0;
    
        /* Set the bind datatype to 1 for CHAR. */
        bind_dp-&gt;T[i] = 1;
    }
  return;
}



void process_select_list()
{
    int i, null_ok, precision, scale;

    if ((strncmp(dyn_statement, &#34;SELECT&#34;, 6) != 0) &amp;&amp;
        (strncmp(dyn_statement, &#34;select&#34;, 6) != 0))
    {
        select_dp-&gt;F = 0;
        return;
    }

    /* If the SQL statement is a SELECT, describe the
        select-list items.  The DESCRIBE function returns
        their names, datatypes, lengths (including precision
        and scale), and NULL/NOT NULL statuses. */

    select_dp-&gt;N = MAX_ITEMS;
    
    EXEC SQL DESCRIBE SELECT LIST FOR S INTO select_dp;

    /* If F is negative, there were more select-list
       items than originally allocated by SQLSQLDAAlloc(). */
    if (select_dp-&gt;F &lt; 0)
    {
        printf (&#34;\nToo many select-list items (%d), maximum is %d\n&#34;,
                -(select_dp-&gt;F), MAX_ITEMS);
        return;
    }

    /* Set the maximum number of array elements in the
       descriptor to the number found. */
    select_dp-&gt;N = select_dp-&gt;F;

    /* Allocate storage for each select-list item.
  
       SQLNumberPrecV6() is used to extract precision and scale
       from the length (select_dp-&gt;L[i]).

       sqlcolumnNullCheck() is used to reset the high-order bit of
       the datatype and to check whether the column
       is NOT NULL.

       CHAR    datatypes have length, but zero precision and
               scale.  The length is defined at CREATE time.

       NUMBER  datatypes have precision and scale only if
               defined at CREATE time.  If the column
               definition was just NUMBER, the precision
               and scale are zero, and you must allocate
               the required maximum length.

       DATE    datatypes return a length of 7 if the default
               format is used.  This should be increased to
               9 to store the actual date character string.
               If you use the TO_CHAR function, the maximum
               length could be 75, but will probably be less
               (you can see the effects of this in SQL*Plus).

       ROWID   datatype always returns a fixed length of 18 if
               coerced to CHAR.

       LONG and
       LONG RAW datatypes return a length of 0 (zero),
               so you need to set a maximum.  In this example,
               it is 240 characters.

       */
    
    printf (&#34;\n&#34;);
    for (i = 0; i &lt; select_dp-&gt;F; i++)
    {
        char title[MAX_VNAME_LEN]; 
        /* Turn off high-order bit of datatype (in this example,
           it does not matter if the column is NOT NULL). */
        SQLColumnNullCheck ((unsigned short *)&amp;(select_dp-&gt;T[i]), 
             (unsigned short *)&amp;(select_dp-&gt;T[i]), &amp;null_ok);

        switch (select_dp-&gt;T[i])
        {
            case  1 : /* CHAR datatype: no change in length
                         needed, except possibly for TO_CHAR
                         conversions (not handled here). */
                break;
            case  2 : /* NUMBER datatype: use SQLNumberPrecV6() to
                         extract precision and scale. */
                SQLNumberPrecV6( SQL_SINGLE_RCTX, 
                      (unsigned long *)&amp;(select_dp-&gt;L[i]), &amp;precision, &amp;scale);
                      /* Allow for maximum size of NUMBER. */
                if (precision == 0) precision = 40;
                      /* Also allow for decimal point and
                         possible sign. */
                /* convert NUMBER datatype to FLOAT if scale &gt; 0,
                   INT otherwise. */
                if (scale &gt; 0)
                    select_dp-&gt;L[i] = sizeof(float);
                else
                    select_dp-&gt;L[i] = sizeof(int);
                break;

            case  8 : /* LONG datatype */
                select_dp-&gt;L[i] = 240;
                break;

            case 11 : /* ROWID datatype */
                select_dp-&gt;L[i] = 18;
                break;

            case 12 : /* DATE datatype */
                select_dp-&gt;L[i] = 9;
                break;
 
            case 23 : /* RAW datatype */
                break;

            case 24 : /* LONG RAW datatype */
                select_dp-&gt;L[i] = 240;
                break;
        }
        /* Allocate space for the select-list data values.
           SQLSQLDAAlloc() reserves a pointer location for
           V[i] but does not allocate the full space for
           the pointer.  */

         if (select_dp-&gt;T[i] != 2)
           select_dp-&gt;V[i] = (char *) realloc(select_dp-&gt;V[i],
                                    select_dp-&gt;L[i] + 1);  
         else
           select_dp-&gt;V[i] = (char *) realloc(select_dp-&gt;V[i],
                                    select_dp-&gt;L[i]);  

        /* Print column headings, right-justifying number
            column headings. */
        
        /* Copy to temporary buffer in case name is null-terminated */
        memset(title, &#39; &#39;, MAX_VNAME_LEN);
        strncpy(title, select_dp-&gt;S[i], select_dp-&gt;C[i]);
        if (select_dp-&gt;T[i] == 2)
           if (scale &gt; 0)
             printf (&#34;%.*s &#34;, select_dp-&gt;L[i]+3, title);
           else
             printf (&#34;%.*s &#34;, select_dp-&gt;L[i], title);
        else
          printf(&#34;%-.*s &#34;, select_dp-&gt;L[i], title);

        /* Coerce ALL datatypes except for LONG RAW and NUMBER to
           character. */
        if (select_dp-&gt;T[i] != 24 &amp;&amp; select_dp-&gt;T[i] != 2)
            select_dp-&gt;T[i] = 1;

        /* Coerce the datatypes of NUMBERs to float or int depending on
           the scale. */
        if (select_dp-&gt;T[i] == 2)
          if (scale &gt; 0)
             select_dp-&gt;T[i] = 4;  /* float */
          else
             select_dp-&gt;T[i] = 3;  /* int */
    }
    printf (&#34;\n\n&#34;);

    /* FETCH each row selected and print the column values. */
    EXEC SQL WHENEVER NOT FOUND GOTO end_select_loop;

    for (;;)
    {
        EXEC SQL FETCH C USING DESCRIPTOR select_dp;

        /* Since each variable returned has been coerced to a
           character string, int, or float very little processing 
           is required here.  This routine just prints out the 
           values on the terminal. */
        for (i = 0; i &lt; select_dp-&gt;F; i++)
        {
            if (*select_dp-&gt;I[i] &lt; 0)
                if (select_dp-&gt;T[i] == 4) 
                  printf (&#34;%-*c &#34;,(int)select_dp-&gt;L[i]+3, &#39; &#39;);
                else
                  printf (&#34;%-*c &#34;,(int)select_dp-&gt;L[i], &#39; &#39;);
            else
                if (select_dp-&gt;T[i] == 3)     /* int datatype */
                  printf (&#34;%*d &#34;, (int)select_dp-&gt;L[i], 
                                 *(int *)select_dp-&gt;V[i]);
                else if (select_dp-&gt;T[i] == 4)     /* float datatype */
                  printf (&#34;%*.2f &#34;, (int)select_dp-&gt;L[i], 
                                 *(float *)select_dp-&gt;V[i]);
                else                          /* character string */
                  printf (&#34;%-*.*s &#34;, (int)select_dp-&gt;L[i],
                            (int)select_dp-&gt;L[i], select_dp-&gt;V[i]);
        }
        printf (&#34;\n&#34;);
    }
end_select_loop:
    return;
}



void help()
{
    puts(&#34;\n\nEnter a SQL statement or a PL/SQL block at the SQL&gt; prompt.&#34;);
    puts(&#34;Statements can be continued over several lines, except&#34;);
    puts(&#34;within string literals.&#34;);
    puts(&#34;Terminate a SQL statement with a semicolon.&#34;);
    puts(&#34;Terminate a PL/SQL block (which can contain embedded semicolons)&#34;);
    puts(&#34;with a slash (/).&#34;);
    puts(&#34;Typing \&#34;exit\&#34; (no semicolon needed) exits the program.&#34;);
    puts(&#34;You typed \&#34;?\&#34; or \&#34;help\&#34; to get this message.\n\n&#34;);
}


void sql_error()
{
    /* ORACLE error handler */
    printf (&#34;\n\n%.70s\n&#34;,sqlca.sqlerrm.sqlerrmc);
    if (parse_flag)
        printf
        (&#34;Parse error at character offset %d in SQL statement.\n&#34;,
           sqlca.sqlerrd[4]);

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK;
    longjmp(jmp_continue, 1);
}
</pre></div>
<!-- class="sect1" -->
<a id="i33925"></a>
<div id="LNPCC4193" class="sect1">
<h2 class="sect1">Sample Program : Dynamic SQL Method 4 using Scrollable Cursors</h2>
<p>This demo program describes the scrollable cursor feature used with oracle dynamic method 4. This program is available on-line in the file <code>scdemo1.pc</code> in your demo directory.</p>
<p class="subhead2"><a id="LNPCC4194"></a>scdemo1.pc</p>
<pre>/*
 * This demo program exhibits the scrollable cursor feature
 * used with oracle dynamic method 4. The scrollable cursor
 * feature can also be used with ANSI dynamic method 4.
 * 
 * This program takes as argument the username/passwd. Once
 * logged in, it prompts for a select query. It then prompts
 * for the orientation and prints the results of the query.
 *
 * Before executing this example, make sure that the HR
 * schema exists.
 */

#include &lt;oci.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;sqlca.h&gt; 
#include &lt;sqlda.h&gt; 
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#include &lt;sqlcpr.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;setjmp.h&gt;


#define MAX_SELECT_ITEMS    200
#define MAX_CHARS           20

/* Maximum size of a select-list item name */
#define MAX_NAME_SIZE       50  
 
SQLDA   *selda; 
SQLDA   *bind_des; 
jmp_buf beginEnv;
jmp_buf loopEnv;

/* Data buffer */
char c_data[MAX_SELECT_ITEMS][MAX_CHARS];
 
char username[60];
char stmt[500];
char stmt2[500];

/* Print the generic error message &amp; exit */

void sql_error()
{
    char msgbuf[512];
    size_t msgbuf_len, msg_len;

    msgbuf_len = sizeof(msgbuf);
    sqlglm(msgbuf, &amp;msgbuf_len, &amp;msg_len);

    printf (&#34;\n\n%.*s\n&#34;, msg_len, msgbuf);

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK RELEASE;
    exit(EXIT_FAILURE);
}

/* Print the error message and continue to query
   the user */
void sql_loop_error()
{
    char msgbuf[512];
    size_t msgbuf_len, msg_len;
    int code = sqlca.sqlcode;

    msgbuf_len = sizeof(msgbuf);
    sqlglm(msgbuf, &amp;msgbuf_len, &amp;msg_len);

    printf (&#34;\n%.*s\n&#34;, msg_len, msgbuf);
    printf(&#34;The error code is %d\n&#34;, sqlca.sqlcode);
    if(code!=0)
      longjmp(beginEnv, 1);

    longjmp(loopEnv, 1);
}

/* FETCH has returned the &#34;no data found&#34;  error code.
   This means that either we have reached the end of 
   the active set or the offset refers to a row beyond the
   active set */
void no_data_found()
{
  printf(&#34;\nNo Data available at the specified offset\n&#34;);
  longjmp(loopEnv, 1);
}

void main(int argc, char *argv[]) 
{
    int i, n;
    int sli;     /* select-list item */
    int offset;
    int contFlag;
    char bindVar[20];
    char *u, temp[3];
    char choice;

    /* Error Handler  */
    EXEC SQL WHENEVER SQLERROR DO sql_error();


    if (argc == 1)
    {
      printf(&#34;Logging in as default user hr\n&#34;);
      strcpy(username, &#34;hr/hr&#34;);
    }
    else
      strcpy(username, argv[1]);

    /* Establish a connection to the data base */
    EXEC SQL CONNECT :username;

    u = username;
    while(*++u != &#39;/&#39;);
    *u = &#39;\0&#39;;

    /* Error Handler */
    EXEC SQL WHENEVER SQLERROR DO sql_loop_error();
    for (;;)
    {

      setjmp(beginEnv);
      printf(&#34;[%s] SQL &gt; &#34;, username);
      gets(stmt);
      if (!strlen(stmt))
        continue;
      for (i=0 ; i &lt; strlen(stmt) ; i++)
           stmt2[i] = tolower(stmt[i]) ;
      stmt2[i]=0 ;
      if(!strcmp(stmt2, &#34;exit&#34;))
        break;

      selda = SQLSQLDAAlloc(SQL_SINGLE_RCTX, MAX_SELECT_ITEMS, MAX_NAME_SIZE, 0);
      bind_des = SQLSQLDAAlloc(SQL_SINGLE_RCTX, MAX_SELECT_ITEMS, 
                               MAX_NAME_SIZE, 30);

      /* prepare a sql statement for the query*/
      EXEC SQL PREPARE S FROM :stmt;

      /* Declare a cursor as scrollable */
      EXEC SQL DECLARE C SCROLL CURSOR FOR S;

      for (i=0; i&lt;MAX_SELECT_ITEMS; i++)
      {
        bind_des-&gt;I[i] = (short *) malloc(sizeof (short));
        bind_des-&gt;V[i] = (char *) malloc(1);
      }
      bind_des-&gt;N = MAX_SELECT_ITEMS;

      EXEC SQL DESCRIBE BIND VARIABLES FOR S INTO bind_des;

      /* set up the bind variables */
      if (bind_des-&gt;F &lt; 0)
      {
        printf(&#34;Bind descriptor, value exceeds the limit\n&#34;);
        exit(-1);
      }

      bind_des-&gt;N = bind_des-&gt;F;
      for (i=0; i&lt;bind_des-&gt;F; i++)
      {
        printf(&#34;Enter the value for bind variable %.*s: &#34;,
               (int)bind_des-&gt;C[i], bind_des-&gt;S[i]);

        fgets(bindVar, sizeof(bindVar), stdin);
        n = strlen(bindVar) - 1;

        bind_des-&gt;L[i] = n;
        bind_des-&gt;V[i] = (char *) realloc(bind_des-&gt;V[i], 
                         (bind_des-&gt;L[i] +1));

        strncpy(bind_des-&gt;V[i], bindVar, n);
        if ((strncmp(bind_des-&gt;V[i], &#34;NULL&#34;, 4) == 0) ||
              (strncmp(bind_des-&gt;V[i], &#34;null&#34;, 4) == 0))
          *bind_des -&gt;I[i] = -1;
        else
          *bind_des -&gt;I[i] = 0;

        bind_des-&gt;T[i] = 1;
      }

      /* open the cursor */
      EXEC SQL OPEN C USING DESCRIPTOR bind_des;
      EXEC SQL DESCRIBE SELECT LIST FOR S INTO selda;

      if (selda-&gt;F &lt; 0)
      {
        printf(&#34;Select descriptor, value exceeds the limit\n&#34;);
        exit(-1);
      }
        
      selda-&gt;N = selda-&gt;F;
      for (sli = 0; sli &lt; selda-&gt;N; sli++)
      {
          /* Set addresses of heads of the arrays 
             in the V element. */
          selda-&gt;V[sli] = c_data[sli];
          /* Convert everything to varchar on output. */
          selda-&gt;T[sli] = 1;
          /* Set the maximum lengths. */
          selda-&gt;L[sli] = MAX_CHARS;
      }

      contFlag = &#39;Y&#39;;
      setjmp(loopEnv);

      while(1)
      {
        while(contFlag != &#39;Y&#39; &amp;&amp; contFlag != &#39;N&#39;)
        {
        printf(&#34;\nContinue with the current fetch? [y/n] :&#34;);
        contFlag = toupper(getchar());
        /* To flush the input buffer */
        getchar();
        }
 
        if(contFlag != &#39;Y&#39;)
          break;
 
        contFlag = &#39;x&#39;;

        printf(&#34;\n\nEnter the row number to be fetched \n&#34;);
        printf(&#34;1.ABSOLUTE\n&#34;);
        printf(&#34;2.RELATIVE\n&#34;);
        printf(&#34;3.FIRST \n&#34;);
        printf(&#34;4.NEXT \n&#34;);
        printf(&#34;5.PREVIOUS \n&#34;);
        printf(&#34;6.LAST \n&#34;);
        printf(&#34;7.CURRENT \n&#34;);
        printf(&#34;Enter your choice --&gt; &#34;);
        scanf(&#34;%c&#34;,&amp;choice);

        /* To flush the input buffer */        getchar();        EXEC SQL WHENEVER NOT FOUND DO no_data_found();
        switch(choice)
        {
         case &#39;1&#39;: printf(&#34;\nEnter Offset :&#34;);
                   scanf(&#34;%d&#34;,&amp;offset);
                   getchar();
                   EXEC SQL FETCH ABSOLUTE :offset C USING DESCRIPTOR selda;
                   break;
         case &#39;2&#39;: printf(&#34;\nEnter Offset :&#34;);
                   scanf(&#34;%d&#34;,&amp;offset);
                   getchar();
                   EXEC SQL FETCH RELATIVE :offset C USING DESCRIPTOR selda;
                   break;
         case &#39;3&#39;: EXEC SQL FETCH FIRST C USING DESCRIPTOR selda;
                   break;
         case &#39;4&#39;: EXEC SQL FETCH NEXT C USING DESCRIPTOR selda;
                   break;
         case &#39;5&#39;: EXEC SQL FETCH PRIOR C USING DESCRIPTOR selda;
                   break;
         case &#39;6&#39;: EXEC SQL FETCH LAST C USING DESCRIPTOR selda;
                   break;
         case &#39;7&#39;: EXEC SQL FETCH CURRENT C USING DESCRIPTOR selda;
                   break;
         default : printf(&#34;Invalid choice\n&#34;);
                   contFlag = &#39;Y&#39;;
                   continue;
        }
 
        /* print the row */
        for(sli=0; sli&lt;selda-&gt;N; sli++)
          printf(&#34;%.20s &#34;, c_data[sli]);
 
        puts(&#34;&#34;);
 
      }
 
        EXEC SQL CLOSE C;
    }
 
    EXEC SQL ROLLBACK RELEASE;
    exit(EXIT_SUCCESS);
}
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_14ady.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_16lob.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>