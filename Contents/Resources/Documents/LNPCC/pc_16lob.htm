<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78016"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/LOBs"></a><title>LOBs</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:51Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_15ody.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_17obj.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">22/35</span> <!-- End Header -->
<script>
<!-- // <![CDATA[
window.name='pc_16lob'
// ]]> -->
</script> <script>
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="LNPCC016" class="chapter"><a id="g1029071"></a> <a id="i998068"></a>
<h1 class="chapter"><span class="secnum">16</span> LOBs</h1>
<p>This chapter describes the support provided by embedded SQL statements for the LOB (Large Object) datatypes.</p>
<p>The four types of LOBs are introduced and compared to the older LONG and LONG RAW datatypes.</p>
<p>The embedded SQL interface in Pro*C/C++ is shown to provide similar functionality to that of the Oracle Call Interface API and the PL/SQL language.</p>
<p>The LOB statements and their options and host variables are presented.</p>
<p>Lastly, examples of Pro*C/C++ programs using the LOB interface are presented as simple illustrations of usage.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i1003528">What are LOBs?</a></p>
</li>
<li>
<p><a href="#i1000154">How to Use LOBs in Your Program</a></p>
</li>
<li>
<p><a href="#i1000162">Rules for LOB Statements</a></p>
</li>
<li>
<p><a href="#i1000172">LOB Statements</a></p>
</li>
<li>
<p><a href="#i1006679">LOBs and the Navigational Interface</a></p>
</li>
<li>
<p><a href="#i1003520">LOB Program Examples</a></p>
</li>
</ul>
<a id="i1003528"></a>
<div id="LNPCC4195" class="sect1">
<h2 class="sect1">What are LOBs?</h2>
<p>Use LOB (large object) columns to store large amounts of data (maximum size is 4 Gigabytes) such as ASCII text, National Character text, files in various graphics formats, and sound wave forms.</p>
<div id="LNPCC4196" class="sect2"><a id="sthref1974"></a>
<h3 class="sect2"><a id="sthref1975"></a>Internal LOBs</h3>
<p>Internal LOBs (BLOBs, CLOBs, NCLOBs) are stored in database table spaces and have transactional support (Commit, Rollback, and so on. work with them) of the database server.</p>
<p>BLOBs (Binary LOBs) store unstructured binary (also called &#34;raw&#34;) data, such as video clips.</p>
<p>CLOBs (Character LOBs) store large blocks of character data from the database character set.</p>
<p>NCLOBs (National Character LOBs) store large blocks of character data from the National Character Set.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4197" class="sect2"><a id="sthref1976"></a>
<h3 class="sect2"><a id="sthref1977"></a>External LOBs</h3>
<p>External LOBs are operating system files outside the database tablespaces, that have no transactional support from the database server.</p>
<p><code><a id="sthref1978"></a><a id="sthref1979"></a>BFILEs</code> (Binary Files) store data in external binary files. A BFILE can be in GIF, JPEG, MPEG, MPEG2, text, or other formats.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4198" class="sect2"><a id="sthref1980"></a>
<h3 class="sect2"><a id="sthref1981"></a>Security for BFILEs</h3>
<p>The DIRECTORY object is used to access and use BFILEs. The DIRECTORY is a logical alias name (stored in the server) for the actual physical directory in the server file system containing the file. Users are permitted to access the file only if granted access privilege on the DIRECTORY object.</p>
<ul>
<li>
<p>The DDL (data definition language) SQL statements CREATE, REPLACE, ALTER, and DROP are used with DIRECTORY database objects.</p>
</li>
<li>
<p>The DML (Data Management Language) SQL statements are used to GRANT and REVOKE the READ system and object privileges on DIRECTORY objects.</p>
</li>
</ul>
<p>A example CREATE DIRECTORY directive is:</p>
<pre>EXEC SQL CREATE OR REPLACE DIRECTORY &#34;Mydir&#34; AS &#39;/usr/home/mydir&#39; ;
</pre>
<p>Other users or roles can read the directory only if you grant them permission with a DML (Data Manipulation Language) statement, such as GRANT. For example, to allow user <code>scott</code> to read BFILES in directory <code>/usr/home/mydir</code>:</p>
<pre>EXEC SQL GRANT READ ON DIRECTORY &#34;Mydir&#34; TO scott ;
</pre>
<p>Up to 10 BFILES can be opened simultaneously in one session. This default value can be changed by setting the SESSION_MAX_OPEN_FILES parameter.</p>
<p>See <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a> for more details on DIRECTORY objects and BFILE security. See <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more details on the GRANT command.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4199" class="sect2"><a id="sthref1982"></a>
<h3 class="sect2">LOBs versus LONG and LONG RAW</h3>
<p>LOBs are different from the older LONG and LONG RAW datatypes in many ways.</p>
<ul>
<li>
<p>The maximum size of a LOB is 4 Gigabytes versus 2 Gigabytes for LONG and LONG RAW.</p>
</li>
<li>
<p>You can use random as well as sequential access methods on LOBs; you can only use sequential access methods on LONG and LONG RAW.</p>
</li>
<li>
<p>LOBs (except NCLOBs) can be attributes of an object type that you define.</p>
</li>
<li>
<p>Tables can have multiple LOB columns, but can have only one LONG or LONG RAW column.</p>
</li>
</ul>
<p>Migration of existing LONG and LONG Raw attributes to LOBs is recommended by Oracle. Oracle plans to end support of LONG and LONG RAW in future releases. See <a class="olink DRDAA" href="../DRDAA/toc.htm"><span class="italic">Oracle&reg; Database Migration Guide</span></a> for more information on migration.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4200" class="sect2"><a id="sthref1983"></a>
<h3 class="sect2"><a id="sthref1984"></a>LOB Locators</h3>
<p>A LOB locator points to the actual LOB contents. The locator is returned when you retrieve the LOB, not the LOB&#39;s contents. LOB locators cannot be saved in one transaction or session and used again in a later transaction or session.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4201" class="sect2"><a id="sthref1985"></a>
<h3 class="sect2"><a id="sthref1986"></a>Temporary LOBs</h3>
<p>You can create <span class="italic">temporary</span> LOBs, that are like local variables, to assist your use of database LOBs. Temporary LOBs are not associated with any table, are only accessible by their creator, have locators (which is how they are accessed), and are deleted when a session ends.</p>
<p>There is no support for temporary BFILES. Temporary LOBs are only permitted to be input variables (IN values) in the WHERE clauses of INSERT, UPDATE, or DELETE statements. They are also permitted as values inserted by an INSERT statement, or a value in the SET clause of an UPDATE statement. Temporary LOBs have no transactional support from the database server, which means that you cannot do COMMITS or ROLLBACKs on them.</p>
<p>Temporary LOB locators can span transactions. They also are deleted when the server abnormally terminates, and when an error is returned from a database SQL operation.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4202" class="sect2"><a id="sthref1987"></a>
<h3 class="sect2">LOB Buffering Subsystem</h3>
<p>The LBS (LOB Buffering Subsystem) is an area of user memory provided for use as a buffer for one or more LOBs in the client&#39;s address space.</p>
<p>Buffering has these advantages, especially for applications on a client that does many small reads and writes to specific regions of the LOB:</p>
<ul>
<li>
<p>The LBS reduces round trips to the server because you fill the buffer with multiple reads/writes to the LOBs, then write to the server when a FLUSH directive is executed.</p>
</li>
<li>
<p>Buffering also reduces the total number of LOB updates on the server. This creates better LOB performance and saves disk space.</p>
</li>
</ul>
<p>Oracle provides a simple buffer subsystem; not a cache. Oracle does not guarantee that the contents of a buffer are always synchronized with the server LOB value. Use the FLUSH statement to actually write updates in the server LOB.</p>
<p>Buffered read/write of a LOB are performed through its locator. A locator enabled for buffering provides a consistent read version of the LOB until you perform a write through that locator.</p>
<p>After being used for a buffered WRITE, a locator becomes an updated locator and provides access to the latest LOB version <span class="italic">as seen through the buffering subsystem</span>. All further buffered WRITEs to the LOB can only be done through this updated locator. Transactions involving buffered LOB operations cannot migrate across user sessions.</p>
<p>The LBS is managed by the user, who is responsible for updating server LOB values by using FLUSH statements to update them. It is single-user and single threaded. Use ROLLBACK and SAVEPOINT actions to guarantee correctness in the server LOBs. Transactional support for buffered LOB operations is not guaranteed by Oracle. To ensure transactional semantics for buffered LOB updates, you must maintain logical savepoints to perform a rollback in the event of an error.</p>
<p>For more information on the LBS, see <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1000154"></a>
<div id="LNPCC4203" class="sect1">
<h2 class="sect1">How to Use LOBs in Your Program</h2>
<p>This section describes some of the important programming issues related to the use of LOBs in your Pro*C/C++ application.</p>
<div id="LNPCC4204" class="sect2"><a id="sthref1988"></a>
<h3 class="sect2"><a id="sthref1989"></a>Three Ways to Access LOBs</h3>
<p>The three methods available to access LOBs in Pro*C/C++ are:</p>
<ul>
<li>
<p>The DBMS_LOB package inside PL/SQL blocks.</p>
</li>
<li>
<p>OCI (Oracle Call Interface) function calls.</p>
</li>
<li>
<p>Embedded SQL statements.</p>
</li>
</ul>
<p>The SQL statements are designed to give users a functional equivalent to the PL/SQL interface while avoiding the complexity of the OCI interface.</p>
<p>The following table compares LOB access by OCI function calls in Pro*C/C++, PL/SQL, and embedded SQL statements in Pro*C/C++. Empty boxes indicate missing functionality.</p>
<div id="LNPCC4205" class="tblformal">
<p class="titleintable"><a id="sthref1990"></a><a id="i1003209"></a>Table 16-1 LOB Access Methods</p>
<table class="cellalignment831" title="LOB Access Methods" summary="LOB Access Methods">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t2">OCI <a id="sthref1991" href="#sthref1991" onclick="footdisplay(1,&#34;\u003cspan class=\&#34;bold\&#34;\u003eFor C/C++ users only. Prototypes for these functions are in ociap.h.\u003c/span\u003e&#34;)"><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></th>
<th class="cellalignment832" id="r1c2-t2">PL/SQL<a id="sthref1992" href="#sthref1992" onclick="footdisplay(2,&#34;\u003cspan class=\&#34;bold\&#34;\u003eFrom dbmslob.sql. All routines are prefixed with \x27DBMS_LOB.\x27 except BFILENAME.\u003c/span\u003e&#34;)"><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a></th>
<th class="cellalignment832" id="r1c3-t2"><span class="bold">Pro*C/C++ Embedded SQL</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t2" headers="r1c1-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r2c1-t2 r1c2-t2">
<p>COMPARE()</p>
</td>
<td class="cellalignment833" headers="r2c1-t2 r1c3-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t2" headers="r1c1-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r3c1-t2 r1c2-t2">
<p>INSTR()</p>
</td>
<td class="cellalignment833" headers="r3c1-t2 r1c3-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t2" headers="r1c1-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r4c1-t2 r1c2-t2">
<p>SUBSTR()</p>
</td>
<td class="cellalignment833" headers="r4c1-t2 r1c3-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t2" headers="r1c1-t2">
<p>OCILobAppend</p>
</td>
<td class="cellalignment833" headers="r5c1-t2 r1c2-t2">
<p>APPEND()</p>
</td>
<td class="cellalignment833" headers="r5c1-t2 r1c3-t2">
<p>APPEND</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t2" headers="r1c1-t2">
<p>OCILobAssign</p>
</td>
<td class="cellalignment833" headers="r6c1-t2 r1c2-t2">
<p>:=</p>
</td>
<td class="cellalignment833" headers="r6c1-t2 r1c3-t2">
<p>ASSIGN</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t2" headers="r1c1-t2">
<p>OCILobCharSetForm</p>
</td>
<td class="cellalignment833" headers="r7c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r7c1-t2 r1c3-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t2" headers="r1c1-t2">
<p>OCICharSetId</p>
</td>
<td class="cellalignment833" headers="r8c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r8c1-t2 r1c3-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t2" headers="r1c1-t2">
<p>OCILobClose</p>
</td>
<td class="cellalignment833" headers="r9c1-t2 r1c2-t2">
<p>CLOSE()</p>
</td>
<td class="cellalignment833" headers="r9c1-t2 r1c3-t2">
<p>CLOSE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t2" headers="r1c1-t2">
<p>OCILobCopy</p>
</td>
<td class="cellalignment833" headers="r10c1-t2 r1c2-t2">
<p>COPY()</p>
</td>
<td class="cellalignment833" headers="r10c1-t2 r1c3-t2">
<p>COPY</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t2" headers="r1c1-t2">
<p>OCILobCreateTemporary</p>
</td>
<td class="cellalignment833" headers="r11c1-t2 r1c2-t2">
<p>CREATETEMPORARY()</p>
</td>
<td class="cellalignment833" headers="r11c1-t2 r1c3-t2">
<p>CREATE TEMPORARY</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t2" headers="r1c1-t2">
<p>OCILobDisableBuffering</p>
</td>
<td class="cellalignment833" headers="r12c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r12c1-t2 r1c3-t2">
<p>DISABLE BUFFERING</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r13c1-t2" headers="r1c1-t2">
<p>OCILobEnableBuffering</p>
</td>
<td class="cellalignment833" headers="r13c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r13c1-t2 r1c3-t2">
<p>ENABLE BUFFERING</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r14c1-t2" headers="r1c1-t2">
<p>OCILobErase</p>
</td>
<td class="cellalignment833" headers="r14c1-t2 r1c2-t2">
<p>ERASE()</p>
</td>
<td class="cellalignment833" headers="r14c1-t2 r1c3-t2">
<p>ERASE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r15c1-t2" headers="r1c1-t2">
<p>OCILobGetChunkSize</p>
</td>
<td class="cellalignment833" headers="r15c1-t2 r1c2-t2">
<p>GETCHUNKSIZE()</p>
</td>
<td class="cellalignment833" headers="r15c1-t2 r1c3-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r16c1-t2" headers="r1c1-t2">
<p>OCILobIsOpen</p>
</td>
<td class="cellalignment833" headers="r16c1-t2 r1c2-t2">
<p>ISOPEN()</p>
</td>
<td class="cellalignment833" headers="r16c1-t2 r1c3-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r17c1-t2" headers="r1c1-t2">
<p>OCILobFileClose</p>
</td>
<td class="cellalignment833" headers="r17c1-t2 r1c2-t2">
<p>FILECLOSE()</p>
</td>
<td class="cellalignment833" headers="r17c1-t2 r1c3-t2">
<p>CLOSE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r18c1-t2" headers="r1c1-t2">
<p>OCILobFileCloseAll</p>
</td>
<td class="cellalignment833" headers="r18c1-t2 r1c2-t2">
<p>FILECLOSEALL()</p>
</td>
<td class="cellalignment833" headers="r18c1-t2 r1c3-t2">
<p>FILE CLOSE ALL</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r19c1-t2" headers="r1c1-t2">
<p>OCILobFileExists</p>
</td>
<td class="cellalignment833" headers="r19c1-t2 r1c2-t2">
<p>FILEEXISTS()</p>
</td>
<td class="cellalignment833" headers="r19c1-t2 r1c3-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r20c1-t2" headers="r1c1-t2">
<p>OCILobFileGetName</p>
</td>
<td class="cellalignment833" headers="r20c1-t2 r1c2-t2">
<p>FILEGETNAME()</p>
</td>
<td class="cellalignment833" headers="r20c1-t2 r1c3-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r21c1-t2" headers="r1c1-t2">
<p>OCILobFileIsOpen</p>
</td>
<td class="cellalignment833" headers="r21c1-t2 r1c2-t2">
<p>FILEISOPEN()</p>
</td>
<td class="cellalignment833" headers="r21c1-t2 r1c3-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r22c1-t2" headers="r1c1-t2">
<p>OCILobFileOpen</p>
</td>
<td class="cellalignment833" headers="r22c1-t2 r1c2-t2">
<p>FILEOPEN()</p>
</td>
<td class="cellalignment833" headers="r22c1-t2 r1c3-t2">
<p>OPEN</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r23c1-t2" headers="r1c1-t2">
<p>OCILobFileSetName</p>
</td>
<td class="cellalignment833" headers="r23c1-t2 r1c2-t2">
<p>BFILENAME()</p>
</td>
<td class="cellalignment833" headers="r23c1-t2 r1c3-t2">
<p>FILE SET<a id="sthref1993" href="#sthref1993" onclick="footdisplay(3,&#34;T\u003cspan class=\&#34;bold\&#34;\u003ehe BFILENAME() built in SQL function may also be used.\u003c/span\u003e&#34;)"><sup class="tablefootnote">Foot&nbsp;3&nbsp;</sup></a></p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r24c1-t2" headers="r1c1-t2">
<p>OCILobFlushBuffer</p>
</td>
<td class="cellalignment833" headers="r24c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r24c1-t2 r1c3-t2">
<p>FLUSH BUFFER</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r25c1-t2" headers="r1c1-t2">
<p>OCILobFreeTemporary</p>
</td>
<td class="cellalignment833" headers="r25c1-t2 r1c2-t2">
<p>FREETEMPORARY()</p>
</td>
<td class="cellalignment833" headers="r25c1-t2 r1c3-t2">
<p>FREE TEMPORARY</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r26c1-t2" headers="r1c1-t2">
<p>OCILobGetLength</p>
</td>
<td class="cellalignment833" headers="r26c1-t2 r1c2-t2">
<p>GETLENGTH()</p>
</td>
<td class="cellalignment833" headers="r26c1-t2 r1c3-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r27c1-t2" headers="r1c1-t2">
<p>OCILobIsEqual</p>
</td>
<td class="cellalignment833" headers="r27c1-t2 r1c2-t2">
<p>=</p>
</td>
<td class="cellalignment833" headers="r27c1-t2 r1c3-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r28c1-t2" headers="r1c1-t2">
<p>OCILobIsTemporary</p>
</td>
<td class="cellalignment833" headers="r28c1-t2 r1c2-t2">
<p>ISTEMPORARY()</p>
</td>
<td class="cellalignment833" headers="r28c1-t2 r1c3-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r29c1-t2" headers="r1c1-t2">
<p>OCILobLoadFromFile</p>
</td>
<td class="cellalignment833" headers="r29c1-t2 r1c2-t2">
<p>LOADFROMFILE()</p>
</td>
<td class="cellalignment833" headers="r29c1-t2 r1c3-t2">
<p>LOAD FROM FILE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r30c1-t2" headers="r1c1-t2">
<p>OCILobLocatorIsInit</p>
</td>
<td class="cellalignment833" headers="r30c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment833" headers="r30c1-t2 r1c3-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r31c1-t2" headers="r1c1-t2">
<p>OCILobOpen</p>
</td>
<td class="cellalignment833" headers="r31c1-t2 r1c2-t2">
<p>OPEN()</p>
</td>
<td class="cellalignment833" headers="r31c1-t2 r1c3-t2">
<p>OPEN</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r32c1-t2" headers="r1c1-t2">
<p>OCILobRead</p>
</td>
<td class="cellalignment833" headers="r32c1-t2 r1c2-t2">
<p>READ()</p>
</td>
<td class="cellalignment833" headers="r32c1-t2 r1c3-t2">
<p>READ</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r33c1-t2" headers="r1c1-t2">
<p>OCILobTrim</p>
</td>
<td class="cellalignment833" headers="r33c1-t2 r1c2-t2">
<p>TRIM()</p>
</td>
<td class="cellalignment833" headers="r33c1-t2 r1c3-t2">
<p>TRIM</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r34c1-t2" headers="r1c1-t2">
<p>OCILobWrite</p>
</td>
<td class="cellalignment833" headers="r34c1-t2 r1c2-t2">
<p>WRITE()</p>
</td>
<td class="cellalignment833" headers="r34c1-t2 r1c3-t2">
<p>WRITE</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r35c1-t2" headers="r1c1-t2">
<p>OCILobWriteAppend</p>
</td>
<td class="cellalignment833" headers="r35c1-t2 r1c2-t2">
<p>WRITEAPPEND()</p>
</td>
<td class="cellalignment833" headers="r35c1-t2 r1c3-t2">
<p>WRITE</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup><span class="bold">For C/C++ users only. Prototypes for these functions are in ociap.h.</span></p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2&nbsp;</sup><span class="bold">From dbmslob.sql. All routines are prefixed with &#39;DBMS_LOB.&#39; except BFILENAME.</span></p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;3&nbsp;</sup>T<span class="bold">he BFILENAME() built in SQL function may also be used.</span></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must explicitly lock the row before using any of the new statements that modify or change a LOB in any way. Operations that can modify a LOB value are APPEND, COPY, ERASE, LOAD FROM FILE, TRIM, and WRITE.</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC4206" class="sect2"><a id="sthref1994"></a>
<h3 class="sect2"><a id="sthref1995"></a>LOB Locators in Your Application</h3>
<p>To use a LOB locator in your Pro*C/C++ application, include the oci.h header file and declare a pointer to the type OCIBlobLocator for BLOBs, OCIClobLocator for CLOBs and NCLOBs, or OCIBFileLocator for BFILEs.</p>
<p>For an NCLOB, you must either</p>
<ul>
<li>
<p>Use the clause &#39;CHARACTER SET IS NCHAR_CS&#39; in the C/C++ declaration,</p>
</li>
<li>
<p>Or, you must have already used an NLS_CHAR precompiler option on the command line or in a configuration file to set the NLS_NCHAR environment variable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#i8234">&#34;NLS_CHAR&#34;</a></div>
</li>
</ul>
<p>Here is how it is done:</p>
<pre>/* In your precompiler program */
#include &lt;oci.h&gt;
...
OCIClobLocator CHARACTER SET IS NCHAR_CS *a_nclob ;
</pre>
<p>Or, if you have already set the precompiler option NLS_CHAR this way when invoking Pro*C/C++:</p>
<pre>NLS_CHAR=(a_nclob)
</pre>
<p>you can omit the CHARACTER SET clause in your code:</p>
<pre>#include &lt;oci.h&gt;
...
OCIClobLocator *a_nclob ;
</pre>
<p>The other declarations are simple:</p>
<pre>/* In your precompiler program */
#include &lt;oci.h&gt;
...
OCIBlobLocator  *a_blob ;
OCIClobLocator  *a_clob ;
OCIBFileLocator *a_bfile ;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC4207" class="sect2"><a id="sthref1996"></a>
<h3 class="sect2"><a id="sthref1997"></a>Initializing a LOB</h3>
<p>There are different techniques which are used to intialize the different types of LOBs. Each is described in this section.</p>
<div id="LNPCC4208" class="sect3"><a id="sthref1998"></a>
<h4 class="sect3">Internal LOBs</h4>
<p>To initialize a BLOB to empty, use the <code>EMPTY_BLOB()</code> function or, use the ALLOCATE SQL statement. For CLOBs and NCLOBs, use the <code>EMPTY_CLOB()</code> function<span class="italic">.</span> See <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more about <code>EMPTY_BLOB()</code> and <code>EMPTY_CLOB()</code>.</p>
<p>These functions are permitted only in the VALUES clause of an INSERT statement or as the source of the SET clause in an UPDATE statement.</p>
<p>For example:</p>
<pre>EXEC SQL INSERT INTO lob_table (a_blob, a_clob)
   VALUES (EMPTY_BLOB(), EMPTY_CLOB()) ;
</pre>
<p>The ALLOCATE statement allocates a LOB locator and initializes it to empty. So, the following code is equivalent to the previous example:</p>
<pre>#include &lt;oci.h&gt;
...
OCIBlobLocator *blob ;
OCIClobLocator *clob ;
EXEC SQL ALLOCATE :blob ;
EXEC SQL ALLOCATE :clob ;
EXEC SQL INSERT INTO lob_table (a_blob, a_clob)
   VALUES (:blob, :clob) ;
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC4209" class="sect3"><a id="sthref1999"></a>
<h4 class="sect3">External LOBs</h4>
<p>Use the LOB FILE SET statement to initialize the DIRECTORY alias of the BFILE and FILENAME this way:</p>
<pre>#include &lt;oci.h&gt;
...
char *alias = &#34;lob_dir&#34; ;
char *filename = &#34;image.gif&#34; ;
OCIBFileLocator *bfile ;
EXEC SQL ALLOCATE :bfile ;
EXEC SQL LOB FILE SET :bfile
   DIRECTORY = :alias, FILENAME = :filename ;
EXEC SQL INSERT INTO file_table (a_bfile) VALUES (:bfile) ;
</pre>
<p>Refer to <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a> for a complete description of DIRECTORY object naming conventions and DIRECTORY object privileges.</p>
<p>Alternatively, you can use the BFILENAME(&#39;directory&#39;, &#39;filename&#39;) function in an INSERT or UPDATE statement to initialize a BFILE column or attribute for a particular row, and give the name of the actual physical directory and filename:</p>
<pre>EXEC SQL INSERT INTO file_table (a_bfile)
   VALUES (BFILENAME(&#39;lob_dir&#39;, &#39;image.gif&#39;))
      RETURNING a_bfile INTO :bfile ;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
BFILENAME() does not check permissions on the directory or filename, or whether the physical directory actually exists. Subsequent file accesses that use the BFILE locator will do those checks and return an error if the file is inaccessible.</div>
</div>
<!-- class="sect3" -->
<div id="LNPCC4210" class="sect3"><a id="sthref2000"></a>
<h4 class="sect3">Temporary LOBs</h4>
<p>A temporary LOB is initialized to empty when it is first created using the embedded SQL LOB CREATE TEMPORARY statement. The EMPTY_BLOB() and EMPTY_CLOB() functions cannot be used with temporary LOBs.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC4211" class="sect3"><a id="sthref2001"></a>
<h4 class="sect3">Freeing LOBs</h4>
<p>The FREE statement is used to free the memory reserved by an ALLOCATE statement:</p>
<pre>EXEC SQL FREE :a_blob;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1000162"></a>
<div id="LNPCC4212" class="sect1">
<h2 class="sect1">Rules for LOB Statements</h2>
<p>Here are the rules for using LOB statements:</p>
<div id="LNPCC4213" class="sect2"><a id="sthref2002"></a>
<h3 class="sect2">For All LOB Statements</h3>
<p>These general restrictions and limitations apply when manipulating LOBs with the SQL LOB statements:</p>
<ul>
<li>
<p>The FOR clause is not allowed in EXEC SQL LOB statements since only one LOB locator can be used in those statements.</p>
</li>
<li>
<p>Distributed LOBs are not supported. Although you may use the AT database clause in any of the new embedded SQL LOB statements, you cannot mix LOB locators that were created or ALLOCATEd using different database connections in the same SQL LOB statement.</p>
</li>
<li>
<p>For the LOB READ and WRITE operations, OCI provides a callback mechanism whereby the client can specify a callback function that will be executed each time a piece of the LOB value is either read or written. The embedded SQL LOB approach does not support this capability.</p>
</li>
<li>
<p>OCI provides a mechanism that allows users to create and specify their own durations that can be used when creating temporary LOBs. There is also a mechanism for specifying that the buffer cache be used for READ and WRITE operations on temporary LOBs. This interface does not support these capabilities.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCC4214" class="sect2"><a id="sthref2003"></a>
<h3 class="sect2"><a id="sthref2004"></a>For the LOB Buffering Subsystem</h3>
<p>For the LBS, these rules must be followed:</p>
<ul>
<li>
<p>Errors in read or write accesses are reported at the next access to the server. Therefore, error recovery has to be coded by you, the user.</p>
</li>
<li>
<p>When updating a LOB with buffered writes, do not update the same LOB with a method that bypasses the LOB Buffering Subsystem.</p>
</li>
<li>
<p>An updated LOB locator enabled for buffering can be passed as an IN parameter to a PL/SQL procedure, but not as an IN OUT or OUT parameter. An error is returned, An error also is returned when there is an attempt to return an updated locator.</p>
</li>
<li>
<p>An ASSIGN of an <span class="italic">updated</span> locator enabled for buffering to another locator is not allowed.</p>
</li>
<li>
<p>You can append to the LOB value with buffered writes, but the starting offset must be one character after the end of the LOB. The LBS does not allow APPEND statements resulting in zero-byte fillers or spaces in LOBs in the database server.</p>
</li>
<li>
<p>The character sets of the host locator bind variable and the database server CLOB must be the same.</p>
</li>
<li>
<p>Only ASSIGN, READ and WRITE statements work with a locator enabled for buffering.</p>
</li>
<li>
<p>The following statements result in errors when used with a locator enabled for buffering: APPEND, COPY, ERASE, DESCRIBE (LENGTH only), and TRIM. Errors are also returned when you use these statements with a locator that is not enabled for buffering, if the LOB pointed to by the locator is being accessed in buffered mode by another locator.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The FLUSH statement must be used on a LOB enabled by the LOB Buffering Subsystem before.</div>
</li>
<li>
<p>Committing the transaction.</p>
</li>
<li>
<p>Migrating from the current transaction to another.</p>
</li>
<li>
<p>Disabling buffer operations on a LOB.</p>
</li>
<li>
<p>Returning from an external procedure execution back to the PL/SQL routine.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If an external callout is called from a PL/SQL block with a locator parameter, then all buffering, including the ENABLE statement should be done inside the external procedure.</div>
</li>
</ul>
<p>Follow this recipe:</p>
<ul>
<li>
<p>Call the external callout.</p>
</li>
<li>
<p>ENABLE the locator for buffering.</p>
</li>
<li>
<p>READ or WRITE using the locator.</p>
</li>
<li>
<p>FLUSH the LOB (LOBs are never implicitly flushed).</p>
</li>
<li>
<p>Disable the locator for buffering.</p>
</li>
<li>
<p>Return to the function/procedure/method in PL/SQL.</p>
</li>
</ul>
<p>You have to explicitly FLUSH a LOB.</p>
</div>
<!-- class="sect2" -->
<a id="i1000167"></a>
<div id="LNPCC4215" class="sect2">
<h3 class="sect2">For Host Variables</h3>
<p>Use the following rules and notes for the LOB statements:</p>
<ul>
<li>
<p><span class="italic">src</span> and <span class="italic">dst</span> can refer to either internal or external LOB locators, but <span class="italic">file</span> refers only to external locators.</p>
</li>
<li>
<p>Numeric host values (<code>amt, src_offset, dst_offset</code>, and so on) are declared <code>as</code> a 4-byte unsigned integer variable. The values are restricted between 0 and 4 Gigabytes.</p>
</li>
<li>
<p>The concept of NULL is part of a LOB locator. There is no need for indicator variables in the LOB statements. NULL cannot be used with numeric value variables such as <code>amt, src_offset</code>, and so on and result in an error.</p>
</li>
<li>
<p>The offset values <code>src_offset</code> and <code>dst_offset</code> have default values 1.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1000172"></a>
<div id="LNPCC03017" class="sect1">
<h2 class="sect1">LOB Statements</h2>
<p>The statements are presented alphabetically. In all the statements where it appears, <span class="italic">database</span> refers to a database connection</p>
<a id="i1005971"></a>
<div id="LNPCC4216" class="sect2">
<h3 class="sect2"><a id="sthref2005"></a>APPEND</h3>
<p class="subhead1"><a id="LNPCC4217"></a>Purpose</p>
<p>This statement appends a LOB value at the end of another LOB.</p>
<p class="subhead1"><a id="LNPCC4218"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB APPEND :<span class="italic">src</span> TO :<span class="italic">dst </span>;
</pre>
<p class="subhead1"><a id="LNPCC4219"></a>Host Variables</p>
<p>src (IN)</p>
<p>An internal LOB locator uniquely referencing the source LOB.</p>
<p>dst (IN OUT)</p>
<p>An internal LOB locator uniquely referencing the destination LOB.</p>
<p class="subhead1"><a id="LNPCC4220"></a>Usage Notes</p>
<p>The data is copied from the source LOB to the end of the destination LOB, extending the destination LOB up to a maximum of 4 Gigabytes. If the LOB is extended beyond 4 Gigabytes, an error will occur.</p>
<p>The source and destination LOBs must already exist and the destination LOB must be initialized.</p>
<p>Both the source and destination LOBs must be of the same internal LOB type. It is an error to have enabled LOB buffering for either type of locator.</p>
</div>
<!-- class="sect2" -->
<a id="i1005972"></a>
<div id="LNPCC4221" class="sect2">
<h3 class="sect2"><a id="sthref2006"></a>ASSIGN</h3>
<p class="subhead1"><a id="LNPCC4222"></a>Purpose</p>
<p>Assigns a LOB or BFILE locator to another.</p>
<p class="subhead1"><a id="LNPCC4223"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB ASSIGN :<span class="italic">src</span> to :<span class="italic">dst </span>;
</pre>
<p class="subhead1"><a id="LNPCC4224"></a>Host Variables</p>
<p>src (IN)</p>
<p>LOB or BFILE locator source copied from.</p>
<p>dst (IN OUT)</p>
<p>LOB or BFILE locator copied to.</p>
<p class="subhead1"><a id="LNPCC4225"></a>Usage Notes</p>
<p>After the assignment, both locators refer to the same LOB value. The destination LOB locator must be a valid initialized (ALLOCATEd) locator.</p>
<p>For internal LOBs, the source locator&#39;s LOB value is copied to the destination locator&#39;s LOB value only when the destination locator is stored in the table. For Pro*C/C++, issuing a FLUSH of an object containing the destination locator will copy the LOB value.</p>
<p>An error is returned when a BFILE locator is assigned to an internal LOB locator and vice-versa. It is also an error if the <span class="italic">src</span> and <span class="italic">dst</span> LOBs are not of the same type.</p>
<p>If the source locator is for an internal LOB that was enabled for buffering, and the source locator has been used to modify the LOB value through the LOB Buffering Subsystem, and the buffers have not been FLUSHed since the WRITE, then the source locator cannot be assigned to the destination locator. This is because only one locator for each LOB can modify the LOB value through the LOB Buffering Subsystem.</p>
</div>
<!-- class="sect2" -->
<a id="i1006635"></a>
<div id="LNPCC4226" class="sect2">
<h3 class="sect2"><a id="sthref2007"></a>CLOSE</h3>
<p class="subhead1"><a id="LNPCC4227"></a>Purpose</p>
<p>Close an open LOB or BFILE.</p>
<p class="subhead1"><a id="LNPCC4228"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB CLOSE :<span class="italic">src ;</span>
</pre>
<p class="subhead1"><a id="LNPCC4229"></a>Host Variables</p>
<p>src (IN OUT)</p>
<p>The locator of the LOB or BFILE to be closed.</p>
<p class="subhead1"><a id="LNPCC4230"></a>Usage Notes</p>
<p>It is an error to close the same LOB twice either with different locators or with the same locator. For external LOBs, no error is produced if the BFILE exists but has not been opened.</p>
<p>It is an error to COMMIT a transaction before closing all previously opened LOBs. At transaction ROLLBACK time, all LOBs that are still open will be discarded without first being closed.</p>
</div>
<!-- class="sect2" -->
<a id="i1005974"></a>
<div id="LNPCC4231" class="sect2">
<h3 class="sect2"><a id="sthref2008"></a>COPY</h3>
<p class="subhead1"><a id="LNPCC4232"></a>Purpose</p>
<p>Copy all or part of a LOB value into a second LOB.</p>
<p class="subhead1"><a id="LNPCC4233"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB COPY :<span class="italic">amt </span>FROM :<span class="italic">src</span> [AT :<span class="italic">src_offset</span>]
   TO :<span class="italic">dst</span> [AT :<span class="italic">dst_offset</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4234"></a>Host Variables</p>
<p>amt (IN)</p>
<p>The maximum number of bytes for BLOBs, or characters for CLOBs and NCLOBs, to copy.</p>
<p>src (IN)</p>
<p>The locator of the source LOB.</p>
<p>src_offset (IN)</p>
<p>This is the number of characters for CLOB or NCLOB, and the number of bytes for a BLOB, starting from 1 at the beginning of the LOB.</p>
<p>dst (IN)</p>
<p>The locator of the destination LOB.</p>
<p>dst_offset (IN)</p>
<p>The destination offset. Same rules as for src_offset.</p>
<p class="subhead1"><a id="LNPCC4235"></a>Usage Notes</p>
<p>If the data already exists at the destination&#39;s offset and beyond, it is overwritten with the source data. If the destination&#39;s offset is beyond the end of the current data, zero-byte fillers (BLOBs) or spaces (CLOBs) are written into the destination LOB from the end of the current data to the beginning of the newly written data from the source.</p>
<p>The destination LOB is extended to accommodate the newly written data if it extends beyond the current length of the destination LOB. It is a runtime error to extend this LOB beyond 4 Gigabytes.</p>
<p>It is also an error to try to copy from a LOB that is not initialized.</p>
<p>Both the source and destination LOBs must be of the same type. LOB buffering must not be enabled for either locator.</p>
<p>The <code>amt</code> variable indicates the maximum amount to copy. If the end of the source LOB is reached before the specified amount is copied, the operation terminates with <code>ORA-22993</code> error.</p>
<p>To make a temporary LOB permanent, the COPY statement must be used to explicitly COPY the temporary LOB into a permanent one.</p>
</div>
<!-- class="sect2" -->
<a id="i1005975"></a>
<div id="LNPCC4236" class="sect2">
<h3 class="sect2"><a id="sthref2009"></a><a id="sthref2010"></a>CREATE TEMPORARY</h3>
<p class="subhead1"><a id="LNPCC4237"></a>Purpose</p>
<p>Creates a temporary LOB.</p>
<p class="subhead1"><a id="LNPCC4238"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB CREATE TEMPORARY :<span class="italic">src ;</span>
</pre>
<p class="subhead1"><a id="LNPCC4239"></a>Host Variables</p>
<p>src (IN OUT)</p>
<p>Before execution, when IN, <code>src</code> is a LOB locator previously ALLOCATEd.</p>
<p>After execution, when OUT, <code>src</code> is a LOB locator that will point to a new empty temporary LOB.</p>
<p class="subhead1"><a id="LNPCC4240"></a>Usage Notes</p>
<p>After successful execution, the locator points to a newly created temporary LOB that resides on the database server independent of a table. The temporary LOB is empty and has zero length.</p>
<p>At the end of a session, all temporary LOBs are freed. READs and WRITEs to temporary LOBs never go through the buffer cache.</p>
</div>
<!-- class="sect2" -->
<a id="i1005976"></a>
<div id="LNPCC4241" class="sect2">
<h3 class="sect2">D<a id="sthref2011"></a>ISABLE BUFFERING</h3>
<p class="subhead1"><a id="LNPCC4242"></a>Purpose</p>
<p>Disables LOB buffering for the LOB locator.</p>
<p class="subhead1"><a id="LNPCC4243"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB DISABLE BUFFERING :<span class="italic">src ;</span>
</pre>
<p class="subhead1"><a id="LNPCC4244"></a>Host Variable</p>
<p>src (IN OUT)</p>
<p>An internal LOB locator.</p>
<p class="subhead1"><a id="LNPCC4245"></a>Usage Notes</p>
<p>This statement does not support BFILEs. Subsequent reads or writes will not be done through the LBS.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Use a FLUSH BUFFER command to make changes permanent, since this statement does not implicitly flush the changes made in the LOB Buffering Subsystem.</div>
</div>
<!-- class="sect2" -->
<a id="i1007921"></a>
<div id="LNPCC4246" class="sect2">
<h3 class="sect2"><a id="sthref2012"></a>ENABLE BUFFERING</h3>
<p class="subhead1"><a id="LNPCC4247"></a>Purpose</p>
<p>Enables LOB buffering for the LOB locator.</p>
<p class="subhead1"><a id="LNPCC4248"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB ENABLE BUFFERING :<span class="italic">src ;</span>
</pre>
<p class="subhead1"><a id="LNPCC4249"></a>Host Variable</p>
<p>src (IN OUT)</p>
<p>An internal LOB locator.</p>
<p class="subhead1"><a id="LNPCC4250"></a>Usage Notes</p>
<p>This statement does not support BFILEs. Subsequent reads and writes are done through the LBS.</p>
</div>
<!-- class="sect2" -->
<a id="i1006646"></a>
<div id="LNPCC4251" class="sect2">
<h3 class="sect2"><a id="sthref2013"></a>ERASE</h3>
<p class="subhead1"><a id="LNPCC4252"></a>Purpose</p>
<p>Erases a given amount of LOB data starting from a given offset.</p>
<p class="subhead1"><a id="LNPCC4253"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB ERASE :<span class="italic">amt</span> FROM :<span class="italic">src</span> [AT :<span class="italic">src_offset</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4254"></a>Host Variables</p>
<p>amt (IN OUT)</p>
<p>The input is the number of bytes or characters to erase. The returned output is the actual number erased.</p>
<p>src (IN OUT)</p>
<p>An internal LOB locator.</p>
<p>src_offset (IN)</p>
<p>The offset from the beginning of the LOB, starting from 1.</p>
<p class="subhead1"><a id="LNPCC4255"></a>Usage Notes</p>
<p>This statement does not support BFILEs.</p>
<p>After execution, <code>amt</code> returns the actual number of characters/bytes that were erased. The actual number and requested number will differ if the end of the LOB value is reached before erasing the requested number of characters/bytes. If the LOB is empty, <code>amt</code> will indicate that 0 characters/bytes were erased.</p>
<p>For BLOBs, erasing means zero-byte fillers overwrite the existing LOB value. For CLOBs, erasing means that spaces overwrite the existing LOB value.</p>
</div>
<!-- class="sect2" -->
<a id="i1009092"></a>
<div id="LNPCC4256" class="sect2">
<h3 class="sect2"><a id="sthref2014"></a><a id="sthref2015"></a>FILE CLOSE ALL</h3>
<p class="subhead1"><a id="LNPCC4257"></a>Purpose</p>
<p>Closes all BFILES opened in the current session.</p>
<p class="subhead1"><a id="LNPCC4258"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB FILE CLOSE ALL ;
</pre>
<p class="subhead1"><a id="LNPCC4259"></a>Usage Notes</p>
<p>If there are any open files in the session whose closure has not been handled properly, you can use the FILE CLOSE ALL statement to close all files opened in the session, and resume file operations from the beginning.</p>
</div>
<!-- class="sect2" -->
<a id="i1005979"></a>
<div id="LNPCC4260" class="sect2">
<h3 class="sect2"><a id="sthref2016"></a>FILE SET</h3>
<p class="subhead1"><a id="LNPCC4261"></a>Purpose</p>
<p>Sets DIRECTORY alias and FILENAME in a BFILE locator.</p>
<p class="subhead1"><a id="LNPCC4262"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB FILE SET :<span class="italic">file</span>
    DIRECTORY = :<span class="italic">alias</span>, FILENAME = :<span class="italic">filename ;</span>
</pre>
<p class="subhead1"><a id="LNPCC4263"></a>Host Variables</p>
<p>file (IN OUT)</p>
<p>BFILE locator where the DIRECTORY alias and FILENAME is set.</p>
<p>alias (IN)</p>
<p>DIRECTORY alias name to set.</p>
<p>filename (IN)</p>
<p>The FILENAME to set.</p>
<p class="subhead1"><a id="LNPCC4264"></a>Usage Notes</p>
<p>The given BFILE locator must be first ALLOCATEd prior to its use in this statement.</p>
<p>Both the DIRECTORY alias name and FILENAME must be provided.</p>
<p>The maximum length of the DIRECTORY alias is 30 bytes. The maximum length of the FILENAME is 255 bytes.</p>
<p>The only external datatypes supported for use with the DIRECTORY alias name and FILENAME attributes are CHARZ, STRING, VARCHAR, VARCHAR2 and CHARF.</p>
<p>It is an error to use this statement with anything but an external LOB locator.</p>
</div>
<!-- class="sect2" -->
<a id="i1006658"></a>
<div id="LNPCC4265" class="sect2">
<h3 class="sect2"><a id="sthref2017"></a>FLUSH BUFFER</h3>
<p class="subhead1"><a id="LNPCC4266"></a>Purpose</p>
<p>Writes this LOB&#39;s buffers to the database server.</p>
<p class="subhead1"><a id="LNPCC4267"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB FLUSH BUFFER :<span class="italic">src</span> [FREE] ;
</pre>
<p class="subhead1"><a id="LNPCC4268"></a>Host Variables</p>
<p>src (IN OUT)</p>
<p>Internal LOB locator.</p>
<p class="subhead1"><a id="LNPCC4269"></a>Usage Notes</p>
<p>Writes the buffer data to the database LOB in the server from the LOB referenced by the input locator.</p>
<p>LOB buffering must have already been enabled for the input LOB locator.</p>
<p>The FLUSH operation, by default, does not free the buffer resources for reallocation to another buffered LOB operation. However, if you want to free the buffer explicitly, you can include the optional FREE keyword to so indicate.</p>
</div>
<!-- class="sect2" -->
<a id="i1005981"></a>
<div id="LNPCC4270" class="sect2">
<h3 class="sect2"><a id="sthref2018"></a>FREE TEMPORARY</h3>
<p class="subhead1"><a id="LNPCC4271"></a>Purpose</p>
<p>Free the temporary space for the LOB locator.</p>
<p class="subhead1"><a id="LNPCC4272"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB FREE TEMPORARY :<span class="italic">src ;</span>
</pre>
<p class="subhead1"><a id="LNPCC4273"></a>Host Variable</p>
<p>src (IN OUT)</p>
<p>The LOB locator pointing to the temporary LOB.</p>
<p class="subhead1"><a id="LNPCC4274"></a>Usage Notes</p>
<p>The input locator must point to a temporary LOB. The output locator is marked not initialized and can be used in subsequent LOB statements.</p>
</div>
<!-- class="sect2" -->
<a id="i1005982"></a>
<div id="LNPCC4275" class="sect2">
<h3 class="sect2">L<a id="sthref2019"></a>OAD FROM FILE</h3>
<p class="subhead1"><a id="LNPCC4276"></a>Purpose</p>
<p>Copy all or a part of a BFILE into an internal LOB.</p>
<p class="subhead1"><a id="LNPCC4277"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB LOAD :<span class="italic">amt</span> FROM FILE :<span class="italic">file</span> [AT :<span class="italic">src_offset</span>] INTO
    :<span class="italic">dst</span> [AT :<span class="italic">dst_offset</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4278"></a>Host Variables</p>
<p>amt (IN)</p>
<p>Maximum number of bytes to be loaded.</p>
<p>file (IN OUT)</p>
<p>The source BFILE locator.</p>
<p>src_offset (IN)</p>
<p>The number of bytes offset from the beginning of the file, starting from 1.</p>
<p>dst (IN OUT)</p>
<p>The destination LOB locator which can be BLOB, CLOB, be NCLOB.</p>
<p>dst_offset (IN)</p>
<p>The number of bytes (for BLOBs) or characters (CLOBs and NCLOBs) from the beginning of the destination LOB where writing will begin. It starts at 1.</p>
<p class="subhead1"><a id="LNPCC4279"></a>Usage Notes</p>
<p>The data is copied from the source BFILE to the destination internal LOB. No character set conversions are performed when copying the BFILE data to a CLOB or NCLOB. Therefore, the BFILE data must already be in the same character set as the CLOB or NCLOB in the database.</p>
<p>The source and destination LOBs must already exist. If the data already exists at the destination&#39;s start position, it is overwritten with the source data. If the destination&#39;s start position is beyond the end of the current data, zero-byte fillers (BLOBs) or spaces (CLOBs and NCLOBs) are written into the destination LOB. The fillers are written to the destination LOB from the end of the data to the beginning of the newly written data from the source.</p>
<p>The destination LOB is extended to accommodate the newly written data if it extends beyond the current length of the destination LOB. It is an error to extend this LOB beyond 4 Gigabytes.</p>
<p>It is also an error to copy from a BFILE that is not initialized.</p>
<p>The amount parameter indicates the maximum amount to load. If the end of the source BFILE is reached before the specified amount is loaded, the operation terminates with <code>ORA-22993</code> error.</p>
</div>
<!-- class="sect2" -->
<a id="i1005983"></a>
<div id="LNPCC4280" class="sect2">
<h3 class="sect2"><a id="sthref2020"></a>OPEN</h3>
<p class="subhead1"><a id="LNPCC4281"></a>Purpose</p>
<p>Open a LOB or BFILE for read or read/write access.</p>
<p class="subhead1"><a id="LNPCC4282"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB OPEN :<span class="italic">src</span> [ READ ONLY | READ WRITE ] ;
</pre>
<p class="subhead1"><a id="LNPCC4283"></a>Host Variables</p>
<p>src (IN OUT)</p>
<p>LOB locator of the LOB or BFILE.</p>
<p class="subhead1"><a id="LNPCC4284"></a>Usage Notes</p>
<p>The default mode in which a LOB or BFILE can be OPENed is for READ ONLY access.</p>
<p>For internal LOBs, being OPEN is associated with the LOB, not the locator. Assigning an already OPENed locator to another locator does not count as OPENing a new LOB. Instead, both locators refer to the same LOB. For BFILEs, being OPEN is associated with the locator.</p>
<p>Only 32 LOBs can be OPEN at any one time. An error will be returned when the 33rd LOB is OPENed.</p>
<p>There is no support for writable BFILEs. Therefore, when you OPEN a BFILE in READ WRITE mode, an error is returned.</p>
<p>It is also an error to open a LOB in READ ONLY mode and then attempt to WRITE to the LOB.</p>
</div>
<!-- class="sect2" -->
<a id="i1006674"></a>
<div id="LNPCC03018" class="sect2">
<h3 class="sect2"><a id="sthref2021"></a>READ</h3>
<p class="subhead1"><a id="LNPCC4285"></a>Purpose</p>
<p>Reads all or part of a LOB or BFILE into a buffer.</p>
<p class="subhead1"><a id="LNPCC4286"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB READ :amt FROM :<span class="italic">src </span>[AT :<span class="italic">src_offset</span>]
   INTO :<span class="italic">buffer</span> [WITH LENGTH :<span class="italic">buflen</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4287"></a>Host Variables</p>
<p>amt (IN OUT)</p>
<p>The input is the number of characters or bytes to be read. The output is the actual number of characters or bytes that were read.</p>
<p>If the amount of bytes to be read is larger than the buffer length it is assumed that the LOB is being READ in a polling mode. On input if this value is 0, then the data will be read in a polling mode from the input offset until the end of the LOB.</p>
<p>The number of bytes or characters actually read is returned in <code>amt.</code> If the data is read in pieces, <code>amt</code> will always contain the length of the last piece read.</p>
<p>When the end of a LOB is reached an <code>ORA-1403: no data found</code> error will be issued.</p>
<p>When reading in a polling mode, the application must invoke the LOB READ repeatedly to read more pieces of the LOB until no more data is left. Control the use of the polling mode with the NOT FOUND condition in a WHENEVER directive to catch the <code>ORA-1403</code> error.</p>
<p>src (IN)</p>
<p>The LOB or BFILE locator.</p>
<p>src_offset (IN)</p>
<p>This is the absolute offset from the beginning of the LOB value from which to start reading. For character LOBs it is the number of characters from the beginning of the LOB. For binary LOBs or BFILEs it is the number of bytes. The first position is 1.</p>
<p>buffer (IN/OUT)</p>
<p>A buffer into which the LOB data will be read. The external datatype of the buffer is restricted to only a few types depending on the type of the source LOB. The maximum length of the buffer depends on the external datatype being used to store the LOB value. The following table summarizes the legal external datatypes and their corresponding maximum lengths categorized by source LOB type:</p>
<div id="LNPCC4288" class="tblformal">
<p class="titleintable"><a id="sthref2022"></a><a id="sthref2023"></a>Table 16-2 Source LOB and Precompiler Datatypes</p>
<table class="cellalignment831" title="Source LOB and Precompiler Datatypes" summary="Source LOB and Precompiler Datatypes" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t9">External LOB<a id="sthref2024" href="#sthref2024" onclick="footdisplay(1,&#34;\u003cspan class=\&#34;bold\&#34;\u003e Any of the external datatypes shown can be used with BFILES.\u003c/span\u003e&#34;)"><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></th>
<th class="cellalignment832" id="r1c2-t9"><span class="bold">Internal LOB</span></th>
<th class="cellalignment832" id="r1c3-t9"><span class="bold">Precompiler External Datatype</span></th>
<th class="cellalignment832" id="r1c4-t9">Precompiler Maximum Length <a id="sthref2025" href="#sthref2025" onclick="footdisplay(2,&#34;\u003cspan class=\&#34;bold\&#34;\u003e Lengths are measured in bytes, not characters.\u003c/span\u003e&#34;)"><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a></th>
<th class="cellalignment832" id="r1c5-t9">PL/SQL Datatype</th>
<th class="cellalignment832" id="r1c6-t9">PL/SQL Maximum Length</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t9" headers="r1c1-t9">
<p>BFILE</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c2-t9">
<p>BLOB</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c3-t9">
<p>RAW</p>
<p>VARRAW</p>
<p>LONG RAW</p>
<p>LONG VARRAW</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c4-t9">
<p>65535</p>
<p>65533</p>
<p>2147483647</p>
<p>2147483643</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c5-t9">
<p>RAW</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c6-t9">
<p>32767</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t9" headers="r1c1-t9">
<p>BFILE</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c2-t9">
<p>CLOB</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c3-t9">
<p>VARCHAR2</p>
<p>VARCHAR</p>
<p>LONG VARCHAR</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c4-t9">
<p>65535</p>
<p>65533</p>
<p>2147483643</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c5-t9">
<p>VARCHAR2</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c6-t9">
<p>32767</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t9" headers="r1c1-t9">
<p>BFILE</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c2-t9">
<p>NCLOB</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c3-t9">
<p>NVARCHAR2</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c4-t9">
<p>4000</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c5-t9">
<p>NVARCHAR2</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c6-t9">
<p>4000</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup> <span class="bold">Any of the external datatypes shown can be used with BFILES.</span></p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2&nbsp;</sup> <span class="bold">Lengths are measured in bytes, not characters.</span></p>
<p>buflen (IN)</p>
<p>Specifies the length of the given buffer when it cannot be determined otherwise.</p>
<p class="subhead1"><a id="LNPCC4289"></a>Usage Notes</p>
<p>A BFILE must already exist on the database server and it must have been opened using the input locator. The database must have permission to read the file and you, the user, must have read permission on the directory.</p>
<p>It is an error to try to read from an un-initialized LOB or BFILE.</p>
<p>The length of the buffer is determined this way:</p>
<ul>
<li>
<p>From <code>buflen</code>, when the WITH LENGTH clause is present.</p>
</li>
<li>
<p>In the absence of the WITH LENGTH clause, the length is determined by treating the buffer host variable in OUT mode.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_04dat.htm#i22611">&#34;Globalization Support&#34;</a></p>
</li>
<li>
<p><a href="#i1006680">&#34;READ a BLOB, Write a File Example&#34;</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006881"></a>
<div id="LNPCC4290" class="sect2">
<h3 class="sect2">TRIM</h3>
<p class="subhead1"><a id="LNPCC4291"></a>Purpose</p>
<p>Truncates the LOB value.</p>
<p class="subhead1"><a id="LNPCC4292"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB TRIM :<span class="italic">src</span> TO :<span class="italic">newlen ;</span>
</pre>
<p class="subhead1"><a id="LNPCC4293"></a>Host Variables</p>
<p>src (IN OUT)</p>
<p>LOB locator for internal LOB.</p>
<p>newlen (IN)</p>
<p>The new length of the LOB value.</p>
<p class="subhead1"><a id="LNPCC4294"></a>Usage Notes</p>
<p>This statement is not for BFILES. The new length cannot be greater than the current length, or an error is returned.</p>
</div>
<!-- class="sect2" -->
<a id="i1006676"></a>
<div id="LNPCC4295" class="sect2">
<h3 class="sect2">WRITE</h3>
<p class="subhead1"><a id="LNPCC4296"></a>Purpose</p>
<p>Writes the contents of a buffer to a LOB.</p>
<p class="subhead1"><a id="LNPCC4297"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB WRITE [APPEND] [ FIRST | NEXT | LAST | ONE ]
    :<span class="italic">amt </span>FROM :<span class="italic">buffer</span> [WITH LENGTH :<span class="italic">buflen</span>] INTO :<span class="italic">dst</span> [AT :<span class="italic">dst_offset</span>] ;
</pre>
<p class="subhead1"><a id="LNPCC4298"></a>Host Variables</p>
<dl>
<dt>amt (IN OUT)</dt>
<dd>
<p>The input is the number of characters or bytes to be written.</p>
<p>The output is the actual number of characters or bytes that is written.</p>
<p>When writing using a polling method, <code>amt</code> will return the cumulative total length written for the execution of the WRITE statement after a WRITE LAST is executed. If the WRITE statement is interrupted, <code>amt</code> will be undefined.</p>
</dd>
<dt>buffer (IN)</dt>
<dd>
<p>A buffer from which the LOB data is written.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006674">&#34;READ&#34;</a> for the lengths of datatypes.</div>
</dd>
<dt>dst (IN OUT)</dt>
<dd>
<p>The LOB locator.</p>
</dd>
<dt>dst_offset (IN)</dt>
<dd>
<p>The offset from the beginning of the LOB (counting from 1), in characters for CLOBs and NCLOBs, in bytes for BLOBs.</p>
</dd>
<dt>buflen (IN)</dt>
<dd>
<p>The buffer length when it cannot be calculated in any other way.</p>
</dd>
</dl>
<p class="subhead1"><a id="LNPCC4299"></a>Usage Notes</p>
<p>If LOB data already exists, it is overwritten with the data stored in the buffer. If the offset specified is beyond the end of the data currently in the LOB, zero-byte fillers or spaces are inserted into the LOB.</p>
<p>Specifying the keyword APPEND in the WRITE statement causes the data to automatically be written to the end of the LOB. When APPEND is specified, the destination offset is assumed to be the end of the LOB. It is an error to specify the destination offset when using the APPEND option in the WRITE statement.</p>
<p>The buffer can be written to the LOB in one piece (using the ONE orientation which is the default) or it can be provided piece-wise using a standard polling method.</p>
<p>Polling is begun by using FIRST, then NEXT to write subsequent pieces. The LAST keyword is used to write the final piece that terminates the write.</p>
<p>Using this piece-wise write mode, the buffer and the length can be different in each call if the pieces are of different sizes and from different locations.</p>
<p>If the total amount of data passed to Oracle is less than the amount specified by the <code>amt</code> parameter after doing all the writes, an error results.</p>
<p>The same rules apply for determining the buffer length as in the READ statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006680">&#34;READ a BLOB, Write a File Example&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006677"></a>
<div id="LNPCC4300" class="sect2">
<h3 class="sect2">DESCRIBE</h3>
<p class="subhead1"><a id="i1006678"></a><a id="LNPCC4301"></a>Purpose</p>
<p>This is a statement that is equivalent to several OCI and PL/SQL statements (which is why it is saved for last). Use the LOB DESCRIBE SQL statement to retrieve attributes from a LOB. This capability is similar to OCI and PL/SQL procedures. The LOB DESCRIBE statement has this format:</p>
<p class="subhead1"><a id="LNPCC4302"></a>Syntax</p>
<pre>EXEC SQL [AT [:]<span class="italic">database</span>] LOB DESCRIBE :<span class="italic">src</span> GET <span class="italic">attribute1</span> [{, <span class="italic">attributeN</span>}]
   INTO :<span class="italic">hv1</span> [[INDICATOR] :<span class="italic">hv_ind1</span>] [{, :<span class="italic">hvN</span> [[INDICATOR] :<span class="italic">hv_indN</span>] }] ;
</pre>
<p>where an attribute can be any of these choices:</p>
<pre>CHUNKSIZE | DIRECTORY | FILEEXISTS | FILENAME | ISOPEN | ISTEMPORARY | LENGTH
</pre>
<p class="subhead1"><a id="LNPCC4303"></a>Host variables</p>
<p>src (IN)</p>
<p>The LOB locator of an internal or external LOB.</p>
<p>hv1 ... hvN ... (OUT)</p>
<p>The host variables that receive the attribute values, in the order specified in the attribute name list.</p>
<p>hv_ind1 ... hv_indN ... (OUT)</p>
<p>Optional host variables that receive the indicator NULL status in the order of the attribute name list.</p>
<p>This table describes the attributes, which LOB it is associated with, and the C types into which they should be read:</p>
<div id="LNPCC4304" class="tblformal">
<p class="titleintable"><a id="sthref2026"></a><a id="sthref2027"></a>Table 16-3 LOB Attributes</p>
<table class="cellalignment831" title="LOB Attributes" summary="LOB Attributes" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t13"><span class="bold">LOB Attribute</span></th>
<th class="cellalignment832" id="r1c2-t13"><span class="bold">Attribute Description</span></th>
<th class="cellalignment832" id="r1c3-t13"><span class="bold">Restrictions</span></th>
<th class="cellalignment832" id="r1c4-t13"><span class="bold">C Type</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t13" headers="r1c1-t13">
<p>CHUNKSIZE</p>
</td>
<td class="cellalignment833" headers="r2c1-t13 r1c2-t13">
<p>The amount (in bytes for BLOBs and characters for CLOBs/NCLOBs) of space used in the LOB chunk to store the LOB value. You speed up performance if you issue READ/WRITE requests using a multiple of this chunk size. If all WRITEs are done on a chunk basis, no extra/excess versioning is done nor duplicated. Users could batch up the WRITE until they have enough for a chunk instead of issuing several WRITE calls for the same CHUNK.</p>
</td>
<td class="cellalignment833" headers="r2c1-t13 r1c3-t13">
<p>BLOBs, CLOBs, and NCLOBs only</p>
</td>
<td class="cellalignment833" headers="r2c1-t13 r1c4-t13">
<p>unsigned int</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t13" headers="r1c1-t13">
<p>DIRECTORY</p>
</td>
<td class="cellalignment833" headers="r3c1-t13 r1c2-t13">
<p>The name of the DIRECTORY alias for the BFILE. The maximum length is 30 bytes.</p>
</td>
<td class="cellalignment833" headers="r3c1-t13 r1c3-t13">
<p>FILE LOBs only</p>
</td>
<td class="cellalignment833" headers="r3c1-t13 r1c4-t13">
<p>char * <a id="sthref2028" href="#sthref2028" onclick="footdisplay(1,&#34;For DIRECTORY and FILENAME attributes, the only external datatypes that will be supported are CHARZ, STRING, VARCHAR, VARCHAR2 and CHARF.&#34;)"><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t13" headers="r1c1-t13">
<p>FILEEXISTS</p>
</td>
<td class="cellalignment833" headers="r4c1-t13 r1c2-t13">
<p>Determines whether or not the BFILE exists on the server&#39;s operating system&#39;s file system. FILEEXISTS is true when it is nonzero; false when it equals 0.</p>
</td>
<td class="cellalignment833" headers="r4c1-t13 r1c3-t13">
<p>FILE LOBs only</p>
</td>
<td class="cellalignment833" headers="r4c1-t13 r1c4-t13">
<p>signed int</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t13" headers="r1c1-t13">
<p>FILENAME</p>
</td>
<td class="cellalignment833" headers="r5c1-t13 r1c2-t13">
<p>The name of the BFILE. The maximum length is 255 bytes.</p>
</td>
<td class="cellalignment833" headers="r5c1-t13 r1c3-t13">
<p>FILE LOBs only</p>
</td>
<td class="cellalignment833" headers="r5c1-t13 r1c4-t13">
<p>char *</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t13" headers="r1c1-t13">
<p>ISOPEN</p>
</td>
<td class="cellalignment833" headers="r6c1-t13 r1c2-t13">
<p>For BFILEs, if the input BFILE locator was never used in an OPEN statement, the BFILE is considered not to be OPENed by this locator. However, a different BFILE locator may have OPENed the BFILE. More than one OPEN can be performed on the same BFILE using different locators. For LOBs, if a different locator OPENed the LOB, the LOB is still considered to be OPEN by the input locator. ISOPEN is true when it is nonzero; false when it equals 0.</p>
</td>
<td class="cellalignment833" headers="r6c1-t13 r1c3-t13">
<p>-</p>
</td>
<td class="cellalignment833" headers="r6c1-t13 r1c4-t13">
<p>signed int</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t13" headers="r1c1-t13">
<p>ISTEMPORARY</p>
</td>
<td class="cellalignment833" headers="r7c1-t13 r1c2-t13">
<p>Determines whether or not the input LOB locator refers to a temporary LOB or not. ISTEMPORARY is true when it is nonzero; false when it equals 0.</p>
</td>
<td class="cellalignment833" headers="r7c1-t13 r1c3-t13">
<p>BLOBs, CLOBs, and NCLOBs only</p>
</td>
<td class="cellalignment833" headers="r7c1-t13 r1c4-t13">
<p>signed int</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t13" headers="r1c1-t13">
<p>LENGTH</p>
</td>
<td class="cellalignment833" headers="r8c1-t13 r1c2-t13">
<p>Length of BLOBs and BFILEs in bytes, CLOBs and NCLOBs in characters. For BFILEs, the length includes EOF if it exists. Empty internal LOBs have zero length. LOBs/BFILEs that are not initialized have undefined length.</p>
</td>
<td class="cellalignment833" headers="r8c1-t13 r1c3-t13">
<p>-</p>
</td>
<td class="cellalignment833" headers="r8c1-t13 r1c4-t13">
<p>unsigned int</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup>For DIRECTORY and FILENAME attributes, the only external datatypes that will be supported are CHARZ, STRING, VARCHAR, VARCHAR2 and CHARF.</p>
<p class="subhead1"><a id="LNPCC4305"></a>Usage Notes</p>
<p>Indicator variables should be declared short. After execution has completed, sqlca.sqlerrd[2] contains the number of attributes retrieved without error. If there was an execution error, the attribute at which it occurred is one more than the contents of sqlca.sqlerrd[2].</p>
<p class="subhead1"><a id="LNPCC4306"></a>DESCRIBE Example</p>
<p>Here is a simple Pro*C/C++ example that extracts the DIRECTORY and FILENAME attributes of a given BFILE:</p>
<p>The oci.h header file is needed for the proper type resolution and compilation of the following OCIBFileLocator declaration:</p>
<pre>#include &lt;oci.h&gt;
...
OCIBFileLocator *bfile ;
char directory[31], filename[256] ;
short d_ind, f_ind ;
</pre>
<p>Finally, select a BFILE locator from some LOB table and perform the DESCRIBE:</p>
<pre>EXEC SQL ALLOCATE :bfile ;
EXEC SQL SELECT a_bfile INTO :bfile FROM lob_table WHERE ... ;
EXEC SQL LOB DESCRIBE :bfile
   GET DIRECTORY, FILENAME INTO :directory:d_ind, :filename:f_ind ;
</pre>
<p>Indicator variables are only valid for use with the DIRECTORY and FILENAME attributes. These attributes are character strings whose values may be truncated if the host variable buffers used to hold their values aren&#39;t large enough. When truncation occurs, the value of the indicator will be set to the original length of the attribute.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006679"></a>
<div id="LNPCC4307" class="sect1">
<h2 class="sect1">LOBs and the Navigational Interface</h2>
<p>The navigational interface can also be used to work with object types that contain LOBs as attributes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_17obj.htm#i453951">&#34;Navigational Access to Objects&#34;</a></div>
<div id="LNPCC4308" class="sect2"><a id="sthref2029"></a>
<h3 class="sect2">Transient Objects</h3>
<p>Use the OBJECT CREATE statement to create transient and persistent objects with LOB attributes. You can ASSIGN a temporary LOB to the LOB attribute of a transient object, then copy the value to a permanent LOB or a LOB attribute of a persistent object to save the data. Or, ASSIGN the temporary LOB to the LOB attribute and use FLUSH to write the value to the database.</p>
<p>You can create a transient object with a BFILE attribute and read data from the BFILE on disk. Remember, temporary BFILEs are not supported.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4309" class="sect2"><a id="sthref2030"></a>
<h3 class="sect2">Persistent Objects</h3>
<p>When you create a persistent object in the object cache that contains an internal LOB attribute, the LOB attribute is implicitly set to empty. You must first flush this object using the OBJECT FLUSH statement, thereby inserting a row into the table and creating an empty LOB. Once the object is refreshed in the object cache (using the VERSION=LATEST option), the real locator is read into the attribute.</p>
<p>When creating an object with a BFILE attribute, the BFILE is set to NULL. It must be updated with a valid directory alias and filename before the BFILE can be read.</p>
<p>A temporary LOB may be ASSIGNed to a LOB attribute of a persistent object. The actual LOB value will be copied when the object is flushed. A user may also explicitly copy a temporary LOB&#39;s value to a LOB attribute of a persistent object using the temporary LOB locator and a locator for the LOB attribute in a COPY statement.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC4310" class="sect2"><a id="sthref2031"></a>
<h3 class="sect2">Navigational Interface Example</h3>
<p>Use the OBJECT GET and SET statements to handle LOBs through the navigational interface.</p>
<p>You can retrieve a LOB locator that is an attribute of an object type and use it in any of the new embedded SQL LOB statements. Place LOB locators back into object types as attributes using the OBJECT SET statement.</p>
<p>Doing so is the same as a direct LOB ASSIGN operation. The same rules apply to an OBJECT GET or SET of a LOB attribute from or to an object type that would apply if a LOB ASSIGN had been performed instead, including type enforcement.</p>
<p>For example, suppose we had this simple type definition</p>
<pre>CREATE TYPE lob_type AS OBJECT (a_blob BLOB) ;
</pre>
<p>This example assumes that the type is a column in the database with a valid (and initialized) BLOB attribute.</p>
<p>The OTT-generated C structure usable by Pro*C/C++ looks like this:</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_19ott.htm#g464850">Chapter 19, &#34;The Object Type Translator&#34;</a> for information on creating an INTYPE file for OTT and running OTT.</div>
<pre>struct lob_type
{
   OCIBlobLocator *a_blob ;
} ;
typedef struct lob_type lob_type ;
</pre>
<p>You can write a Pro*C/C++ program to extract the BLOB attribute and retrieve the BLOB&#39;s current length in a DESCRIBE statement. You can then TRIM the BLOB to half its size, setting the attribute back with a SET OBJECT and then make the change permanent with an OBJECT FLUSH.</p>
<p>First include oci.h and make some local variable declarations:</p>
<pre>#include &lt;oci.h&gt;
lob_type *lob_type_p ;
OCIBlobLocator *blob = (OCIBlobLocator *)0 ;
unsigned int length ;
</pre>
<p>Select the BLOB attribute from the object, do an OBJECT GET, and do a DESCRIBE to get the current length of the BLOB:</p>
<pre>EXEC SQL ALLOCATE :blob ;
EXEC SQL SELECT a_column
   INTO :lob_type_p FROM a_table WHERE ... FOR UPDATE ;
EXEC SQL OBJECT GET a_blob FROM :lob_type_p INTO :blob ;
EXEC SQL LOB DESCRIBE :blob GET LENGTH INTO :length ;
</pre>
<p>Cut the length in half and TRIM the BLOB to that new length:</p>
<pre>length = (unsigned int)(length / 2) ;
EXEC SQL LOB TRIM :blob TO :length ;
</pre>
<p>Once the BLOB has been changed, set the BLOB attribute back into the object, FLUSH the change back to the server, and commit:</p>
<pre>EXEC SQL OBJECT SET a_blob OF :lob_type_p TO :blob ;
EXEC SQL OBJECT FLUSH :lob_type_p ;
EXEC SQL FREE :blob ;
EXEC SQL COMMIT WORK ;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1003520"></a>
<div id="LNPCC4311" class="sect1">
<h2 class="sect1">LOB Program Examples</h2>
<p>Here are two examples which show how to read and write BFILEs and BLOBs.</p>
<a id="i1006680"></a>
<div id="LNPCC4312" class="sect2">
<h3 class="sect2">READ a BLOB, Write a File Example</h3>
<p>In this example we will be reading data from a BLOB with an unknown arbitrary length into a buffer and then writing the data from the buffer into an external file. Our buffer is small, so depending on the size of the BLOB we are reading, we may be able to read the BLOB value into the buffer in a single READ statement or we may be required to utilize a standard polling method instead.</p>
<p>First we start off with oci.h and some simple local variable declarations</p>
<pre>#include &lt;oci.h&gt;
OCIBlobLocator *blob ;
FILE *fp ;
unsigned int amt, offset = 1 ;
</pre>
<p>Now we need a buffer to store the BLOB value and then write to the file from:</p>
<pre>#define MAXBUFLEN 5000
unsigned char buffer[MAXBUFLEN] ;
EXEC SQL VAR buffer IS RAW(MAXBUFLEN) ;
</pre>
<p>Allocate the BLOB host variable and select a BLOB which we will READ:</p>
<pre>EXEC SQL ALLOCATE :blob ;
EXEC SQL SELECT a_blob INTO :blob FROM lob_table WHERE ... ;
</pre>
<p>We can then open the external file to which we will write the BLOB value:</p>
<pre>fp = fopen((const char *)&#34;image.gif&#34;, (const char *)&#34;w&#34;) ;
</pre>
<p>If the buffer can hold the entire LOB value in a single READ we need to catch the NOT FOUND condition to signal LOB READ termination:</p>
<pre>EXEC SQL WHENEVER NOT FOUND GOTO end_of_lob ;
</pre>
<p>Now do our first READ. We set the amount to the maximum value of 4 Gigabytes. It is larger than our buffer so if the LOB doesn&#39;t fit we will READ using a polling mode:</p>
<pre>amt = 4294967295 ;
EXEC SQL LOB READ :amt FROM :blob AT :offset INTO :buffer ;
</pre>
<p>If we get here then it means that the buffer was not large enough to hold the entire LOB value, so we must write what we have using binary I/O and continue reading:</p>
<pre>(void) fwrite((void *)buffer, (size_t)MAXBUFLEN, (size_t)1, fp) ;
</pre>
<p>We use a standard polling method to continue reading with the LOB READ inside of an infinite loop. We can set up the NOT FOUND condition to terminate the loop:</p>
<pre>EXEC SQL WHENEVER NOT FOUND DO break ;
while (TRUE)
  {
</pre>
<p>During polling, the offset is not used so we can omit it in subsequent LOB READs. We need the amount, however, because it will tell us how much was READ in the last READ invocation</p>
<pre>    EXEC SQL LOB READ :amt FROM :blob INTO :buffer ;
    (void) fwrite((void *)buffer, (size_t)MAXBUFLEN, (size_t)1, fp) ;
  }
</pre>
<p>Here, we have reached the end of the LOB value. The amount holds the amount of the last piece that was READ. During polling, the amount for each interim piece was set to MAXBUFLEN, or the maximum size of our buffer:</p>
<pre>end_of_lob:
(void) fwrite((void *)buffer, (size_t)amt, (size_t)1, fp) ;
</pre>
<p>The basic structure of this code should allow internal LOBs of arbitrary length to be READ into local buffers and then written to external files. It has been modeled after OCI and PL/SQL. Refer to the examples in the Appendix of the <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> and to the appropriate chapter of the <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a> for further details.</p>
</div>
<!-- class="sect2" -->
<a id="i1006681"></a>
<div id="LNPCC4313" class="sect2">
<h3 class="sect2">Read a File, WRITE a BLOB Example</h3>
<p>In this example we will be reading data from a file with a known arbitrary length into a buffer and then writing the data from the buffer into an internal BLOB. Our buffer is small, so depending on the size of the file we are reading, we may be able to write the file data into the LOB in a single WRITE or we may be required to utilize a standard polling method instead.</p>
<p>First we start off with oci.h and some simple local variable declarations</p>
<pre>#include &lt;oci.h&gt;
OCIBlobLocator *blob ;
FILE *fp ;
unsigned int amt, offset = 1 ;
unsigned filelen, remainder, nbytes ;
boolean last ;
</pre>
<p>We need a buffer to store the file data and then write to the LOB:</p>
<pre>#define MAXBUFLEN 5000
unsigned char buffer[MAXBUFLEN] ;
EXEC SQL VAR buffer IS RAW(MAXBUFLEN) ;
</pre>
<p>We initialize an empty BLOB in an empty table and retrieve that BLOB into an ALLOCATEd locator and then fill it with the data from the file:</p>
<pre>EXEC SQL ALLOCATE :blob ;
EXEC SQL INSERT INTO lob_table (a_blob) VALUES (EMPTY_BLOB())
   RETURNING a_blob INTO :blob ;
</pre>
<p>Open the binary file and determine its length. The total amount we write to our BLOB is the actual length of the binary file:</p>
<pre>fp = fopen((const char *)&#34;image.gif&#34;, (const char *)&#34;r&#34;) ;
(void) fseek(fp, 0L, SEEK_END) ;
filelen = (unsigned int)ftell(fp) ;
amt = filelen ;
</pre>
<p>Set up our initial read of the file, determining the number of bytes to read based on our buffer size:</p>
<pre>if (filelen &gt; MAXBUFLEN)
    nbytes = MAXBUFLEN ;
else
    nbytes = filelen ;
</pre>
<p>Issue a file I/O operation to read <code>n</code> bytes of data from our file, <code>fp</code>, into our buffer and determine how much is left to read. Start reading from the beginning of the file:</p>
<pre>(void) fseek(fp, 0L, SEEK_SET) ;
(void) fread((void *)buffer, (size_t)nbytes, (size_t)1, fp) ;
remainder = filelen - nbytes ;
</pre>
<p>Based on what is left, either write the buffer in a single piece or initiate polling to write the data from the file in several smaller pieces:</p>
<pre>     if (remainder == 0)
     {
</pre>
<p>In this case we can write the data in a single piece:</p>
<pre>        EXEC SQL LOB WRITE ONE :amt
           FROM :buffer INTO :blob AT :offset ;
      }
     else
      {
</pre>
<p>Initiate the polling method for writing the data piece-wise into the LOB. First, to initiate the polling method, we use the FIRST orientation on the initial WRITE:</p>
<pre>        EXEC SQL LOB WRITE FIRST :amt
           FROM :buffer INTO :blob AT :offset ;
</pre>
<p>Set up a simple loop to implement the polling method:</p>
<pre>        last = FALSE ;
        EXEC SQL WHENEVER SQLERROR DO break ;
        do
          {
</pre>
<p>Calculate the number of bytes to read from the file and subsequently to WRITE into the destination LOB. Also determine if this will be our LAST piece:</p>
<pre>            if (remainder &gt; MAXBUFLEN)
                nbytes = MAXBUFLEN ;
            else
                {
                    nbytes = remainder ;
                    last = TRUE ;
                }
</pre>
<p>Again read the next <code>nbytes</code> from the file on the file system into our buffer. If any error occurs during a file read, we automatically set the next WRITE to be the LAST one:</p>
<pre>            if  fread((void *)buffer, (size_t)nbytes, (size_t)1, fp) != 1)
               last = TRUE ;
</pre>
<p>At this point, either WRITE the LAST piece or an interim NEXT piece which would indicate that there is still data left to be processed from the file:</p>
<pre>           if (last)
             {  
               EXEC SQL LOB WRITE LAST :amt
                  FROM :buffer INTO :blob  ;
             }
           
           else
             {
               EXEC SQL LOB WRITE NEXT :amt
                  FROM :buffer INTO :blob  ;
             }
           remainder -= nbytes ;
          } 
while (!last &amp;&amp; !feof(fp)) ;
</pre>
<p>This code example allows files of arbitrary length to be read into a local buffer and then written to a LOB. It has been modeled after OCI examples. Refer to the examples in the Appendix of the <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for further details.</p>
</div>
<!-- class="sect2" -->
<a id="i1006682"></a>
<div id="LNPCC4314" class="sect2">
<h3 class="sect2">lobdemo1.pc</h3>
<p>This program, <code>lobdemo1.pc</code>, illustrates several LOB embedded SQL statements. The source code is in the <code>demo</code> directory. The application uses a table named <code>license_table</code> whose columns are social security number, name, and a CLOB containing text summarizing driving offenses. Several simplified SQL operations of a typical motor vehicle department are modeled.<a id="sthref2032"></a></p>
<p>The possible actions are:</p>
<ul>
<li>
<p>Add new records.</p>
</li>
<li>
<p>List records by social security number.</p>
</li>
<li>
<p>List information in a record, given a social security number.</p>
</li>
<li>
<p>Append a new traffic violation to an existing CLOB&#39;s contents.</p>
</li>
</ul>
<pre>/***************************************************************************
  
  SCENARIO: 
  
  We consider the example of a database used to store driver&#39;s
  licenses. The licenses are stored as rows of a table containing
  three columns: the sss number of a person, his name in text and the 
  text summary of the info found in his license.

  The sss number is the driver&#39;s unique social security number.

  The name is the driver&#39;s given name as found on his ID card.

  The text summary is a summary of the information on the driver,
  including his driving record, which can be arbitrarily long and may
  contain comments and data regarding the person&#39;s driving ability. 

  APPLICATION OVERVIEW:

  This example demonstrate how a Pro*C client can handle the new LOB
  datatypes through PL/SQL routines. Demonstrated are mechanisms for
  accessing and storing lobs to tables and manipulating LOBs through
  the stored procedures available through the dbms_lob package.

****************************************************************************/

/***************************************************************************

   To run the demo:

   1. Execute the script, lobdemo1c.sql in SQL*Plus
   2. Precompile using Pro*C/C++
        proc lobdemo1 user=scott/tiger sqlcheck=full
   3. Compile/Link (This step is platform specific)

****************************************************************************/

/*** The following will be added to the creation script for this example ***
 *** This code can be found in lobdemo1c.sql                                ***

connect scott/tiger;

set serveroutput on;

Rem Make sure database has no license_table floating around

drop table license_table;

Rem ABSTRACTION:
Rem A license table reduces the notion of a driver&#39;s license into three 
Rem distinct components - a unique social security number (sss), 
Rem a name (name), and a text summary of miscellaneous information.

Rem IMPLEMENTATION:
Rem Our implementation follows this abstraction

create table license_table(
  sss char(9),
  name varchar2(50),
  txt_summary clob);

insert into license_table 
        values(&#39;971517006&#39;, &#39;Dennis Kernighan&#39;, 
        &#39;Wearing a Bright Orange Shirt - 31 Oct 1996&#39;);

insert into license_table 
        values(&#39;555001212&#39;, &#39;Eight H. Number&#39;, 
        &#39;Driving Under the Influence - 1 Jan 1997&#39;);

insert into license_table 
        values(&#39;010101010&#39;, &#39;P. Doughboy&#39;, 
        &#39;Impersonating An Oracle Employee - 10 Jan 1997&#39;);

insert into license_table
        values(&#39;555377012&#39;, &#39;Calvin N. Hobbes&#39;, 
        &#39;Driving Under the Influence - 30 Nov 1996&#39;);

select count(*) from license_table;

Rem Commit to save
commit;

****************************************************************************/

/**************************
 * Begin lobdemo1.pc code *
 **************************/

#define EX_SUCCESS       0
#define EX_FAILURE       1

#ifndef STDIO
# include &lt;stdio.h&gt;
#endif /* STDIO */

#ifndef SQLCA_ORACLE
# include &lt;sqlca.h&gt;
#endif /* SQLCA_ORACLE */

#ifndef OCI_ORACLE
# include &lt;oci.h&gt;
#endif /* OCI_ORACLE */

#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

#ifndef LOBDEMO1_ORACLE
# include &#34;lobdemo1.h&#34;
#endif /* LOBDEMO1_ORACLE */

/***********
 * Defines *
 ***********/
#define SSS_LENGTH 12
#define NAME_LENGTH 50 /* corresponds with max length of name in table */
#define BUFLEN 1024
#define MAXCRIME 5
#define DATELENGTH 12

/***********
 * Globals *
 ***********/

char *CrimeList[MAXCRIME]={ &#34;Driving Under the Influence&#34;, 
                            &#34;Grand Theft Auto&#34;, 
                            &#34;Driving Without a License&#34;,
                            &#34;Impersonating an Oracle Employee&#34;,
                            &#34;Wearing a Bright Orange Shirt&#34; };

char curdate[DATELENGTH];

/*********************** 
 * Function prototypes *
 ***********************/

#if defined(__STDC__)
  void GetDate( void );
  void PrintSQLError( void );
  void Driver( void );
  void ListRecords( void );
  void PrintCrime( OCIClobLocator *a_clob );
  void GetRecord( void );
  void NewRecord( void );
  char *NewCrime( void );
  void GetName( char *name_holder );
  void AppendToClob( OCIClobLocator *a_clob, char *charbuf );
  void AddCrime( void );
  void ReadClob( OCIClobLocator *a_clob );
  boolean GetSSS( char *suggested_sss );
#else
  void GetDate();
  void PrintSQLError( );
  void Driver( );
  void ListRecords( );
  void PrintCrime(/* OCIClobLocator *a_clob */);
  void GetRecord( );
  void NewRecord( );
  char *NewCrime( );
  void GetName(/* char *name_holder */);
  void AppendToClob(/* OCIClobLocator *a_clob, char *charbuf */);
  void AddCrime();
  boolean GetSSS(/* char *suggested_sss */);
#endif

/* 
 * NAME
 *   GetDate
 * DESCRIPTION
 *   Get date from user
 * LOB FEATURES
 *   none
 */ 

void GetDate()
{
  time_t now;

  now = time(NULL);
  strftime(curdate, 100, &#34; - %d %b %Y&#34;, localtime(&amp;now));
}

main()
{
  char * uid = &#34;scott/tiger&#34;;

  EXEC SQL WHENEVER SQLERROR DO PrintSQLError();

  printf(&#34;Connecting to license database account: %s \n&#34;, uid);
  EXEC SQL CONNECT :uid;
  
  GetDate();

  printf(&#34;\t*******************************\n&#34;);
  printf(&#34;\t* Welcome to the DMV Database *\n&#34;);
  printf(&#34;\t*******************************\n\n&#34;);
  printf(&#34;Today&#39;s Date is%s\n&#34;, curdate);

  Driver();

  EXEC SQL COMMIT RELEASE;

  return (EX_SUCCESS);
}

/* 
 * NAME
 *   Driver
 * DESCRIPTION
 *   Command Dispatch Routine
 * LOB FEATURES
 *   none
 */ 

void Driver()
{
  char choice[20];
  boolean done = FALSE;

  while (!done)
  {
    printf(&#34;\nLicense Options:\n&#34;);
    printf(&#34;\t(L)ist available records by SSS number\n&#34;);
    printf(&#34;\t(G)et information on a particular record\n&#34;);
    printf(&#34;\t(A)dd crime to a record\n&#34;);
    printf(&#34;\t(I)nsert new record to database\n&#34;);
    printf(&#34;\t(Q)uit\n&#34;);
    printf(&#34;Enter your choice: &#34;);

    fgets(choice, 20, stdin);
    switch(toupper(choice[0]))
    {
    case &#39;L&#39;:
      ListRecords();
      break;
    case &#39;G&#39;:
      GetRecord();
      break;
    case &#39;A&#39;:
      AddCrime();
      break;
    case &#39;I&#39;: 
      NewRecord();
      break;
    case &#39;Q&#39;:
      done = TRUE;
      break;
    default:
      break;
    }
  }
}

/* 
 * NAME
 *   ListRecords
 * DESCRIPTION
 *   List available records by sss number
 * LOB FEATURES
 *   none
 */ 

void ListRecords()
{
  char *select_sss = &#34;SELECT SSS FROM LICENSE_TABLE&#34;;
  char sss[10];

  EXEC SQL PREPARE sss_exec FROM :select_sss;
  EXEC SQL DECLARE sss_cursor CURSOR FOR sss_exec;
  EXEC SQL OPEN sss_cursor;

  printf(&#34;Available records:\n&#34;);

  EXEC SQL WHENEVER NOT FOUND DO break;
  while (TRUE)
    {
      EXEC SQL FETCH sss_cursor INTO :sss;
      printf(&#34;\t%s\n&#34;, sss);
    }
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL CLOSE sss_cursor;
}


/* 
 * NAME
 *   PrintCrime
 * DESCRIPTION
 *   Tests correctness of clob
 * LOB FEATURES
 *   OCIlobRead and OCILobGetLength
 */

void PrintCrime(a_clob)
  OCIClobLocator *a_clob; 
{ 
  ub4 lenp; 

  printf(&#34;\n&#34;);
  printf(&#34;=====================\n&#34;);
  printf(&#34; CRIME SHEET SUMMARY \n&#34;);
  printf(&#34;=====================\n\n&#34;);

  EXEC SQL LOB DESCRIBE :a_clob GET LENGTH INTO :lenp;

  if(lenp == 0) /* No crime on file */
    {
      printf(&#34;Record is clean\n&#34;);
    }
  else
    {
      ub4 amt = lenp;
      varchar *the_string = (varchar *)malloc(2 + lenp);

      the_string-&gt;len = (ub2)lenp;      

      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL LOB READ :amt
        FROM :a_clob INTO :the_string WITH LENGTH :lenp;
         
      printf(&#34;%.*s\n&#34;, the_string-&gt;len, the_string-&gt;arr);
      free(the_string);
    }
}

/* 
 * NAME
 *   GetRecord
 * DESCRIPTION
 *   Get license of single individual
 * LOB FEATURES
 *   allocate and select of blob and clob
 */ 

void GetRecord()
{
  char sss[SSS_LENGTH];
  
  if(GetSSS(sss) == TRUE)
    {
      OCIClobLocator *license_txt;
      char name[NAME_LENGTH]={&#39;\0&#39;};
      
      EXEC SQL ALLOCATE :license_txt;

      EXEC SQL SELECT name, txt_summary INTO :name, :license_txt 
        FROM license_table WHERE sss = :sss;
      
      printf(&#34;========================================================\n\n&#34;);
      printf(&#34;NAME: %s\tSSS: %s\n&#34;, name, sss);
      PrintCrime(license_txt);
      printf(&#34;\n\n========================================================\n&#34;);

      EXEC SQL FREE :license_txt;
    }
  else
    {
      printf(&#34;SSS Number Not Found\n&#34;);
    }
}

/* 
 * NAME
 *   NewRecord
 * DESCRIPTION
 *   Create new record in database
 * LOB FEATURES
 *   EMPTY_CLOB() and OCILobWrite
 */ 

void NewRecord()
{
  char sss[SSS_LENGTH], name[NAME_LENGTH] = {&#39;\0&#39;};
  
  if(GetSSS(sss) == TRUE)
    {
      printf(&#34;Record with that sss number already exists.\n&#34;);
      return;
    }
  else
    {
      OCIClobLocator *license_txt;
      
      EXEC SQL ALLOCATE :license_txt;
      
      GetName(name);

      EXEC SQL INSERT INTO license_table 
        VALUES (:sss, :name, empty_clob());

      EXEC SQL SELECT TXT_SUMMARY INTO :license_txt FROM LICENSE_TABLE
        WHERE SSS = :sss;

      printf(&#34;========================================================\n\n&#34;);
      printf(&#34;NAME: %s\tSSS: %s\n&#34;, name, sss);
      PrintCrime(license_txt);
      printf(&#34;\n\n========================================================\n&#34;);

      EXEC SQL FREE :license_txt;
    }
}

/* 
 * NAME
 *   NewCrime
 * DESCRIPTION
 *   Query user for new crime
 * LOB FEATURES
 *   None
 */ 

char *NewCrime()
{
  int  SuggestedCrimeNo;
  int  i;
  char crime[10];

  printf(&#34;Select from the following:\n&#34;);
  for(i = 1; i &lt;= MAXCRIME; i++)
    printf(&#34;(%d) %s\n&#34;, i, CrimeList[i-1]);

  printf(&#34;Crime (1-5): &#34;);
  fgets(crime, 10, stdin);
  SuggestedCrimeNo = atoi(crime);

  while((SuggestedCrimeNo &lt; 1) || (SuggestedCrimeNo &gt; MAXCRIME))
    {
      printf(&#34;Invalid selection\n&#34;);
      printf(&#34;Crime (1-5): &#34;);
      fgets(crime, 10, stdin);
      SuggestedCrimeNo = atoi(crime);
    }
  
  return CrimeList[SuggestedCrimeNo-1];
}

/* 
 * NAME
 *   AppendToClob
 * DESCRIPTION
 *   Append String charbuf to a Clob in the following way:
 *   if the contents of the clob a_clob were &lt;foo&gt; and the
 *   contents of charbuf were &lt;bar&gt;, after the append a_clob
 *   will contain: &lt;foo&gt;\n&lt;bar&gt; - &lt;curdate&gt;
 *   where &lt;curdate&gt; is today&#39;s date as obtained by the
 *   GetDate procedure.
 * LOB FEATURES
 *   OCILobWrite
 * NOTE
 *   Potentially, charbuf can be a very large string buffer.
 *   Furthermore, it should be noted that lobs and lob
 *   performance were designed for large data. Therefore, 
 *   users are encouraged to read and write large chunks of
 *   data to lobs. 
 */ 

void AppendToClob(a_clob, charbuf)
  OCIClobLocator *a_clob;
  char *charbuf;
{
  ub4 ClobLen, WriteAmt, Offset;
  int CharLen = strlen(charbuf);
  int NewCharbufLen = CharLen + DATELENGTH + 4; 
  varchar *NewCharbuf;
 
  NewCharbuf = (varchar *)malloc(2 + NewCharbufLen);

  NewCharbuf-&gt;arr[0] = &#39;\n&#39;;
  NewCharbuf-&gt;arr[1] = &#39;\0&#39;;
  strcat((char *)NewCharbuf-&gt;arr, charbuf);
  NewCharbuf-&gt;arr[CharLen + 1] = &#39;\0&#39;;
  strcat((char *)NewCharbuf-&gt;arr, curdate);

  NewCharbuf-&gt;len = NewCharbufLen;

  EXEC SQL LOB DESCRIBE :a_clob GET LENGTH INTO :ClobLen;

  WriteAmt = NewCharbufLen;
  Offset = ClobLen + 1;

  EXEC SQL LOB WRITE ONE :WriteAmt FROM :NewCharbuf
    WITH LENGTH :NewCharbufLen INTO :a_clob AT :Offset;

  free(NewCharbuf);
}

/* 
 * NAME
 *   AddCrime
 * DESCRIPTION
 *   Add a crime to a citizen&#39;s crime file
 * LOB FEATURES
 *   OCILobWrite
 */ 

void AddCrime()
{
  char sss[SSS_LENGTH];

  if (GetSSS(sss) == TRUE)
    {
      OCIClobLocator *license_txt;
      char *crimebuf;
      char  name[NAME_LENGTH] = {&#39;\0&#39;};
      
      EXEC SQL ALLOCATE :license_txt;    
      
      EXEC SQL SELECT txt_summary INTO :license_txt FROM license_table
        WHERE sss = :sss FOR UPDATE; 

      crimebuf = NewCrime();

      printf(&#34;Added %s to CrimeList\n&#34;, crimebuf);
      AppendToClob(license_txt, crimebuf);

      EXEC SQL SELECT name INTO :name FROM license_table WHERE sss = :sss;

      printf(&#34;NAME: %s SSS: %s\n&#34;, name, sss);
      PrintCrime(license_txt);

      EXEC SQL COMMIT;
      EXEC SQL FREE :license_txt;
    }
  else
    {
      printf(&#34;SSS Number Not Found\n&#34;);
    }
}

/* 
 * NAME
 *   GetSSS
 * DESCRIPTION
 *   Fills the passed buffer with a client-supplied social security number
 *   Returns FALSE if sss does not correspond to any entry in the database,
 *   else returns TRUE
 * LOB FEATURES
 *   none
 */

boolean GetSSS(suggested_sss)
  char *suggested_sss;
{
  int count = 0;
  int i;

  printf(&#34;Social Security Number: &#34;);
  fgets(suggested_sss, SSS_LENGTH, stdin);

  for(i = 0; ((suggested_sss[i] != &#39;\0&#39;) &amp;&amp; (i &lt; SSS_LENGTH)); i++)
    {
      if(suggested_sss[i] == &#39;\n&#39;) 
        suggested_sss[i]=&#39;\0&#39;;
    }

  EXEC SQL SELECT COUNT(*) INTO :count FROM license_table 
    WHERE sss = :suggested_sss;

  return (count != 0);
}

/* 
 * NAME
 *   GetName
 * DESCRIPTION
 *   Get name from user. 
 *   
 * LOB FEATURES
 *   none
 */

void GetName(name_holder)
  char *name_holder;
{
  int count=0;
  int i;

  printf(&#34;Enter Name: &#34;);
  fgets(name_holder, NAME_LENGTH + 1, stdin);

  for(i = 0; name_holder[i] != &#39;\0&#39;; i++)
    {
      if(name_holder[i] == &#39;\n&#39;) 
        name_holder[i]=&#39;\0&#39;;
    }

  return;
}

/* 
 * NAME
 *   PrintSQLError
 * DESCRIPTION
 *   Prints an error message using info in sqlca and calls exit.
 * COLLECTION FEATURES
 *   none
 */ 

void PrintSQLError()
{
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  printf(&#34;SQL error occurred...\n&#34;);
  printf(&#34;%.*s\n&#34;, (int)sqlca.sqlerrm.sqlerrml,
         (CONST char *)sqlca.sqlerrm.sqlerrmc);
  EXEC SQL ROLLBACK RELEASE;
  exit(EX_FAILURE);
}

</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_15ody.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_17obj.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>


</body></html>