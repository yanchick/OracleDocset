<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-78004"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Datatypes%20and%20Host%20Variables"></a><title>Datatypes and Host Variables</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-10T8:50:37Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53432-01"/>
<meta name="dcterms.isVersionOf" content="LNPCC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pc_03dbc.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pc_05adv.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53432-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/35</span> <!-- End Header -->
<div id="LNPCC3154" class="chapter"><a id="g52211"></a> <a id="i15407"></a>
<h1 class="chapter"><span class="secnum">4</span> Datatypes and Host Variables</h1>
<p>This chapter provides the basic information you need to write a Pro*C/C++ program. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i15971">Oracle Datatypes</a></p>
</li>
<li>
<p><a href="#i27299">Host Variables</a></p>
</li>
<li>
<p><a href="#i12463">Indicator Variables</a></p>
</li>
<li>
<p><a href="#i23767">VARCHAR Variables</a></p>
</li>
<li>
<p><a href="#i23772">Cursor Variables</a></p>
</li>
<li>
<p><a href="#i24497">CONTEXT Variables</a></p>
</li>
<li>
<p><a href="#i23634">Universal ROWIDs</a></p>
</li>
<li>
<p><a href="#i12467">Host Structures</a></p>
</li>
<li>
<p><a href="#i9172">Pointer Variables</a></p>
</li>
<li>
<p><a href="#i22611">Globalization Support</a></p>
</li>
<li>
<p><a href="#i22704">NCHAR Variables</a></p>
</li>
</ul>
<p>This chapter also includes several complete demonstration programs that you can study. These programs illustrate the techniques described. They are available on-line in your <code>demo</code> directory, so you can compile and run them, and modify them for your own uses.</p>
<a id="i15971"></a>
<div id="LNPCC3155" class="sect1">
<h2 class="sect1"><a id="sthref406"></a>Oracle Datatypes</h2>
<p>Oracle recognizes two kinds of datatypes: <span class="italic">internal</span> and <span class="italic">external</span>. Internal datatypes specify how Oracle stores column values in database tables, as well as the formats used to represent pseudocolumn values such as NULL, SYSDATE, USER, and so on. External datatypes specify the formats used to store values in input and output host variables.</p>
<p>For descriptions of the Oracle internal (also called <span class="italic">built-in</span>) datatypes, see <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference.</span></a></p>
<a id="i15555"></a>
<div id="LNPCC3156" class="sect2">
<h3 class="sect2">Internal Datatypes<a id="sthref407"></a></h3>
<p>For values stored in database columns, Oracle uses the internal datatypes shown in <a href="#g39946">Table 4-1</a></p>
<div id="LNPCC3157" class="tblformal">
<p class="titleintable"><a id="sthref408"></a><a id="g39946"></a>Table 4-1 Oracle Internal Datatypes</p>
<table class="cellalignment831" title="Oracle Internal Datatypes" summary="Oracle Internal Types" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t2">Name</th>
<th class="cellalignment832" id="r1c2-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t2" headers="r1c1-t2">
<p>VARCHAR2</p>
</td>
<td class="cellalignment833" headers="r2c1-t2 r1c2-t2">
<p>Variable-length character string, &lt;= 4000 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t2" headers="r1c1-t2">
<p>NVARCHAR2 or NCHAR VARYING</p>
</td>
<td class="cellalignment833" headers="r3c1-t2 r1c2-t2">
<p>Variable-length single-byte or National Character string,&lt;= 4000 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t2" headers="r1c1-t2">
<p>NUMBER</p>
</td>
<td class="cellalignment833" headers="r4c1-t2 r1c2-t2">
<p>Numeric value having precision and scale, represented in a base-100 format.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t2" headers="r1c1-t2">
<p>LONG</p>
</td>
<td class="cellalignment833" headers="r5c1-t2 r1c2-t2">
<p>Variable-length character string &lt;=2**31-1 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t2" headers="r1c1-t2">
<p>BINARY_FLOAT</p>
</td>
<td class="cellalignment833" headers="r6c1-t2 r1c2-t2">
<p>32-bit floating point number, 4 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t2" headers="r1c1-t2">
<p>BINARY_DOUBLE</p>
</td>
<td class="cellalignment833" headers="r7c1-t2 r1c2-t2">
<p>64-bit floating point number, 8 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t2" headers="r1c1-t2">
<p>TIMESTAMP</p>
</td>
<td class="cellalignment833" headers="r8c1-t2 r1c2-t2">
<p>Year, month, and day values of date, as well as hour, minute, and second values of time, 7 or 11 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t2" headers="r1c1-t2">
<p>DATE</p>
</td>
<td class="cellalignment833" headers="r9c1-t2 r1c2-t2">
<p>Fixed-length date + time value, 7 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t2" headers="r1c1-t2">
<p>INTERVAL YEAR</p>
</td>
<td class="cellalignment833" headers="r10c1-t2 r1c2-t2">
<p>Stores a period of time in years and months, 5 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t2" headers="r1c1-t2">
<p>INTERVAL DAY</p>
</td>
<td class="cellalignment833" headers="r11c1-t2 r1c2-t2">
<p>Stores a period of time in days, hours, minutes, and seconds, 11 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t2" headers="r1c1-t2">
<p>RAW</p>
</td>
<td class="cellalignment833" headers="r12c1-t2 r1c2-t2">
<p>Variable-length binary data, &lt;=2000 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r13c1-t2" headers="r1c1-t2">
<p>LONG RAW</p>
</td>
<td class="cellalignment833" headers="r13c1-t2 r1c2-t2">
<p>Variable-length binary data, &lt;=2**31-1 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r14c1-t2" headers="r1c1-t2">
<p>ROWID</p>
</td>
<td class="cellalignment833" headers="r14c1-t2 r1c2-t2">
<p>Binary value.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r15c1-t2" headers="r1c1-t2">
<p>UROWID</p>
</td>
<td class="cellalignment833" headers="r15c1-t2 r1c2-t2">
<p>Binary value, &lt;=4000 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r16c1-t2" headers="r1c1-t2">
<p>CHAR</p>
</td>
<td class="cellalignment833" headers="r16c1-t2 r1c2-t2">
<p>Fixed-length character string, &lt;=2000 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r17c1-t2" headers="r1c1-t2">
<p>NCHAR</p>
</td>
<td class="cellalignment833" headers="r17c1-t2 r1c2-t2">
<p>Fixed-length single-byte or National Character string, &lt;= 2000 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r18c1-t2" headers="r1c1-t2">
<p>CLOB</p>
</td>
<td class="cellalignment833" headers="r18c1-t2 r1c2-t2">
<p>Character data, &lt;= 4 Gbytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r19c1-t2" headers="r1c1-t2">
<p>NCLOB</p>
</td>
<td class="cellalignment833" headers="r19c1-t2 r1c2-t2">
<p>National Character Set data, &lt;= 4 Gbytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r20c1-t2" headers="r1c1-t2">
<p>BLOB</p>
</td>
<td class="cellalignment833" headers="r20c1-t2 r1c2-t2">
<p>Binary data, &lt;= 4 Gbytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r21c1-t2" headers="r1c1-t2">
<p>BFILE</p>
</td>
<td class="cellalignment833" headers="r21c1-t2 r1c2-t2">
<p>External file binary data, &lt;= 4 Gbytes.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>These internal datatypes can be quite different from C datatypes. For example, C has no datatype that is equivalent to the Oracle NUMBER datatype. However, NUMBERs can be converted between C datatypes such as <span class="bold">float</span> and <span class="bold">double</span>, with some restrictions. For example, the Oracle NUMBER datatype allows up to 38 decimal digits of precision, while no current C implementations can represent <span class="bold">double</span> with that degree of precision.</p>
<p>The Oracle NUMBER datatype represents values exactly (within the precision limits), while floating-point formats cannot represent values such as 10.0 exactly.</p>
<p>Use the LOB datatypes to store unstructured data (text, graphic images, video clips, or sound waveforms). BFILE data is stored in an operating system file outside the database. LOB types store <span class="italic">locators</span> that specify the location of the data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_16lob.htm#g1029071">Chapter 16, &#34;LOBs&#34;</a></div>
<p>NCHAR and NVARCHAR2 are used to store multibyte character data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i22611">&#34;Globalization Support&#34;</a> for a discussion of these datatypes</div>
</div>
<!-- class="sect2" -->
<a id="i15640"></a>
<div id="LNPCC3158" class="sect2">
<h3 class="sect2">External Datatypes</h3>
<p>As shown in <a href="#g39803">Table 4-2</a>, the external datatypes include all the internal datatypes plus several datatypes that closely match C constructs. For example, the STRING external datatype refers to a C null-terminated string.</p>
<div id="LNPCC3159" class="tblformal">
<p class="titleintable"><a id="sthref409"></a><a id="g39803"></a>Table 4-2 Oracle External Datatypes</p>
<table class="cellalignment831" title=" Oracle External Datatypes" summary="Oracle External Datatypes" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t5">Name</th>
<th class="cellalignment832" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t5" headers="r1c1-t5">
<p>VARCHAR2</p>
</td>
<td class="cellalignment833" headers="r2c1-t5 r1c2-t5">
<p>Variable-length character string, &lt;= 65535 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t5" headers="r1c1-t5">
<p>NUMBER</p>
</td>
<td class="cellalignment833" headers="r3c1-t5 r1c2-t5">
<p>Decimal number, represented using a base-100 format.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t5" headers="r1c1-t5">
<p>INTEGER</p>
</td>
<td class="cellalignment833" headers="r4c1-t5 r1c2-t5">
<p>Signed integer.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t5" headers="r1c1-t5">
<p>FLOAT</p>
</td>
<td class="cellalignment833" headers="r5c1-t5 r1c2-t5">
<p>Real number.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t5" headers="r1c1-t5">
<p>STRING</p>
</td>
<td class="cellalignment833" headers="r6c1-t5 r1c2-t5">
<p>Null-terminated variable length character string.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t5" headers="r1c1-t5">
<p>VARNUM</p>
</td>
<td class="cellalignment833" headers="r7c1-t5 r1c2-t5">
<p>Decimal number, like NUMBER, but includes representation length component.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t5" headers="r1c1-t5">
<p>LONG</p>
</td>
<td class="cellalignment833" headers="r8c1-t5 r1c2-t5">
<p>Fixed-length character string, up to 2**31-1 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t5" headers="r1c1-t5">
<p>VARCHAR</p>
</td>
<td class="cellalignment833" headers="r9c1-t5 r1c2-t5">
<p>Variable-length character string, &lt;= 65533 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t5" headers="r1c1-t5">
<p>ROWID</p>
</td>
<td class="cellalignment833" headers="r10c1-t5 r1c2-t5">
<p>Binary value, external length is system dependent.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t5" headers="r1c1-t5">
<p>DATE</p>
</td>
<td class="cellalignment833" headers="r11c1-t5 r1c2-t5">
<p>Fixed-length date/time value, 7 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r12c1-t5" headers="r1c1-t5">
<p>VARRAW</p>
</td>
<td class="cellalignment833" headers="r12c1-t5 r1c2-t5">
<p>Variable-length binary data, &lt;= 65533 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r13c1-t5" headers="r1c1-t5">
<p>RAW</p>
</td>
<td class="cellalignment833" headers="r13c1-t5 r1c2-t5">
<p>Fixed-length binary data, &lt;= 65535 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r14c1-t5" headers="r1c1-t5">
<p>LONG RAW</p>
</td>
<td class="cellalignment833" headers="r14c1-t5 r1c2-t5">
<p>Fixed-length binary data, &lt;= 2**31-1 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r15c1-t5" headers="r1c1-t5">
<p>UNSIGNED</p>
</td>
<td class="cellalignment833" headers="r15c1-t5 r1c2-t5">
<p>Unsigned integer.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r16c1-t5" headers="r1c1-t5">
<p>LONG VARCHAR</p>
</td>
<td class="cellalignment833" headers="r16c1-t5 r1c2-t5">
<p>Variable-length character string, &lt;=&nbsp;2**31-5 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r17c1-t5" headers="r1c1-t5">
<p>LONG VARRAW</p>
</td>
<td class="cellalignment833" headers="r17c1-t5 r1c2-t5">
<p>Variable-length binary data, &lt;= 2**31-5 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r18c1-t5" headers="r1c1-t5">
<p>CHAR</p>
</td>
<td class="cellalignment833" headers="r18c1-t5 r1c2-t5">
<p>Fixed-length character string, &lt;= 65535 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r19c1-t5" headers="r1c1-t5">
<p>CHARZ</p>
</td>
<td class="cellalignment833" headers="r19c1-t5 r1c2-t5">
<p>Fixed-length, null-terminated character string, &lt;= 65534 bytes.</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r20c1-t5" headers="r1c1-t5">
<p>CHARF</p>
</td>
<td class="cellalignment833" headers="r20c1-t5 r1c2-t5">
<p>Used in TYPE or VAR statements to force CHAR to default to CHAR, instead of VARCHAR2 or CHARZ.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Brief descriptions of the Oracle datatypes follow.</p>
<a id="i15737"></a>
<div id="LNPCC3160" class="sect3">
<h4 class="sect3">VARCHAR2 <a id="sthref410"></a></h4>
<p>You use the VARCHAR2 datatype to store variable-length character strings. The maximum length of a VARCHAR2 value is 64K bytes.</p>
<p>You specify the maximum length of a VARCHAR2(<span class="italic">n</span>) value in bytes, not characters. So, if a VARCHAR2(<span class="italic">n</span>) variable stores multibyte characters, its maximum length can be less than <span class="italic">n</span> characters.</p>
<p>When you precompile using the option CHAR_MAP=VARCHAR2, Oracle assigns the VARCHAR2 datatype to all host variables that you declare as <span class="bold">char[n]</span> or <span class="bold">char.</span></p>
<div id="LNPCC3161" class="sect4"><a id="sthref411"></a>
<h5 class="sect4">On Input</h5>
<p>Oracle reads the number of bytes specified for the input host variable, strips any trailing blanks, then stores the input value in the target database column. Be careful. An uninitialized host variable can contain NULLs. So, always blank-pad a character input host variable to its declared length, and do not null-terminate it.</p>
<p>If the input value is longer than the defined width of the database column, Oracle generates an error. If the input value contains nothing but blanks, Oracle treats it like a NULL.</p>
<p>Oracle can convert a character value to a NUMBER column value if the character value represents a valid number. Otherwise, Oracle generates an error.</p>
</div>
<!-- class="sect4" -->
<div id="LNPCC3162" class="sect4"><a id="sthref412"></a>
<h5 class="sect4">On Output</h5>
<p>Oracle returns the number of bytes specified for the output host variable, blank-padding if necessary. It then assigns the output value to the target host variable. If a NULL is returned, Oracle fills the host variable with blanks.</p>
<p>If the output value is longer than the declared length of the host variable, Oracle truncates the value before assigning it to the host variable. If there is an indicator variable associated with the host variable, Oracle sets it to the original length of the output value.</p>
<p>Oracle can convert NUMBER column values to character values. The length of the character host variable determines precision. If the host variable is too short for the number, scientific notation is used. For example, if you SELECT the column value 123456789 into a character host variable of length 6, Oracle returns the value &#39;1.2E08&#39;. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNPCC3163" class="sect3"><a id="sthref413"></a>
<h4 class="sect3">NUMBER <a id="sthref414"></a></h4>
<p>You use the NUMBER datatype to store fixed or floating-point numbers. You can specify precision and scale. The maximum precision of a NUMBER value is 38. The magnitude range is 1.0E-130 to 9.99...9E125 (38 nines followed by 88 zeroes). Scale can range from -84 to 127.</p>
<p>NUMBER values are stored in a variable-length format, starting with an exponent byte and followed by 19 mantissa bytes. The high-order bit of the exponent byte is a sign bit, which is set for positive numbers. The low-order 7 bits represent the magnitude.</p>
<p>The mantissa forms a 38-digit number with each byte representing 2 of the digits in a base-100 format. The sign of the mantissa is specified by the value of the first (left-most) byte. If greater than 101 then the mantissa is negative and the first digit of the mantissa is equal to the left-most byte minus 101.</p>
<p>On output, the host variable contains the number as represented internally by Oracle. To accommodate the largest possible number, the output host variable must be 22 bytes long. Only the bytes used to represent the number are returned. Oracle does not blank-pad or null-terminate the output value. If you need to know the length of the returned value, use the VARNUM datatype instead.</p>
<p>There is seldom a need to use this external datatype.</p>
</div>
<!-- class="sect3" -->
<a id="i15758"></a>
<div id="LNPCC3164" class="sect3">
<h4 class="sect3">INTEGER <a id="sthref415"></a><a id="sthref416"></a></h4>
<p>You use the INTEGER datatype to store numbers that have no fractional part. An integer is a signed, 2-byte, 4-byte or 8-byte binary number. The order of the bytes in a word is system dependent. You must specify a length for input and output host variables. On output, if the column value is a real number, Oracle truncates any fractional part. <a id="sthref417"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3165" class="sect3"><a id="sthref418"></a>
<h4 class="sect3">FLOAT <a id="sthref419"></a><a id="sthref420"></a></h4>
<p>You use the FLOAT datatype to store numbers that have a fractional part or that exceed the capacity of the INTEGER datatype. The number is represented using the floating-point format of your computer and typically requires 4 or 8 bytes of storage. You must specify a length for input and output host variables.</p>
<p>Oracle can represent numbers with greater precision than most floating-point implementations because the internal format of Oracle numbers is decimal. This can cause a loss of precision when fetching into a FLOAT variable.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3166" class="sect3"><a id="sthref421"></a>
<h4 class="sect3">STRING <a id="sthref422"></a><a id="sthref423"></a></h4>
<p>The STRING datatype is like the VARCHAR2 datatype, except that a STRING value is always null-terminated. When you precompile using the option CHAR_MAP=STRING, Oracle assigns the STRING datatype to all host variables that you declare as char[n] or char.</p>
<div id="LNPCC3167" class="sect4"><a id="sthref424"></a>
<h5 class="sect4">On Input</h5>
<p>Oracle uses the specified length to limit the scan for the null terminator. If a null terminator is not found, Oracle generates an error. If you do not specify a length, Oracle assumes the maximum length of 2000 bytes. The minimum length of a STRING value is 2 bytes. If the first character is a null terminator and the specified length is 2, Oracle inserts a null unless the column is defined as NOT NULL. If the column is defined as NOT NULL, an error occurs. An all-blank value is stored intact.</p>
</div>
<!-- class="sect4" -->
<div id="LNPCC3168" class="sect4"><a id="sthref425"></a>
<h5 class="sect4">On Output</h5>
<p>Oracle appends a null byte to the last character returned. If the string length exceeds the specified length, Oracle truncates the output value and appends a null byte. If a NULL is SELECTed, Oracle returns a null byte in the first character position. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness. <a id="sthref426"></a></p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNPCC3169" class="sect3"><a id="sthref427"></a>
<h4 class="sect3">VARNUM<a id="sthref428"></a></h4>
<p>The VARNUM datatype is like the NUMBER datatype, except that the first byte of a VARNUM variable stores the length of the representation.</p>
<p>On input, you must set the first byte of the host variable to the length of the value. On output, the host variable contains the length followed by the number as represented internally by Oracle. To accommodate the largest possible number, the host variable must be 22 bytes long. After SELECTing a column value into a VARNUM host variable, you can check the first byte to get the length of the value.</p>
<p>Normally, there is little reason to use this datatype.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3170" class="sect3"><a id="sthref429"></a>
<h4 class="sect3">LONG <a id="sthref430"></a></h4>
<p>You use the LONG datatype to store fixed-length character strings.</p>
<p>The LONG datatype is like the VARCHAR2 datatype, except that the maximum length of a LONG value is 2147483647 bytes or two gigabytes.</p>
</div>
<!-- class="sect3" -->
<a id="i15785"></a>
<div id="LNPCC3171" class="sect3">
<h4 class="sect3">VARCHAR <a id="sthref431"></a></h4>
<p>You use the VARCHAR datatype to store variable-length character strings. VARCHAR variables have a 2-byte length field followed by a &lt;=65533-byte string field. However, for VARCHAR array elements, the maximum length of the string field is 65530 bytes. When you specify the length of a VARCHAR variable, be sure to include 2 bytes for the length field. For longer strings, use the LONG VARCHAR datatype. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.</p>
</div>
<!-- class="sect3" -->
<a id="i15789"></a>
<div id="LNPCC3172" class="sect3">
<h4 class="sect3">ROWID<a id="sthref432"></a><a id="sthref433"></a><a id="sthref434"></a></h4>
<p>Rows in Index-Organized tables do not have permanent physical addresses. The logical ROWID is accessed using the same syntax as the physical ROWID. For this reason, the physical ROWID includes a <span class="italic">data object number</span> (schema objects in the same segment).</p>
<p><a id="sthref435"></a><a id="sthref436"></a>To support both logical and physical ROWIDs (as well as ROWIDs of non-Oracle tables) the <span class="italic">universal ROWID</span> was defined.</p>
<p>You can use character host variables to store rowids in a readable format. When you SELECT or FETCH a rowid into a character host variable, Oracle converts the binary value to an 18-byte character string and returns it in the format</p>
<pre>BBBBBBBB.RRRR.FFFF 
</pre>
<p>where BBBBBBBB is the block in the database file, RRRR is the row in the block (the first row is 0), and FFFF is the database file. These numbers are hexadecimal. For example, the rowid</p>
<pre>0000000E.000A.0007 
points to the 11th row in the 15th block in the 7th database file. 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i23634">&#34;Universal ROWIDs&#34;</a> for a further discussion of how to use the universal ROWID in applications.</div>
<p>Typically, you FETCH a rowid into a character host variable, then compare the host variable to the ROWID pseudocolumn in the WHERE clause of an UPDATE or DELETE statement. That way, you can identify the latest row fetched by a cursor.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_08arr.htm#i1776">&#34;Mimicking CURRENT OF&#34;</a>.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you need full portability or your application communicates with a non-Oracle database using Oracle Open Gateway technology, specify a maximum length of 256 (not 18) bytes when declaring the host variable. Though you can assume nothing about the host variable&#39;s contents, the host variable will behave normally in SQL statements.<a id="sthref437"></a></div>
</div>
<!-- class="sect3" -->
<div id="LNPCC3173" class="sect3"><a id="sthref438"></a>
<h4 class="sect3">DATE<a id="sthref439"></a></h4>
<p><a id="i38637"></a>You use the DATE datatype to store dates and times in 7-byte, fixed-length fields. As <a href="#BEHEDBHA">Table 4-3</a> shows, the century, year, month, day, hour (in 24-hour format), minute, and second are stored in that order from left to right.</p>
<div id="LNPCC3174" class="tblformal">
<p class="titleintable"><a id="sthref440"></a><a id="BEHEDBHA"></a>Table 4-3 DATE Format</p>
<table class="cellalignment831" title="DATE Format" summary="Date Format" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t9">Date Datatype</th>
<th class="cellalignment832" id="r1c2-t9">Century</th>
<th class="cellalignment832" id="r1c3-t9">Year</th>
<th class="cellalignment832" id="r1c4-t9">Month</th>
<th class="cellalignment832" id="r1c5-t9">Day</th>
<th class="cellalignment832" id="r1c6-t9">Hour</th>
<th class="cellalignment832" id="r1c7-t9">Minutes</th>
<th class="cellalignment832" id="r1c8-t9">Second</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t9" headers="r1c1-t9">
<p><span class="bold">Byte</span></p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c2-t9">
<p>1</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c3-t9">
<p>2</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c4-t9">
<p>3</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c5-t9">
<p>4</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c6-t9">
<p>5</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c7-t9">
<p>6</p>
</td>
<td class="cellalignment833" headers="r2c1-t9 r1c8-t9">
<p>7</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t9" headers="r1c1-t9">
<p><span class="bold">Meaning</span></p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c2-t9">
<p>Century</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c3-t9">
<p>Year</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c4-t9">
<p>Month</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c5-t9">
<p>Day</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c6-t9">
<p>Hour</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c7-t9">
<p>Minute</p>
</td>
<td class="cellalignment833" headers="r3c1-t9 r1c8-t9">
<p>Second</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t9" headers="r1c1-t9">
<p><span class="bold">Example</span></p>
<p><span class="bold">17-OCT-1994 at 1:23:12 PM</span></p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c2-t9">
<p>119</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c3-t9">
<p>194</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c4-t9">
<p>10</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c5-t9">
<p>17</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c6-t9">
<p>14</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c7-t9">
<p>24</p>
</td>
<td class="cellalignment833" headers="r4c1-t9 r1c8-t9">
<p>13</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The century and year bytes are in excess-100 notation. The hour, minute, and second are in excess-1 notation. Dates before the Common Era (B.C.E.) are less than 100. The epoch is January 1, 4712 B.C.E. For this date, the century byte is 53 and the year byte is 88. The hour byte ranges from 1 to 24. The minute and second bytes range from 1 to 60. The time defaults to midnight (1, 1, 1).</p>
<p>Normally, there is little reason to use the DATE datatype.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3175" class="sect3"><a id="sthref441"></a>
<h4 class="sect3">RAW<a id="sthref442"></a></h4>
<p>You use the RAW datatype to store binary data or byte strings. The maximum length of a RAW value is 65535 bytes.</p>
<p>RAW data is like CHARACTER data, except that Oracle assumes nothing about the meaning of RAW data and does no character set conversions when you transmit RAW data from one system to another.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3176" class="sect3"><a id="sthref443"></a>
<h4 class="sect3">VARRAW <a id="sthref444"></a></h4>
<p>You use the VARRAW datatype to store variable-length binary data or byte strings. The VARRAW datatype is like the RAW datatype, except that VARRAW variables have a 2-byte length field followed by a data field &lt;= 65533 bytes in length. For longer strings, use the LONG VARRAW datatype.</p>
<p>When you specify the length of a VARRAW variable, be sure to include 2 bytes for the length field. The first two bytes of the variable must be interpretable as an integer.</p>
<p>To get the length of a VARRAW variable, simply refer to its length field.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3177" class="sect3"><a id="sthref445"></a>
<h4 class="sect3">LONG RAW<a id="sthref446"></a></h4>
<p>You use the LONG RAW datatype to store binary data or byte strings. The maximum length of a LONG RAW value is 2147483647 bytes or two gigabytes.</p>
<p>LONG RAW data is like LONG data, except that Oracle assumes nothing about the meaning of LONG RAW data and does no character set conversions when you transmit LONG RAW data from one system to another.</p>
</div>
<!-- class="sect3" -->
<a id="i15890"></a>
<div id="LNPCC3178" class="sect3">
<h4 class="sect3">UNSIGNED <a id="sthref447"></a></h4>
<p>You use the UNSIGNED datatype to store unsigned integers. An unsigned integer is a binary number of 2 or 4 bytes. The order of the bytes in a word is system dependent. You must specify a length for input and output host variables. On output, if the column value is a floating-point number, Oracle truncates the fractional part.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3179" class="sect3"><a id="sthref448"></a>
<h4 class="sect3">LONG VARCHAR <a id="sthref449"></a></h4>
<p>You use the LONG VARCHAR datatype to store variable-length character strings. LONG VARCHAR variables have a 4-byte length field followed by a string field. The maximum length of the string field is 2147483643 (2**31 - 5) bytes. When you specify the length of a LONG VARCHAR for use in a VAR or TYPE statement, do not include the 4 length bytes.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3180" class="sect3"><a id="sthref450"></a>
<h4 class="sect3">LONG VARRAW <a id="sthref451"></a></h4>
<p>You use the LONG VARRAW datatype to store variable-length binary data or byte strings. LONG VARRAW variables have a 4-byte length field followed by a data field. The maximum length of the data field is 2147483643 bytes. When you specify the length of a LONG VARRAW for use in a VAR or TYPE statement, do not include the 4 length bytes.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3181" class="sect3"><a id="sthref452"></a>
<h4 class="sect3">CHAR <a id="sthref453"></a></h4>
<p>You use the CHAR datatype to store fixed-length character strings. The maximum length of a CHAR value is 65535 bytes.</p>
<div id="LNPCC3182" class="sect4"><a id="sthref454"></a>
<h5 class="sect4">On Input</h5>
<p>Oracle reads the number of bytes specified for the input host variable, does <span class="italic">not</span> strip trailing blanks, then stores the input value in the target database column.</p>
<p>If the input value is longer than the defined width of the database column, Oracle generates an error. If the input value is all-blank, Oracle treats it like a character value.</p>
</div>
<!-- class="sect4" -->
<div id="LNPCC3183" class="sect4"><a id="sthref455"></a>
<h5 class="sect4">On Output</h5>
<p>Oracle returns the number of bytes specified for the output host variable, doing blank-padding if necessary, then assigns the output value to the target host variable. If a NULL is returned, Oracle fills the host variable with blanks.</p>
<p>If the output value is longer than the declared length of the host variable, Oracle truncates the value before assigning it to the host variable. If an indicator variable is available, Oracle sets it to the original length of the output value. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i15909"></a>
<div id="LNPCC3184" class="sect3">
<h4 class="sect3">CHARZ <a id="sthref456"></a></h4>
<p>When DBMS=V7 or V8, Oracle, by default, assigns the CHARZ datatype to all character host variables in a Pro*C/C++ program. The CHARZ datatype indicates fixed-length, null-terminated character strings. The maximum length of a CHARZ value is 65534 bytes.</p>
<div id="LNPCC3185" class="sect4"><a id="sthref457"></a>
<h5 class="sect4">On Input</h5>
<p>The CHARZ and STRING datatypes work the same way. You must null-terminate the input value. The null terminator serves only to delimit the string; it does not become part of the stored data.</p>
</div>
<!-- class="sect4" -->
<div id="LNPCC3186" class="sect4"><a id="sthref458"></a>
<h5 class="sect4">On Output</h5>
<p>CHARZ host variables are blank-padded if necessary, then null-terminated. The output value is always null-terminated, even if data must be truncated. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNPCC3187" class="sect3"><a id="sthref459"></a>
<h4 class="sect3">CHARF <a id="sthref460"></a></h4>
<p>The CHARF datatype is used in EXEC SQL TYPE and EXEC SQL VAR statements. When you precompile with the DBMS option set to V7 or V8, specifying the external datatype CHAR in a TYPE or VAR statement equivalences the C type or variable to the fixed-length, null-terminated datatype CHARZ.</p>
<p>However, you might not want either of these type equivalences, but rather an equivalence to the fixed-length external type CHAR. If you use the external type CHARF, the C type or variable is <span class="italic">always</span> equivalenced to the fixed-length ANSI datatype CHAR, regardless of the DBMS value. CHARF never allows the C type to be equivalenced to VARCHAR2 or CHARZ. Alternatively, when you set the option CHAR_MAP=CHARF, all host variables declared as char[n] or char are equivalenced to a CHAR string. If a NULL is selected explicitly, the value in the host variable is indeterminate. The value of the indicator variable needs to be checked for NULL-ness.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i27375"></a>
<div id="LNPCC3188" class="sect2">
<h3 class="sect2">Additional External Datatypes</h3>
<p>This section describes additional external datatypes.</p>
<a id="i38099"></a>
<div id="LNPCC3189" class="sect3">
<h4 class="sect3">Datetime and Interval Datatypes</h4>
<p>The datetime and interval datatypes are briefly summarized here.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more a more complete discussion, see <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="sect3" -->
<div id="LNPCC3190" class="sect3"><a id="sthref461"></a>
<h4 class="sect3">ANSI DATE</h4>
<p><a id="sthref462"></a><a id="sthref463"></a>The <code>ANSI</code> <code>DATE</code> is based on the <code>DATE</code>, but contains no time portion. (Therefore, it also has no time zone.) <code>ANSI</code> <code>DATE</code> follows the <code>ANSI</code> specification for the <code>DATE</code> datatype. When assigning an <code>ANSI</code> <code>DATE</code> to a <code>DATE</code> or a timestamp datatype, the time portion of the Oracle <code>DATE</code> and the timestamp are set to zero. When assigning a <code>DATE</code> or a timestamp to an <code>ANSI</code> <code>DATE</code>, the time portion is ignored.</p>
<p>You are encouraged to instead use the <code>TIMESTAMP</code> datatype which contains both date and time.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3191" class="sect3"><a id="sthref464"></a>
<h4 class="sect3">TIMESTAMP<a id="sthref465"></a><a id="sthref466"></a></h4>
<p>The <code>TIMESTAMP</code> datatype is an extension of the <code>DATE</code> datatype. It stores the year, month, and day of the <code>DATE</code> datatype, plus the hour, minute, and second values. It has no time zone. The <code>TIMESTAMP</code> datatype has the form:</p>
<pre>TIMESTAMP(fractional_seconds_precision) 
</pre>
<p>where <code><span class="codeinlineitalic">fractional_seconds_precision</span></code> (which is optional) specifies the number of digits in the fractional part of the <code>SECOND</code> datetime field and can be a number in the range 0 to 9. The default is 6.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3192" class="sect3"><a id="sthref467"></a>
<h4 class="sect3">TIMESTAMP WITH TIME ZONE<a id="sthref468"></a><a id="sthref469"></a></h4>
<p><code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> (<code>TSTZ</code>) is a variant of <code>TIMESTAMP</code> that includes an explicit time zone displacement in its value. The time zone displacement is the difference (in hours and minutes) between local time and UTC (Coordinated Universal Time&mdash;formerly Greenwich Mean Time). The <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> ZONE datatype has the form:</p>
<pre>TIMESTAMP(fractional_seconds_precision) WITH TIME ZONE
</pre>
<p>where <code><span class="codeinlineitalic">fractional_seconds_precision</span></code> optionally specifies the number of digits in the fractional part of the <code>SECOND</code> datetime field and can be a number in the range 0 to 9. The default is 6.</p>
<p>Two <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values are considered identical if they represent the same instant in UTC, regardless of the <code>TIME</code> <code>ZONE</code> offsets stored in the data.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3193" class="sect3"><a id="sthref470"></a>
<h4 class="sect3">TIMESTAMP WITH LOCAL TIME ZONE<a id="sthref471"></a><a id="sthref472"></a></h4>
<p><code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code> (<code>TSLTZ</code>) is another variant of <code>TIMESTAMP</code> that includes a time zone displacement in its value. Storage is in the same format as for <code>TIMESTAMP</code>. This type differs from <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> in that data stored in the database is normalized to the database time zone, and the time zone displacement is not stored as part of the column data. When users retrieve the data, Oracle returns it in the users&#39; local session time zone.</p>
<p>The time zone displacement is the difference (in hours and minutes) between local time and UTC (Coordinated Universal Time&mdash;formerly Greenwich Mean Time). The <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> ZONE datatype has the form:</p>
<pre>TIMESTAMP(fractional_seconds_precision) WITH LOCAL TIME ZONE
</pre>
<p>where <code><span class="codeinlineitalic">fractional_seconds_precision</span></code> optionally specifies the number of digits in the fractional part of the <code>SECOND</code> datetime field and can be a number in the range 0 to 9. The default is 6.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3194" class="sect3"><a id="sthref473"></a>
<h4 class="sect3">INTERVAL YEAR TO MONTH<a id="sthref474"></a><a id="sthref475"></a></h4>
<p><code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> stores a period of time using the <code>YEAR</code> and <code>MONTH</code> datetime fields. The <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> datatype has the form:</p>
<pre>INTERVAL YEAR(year_precision) TO MONTH
</pre>
<p>where the optional <code><span class="codeinlineitalic">year_precision</span></code> is the number of digits in the <code>YEAR</code> datetime field. The default value of <code><span class="codeinlineitalic">year_precision</span></code> is 2.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3195" class="sect3"><a id="sthref476"></a>
<h4 class="sect3">INTERVAL DAY TO SECOND<a id="sthref477"></a><a id="sthref478"></a></h4>
<p><code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> stores a period of time in terms of days, hours, minutes, and seconds. The <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> datatype has the form:</p>
<pre>INTERVAL DAY (day_precision) TO SECOND(fractional_seconds_precision)
</pre>
<p>where:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">day_precision</span></code> is the number of digits in the <code>DAY</code> datetime field. It is optional. Accepted values are 0 to 9. The default is 2.</p>
</li>
</ul>
<p><code><span class="codeinlineitalic">fractional_seconds_precision</span></code> is the number of digits in the fractional part of the <code>SECOND</code> datetime field. It is optional. Accepted values are 0 to 9. The default is 6.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3196" class="sect3"><a id="sthref479"></a>
<h4 class="sect3"><a id="sthref480"></a>Avoiding Unexpected Results Using Datetime</h4>
<div class="infobox-note">
<p class="notep1">Note:</p>
To avoid unexpected results in your DML operations on datetime data, you can verify the database and session time zones by querying the built-in SQL functions <code>DBTIMEZONE</code> and <code>SESSIONTIMEZONE</code>. If the time zones have not been set manually, Oracle uses the operating system time zone by default. If the operating system time zone is not a valid Oracle time zone, Oracle uses UTC as the default value.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i27299"></a>
<div id="LNPCC3197" class="sect1">
<h2 class="sect1">Host Variables</h2>
<p>Host variables are the key to communication between your host program and Oracle. Typically, a precompiler program inputs data from a host variable to Oracle, and Oracle outputs data to a host variable in the program. Oracle stores input data in database columns, and stores output data in program host variables.</p>
<p>A host variable can be any arbitrary C expression that resolves to a scalar type. But, a host variable must also be an <span class="italic">lvalue</span>. Host arrays of most host variables are also supported.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i9172">&#34;Pointer Variables&#34;</a><a id="sthref481"></a></div>
<a id="i9042"></a>
<div id="LNPCC3198" class="sect2">
<h3 class="sect2">Host Variable Declaration</h3>
<p>You declare a host variable according to the rules of the C programming language, specifying a C datatype supported by the Oracle program interface. The C datatype must be compatible with that of the source or target database column.</p>
<p><a id="sthref482"></a>If MODE=ORACLE, you do not have to declare host variables in a special Declare Section. However, if you do not use a Declare Section, the FIPS flagger warns you about this, as the Declare Section is part of the ANSI SQL Standard.<a id="sthref483"></a> If CODE=CPP (you are compiling C++ code) or PARSE=NONE or PARSE=PARTIAL, then you must have a Declare Section.</p>
<p><a href="#g39867">Table 4-4</a> shows the C datatypes and the pseudotypes that you can use when declaring host variables. Only these datatypes can be used for host variables.</p>
<div id="LNPCC3199" class="tblformal">
<p class="titleintable"><a id="sthref484"></a><a id="g39867"></a>Table 4-4 C Datatypes for Host Variables</p>
<table class="cellalignment831" title=" C Datatypes for Host Variables" summary="C Datatypes for Host Variables" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t13">C Datatype or Pseudotype</th>
<th class="cellalignment832" id="r1c2-t13">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t13" headers="r1c1-t13">
<p>char</p>
</td>
<td class="cellalignment833" headers="r2c1-t13 r1c2-t13">
<p>single character</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t13" headers="r1c1-t13">
<p>char[n]</p>
</td>
<td class="cellalignment833" headers="r3c1-t13 r1c2-t13">
<p>n-character array (string)</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t13" headers="r1c1-t13">
<p>int</p>
</td>
<td class="cellalignment833" headers="r4c1-t13 r1c2-t13">
<p>integer</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t13" headers="r1c1-t13">
<p>short</p>
</td>
<td class="cellalignment833" headers="r5c1-t13 r1c2-t13">
<p>small integer</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t13" headers="r1c1-t13">
<p>long</p>
</td>
<td class="cellalignment833" headers="r6c1-t13 r1c2-t13">
<p>large integer</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t13" headers="r1c1-t13">
<p>long long</p>
</td>
<td class="cellalignment833" headers="r7c1-t13 r1c2-t13">
<p>very large (8-byte) integer</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t13" headers="r1c1-t13">
<p>float</p>
</td>
<td class="cellalignment833" headers="r8c1-t13 r1c2-t13">
<p>floating-point number (usually single precision)</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t13" headers="r1c1-t13">
<p>double</p>
</td>
<td class="cellalignment833" headers="r9c1-t13 r1c2-t13">
<p>floating-point number (always double precision)</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t13" headers="r1c1-t13">
<p>VARCHAR[n]</p>
</td>
<td class="cellalignment833" headers="r10c1-t13 r1c2-t13">
<p>variable-length string</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><a href="#g39898">Table 4-5</a> shows the compatible Oracle internal datatypes.</p>
<div id="LNPCC3200" class="tblformal">
<p class="titleintable"><a id="sthref485"></a><a id="g39898"></a>Table 4-5 C to Oracle Datatype Compatibility</p>
<table class="cellalignment831" title=" C to Oracle Datatype Compatibility" summary="C to Oracle Datatype Compatibility" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t14">Internal Type</th>
<th class="cellalignment832" id="r1c2-t14">C Type</th>
<th class="cellalignment832" id="r1c3-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t14" headers="r1c1-t14">
<p>VARCHAR2(Y)</p>
<p>(Note 1)</p>
</td>
<td class="cellalignment833" headers="r2c1-t14 r1c2-t14">
<p>char</p>
</td>
<td class="cellalignment833" headers="r2c1-t14 r1c3-t14">
<p>single character</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t14" headers="r1c1-t14">
<p>CHAR(X)</p>
<p>(Note 1)</p>
</td>
<td class="cellalignment833" headers="r3c1-t14 r1c2-t14">
<p>char[n]</p>
<p>VARCHAR[n]</p>
<p>int</p>
<p>short</p>
<p>long</p>
<p>long long</p>
<p>float</p>
<p>double</p>
</td>
<td class="cellalignment833" headers="r3c1-t14 r1c3-t14">
<p>n-byte character array</p>
<p>n-byte variable-length character array</p>
<p>integer</p>
<p>small integer</p>
<p>large integer</p>
<p>very large (8-byte) integer</p>
<p>floating-point number</p>
<p>double-precision floating-point</p>
<p>number</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t14" headers="r1c1-t14">
<p>NUMBER</p>
</td>
<td class="cellalignment833" headers="r4c1-t14 r1c2-t14">
<p>int</p>
</td>
<td class="cellalignment833" headers="r4c1-t14 r1c3-t14">
<p>integer</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t14" headers="r1c1-t14">
<p>NUMBER(P,S)</p>
<p>(Note 2)</p>
</td>
<td class="cellalignment833" headers="r5c1-t14 r1c2-t14">
<p>short</p>
<p>int</p>
<p>long</p>
<p>float</p>
<p>double</p>
<p>char</p>
<p>char[n]</p>
<p>VARCHAR[n]</p>
</td>
<td class="cellalignment833" headers="r5c1-t14 r1c3-t14">
<p>small integer</p>
<p>integer</p>
<p>large integer</p>
<p>floating-point number</p>
<p>double-precision floating-point</p>
<p>number</p>
<p>single character</p>
<p>n-byte character array</p>
<p>n-byte variable-length character array</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t14" headers="r1c1-t14">
<p>DATE</p>
</td>
<td class="cellalignment833" headers="r6c1-t14 r1c2-t14">
<p>char[n]</p>
<p>VARCHAR[n]</p>
</td>
<td class="cellalignment833" headers="r6c1-t14 r1c3-t14">
<p>n-byte character array</p>
<p>n-byte variable-length character array</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t14" headers="r1c1-t14">
<p>LONG</p>
</td>
<td class="cellalignment833" headers="r7c1-t14 r1c2-t14">
<p>char[n]</p>
<p>VARCHAR[n]</p>
</td>
<td class="cellalignment833" headers="r7c1-t14 r1c3-t14">
<p>n-byte character array</p>
<p>n-byte variable-length character array</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t14" headers="r1c1-t14">
<p>RAW(X)</p>
<p>(Note 1)</p>
</td>
<td class="cellalignment833" headers="r8c1-t14 r1c2-t14">
<p>unsigned char[n]</p>
<p>VARCHAR[n]</p>
</td>
<td class="cellalignment833" headers="r8c1-t14 r1c3-t14">
<p>n-byte character array</p>
<p>n-byte variable-length character array</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t14" headers="r1c1-t14">
<p>LONG RAW</p>
</td>
<td class="cellalignment833" headers="r9c1-t14 r1c2-t14">
<p>unsigned char[n]</p>
<p>VARCHAR[n]</p>
</td>
<td class="cellalignment833" headers="r9c1-t14 r1c3-t14">
<p>n-byte character array</p>
<p>n-byte variable-length character array</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r10c1-t14" headers="r1c1-t14">
<p>ROWID</p>
</td>
<td class="cellalignment833" headers="r10c1-t14 r1c2-t14">
<p>unsigned char[n]</p>
<p>VARCHAR[n]</p>
</td>
<td class="cellalignment833" headers="r10c1-t14 r1c3-t14">
<p>n-byte character array</p>
<p>n-byte variable-length character array</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r11c1-t14" headers="r1c1-t14">
<p>Notes:</p>
<p>1. X ranges from 1 to 2000. 1 is the default value. Y ranges from 1 to 4000.</p>
<p>2. P ranges from 1 to 38. S ranges from -84 to 127.</p>
</td>
<td class="cellalignment833" headers="r11c1-t14 r1c2-t14">&nbsp;</td>
<td class="cellalignment833" headers="r11c1-t14 r1c3-t14">&nbsp;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>One-dimensional arrays of simple C types can also serve as host variables. For char[n] and VARCHAR[n], <span class="italic">n</span> specifies the maximum string length, <span class="italic">not</span> the number of strings in the array. Two-dimensional arrays are allowed only for char[m][n] and VARCHAR[m][n], where <span class="italic">m</span> specifies the number of strings in the array and <span class="italic">n</span> specifies the maximum string length.</p>
<p>Pointers to simple C types are supported. Pointers to char[n] and VARCHAR[n] variables should be declared as pointer to char or VARCHAR (with no length specification). Arrays of pointers, however, are not supported.</p>
<div id="LNPCC3201" class="sect3"><a id="sthref486"></a>
<h4 class="sect3">Storage-Class Specifiers</h4>
<p>Pro*C/C++ lets you use the <span class="bold">auto</span>, <span class="bold">extern</span>, and <span class="bold">static</span> storage-class specifiers when you declare host variables. However, you cannot use the <span class="bold">register</span> storage-class specifier to store host variables, since the precompiler takes the address of host variables by placing an ampersand (&amp;) before them. Following the rules of C, you can use the <span class="bold">auto</span> storage class specifier only within a block.</p>
<p>To comply with the ANSI C standard, the Pro*C/C++ Precompiler provides the ability to declare an <span class="bold">extern char[n]</span> host variable with or without a maximum length, as the following examples shows:</p>
<pre>extern char  protocol[15]; 
extern char  msg[]; 
</pre>
<p>However, you should always specify the maximum length. In the last example, if <span class="italic">msg</span> is an output host variable declared in one precompilation unit but defined in another, the precompiler has no way of knowing its maximum length. If you have not allocated enough storage for <span class="italic">msg</span> in the second precompilation unit, you might corrupt memory. (Usually, &#34;enough&#34; is the number of bytes in the longest column value that might be SELECTed or FETCHed into the host variable, plus one byte for a possible null terminator.)</p>
<p>If you neglect to specify the maximum length for an <span class="bold">extern char[ ]</span> host variable, the precompiler issues a warning message. The precompiler also assumes that the host variable will store a CHARACTER column value, which cannot exceed 255 characters in length. So, if you want to SELECT or FETCH a VARCHAR2 or a LONG column value of length greater than 255 characters into the host variable, you <span class="italic">must</span> specify a maximum length.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCC3202" class="sect3"><a id="sthref487"></a>
<h4 class="sect3">Type Qualifiers</h4>
<p>You can also use the <span class="bold">const</span> and <span class="bold">volatile</span> type qualifiers when you declare host variables.</p>
<p>A <span class="bold">const</span> host variable must have a constant value, that is, your program cannot change its initial value. A <span class="bold">volatile</span> host variable can have its value changed in ways unknown to your program (for example, by a device attached to the system).</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i8735"></a>
<div id="LNPCC3203" class="sect2">
<h3 class="sect2">Host Variable Referencing</h3>
<p>You use host variables in SQL data manipulation statements. A host variable must be prefixed with a colon (:) in SQL statements but must not be prefixed with a colon in C statements, as the following example shows:<a id="sthref488"></a></p>
<pre>char    buf[15];
int     emp_number; 
float   salary; 
... 
gets(buf); 
emp_number = atoi(buf); 

EXEC SQL SELECT sal INTO :salary FROM emp 
    WHERE empno = :emp_number; 
</pre>
<p>Though it might be confusing, you can give a host variable the same name as an Oracle table or column, as this example shows:</p>
<pre>int     empno; 
char    ename[10]; 
float   sal; 
... 
EXEC SQL SELECT ename, sal INTO :ename, :sal FROM emp 
    WHERE empno = :empno; 
</pre>
<div id="LNPCC3204" class="sect3"><a id="sthref489"></a>
<h4 class="sect3">Restrictions</h4>
<p>A host variable name is a C identifier, hence it must be declared and referenced in the same upper/lower case format. It cannot substitute for a column, table, or other Oracle object in a SQL statement, and must not be an Oracle reserved word.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_abres.htm#CJACFAAC">Appendix A, &#34; Reserved Words, Keywords, and Namespaces&#34;</a>.<a id="sthref490"></a></div>
<p>A host variable must resolve to an address in the program. For this reason, function calls and numeric expressions cannot serve as host variables. The following code is <span class="italic">invalid</span>:</p>
<pre>#define MAX_EMP_NUM    9000 
... 
int get_dept(); 
... 
EXEC SQL INSERT INTO emp (empno, ename, deptno) VALUES 
    (:MAX_EMP_NUM + 10, &#39;CHEN&#39;, :get_dept()); <a id="sthref491"></a><a id="sthref492"></a><a id="sthref493"></a>
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i12463"></a>
<div id="LNPCC3205" class="sect1">
<h2 class="sect1">Indicator Variables <a id="sthref494"></a><a id="sthref495"></a></h2>
<p>You can associate every host variable with an optional indicator variable. An indicator variable must be defined as a 2-byte integer and, in SQL statements, must be prefixed with a colon and immediately follow its host variable (unless you use the keyword INDICATOR). If you are using Declare Sections, you must also declare indicator variables inside the Declare Sections.</p>
<p>This applies to relational columns, not object types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_17obj.htm#g480794">Chapter 17, &#34;Objects&#34;</a></div>
<div id="LNPCC3206" class="sect2"><a id="sthref496"></a>
<h3 class="sect2">The INDICATOR Keyword <a id="sthref497"></a></h3>
<p>To improve readability, you can precede any indicator variable with the optional keyword INDICATOR. You must still prefix the indicator variable with a colon. The correct syntax is:</p>
<pre>:host_variable INDICATOR :indicator_variable 
</pre>
<p>which is equivalent to</p>
<pre>:host_variable:indicator_variable 
</pre>
<p>You can use both forms of expression in your host program.</p>
<p>Possible indicator values, and their meanings, are:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="possible indicator values and their meanings" summary="Indicator Values" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t17">Indicator Values</th>
<th class="cellalignment832" id="r1c2-t17">Meanings</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t17" headers="r1c1-t17">0</td>
<td class="cellalignment833" headers="r2c1-t17 r1c2-t17">The operation was successful</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t17" headers="r1c1-t17">-1</td>
<td class="cellalignment833" headers="r3c1-t17 r1c2-t17">A NULL was returned, inserted, or updated.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t17" headers="r1c1-t17">-2</td>
<td class="cellalignment833" headers="r4c1-t17 r1c2-t17">Output to a character host variable from a &#34;long&#34; type was truncated, but the original column length cannot be determined.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t17" headers="r1c1-t17">&gt;0</td>
<td class="cellalignment833" headers="r5c1-t17 r1c2-t17">The result of a SELECT or FETCH into a character host variable was truncated. In this case, if the host variable is a multibyte character variable, the indicator value is the original column length in characters. If the host variable is not a multibye character variable, then the indicator length is the original column length in bytes.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<div id="LNPCC3207" class="sect2"><a id="sthref498"></a>
<h3 class="sect2">Example of INDICATOR Variable Usage</h3>
<p>Typically, you use indicator variables to assign NULLs to input host variables and detect NULLs or truncated values in output host variables. In the example later, you declare three host variables and one indicator variable, then use a SELECT statement to search the database for an employee number matching the value of host variable <span class="italic">emp_number</span>. When a matching row is found, Oracle sets output host variables <span class="italic">salary</span> and <span class="italic">commission</span> to the values of columns SAL and COMM in that row and stores a return code in indicator variable <span class="italic">ind_comm</span>. The next statements use <span class="italic">ind_comm</span> to select a course of action.</p>
<pre>EXEC SQL BEGIN DECLARE SECTION; 
    int    emp_number; 
    float  salary, commission; 
    short comm_ind;  /* indicator variable  */
EXEC SQL END DECLARE SECTION;
    char temp[16];
    float  pay;      /* not used in a SQL statement */
...
printf(&#34;Employee number? &#34;); 
gets(temp);
emp_number = atof(temp);
EXEC SQL SELECT SAL, COMM 
    INTO :salary, :commission:ind_comm 
    FROM EMP 
    WHERE EMPNO = :emp_number; 
if(ind_comm == -1)    /* commission is null */
    pay = salary; 
else
    pay = salary + commission; 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_06sql.htm#i2144">&#34;Indicator Variables&#34;</a></div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3208" class="sect2"><a id="sthref499"></a>
<h3 class="sect2">INDICATOR Variable Guidelines<a id="sthref500"></a></h3>
<p>The following guidelines apply to declaring and referencing indicator variables. An indicator variable must</p>
<ul>
<li>
<p>Be declared explicitly (in the Declare Section if present) as a 2-byte integer.</p>
</li>
<li>
<p>Be prefixed with a colon (:) in SQL statements.</p>
</li>
<li>
<p>Immediately follow its host variable in SQL statements and PL/SQL blocks (unless preceded by the keyword INDICATOR).</p>
</li>
</ul>
<p>An indicator variable must <span class="italic">not</span>:</p>
<ul>
<li>
<p>Be prefixed with a colon in host language statements.</p>
</li>
<li>
<p>Follow its host variable in host language statements.</p>
</li>
<li>
<p>Be an Oracle reserved word.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCC3209" class="sect2"><a id="sthref501"></a>
<h3 class="sect2">Oracle Restrictions</h3>
<p>When DBMS=V7 or V8, if you SELECT or FETCH a NULL into a host variable that has no indicator, Oracle issues the following error message:</p>
<pre>ORA-01405: fetched column value is NULL
</pre>
<p>When precompiling with MODE=ORACLE and DBMS=V7 or V8 specified, you can specify UNSAFE_NULL=YES to disable the ORA-01405 message.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#i8679">&#34;UNSAFE_NULL&#34;</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i23767"></a>
<div id="LNPCC3210" class="sect1">
<h2 class="sect1">VARCHAR Variables</h2>
<p>You can use the VARCHAR pseudotype to declare variable-length character strings. When your program deals with strings that are output from, or input to, VARCHAR2 or LONG columns, you might find it more convenient to use VARCHAR host variables instead of standard C strings. The datatype name VARCHAR can be uppercase or lowercase, but it <span class="italic">cannot</span> be mixed case. In this Guide, uppercase is used to emphasize that VARCHAR is not a native C datatype.</p>
<a id="i23305"></a>
<div id="LNPCC3211" class="sect2">
<h3 class="sect2">VARCHAR Variable Declaration</h3>
<p>Think of a VARCHAR as an extended C type or pre-declared <span class="bold">struct</span>. For example, the precompiler expands the VARCHAR declaration<a id="sthref502"></a><a id="sthref503"></a></p>
<pre>VARCHAR   username[20];
 
</pre>
<p>into the following <span class="bold">struct</span> with array and length members:</p>
<pre>struct 
{ 
    unsigned short  len; 
    unsigned char   arr[20]; 
} username; 
</pre>
<p>The advantage of using VARCHAR variables is that you can explicitly reference the length member of the VARCHAR structure after a SELECT or FETCH. Oracle puts the length of the selected character string in the length member. You can then use this member to do things such as adding the null (&#39;\0&#39;) terminator<a id="sthref504"></a>.</p>
<pre>username.arr[username.len] = &#39;\0&#39;; 
</pre>
<p>or using the length in a <span class="italic">strncpy</span> or <span class="italic">printf</span> statement; for example:</p>
<pre>printf(&#34;Username is %.*s\n&#34;, username.len, username.arr);
</pre>
<p>You specify the maximum length of a VARCHAR variable in its declaration. The length must lie in the range 1.65533. For example, the following declaration is <span class="italic">invalid</span> because no length is specified:<a id="sthref505"></a></p>
<pre>VARCHAR   null_string[];    /* invalid */
</pre>
<p>The length specification holds the current length of the value stored in the array member.<a id="sthref506"></a></p>
<p>You can declare multiple VARCHARs on a single line; for example:</p>
<pre>VARCHAR emp_name[ENAME_LEN], dept_loc[DEPT_NAME_LEN];
</pre>
<p>The length specifier for a VARCHAR can be a <span class="bold">#define</span>d macro, or any complex expression that can be resolved to an integer at precompile time.</p>
<p>You can also declare pointers to VARCHAR datatypes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_05adv.htm#i434340">&#34;VARCHAR Variables and Pointers&#34;</a>.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not attempt to use a typedef statement such as:
<pre>typedef VARCHAR buf[64]; 
</pre>
<p>This causes errors during C compilation.</p>
</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3212" class="sect2"><a id="sthref507"></a>
<h3 class="sect2">VARCHAR Variable Referencing</h3>
<p>In SQL statements, you reference VARCHAR variables using the <span class="bold">struct</span> name prefixed with a colon, as the following example shows:</p>
<pre>... 
int       part_number; 
VARCHAR   part_desc[40]; 
... 
main() 
{ 
    ... 
    EXEC SQL SELECT pdesc INTO :part_desc 
        FROM parts 
        WHERE pnum = :part_number; 
    ... 
</pre>
<p>After the query is executed, <span class="italic">part_desc.len</span> holds the actual length of the character string retrieved from the database and stored in <span class="italic">part_desc.arr</span>.</p>
<p>In C statements, you reference VARCHAR variables using the component names, as the next example shows:</p>
<pre>printf(&#34;\n\nEnter part description: &#34;); 
gets(part_desc.arr); 
/* You must set the length of the string
   before using the VARCHAR in an INSERT or UPDATE */
part_desc.len = strlen(part_desc.arr); 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3213" class="sect2"><a id="sthref508"></a>
<h3 class="sect2">Return NULLs to a VARCHAR Variable</h3>
<p>Oracle automatically sets the length component of a VARCHAR output host variable. If you SELECT or FETCH a NULL into a VARCHAR, the server does not change the length or array members.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you select a NULL into a VARCHAR host variable, and there is no associated indicator variable, an ORA-01405 error occurs at run time. Avoid this by coding indicator variables with all host variables. (As a temporary fix, use the UNSAFE_NULL=YES precompiler option. See also <a href="pc_10opt.htm#i4752">&#34;DBMS&#34;</a>).</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3214" class="sect2"><a id="sthref509"></a>
<h3 class="sect2">Insert NULLs Using VARCHAR Variables</h3>
<p>If you set the length of a VARCHAR variable to zero before performing an UPDATE or INSERT statement, the column value is set to NULL. If the column has a NOT NULL constraint, Oracle returns an error.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3215" class="sect2"><a id="sthref510"></a>
<h3 class="sect2">Pass VARCHAR Variables to a Function</h3>
<p>VARCHARs are structures, and most C compilers permit passing of structures to a function by value, and returning structures by copy out from functions. However, in Pro*C/C++ you must pass VARCHARs to functions by reference. The following example shows the correct way to pass a VARCHAR variable to a function: <a id="sthref511"></a></p>
<pre>VARCHAR emp_name[20]; 
... 
emp_name.len = 20; 
SELECT ename INTO :emp_name FROM emp 
WHERE empno = 7499; 
... 
print_employee_name(&amp;emp_name); /* pass by pointer */ 
... 
 
print_employee_name(name) 
VARCHAR *name; 
{ 
    ... 
    printf(&#34;name is %.*s\n&#34;, name-&gt;len, name-&gt;arr); 
    ... 
}
</pre></div>
<!-- class="sect2" -->
<a id="i23400"></a>
<div id="LNPCC3216" class="sect2">
<h3 class="sect2">Find the Length of the VARCHAR Array Component</h3>
<p>When the precompiler processes a VARCHAR declaration, the actual length of the array element in the generated structure can be longer than that declared. For example, on a Sun Solaris system, the Pro*C/C++ declaration</p>
<pre>VARCHAR my_varchar[12];
 
</pre>
<p>is expanded by the precompiler to</p>
<pre>struct my_varchar
{
    unsigned short len;
    unsigned char  arr[12];
};
</pre>
<p>However, the precompiler or the C compiler on this system pads the length of the array component to 14 bytes. This alignment requirement pads the total length of the structure to 16 bytes: 14 for the padded array and 2 bytes for the length.</p>
<p>The <code>SQLVarcharGetLength()</code> (replaces the non-threaded <code>sqlvcp()</code>) function&mdash;part of the SQLLIB runtime library&mdash;returns the actual (possibly padded) length of the array member. <a id="sthref512"></a><a id="sthref513"></a></p>
<p>You pass the <code>SQLVarcharGetLength()</code> function the length of the data for a VARCHAR host variable or a VARCHAR pointer host variable, and <code>SQLVarcharGetLength()</code> returns the total length of the array component of the VARCHAR. The total length includes any padding that might be added by your C compiler.</p>
<p>The syntax of <code>SQLVarcharGetLength()</code> is</p>
<pre>SQLVarcharGetLength (dvoid *context, unsigned long *datlen, unsigned long *totlen); 
</pre>
<p>For single-threaded applications, use <code>sqlvcp()</code>. Put the length of the VARCHAR in the <code>datlen</code> parameter before calling <code>sqlvcp()</code>. When the function returns, the <code>totlen</code> parameter contains the total length of the array element. Both parameters are pointers to unsigned long integers, so must be passed by reference.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_05adv.htm#i426817">&#34;New Names for SQLLIB Public Functions&#34;</a> for a discussion of these and all other SQLLIB public functions.</div>
</div>
<!-- class="sect2" -->
<a id="i24296"></a>
<div id="LNPCC3217" class="sect2">
<h3 class="sect2">Example Program: Using sqlvcp()</h3>
<p>The following example program shows how you can use the function in a Pro*C/C++ application. The example also uses the <code>sqlgls()</code> function. The example declares a VARCHAR pointer, then uses the <code>sqlvcp()</code> function to determine the size required for the VARCHAR buffer. The program FETCHes employee names from the EMP table and prints them. Finally, the example uses the <code>sqlgls()</code> function to print out the SQL statement and its function code and length attributes. This program is available on-line as <code>sqlvcp.pc</code> in your <code>demo</code> directory.<a id="sthref514"></a><a id="sthref515"></a><a id="sthref516"></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_09err.htm#g35612">Chapter 9, &#34;Handling Runtime Errors&#34;</a></div>
<pre>/*
 *  The sqlvcp.pc program demonstrates how you can use the
 *  sqlvcp() function to determine the actual size of a
 *  VARCHAR struct. The size is then used as an offset to
 *  increment a pointer that steps through an array of
 *  VARCHARs.
 *
 *  This program also demonstrates the use of the sqlgls()
 *  function, to get the text of the last SQL statement executed.
 *  sqlgls() is described in the &#34;Error Handling&#34; chapter of
 *  The Programmer&#39;s Guide to the Oracle Pro*C/C++ Precompiler.
 */

#include &lt;stdio.h&gt; 
#include &lt;sqlca.h&gt;
#include &lt;sqlcpr.h&gt;

/*  Fake a VARCHAR pointer type. */ 

struct my_vc_ptr 
{ 
    unsigned short len; 
    unsigned char arr[32767]; 
}; 

/* Define a type for the VARCHAR pointer */
typedef struct my_vc_ptr my_vc_ptr; 
my_vc_ptr *vc_ptr; 


EXEC SQL BEGIN DECLARE SECTION; 
VARCHAR *names;  
int      limit;    /* for use in FETCH FOR clause  */ 
char    *username = &#34;scott/tiger&#34;; 
EXEC SQL END DECLARE SECTION; 
void sql_error(); 
extern void sqlvcp(), sqlgls(); 

main() 
{ 
    unsigned int vcplen, function_code, padlen, buflen; 
    int i; 
    char stmt_buf[120]; 

    EXEC SQL WHENEVER SQLERROR DO sql_error(); 

    EXEC SQL CONNECT :username; 
    printf(&#34;\nConnected.\n&#34;); 
     
/*  Find number of rows in table. */ 
    EXEC SQL SELECT COUNT(*) INTO :limit FROM emp; 
     
     
/*  Declare a cursor for the FETCH statement. */ 
    EXEC SQL DECLARE emp_name_cursor CURSOR FOR 
    SELECT ename FROM emp; 
    EXEC SQL FOR :limit OPEN emp_name_cursor; 
     
/*  Set the desired DATA length for the VARCHAR. */ 
    vcplen = 10; 
     
/*  Use SQLVCP to help find the length to malloc. */ 
    sqlvcp(&amp;vcplen, &amp;padlen); 
    printf(&#34;Actual array length of VARCHAR is %ld\n&#34;, padlen); 
     
/*  Allocate the names buffer for names. 
    Set the limit variable for the FOR clause. */ 
    names = (VARCHAR *) malloc((sizeof (short) + 
    (int) padlen) * limit); 
    if (names == 0) 
    { 
        printf(&#34;Memory allocation error.\n&#34;); 
        exit(1); 
    }
/*  Set the maximum lengths before the FETCH. 
 *  Note the &#34;trick&#34; to get an effective VARCHAR *.
 */ 
    for (vc_ptr = (my_vc_ptr *) names, i = 0; i &lt; limit; i++) 
    { 
        vc_ptr-&gt;len = (short) padlen; 
        vc_ptr = (my_vc_ptr *)((char *) vc_ptr + 
        padlen + sizeof (short)); 
    } 
/*  Execute the FETCH. */ 
    EXEC SQL FOR :limit FETCH emp_name_cursor INTO :names; 
     
/*  Print the results. */ 
    printf(&#34;Employee names--\n&#34;); 
    
    for (vc_ptr = (my_vc_ptr *) names, i = 0; i &lt; limit; i++) 
    { 
        printf
         (&#34;%.*s\t(%d)\n&#34;, vc_ptr-&gt;len, vc_ptr-&gt;arr, vc_ptr-&gt;len); 
        vc_ptr = (my_vc_ptr *)((char *) vc_ptr + 
                  padlen + sizeof (short)); 
    } 
     
/*  Get statistics about the most recent 
 *  SQL statement using SQLGLS. Note that 
 *  the most recent statement in this example 
 *  is not a FETCH, but rather &#34;SELECT ENAME FROM EMP&#34; 
 *  (the cursor).
 */ 
    buflen = (long) sizeof (stmt_buf); 
    
/*  The returned value should be 1, indicating no error. */ 
    sqlgls(stmt_buf, &amp;buflen, &amp;function_code);
    if (buflen != 0)
    { 
        /* Print out the SQL statement. */ 
        printf(&#34;The SQL statement was--\n%.*s\n&#34;, buflen, stmt_buf); 
     
        /* Print the returned length. */ 
        printf(&#34;The statement length is %ld\n&#34;, buflen); 
     
        /* Print the attributes. */ 
        printf(&#34;The function code is %ld\n&#34;, function_code); 
    
        EXEC SQL COMMIT RELEASE; 
        exit(0); 
    }
    else 
    { 
        printf(&#34;The SQLGLS function returned an error.\n&#34;); 
        EXEC SQL ROLLBACK RELEASE; 
        exit(1); 
    } 
} 

void
sql_error() 
{ 
    char err_msg[512]; 
    int buf_len, msg_len;

     
    EXEC SQL WHENEVER SQLERROR CONTINUE; 
 
    buf_len = sizeof (err_msg); 
    sqlglm(err_msg, &amp;buf_len, &amp;msg_len); 
    printf(&#34;%.*s\n&#34;, msg_len, err_msg); 
 
    EXEC SQL ROLLBACK RELEASE; 
    exit(1); 
} 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i23772"></a>
<div id="LNPCC3218" class="sect1">
<h2 class="sect1">Cursor Variables <a id="sthref517"></a><a id="sthref518"></a><a id="sthref519"></a></h2>
<p>You can use <span class="italic">cursor variables</span> in your Pro*C/C++ program for queries. A cursor variable is a handle for a cursor that must be defined and opened on the Oracle server using PL/SQL. See the <a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for complete information about cursor variables.</p>
<p>The advantages of cursor variables are:</p>
<ul>
<li>
<p>Ease of maintenance</p>
<p>Queries are centralized, in the stored procedure that opens the cursor variable. If you need to change the cursor, you only need to make the change in one place: the stored procedure. There is no need to change each application.</p>
</li>
<li>
<p>Convenient security</p>
<p>The user of the application is the username used when the Pro*C/C++ application connects to the server. The user must have <span class="italic">execute</span> permission on the stored procedure that opens the cursor but not <span class="italic">read</span> permission on the tables used in the query. This capability can be used to limit access to the columns in the table, and access to other stored procedures.</p>
</li>
</ul>
<div id="LNPCC3219" class="sect2"><a id="sthref520"></a>
<h3 class="sect2">Declare a Cursor Variable<a id="sthref521"></a></h3>
<p>You declare a cursor variable in your Pro*C/C++ program using the Pro*C/C++ pseudotype SQL_CURSOR. For example:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION;
    sql_cursor     emp_cursor;             /* a cursor variable */
    SQL_CURSOR     dept_cursor;      /* another cursor variable */
    sql_cursor     *ecp;      /* a pointer to a cursor variable */
    ...
EXEC SQL END DECLARE SECTION;
ecp = &amp;emp_cursor;             /* assign a value to the pointer */
</pre>
<p>You can declare a cursor variable using the type specification SQL_CURSOR, in all upper case, or sql_cursor, in all lower case; you cannot use mixed case.</p>
<p>A cursor variable is just like any other host variable in the Pro*C/C++ program. It has scope, following the scope rules of C. You can pass it as a parameter to other functions, even functions external to the source file in which you declared it. You can also define functions that return cursor variables, or pointers to cursor variables. <a id="sthref522"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A SQL_CURSOR is implemented as a C <span class="bold">struct</span> in the code that Pro*C/C++ generates. So you can always pass it by pointer to another function, or return a pointer to a cursor variable from a function. But you can only pass it or return it by value if your C compiler supports these operations. <a id="sthref523"></a></div>
</div>
<!-- class="sect2" -->
<a id="i24316"></a>
<div id="LNPCC3220" class="sect2">
<h3 class="sect2"><a id="sthref524"></a><a id="sthref525"></a><a id="sthref526"></a>Allocate a Cursor Variable<a id="sthref527"></a></h3>
<p>Before you can use a cursor variable, either to open it or to FETCH it, you must allocate the cursor. You do this using the new precompiler command ALLOCATE. For example, to allocate the SQL_CURSOR <span class="italic">emp_cursor</span> that was declared in the example earlier, you write the statement:</p>
<pre>EXEC SQL ALLOCATE :emp_cursor;
</pre>
<p>Allocating a cursor does <span class="italic">not</span> require a call to the server, either at precompile time or at runtime. If the ALLOCATE statement contains an error (for example, an undeclared host variable), Pro*C/C++ issues a precompile-time error. Allocating a cursor variable <span class="italic">does</span> cause heap memory to be used. For this reason, you can free a cursor variable in a program loop. Memory allocated for cursor variables is <span class="italic">not</span> freed when the cursor is closed, but only when an explicit CLOSE is executed, or the connection is closed:</p>
<pre>EXEC SQL CLOSE :emp_cursor;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i24323">&#34;Closing and Freeing a Cursor Variable&#34;</a></div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3221" class="sect2"><a id="sthref528"></a>
<h3 class="sect2">Open a Cursor Variable</h3>
<p><a id="sthref529"></a>You must open a cursor variable on the Oracle database server. You cannot use the embedded SQL OPEN command to open a cursor variable. You can open a cursor variable either by calling a PL/SQL stored procedure that opens the cursor (and defines it in the same statement). Or, you can open and define a cursor variable using an anonymous PL/SQL block in your Pro*C/C++ program.</p>
<p>For example, consider the following PL/SQL package, stored in the database:</p>
<pre>CREATE PACKAGE demo_cur_pkg AS
    TYPE EmpName IS RECORD (name VARCHAR2(10));
    TYPE cur_type IS REF CURSOR RETURN EmpName;
    PROCEDURE open_emp_cur (
               curs     IN OUT cur_type,
               dept_num IN     NUMBER);
END;

CREATE PACKAGE BODY demo_cur_pkg AS
    CREATE PROCEDURE open_emp_cur (
               curs     IN OUT cur_type,
               dept_num IN     NUMBER) IS
    BEGIN
        OPEN curs FOR
            SELECT ename FROM emp
                WHERE deptno = dept_num
                ORDER BY ename ASC;
    END;
END;
</pre>
<p>After this package has been stored, you can open the cursor <span class="italic">curs</span> by calling the <span class="italic">open_emp_cur</span> stored procedure from your Pro*C/C++ program, and FETCH from the cursor in the program. For example:</p>
<pre>...
sql_cursor    emp_cursor;
char          emp_name[11];
...
EXEC SQL ALLOCATE :emp_cursor;  /* allocate the cursor variable */
...
/* Open the cursor on the server side. */
EXEC SQL EXECUTE
    begin
        demo_cur_pkg.open_emp_cur(:emp_cursor, :dept_num);
    end;
;
EXEC SQL WHENEVER NOT FOUND DO break;
for (;;)
{
    EXEC SQL FETCH :emp_cursor INTO :emp_name;
    printf(&#34;%s\n&#34;, emp_name);
}
...
</pre>
<p>To open a cursor using a PL/SQL anonymous block in your Pro*C/C++ program, you define the cursor in the anonymous block. For example: <a id="sthref530"></a></p>
<pre>sql_cursor emp_cursor;
int dept_num = 10;
...
EXEC SQL EXECUTE
    BEGIN
        OPEN :emp_cursor FOR SELECT ename FROM emp
             WHERE deptno = :dept_num;
    END;
END-EXEC;
...
</pre>
<p>The earlier examples show how to use PL/SQL to open a cursor variable. You can also open a cursor variable using embedded SQL with the CURSOR clause:</p>
<pre>...
sql_cursor emp_cursor;
...
EXEC ORACLE OPTION(select_error=no);
EXEC SQL
    SELECT CURSOR(SELECT ename FROM emp WHERE deptno = :dept_num)
    INTO :emp_cursor FROM DUAL;
EXEC ORACLE OPTION(select_error=yes);
</pre>
<p>In the statement earlier, the emp_cursor cursor variable is bound to the first column of the outermost select. The first column is itself a query, but it is represented in the form compatible with a sql_cursor host variable since the CURSOR(...) conversion clause is used.</p>
<p>Before using queries which involve the CURSOR clause, you must set the SELECT_ERROR option to NO. This will prevent the cancellation of the parent cursor and allow the program to run without errors.</p>
<div id="LNPCC3222" class="sect3"><a id="sthref531"></a>
<h4 class="sect3">Opening in a Standalone Stored Procedure</h4>
<p>In the example earlier, a reference cursor was defined inside a package, and the cursor was opened in a procedure in that package. But it is not always necessary to define a reference cursor inside the package that contains the procedures that open the cursor.</p>
<p>If you need to open a cursor inside a standalone stored procedure, you can define the cursor in a separate package, and then reference that package in the standalone stored procedure that opens the cursor. Here is an example:</p>
<pre>PACKAGE dummy IS
    TYPE EmpName IS RECORD (name VARCHAR2(10));
    TYPE emp_cursor_type IS REF CURSOR RETURN EmpName;
END;
-- and then define a standalone procedure:
PROCEDURE open_emp_curs (
      emp_cursor IN OUT dummy.emp_cursor_type;
      dept_num   IN     NUMBER) IS
    BEGIN
        OPEN emp_cursor FOR
            SELECT ename FROM emp WHERE deptno = dept_num;
    END;
END;
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC3223" class="sect3"><a id="sthref532"></a>
<h4 class="sect3">Return Types</h4>
<p>When you define a reference cursor in a PL/SQL stored procedure, you must declare the type that the cursor returns. See the <a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for complete information on the reference cursor type and its return types.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i24323"></a>
<div id="LNPCC3224" class="sect2">
<h3 class="sect2">Closing and Freeing a Cursor Variable</h3>
<p>Use the CLOSE command to close a cursor variable. For example, to close the <span class="italic">emp_cursor</span> cursor variable that was OPENed in the examples earlier, use the embedded SQL statement:</p>
<pre>EXEC SQL CLOSE :emp_cursor;
</pre>
<p>The cursor variable is a host variable, and so you must precede it with a colon.</p>
<p>You can reuse ALLOCATEd cursor variables. You can open, FETCH, and CLOSE as many times as needed for your application. However, if you disconnect from the server, then reconnect, you must re-ALLOCATE cursor variables.</p>
<p>Cursors are deallocated by the FREE embedded SQL statement. For example:</p>
<pre>EXEC SQL FREE :emp_cursor;
</pre>
<p>If the cursor is still open, it is closed and the memory allocated for it is released.</p>
</div>
<!-- class="sect2" -->
<a id="i23020"></a>
<div id="LNPCC3225" class="sect2">
<h3 class="sect2">Cursor Variables with the OCI (Release 7 Only)</h3>
<p>You can share a Pro*C/C++ cursor variable with an OCI function. To do so, you must use the SQLLIB conversion functions, <code>SQLCDAFromResultSetCursor()</code> (formerly known as <code>sqlcdat()</code>) and SQLCDAToResultSetCursor (formerly known as <code>sqlcurt()</code>). These functions convert between OCI cursor data areas and Pro*C/C++ cursor variables.</p>
<p>The <code>SQLCDAFromResultSetCursor()</code> function translates an allocated cursor variable to an OCI cursor data area. The syntax is:</p>
<pre>void SQLCDAFromResultSetCursor(dvoid *context, Cda_Def *cda, void *cur, 
   sword *retval);
</pre>
<p>where the parameters are:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="parameter descriptions for sqlcdafromresultsetcursor" summary="Parameters" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t27">Parameters</th>
<th class="cellalignment832" id="r1c2-t27">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t27" headers="r1c1-t27">context</td>
<td class="cellalignment833" headers="r2c1-t27 r1c2-t27">A pointer to the SQLLIB runtime context.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t27" headers="r1c1-t27">cda</td>
<td class="cellalignment833" headers="r3c1-t27 r1c2-t27">A pointer to the destination OCI cursor data area.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t27" headers="r1c1-t27">cur</td>
<td class="cellalignment833" headers="r4c1-t27 r1c2-t27">A pointer to the source Pro*C/C++ cursor variable.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t27" headers="r1c1-t27">retval</td>
<td class="cellalignment833" headers="r5c1-t27 r1c2-t27">0 if no error, otherwise a SQLLIB (SQL) error number.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
In the case of an error, the <span class="italic">V2</span> and <span class="italic">rc</span> return code fields in the CDA also receive the error codes. The <span class="italic">rows processed count</span> field in the CDA is not set.
<p>For non-threaded or default context applications, pass the defined constant SQL_SINGLE_RCTX as the context.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_05adv.htm#i426817">&#34;New Names for SQLLIB Public Functions&#34;</a></div>
<p>The <code>SQLCDAToResultSetCursor()</code> function translates an OCI cursor data area to a Pro*C/C++ cursor variable. The syntax is:</p>
<pre>void SQLCDAToResultSetCursor(dvoid *context, void *cur, Cda_Def *cda, 
   int *retval);
</pre>
<p>where the parameters are:</p>
<div class="inftblinformal">
<table class="cellalignment834" title="parameter descriptions for sqlcdatoresultsetcursor" summary="Parameters" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t30">Parameters</th>
<th class="cellalignment832" id="r1c2-t30">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t30" headers="r1c1-t30">context</td>
<td class="cellalignment833" headers="r2c1-t30 r1c2-t30">A pointer to the SQLLIB runtime context.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t30" headers="r1c1-t30">cur</td>
<td class="cellalignment833" headers="r3c1-t30 r1c2-t30">A pointer to the destination Pro*C/C++ cursor variable.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t30" headers="r1c1-t30">cda</td>
<td class="cellalignment833" headers="r4c1-t30 r1c2-t30">A pointer to the source OCI cursor data area.</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t30" headers="r1c1-t30">retval</td>
<td class="cellalignment833" headers="r5c1-t30 r1c2-t30">0 if no error, otherwise an error code.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The SQLCA structure is not updated by this routine. The SQLCA components are only set after a database operation is performed using the translated cursor.
<p>For non-threaded applications, pass the defined constant SQL_SINGLE_RCTX as the context.</p>
</div>
<p>ANSI and K&amp;R prototypes for these functions are provided in the <code>sql2oci.h</code> header file. Memory for both <span class="italic">cda</span> and <span class="italic">cur</span> must be allocated prior to calling these functions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_05adv.htm#i426817">&#34;New Names for SQLLIB Public Functions&#34;</a> for more details on the SQLLIB Public Functions, see the table.</div>
</div>
<!-- class="sect2" -->
<div id="LNPCC3226" class="sect2"><a id="sthref533"></a>
<h3 class="sect2">Restrictions<a id="sthref534"></a></h3>
<p>The following restrictions apply to the use of cursor variables:</p>
<ul>
<li>
<p>If you use the same cursor variable in Pro*C/C++ and OCI V7, then you must use either SQLLDAGetCurrent() or SQLLDAGetName() immediately after connecting.</p>
</li>
<li>
<p>You cannot translate a cursor variable to an OCI release 8 equivalent.</p>
</li>
<li>
<p>You cannot use cursor variables with dynamic SQL. <a id="sthref535"></a></p>
</li>
<li>
<p>You can only use cursor variables with the ALLOCATE, FETCH, FREE, and CLOSE commands</p>
</li>
<li>
<p>The DECLARE CURSOR command does not apply to cursor variables.</p>
</li>
<li>
<p>You cannot FETCH from a CLOSEd cursor variable.</p>
</li>
<li>
<p>You cannot FETCH from a non-ALLOCATEd cursor variable.</p>
</li>
<li>
<p>If you precompile with MODE=ANSI, it is an error to close a cursor variable that is already closed.</p>
</li>
<li>
<p>You cannot use the AT clause with the ALLOCATE command, nor with the FETCH and CLOSE commands if they reference a cursor variable.</p>
</li>
<li>
<p>Cursor variables cannot be stored in columns in the database.</p>
</li>
<li>
<p>A cursor variable itself cannot be declared in a package specification. Only the <span class="italic">type</span> of the cursor variable can be declared in the package specification.</p>
</li>
<li>
<p>A cursor variable cannot be a component of a PL/SQL record.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCC3227" class="sect2"><a id="sthref536"></a>
<h3 class="sect2">Example:<a id="sthref537"></a> cv_demo.sql and sample11.pc</h3>
<p>The following example programs&mdash;a PL/SQL script and a Pro*C/C++ program&mdash;demonstrate how you can use cursor variables. These sources are available on-line in your <code>demo</code> directory. Also see another version of the same application, <code>cv_demo.pc</code>, in the demo directory.</p>
<div id="LNPCC3228" class="sect3"><a id="sthref538"></a>
<h4 class="sect3">cv_demo.sql<a id="sthref539"></a></h4>
<pre>-- PL/SQL source for a package that declares and
-- opens a ref cursor
CONNECT SCOTT/TIGER;
CREATE OR REPLACE PACKAGE emp_demo_pkg as
   TYPE emp_cur_type IS REF CURSOR RETURN emp%ROWTYPE;
     PROCEDURE open_cur(curs IN OUT emp_cur_type, dno IN NUMBER);
END emp_demo_pkg;
 
 
CREATE OR REPLACE PACKAGE BODY emp_demo_pkg AS
    PROCEDURE open_cur(curs IN OUT emp_cur_type, dno IN NUMBER) IS
    BEGIN 
        OPEN curs FOR SELECT *
            FROM emp WHERE deptno = dno
            ORDER BY ename ASC;
    END;
END emp_demo_pkg;
</pre></div>
<!-- class="sect3" -->
<div id="LNPCC3229" class="sect3"><a id="sthref540"></a>
<h4 class="sect3">sample11.pc<a id="sthref541"></a><a id="sthref542"></a></h4>
<pre>/*
 *  Fetch from the EMP table, using a cursor variable.
 *  The cursor is opened in the stored PL/SQL procedure
 *  open_cur, in the EMP_DEMO_PKG package.
 *
 *  This package is available on-line in the file
 *  sample11.sql, in the demo directory.
 *
 */
 
#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlda.h&gt;
#include &lt;sqlcpr.h&gt;
 
/* Error handling function. */
void sql_error(msg)
    char *msg;
{
    size_t clen, fc;
    char cbuf[128];
 
    clen = sizeof (cbuf);
    sqlgls((char *)cbuf, (size_t *)&amp;clen, (size_t *)&amp;fc);
 
    printf(&#34;\n%s\n&#34;, msg);
    printf(&#34;Statement is--\n%s\n&#34;, cbuf);
    printf(&#34;Function code is %ld\n\n&#34;, fc);
 
    sqlglm((char *)cbuf, (size_t *) &amp;clen, (size_t *) &amp;clen);
    printf (&#34;\n%.*s\n&#34;, clen, cbuf);
  
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK RELEASE;
    exit(EXIT_FAILURE);
}

void main()
{
    char temp[32];
 
    EXEC SQL BEGIN DECLARE SECTION;
        char *uid = &#34;scott/tiger&#34;;
        SQL_CURSOR emp_cursor;
        int dept_num;
        struct
        {
            int   emp_num;
            char  emp_name[11];
            char  job[10];
            int   manager;
            char  hire_date[10];
            float salary;
            float commission;
            int   dept_num;
        } emp_info;
    
        struct
        {
            short emp_num_ind;
            short emp_name_ind;
            short job_ind;
            short manager_ind;
            short hire_date_ind;
            short salary_ind;
            short commission_ind;
            short dept_num_ind;
        } emp_info_ind;
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR do sql_error(&#34;Oracle error&#34;);
    
/* Connect to Oracle. */
    EXEC SQL CONNECT :uid;
 
/* Allocate the cursor variable. */
    EXEC SQL ALLOCATE :emp_cursor;
 
/* Exit the inner for (;;) loop when NO DATA FOUND. */
    EXEC SQL WHENEVER NOT FOUND DO break;
 
    for (;;)
    {
        printf(&#34;\nEnter department number  (0 to exit): &#34;);
        gets(temp);
        dept_num = atoi(temp);
        if (dept_num &lt;= 0)
            break;
 
        EXEC SQL EXECUTE
            begin
                emp_demo_pkg.open_cur(:emp_cursor, :dept_num);
            end;
        END-EXEC;
 
        printf(&#34;\nFor department %d--\n&#34;, dept_num);
        printf(&#34;ENAME           SAL     COMM\n&#34;);
        printf(&#34;-----           ---     ----\n&#34;);
 
/* Fetch each row in the EMP table into the data struct.
   Note the use of a parallel indicator struct. */
        for (;;)
        {
             EXEC SQL FETCH :emp_cursor 
                 INTO :emp_info INDICATOR :emp_info_ind;
 
             printf(&#34;%s &#34;, emp_info.emp_name);
             printf(&#34;%8.2f &#34;, emp_info.salary);
             if (emp_info_ind.commission_ind != 0)
                 printf(&#34;    NULL\n&#34;);
             else
                 printf(&#34;%8.2f\n&#34;, emp_info.commission);
        }
 
    }
 
/* Close the cursor. */
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE :emp_cursor;

/* Disconnect from Oracle. */
    EXEC SQL ROLLBACK WORK RELEASE;
    exit(EXIT_SUCCESS);

}
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i24497"></a>
<div id="LNPCC3230" class="sect1">
<h2 class="sect1">CONTEXT Variables</h2>
<p>A <span class="italic">runtime context</span>, usually simply called a context, is a handle to a an area in client memory which contains zero or more connections, zero or more cursors, their inline options (such as MODE, HOLD_CURSOR, RELEASE_CURSOR, SELECT_ERROR, and so on.) and other additional state information.</p>
<p>To define a context host variable use pseudo-type <span class="italic">sql_context</span>. For example:</p>
<pre>sql_context my_context ;
</pre>
<p>Use the CONTEXT ALLOCATE precompiler directive to allocate and initialize memory for a context:</p>
<pre>EXEC SQL CONTEXT ALLOCATE :<span class="italic">context</span> ;
</pre>
<p>where <code>context</code> is a host variable that is a handle to the context. For example:</p>
<pre>EXEC SQL CONTEXT ALLOCATE :my_context ;
</pre>
<p>Use the CONTEXT USE precompiler directive to define which context is to be used by the embedded SQL statements (such as CONNECT, INSERT, DECLARE CURSOR, and so on.) from that point on in the source file, not in the flow of program logic. That context is used until another CONTEXT USE statement is encountered. The syntax is:</p>
<pre>EXEC SQL CONTEXT USE {:<span class="italic">context</span> | DEFAULT} ;
</pre>
<p>The keyword DEFAULT specifies that the default (also known as global) context is to be used in all the embedded SQL statements that are executed subsequently, until another CONTEXT USE directive is encountered. A simple example is:</p>
<pre>EXEC SQL CONTEXT USE :my_context ;
</pre>
<p>If the context variable <code>my_context</code> has not been defined and allocated already, an error is returned.</p>
<p>The CONTEXT FREE statement frees the memory used by the context after it is no longer needed:</p>
<pre>EXEC SQL CONTEXT FREE :<span class="italic">context</span> ;
</pre>
<p>An example is:</p>
<pre>EXEC SQL CONTEXT FREE :my_context ;
</pre>
<p>The following example demonstrates the use of a default context in the same application as a user-defined context:</p>
<p class="subhead1"><a id="LNPCC3231"></a>CONTEXT USE Example</p>
<pre>#include &lt;sqlca.h&gt;
#include &lt;ociextp.h&gt;
main()
{
   sql_context ctx1;
   char *usr1 = &#34;scott/tiger&#34;;
   char *usr2 = &#34;system/manager&#34;;

   /* Establish connection to SCOTT in global runtime context */
   EXEC SQL CONNECT :usr1;

   /* Establish connection to SYSTEM in runtime context ctx1 */
   EXEC SQL CONTEXT ALLOCATE :ctx1;
   EXEC SQL CONTEXT USE :ctx1;
   EXEC SQL CONNECT :usr2; 

   /* Insert into the emp table from schema SCOTT */
   EXEC SQL CONTEXT USE DEFAULT;
   EXEC SQL INSERT INTO emp (empno, ename) VALUES (1234, &#39;WALKER&#39;);
   ...
}
</pre></div>
<!-- class="sect1" -->
<a id="i23634"></a>
<div id="LNPCC3232" class="sect1">
<h2 class="sect1">Universal ROWIDs</h2>
<p>There are two kinds of table organization used in the database server: <span class="italic">heap tables</span> and i<span class="italic">ndex-organized tables</span>.</p>
<p>Heap tables are the default. The physical row address (ROWID) is a permanent property that is used to identify a row in a heap table. The external character format of the physical ROWID is an 18-byte character string in base-64 encoding.</p>
<p>An index-organized table does not have physical row addresses as permanent identifiers. A <span class="italic">logical</span> ROWID is defined for these tables. When you use a SELECT ROWID ... statement from an index-organized table the ROWID is an opaque structure that contains the primary key of the table, control information, and an optional physical &#34;guess&#34;. You can use this ROWID in a SQL statement containing a clause such as &#34;WHERE ROWID = ...&#34; to retrieve values from the table.</p>
<p>Universal ROWID can be used for both physical ROWID and logical ROWID. You can use universal ROWIDs to access data in heap tables, or index-organized tables, since the table organization can change with no effect on applications. The column datatype used for ROWID is UROWID(<span class="italic">length</span>), where <code>length</code> is optional.</p>
<p>Use the universal ROWID in all new applications.</p>
<p>For more information on universal ROWIDs, see <a class="olink CNCPT" href="../CNCPT/toc.htm"><span class="italic">Oracle Database Concepts</span></a>.</p>
<p>Use a universal ROWID variable this way:</p>
<ul>
<li>
<p>Declare it as type pointer to OCIRowid.</p>
</li>
<li>
<p>Allocate memory for the universal ROWID variable.</p>
</li>
<li>
<p>Use the universal ROWID as a host bind variable.</p>
</li>
<li>
<p>Free the memory when finished.</p>
</li>
</ul>
<p>For example:</p>
<pre>OCIRowid *my_urowid ;
...
EXEC SQL ALLOCATE :my_urowid ;
/* Bind my_urowid as type SQLT_RDD -- no implicit conversion */
EXEC SQL SELECT rowid INTO :my_urowid FROM my_table WHERE ... ;
...
EXEC SQL UPDATE my_table SET ... WHERE rowid = :my_urowid ;
EXEC SQL FREE my_urpwid ;
...
</pre>
<p>You also have the option of using a character host variable of width between 19 (18 bytes plus the null-terminator) and 4001 as the host bind variable for universal ROWID. Character-based universal ROWIDs are supported for heap tables only for backward compatibility. Because universal ROWID can be variable length, there can be truncation.</p>
<p>Use the character variable this way:</p>
<pre>/* n is based on table characteristics  */
int n=4001 ;
char my_urowid_char[n] ;
...
EXEC SQL ALLOCATE :my_urowid_char ;
/* Bind my_urowid_char as SQLT_STR  */
EXEC SQL SELECT rowid INTO :my_urowid_char FROM my_table WHERE ... ;
EXEC ORACLE OPTION(CHAR_MAP=STRING);
EXEC SQL UPDATE my_table SET ... WHERE rowid = :my_urowid_char ;
EXEC SQL FREE :my_urowid_char ;
...
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_06sql.htm#i5843">&#34;Positioned Update&#34;</a> for an example of a <span class="italic">positioned update</span> using the universal ROWID.</div>
<a id="i24935"></a>
<div id="LNPCC3233" class="sect2">
<h3 class="sect2">SQLRowidGet()</h3>
<p>A SQLLIB function, SQLRowidGet(), provides the ability to retrieve a pointer to the universal ROWID of the last row inserted, updated, or selected. The function prototype and its arguments are:</p>
<pre>void SQLRowidGet (dvoid *rctx, OCIRowid **urid) ;
</pre>
<p>rctx (IN)</p>
<p>is a pointer to a runtime context. For the default context or a non-threaded case, pass SQL_SINGLE_RCTX.</p>
<p>urid (OUT)</p>
<p>is a pointer to a universal ROWID pointer. When a normal execution finishes, this will point to a valid ROWID. In case of an error, NULL is returned.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The universal ROWID pointer must have been previously allocated to call SQLRowidGet(). Use FREE afterward on the universal ROWID.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i12467"></a>
<div id="LNPCC3234" class="sect1">
<h2 class="sect1">Host Structures <a id="sthref543"></a><a id="sthref544"></a></h2>
<p>You can use a C structure to contain host variables. You reference a structure containing host variables in the INTO clause of a SELECT or a FETCH statement, and in the VALUES list of an INSERT statement. Every component of the host structure must be a legal Pro*C/C++ host variable, as defined in <a href="#g39867">Table 4-4</a>.</p>
<p>When a structure is used as a host variable, only the name of the structure is used in the SQL statement. However, each of the members of the structure sends data to Oracle, or receives data from Oracle on a query. The following example shows a host structure that is used to add an employee to the EMP table:</p>
<pre>typedef struct 
{ 
    char  emp_name[11]; /* one greater than column length */ 
    int   emp_number; 
    int   dept_number; 
    float salary; 
} emp_record; 
... 
/* define a new structure of type &#34;emp_record&#34; */ 
emp_record new_employee; 
 
strcpy(new_employee.emp_name, &#34;CHEN&#34;); 
new_employee.emp_number = 9876; 
new_employee.dept_number = 20; 
new_employee.salary = 4250.00; 
 
EXEC SQL INSERT INTO emp (ename, empno, deptno, sal) 
    VALUES (:new_employee); 
</pre>
<p>The order that the members are declared in the structure must match the order that the associated columns occur in the SQL statement, or in the database table if the column list in the INSERT statement is omitted.</p>
<p>For example, the following use of a host structure is <span class="italic">invalid</span>, and causes a runtime error:</p>
<pre>struct 
{ 
    int empno; 
    float salary;          /* struct components in wrong order */
    char emp_name[10]; 
} emp_record; 
 
... 
SELECT empno, ename, sal 
   INTO :emp_record FROM emp; 
</pre>
<p>The example is wrong because the components of the structure are not declared in the same order as the associated columns in the select list. The correct form of the SELECT statement is:</p>
<pre>SELECT empno, sal, ename   /* reverse order of sal and ename */
    INTO :emp_record FROM emp;
</pre>
<div id="LNPCC3235" class="sect2"><a id="sthref545"></a>
<h3 class="sect2">Host Structures and Arrays<a id="sthref546"></a></h3>
<p>An <span class="italic">array</span> is a collection of related data items, called <span class="italic">elements</span>, associated with a single variable name. When declared as a host variable, the array is called a <span class="italic">host array</span>. Likewise, an indicator variable declared as an array is called an <span class="italic">indicator array</span>. An indicator array can be associated with any host array.<a id="sthref547"></a></p>
<p>Host arrays can increase performance by letting you manipulate an entire collection of data items with a single SQL statement. With few exceptions, you can use host arrays wherever scalar host variables are allowed. Also, you can associate an indicator array with any host array.</p>
<p>For a complete discussion of host arrays, see also <a href="pc_08arr.htm#g20885">Chapter 8, &#34;Host Arrays&#34;</a>.</p>
<p>You can use host arrays as components of host structures. In the following example, a structure containing arrays is used to INSERT three new entries into the EMP table:</p>
<pre>struct 
{ 
    char emp_name[3][10]; 
    int emp_number[3]; 
    int dept_number[3]; 
} emp_rec; 
... 
strcpy(emp_rec.emp_name[0], &#34;ANQUETIL&#34;); 
strcpy(emp_rec.emp_name[1], &#34;MERCKX&#34;); 
strcpy(emp_rec.emp_name[2], &#34;HINAULT&#34;); 
emp_rec.emp_number[0] = 1964; emp_rec.dept_number[0] = 5; 
emp_rec.emp_number[1] = 1974; emp_rec.dept_number[1] = 5; 
emp_rec.emp_number[2] = 1985; emp_rec.dept_number[2] = 5; 
 
EXEC SQL INSERT INTO emp (ename, empno, deptno) 
    VALUES (:emp_rec); 
...
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3236" class="sect2"><a id="sthref548"></a>
<h3 class="sect2">PL/SQL Records</h3>
<p>You cannot bind a C <span class="bold">struct</span> to a PL/SQL record. <a id="sthref549"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3237" class="sect2"><a id="sthref550"></a>
<h3 class="sect2"><a id="sthref551"></a>Nested Structures and Unions</h3>
<p><a id="sthref552"></a>You cannot nest host structures. The following example is <span class="italic">invalid</span>:<a id="sthref553"></a><a id="sthref554"></a></p>
<pre>struct 
{ 
    int emp_number; 
    struct 
    { 
        float salary; 
        float commission; 
    } sal_info;            /* INVALID */ 
    int dept_number; 
} emp_record; 
... 
EXEC SQL SELECT empno, sal, comm, deptno 
    INTO :emp_record 
    FROM emp; 
</pre>
<p>Also, you cannot use a C <span class="bold">union</span> as a host structure, nor can you nest a <span class="bold">union</span> in a structure that is to be used as a host structure.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3238" class="sect2"><a id="sthref555"></a>
<h3 class="sect2">Host Indicator Structures<a id="sthref556"></a></h3>
<p>When you need to use indicator variables, but your host variables are contained in a host structure, you set up a second structure that contains an indicator variable for each host variable in the host structure.</p>
<p>For example, suppose you declare a host structure <span class="italic">student_record</span> as follows:</p>
<pre>struct 
{ 
    char s_name[32]; 
    int s_id; 
    char grad_date[9]; 
} student_record; 
</pre>
<p>If you want to use the host structure in a query such as</p>
<pre>EXEC SQL SELECT student_name, student_idno, graduation_date 
    INTO :student_record 
    FROM college_enrollment 
    WHERE student_idno = 7200; 
</pre>
<p>and you need to know if the graduation date can be NULL, then you must declare a separate host indicator structure. You declare this as</p>
<pre>struct 
{ 
    short s_name_ind;  /* indicator variables must be shorts */ 
    short s_id_ind; 
    short grad_date_ind; 
} student_record_ind; 
</pre>
<p>Reference the indicator structure in the SQL statement in the same way that you reference a host indicator variable:</p>
<pre>EXEC SQL SELECT student_name, student_idno, graduation_date 
    INTO :student_record INDICATOR :student_record_ind 
    FROM college_enrollment 
    WHERE student_idno = 7200;
 
</pre>
<p>When the query completes, the NULL/NOT NULL status of each selected component is available in the host indicator structure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This Guide conventionally names indicator variables and indicator structures by appending <span class="italic">_ind</span> to the host variable or structure name. However, the names of indicator variables are completely arbitrary. You can adopt a different convention, or use no convention at all. <a id="sthref557"></a></div>
</div>
<!-- class="sect2" -->
<a id="i11039"></a>
<div id="LNPCC3239" class="sect2">
<h3 class="sect2">Example Program: Cursor and a Host Structure<a id="sthref558"></a></h3>
<p>The demonstration program in this section shows a query that uses an explicit cursor, selecting data into a host structure. This program is available in the file <code>sample2.pc</code> in your <code>demo</code> directory.</p>
<pre>/*
 *  sample2.pc
 *
 *  This program connects to ORACLE, declares and opens a cursor, 
 *  fetches the names, salaries, and commissions of all
 *  salespeople, displays the results, then closes the cursor. 
 */ 

#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;

#define UNAME_LEN      20 
#define PWD_LEN        40 
 
/*
 * Use the precompiler typedef&#39;ing capability to create
 * null-terminated strings for the authentication host
 * variables. (This isn&#39;t really necessary--plain char *&#39;s
 * does work as well. This is just for illustration.)
 */
typedef char asciiz[PWD_LEN]; 

EXEC SQL TYPE asciiz IS STRING(PWD_LEN) REFERENCE; 
asciiz     username; 
asciiz     password; 

struct emp_info 
{ 
    asciiz     emp_name; 
    float      salary; 
    float      commission; 
}; 


/* Declare function to handle unrecoverable errors. */ 
void sql_error(); 


main() 
{ 
    struct emp_info *emp_rec_ptr; 

/* Allocate memory for emp_info struct. */ 
    if ((emp_rec_ptr = 
        (struct emp_info *) malloc(sizeof(struct emp_info))) == 0)
    { 
        fprintf(stderr, &#34;Memory allocation error.\n&#34;); 
        exit(1); 
    } 
 
/* Connect to ORACLE. */ 
    strcpy(username, &#34;SCOTT&#34;); 
    strcpy(password, &#34;TIGER&#34;); 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error(&#34;ORACLE error--&#34;);
 
    EXEC SQL CONNECT :username IDENTIFIED BY :password; 
    printf(&#34;\nConnected to ORACLE as user: %s\n&#34;, username); 
 
/* Declare the cursor. All static SQL explicit cursors
 * contain SELECT commands. &#39;salespeople&#39; is a SQL identifier,
 * not a (C) host variable.
 */
    EXEC SQL DECLARE salespeople CURSOR FOR 
        SELECT ENAME, SAL, COMM 
            FROM EMP 
            WHERE JOB LIKE &#39;SALES%&#39;; 
 
/* Open the cursor. */
    EXEC SQL OPEN salespeople; 
 
/* Get ready to print results. */
    printf(&#34;\n\nThe company&#39;s salespeople are--\n\n&#34;);
    printf(&#34;Salesperson   Salary   Commission\n&#34;); 
    printf(&#34;-----------   ------   ----------\n&#34;); 
 
/* Loop, fetching all salesperson&#39;s statistics.
 * Cause the program to break the loop when no more
 * data can be retrieved on the cursor.
 */
    EXEC SQL WHENEVER NOT FOUND DO break; 

    for (;;) 
    { 
        EXEC SQL FETCH salespeople INTO :emp_rec_ptr; 
        printf(&#34;%-11s%9.2f%13.2f\n&#34;, emp_rec_ptr-&gt;emp_name, 
                emp_rec_ptr-&gt;salary, emp_rec_ptr-&gt;commission); 
    } 
 
/* Close the cursor. */
    EXEC SQL CLOSE salespeople; 
 
    printf(&#34;\nArrivederci.\n\n&#34;);

    EXEC SQL COMMIT WORK RELEASE; 
    exit(0); 
} 



void 
sql_error(msg) 
char *msg;
{ 
    char err_msg[512];
    int buf_len, msg_len;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    printf(&#34;\n%s\n&#34;, msg);

/* Call sqlglm() to get the complete text of the
 * error message.
 */
    buf_len = sizeof (err_msg);
    sqlglm(err_msg, &amp;buf_len, &amp;msg_len);
    printf(&#34;%.*s\n&#34;, msg_len, err_msg);

    EXEC SQL ROLLBACK RELEASE;
    exit(1);
} 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i9172"></a>
<div id="LNPCC3240" class="sect1">
<h2 class="sect1">Pointer Variables</h2>
<p>C supports <span class="italic">pointers</span>, which &#34;point&#34; to other variables. A pointer holds the address (storage location) of a variable, not its value.<a id="sthref559"></a></p>
<div id="LNPCC3241" class="sect2"><a id="sthref560"></a>
<h3 class="sect2">Pointer Variable Declaration</h3>
<p>You define pointers as host variables following the normal C practice, as the next example shows:<a id="sthref561"></a><a id="sthref562"></a></p>
<pre>int   *int_ptr; 
char  *char_ptr;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCC3242" class="sect2"><a id="sthref563"></a>
<h3 class="sect2">Pointer Variable Referencing</h3>
<p>In SQL statements, prefix pointers with a colon, as shown in the following example:<a id="sthref564"></a></p>
<pre>EXEC SQL SELECT intcol INTO :int_ptr FROM ... 
</pre>
<p>Except for pointers to character strings, the size of the referenced value is given by the size of the base type specified in the declaration. For pointers to character strings, the referenced value is assumed to be a NULL-terminated string. Its size is determined at run time by calling the <code>strlen()</code> function. For details, see also <a href="#i22611">&#34;Globalization Support&#34;</a>.<a id="sthref565"></a></p>
<p>You can use pointers to reference the members of a <span class="bold">struct</span>. First, declare a pointer host variable, then set the pointer to the address of the desired member, as shown in the example later. The datatypes of the <span class="bold">struct</span> member and the pointer variable must be the same. Most compilers will warn you of a mismatch.<a id="sthref566"></a></p>
<pre>struct 
{ 
    int  i; 
    char c; 
} structvar; 
int   *i_ptr; 
char  *c_ptr; 
... 
main() 
{ 
    i_ptr = &amp;structvar.i; 
    c_ptr = &amp;structvar.c; 
/* Use i_ptr and c_ptr in SQL statements. */ 
... 
</pre></div>
<!-- class="sect2" -->
<a id="i13390"></a>
<div id="LNPCC3243" class="sect2">
<h3 class="sect2">Structure Pointers <a id="sthref567"></a></h3>
<p>You can use a pointer to a structure as a host variable. The following example</p>
<ul>
<li>
<p>Declares a structure</p>
</li>
<li>
<p>Declares a pointer to the structure</p>
</li>
<li>
<p>Allocates memory for the structure</p>
</li>
<li>
<p>Uses the struct pointer as a host variable in a query</p>
</li>
<li>
<p>Dereferences the struct components to print the results</p>
</li>
</ul>
<pre>struct EMP_REC 
{ 
    int emp_number; 
    float salary; 
}; 
char *name = &#34;HINAULT&#34;; 
... 
struct EMP_REC *sal_rec; 
sal_rec = (struct EMP_REC *) malloc(sizeof (struct EMP_REC)); 
... 
EXEC SQL SELECT empno, sal INTO :sal_rec 
    FROM emp 
    WHERE ename = :name; 

printf(&#34;Employee number and salary for %s: &#34;, name); 
printf(&#34;%d, %g\n&#34;, sal_rec-&gt;emp_number, sal_rec-&gt;salary);
</pre>
<p>In the SQL statement, pointers to host structures are referred to in exactly the same way as a host structure. The &#34;address of&#34; notation (<span class="bold">&amp;</span>) is not required; in fact, it is an error to use it.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i22611"></a>
<div id="LNPCC3244" class="sect1">
<h2 class="sect1">Globalization Support</h2>
<p>Although the widely-used 7- or 8-bit ASCII and EBCDIC character sets are adequate to represent the Roman alphabet, some Asian languages, such as Japanese, contain thousands of characters. These languages can require at least 16 bits (two bytes) to represent each character. How does Oracle deal with such dissimilar languages?</p>
<p>Oracle provides Globalization Support, which lets you process single-byte and multibyte character data and convert between character sets. It also lets your applications run in different language environments. With Globalization Support, number and date formats adapt automatically to the language conventions specified for a user session. Thus, Globalization Support allows users around the world to interact with Oracle in their native languages.</p>
<p>You control the operation of language-dependent features by specifying various Globalization Support or NLS parameters. Default values for these parameters can be set in the Oracle initialization file. <a href="#i22631">Table 4-6</a> shows what each Globalization Support parameter specifies.<a id="sthref568"></a><a id="sthref569"></a><a id="sthref570"></a><a id="sthref571"></a><a id="sthref572"></a><a id="sthref573"></a><a id="sthref574"></a><a id="sthref575"></a><a id="sthref576"></a></p>
<div id="LNPCC3245" class="tblformal">
<p class="titleintable"><a id="sthref577"></a><a id="sthref578"></a>Table 4-6 <a id="i22631"></a> <span class="bold">Globalization Support Parameters</span></p>
<table class="cellalignment831" title=" Globalization Support Parameters" summary="Globalization Suport Parameters" dir="ltr">
<thead>
<tr class="cellalignment825">
<th class="cellalignment832" id="r1c1-t36">Globalization Support Parameter</th>
<th class="cellalignment832" id="r1c2-t36">Specifies</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment825">
<td class="cellalignment833" id="r2c1-t36" headers="r1c1-t36">
<p>NLS_LANGUAGE</p>
</td>
<td class="cellalignment833" headers="r2c1-t36 r1c2-t36">
<p>language-dependent conventions</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r3c1-t36" headers="r1c1-t36">
<p>NLS_TERRITORY</p>
</td>
<td class="cellalignment833" headers="r3c1-t36 r1c2-t36">
<p>territory-dependent conventions</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r4c1-t36" headers="r1c1-t36">
<p>NLS_DATE_FORMAT</p>
</td>
<td class="cellalignment833" headers="r4c1-t36 r1c2-t36">
<p>date format</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r5c1-t36" headers="r1c1-t36">
<p>NLS_DATE_LANGUAGE</p>
</td>
<td class="cellalignment833" headers="r5c1-t36 r1c2-t36">
<p>language for day and month names</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r6c1-t36" headers="r1c1-t36">
<p>NLS_NUMERIC_CHARACTERS</p>
</td>
<td class="cellalignment833" headers="r6c1-t36 r1c2-t36">
<p>decimal character and group separator</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r7c1-t36" headers="r1c1-t36">
<p>NLS_CURRENCY</p>
</td>
<td class="cellalignment833" headers="r7c1-t36 r1c2-t36">
<p>local currency symbol</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r8c1-t36" headers="r1c1-t36">
<p>NLS_ISO_CURRENCY</p>
</td>
<td class="cellalignment833" headers="r8c1-t36 r1c2-t36">
<p>ISO currency symbol</p>
</td>
</tr>
<tr class="cellalignment825">
<td class="cellalignment833" id="r9c1-t36" headers="r1c1-t36">
<p>NLS_SORT</p>
</td>
<td class="cellalignment833" headers="r9c1-t36 r1c2-t36">
<p>sort sequence</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The main parameters are NLS_LANGUAGE and NLS_TERRITORY. NLS_LANGUAGE specifies the default values for language-dependent features, which include:</p>
<ul>
<li>
<p>Language for server messages</p>
</li>
<li>
<p>Language for day and month names</p>
</li>
<li>
<p>Sort sequence</p>
</li>
</ul>
<p>NLS_TERRITORY specifies the default values for territory-dependent features, which include</p>
<ul>
<li>
<p>Date format</p>
</li>
<li>
<p>Decimal character</p>
</li>
<li>
<p>Group separator</p>
</li>
<li>
<p>Local currency symbol</p>
</li>
<li>
<p>ISO currency symbol</p>
</li>
</ul>
<p>You can control the operation of language-dependent Globalization Support features for a user session by specifying the parameter NLS_LANG as follows: <a id="sthref579"></a></p>
<pre>NLS_LANG = &lt;language&gt;_&lt;territory&gt;.&lt;character set&gt; 
</pre>
<p>where <span class="italic">language</span> specifies the value of NLS_LANGUAGE for the user session, <span class="italic">territory</span> specifies the value of NLS_TERRITORY, and <span class="italic">character set</span> specifies the encoding scheme used for the terminal. An <span class="italic">encoding scheme</span> (usually called a character set or code page) is a range of numeric codes that corresponds to the set of characters a terminal can display. It also includes codes that control communication with the terminal.<a id="sthref580"></a><a id="sthref581"></a><a id="sthref582"></a></p>
<p>You define NLS_LANG as an environment variable (or the equivalent on your system). For example, on UNIX using the C shell, you might define NLS_LANG as follows:</p>
<pre>setenv NLS_LANG French_France.WE8ISO8859P1 
</pre>
<p>During an Oracle database session you can change the values of Globalization Support parameters. Use the ALTER SESSION statement as follows:</p>
<pre>ALTER SESSION SET &lt;globalization support_parameter&gt; = &lt;value&gt;
</pre>
<p>Pro*C/C++ fully supports all the Globalization Support features that allow your applications to process foreign language data stored in an Oracle database. For example, you can declare foreign language character variables and pass them to string functions such as INSTRB, LENGTHB, and SUBSTRB. These functions have the same syntax as the INSTR, LENGTH, and SUBSTR functions, respectively, but operate on a byte-by-byte basis rather than a character-by-character basis.<a id="sthref583"></a></p>
<p>You can use the functions NLS_INITCAP, NLS_LOWER, and NLS_UPPER to handle special instances of case conversion. And, you can use the function NLSSORT to specify WHERE-clause comparisons based on linguistic rather than binary ordering. You can even pass globalization support parameters to the TO_CHAR, TO_DATE, and TO_NUMBER functions. For more information about Globalization Support, see <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide.</span></a></p>
</div>
<!-- class="sect1" -->
<a id="i22704"></a>
<div id="LNPCC3246" class="sect1">
<h2 class="sect1">NCHAR Variables</h2>
<p>Three internal database datatypes can store National Character Set data. They are <span class="italic">NCHAR, NCLOB,</span> and <span class="italic">NVARCHAR2</span> (also known as <span class="italic">NCHAR VARYING)</span>. You use these datatypes only in relational columns.</p>
<a id="i22710"></a>
<div id="LNPCC3247" class="sect2">
<h3 class="sect2">CHARACTER SET [IS] NCHAR_CS</h3>
<p>To specify which host variables hold National Character Set data, insert the clause &#34;<span class="italic">CHARACTER SET [IS] NCHAR_CS&#34;</span> in character variable declarations. Then you are able to store National Character Set data in those variables. You can omit the token <span class="italic">IS</span>. NCHAR_CS is the name of the National Character Set.</p>
<p>For example:</p>
<pre>char character set is nchar_cs *str = <span class="bold">&#34;&lt;</span>Japanese_string&gt;<span class="bold">&#34;;</span>
</pre>
<p>In this example, <span class="italic">&lt;Japanese_string&gt;</span> consists of Unicode characters that are in the National Character Set <span class="italic">AL16UTF16</span>, as defined by the variable NLS_NCHAR.</p>
<p>You can accomplish the same thing by entering NLS_CHAR=str on the command line, and coding in your application:</p>
<pre>char *str = &#34;&lt;Japanese_string&gt;&#34;
</pre>
<p>Pro*C/C++ treats variables declared this way as of the character set specified by the environment variable <span class="italic">NLS_NCHAR</span>. The variable size of an NCHAR variable is specified as a byte count, the same way that ordinary C variables are.</p>
<p>To select data into str, use the following simple query:</p>
<pre>EXEC SQL
   SELECT ENAME INTO :str FROM EMP WHERE DEPT = n&#39;&lt;Japanese_string1&gt;&#39;;
</pre>
<p>Or, you can use <span class="italic">str</span> in the following SELECT:</p>
<pre>EXEC SQL 
   SELECT DEPT INTO :dept FROM DEPT_TAB WHERE ENAME = :str;
</pre></div>
<!-- class="sect2" -->
<a id="i22729"></a>
<div id="LNPCC3248" class="sect2">
<h3 class="sect2">Environment Variable NLS_NCHAR</h3>
<p>Pro*C/C++ supports National Character Sets with database support when NLS_LOCAL=NO. When NLS_LOCAL=NO, and the new environmental variable NLS_NCHAR is set to a valid National Character Set, the database server supports NCHAR. See NLS_NCHAR in the <a class="olink REFRN" href="../REFRN/toc.htm"><span class="italic">Oracle Database Reference</span></a>.</p>
<p>NLS_NCHAR specifies the character set used for National Character Set data (NCHAR, NVARCHAR2, NCLOB). If it is not specified, the character set defined or indirectly defined by NLS_LANG will be used.</p>
<p>NLS_NCHAR must have a valid National Character Set specification (not a language name, that is set by NLS_LANG) at both precompile-time and runtime. SQLLIB performs a runtime check when the first SQL statement is executed. If the precompile-time and runtime character sets are different, SQLLIB will return an error code.</p>
</div>
<!-- class="sect2" -->
<a id="i22733"></a>
<div id="LNPCC3249" class="sect2">
<h3 class="sect2">CONVBUFSZ Clause in VAR<a id="sthref584"></a><a id="sthref585"></a></h3>
<p>You can override the default assignments by equivalencing host variables to Oracle external datatypes, using the EXEC SQL VAR statement, This is called <span class="italic">host variable equivalencing</span>.</p>
<p>The EXEC SQL VAR statement can have an optional clause: <code>CONVBUFSZ (&lt;size&gt;)</code>. You specify the size, <code>&lt;size&gt;</code>, in bytes, of the buffer in the Oracle runtime library used to perform conversion of the specified host variable between character sets.</p>
<p>The new syntax is:</p>
<pre>EXEC SQL VAR <span class="italic">host_variable</span> IS <span class="italic">datatype</span> [CONVBUFSZ [IS] (<span class="italic">size</span>)] ;
</pre>
<dl>
<dd>
<p>or</p>
<pre>EXEC SQL VAR <span class="italic">host_variable</span> [CONVBUFSZ [IS] (<span class="italic">size</span>)];
</pre>
<p>where <span class="italic">datatype</span> is:</p>
<pre><span class="italic">type_name</span> [ ( { <span class="italic">length</span> | <span class="italic">precision</span>, <span class="italic">scale</span> } ) ]
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_afemb.htm#CHEDHEEB">&#34;VAR (Oracle Embedded SQL Directive)&#34;</a> for a complete discussion of all keywords, examples, and variables.</div>
</dd>
</dl>
</div>
<!-- class="sect2" -->
<div id="LNPCC3250" class="sect2"><a id="sthref586"></a>
<h3 class="sect2">Character Strings in Embedded SQL <a id="sthref587"></a></h3>
<p>A multibyte character string in an embedded SQL statement consists of a character literal that identifies the string as multibyte, immediately followed by the string. The string is enclosed in the usual single quotes.</p>
<p>For example, an embedded SQL statement such as</p>
<pre>EXEC SQL SELECT empno INTO :emp_num FROM emp
    WHERE ename = N&#39;&lt;Japanese_string&gt;&#39;;
</pre>
<p>contains a multibyte character string (&lt;Japanese_string&gt; could actually be Kanji), since the N character literal preceding the string identifies it as a multibyte string. Since Oracle is case-insensitive, you can use &#34;n&#34; or &#34;N&#34; in the example.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3251" class="sect2"><a id="sthref588"></a>
<h3 class="sect2">Strings Restrictions</h3>
<p>You cannot use datatype equivalencing (the TYPE or VAR commands) with multibyte character strings.</p>
<p>Dynamic SQL method 4 is not available for multibyte character string host variables in Pro*C/C++.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCC3252" class="sect2"><a id="sthref589"></a>
<h3 class="sect2">Indicator Variables <a id="sthref590"></a></h3>
<p>You can use indicator variables with host character variables that are multibyte characters (as specified using the NLS_CHAR option).</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment824">
<tr>
<td class="cellalignment833">
<table class="cellalignment829">
<tr>
<td class="cellalignment828"><a href="pc_03dbc.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment828"><a href="pc_05adv.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment836">
<table class="cellalignment827">
<tr>
<td class="cellalignment828"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment828"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment828"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment828"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment828"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment828"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>