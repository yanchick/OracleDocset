<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-104239"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Managing%20Oracle%20Streams%20Replication"></a><title>Managing Oracle Streams Replication</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1044"/>
<meta name="dcterms.created" content="2015-02-12T7:14:20Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Streams Replication Administrator&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53118-02"/>
<meta name="dcterms.isVersionOf" content="STREP"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2003, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="ptrep_admin.htm" title="Previous" type="text/html"/>
<link rel="Next" href="man_comp.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53118-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">18/28</span> <!-- End Header -->
<div id="STREP013" class="chapter"><a id="CEGHBBIC"></a>
<h1 class="chapter"><span class="secnum">12</span> Managing Oracle Streams Replication</h1>
<p><a id="sthref558"></a><a id="sthref559"></a><a id="sthref560"></a>This chapter contains instructions for managing an Oracle Streams replication environment.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#CEGGEDFB">About Managing Oracle Streams</a></p>
</li>
<li>
<p><a href="#BABBFAJD">Tracking LCRs Through a Stream</a></p>
</li>
<li>
<p><a href="#CEGDFGJJ">Splitting and Merging an Oracle Streams Destination</a></p>
</li>
<li>
<p><a href="#i1019206">Changing the DBID or Global Name of a Source Database</a></p>
</li>
<li>
<p><a href="#i1016713">Resynchronizing a Source Database in a Multiple-Source Environment</a></p>
</li>
<li>
<p><a href="#i1014311">Performing Database Point-in-Time Recovery in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1016872">Running Flashback Queries in an Oracle Streams Replication Environment</a></p>
</li>
<li>
<p><a href="#CEGICHAA">Recovering from Operation Errors</a></p>
</li>
</ul>
<a id="CEGGEDFB"></a>
<div id="STREP433" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">About Managing Oracle Streams</h2>
<p>After an Oracle Streams replication environment is in place, you can manage the Oracle Streams components at each database. Management includes administering the components. For example, you can set capture process parameters to modify the behavior of a capture process. Management also includes monitoring the Oracle Streams components and troubleshooting them if there are problems.</p>
<p>The following documentation provides instructions for managing Oracle Streams:</p>
<ul>
<li>
<p><a class="olink STRMS" href="../STRMS/toc.htm"><span class="italic">Oracle Streams Concepts and Administration</span></a> provides detailed instructions about managing Oracle Streams components.</p>
</li>
<li>
<p><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span> (this document) provides instructions that are specific to an Oracle Streams replication environment.</p>
</li>
<li>
<p>The online help for the Oracle Streams interface in Oracle Enterprise Manager Cloud Control provides information about managing Oracle Streams with Oracle Enterprise Manager Cloud Control.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BABBFAJD"></a>
<div id="STREP145" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Tracking LCRs Through a Stream<a id="sthref561"></a><a id="sthref562"></a><a id="sthref563"></a><a id="sthref564"></a><a id="sthref565"></a><a id="sthref566"></a><a id="sthref567"></a><a id="sthref568"></a><a id="sthref569"></a></h2>
<p>A logical change record (LCR) typically flows through a stream in the following way:</p>
<ol>
<li>
<p>A database change is captured, formatted into an LCR, and enqueued. A capture process or a synchronous capture can capture database changes implicitly. An application or user can construct and enqueue LCRs to capture database changes explicitly.</p>
</li>
<li>
<p>One or more propagations send the LCR to other databases in the Oracle Streams environment.</p>
</li>
<li>
<p>One or more apply processes dequeue the LCR and process it.</p>
</li>
</ol>
<p>You can track an LCR through a stream using one of the following methods:</p>
<ul>
<li>
<p>When LCRs are captured by a capture process, you can set the <code dir="ltr">message_tracking_frequency</code> capture process parameter to <code dir="ltr">1</code> or another relatively low value.</p>
</li>
<li>
<p>When LCRs are captured by a capture process or a synchronous capture, or when LCRs are constructed by an application, you can run the <code dir="ltr">SET_MESSAGE_TRACKING</code> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package.</p>
</li>
</ul>
<p>LCR tracking is useful if LCRs are not being applied as expected by one or more apply processes. When this happens, you can use LCR tracking to determine where the LCRs are stopping in the stream and address the problem at that location.</p>
<p>After using one of these methods to track LCRs, use the <code dir="ltr">V$STREAMS_MESSAGE_TRACKING</code> view to monitor the progress of LCRs through a stream. By tracking an LCR through the stream, you can determine where the LCR is blocked. After LCR tracking is started, each LCR includes a tracking label.</p>
<p>When LCR tracking is started using the <code dir="ltr">message_tracking_frequency</code> capture process parameter, the tracking label is <code dir="ltr"><span class="codeinlineitalic">capture_process_name:</span></code><code dir="ltr">AUTOTRACK</code>, where <code dir="ltr"><span class="codeinlineitalic">capture_process_name</span></code> is the name of the capture process. Only the first 20 bytes of the capture process name are used; the rest is truncated if it exceeds 20 bytes.</p>
<p>The <code dir="ltr">SET_MESSAGE_TRACKING</code> procedure enables you to specify a tracking label that becomes part of each LCR generated by the current session. Using this tracking label, you can query the <code dir="ltr">V$STREAMS_MESSAGE_TRACKING</code> view to track the LCRs through the stream and see how they were processed by each Oracle Streams client. When you use the <code dir="ltr">SET_MESSAGE_TRACKING</code> procedure, the following LCRs are tracked:</p>
<ul>
<li>
<p>When a capture process or a synchronous capture captures an LCR, and a tracking label is set for the session that made the captured database change, the tracking label is included in the LCR automatically.</p>
</li>
<li>
<p>When a user or application constructs an LCR and a tracking label is set for the session that constructs the LCR, the tracking label is included in the LCR automatically.</p>
</li>
</ul>
<p>To track LCRs through a stream, complete the following steps:</p>
<ol>
<li id="CEGJAAJB">
<p>Start LCR tracking.</p>
<p>You can start LCR tracking in one of the following ways:</p>
<ul>
<li>
<p>Connect to database running the capture process and set the <code dir="ltr">message_tracking_frequency</code> capture process parameter to <code dir="ltr">1</code> or another relatively low value. After setting the capture process parameter, proceed to Step <a href="#CEGCBDHI">2</a>.</p>
<p>See <a class="olink STRMS630" href="../STRMS/strms_mcap.htm#STRMS630"><span class="italic">Oracle Streams Concepts and Administration</span></a> for information about setting capture process parameters.</p>
<p>See <a class="olink ADMIN00102" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=ADMIN00102"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for instructions about connecting to a database in SQL*Plus.</p>
</li>
<li>
<p>Run the <code dir="ltr">SET_MESSAGE_TRACKING</code> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package by completing the following steps:</p>
</li>
</ul>
<ol>
<li>
<p>In SQL*Plus, start a session. To use a tracking label for database changes captured by a capture process or synchronous capture, connect to the source database for the capture process or synchronous capture.</p>
</li>
<li id="BABCFBAA">
<p>Begin message tracking:</p>
<pre dir="ltr">BEGIN
  DBMS_STREAMS_ADM.SET_MESSAGE_TRACKING(
    tracking_label =&gt; &#39;TRACK_LCRS&#39;);
END;
/
</pre>
<p>You can use any label you choose to track LCRs. This example uses the <code dir="ltr">TRACK_LCRS</code> label.</p>
<p>Information about the LCRs is tracked in memory, and the <code dir="ltr">V$STREAMS_MESSAGE_TRACKING</code> dynamic performance view is populated with information about the LCRs.</p>
</li>
<li>
<p>Optionally, to ensure that message tracking is set in the session, query the tracking label:</p>
<pre dir="ltr">SELECT DBMS_STREAMS_ADM.GET_MESSAGE_TRACKING() TRACKING_LABEL FROM DUAL;
</pre>
<p>This query should return the tracking label you specified in Step <a href="#BABCFBAA">b</a>:</p>
<pre dir="ltr">TRACKING_LABEL
--------------------------------------------------------------------------
TRACK_LCRS
</pre></li>
</ol>
</li>
<li id="CEGCBDHI">
<p>Make changes to the source database that will be captured by the capture process or synchronous capture that starts the stream, or construct and enqueue the LCRs you want to track. Typically, these LCRs are for testing purposes only. For example, you can insert several dummy rows into a table and then modify these rows. When the testing is complete, you can delete the rows.</p>
</li>
<li>
<p>Monitor the entire Oracle Streams environment to track the LCRs. To do so, query the <code dir="ltr">V$STREAMS_MESSAGE_TRACKING</code> view at each database that processes the LCRs.</p>
<p>For example, run the following query at each database:</p>
<pre dir="ltr">COLUMN COMPONENT_NAME HEADING &#39;Component|Name&#39; FORMAT A10
COLUMN COMPONENT_TYPE HEADING &#39;Component|Type&#39; FORMAT A12
COLUMN ACTION HEADING &#39;Action&#39; FORMAT A11
COLUMN SOURCE_DATABASE_NAME HEADING &#39;Source|Database&#39; FORMAT A10
COLUMN OBJECT_OWNER HEADING &#39;Object|Owner&#39; FORMAT A6
COLUMN OBJECT_NAME HEADING &#39;Object|Name&#39; FORMAT A10
COLUMN COMMAND_TYPE HEADING &#39;Command|Type&#39; FORMAT A7
 
SELECT COMPONENT_NAME,
       COMPONENT_TYPE,
       ACTION,
       SOURCE_DATABASE_NAME,
       OBJECT_OWNER,
       OBJECT_NAME,
       COMMAND_TYPE
   FROM V$STREAMS_MESSAGE_TRACKING;
</pre>
<p>Ensure that you specify the correct tracking label in the <code dir="ltr">WHERE</code> clause.</p>
<p>These queries will show how the LCRs were processed at each database. If the LCRs are not being applied at destination databases, then these queries will show where in the stream the LCRs are stopping.</p>
<p>For example, the output at a source database with a synchronous capture is similar to the following:</p>
<pre dir="ltr">Component  Component                Source     Object Object     Command
Name       Type         Action      Database   Owner  Name       Type
---------- ------------ ----------- ---------- ------ ---------- -------
CAPTURE    SYNCHRONOUS  Create      HUB.EXAMPL HR     EMPLOYEES  UPDATE
           CAPTURE                  E.COM
CAPTURE    SYNCHRONOUS  Rule evalua HUB.EXAMPL HR     EMPLOYEES  UPDATE
           CAPTURE      tion        E.COM
CAPTURE    SYNCHRONOUS  Enqueue     HUB.EXAMPL HR     EMPLOYEES  UPDATE
           CAPTURE                  E.COM
</pre>
<p>The output at a destination database with an apply process is similar to the following:</p>
<pre dir="ltr">Component  Component                Source     Object Object     Command
Name       Type         Action      Database   Owner  Name       Type
---------- ------------ ----------- ---------- ------ ---------- -------
APPLY_SYNC APPLY READER Dequeue     HUB.EXAMPL HR     EMPLOYEES  UPDATE
_CAP                                E.COM
APPLY_SYNC APPLY READER Dequeue     HUB.EXAMPL HR     EMPLOYEES  UPDATE
_CAP                                E.COM
APPLY_SYNC APPLY READER Dequeue     HUB.EXAMPL HR     EMPLOYEES  UPDATE
_CAP                                E.COM
</pre>
<p>You can query additional columns in the <code dir="ltr">V$STREAMS_MESSAGE_TRACKING</code> view to display more information. For example, the <code dir="ltr">ACTION_DETAILS</code> column provides detailed information about each action.</p>
</li>
<li>
<p>Stop message tracking. Complete one of the following actions based your choice in Step <a href="#CEGJAAJB">1</a>:</p>
<ul>
<li>
<p>If you set the <code dir="ltr">message_tracking_frequency</code> capture process parameter in Step <a href="#CEGJAAJB">1</a>, then set this parameter back to its default value. The default is to track every two-millionth message.</p>
<p>To set this capture process parameter back to its default value, connect to database running the capture process and set the <code dir="ltr">message_tracking_frequency</code> capture process parameter to <code dir="ltr">NULL</code>.</p>
<p>See <a class="olink STRMS630" href="../STRMS/strms_mcap.htm#STRMS630"><span class="italic">Oracle Streams Concepts and Administration</span></a> for information about setting capture process parameters.</p>
</li>
<li>
<p>If you started message tracking in the current session, then stop message tracking in the session.</p>
<p>To stop message tracking in the current session, set the <code dir="ltr">tracking_label</code> parameter to <code dir="ltr">NULL</code> in the <code dir="ltr">SET_MESSAGE_TRACKING</code> procedure:</p>
<pre dir="ltr">BEGIN
  DBMS_STREAMS_ADM.SET_MESSAGE_TRACKING(
    tracking_label =&gt; NULL,
    actions        =&gt; DBMS_STREAMS_ADM.ACTION_MEMORY);
END;
/
</pre></li>
</ul>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS306" href="../ARPLS/d_cap_a.htm#ARPLS306"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code dir="ltr">message_tracking_frequency</code> capture process parameter</div>
</div>
<!-- class="sect1" -->
<a id="CEGDFGJJ"></a>
<div id="STREP144" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Splitting and Merging an Oracle Streams Destination<a id="sthref570"></a><a id="sthref571"></a><a id="sthref572"></a></h2>
<p>The following sections describe how to split and merge streams and provide examples that do so:</p>
<ul>
<li>
<p><a href="#CEGDDCGI">About Splitting and Merging Oracle Streams</a></p>
</li>
<li>
<p><a href="#CEGIIAIE">Split and Merge Options</a></p>
</li>
<li>
<p><a href="#CEGDFAGE">Examples That Split and Merge Oracle Streams</a></p>
</li>
</ul>
<a id="CEGDDCGI"></a>
<div id="STREP434" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">About Splitting and Merging Oracle Streams</h3>
<p>Splitting and merging an Oracle Streams destination is useful under the following conditions:</p>
<ul>
<li>
<p>A single capture process captures changes that are sent to two or more apply processes.</p>
</li>
<li>
<p>An apply process stops accepting changes captured by the capture process. The apply process might stop accepting changes if, for example, the apply process is disabled, the database that contains the apply process goes down, there is a network problem, the computer system running the database that contains the apply process goes down, or for some other reason.</p>
</li>
</ul>
<p>When these conditions are met, it is best to split the problem destination off from the other destinations. The reason to split the destination off depends on whether the configuration uses the combined capture and apply optimization:</p>
<ul>
<li>
<p>If the apply process at the problem destination is part of a combined capture and apply optimization and the destination is not split off, then performance will suffer when the destination becomes available again. In this case, the capture process must capture the changes that must now be applied at the destination previously split off. The other destinations will not receive more recent changes until the problem destination has caught up. However, if the problem destination is split off, then it can catch up to the other destinations independently, without affecting the other destinations.</p>
</li>
<li>
<p>If the apply process at the destination is not part of a combined capture and apply optimization, then captured changes that cannot be sent to the problem destination queue remain in the source queue, causing the source queue size to increase. Eventually, the source queue will spill captured logical change records (LCRs) to hard disk, and the performance of the Oracle Streams replication environment will suffer.</p>
</li>
</ul>
<p>Split and merge operations are possible in the following types of Oracle Streams replication environments:</p>
<ul>
<li>
<p>Changes captured by a single capture process are sent to multiple remote destinations using propagations and are applied by apply processes at the remote destinations.</p>
</li>
<li>
<p>Changes captured by a single capture process are applied locally by multiple apply processes on the same database that is running the capture process.</p>
</li>
<li>
<p>Changes captured by a single capture process are sent to one or more remote destinations using propagations and are applied locally by one or more apply processes on the same database that is running the capture process.</p>
</li>
</ul>
<p>For environment with local capture and apply, split and merge operations are possible when the capture process and apply processes share the same queue, and when a propagation sends changes from the capture process&#39;s queue to an apply process&#39;s queue within the one database.</p>
<p><a href="#CEGIHGEF">Figure 12-1</a> shows an Oracle Streams replication environment that uses propagations to send changes to multiple destinations. In this example, destination database A is down.</p>
<div id="STREP435" class="figure">
<p class="titleinfigure"><a id="CEGIHGEF"></a>Figure 12-1 Problem Destination in an Oracle Streams Replication Environment</p>
<img width="575" height="767" src="img/strep059.gif" alt="Description of Figure 12-1 follows"/><br/>
<a id="sthref573" href="img_text/strep059.htm">Description of &#34;Figure 12-1 Problem Destination in an Oracle Streams Replication Environment&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>You can use the following data dictionary views to determine when there is a problem with a stream:</p>
<ul>
<li>
<p>Query the <code dir="ltr">V$BUFFERED_QUEUES</code> view to identify how many messages are in a buffered queue and how many of these messages have spilled to hard disk.</p>
</li>
<li>
<p>When propagations are used, query the <code dir="ltr">DBA_PROPAGATION</code> and <code dir="ltr">V$PROPAGATION_SENDER</code> views to show the propagations in a database and the status of each propagation</p>
</li>
</ul>
<p>To avoid degraded performance in this situation, split the stream that flows to the problem database off from the other streams flowing from the capture process. When the problem is corrected, merge the stream back into the other streams flowing from the capture process.</p>
<p>You can configure capture process parameters to split and merge a problem stream automatically, or you can split and merge a problem stream manually. Either way, the <code dir="ltr">SPLIT_STREAMS</code>, <code dir="ltr">MERGE_STREAMS_JOB</code>, and <code dir="ltr">MERGE_STREAMS</code> procedures in the <code dir="ltr">DBMS_STREAMS_ADM</code> package are used. The <code dir="ltr">SPLIT_STREAMS</code> procedure splits off the stream for the problem destination from all of the other streams flowing from a capture process to other destinations. The <code dir="ltr">SPLIT_STREAMS</code> procedure always clones the capture process and the queue. The <code dir="ltr">SPLIT_STREAMS</code> procedure also clones the propagation in an environment that sends changes to remote destination databases. The cloned versions of these components are used by the stream that is split off. While the problem stream is split off, the streams to other destinations proceed as usual.</p>
<p><a href="#CEGIIBEC">Figure 12-2</a> shows the cloned stream created by the <code dir="ltr">SPLIT_STREAMS</code> procedure.</p>
<div id="STREP436" class="figure">
<p class="titleinfigure"><a id="CEGIIBEC"></a>Figure 12-2 Splitting Oracle Streams</p>
<img width="575" height="767" src="img/strep060.gif" alt="Description of Figure 12-2 follows"/><br/>
<a id="sthref574" href="img_text/strep060.htm">Description of &#34;Figure 12-2 Splitting Oracle Streams&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>When the problem destination becomes available again, the cloned stream begins to send captured changes to the destination database again.</p>
<p><a href="#CEGCEDJF">Figure 12-3</a> shows a destination database A that is up and running and a cloned capture process that is enabled at the capture database. The cloned stream begins to flow and starts to catch up to the original streams.</p>
<div id="STREP437" class="figure">
<p class="titleinfigure"><a id="CEGCEDJF"></a>Figure 12-3 Cloned Stream Begins Flowing and Starts to Catch Up to One Original Stream</p>
<img width="575" height="767" src="img/strep061.gif" alt="Description of Figure 12-3 follows"/><br/>
<a id="sthref575" href="img_text/strep061.htm">Description of &#34;Figure 12-3 Cloned Stream Begins Flowing and Starts to Catch Up to One Original Stream&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>When the cloned stream catches up to one of the original streams, one of the following procedures merges the streams:</p>
<ul>
<li>
<p>The <code dir="ltr">MERGE_STREAMS</code> procedure merges the stream that was split off back into the other streams flowing from the original capture process.</p>
</li>
<li>
<p>The <code dir="ltr">MERGE_STREAMS_JOB</code> procedure determines whether the streams are within the user-specified merge threshold. If they are, then the <code dir="ltr">MERGE_STREAMS_JOB</code> procedure runs the <code dir="ltr">MERGE_STREAMS</code> procedure. If the streams are not within the merge threshold, then the <code dir="ltr">MERGE_STREAMS_JOB</code> procedure does nothing.</p>
</li>
</ul>
<p>Typically, it is best to run the <code dir="ltr">MERGE_STREAMS_JOB</code> procedure instead of running the <code dir="ltr">MERGE_STREAMS</code> procedure directly, because the <code dir="ltr">MERGE_STREAMS_JOB</code> procedure automatically determines whether the streams are ready to merge before merging them.</p>
<p><a href="#CEGBEDJH">Figure 12-4</a> shows the results of running the <code dir="ltr">MERGE_STREAMS</code> procedure. The Oracle Streams replication environment has its original components, and all of the streams are flowing normally.</p>
<div id="STREP438" class="figure">
<p class="titleinfigure"><a id="CEGBEDJH"></a>Figure 12-4 Merging Oracle Streams</p>
<img width="575" height="767" src="img/strep062.gif" alt="Description of Figure 12-4 follows"/><br/>
<a id="sthref576" href="img_text/strep062.htm">Description of &#34;Figure 12-4 Merging Oracle Streams&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS171" href="../STRMS/strms_adcca.htm#STRMS171"><span class="italic">Oracle Streams Concepts and Administration</span></a> for information about combined capture and apply</div>
</div>
<!-- class="sect2" -->
<a id="CEGIIAIE"></a>
<div id="STREP592" class="sect2">
<h3 class="sect2">Split and Merge Options</h3>
<p>The following split and merge options are available:</p>
<ul>
<li>
<p><a href="#CEGGJBIJ">Automatic Split and Merge</a></p>
</li>
<li>
<p><a href="#CEGDBFGJ">Manual Split and Automatic Merge</a></p>
</li>
<li>
<p><a href="#CEGGEGDH">Manual Split and Merge With Generated Scripts</a></p>
</li>
</ul>
<a id="CEGGJBIJ"></a>
<div id="STREP593" class="sect3">
<h4 class="sect3">Automatic Split and Merge<a id="sthref577"></a><a id="sthref578"></a></h4>
<p>You can set two capture process parameters, <code dir="ltr">split_threshold</code> and <code dir="ltr">merge_theshold</code>, so that Oracle Streams performs split and merge operations automatically. When these parameters are set to specify automatic split and merge, an Oracle Scheduler job monitors the streams flowing from the capture process. When an Oracle Scheduler job identifies a problem with a stream, the job splits the problem stream off from the other streams flowing from the capture process. When a split operation is complete, a new Oracle Scheduler merge job monitors the split stream. When the problem is corrected, this job merges the stream back with the other streams.</p>
<p>When the <code dir="ltr">split_threshold</code> capture process parameter is set to <code dir="ltr">INFINITE</code>, automatic splitting is disabled. When the <code dir="ltr">split_threshold</code> parameter is not set to <code dir="ltr">INFINITE</code>, automatic splitting is enabled. Automatic splitting only occurs when communication with an apply process has been lost for the number of seconds specified in the <code dir="ltr">split_threshold</code> parameter. For example, communication with an apply process is lost when an apply process becomes disabled or a destination database goes down. Automatic splitting does not occur when one stream is processing changes slower than other streams.</p>
<p>When a stream is split, a cloned capture process is created. The cloned capture process might be enabled or disabled after the split depending on whether the configuration uses the combined capture and apply optimization:</p>
<ul>
<li>
<p>If the apply process is part of a combined capture and apply optimization, then the cloned capture process is enabled. The cloned capture process does not capture any changes until the apply process is enabled and communication is established with the apply process.</p>
</li>
<li>
<p>If the apply process is not part of a combined capture and apply optimization, then the cloned capture process is disabled so that LCRs do not build up in a queue. When the apply process is enabled and the cloned stream can flow, you can start the cloned capture process manually.</p>
</li>
</ul>
<p>The split stream is merged back with the original streams automatically when the difference, in seconds, between <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> in the <code dir="ltr">GV$STREAMS_CAPTURE</code> view of the cloned capture process and the original capture process is less than or equal to the value specified for the <code dir="ltr">merge_threshold</code> capture process parameter. The <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> records the time when a captured change was recorded in the redo log. If the difference is greater than the value specified by this capture process parameter, then automatic merge does not begin, and the value is recorded in the <code dir="ltr">LAG</code> column of the <code dir="ltr">DBA_STREAMS_SPLIT_MERGE</code> view.</p>
<p>When the capture process and the apply process for a stream run in different database instances, automatic split and merge is always possible for the stream. When a capture process and apply process for a stream run on the same database instance, automatic split and merge is possible only when all of the following conditions are met:</p>
<ul>
<li>
<p>The capture process and apply process use the same queue.</p>
</li>
<li>
<p>The apply process has no errors in its error queue.</p>
</li>
<li>
<p>The apply process is not an XStream outbound server.</p>
</li>
<li>
<p>The apply process is stopped.</p>
</li>
<li>
<p>No messages have spilled from the buffered queue to the hard disk.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CEGJFAGC">&#34;Splitting and Merging an Oracle Streams Destination Automatically&#34;</a> for an example</p>
</li>
<li>
<p><a class="olink ARPLS306" href="../ARPLS/d_cap_a.htm#ARPLS306"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the capture process parameters</p>
</li>
<li>
<p><a class="olink STRMS1603" href="../STRMS/strms_cpmon.htm#STRMS1603"><span class="italic">Oracle Streams Concepts and Administration</span></a> for information about monitoring automatic split and merge operations</p>
</li>
<li>
<p><a class="olink XSTRM" href="../XSTRM/toc.htm"><span class="italic">Oracle Database XStream Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CEGDBFGJ"></a>
<div id="STREP439" class="sect3">
<h4 class="sect3">Manual Split and Automatic Merge<a id="sthref579"></a><a id="sthref580"></a><a id="sthref581"></a></h4>
<p>When you split streams manually with the <code dir="ltr">SPLIT_STREAMS</code> procedure, the <code dir="ltr">auto_merge_threshold</code> procedure parameter gives you the option of automatically merging the stream back to the original capture process when the problem at the destination is corrected. After the apply process for the problem stream is accepting changes, you can start the cloned capture process and wait for the cloned capture process to catch up to the original capture process. When the cloned capture process nearly catches up, the <code dir="ltr">auto_merge_threshold</code> parameter setting determines whether the split stream is merged automatically or manually:</p>
<ul>
<li>
<p>When <code dir="ltr">auto_merge_threshold</code> is set to a positive number, the <code dir="ltr">SPLIT_STREAMS</code> procedure creates an Oracle Scheduler job with a schedule. The job runs the <code dir="ltr">MERGE_STREAMS_JOB</code> procedure and specifies a merge threshold equal to the value specified in the <code dir="ltr">auto_merge_threshold</code> parameter. You can modify the schedule for a job after it is created.</p>
<p>In this case, the split stream is merged back with the original streams automatically when the difference, in seconds, between <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> in the <code dir="ltr">GV$STREAMS_CAPTURE</code> view of the cloned capture process and the original capture process is less than or equal to the value specified for the <code dir="ltr">auto_merge_threshold</code> parameter. The <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> records the time when a captured change was recorded in the redo log.</p>
</li>
<li>
<p>When <code dir="ltr">auto_merge_threshold</code> is set to <code dir="ltr">NULL</code> or <code dir="ltr">0</code> (zero), the split stream is not merged back with the original streams automatically. To merge the split stream with the original streams, run the <code dir="ltr">MERGE_STREAMS_JOB</code> or <code dir="ltr">MERGE_STREAMS</code> procedure manually.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CEGIIIDE">&#34;Splitting an Oracle Streams Destination Manually and Merging It Automatically&#34;</a> for an example</div>
</div>
<!-- class="sect3" -->
<a id="CEGGEGDH"></a>
<div id="STREP440" class="sect3">
<h4 class="sect3">Manual Split and Merge With Generated Scripts</h4>
<p>The <code dir="ltr">SPLIT_STREAMS</code> and <code dir="ltr">MERGE_STREAMS</code> procedures can perform actions directly or generate a script that performs the actions when the script is run. Using a procedure to perform actions directly is simpler than running a script, and the split or merge operation is performed immediately. However, you might choose to generate a script for the following reasons:</p>
<ul>
<li>
<p>You want to review the actions performed by the procedure before splitting or merging streams.</p>
</li>
<li>
<p>You want to modify the script to customize its actions.</p>
</li>
</ul>
<p>For example, you might choose to modify the script if you want to change the rules in the rule set for the cloned capture process. In some Oracle Streams replication environments, only a subset of the changes made to the source database are sent to each destination database, and each destination database might receive a different subset of the changes. In such an environment, you can modify the rule set for the cloned capture process so that it only captures changes that are propagated by the cloned propagation.</p>
<p>The <code dir="ltr">perform_actions</code> parameter in each procedure controls whether the procedure performs actions directly:</p>
<ul>
<li>
<p>To split or merge streams directly when you run one of these procedures, set the <code dir="ltr">perform_actions</code> parameter to <code dir="ltr">TRUE</code>. The default value for this parameter is <code dir="ltr">TRUE</code>.</p>
</li>
<li>
<p>To generate a script when you run one of these procedures, set the <code dir="ltr">perform_actions</code> parameter to <code dir="ltr">FALSE</code>, and use the <code dir="ltr">script_name</code> and <code dir="ltr">script_directory_object</code> parameters to specify the name and location of the script.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CEGFHAFH">&#34;Splitting and Merging an Oracle Streams Destination Manually With Scripts&#34;</a> for an example</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CEGDFAGE"></a>
<div id="STREP441" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Examples That Split and Merge Oracle Streams</h3>
<p>The following sections provide instructions for splitting and merging streams:</p>
<ul>
<li>
<p><a href="#CEGJFAGC">Splitting and Merging an Oracle Streams Destination Automatically</a></p>
</li>
<li>
<p><a href="#CEGIIIDE">Splitting an Oracle Streams Destination Manually and Merging It Automatically</a></p>
</li>
<li>
<p><a href="#CEGFHAFH">Splitting and Merging an Oracle Streams Destination Manually With Scripts</a></p>
</li>
</ul>
<p>These examples make the following assumptions about the Oracle Streams replication environment:</p>
<ul>
<li>
<p>A single capture process named <code dir="ltr">strms_capture</code> captures changes that are sent to three destination databases.</p>
</li>
<li>
<p>The propagations that send these changes to the destination queues at the destination databases are the following:</p>
<ul>
<li>
<p><code dir="ltr">strms_prop_a</code></p>
</li>
<li>
<p><code dir="ltr">strms_prop_b</code></p>
</li>
<li>
<p><code dir="ltr">strms_prop_c</code></p>
</li>
</ul>
</li>
<li>
<p>A queue named <code dir="ltr">streams_queue</code> is the source queue for all three propagations.</p>
</li>
<li>
<p>There is a problem at the destination for the <code dir="ltr">strms_prop_a</code> propagation. This propagation cannot send messages to the destination queue.</p>
</li>
<li>
<p>The other two propagations (<code dir="ltr">strms_prop_b</code> and <code dir="ltr">strms_prop_c</code>) are propagating messages normally.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS599" href="../ARPLS/d_streams_adm.htm#ARPLS599"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <a class="olink ARPLS867" href="../ARPLS/d_streams_adm.htm#ARPLS867"><code dir="ltr">SPLIT_STREAMS</code> procedure</a> and the <a class="olink ARPLS866" href="../ARPLS/d_streams_adm.htm#ARPLS866"><code dir="ltr">MERGE_STREAMS</code> procedure</a></div>
<a id="CEGJFAGC"></a>
<div id="STREP594" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Splitting and Merging an Oracle Streams Destination Automatically</h4>
<p>Before reviewing this example, see the following sections:</p>
<ul>
<li>
<p><a href="#CEGGJBIJ">&#34;Automatic Split and Merge&#34;</a> for conceptual information</p>
</li>
<li>
<p><a href="#CEGDFAGE">&#34;Examples That Split and Merge Oracle Streams&#34;</a> for assumptions about the Oracle Streams replication environment in this example</p>
</li>
</ul>
<p>Complete the following steps to split and merge a stream automatically:</p>
<ol>
<li>
<p>In SQL*Plus, connect as the Oracle Streams administrator to the database with the capture process.</p>
<p>See <a class="olink ADMIN00102" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=ADMIN00102"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for instructions about connecting to a database in SQL*Plus.</p>
</li>
<li id="CEGHBGIB">
<p>Ensure that the following parameters are set properly for the <code dir="ltr">strms_capture</code> capture process to enable automatic split and merge:</p>
<ul>
<li>
<p><code dir="ltr">split_threshold</code>: Ensure that this parameter is not set to <code dir="ltr">INFINITE</code>. The default setting for this parameter is <code dir="ltr">1800</code> seconds.</p>
</li>
<li>
<p><code dir="ltr">merge_threshold</code>: Ensure that this parameter is not set to a negative value. The default setting for this parameter is <code dir="ltr">60</code> seconds.</p>
</li>
</ul>
<p>To check the settings for these parameters, query the <code dir="ltr">DBA_CAPTURE_PARAMETERS</code> view. See <a class="olink STRMS890" href="../STRMS/strms_cpmon.htm#STRMS890"><span class="italic">Oracle Streams Concepts and Administration</span></a> for instructions.</p>
</li>
<li>
<p>If you must reset one or both of the capture process parameters described in Step&nbsp;<a href="#CEGHBGIB">2</a>, then use Oracle Enterprise Manager Cloud Control or the <code dir="ltr">SET_PARAMETER</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package to reset the parameters. See <a class="olink STRMS630" href="../STRMS/strms_mcap.htm#STRMS630"><span class="italic">Oracle Streams Concepts and Administration</span></a> for instructions about using the <code dir="ltr">SET_PARAMETER</code> procedure.</p>
</li>
<li id="CEGGGAFB">
<p>Monitor the <code dir="ltr">DBA_STREAMS_SPLIT_MERGE</code> view periodically to check whether an automatic split and merge operation is in process.</p>
<p>When an automatic split occurs, certain components, such as the capture process, queue, and propagation, are cloned, and each is given a system-generated name. The <code dir="ltr">DBA_STREAMS_SPLIT_MERGE</code> view contains the name of each cloned component, and other information about the split and merge operation.</p>
<p>Query the <code dir="ltr">DBA_STREAMS_SPLIT_MERGE</code> view to determine whether a stream has been split off from the original capture process:</p>
<pre dir="ltr">COLUMN ORIGINAL_CAPTURE_NAME HEADING &#39;Original|Capture|Process&#39; FORMAT A10
COLUMN ACTION_TYPE HEADING &#39;Action|Type&#39; FORMAT A7
COLUMN STATUS_UPDATE_TIME HEADING &#39;Status|Update|Time&#39; FORMAT A15
COLUMN STATUS HEADING &#39;Status&#39; FORMAT A16
COLUMN JOB_NEXT_RUN_DATE HEADING &#39;Next Job|Run Date&#39; FORMAT A20
 
SELECT ORIGINAL_CAPTURE_NAME,
       ACTION_TYPE,
       STATUS_UPDATE_TIME, 
       STATUS, 
       JOB_NEXT_RUN_DATE 
  FROM DBA_STREAMS_SPLIT_MERGE 
  ORDER BY STATUS_UPDATE_TIME DESC;
</pre>
<p>If a stream has been split off from the original capture process, then your output looks similar to the following:</p>
<pre dir="ltr">Original           Status
Capture    Action  Update                           Next Job
Process    Type    Time            Status           Run Date
---------- ------- --------------- ---------------- --------------------
DB$CAP     MERGE   01-APR-09 06.49 NOTHING TO MERGE 01-APR-09 06.54.29.0
                   .29.204804 AM                    00000 AM -07:00
DB$CAP     SPLIT   01-APR-09 06.49 SPLIT DONE       01-APR-09 06.47.59.0
                   .17.389146 AM                    00000 AM -07:00
</pre>
<p>This output shows that an automatic split was performed. The merge job was run at <code dir="ltr">01-APR-09 06.49.29.204804 AM</code>, but the status shows <code dir="ltr">NOTHING</code> <code dir="ltr">TO</code> <code dir="ltr">MERGE</code> because the split stream is not ready to merge yet. The <code dir="ltr">SPLIT</code> <code dir="ltr">DONE</code> status indicates that the stream was split off at the following date and time: <code dir="ltr">01-APR-09 06.49.17.389146 AM</code>.</p>
</li>
<li>
<p>After an automatic split is performed, correct the problem with the destination. The problem is corrected when the apply process at the destination database can accept changes from the cloned capture process. An Oracle Scheduler job performs an automatic merge when the problem is corrected.</p>
</li>
<li>
<p>If the cloned capture process is disabled, then start the cloned capture process. The cloned capture process is disabled only if the stream is not a combined capture and apply optimization. See <a class="olink STRMS217" href="../STRMS/strms_mcap.htm#STRMS217"><span class="italic">Oracle Streams Concepts and Administration</span></a> for instructions for starting a capture process.</p>
</li>
</ol>
<p>The cloned capture process captures changes that satisfy its rule sets. These changes are sent to the apply process.</p>
<p>During this time, an Oracle Scheduler job runs the <code dir="ltr">MERGE_STREAMS_JOB</code> procedure according to its schedule. The <code dir="ltr">MERGE_STREAMS_JOB</code> procedure queries the <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> in the <code dir="ltr">GV$STREAMS_CAPTURE</code> view. When the difference between <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> of the cloned capture process and the original capture process is less than or equal to the value of the <code dir="ltr">merge_threshold</code> capture process parameter, the <code dir="ltr">MERGE_STREAMS_JOB</code> procedure determines that the streams are ready to merge. The <code dir="ltr">MERGE_STREAMS_JOB</code> procedure runs the <code dir="ltr">MERGE_STREAMS</code> procedure automatically to merge the streams back together.</p>
<p>The <code dir="ltr">LAG</code> column in the <code dir="ltr">DBA_STREAMS_SPLIT_MERGE</code> view tracks the time in seconds that the cloned capture process lags behind the original capture process. The following query displays the lag time:</p>
<pre dir="ltr">COLUMN ORIGINAL_CAPTURE_NAME HEADING &#39;Original Capture Process&#39; FORMAT A25
COLUMN CLONED_CAPTURE_NAME HEADING &#39;Cloned Capture Process&#39; FORMAT A25
COLUMN LAG HEADING &#39;Lag&#39; FORMAT 999999999999999
 
SELECT ORIGINAL_CAPTURE_NAME,
       CLONED_CAPTURE_NAME,
       LAG
 FROM DBA_STREAMS_SPLIT_MERGE
 WHERE ACTION_TYPE = &#39;MERGE&#39;;
</pre>
<p>Your output looks similar to the following:</p>
<pre dir="ltr">Original Capture Process  Cloned Capture Process                 Lag
------------------------- ------------------------- ----------------
DB$CAP                    CLONED$_DB$CAP_5                      2048
</pre>
<p>This output shows that there is a lag of 2,048 seconds between the <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> values for the original capture process and the cloned capture process. When the cloned capture process is within the threshold, the merge job can start the <code dir="ltr">MERGE_STREAMS</code> procedure. By default, the merge threshold is 60 seconds.</p>
<p>The <code dir="ltr">MERGE_STREAMS</code> procedure performs the following actions:</p>
<ul>
<li>
<p>Stops the cloned capture process.</p>
</li>
<li>
<p>Re-creates the original propagation called <code dir="ltr">strms_prop_a</code>.</p>
</li>
<li>
<p>Drops the cloned propagation.</p>
</li>
<li>
<p>Drops the cloned capture process.</p>
</li>
<li>
<p>Drops the cloned queue.</p>
</li>
</ul>
<p>Repeat the query in Step <a href="#CEGGGAFB">4</a> periodically to monitor the split and merge operation. After the merge operation is complete, the output for this query is similar to the following:</p>
<pre dir="ltr">Original           Status
Capture    Action  Update                           Next Job
Process    Type    Time            Status           Run Date
---------- ------- --------------- ---------------- --------------------
DB$CAP     MERGE   01-APR-09 07.32 NOTHING TO MERGE 01-APR-09 07.37.04.0
                   .04.820795 AM                    00000 AM -07:00
DB$CAP     MONITOR 01-APR-09 07.32 MERGE DONE       01-APR-09 07.36.20.0
                   .04.434925 AM                    00000 AM -07:00
DB$CAP     SPLIT   01-APR-09 06.49 SPLIT DONE       01-APR-09 06.47.59.0
                   .17.389146 AM                    00000 AM -07:00
</pre>
<p>This output shows that the split stream was merged back into the original capture process at the following date an time: <code dir="ltr">01-APR-09 07.32.04.434925 AM</code>. The next status shows <code dir="ltr">NOTHING</code> <code dir="ltr">TO</code> <code dir="ltr">MERGE</code> because there are no remaining split streams.</p>
<p>After the streams are merged, the Oracle Streams replication environment has the same components as it had before the split and merge operation. Information about the completed split and merge operation is stored in the <code dir="ltr">DBA_STREAMS_SPLIT_MERGE_HIST</code> for future reference.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS1603" href="../STRMS/strms_cpmon.htm#STRMS1603"><span class="italic">Oracle Streams Concepts and Administration</span></a> for information about monitoring automatic split and merge operations</div>
</div>
<!-- class="sect3" -->
<a id="CEGIIIDE"></a>
<div id="STREP442" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Splitting an Oracle Streams Destination Manually and Merging It Automatically</h4>
<p>Before reviewing this example, see the following sections:</p>
<ul>
<li>
<p><a href="#CEGDBFGJ">&#34;Manual Split and Automatic Merge&#34;</a> for conceptual information</p>
</li>
<li>
<p><a href="#CEGDFAGE">&#34;Examples That Split and Merge Oracle Streams&#34;</a> for assumptions about the Oracle Streams replication environment in this example</p>
</li>
</ul>
<p>The example in this section splits the stream manually and merges it automatically. That is, the <code dir="ltr">perform_actions</code> parameter is set to <code dir="ltr">TRUE</code> in the <code dir="ltr">SPLIT_STREAMS</code> procedure. Also, the example merges the streams automatically at the appropriate time because the <code dir="ltr">auto_merge_threshold</code> parameter is to set a positive number (60) in the <code dir="ltr">SPLIT_STREAMS</code> procedure.</p>
<p>Complete the following steps to split streams directly and merge streams automatically:</p>
<ol>
<li>
<p>In SQL*Plus, connect as the Oracle Streams administrator to the database with the capture process.</p>
<p>See <a class="olink ADMIN00102" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=ADMIN00102"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for instructions about connecting to a database in SQL*Plus.</p>
</li>
<li>
<p>Run the following procedure to split the stream flowing through propagation <code dir="ltr">strms_prop_a</code> from the other propagations flowing from the <code dir="ltr">strms_capture</code> capture process:</p>
<pre dir="ltr">DECLARE
    schedule_name  VARCHAR2(30);
    job_name       VARCHAR2(30);
BEGIN
    schedule_name := &#39;merge_job1_schedule&#39;;
    job_name      := &#39;merge_job1&#39;;
  DBMS_STREAMS_ADM.SPLIT_STREAMS(
    propagation_name        =&gt; &#39;strms_prop_a&#39;,
    cloned_propagation_name =&gt; &#39;cloned_prop_a&#39;,
    cloned_queue_name       =&gt; &#39;cloned_queue&#39;,
    cloned_capture_name     =&gt; &#39;cloned_capture&#39;,
    perform_actions         =&gt; TRUE,
    auto_merge_threshold    =&gt; 60,
    schedule_name           =&gt; schedule_name,
    merge_job_name          =&gt; job_name);
END;
/
</pre>
<p>Running this procedure performs the following actions:</p>
<ul>
<li>
<p>Creates a new queue called <code dir="ltr">cloned_queue</code>.</p>
</li>
<li>
<p>Creates a new propagation called <code dir="ltr">cloned_prop_a</code> that propagates messages from the <code dir="ltr">cloned_queue</code> queue to the existing destination queue used by the <code dir="ltr">strms_prop_a</code> propagation. The cloned propagation <code dir="ltr">cloned_prop_a</code> uses the same rule set as the original propagation <code dir="ltr">strms_prop_a</code>.</p>
</li>
<li>
<p>Stops the capture process <code dir="ltr">strms_capture</code>.</p>
</li>
<li>
<p>Queries the acknowledge SCN for the original propagation <code dir="ltr">strms_prop_a</code>. The acknowledged SCN is the last SCN acknowledged by the apply process that applies the changes sent by the propagation. The <code dir="ltr">ACKED_SCN</code> value in the <code dir="ltr">DBA_PROPAGATION</code> view shows the acknowledged SCN for a propagation.</p>
</li>
<li>
<p>Creates a new capture process called <code dir="ltr">cloned_capture</code>. The start SCN for <code dir="ltr">cloned_capture</code> is set to the value of the acknowledged SCN for the <code dir="ltr">strms_prop_a</code> propagation. The cloned capture process <code dir="ltr">cloned_capture</code> uses the same rule set as the original capture process <code dir="ltr">strms_capture</code>.</p>
</li>
<li>
<p>Drops the original propagation <code dir="ltr">strms_prop_a</code>.</p>
</li>
<li>
<p>Starts the original capture process <code dir="ltr">strms_capture</code> with the start SCN set to the value of the acknowledged SCN for the <code dir="ltr">strms_prop_a</code> propagation.</p>
</li>
<li>
<p>Creates an Oracle Scheduler job named <code dir="ltr">merge_job1</code> with a schedule named <code dir="ltr">merge_job1_schedule</code>. Both the job and the schedule are owned by the user who ran the <code dir="ltr">SPLIT_STREAMS</code> procedure. The schedule starts to run when the <code dir="ltr">SPLIT_STREAMS</code> procedure completes. The system defines the initial schedule, but you can modify it in the same way that you would modify any Oracle Scheduler job. See <a class="olink ADMIN034" href="../ADMIN/scheduse.htm#ADMIN034"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for instructions.</p>
</li>
</ul>
</li>
<li>
<p>Correct the problem with the destination of <code dir="ltr">cloned_prop_a</code>. The problem is corrected when the apply process at the destination database can accept changes from the cloned capture process.</p>
</li>
<li>
<p>While connected as the Oracle Streams administrator, start the cloned capture process by running the following procedure:</p>
<pre dir="ltr">exec DBMS_CAPTURE_ADM.START_CAPTURE(&#39;cloned_capture&#39;);
</pre></li>
</ol>
<p>After the cloned capture process <code dir="ltr">cloned_capture</code> starts running, it captures changes that satisfy its rule sets from the acknowledged SCN forward. These changes are propagated by the <code dir="ltr">cloned_prop_a</code> propagation and processed by the apply process at the destination database.</p>
<p>During this time, the Oracle Scheduler job runs the <code dir="ltr">MERGE_STREAMS_JOB</code> procedure according to its schedule. The <code dir="ltr">MERGE_STREAMS_JOB</code> procedure queries the <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> in the <code dir="ltr">GV$STREAMS_CAPTURE</code> view. When the difference between <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> of the cloned capture process <code dir="ltr">cloned_capture</code> and the original capture process <code dir="ltr">strms_capture</code> is less than or equal 60 seconds, the <code dir="ltr">MERGE_STREAMS_JOB</code> procedure determines that the streams are ready to merge. The <code dir="ltr">MERGE_STREAMS_JOB</code> procedure runs the <code dir="ltr">MERGE_STREAMS</code> procedure automatically to merge the streams back together.</p>
<p>The following query displays the <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> for the original capture process and cloned capture process:</p>
<pre dir="ltr">COLUMN CAPTURE_NAME HEADING &#39;Capture|Name&#39; FORMAT A17
COLUMN STATE HEADING &#39;State&#39; FORMAT A20
COLUMN CREATE_MESSAGE HEADING &#39;Last Message|Create Time&#39;
 
SELECT CAPTURE_NAME,
 STATE,
 TO_CHAR(CAPTURE_MESSAGE_CREATE_TIME, &#39;HH24:MI:SS MM/DD/YY&#39;) CREATE_MESSAGE
 FROM V$STREAMS_CAPTURE;
</pre>
<p>Your output looks similar to the following:</p>
<pre dir="ltr">Capture                                Last Message
Name              State                Create Time
----------------- -------------------- -----------------
DB$CAP            CAPTURING CHANGES    07:22:55 04/01/09
CLONED$_DB$CAP_5  CAPTURING CHANGES    06:50:39 04/01/09
</pre>
<p>This output shows that there is more than a 30 minute difference between the <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> values for the original capture process and the cloned capture process. When the cloned capture process is within the threshold, the merge job can start the <code dir="ltr">MERGE_STREAMS</code> procedure. By default, the merge threshold is 60 seconds.</p>
<p>The <code dir="ltr">MERGE_STREAMS</code> procedure performs the following actions:</p>
<ul>
<li>
<p>Stops the cloned capture process <code dir="ltr">cloned_capture</code>.</p>
</li>
<li>
<p>Re-creates the propagation called <code dir="ltr">strms_prop_a</code>.</p>
</li>
<li>
<p>Drops the cloned propagation <code dir="ltr">cloned_prop_a</code>.</p>
</li>
<li>
<p>Drops the cloned capture process <code dir="ltr">cloned_capture</code>.</p>
</li>
<li>
<p>Drops the cloned queue <code dir="ltr">cloned_queue</code>.</p>
</li>
</ul>
<p>After the streams are merged, the Oracle Streams replication environment has the same components as it had before the split and merge operation. Information about the completed split and merge operation is stored in the <code dir="ltr">DBA_STREAMS_SPLIT_MERGE_HIST</code> for future reference.</p>
</div>
<!-- class="sect3" -->
<a id="CEGFHAFH"></a>
<div id="STREP443" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Splitting and Merging an Oracle Streams Destination Manually With Scripts</h4>
<p>Before reviewing this example, see the following sections:</p>
<ul>
<li>
<p><a href="#CEGGEGDH">&#34;Manual Split and Merge With Generated Scripts&#34;</a> for conceptual information</p>
</li>
<li>
<p><a href="#CEGDFAGE">&#34;Examples That Split and Merge Oracle Streams&#34;</a> for assumptions about the Oracle Streams replication environment in this example</p>
</li>
</ul>
<p>The example in this section splits and merges streams by generating and running scripts. That is, the <code dir="ltr">perform_actions</code> parameter is set to <code dir="ltr">FALSE</code> in the <code dir="ltr">SPLIT_STREAMS</code> procedure. Also, the example merges the streams manually at the appropriate time because the <code dir="ltr">auto_merge_threshold</code> parameter is set to <code dir="ltr">NULL</code> in the <code dir="ltr">SPLIT_STREAMS</code> procedure.</p>
<p>Complete the following steps to use scripts to split and merge streams:</p>
<ol>
<li>
<p>In SQL*Plus, connect as the Oracle Streams administrator to the database with the capture process.</p>
<p>See <a class="olink ADMIN00102" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=ADMIN00102"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for instructions about connecting to a database in SQL*Plus.</p>
</li>
<li>
<p>If it does not already exist, then create a directory object named <code dir="ltr">db_dir</code> to hold the scripts generated by the procedures:</p>
<pre dir="ltr">CREATE DIRECTORY db_dir AS &#39;/usr/db_files&#39;;
</pre></li>
<li>
<p>Run the following procedure to generate a script to split the streams:</p>
<pre dir="ltr">DECLARE
    schedule_name  VARCHAR2(30);
    job_name       VARCHAR2(30);
BEGIN
  DBMS_STREAMS_ADM.SPLIT_STREAMS(
    propagation_name        =&gt; &#39;strms_prop_a&#39;,
    cloned_propagation_name =&gt; &#39;cloned_prop_a&#39;,
    cloned_queue_name       =&gt; &#39;cloned_queue&#39;,
    cloned_capture_name     =&gt; &#39;cloned_capture&#39;,
    perform_actions         =&gt; FALSE,
    script_name             =&gt; &#39;split.sql&#39;,
    script_directory_object =&gt; &#39;db_dir&#39;,
    auto_merge_threshold    =&gt; NULL,
    schedule_name           =&gt; schedule_name,
    merge_job_name          =&gt; job_name);
END;
/
</pre>
<p>Running this procedure generates the <code dir="ltr">split.sql</code> script. The script contains the actions that will split the stream flowing through propagation <code dir="ltr">strms_prop_a</code> from the other propagations flowing from the <code dir="ltr">strms_capture</code> capture process.</p>
</li>
<li>
<p>Go to the directory used by the <code dir="ltr">db_dir</code> directory object, and open the <code dir="ltr">split.sql</code> script with a text editor.</p>
</li>
<li>
<p>Examine the script and make modifications, if necessary.</p>
</li>
<li>
<p>Save and close the script.</p>
</li>
<li>
<p>While connected as the Oracle Streams administrator in SQL*Plus, run the script:</p>
<pre dir="ltr">@/usr/db_files/split.sql
</pre>
<p>Running the script performs the following actions:</p>
<ul>
<li>
<p>Runs the <code dir="ltr">SET_UP_QUEUE</code> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package to create a queue called <code dir="ltr">cloned_queue</code>.</p>
</li>
<li>
<p>Runs the <code dir="ltr">CREATE_PROPAGATION</code> procedure in the <code dir="ltr">DBMS_PROPAGATION_ADM</code> package to create a propagation called <code dir="ltr">cloned_prop_a</code>. This new propagation propagates messages from the <code dir="ltr">cloned_queue</code> queue to the existing destination queue used by the <code dir="ltr">strms_prop_a</code> propagation. The cloned propagation <code dir="ltr">cloned_prop_a</code> uses the same rule set as the original propagation <code dir="ltr">strms_prop_a</code>.</p>
<p>The <code dir="ltr">CREATE_PROPAGATION</code> procedure sets the <code dir="ltr">original_propagation_name</code> parameter to <code dir="ltr">strms_prop_a</code> and the <code dir="ltr">auto_merge_threshold</code> parameter to <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p>Runs the <code dir="ltr">STOP_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package to stop the capture process <code dir="ltr">strms_capture</code>.</p>
</li>
<li>
<p>Queries the acknowledge SCN for the original propagation <code dir="ltr">strms_prop_a</code>. The acknowledged SCN is the last SCN acknowledged by the apply process that applies the changes sent by the propagation. The <code dir="ltr">ACKED_SCN</code> value in the <code dir="ltr">DBA_PROPAGATION</code> view shows the acknowledged SCN for a propagation.</p>
</li>
<li>
<p>Runs the <code dir="ltr">CREATE_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package to create a capture process called <code dir="ltr">cloned_capture</code>. The start SCN for <code dir="ltr">cloned_capture</code> is set to the value of the acknowledged SCN for the <code dir="ltr">strms_prop_a</code> propagation. The cloned capture process <code dir="ltr">cloned_capture</code> uses the same rule set as the original capture process <code dir="ltr">strms_capture</code>.</p>
</li>
<li>
<p>Runs the <code dir="ltr">DROP_PROPAGATION</code> procedure in the <code dir="ltr">DBMS_PROPAGATION_ADM</code> package to drop the original propagation <code dir="ltr">strms_prop_a</code>.</p>
</li>
<li>
<p>Runs the <code dir="ltr">START_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package to start the original capture process <code dir="ltr">strms_capture</code> with the start SCN set to the value of the acknowledged SCN for the <code dir="ltr">strms_prop_a</code> propagation.</p>
</li>
</ul>
</li>
<li>
<p>Correct the problem with the destination of <code dir="ltr">cloned_prop_a</code>. The problem is corrected when the apply process at the destination database can accept changes from the cloned capture process.</p>
</li>
<li>
<p>While connected as the Oracle Streams administrator, start the cloned capture process by running the following procedure:</p>
<pre dir="ltr">exec DBMS_CAPTURE_ADM.START_CAPTURE(&#39;cloned_capture&#39;);
</pre></li>
<li>
<p>Monitor the Oracle Streams replication environment until the cloned capture process catches up to, or nearly catches up to, the original capture process. Specifically, query the <code dir="ltr">CAPTURE_MESSAGE_CREATION_TIME</code> column in the <code dir="ltr">GV$STREAMS_CAPTURE</code> view for each capture process.</p>
<p>Run the following query to check the <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> for each capture process periodically:</p>
<pre dir="ltr">SELECT CAPTURE_NAME,
       TO_CHAR(CAPTURE_MESSAGE_CREATE_TIME, &#39;HH24:MI:SS MM/DD/YY&#39;) 
   FROM GV$STREAMS_CAPTURE;
</pre>
<p>Do not move on to the next step until the difference between <code dir="ltr">CAPTURE_MESSAGE_CREATE_TIME</code> of the cloned capture process <code dir="ltr">cloned_capture</code> and the original capture process <code dir="ltr">strms_capture</code> is relatively small.</p>
</li>
<li>
<p>Run the following procedure to generate a script to merge the streams:</p>
<pre dir="ltr">BEGIN
  DBMS_STREAMS_ADM.MERGE_STREAMS(
    cloned_propagation_name =&gt; &#39;cloned_prop_a&#39;,
    perform_actions         =&gt; FALSE,
    script_name             =&gt; &#39;merge.sql&#39;,
    script_directory_object =&gt; &#39;db_dir&#39;);
END;
/
</pre>
<p>Running this procedure generates the <code dir="ltr">merge.sql</code> script. The script contains the actions that will merge the stream flowing through propagation <code dir="ltr">cloned_prop_a</code> with the other propagations flowing from the <code dir="ltr">strms_capture</code> capture process.</p>
</li>
<li>
<p>Go to the directory used by the <code dir="ltr">db_dir</code> directory object, and open the <code dir="ltr">merge.sql</code> script with a text editor.</p>
</li>
<li>
<p>Examine the script and make modifications, if necessary.</p>
</li>
<li>
<p>Save and close the script.</p>
</li>
<li>
<p>While connected as the Oracle Streams administrator in SQL*Plus, run the script:</p>
<pre dir="ltr">@/usr/db_files/merge.sql
</pre>
<p>Running the script performs the following actions:</p>
<ul>
<li>
<p>Runs the <code dir="ltr">STOP_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package to stop the cloned capture process <code dir="ltr">cloned_capture</code>.</p>
</li>
<li>
<p>Runs the <code dir="ltr">STOP_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package to stop the original capture process <code dir="ltr">strms_capture</code>.</p>
</li>
<li>
<p>Runs the <code dir="ltr">CREATE_PROPAGATION</code> procedure in the <code dir="ltr">DBMS_PROPAGATION_ADM</code> package to re-create the propagation called <code dir="ltr">strms_prop_a</code>.</p>
</li>
<li>
<p>Starts the original capture process <code dir="ltr">strms_capture</code> from the lower SCN value of these two SCN values:</p>
<ul>
<li>
<p>The acknowledged SCN of the cloned propagation <code dir="ltr">cloned_prop_a</code>.</p>
</li>
<li>
<p>The lowest acknowledged SCN of the other propagations that propagate changes captured by the original capture process (propagations <code dir="ltr">strms_prop_b</code> and <code dir="ltr">strms_prop_c</code> in this example).</p>
</li>
</ul>
<p>When the <code dir="ltr">strms_capture</code> capture process is started, it might recapture changes that it already captured, or it might capture changes that were already captured by the cloned capture process <code dir="ltr">cloned_capture</code>. In either case, the relevant apply processes will discard any duplicate changes they receive.</p>
</li>
<li>
<p>Runs the <code dir="ltr">DROP_PROPAGATION</code> procedure in the <code dir="ltr">DBMS_PROPAGATION_ADM</code> package to drop the cloned propagation <code dir="ltr">cloned_prop_a</code>.</p>
</li>
<li>
<p>Runs the <code dir="ltr">DROP_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package to drop the cloned capture process <code dir="ltr">cloned_capture</code>.</p>
</li>
<li>
<p>Runs the <code dir="ltr">REMOVE_QUEUE</code> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package to drop the cloned queue <code dir="ltr">cloned_queue</code>.</p>
</li>
</ul>
</li>
</ol>
<p>After the script runs successfully, the streams are merged, and the Oracle Streams replication environment has the same components as it had before the split and merge operation. Information about the completed split and merge operation is stored in the <code dir="ltr">DBA_STREAMS_SPLIT_MERGE_HIST</code> for future reference.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1019206"></a>
<div id="STREP135" class="sect1">
<h2 class="sect1">Changing the DBID or Global Name of a Source Database<a id="sthref582"></a><a id="sthref583"></a><a id="sthref584"></a><a id="sthref585"></a></h2>
<p>Typically, database administrators change the <code dir="ltr">DBID</code> and global name of a database when it is a clone of another database. You can view the <code dir="ltr">DBID</code> of a database by querying the <code dir="ltr">DBID</code> column in the <code dir="ltr">V$DATABASE</code> dynamic performance view, and you can view the global name of a database by querying the <code dir="ltr">GLOBAL_NAME</code> static data dictionary view. When you change the <code dir="ltr">DBID</code> or global name of a source database, any existing capture processes that capture changes originating at this source database become unusable. The capture processes can be local capture processes or downstream capture processes that capture changes that originated at the source database. Also, any existing apply processes that apply changes from the source database become unusable. However, existing synchronous captures and propagations do not need to be re-created, although modifications to propagation rules might be necessary.</p>
<p>If a capture process or synchronous capture is capturing changes to a source database for which you have changed the <code dir="ltr">DBID</code> or global name, then complete the following steps:</p>
<ol>
<li>
<p>Shut down the source database.</p>
</li>
<li>
<p>Restart the source database with <code dir="ltr">RESTRICTED</code> <code dir="ltr">SESSION</code> enabled using <code dir="ltr">STARTUP</code> <code dir="ltr">RESTRICT</code>.</p>
</li>
<li id="i1019165">
<p>Drop the capture process using the <code dir="ltr">DROP_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package. The capture process can be a local capture process at the source database or a downstream capture process at a remote database. Synchronous captures do not need to be dropped.</p>
</li>
<li>
<p>At the source database, run the <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code> <code dir="ltr">SWITCH</code> <code dir="ltr">LOGFILE</code> statement on the database.</p>
</li>
<li>
<p>If any changes have been captured from the source database, then manually resynchronize the data at all destination databases that apply changes originating at this source database. If the database never captured any changes, then this step is not necessary.</p>
</li>
<li>
<p>Modify any rules that use the source database name as a condition. The source database name should be changed to the new global name of the source database where appropriate in these rules. You might need to modify capture process rules, propagation rules, and apply process rules at the local database and at remote databases in the environment. Typically, synchronous capture rules do not contain a condition for the source database.</p>
</li>
<li id="i1019170">
<p>Drop the apply processes that apply changes from the capture process that you dropped in Step <a href="#i1019165">3</a>. Use the <code dir="ltr">DROP_APPLY</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package to drop an apply process. Apply processes that apply changes captured by synchronous capture do not need to be dropped.</p>
</li>
<li id="i1019318">
<p>At each destination database that applies changes from the source database, re-create the apply processes you dropped in Step <a href="#i1019170">7</a>. You might want to associate the each apply process with the same rule sets it used before it was dropped. See <a href="capply.htm#CHDCACFH">Chapter 7, &#34;Configuring Implicit Apply&#34;</a> for instructions.</p>
</li>
<li id="i1019397">
<p>Re-create the capture process you dropped in Step <a href="#i1019165">3</a>, if necessary. You might want to associate the capture process with the same rule sets used by the capture process you dropped in Step <a href="#i1019165">3</a>. See <a href="ccap.htm#i1006171">&#34;Configuring a Capture Process&#34;</a> for instructions.</p>
</li>
<li>
<p>At the source database, prepare database objects whose changes will be captured by the re-created capture process for instantiation. See <a href="instant.htm#i1009355">&#34;Preparing Database Objects for Instantiation at a Source Database&#34;</a>.</p>
</li>
<li>
<p>At each destination database that applies changes from the source database, set the instantiation SCN for all databases objects to which changes from the source database will be applied. See <a href="instant.htm#i1009604">&#34;Setting Instantiation SCNs at a Destination Database&#34;</a> for instructions.</p>
</li>
<li>
<p>Disable the restricted session using the <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code> <code dir="ltr">DISABLE</code> <code dir="ltr">RESTRICTED</code> <code dir="ltr">SESSION</code> statement.</p>
</li>
<li>
<p>At each destination database that applies changes from the source database, start the apply processes you created in Step <a href="#i1019318">8</a>.</p>
</li>
<li>
<p>At the source database, start the capture process you created in Step <a href="#i1019397">9</a>.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SUTIL014" href="../SUTIL/GUID-D138A757-6A2A-41A2-B722-A98708C5F5AD.htm#SUTIL014"><span class="italic">Oracle Database Utilities</span></a> for more information about changing the <code dir="ltr">DBID</code> of a database using the DBNEWID utility</div>
</div>
<!-- class="sect1" -->
<a id="i1016713"></a>
<div id="STREP162" class="sect1">
<h2 class="sect1">Resynchronizing a Source Database in a Multiple-Source Environment</h2>
<p>A multiple-source environment is one in which there is more than one source database for any of the shared data. If a source database in a multiple-source environment cannot be recovered to the current point in time, then you can use the method described in this section to resynchronize the source database with the other source databases in the environment. Some reasons why a database cannot be recovered to the current point in time include corrupted archived redo logs or the media failure of an online redo log group.</p>
<p>For example, a bidirectional Oracle Streams environment is one in which exactly two databases share the replicated database objects and data. In this example, assume that database A is the database that must be resynchronized and that database B is the other source database in the environment. To resynchronize database A in this bidirectional Oracle Streams environment, complete the following steps:</p>
<ol>
<li>
<p>Verify that database B has applied all of the changes sent from database A. You can query the <code dir="ltr">V$BUFFERED_SUBSCRIBERS</code> data dictionary view at database B to determine whether the apply process that applies these changes has any unapplied changes in its queue. See the example on viewing propagations dequeuing LCRs from each buffered queue in <a class="olink STRMS164" href="../STRMS/strms_qpmon.htm#STRMS164"><span class="italic">Oracle Streams Concepts and Administration</span></a> for an example of such a query. Do not continue until all of these changes have been applied.</p>
</li>
<li>
<p>Remove the Oracle Streams configuration from database A by running the <code dir="ltr">REMOVE_STREAMS_CONFIGURATION</code> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package. See <a class="olink ARPLS508" href="../ARPLS/d_streams_adm.htm#ARPLS508"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about this procedure.</p>
</li>
<li id="i1018479">
<p>At database B, drop the apply process that applies changes from database A. Do not drop the rule sets used by this apply process because you will re-create the apply process in a subsequent step.</p>
</li>
<li>
<p>Complete the steps in <a href="config_add.htm#i1010925">&#34;Adding a New Database to an Existing Multiple-Source Environment&#34;</a> to add database A back into the Oracle Streams environment.</p>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="i1014311"></a>
<div id="STREP121" class="sect1">
<h2 class="sect1">Performing Database Point-in-Time Recovery in an Oracle Streams Environment<a id="sthref586"></a><a id="sthref587"></a></h2>
<p>Point-in-time recovery is the recovery of a database to a specified noncurrent time, SCN, or log sequence number. The following sections discuss performing point-in-time recovery in an Oracle Streams replication environment:</p>
<ul>
<li>
<p><a href="#i1017951">Performing Point-in-Time Recovery on the Source in a Single-Source Environment</a></p>
</li>
<li>
<p><a href="#i1013127">Performing Point-in-Time Recovery in a Multiple-Source Environment</a></p>
</li>
<li>
<p><a href="#i1011204">Performing Point-in-Time Recovery on a Destination Database</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink BRADV" href="../BRADV/toc.htm"><span class="italic">Oracle Database Backup and Recovery User&#39;s Guide</span></a> for more information about point-in-time recovery</div>
<a id="i1017951"></a>
<div id="STREP444" class="sect2">
<h3 class="sect2">Performing Point-in-Time Recovery on the Source in a Single-Source Environment<a id="sthref588"></a><a id="sthref589"></a></h3>
<p>A single-source Oracle Streams replication environment is one in which there is only one source database for shared data. If database point-in-time recovery is required at the source database in a single-source Oracle Streams environment, and any capture processes that capture changes generated at a source database are running, then you must stop these capture processes before you perform the recovery operation. Both local and downstream capture process that capture changes generated at the source database must be stopped. Typically, database administrators reset the log sequence number of a database during point-in-time recovery. The <code dir="ltr">ALTER</code> <code dir="ltr">DATABASE</code> <code dir="ltr">OPEN</code> <code dir="ltr">RESETLOGS</code> statement is an example of a statement that resets the log sequence number.</p>
<p>The instructions in this section assume that the single-source replication environment has the following characteristics:</p>
<ul>
<li>
<p>Only one capture process named <code dir="ltr">strm01_capture</code>, which can be a local or downstream capture process</p>
</li>
<li>
<p>Only one destination database with the global name <code dir="ltr">dest.example.com</code></p>
</li>
<li>
<p>Only one apply process named <code dir="ltr">strm01_apply</code> at the destination database</p>
</li>
</ul>
<p>If point-in-time recovery must be performed on the source database, then you can follow these instructions to recover as many transactions as possible at the source database by using transactions applied at the destination database. These instructions assume that you can identify the transactions applied at the destination database after the source point-in-time SCN and execute these transactions at the source database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle recommends that you set the apply process parameter <code dir="ltr">commit_serialization</code> to <code dir="ltr">FULL</code> when performing point-in-time recovery in a single-source Oracle Streams replication environment.</div>
<p>Complete the following steps to perform point-in-time recovery on the source database in a single-source Oracle Streams replication environment:</p>
<a id="i1021245"></a>
<ol>
<li id="CEGECDDA">
<p>Perform point-in-time recovery on the source database if you have not already done so. Note the point-in-time recovery SCN because it is needed in subsequent steps.</p>
</li>
<li>
<p>Ensure that the source database is in restricted mode.</p>
</li>
<li>
<p>Connect to the database running the capture process and list the rule sets used by the capture process.</p>
<p>To list the rule sets used by the capture process, run the following query:</p>
<pre dir="ltr">COLUMN CAPTURE_NAME HEADING &#39;Capture|Process|Name&#39; FORMAT A15
COLUMN RULE_SET_OWNER HEADING &#39;Positive|Rule Owner&#39; FORMAT A15
COLUMN RULE_SET_NAME HEADING &#39;Positive|Rule Set&#39; FORMAT A15
COLUMN NEGATIVE_RULE_SET_OWNER HEADING &#39;Negative|Rule Owner&#39; FORMAT A15
COLUMN NEGATIVE_RULE_SET_NAME HEADING &#39;Negative|Rule Set&#39; FORMAT A15
 
SELECT CAPTURE_NAME, 
       RULE_SET_OWNER, 
       RULE_SET_NAME, 
       NEGATIVE_RULE_SET_OWNER, 
       NEGATIVE_RULE_SET_NAME
   FROM DBA_CAPTURE;
</pre>
<p>Make a note of the rule sets used by the capture process. You will need to specify these rule sets for the new capture process in Step <a href="#i1021736">12</a>.</p>
</li>
<li>
<p>Connect to the destination database and list the rule sets used by the apply process.</p>
<p>To list the rule sets used by the capture process, run the following query:</p>
<pre dir="ltr">COLUMN APPLY_NAME HEADING &#39;Apply|Process|Name&#39; FORMAT A15
COLUMN RULE_SET_OWNER HEADING &#39;Positive|Rule Owner&#39; FORMAT A15
COLUMN RULE_SET_NAME HEADING &#39;Positive|Rule Set&#39; FORMAT A15
COLUMN NEGATIVE_RULE_SET_OWNER HEADING &#39;Negative|Rule Owner&#39; FORMAT A15
COLUMN NEGATIVE_RULE_SET_NAME HEADING &#39;Negative|Rule Set&#39; FORMAT A15
 
SELECT APPLY_NAME, 
       RULE_SET_OWNER, 
       RULE_SET_NAME, 
       NEGATIVE_RULE_SET_OWNER, 
       NEGATIVE_RULE_SET_NAME
   FROM DBA_APPLY;
</pre>
<p>Make a note of the rule sets used by the apply process. You will need to specify these rule sets for the new apply process in Step <a href="#CEGCFGIJ">k</a>.</p>
</li>
<li>
<p>Stop the capture process using the <code dir="ltr">STOP_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
</li>
<li id="i1021755">
<p>At the source database, perform a data dictionary build:</p>
<pre dir="ltr">SET SERVEROUTPUT ON
DECLARE
  scn  NUMBER;
BEGIN
  DBMS_CAPTURE_ADM.BUILD(
    first_scn =&gt; scn);
  DBMS_OUTPUT.PUT_LINE(&#39;First SCN Value = &#39; || scn);
END;
/
</pre>
<p>Note the SCN value returned because it is needed in Step <a href="#i1021736">12</a>.</p>
</li>
<li>
<p>At the destination database, wait until all of the transactions from the source database in the apply process&#39;s queue have been applied. The apply processes should become idle when these transactions have been applied. You can query the <code dir="ltr">STATE</code> column in both the <code dir="ltr">V$STREAMS_APPLY_READER</code> and <code dir="ltr">V$STREAMS_APPLY_SERVER</code>. The state should be <code dir="ltr">IDLE</code> for the apply process in both views before you continue.</p>
</li>
<li id="i1021233">
<p>Perform a query at the destination database to determine the highest SCN for a transaction that was applied.</p>
<p>If the apply process is running, then perform the following query:</p>
<pre dir="ltr">SELECT HWM_MESSAGE_NUMBER FROM V$STREAMS_APPLY_COORDINATOR
  WHERE APPLY_NAME = &#39;STRM01_APPLY&#39;;
</pre>
<p>If the apply process is disabled, then perform the following query:</p>
<pre dir="ltr">SELECT APPLIED_MESSAGE_NUMBER FROM DBA_APPLY_PROGRESS
  WHERE APPLY_NAME = &#39;STRM01_APPLY&#39;;
</pre>
<p>Note the highest apply SCN returned by the query because it is needed in subsequent steps.</p>
</li>
<li id="i1021369">
<p>If the highest apply SCN obtained in Step <a href="#i1021233">8</a> is less than the point-in-time recovery SCN noted in Step <a href="#CEGECDDA">1</a>, then proceed to Step <a href="#i1021351">10</a>. Otherwise, if the highest apply SCN obtained in Step <a href="#i1021233">8</a> is greater than or equal to the point-in-time recovery SCN noted in Step <a href="#CEGECDDA">1</a>, then the apply process has applied some transactions from the source database after point-in-time recovery SCN, and you must complete the following steps:</p>
<ol>
<li>
<p>Manually execute the transactions that were applied after the point-in-time SCN at the source database. When you execute these transactions at the source database, ensure that you set an Oracle Streams tag in the session so that the transactions will not be captured by the capture process. If no such Oracle Streams session tag is set, then these changes can be cycled back to the destination database. See <a href="rep_tags.htm#i1010837">&#34;Managing Oracle Streams Tags for the Current Session&#34;</a> for instructions.</p>
</li>
<li>
<p>Disable the restricted session at the source database.</p>
</li>
<li>
<p>Proceed to Step <a href="#i1021655">11</a>. Do not complete Step <a href="#i1021351">10</a>.</p>
</li>
</ol>
</li>
<li id="i1021351">
<p>If the highest apply SCN obtained in Step <a href="#i1021233">8</a> is less than the point-in-time recovery SCN noted in Step <a href="#CEGECDDA">1</a>, then the apply process has not applied any transactions from the source database after point-in-time recovery SCN, and you must complete the following steps:</p>
<ol>
<li>
<p>Disable the restricted session at the source database.</p>
</li>
<li>
<p>Ensure that the apply process is running at the destination database.</p>
</li>
<li>
<p>Set the <code dir="ltr">maximum_scn</code> capture process parameter of the original capture process to the point-in-time recovery SCN using the <code dir="ltr">SET_PARAMETER</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
</li>
<li>
<p>Set the start SCN of the original capture process to the oldest SCN of the apply process. You can determine the oldest SCN of a running apply process by querying the <code dir="ltr">OLDEST_SCN_NUM</code> column in the <code dir="ltr">V$STREAMS_APPLY_READER</code> dynamic performance view at the destination database. To set the start SCN of the capture process, specify the <code dir="ltr">start_scn</code> parameter when you run the <code dir="ltr">ALTER_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
</li>
<li>
<p>Ensure that the capture process writes information to the alert log by running the following procedure:</p>
<pre dir="ltr">BEGIN
  DBMS_CAPTURE_ADM.SET_PARAMETER(
    capture_name =&gt; &#39;strm01_capture&#39;,
    parameter    =&gt; &#39;write_alert_log&#39;, 
    value        =&gt; &#39;Y&#39;);
END;
/
</pre></li>
<li>
<p>Start the original capture process using the <code dir="ltr">START_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
</li>
<li>
<p>Ensure that the original capture process has captured all changes up to the <code dir="ltr">maximum_scn</code> setting by querying the <code dir="ltr">CAPTURED_SCN</code> column in the <code dir="ltr">DBA_CAPTURE</code> data dictionary view. When the value returned by the query is equal to or greater than the <code dir="ltr">maximum_scn</code> value, the capture process should stop automatically. When the capture process is stopped, proceed to the next step.</p>
</li>
<li id="i1022225">
<p>Find the value of the <code dir="ltr">LAST_ENQUEUE_MESSAGE_NUMBER</code> in the alert log. Note this value because it is needed in subsequent steps.</p>
</li>
<li>
<p>At the destination database, wait until all the changes are applied. You can monitor the applied changes for the apply process <code dir="ltr">strm01_apply</code> by running the following queries at the destination database:</p>
<pre dir="ltr">SELECT DEQUEUED_MESSAGE_NUMBER
  FROM V$STREAMS_APPLY_READER
  WHERE APPLY_NAME = &#39;STRM01_APPLY&#39; AND
        DEQUEUED_MESSAGE_NUMBER = <span class="codeinlineitalic">last_enqueue_message_number</span>;
</pre>
<p>Substitute the <code dir="ltr">LAST_ENQUEUE_MESSAGE_NUMBER</code> found in the alert log in Step <a href="#i1022225">h</a> for <span class="italic">last_enqueue_message_number</span> on the last line of the query. When this query returns a row, all of the changes from the capture database have been applied at the destination database.</p>
<p>Also, ensure that the state of the apply process reader server and each apply server is <code dir="ltr">IDLE</code>. For example, run the following queries for an apply process named <code dir="ltr">strm01_apply</code>:</p>
<pre dir="ltr">SELECT STATE FROM V$STREAMS_APPLY_READER 
  WHERE APPLY_NAME = &#39;STRM01_APPLY&#39;;

SELECT STATE FROM V$STREAMS_APPLY_SERVER 
  WHERE APPLY_NAME = &#39;STRM01_APPLY&#39;;
</pre>
<p>When both of these queries return <code dir="ltr">IDLE</code>, move on to the next step.</p>
</li>
<li>
<p>At the destination database, drop the apply process using the <code dir="ltr">DROP_APPLY</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package.</p>
</li>
<li id="CEGCFGIJ">
<p>At the destination database, create a new apply process. The new apply process should use the same queue and rule sets used by the original apply process.</p>
</li>
<li>
<p>At the destination database, start the new apply process using the <code dir="ltr">START_APPLY</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package.</p>
</li>
</ol>
</li>
<li id="i1021655">
<p>Drop the original capture process using the <code dir="ltr">DROP_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
</li>
<li id="i1021736">
<p>Create a new capture process using the <code dir="ltr">CREATE_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package to replace the capture process you dropped in Step&nbsp;<a href="#i1021655">11</a>. Specify the SCN returned by the data dictionary build in Step <a href="#i1021755">6</a> for both the <code dir="ltr">first_scn</code> and <code dir="ltr">start_scn</code> parameters. The new capture process should use the same queue and rule sets as the original capture process.</p>
</li>
<li>
<p>Start the new capture process using the <code dir="ltr">START_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1013127"></a>
<div id="STREP445" class="sect2">
<h3 class="sect2">Performing Point-in-Time Recovery in a Multiple-Source Environment<a id="sthref590"></a></h3>
<p>A multiple-source environment is one in which there is more than one source database for any of the shared data. If database point-in-time recovery is required at a source database in a multiple-source Oracle Streams environment, then you can use another source database in the environment to recapture the changes made to the recovered source database after the point-in-time recovery.</p>
<p>For example, in a multiple-source Oracle Streams environment, one source database can become unavailable at time T2 and undergo point in time recovery to an earlier time T1. After recovery to T1, transactions performed at the recovered database between T1 and T2 are lost at the recovered database. However, before the recovered database became unavailable, assume that these transactions were propagated to another source database and applied. In this case, you can use this other source database to restore the lost changes to the recovered database.</p>
<p>Specifically, to restore changes made to the recovered database after the point-in-time recovery, you configure a capture process to recapture these changes from the redo logs at the other source database, a propagation to propagate these changes from the database where changes are recaptured to the recovered database, and an apply process at the recovered database to apply these changes.</p>
<p>Changes originating at the other source database that were applied at the recovered database between T1 and T2 also have been lost and must be recovered. To accomplish this, alter the capture process at the other source database to start capturing changes at an earlier SCN. This SCN is the oldest SCN for the apply process at the recovered database.</p>
<p>The following SCN values are required to restore lost changes to the recovered database:</p>
<ul>
<li>
<p><span class="bold">Point-in-time SCN</span>: The SCN for the point-in-time recovery at the recovered database.</p>
</li>
<li>
<p><span class="bold">Instantiation SCN</span>: The SCN value to which the instantiation SCN must be set for each database object involved in the recovery at the recovered database while changes are being reapplied. At the other source database, this SCN value corresponds to one less than the <span class="italic">commit SCN</span> of the first transaction that was applied at the other source database and lost at the recovered database.</p>
</li>
<li>
<p><span class="bold">Start SCN</span>: The SCN value to which the start SCN is set for the capture process created to recapture changes at the other source database. This SCN value corresponds to the <span class="italic">earliest SCN</span> at which the apply process at the other source database started applying a transaction that was lost at the recovered database. This capture process can be a local or downstream capture process that uses the other source database for its source database.</p>
</li>
<li>
<p><span class="bold">Maximum SCN</span>: The SCN value to which the <code dir="ltr">maximum_scn</code> parameter for the capture process created to recapture lost changes should be set. The capture process stops capturing changes when it reaches this SCN value. The current SCN for the other source database is used for this value.</p>
</li>
</ul>
<p>You should record the point-in-time SCN when you perform point-in-time recovery on the recovered database. You can use the <code dir="ltr">GET_SCN_MAPPING</code> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package to determine the other necessary SCN values.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS552" href="../ARPLS/d_streams_adm.htm#ARPLS552"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">GET_SCN_MAPPING</code> procedure</div>
</div>
<!-- class="sect2" -->
<a id="i1011204"></a>
<div id="STREP446" class="sect2">
<h3 class="sect2">Performing Point-in-Time Recovery on a Destination Database<a id="sthref591"></a><a id="sthref592"></a><a id="sthref593"></a></h3>
<p>If database point-in-time recovery is required at a destination database in an Oracle Streams environment, then you must reapply the captured changes that had already been applied after the point-in-time recovery.</p>
<p>For each relevant capture process, you can choose either of the following methods to perform point-in-time recovery at a destination database in an Oracle Streams environment:</p>
<ul>
<li>
<p>Reset the start SCN for the existing capture process that captures the changes that are applied at the destination database.</p>
</li>
<li>
<p>Create a new capture process to capture the changes that must be reapplied at the destination database.</p>
</li>
</ul>
<p>Resetting the start SCN for the capture process is simpler than creating a new capture process. However, if the capture process captures changes that are applied at multiple destination databases, then the changes are resent to all the destination databases, including the ones that did not perform point-in-time recovery. If a change is already applied at a destination database, then it is discarded by the apply process, but you might not want to use the network and computer resources required to resend the changes to multiple destination databases. In this case, you can create and temporarily use a new capture process and a new propagation that propagates changes only to the destination database that was recovered.</p>
<p>The following sections provide instructions for each task:</p>
<ul>
<li>
<p><a href="#i1011272">Resetting the Start SCN for the Existing Capture Process to Perform Recovery</a></p>
</li>
<li>
<p><a href="#i1011319">Creating a New Capture Process to Perform Recovery</a></p>
</li>
</ul>
<p>If there are multiple apply processes at the destination database where you performed point-in-time recovery, then complete one of the tasks in this section for each apply process.</p>
<p>Neither of these methods should be used if any of the following conditions are true regarding the destination database you are recovering:</p>
<ul>
<li>
<p>A propagation propagates persistent LCRs to the destination database. Both of these methods reapply only captured LCRs at the destination database, not persistent LCRs.</p>
</li>
<li>
<p>In a directed networks configuration, the destination database is used to propagate LCRs from a capture process to other databases, but the destination database does not apply LCRs from this capture process.</p>
</li>
<li>
<p>The oldest message number for an apply process at the destination database is lower than the first SCN of a capture process that captures changes for this apply process. The following query at a destination database lists the oldest message number (oldest SCN) for each apply process:</p>
<pre dir="ltr">SELECT APPLY_NAME, OLDEST_MESSAGE_NUMBER FROM DBA_APPLY_PROGRESS;
</pre>
<p>The following query at a source database lists the first SCN for each capture process:</p>
<pre dir="ltr">SELECT CAPTURE_NAME, FIRST_SCN FROM DBA_CAPTURE;
</pre></li>
<li>
<p>The archived log files that contain the intended start SCN are no longer available.</p>
</li>
</ul>
<p>If any of these conditions are true in your environment, then you cannot use the methods described in this section. Instead, you must manually resynchronize the data at all destination databases.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are using combined capture and apply in a single-source replication environment, and the destination database has undergone point-in-time recovery, then the Oracle Streams capture process automatically detects where to capture changes upon restart, and no extra steps are required for it. See <a class="olink STRMS171" href="../STRMS/strms_adcca.htm#STRMS171"><span class="italic">Oracle Streams Concepts and Administration</span></a> for more information.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS" href="../STRMS/toc.htm"><span class="italic">Oracle Streams Concepts and Administration</span></a> for more information about <a class="olink STRMS123" href="../STRMS/strms_capture.htm#STRMS123">SCN values relating to a capture process</a> and <a class="olink STRMS105" href="../STRMS/strms_prop.htm#STRMS105">directed networks</a></div>
<a id="i1011272"></a>
<div id="STREP447" class="sect3">
<h4 class="sect3">Resetting the Start SCN for the Existing Capture Process to Perform Recovery</h4>
<p>If you decide to reset the start SCN for the existing capture process to perform point-in-time recovery, then complete the following steps:</p>
<ol>
<li>
<p>If the destination database is also a source database in a multiple-source Oracle Streams environment, then complete the actions described in <a href="#i1013127">&#34;Performing Point-in-Time Recovery in a Multiple-Source Environment&#34;</a>.</p>
</li>
<li>
<p>Drop the propagation that propagates changes from the source queue at the source database to the destination queue at the destination database. Use the <code dir="ltr">DROP_PROPAGATION</code> procedure in the <code dir="ltr">DBMS_PROPAGATION_ADM</code> package to drop the propagation.</p>
<p>If you are using directed networks, and there are intermediate databases between the source database and destination database, then drop the propagation at each intermediate database in the path to the destination database, including the propagation at the source database.</p>
<p>Do not drop the rule sets used by the propagations you drop.</p>
<p>If the existing capture process is a downstream capture process that is configured at the destination database, then the downstream capture process is recovered to the same point-in-time as the destination database when you perform point-in-time recovery in Step <a href="#CHDDGEIH">3</a>. In this case, the remaining steps in this section after Step <a href="#CHDDGEIH">3</a> are not required. Ensure that the required redo log files are available to the capture process.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must drop the appropriate propagation(s). Disabling them is not sufficient. You will re-create the propagation(s) in Step&nbsp;<a href="#i1011315">7</a>, and dropping them now ensures that only LCRs created after resetting the start SCN for the capture process are propagated.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS105" href="../STRMS/strms_prop.htm#STRMS105"><span class="italic">Oracle Streams Concepts and Administration</span></a> for more information about directed networks</div>
</li>
<li id="CHDDGEIH">
<p>Perform the point-in-time recovery at the destination database.</p>
</li>
<li id="i1011297">
<p>Query for the oldest message number (oldest SCN) from the source database for the apply process at the destination database. Make a note of the results of the query. The oldest message number is the earliest system change number (SCN) that might need to be applied.</p>
<p>The following query at a destination database lists the oldest message number for each apply process:</p>
<pre dir="ltr">SELECT APPLY_NAME, OLDEST_MESSAGE_NUMBER FROM DBA_APPLY_PROGRESS;
</pre></li>
<li>
<p>Stop the existing capture process using the <code dir="ltr">STOP_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
</li>
<li>
<p>Reset the start SCN of the existing capture process.</p>
<p>To reset the start SCN for an existing capture process, run the <code dir="ltr">ALTER_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package and set the <code dir="ltr">start_scn</code> parameter to the value you recorded from the query in Step <a href="#i1011297">4</a>. For example, to reset the start SCN for a capture process named <code dir="ltr">strm01_capture</code> to the value <code dir="ltr">829381993</code>, run the following <code dir="ltr">ALTER_CAPTURE</code> procedure:</p>
<pre dir="ltr">BEGIN
  DBMS_CAPTURE_ADM.ALTER_CAPTURE(
    capture_name  =&gt;  &#39;strm01_capture&#39;,
    start_scn     =&gt;  829381993);
END;
/
</pre></li>
<li id="i1011315">
<p>If you are not using directed networks between the source database and destination database, then create a new propagation to propagate changes from the source queue to the destination queue using the <code dir="ltr">CREATE_PROPAGATION</code> procedure in the <code dir="ltr">DBMS_PROPAGATION_ADM</code> package. Specify any rule sets used by the original propagation when you create the propagation.</p>
<p>If you are using directed networks, and there are intermediate databases between the source database and destination database, then create a new propagation at each intermediate database in the path to the destination database, including the propagation at the source database.</p>
</li>
<li>
<p>Start the existing capture process using the <code dir="ltr">START_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="i1011319"></a>
<div id="STREP448" class="sect3">
<h4 class="sect3">Creating a New Capture Process to Perform Recovery</h4>
<p>If you decide to create a capture process to perform point-in-time recovery, then complete the following steps:</p>
<a id="i1011322"></a>
<ol>
<li id="CEGGEACJ">
<p>If the destination database is also a source database in a multiple-source Oracle Streams environment, then complete the actions described in <a href="#i1013127">&#34;Performing Point-in-Time Recovery in a Multiple-Source Environment&#34;</a>.</p>
</li>
<li id="CEGCGHAF">
<p>If you are not using directed networks between the source database and destination database, then drop the propagation that propagates changes from the source queue at the source database to the destination queue at the destination database. Use the <code dir="ltr">DROP_PROPAGATION</code> procedure in the <code dir="ltr">DBMS_PROPAGATION_ADM</code> package to drop the propagation.</p>
<p>If you are using directed networks, and there are intermediate databases between the source database and destination database, then drop the propagation that propagates LCRs between the last intermediate database and the destination database. You do not need to drop the propagations at the other intermediate databases nor at the source database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must drop the appropriate propagation. Disabling it is not sufficient.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS105" href="../STRMS/strms_prop.htm#STRMS105"><span class="italic">Oracle Streams Concepts and Administration</span></a> for more information about directed networks</div>
</li>
<li>
<p>Perform the point-in-time recovery at the destination database.</p>
</li>
<li id="i1011342">
<p>Query for the oldest message number (oldest SCN) from the source database for the apply process at the destination database. Make a note of the results of the query. The oldest message number is the earliest system change number (SCN) that might need to be applied.</p>
<p>The following query at a destination database lists the oldest message number for each apply process:</p>
<pre dir="ltr">SELECT APPLY_NAME, OLDEST_MESSAGE_NUMBER FROM DBA_APPLY_PROGRESS;
</pre></li>
<li id="i1011347">
<p>Create a queue at the source database to be used by the capture process using the <code dir="ltr">SET_UP_QUEUE</code> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package.</p>
<p>If you are using directed networks, and there are intermediate databases between the source database and destination database, then create a queue at each intermediate database in the path to the destination database, including the new queue at the source database. Do not create a new queue at the destination database.</p>
</li>
<li id="i1011350">
<p>If you are not using directed networks between the source database and destination database, then create a new propagation to propagate changes from the source queue created in Step <a href="#i1011347">5</a> to the destination queue using the <code dir="ltr">CREATE_PROPAGATION</code> procedure in the <code dir="ltr">DBMS_PROPAGATION_ADM</code> package. Specify any rule sets used by the original propagation when you create the propagation.</p>
<p>If you are using directed networks, and there are intermediate databases between the source database and destination database, then create a propagation at each intermediate database in the path to the destination database, including the propagation from the source database to the first intermediate database. These propagations propagate changes captured by the capture process you will create in Step <a href="#i1011362">7</a> between the queues created in&nbsp;Step&nbsp;<a href="#i1011347">5</a>.</p>
</li>
<li id="i1011362">
<p>Create a new capture process at the source database using the <code dir="ltr">CREATE_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package. Set the <code dir="ltr">source_queue</code> parameter to the local queue you created in Step <a href="#i1011347">5</a> and the <code dir="ltr">start_scn</code> parameter to the value you recorded from the query in Step <a href="#i1011342">4</a>. Also, specify any rule sets used by the original capture process. If the rule sets used by the original capture process instruct the capture process to capture changes that should not be sent to the destination database that was recovered, then you can create and use smaller, customized rule sets that share some rules with the original rule sets.</p>
</li>
<li id="i1011370">
<p>Start the capture process you created in Step <a href="#i1011362">7</a> using the <code dir="ltr">START_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
</li>
<li id="i1011375">
<p>When the oldest message number of the apply process at the recovered database is approaching the capture number of the original capture process at the source database, stop the original capture process using the <code dir="ltr">STOP_CAPTURE</code> procedure in the <code dir="ltr">DBMS_CAPTURE_ADM</code> package.</p>
<p>At the destination database, you can use the following query to determine the oldest message number from the source database for the apply process:</p>
<pre dir="ltr">SELECT APPLY_NAME, OLDEST_MESSAGE_NUMBER FROM DBA_APPLY_PROGRESS;
</pre>
<p>At the source database, you can use the following query to determine the capture number of the original capture process:</p>
<pre dir="ltr">SELECT CAPTURE_NAME, CAPTURE_MESSAGE_NUMBER FROM V$STREAMS_CAPTURE;
</pre></li>
<li>
<p>When the oldest message number of the apply process at the recovered database is beyond the capture number of the original capture process at the source database, drop the new capture process created in Step <a href="#i1011362">7</a>.</p>
</li>
<li>
<p>If you are not using directed networks between the source database and destination database, then drop the new propagation created in Step <a href="#i1011350">6</a>.</p>
<p>If you are using directed networks, and there are intermediate databases between the source database and destination database, then drop the new propagation at each intermediate database in the path to the destination database, including the new propagation at the source database.</p>
</li>
<li>
<p>If you are not using directed networks between the source database and destination database, then remove the queue created in Step <a href="#i1011347">5</a>.</p>
<p>If you are using directed networks, and there are intermediate databases between the source database and destination database, then drop the new queue at each intermediate database in the path to the destination database, including the new queue at the source database. Do not drop the queue at the destination database.</p>
</li>
<li>
<p>If you are not using directed networks between the source database and destination database, then create a propagation that propagates changes from the original source queue at the source database to the destination queue at the destination database. Use the <code dir="ltr">CREATE_PROPAGATION</code> procedure in the <code dir="ltr">DBMS_PROPAGATION_ADM</code> package to create the propagation. Specify any rule sets used by the original propagation when you create the propagation.</p>
<p>If you are using directed networks, and there are intermediate databases between the source database and destination database, then re-create the propagation from the last intermediate database to the destination database. You dropped this propagation in Step <a href="#CEGCGHAF">2</a>.</p>
</li>
<li>
<p>Start the capture process you stopped in Step <a href="#i1011375">9</a>.</p>
</li>
</ol>
<p>All of the steps after Step <a href="#i1011370">8</a> can be deferred to a later time, or they can be done as soon as the condition described in Step <a href="#i1011375">9</a> is met.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1016872"></a>
<div id="STREP133" class="sect1">
<h2 class="sect1">Running Flashback Queries in an Oracle Streams Replication Environment<a id="sthref594"></a><a id="sthref595"></a></h2>
<p>Oracle Flashback Query enables you to view and repair historical data. You can perform queries on a database as of a certain clock time or system change number (SCN). In an Oracle Streams single-source replication environment, you can use Flashback Query at the source database and a destination database at a past time when the replicated database objects should be identical.</p>
<p>You can run the queries at corresponding SCNS at the source and destination databases to determine whether all of the changes to the replicated objects performed at the source database have been applied at the destination database. If there are apply errors at the destination database, then such a Flashback Query can show how the replicated objects looked at the time when the error was raised. This information could be useful in determining the cause of the error and the best way to correct the error.</p>
<p>Running a Flashback Query at each database can also check whether tables have certain rows at the corresponding SCNs. If the table data does not match at the corresponding SCNs, then there is a problem with the replication environment.</p>
<p>To run queries, the Oracle Streams replication environment must have the following characteristics:</p>
<ul>
<li>
<p>The replication environment must be a single-source environment, where changes to replicated objects are captured at only one database.</p>
</li>
<li>
<p>No modifications are made to the replicated objects in the Stream. That is, no transformations, subset rules (row migration), or apply handlers modify the LCRs for the replicated objects.</p>
</li>
<li>
<p>No DML or DDL changes are made to the replicated objects at the destination database.</p>
</li>
<li>
<p>Both the source database and the destination database must be configured to use Oracle Flashback, and the Oracle Streams administrator at both databases must be able to execute subprograms in the <code dir="ltr">DBMS_FLASHBACK</code> package.</p>
</li>
<li>
<p>The information in the undo tablespace must go back far enough to perform the query at each database. Oracle Flashback features use the Automatic Undo Management system to obtain historical data and metadata for a transaction. The <code dir="ltr">UNDO_RETENTION</code> initialization parameter at each database must be set to a value that is large enough to perform the Flashback Query.</p>
</li>
</ul>
<p>Because Oracle Streams replication is asynchronous, you cannot use a past time in the Flashback Query. However, you can use the <code dir="ltr">GET_SCN_MAPPING</code> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package to determine the SCN at the destination database that corresponds to an SCN at the source database.</p>
<p>These instructions assume that you know the SCN for the Flashback Query at the source database. Using this SCN, you can determine the corresponding SCN for the Flashback Query at the destination database. To run these queries, complete the following steps:</p>
<a id="i1017320"></a>
<ol>
<li id="BABEHEHC">
<p>At the destination database, ensure that the archived redo log file for the approximate time of the Flashback Query is available to the database. The <code dir="ltr">GET_SCN_MAPPING</code> procedure requires that this redo log file be available.</p>
</li>
<li>
<p>In SQL*Plus, connect to the destination database as the Oracle Streams administrator.</p>
<p>See <a class="olink ADMIN00102" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=ADMIN00102"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for instructions about connecting to a database in SQL*Plus.</p>
</li>
<li id="i1017192">
<p>Run the <code dir="ltr">GET_SCN_MAPPING</code> procedure. In this example, assume that the SCN for the source database is <code dir="ltr">52073983</code> and that the name of the apply process that applies changes from the source database is <code dir="ltr">strm01_apply</code>:</p>
<pre dir="ltr">SET SERVEROUTPUT ON
DECLARE
  dest_scn   NUMBER;
  start_scn  NUMBER;
  dest_skip  DBMS_UTILITY.NAME_ARRAY;
BEGIN
  DBMS_STREAMS_ADM.GET_SCN_MAPPING(
    apply_name             =&gt; &#39;strm01_apply&#39;,
    src_pit_scn            =&gt; &#39;52073983&#39;,
    dest_instantiation_scn =&gt; dest_scn,
    dest_start_scn         =&gt; start_scn,
    dest_skip_txn_ids      =&gt; dest_skip);
  IF dest_skip.count = 0 THEN
    DBMS_OUTPUT.PUT_LINE(&#39;No Skipped Transactions&#39;);
    DBMS_OUTPUT.PUT_LINE(&#39;Destination SCN: &#39; || dest_scn);
  ELSE
    DBMS_OUTPUT.PUT_LINE(&#39;Destination SCN invalid for Flashback Query.&#39;);
    DBMS_OUTPUT.PUT_LINE(&#39;At least one transaction was skipped.&#39;);
  END IF;
END;
/
</pre>
<p>If a valid destination SCN is returned, then proceed to Step <a href="#i1017206">4</a>.</p>
<p>If the destination SCN was not valid for Flashback Query because one or more transactions were skipped by the apply process, then the apply process parameter <code dir="ltr">commit_serialization</code> was set to <code dir="ltr">DEPENDENT_TRANSACTIONS</code>, and nondependent transactions have been applied out of order. There is at least one transaction with a source commit SCN less than <code dir="ltr">src_pit_scn</code> that was committed at the destination database after the returned <code dir="ltr">dest_instantiation_scn</code>. Therefore, tables might not be the same at the source and destination databases for the specified source SCN. You can choose a different source SCN and restart at Step <a href="#BABEHEHC">1</a>.</p>
</li>
<li id="i1017206">
<p>Run the Flashback Query at the source database using the source SCN.</p>
</li>
<li id="i1017210">
<p>Run the Flashback Query at the destination database using the SCN returned in Step <a href="#i1017192">3</a>.</p>
</li>
<li>
<p>Compare the results of the queries in Steps <a href="#i1017206">4</a> and <a href="#i1017210">5</a> and take any necessary action.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS1008" href="../ADFNS/adfns_flashback.htm#ADFNS1008"><span class="italic">Oracle Database Development Guide</span></a> for more information about Flashback&nbsp;Query</p>
</li>
<li>
<p><a class="olink ARPLS552" href="../ARPLS/d_streams_adm.htm#ARPLS552"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">GET_SCN_MAPPING</code> procedure</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="CEGICHAA"></a>
<div id="STREP149" class="sect1">
<h2 class="sect1">Recovering from Operation Errors<a id="sthref596"></a><a id="sthref597"></a><a id="sthref598"></a><a id="sthref599"></a><a id="sthref600"></a><a id="sthref601"></a></h2>
<p>You can recover from the following operations using the <a class="olink ARPLS865" href="../ARPLS/d_streams_adm.htm#ARPLS865"><code dir="ltr">RECOVER_OPERATION</code></a> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package:</p>
<ul>
<li>
<p>Split and merge operations using:</p>
<ul>
<li>
<p>Automatic split and merge operations invoked by the <code dir="ltr">split_threshold</code> and <code dir="ltr">merge_threshold</code> capture process parameters.</p>
</li>
<li>
<p>Spit and merge operations that use the <a class="olink ARPLS867" href="../ARPLS/d_streams_adm.htm#ARPLS867"><code dir="ltr">SPLIT_STREAMS</code></a> and <a class="olink ARPLS881" href="../ARPLS/d_streams_adm.htm#ARPLS881"><code dir="ltr">MERGE_STREAMS_JOB</code></a> procedures in the <code dir="ltr">DBMS_STREAMS_ADM</code> package.</p>
</li>
</ul>
</li>
<li>
<p>Change table configuration operations performed by the <a class="olink ARPLS72443" href="../ARPLS/d_streams_adm.htm#ARPLS72443"><code dir="ltr">MAINTAIN_CHANGE_TABLE</code></a> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package.</p>
</li>
<li>
<p>Replication configuration operations performed by the following procedures in the <code dir="ltr">DBMS_STREAMS_ADM</code> package:</p>
<ul>
<li>
<p><a class="olink ARPLS825" href="../ARPLS/d_streams_adm.htm#ARPLS825"><code dir="ltr">MAINTAIN_GLOBAL</code></a></p>
</li>
<li>
<p><a class="olink ARPLS826" href="../ARPLS/d_streams_adm.htm#ARPLS826"><code dir="ltr">MAINTAIN_SCHEMAS</code></a></p>
</li>
<li>
<p><a class="olink ARPLS863" href="../ARPLS/d_streams_adm.htm#ARPLS863"><code dir="ltr">MAINTAIN_SIMPLE_TTS</code></a></p>
</li>
<li>
<p><a class="olink ARPLS827" href="../ARPLS/d_streams_adm.htm#ARPLS827"><code dir="ltr">MAINTAIN_TABLES</code></a></p>
</li>
<li>
<p><a class="olink ARPLS864" href="../ARPLS/d_streams_adm.htm#ARPLS864"><code dir="ltr">MAINTAIN_TTS</code></a></p>
</li>
<li>
<p><a class="olink ARPLS831" href="../ARPLS/d_streams_adm.htm#ARPLS831"><code dir="ltr">PRE_INSTANTIATION_SETUP</code></a> and <a class="olink ARPLS830" href="../ARPLS/d_streams_adm.htm#ARPLS830"><code dir="ltr">POST_INSTANTIATION_SETUP</code></a></p>
</li>
</ul>
</li>
</ul>
<p>Information about the operation is stored in the following data dictionary views when the operation is in process:</p>
<ul>
<li>
<p><a class="olink REFRN23545" href="../REFRN/GUID-AE694110-3EC9-49E7-BDA9-EFAF283C7D77.htm#REFRN23545"><code dir="ltr">DBA_RECOVERABLE_SCRIPT</code></a></p>
</li>
<li>
<p><a class="olink REFRN23755" href="../REFRN/GUID-F0381E5D-7C94-4770-A5B2-C1630025F348.htm#REFRN23755"><code dir="ltr">DBA_RECOVERABLE_SCRIPT_HIST</code></a></p>
</li>
<li>
<p><a class="olink REFRN23548" href="../REFRN/GUID-A9D0BD9D-44BD-4CC6-966A-1C9740DAD037.htm#REFRN23548"><code dir="ltr">DBA_RECOVERABLE_SCRIPT_PARAMS</code></a></p>
</li>
<li>
<p><a class="olink REFRN23546" href="../REFRN/GUID-0BC6927B-C58D-4252-BA83-43C55FA8A19E.htm#REFRN23546"><code dir="ltr">DBA_RECOVERABLE_SCRIPT_BLOCKS</code></a></p>
</li>
<li>
<p><a class="olink REFRN23547" href="../REFRN/GUID-9CAB8ECE-B0BA-4E13-8242-8A31AE2336B5.htm#REFRN23547"><code dir="ltr">DBA_RECOVERABLE_SCRIPT_ERRORS</code></a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the <code dir="ltr">perform_actions</code> parameter is set to <code dir="ltr">FALSE</code> when one of the configuration procedures is run, and a script is used to configure the Oracle Streams replication environment, then these data dictionary views are not populated, and the <code dir="ltr">RECOVER_OPERATION</code> procedure cannot be used for the operation.</div>
<p>When the operation completes successfully, metadata about the operation is moved from the <code dir="ltr">DBA_RECOVERABLE_SCRIPT</code> view to the <code dir="ltr">DBA_RECOVERABLE_SCRIPT_HIST</code> view. The other views, <code dir="ltr">DBA_RECOVERABLE_SCRIPT_PARAMS</code>, <code dir="ltr">DBA_RECOVERABLE_SCRIPT_BLOCKS</code>, and <code dir="ltr">DBA_RECOVERABLE_SCRIPT_ERRORS</code>, retain information about the operation until it is purged automatically after 30 days.</p>
<p>When the operation encounters an error, you can use the <a class="olink ARPLS865" href="../ARPLS/d_streams_adm.htm#ARPLS865"><code dir="ltr">RECOVER_OPERATION</code></a> procedure in the <code dir="ltr">DBMS_STREAMS_ADM</code> package to either roll the operation forward, roll the operation back, or purge the metadata about the operation. Specifically, the <code dir="ltr">operation_mode</code> parameter in the <a class="olink ARPLS865" href="../ARPLS/d_streams_adm.htm#ARPLS865"><code dir="ltr">RECOVER_OPERATION</code></a> procedure provides the following options:</p>
<ul>
<li>
<p><code dir="ltr">FORWARD</code>: This option attempts to complete the operation from the point at which it failed. Before specifying this option, correct the conditions that caused the errors reported in the <code dir="ltr">DBA_RECOVERABLE_SCRIPT_ERRORS</code> view.</p>
<p>You can also use the <code dir="ltr">FORWARD</code> option to obtain more information about what caused the error. To do so, run <code dir="ltr">SET</code> <code dir="ltr">SERVEROUTPUT</code> <code dir="ltr">ON</code> in SQL*Plus and run the <code dir="ltr">RECOVER_OPERATION</code> procedure with the appropriate script ID. The <code dir="ltr">RECOVER_OPERATION</code> procedure shows the actions that lead to the error and the error numbers and messages.</p>
</li>
<li>
<p><code dir="ltr">ROLLBACK</code>: This option rolls back all of the actions performed by the operation. If the rollback is successful, then this option also moves the metadata about the operation from the <code dir="ltr">DBA_RECOVERABLE_SCRIPT</code> view to the <code dir="ltr">DBA_RECOVERABLE_SCRIPT_HIST</code> view. The other views retain information about the operation for 30 days.</p>
</li>
<li>
<p><code dir="ltr">PURGE</code>: This option moves the metadata about the operation from the <code dir="ltr">DBA_RECOVERABLE_SCRIPT</code> view to the <code dir="ltr">DBA_RECOVERABLE_SCRIPT_HIST</code> view without rolling the operation back. The other views retain information about the operation for 30 days.</p>
</li>
</ul>
<p>When a recovery operation is complete, information about the operation is stored in the <code dir="ltr">DBA_RECOVERABLE_SCRIPT_HIST</code> view. The <code dir="ltr">STATUS</code> column shows either <code dir="ltr">EXECUTED</code> or <code dir="ltr">PURGED</code> for each recovery operation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To run the <code dir="ltr">RECOVER_OPERATION</code> procedure, both databases must be Oracle Database 10<span class="italic">g</span> Release 2 or later databases.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="config_simple.htm#CACJHHAA">&#34;Configuring Replication Using the DBMS_STREAMS_ADM Package&#34;</a> for more information about configuring an Oracle Streams replication environment with these procedures</p>
</li>
<li>
<p><a href="prep_rep.htm#CACGBCIB">&#34;Tasks to Complete Before Configuring Oracle Streams Replication&#34;</a> for information about prerequisites that must be met before running these procedures</p>
</li>
<li>
<p><a class="olink ARPLS865" href="../ARPLS/d_streams_adm.htm#ARPLS865"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p>
</li>
</ul>
</div>
<div id="STREP273" class="sect2"><a id="sthref602"></a>
<h3 class="sect2">Recovery Scenario</h3>
<p>This section contains a scenario in which the <code dir="ltr">MAINTAIN_SCHEMAS</code> procedure stops because it encounters an error. Assume that the following procedure encountered an error when it was run at the capture database:</p>
<pre dir="ltr">BEGIN
  DBMS_STREAMS_ADM.MAINTAIN_SCHEMAS(
    schema_names                 =&gt; &#39;hr&#39;,
    source_directory_object      =&gt; &#39;SOURCE_DIRECTORY&#39;,
    destination_directory_object =&gt; &#39;DEST_DIRECTORY&#39;,
    source_database              =&gt; &#39;dbs1.example.com&#39;,
    destination_database         =&gt; &#39;dbs2.example.com&#39;,
    perform_actions              =&gt; TRUE,
    dump_file_name               =&gt; &#39;export_hr.dmp&#39;,
    capture_queue_table          =&gt; &#39;rep_capture_queue_table&#39;,
    capture_queue_name           =&gt; &#39;rep_capture_queue&#39;,
    capture_queue_user           =&gt; NULL,
    apply_queue_table            =&gt; &#39;rep_dest_queue_table&#39;,
    apply_queue_name             =&gt; &#39;rep_dest_queue&#39;,
    apply_queue_user             =&gt; NULL,
    capture_name                 =&gt; &#39;capture_hr&#39;,
    propagation_name             =&gt; &#39;prop_hr&#39;,
    apply_name                   =&gt; &#39;apply_hr&#39;,
    log_file                     =&gt; &#39;export_hr.clg&#39;,
    bi_directional               =&gt; FALSE,
    include_ddl                  =&gt; TRUE,
    instantiation                =&gt; DBMS_STREAMS_ADM.INSTANTIATION_SCHEMA);
END;
/
</pre>
<p>Complete the following steps to diagnose the problem and recover the operation:</p>
<ol>
<li>
<p>In SQL*Plus, connect to the capture database as the Oracle Streams administrator.</p>
<p>See <a class="olink ADMIN00102" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=ADMIN00102"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for instructions about connecting to a database in SQL*Plus.</p>
</li>
<li id="CIAHCFDA">
<p>Determine the <code dir="ltr">SCRIPT_ID</code> value for the operation by running the following query:</p>
<pre dir="ltr">SELECT SCRIPT_ID FROM DBA_RECOVERABLE_SCRIPT ORDER BY CREATION_TIME DESC;
</pre>
<p>This query assumes that the most recent configuration operation is the one that encountered errors. Therefore, if more than one <code dir="ltr">SCRIPT_ID</code> is returned by the query, then use the first <code dir="ltr">SCRIPT_ID</code> in the list.</p>
</li>
<li id="CEGIJAGA">
<p>Query the <code dir="ltr">DBA_RECOVERABLE_SCRIPT_ERRORS</code> data dictionary view to determine the error and specify the <code dir="ltr">SCRIPT_ID</code> returned in Step <a href="#CIAHCFDA">2</a> in the <code dir="ltr">WHERE</code> clause.</p>
<p>For example, if the <code dir="ltr">SCRIPT_ID</code> is <code dir="ltr">F73ED2C9E96B27B0E030578CB10B2424</code>, then run the following query:</p>
<pre dir="ltr">COLUMN SCRIPT_ID     HEADING &#39;Script ID&#39;     FORMAT A35
COLUMN BLOCK_NUM     HEADING &#39;Block|Number&#39; FORMAT 999999
COLUMN ERROR_MESSAGE HEADING &#39;Error Message&#39; FORMAT A33

SELECT BLOCK_NUM, ERROR_MESSAGE 
  FROM DBA_RECOVERABLE_SCRIPT_ERRORS
  WHERE SCRIPT_ID = &#39;F73ED2C9E96B27B0E030578CB10B2424&#39;;
</pre>
<p>The query returns the following output:</p>
<pre dir="ltr">Block
Number Error Message
------- ---------------------------------
     12 ORA-39001: invalid argument value
</pre></li>
<li>
<p>Query the <code dir="ltr">DBA_RECOVERABLE_SCRIPT_BLOCKS</code> data dictionary view for the script ID returned in Step <a href="#CIAHCFDA">2</a> and block number returned in Step <a href="#CEGIJAGA">3</a> for information about the block in which the error occurred.</p>
<p>For example, if the script ID is <code dir="ltr">F73ED2C9E96B27B0E030578CB10B2424</code> and the block number is <code dir="ltr">12</code>, run the following query:</p>
<pre dir="ltr">COLUMN FORWARD_BLOCK        HEADING &#39;Forward Block&#39;               FORMAT A50
COLUMN FORWARD_BLOCK_DBLINK HEADING &#39;Forward Block|Database Link&#39; FORMAT A13
COLUMN STATUS               HEADING &#39;Status&#39;                      FORMAT A12

SET LONG 10000
SELECT FORWARD_BLOCK,
       FORWARD_BLOCK_DBLINK,
       STATUS
  FROM DBA_RECOVERABLE_SCRIPT_BLOCKS
  WHERE SCRIPT_ID = &#39;F73ED2C9E96B27B0E030578CB10B2424&#39; AND
        BLOCK_NUM = 12;
</pre>
<p>The output contains the following information:</p>
<ul>
<li>
<p>The <code dir="ltr">FORWARD_BLOCK</code> column contains detailed information about the actions performed by the procedure in the specified block. If necessary, spool the output into a file. In this scenario, the <code dir="ltr">FORWARD_BLOCK</code> column for block <code dir="ltr">12</code> contains the code for the Data Pump export.</p>
</li>
<li>
<p>The <code dir="ltr">FORWARD_BLOCK_DBLINK</code> column shows the database where the block is executed. In this scenario, the <code dir="ltr">FORWARD_BLOCK_DBLINK</code> column for block <code dir="ltr">12</code> shows <code dir="ltr">DBS1.EXAMPLE.COM</code> because the Data Pump export was being performed on <code dir="ltr">DBS1.EXAMPLE.COM</code> when the error occurred.</p>
</li>
<li>
<p>The <code dir="ltr">STATUS</code> column shows the status of the block execution. In this scenario, the <code dir="ltr">STATUS</code> column for block <code dir="ltr">12</code> shows <code dir="ltr">ERROR</code>.</p>
</li>
</ul>
</li>
<li>
<p>Optionally, run the <code dir="ltr">RECOVER_OPERATION</code> procedure operation at the capture database with <code dir="ltr">SET</code> <code dir="ltr">SERVEROUTPUT</code> <code dir="ltr">ON</code> to display more information about the errors:</p>
<pre dir="ltr">SET SERVEROUTPUT ON
BEGIN
  DBMS_STREAMS_ADM.RECOVER_OPERATION(
    script_id       =&gt; &#39;F73ED2C9E96B27B0E030578CB10B2424&#39;,
    operation_mode  =&gt; &#39;FORWARD&#39;);
END;
/
</pre>
<p>With server output on, the actions that caused the error run again, and the actions and the resulting errors are displayed.</p>
</li>
<li>
<p>Interpret the output from the previous steps and diagnose the problem. The output returned in Step <a href="#CEGIJAGA">3</a> provides the following information:</p>
<ul>
<li>
<p>The unique identifier for the configuration operation is <code dir="ltr">F73ED2C9E96B27B0E030578CB10B2424</code>. This value is the <code dir="ltr">RAW</code> value returned in the <code dir="ltr">SCRIPT_ID</code> field.</p>
</li>
<li>
<p>Only one Oracle Streams configuration procedure is in the process of running because only one row was returned by the query. If multiple rows were returned by the query, then query the <code dir="ltr">DBA_RECOVERABLE_SCRIPT</code> and <code dir="ltr">DBA_RECOVERABLE_SCRIPT_PARAMS</code> views to determine which script ID applies to the configuration operation.</p>
</li>
<li>
<p>The cause in <a class="olink ERRMG" href="../ERRMG/toc.htm"><span class="italic">Oracle Database Error Messages</span></a> for the <code dir="ltr">ORA-39001</code> error is the following: The user specified API parameters were of the wrong type or value range. Subsequent messages supplied by <code dir="ltr">DBMS_DATAPUMP.GET_STATUS</code> will further describe the error.</p>
</li>
<li>
<p>The query on the <code dir="ltr">DBA_RECOVERABLE_SCRIPT_BLOCKS</code> view shows that the error occurred during Data Pump export.</p>
</li>
</ul>
<p>The output from the queries shows that the <code dir="ltr">MAINTAIN_SCHEMAS</code> procedure encountered a Data Pump error. Notice that the <code dir="ltr">instantiation</code> parameter in the <code dir="ltr">MAINTAIN_SCHEMAS</code> procedure was set to <code dir="ltr">DBMS_STREAMS_ADM.INSTANTIATION_SCHEMA</code>. This setting means that the <code dir="ltr">MAINTAIN_SCHEMAS</code> procedure performs the instantiation using a Data Pump export and import. A Data Pump export dump file is generated to complete the export/import.</p>
<p>Data Pump errors usually are caused by one of the following conditions:</p>
<ul>
<li>
<p>One or more of the directory objects used to store the export dump file do not exist.</p>
</li>
<li>
<p>The user running the procedure does not have access to specified directory objects.</p>
</li>
<li>
<p>An export dump file with the same name as the one generated by the procedure already exists in a directory specified in the <code dir="ltr">source_directory_object</code> or <code dir="ltr">destination_directory_object</code> parameter.</p>
</li>
</ul>
</li>
<li>
<p>Query the <code dir="ltr">DBA_RECOVERABLE_SCRIPT_PARAMS</code> data dictionary view at the capture database to determine the names of the directory objects specified when the <code dir="ltr">MAINTAIN_SCHEMAS</code> procedure was run:</p>
<pre dir="ltr">COLUMN PARAMETER HEADING &#39;Parameter&#39; FORMAT A30
COLUMN VALUE     HEADING &#39;Value&#39;     FORMAT A45

SELECT PARAMETER,
       VALUE
       FROM DBA_RECOVERABLE_SCRIPT_PARAMS
       WHERE SCRIPT_ID = &#39;F73ED2C9E96B27B0E030578CB10B2424&#39;;
</pre>
<p>The query returns the following output:</p>
<pre dir="ltr">Parameter                      Value
------------------------------ ---------------------------------------------
SOURCE_DIRECTORY_OBJECT        SOURCE_DIRECTORY
DESTINATION_DIRECTORY_OBJECT   DEST_DIRECTORY
SOURCE_DATABASE                DBS1.EXAMPLE
DESTINATION_DATABASE           DBS2.EXAMPLE
CAPTURE_QUEUE_TABLE            REP_CAPTURE_QUEUE_TABLE
CAPTURE_QUEUE_OWNER            STRMADMIN
CAPTURE_QUEUE_NAME             REP_CAPTURE_QUEUE
CAPTURE_QUEUE_USER
APPLY_QUEUE_TABLE              REP_DEST_QUEUE_TABLE
APPLY_QUEUE_OWNER              STRMADMIN
APPLY_QUEUE_NAME               REP_DEST_QUEUE
APPLY_QUEUE_USER
CAPTURE_NAME                   CAPTURE_HR
APPLY_NAME                     APPLY_HR
PROPAGATION_NAME               PROP_HR
INSTANTIATION                  INSTANTIATION_SCHEMA
BI_DIRECTIONAL                 TRUE
INCLUDE_DDL                    TRUE
LOG_FILE                       export_hr.clg
DUMP_FILE_NAME                 export_hr.dmp
SCHEMA_NAMES                   HR
</pre></li>
<li>
<p>Ensure that the directory object specified for the <code dir="ltr">source_directory_object</code> parameter exists at the source database, and ensure that the directory object specified for the <code dir="ltr">destination_directory_object</code> parameter exists at the destination database. Check for these directory objects by querying the <code dir="ltr">DBA_DIRECTORIES</code> data dictionary view.</p>
<p>For this scenario, assume that the <code dir="ltr">SOURCE_DIRECTORY</code> directory object does not exist at the source database, and the <code dir="ltr">DEST_DIRECTORY</code> directory object does not exist at the destination database. The Data Pump error occurred because the directory objects used for the export dump file did not exist.</p>
</li>
<li>
<p>Create the required directory objects at the source and destination databases using the SQL statement <code dir="ltr">CREATE</code> <code dir="ltr">DIRECTORY</code>. See <a href="config_simple.htm#CACHFABG">&#34;Creating the Required Directory Objects&#34;</a> for instructions.</p>
</li>
<li>
<p>Run the <code dir="ltr">RECOVER_OPERATION</code> procedure at the capture database:</p>
<pre dir="ltr">BEGIN
  DBMS_STREAMS_ADM.RECOVER_OPERATION(
    script_id       =&gt; &#39;F73ED2C9E96B27B0E030578CB10B2424&#39;,
    operation_mode  =&gt; &#39;FORWARD&#39;);
END;
/
</pre>
<p>Notice that the <code dir="ltr">script_id</code> parameter is set to the value determined in Step <a href="#CEGIJAGA">3</a>, and the <code dir="ltr">operation_mode</code> parameter is set to <code dir="ltr">FORWARD</code> to complete the configuration. Also, the <code dir="ltr">RECOVER_OPERATION</code> procedure must be run at the database where the configuration procedure was run.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment91">
<tr>
<td class="cellalignment98">
<table class="cellalignment96">
<tr>
<td class="cellalignment95"><a href="ptrep_admin.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment95"><a href="man_comp.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2003, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment100">
<table class="cellalignment94">
<tr>
<td class="cellalignment95"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment95"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment95"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment95"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment95"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment95"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>