<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-104194"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Oracle%20Streams%20Conflict%20Resolution"></a><title>Oracle Streams Conflict Resolution</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1044"/>
<meta name="dcterms.created" content="2015-02-12T7:14:19Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Streams Replication Administrator&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53118-02"/>
<meta name="dcterms.isVersionOf" content="STREP"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2003, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="instant.htm" title="Previous" type="text/html"/>
<link rel="Next" href="rep_tags.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53118-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/28</span> <!-- End Header -->
<div id="STREP001" class="chapter"><a id="g1013001"></a> <a id="i1006084"></a>
<h1 class="chapter"><span class="secnum">9</span> Oracle Streams Conflict Resolution</h1>
<p><a id="sthref358"></a><a id="sthref359"></a><a id="sthref360"></a>Some Oracle Streams environments must use conflict handlers to resolve possible data conflicts that can result from sharing data between multiple databases.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1006131">About DML Conflicts in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1006168">Conflict Types in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1006225">Conflicts and Transaction Ordering in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1006244">Conflict Detection in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1006279">Conflict Avoidance in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1006358">Conflict Resolution in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1007732">Managing Oracle Streams Conflict Detection and Resolution</a></p>
</li>
<li>
<p><a href="#i1012076">Monitoring Conflict Detection and Update Conflict Handlers</a></p>
</li>
</ul>
<a id="i1006131"></a>
<div id="STREP358" class="sect1">
<h2 class="sect1">About DML Conflicts<a id="sthref361"></a> in an Oracle Streams Environment</h2>
<p>A <span class="bold">conflict</span> is a mismatch between the old values in an LCR and the expected data in a table. Conflicts can occur in an Oracle Streams environment that permits concurrent data manipulation language (DML) operations on the same data at multiple databases. In an Oracle Streams environment, DML conflicts can occur only when an apply process is applying a message that contains a row change resulting from a DML operation. This type of message is called a row logical change record, or row LCR. An apply process automatically detects conflicts caused by row LCRs.</p>
<p>For example, when two transactions originating at different databases update the same row at nearly the same time, a conflict can occur. When you configure an Oracle Streams environment, you must consider whether conflicts can occur. You can configure conflict resolution to resolve conflicts automatically, if your system design permits conflicts.</p>
<p>In general, you should try to design an Oracle Streams environment that avoids the possibility of conflicts. Using the conflict avoidance techniques discussed later in this chapter, most system designs can avoid conflicts in all or a large percentage of the shared data. However, many applications require that some percentage of the shared data be updatable at multiple databases at any time. If this is the case, then you must address the possibility of conflicts.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An apply process does not detect DDL conflicts or conflicts resulting from user messages. Ensure that your environment avoids these types of conflicts.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS107" href="../STRMS/strms_capture.htm#STRMS107"><span class="italic">Oracle Streams Concepts and Administration</span></a> for more information about row LCRs</div>
</div>
<!-- class="sect1" -->
<a id="i1006168"></a>
<div id="STREP359" class="sect1">
<h2 class="sect1">Conflict Types<a id="sthref362"></a> in an Oracle Streams Environment</h2>
<p>You can encounter these types of conflicts when you share data at multiple databases:</p>
<ul>
<li>
<p><a href="#i1006191">Update Conflicts in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1006198">Uniqueness Conflicts in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1006206">Delete Conflicts in an Oracle Streams Environment</a></p>
</li>
<li>
<p><a href="#i1006214">Foreign Key Conflicts in an Oracle Streams Environment</a></p>
</li>
</ul>
<a id="i1006191"></a>
<div id="STREP360" class="sect2">
<h3 class="sect2">Update Conflicts<a id="sthref363"></a> in an Oracle Streams Environment</h3>
<p>An <span class="glossaryterm">update conflict</span> occurs when the apply process applies a row LCR containing an update to a row that conflicts with another update to the same row. Update conflicts can happen when two transactions originating from different databases update the same row at nearly the same time.</p>
</div>
<!-- class="sect2" -->
<a id="i1006198"></a>
<div id="STREP361" class="sect2">
<h3 class="sect2">Uniqueness Conflicts<a id="sthref364"></a><a id="sthref365"></a> in an Oracle Streams Environment</h3>
<p>A <span class="glossaryterm">uniqueness conflict</span> occurs when the apply process applies a row LCR containing a change to a row that violates a uniqueness integrity constraint, such as a <code dir="ltr">PRIMARY</code> <code dir="ltr">KEY</code> or <code dir="ltr">UNIQUE</code> constraint. For example, consider what happens when two transactions originate from two different databases, each inserting a row into a table with the same primary key value. In this case, the transactions cause a uniqueness conflict.</p>
</div>
<!-- class="sect2" -->
<a id="i1006206"></a>
<div id="STREP362" class="sect2">
<h3 class="sect2">Delete Conflicts<a id="sthref366"></a><a id="sthref367"></a> in an Oracle Streams Environment</h3>
<p>A <span class="glossaryterm">delete conflict</span> occurs when two transactions originate at different databases, with one transaction deleting a row and another transaction updating or deleting the same row. In this case, the row referenced in the row LCR does not exist to be either updated or deleted.</p>
</div>
<!-- class="sect2" -->
<a id="i1006214"></a>
<div id="STREP363" class="sect2">
<h3 class="sect2">Foreign Key Conflicts<a id="sthref368"></a><a id="sthref369"></a> in an Oracle Streams Environment</h3>
<p>A <span class="glossaryterm">foreign key conflict</span> occurs when the apply process applies a row LCR containing a change to a row that violates a foreign key constraint. For example, in the <code dir="ltr">hr</code> schema, the <code dir="ltr">department_id</code> column in the <code dir="ltr">employees</code> table is a foreign key of the <code dir="ltr">department_id</code> column in the <code dir="ltr">departments</code> table. Consider what can happen when the following changes originate at two different databases (<code dir="ltr">A</code> and <code dir="ltr">B</code>) and are propagated to a third database (<code dir="ltr">C</code>):</p>
<ul>
<li>
<p>At database <code dir="ltr">A</code>, a row is inserted into the <code dir="ltr">departments</code> table with a <code dir="ltr">department_id</code> of <code dir="ltr">271</code>. This change is propagated to database <code dir="ltr">B</code> and applied there.</p>
</li>
<li>
<p>At database <code dir="ltr">B</code>, a row is inserted into the <code dir="ltr">employees</code> table with an <code dir="ltr">employee_id</code> of&nbsp;<code dir="ltr">206</code> and a <code dir="ltr">department_id</code> of <code dir="ltr">271</code>.</p>
</li>
</ul>
<p>If the change that originated at database <code dir="ltr">B</code> is applied at database <code dir="ltr">C</code> before the change that originated at database <code dir="ltr">A</code>, then a foreign key conflict results because the row for the department with a <code dir="ltr">department_id</code> of <code dir="ltr">271</code> does not yet exist in the <code dir="ltr">departments</code> table at database <code dir="ltr">C</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006225"></a>
<div id="STREP364" class="sect1">
<h2 class="sect1">Conflicts and Transaction Ordering<a id="sthref370"></a><a id="sthref371"></a> in an Oracle Streams Environment</h2>
<p>Ordering conflicts can occur in an Oracle Streams environment when three or more databases share data and the data is updated at two or more of these databases. For example, consider a scenario in which three databases share information in the <code dir="ltr">hr.departments</code> table. The database names are <code dir="ltr">mult1.example.com</code>, <code dir="ltr">mult2.example.com</code>, and <code dir="ltr">mult3.example.com</code>. Suppose a change is made to a row in the <code dir="ltr">hr.departments</code> table at <code dir="ltr">mult1.example.com</code> that will be propagated to both <code dir="ltr">mult2.example.com</code> and <code dir="ltr">mult3.example.com</code>. The following series of actions might occur:</p>
<ol>
<li>
<p>The change is propagated to <code dir="ltr">mult2.example.com</code>.</p>
</li>
<li>
<p>An apply process at <code dir="ltr">mult2.example.com</code> applies the change from <code dir="ltr">mult1.example.com</code>.</p>
</li>
<li>
<p>A different change to the same row is made at <code dir="ltr">mult2.example.com</code>.</p>
</li>
<li>
<p>The change at <code dir="ltr">mult2.example.com</code> is propagated to <code dir="ltr">mult3.example.com</code>.</p>
</li>
<li>
<p>An apply process at <code dir="ltr">mult3.example.com</code> attempts to apply the change from <code dir="ltr">mult2.example.com</code> before another apply process at <code dir="ltr">mult3.example.com</code> applies the change from <code dir="ltr">mult1.example.com</code>.</p>
</li>
</ol>
<p>In this case, a conflict occurs because a column value for the row at <code dir="ltr">mult3.example.com</code> does not match the corresponding old value in the row LCR propagated from <code dir="ltr">mult2.example.com</code>.</p>
<p>In addition to causing a data conflict, transactions that are applied out of order might experience referential integrity problems at a remote database if supporting data has not been successfully propagated to that database. Consider the scenario where a new customer calls an order department. A customer record is created and an order is placed. If the order data is applied at a remote database before the customer data, then a referential integrity error is raised because the customer that the order references does not exist at the remote database.</p>
<p>If an ordering conflict is encountered, then you can resolve the conflict by reexecuting the transaction in the error queue after the required data has been propagated to the remote database and applied.</p>
</div>
<!-- class="sect1" -->
<a id="i1006244"></a>
<div id="STREP365" class="sect1">
<h2 class="sect1">Conflict Detection<a id="sthref372"></a><a id="sthref373"></a> in an Oracle Streams Environment</h2>
<p>An apply process detects update, uniqueness, delete, and foreign key conflicts as follows:</p>
<ul>
<li>
<p>An apply process detects an update conflict if there is any difference between the old values for a row in a row LCR and the current values of the same row at the destination database.</p>
</li>
<li>
<p>An apply process detects a uniqueness conflict if a uniqueness constraint violation occurs when applying an LCR that contains an insert or update operation.</p>
</li>
<li>
<p>An apply process detects a delete conflict if it cannot find a row when applying an LCR that contains an update or delete operation, because the primary key of the row does not exist.</p>
</li>
<li>
<p>An apply process detects a foreign key conflict if a foreign key constraint violation occurs when applying an LCR.</p>
</li>
</ul>
<p>A conflict can be detected when an apply process attempts to apply an LCR directly or when an apply process handler, such as a DML handler, runs the <code dir="ltr">EXECUTE</code> member procedure for an LCR. A conflict can also be detected when either the <code dir="ltr">EXECUTE_ERROR</code> or <code dir="ltr">EXECUTE_ALL_ERRORS</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package is run.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>If a column is updated and the column&#39;s old value equals its new value, then Oracle never detects a conflict for this column update.</p>
</li>
<li>
<p>Any old LOB values in update LCRs, delete LCRs, and LCRs dealing with piecewise updates to LOB columns are not used by conflict detection.</p>
</li>
</ul>
</div>
<a id="i1007231"></a>
<div id="STREP366" class="sect2">
<h3 class="sect2">Control Over Conflict Detection for Nonkey Columns<a id="sthref374"></a><a id="sthref375"></a></h3>
<p>By default, an apply process compares old values for all columns during conflict detection, but you can stop conflict detection for nonkey columns using the <code dir="ltr">COMPARE_OLD_VALUES</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package. Conflict detection might not be needed for some nonkey columns.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1018934">&#34;Stopping Conflict Detection for Nonkey Columns&#34;</a></p>
</li>
<li>
<p><a href="#i1015639">&#34;Displaying Information About Conflict Detection&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="STREP367" class="sect2"><a id="sthref376"></a>
<h3 class="sect2">Rows Identification During Conflict Detection in an Oracle Streams Environment <a id="sthref377"></a></h3>
<p>To detect conflicts accurately, Oracle must be able to identify and match corresponding rows at different databases uniquely. By default, Oracle uses the primary key of a table to identify rows in a table uniquely. When a table does not have a primary key, you should designate a substitute key. A substitute key is a column or set of columns that Oracle can use to identify uniquely rows in the table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS214" href="../STRMS/strms_adapply.htm#STRMS214"><span class="italic">Oracle Streams Concepts and Administration</span></a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006279"></a>
<div id="STREP368" class="sect1">
<h2 class="sect1">Conflict Avoidance<a id="sthref378"></a> <a id="sthref379"></a>in an Oracle Streams Environment</h2>
<p>This section describes ways to avoid data conflicts.</p>
<div id="STREP369" class="sect2"><a id="sthref380"></a>
<h3 class="sect2">Use a Primary Database Ownership Model<a id="sthref381"></a></h3>
<p>You can avoid the possibility of conflicts by limiting the number of databases in the system that have simultaneous update access to the tables containing shared data. Primary ownership prevents all conflicts, because only a single database permits updates to a set of shared data. Applications can even use row and column subsetting to establish more granular ownership of data than at the table level. For example, applications might have update access to specific columns or rows in a shared table on a database-by-database basis.</p>
</div>
<!-- class="sect2" -->
<div id="STREP370" class="sect2"><a id="sthref382"></a>
<h3 class="sect2">Avoid Specific Types of Conflicts</h3>
<p>If a primary database ownership model is too restrictive for your application requirements, then you can use a shared ownership data model, which means that conflicts might be possible. Even so, typically you can use some simple strategies to avoid specific types of conflicts.</p>
<a id="i1006292"></a>
<div id="STREP100" class="sect3">
<h4 class="sect3">Avoid Uniqueness Conflicts<a id="sthref383"></a><a id="sthref384"></a><a id="sthref385"></a><a id="sthref386"></a><a id="sthref387"></a> in an Oracle Streams Environment</h4>
<p>You can avoid uniqueness conflicts by ensuring that each database uses unique identifiers for shared data. There are three ways to ensure unique identifiers at all databases in an Oracle Streams environment.</p>
<p>One way is to construct a unique identifier by executing the following select statement:</p>
<pre dir="ltr">SELECT SYS_GUID() OID FROM DUAL;
</pre>
<p>This SQL operator returns a 16-byte globally unique identifier. This value is based on an algorithm that uses time, date, and the computer identifier to generate a globally unique identifier. The globally unique identifier appears in a format similar to the following:</p>
<pre dir="ltr">A741C791252B3EA0E034080020AE3E0A
</pre>
<p><a id="sthref388"></a><a id="sthref389"></a>Another way to avoid uniqueness conflicts is to create a sequence at each of the databases that shares data and concatenate the database name (or other globally unique value) with the local sequence. This approach helps to avoid any duplicate sequence values and helps to prevent uniqueness conflicts.</p>
<p>Finally, you can create a customized sequence at each of the databases that shares data so that no two databases can generate the same value. You can accomplish this by using a combination of starting, incrementing, and maximum values in the <code dir="ltr">CREATE</code> <code dir="ltr">SEQUENCE</code> statement. For example, you might configure the following sequences:</p>
<div id="STREP371" class="tblformal">
<p class="titleintable"><a id="sthref390"></a><a id="sthref391"></a>Table 9-1 Customized Sequences for Oracle Streams Replication Environments</p>
<table class="cellalignment105" title="Customized Sequences for Oracle Streams Replication Environments" summary="This table lists values to use for the STARTS WITH, INCREMENT BY, and range parameters in the CREATE SEQUENCE statement to generate unique sequences at different master sites." dir="ltr">
<thead>
<tr class="cellalignment92">
<th class="cellalignment104" id="r1c1-t7">Parameter</th>
<th class="cellalignment104" id="r1c2-t7">Database A</th>
<th class="cellalignment104" id="r1c3-t7">Database B</th>
<th class="cellalignment104" id="r1c4-t7">Database C</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment92">
<td class="cellalignment98" id="r2c1-t7" headers="r1c1-t7">
<p><code dir="ltr">START</code> <code dir="ltr">WITH</code></p>
</td>
<td class="cellalignment98" headers="r2c1-t7 r1c2-t7">
<p>1</p>
</td>
<td class="cellalignment98" headers="r2c1-t7 r1c3-t7">
<p>3</p>
</td>
<td class="cellalignment98" headers="r2c1-t7 r1c4-t7">
<p>5</p>
</td>
</tr>
<tr class="cellalignment92">
<td class="cellalignment98" id="r3c1-t7" headers="r1c1-t7">
<p><code dir="ltr">INCREMENT</code> <code dir="ltr">BY</code></p>
</td>
<td class="cellalignment98" headers="r3c1-t7 r1c2-t7">
<p>10</p>
</td>
<td class="cellalignment98" headers="r3c1-t7 r1c3-t7">
<p>10</p>
</td>
<td class="cellalignment98" headers="r3c1-t7 r1c4-t7">
<p>10</p>
</td>
</tr>
<tr class="cellalignment92">
<td class="cellalignment98" id="r4c1-t7" headers="r1c1-t7">
<p>Range Example</p>
</td>
<td class="cellalignment98" headers="r4c1-t7 r1c2-t7">
<p>1, 11, 21, 31, 41,...</p>
</td>
<td class="cellalignment98" headers="r4c1-t7 r1c3-t7">
<p>3, 13, 23, 33, 43,...</p>
</td>
<td class="cellalignment98" headers="r4c1-t7 r1c4-t7">
<p>5, 15, 25, 35, 45,...</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Using a similar approach, you can define different ranges for each database by specifying a <code dir="ltr">START</code> <code dir="ltr">WITH</code> and <code dir="ltr">MAXVALUE</code> that would produce a unique range for each database.</p>
</div>
<!-- class="sect3" -->
<a id="i1006345"></a>
<div id="STREP372" class="sect3">
<h4 class="sect3">Avoid Delete Conflicts<a id="sthref392"></a> in an Oracle Streams Environment</h4>
<p>Always avoid delete conflicts in shared data environments. In general, applications that operate within a shared ownership data model should not delete rows using <code dir="ltr">DELETE</code> statements. Instead, applications should mark rows for deletion and then configure the system to purge logically deleted rows periodically.</p>
</div>
<!-- class="sect3" -->
<div id="STREP373" class="sect3"><a id="sthref393"></a>
<h4 class="sect3">Avoid Update Conflicts<a id="sthref394"></a> in an Oracle Streams Environment</h4>
<p>After trying to eliminate the possibility of uniqueness and delete conflicts, you should also try to limit the number of possible update conflicts. However, in a shared ownership data model, update conflicts cannot be avoided in all cases. If you cannot avoid all update conflicts, then you must understand the types of conflicts possible and configure the system to resolve them if they occur.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006358"></a>
<div id="STREP374" class="sect1">
<h2 class="sect1">Conflict Resolution<a id="sthref395"></a> in an Oracle Streams Environment</h2>
<p>After an update conflict has been detected, a conflict handler can attempt to resolve it. Oracle Streams provides prebuilt conflict handlers to resolve update conflicts, but not uniqueness, delete, foreign key, or ordering conflicts. However, you can build your own custom conflict handler to resolve data conflicts specific to your business rules. Such a conflict handler can be part of a procedure DML handler or an error handler.</p>
<p>Whether you use prebuilt or custom conflict handlers, a conflict handler is applied as soon as a conflict is detected. If neither the specified conflict handler nor the relevant apply handler can resolve the conflict, then the conflict is logged in the error queue. You might want to use the relevant apply handler to notify the database administrator when a conflict occurs.</p>
<p>When a conflict causes a transaction to be moved to the error queue, sometimes it is possible to correct the condition that caused the conflict. In these cases, you can reexecute a transaction using the <code dir="ltr">EXECUTE_ERROR</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink STRMS004" href="../STRMS/strms_apply.htm#STRMS004"><span class="italic">Oracle Streams Concepts and Administration</span></a> for more information about procedure DML handlers, error handlers, and the error queue</p>
</li>
<li>
<p><a class="olink ARPLS326" href="../ARPLS/d_apply.htm#ARPLS326"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">EXECUTE_ERROR</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package</p>
</li>
</ul>
</div>
<a id="CHDDHEAF"></a>
<div id="STREP375" class="sect2">
<h3 class="sect2">Prebuilt Update Conflict Handlers<a id="sthref396"></a><a id="sthref397"></a></h3>
<p>This section describes the types of prebuilt update conflict handlers available to you and how column lists and resolution columns are used in prebuilt update conflict handlers. A column list is a list of columns for which the update conflict handler is called when there is an update conflict. The resolution column is the column used to identify an update conflict handler. If you use a <code dir="ltr">MAXIMUM</code> or <code dir="ltr">MINIMUM</code> prebuilt update conflict handler, then the resolution column is also the column used to resolve the conflict. The resolution column must be one of the columns in the column list for the handler.</p>
<p>Use the <code dir="ltr">SET_UPDATE_CONFLICT_HANDLER</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package to specify one or more update conflict handlers for a particular table. There are no prebuilt conflict handlers for uniqueness, delete, or foreign key conflicts.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1007732">&#34;Managing Oracle Streams Conflict Detection and Resolution&#34;</a> for instructions on adding, modifying, and removing an update conflict handler</p>
</li>
<li>
<p><a class="olink ARPLS323" href="../ARPLS/d_apply.htm#ARPLS323"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">SET_UPDATE_CONFLICT_HANDLER</code> procedure</p>
</li>
<li>
<p><a href="#i1006514">&#34;Column Lists&#34;</a></p>
</li>
<li>
<p><a href="#i1006544">&#34;Resolution Columns&#34;</a></p>
</li>
</ul>
</div>
<div id="STREP376" class="sect3"><a id="sthref398"></a>
<h4 class="sect3">Types of Prebuilt Update Conflict Handlers</h4>
<p>Oracle provides the following types of prebuilt update conflict handlers for an Oracle Streams environment: <code dir="ltr">OVERWRITE</code>, <code dir="ltr">DISCARD</code>, <code dir="ltr">MAXIMUM</code>, and <code dir="ltr">MINIMUM</code>.</p>
<p>The description for each type of handler later in this section refers to the following conflict scenario:</p>
<ol>
<li>
<p>The following update is made at the <code dir="ltr">dbs1.example.com</code> source database:</p>
<pre dir="ltr">UPDATE hr.employees SET salary = 4900 WHERE employee_id = 200;
COMMIT;
</pre>
<p>This update changes the salary for employee <code dir="ltr">200</code> from <code dir="ltr">4400</code> to <code dir="ltr">4900</code>.</p>
</li>
<li>
<p>At nearly the same time, the following update is made at the <code dir="ltr">dbs2.example.com</code> destination database:</p>
<pre dir="ltr">UPDATE hr.employees SET salary = 5000 WHERE employee_id = 200;
COMMIT;
</pre></li>
<li>
<p>A capture process or synchronous capture captures the update at the <code dir="ltr">dbs1.example.com</code> source database and puts the resulting row LCR in a queue.</p>
</li>
<li>
<p>A propagation propagates the row LCR from the queue at <code dir="ltr">dbs1.example.com</code> to a queue at <code dir="ltr">dbs2.example.com</code>.</p>
</li>
<li>
<p>An apply process at <code dir="ltr">dbs2.example.com</code> attempts to apply the row LCR to the <code dir="ltr">hr.employees</code> table but encounters a conflict because the salary value at <code dir="ltr">dbs2.example.com</code> is <code dir="ltr">5000</code>, which does not match the old value for the salary in the row LCR (<code dir="ltr">4400</code>).</p>
</li>
</ol>
<p>The following sections describe each prebuilt conflict handler and explain how the handler resolves this conflict.</p>
<a id="i1006459"></a>
<div id="STREP377" class="sect4">
<h5 class="sect4">OVERWRITE<a id="sthref399"></a><a id="sthref400"></a></h5>
<p>When a conflict occurs, the <code dir="ltr">OVERWRITE</code> handler replaces the current value at the destination database with the new value in the LCR from the source database.</p>
<p>If the <code dir="ltr">OVERWRITE</code> handler is used for the <code dir="ltr">hr.employees</code> table at the <code dir="ltr">dbs2.example.com</code> destination database in the conflict example, then the new value in the row LCR overwrites the value at <code dir="ltr">dbs2.example.com</code>. Therefore, after the conflict is resolved, the salary for employee <code dir="ltr">200</code> is&nbsp;<code dir="ltr">4900</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i1006464"></a>
<div id="STREP378" class="sect4">
<h5 class="sect4">DISCARD<a id="sthref401"></a><a id="sthref402"></a></h5>
<p>When a conflict occurs, the <code dir="ltr">DISCARD</code> handler ignores the values in the LCR from the source database and retains the value at the destination database.</p>
<p>If the <code dir="ltr">DISCARD</code> handler is used for the <code dir="ltr">hr.employees</code> table at the <code dir="ltr">dbs2.example.com</code> destination database in the conflict example, then the new value in the row LCR is discarded. Therefore, after the conflict is resolved, the salary for employee <code dir="ltr">200</code> is&nbsp;<code dir="ltr">5000</code> at <code dir="ltr">dbs2.example.com</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i1006469"></a>
<div id="STREP379" class="sect4">
<h5 class="sect4">MAXIMUM<a id="sthref403"></a><a id="sthref404"></a></h5>
<p>When a conflict occurs, the <code dir="ltr">MAXIMUM</code> conflict handler compares the new value in the LCR from the source database with the current value in the destination database for a designated resolution column. If the new value of the resolution column in the LCR is greater than the current value of the column at the destination database, then the apply process resolves the conflict in favor of the LCR. If the new value of the resolution column in the LCR is less than the current value of the column at the destination database, then the apply process resolves the conflict in favor of the destination database.</p>
<p>If the <code dir="ltr">MAXIMUM</code> handler is used for the <code dir="ltr">salary</code> column in the <code dir="ltr">hr.employees</code> table at the <code dir="ltr">dbs2.example.com</code> destination database in the conflict example, then the apply process does not apply the row LCR, because the salary in the row LCR is less than the current salary in the table. Therefore, after the conflict is resolved, the salary for employee <code dir="ltr">200</code> is&nbsp;<code dir="ltr">5000</code> at <code dir="ltr">dbs2.example.com</code>.</p>
<p><a id="sthref405"></a><a id="sthref406"></a><a id="sthref407"></a>If you want to resolve conflicts based on the time of the transactions involved, then one way to do this is to add a column to a shared table that automatically records the transaction time with a trigger. You can designate this column as a resolution column for a <code dir="ltr">MAXIMUM</code> conflict handler, and the transaction with the latest (or greater) time would be used automatically.</p>
<p>The following is an example of a trigger that records the time of a transaction for the <code dir="ltr">hr.employees</code> table. Assume that the <code dir="ltr">job_id</code>, <code dir="ltr">salary</code>, and <code dir="ltr">commission_pct</code> columns are part of the column list for the conflict resolution handler. The trigger should fire only when an <code dir="ltr">UPDATE</code> is performed on the columns in the column list or when an <code dir="ltr">INSERT</code> is performed.</p>
<pre dir="ltr">ALTER TABLE hr.employees ADD (time TIMESTAMP WITH TIME ZONE);

CREATE OR REPLACE TRIGGER hr.insert_time_employees
BEFORE 
  INSERT OR UPDATE OF job_id, salary, commission_pct ON hr.employees
FOR EACH ROW
BEGIN
   -- Consider time synchronization problems. The previous update to this 
   -- row might have originated from a site with a clock time ahead of the 
   -- local clock time.
   IF :OLD.TIME IS NULL OR :OLD.TIME &lt; SYSTIMESTAMP THEN
     :NEW.TIME := SYSTIMESTAMP;
   ELSE
     :NEW.TIME := :OLD.TIME + 1 / 86400;
   END IF;
END;
/
</pre>
<p>If you use such a trigger for conflict resolution, then ensure that the trigger&#39;s firing property is fire once, which is the default. Otherwise, a new time might be marked when transactions are applied by an apply process, resulting in the loss of the actual time of the transaction.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS215" href="../STRMS/strms_adapply.htm#STRMS215"><span class="italic">Oracle Streams Concepts and Administration</span></a></div>
</div>
<!-- class="sect4" -->
<a id="i1006509"></a>
<div id="STREP380" class="sect4">
<h5 class="sect4">MINIMUM<a id="sthref408"></a><a id="sthref409"></a></h5>
<p>When a conflict occurs, the <code dir="ltr">MINIMUM</code> conflict handler compares the new value in the LCR from the source database with the current value in the destination database for a designated resolution column. If the new value of the resolution column in the LCR is less than the current value of the column at the destination database, then the apply process resolves the conflict in favor of the LCR. If the new value of the resolution column in the LCR is greater than the current value of the column at the destination database, then the apply process resolves the conflict in favor of the destination database.</p>
<p>If the <code dir="ltr">MINIMUM</code> handler is used for the <code dir="ltr">salary</code> column in the <code dir="ltr">hr.employees</code> table at the <code dir="ltr">dbs2.example.com</code> destination database in the conflict example, then the apply process resolves the conflict in favor of the row LCR, because the salary in the row LCR is less than the current salary in the table. Therefore, after the conflict is resolved, the salary for employee <code dir="ltr">200</code> is&nbsp;<code dir="ltr">4900</code>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1006514"></a>
<div id="STREP101" class="sect3">
<h4 class="sect3">Column Lists<a id="sthref410"></a><a id="sthref411"></a><a id="sthref412"></a></h4>
<p>Each time you specify a prebuilt update conflict handler for a table, you must specify a <span class="bold">column list</span>. A column list is a list of columns for which the update conflict handler is called. If an update conflict occurs for one or more of the columns in the list when an apply process tries to apply a row LCR, then the update conflict handler is called to resolve the conflict. The update conflict handler is not called if a conflict occurs only in columns that are not in the list. The scope of conflict resolution is a single column list on a single row LCR.</p>
<p>You can specify multiple update conflict handlers for a particular table, but the same column cannot be in more than one column list. For example, suppose you specify two prebuilt update conflict handlers on <code dir="ltr">hr.employees</code> table:</p>
<ul>
<li>
<p>The first update conflict handler has the following columns in its column list: <code dir="ltr">salary</code> and <code dir="ltr">commission_pct</code>.</p>
</li>
<li>
<p>The second update conflict handler has the following columns in its column list: <code dir="ltr">job_id</code> and <code dir="ltr">department_id</code>.</p>
</li>
</ul>
<p>Also, assume that no other conflict handlers exist for this table. In this case, if a conflict occurs for the <code dir="ltr">salary</code> column when an apply process tries to apply a row LCR, then the first update conflict handler is called to resolve the conflict. If, however, a conflict occurs for the <code dir="ltr">department_id</code> column, then the second update conflict handler is called to resolve the conflict. If a conflict occurs for a column that is not in a column list for any conflict handler, then no conflict handler is called, and an error results. In this example, if a conflict occurs for the <code dir="ltr">manager_id</code> column in the <code dir="ltr">hr.employees</code> table, then an error results. If conflicts occur in more than one column list when a row LCR is being applied, and there are no conflicts in any columns that are not in a column list, then the appropriate update conflict handler is invoked for each column list with a conflict.</p>
<p>Column lists enable you to use different handlers to resolve conflicts for different types of data. For example, numeric data is often suited for a maximum or minimum conflict handler, while an overwrite or discard conflict handler might be preferred for character data.</p>
<p>If a conflict occurs in a column that is not in a column list, then the error handler for the specific operation on the table attempts to resolve the conflict. If the error handler cannot resolve the conflict, or if there is no such error handler, then the transaction that caused the conflict is moved to the error queue.</p>
<p>Also, if a conflict occurs for a column in a column list that uses either the <code dir="ltr">OVERWRITE</code>, <code dir="ltr">MAXIMUM</code>, or <code dir="ltr">MINIMUM</code> prebuilt handler, and the row LCR does not contain all of the columns in this column list, then the conflict cannot be resolved because all of the values are not available. In this case, the transaction that caused the conflict is moved to the error queue. If the column list uses the <code dir="ltr">DISCARD</code> prebuilt method, then the row LCR is discarded and no error results, even if the row LCR does not contain all of the columns in this column list.</p>
<p>A conditional supplemental log group must be specified for the columns specified in a column list if more than one column at the source database affects the column list at the destination database. Supplemental logging is specified at the source database and adds additional information to the LCR, which is needed to resolve conflicts properly. Typically, a conditional supplemental log group must be specified for the columns in a column list if there are multiple columns in the column list, but not if there is only one column in the column list.</p>
<p>However, in some cases, a conditional supplemental log group is required even if there is only one column in a column list. That is, an apply handler or custom rule-based transformation can combine multiple columns from the source database into a single column in the column list at the destination database. For example, a custom rule-based transformation can take three columns that store street, state, and postal code data from a source database and combine the data into a single address column at a destination database.</p>
<p>Also, in some cases, no conditional supplemental log group is required even if there are multiple columns in a column list. For example, an apply handler or custom rule-based transformation can separate one address column from the source database into multiple columns that are in a column list at the destination database. A custom rule-based transformation can take an address that includes street, state, and postal code data in one address column at a source database and separate the data into three columns at a destination database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prebuilt update conflict handlers do not support LOB, <code dir="ltr">LONG</code>, <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, user-defined type, and Oracle-supplied type columns. Therefore, you should not include these types of columns in the <code dir="ltr">column_list</code> parameter when running the <code dir="ltr">SET_UPDATE_CONFLICT_HANDLER</code> procedure.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="prep_rep.htm#i1008208">&#34;Specifying Supplemental Logging&#34;</a></p>
</li>
<li>
<p><a class="olink SQLRF0021" href="../SQLRF/sql_elements001.htm#SQLRF0021"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about data types</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i1006544"></a>
<div id="STREP381" class="sect3">
<h4 class="sect3">Resolution Columns<a id="sthref413"></a><a id="sthref414"></a></h4>
<p>The <span class="bold">resolution column</span> is the column used to identify a prebuilt update conflict handler. If you use a <code dir="ltr">MAXIMUM</code> or <code dir="ltr">MINIMUM</code> prebuilt update conflict handler, then the resolution column is also the column used to resolve the conflict. The resolution column must be one of the columns in the column list for the handler.</p>
<p>For example, if the <code dir="ltr">salary</code> column in the <code dir="ltr">hr.employees</code> table is specified as the resolution column for a maximum or minimum conflict handler, then the <code dir="ltr">salary</code> column is evaluated to determine whether column list values in the row LCR are applied or the destination database values for the column list are retained.</p>
<p>In either of the following situations involving a resolution column for a conflict, the apply process moves the transaction containing the row LCR that caused the conflict to the error queue, if the error handler cannot resolve the problem. In these cases, the conflict cannot be resolved and the values of the columns at the destination database remain unchanged:</p>
<ul>
<li>
<p>The new LCR value and the destination row value for the resolution column are the same (for example, if the resolution column was not the column causing the conflict).</p>
</li>
<li>
<p>Either the new LCR value of the resolution column or the current value of the resolution column at the destination database is <code dir="ltr">NULL</code>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although the resolution column is not used for <code dir="ltr">OVERWRITE</code> and <code dir="ltr">DISCARD</code> conflict handlers, a resolution column must be specified for these conflict handlers.</div>
</div>
<!-- class="sect3" -->
<div id="STREP382" class="sect3"><a id="sthref415"></a>
<h4 class="sect3">Data Convergence<a id="sthref416"></a></h4>
<p>When you share data between multiple databases, and you want the data to be the same at all of these databases, then ensure that you use conflict resolution handlers that cause the data to converge at all databases. If you allow changes to shared data at all of your databases, then data convergence for a table is possible only if all databases that are sharing data capture changes to the shared data and propagate these changes to all of the other databases that are sharing the data.</p>
<p>In such an environment, the <code dir="ltr">MAXIMUM</code> conflict resolution method can guarantee convergence only if the values in the resolution column are always increasing. A time-based resolution column meets this requirement, if successive time stamps on a row are distinct. The <code dir="ltr">MINIMUM</code> conflict resolution method can guarantee convergence in such an environment only if the values in the resolution column are always decreasing.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006561"></a>
<div id="STREP383" class="sect2">
<h3 class="sect2">Custom Conflict Handlers<a id="sthref417"></a><a id="sthref418"></a></h3>
<p>You can create a PL/SQL procedure to use as a custom conflict handler. You use the <code dir="ltr">SET_DML_HANDLER</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package to designate one or more custom conflict handlers for a particular table. Specifically, set the following parameters when you run this procedure to specify a custom conflict handler:</p>
<ul>
<li>
<p>Set the <code dir="ltr">object_name</code> parameter to the fully qualified name of the table for which you want to perform conflict resolution.</p>
</li>
<li>
<p>Set the <code dir="ltr">object_type</code> parameter to <code dir="ltr">TABLE</code>.</p>
</li>
<li>
<p>Set the <code dir="ltr">operation_name</code> parameter to the type of operation for which the custom conflict handler is called. The possible operations are the following: <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, and <code dir="ltr">LOB_UPDATE</code>. You can also set the <code dir="ltr">operation_name</code> parameter to <code dir="ltr">DEFAULT</code> so that the handler is used by default for all operations.</p>
</li>
<li>
<p>If you want an error handler to perform conflict resolution when an error is raised, then set the <code dir="ltr">error_handler</code> parameter to <code dir="ltr">TRUE</code>. Or, if you want to include conflict resolution in your procedure DML handler, then set the <code dir="ltr">error_handler</code> parameter to <code dir="ltr">FALSE</code>.</p>
<p>If you specify <code dir="ltr">FALSE</code> for this parameter, then, when you execute a row LCR using the <code dir="ltr">EXECUTE</code> member procedure for the LCR, the conflict resolution within the procedure DML handler is performed for the specified object and operation(s).</p>
</li>
<li>
<p>Specify the procedure to resolve a conflict by setting the <code dir="ltr">user_procedure</code> parameter. This user procedure is called to resolve any conflicts on the specified table resulting from the specified type of operation.</p>
</li>
</ul>
<p>If the custom conflict handler cannot resolve the conflict, then the apply process moves the transaction containing the conflict to the error queue and does not apply the transaction.</p>
<p>If both a prebuilt update conflict handler and a custom conflict handler exist for a particular object, then the prebuilt update conflict handler is invoked only if both of the following conditions are met:</p>
<ul>
<li>
<p>The custom conflict handler executes the row LCR using the <code dir="ltr">EXECUTE</code> member procedure for the LCR.</p>
</li>
<li>
<p>The <code dir="ltr">conflict_resolution</code> parameter in the <code dir="ltr">EXECUTE</code> member procedure for the row LCR is set to <code dir="ltr">TRUE</code>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink STRMS144" href="../STRMS/strms_mapply.htm#STRMS144"><span class="italic">Oracle Streams Concepts and Administration</span></a> for more information about managing error handlers</p>
</li>
<li>
<p><a class="olink ARPLS324" href="../ARPLS/d_apply.htm#ARPLS324"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">SET_DML_HANDLER</code> procedure</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007732"></a>
<div id="STREP161" class="sect1">
<h2 class="sect1">Managing Oracle Streams Conflict Detection and Resolution</h2>
<p>This section describes the following tasks:</p>
<ul>
<li>
<p><a href="#i1018834">Setting an Update Conflict Handler</a></p>
</li>
<li>
<p><a href="#i1007920">Modifying an Existing Update Conflict Handler</a></p>
</li>
<li>
<p><a href="#i1016905">Removing an Existing Update Conflict Handler</a></p>
</li>
<li>
<p><a href="#i1018934">Stopping Conflict Detection for Nonkey Columns</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1012925">&#34;Displaying Information About Update Conflict Handlers&#34;</a></div>
<a id="i1018834"></a>
<div id="STREP384" class="sect2">
<h3 class="sect2">Setting an Update Conflict Handler<a id="sthref419"></a><a id="sthref420"></a></h3>
<p>Set an update conflict handler using the <code dir="ltr">SET_UPDATE_CONFLICT_HANDLER</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package. You can use one of the following prebuilt methods when you create an update conflict resolution handler:</p>
<ul>
<li>
<p><code dir="ltr">OVERWRITE</code></p>
</li>
<li>
<p><code dir="ltr">DISCARD</code></p>
</li>
<li>
<p><code dir="ltr">MAXIMUM</code></p>
</li>
<li>
<p><code dir="ltr">MINIMUM</code></p>
</li>
</ul>
<p>For example, suppose an Oracle Streams environment captures changes to the <code dir="ltr">hr.jobs</code> table at <code dir="ltr">dbs1.example.com</code> and propagates these changes to the <code dir="ltr">dbs2.example.com</code> destination database, where they are applied. In this environment, applications can perform DML changes on the <code dir="ltr">hr.jobs</code> table at both databases, but, if there is a conflict for a particular DML change, then the change at the <code dir="ltr">dbs1.example.com</code> database should always overwrite the change at the <code dir="ltr">dbs2.example.com</code> database. In this environment, you can accomplish this goal by specifying an <code dir="ltr">OVERWRITE</code> handler at the <code dir="ltr">dbs2.example.com</code> database.</p>
<p>To specify an update conflict handler for the <code dir="ltr">hr.jobs</code> table in the <code dir="ltr">hr</code> schema at the <code dir="ltr">dbs2.example.com</code> database, run the following procedure at <code dir="ltr">dbs2.example.com</code>:</p>
<pre dir="ltr">DECLARE
  cols DBMS_UTILITY.NAME_ARRAY;
  BEGIN
    cols(1) := &#39;job_title&#39;;
    cols(2) := &#39;min_salary&#39;;
    cols(3) := &#39;max_salary&#39;;
    DBMS_APPLY_ADM.SET_UPDATE_CONFLICT_HANDLER(
      object_name       =&gt; &#39;hr.jobs&#39;,
      method_name       =&gt; &#39;OVERWRITE&#39;,
      resolution_column =&gt; &#39;job_title&#39;,
      column_list       =&gt; cols);
END;
/
</pre>
<p>All apply processes running on a database that apply changes to the specified table locally use the specified update conflict handler.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The <code dir="ltr">resolution_column</code> is not used for <code dir="ltr">OVERWRITE</code> and <code dir="ltr">DISCARD</code> methods, but one of the columns in the <code dir="ltr">column_list</code> still must be specified.</p>
</li>
<li>
<p>You must specify a conditional supplemental log group at the source database for all of the columns in the <code dir="ltr">column_list</code> at the destination database. In this example, you would specify a conditional supplemental log group including the <code dir="ltr">job_title</code>, <code dir="ltr">min_salary</code>, and <code dir="ltr">max_salary</code> columns in the <code dir="ltr">hr.jobs</code> table at the <code dir="ltr">dbs1.example.com</code> database.</p>
</li>
<li>
<p>Prebuilt update conflict handlers do not support LOB, <code dir="ltr">LONG</code>, <code dir="ltr">LONG</code> <code dir="ltr">RAW</code>, user-defined type, and Oracle-supplied type columns. Therefore, you should not include these types of columns in the <code dir="ltr">column_list</code> parameter when running the procedure <code dir="ltr">SET_UPDATE_CONFLICT_HANDLER</code>.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="prep_rep.htm#i1008208">&#34;Specifying Supplemental Logging&#34;</a></p>
</li>
<li>
<p><a class="olink STREX004" href="../STREX/repmultdemo.htm#STREX004"><span class="italic">Oracle Streams Extended Examples</span></a> for an example Oracle Streams environment that illustrates using the <code dir="ltr">MAXIMUM</code> prebuilt method for time-based conflict resolution</p>
</li>
<li>
<p><a class="olink SQLRF0021" href="../SQLRF/sql_elements001.htm#SQLRF0021"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about data types</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007920"></a>
<div id="STREP385" class="sect2">
<h3 class="sect2">Modifying an Existing Update Conflict Handler<a id="sthref421"></a><a id="sthref422"></a></h3>
<p>You can modify an existing update conflict handler by running the <code dir="ltr">SET_UPDATE_CONFLICT_HANDLER</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package. To update an existing conflict handler, specify the same table and resolution column as the existing conflict handler.</p>
<p>To modify the update conflict handler created in <a href="#i1018834">&#34;Setting an Update Conflict Handler&#34;</a>, you specify the <code dir="ltr">hr.jobs</code> table and the <code dir="ltr">job_title</code> column as the resolution column. You can modify this update conflict handler by specifying a different type of prebuilt method or a different column list, or both. However, to change the resolution column for an update conflict handler, you must remove and re-create the handler.</p>
<p>For example, suppose the environment changes, and you want changes from <code dir="ltr">dbs1.example.com</code> to be discarded in the event of a conflict, whereas previously changes from <code dir="ltr">dbs1.example.com</code> overwrote changes at <code dir="ltr">dbs2.example.com</code>. You can accomplish this goal by specifying a <code dir="ltr">DISCARD</code> handler at the <code dir="ltr">dbs2.example.com</code> database.</p>
<p>To modify the existing update conflict handler for the <code dir="ltr">hr.jobs</code> table in the <code dir="ltr">hr</code> schema at the <code dir="ltr">dbs2.example.com</code> database, run the following procedure:</p>
<pre dir="ltr">DECLARE
  cols DBMS_UTILITY.NAME_ARRAY;
  BEGIN
    cols(1) := &#39;job_title&#39;;
    cols(2) := &#39;min_salary&#39;;
    cols(3) := &#39;max_salary&#39;;
    DBMS_APPLY_ADM.SET_UPDATE_CONFLICT_HANDLER(
      object_name       =&gt; &#39;hr.jobs&#39;,
      method_name       =&gt; &#39;DISCARD&#39;,
      resolution_column =&gt; &#39;job_title&#39;,
      column_list       =&gt; cols);
END;
/
</pre></div>
<!-- class="sect2" -->
<a id="i1016905"></a>
<div id="STREP386" class="sect2">
<h3 class="sect2">Removing an Existing Update Conflict Handler<a id="sthref423"></a><a id="sthref424"></a></h3>
<p>You can remove an existing update conflict handler by running the <code dir="ltr">SET_UPDATE_CONFLICT_HANDLER</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package. To remove a an existing conflict handler, specify <code dir="ltr">NULL</code> for the method, and specify the same table, column list, and resolution column as the existing conflict handler.</p>
<p>For example, suppose you want to remove the update conflict handler created in <a href="#i1018834">&#34;Setting an Update Conflict Handler&#34;</a> and then modified in <a href="#i1007920">&#34;Modifying an Existing Update Conflict Handler&#34;</a>. To remove this update conflict handler, run the following procedure:</p>
<pre dir="ltr">DECLARE
  cols DBMS_UTILITY.NAME_ARRAY;
  BEGIN
    cols(1) := &#39;job_title&#39;;
    cols(2) := &#39;min_salary&#39;;
    cols(3) := &#39;max_salary&#39;;
    DBMS_APPLY_ADM.SET_UPDATE_CONFLICT_HANDLER(
      object_name       =&gt; &#39;hr.jobs&#39;,
      method_name       =&gt; NULL,
      resolution_column =&gt; &#39;job_title&#39;,
      column_list       =&gt; cols);
END;
/
</pre></div>
<!-- class="sect2" -->
<a id="i1018934"></a>
<div id="STREP387" class="sect2">
<h3 class="sect2">Stopping Conflict Detection for Nonkey Columns<a id="sthref425"></a><a id="sthref426"></a></h3>
<p>You can stop conflict detection for nonkey columns using the <code dir="ltr">COMPARE_OLD_VALUES</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package.</p>
<p>For example, suppose you configure a <code dir="ltr">time</code> column for conflict resolution for the <code dir="ltr">hr.employees</code> table, as described in <a href="#i1006469">&#34;MAXIMUM&#34;</a>. In this case, you can decide to stop conflict detection for the other nonkey columns in the table. After adding the <code dir="ltr">time</code> column and creating the trigger as described in that section, add the columns in the <code dir="ltr">hr.employees</code> table to the column list for an update conflict handler:</p>
<pre dir="ltr">DECLARE
  cols  DBMS_UTILITY.NAME_ARRAY;
BEGIN
  cols(1)  := &#39;first_name&#39;;
  cols(2)  := &#39;last_name&#39;;
  cols(3)  := &#39;email&#39;;
  cols(4)  := &#39;phone_number&#39;;
  cols(5)  := &#39;hire_date&#39;;
  cols(6)  := &#39;job_id&#39;;
  cols(7)  := &#39;salary&#39;;
  cols(8)  := &#39;commission_pct&#39;;
  cols(9)  := &#39;manager_id&#39;;
  cols(10) := &#39;department_id&#39;;
  cols(11) := &#39;time&#39;;
  DBMS_APPLY_ADM.SET_UPDATE_CONFLICT_HANDLER(
    object_name       =&gt; &#39;hr.employees&#39;,
    method_name       =&gt; &#39;MAXIMUM&#39;,
    resolution_column =&gt; &#39;time&#39;,
    column_list       =&gt; cols);
END;
/
</pre>
<p>This example does not include the primary key for the table in the column list because it assumes that the primary key is never updated. However, other key columns are included in the column list.</p>
<p>To stop conflict detection for all nonkey columns in the table for both <code dir="ltr">UPDATE</code> and <code dir="ltr">DELETE</code> operations at a destination database, run the following procedure:</p>
<pre dir="ltr">DECLARE
  cols DBMS_UTILITY.LNAME_ARRAY;
  BEGIN
    cols(1) := &#39;first_name&#39;;
    cols(2) := &#39;last_name&#39;;
    cols(3) := &#39;email&#39;;
    cols(4) := &#39;phone_number&#39;;
    cols(5) := &#39;hire_date&#39;;
    cols(6) := &#39;job_id&#39;;
    cols(7) := &#39;salary&#39;;
    cols(8) := &#39;commission_pct&#39;;  
  DBMS_APPLY_ADM.COMPARE_OLD_VALUES(
    object_name  =&gt; &#39;hr.employees&#39;,
    column_table =&gt; cols, 
    operation    =&gt; &#39;*&#39;,
    compare      =&gt; FALSE);
END;
/
</pre>
<p>The asterisk (<code dir="ltr">*</code>) specified for the <code dir="ltr">operation</code> parameter means that conflict detection is stopped for both <code dir="ltr">UPDATE</code> and <code dir="ltr">DELETE</code> operations. After you run this procedure, all apply processes running on the database that apply changes to the specified table locally do not detect conflicts on the specified columns. Therefore, in this example, the <code dir="ltr">time</code> column is the only column used for conflict detection.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The example in this section sets an update conflict handler before stopping conflict detection for nonkey columns. However, an update conflict handler is not required before you stop conflict detection for nonkey columns.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1007231">&#34;Control Over Conflict Detection for Nonkey Columns&#34;</a></p>
</li>
<li>
<p><a href="#i1015639">&#34;Displaying Information About Conflict Detection&#34;</a></p>
</li>
<li>
<p><a class="olink STREX004" href="../STREX/repmultdemo.htm#STREX004"><span class="italic">Oracle Streams Extended Examples</span></a> for a detailed example that uses time-based conflict resolution</p>
</li>
<li>
<p><a class="olink ARPLS526" href="../ARPLS/d_apply.htm#ARPLS526"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">COMPARE_OLD_VALUES</code> procedure</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1012076"></a>
<div id="STREP158" class="sect1">
<h2 class="sect1">Monitoring Conflict Detection and Update Conflict Handlers</h2>
<p>The following sections contain queries that you can run to monitor an apply process in a Stream replication environment:</p>
<ul>
<li>
<p><a href="#i1015639">Displaying Information About Conflict Detection</a></p>
</li>
<li>
<p><a href="#i1012925">Displaying Information About Update Conflict Handlers</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS004" href="../STRMS/strms_apply.htm#STRMS004"><span class="italic">Oracle Streams Concepts and Administration</span></a></div>
<a id="i1015639"></a>
<div id="STREP388" class="sect2">
<h3 class="sect2">Displaying Information About Conflict Detection<a id="sthref427"></a><a id="sthref428"></a><a id="sthref429"></a></h3>
<p>You can stop conflict detection for nonkey columns using the <code dir="ltr">COMPARE_OLD_VALUES</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package. When you use this procedure, conflict detection is stopped for updates and deletes on the specified columns for all apply processes at a destination database. To display each column for which conflict detection has been stopped, run the following query:</p>
<pre dir="ltr">COLUMN OBJECT_OWNER HEADING &#39;Table Owner&#39; FORMAT A15
COLUMN OBJECT_NAME HEADING &#39;Table Name&#39; FORMAT A20
COLUMN COLUMN_NAME HEADING &#39;Column Name&#39; FORMAT A20
COLUMN COMPARE_OLD_ON_DELETE HEADING &#39;Compare|Old On|Delete&#39; FORMAT A7
COLUMN COMPARE_OLD_ON_UPDATE HEADING &#39;Compare|Old On|Update&#39; FORMAT A7

SELECT OBJECT_OWNER, 
       OBJECT_NAME, 
       COLUMN_NAME, 
       COMPARE_OLD_ON_DELETE, 
       COMPARE_OLD_ON_UPDATE 
  FROM DBA_APPLY_TABLE_COLUMNS
  WHERE APPLY_DATABASE_LINK IS NULL;
</pre>
<p>Your output should look similar to the following:</p>
<pre dir="ltr">                                                          Compare Compare
                                                          Old On  Old On
Table Owner     Table Name           Column Name          Delete  Update
--------------- -------------------- -------------------- ------- -------
HR              EMPLOYEES            COMMISSION_PCT       NO      NO
HR              EMPLOYEES            EMAIL                NO      NO
HR              EMPLOYEES            FIRST_NAME           NO      NO
HR              EMPLOYEES            HIRE_DATE            NO      NO
HR              EMPLOYEES            JOB_ID               NO      NO
HR              EMPLOYEES            LAST_NAME            NO      NO
HR              EMPLOYEES            PHONE_NUMBER         NO      NO
HR              EMPLOYEES            SALARY               NO      NO

</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can also stop conflict detection for changes that are applied to remote non-Oracle databases. This query does not display such specifications because it lists a specification only if the <code dir="ltr">APPLY_DATABASE_LINK</code> column is <code dir="ltr">NULL</code>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1007231">&#34;Control Over Conflict Detection for Nonkey Columns&#34;</a></p>
</li>
<li>
<p><a href="#i1018934">&#34;Stopping Conflict Detection for Nonkey Columns&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1012925"></a>
<div id="STREP389" class="sect2">
<h3 class="sect2">Displaying Information About Update Conflict Handlers<a id="sthref430"></a><a id="sthref431"></a><a id="sthref432"></a></h3>
<p>When you specify an update conflict handler using the <code dir="ltr">SET_UPDATE_CONFLICT_HANDLER</code> procedure in the <code dir="ltr">DBMS_APPLY_ADM</code> package, the update conflict handler is run for all apply processes in the database, when a relevant conflict occurs.</p>
<p>The query in this section displays all of the columns for which conflict resolution has been specified using a prebuilt update conflict handler. That is, it shows the columns in all of the column lists specified in the database. This query also shows the type of prebuilt conflict handler specified and the resolution column specified for the column list.</p>
<p>To display information about all of the update conflict handlers in a database, run the following query:</p>
<pre dir="ltr">COLUMN OBJECT_OWNER HEADING &#39;Table|Owner&#39; FORMAT A5
COLUMN OBJECT_NAME HEADING &#39;Table Name&#39; FORMAT A12
COLUMN METHOD_NAME HEADING &#39;Method&#39; FORMAT A12
COLUMN RESOLUTION_COLUMN HEADING &#39;Resolution|Column&#39; FORMAT A13
COLUMN COLUMN_NAME HEADING &#39;Column Name&#39; FORMAT A30

SELECT OBJECT_OWNER, 
       OBJECT_NAME, 
       METHOD_NAME, 
       RESOLUTION_COLUMN, 
       COLUMN_NAME
  FROM DBA_APPLY_CONFLICT_COLUMNS
  ORDER BY OBJECT_OWNER, OBJECT_NAME, RESOLUTION_COLUMN;
</pre>
<p>Your output looks similar to the following:</p>
<pre dir="ltr">Table                           Resolution
Owner Table Name   Method       Column        Column Name
----- ------------ ------------ ------------- ------------------------------
HR    COUNTRIES    MAXIMUM      TIME          COUNTRY_NAME
HR    COUNTRIES    MAXIMUM      TIME          REGION_ID
HR    COUNTRIES    MAXIMUM      TIME          TIME
HR    DEPARTMENTS  MAXIMUM      TIME          DEPARTMENT_NAME
HR    DEPARTMENTS  MAXIMUM      TIME          LOCATION_ID
HR    DEPARTMENTS  MAXIMUM      TIME          MANAGER_ID
HR    DEPARTMENTS  MAXIMUM      TIME          TIME
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007732">&#34;Managing Oracle Streams Conflict Detection and Resolution&#34;</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment91">
<tr>
<td class="cellalignment98">
<table class="cellalignment96">
<tr>
<td class="cellalignment95"><a href="instant.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment95"><a href="rep_tags.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2003, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment100">
<table class="cellalignment94">
<tr>
<td class="cellalignment95"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment95"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment95"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment95"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment95"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment95"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>