<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-103572"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/SELECT"></a><title>SELECT</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1093"/>
<meta name="dcterms.created" content="2017-07-18T18:53:2Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SQL Language Reference"/>
<meta name="dcterms.identifier" content="E41329-25"/>
<meta name="dcterms.isVersionOf" content="SQLRF"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2017,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="statements_10001.htm" title="Previous" type="text/html"/>
<link rel="Next" href="statements_10003.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41329-25.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">515/555</span> <!-- End Header --><a id="i2065646"></a>
<div id="SQLRF01702" class="refsect1"><!-- infolevel="all" infotype="General" -->
<h1 class="refsect1">SELECT <a id="sthref7287"></a><a id="sthref7288"></a></h1>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7289"></a>Purpose</p>
<p><a id="sthref7290"></a><a id="sthref7291"></a><a id="sthref7292"></a><a id="sthref7293"></a><a id="sthref7294"></a>Use a <code dir="ltr">SELECT</code> statement or subquery to retrieve data from one or more tables, object tables, views, object views, or materialized views.</p>
<p><a id="sthref7295"></a>If part or all of the result of a <code dir="ltr">SELECT</code> statement is equivalent to an existing materialized view, then Oracle Database may use the materialized view in place of one or more tables specified in the <code dir="ltr">SELECT</code> statement. This substitution is called <span class="bold">query rewrite</span>. It takes place only if cost optimization is enabled and the <code dir="ltr">QUERY_REWRITE_ENABLED</code> parameter is set to <code dir="ltr">TRUE</code>. To determine whether query rewrite has occurred, use the <code dir="ltr">EXPLAIN</code> <code dir="ltr">PLAN</code> statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="queries.htm#g2080389">Chapter 9, &#34;SQL Queries and Subqueries&#34;</a> for general information on queries and subqueries</p>
</li>
<li>
<p><span class="italic">Oracle Database Data Warehousing Guide</span> for more information on <a class="olink DWHSG008" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG008">materialized views</a> and <a class="olink DWHSG018" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG018">query rewrite</a></p>
</li>
<li>
<p><a href="statements_9010.htm#i2061796">EXPLAIN PLAN</a></p>
</li>
</ul>
</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7296"></a>Additional Topics</p>
<ul>
<li>
<p><a href="#i2065699">Prerequisites</a></p>
</li>
<li>
<p><a href="#i2065706">Syntax</a></p>
</li>
<li>
<p><a href="#i2065806">Semantics</a></p>
</li>
<li>
<p><a href="#i2066378">Examples</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="i2065699"></a>Prerequisites</p>
<p>For you to select data from a table or materialized view, the table or materialized view must be in your own schema or you must have the <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> privilege on the table or materialized view.</p>
<p>For you to select rows from the base tables of a view:</p>
<ul>
<li>
<p>The view must be in your own schema or you must have the <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> privilege on the view, and</p>
</li>
<li>
<p>Whoever owns the schema containing the view must have the <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> privilege on the base tables.</p>
</li>
</ul>
<p>The <code dir="ltr">READ</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> or <code dir="ltr">SELECT</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> system privilege also allows you to select data from any table or any materialized view or the base table of any view.</p>
<p>To specify the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause, the preceding prerequisites apply with the following exception: The <code dir="ltr">READ</code> and <code dir="ltr">READ</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> privileges, where mentioned, do not allow you to specify the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause.</p>
<p>To issue an Oracle Flashback Query using the <code dir="ltr"><span class="codeinlineitalic">flashback_query_clause</span></code>, you must have the <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> privilege on the objects in the select list. In addition, either you must have <code dir="ltr">FLASHBACK</code> object privilege on the objects in the select list, or you must have <code dir="ltr">FLASHBACK</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> system privilege.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="i2065706"></a>Syntax</p>
<p class="subhead2"><a id="i2126436"></a><a id="SQLRF55224"></a><span class="italic">select</span>::=</p>
<img width="279" height="46" src="img/select.gif" alt="Description of select.gif follows"/><br/>
<a id="sthref7297" href="img_text/select.htm">Description of the illustration &#39;&#39;select.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2126435"><span class="xreftitleitalic"><span class="italic">subquery</span>::=</span></a>, <a href="#i2126016"><span class="xreftitleitalic"><span class="italic">for_update_clause</span> ::=</span></a>)</p>
<p class="subhead2"><a id="i2126435"></a><a id="SQLRF55225"></a><span class="italic">subquery</span>::=<a id="sthref7298"></a></p>
<img width="742" height="183" src="img/subquery.gif" alt="Description of subquery.gif follows"/><br/>
<a id="sthref7299" href="img_text/subquery.htm">Description of the illustration &#39;&#39;subquery.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#CHDDCHGF"><span class="xreftitleitalic"><span class="italic">query_block</span>::=</span></a>, <a href="#i2168299"><span class="xreftitleitalic"><span class="italic">order_by_clause</span> ::=</span></a>, <a href="#BABBADDD"><span class="xreftitleitalic"><span class="italic">row_limiting_clause</span>::=</span></a>)</p>
<p class="subhead2"><a id="CHDDCHGF"></a><a id="SQLRF55226"></a><span class="italic">query_block</span>::=</p>
<img width="791" height="331" src="img/query_block.gif" alt="Description of query_block.gif follows"/><br/>
<a id="sthref7300" href="img_text/query_block.htm">Description of the illustration &#39;&#39;query_block.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#BABFAFID"><span class="xreftitleitalic"><span class="italic"><span class="italic">with_clause</span></span>::=</span></a>, <a href="#i2126854"><span class="xreftitleitalic"><span class="italic">select_list</span>::=</span></a>, <a href="#i2126863"><span class="xreftitleitalic"><span class="italic">table_reference</span>::=</span></a>, <a href="#CHDIJFDJ"><span class="xreftitleitalic"><span class="italic">join_clause</span> ::=</span></a>, <a href="#CHDIFBBI"><span class="xreftitleitalic"><span class="italic">where_clause</span>::=</span></a>, <a href="#i2126079"><span class="xreftitleitalic"><span class="italic">hierarchical_query_clause</span> ::=</span></a>, <a href="#i2065777"><span class="xreftitleitalic"><span class="italic">group_by_clause</span> ::=</span></a>, <a href="#i2161264"><span class="xreftitleitalic"><span class="italic">model_clause</span> ::=</span></a>)</p>
<p class="subhead2"><a id="BABFAFID"></a><a id="SQLRF56374"></a><span class="italic"><a href="#BABCGAAJ"><span class="xreftitleitalic"><span class="italic">with_clause</span></span></a></span>::=</p>
<img width="447" height="46" src="img/with_clause.gif" alt="Description of with_clause.gif follows"/><br/>
<a id="sthref7301" href="img_text/with_clause.htm">Description of the illustration &#39;&#39;with_clause.gif&#39;&#39;</a><br/>
<br/>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot specify only the <code dir="ltr">WITH</code> keyword. You must specify at least one of the clauses <code dir="ltr"><span class="codeinlineitalic">plsql_declarations</span></code> or <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code>.</div>
<p class="subhead2"><a id="BABDCHCC"></a><a id="SQLRF55663"></a><a href="#BABJCBCC"><span class="xreftitleitalic"><span class="italic">plsql_declarations</span></span></a>::=</p>
<img width="220" height="70" src="img/plsql_declarations.gif" alt="Description of plsql_declarations.gif follows"/><br/>
<a id="sthref7302" href="img_text/plsql_declarations.htm">Description of the illustration &#39;&#39;plsql_declarations.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2161315"></a><a id="SQLRF55227"></a><a href="#i2077142"><span class="xreftitleitalic"><span class="italic">subquery_factoring_clause</span></span></a>::=</p>
<img width="796" height="110" src="img/subquery_factoring_clause.gif" alt="Description of subquery_factoring_clause.gif follows"/><br/>
<a id="sthref7303" href="img_text/subquery_factoring_clause.htm">Description of the illustration &#39;&#39;subquery_factoring_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BCEHEGJA"></a><a id="SQLRF55228"></a><a href="#BCEDDGGE"><span class="xreftitleitalic"><span class="italic">search_clause</span></span></a>::=</p>
<img width="732" height="183" src="img/search_clause.gif" alt="Description of search_clause.gif follows"/><br/>
<a id="sthref7304" href="img_text/search_clause.htm">Description of the illustration &#39;&#39;search_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABFHEJC"></a><a id="SQLRF55574"></a><a href="#BABFFJFD"><span class="xreftitleitalic"><span class="italic">cycle_clause</span></span></a>::=</p>
<img width="659" height="58" src="img/cycle_clause.gif" alt="Description of cycle_clause.gif follows"/><br/>
<a id="sthref7305" href="img_text/cycle_clause.htm">Description of the illustration &#39;&#39;cycle_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2126854"></a><a id="SQLRF55229"></a><a href="#i2080424"><span class="xreftitleitalic"><span class="italic">select_list</span></span></a>::=</p>
<img width="463" height="291" src="img/select_list.gif" alt="Description of select_list.gif follows"/><br/>
<a id="sthref7306" href="img_text/select_list.htm">Description of the illustration &#39;&#39;select_list.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2126863"></a><a id="SQLRF55230"></a><span class="italic">table_reference</span>::=</p>
<img width="848" height="159" src="img/table_reference.gif" alt="Description of table_reference.gif follows"/><br/>
<a id="sthref7307" href="img_text/table_reference.htm">Description of the illustration &#39;&#39;table_reference.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2126073"><span class="xreftitleitalic"><span class="italic">query_table_expression</span>::=</span></a>, <a href="#i2126134"><span class="xreftitleitalic"><span class="italic">flashback_query_clause</span> ::=</span></a>, <a href="#CHDCEJJE"><span class="xreftitleitalic"><span class="italic">pivot_clause</span>::=</span></a>, <a href="#CHDJBHHI"><span class="xreftitleitalic"><span class="italic">unpivot_clause</span>::=</span></a>, <a href="#BABFAJHB"><span class="xreftitleitalic"><span class="italic">row_pattern_clause</span>::=</span></a>, <a href="#BCEGGHJC"><span class="xreftitleitalic"><span class="italic">containers_clause</span>::=</span></a>)</p>
<p class="subhead2"><a id="i2126134"></a><a id="SQLRF55231"></a><a href="#i2112818"><span class="xreftitleitalic"><span class="italic">flashback_query_clause</span></span></a> ::=</p>
<img width="774" height="187" src="img/flashback_query_clause.gif" alt="Description of flashback_query_clause.gif follows"/><br/>
<a id="sthref7308" href="img_text/flashback_query_clause.htm">Description of the illustration &#39;&#39;flashback_query_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2126073"></a><a id="SQLRF55232"></a><a href="#i2076542"><span class="xreftitleitalic"><span class="italic">query_table_expression</span></span></a>::=</p>
<img width="661" height="263" src="img/query_table_expression.gif" alt="Description of query_table_expression.gif follows"/><br/>
<a id="sthref7309" href="img_text/query_table_expression.htm">Description of the illustration &#39;&#39;query_table_expression.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2126149"><span class="xreftitleitalic"><span class="italic">subquery_restriction_clause</span>::=</span></a>, <a href="#i2065746"><span class="xreftitleitalic"><span class="italic">table_collection_expression</span> ::=</span></a>)</p>
<p class="subhead2"><a id="CHDCEJJE"></a><a id="SQLRF55233"></a><a href="#CHDFAFIE"><span class="xreftitleitalic"><span class="italic">pivot_clause</span></span></a>::=<a id="sthref7310"></a></p>
<img width="739" height="175" src="img/pivot_clause.gif" alt="Description of pivot_clause.gif follows"/><br/>
<a id="sthref7311" href="img_text/pivot_clause.htm">Description of the illustration &#39;&#39;pivot_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF55234"></a><span class="italic">pivot_for_clause</span>::=</p>
<img width="253" height="91" src="img/pivot_for_clause.gif" alt="Description of pivot_for_clause.gif follows"/><br/>
<a id="sthref7312" href="img_text/pivot_for_clause.htm">Description of the illustration &#39;&#39;pivot_for_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF55235"></a><span class="italic">pivot_in_clause</span>::=</p>
<img width="532" height="227" src="img/pivot_in_clause.gif" alt="Description of pivot_in_clause.gif follows"/><br/>
<a id="sthref7313" href="img_text/pivot_in_clause.htm">Description of the illustration &#39;&#39;pivot_in_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="CHDJBHHI"></a><a id="SQLRF55236"></a><a href="#CHDIBEFI"><span class="xreftitleitalic"><span class="italic">unpivot_clause</span></span></a>::=<a id="sthref7314"></a></p>
<img width="786" height="110" src="img/unpivot_clause.gif" alt="Description of unpivot_clause.gif follows"/><br/>
<a id="sthref7315" href="img_text/unpivot_clause.htm">Description of the illustration &#39;&#39;unpivot_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF55237"></a><span class="italic">unpivot_in_clause</span>::=</p>
<img width="595" height="175" src="img/unpivot_in_clause.gif" alt="Description of unpivot_in_clause.gif follows"/><br/>
<a id="sthref7316" href="img_text/unpivot_in_clause.htm">Description of the illustration &#39;&#39;unpivot_in_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF55238"></a><a href="#i2065953"><span class="xreftitleitalic"><span class="italic">sample_clause</span></span></a> ::=<a id="sthref7317"></a></p>
<img width="617" height="46" src="img/sample_clause.gif" alt="Description of sample_clause.gif follows"/><br/>
<a id="sthref7318" href="img_text/sample_clause.htm">Description of the illustration &#39;&#39;sample_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF55239"></a><span class="italic">partition_extension_clause</span>::=</p>
<img width="475" height="187" src="img/partition_extension_clause.gif" alt="Description of partition_extension_clause.gif follows"/><br/>
<a id="sthref7319" href="img_text/partition_extension_clause.htm">Description of the illustration &#39;&#39;partition_extension_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2126149"></a><a id="SQLRF55240"></a><a href="#i2146468"><span class="xreftitleitalic"><span class="italic">subquery_restriction_clause</span></span></a>::=<a id="sthref7320"></a><a id="sthref7321"></a></p>
<img width="463" height="64" src="img/subquery_restriction_clause.gif" alt="Description of subquery_restriction_clause.gif follows"/><br/>
<a id="sthref7322" href="img_text/subquery_restriction_clause.htm">Description of the illustration &#39;&#39;subquery_restriction_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2065746"></a><a id="SQLRF55241"></a><a href="#i2104990"><span class="xreftitleitalic"><span class="italic">table_collection_expression</span></span></a> ::=</p>
<img width="414" height="46" src="img/table_collection_expression.gif" alt="Description of table_collection_expression.gif follows"/><br/>
<a id="sthref7323" href="img_text/table_collection_expression.htm">Description of the illustration &#39;&#39;table_collection_expression.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BCEGGHJC"></a><a id="SQLRF56897"></a><a href="#BCEJBBIH"><span class="xreftitleitalic"><span class="italic">containers_clause</span></span></a>::=</p>
<img width="402" height="64" src="img/containers_clause.gif" alt="Description of containers_clause.gif follows"/><br/>
<a id="sthref7324" href="img_text/containers_clause.htm">Description of the illustration &#39;&#39;containers_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="CHDIJFDJ"></a><a id="SQLRF55242"></a><a href="#i2080416"><span class="xreftitleitalic"><span class="italic">join_clause</span></span></a> ::=</p>
<img width="345" height="103" src="img/join_clause.gif" alt="Description of join_clause.gif follows"/><br/>
<a id="sthref7325" href="img_text/join_clause.htm">Description of the illustration &#39;&#39;join_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#BABCGEDH"><span class="xreftitleitalic"><span class="italic"><span class="italic">inner_cross_join_clause</span></span>::=</span></a>, <a href="#BABBCHJA"><span class="xreftitleitalic"><span class="italic"><span class="italic">outer_join_clause</span></span>::=</span></a>, <a href="#BABJHDDA"><span class="xreftitleitalic"><span class="italic">cross_outer_apply_clause</span>::=</span></a>)</p>
<p class="subhead2"><a id="BABCGEDH"></a><a id="SQLRF55243"></a><span class="italic"><a href="#BABHEICD"><span class="xreftitleitalic"><span class="italic">inner_cross_join_clause</span></span></a></span>::=</p>
<img width="562" height="175" src="img/inner_cross_join_clause.gif" alt="Description of inner_cross_join_clause.gif follows"/><br/>
<a id="sthref7326" href="img_text/inner_cross_join_clause.htm">Description of the illustration &#39;&#39;inner_cross_join_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2126863"><span class="xreftitleitalic"><span class="italic">table_reference</span>::=</span></a>)</p>
<p class="subhead2"><a id="BABBCHJA"></a><a id="SQLRF55244"></a><span class="italic"><a href="#BABJCIFA"><span class="xreftitleitalic"><span class="italic">outer_join_clause</span></span></a></span>::=</p>
<img width="605" height="187" src="img/outer_join_clause.gif" alt="Description of outer_join_clause.gif follows"/><br/>
<a id="sthref7327" href="img_text/outer_join_clause.htm">Description of the illustration &#39;&#39;outer_join_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2197413"><span class="xreftitleitalic"><span class="italic">query_partition_clause</span>::=</span></a>, <a href="#BABIBHAJ"><span class="xreftitleitalic"><span class="italic">outer_join_type</span>::=</span></a>, <a href="#i2126863"><span class="xreftitleitalic"><span class="italic">table_reference</span>::=</span></a>)</p>
<p class="subhead2"><a id="i2197413"></a><a id="SQLRF55245"></a><a href="#i2196190"><span class="xreftitleitalic"><span class="italic">query_partition_clause</span></span></a>::=</p>
<img width="317" height="123" src="img/query_partition_clause.gif" alt="Description of query_partition_clause.gif follows"/><br/>
<a id="sthref7328" href="img_text/query_partition_clause.htm">Description of the illustration &#39;&#39;query_partition_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABIBHAJ"></a><a id="SQLRF55246"></a><a href="#i2192732"><span class="xreftitleitalic"><span class="italic">outer_join_type</span></span></a>::=</p>
<img width="223" height="91" src="img/outer_join_type.gif" alt="Description of outer_join_type.gif follows"/><br/>
<a id="sthref7329" href="img_text/outer_join_type.htm">Description of the illustration &#39;&#39;outer_join_type.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABJHDDA"></a><a id="SQLRF56412"></a><a href="#BABCHEAJ"><span class="xreftitleitalic"><span class="italic">cross_outer_apply_clause</span></span></a>::=</p>
<img width="345" height="58" src="img/cross_outer_apply_clause.gif" alt="Description of cross_outer_apply_clause.gif follows"/><br/>
<a id="sthref7330" href="img_text/cross_outer_apply_clause.htm">Description of the illustration &#39;&#39;cross_outer_apply_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2126863"><span class="xreftitleitalic"><span class="italic">table_reference</span>::=</span></a>, <a href="#i2197413"><span class="xreftitleitalic"><span class="italic">query_partition_clause</span>::=</span></a>)</p>
<p class="subhead2"><a id="CHDIFBBI"></a><a id="SQLRF55247"></a><a href="#i2134734"><span class="xreftitleitalic"><span class="italic">where_clause</span></span></a>::=</p>
<img width="159" height="27" src="img/where_clause.gif" alt="Description of where_clause.gif follows"/><br/>
<a id="sthref7331" href="img_text/where_clause.htm">Description of the illustration &#39;&#39;where_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2126079"></a><a id="SQLRF55248"></a><a href="#i2066102"><span class="xreftitleitalic"><span class="italic">hierarchical_query_clause</span></span></a> ::=<a id="sthref7332"></a><a id="sthref7333"></a><a id="sthref7334"></a></p>
<img width="610" height="98" src="img/hierarchical_query_clause.gif" alt="Description of hierarchical_query_clause.gif follows"/><br/>
<a id="sthref7335" href="img_text/hierarchical_query_clause.htm">Description of the illustration &#39;&#39;hierarchical_query_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<code dir="ltr"><span class="codeinlineitalic">condition</span></code> can be any condition as described in <a href="conditions.htm#g1077361">Chapter 6, &#34;Conditions&#34;</a>)</p>
<p class="subhead2"><a id="i2065777"></a><a id="SQLRF55249"></a><a href="#i2182483"><span class="xreftitleitalic"><span class="italic">group_by_clause</span></span></a> ::=<a id="sthref7336"></a></p>
<img width="515" height="123" src="img/group_by_clause.gif" alt="Description of group_by_clause.gif follows"/><br/>
<a id="sthref7337" href="img_text/group_by_clause.htm">Description of the illustration &#39;&#39;group_by_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2126291"><span class="xreftitleitalic"><span class="italic">rollup_cube_clause</span>::=</span></a>, <a href="#i2126297"><span class="xreftitleitalic"><span class="italic">grouping_sets_clause</span>::=</span></a>)</p>
<p class="subhead2"><a id="i2126291"></a><a id="SQLRF55250"></a><span class="italic">rollup_cube_clause</span>::=</p>
<img width="333" height="58" src="img/rollup_cube_clause.gif" alt="Description of rollup_cube_clause.gif follows"/><br/>
<a id="sthref7338" href="img_text/rollup_cube_clause.htm">Description of the illustration &#39;&#39;rollup_cube_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2189804"><span class="xreftitleitalic"><span class="italic">grouping_expression_list</span>::=</span></a>)</p>
<p class="subhead2"><a id="i2126297"></a><a id="SQLRF55251"></a><span class="italic">grouping_sets_clause</span>::=</p>
<img width="437" height="91" src="img/grouping_sets_clause.gif" alt="Description of grouping_sets_clause.gif follows"/><br/>
<a id="sthref7339" href="img_text/grouping_sets_clause.htm">Description of the illustration &#39;&#39;grouping_sets_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2126291"><span class="xreftitleitalic"><span class="italic">rollup_cube_clause</span>::=</span></a>, <a href="#i2189804"><span class="xreftitleitalic"><span class="italic">grouping_expression_list</span>::=</span></a>)</p>
<p class="subhead2"><a id="i2189804"></a><a id="SQLRF55252"></a><span class="italic">grouping_expression_list</span>::=</p>
<img width="150" height="58" src="img/grouping_expression_list.gif" alt="Description of grouping_expression_list.gif follows"/><br/>
<a id="sthref7340" href="img_text/grouping_expression_list.htm">Description of the illustration &#39;&#39;grouping_expression_list.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF55253"></a><span class="italic">expression_list</span>::=</p>
<img width="235" height="143" src="img/expression_list.gif" alt="Description of expression_list.gif follows"/><br/>
<a id="sthref7341" href="img_text/expression_list.htm">Description of the illustration &#39;&#39;expression_list.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2161264"></a><a id="SQLRF55254"></a><a href="#i2172805"><span class="xreftitleitalic"><span class="italic">model_clause</span></span></a> ::= <a id="sthref7342"></a></p>
<img width="721" height="58" src="img/model_clause.gif" alt="Description of model_clause.gif follows"/><br/>
<a id="sthref7343" href="img_text/model_clause.htm">Description of the illustration &#39;&#39;model_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2161331"><span class="xreftitleitalic"><span class="italic">cell_reference_options</span>::=</span></a>, <a href="#i2171032"><span class="xreftitleitalic"><span class="italic">return_rows_clause</span>::=</span></a>, <a href="#i2161349"><span class="xreftitleitalic"><span class="italic">reference_model</span>::=</span></a>, <a href="#i2161360"><span class="xreftitleitalic"><span class="italic">main_model</span>::=</span></a>)</p>
<p class="subhead2"><a id="i2161331"></a><a id="SQLRF55255"></a><a href="#i2168572"><span class="xreftitleitalic"><span class="italic">cell_reference_options</span></span></a>::=</p>
<img width="529" height="70" src="img/cell_reference_options.gif" alt="Description of cell_reference_options.gif follows"/><br/>
<a id="sthref7344" href="img_text/cell_reference_options.htm">Description of the illustration &#39;&#39;cell_reference_options.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2171032"></a><a id="SQLRF55256"></a><a href="#i2171017"><span class="xreftitleitalic"><span class="italic">return_rows_clause</span></span></a>::=</p>
<img width="265" height="58" src="img/return_rows_clause.gif" alt="Description of return_rows_clause.gif follows"/><br/>
<a id="sthref7345" href="img_text/return_rows_clause.htm">Description of the illustration &#39;&#39;return_rows_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2161349"></a><a id="SQLRF55257"></a><a href="#i2161156"><span class="xreftitleitalic"><span class="italic">reference_model</span></span></a>::=</p>
<img width="768" height="46" src="img/reference_model.gif" alt="Description of reference_model.gif follows"/><br/>
<a id="sthref7346" href="img_text/reference_model.htm">Description of the illustration &#39;&#39;reference_model.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2161363"><span class="xreftitleitalic"><span class="italic">model_column_clauses</span>::=</span></a>, <a href="#i2161331"><span class="xreftitleitalic"><span class="italic">cell_reference_options</span>::=</span></a>)</p>
<p class="subhead2"><a id="i2161360"></a><a id="SQLRF55258"></a><a href="#i2168646"><span class="xreftitleitalic"><span class="italic">main_model</span></span></a>::=</p>
<img width="702" height="46" src="img/main_model.gif" alt="Description of main_model.gif follows"/><br/>
<a id="sthref7347" href="img_text/main_model.htm">Description of the illustration &#39;&#39;main_model.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2161363"><span class="xreftitleitalic"><span class="italic">model_column_clauses</span>::=</span></a>, <a href="#i2161331"><span class="xreftitleitalic"><span class="italic">cell_reference_options</span>::=</span></a>, <a href="#i2161401"><span class="xreftitleitalic"><span class="italic">model_rules_clause</span>::=</span></a>)</p>
<p class="subhead2"><a id="i2161363"></a><a id="SQLRF55259"></a><a href="#i2168561"><span class="xreftitleitalic"><span class="italic">model_column_clauses</span></span></a>::=</p>
<img width="735" height="194" src="img/model_column_clauses.gif" alt="Description of model_column_clauses.gif follows"/><br/>
<a id="sthref7348" href="img_text/model_column_clauses.htm">Description of the illustration &#39;&#39;model_column_clauses.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2161401"></a><a id="SQLRF55261"></a><a href="#i2191799"><span class="xreftitleitalic"><span class="italic">model_rules_clause</span></span></a>::=</p>
<img width="798" height="267" src="img/model_rules_clause.gif" alt="Description of model_rules_clause.gif follows"/><br/>
<a id="sthref7349" href="img_text/model_rules_clause.htm">Description of the illustration &#39;&#39;model_rules_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#CHDJAAEF"><span class="xreftitleitalic"><span class="italic">model_iterate_clause</span>::=</span></a>, <a href="#i2161423"><span class="xreftitleitalic"><span class="italic">cell_assignment</span>::=</span></a>, <a href="#i2168299"><span class="xreftitleitalic"><span class="italic">order_by_clause</span> ::=</span></a>)</p>
<p class="subhead2"><a id="CHDJAAEF"></a><a id="SQLRF55262"></a><span class="italic">model_iterate_clause</span>::=</p>
<img width="454" height="46" src="img/model_iterate_clause.gif" alt="Description of model_iterate_clause.gif follows"/><br/>
<a id="sthref7350" href="img_text/model_iterate_clause.htm">Description of the illustration &#39;&#39;model_iterate_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2161423"></a><a id="SQLRF55263"></a><a href="#i2168603"><span class="xreftitleitalic"><span class="italic">cell_assignment</span></span></a>::=</p>
<img width="430" height="156" src="img/cell_assignment.gif" alt="Description of cell_assignment.gif follows"/><br/>
<a id="sthref7351" href="img_text/cell_assignment.htm">Description of the illustration &#39;&#39;cell_assignment.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#i2168318"><span class="xreftitleitalic"><span class="italic">single_column_for_loop</span>::=</span></a>, <a href="#i2168325"><span class="xreftitleitalic"><span class="italic">multi_column_for_loop</span>::=</span></a>)</p>
<p class="subhead2"><a id="i2168318"></a><a id="SQLRF55264"></a><a href="#i2182160"><span class="xreftitleitalic"><span class="italic">single_column_for_loop</span></span></a>::=</p>
<img width="770" height="159" src="img/single_column_for_loop.gif" alt="Description of single_column_for_loop.gif follows"/><br/>
<a id="sthref7352" href="img_text/single_column_for_loop.htm">Description of the illustration &#39;&#39;single_column_for_loop.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2168325"></a><a id="SQLRF55265"></a><a href="#i2168616"><span class="xreftitleitalic"><span class="italic">multi_column_for_loop</span></span></a>::=</p>
<img width="584" height="123" src="img/multi_column_for_loop.gif" alt="Description of multi_column_for_loop.gif follows"/><br/>
<a id="sthref7353" href="img_text/multi_column_for_loop.htm">Description of the illustration &#39;&#39;multi_column_for_loop.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2168299"></a><a id="SQLRF55266"></a><a href="#i2171079"><span class="xreftitleitalic"><span class="italic">order_by_clause</span></span></a> ::=<a id="sthref7354"></a></p>
<img width="715" height="143" src="img/order_by_clause.gif" alt="Description of order_by_clause.gif follows"/><br/>
<a id="sthref7355" href="img_text/order_by_clause.htm">Description of the illustration &#39;&#39;order_by_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABBADDD"></a><a id="SQLRF55631"></a><a href="#BABHFGAA"><span class="xreftitleitalic"><span class="italic">row_limiting_clause</span></span></a>::=</p>
<img width="673" height="202" src="img/row_limiting_clause.gif" alt="Description of row_limiting_clause.gif follows"/><br/>
<a id="sthref7356" href="img_text/row_limiting_clause.htm">Description of the illustration &#39;&#39;row_limiting_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="i2126016"></a><a id="SQLRF55267"></a><a href="#i2066346"><span class="xreftitleitalic"><span class="italic">for_update_clause</span></span></a> ::=<a id="sthref7357"></a></p>
<img width="848" height="135" src="img/for_update_clause.gif" alt="Description of for_update_clause.gif follows"/><br/>
<a id="sthref7358" href="img_text/for_update_clause.htm">Description of the illustration &#39;&#39;for_update_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABFAJHB"></a><a id="SQLRF56441"></a><a href="#BABHFEEE"><span class="xreftitleitalic"><span class="italic">row_pattern_clause</span></span></a>::=</p>
<img width="760" height="199" src="img/row_pattern_clause.gif" alt="Description of row_pattern_clause.gif follows"/><br/>
<a id="sthref7359" href="img_text/row_pattern_clause.htm">Description of the illustration &#39;&#39;row_pattern_clause.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#BABDAJEE"><span class="xreftitleitalic"><span class="italic">row_pattern_partition_by</span>::=</span></a>, <a href="#BABDHDEB"><span class="xreftitleitalic"><span class="italic">row_pattern_order_by</span>::=</span></a>, <a href="#BABIAAGF"><span class="xreftitleitalic"><span class="italic">row_pattern_measures</span>::=</span></a>, <a href="#BABEGCAD"><span class="xreftitleitalic"><span class="italic">row_pattern_rows_per_match</span>::=</span></a>, <a href="#BABJAEDA"><span class="xreftitleitalic"><span class="italic">row_pattern_skip_to</span>::=</span></a>, <a href="#BABDACDD"><span class="xreftitleitalic"><span class="italic">row_pattern</span>::=</span></a>, <a href="#BABEGIDD"><span class="xreftitleitalic"><span class="italic">row_pattern_subset_clause</span>::=</span></a>, <a href="#BABGCICD"><span class="xreftitleitalic"><span class="italic">row_pattern_definition_list</span>::=</span></a>)</p>
<p class="subhead2"><a id="BABDAJEE"></a><a id="SQLRF56442"></a><a href="#BABBHEEC"><span class="xreftitleitalic"><span class="italic">row_pattern_partition_by</span></span></a>::=</p>
<img width="241" height="58" src="img/row_pattern_partition_by.gif" alt="Description of row_pattern_partition_by.gif follows"/><br/>
<a id="sthref7360" href="img_text/row_pattern_partition_by.htm">Description of the illustration &#39;&#39;row_pattern_partition_by.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABDHDEB"></a><a id="SQLRF56443"></a><a href="#BABDGHAA"><span class="xreftitleitalic"><span class="italic">row_pattern_order_by</span></span></a>::=</p>
<img width="220" height="58" src="img/row_pattern_order_by.gif" alt="Description of row_pattern_order_by.gif follows"/><br/>
<a id="sthref7361" href="img_text/row_pattern_order_by.htm">Description of the illustration &#39;&#39;row_pattern_order_by.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABIAAGF"></a><a id="SQLRF56444"></a><a href="#BABCAEJD"><span class="xreftitleitalic"><span class="italic">row_pattern_measures</span></span></a>::=</p>
<img width="319" height="58" src="img/row_pattern_measures.gif" alt="Description of row_pattern_measures.gif follows"/><br/>
<a id="sthref7362" href="img_text/row_pattern_measures.htm">Description of the illustration &#39;&#39;row_pattern_measures.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF56445"></a><a href="#BABHGEBI"><span class="xreftitleitalic"><span class="italic">row_pattern_measure_column</span></span></a>::=</p>
<img width="169" height="27" src="img/row_pattern_measure_column.gif" alt="Description of row_pattern_measure_column.gif follows"/><br/>
<a id="sthref7363" href="img_text/row_pattern_measure_column.htm">Description of the illustration &#39;&#39;row_pattern_measure_column.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABEGCAD"></a><a id="SQLRF56446"></a><a href="#BABDDHIG"><span class="xreftitleitalic"><span class="italic">row_pattern_rows_per_match</span></span></a>::=</p>
<img width="274" height="58" src="img/row_pattern_rows_per_match.gif" alt="Description of row_pattern_rows_per_match.gif follows"/><br/>
<a id="sthref7364" href="img_text/row_pattern_rows_per_match.htm">Description of the illustration &#39;&#39;row_pattern_rows_per_match.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABJAEDA"></a><a id="SQLRF56447"></a><a href="#BABGGJBG"><span class="xreftitleitalic"><span class="italic">row_pattern_skip_to</span></span></a>::=</p>
<img width="511" height="143" src="img/row_pattern_skip_to.gif" alt="Description of row_pattern_skip_to.gif follows"/><br/>
<a id="sthref7365" href="img_text/row_pattern_skip_to.htm">Description of the illustration &#39;&#39;row_pattern_skip_to.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABDACDD"></a><a id="SQLRF56448"></a><a href="#BABCABFD"><span class="xreftitleitalic"><span class="italic">row_pattern</span></span></a>::=</p>
<img width="296" height="46" src="img/row_pattern.gif" alt="Description of row_pattern.gif follows"/><br/>
<a id="sthref7366" href="img_text/row_pattern.htm">Description of the illustration &#39;&#39;row_pattern.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF56449"></a><a href="#BABDBFFB"><span class="xreftitleitalic"><span class="italic">row_pattern_term</span></span></a>::=</p>
<img width="301" height="46" src="img/row_pattern_term.gif" alt="Description of row_pattern_term.gif follows"/><br/>
<a id="sthref7367" href="img_text/row_pattern_term.htm">Description of the illustration &#39;&#39;row_pattern_term.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF56450"></a><a href="#BABCBDAA"><span class="xreftitleitalic"><span class="italic">row_pattern_factor</span></span></a>::=</p>
<img width="334" height="46" src="img/row_pattern_factor.gif" alt="Description of row_pattern_factor.gif follows"/><br/>
<a id="sthref7368" href="img_text/row_pattern_factor.htm">Description of the illustration &#39;&#39;row_pattern_factor.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF56452"></a><a href="#BABBIDEJ"><span class="xreftitleitalic"><span class="italic">row_pattern_primary</span></span></a>::=</p>
<img width="254" height="208" src="img/row_pattern_primary.gif" alt="Description of row_pattern_primary.gif follows"/><br/>
<a id="sthref7369" href="img_text/row_pattern_primary.htm">Description of the illustration &#39;&#39;row_pattern_primary.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF56453"></a><a href="#BABEEAJJ"><span class="xreftitleitalic"><span class="italic">row_pattern_permute</span></span></a>::=</p>
<img width="277" height="58" src="img/row_pattern_permute.gif" alt="Description of row_pattern_permute.gif follows"/><br/>
<a id="sthref7370" href="img_text/row_pattern_permute.htm">Description of the illustration &#39;&#39;row_pattern_permute.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF56451"></a><a href="#BABEGBGE"><span class="xreftitleitalic"><span class="italic">row_pattern_quantifier</span></span></a>::=</p>
<img width="569" height="235" src="img/row_pattern_quantifier.gif" alt="Description of row_pattern_quantifier.gif follows"/><br/>
<a id="sthref7371" href="img_text/row_pattern_quantifier.htm">Description of the illustration &#39;&#39;row_pattern_quantifier.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABEGIDD"></a><a id="SQLRF56454"></a><a href="#BABIHBJA"><span class="xreftitleitalic"><span class="italic">row_pattern_subset_clause</span></span></a>::=</p>
<img width="275" height="58" src="img/row_pattern_subset_clause.gif" alt="Description of row_pattern_subset_clause.gif follows"/><br/>
<a id="sthref7372" href="img_text/row_pattern_subset_clause.htm">Description of the illustration &#39;&#39;row_pattern_subset_clause.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF56455"></a><a href="#BABCDBBJ"><span class="xreftitleitalic"><span class="italic">row_pattern_subset_item</span></span></a>::=</p>
<img width="343" height="58" src="img/row_pattern_subset_item.gif" alt="Description of row_pattern_subset_item.gif follows"/><br/>
<a id="sthref7373" href="img_text/row_pattern_subset_item.htm">Description of the illustration &#39;&#39;row_pattern_subset_item.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABGCICD"></a><a id="SQLRF56456"></a><a href="#BABGDJCE"><span class="xreftitleitalic"><span class="italic">row_pattern_definition_list</span></span></a>::=</p>
<img width="187" height="58" src="img/row_pattern_definition_list.gif" alt="Description of row_pattern_definition_list.gif follows"/><br/>
<a id="sthref7374" href="img_text/row_pattern_definition_list.htm">Description of the illustration &#39;&#39;row_pattern_definition_list.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF56457"></a><a href="#BABIHJAH"><span class="xreftitleitalic"><span class="italic">row_pattern_definition</span></span></a>::=</p>
<img width="232" height="27" src="img/row_pattern_definition.gif" alt="Description of row_pattern_definition.gif follows"/><br/>
<a id="sthref7375" href="img_text/row_pattern_definition.htm">Description of the illustration &#39;&#39;row_pattern_definition.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="SQLRF56508"></a><a href="#BABHGBCB"><span class="xreftitleitalic"><span class="italic">row_pattern_rec_func</span></span></a>::=</p>
<img width="228" height="123" src="img/row_pattern_rec_func.gif" alt="Description of row_pattern_rec_func.gif follows"/><br/>
<a id="sthref7376" href="img_text/row_pattern_rec_func.htm">Description of the illustration &#39;&#39;row_pattern_rec_func.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#BABEGGCJ"><span class="xreftitleitalic"><span class="italic">row_pattern_classifier_func</span>::=</span></a>, <a href="#BABBDBGI"><span class="xreftitleitalic"><span class="italic">row_pattern_match_num_func</span>::=</span></a>, <a href="#BABDHIEA"><span class="xreftitleitalic"><span class="italic">row_pattern_navigation_func</span>::=</span></a>, <a href="#BABBDCFA"><span class="xreftitleitalic"><span class="italic">row_pattern_aggregate_func</span>::=</span></a>)</p>
<p class="subhead2"><a id="BABEGGCJ"></a><a id="SQLRF56509"></a><a href="#BABBGAAB"><span class="xreftitleitalic"><span class="italic">row_pattern_classifier_func</span></span></a>::=</p>
<img width="169" height="27" src="img/row_pattern_classifier_func.gif" alt="Description of row_pattern_classifier_func.gif follows"/><br/>
<a id="sthref7377" href="img_text/row_pattern_classifier_func.htm">Description of the illustration &#39;&#39;row_pattern_classifier_func.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABBDBGI"></a><a id="SQLRF56510"></a><a href="#BABBEEBD"><span class="xreftitleitalic"><span class="italic">row_pattern_match_num_func</span></span></a>::=</p>
<img width="201" height="27" src="img/row_pattern_match_num_func.gif" alt="Description of row_pattern_match_num_func.gif follows"/><br/>
<a id="sthref7378" href="img_text/row_pattern_match_num_func.htm">Description of the illustration &#39;&#39;row_pattern_match_num_func.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABDHIEA"></a><a id="SQLRF56511"></a><a href="#BABGCIIA"><span class="xreftitleitalic"><span class="italic">row_pattern_navigation_func</span></span></a>::=</p>
<img width="220" height="91" src="img/row_pattern_navigation_func.gif" alt="Description of row_pattern_navigation_func.gif follows"/><br/>
<a id="sthref7379" href="img_text/row_pattern_navigation_func.htm">Description of the illustration &#39;&#39;row_pattern_navigation_func.gif&#39;&#39;</a><br/>
<br/>
<p>(<a href="#BABFDCHF"><span class="xreftitleitalic"><span class="italic">row_pattern_nav_logical</span>::=</span></a>, <a href="#BABGEACD"><span class="xreftitleitalic"><span class="italic">row_pattern_nav_physical</span>::=</span></a>, <a href="#BABCFIDG"><span class="xreftitleitalic"><span class="italic">row_pattern_nav_compound</span>::=</span></a>)</p>
<p class="subhead2"><a id="BABFDCHF"></a><a id="SQLRF56512"></a><a href="#BABHCBFE"><span class="xreftitleitalic"><span class="italic">row_pattern_nav_logical</span></span></a>::=</p>
<img width="503" height="95" src="img/row_pattern_nav_logical.gif" alt="Description of row_pattern_nav_logical.gif follows"/><br/>
<a id="sthref7380" href="img_text/row_pattern_nav_logical.htm">Description of the illustration &#39;&#39;row_pattern_nav_logical.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABGEACD"></a><a id="SQLRF56513"></a><a href="#BABFIFBC"><span class="xreftitleitalic"><span class="italic">row_pattern_nav_physical</span></span></a>::=</p>
<img width="345" height="64" src="img/row_pattern_nav_physical.gif" alt="Description of row_pattern_nav_physical.gif follows"/><br/>
<a id="sthref7381" href="img_text/row_pattern_nav_physical.htm">Description of the illustration &#39;&#39;row_pattern_nav_physical.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABCFIDG"></a><a id="SQLRF56514"></a><a href="#BABDHEAH"><span class="xreftitleitalic"><span class="italic">row_pattern_nav_compound</span></span></a>::=</p>
<img width="781" height="95" src="img/row_pattern_nav_compound.gif" alt="Description of row_pattern_nav_compound.gif follows"/><br/>
<a id="sthref7382" href="img_text/row_pattern_nav_compound.htm">Description of the illustration &#39;&#39;row_pattern_nav_compound.gif&#39;&#39;</a><br/>
<br/>
<p class="subhead2"><a id="BABBDCFA"></a><a id="SQLRF56515"></a><a href="#BABIDJGB"><span class="xreftitleitalic"><span class="italic">row_pattern_aggregate_func</span></span></a>::=</p>
<img width="300" height="79" src="img/row_pattern_aggregate_func.gif" alt="Description of row_pattern_aggregate_func.gif follows"/><br/>
<a id="sthref7383" href="img_text/row_pattern_aggregate_func.htm">Description of the illustration &#39;&#39;row_pattern_aggregate_func.gif&#39;&#39;</a><br/>
<br/></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="i2065806"></a>Semantics</p>
<p class="subhead1"><a id="BABCGAAJ"></a><a id="SQLRF55664"></a><span class="italic">with_clause</span><a id="sthref7384"></a></p>
<p>Use the <code dir="ltr"><span class="codeinlineitalic">with_clause</span></code> to define the following:</p>
<ul>
<li>
<p>PL/SQL procedures and functions (using the <code dir="ltr"><span class="codeinlineitalic">plsql_declarations</span></code> clause)</p>
</li>
<li>
<p>Subquery blocks (using the <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code>)</p>
</li>
</ul>
<p class="subhead1"><a id="BABJCBCC"></a><a id="SQLRF55665"></a><span class="italic">plsql_declarations</span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">plsql_declarations</span></code> clause lets you declare and define PL/SQL functions and procedures. You can then reference the PL/SQL functions in the query in which you specify this clause, as well as its subqueries, if any. For the purposes of name resolution, these function names have precedence over schema-level stored functions.</p>
<p>If the query in which you specify this clause is not a top-level <code dir="ltr">SELECT</code> statement, then the following rules apply to the top-level SQL statement that contains the query:</p>
<ul>
<li>
<p>If the top-level statement is a <code dir="ltr">SELECT</code> statement, then it must have either a <code dir="ltr">WITH</code> <code dir="ltr"><span class="codeinlineitalic">plsql_declarations</span></code> clause or the <code dir="ltr">WITH_PLSQL</code> hint.</p>
</li>
<li>
<p>If the top-level statement is a <code dir="ltr">DELETE</code>, <code dir="ltr">MERGE</code>, <code dir="ltr">INSERT</code>, or <code dir="ltr">UPDATE</code> statement, then it must have the <code dir="ltr">WITH_PLSQL</code> hint.</p>
</li>
</ul>
<p>The <code dir="ltr">WITH_PLSQL</code> hint only enables you to specify the <code dir="ltr">WITH</code> <code dir="ltr"><span class="codeinlineitalic">plsql_declarations</span></code> clause within the statement. It is not an optimizer hint.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><span class="italic">Oracle Database PL/SQL Language Reference</span> for syntax and restrictions for <a class="olink LNPLS01322" href="../LNPLS/function.htm#LNPLS01322"><code dir="ltr"><span class="codeinlineitalic">function_declaration</span></code></a> and <a class="olink LNPLS01336" href="../LNPLS/procedure.htm#LNPLS01336"><code dir="ltr"><span class="codeinlineitalic">procedure_declaration</span></code></a>.</p>
</li>
<li>
<p><a href="#BABJFIDC">&#34;Using a PL/SQL Function in the WITH Clause: Examples&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead1"><a id="i2077142"></a><a id="SQLRF30048"></a><span class="italic">subquery_factoring_clause<a id="sthref7385"></a></span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code> lets you assign a name (<code dir="ltr"><span class="codeinlineitalic">query_name</span></code>) to a subquery block. You can then reference the subquery block multiple places in the query by specifying <code dir="ltr"><span class="codeinlineitalic">query_name</span></code>. Oracle Database optimizes the query by treating the <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> as either an inline view or as a temporary table. The <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> is subject to the same naming conventions and restrictions as database schema objects. Refer to <a href="sql_elements008.htm#i27570">&#34;Database Object Naming Rules&#34;</a> for information on database object names.</p>
<p>The column aliases following the <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> and the set operators separating multiple subqueries in the <code dir="ltr">AS</code> clause are valid and required for recursive subquery factoring. The <code dir="ltr"><span class="codeinlineitalic">search_clause</span></code> and <code dir="ltr"><span class="codeinlineitalic">cycle_clause</span></code> are valid only for recursive subquery factoring but are not required. See <a href="#BCEJGIBG">&#34;Recursive Subquery Factoring&#34;</a>.</p>
<p>You can specify this clause in any top-level <code dir="ltr">SELECT</code> statement and in most types of subqueries. The query name is visible to the main query and to all subsequent subqueries. For recursive subquery factoring, the query name is even visible to the subquery that defines the query name itself.</p>
<p><a id="BCEJGIBG"></a><a id="SQLRF55268"></a><span class="subhead3"><a id="sthref7386"></a>Recursive Subquery Factoring&nbsp;</span>If a <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code> refers to its own <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> in the subquery that defines it, then the <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code> is said to be <span class="bold">recursive</span>. A recursive <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code> must contain two query blocks: the first is the <span class="bold">anchor member</span> and the second is the <span class="bold">recursive member</span>. The anchor member must appear before the recursive member, and it cannot reference <code dir="ltr"><span class="codeinlineitalic">query_name</span></code>. The anchor member can be composed of one or more query blocks combined by the set operators: <code dir="ltr">UNION</code> <code dir="ltr">ALL</code>, <code dir="ltr">UNION</code>, <code dir="ltr">INTERSECT</code> or <code dir="ltr">MINUS</code>. The recursive member must follow the anchor member and must reference <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> exactly once. You must combine the recursive member with the anchor member using the <code dir="ltr">UNION</code> <code dir="ltr">ALL</code> set operator.</p>
<p>The number of column aliases following <code dir="ltr">WITH</code> <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> and the number of columns in the <code dir="ltr">SELECT</code> lists of the anchor and recursive query blocks must be the same.</p>
<p>The recursive member cannot contain any of the following elements:</p>
<ul>
<li>
<p>The <code dir="ltr">DISTINCT</code> keyword or a <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause</p>
</li>
<li>
<p>The <code dir="ltr"><span class="codeinlineitalic">model_clause</span></code></p>
</li>
<li>
<p>An aggregate function. However, analytic functions are permitted in the select list.</p>
</li>
<li>
<p>Subqueries that refer to <code dir="ltr"><span class="codeinlineitalic">query_name</span></code>.</p>
</li>
<li>
<p>Outer joins that refer to <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> as the right table.</p>
</li>
</ul>
<p><a id="BCEDDGGE"></a><a id="SQLRF55269"></a><span class="subhead3"><span class="italic">search_clause</span> &nbsp;</span>Use the <code dir="ltr">SEARCH</code> clause to specify an ordering for the rows.</p>
<ul>
<li>
<p>Specify <code dir="ltr">BREADTH</code> <code dir="ltr">FIRST</code> <code dir="ltr">BY</code> if you want sibling rows returned before any child rows are returned.</p>
</li>
<li>
<p>Specify <code dir="ltr">DEPTH</code> <code dir="ltr">FIRST</code> <code dir="ltr">BY</code> if you want child rows returned before any siblings rows are returned.</p>
</li>
<li>
<p>Sibling rows are ordered by the columns listed after the <code dir="ltr">BY</code> keyword.</p>
</li>
<li>
<p>The <code dir="ltr"><span class="codeinlineitalic">c_alias</span></code> list following the <code dir="ltr">SEARCH</code> keyword must contain column names from the column alias list for <code dir="ltr"><span class="codeinlineitalic">query_name</span></code>.</p>
</li>
<li>
<p>The <code dir="ltr"><span class="codeinlineitalic">ordering_column</span></code> is automatically added to the column list for the query name. The query that selects from <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> can include an <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> on <code dir="ltr"><span class="codeinlineitalic">ordering_column</span></code> to return the rows in the order that was specified by the <code dir="ltr">SEARCH</code> clause.</p>
</li>
</ul>
<p><a id="BABFFJFD"></a><a id="SQLRF55575"></a><span class="subhead3"><span class="italic">cycle_clause</span>&nbsp;</span>Use the <code dir="ltr">CYCLE</code> clause to mark cycles in the recursion.</p>
<ul>
<li>
<p>The <code dir="ltr"><span class="codeinlineitalic">c_alias</span></code> list following the <code dir="ltr">CYCLE</code> keyword must contain column names from the column alias list for <code dir="ltr"><span class="codeinlineitalic">query_name</span></code>. Oracle Database uses these columns to detect a cycle.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">cycle_value</span></code> and <code dir="ltr"><span class="codeinlineitalic">no_cycle_value</span></code> should be character strings of length 1.</p>
</li>
<li>
<p>If a cycle is detected, then the cycle mark column specified by <code dir="ltr"><span class="codeinlineitalic">cycle_mark_c_alias</span></code> for the row causing the cycle is set to the value specified for <code dir="ltr"><span class="codeinlineitalic">cycle_value</span></code>. The recursion will then stop for this row. That is, it will not look for child rows for the offending row, but it will continue for other noncyclic rows.</p>
</li>
<li>
<p>If no cycles are found, then the cycle mark column is set to the default value specified for <code dir="ltr"><span class="codeinlineitalic">no_cycle_value</span></code>.</p>
</li>
<li>
<p>The cycle mark column is automatically added to the column list for the <code dir="ltr"><span class="codeinlineitalic">query_name</span></code>.</p>
</li>
<li>
<p>A row is considered to form a cycle if one of its ancestor rows has the same values for the cycle columns.</p>
</li>
</ul>
<p>If you omit the <code dir="ltr">CYCLE</code> clause, then the recursive <code dir="ltr">WITH</code> clause returns an error if cycles are discovered. In this case, a row forms a cycle if one of its ancestor rows has the same values for all the columns in the column alias list for <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> that are referenced in the <code dir="ltr">WHERE</code> clause of the recursive member.</p>
<p><a id="SQLRF55270"></a><span class="subhead3">Restrictions on Subquery Factoring&nbsp;</span>This clause is subject to the following restrictions:</p>
<ul>
<li>
<p>You can specify only one <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code> in a single SQL statement. Any <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> defined in the <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code> can be used in any subsequent named query block in the <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code>.</p>
</li>
<li>
<p>In a compound query with set operators, you cannot use the <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> for any of the component queries, but you can use the <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> in the <code dir="ltr">FROM</code> clause of any of the component queries.</p>
</li>
<li>
<p>You cannot specify duplicate names in the column alias list for <code dir="ltr"><span class="codeinlineitalic">query_name</span></code>.</p>
</li>
<li>
<p>The name used for the <code dir="ltr"><span class="codeinlineitalic">ordering_column</span></code> has to be different from the name used for <code dir="ltr"><span class="codeinlineitalic">cycle_mark_c_alias</span></code>.</p>
</li>
<li>
<p>The <code dir="ltr"><span class="codeinlineitalic">ordering_column</span></code> and cycle mark column names cannot already be in the column alias list for <code dir="ltr"><span class="codeinlineitalic">query_name</span></code>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT010" href="../CNCPT/tablecls.htm#CNCPT010"><span class="italic">Oracle Database Concepts</span></a> for information about inline views</p>
</li>
<li>
<p><a href="#i2129904">&#34;Subquery Factoring: Example&#34;</a></p>
</li>
<li>
<p><a href="#BABCDJDB">&#34;Recursive Subquery Factoring: Examples&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead1"><a id="SQLRF55271"></a><span class="italic">hint</span></p>
<p>Specify a comment that passes instructions to the optimizer on choosing an execution plan for the statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="sql_elements006.htm#i35922">&#34;Hints&#34;</a> for the syntax and description of hints</div>
<p class="subhead1"><a id="SQLRF55272"></a>DISTINCT | UNIQUE <a id="sthref7387"></a><a id="sthref7388"></a><a id="sthref7389"></a><a id="sthref7390"></a></p>
<p>Specify <code dir="ltr">DISTINCT</code> or <code dir="ltr">UNIQUE</code> if you want the database to return only one copy of each set of duplicate rows selected. These two keywords are synonymous. Duplicate rows are those with matching values for each expression in the select list.</p>
<p><a id="SQLRF55273"></a><span class="subhead3">Restrictions on DISTINCT and UNIQUE Queries&nbsp;</span>These types of queries are subject to the following restrictions:</p>
<ul>
<li>
<p>When you specify <code dir="ltr">DISTINCT</code> or <code dir="ltr">UNIQUE</code>, the total number of bytes in all select list expressions is limited to the size of a data block minus some overhead. This size is specified by the initialization parameter <code dir="ltr">DB_BLOCK_SIZE</code>.</p>
</li>
<li>
<p>You cannot specify <code dir="ltr">DISTINCT</code> if the <code dir="ltr"><span class="codeinlineitalic">select_list</span></code> contains LOB columns.</p>
</li>
</ul>
<p class="subhead1"><a id="SQLRF55274"></a>ALL <a id="sthref7391"></a></p>
<p>Specify <code dir="ltr">ALL</code> if you want the database to return all rows selected, including all copies of duplicates. The default is <code dir="ltr">ALL</code>.</p>
<p class="subhead1"><a id="i2080424"></a><a id="SQLRF55276"></a><span class="italic">select_list</span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">select_list</span></code> lets you specify the columns you want to retrieve from the database.</p>
<p class="subhead2"><a id="SQLRF55275"></a>* (all-column wildcard)</p>
<p><a id="sthref7392"></a><a id="sthref7393"></a><a id="sthref7394"></a>Specify the all-column wildcard (asterisk) to select all columns, excluding pseudocolumns and <code dir="ltr">INVISIBLE</code> columns, from all tables, views, or materialized views listed in the <code dir="ltr">FROM</code> clause. The columns are returned in the order indicated by the <code dir="ltr">COLUMN_ID</code> column of the <code dir="ltr">*_TAB_COLUMNS</code> data dictionary view for the table, view, or materialized view.</p>
<p>If you are selecting from a table rather than from a view or a materialized view, then columns that have been marked as <code dir="ltr">UNUSED</code> by the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">SET</code> <code dir="ltr">UNUSED</code> statement are not selected.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="statements_3001.htm#CJAHHIBI">ALTER TABLE</a>, <a href="#i2129937">&#34;Simple Query Examples&#34;</a>, and <a href="#i2130183">&#34;Selecting from the DUAL Table: Example&#34;</a></div>
<p class="subhead2"><a id="SQLRF55277"></a><span class="italic">query_name</span>.*</p>
<p>Specify <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> followed by a period and the asterisk to select all columns from the specified subquery block. For <code dir="ltr"><span class="codeinlineitalic">query_name</span></code>, specify a subquery block name already specified in the <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code>. You must have specified the <code dir="ltr"><span class="codeinlineitalic">subquery_factoring_clause</span></code> in order to specify <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> in the <code dir="ltr"><span class="codeinlineitalic">select_list</span></code>. If you specify <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> in the <code dir="ltr"><span class="codeinlineitalic">select_list</span></code>, then you also must specify <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> in the <code dir="ltr"><span class="codeinlineitalic">query_table_expression</span></code> (<code dir="ltr">FROM</code> clause).</p>
<p class="subhead2"><a id="SQLRF55278"></a><span class="italic">table.*</span> | <span class="italic">view.*</span> | <span class="italic">materialized view.*</span></p>
<p>Specify the object name followed by a period and the asterisk to select all columns from the specified table, view, or materialized view. Oracle Database returns a set of columns in the order in which the columns were specified when the object was created. A query that selects rows from two or more tables, views, or materialized views is a join.</p>
<p>You can use the schema qualifier to select from a table, view, or materialized view in a schema other than your own. If you omit <code dir="ltr"><span class="codeinlineitalic">schema</span></code>, then the database assumes the table, view, or materialized view is in your own schema.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="queries006.htm#i2054012">&#34;Joins&#34;</a></div>
<p class="subhead2"><a id="SQLRF57090"></a><span class="italic">t_alias</span>.*</p>
<p>Specify a correlation name (alias) followed by a period and the asterisk to select all columns from the object with that correlation name specified in the <code dir="ltr">FROM</code> clause of the same subquery. The object can be a table, view, materialized view, or subquery. Oracle Database returns a set of columns in the order in which the columns were specified when the object was created. A query that selects rows from two or more objects is a join.</p>
<p class="subhead2"><a id="SQLRF55279"></a><span class="italic">expr</span></p>
<p>Specify an expression representing the information you want to select. A column name in this list can be qualified with <code dir="ltr"><span class="codeinlineitalic">schema</span></code> only if the table, view, or materialized view containing the column is qualified with <code dir="ltr"><span class="codeinlineitalic">schema</span></code> in the <code dir="ltr">FROM</code> clause. If you specify a member method of an object type, then you must follow the method name with parentheses even if the method takes no arguments.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2130199">&#34;Selecting Sequence Values: Examples&#34;</a></div>
<p><a id="SQLRF55280"></a><span class="subhead3"><span class="italic">c_alias</span>&nbsp;</span>Specify an alias for the column expression. Oracle Database will use this alias in the column heading of the result set. The <code dir="ltr">AS</code> keyword is optional. The alias effectively renames the select list item for the duration of the query. The alias can be used in the <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code> but not other clauses in the query.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG080" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG080"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for information on using the <code dir="ltr"><span class="codeinlineitalic">expr</span></code> <code dir="ltr">AS</code> <code dir="ltr"><span class="codeinlineitalic">c_alias</span></code> syntax with the <code dir="ltr">UNION</code> <code dir="ltr">ALL</code> operator in queries of multiple materialized views</p>
</li>
<li>
<p><a href="expressions001.htm#i1002626">&#34;About SQL Expressions&#34;</a> for the syntax of <code dir="ltr"><span class="codeinlineitalic">expr</span></code></p>
</li>
</ul>
</div>
<p><a id="SQLRF55281"></a><span class="subhead3">Restrictions on the Select List&nbsp;</span>The select list is subject to the following restrictions:</p>
<ul>
<li>
<p>If you also specify a <a href="#i2182483"><span class="xreftitleitalic"><span class="italic">group_by_clause</span></span></a> in this statement, then this select list can contain only the following types of expressions:</p>
<ul>
<li>
<p>Constants</p>
</li>
<li>
<p>Aggregate functions and the functions <code dir="ltr">USER</code>, <code dir="ltr">UID</code>, and <code dir="ltr">SYSDATE</code></p>
</li>
<li>
<p>Expressions identical to those in the <code dir="ltr"><span class="codeinlineitalic">group_by_clause</span></code>. If the <code dir="ltr"><span class="codeinlineitalic">group_by_clause</span></code> is in a subquery, then all columns in the select list of the subquery must match the <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> columns in the subquery. If the select list and <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> columns of a top-level query or of a subquery do not match, then the statement results in ORA-00979.</p>
</li>
<li>
<p>Expressions involving the preceding expressions that evaluate to the same value for all rows in a group</p>
</li>
</ul>
</li>
<li>
<p>You can select a rowid from a join view only if the join has one and only one key-preserved table. The rowid of that table becomes the rowid of the view.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN020" href="../ADMIN/views.htm#ADMIN020"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for information on key-preserved tables</div>
</li>
<li>
<p>If two or more tables have some column names in common, and if you are specifying a join in the <code dir="ltr">FROM</code> clause, then you must qualify column names with names of tables or table aliases.</p>
</li>
</ul>
<p class="subhead1"><a id="SQLRF55282"></a>FROM Clause</p>
<p>The <code dir="ltr">FROM</code> clause lets you specify the objects from which data is selected.</p>
<p class="subhead2"><a id="i2076542"></a><a id="SQLRF55283"></a><span class="italic">query_table_expression</span></p>
<p>Use the <code dir="ltr"><span class="codeinlineitalic">query_table_expression</span></code> clause to identify a subquery block, table, view, materialized view, partition, or subpartition, or to specify a subquery that identifies the objects. In order to specify a subquery block, you must have specified the subquery block name (<code dir="ltr"><span class="codeinlineitalic">query_name</span></code>) in the subquery_factoring_clause.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2130078">&#34;Using Subqueries: Examples&#34;</a></div>
<p><a id="SQLRF55284"></a><span class="subhead3">ONLY&nbsp;</span>The <code dir="ltr">ONLY</code> clause applies only to views. Specify <code dir="ltr">ONLY</code> if the view in the <code dir="ltr">FROM</code> clause is a view belonging to a hierarchy and you do not want to include rows from any of its subviews.</p>
<p><a id="BABCJCAG"></a><a id="SQLRF55632"></a><span class="subhead3"><a id="sthref7395"></a><a id="sthref7396"></a>LATERAL&nbsp;</span>Specify <code dir="ltr">LATERAL</code> to designate <code dir="ltr"><span class="codeinlineitalic">subquery</span></code> as a lateral inline view. Within a lateral inline view, you can specify tables that appear to the left of the lateral inline view in the <code dir="ltr">FROM</code> clause of a query. You can specify this left correlation anywhere within <code dir="ltr"><span class="codeinlineitalic">subquery</span></code> (such as the <code dir="ltr">SELECT</code>, <code dir="ltr">FROM</code>, and <code dir="ltr">WHERE</code> clauses) and at any nesting level.</p>
<p><a id="SQLRF55633"></a><span class="subhead3">Restrictions on LATERAL:&nbsp;</span>Lateral inline views are subject to the following restrictions:</p>
<ul>
<li>
<p>If you specify <code dir="ltr">LATERAL</code>, then you cannot specify the <code dir="ltr"><span class="codeinlineitalic">pivot_clause</span></code>, the <code dir="ltr"><span class="codeinlineitalic">unpivot_clause</span></code>, or a pattern in the <code dir="ltr"><span class="codeinlineitalic">table_reference</span></code> clause.</p>
</li>
<li>
<p>If a lateral inline view contains the <code dir="ltr"><span class="codeinlineitalic">query_partition_clause</span></code>, and it is the right side of a join clause, then it cannot contain a left correlation to the left table in the join clause. However, it can contain a left correlation to a table to its left in the <code dir="ltr">FROM</code> clause that is not the left table.</p>
</li>
<li>
<p>A lateral inline view cannot contain a left correlation to the first table in a right outer join or full outer join.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABFDGIJ">&#34;Using Lateral Inline Views: Example&#34;</a></div>
<p class="subhead2"><a id="i2112818"></a><a id="SQLRF55285"></a><span class="italic">flashback_query_clause <a id="sthref7397"></a><a id="sthref7398"></a><a id="sthref7399"></a><a id="sthref7400"></a></span></p>
<p>Use the <code dir="ltr"><span class="codeinlineitalic">flashback_query_clause</span></code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data.</p>
<p>This clause implements SQL-driven Flashback, which lets you specify the following:</p>
<ul>
<li>
<p>A different system change number or timestamp for each object in the select list, using the clauses <code dir="ltr">VERSIONS</code> <code dir="ltr">BETWEEN</code> <code dir="ltr">{</code> <code dir="ltr">SCN</code> <code dir="ltr">|</code> <code dir="ltr">TIMESTAMP</code> <code dir="ltr">}</code> or <code dir="ltr">VERSIONS</code> <code dir="ltr">AS</code> <code dir="ltr">OF</code> <code dir="ltr">{</code> <code dir="ltr">SCN</code> <code dir="ltr">|</code> <code dir="ltr">TIMESTAMP</code> <code dir="ltr">}</code>. You can also implement session-level Flashback using the <code dir="ltr">DBMS_FLASHBACK</code> package.</p>
</li>
<li>
<p>A valid time period for each object in the select list, using the clauses <code dir="ltr">VERSIONS</code> <code dir="ltr">PERIOD</code> <code dir="ltr">FOR</code> or <code dir="ltr">AS</code> <code dir="ltr">OF</code> <code dir="ltr">PERIOD</code> <code dir="ltr">FOR</code>. You can also implement valid-time session-level Flashback using the <code dir="ltr">DBMS_FLASHBACK_ARCHIVE</code> package.</p>
</li>
</ul>
<p>A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code dir="ltr">VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code dir="ltr">FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID.</p>
<p><a id="SQLRF55287"></a><span class="subhead3">VERSIONS BETWEEN { SCN | TIMESTAMP }&nbsp;</span></p>
<p>Specify <code dir="ltr">VERSIONS</code> <code dir="ltr">BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows.</p>
<ul>
<li>
<p>Specify <code dir="ltr">VERSIONS</code> <code dir="ltr">BETWEEN</code> <code dir="ltr">SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code dir="ltr">MINVALUE</code> and <code dir="ltr">MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively.</p>
</li>
<li>
<p>Specify <code dir="ltr">VERSIONS</code> <code dir="ltr">BETWEEN</code> <code dir="ltr">TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code dir="ltr">MINVALUE</code> and <code dir="ltr">MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively.</p>
</li>
</ul>
<p><a id="SQLRF55286"></a><span class="subhead3">AS OF { SCN | TIMESTAMP }&nbsp;</span>Specify <code dir="ltr">AS</code> <code dir="ltr">OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code dir="ltr">SCN</code>, then <code dir="ltr"><span class="codeinlineitalic">expr</span></code> must evaluate to a number. If you specify <code dir="ltr">TIMESTAMP</code>, then <code dir="ltr"><span class="codeinlineitalic">expr</span></code> must evaluate to a timestamp value. In either case, <code dir="ltr"><span class="codeinlineitalic">expr</span></code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time.</p>
<p>Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to <a href="pseudocolumns003.htm#i1009358">&#34;Version Query Pseudocolumns&#34;</a> for more information.</p>
<p>When both clauses are used together, the <code dir="ltr">AS</code> <code dir="ltr">OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code dir="ltr">VERSIONS</code> clause determines the versions of the rows as seen from the <code dir="ltr">AS</code> <code dir="ltr">OF</code> point. The database returns null for a row version if the transaction started before the first <code dir="ltr">BETWEEN</code> value or ended after the <code dir="ltr">AS</code> <code dir="ltr">OF</code> point.</p>
<p><a id="SQLRF56458"></a><span class="subhead3">VERSIONS PERIOD FOR&nbsp;</span>Specify <code dir="ltr">VERSIONS</code> <code dir="ltr">PERIOD</code> <code dir="ltr">FOR</code> to retrieve rows from <code dir="ltr"><span class="codeinlineitalic">table</span></code> based on whether they are considered valid during the specified time period. In order to use this clause, <code dir="ltr"><span class="codeinlineitalic">table</span></code> must support Temporal Validity.</p>
<ul>
<li>
<p>For <code dir="ltr"><span class="codeinlineitalic">valid_time_column</span></code>, specify the name of the valid time dimension column for <code dir="ltr"><span class="codeinlineitalic">table</span></code>.</p>
</li>
<li>
<p>Use the <code dir="ltr">BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code dir="ltr">MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code dir="ltr"><span class="codeinlineitalic">table</span></code>. <code dir="ltr">MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code dir="ltr"><span class="codeinlineitalic">table</span></code>.</p>
</li>
</ul>
<p><a id="SQLRF56459"></a><span class="subhead3">AS OF PERIOD FOR&nbsp;</span>Specify <code dir="ltr">AS</code> <code dir="ltr">OF</code> <code dir="ltr">PERIOD</code> <code dir="ltr">FOR</code> to retrieve rows from <code dir="ltr"><span class="codeinlineitalic">table</span></code> based on whether they are considered valid as of the specified time. In order to use this clause, <code dir="ltr"><span class="codeinlineitalic">table</span></code> must support Temporal Validity.</p>
<ul>
<li>
<p>For <code dir="ltr"><span class="codeinlineitalic">valid_time_column</span></code>, specify the name of the valid time dimension column for <code dir="ltr"><span class="codeinlineitalic">table</span></code>.</p>
</li>
<li>
<p>Use <code dir="ltr"><span class="codeinlineitalic">expr</span></code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS967" href="../ADFNS/adfns_design.htm#ADFNS967"><span class="italic">Oracle Database Development Guide</span></a> for more information on Temporal Validity</p>
</li>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> <a href="statements_7002.htm#CJADHJHB"><span class="xreftitleitalic"><span class="italic">period_definition</span></span></a> to learn how to configure a table to support Temporal Validity and for information about the <code dir="ltr"><span class="codeinlineitalic">valid_time_column</span></code>, start time column, and end time column</p>
</li>
</ul>
</div>
<p><a id="SQLRF56392"></a><span class="subhead3">Note on Flashback Queries&nbsp;</span>When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query.</p>
<p><a id="SQLRF55288"></a><span class="subhead3">Restrictions on Flashback Queries&nbsp;</span>These queries are subject to the following restrictions:</p>
<ul>
<li>
<p>You cannot specify a column expression or a subquery in the expression of the <code dir="ltr">AS</code> <code dir="ltr">OF</code> clause.</p>
</li>
<li>
<p>You cannot specify the <code dir="ltr">AS</code> <code dir="ltr">OF</code> clause if you have specified the <code dir="ltr"><span class="codeinlineitalic">for_update_clause</span></code>.</p>
</li>
<li>
<p>You cannot use the <code dir="ltr">AS</code> <code dir="ltr">OF</code> clause in the defining query of a materialized view.</p>
</li>
<li>
<p>You cannot use the <code dir="ltr">VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster.</p>
</li>
<li>
<p>You cannot use the <code dir="ltr">VERSIONS</code> clause in flashback queries to views. However, you can use the <code dir="ltr">VERSIONS</code> syntax in the defining query of a view.</p>
</li>
<li>
<p>You cannot specify the <code dir="ltr"><span class="codeinlineitalic">flashback_query_clause</span></code> if you have specified <code dir="ltr"><span class="codeinlineitalic">query_name</span></code> in the <code dir="ltr"><span class="codeinlineitalic">query_table_expression</span></code>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS01003" href="../ADFNS/adfns_flashback.htm#ADFNS01003"><span class="italic">Oracle Database Development Guide</span></a> for more information on Oracle Flashback Query</p>
</li>
<li>
<p><a href="#i2112847">&#34;Using Flashback Queries: Example&#34;</a></p>
</li>
<li>
<p><a class="olink ADFNS01009" href="../ADFNS/adfns_flashback.htm#ADFNS01009"><span class="italic">Oracle Database Development Guide</span></a> and <a class="olink ARPLS142" href="../ARPLS/d_flashb.htm#ARPLS142"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about session-level Flashback using the <code dir="ltr">DBMS_FLASHBACK</code> package</p>
</li>
<li>
<p><a class="olink ADMIN01513" href="../ADMIN/tables.htm#ADMIN01513"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> and to the description of <a class="olink REFRN23379" href="../REFRN/GUID-630F4399-B3C8-45BA-8E4F-90D4E130C197.htm#REFRN23379"><code dir="ltr">FLASHBACK_TRANSACTION_QUERY</code></a> in the <span class="italic">Oracle Database Reference</span> for more information about transaction history</p>
</li>
</ul>
</div>
<p><a id="SQLRF55289"></a><span class="subhead3"><span class="italic">partition_extension_clause</span>&nbsp;</span>For <code dir="ltr">PARTITION</code> or <code dir="ltr">SUBPARTITION</code>, specify the name or key value of the partition or subpartition within <code dir="ltr"><span class="codeinlineitalic">table</span></code> from which you want to retrieve data.</p>
<p>For range- and list-partitioned data, as an alternative to this clause, you can specify a condition in the <code dir="ltr">WHERE</code> clause that restricts the retrieval to one or more partitions of <code dir="ltr"><span class="codeinlineitalic">table</span></code>. Oracle Database will interpret the condition and fetch data from only those partitions. It is not possible to formulate such a <code dir="ltr">WHERE</code> condition for hash-partitioned data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="sql_elements009.htm#i165979">&#34;References to Partitioned Tables and Indexes&#34;</a> and <a href="#i2105152">&#34;Selecting from a Partition: Example&#34;</a></div>
<p><a id="SQLRF55290"></a><span class="subhead3"><span class="italic">dblink</span>&nbsp;</span>For <code dir="ltr"><span class="codeinlineitalic">dblink</span></code>, specify the complete or partial name for a database link to a remote database where the table, view, or materialized view is located. This database need not be an Oracle Database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="sql_elements009.htm#i27761">&#34;References to Objects in Remote Databases&#34;</a> for more information on referring to database links</p>
</li>
<li>
<p><a href="queries010.htm#i2054175">&#34;Distributed Queries&#34;</a> for more information about distributed queries and <a href="#i2130133">&#34;Using Distributed Queries: Example&#34;</a></p>
</li>
</ul>
</div>
<p>If you omit <code dir="ltr"><span class="codeinlineitalic">dblink</span></code>, then the database assumes that the table, view, or materialized view is on the local database.</p>
<p><a id="SQLRF55291"></a><span class="subhead3">Restrictions on Database Links&nbsp;</span>Database links are subject to the following restrictions:</p>
<ul>
<li>
<p>You cannot query a user-defined type or an object <code dir="ltr">REF</code> on a remote table.</p>
</li>
<li>
<p>You cannot query columns of type <code dir="ltr">ANYTYPE</code>, <code dir="ltr">ANYDATA</code>, or <code dir="ltr">ANYDATASET</code> from remote tables.</p>
</li>
</ul>
<p><a id="SQLRF55292"></a><span class="subhead3"><span class="italic">table</span> | <span class="italic">view</span> | <span class="italic">materialized</span> <span class="italic">view</span>&nbsp;</span>Specify the name of a table, view, or materialized view from which data is selected.</p>
<p class="subhead2"><a id="i2065953"></a><a id="SQLRF55293"></a><span class="italic">sample_clause <a id="sthref7401"></a><a id="sthref7402"></a></span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">sample_clause</span></code> lets you instruct the database to select from a random sample of data from the table, rather than from the entire table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2105143">&#34;Selecting a Sample: Examples&#34;</a></div>
<p><a id="SQLRF55294"></a><span class="subhead3">BLOCK&nbsp;</span><code dir="ltr">BLOCK</code> instructs the database to attempt to perform random block sampling instead of random row sampling.</p>
<p>Block sampling is possible only during full table scans or index fast full scans. If a more efficient execution path exists, then Oracle Database does not perform block sampling. If you want to guarantee block sampling for a particular table or index, then use the <code dir="ltr">FULL</code> or <code dir="ltr">INDEX_FFS</code> hint.</p>
<p><a id="SQLRF55295"></a><span class="subhead3"><span class="italic">sample_percent</span>&nbsp;</span>For <code dir="ltr"><span class="codeinlineitalic">sample_percent</span></code>, specify the percentage of the total row or block count to be included in the sample. The value must be in the range .000001 to, but not including, 100. This percentage indicates the probability of each row, or each cluster of rows in the case of block sampling, being selected as part of the sample. It does not mean that the database will retrieve exactly <code dir="ltr"><span class="codeinlineitalic">sample_percent</span></code> of the rows of <code dir="ltr"><span class="codeinlineitalic">table</span></code>.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
<p class="warnsp">The use of statistically incorrect assumptions when using this feature can lead to incorrect or undesirable results.</p>
</div>
<p><a id="SQLRF55296"></a><span class="subhead3">SEED <span class="italic">seed_value</span>&nbsp;</span>Specify this clause to instruct the database to attempt to return the same sample from one execution to the next. The <code dir="ltr"><span class="codeinlineitalic">seed_value</span></code> must be an integer between 0 and 4294967295. If you omit this clause, then the resulting sample will change from one execution to the next.</p>
<p><a id="SQLRF55298"></a><span class="subhead3">Restrictions on <span class="italic">sample_clause</span>&nbsp;</span>The following restrictions apply to the <code dir="ltr">SAMPLE</code> clause:</p>
<ul>
<li>
<p>You cannot specify the <code dir="ltr">SAMPLE</code> clause in a subquery in a DML statement.</p>
</li>
<li>
<p>You can specify the <code dir="ltr">SAMPLE</code> clause in a query on a base table, a container table of a materialized view, or a view that is key preserving. You cannot specify this clause on a view that is not key preserving.</p>
</li>
</ul>
<p><a id="i2146468"></a><a id="SQLRF55299"></a><span class="subhead3"><span class="italic">subquery_restriction_clause</span>&nbsp;</span>The <code dir="ltr"><span class="codeinlineitalic">subquery_restriction_clause</span></code> lets you restrict the subquery in one of the following ways:</p>
<p><a id="SQLRF55300"></a><span class="subhead3">WITH READ ONLY&nbsp;</span>Specify <code dir="ltr">WITH READ ONLY</code> to indicate that the table or view cannot be updated.</p>
<p><a id="SQLRF55301"></a><span class="subhead3">WITH CHECK OPTION&nbsp;</span>Specify <code dir="ltr">WITH CHECK OPTION</code> to indicate that Oracle Database prohibits any changes to the table or view that would produce rows that are not included in the subquery. When used in the subquery of a DML statement, you can specify this clause in a subquery in the <code dir="ltr">FROM</code> clause but not in subquery in the <code dir="ltr">WHERE</code> clause.</p>
<p><a id="SQLRF55302"></a><span class="subhead3">CONSTRAINT <span class="italic">constraint</span>&nbsp;</span>Specify the name of the <code dir="ltr">CHECK OPTION</code> constraint. If you omit this identifier, then Oracle automatically assigns the constraint a name of the form <code dir="ltr">SYS_C</code><code dir="ltr"><span class="codeinlineitalic">n</span></code>, where n is an integer that makes the constraint name unique within the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2066598">&#34;Using the WITH CHECK OPTION Clause: Example&#34;</a></div>
<p class="subhead2"><a id="i2104990"></a><a id="SQLRF30047"></a><span class="italic">table_collection_expression <a id="sthref7403"></a><a id="sthref7404"></a><a id="sthref7405"></a><a id="sthref7406"></a><a id="sthref7407"></a><a id="sthref7408"></a><a id="sthref7409"></a></span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">table_collection_expression</span></code> lets you inform Oracle that the value of <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> should be treated as a table for purposes of query and DML operations. The <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value&mdash;that is, a value whose type is nested table or varray. This process of extracting the elements of a collection is called <span class="bold">collection unnesting</span>.</p>
<p>The optional plus (+) is relevant if you are joining the <code dir="ltr">TABLE</code> collection expression with the parent table. The + creates an outer join of the two, so that the query returns rows from the outer table even if the collection expression is null.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In earlier releases of Oracle, when <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> was a subquery, <code dir="ltr"><span class="codeinlineitalic">table_collection_expression</span></code> was expressed as <code dir="ltr">THE</code> <code dir="ltr"><span class="codeinlineitalic">subquery</span></code>. That usage is now deprecated.</div>
<p>The <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> can reference columns of tables defined to its left in the <code dir="ltr">FROM</code> clause. This is called <span class="bold">left correlation</span>. Left correlation can occur only in <code dir="ltr"><span class="codeinlineitalic">table_collection_expression</span></code>. Other subqueries cannot contains references to columns defined outside the subquery.</p>
<p><a id="sthref7410"></a>The optional <code dir="ltr">(+)</code> lets you specify that <code dir="ltr"><span class="codeinlineitalic">table_collection_expression</span></code> should return a row with all fields set to null if the collection is null or empty. The <code dir="ltr">(+)</code> is valid only if <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> uses left correlation. The result is similar to that of an outer join.</p>
<p>When you use the <code dir="ltr">(+)</code> syntax in the <code dir="ltr">WHERE</code> clause of a subquery in an <code dir="ltr">UPDATE</code> or <code dir="ltr">DELETE</code> operation, you must specify two tables in the <code dir="ltr">FROM</code> clause of the subquery. Oracle Database ignores the outer join syntax unless there is a join in the subquery itself.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="queries006.htm#i2054062">&#34;Outer Joins&#34;</a></p>
</li>
<li>
<p><a href="#i2071643">&#34;Table Collections: Examples&#34;</a> and <a href="#i2071637">&#34;Collection Unnesting: Examples&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead2"><a id="SQLRF55303"></a><span class="italic">t_alias <a id="sthref7411"></a><a id="sthref7412"></a></span></p>
<p>Specify a <span class="bold">correlation name</span>, which is an alias for the table, view, materialized view, or subquery for evaluating the query. This alias is required if the select list references any object type attributes or object type methods. Correlation names are most often used in a correlated query. Other references to the table, view, or materialized view throughout the query must refer to this alias.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2066912">&#34;Using Correlated Subqueries: Examples&#34;</a></div>
<p class="subhead2"><a id="CHDFAFIE"></a><a id="SQLRF55304"></a><span class="italic">pivot_clause</span> <a id="sthref7413"></a><a id="sthref7414"></a><a id="sthref7415"></a></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">pivot_clause</span></code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code dir="ltr"><span class="codeinlineitalic">pivot_clause</span></code> performs the following steps:</p>
<ol>
<li>
<p>The <code dir="ltr"><span class="codeinlineitalic">pivot_clause</span></code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause to return multiple values, yet the <code dir="ltr"><span class="codeinlineitalic">pivot_clause</span></code> does not contain an explicit <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause. Instead, the <code dir="ltr"><span class="codeinlineitalic">pivot_clause</span></code> performs an implicit <code dir="ltr">GROUP</code> <code dir="ltr">BY</code>. The implicit grouping is based on all the columns not referred to in the <code dir="ltr"><span class="codeinlineitalic">pivot_clause</span></code>, along with the set of values specified in the <code dir="ltr"><span class="codeinlineitalic">pivot_in_clause</span></code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions.</p>
</li>
<li>
<p>The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output:</p>
<ol>
<li>
<p>All the implicit grouping columns not referred to in the <code dir="ltr"><span class="codeinlineitalic">pivot_clause</span></code>, followed by</p>
</li>
<li>
<p>New columns corresponding to values in the <code dir="ltr"><span class="codeinlineitalic">pivot_in_clause</span></code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code dir="ltr">XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both.</p>
</li>
</ol>
</li>
</ol>
<p>The subclauses of the <code dir="ltr"><span class="codeinlineitalic">pivot_clause</span></code> have the following semantics:</p>
<p><a id="SQLRF55305"></a><span class="subhead3">XML&nbsp;</span>The optional <code dir="ltr">XML</code> keyword generates XML output for the query. The <code dir="ltr">XML</code> keyword permits the <code dir="ltr"><span class="codeinlineitalic">pivot_in_clause</span></code> to contain either a subquery or the wildcard keyword <code dir="ltr">ANY</code>. Subqueries and <code dir="ltr">ANY</code> wildcards are useful when the <code dir="ltr"><span class="codeinlineitalic">pivot_in_clause</span></code> values are not known in advance. With XML output, the values of the pivot column are evaluated at execution time. You cannot specify <code dir="ltr">XML</code> when you specify explicit pivot values using expressions in the <code dir="ltr"><span class="codeinlineitalic">pivot_in_clause</span></code>.</p>
<p>When XML output is generated, the aggregate function is applied to each distinct pivot value, and the database returns a column of <code dir="ltr">XMLType</code> containing an XML string for all value and measure pairs.</p>
<p><a id="SQLRF55306"></a><span class="subhead3"><span class="italic">expr</span>&nbsp;</span>For <code dir="ltr"><span class="codeinlineitalic">expr</span></code>, specify an expression that evaluates to a constant value of a pivot column. You can optionally provide an alias for each pivot column value. If there is no alias, the column heading becomes a quoted identifier.</p>
<p><a id="CHDEDGHG"></a><a id="SQLRF55307"></a><span class="subhead3"><span class="italic">subquery</span>&nbsp;</span>A subquery is used only in conjunction with the <code dir="ltr">XML</code> keyword. When you specify a subquery, all values found by the subquery are used for pivoting. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code dir="ltr"><span class="codeinlineitalic">pivot_in_clause</span></code>, the subquery produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> value of that row. The XML string for each output row includes all pivot values found by the subquery, even if there are no corresponding rows in the input data.</p>
<p>The subquery must return a list of unique values at the execution time of the pivot query. If the subquery does not return a unique value, then Oracle Database raises a run-time error. Use the <code dir="ltr">DISTINCT</code> keyword in the subquery if you are not sure the query will return unique values.</p>
<p><a id="CHDBDIGG"></a><a id="SQLRF55308"></a><span class="subhead3">ANY&nbsp;</span>The <code dir="ltr">ANY</code> keyword is used only in conjunction with the <code dir="ltr">XML</code> keyword. The <code dir="ltr">ANY</code> keyword acts as a wildcard and is similar in effect to <code dir="ltr"><span class="codeinlineitalic">subquery</span></code>. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code dir="ltr"><span class="codeinlineitalic">pivot_in_clause</span></code>, the <code dir="ltr">ANY</code> keyword produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> value of that row. However, in contrast to the behavior when you specify <code dir="ltr"><span class="codeinlineitalic">subquery</span></code>, the <code dir="ltr">ANY</code> wildcard produces an XML string for each output row that includes only the pivot values found in the input data corresponding to that row.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG0209" href="../DWHSG/analysis.htm#DWHSG0209"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information about <code dir="ltr">PIVOT</code> and <code dir="ltr">UNPIVOT</code> and <a href="#CHDFIIDD">&#34;Using PIVOT and UNPIVOT: Examples&#34;</a></div>
<p class="subhead2"><a id="CHDIBEFI"></a><a id="SQLRF55309"></a><span class="italic">unpivot_clause</span> <a id="sthref7416"></a><a id="sthref7417"></a><a id="sthref7418"></a></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">unpivot_clause</span></code> rotates columns into rows.</p>
<ul>
<li>
<p>The <code dir="ltr">INCLUDE</code> | <code dir="ltr">EXCLUDE</code> <code dir="ltr">NULLS</code> clause gives you the option of including or excluding null-valued rows. <code dir="ltr">INCLUDE</code> <code dir="ltr">NULLS</code> causes the unpivot operation to include null-valued rows; <code dir="ltr">EXCLUDE</code> <code dir="ltr">NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls.</p>
</li>
<li>
<p>For <code dir="ltr"><span class="codeinlineitalic">column</span></code>, specify a name for each output column that will hold measure values, such as <code dir="ltr">sales_quantity</code>.</p>
</li>
<li>
<p>In the <code dir="ltr"><span class="codeinlineitalic">pivot_for_clause</span></code>, specify a name for each output column that will hold descriptor values, such as quarter or product.</p>
</li>
<li>
<p>In the <code dir="ltr"><span class="codeinlineitalic">unpivot_in_clause</span></code>, specify the input data columns whose names will become values in the output columns of the <code dir="ltr"><span class="codeinlineitalic">pivot_for_clause</span></code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code dir="ltr">AS</code> clause lets you map the input data column names to the specified <code dir="ltr"><span class="codeinlineitalic">literal</span></code> values in the output columns.</p>
</li>
</ul>
<p>The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character.</p>
<ul>
<li>
<p>If all the value columns are <code dir="ltr">CHAR</code>, then the unpivoted column is <code dir="ltr">CHAR</code>. If any value column is <code dir="ltr">VARCHAR2</code>, then the unpivoted column is <code dir="ltr">VARCHAR2</code>.</p>
</li>
<li>
<p>If all the value columns are <code dir="ltr">NUMBER</code>, then the unpivoted column is <code dir="ltr">NUMBER</code>. If any value column is <code dir="ltr">BINARY_DOUBLE</code>, then the unpivoted column is <code dir="ltr">BINARY_DOUBLE</code>. If no value column is <code dir="ltr">BINARY_DOUBLE</code> but any value column is <code dir="ltr">BINARY_FLOAT</code>, then the unpivoted column is <code dir="ltr">BINARY_FLOAT</code>.</p>
</li>
</ul>
<p class="subhead2"><a id="BCEJBBIH"></a><a id="SQLRF56898"></a><span class="italic">containers_clause</span></p>
<p>The <code dir="ltr">CONTAINERS</code> clause is useful in a multitenant container database (CDB). This clause lets you query data in the specified table or view across all containers in a CDB.</p>
<p>In order to issue this clause, you must be a common user connected to the root, the table or view must exist in the root and in all PDBs, and the table or view must be in your own schema. It is not necessary to specify <code dir="ltr"><span class="codeinlineitalic">schema</span></code>, but if you do then you must specify your own schema.</p>
<p>The query returns all rows from the table or view in the root and in all open PDBs, except PDBs that are open in <code dir="ltr">RESTRICTED</code> mode. If the queried table or view does not already contain a <code dir="ltr">CON_ID</code> column, then the query adds a <code dir="ltr">CON_ID</code> column to the query result, which identifies the container whose data a given row represents.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN14319" href="../ADMIN/cdb_mon.htm#ADMIN14319"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information on the <code dir="ltr">CONTAINERS</code> clause</div>
<p class="subhead2"><a id="i2080416"></a><a id="SQLRF55310"></a><span class="italic">join_clause <a id="sthref7419"></a><a id="sthref7420"></a></span></p>
<p>Use the appropriate <code dir="ltr"><span class="codeinlineitalic">join_clause</span></code> syntax to identify tables that are part of a join from which to select data. The <code dir="ltr"><span class="codeinlineitalic">inner_cross_join_clause</span></code> lets you specify an inner or cross join. The <code dir="ltr"><span class="codeinlineitalic">outer_join_clause</span></code> lets you specify an outer join. The <code dir="ltr"><span class="codeinlineitalic">cross_outer_apply_clause</span></code> lets you specify a variation of an ANSI <code dir="ltr">CROSS</code> <code dir="ltr">JOIN</code> or an ANSI <code dir="ltr">LEFT</code> <code dir="ltr">OUTER</code> <code dir="ltr">JOIN</code> with left correlation support.</p>
<p>When you join more than two row sources, you can use parentheses to override default precedence. For example, the following syntax:</p>
<pre dir="ltr">SELECT ... FROM a JOIN (b JOIN c) ...
</pre>
<p>results in a join of <code dir="ltr">b</code> and <code dir="ltr">c</code>, and then a join of that result set with <code dir="ltr">a</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="queries006.htm#i2054012">&#34;Joins&#34;</a> for more information on joins, <a href="#i2066611">&#34;Using Join Queries: Examples&#34;</a>, <a href="#i2066652">&#34;Using Self Joins: Example&#34;</a>, and <a href="#i2107296">&#34;Using Outer Joins: Examples&#34;</a></div>
<p class="subhead2"><a id="BABHEICD"></a><a id="SQLRF55311"></a><span class="italic">inner_cross_join_clause</span></p>
<p>Inner joins return only those rows that satisfy the join condition.</p>
<p><a id="SQLRF55312"></a><span class="subhead3">INNER&nbsp;</span>Specify <code dir="ltr">INNER</code> to explicitly specify an inner join.</p>
<p><a id="SQLRF55313"></a><span class="subhead3">JOIN&nbsp;</span>The <code dir="ltr">JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code dir="ltr">WHERE</code> clause joins with <code dir="ltr">FROM</code> clause join syntax.</p>
<p><a id="SQLRF55314"></a><span class="subhead3">ON <span class="italic">condition</span>&nbsp;</span>Use the <code dir="ltr">ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code dir="ltr">WHERE</code> clause.</p>
<p><a id="SQLRF55315"></a><span class="subhead3">USING (<span class="italic">column</span>)&nbsp;</span>When you are specifying an equijoin of columns that have the same name in both tables, the <code dir="ltr">USING</code> <code dir="ltr"><span class="codeinlineitalic">column</span></code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias.</p>
<p><a id="SQLRF55316"></a><span class="subhead3">CROSS <a id="sthref7421"></a><a id="sthref7422"></a>&nbsp;</span>The <code dir="ltr">CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation.</p>
<p><a id="SQLRF56413"></a><span class="subhead3">NATURAL&nbsp;</span>The <code dir="ltr">NATURAL</code> keyword indicates that a natural join is being performed. Refer to <a href="#BABHGCAE">NATURAL</a> for the full semantics of this clause.</p>
<p class="subhead2"><a id="BABJCIFA"></a><a id="SQLRF55317"></a><span class="italic">outer_join_clause</span></p>
<p>Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code dir="ltr"><span class="codeinlineitalic">table_reference</span></code> syntax on both sides of the join, or a partitioned outer join using the <code dir="ltr"><span class="codeinlineitalic">query_partition_clause</span></code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called <span class="bold">data densification</span>.</p>
<p><a id="i2196190"></a><a id="SQLRF55319"></a><span class="subhead3"><span class="italic">query_partition_clause</span>&nbsp;</span>The <code dir="ltr"><span class="codeinlineitalic">query_partition_clause</span></code> lets you define a <span class="bold">partitioned outer join</span>. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> clause. The rows in each query partition have same value for the <code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> expression.</p>
<p>The <code dir="ltr"><span class="codeinlineitalic">query_partition_clause</span></code> can be on either side of the outer join. The result of a partitioned outer join is a <code dir="ltr">UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations.</p>
<p>If you omit this clause, then the database treats the entire table expression&mdash;everything specified in <code dir="ltr"><span class="codeinlineitalic">table_reference</span></code>&mdash;as a single partition, resulting in a conventional outer join.</p>
<p>To use the <code dir="ltr"><span class="codeinlineitalic">query_partition_clause</span></code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code dir="ltr"><span class="codeinlineitalic">model_column_clauses</span></code>) or a partitioned outer join (in the <code dir="ltr"><span class="codeinlineitalic">outer_join_clause</span></code>), use the lower branch of the syntax (with parentheses).</p>
<p><a id="SQLRF55320"></a><span class="subhead3">Restrictions on Partitioned Outer Joins&nbsp;</span>Partitioned outer joins are subject to the following restrictions:</p>
<ul>
<li>
<p>You can specify the <code dir="ltr"><span class="codeinlineitalic">query_partition_clause</span></code> on either the right or left side of the join, but not both.</p>
</li>
<li>
<p>You cannot specify a <code dir="ltr">FULL</code> partitioned outer join.</p>
</li>
<li>
<p>If you specify the <code dir="ltr"><span class="codeinlineitalic">query_partition_clause</span></code> in an outer join with an <code dir="ltr">ON</code> clause, then you cannot specify a subquery in the <code dir="ltr">ON</code> condition.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2177515">&#34;Using Partitioned Outer Joins: Examples&#34;</a></div>
<p><a id="BABHGCAE"></a><a id="SQLRF55325"></a><span class="subhead3">NATURAL<a id="sthref7423"></a><a id="sthref7424"></a>&nbsp;</span>The <code dir="ltr">NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias.</p>
<p>On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:</p>
<pre dir="ltr">   a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1
</pre>
<p>This example can be interpreted in either of the following ways:</p>
<pre dir="ltr">   a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) 
   (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1
</pre>
<p>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right.</p>
<p><a id="SQLRF55326"></a><span class="subhead3">Restriction on Natural Joins&nbsp;</span>You cannot specify a LOB column, columns of <code dir="ltr">ANYTYPE</code>, <code dir="ltr">ANYDATA</code>, or <code dir="ltr">ANYDATASET</code>, or a collection column as part of a natural join.</p>
<p><a id="i2192732"></a><a id="SQLRF55318"></a><span class="subhead3"><span class="italic">outer_join_type<a id="sthref7425"></a><a id="sthref7426"></a><a id="sthref7427"></a><a id="sthref7428"></a><a id="sthref7429"></a><a id="sthref7430"></a><a id="sthref7431"></a><a id="sthref7432"></a></span>&nbsp;</span>The <code dir="ltr"><span class="codeinlineitalic">outer_join_type</span></code> indicates the kind of outer join being performed:</p>
<ul>
<li>
<p>Specify <code dir="ltr">RIGHT</code> to indicate a right outer join.</p>
</li>
<li>
<p>Specify <code dir="ltr">LEFT</code> to indicate a left outer join.</p>
</li>
<li>
<p>Specify <code dir="ltr">FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls.</p>
</li>
<li>
<p>You can specify the optional <code dir="ltr">OUTER</code> keyword following <code dir="ltr">RIGHT</code>, <code dir="ltr">LEFT</code>, or <code dir="ltr">FULL</code> to explicitly clarify that an outer join is being performed.</p>
</li>
</ul>
<p><a id="SQLRF55321"></a><span class="subhead3">ON <span class="italic">condition</span>&nbsp;</span>Use the <code dir="ltr">ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code dir="ltr">WHERE</code> clause.</p>
<p><a id="SQLRF55322"></a><span class="subhead3">Restriction on the ON <span class="italic">condition</span> Clause&nbsp;</span>You cannot specify this clause with a <code dir="ltr">NATURAL</code> outer join.</p>
<p><a id="SQLRF55323"></a><span class="subhead3">USING <span class="italic">column</span>&nbsp;</span>In an outer join with the <code dir="ltr">USING</code> clause, the query returns a single column which is a coalesce of the two matching columns in the join. The coalesce functions as follows:</p>
<pre dir="ltr">COALESCE (a, b) = a if a NOT NULL, else b.
</pre>
<p>Therefore:</p>
<ul>
<li>
<p>A left outer join returns all the common column values from the left table in the <code dir="ltr">FROM</code> clause.</p>
</li>
<li>
<p>A right outer join returns all the common column values from the right table in the <code dir="ltr">FROM</code> clause.</p>
</li>
<li>
<p>A full outer join returns all the common column values from both joined tables.</p>
</li>
</ul>
<p><a id="SQLRF55324"></a><span class="subhead3">Restriction on the USING <span class="italic">column</span> Clause&nbsp;</span>The <code dir="ltr">USING</code> <code dir="ltr"><span class="codeinlineitalic">column</span></code> clause is subject to the following restrictions:</p>
<ul>
<li>
<p>Within this clause, do not qualify the column name with a table name or table alias.</p>
</li>
<li>
<p>You cannot specify a LOB column or a collection column in the <code dir="ltr">USING</code> <code dir="ltr"><span class="codeinlineitalic">column</span></code> clause.</p>
</li>
<li>
<p>You cannot specify this clause with a <code dir="ltr">NATURAL</code> outer join.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="queries006.htm#i2054062">&#34;Outer Joins&#34;</a> for additional rules and restrictions pertaining to outer joins</p>
</li>
<li>
<p><a class="olink DWHSG02013" href="../DWHSG/analysis.htm#DWHSG02013"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for a complete discussion of partitioned outer joins and data densification</p>
</li>
<li>
<p><a href="#i2107296">&#34;Using Outer Joins: Examples&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead2"><a id="BABCHEAJ"></a><a id="SQLRF56414"></a><span class="italic">cross_outer_apply_clause</span></p>
<p>This clause allows you to perform a variation of an ANSI <code dir="ltr">CROSS</code> <code dir="ltr">JOIN</code> or an ANSI <code dir="ltr">LEFT</code> <code dir="ltr">OUTER</code> <code dir="ltr">JOIN</code> with left correlation support. You can specify a <code dir="ltr"><span class="codeinlineitalic">table_reference</span></code> or <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> to the right of the <code dir="ltr">APPLY</code> keyword. The <code dir="ltr"><span class="codeinlineitalic">table_reference</span></code> can be a table, inline view, or <code dir="ltr">TABLE</code> collection expression. The <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value&mdash;that is, a value whose type is nested table or varray. The <code dir="ltr"><span class="codeinlineitalic">table_reference</span></code> or <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> can reference columns of tables defined in the <code dir="ltr">FROM</code> clause to the left of the <code dir="ltr">APPLY</code> keyword. This is called left correlation.</p>
<ul>
<li>
<p>Specify <code dir="ltr">CROSS</code> <code dir="ltr">APPLY</code> to perform a variation of an ANSI <code dir="ltr">CROSS</code> <code dir="ltr">JOIN</code>. Only rows from the table on the left side of the join that produce a result set from <code dir="ltr"><span class="codeinlineitalic">table_reference</span></code> or <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> are returned.</p>
</li>
<li>
<p>Specify <code dir="ltr">OUTER</code> <code dir="ltr">APPLY</code> to perform a variation of an ANSI <code dir="ltr">LEFT</code> <code dir="ltr">OUTER</code> <code dir="ltr">JOIN</code>. All rows from the table on the left side of the join are returned. Rows that do not produce a result set from <code dir="ltr"><span class="codeinlineitalic">table_reference</span></code> or <code dir="ltr"><span class="codeinlineitalic">collection_expression</span></code> have the NULL value in the corresponding column(s).</p>
</li>
</ul>
<p><a id="SQLRF56415"></a><span class="subhead3">Restriction on the <span class="italic">cross_outer_apply_clause</span>&nbsp;</span>The <code dir="ltr"><span class="codeinlineitalic">table_reference</span></code> cannot be a lateral inline view.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABDADCJ">Using CROSS APPLY and OUTER APPLY Joins: Examples</a></div>
<p class="subhead1"><a id="i2134734"></a><a id="SQLRF55327"></a><span class="italic">where_clause<a id="sthref7433"></a></span></p>
<p>The <code dir="ltr">WHERE</code> condition lets you restrict the rows selected to those that satisfy one or more conditions. For <code dir="ltr"><span class="codeinlineitalic">condition</span></code>, specify any valid SQL condition.</p>
<p>If you omit this clause, then the database returns all rows from the tables, views, or materialized views in the <code dir="ltr">FROM</code> clause.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If this clause refers to a <code dir="ltr">DATE</code> column of a partitioned table or index, then the database performs partition pruning only if:
<ul>
<li>
<p>You created the table or index partitions by fully specifying the year using the <code dir="ltr">TO_DATE</code> function with a 4-digit format mask, <span class="italic">and</span></p>
</li>
<li>
<p>You specify the date in the <code dir="ltr"><span class="codeinlineitalic">where_clause</span></code> of the query using the <code dir="ltr">TO_DATE</code> function and either a 2- or 4-digit format mask.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="conditions.htm#g1077361">Chapter 6, &#34;Conditions&#34;</a> for the syntax description of <code dir="ltr"><span class="codeinlineitalic">condition</span></code></p>
</li>
<li>
<p><a href="#i2105152">&#34;Selecting from a Partition: Example&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead1"><a id="i2066102"></a><a id="SQLRF55328"></a><span class="italic">hierarchical_query_clause <a id="sthref7434"></a><a id="sthref7435"></a><a id="sthref7436"></a></span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">hierarchical_query_clause</span></code> lets you select rows in a hierarchical order.</p>
<p><code dir="ltr">SELECT</code> statements that contain hierarchical queries can contain the <code dir="ltr">LEVEL</code> pseudocolumn in the select list. <code dir="ltr">LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory.</p>
<p>Oracle processes hierarchical queries as follows:</p>
<ul>
<li>
<p>A join, if present, is evaluated first, whether the join is specified in the <code dir="ltr">FROM</code> clause or with <code dir="ltr">WHERE</code> clause predicates.</p>
</li>
<li>
<p>The <code dir="ltr">CONNECT</code> <code dir="ltr">BY</code> condition is evaluated.</p>
</li>
<li>
<p>Any remaining <code dir="ltr">WHERE</code> clause predicates are evaluated.</p>
</li>
</ul>
<p>If you specify this clause, then do not specify either <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> or <code dir="ltr">GROUP</code> <code dir="ltr">BY</code>, because they will destroy the hierarchical order of the <code dir="ltr">CONNECT</code> <code dir="ltr">BY</code> results. If you want to order rows of siblings of the same parent, then use the <code dir="ltr">ORDER</code> <code dir="ltr">SIBLINGS</code> <code dir="ltr">BY</code> clause.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="queries003.htm#i2053935">&#34;Hierarchical Queries&#34;</a> for a discussion of hierarchical queries and <a href="#i2130122">&#34;Using the LEVEL Pseudocolumn: Examples&#34;</a></div>
<p class="subhead2"><a id="SQLRF55329"></a>START WITH Clause <span class="italic"><a id="sthref7437"></a></span></p>
<p>Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code dir="ltr"><span class="codeinlineitalic">condition</span></code> can be any condition as described in <a href="conditions.htm#g1077361">Chapter 6, &#34;Conditions&#34;</a>. Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows.</p>
<p class="subhead2"><a id="SQLRF55330"></a>CONNECT BY Clause <span class="italic"><a id="sthref7438"></a></span></p>
<p>Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code dir="ltr"><span class="codeinlineitalic">condition</span></code> can be any condition as described in <a href="conditions.htm#g1077361">Chapter 6, &#34;Conditions&#34;</a>. However, it must use the <code dir="ltr">PRIOR</code> operator to refer to the parent row.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pseudocolumns.htm#g1020307">Chapter 3, &#34;Pseudocolumns&#34;</a> for more information on <code dir="ltr">LEVEL</code></p>
</li>
<li>
<p><a href="queries003.htm#i2053935">&#34;Hierarchical Queries&#34;</a> for general information on hierarchical queries</p>
</li>
<li>
<p><a href="#i2130004">&#34;Hierarchical Query Examples&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead1"><a id="i2182483"></a><a id="SQLRF20038"></a><span class="italic">group_by_clause <a id="sthref7439"></a><a id="sthref7440"></a></span></p>
<p>Specify the <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause if you want the database to group the selected rows based on the value of <code dir="ltr"><span class="codeinlineitalic">expr</span></code>(s) for each row and return a single row of summary information for each group. If this clause contains <code dir="ltr">CUBE</code> or <code dir="ltr">ROLLUP</code> extensions, then the database produces superaggregate groupings in addition to the regular groupings.</p>
<p>Expressions in the <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause can contain any columns of the tables, views, or materialized views in the <code dir="ltr">FROM</code> clause, regardless of whether the columns appear in the select list.</p>
<p>The <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause groups rows but does not guarantee the order of the result set. To order the groupings, use the <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause.</p>
<p>If the <code dir="ltr">NLS_SORT</code> parameter has a setting other than <code dir="ltr">BINARY</code> and the <code dir="ltr">NLS_COMP</code> parameter is set to <code dir="ltr">LINGUISTIC</code>, then expression values are compared linguistically according to the linguistic definition specified in <code dir="ltr">NLS_SORT</code> to decide if they are equal and therefore belong to the same group. When character values are compared linguistically for <code dir="ltr">GROUP</code> <code dir="ltr">BY</code>, they are first transformed to collation keys and then compared like <code dir="ltr">RAW</code> values. The collation keys are the same values that are returned by the function <code dir="ltr">NLSSORT</code> and are subject to the same restrictions that are described in <a href="functions125.htm#i78399">&#34;NLSSORT&#34;</a>. As a result of these restrictions, two values may compare as linguistically equal and be grouped together if they do not differ in the prefix that was used to produce the collation key, even if they differ in the rest of the value.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink DWHSG020" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG020"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for an expanded discussion and examples of using SQL grouping syntax for data aggregation</p>
</li>
<li>
<p>the <a href="functions079.htm#i1002035">GROUP_ID</a>, <a href="functions080.htm#i77498">GROUPING</a>, and <a href="functions081.htm#i1001964">GROUPING_ID</a> functions for examples</p>
</li>
<li>
<p><a href="#i2066419">&#34;Using the GROUP BY Clause: Examples&#34;</a></p>
</li>
</ul>
</div>
<p><a id="SQLRF55331"></a><span class="subhead3">ROLLUP <a id="sthref7441"></a><a id="sthref7442"></a><a id="sthref7443"></a>&nbsp;</span>The <code dir="ltr">ROLLUP</code> operation in the <code dir="ltr"><span class="codeinlineitalic">simple_grouping_clause</span></code> groups the selected rows based on the values of the first n, n-1, n-2, ... 0 expressions in the <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> specification, and returns a single row of summary for each group. You can use the <code dir="ltr">ROLLUP</code> operation to produce <span class="bold">subtotal values</span> by using it with the <code dir="ltr">SUM</code> function. When used with <code dir="ltr">SUM</code>, <code dir="ltr">ROLLUP</code> generates subtotals from the most detailed level to the grand total. Aggregate functions such as <code dir="ltr">COUNT</code> can be used to produce other kinds of superaggregates.</p>
<p>For example, given three expressions (n=3) in the <code dir="ltr">ROLLUP</code> clause of the <code dir="ltr"><span class="codeinlineitalic">simple_grouping_clause</span></code>, the operation results in n+1 = 3+1 = 4 groupings.</p>
<p>Rows grouped on the values of the first <code dir="ltr"><span class="codeinlineitalic">n</span></code> expressions are called <span class="bold">regular rows</span>, and the others are called <span class="bold">superaggregate rows</span>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG021" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG021"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for information on using <code dir="ltr">ROLLUP</code> with materialized views</div>
<p><a id="SQLRF55332"></a><span class="subhead3">CUBE <a id="sthref7444"></a><a id="sthref7445"></a>&nbsp;</span>The <code dir="ltr">CUBE</code> operation in the <code dir="ltr"><span class="codeinlineitalic">simple_grouping_clause</span></code> groups the selected rows based on the values of all possible combinations of expressions in the specification. It returns a single row of summary information for each group. You can use the <code dir="ltr">CUBE</code> operation to produce <span class="bold">cross-tabulation values</span>.</p>
<p>For example, given three expressions (n=3) in the <code dir="ltr">CUBE</code> clause of the <code dir="ltr"><span class="codeinlineitalic">simple_grouping_clause</span></code>, the operation results in 2<sup>n</sup> = 2<sup>3</sup> = 8 groupings. Rows grouped on the values of <code dir="ltr"><span class="codeinlineitalic">n</span></code> expressions are called <span class="bold">regular rows</span>, and the rest are called <span class="bold">superaggregate rows</span>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG021" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG021"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for information on using <code dir="ltr">CUBE</code> with materialized views</p>
</li>
<li>
<p><a href="#i2066443">&#34;Using the GROUP BY CUBE Clause: Example&#34;</a></p>
</li>
</ul>
</div>
<p><a id="SQLRF55333"></a><span class="subhead3">GROUPING SETS<a id="sthref7446"></a><a id="sthref7447"></a><a id="sthref7448"></a>&nbsp;</span><code dir="ltr">GROUPING</code> <code dir="ltr">SETS</code> are a further extension of the <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause that let you specify multiple groupings of data. Doing so facilitates efficient aggregation by pruning the aggregates you do not need. You specify just the desired groups, and the database does not need to perform the full set of aggregations generated by <code dir="ltr">CUBE</code> or <code dir="ltr">ROLLUP</code>. Oracle Database computes all groupings specified in the <code dir="ltr">GROUPING</code> <code dir="ltr">SETS</code> clause and combines the results of individual groupings with a <code dir="ltr">UNION</code> <code dir="ltr">ALL</code> operation. The <code dir="ltr">UNION</code> <code dir="ltr">ALL</code> means that the result set can include duplicate rows.</p>
<p><a id="sthref7449"></a><a id="sthref7450"></a>Within the <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause, you can combine expressions in various ways:</p>
<ul>
<li>
<p>To specify <span class="bold">composite columns</span>, group columns within parentheses so that the database treats them as a unit while computing <code dir="ltr">ROLLUP</code> or <code dir="ltr">CUBE</code> operations.</p>
</li>
<li>
<p>To specify <span class="bold">concatenated grouping sets</span>, separate multiple grouping sets, <code dir="ltr">ROLLUP</code>, and <code dir="ltr">CUBE</code> operations with commas so that the database combines them into a single <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause. The result is a cross-product of groupings from each grouping set.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2091446">&#34;Using the GROUPING SETS Clause: Example&#34;</a></div>
<p class="subhead2"><a id="i2078943"></a><a id="SQLRF20040"></a>HAVING Clause <a id="sthref7451"></a></p>
<p>Use the <code dir="ltr">HAVING</code> clause to restrict the groups of returned rows to those groups for which the specified <code dir="ltr"><span class="codeinlineitalic">condition</span></code> is <code dir="ltr">TRUE</code>. If you omit this clause, then the database returns summary rows for all groups.</p>
<p>Specify <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> and <code dir="ltr">HAVING</code> after the <code dir="ltr"><span class="codeinlineitalic">where_clause</span></code> and <code dir="ltr"><span class="codeinlineitalic">hierarchical_query_clause</span></code>. If you specify both <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> and <code dir="ltr">HAVING</code>, then they can appear in either order.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2130020">&#34;Using the HAVING Condition: Example&#34;</a></div>
<p><a id="SQLRF55334"></a><span class="subhead3">Restrictions on the GROUP BY Clause:&nbsp;</span>This clause is subject to the following restrictions:</p>
<ul>
<li>
<p>You cannot specify LOB columns, nested tables, or varrays as part of <code dir="ltr"><span class="codeinlineitalic">expr</span></code>.</p>
</li>
<li>
<p>The expressions can be of any form except scalar subquery expressions.</p>
</li>
<li>
<p>If the <code dir="ltr"><span class="codeinlineitalic">group_by_clause</span></code> references any object type columns, then the query will not be parallelized.</p>
</li>
</ul>
<p class="subhead1"><a id="i2172805"></a><a id="SQLRF55335"></a><span class="italic">model_clause <a id="sthref7452"></a></span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">model_clause</span></code> lets you view selected rows as a multidimensional array and randomly access cells within that array. Using the <code dir="ltr"><span class="codeinlineitalic">model_clause</span></code>, you can specify a series of cell assignments, referred to as <span class="bold">rules</span>, that invoke calculations on individual cells and ranges of cells. These rules operate on the results of a query and do not update any database tables.</p>
<p>When using the <code dir="ltr"><span class="codeinlineitalic">model_clause</span></code> in a query, the <code dir="ltr">SELECT</code> and <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clauses must refer only to those columns defined in the <code dir="ltr"><span class="codeinlineitalic">model_column_clauses</span></code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>The syntax description of <code dir="ltr"><span class="codeinlineitalic">expr</span></code> in <a href="expressions001.htm#i1002626">&#34;About SQL Expressions&#34;</a> and the syntax description of <code dir="ltr"><span class="codeinlineitalic">condition</span></code> in <a href="conditions.htm#g1077361">Chapter 6, &#34;Conditions&#34;</a></p>
</li>
<li>
<p><a class="olink DWHSG022" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG022"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for an expanded discussion and examples</p>
</li>
<li>
<p><a href="#i2171160">&#34;The MODEL clause: Examples&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead1"><a id="i2168646"></a><a id="SQLRF55336"></a><span class="italic">main_model</span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">main_model</span></code> clause defines how the selected rows will be viewed in a multidimensional array and what rules will operate on which cells in that array.</p>
<p class="subhead2"><a id="i2168561"></a><a id="SQLRF55337"></a><span class="italic">model_column_clauses</span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">model_column_clauses</span></code> define and classify the columns of a query into three groups: partition columns, dimension columns, and measure columns. For <code dir="ltr"><span class="codeinlineitalic">expr</span></code>, you can specify a column, constant, host variable, single-row function, aggregate function, or any expression involving them. If <code dir="ltr"><span class="codeinlineitalic">expr</span></code> is a column, then the column alias (<code dir="ltr"><span class="codeinlineitalic">c_alias</span></code>) is optional. If <code dir="ltr"><span class="codeinlineitalic">expr</span></code> is not a column, then the column alias is required. If you specify a column alias, then you must use the alias to refer to the column in the <code dir="ltr"><span class="codeinlineitalic">model_rules_clause</span></code>, <code dir="ltr">SELECT</code> list, and the query <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clauses.</p>
<p><a id="SQLRF55338"></a><span class="subhead3">PARTITION BY&nbsp;</span>The <code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> clause specifies the columns that will be used to divide the selected rows into partitions based on the values of the specified columns.</p>
<p><a id="SQLRF55339"></a><span class="subhead3">DIMENSION BY&nbsp;</span>The <code dir="ltr">DIMENSION</code> <code dir="ltr">BY</code> clause specifies the columns that will identify a row within a partition. The values of the dimension columns, along with those of the partition columns, serve as array indexes to the measure columns within a row.</p>
<p><a id="SQLRF55340"></a><span class="subhead3">MEASURES&nbsp;</span>The <code dir="ltr">MEASURES</code> clause identifies the columns on which the calculations can be performed. Measure columns in individual rows are treated like cells that you can reference, by specifying the values for the partition and dimension columns, and update.</p>
<p class="subhead2"><a id="i2168572"></a><a id="SQLRF55342"></a><span class="italic">cell_reference_options</span></p>
<p>Use the <code dir="ltr"><span class="codeinlineitalic">cell_reference_options</span></code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained.</p>
<p><a id="SQLRF55343"></a><span class="subhead3">IGNORE NAV&nbsp;</span>When you specify <code dir="ltr">IGNORE</code> <code dir="ltr">NAV</code>, the database returns the following values for the null and absent values of the data type specified:</p>
<ul>
<li>
<p>Zero for numeric data types</p>
</li>
<li>
<p>01-JAN-2000 for datetime data types</p>
</li>
<li>
<p>An empty string for character data types</p>
</li>
<li>
<p>Null for all other data types</p>
</li>
</ul>
<p><a id="SQLRF55344"></a><span class="subhead3">KEEP NAV&nbsp;</span>When you specify <code dir="ltr">KEEP</code> <code dir="ltr">NAV</code>, the database returns null for both null and absent cell values. <code dir="ltr">KEEP</code> <code dir="ltr">NAV</code> is the default.</p>
<p><a id="SQLRF55345"></a><span class="subhead3">UNIQUE SINGLE REFERENCE&nbsp;</span>When you specify <code dir="ltr">UNIQUE</code> <code dir="ltr">SINGLE</code> <code dir="ltr">REFERENCE</code>, the database checks only single-cell references on the right-hand side of the rule for uniqueness, not the entire query result set.</p>
<p><a id="SQLRF55346"></a><span class="subhead3">UNIQUE DIMENSION&nbsp;</span>When you specify <code dir="ltr">UNIQUE</code> <code dir="ltr">DIMENSION</code>, the database checks that the <code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> and <code dir="ltr">DIMENSION</code> <code dir="ltr">BY</code> columns form a unique key to the query. <code dir="ltr">UNIQUE</code> <code dir="ltr">DIMENSION</code> is the default.</p>
<p class="subhead2"><a id="i2191799"></a><a id="SQLRF55347"></a><span class="italic">model_rules_clause</span></p>
<p>Use the <code dir="ltr"><span class="codeinlineitalic">model_rules_clause</span></code> to specify the cells to be updated, the rules for updating those cells, and optionally, how the rules are to be applied and processed.</p>
<p>Each rule represents an assignment and consists of a left-hand side and right-hand side. The left-hand side of the rule identifies the cells to be updated by the right-hand side of the rule. The right-hand side of the rule evaluates to the values to be assigned to the cells specified on the left-hand side of the rule.</p>
<p><a id="SQLRF55348"></a><span class="subhead3">UPSERT ALL&nbsp;</span><code dir="ltr">UPSERT</code> <code dir="ltr">ALL</code> allows <code dir="ltr">UPSERT</code> behavior for a rule with both positional and symbolic references on the left-hand side of the rule. When evaluating an <code dir="ltr">UPSERT</code> <code dir="ltr">ALL</code> rule, Oracle performs the following steps to create a list of cell references to be upserted:</p>
<ol>
<li>
<p>Find the existing cells that satisfy all the symbolic predicates of the cell reference.</p>
</li>
<li>
<p>Using just the dimensions that have symbolic references, find the distinct dimension value combinations of these cells.</p>
</li>
<li>
<p>Perform a cross product of these value combinations with the dimension values specified by way of positional references.</p>
</li>
</ol>
<p>Refer to <a class="olink DWHSG0222" href="../DWHSG/sqlmodel.htm#DWHSG0222"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on the semantics of <code dir="ltr">UPSERT</code> <code dir="ltr">ALL</code>.</p>
<p><a id="i2168592"></a><a id="SQLRF55349"></a><span class="subhead3">UPSERT&nbsp;</span>When you specify <code dir="ltr">UPSERT</code>, the database applies the rules to those cells referenced on the left-hand side of the rule that exist in the multidimensional array, and inserts new rows for those that do not exist. <code dir="ltr">UPSERT</code> behavior applies only when positional referencing is used on the left-hand side and a single cell is referenced. <code dir="ltr">UPSERT</code> is the default. Refer to <a href="#i2168603"><span class="xreftitleitalic"><span class="italic">cell_assignment</span></span></a> for more information on positional referencing and single-cell references.</p>
<p><code dir="ltr">UPDATE</code> and <code dir="ltr">UPSERT</code> can be specified for individual rules as well. When either <code dir="ltr">UPDATE</code> or <code dir="ltr">UPSERT</code> is specified for a specific rule, it takes precedence over the option specified in the <code dir="ltr">RULES</code> clause.</p>
<div class="infobox-note">
<p class="notep1">Notes on UPSERT [ALL] and UPDATE:</p>
If an <code dir="ltr">UPSERT</code> <code dir="ltr">ALL</code>, <code dir="ltr">UPSERT</code>, or <code dir="ltr">UPDATE</code> rule does not contain the appropriate predicates, then the database may implicitly convert it to a different type of rule:
<ul>
<li>
<p>If an <code dir="ltr">UPSERT</code> rule contains an existential predicate, then the rule is treated as an <code dir="ltr">UPDATE</code> rule.</p>
</li>
<li>
<p>An <code dir="ltr">UPSERT</code> <code dir="ltr">ALL</code> rule must have at least one existential predicate and one qualified predicate on its left side. If it has no existential predicate, then it is treated as an <code dir="ltr">UPSERT</code> rule. If it has no qualified predicate, then it is treated as an <code dir="ltr">UPDATE</code> rule</p>
</li>
</ul>
</div>
<p><a id="i2168589"></a><a id="SQLRF55350"></a><span class="subhead3">UPDATE&nbsp;</span>When you specify <code dir="ltr">UPDATE</code>, the database applies the rules to those cells referenced on the left-hand side of the rule that exist in the multidimensional array. If the cells do not exist, then the assignment is ignored.</p>
<p><a id="SQLRF55351"></a><span class="subhead3">AUTOMATIC ORDER&nbsp;</span>When you specify <code dir="ltr">AUTOMATIC</code> <code dir="ltr">ORDER</code>, the database evaluates the rules based on their dependency order. In this case, a cell can be assigned a value once only.</p>
<p><a id="SQLRF55352"></a><span class="subhead3">SEQUENTIAL ORDER&nbsp;</span>When you specify <code dir="ltr">SEQUENTIAL</code> <code dir="ltr">ORDER</code>, the database evaluates the rules in the order they appear. In this case, a cell can be assigned a value more than once. <code dir="ltr">SEQUENTIAL</code> <code dir="ltr">ORDER</code> is the default.</p>
<p><a id="SQLRF55353"></a><span class="subhead3">ITERATE ... [UNTIL]&nbsp;</span>Use <code dir="ltr">ITERATE</code> ... [<code dir="ltr">UNTIL</code>] to specify the number of times to cycle through the rules and, optionally, an early termination condition. The parentheses around the <code dir="ltr">UNTIL</code> condition are optional.</p>
<p>When you specify <code dir="ltr">ITERATE</code> ... [<code dir="ltr">UNTIL</code>], rules are evaluated in the order in which they appear. Oracle Database returns an error if both <code dir="ltr">AUTOMATIC</code> <code dir="ltr">ORDER</code> and <code dir="ltr">ITERATE</code> ... <code dir="ltr">[UNTIL]</code> are specified in the <code dir="ltr"><span class="codeinlineitalic">model_rules_clause</span></code>.</p>
<p class="subhead2"><a id="i2168603"></a><a id="SQLRF55354"></a><span class="italic">cell_assignment</span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">cell_assignment</span></code> clause, which is the left-hand side of the rule, specifies one or more cells to be updated. When a <code dir="ltr"><span class="codeinlineitalic">cell_assignment</span></code> references a single cell, it is called a <span class="bold">single-cell reference</span>. When more than one cell is referenced, it is called a <span class="bold">multiple-cell reference</span>.</p>
<p>All dimension columns defined in the <code dir="ltr"><span class="codeinlineitalic">model_clause</span></code> must be qualified in the <code dir="ltr"><span class="codeinlineitalic">cell_assignment</span></code> clause. A dimension can be qualified using either symbolic or positional referencing.</p>
<p>A <span class="bold">symbolic reference</span> qualifies a single dimension column using a Boolean condition like <code dir="ltr"><span class="codeinlineitalic">dimension_column</span></code><code dir="ltr">=</code><code dir="ltr"><span class="codeinlineitalic">constant</span></code>. A <span class="bold">positional reference</span> is one where the dimension column is implied by its position in the <code dir="ltr">DIMENSION</code> <code dir="ltr">BY</code> clause. The only difference between symbolic references and positional references is in the treatment of nulls.</p>
<p>Using a single-cell symbolic reference such as <code dir="ltr">a[x=null,y=2000]</code>, no cells qualify because <code dir="ltr">x=null</code> evaluates to <code dir="ltr">FALSE</code>. However, using a single-cell positional reference such as <code dir="ltr">a[null,2000]</code>, a cell where <code dir="ltr">x</code> is null and <code dir="ltr">y</code> is 2000 qualifies because null = null evaluates to <code dir="ltr">TRUE</code>. With single-cell positional referencing, you can reference, update, and insert cells where dimension columns are null.</p>
<p>You can specify a condition or an expression representing a dimension column value using either symbolic or positional referencing. <code dir="ltr"><span class="codeinlineitalic">condition</span></code> cannot contain aggregate functions or the <code dir="ltr">CV</code> function, and <code dir="ltr"><span class="codeinlineitalic">condition</span></code> must reference a single dimension column. <code dir="ltr"><span class="codeinlineitalic">expr</span></code> cannot contain a subquery. Refer to <a href="expressions011.htm#i1049969">&#34;Model Expressions&#34;</a> for information on model expressions.</p>
<p class="subhead2"><a id="i2182160"></a><a id="SQLRF55355"></a><span class="italic">single_column_for_loop</span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">single_column_for_loop</span></code> clause lets you specify a range of cells to be updated within a single dimension column.</p>
<p>The <code dir="ltr">IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code dir="ltr"><span class="codeinlineitalic">subquery</span></code>, it cannot:</p>
<ul>
<li>
<p>Be a correlated query</p>
</li>
<li>
<p>Return more than 10,000 rows</p>
</li>
<li>
<p>Be a query defined in the <code dir="ltr">WITH</code> clause</p>
</li>
</ul>
<p>The <code dir="ltr">FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code dir="ltr">FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code dir="ltr">INCREMENT</code> and <code dir="ltr">DECREMENT</code> values must be positive.</p>
<p>Optionally, you can specify the <code dir="ltr">LIKE</code> clause within the <code dir="ltr">FROM</code> clause. In the <code dir="ltr">LIKE</code> clause, <code dir="ltr"><span class="codeinlineitalic">pattern</span></code> is a character string containing a single pattern-matching character <code dir="ltr">%</code>. This character is replaced during execution with the current incremented or decremented value in the <code dir="ltr">FROM</code> clause.</p>
<p>If all dimensions other than those used by a <code dir="ltr">FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code dir="ltr">FOR</code> loops is counted as part of the 10,000 row limit of the <code dir="ltr">MODEL</code> clause.</p>
<p class="subhead2"><a id="i2168616"></a><a id="SQLRF55356"></a><span class="italic">multi_column_for_loop</span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">multi_column_for_loop</span></code> clause lets you specify a range of cells to be updated across multiple dimension columns. The <code dir="ltr">IN</code> clause lets you specify the values of the dimension columns as either multiple lists of values or as a subquery. When using <code dir="ltr"><span class="codeinlineitalic">subquery</span></code>, it cannot:</p>
<ul>
<li>
<p>Be a correlated query</p>
</li>
<li>
<p>Return more than 10,000 rows</p>
</li>
<li>
<p>Be a query defined in the <code dir="ltr">WITH</code> clause</p>
</li>
</ul>
<p>If all dimensions other than those used by a <code dir="ltr">FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code dir="ltr">FOR</code> loops is counted as part of the 10,000 row limit of the <code dir="ltr">MODEL</code> clause.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG0223" href="../DWHSG/sqlmodel.htm#DWHSG0223"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information about using <code dir="ltr">FOR</code> loops in the <code dir="ltr">MODEL</code> clause</div>
<p class="subhead2"><a id="SQLRF55357"></a><span class="italic">order_by_clause</span></p>
<p>Use the <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause to specify the order in which cells on the left-hand side of the rule are to be evaluated. The <code dir="ltr"><span class="codeinlineitalic">expr</span></code> must resolve to a dimension or measure column. If the <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause is not specified, then the order defaults to the order of the columns as specified in the <code dir="ltr">DIMENSION</code> <code dir="ltr">BY</code> clause. See <a href="#i2171079"><span class="xreftitleitalic"><span class="italic">order_by_clause</span></span></a> for more information.</p>
<p><a id="SQLRF55358"></a><span class="subhead3">Restrictions on the <span class="italic">order_by_clause</span>&nbsp;</span>Use of the <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause in the model rule is subject to the following restrictions:</p>
<ul>
<li>
<p>You cannot specify <code dir="ltr">SIBLINGS</code>, <code dir="ltr"><span class="codeinlineitalic">position</span></code>, or <code dir="ltr"><span class="codeinlineitalic">c_alias</span></code> in the <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code> of the <code dir="ltr"><span class="codeinlineitalic">model_clause</span></code>.</p>
</li>
<li>
<p>You cannot specify this clause on the left-hand side of the model rule and also specify a <code dir="ltr">FOR</code> loop on the right-hand side of the rule.</p>
</li>
</ul>
<p class="subhead2"><a id="SQLRF55359"></a><span class="italic">expr</span></p>
<p>Specify an expression representing the value or values of the cell or cells specified on the right-hand side of the rule. <code dir="ltr"><span class="codeinlineitalic">expr</span></code> cannot contain a subquery. Refer to <a href="expressions011.htm#i1049969">&#34;Model Expressions&#34;</a> for information on model expressions.</p>
<p class="subhead1"><a id="i2171017"></a><a id="SQLRF55360"></a><span class="italic">return_rows_clause</span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">return_rows_clause</span></code> lets you specify whether to return all rows selected or only those rows updated by the model rules. <code dir="ltr">ALL</code> is the default.</p>
<p class="subhead1"><a id="i2161156"></a><a id="SQLRF55361"></a><span class="italic">reference_model</span></p>
<p>Use the <code dir="ltr"><span class="codeinlineitalic">reference_model</span></code> clause when you need to access multiple arrays from inside the <code dir="ltr"><span class="codeinlineitalic">model_clause</span></code>. This clause defines a read-only multidimensional array based on the results of a query.</p>
<p>The subclauses of the <code dir="ltr"><span class="codeinlineitalic">reference_model</span></code> clause have the same semantics as for the <code dir="ltr"><span class="codeinlineitalic">main_model</span></code> clause. Refer to <a href="#i2168561"><span class="xreftitleitalic"><span class="italic">model_column_clauses</span></span></a> and <a href="#i2168572"><span class="xreftitleitalic"><span class="italic">cell_reference_options</span></span></a>.</p>
<p><a id="SQLRF55362"></a><span class="subhead3">Restrictions on the <span class="italic">reference_model</span> clause&nbsp;</span>This clause is subject to the following restrictions:</p>
<ul>
<li>
<p><code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> columns cannot be specified for reference models.</p>
</li>
<li>
<p>The subquery of the reference model cannot refer to columns in an outer subquery.</p>
</li>
</ul>
<p class="subhead1"><a id="SQLRF55363"></a>Set Operators: UNION, UNION ALL, INTERSECT, MINUS <code dir="ltr"><a id="sthref7453"></a><a id="sthref7454"></a><a id="sthref7455"></a><a id="sthref7456"></a><a id="sthref7457"></a><a id="sthref7458"></a></code></p>
<p>The set operators combine the rows returned by two <code dir="ltr">SELECT</code> statements into a single result. The number and data types of the columns selected by each component query must be the same, but the column lengths can be different. The names of the columns in the result set are the names of the expressions in the select list preceding the set operator.</p>
<p>If you combine more than two queries with set operators, then the database evaluates adjacent queries from left to right. The parentheses around the subquery are optional. You can use them to specify a different order of evaluation.</p>
<p>Refer to <a href="queries004.htm#i2054381">&#34;The UNION [ALL], INTERSECT, MINUS Operators&#34;</a> for information on these operators, including restrictions on their use.</p>
<p class="subhead1"><a id="i2171079"></a><a id="SQLRF20039"></a><span class="italic">order_by_clause <a id="sthref7459"></a><a id="sthref7460"></a></span></p>
<p>Use the <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause to order rows returned by the statement. Without an <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order.</p>
<p><a id="SQLRF55364"></a><span class="subhead3">SIBLINGS<a id="sthref7461"></a><a id="sthref7462"></a><a id="sthref7463"></a><a id="sthref7464"></a>&nbsp;</span>The <code dir="ltr">SIBLINGS</code> keyword is valid only if you also specify the <code dir="ltr"><span class="codeinlineitalic">hierarchical_query_clause</span></code> (<code dir="ltr">CONNECT</code> <code dir="ltr">BY</code>). <code dir="ltr">ORDER</code> <code dir="ltr">SIBLINGS</code> <code dir="ltr">BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code> to the siblings of the hierarchy.</p>
<p><a id="SQLRF55365"></a><span class="subhead3"><span class="italic">expr</span>&nbsp;</span><code dir="ltr"><span class="codeinlineitalic">expr</span></code> orders rows based on their value for <code dir="ltr"><span class="codeinlineitalic">expr</span></code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code dir="ltr">FROM</code> clause.</p>
<p><a id="SQLRF55366"></a><span class="subhead3"><span class="italic">position</span>&nbsp;</span>Specify <code dir="ltr"><span class="codeinlineitalic">position</span></code> to order rows based on their value for the expression in this position of the select list. The <code dir="ltr"><span class="codeinlineitalic">position</span></code> value must be an integer.</p>
<p>You can specify multiple expressions in the <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to <a href="queries005.htm#i2053998">&#34;Sorting Query Results&#34;</a> for a discussion of ordering query results.</p>
<p><a id="SQLRF55367"></a><span class="subhead3">ASC | DESC&nbsp;</span>Specify whether the ordering sequence is ascending or descending. <code dir="ltr">ASC</code> is the default.</p>
<p><a id="SQLRF55368"></a><span class="subhead3">NULLS FIRST | NULLS LAST&nbsp;</span>Specify whether returned rows containing null values should appear first or last in the ordering sequence.</p>
<p><code dir="ltr">NULLS</code> <code dir="ltr">LAST</code> is the default for ascending order, and <code dir="ltr">NULLS</code> <code dir="ltr">FIRST</code> is the default for descending order.</p>
<p><a id="SQLRF55369"></a><span class="subhead3">Restrictions on the ORDER BY Clause&nbsp;</span>The following restrictions apply to the <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause:</p>
<ul>
<li>
<p>If you have specified the <code dir="ltr">DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list.</p>
</li>
<li>
<p>An <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code> can contain no more than 255 expressions.</p>
</li>
<li>
<p>You cannot order by a LOB, <code dir="ltr">LONG</code>, or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> column, nested table, or varray.</p>
</li>
<li>
<p>If you specify a <a href="#i2182483"><span class="xreftitleitalic"><span class="italic">group_by_clause</span></span></a> in the same statement, then this <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code> is restricted to the following expressions:</p>
<ul>
<li>
<p>Constants</p>
</li>
<li>
<p>Aggregate functions</p>
</li>
<li>
<p>Analytic functions</p>
</li>
<li>
<p>The functions <code dir="ltr">USER</code>, <code dir="ltr">UID</code>, and <code dir="ltr">SYSDATE</code></p>
</li>
<li>
<p>Expressions identical to those in the <code dir="ltr"><span class="codeinlineitalic">group_by_clause</span></code></p>
</li>
<li>
<p>Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2130036">&#34;Using the ORDER BY Clause: Examples&#34;</a></div>
<p class="subhead1"><a id="BABHFGAA"></a><a id="SQLRF55636"></a><span class="italic"><a id="sthref7465"></a><a id="sthref7466"></a><a id="sthref7467"></a>row_limiting_clause</span></p>
<p>The <code dir="ltr"><span class="codeinlineitalic">row_limiting_clause</span></code> allows you to limit the rows returned by the query. You can specify an offset, and the number of rows or percentage of rows to return. You can use this clause to implement top-N reporting. For consistent results, specify the <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code> to ensure a deterministic sort order.</p>
<p class="subhead2"><a id="SQLRF55637"></a>OFFSET</p>
<p>Use this clause to specify the number of rows to skip before row limiting begins. <code dir="ltr"><span class="codeinlineitalic">offset</span></code> must be a number or an expression that evaluates to a numeric value. If you specify a negative number, then <code dir="ltr"><span class="codeinlineitalic">offset</span></code> is treated as 0. If you specify NULL, or a number greater than or equal to the number of rows returned by the query, then 0 rows are returned. If <code dir="ltr"><span class="codeinlineitalic">offset</span></code> includes a fraction, then the fractional portion is truncated. If you do not specify this clause, then <code dir="ltr"><span class="codeinlineitalic">offset</span></code> is 0 and row limiting begins with the first row.</p>
<p><a id="SQLRF55638"></a><span class="subhead3">ROW | ROWS&nbsp;</span>These keywords can be used interchangeably and are provided for semantic clarity.</p>
<p class="subhead2"><a id="SQLRF55639"></a>FETCH</p>
<p>Use this clause to specify the number of rows or percentage of rows to return. If you do not specify this clause, then all rows are returned, beginning at row <code dir="ltr"><span class="codeinlineitalic">offset</span></code> + 1.</p>
<p><a id="SQLRF55640"></a><span class="subhead3">FIRST | NEXT&nbsp;</span>These keywords can be used interchangeably and are provided for semantic clarity.</p>
<p><a id="SQLRF55641"></a><span class="subhead3"><span class="italic">rowcount</span> | <span class="italic">percent</span> PERCENT&nbsp;</span>Use <code dir="ltr"><span class="codeinlineitalic">rowcount</span></code> to specify the number of rows to return. <code dir="ltr"><span class="codeinlineitalic">rowcount</span></code> must be a number or an expression that evaluates to a numeric value. If you specify a negative number, then <code dir="ltr"><span class="codeinlineitalic">rowcount</span></code> is treated as 0. If <code dir="ltr"><span class="codeinlineitalic">rowcount</span></code> is greater than the number of rows available beginning at row <code dir="ltr"><span class="codeinlineitalic">offset</span></code> + 1, then all available rows are returned. If <code dir="ltr"><span class="codeinlineitalic">rowcount</span></code> includes a fraction, then the fractional portion is truncated. If <code dir="ltr"><span class="codeinlineitalic">rowcount</span></code> is NULL, then 0 rows are returned.</p>
<p>Use <code dir="ltr"><span class="codeinlineitalic">percent</span></code> <code dir="ltr">PERCENT</code> to specify the percentage of the total number of selected rows to return. <code dir="ltr"><span class="codeinlineitalic">percent</span></code> must be a number or an expression that evaluates to a numeric value. If you specify a negative number, then <code dir="ltr"><span class="codeinlineitalic">percent</span></code> is treated as 0. If <code dir="ltr"><span class="codeinlineitalic">percent</span></code> is NULL, then 0 rows are returned.</p>
<p>If you do not specify <code dir="ltr"><span class="codeinlineitalic">rowcount</span></code> or <code dir="ltr"><span class="codeinlineitalic">percent</span></code> <code dir="ltr">PERCENT</code>, then 1 row is returned.</p>
<p><a id="SQLRF55642"></a><span class="subhead3">ROW | ROWS&nbsp;</span>These keywords can be used interchangeably and are provided for semantic clarity.</p>
<p><a id="SQLRF55643"></a><span class="subhead3">ONLY | WITH TIES&nbsp;</span>Specify <code dir="ltr">ONLY</code> to return exactly the specified number of rows or percentage of rows.</p>
<p>Specify <code dir="ltr">WITH</code> <code dir="ltr">TIES</code> to return additional rows with the same sort key as the last row fetched. If you specify <code dir="ltr">WITH</code> <code dir="ltr">TIES</code>, then you must specify the <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code>. If you do not specify the <code dir="ltr"><span class="codeinlineitalic">order_by_clause</span></code>, then no additional rows will be returned.</p>
<p><a id="SQLRF55644"></a><span class="subhead3">Restrictions on the <span class="italic">row_limiting_clause</span>&nbsp;</span>This clause is subject to the following restrictions:</p>
<ul>
<li>
<p>You cannot specify this clause with the <code dir="ltr"><span class="codeinlineitalic">for_update_clause</span></code>.</p>
</li>
<li>
<p>If you specify this clause, then the select list cannot contain the sequence pseudocolumns <code dir="ltr">CURRVAL</code> or <code dir="ltr">NEXTVAL</code>.</p>
</li>
<li>
<p>Materialized views are not eligible for an incremental refresh if the defining query contains the <code dir="ltr"><span class="codeinlineitalic">row_limiting_clause</span></code>.</p>
</li>
<li>
<p>If the select list contains columns with identical names and you specify the <code dir="ltr"><span class="codeinlineitalic">row_limiting_clause</span></code>, then an ORA-00918 error occurs. This error occurs whether the identically named columns are in the same table or in different tables. You can work around this issue by specifying unique column aliases for the identically named columns.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABEAACC">&#34;Row Limiting: Examples&#34;</a></div>
<p class="subhead1"><a id="i2066346"></a><a id="SQLRF55370"></a><span class="italic">for_update_clause <a id="sthref7468"></a><a id="sthref7469"></a></span></p>
<p>The <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code dir="ltr">SELECT</code> statement, not in subqueries.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code dir="ltr">SELECT</code> ... <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement. You can do this using one of the programmatic languages or <code dir="ltr">DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see <a class="olink ADLOB1004" href="../ADLOB/adlob_lob_ops.htm#ADLOB1004"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a>.</div>
<p>Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly.</p>
<p><a id="SQLRF55371"></a><span class="subhead3">Restrictions on the FOR UPDATE Clause&nbsp;</span>This clause is subject to the following restrictions:</p>
<ul>
<li>
<p>You cannot specify this clause with the following other constructs: the <code dir="ltr">DISTINCT</code> operator, <code dir="ltr">CURSOR</code> expression, set operators, <code dir="ltr"><span class="codeinlineitalic">group_by_clause</span></code>, or aggregate functions.</p>
</li>
<li>
<p>The tables locked by this clause must all be located on the same database and on the same database as any <code dir="ltr">LONG</code> columns and sequences referenced in the same statement.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2130052">&#34;Using the FOR UPDATE Clause: Examples&#34;</a></div>
<p><a id="SQLRF01706"></a><span class="subhead3">Using the FOR UPDATE Clause on Views&nbsp;</span>In general, this clause is not supported on views. However, in some cases, a <code dir="ltr">SELECT</code> ... <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code dir="ltr">SELECT</code> ... <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause on a view can succeed or fail.</p>
<ul>
<li>
<p>Using the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause on merged views</p>
<p>An error can occur when you use the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause on a merged view if both of the following conditions apply:</p>
<ul>
<li>
<p>The underlying column of the view is an expression</p>
</li>
<li>
<p>The <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause applies to a column list</p>
</li>
</ul>
<p>The following statement succeeds because the underlying column of the view is not an expression:</p>
<pre dir="ltr">SELECT employee_id FROM (SELECT * FROM employees)
   FOR UPDATE OF employee_id;
</pre>
<p>The following statement succeeds because, while the underlying column of the view is an expression, the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause does not apply to a column list:</p>
<pre dir="ltr">SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees)
   FOR UPDATE;
</pre>
<p>The following statement fails because the underlying column of the view is an expression and the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause applies to a column list:</p>
<pre dir="ltr">SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees)
   FOR UPDATE OF employee_id;
                 *
Error at line 2:
ORA-01733: virtual column not allowed here
</pre></li>
<li>
<p>Using the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause on non-merged views</p>
<p>Since the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code dir="ltr">NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code dir="ltr">ORA-02014</code> error.</p>
<p>In the following example, the <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> statement prevents view merging, which causes an error:</p>
<pre dir="ltr">SELECT avgsal
   FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id)
   FOR UPDATE;
FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id)
     *
ERROR at line 2:
ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.
</pre></li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Due to the complexity of the view merging mechanism, Oracle recommends against using the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause on views.</div>
<p class="subhead2"><a id="SQLRF55372"></a>OF ... <span class="italic">column</span></p>
<p>Use the <code dir="ltr">OF</code> ... <code dir="ltr"><span class="codeinlineitalic">column</span></code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code dir="ltr">OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query.</p>
<p class="subhead2"><a id="SQLRF55373"></a>NOWAIT | WAIT</p>
<p>The <code dir="ltr">NOWAIT</code> and <code dir="ltr">WAIT</code> clauses let you tell the database how to proceed if the <code dir="ltr">SELECT</code> statement attempts to lock a row that is locked by another user.</p>
<ul>
<li>
<p>Specify <code dir="ltr">NOWAIT</code> to return control to you immediately if a lock exists.</p>
</li>
<li>
<p>Specify <code dir="ltr">WAIT</code> to instruct the database to wait <code dir="ltr"><span class="codeinlineitalic">integer</span></code> seconds for the row to become available and then return control to you.</p>
</li>
</ul>
<p>If you specify neither <code dir="ltr">WAIT</code> nor <code dir="ltr">NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code dir="ltr">SELECT</code> statement.</p>
<p><a id="SQLRF55374"></a><span class="subhead3">SKIP LOCKED&nbsp;</span></p>
<p><code dir="ltr">SKIP</code> <code dir="ltr">LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code dir="ltr">SKIP</code> <code dir="ltr">LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code dir="ltr">WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments, such as Oracle Streams Advanced Queuing. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Oracle recommends that you use the Oracle Streams Advanced Queuing APIs instead of directly using the <code dir="ltr">SKIP</code> <code dir="ltr">LOCKED</code> functionality. Refer to <a class="olink ADQUE2835" href="../ADQUE/aq_opers.htm#ADQUE2835"><span class="italic">Oracle Database Advanced Queuing User&#39;s Guide</span></a> for more information.</p>
<dl>
<dt>Note on the WAIT and SKIP LOCKED Clauses</dt>
<dd>
<p>If you specify <code dir="ltr">WAIT</code> or <code dir="ltr">SKIP</code> <code dir="ltr">LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code dir="ltr">SELECT</code> statement until the lock on the table is released. In the case of <code dir="ltr">WAIT</code>, the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause is blocked regardless of the wait time specified.</p>
</dd>
</dl>
<p class="subhead1"><a id="BABHFEEE"></a><a id="SQLRF56466"></a><span class="italic">row_pattern_clause</span></p>
<p>The <code dir="ltr">MATCH_RECOGNIZE</code> clause lets you perform pattern matching. Use this clause to recognize patterns in a sequence of rows in <code dir="ltr"><span class="codeinlineitalic">table</span></code>, which is called the row pattern input table. The result of a query that uses the <code dir="ltr">MATCH_RECOGNIZE</code> clause is called the row pattern output table.</p>
<p>The <code dir="ltr">MATCH_RECOGNIZE</code> enables you to do the following tasks:</p>
<ul>
<li>
<p>Logically partition and order the data with the <code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> and <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clauses.</p>
</li>
<li>
<p>Define measures, which are expressions usable in other parts of the SQL query, in the <code dir="ltr">MEASURES</code> clause.</p>
</li>
<li>
<p>Define patterns of rows to seek using the <code dir="ltr">PATTERN</code> clause. These patterns use regular expression syntax, a powerful and expressive feature, applied to the pattern variables you define.</p>
</li>
<li>
<p>Specify the logical conditions required to map a row to a row pattern variable in the <code dir="ltr">DEFINE</code> clause.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG8956" href="../DWHSG/pattern.htm#DWHSG8956"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on pattern matching</p>
</li>
<li>
<p><a href="#BABJHHDD">&#34;Row Pattern Matching: Example&#34;</a></p>
</li>
</ul>
</div>
<p class="subhead1"><a id="BABBHEEC"></a><a id="SQLRF56467"></a><span class="italic">row_pattern_partition_by</span></p>
<p>Specify <code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> to divide the rows in the row pattern input table into logical groups called row pattern partitions. Use <code dir="ltr"><span class="codeinlineitalic">column</span></code> to specify one or more partitioning columns. Each partition consists of the set of rows in the row pattern input table that have the same value(s) on the partitioning column(s).</p>
<p>If you specify this clause, then matches are found within partitions and do not cross partition boundaries. If you do not specify this clause, then all rows of the row input table constitute a single row pattern partition.</p>
<p class="subhead1"><a id="BABDGHAA"></a><a id="SQLRF56468"></a><span class="italic">row_pattern_order_by</span></p>
<p>Specify <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> to order rows within each row pattern partition. Use <code dir="ltr"><span class="codeinlineitalic">column</span></code> to specify one or more ordering columns. If you specify multiple columns, then Oracle Database first sorts rows based on their values for the first column. Rows with the same value for the first column are then sorted based on their values for the second column, and so on. Oracle Database sorts nulls following all others in ascending order.</p>
<p>If you do not specify this clause, then the result of the <code dir="ltr"><span class="codeinlineitalic">row_pattern_clause</span></code> is nondeterministic and you may get inconsistent results each time you run the query.</p>
<p class="subhead1"><a id="BABCAEJD"></a><a id="SQLRF56469"></a><span class="italic">row_pattern_measures</span></p>
<p>Use the <code dir="ltr">MEASURES</code> clause to define one or more row pattern measure columns. These columns are included in the row pattern output table and contain values that are useful for analyzing data.</p>
<p>When you define a row pattern measure column, using the <code dir="ltr"><span class="codeinlineitalic">row_pattern_measure_column</span></code> clause, you specify its pattern measure expression. The values in the column are calculated by evaluating the pattern measure expression whenever a match is found.</p>
<p><a id="BABHGEBI"></a><a id="SQLRF56470"></a><span class="subhead3"><span class="italic">row_pattern_measure_column</span>&nbsp;</span>Use this clause to define a row pattern measure column.</p>
<ul>
<li>
<p>For <code dir="ltr"><span class="codeinlineitalic">expr</span></code>, specify the pattern measure expression. A pattern measure expression is an expression as described in <a href="expressions.htm#g1057115">Chapter 5, &#34;Expressions&#34;</a> that can contain only the following elements:</p>
<ul>
<li>
<p>Constants: Text literals and numeric literals</p>
</li>
<li>
<p>References to any column of the row pattern input table</p>
</li>
<li>
<p>The <code dir="ltr">CLASSIFIER</code> function, which returns the name of the primary row pattern variable to which the row is mapped. Refer to <a href="#BABBGAAB"><span class="xreftitleitalic"><span class="italic">row_pattern_classifier_func</span></span></a> for more information.</p>
</li>
<li>
<p>The <code dir="ltr">MATCH_NUMBER</code> function, which returns the sequential number of a row pattern match within the row pattern partition. Refer to <a href="#BABBEEBD"><span class="xreftitleitalic"><span class="italic">row_pattern_match_num_func</span></span></a> for more information.</p>
</li>
<li>
<p>Row pattern navigation functions: <code dir="ltr">PREV</code>, <code dir="ltr">NEXT</code>, <code dir="ltr">FIRST</code>, and <code dir="ltr">LAST</code>. Refer to <a href="#BABGCIIA"><span class="xreftitleitalic"><span class="italic">row_pattern_navigation_func</span></span></a> for more information.</p>
</li>
<li>
<p>Row pattern aggregate functions: <a href="functions019.htm#i82074">AVG</a>, <a href="functions046.htm#i82697">COUNT</a>, <a href="functions110.htm#i89072">MAX</a>, <a href="functions112.htm#i1280029">MIN</a>, or <a href="functions197.htm#i89126">SUM</a>. Refer to <a href="#BABIDJGB"><span class="xreftitleitalic"><span class="italic">row_pattern_aggregate_func</span></span></a> for more information.</p>
</li>
</ul>
</li>
<li>
<p>For <code dir="ltr"><span class="codeinlineitalic">c_alias</span></code>, specify the alias for the pattern measure expression. Oracle Database uses this alias in the column heading of the row pattern output table. The <code dir="ltr">AS</code> keyword is optional. The alias can be used in other parts of the query, such as the <code dir="ltr">SELECT</code> ... <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause.</p>
</li>
</ul>
<p class="subhead1"><a id="BABDDHIG"></a><a id="SQLRF56471"></a><span class="italic">row_pattern_rows_per_match</span></p>
<p>This clause lets you specify whether the row pattern output table includes summary or detailed data about each match.</p>
<ul>
<li>
<p>If you specify <code dir="ltr">ONE</code> <code dir="ltr">ROW</code> <code dir="ltr">PER</code> <code dir="ltr">MATCH</code>, then each match produces one summary row. This is the default.</p>
</li>
<li>
<p>If you specify <code dir="ltr">ALL</code> <code dir="ltr">ROWS</code> <code dir="ltr">PER</code> <code dir="ltr">MATCH</code>, then each match that spans multiple rows will produce one output row for each row in the match.</p>
</li>
</ul>
<p class="subhead1"><a id="BABGGJBG"></a><a id="SQLRF56472"></a><span class="italic">row_pattern_skip_to</span></p>
<p>This clause lets you specify the point to resume row pattern matching after a non-empty match is found.</p>
<ul>
<li>
<p>Specify <code dir="ltr">AFTER</code> <code dir="ltr">MATCH</code> <code dir="ltr">SKIP</code> <code dir="ltr">TO</code> <code dir="ltr">NEXT</code> <code dir="ltr">ROW</code> to resume pattern matching at the row after the first row of the current match.</p>
</li>
<li>
<p>Specify <code dir="ltr">AFTER</code> <code dir="ltr">MATCH</code> <code dir="ltr">SKIP</code> <code dir="ltr">PAST</code> <code dir="ltr">LAST</code> <code dir="ltr">ROW</code> to resume pattern matching at the next row after the last row of the current match. This is the default.</p>
</li>
<li>
<p>Specify <code dir="ltr">AFTER</code> <code dir="ltr">MATCH</code> <code dir="ltr">SKIP</code> <code dir="ltr">TO</code> <code dir="ltr">FIRST</code> <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code> to resume pattern matching at the first row that is mapped to pattern variable <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code>. The <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code> must be defined in the <code dir="ltr">DEFINE</code> clause.</p>
</li>
<li>
<p>Specify <code dir="ltr">AFTER</code> <code dir="ltr">MATCH</code> <code dir="ltr">SKIP</code> <code dir="ltr">TO</code> <code dir="ltr">LAST</code> <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code> to resume pattern matching at the last row that is mapped to pattern variable <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code>. The <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code> must be defined in the <code dir="ltr">DEFINE</code> clause.</p>
</li>
<li>
<p><code dir="ltr">AFTER</code> <code dir="ltr">MATCH</code> <code dir="ltr">SKIP</code> <code dir="ltr">TO</code> <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code> has the same behavior as <code dir="ltr">AFTER</code> <code dir="ltr">MATCH</code> <code dir="ltr">SKIP</code> <code dir="ltr">TO</code> <code dir="ltr">LAST</code> <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG8993" href="../DWHSG/pattern.htm#DWHSG8993"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on the <code dir="ltr">AFTER</code> <code dir="ltr">MATCH</code> <code dir="ltr">SKIP</code> clauses</div>
<p class="subhead1"><a id="SQLRF56516"></a>PATTERN</p>
<p>Use the <code dir="ltr">PATTERN</code> clause to define which pattern variables must be matched, the sequence in which they must be matched, and the quantity of rows that must be matched for each pattern variable.</p>
<p>A row pattern match consists of a set of contiguous rows in a row pattern partition. Each row of the match is mapped to a pattern variable. The mapping of rows to pattern variables must conform to the regular expression specified in the <code dir="ltr"><span class="codeinlineitalic">row_pattern</span></code> clause, and all conditions in the <code dir="ltr">DEFINE</code> clause must be true.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is outside the scope of this document to explain regular expression concepts and details. If you are not familiar with regular expressions, then you are encouraged to familiarize yourself with the topic using other sources.</div>
<p>The precedence of the elements that you specify in the regular expression of the <code dir="ltr">PATTERNS</code> clause, in decreasing order, is as follows:</p>
<ul>
<li>
<p>Row pattern elements (specified in the <code dir="ltr"><span class="codeinlineitalic">row_pattern_primary</span></code> clause)</p>
</li>
<li>
<p>Row pattern quantifiers (specified in the <code dir="ltr"><span class="codeinlineitalic">row_pattern_quantifier</span></code> clause)</p>
</li>
<li>
<p>Concatenation (specified in the <code dir="ltr"><span class="codeinlineitalic">row_pattern_term</span></code> clause)</p>
</li>
<li>
<p>Alternation (specified in the <code dir="ltr"><span class="codeinlineitalic">row_pattern</span></code> clause)</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG8986" href="../DWHSG/pattern.htm#DWHSG8986"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on the <code dir="ltr">PATTERN</code> clause</div>
<p class="subhead1"><a id="BABCABFD"></a><a id="SQLRF56473"></a><span class="italic">row_pattern</span></p>
<p>Use this clause to specify the row pattern. A row pattern is a regular expression that can take one of the following forms:</p>
<ul>
<li>
<p>A single row pattern term</p>
<p>For example: <code dir="ltr">PATTERN(A)</code></p>
</li>
<li>
<p>A row pattern, a vertical bar, and a row pattern term</p>
<p>For example: <code dir="ltr">PATTERN(A|B)</code></p>
</li>
<li>
<p>A recursively built row pattern, a vertical bar, and a row pattern term</p>
<p>For example: <code dir="ltr">PATTERN(A|B|C)</code></p>
</li>
</ul>
<p>The vertical bar in this clause represents <span class="bold">alternation</span>. Alternation matches a single regular expression from a list of several possible regular expressions. Alternatives are preferred in the order they are specified. For example, if you specify <code dir="ltr">PATTERN(A|B|C)</code>, then Oracle Database attempts to match <code dir="ltr">A</code> first. If <code dir="ltr">A</code> is not matched, then it attempts to match <code dir="ltr">B</code>. If <code dir="ltr">B</code> is not matched, then it attempts to match <code dir="ltr">C</code>.</p>
<p class="subhead1"><a id="BABDBFFB"></a><a id="SQLRF56474"></a><span class="italic">row_pattern_term</span></p>
<p>This clause lets you specify a row pattern term. A row pattern term can take one of the following forms:</p>
<ul>
<li>
<p>A single row pattern factor</p>
<p>For example: <code dir="ltr">PATTERN(A)</code></p>
</li>
<li>
<p>A row pattern term followed by a row pattern factor.</p>
<p>For example: <code dir="ltr">PATTERN(A B)</code></p>
</li>
<li>
<p>A recursively built row pattern term followed by a row pattern factor</p>
<p>For example: <code dir="ltr">PATTERN(A B C)</code></p>
</li>
</ul>
<p>The syntax used in the second and third examples represents <span class="bold">concatenation</span>. Concatenation is used to list two or more items in a pattern to be matched and the order in which they are to be matched. For example, if you specify <code dir="ltr">PATTERN(A B C)</code>, then Oracle Database first matches <code dir="ltr">A</code>, then uses the resulting matched rows to match <code dir="ltr">B</code>, then uses the resulting matched rows to match <code dir="ltr">C</code>. Only rows that match <code dir="ltr">A</code>, <code dir="ltr">B</code>, and <code dir="ltr">C</code>, are included in the row pattern match.</p>
<p class="subhead1"><a id="BABCBDAA"></a><a id="SQLRF56475"></a><span class="italic">row_pattern_factor</span></p>
<p>This clause lets you specify a row pattern factor. A row pattern factor consists of a row pattern element, specified using the <code dir="ltr"><span class="codeinlineitalic">row_pattern_primary</span></code> clause, and an optional row pattern quantifier, specified using the <code dir="ltr"><span class="codeinlineitalic">row_pattern_quantifier</span></code> clause.</p>
<p class="subhead1"><a id="BABBIDEJ"></a><a id="SQLRF56476"></a><span class="italic">row_pattern_primary</span></p>
<p>Use this clause to specify the row pattern element. <a href="#BABIDGEJ">Table 19-1</a> lists the valid row pattern elements and their descriptions.</p>
<div id="SQLRF56517" class="tblhruleformal">
<p class="titleintable"><a id="sthref7470"></a><a id="BABIDGEJ"></a>Table 19-1 Row Pattern Elements</p>
<table class="cellalignment5872" title="Row Pattern Elements" summary="First column lists row pattern quantifiers; second column provides descriptions." dir="ltr">
<thead>
<tr class="cellalignment5863">
<th class="cellalignment5873" id="r1c1-t52">Row Pattern Element</th>
<th class="cellalignment5873" id="r1c2-t52">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r2c1-t52" headers="r1c1-t52">
<p><code dir="ltr"><span class="codeinlineitalic">variable_name</span></code></p>
</td>
<td class="cellalignment5869" headers="r2c1-t52 r1c2-t52">
<p>Specify a primary pattern variable name that is defined in the <code dir="ltr"><span class="codeinlineitalic">row_pattern_definition</span></code> clause. You cannot specify a union pattern variable that is defined in the <code dir="ltr"><span class="codeinlineitalic">row_pattern_subset_item</span></code> clause.</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r3c1-t52" headers="r1c1-t52">
<p><code dir="ltr">$</code></p>
</td>
<td class="cellalignment5869" headers="r3c1-t52 r1c2-t52">
<p><code dir="ltr">$</code> matches the position after the last row in the partition. This element is an anchor. Anchors work in terms of positions rather than rows.</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r4c1-t52" headers="r1c1-t52">
<p><code dir="ltr">^</code></p>
</td>
<td class="cellalignment5869" headers="r4c1-t52 r1c2-t52">
<p><code dir="ltr">^</code> matches the position before the first row in the partition. This element is an anchor. Anchors work in terms of positions rather than rows</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r5c1-t52" headers="r1c1-t52">
<p><code dir="ltr">(</code> <code dir="ltr">[</code><code dir="ltr"><span class="codeinlineitalic">row_pattern</span></code><code dir="ltr">]</code> <code dir="ltr">)</code></p>
</td>
<td class="cellalignment5869" headers="r5c1-t52 r1c2-t52">
<p>Use <code dir="ltr"><span class="codeinlineitalic">row_pattern</span></code> to specify the row pattern to be matched. An empty pattern <code dir="ltr">()</code> matches an empty set of rows.</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r6c1-t52" headers="r1c1-t52">
<p><code dir="ltr">{-</code> <code dir="ltr"><span class="codeinlineitalic">row_pattern</span></code> <code dir="ltr">-}</code></p>
</td>
<td class="cellalignment5869" headers="r6c1-t52 r1c2-t52">
<p>Exclusion syntax. Use <code dir="ltr"><span class="codeinlineitalic">row_pattern</span></code> to specify parts of the pattern to be excluded from the output of <code dir="ltr">ALL</code> <code dir="ltr">ROWS</code> <code dir="ltr">PER</code> <code dir="ltr">MATCH</code>.</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r7c1-t52" headers="r1c1-t52">
<p><code dir="ltr"><span class="codeinlineitalic">row_pattern_permute</span></code></p>
</td>
<td class="cellalignment5869" headers="r7c1-t52 r1c2-t52">
<p>Use <code dir="ltr"><span class="codeinlineitalic">row_pattern_permute</span></code> to specify a pattern that is a permutation of row pattern elements. Refer to <a href="#BABEEAJJ"><span class="xreftitleitalic"><span class="italic">row_pattern_permute</span></span></a> for the full semantics of this clause.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="subhead1"><a id="BABEEAJJ"></a><a id="SQLRF56477"></a><span class="italic">row_pattern_permute</span></p>
<p>Use the <code dir="ltr">PERMUTE</code> clause to express a pattern that is a permutation of the specified row pattern elements. For example, <code dir="ltr">PATTERN</code> <code dir="ltr">(PERMUTE</code> <code dir="ltr">(A,</code> <code dir="ltr">B,</code> <code dir="ltr">C))</code> is equivalent to an alternation of all permutations of the three row pattern elements <code dir="ltr">A</code>, <code dir="ltr">B</code>, and <code dir="ltr">C</code>, similar to the following:</p>
<pre dir="ltr">PATTERN (A B C | A C B | B A C | B C A | C A B | C B A)
</pre>
<p>Note that the row pattern elements are expanded lexicographically and that each element to permute must be separated by a comma from the other elements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG9022" href="../DWHSG/pattern.htm#DWHSG9022"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on permutations</div>
<p class="subhead1"><a id="BABEGBGE"></a><a id="SQLRF56478"></a><span class="italic">row_pattern_quantifier</span></p>
<p>Use this clause to specify the row pattern quantifier, which is a postfix operator that defines the number of iterations accepted for a match.</p>
<p>Row pattern quantifiers are referred to as greedy; they will attempt to match as many instances of the regular expression on which they are applied as possible. The exception is row pattern quantifiers that have a question mark (<code dir="ltr">?</code>) as a suffix, which are referred to as reluctant. They will attempt to match as few instances as possible of the regular expression on which they are applied.</p>
<p><a href="#BABGAGEF">Table 19-2</a> lists the valid row pattern quantifiers and the number of iterations they accept for a match. In this table, <code dir="ltr"><span class="codeinlineitalic">n</span></code> and <code dir="ltr"><span class="codeinlineitalic">m</span></code> represent unsigned integers.</p>
<div id="SQLRF56479" class="tblhruleformal">
<p class="titleintable"><a id="sthref7471"></a><a id="BABGAGEF"></a>Table 19-2 Row Pattern Quantifiers</p>
<table class="cellalignment5872" title="Row Pattern Quantifiers" summary="First column lists row pattern quantifiers; second column provides descriptions." dir="ltr">
<thead>
<tr class="cellalignment5863">
<th class="cellalignment5873" id="r1c1-t54">Row Pattern Quantifier</th>
<th class="cellalignment5873" id="r1c2-t54">Number of Iterations Accepted for a Match</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r2c1-t54" headers="r1c1-t54">
<p><code dir="ltr">*</code></p>
</td>
<td class="cellalignment5869" headers="r2c1-t54 r1c2-t54">
<p>0 or more iterations (greedy)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r3c1-t54" headers="r1c1-t54">
<p><code dir="ltr">*?</code></p>
</td>
<td class="cellalignment5869" headers="r3c1-t54 r1c2-t54">
<p>0 or more iterations (reluctant)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r4c1-t54" headers="r1c1-t54">
<p><code dir="ltr">+</code></p>
</td>
<td class="cellalignment5869" headers="r4c1-t54 r1c2-t54">
<p>1 or more iterations (greedy)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r5c1-t54" headers="r1c1-t54">
<p><code dir="ltr">+?</code></p>
</td>
<td class="cellalignment5869" headers="r5c1-t54 r1c2-t54">
<p>1 or more iterations (reluctant)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r6c1-t54" headers="r1c1-t54">
<p><code dir="ltr">?</code></p>
</td>
<td class="cellalignment5869" headers="r6c1-t54 r1c2-t54">
<p>0 or 1 iterations (greedy)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r7c1-t54" headers="r1c1-t54">
<p><code dir="ltr">??</code></p>
</td>
<td class="cellalignment5869" headers="r7c1-t54 r1c2-t54">
<p>0 or 1 iterations (reluctant)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r8c1-t54" headers="r1c1-t54">
<p><code dir="ltr">{</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">,}</code></p>
</td>
<td class="cellalignment5869" headers="r8c1-t54 r1c2-t54">
<p><code dir="ltr"><span class="codeinlineitalic">n</span></code> or more iterations, (<code dir="ltr"><span class="codeinlineitalic">n</span></code> &gt;= 0) (greedy)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r9c1-t54" headers="r1c1-t54">
<p><code dir="ltr">{</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">,}?</code></p>
</td>
<td class="cellalignment5869" headers="r9c1-t54 r1c2-t54">
<p><code dir="ltr"><span class="codeinlineitalic">n</span></code> or more iterations, (<code dir="ltr"><span class="codeinlineitalic">n</span></code> &gt;= 0) (reluctant)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r10c1-t54" headers="r1c1-t54">
<p><code dir="ltr">{</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">,</code><code dir="ltr"><span class="codeinlineitalic">m</span></code><code dir="ltr">}</code></p>
</td>
<td class="cellalignment5869" headers="r10c1-t54 r1c2-t54">
<p>Between <code dir="ltr"><span class="codeinlineitalic">n</span></code> and <code dir="ltr"><span class="codeinlineitalic">m</span></code> iterations, inclusive, (0 &lt;= <code dir="ltr"><span class="codeinlineitalic">n</span></code> &lt;= <code dir="ltr"><span class="codeinlineitalic">m</span></code>, 0 &lt; <code dir="ltr"><span class="codeinlineitalic">m</span></code>) (greedy)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r11c1-t54" headers="r1c1-t54">
<p><code dir="ltr">{</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">,</code><code dir="ltr"><span class="codeinlineitalic">m</span></code><code dir="ltr">}?</code></p>
</td>
<td class="cellalignment5869" headers="r11c1-t54 r1c2-t54">
<p>Between <code dir="ltr"><span class="codeinlineitalic">n</span></code> and <code dir="ltr"><span class="codeinlineitalic">m</span></code> iterations, inclusive, (0 &lt;= <code dir="ltr"><span class="codeinlineitalic">n</span></code> &lt;= <code dir="ltr"><span class="codeinlineitalic">m</span></code>, 0 &lt; <code dir="ltr"><span class="codeinlineitalic">m</span></code>) (reluctant)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r12c1-t54" headers="r1c1-t54">
<p><code dir="ltr">{,</code><code dir="ltr"><span class="codeinlineitalic">m</span></code><code dir="ltr">}</code></p>
</td>
<td class="cellalignment5869" headers="r12c1-t54 r1c2-t54">
<p>Between 0 and <code dir="ltr"><span class="codeinlineitalic">m</span></code> iterations, inclusive (<code dir="ltr"><span class="codeinlineitalic">m</span></code> &gt; 0) (greedy)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r13c1-t54" headers="r1c1-t54">
<p><code dir="ltr">{,</code><code dir="ltr"><span class="codeinlineitalic">m</span></code><code dir="ltr">}?</code></p>
</td>
<td class="cellalignment5869" headers="r13c1-t54 r1c2-t54">
<p>Between 0 and <code dir="ltr"><span class="codeinlineitalic">m</span></code> iterations, inclusive (<code dir="ltr"><span class="codeinlineitalic">m</span></code> &gt; 0) (reluctant)</p>
</td>
</tr>
<tr class="cellalignment5863">
<td class="cellalignment5869" id="r14c1-t54" headers="r1c1-t54">
<p><code dir="ltr">{</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">}?</code></p>
</td>
<td class="cellalignment5869" headers="r14c1-t54 r1c2-t54">
<p><code dir="ltr"><span class="codeinlineitalic">n</span></code> iterations, (<code dir="ltr"><span class="codeinlineitalic">n</span></code> &gt; 0)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG8986" href="../DWHSG/pattern.htm#DWHSG8986"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on row pattern quantifiers</div>
<p class="subhead1"><a id="BABIHBJA"></a><a id="SQLRF56480"></a><span class="italic">row_pattern_subset_clause</span></p>
<p>The <code dir="ltr">SUBSET</code> clause lets you specify one or more union row pattern variables. Use the <code dir="ltr"><span class="codeinlineitalic">row_pattern_subset_item</span></code> clause to declare each union row pattern variable.</p>
<p>You can specify union row pattern variables in the following clauses:</p>
<ul>
<li>
<p><code dir="ltr">MEASURES</code> clause: In the expression for a row pattern measure column. That is, in expression <code dir="ltr"><span class="codeinlineitalic">expr</span></code> of the <code dir="ltr"><span class="codeinlineitalic">row_pattern_measure_column</span></code> clause.</p>
</li>
<li>
<p><code dir="ltr">DEFINE</code> clause: In the condition that defines a primary pattern variable. That is, in <code dir="ltr"><span class="codeinlineitalic">condition</span></code> of the <code dir="ltr"><span class="codeinlineitalic">row_pattern_definition</span></code> clause</p>
</li>
</ul>
<p class="subhead1"><a id="BABCDBBJ"></a><a id="SQLRF56481"></a><span class="italic">row_pattern_subset_item</span></p>
<p>This clause lets you create a grouping of multiple pattern variables that can be referred to with a variable name of its own. The variable name that refers to this grouping is called a union row pattern variable.</p>
<ul>
<li>
<p>For <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code> on the left side of the equal sign, specify the name of the union row pattern variable.</p>
</li>
<li>
<p>On the right side of the equal sign, specify a comma-separated list of distinct primary row pattern variables within parentheses. This list cannot include any union row pattern variables.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG8989" href="../DWHSG/pattern.htm#DWHSG8989"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on defining union row pattern variables</div>
<p class="subhead1"><a id="SQLRF56518"></a>DEFINE</p>
<p>Use the <code dir="ltr">DEFINE</code> clause to specify one or more row pattern definitions. A row pattern definition specifies the conditions that a row must meet in order to be mapped to a specific pattern variable.</p>
<p>The <code dir="ltr">DEFINE</code> clause only supports running semant<a class="olink DWHSG9193" href="../DWHSG/pattern.htm#DWHSG9193"></a>ics.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG8999" href="../DWHSG/pattern.htm#DWHSG8999"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on the <code dir="ltr">DEFINE</code> clause</p>
</li>
<li>
<p><a class="olink DWHSG9193" href="../DWHSG/pattern.htm#DWHSG9193"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on running and final semantics</p>
</li>
</ul>
</div>
<p class="subhead1"><a id="BABGDJCE"></a><a id="SQLRF56482"></a><span class="italic">row_pattern_definition_list</span></p>
<p>This clause lets you specify one or more row pattern definitions.</p>
<p class="subhead1"><a id="BABIHJAH"></a><a id="SQLRF56483"></a><span class="italic">row_pattern_definition</span></p>
<p>This clause lets you specify a row pattern definition, which contains the conditions that a row must meet in order to be mapped to the specified pattern variable.</p>
<ul>
<li>
<p>For <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code>, specify the name of the pattern variable.</p>
</li>
<li>
<p>For <code dir="ltr"><span class="codeinlineitalic">condition</span></code>, specify a condition as described in <a href="conditions.htm#g1077361">Chapter 6, &#34;Conditions&#34;</a>, with the following extension: <code dir="ltr"><span class="codeinlineitalic">condition</span></code> can contain any of the functions described by <a href="#BABDHIEA"><span class="xreftitleitalic"><span class="italic">row_pattern_navigation_func</span>::=</span></a> and <a href="#BABBDCFA"><span class="xreftitleitalic"><span class="italic">row_pattern_aggregate_func</span>::=</span></a>.</p>
</li>
</ul>
<p class="subhead1"><a id="BABHGBCB"></a><a id="SQLRF56484"></a><span class="italic">row_pattern_rec_func</span></p>
<p>This clause comprises the following clauses, which let you specify row pattern recognition functions:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">row_pattern_classifier_func</span></code>: Use this clause to specify the <code dir="ltr">CLASSIFIER</code> function, which returns a character string whose value is the name of the variable to which the row is mapped.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">row_pattern_match_num_func</span></code>: Use this clause to specify the <code dir="ltr">MATCH_NUMBER</code> function, which returns a numeric value with scale 0 (zero) whose value is the sequential number of the match within the row pattern partition.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">row_pattern_navigation_func</span></code>: Use this clause to specify functions that perform row pattern navigation operations.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">row_pattern_aggregate_func</span></code>: Use this clause to specify an aggregate function in the expression for a row pattern measure column or in the condition that defines a primary pattern variable.</p>
</li>
</ul>
<p>You can specify row pattern recognition functions in the following clauses:</p>
<ul>
<li>
<p><code dir="ltr">MEASURES</code> clause: In the expression for a row pattern measure column. That is, in expression <code dir="ltr"><span class="codeinlineitalic">expr</span></code> of the <code dir="ltr"><span class="codeinlineitalic">row_pattern_measure_column</span></code> clause.</p>
</li>
<li>
<p><code dir="ltr">DEFINE</code> clause: In the condition that defines a primary pattern variable. That is, in <code dir="ltr"><span class="codeinlineitalic">condition</span></code> of the <code dir="ltr"><span class="codeinlineitalic">row_pattern_definition</span></code> clause</p>
</li>
</ul>
<p>A row pattern recognition function may behave differently depending whether you specify it in the <code dir="ltr">MEASURES</code> or <code dir="ltr">DEFINE</code> clause. These details are explained in the semantics for each clause.</p>
<p class="subhead1"><a id="BABBGAAB"></a><a id="SQLRF56485"></a><span class="italic">row_pattern_classifier_func</span></p>
<p>The <code dir="ltr">CLASSIFIER</code> function returns a character string whose value is the name of the variable to which the row is mapped.</p>
<ul>
<li>
<p>In the <code dir="ltr">MEASURES</code> clause:</p>
<ul>
<li>
<p>If you specify <code dir="ltr">ONE</code> <code dir="ltr">ROW</code> <code dir="ltr">PER</code> <code dir="ltr">MATCH</code>, then the query uses the last row of the match when processing the <code dir="ltr">MEASURES</code> clause, so the <code dir="ltr">CLASSIFIER</code> function returns the name of the pattern variable to which the last row of the match is mapped.</p>
</li>
<li>
<p>If you specify <code dir="ltr">ALL</code> <code dir="ltr">ROWS</code> <code dir="ltr">PER</code> <code dir="ltr">MATCH</code>, then for each row of the match found, the <code dir="ltr">CLASSIFIER</code> function returns the name of the pattern variable to which the row is mapped.</p>
</li>
</ul>
<p>For empty matches&mdash;that is, matches that contain no rows, the <code dir="ltr">CLASSIFER</code> function returns NULL.</p>
</li>
<li>
<p>In the <code dir="ltr">DEFINE</code> clause, the <code dir="ltr">CLASSIFIER</code> function returns the name of the primary pattern variable to which the current row is mapped.</p>
</li>
</ul>
<p class="subhead1"><a id="BABBEEBD"></a><a id="SQLRF56486"></a><span class="italic">row_pattern_match_num_func</span></p>
<p>The <code dir="ltr">MATCH_NUMBER</code> function returns a numeric value with scale 0 (zero) whose value is the sequential number of the match within the row pattern partition.</p>
<p>Matches within a row pattern partition are numbered sequentially starting with 1 in the order in which they are found. If multiple rows satisfy a match, then they are all assigned the same match number. Note that match numbering starts over again at 1 in each row pattern partition, because there is no inherent ordering between row pattern partitions.</p>
<ul>
<li>
<p>In the <code dir="ltr">MEASURES</code> clause: You can use <code dir="ltr">MATCH_NUMBER</code> to obtain the sequential number of the match within the row pattern.</p>
</li>
<li>
<p>In the <code dir="ltr">DEFINE</code> clause: You can use <code dir="ltr">MATCH_NUMBER</code> to define conditions that depend upon the match number.</p>
</li>
</ul>
<p class="subhead1"><a id="BABGCIIA"></a><a id="SQLRF56487"></a><span class="italic">row_pattern_navigation_func</span></p>
<p>This clause lets you perform the following row pattern navigation operations:</p>
<ul>
<li>
<p>Navigate among the group of rows mapped to a pattern variable using the <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> functions of the <code dir="ltr"><span class="codeinlineitalic">row_pattern_nav_logical</span></code> clause.</p>
</li>
<li>
<p>Navigate among all rows in a row pattern partition using the <code dir="ltr">PREV</code> and <code dir="ltr">NEXT</code> functions of the <code dir="ltr"><span class="codeinlineitalic">row_pattern_nav_physical</span></code> clause</p>
</li>
<li>
<p>Nest the <code dir="ltr">FIRST</code> or <code dir="ltr">LAST</code> function within the <code dir="ltr">PREV</code> or <code dir="ltr">NEXT</code> function using the <code dir="ltr"><span class="codeinlineitalic">row_pattern_nav_compound</span></code> clause.</p>
</li>
</ul>
<p class="subhead1"><a id="BABHCBFE"></a><a id="SQLRF56488"></a><span class="italic">row_pattern_nav_logical</span></p>
<p>This clause lets you use the <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> functions to navigate among the group of rows mapped to a pattern variable using an optional logical offset.</p>
<ul>
<li>
<p>The <code dir="ltr">FIRST</code> function returns the value of expression <code dir="ltr"><span class="codeinlineitalic">expr</span></code> when evaluated in the first row of the group of rows mapped to the pattern variable that is specified in <code dir="ltr"><span class="codeinlineitalic">expr</span></code>. If no rows are mapped to the pattern variable, then the <code dir="ltr">FIRST</code> function returns NULL.</p>
</li>
<li>
<p>The <code dir="ltr">LAST</code> function returns the value of expression <code dir="ltr"><span class="codeinlineitalic">expr</span></code> when evaluated in the last row of the group of rows mapped to the pattern variable that is specified in <code dir="ltr"><span class="codeinlineitalic">expr</span></code>. If no rows are mapped to the pattern variable, then the <code dir="ltr">LAST</code> function returns NULL.</p>
</li>
<li>
<p>Use <code dir="ltr"><span class="codeinlineitalic">expr</span></code> to specify the expression to be evaluated. It must contain at least one row pattern column reference. If it contains more than one row pattern column reference, then all must refer to the same pattern variable.</p>
</li>
<li>
<p>Use the optional <code dir="ltr"><span class="codeinlineitalic">offset</span></code> to specify the logical offset within the set of rows mapped to the pattern variable. When specified with the <code dir="ltr">FIRST</code> function, the offset is the number of rows from the first row, in ascending order. When specified with the <code dir="ltr">LAST</code> function, the offset is the number of rows from the last row in descending order. The default offset is 0.</p>
<p>For <code dir="ltr"><span class="codeinlineitalic">offset</span></code>, specify a non-negative integer. It must be a runtime constant (literal, bind variable, or expressions involving them), but not a column or subquery.</p>
<p>If you specify an <code dir="ltr"><span class="codeinlineitalic">offset</span></code> that is greater than or equal to the number of rows mapped to the pattern variable minus 1, then the function returns NULL.</p>
</li>
</ul>
<p>You can specify running or final semantics for the <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> functions as follows:</p>
<ul>
<li>
<p>The <code dir="ltr">MEASURES</code> clause supports running and final semantics. Specify <code dir="ltr">RUNNING</code> for running semantics. Specify <code dir="ltr">FINAL</code> for final semantics. The default is <code dir="ltr">RUNNING</code>.</p>
</li>
<li>
<p>The <code dir="ltr">DEFINE</code> clause supports only running semantics. Therefore, running semantics will be used whether you specify or omit <code dir="ltr">RUNNING</code>. You cannot specify <code dir="ltr">FINAL</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG9001" href="../DWHSG/pattern.htm#DWHSG9001"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on the <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> functions</p>
</li>
<li>
<p><a class="olink DWHSG9193" href="../DWHSG/pattern.htm#DWHSG9193"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on running and final semantics</p>
</li>
</ul>
</div>
</li>
</ul>
<p class="subhead1"><a id="BABFIFBC"></a><a id="SQLRF56489"></a><span class="italic">row_pattern_nav_physical</span></p>
<p>This clause lets you use the <code dir="ltr">PREV</code> and <code dir="ltr">NEXT</code> functions to navigate all rows in a row pattern partition using an optional physical offset.</p>
<ul>
<li>
<p>The <code dir="ltr">PREV</code> function returns the value of expression <code dir="ltr"><span class="codeinlineitalic">expr</span></code> when evaluated in the previous row in the partition. If there is no previous row in the partition, then the <code dir="ltr">PREV</code> function returns NULL.</p>
</li>
<li>
<p>The <code dir="ltr">NEXT</code> function returns the value of expression <code dir="ltr"><span class="codeinlineitalic">expr</span></code> when evaluated in the next row in the partition. If there is no next row in the partition, then the NEXT function returns NULL.</p>
</li>
<li>
<p>Use <code dir="ltr"><span class="codeinlineitalic">expr</span></code> to specify the expression to be evaluated. It must contain at least one row pattern column reference. If it contains more than one row pattern column reference, then all must refer to the same pattern variable.</p>
</li>
<li>
<p>Use the optional <code dir="ltr"><span class="codeinlineitalic">offset</span></code> to specify the physical offset within the partition. When specified with the <code dir="ltr">PREV</code> function, it is the number of rows before the current row. When specified with the <code dir="ltr">NEXT</code> function, it is the number of rows after the current row. The default is 1. If you specify an offset of 0, then the current row is evaluated.</p>
<p>For <code dir="ltr"><span class="codeinlineitalic">offset</span></code>, specify a non-negative integer. It must be a runtime constant (literal, bind variable, or expressions involving them), but not a column or subquery.</p>
</li>
</ul>
<p>The <code dir="ltr">PREV</code> and <code dir="ltr">NEXT</code> functions always use running semantics. Therefore, you cannot specify the <code dir="ltr">RUNNING</code> or <code dir="ltr">FINAL</code> keywords with this clause.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG8999" href="../DWHSG/pattern.htm#DWHSG8999"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on the <code dir="ltr">PREV</code> and <code dir="ltr">NEXT</code> functions</p>
</li>
<li>
<p><a class="olink DWHSG9193" href="../DWHSG/pattern.htm#DWHSG9193"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on running and final semantics</p>
</li>
</ul>
</div>
<p class="subhead1"><a id="BABDHEAH"></a><a id="SQLRF56519"></a><span class="italic">row_pattern_nav_compound</span></p>
<p>This clause lets you nest the <code dir="ltr"><span class="codeinlineitalic">row_pattern_nav_logical</span></code> clause within the <code dir="ltr"><span class="codeinlineitalic">row_pattern_nav_physical</span></code> clause. That is, it lets you nest the <code dir="ltr">FIRST</code> or <code dir="ltr">LAST</code> function within the <code dir="ltr">PREV</code> or <code dir="ltr">NEXT</code> function. The <code dir="ltr"><span class="codeinlineitalic">row_pattern_nav_logical</span></code> clause is evaluated first and then the result is supplied to the <code dir="ltr"><span class="codeinlineitalic">row_pattern_nav_physical</span></code> clause.</p>
<p>Refer to <a href="#BABHCBFE"><span class="xreftitleitalic"><span class="italic">row_pattern_nav_logical</span></span></a> and <a href="#BABFIFBC"><span class="xreftitleitalic"><span class="italic">row_pattern_nav_physical</span></span></a> for the full semantics of these clauses.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG9015" href="../DWHSG/pattern.htm#DWHSG9015"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on nesting the <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> functions within the <code dir="ltr">PREV</code> and <code dir="ltr">NEXT</code> functions</div>
<p class="subhead1"><a id="BABIDJGB"></a><a id="SQLRF56491"></a><span class="italic">row_pattern_aggregate_func</span></p>
<p>This clause lets you use an aggregate function in the expression for a row pattern measure column or in the condition that defines a primary pattern variable.</p>
<p>For <code dir="ltr"><span class="codeinlineitalic">aggregate_function</span></code>, specify any one of the <a href="functions019.htm#i82074">AVG</a>, <a href="functions046.htm#i82697">COUNT</a>, <a href="functions110.htm#i89072">MAX</a>, <a href="functions112.htm#i1280029">MIN</a>, or <a href="functions197.htm#i89126">SUM</a> functions. The <code dir="ltr">DISTINCT</code> keyword is not supported.</p>
<p>You can specify running or final semantics for aggregate functions as follows:</p>
<ul>
<li>
<p>The <code dir="ltr">MEASURES</code> clause supports running and final semantics. Specify <code dir="ltr">RUNNING</code> for running semantics. Specify <code dir="ltr">FINAL</code> for final semantics. The default is <code dir="ltr">RUNNING</code>.</p>
</li>
<li>
<p>The <code dir="ltr">DEFINE</code> clause supports only running semantics. Therefore, running semantics will be used whether you specify or omit <code dir="ltr">RUNNING</code>. You cannot specify <code dir="ltr">FINAL</code>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DWHSG8998" href="../DWHSG/pattern.htm#DWHSG8998"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on aggregate functions</p>
</li>
<li>
<p><a class="olink DWHSG9193" href="../DWHSG/pattern.htm#DWHSG9193"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information on running and final semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="i2066378"></a>Examples</p>
<p><a id="BABJFIDC"></a><a id="SQLRF55666"></a><span class="subhead3">Using a PL/SQL Function in the WITH Clause: Examples&nbsp;</span></p>
<p>The following example declares and defines a PL/SQL function <code dir="ltr">get_domain</code> in the <code dir="ltr">WITH</code> clause. The <code dir="ltr">get_domain</code> function returns the domain name from a URL string, assuming that the URL string has the &#34;<code dir="ltr">www</code>&#34; prefix immediately preceding the domain name, and the domain name is separated by dots on the left and right. The <code dir="ltr">SELECT</code> statement uses <code dir="ltr">get_domain</code> to find distinct catalog domain names from the <code dir="ltr">orders</code> table in the <code dir="ltr">oe</code> schema.</p>
<pre dir="ltr">WITH
 FUNCTION get_domain(url VARCHAR2) RETURN VARCHAR2 IS
   pos BINARY_INTEGER;
   len BINARY_INTEGER;
 BEGIN
   pos := INSTR(url, &#39;www.&#39;);
   len := INSTR(SUBSTR(url, pos + 4), &#39;.&#39;) - 1;
   RETURN SUBSTR(url, pos + 4, len);
 END;
SELECT DISTINCT get_domain(catalog_url)
  FROM product_information;
/
</pre>
<p><a id="i2129904"></a><a id="SQLRF55375"></a><span class="subhead3">Subquery Factoring: Example&nbsp;</span>The following statement creates the query names <code dir="ltr">dept_costs</code> and <code dir="ltr">avg_cost</code> for the initial query block containing a join, and then uses the query names in the body of the main query.</p>
<pre dir="ltr">WITH 
   dept_costs AS (
      SELECT department_name, SUM(salary) dept_total
         FROM employees e, departments d
         WHERE e.department_id = d.department_id
      GROUP BY department_name),
   avg_cost AS (
      SELECT SUM(dept_total)/COUNT(*) avg
      FROM dept_costs)
SELECT * FROM dept_costs
   WHERE dept_total &gt;
      (SELECT avg FROM avg_cost)
      ORDER BY department_name;

DEPARTMENT_NAME                DEPT_TOTAL
------------------------------ ----------
Sales                              304500
Shipping                           156400
</pre>
<p><a id="BABCDJDB"></a><a id="SQLRF55576"></a><span class="subhead3">Recursive Subquery Factoring: Examples&nbsp;</span>The following statement shows the employees who directly or indirectly report to employee 101 and their reporting level.</p>
<pre dir="ltr">WITH
  reports_to_101 (eid, emp_last, mgr_id, reportLevel) AS
  (
     SELECT employee_id, last_name, manager_id, 0 reportLevel
     FROM employees
     WHERE employee_id = 101
   UNION ALL
     SELECT e.employee_id, e.last_name, e.manager_id, reportLevel+1
     FROM reports_to_101 r, employees e
     WHERE r.eid = e.manager_id
  )
SELECT eid, emp_last, mgr_id, reportLevel
FROM reports_to_101
ORDER BY reportLevel, eid;

       EID EMP_LAST                      MGR_ID REPORTLEVEL
---------- ------------------------- ---------- -----------
       101 Kochhar                          100           0
       108 Greenberg                        101           1
       200 Whalen                           101           1
       203 Mavris                           101           1
       204 Baer                             101           1
       205 Higgins                          101           1
       109 Faviet                           108           2
       110 Chen                             108           2
       111 Sciarra                          108           2
       112 Urman                            108           2
       113 Popp                             108           2
       206 Gietz                            205           2
</pre>
<p>The following statement shows employees who directly or indirectly report to employee 101, their reporting level, and their management chain.</p>
<pre dir="ltr">WITH
  reports_to_101 (eid, emp_last, mgr_id, reportLevel, mgr_list) AS
  (
     SELECT employee_id, last_name, manager_id, 0 reportLevel,
            CAST(manager_id AS VARCHAR2(2000))
     FROM employees
     WHERE employee_id = 101
  UNION ALL
     SELECT e.employee_id, e.last_name, e.manager_id, reportLevel+1,
            CAST(mgr_list || &#39;,&#39; || manager_id AS VARCHAR2(2000))
     FROM reports_to_101 r, employees e
     WHERE r.eid = e.manager_id
  )
SELECT eid, emp_last, mgr_id, reportLevel, mgr_list
FROM reports_to_101
ORDER BY reportLevel, eid;

        EID EMP_LAST                      MGR_ID REPORTLEVEL MGR_LIST
 ---------- ------------------------- ---------- ----------- --------
       101 Kochhar                          100           0  100
       108 Greenberg                        101           1  100,101
       200 Whalen                           101           1  100,101
       203 Mavris                           101           1  100,101
       204 Baer                             101           1  100,101
       205 Higgins                          101           1  100,101
       109 Faviet                           108           2  100,101,108
       110 Chen                             108           2  100,101,108
       111 Sciarra                          108           2  100,101,108
       112 Urman                            108           2  100,101,108
       113 Popp                             108           2  100,101,108
       206 Gietz                            205           2  100,101,205
</pre>
<p>The following statement shows the employees who directly or indirectly report to employee 101 and their reporting level. It stops at reporting level 1.</p>
<pre dir="ltr">WITH
  reports_to_101 (eid, emp_last, mgr_id, reportLevel) AS
  (
    SELECT employee_id, last_name, manager_id, 0 reportLevel
    FROM employees
    WHERE employee_id = 101
  UNION ALL
    SELECT e.employee_id, e.last_name, e.manager_id, reportLevel+1
    FROM reports_to_101 r, employees e
    WHERE r.eid = e.manager_id
  )
SELECT eid, emp_last, mgr_id, reportLevel
FROM reports_to_101
WHERE reportLevel &lt;= 1
ORDER BY reportLevel, eid;

       EID EMP_LAST                      MGR_ID REPORTLEVEL
---------- ------------------------- ---------- -----------
       101 Kochhar                          100           0
       108 Greenberg                        101           1
       200 Whalen                           101           1
       203 Mavris                           101           1
       204 Baer                             101           1
       205 Higgins                          101           1
</pre>
<p>The following statement shows the entire organization, indenting for each level of management.</p>
<pre dir="ltr">WITH
  org_chart (eid, emp_last, mgr_id, reportLevel, salary, job_id) AS
  (
    SELECT employee_id, last_name, manager_id, 0 reportLevel, salary, job_id
    FROM employees
    WHERE manager_id is null
  UNION ALL
    SELECT e.employee_id, e.last_name, e.manager_id,
           r.reportLevel+1 reportLevel, e.salary, e.job_id
    FROM org_chart r, employees e
    WHERE r.eid = e.manager_id
  )
  SEARCH DEPTH FIRST BY emp_last SET order1
SELECT lpad(&#39; &#39;,2*reportLevel)||emp_last emp_name, eid, mgr_id, salary, job_id
FROM org_chart
ORDER BY order1;

EMP_NAME                    EID     MGR_ID     SALARY JOB_ID
-------------------- ---------- ---------- ---------- ----------
King                        100                 24000 AD_PRES
  Cambrault                 148        100      11000 SA_MAN
    Bates                   172        148       7300 SA_REP
    Bloom                   169        148      10000 SA_REP
    Fox                     170        148       9600 SA_REP
    Kumar                   173        148       6100 SA_REP
    Ozer                    168        148      11500 SA_REP
    Smith                   171        148       7400 SA_REP
  De Haan                   102        100      17000 AD_VP
    Hunold                  103        102       9000 IT_PROG
      Austin                105        103       4800 IT_PROG
      Ernst                 104        103       6000 IT_PROG
      Lorentz               107        103       4200 IT_PROG
      Pataballa             106        103       4800 IT_PROG
  Errazuriz                 147        100      12000 SA_MAN
    Ande                    166        147       6400 SA_REP
. . .
</pre>
<p>The following statement shows the entire organization, indenting for each level of management, with each level ordered by <code dir="ltr"><span class="codeinlineitalic">hire_date</span></code>. The value of <code dir="ltr"><span class="codeinlineitalic">is_cycle</span></code> is set to <code dir="ltr">Y</code> for any employee who has the same <code dir="ltr"><span class="codeinlineitalic">hire_date</span></code> as any manager above him in the management chain.</p>
<pre dir="ltr">WITH
  dup_hiredate (eid, emp_last, mgr_id, reportLevel, hire_date, job_id) AS
  (
    SELECT employee_id, last_name, manager_id, 0 reportLevel, hire_date, job_id
    FROM employees
    WHERE manager_id is null
  UNION ALL
    SELECT e.employee_id, e.last_name, e.manager_id,
           r.reportLevel+1 reportLevel, e.hire_date, e.job_id
    FROM dup_hiredate r, employees e
    WHERE r.eid = e.manager_id
  )
  SEARCH DEPTH FIRST BY hire_date SET order1
  CYCLE hire_date SET is_cycle TO &#39;Y&#39; DEFAULT &#39;N&#39;
SELECT lpad(&#39; &#39;,2*reportLevel)||emp_last emp_name, eid, mgr_id,
       hire_date, job_id, is_cycle
FROM dup_hiredate
ORDER BY order1;

EMP_NAME                    EID     MGR_ID HIRE_DATE JOB_ID     IS_CYCLE
-------------------- ---------- ---------- --------- ---------- --------
King                        100            17-JUN-03 AD_PRES           N
  De Haan                   102        100 13-JAN-01 AD_VP             N
    Hunold                  103        102 03-JAN-06 IT_PROG           N
      Austin                105        103 25-JUN-05 IT_PROG           N
. . .
  Kochhar                   101        100 21-SEP-05 AD_VP             N
    Mavris                  203        101 07-JUN-02 HR_REP            N
    Baer                    204        101 07-JUN-02 PR_REP            N
    Higgins                 205        101 07-JUN-02 AC_MGR            N
      <span class="bold">Gietz</span>                 <span class="bold">206</span>        <span class="bold">205</span> <span class="bold">07-JUN-02</span> <span class="bold">AC_ACCOUNT</span>        <span class="bold">Y</span>
    Greenberg               108        101 17-AUG-02 FI_MGR            N
      Faviet                109        108 16-AUG-02 FI_ACCOUNT        N
      Chen                  110        108 28-SEP-05 FI_ACCOUNT        N
. . .
</pre>
<p>The following statement counts the number of employees under each manager.</p>
<pre dir="ltr">WITH
  emp_count (eid, emp_last, mgr_id, mgrLevel, salary, cnt_employees) AS
  (
    SELECT employee_id, last_name, manager_id, 0 mgrLevel, salary, 0 cnt_employees
    FROM employees
  UNION ALL
    SELECT e.employee_id, e.last_name, e.manager_id,
           r.mgrLevel+1 mgrLevel, e.salary, 1 cnt_employees
    FROM emp_count r, employees e
    WHERE e.employee_id = r.mgr_id
  )
  SEARCH DEPTH FIRST BY emp_last SET order1
SELECT emp_last, eid, mgr_id, salary, sum(cnt_employees), max(mgrLevel) mgrLevel
FROM emp_count
GROUP BY emp_last, eid, mgr_id, salary
HAVING max(mgrLevel) &gt; 0
ORDER BY mgr_id NULLS FIRST, emp_last;

EMP_LAST                  EID     MGR_ID     SALARY SUM(CNT_EMPLOYEES)   MGRLEVEL
------------------ ---------- ---------- ---------- ------------------ ----------
King                      100                 24000                106          3
Cambrault                 148        100      11000                  7          2
De Haan                   102        100      17000                  5          2
Errazuriz                 147        100      12000                  6          1
Fripp                     121        100       8200                  8          1
Hartstein                 201        100      13000                  1          1
Kaufling                  122        100       7900                  8          1
. . .
</pre>
<p><a id="i2129937"></a><a id="SQLRF55376"></a><span class="subhead3">Simple Query Examples&nbsp;</span>The following statement selects rows from the <code dir="ltr">employees</code> table with the department number of 30:</p>
<pre dir="ltr">SELECT * 
   FROM employees 
   WHERE department_id = 30
   ORDER BY last_name;
</pre>
<p>The following statement selects the name, job, salary and department number of all employees except purchasing clerks from department number 30:</p>
<pre dir="ltr">SELECT last_name, job_id, salary, department_id 
   FROM employees 
   WHERE NOT (job_id = &#39;PU_CLERK&#39; AND department_id = 30)
   ORDER BY last_name; 
</pre>
<p>The following statement selects from subqueries in the <code dir="ltr">FROM</code> clause and for each department returns the total employees and salaries as a decimal value of all the departments:</p>
<pre dir="ltr">SELECT a.department_id &#34;Department&#34;,
   a.num_emp/b.total_count &#34;%_Employees&#34;,
   a.sal_sum/b.total_sal &#34;%_Salary&#34;
FROM
(SELECT department_id, COUNT(*) num_emp, SUM(salary) sal_sum
   FROM employees
   GROUP BY department_id) a,
(SELECT COUNT(*) total_count, SUM(salary) total_sal
   FROM employees) b
ORDER BY a.department_id;
</pre>
<p><a id="i2105152"></a><a id="SQLRF55377"></a><span class="subhead3">Selecting from a Partition: Example&nbsp;</span>You can select rows from a single partition of a partitioned table by specifying the keyword <code dir="ltr">PARTITION</code> in the <code dir="ltr">FROM</code> clause. This SQL statement assigns an alias for and retrieves rows from the <code dir="ltr">sales_q2_2000</code> partition of the sample table <code dir="ltr">sh.sales</code>:</p>
<pre dir="ltr">SELECT * FROM sales PARTITION (sales_q2_2000) s
   WHERE s.amount_sold &gt; 1500
   ORDER BY cust_id, time_id, channel_id;
</pre>
<p>The following example selects rows from the <code dir="ltr">oe.orders</code> table for orders earlier than a specified date:</p>
<pre dir="ltr">SELECT * FROM orders
   WHERE order_date &lt; TO_DATE(&#39;2006-06-15&#39;, &#39;YYYY-MM-DD&#39;);
</pre>
<p><a id="i2105143"></a><a id="SQLRF55378"></a><span class="subhead3">Selecting a Sample: Examples &nbsp;</span>The following query estimates the number of orders in the <code dir="ltr">oe.orders</code> table:</p>
<pre dir="ltr">SELECT COUNT(*) * 10 FROM orders SAMPLE (10);

COUNT(*)*10
-----------
         70
</pre>
<p>Because the query returns an estimate, the actual return value may differ from one query to the next.</p>
<pre dir="ltr">SELECT COUNT(*) * 10 FROM orders SAMPLE (10);

COUNT(*)*10
-----------
         80
</pre>
<p>The following query adds a seed value to the preceding query. Oracle Database always returns the same estimate given the same seed value:</p>
<pre dir="ltr">SELECT COUNT(*) * 10 FROM orders SAMPLE(10) SEED (1);

COUNT(*)*10
-----------
        130

SELECT COUNT(*) * 10 FROM orders SAMPLE(10) SEED(4);

COUNT(*)*10
-----------
        120

SELECT COUNT(*) * 10 FROM orders SAMPLE(10) SEED (1);

COUNT(*)*10
-----------
        130
</pre>
<p><a id="i2112847"></a><a id="SQLRF55379"></a><span class="subhead3">Using Flashback Queries: Example&nbsp;</span>The following statements show a current value from the sample table <code dir="ltr">hr.employees</code> and then change the value. The intervals used in these examples are very short for demonstration purposes. Time intervals in your own environment are likely to be larger.</p>
<pre dir="ltr">SELECT salary FROM employees
   WHERE last_name = &#39;Chung&#39;;
   
    SALARY
----------
      3800

UPDATE employees SET salary = 4000
   WHERE last_name = &#39;Chung&#39;;
1 row updated.

SELECT salary FROM employees
   WHERE last_name = &#39;Chung&#39;;

    SALARY
----------
      4000
</pre>
<p>To learn what the value was before the update, you can use the following Flashback Query:</p>
<pre dir="ltr">SELECT salary FROM employees
   AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL &#39;1&#39; MINUTE)
   WHERE last_name = &#39;Chung&#39;;
   
    SALARY
----------
      3800
</pre>
<p>To learn what the values were during a particular time period, you can use a version Flashback Query:</p>
<pre dir="ltr">SELECT salary FROM employees
  VERSIONS BETWEEN TIMESTAMP
    SYSTIMESTAMP - INTERVAL &#39;10&#39; MINUTE AND
    SYSTIMESTAMP - INTERVAL &#39;1&#39; MINUTE
  WHERE last_name = &#39;Chung&#39;;
</pre>
<p>To revert to the earlier value, use the Flashback Query as the subquery of another <code dir="ltr">UPDATE</code> statement:</p>
<pre dir="ltr">UPDATE employees SET salary =      
   (SELECT salary FROM employees
   AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL &#39;2&#39; MINUTE)
   WHERE last_name = &#39;Chung&#39;)
   WHERE last_name = &#39;Chung&#39;;
1 row updated.

SELECT salary FROM employees
   WHERE last_name = &#39;Chung&#39;;
   
    SALARY
----------
      3800
</pre>
<p><a id="i2066419"></a><a id="SQLRF55380"></a><span class="subhead3">Using the GROUP BY Clause: Examples&nbsp;</span>To return the minimum and maximum salaries for each department in the <code dir="ltr">employees</code> table, issue the following statement:</p>
<pre dir="ltr">SELECT department_id, MIN(salary), MAX (salary)
     FROM employees
     GROUP BY department_id
   ORDER BY department_id;
</pre>
<p>To return the minimum and maximum salaries for the clerks in each department, issue the following statement:</p>
<pre dir="ltr">SELECT department_id, MIN(salary), MAX (salary)
     FROM employees
     WHERE job_id = &#39;PU_CLERK&#39;
     GROUP BY department_id
   ORDER BY department_id;
</pre>
<p><a id="i2066443"></a><a id="SQLRF55381"></a><span class="subhead3">Using the GROUP BY CUBE Clause: Example&nbsp;</span>To return the number of employees and their average yearly salary across all possible combinations of department and job category, issue the following query on the sample tables <code dir="ltr">hr.employees</code> and <code dir="ltr">hr.departments</code>:</p>
<pre dir="ltr">SELECT DECODE(GROUPING(department_name), 1, &#39;All Departments&#39;,
      department_name) AS department_name,
   DECODE(GROUPING(job_id), 1, &#39;All Jobs&#39;, job_id) AS job_id,
   COUNT(*) &#34;Total Empl&#34;, AVG(salary) * 12 &#34;Average Sal&#34;
   FROM employees e, departments d
   WHERE d.department_id = e.department_id
   GROUP BY CUBE (department_name, job_id)
   ORDER BY department_name, job_id;

DEPARTMENT_NAME                JOB_ID     Total Empl Average Sal
------------------------------ ---------- ---------- -----------
Accounting                     AC_ACCOUNT          1       99600
Accounting                     AC_MGR              1      144000
Accounting                     All Jobs            2      121800
Administration                 AD_ASST             1       52800
. . .
Shipping                       ST_CLERK           20       33420
Shipping                       ST_MAN              5       87360
</pre>
<p><a id="i2091446"></a><a id="SQLRF55382"></a><span class="subhead3">Using the GROUPING SETS Clause: Example&nbsp;</span>The following example finds the sum of sales aggregated for three precisely specified groups:</p>
<ul>
<li>
<p><code dir="ltr">(channel_desc, calendar_month_desc, country_id)</code></p>
</li>
<li>
<p><code dir="ltr">(channel_desc, country_id)</code></p>
</li>
<li>
<p><code dir="ltr">(calendar_month_desc, country_id)</code></p>
</li>
</ul>
<p>Without the <code dir="ltr">GROUPING</code> <code dir="ltr">SETS</code> syntax, you would have to write less efficient queries with more complicated SQL. For example, you could run three separate queries and <code dir="ltr">UNION</code> them, or run a query with a <code dir="ltr">CUBE(channel_desc, calendar_month_desc, country_id)</code> operation and filter out five of the eight groups it would generate.</p>
<pre dir="ltr">SELECT channel_desc, calendar_month_desc, co.country_id,
      TO_CHAR(sum(amount_sold) , &#39;9,999,999,999&#39;) SALES$
   FROM sales, customers, times, channels, countries co
   WHERE sales.time_id=times.time_id 
      AND sales.cust_id=customers.cust_id 
      AND sales.channel_id= channels.channel_id 
      AND customers.country_id = co.country_id
      AND channels.channel_desc IN (&#39;Direct Sales&#39;, &#39;Internet&#39;) 
      AND times.calendar_month_desc IN (&#39;2000-09&#39;, &#39;2000-10&#39;)
      AND co.country_iso_code IN (&#39;UK&#39;, &#39;US&#39;)
  GROUP BY GROUPING SETS( 
      (channel_desc, calendar_month_desc, co.country_id), 
      (channel_desc, co.country_id), 
      (calendar_month_desc, co.country_id) );

CHANNEL_DESC         CALENDAR COUNTRY_ID     SALES$
-------------------- -------- ----------     ----------
Internet             2000-09       52790        124,224
Direct Sales         2000-09       52790        638,201
Internet             2000-10       52790        137,054
Direct Sales         2000-10       52790        682,297
                     2000-09       52790        762,425
                     2000-10       52790        819,351
Internet                           52790        261,278
Direct Sales                       52790      1,320,497
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The functions <a href="functions079.htm#i1002035">GROUP_ID</a>, <a href="functions080.htm#i77498">GROUPING</a>, and <a href="functions081.htm#i1001964">GROUPING_ID</a> for more information on those functions</div>
<p><a id="i2130004"></a><a id="SQLRF55383"></a><span class="subhead3">Hierarchical Query Examples&nbsp;</span>The following query with a <code dir="ltr">CONNECT</code> <code dir="ltr">BY</code> clause defines a hierarchical relationship in which the <code dir="ltr">employee_id</code> value of the parent row is equal to the <code dir="ltr">manager_id</code> value of the child row:</p>
<pre dir="ltr">SELECT last_name, employee_id, manager_id FROM employees
   CONNECT BY employee_id = manager_id
   ORDER BY last_name;
</pre>
<p>In the following <code dir="ltr">CONNECT</code> <code dir="ltr">BY</code> clause, the <code dir="ltr">PRIOR</code> operator applies only to the <code dir="ltr">employee_id</code> value. To evaluate this condition, the database evaluates <code dir="ltr">employee_id</code> values for the parent row and <code dir="ltr">manager_id</code>, <code dir="ltr">salary</code>, and <code dir="ltr">commission_pct</code> values for the child row:</p>
<pre dir="ltr">SELECT last_name, employee_id, manager_id FROM employees
   CONNECT BY PRIOR employee_id = manager_id
   AND salary &gt; commission_pct
   ORDER BY last_name; 
</pre>
<p>To qualify as a child row, a row must have a <code dir="ltr">manager_id</code> value equal to the <code dir="ltr">employee_id</code> value of the parent row and it must have a <code dir="ltr">salary</code> value greater than its <code dir="ltr">commission_pct</code> value.</p>
<p><a id="i2130020"></a><a id="SQLRF55384"></a><span class="subhead3">Using the HAVING Condition: Example&nbsp;</span>To return the minimum and maximum salaries for the employees in each department whose lowest salary is less than $5,000, issue the next statement:</p>
<pre dir="ltr">SELECT department_id, MIN(salary), MAX (salary)
   FROM employees
   GROUP BY department_id
   HAVING MIN(salary) &lt; 5000
   ORDER BY department_id;

DEPARTMENT_ID MIN(SALARY) MAX(SALARY)
------------- ----------- -----------
           10        4400        4400
           30        2500       11000
           50        2100        8200
           60        4200        9000
</pre>
<p>The following example uses a correlated subquery in a <code dir="ltr">HAVING</code> clause that eliminates from the result set any departments without managers and managers without departments:</p>
<pre dir="ltr">SELECT department_id, manager_id 
   FROM employees 
   GROUP BY department_id, manager_id HAVING (department_id, manager_id) IN
   (SELECT department_id, manager_id FROM employees x 
      WHERE x.department_id = employees.department_id)
   ORDER BY department_id;
</pre>
<p><a id="i2130036"></a><a id="SQLRF55385"></a><span class="subhead3">Using the ORDER BY Clause: Examples&nbsp;</span>To select all purchasing clerk records from <code dir="ltr">employees</code> and order the results by salary in descending order, issue the following statement:</p>
<pre dir="ltr">SELECT * 
   FROM employees
   WHERE job_id = &#39;PU_CLERK&#39; 
   ORDER BY salary DESC; 
</pre>
<p>To select information from <code dir="ltr">employees</code> ordered first by ascending department number and then by descending salary, issue the following statement:</p>
<pre dir="ltr">SELECT last_name, department_id, salary
   FROM employees
   ORDER BY department_id ASC, salary DESC, last_name; 
</pre>
<p>To select the same information as the previous <code dir="ltr">SELECT</code> and use the positional <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> notation, issue the following statement, which orders by ascending <code dir="ltr">department_id</code>, then descending <code dir="ltr">salary</code>, and finally alphabetically by <code dir="ltr">last_name</code>:</p>
<pre dir="ltr">SELECT last_name, department_id, salary 
   FROM employees 
   ORDER BY 2 ASC, 3 DESC, 1; 
</pre>
<p><a id="i2171160"></a><a id="SQLRF55386"></a><span class="subhead3">The MODEL clause: Examples&nbsp;</span>The view created below is based on the sample <code dir="ltr">sh</code> schema and is used by the example that follows.</p>
<pre dir="ltr">CREATE OR REPLACE VIEW sales_view_ref AS
  SELECT country_name country,
         prod_name prod,
         calendar_year year,
         SUM(amount_sold) sale,
         COUNT(amount_sold) cnt
    FROM sales,times,customers,countries,products
    WHERE sales.time_id = times.time_id
      AND sales.prod_id = products.prod_id
      AND sales.cust_id = customers.cust_id
      AND customers.country_id = countries.country_id
      AND ( customers.country_id = 52779
            OR customers.country_id = 52776 )
      AND ( prod_name = &#39;Standard Mouse&#39;
            OR prod_name = &#39;Mouse Pad&#39; )
    GROUP BY country_name,prod_name,calendar_year;

SELECT country, prod, year, sale
  FROM sales_view_ref
  ORDER BY country, prod, year;

COUNTRY       PROD                                         YEAR        SALE
----------    -----------------------------------      --------   ---------
France        Mouse Pad                                    1998     2509.42
France        Mouse Pad                                    1999     3678.69
France        Mouse Pad                                    2000     3000.72
France        Mouse Pad                                    2001     3269.09
France        Standard Mouse                               1998     2390.83
France        Standard Mouse                               1999     2280.45
France        Standard Mouse                               2000     1274.31
France        Standard Mouse                               2001     2164.54
Germany       Mouse Pad                                    1998     5827.87
Germany       Mouse Pad                                    1999     8346.44
Germany       Mouse Pad                                    2000     7375.46
Germany       Mouse Pad                                    2001     9535.08
Germany       Standard Mouse                               1998     7116.11
Germany       Standard Mouse                               1999     6263.14
Germany       Standard Mouse                               2000     2637.31
Germany       Standard Mouse                               2001     6456.13
 
16 rows selected.
</pre>
<p>The next example creates a multidimensional array from <code dir="ltr">sales_view_ref</code> with columns containing country, product, year, and sales. It also:</p>
<ul>
<li>
<p>Assigns the sum of the sales of the Mouse Pad for years 1999 and 2000 to the sales of the Mouse Pad for year 2001, if a row containing sales of the Mouse Pad for year 2001 exists.</p>
</li>
<li>
<p>Assigns the value of sales of the Standard Mouse for year 2001 to sales of the Standard Mouse for year 2002, creating a new row if a row containing sales of the Standard Mouse for year 2002 does not exist.</p>
</li>
</ul>
<pre dir="ltr">SELECT country,prod,year,s
  FROM sales_view_ref
  MODEL
    PARTITION BY (country)
    DIMENSION BY (prod, year)
    MEASURES (sale s)
    IGNORE NAV
    UNIQUE DIMENSION
    RULES UPSERT SEQUENTIAL ORDER
    (
      s[prod=&#39;Mouse Pad&#39;, year=2001] =
        s[&#39;Mouse Pad&#39;, 1999] + s[&#39;Mouse Pad&#39;, 2000],
      s[&#39;Standard Mouse&#39;, 2002] = s[&#39;Standard Mouse&#39;, 2001]
    )
  ORDER BY country, prod, year;
 
COUNTRY       PROD                                         YEAR        SALE
----------    -----------------------------------      --------   ---------
France        Mouse Pad                                    1998     2509.42
France        Mouse Pad                                    1999     3678.69
France        Mouse Pad                                    2000     3000.72
France        Mouse Pad                                    2001     6679.41
France        Standard Mouse                               1998     2390.83
France        Standard Mouse                               1999     2280.45
France        Standard Mouse                               2000     1274.31
France        Standard Mouse                               2001     2164.54
France        Standard Mouse                               2002     2164.54
Germany       Mouse Pad                                    1998     5827.87
Germany       Mouse Pad                                    1999     8346.44
Germany       Mouse Pad                                    2000     7375.46
Germany       Mouse Pad                                    2001     15721.9
Germany       Standard Mouse                               1998     7116.11
Germany       Standard Mouse                               1999     6263.14
Germany       Standard Mouse                               2000     2637.31
Germany       Standard Mouse                               2001     6456.13
Germany       Standard Mouse                               2002     6456.13

18 rows selected.
</pre>
<p>The first rule uses <code dir="ltr">UPDATE</code> behavior because symbolic referencing is used on the left-hand side of the rule. The rows represented by the left-hand side of the rule exist, so the measure columns are updated. If the rows did not exist, then no action would have been taken.</p>
<p>The second rule uses <code dir="ltr">UPSERT</code> behavior because positional referencing is used on the left-hand side and a single cell is referenced. The rows do not exist, so new rows are inserted and the related measure columns are updated. If the rows did exist, then the measure columns would have been updated.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG021" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG021"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for an expanded discussion and examples</div>
<p>The next example uses the same <code dir="ltr">sales_view_ref</code> view and the analytic function <code dir="ltr">SUM</code> to calculate a cumulative sum (<code dir="ltr">csum</code>) of sales per country and per year.</p>
<pre dir="ltr">SELECT country, year, sale, csum
   FROM 
   (SELECT country, year, SUM(sale) sale
    FROM sales_view_ref
    GROUP BY country, year
   )
   MODEL DIMENSION BY (country, year)
         MEASURES (sale, 0 csum) 
         RULES (csum[any, any]= 
                  SUM(sale) OVER (PARTITION BY country 
                                  ORDER BY year 
                                  ROWS UNBOUNDED PRECEDING) 
                )
   ORDER BY country, year;

COUNTRY               YEAR       SALE       CSUM
--------------- ---------- ---------- ----------
France                1998    4900.25    4900.25
France                1999    5959.14   10859.39
France                2000    4275.03   15134.42
France                2001    5433.63   20568.05
Germany               1998   12943.98   12943.98
Germany               1999   14609.58   27553.56
Germany               2000   10012.77   37566.33
Germany               2001   15991.21   53557.54
 
8 rows selected.
</pre>
<p><a id="BABEAACC"></a><a id="SQLRF55645"></a><span class="subhead3">Row Limiting: Examples&nbsp;</span></p>
<p>The following statement returns the 5 employees with the lowest <code dir="ltr">employee_id</code> values:</p>
<pre dir="ltr">SELECT employee_id, last_name
  FROM employees
  ORDER BY employee_id
  FETCH FIRST 5 ROWS ONLY;

EMPLOYEE_ID LAST_NAME
----------- -------------------------
        100 King
        101 Kochhar
        102 De Haan
        103 Hunold
        104 Ernst
</pre>
<p>The following statement returns the next 5 employees with the lowest <code dir="ltr">employee_id</code> values:</p>
<pre dir="ltr">SELECT employee_id, last_name
  FROM employees
  ORDER BY employee_id
  OFFSET 5 ROWS FETCH NEXT 5 ROWS ONLY;

EMPLOYEE_ID LAST_NAME
----------- -------------------------
        105 Austin
        106 Pataballa
        107 Lorentz
        108 Greenberg
        109 Faviet
</pre>
<p>The following statement returns the 5 percent of employees with the lowest salaries:</p>
<pre dir="ltr">SELECT employee_id, last_name, salary
  FROM employees
  ORDER BY salary
  FETCH FIRST 5 PERCENT ROWS ONLY;

EMPLOYEE_ID LAST_NAME                     SALARY
----------- ------------------------- ----------
        132 Olson                           2100
        128 Markle                          2200
        136 Philtanker                      2200
        127 Landry                          2400
        135 Gee                             2400
        119 Colmenares                      2500
</pre>
<p>Because <code dir="ltr">WITH</code> <code dir="ltr">TIES</code> is specified, the following statement returns the 5 percent of employees with the lowest salaries, plus all additional employees with the same salary as the last row fetched in the previous example:</p>
<pre dir="ltr">SELECT employee_id, last_name, salary
  FROM employees
  ORDER BY salary
  FETCH FIRST 5 PERCENT ROWS WITH TIES;

EMPLOYEE_ID LAST_NAME                     SALARY
----------- ------------------------- ----------
        132 Olson                           2100
        128 Markle                          2200
        136 Philtanker                      2200
        127 Landry                          2400
        135 Gee                             2400
        119 Colmenares                      2500
        131 Marlow                          2500
        140 Patel                           2500
        144 Vargas                          2500
        182 Sullivan                        2500
        191 Perkins                         2500
</pre>
<p><a id="i2130052"></a><a id="SQLRF55387"></a><span class="subhead3">Using the FOR UPDATE Clause: Examples&nbsp;</span>The following statement locks rows in the <code dir="ltr">employees</code> table with purchasing clerks located in Oxford, which has <code dir="ltr">location_id</code> 2500, and locks rows in the <code dir="ltr">departments</code> table with departments in Oxford that have purchasing clerks:</p>
<pre dir="ltr">SELECT e.employee_id, e.salary, e.commission_pct
   FROM employees e, departments d
   WHERE job_id = &#39;SA_REP&#39;
   AND e.department_id = d.department_id
   AND location_id = 2500
   ORDER BY e.employee_id
   FOR UPDATE;
</pre>
<p>The following statement locks only those rows in the <code dir="ltr">employees</code> table with purchasing clerks located in Oxford. No rows are locked in the <code dir="ltr">departments</code> table:</p>
<pre dir="ltr">SELECT e.employee_id, e.salary, e.commission_pct
   FROM employees e JOIN departments d
   USING (department_id)
   WHERE job_id = &#39;SA_REP&#39;
   AND location_id = 2500
   ORDER BY e.employee_id
   FOR UPDATE OF e.salary;
</pre>
<p><a id="i2066598"></a><a id="SQLRF55388"></a><span class="subhead3">Using the WITH CHECK OPTION Clause: Example&nbsp;</span>The following statement is legal even though the third value inserted violates the condition of the subquery <code dir="ltr"><span class="codeinlineitalic">where_clause</span></code>:</p>
<pre dir="ltr">INSERT INTO (SELECT department_id, department_name, location_id
   FROM departments WHERE location_id &lt; 2000)
   VALUES (9999, &#39;Entertainment&#39;, 2500);
</pre>
<p>However, the following statement is illegal because it contains the <code dir="ltr">WITH</code> <code dir="ltr">CHECK</code> <code dir="ltr">OPTION</code> clause:</p>
<pre dir="ltr">INSERT INTO (SELECT department_id, department_name, location_id
   FROM departments WHERE location_id &lt; 2000 WITH CHECK OPTION)
   VALUES (9999, &#39;Entertainment&#39;, 2500);
     *
ERROR at line 2:
ORA-01402: view WITH CHECK OPTION where-clause violation
</pre>
<p><a id="CHDFIIDD"></a><a id="SQLRF55389"></a><span class="subhead3">Using PIVOT and UNPIVOT: Examples<a id="sthref7472"></a><a id="sthref7473"></a>&nbsp;</span>The <code dir="ltr">oe.orders</code> table contains information about when an order was placed (<code dir="ltr">order_date</code>), how it was place (<code dir="ltr">order_mode</code>), and the total amount of the order (<code dir="ltr">order_total</code>), as well as other information. The following example shows how to use the <code dir="ltr">PIVOT</code> clause to pivot <code dir="ltr">order_mode</code> values into columns, aggregating <code dir="ltr">order_total</code> data in the process, to get yearly totals by order mode:</p>
<pre dir="ltr">CREATE TABLE pivot_table AS
SELECT * FROM
(SELECT EXTRACT(YEAR FROM order_date) year, order_mode, order_total FROM orders)
PIVOT
(SUM(order_total) FOR order_mode IN (&#39;direct&#39; AS Store, &#39;online&#39; AS Internet));

SELECT * FROM pivot_table ORDER BY year;

      YEAR      STORE   INTERNET
---------- ---------- ----------
      2004     5546.6
      2006   371895.5   100056.6
      2007  1274078.8  1271019.5
      2008   252108.3   393349.4
</pre>
<p>The <code dir="ltr">UNPIVOT</code> clause lets you rotate specified columns so that the input column headings are output as values of one or more descriptor columns, and the input column values are output as values of one or more measures columns. The first query that follows shows that nulls are excluded by default. The second query shows that you can include nulls using the <code dir="ltr">INCLUDE</code> <code dir="ltr">NULLS</code> clause.</p>
<pre dir="ltr">SELECT * FROM pivot_table
  UNPIVOT (yearly_total FOR order_mode IN (store AS &#39;direct&#39;,
           internet AS &#39;online&#39;))
  ORDER BY year, order_mode;

      YEAR ORDER_ YEARLY_TOTAL
---------- ------ ------------
      2004 direct       5546.6
      2006 direct     371895.5
      2006 online     100056.6
      2007 direct    1274078.8
      2007 online    1271019.5
      2008 direct     252108.3
      2008 online     393349.4

7 rows selected.

SELECT * FROM pivot_table
  UNPIVOT INCLUDE NULLS 
    (yearly_total FOR order_mode IN (store AS &#39;direct&#39;, internet AS &#39;online&#39;))
  ORDER BY year, order_mode;

      YEAR ORDER_ YEARLY_TOTAL
---------- ------ ------------
      2004 direct       5546.6
      2004 online
      2006 direct     371895.5
      2006 online     100056.6
      2007 direct    1274078.8
      2007 online    1271019.5
      2008 direct     252108.3
      2008 online     393349.4

8 rows selected.
</pre>
<p><a id="i2066611"></a><a id="SQLRF55390"></a><span class="subhead3">Using Join Queries: Examples&nbsp;</span>The following examples show various ways of joining tables in a query. In the first example, an equijoin returns the name and job of each employee and the number and name of the department in which the employee works:</p>
<pre dir="ltr">SELECT last_name, job_id, departments.department_id, department_name
   FROM employees, departments
   WHERE employees.department_id = departments.department_id
   ORDER BY last_name, job_id;

LAST_NAME           JOB_ID     DEPARTMENT_ID DEPARTMENT_NAME
------------------- ---------- ------------- ----------------------
Abel                 SA_REP               80 Sales
Ande                 SA_REP               80 Sales
Atkinson             ST_CLERK             50 Shipping
Austin               IT_PROG              60 IT
. . .
</pre>
<p>You must use a join to return this data because employee names and jobs are stored in a different table than department names. Oracle Database combines rows of the two tables according to this join condition:</p>
<pre dir="ltr">employees.department_id = departments.department_id 
</pre>
<p>The following equijoin returns the name, job, department number, and department name of all sales managers:</p>
<pre dir="ltr">SELECT last_name, job_id, departments.department_id, department_name
   FROM employees, departments
   WHERE employees.department_id = departments.department_id
   AND job_id = &#39;SA_MAN&#39;
   ORDER BY last_name;

LAST_NAME           JOB_ID     DEPARTMENT_ID DEPARTMENT_NAME
------------------- ---------- ------------- -----------------------
Cambrault           SA_MAN                80 Sales
Errazuriz           SA_MAN                80 Sales
Partners            SA_MAN                80 Sales
Russell             SA_MAN                80 Sales
Zlotkey             SA_MAN                80 Sales
</pre>
<p>This query is identical to the preceding example, except that it uses an additional <code dir="ltr"><span class="codeinlineitalic">where_clause</span></code> condition to return only rows with a <code dir="ltr">job</code> value of &#39;<code dir="ltr">SA_MAN</code>&#39;.</p>
<p><a id="i2130078"></a><a id="SQLRF55391"></a><span class="subhead3">Using Subqueries: Examples&nbsp;</span>To determine who works in the same department as employee &#39;<code dir="ltr">Lorentz</code>&#39;, issue the following statement:</p>
<pre dir="ltr">SELECT last_name, department_id FROM employees
   WHERE department_id =
     (SELECT department_id FROM employees
      WHERE last_name = &#39;Lorentz&#39;)
   ORDER BY last_name, department_id; 
</pre>
<p>To give all employees in the <code dir="ltr">employees</code> table a 10% raise if they have changed jobs&mdash;if they appear in the <code dir="ltr">job_history</code> table&mdash;issue the following statement:</p>
<pre dir="ltr">UPDATE employees 
    SET salary = salary * 1.1
    WHERE employee_id IN (SELECT employee_id FROM job_history);
</pre>
<p>To create a second version of the <code dir="ltr">departments</code> table <code dir="ltr">new_departments</code>, with only three of the columns of the original table, issue the following statement:</p>
<pre dir="ltr">CREATE TABLE new_departments 
   (department_id, department_name, location_id)
   AS SELECT department_id, department_name, location_id 
   FROM departments; 
</pre>
<p><a id="i2066652"></a><a id="SQLRF55392"></a><span class="subhead3">Using Self Joins: Example &nbsp;</span>The following query uses a self join to return the name of each employee along with the name of the employee&#39;s manager. A <code dir="ltr">WHERE</code> clause is added to shorten the output.</p>
<pre dir="ltr">SELECT e1.last_name||&#39; works for &#39;||e2.last_name 
   &#34;Employees and Their Managers&#34;
   FROM employees e1, employees e2 
   WHERE e1.manager_id = e2.employee_id
      AND e1.last_name LIKE &#39;R%&#39;
   ORDER BY e1.last_name;

Employees and Their Managers   
-------------------------------
Rajs works for Mourgos
Raphaely works for King
Rogers works for Kaufling
Russell works for King
</pre>
<p>The join condition for this query uses the aliases <code dir="ltr">e1</code> and <code dir="ltr">e2</code> for the sample table <code dir="ltr">employees</code>:</p>
<pre dir="ltr">e1.manager_id = e2.employee_id
</pre>
<p><a id="i2107296"></a><a id="SQLRF55393"></a><span class="subhead3">Using Outer Joins: Examples&nbsp;</span>The following example shows how a partitioned outer join fills data gaps in rows to facilitate analytic function specification and reliable report formatting. The example first creates a small data table to be used in the join:</p>
<pre dir="ltr">SELECT d.department_id, e.last_name
   FROM departments d LEFT OUTER JOIN employees e
   ON d.department_id = e.department_id
   ORDER BY d.department_id, e.last_name;
</pre>
<p>Users familiar with the traditional Oracle Database outer joins syntax will recognize the same query in this form:</p>
<pre dir="ltr">SELECT d.department_id, e.last_name
   FROM departments d, employees e
   WHERE d.department_id = e.department_id(+)
   ORDER BY d.department_id, e.last_name;
</pre>
<p>Oracle strongly recommends that you use the more flexible <code dir="ltr">FROM</code> clause join syntax shown in the former example.</p>
<p>The left outer join returns all departments, including those without any employees. The same statement with a right outer join returns all employees, including those not yet assigned to a department:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The employee Zeuss was added to the employees table for these examples, and is not part of the sample data.</div>
<pre dir="ltr">SELECT d.department_id, e.last_name
   FROM departments d RIGHT OUTER JOIN employees e
   ON d.department_id = e.department_id
   ORDER BY d.department_id, e.last_name;

DEPARTMENT_ID LAST_NAME
------------- -------------------------
. . .
          110 Gietz
          110 Higgins
              Grant
              Zeuss
</pre>
<p>It is not clear from this result whether employees Grant and Zeuss have <code dir="ltr">department_id</code> <code dir="ltr">NULL</code>, or whether their <code dir="ltr">department_id</code> is not in the <code dir="ltr">departments</code> table. To determine this requires a full outer join:</p>
<pre dir="ltr">SELECT d.department_id as d_dept_id, e.department_id as e_dept_id,
      e.last_name
   FROM departments d FULL OUTER JOIN employees e
   ON d.department_id = e.department_id
   ORDER BY d.department_id, e.last_name;

 D_DEPT_ID  E_DEPT_ID LAST_NAME
---------- ---------- -------------------------
  . . .
       110        110 Gietz
       110        110 Higgins
  . . .
       260
       270
                  999 Zeuss
                      Grant
</pre>
<p>Because the column names in this example are the same in both tables in the join, you can also use the common column feature by specifying the <code dir="ltr">USING</code> clause of the join syntax. The output is the same as for the preceding example except that the <code dir="ltr">USING</code> clause coalesces the two matching columns <code dir="ltr">department_id</code> into a single column output:</p>
<pre dir="ltr">SELECT department_id AS d_e_dept_id, e.last_name
   FROM departments d FULL OUTER JOIN employees e
   USING (department_id)
   ORDER BY department_id, e.last_name;

D_E_DEPT_ID LAST_NAME
----------- -------------------------
  . . .
        110 Higgins
        110 Gietz
  . . .
        260
        270
        999 Zeuss
            Grant
</pre>
<p><a id="i2177515"></a><a id="SQLRF55394"></a><span class="subhead3">Using Partitioned Outer Joins: Examples&nbsp;</span>The following example shows how a partitioned outer join fills in gaps in rows to facilitate analytic calculation specification and reliable report formatting. The example first creates and populates a simple table to be used in the join:</p>
<pre dir="ltr">CREATE TABLE inventory (time_id    DATE,
                        product    VARCHAR2(10),
                        quantity   NUMBER);

INSERT INTO inventory VALUES (TO_DATE(&#39;01/04/01&#39;, &#39;DD/MM/YY&#39;), &#39;bottle&#39;, 10);
INSERT INTO inventory VALUES (TO_DATE(&#39;06/04/01&#39;, &#39;DD/MM/YY&#39;), &#39;bottle&#39;, 10);
INSERT INTO inventory VALUES (TO_DATE(&#39;01/04/01&#39;, &#39;DD/MM/YY&#39;), &#39;can&#39;, 10);
INSERT INTO inventory VALUES (TO_DATE(&#39;04/04/01&#39;, &#39;DD/MM/YY&#39;), &#39;can&#39;, 10);

SELECT times.time_id, product, quantity FROM inventory 
   PARTITION BY  (product) 
   RIGHT OUTER JOIN times ON (times.time_id = inventory.time_id) 
   WHERE times.time_id BETWEEN TO_DATE(&#39;01/04/01&#39;, &#39;DD/MM/YY&#39;) 
      AND TO_DATE(&#39;06/04/01&#39;, &#39;DD/MM/YY&#39;) 
   ORDER BY  2,1; 

TIME_ID   PRODUCT      QUANTITY
--------- ---------- ----------
01-APR-01 bottle             10
02-APR-01 bottle
03-APR-01 bottle
04-APR-01 bottle
05-APR-01 bottle
06-APR-01 bottle             10
01-APR-01 can                10
02-APR-01 can
03-APR-01 can
04-APR-01 can                10
05-APR-01 can
06-APR-01 can

12 rows selected.
</pre>
<p>The data is now more dense along the time dimension for each partition of the product dimension. However, each of the newly added rows within each partition is null in the quantity column. It is more useful to see the nulls replaced by the preceding non-<code dir="ltr">NULL</code> value in time order. You can achieve this by applying the analytic function <code dir="ltr">LAST_VALUE</code> on top of the query result:</p>
<pre dir="ltr">SELECT time_id, product, LAST_VALUE(quantity IGNORE NULLS) 
   OVER (PARTITION BY product ORDER BY time_id) quantity 
   FROM ( SELECT times.time_id, product, quantity 
             FROM inventory PARTITION BY  (product) 
                RIGHT OUTER JOIN times ON (times.time_id = inventory.time_id) 
   WHERE times.time_id BETWEEN TO_DATE(&#39;01/04/01&#39;, &#39;DD/MM/YY&#39;) 
      AND TO_DATE(&#39;06/04/01&#39;, &#39;DD/MM/YY&#39;)) 
   ORDER BY  2,1; 

TIME_ID   PRODUCT      QUANTITY
--------- ---------- ----------
01-APR-01 bottle             10
02-APR-01 bottle             10
03-APR-01 bottle             10
04-APR-01 bottle             10
05-APR-01 bottle             10
06-APR-01 bottle             10
01-APR-01 can                10
02-APR-01 can                10
03-APR-01 can                10
04-APR-01 can                10
05-APR-01 can                10
06-APR-01 can                10

12 rows selected.
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG02013" href="../DWHSG/analysis.htm#DWHSG02013"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for an expanded discussion on filling gaps in time series calculations and examples of usage</div>
<p><a id="i2182875"></a><a id="SQLRF55395"></a><span class="subhead3">Using Antijoins: Example&nbsp;</span>The following example selects a list of employees who are not in a particular set of departments:</p>
<pre dir="ltr">SELECT * FROM employees 
   WHERE department_id NOT IN 
   (SELECT department_id FROM departments 
       WHERE location_id = 1700)
   ORDER BY last_name;
</pre>
<p><a id="i2166436"></a><a id="SQLRF55396"></a><span class="subhead3">Using Semijoins: Example&nbsp;</span>In the following example, only one row needs to be returned from the <code dir="ltr">departments</code> table, even though many rows in the <code dir="ltr">employees</code> table might match the subquery. If no index has been defined on the <code dir="ltr">salary</code> column in <code dir="ltr">employees</code>, then a semijoin can be used to improve query performance.</p>
<pre dir="ltr">SELECT * FROM departments 
   WHERE EXISTS 
   (SELECT * FROM employees 
       WHERE departments.department_id = employees.department_id 
       AND employees.salary &gt; 2500)
   ORDER BY department_name;
</pre>
<p><a id="BABDADCJ"></a><a id="SQLRF56416"></a><span class="subhead3">Using CROSS APPLY and OUTER APPLY Joins: Examples&nbsp;</span>The following statement uses the <code dir="ltr">CROSS</code> <code dir="ltr">APPLY</code> clause of the <code dir="ltr"><span class="codeinlineitalic">cross_outer_apply_clause</span></code>. The join returns only rows from the table on the left side of the join (<code dir="ltr">departments</code>) that produce a result from the inline view on the right side of the join. That is, the join returns only the departments that have at least one employee. The <code dir="ltr">WHERE</code> clause restricts the result set to include only the Marketing, Operations, and Public Relations departments. However, the Operations department is not included in the result set because it has no employees.</p>
<pre dir="ltr">SELECT d.department_name, v.employee_id, v.last_name
  FROM departments d CROSS APPLY (SELECT * FROM employees e
                                  WHERE e.department_id = d.department_id) v
  WHERE d.department_name IN (&#39;Marketing&#39;, &#39;Operations&#39;, &#39;Public Relations&#39;)
  ORDER BY d.department_name, v.employee_id;

DEPARTMENT_NAME                EMPLOYEE_ID LAST_NAME
------------------------------ ----------- -------------------------
Marketing                      201         Hartstein
Marketing                      202         Fay
Public Relations               204         Baer
</pre>
<p>The following statement uses the <code dir="ltr">OUTER</code> <code dir="ltr">APPLY</code> clause of the <code dir="ltr"><span class="codeinlineitalic">cross_outer_apply_clause</span></code>. The join returns all rows from the table on the left side of the join (<code dir="ltr">departments</code>) regardless of whether they produce a result from the inline view on the right side of the join. That is, the join returns all departments regardless of whether the departments have any employees. The <code dir="ltr">WHERE</code> clause restricts the result set to include only the Marketing, Operations, and Public Relations departments. The Operations department is included in the result set even though it has no employees.</p>
<pre dir="ltr">SELECT d.department_name, v.employee_id, v.last_name
  FROM departments d OUTER APPLY (SELECT * FROM employees e
                                  WHERE e.department_id = d.department_id) v
  WHERE d.department_name IN (&#39;Marketing&#39;, &#39;Operations&#39;, &#39;Public Relations&#39;)
  ORDER by d.department_name, v.employee_id;

DEPARTMENT_NAME                EMPLOYEE_ID LAST_NAME
------------------------------ ----------- -------------------------
Marketing                      201         Hartstein
Marketing                      202         Fay
Operations
Public Relations               204         Baer
</pre>
<p><a id="BABFDGIJ"></a><a id="SQLRF55646"></a><span class="subhead3">Using Lateral Inline Views: Example&nbsp;</span>The following example shows a join with two operands. The second operand is an inline view that specifies the first operand, table <code dir="ltr">e</code>, in the <code dir="ltr">WHERE</code> clause. This results in an error.</p>
<pre dir="ltr">SELECT * FROM employees e, (SELECT * FROM departments d
                            WHERE e.department_id = d.department_id);
ORA-00904: &#34;E&#34;.&#34;DEPARTMENT_ID&#34;: invalid identifier
</pre>
<p>The following example shows a join with two operands. The second operand is a lateral inline view that specifies the first operand, table <code dir="ltr">e</code>, in the <code dir="ltr">WHERE</code> clause and succeeds without an error.</p>
<pre dir="ltr">SELECT * FROM employees e, LATERAL(SELECT * FROM departments d
                                   WHERE e.department_id = d.department_id);
</pre>
<p><a id="i2071643"></a><a id="SQLRF55397"></a><span class="subhead3">Table Collections: Examples&nbsp;</span>You can perform DML operations on nested tables only if they are defined as columns of a table. Therefore, when the <code dir="ltr"><span class="codeinlineitalic">query_table_expr_clause</span></code> of an <code dir="ltr">INSERT</code>, <code dir="ltr">DELETE</code>, or <code dir="ltr">UPDATE</code> statement is a <code dir="ltr"><span class="codeinlineitalic">table_collection_expression</span></code>, the collection expression must be a subquery that uses the <code dir="ltr">TABLE</code> collection expression to select the nested table column of the table. The examples that follow are based on the following scenario:</p>
<p>Suppose the database contains a table <code dir="ltr">hr_info</code> with columns <code dir="ltr">department_id</code>, <code dir="ltr">location_id</code>, and <code dir="ltr">manager_id</code>, and a column of nested table type <code dir="ltr">people</code> which has <code dir="ltr">last_name</code>, <code dir="ltr">department_id</code>, and <code dir="ltr">salary</code> columns for all the employees of each respective manager:</p>
<pre dir="ltr">CREATE TYPE people_typ AS OBJECT (
   last_name      VARCHAR2(25),
   department_id  NUMBER(4),
   salary         NUMBER(8,2));
/
CREATE TYPE people_tab_typ AS TABLE OF people_typ;
/
CREATE TABLE hr_info (
   department_id   NUMBER(4),
   location_id     NUMBER(4),
   manager_id      NUMBER(6),
   people          people_tab_typ)
   NESTED TABLE people STORE AS people_stor_tab;

INSERT INTO hr_info VALUES (280, 1800, 999, people_tab_typ());
</pre>
<p>The following example inserts into the <code dir="ltr">people</code> nested table column of the <code dir="ltr">hr_info</code> table for department 280:</p>
<pre dir="ltr">INSERT INTO TABLE(SELECT h.people FROM hr_info h
   WHERE h.department_id = 280)
   VALUES (&#39;Smith&#39;, 280, 1750);
</pre>
<p>The next example updates the department 280 <code dir="ltr">people</code> nested table:</p>
<pre dir="ltr">UPDATE TABLE(SELECT h.people FROM hr_info h
   WHERE h.department_id = 280) p
   SET p.salary = p.salary + 100;
</pre>
<p>The next example deletes from the department 280 <code dir="ltr">people</code> nested table:</p>
<pre dir="ltr">DELETE TABLE(SELECT h.people FROM hr_info h
   WHERE h.department_id = 280) p
   WHERE p.salary &gt; 1700;
</pre>
<p><a id="i2071637"></a><a id="SQLRF55398"></a><span class="subhead3"><a id="sthref7474"></a><a id="sthref7475"></a>Collection Unnesting: Examples&nbsp;</span>To select data from a nested table column, use the <code dir="ltr">TABLE</code> collection expression to treat the nested table as columns of a table. This process is called <span class="bold">collection unnesting</span>.</p>
<p>You could get all the rows from <code dir="ltr">hr_info</code>, which was created in the preceding example, and all the rows from the <code dir="ltr">people</code> nested table column of <code dir="ltr">hr_info</code> using the following statement:</p>
<pre dir="ltr">SELECT t1.department_id, t2.* FROM hr_info t1, TABLE(t1.people) t2
   WHERE t2.department_id = t1.department_id;
</pre>
<p>Now suppose that <code dir="ltr">people</code> is not a nested table column of <code dir="ltr">hr_info</code>, but is instead a separate table with columns <code dir="ltr">last_name</code>, <code dir="ltr">department_id</code>, <code dir="ltr">address</code>, <code dir="ltr">hiredate</code>, and <code dir="ltr">salary</code>. You can extract the same rows as in the preceding example with this statement:</p>
<pre dir="ltr">SELECT t1.department_id, t2.* 
   FROM hr_info t1, TABLE(CAST(MULTISET(
      SELECT t3.last_name, t3.department_id, t3.salary 
         FROM people t3
      WHERE t3.department_id = t1.department_id)
      AS people_tab_typ)) t2;
</pre>
<p>Finally, suppose that <code dir="ltr">people</code> is neither a nested table column of table <code dir="ltr">hr_info</code> nor a table itself. Instead, you have created a function <code dir="ltr">people_func</code> that extracts from various sources the name, department, and salary of all employees. You can get the same information as in the preceding examples with the following query:</p>
<pre dir="ltr">SELECT t1.department_id, t2.* FROM hr_info t1, TABLE(CAST
   (people_func( ... ) AS people_tab_typ)) t2;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ00204" href="../ADOBJ/adobjcol.htm#ADOBJ00204"><span class="italic">Oracle Database Object-Relational Developer&#39;s Guide</span></a> for more examples of collection unnesting.</div>
<p><a id="i2130122"></a><a id="SQLRF55399"></a><span class="subhead3">Using the LEVEL Pseudocolumn: Examples&nbsp;</span>The following statement returns all employees in hierarchical order. The root row is defined to be the employee whose job is <code dir="ltr">AD_VP</code>. The child rows of a parent row are defined to be those who have the employee number of the parent row as their manager number.</p>
<pre dir="ltr">SELECT LPAD(&#39; &#39;,2*(LEVEL-1)) || last_name org_chart, 
        employee_id, manager_id, job_id
    FROM employees
    START WITH job_id = &#39;AD_VP&#39; 
    CONNECT BY PRIOR employee_id = manager_id; 

ORG_CHART          EMPLOYEE_ID MANAGER_ID JOB_ID
------------------ ----------- ---------- ----------
Kochhar                    101        100 AD_VP
  Greenberg                108        101 FI_MGR
    Faviet                 109        108 FI_ACCOUNT
    Chen                   110        108 FI_ACCOUNT
    Sciarra                111        108 FI_ACCOUNT
    Urman                  112        108 FI_ACCOUNT
    Popp                   113        108 FI_ACCOUNT
  Whalen                   200        101 AD_ASST
  Mavris                   203        101 HR_REP
  Baer                     204        101 PR_REP
  Higgins                  205        101 AC_MGR
    Gietz                  206        205 AC_ACCOUNT
De Haan                    102        100 AD_VP
  Hunold                   103        102 IT_PROG
    Ernst                  104        103 IT_PROG
    Austin                 105        103 IT_PROG
    Pataballa              106        103 IT_PROG
    Lorentz                107        103 IT_PROG
</pre>
<p>The following statement is similar to the previous one, except that it does not select employees with the job <code dir="ltr">FI_MGR</code>.</p>
<pre dir="ltr">SELECT LPAD(&#39; &#39;,2*(LEVEL-1)) || last_name org_chart, 
        employee_id, manager_id, job_id
    FROM employees
    WHERE job_id != &#39;FI_MGR&#39;
    START WITH job_id = &#39;AD_VP&#39; 
    CONNECT BY PRIOR employee_id = manager_id; 

ORG_CHART          EMPLOYEE_ID MANAGER_ID JOB_ID
------------------ ----------- ---------- ----------
Kochhar                    101        100 AD_VP
    Faviet                 109        108 FI_ACCOUNT
    Chen                   110        108 FI_ACCOUNT
    Sciarra                111        108 FI_ACCOUNT
    Urman                  112        108 FI_ACCOUNT
    Popp                   113        108 FI_ACCOUNT
  Whalen                   200        101 AD_ASST
  Mavris                   203        101 HR_REP
  Baer                     204        101 PR_REP
  Higgins                  205        101 AC_MGR
    Gietz                  206        205 AC_ACCOUNT
De Haan                    102        100 AD_VP
  Hunold                   103        102 IT_PROG
    Ernst                  104        103 IT_PROG
    Austin                 105        103 IT_PROG
    Pataballa              106        103 IT_PROG
    Lorentz                107        103 IT_PROG

</pre>
<p>Oracle Database does not return the manager <code dir="ltr">Greenberg</code>, although it does return employees who are managed by <code dir="ltr">Greenberg</code>.</p>
<p>The following statement is similar to the first one, except that it uses the <code dir="ltr">LEVEL</code> pseudocolumn to select only the first two levels of the management hierarchy:</p>
<pre dir="ltr">SELECT LPAD(&#39; &#39;,2*(LEVEL-1)) || last_name org_chart, 
employee_id, manager_id, job_id 
    FROM employees
    START WITH job_id = &#39;AD_PRES&#39; 
    CONNECT BY PRIOR employee_id = manager_id AND LEVEL &lt;= 2; 

ORG_CHART          EMPLOYEE_ID MANAGER_ID JOB_ID
------------------ ----------- ---------- ----------
King                       100            AD_PRES
  Kochhar                  101        100 AD_VP
  De Haan                  102        100 AD_VP
  Raphaely                 114        100 PU_MAN
  Weiss                    120        100 ST_MAN
  Fripp                    121        100 ST_MAN
  Kaufling                 122        100 ST_MAN
  Vollman                  123        100 ST_MAN
  Mourgos                  124        100 ST_MAN
  Russell                  145        100 SA_MAN
  Partners                 146        100 SA_MAN
  Errazuriz                147        100 SA_MAN
  Cambrault                148        100 SA_MAN
  Zlotkey                  149        100 SA_MAN
  Hartstein                201        100 MK_MAN
</pre>
<p><a id="i2130133"></a><a id="SQLRF55400"></a><span class="subhead3">Using Distributed Queries: Example &nbsp;</span>This example shows a query that joins the <code dir="ltr">departments</code> table on the local database with the <code dir="ltr">employees</code> table on the <code dir="ltr">remote</code> database:</p>
<pre dir="ltr">SELECT last_name, department_name 
   FROM employees@remote, departments
   WHERE employees.department_id = departments.department_id; 
</pre>
<p><a id="i2066912"></a><a id="SQLRF55401"></a><span class="subhead3">Using Correlated Subqueries: Examples&nbsp;</span>The following examples show the general syntax of a correlated subquery:</p>
<pre dir="ltr">SELECT <span class="italic">select_list</span> 
    FROM <span class="italic">table1</span> <span class="italic">t_alias1</span> 
    WHERE <span class="italic">expr</span> <span class="italic">operator</span> 
        (SELECT <span class="italic">column_list</span> 
            FROM <span class="italic">table2</span> <span class="italic">t_alias2</span> 
            WHERE <span class="italic">t_alias1</span>.<span class="italic">column</span> 
               operator <span class="italic">t_alias2</span>.<span class="italic">column</span>); 

UPDATE <span class="italic">table1</span> <span class="italic">t_alias1</span> 
    SET <span class="italic">column</span> = 
        (SELECT <span class="italic">expr</span> 
            FROM <span class="italic">table2</span> <span class="italic">t_alias2</span> 
            WHERE <span class="italic">t_alias1</span>.<span class="italic">column</span> = <span class="italic">t_alias2</span>.<span class="italic">column</span>); 

DELETE FROM <span class="italic">table1</span> <span class="italic">t_alias1</span> 
    WHERE <span class="italic">column</span> <span class="italic">operator</span> 
        (SELECT <span class="italic">expr</span> 
            FROM <span class="italic">table2</span> <span class="italic">t_alias2</span> 
            WHERE <span class="italic">t_alias1</span>.<span class="italic">column</span> = <span class="italic">t_alias2</span>.<span class="italic">column</span>); 
</pre>
<p>The following statement returns data about employees whose salaries exceed their department average. The following statement assigns an alias to <code dir="ltr">employees</code>, the table containing the salary information, and then uses the alias in a correlated subquery:</p>
<pre dir="ltr">SELECT department_id, last_name, salary 
   FROM employees x 
   WHERE salary &gt; (SELECT AVG(salary) 
      FROM employees 
      WHERE x.department_id = department_id) 
   ORDER BY department_id; 
</pre>
<p>For each row of the <code dir="ltr">employees</code> table, the parent query uses the correlated subquery to compute the average salary for members of the same department. The correlated subquery performs the following steps for each row of the <code dir="ltr">employees</code> table:</p>
<ol>
<li>
<p>The <code dir="ltr">department_id</code> of the row is determined.</p>
</li>
<li>
<p>The <code dir="ltr">department_id</code> is then used to evaluate the parent query.</p>
</li>
<li>
<p>If the salary in that row is greater than the average salary of the departments of that row, then the row is returned.</p>
</li>
</ol>
<p>The subquery is evaluated once for each row of the <code dir="ltr">employees</code> table.</p>
<p><a id="i2130183"></a><a id="SQLRF55402"></a><span class="subhead3">Selecting from the DUAL Table: Example &nbsp;</span>The following statement returns the current date:</p>
<pre dir="ltr">SELECT SYSDATE FROM DUAL; 
</pre>
<p>You could select <code dir="ltr">SYSDATE</code> from the <code dir="ltr">employees</code> table, but the database would return 14 rows of the same <code dir="ltr">SYSDATE</code>, one for every row of the <code dir="ltr">employees</code> table. Selecting from <code dir="ltr">DUAL</code> is more convenient.</p>
<p><a id="i2130199"></a><a id="SQLRF55403"></a><span class="subhead3">Selecting Sequence Values: Examples &nbsp;</span>The following statement increments the <code dir="ltr">employees_seq</code> sequence and returns the new value:</p>
<pre dir="ltr">SELECT employees_seq.nextval 
    FROM DUAL; 
</pre>
<p>The following statement selects the current value of <code dir="ltr">employees_seq</code>:</p>
<pre dir="ltr">SELECT employees_seq.currval 
    FROM DUAL; 
</pre>
<p><a id="BABJHHDD"></a><a id="SQLRF56520"></a><span class="subhead3">Row Pattern Matching: Example&nbsp;</span>This example uses row pattern matching to query stock price data. The following statements create table <code dir="ltr">Ticker</code> and inserts stock price data into the table:</p>
<pre dir="ltr">CREATE TABLE Ticker (SYMBOL VARCHAR2(10), tstamp DATE, price NUMBER);

INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;01-Apr-11&#39;, 12);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;02-Apr-11&#39;, 17);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;03-Apr-11&#39;, 19);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;04-Apr-11&#39;, 21);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;05-Apr-11&#39;, 25);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;06-Apr-11&#39;, 12);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;07-Apr-11&#39;, 15);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;08-Apr-11&#39;, 20);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;09-Apr-11&#39;, 24);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;10-Apr-11&#39;, 25);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;11-Apr-11&#39;, 19);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;12-Apr-11&#39;, 15);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;13-Apr-11&#39;, 25);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;14-Apr-11&#39;, 25);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;15-Apr-11&#39;, 14);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;16-Apr-11&#39;, 12);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;17-Apr-11&#39;, 14);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;18-Apr-11&#39;, 24);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;19-Apr-11&#39;, 23);
INSERT INTO Ticker VALUES(&#39;ACME&#39;, &#39;20-Apr-11&#39;, 22);
</pre>
<p>The following query uses row pattern matching to find all cases where stock prices dipped to a bottom price and then rose. This is generally called a V-shape. The resulting output contains only three rows because the query specifies <code dir="ltr">ONE</code> <code dir="ltr">ROW</code> <code dir="ltr">PER</code> <code dir="ltr">MATCH</code>, and three matches were found.</p>
<pre dir="ltr">SELECT *
FROM Ticker MATCH_RECOGNIZE (
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES STRT.tstamp AS start_tstamp,
              LAST(DOWN.tstamp) AS bottom_tstamp,
              LAST(UP.tstamp) AS end_tstamp
     ONE ROW PER MATCH
     AFTER MATCH SKIP TO LAST UP
     PATTERN (STRT DOWN+ UP+)
     DEFINE
        DOWN AS DOWN.price &lt; PREV(DOWN.price),
        UP AS UP.price &gt; PREV(UP.price)
     ) MR
ORDER BY MR.symbol, MR.start_tstamp;

SYMBOL     START_TST BOTTOM_TS END_TSTAM
---------- --------- --------- ---------
ACME       05-APR-11 06-APR-11 10-APR-11
ACME       10-APR-11 12-APR-11 13-APR-11
ACME       14-APR-11 16-APR-11 18-APR-11
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5862">
<tr>
<td class="cellalignment5869">
<table class="cellalignment5867">
<tr>
<td class="cellalignment5866"><a href="statements_10001.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5866"><a href="statements_10003.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2017,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5871">
<table class="cellalignment5865">
<tr>
<td class="cellalignment5866"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5866"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5866"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5866"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5866"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5866"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>