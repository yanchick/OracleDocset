<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-52"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/PSBTREE%3A%20Extensible%20Indexing%20Example"></a><title>PSBTREE: Extensible Indexing Example</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="dcterms.created" content="2017-06-09T01:57:02Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Data Cartridge Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E15882-06"/>
<meta name="dcterms.isVersionOf" content="ADDCI"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pwr_example.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pipelined_example.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E15882-06.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF"></a> <span id="PAGE" style="display:none;">23/33</span> <!-- End Header -->
<a id="ADDCI3160"></a>
<h1 id="ADDCI-GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF" class="sect1"><span class="enumeration_chapter">16</span> PSBTREE: Extensible Indexing Example</h1>
<div>
<p>Consider an extensible indexing example, with C-language implementation of <code class="codeph">ODCIIndex</code> interface routines.</p>
</div>
<a id="ADDCI4877"></a>
<div class="props_rev_3"><a id="GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D"></a>
<h2 id="ADDCI-GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D" class="sect2">About the PSBTREE Example</h2>
<div>
<div class="section">
<p>Consider how to implement the extensible indexing interface routines in C. The example&#39;s focus is on topics that are common to all implementations; it does not expose domain-specific details.</p>
<p>The code for the example is in the demo directory, in the file <code class="codeph">extdemo6.sql</code>. It extends an earlier example (<code class="codeph">extdemo2.sql</code>, also in demo directory) by adding to the indextype support for <a id="d55802e116" class="indexterm-anchor"></a>local domain indexes on range partitioned tables.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADDCI4878"></a>
<div class="props_rev_3"><a id="GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE"></a>
<h2 id="ADDCI-GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE" class="sect2">Design of the Indextype</h2>
<div>
<p>The <a id="d55802e172" class="indexterm-anchor"></a>indextype implemented here, called <code class="codeph">PSBtree,</code> operates like a b-tree index. It supports three user-defined operators: <code class="codeph">eq</code> (equals), <code class="codeph">lt</code> (less than), and <code class="codeph">gt</code> (greater than). These operators operate on operands of <code class="codeph">VARCHAR2</code> data type.</p>
<p>The index data consists of records of the form <code class="codeph">&lt;key, rid&gt;</code> where <code class="codeph">key</code> is the value of the indexed column and <code class="codeph">rid</code> is the row identifier of the corresponding row. To simplify the implementation of the indextype, the index data is stored in an system-partitioned table.</p>
<p>When an index is a system-managed local domain index, one partition in a system-partitioned table is created for each partition to store the index data for that partition. Thus, the index manipulation routines merely translate operations on the <code class="codeph">PSBtree</code> into operations on the table partition that stores the index data.</p>
<p>When a user creates a <code class="codeph">PSBtree</code> index (a local index), <code class="codeph">n</code> table partitions are created consisting of the indexed column and a <code class="codeph">rowid</code> column, where <code class="codeph">n</code> is the number of partitions in the base table. Inserts into the base table cause appropriate insertions into the affected index table partition. Deletes and updates are handled similarly. When the <code class="codeph">PSBtree</code> is queried based on a user-defined operator (one of <code class="codeph">gt</code>, <code class="codeph">lt</code> and <code class="codeph">eq</code>), an appropriate query is issued against the index table partitions to retrieve all the satisfying rows. Appropriate partition pruning occurs, and only the index table partitions that correspond to the relevant, or &#34;interesting&#34;, partitions are accessed.</p>
</div>
</div>
<a id="ADDCI4879"></a>
<div class="props_rev_3"><a id="GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F"></a>
<h2 id="ADDCI-GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F" class="sect2">Implementing Operators</h2>
<div>
<p>The <code class="codeph">PSBtree</code> indextype supports three operators: <code class="codeph">eq</code>, <code class="codeph">gt</code> and <code class="codeph">lt</code>. Each operator has a corresponding functional implementation.</p>
</div>
<a id="ADDCI4880"></a>
<div class="props_rev_3"><a id="GUID-72B9F965-1889-44D6-A0E7-27868DAAF155"></a>
<h3 id="ADDCI-GUID-72B9F965-1889-44D6-A0E7-27868DAAF155" class="sect3">Functional Implementations</h3>
<div>
<p>Consider the functional implementation of comparison operators. The <a href="psbtree_example.htm#GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B">Implementing the EQUALS Operator</a> section explains how to implement <code class="codeph">eq</code> (equals), the <a href="psbtree_example.htm#GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF">Implementing the LESS THAN Operator</a> section explains how to implement <code class="codeph">lt</code> (less than), and the <a href="psbtree_example.htm#GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242">Implementing the GREATER THAN Operator</a> section explains how to implement <code class="codeph">gt</code> (greater than) operators.</p>
</div>
<a id="CACFGDEF"></a>
<div class="props_rev_3"><a id="GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B"></a>
<h4 id="ADDCI-GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B" class="sect4">Implementing the EQUALS Operator</h4>
<div>
<div class="section">
<p>The functional implementation for <code class="codeph">eq</code> is provided by a function (<code class="codeph">bt_eq</code>) that takes in two <code class="codeph">VARCHAR2</code> parameters and returns <code class="codeph">1</code> if they are equal and <code class="codeph">0</code> otherwise.</p>
<pre dir="ltr">CREATE FUNCTION bt_eq(a VARCHAR2, b VARCHAR2) RETURN NUMBER AS
BEGIN 
  IF a = b then
    RETURN 1;
  ELSE
    RETURN 0;
  END IF;
END;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACBEEIH"></a>
<div class="props_rev_3"><a id="GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF"></a>
<h4 id="ADDCI-GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF" class="sect4">Implementing the LESS THAN Operator</h4>
<div>
<div class="section">
<p>The functional implementation for <code class="codeph">lt</code> is provided by a function (<code class="codeph">bt_lt</code>) that takes in two <code class="codeph">VARCHAR2</code> parameters and returns <code class="codeph">1</code> if the first parameter is less than the second, <code class="codeph">0</code> otherwise.</p>
<pre dir="ltr">CREATE FUNCTION bt_lt(a VARCHAR2, b VARCHAR2) RETURN NUMBER AS
BEGIN 
  IF a &lt; b then
    RETURN 1;
  ELSE
    RETURN 0;
  END IF;
END;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACDGGHF"></a>
<div class="props_rev_3"><a id="GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242"></a>
<h4 id="ADDCI-GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242" class="sect4">Implementing the GREATER THAN Operator</h4>
<div>
<div class="section">
<p>The functional implementation for <code class="codeph">gt</code> is provided by a function (<code class="codeph">bt_gt</code>) that takes in two <code class="codeph">VARCHAR2</code> parameters and returns <code class="codeph">1</code> if the first parameter is greater than the second, <code class="codeph">0</code> otherwise.</p>
<pre dir="ltr">CREATE FUNCTION bt_gt(a VARCHAR2, b VARCHAR2) RETURN NUMBER AS
BEGIN 
  IF a &gt; b then
    RETURN 1;
  ELSE
    RETURN 0;
  END IF;
END;
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADDCI4885"></a><a id="ADDCI4886"></a><a id="ADDCI4887"></a><a id="ADDCI4884"></a>
<div class="props_rev_3"><a id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B"></a>
<h3 id="ADDCI-GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B" class="sect3">Operators</h3>
<div>
<p>To create the operator, you must specify the signature of the operator along with its return type and its functional implementation. <a href="psbtree_example.htm#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACGHFEC">Example 15-1</a> shows how to create <code class="codeph">eq</code> (equals), <a href="psbtree_example.htm#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACDBEEI">Example 15-2</a> shows how to create <code class="codeph">lt</code> (less than), and <a href="psbtree_example.htm#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACHCAHE">Example 15-3</a> shows how to create <code class="codeph">gt</code> (greater than) operators.</p>
<div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACGHFEC">
<p class="titleinexample">Example 15-1 Creating the EQUALS Operator</p>
<pre dir="ltr">CREATE OPERATOR eq 
BINDING (VARCHAR2, VARCHAR2) RETURN NUMBER 
USING bt_eq;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACDBEEI">
<p class="titleinexample">Example 15-2 Creating the LESS THAN Operator</p>
<pre dir="ltr">CREATE OPERATOR lt 
BINDING (VARCHAR2, VARCHAR2) RETURN NUMBER 
USING bt_lt;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACHCAHE">
<p class="titleinexample">Example 15-3 Creating the GREATER THAN Operator</p>
<pre dir="ltr">CREATE OPERATOR gt 
BINDING (VARCHAR2, VARCHAR2) RETURN NUMBER 
USING bt_gt;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADDCI4888"></a>
<div class="props_rev_3"><a id="GUID-F76F035E-4432-4555-9039-2E66E064D67E"></a>
<h2 id="ADDCI-GUID-F76F035E-4432-4555-9039-2E66E064D67E" class="sect2">Implementing the ODCIIndex Interfaces</h2>
<div>
<p>To implement the <code class="codeph">PSBTREE</code>, you must implement the <code class="codeph">ODCIIndex</code><span class="italic"><code class="codeph">XXX</code></span><code class="codeph">()</code> routines. You can implement the index routines in any language supported by Oracle. This discussion implements the <a href="ext_idx_ref.htm#GUID-28AC1C1B-6B6B-446F-A6C9-EEF4A4842D5F">ODCIGetInterfaces()</a> routine in the C programming language. Note that these require advance setup, such as creating a library object, <code class="codeph">extdemo6l</code>, for your compiled C code.</p>
</div>
<a id="ADDCI4890"></a><a id="ADDCI4889"></a>
<div class="props_rev_3"><a id="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1"></a>
<h3 id="ADDCI-GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1" class="sect3">Defining an Implementation Type for PSBTREE</h3>
<div>
<div class="section">
<p>Define an implementation type that implements the <code class="codeph">ODCIIndex</code> interface routines, as demonstrated in <a href="psbtree_example.htm#GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1__CACCEJJA">Example 15-4</a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1__CACCEJJA">
<p class="titleinexample">Example 15-4 Creating a PSBTREE Index Type</p>
<pre dir="ltr">CREATE TYPE psbtree_im AS OBJECT
(
  scanctx RAW(4),
  STATIC FUNCTION ODCIGetInterfaces(ifclist OUT SYS.ODCIObjectList)
    RETURN NUMBER,
  STATIC FUNCTION ODCIIndexCreate (ia SYS.ODCIIndexInfo, parms VARCHAR2,
    env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIIndexAlter (ia sys.ODCIIndexInfo, 
    parms IN OUT VARCHAR2, altopt number, env sys.ODCIEnv) RETURN NUMBER, 
  STATIC FUNCTION ODCIIndexDrop(ia SYS.ODCIIndexInfo, env SYS.ODCIEnv) 
    RETURN NUMBER,
  STATIC FUNCTION ODCIIndexExchangePartition(ia SYS.ODCIIndexInfo,
    ia1 SYS.ODCIIndexInfo, env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIIndexUpdPartMetadata(ia sys.ODCIIndexInfo, 
    palist sys.ODCIPartInfoList, env sys.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIIndexExchangePartition (ia sys.ODCIIndexInfo,
    ia1 sys.ODCIIndexInfo, env sys.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIIndexInsert(ia SYS.ODCIIndexInfo, rid VARCHAR2,
    newval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIIndexDelete(ia SYS.ODCIIndexInfo, rid VARCHAR2,
    oldval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIIndexUpdate(ia SYS.ODCIIndexInfo, rid VARCHAR2,
    oldval VARCHAR2, newval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIIndexStart(sctx IN OUT psbtree_im, ia SYS.ODCIIndexInfo,
    op SYS.ODCIPredInfo, qi sys.ODCIQueryInfo, strt number, stop number,
    cmpval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
  MEMBER FUNCTION ODCIIndexFetch(nrows NUMBER, rids OUT SYS.ODCIridlist,
    env SYS.ODCIEnv) RETURN NUMBER,
  MEMBER FUNCTION ODCIIndexClose(env SYS.ODCIEnv) RETURN NUMBER
);
/
SHOW ERRORS
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADDCI4892"></a><a id="ADDCI4891"></a>
<div class="props_rev_3"><a id="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8"></a>
<h3 id="ADDCI-GUID-2616416C-EC74-41FD-B435-7956E4CB49E8" class="sect3">Creating the Implementation Type Body</h3>
<div>
<div class="section">
<p>Define the implementation type body, as demonstrated in <a href="psbtree_example.htm#GUID-2616416C-EC74-41FD-B435-7956E4CB49E8__CACEJJHI">Example 15-5</a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8__CACEJJHI">
<p class="titleinexample">Example 15-5 Creating the Implementation Body for PBSTREE</p>
<pre dir="ltr">CREATE OR REPLACE TYPE BODY psbtree_im IS 
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADDCI4893"></a>
<div class="props_rev_3"><a id="GUID-385BF144-F676-468E-A9A6-7633E0939A1A"></a>
<h3 id="ADDCI-GUID-385BF144-F676-468E-A9A6-7633E0939A1A" class="sect3">Defining PL/SQL Routines in the Implementation Body</h3>
<div>
<div class="section">
<p>Consider how to implement the index definition routines in PL/SQL.</p>
</div>
<!-- class="section" --></div>
<a id="ADDCI4894"></a>
<div class="props_rev_3"><a id="GUID-CD482284-5973-4954-9086-DAFD9E872FE7"></a>
<h4 id="ADDCI-GUID-CD482284-5973-4954-9086-DAFD9E872FE7" class="sect4">Implementing ODCIGetInterfaces() for PBSTREE in PL/SQL</h4>
<div>
<div class="section">
<p>The <a href="ext_idx_ref.htm#GUID-28AC1C1B-6B6B-446F-A6C9-EEF4A4842D5F">ODCIGetInterfaces()</a> routine returns the expected interface name through its <code class="codeph">OUT</code> parameter.</p>
<pre dir="ltr">STATIC FUNCTION ODCIGetInterfaces(
  ifclist OUT sys.ODCIObjectList) 
RETURN NUMBER IS
BEGIN
  ifclist := sys.ODCIObjectList(sys.ODCIObject(&#39;SYS&#39;,&#39;ODCIINDEX2&#39;));
  RETURN ODCIConst.Success;
END ODCIGetInterfaces;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACGFBIH"></a>
<div class="props_rev_3"><a id="GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83"></a>
<h4 id="ADDCI-GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83" class="sect4">Implementing ODCIIndexCreate() for PBSTREE in PL/SQL</h4>
<div>
<div class="section">
<p>The <a href="ext_idx_ref.htm#GUID-C14A0478-6EA1-4EAE-BAA6-AA59EE5D300C">ODCIIndexCreate()</a> routine creates a system-partitioned index storage table with two columns. The first column stores the <code class="codeph">VARCHAR2</code> indexed column value. The routine makes use of the information passed in to determine the context in which it is invoked. Dynamic SQL is used to execute the dynamically constructed SQL statement.</p>
<pre dir="ltr">STATIC FUNCTION ODCIIndexCreate (
  ia sys.ODCIIndexInfo, 
  parms VARCHAR2, 
  env sys.ODCIEnv) 
RETURN NUMBER IS
  i INTEGER;
  stmt VARCHAR2(2000);
  cursor cur1(ianame VARCHAR2) IS
    SELECT partition_name, parameters 
    FROM user_ind_partitions 
    WHERE index_name = ianame order by partition_name;
BEGIN
  stmt := &#39;&#39;;
 
  IF (env.CallProperty is null)  THEN
    stmt := &#39;create table &#39; ||ia.IndexSchema || &#39;.&#39; || ia.IndexName ||
      &#39;_sbtree(f1 VARCHAR2(1000), f2 rowid)&#39;;

  ELSEIF (env.callproperty = sys.ODCIConst.FirstCall) THEN
  stmt := &#39;&#39;;
  i := 1;
  FOR c1 in cur1(ia.indexname) LOOP
    IF (i &gt;1) THEN
      stmt := stmt || &#39;,&#39;;
    END IF;
    stmt := stmt || &#39;partition &#39; || c1.partition_name;
    i := i+1;
  END LOOP;
  stmt := &#39;create table &#39; || ia.indexschema || &#39;.&#39; || ia.indexname ||
    &#39;_sbtree (f1 VARCHAR2(1000), f2 rowid) partition by system &#39; ||
     &#39;( &#39; || stmt || &#39;)&#39;;

  ELSEIF (env.callproperty = sys.ODCIConst.FinalCall) THEN
    stmt := &#39;create index &#39; || ia.indexschema || &#39;.&#39; || ia.indexname ||
      &#39;_sbti on &#39; || ia.indexschema || &#39;.&#39; || ia.indexname ||
      &#39;_sbtree (f1) local&#39;;
  END IF;
 
  dbms_output.put_line(&#39;Create&#39;);
  dbms_output.put_line(stmt);
 
  -- execute the statement
  IF ((env.CallProperty is null) OR
      (env.CallProperty = sys.ODCIConst.FirstCall) OR
      (env.CallProperty = sys.ODCIConst.FinalCall) ) THEN
    execute immediate stmt;

  IF (env.CallProperty is null) THEN
    execute immediate &#39;insert into &#39; ||ia.IndexSchema || &#39;.&#39; || ia.IndexName 
      || &#39;_sbtree select &#39;  || ia.IndexCols(1).Colname || &#39;, ROWID from &#39; ||
      ia.IndexCols(1).TableSchema || &#39;.&#39; || ia.IndexCols(1).TableName;
    execute immediate &#39;create index &#39; || ia.indexschema || &#39;.&#39; || 
      ia.indexname || &#39;_sbti on &#39; || ia.indexschema || &#39;.&#39; || 
      ia.indexname || &#39;_sbtree (f1)&#39;;
    END IF;
  END IF;
 
  RETURN ODCIConst.Success;
END ODCIIndexCreate;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACDJCFF"></a>
<div class="props_rev_3"><a id="GUID-43232667-0102-4BCD-9C00-D106F8D049D2"></a>
<h4 id="ADDCI-GUID-43232667-0102-4BCD-9C00-D106F8D049D2" class="sect4">Implementing ODCIIndexDrop() for PBSTREE in PL/SQL</h4>
<div>
<div class="section">
<p>The <a href="ext_idx_ref.htm#GUID-F128CB3B-6B3E-41C3-A623-67BCB5BC9292">ODCIIndexDrop()</a> routine drops the index storage tables.</p>
<pre dir="ltr">STATIC FUNCTION ODCIIndexDrop(
  ia sys.ODCIIndexInfo,
  env sys.ODCIEnv) 
RETURN NUMBER IS
  stmt VARCHAR2(1000);
  cnum INTEGER;
  junk INTEGER;
BEGIN
  -- construct the sql statement
  stmt := &#39;&#39;;

  IF (env.CallProperty is null) THEN
    stmt := &#39;drop table &#39; || ia.IndexSchema || &#39;.&#39; || ia.IndexName || &#39;_sbtree&#39;;
    dbms_output.put_line(&#39;Drop&#39;);
    dbms_output.put_line(stmt);
    execute immediate stmt;
  END IF;
  RETURN ODCIConst.Success;
END ODCIIndexDrop;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACCCEAE"></a>
<div class="props_rev_3"><a id="GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878"></a>
<h4 id="ADDCI-GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878" class="sect4">Implementing ODCIIndexAlter() for PSBTREE in PL/SQL</h4>
<div>
<div class="section">
<p>The <a href="ext_idx_ref.htm#GUID-9DB1D609-69C3-483B-AA77-087AD51A3A55">ODCIIndexAlter()</a> routine can perform many index alteration tasks, such as rebuilding and renaming an index.</p>
<pre dir="ltr">STATIC FUNCTION ODCIIndexAlter (
  ia sys.ODCIIndexInfo, 
  parms IN OUT VARCHAR2, 
  altopt NUMBER,
  env sys.ODCIEnv) 
RETURN NUMBER IS
  stmt    VARCHAR2(2000);
BEGIN
  stmt := &#39;&#39;;
  IF (altopt = ODCIConst.AlterIndexRebuild) THEN
    IF (ia.IndexPartition is null) THEN
      stmt := &#39;insert into &#39; || ia.indexschema || &#39;.&#39; || ia.indexname ||
          &#39;_sbtree select &#39; || ia.indexcols(1).colname || &#39;, rowid from &#39; ||
          ia.indexcols(1).tableschema || &#39;.&#39; || ia.indexcols(1).tablename;
    ELSE
      stmt := &#39;insert into &#39; || ia.indexschema || &#39;.&#39; || ia.indexname ||
          &#39;_sbtree partition (&#39; || ia.indexpartition || &#39;) select &#39; || 
          ia.indexcols(1).colname || &#39;, rowid from &#39; ||
          ia.indexcols(1).tableschema || &#39;.&#39; || ia.indexcols(1).tablename ||
          &#39; partition (&#39; || ia.indexcols(1).tablepartition || &#39;)&#39;;
    END IF;
  ELSEIF (altopt = ODCIConst.AlterIndexRename) THEN
    IF (ia.IndexPartition is not null) THEN
      stmt := &#39;alter table &#39; || ia.indexschema || &#39;.&#39; || ia.indexname ||
          &#39;_sbtree rename partition &#39; || ia.indexpartition || &#39; to &#39; || parms;
    ELSE
      stmt := &#39;alter table &#39; || ia.indexschema || &#39;.&#39; || ia.indexname ||
          &#39;_sbtree rename to &#39; || parms || &#39;_sbtree&#39;;
    END IF;
  END IF;

  dbms_output.put_line(&#39;Alter&#39;);
  IF ((altopt=ODCIConst.AlterIndexRebuild) or (altopt=ODCIConst.AlterIndexRename))
  THEN
    dbms_output.put_line(stmt);
    execute immediate stmt;
  END IF;
  RETURN ODCIConst.Success;
END ODCIIndexAlter;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACBFDJC"></a>
<div class="props_rev_3"><a id="GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA"></a>
<h4 id="ADDCI-GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA" class="sect4">Implementing ODCIIndexUpdPartMetadata() for PSBTREE in PL/SQL</h4>
<div>
<div class="section">
<p>To handle partition maintenance operations, the kernel performs the maintenance tasks on behalf of the user. The indextype, to maintain its metadata, should have the <a href="ext_idx_ref.htm#GUID-C2C4DB40-106A-491C-B241-985B69DC2FE1">ODCIIndexUpdPartMetadata()</a> routine.</p>
<pre dir="ltr">STATIC FUNCTION ODCIIndexUpdPartMetadata(
  ia sys.ODCIIndexInfo, 
  palist sys.ODCIPartInfoList, 
  env sys.ODCIEnv) 
RETURN NUMBER IS
  col  number;
BEGIN
  dbms_output.put_line(&#39;ODCIUpdPartMetadata&#39;);
  sys.ODCIIndexInfoDump(ia);
  sys.ODCIPartInfoListDump(palist);
  sys.ODCIEnvDump(env);
  RETURN ODCIConst.Success;
END ODCIIndexUpdPartMetadata;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACJCGBH"></a>
<div class="props_rev_3"><a id="GUID-395A7999-CD4F-4995-8455-F6D51D3710EF"></a>
<h4 id="ADDCI-GUID-395A7999-CD4F-4995-8455-F6D51D3710EF" class="sect4">Implementing ODCIIndexExchangePartition() for PSBTREE in PL/SQL</h4>
<div>
<div class="section">
<p>The <a href="ext_idx_ref.htm#GUID-7914F874-620F-48F1-ADDC-040CC82D46ED">ODCIIndexExchangePartition()</a> exchanges the index storage tables for the index partition being exchanged, with the index storage table for the global domain index.</p>
<pre dir="ltr">STATIC FUNCTION ODCIIndexExchangePartition(
  ia sys.ODCIIndexInfo,
  ia1 sys.ODCIIndexInfo,
  env sys.ODCIEnv)
RETURN NUMBER IS
  stmt VARCHAR2(2000);
  cnum INTEGER;
  junk INTEGER;
BEGIN
  stmt := &#39;&#39;;
  dbms_output.put_line(&#39;Exchange Partitions&#39;);

  -- construct the sql statement
  stmt := &#39;alter table &#39; || ia.IndexSchema || &#39;.&#39; || ia.IndexName ||
    &#39;_sbtree exchange partition &#39; ||   ia.IndexPartition || &#39; with table &#39; ||
    ia1.IndexSchema || &#39;.&#39; || ia1.IndexName || &#39;_sbtree&#39;;
 
  dbms_output.put_line(stmt);
  execute immediate stmt;
 
  RETURN ODCIConst.Success;
END ODCIIndexExchangePartition;
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADDCI4900"></a>
<div class="props_rev_3"><a id="GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0"></a>
<h3 id="ADDCI-GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0" class="sect3">Registering the C Implementation of the ODCIIndex<span class="italic">XXX</span>() Methods</h3>
<div>
<div class="section">
<p>After creating the <code class="codeph">extdemo6l</code> library object for the compiled C methods, you must register the implementations of each of the routines. The <a href="psbtree_example.htm#GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB">Registering the Implementation of ODCIIndexInsert()</a> demonstrates how to register the <a href="ext_idx_ref.htm#GUID-EF42025B-6DE2-4F2A-90EF-62775EE0EED6">ODCIIndexInsert()</a> implementation, the <a href="psbtree_example.htm#GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3">Registering the Implementation of ODCIIndexDelete()</a> registers the <a href="ext_idx_ref.htm#GUID-4B2E080D-FE8B-4598-9084-56FBE255196B">ODCIIndexDelete()</a> implementation, the <a href="psbtree_example.htm#GUID-20EAB399-76F5-4C79-AE81-63B8956504F7">Registering the Implementation of ODCIIndexUpdate()</a> registers the <a href="ext_idx_ref.htm#GUID-CB42E738-EFD1-4053-9DDF-BEF455F92815">ODCIIndexUpdate()</a> implementation, the <a href="psbtree_example.htm#GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3">Registering the Implementation of ODCIIndexStart()</a> registers the <a href="ext_idx_ref.htm#GUID-53F2321C-B0F8-4783-AC1B-056372A0C073">ODCIIndexStart()</a> implementation, the <a href="psbtree_example.htm#GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE">Registering the Implementation of ODCIIndexFetch()</a> registers the <a href="ext_idx_ref.htm#GUID-BB601420-A858-46E3-A9AC-3433220D4F82">ODCIIndexFetch()</a> implementation, and the <a href="psbtree_example.htm#GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32">Registering the Implementation of ODCIIndexClose()</a> registers the <a href="ext_idx_ref.htm#GUID-2F49CDE4-C064-4644-948C-BBF014FDD8C8">ODCIIndexClose()</a> implementation.</p>
</div>
<!-- class="section" --></div>
<a id="CACGAHCG"></a>
<div class="props_rev_3"><a id="GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB"></a>
<h4 id="ADDCI-GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB" class="sect4">Registering the Implementation of ODCIIndexInsert()</h4>
<div>
<div class="section">
<p>Register the implementation of the <a href="ext_idx_ref.htm#GUID-EF42025B-6DE2-4F2A-90EF-62775EE0EED6">ODCIIndexInsert()</a> routine.</p>
<pre dir="ltr">STATIC FUNCTION ODCIIndexInsert(
  ia SYS.ODCIIndexInfo,
  rid VARCHAR2,
  newval VARCHAR2,
  env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name &#34;qxiqtbspi&#34;
library extdemo6l
with context
parameters (
  context,
  ia,
  ia indicator struct,
  rid,
  rid indicator,
  newval,
  newval indicator,
  env,
  env indicator struct,
  return OCINumber
);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACBHAHC"></a>
<div class="props_rev_3"><a id="GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3"></a>
<h4 id="ADDCI-GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3" class="sect4">Registering the Implementation of ODCIIndexDelete()</h4>
<div>
<div class="section">
<p>Register the implementation of the <a href="ext_idx_ref.htm#GUID-4B2E080D-FE8B-4598-9084-56FBE255196B">ODCIIndexDelete()</a> routine.</p>
<pre dir="ltr">STATIC FUNCTION ODCIIndexDelete(
  ia SYS.ODCIIndexInfo, 
  rid VARCHAR2,
  oldval VARCHAR2, 
  env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name &#34;qxiqtbspd&#34;
library extdemo6l
with context
parameters (
  context,
  ia,
  ia indicator struct,
  rid,
  rid indicator,
  oldval,
  oldval indicator,
  env,
  env indicator struct,
  return OCINumber
);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACBCCEH"></a>
<div class="props_rev_3"><a id="GUID-20EAB399-76F5-4C79-AE81-63B8956504F7"></a>
<h4 id="ADDCI-GUID-20EAB399-76F5-4C79-AE81-63B8956504F7" class="sect4">Registering the Implementation of ODCIIndexUpdate()</h4>
<div>
<div class="section">
<p>Register the implementation of the <a href="ext_idx_ref.htm#GUID-CB42E738-EFD1-4053-9DDF-BEF455F92815">ODCIIndexUpdate()</a> routine.</p>
<pre dir="ltr">STATIC FUNCTION ODCIIndexUpdate(
  ia SYS.ODCIIndexInfo, 
  rid VARCHAR2,
  oldval VARCHAR2,
  newval VARCHAR2,
  env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name &#34;qxiqtbspu&#34;
library extdemo6l
with context
parameters (
  context,
  ia,
  ia indicator struct,
  rid,
  rid indicator,
  oldval,
  oldval indicator,
  newval,
  newval indicator,
  env,
  env indicator struct,
  return OCINumber
);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACJADGC"></a>
<div class="props_rev_3"><a id="GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3"></a>
<h4 id="ADDCI-GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3" class="sect4">Registering the Implementation of ODCIIndexStart()</h4>
<div>
<div class="section">
<p>Register the implementation of the <a href="ext_idx_ref.htm#GUID-53F2321C-B0F8-4783-AC1B-056372A0C073">ODCIIndexStart()</a> routine.</p>
<pre dir="ltr">STATIC FUNCTION ODCIIndexStart(
  sctx IN OUT psbtree_im,
  ia SYS.ODCIIndexInfo,
  op SYS.ODCIPredInfo,
  qi SYS.ODCIQueryInfo,
  strt NUMBER,
  stop NUMBER,
  cmpval VARCHAR2,
  env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name &#34;qxiqtbsps&#34;
library extdemo6l
with context
parameters (
  context,
  sctx,
  sctx indicator struct,
  ia,
  ia indicator struct,
  op,
  op indicator struct,
  qi,
  qi indicator struct,
  strt,
  strt indicator,
  stop,
  stop indicator,
  cmpval,
  cmpval indicator,
  env,
  env indicator struct,
  return OCINumber
);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADDCI4905"></a>
<div class="props_rev_3"><a id="GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE"></a>
<h4 id="ADDCI-GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE" class="sect4">Registering the Implementation of ODCIIndexFetch()</h4>
<div>
<div class="section">
<p>Register the implementation of the <a href="ext_idx_ref.htm#GUID-BB601420-A858-46E3-A9AC-3433220D4F82">ODCIIndexFetch()</a> routine.</p>
<pre dir="ltr">MEMBER FUNCTION ODCIIndexFetch(
  nrows NUMBER,
  rids OUT SYS.ODCIRidList,
  env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name &#34;qxiqtbspf&#34;
library extdemo6l
with context
parameters (
  context,
  self,
  self indicator struct,
  nrows,
  nrows indicator,
  rids,
  rids indicator,
  env,
  env indicator struct,
  return OCINumber
 );
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACIDHBA"></a>
<div class="props_rev_3"><a id="GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32"></a>
<h4 id="ADDCI-GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32" class="sect4">Registering the Implementation of ODCIIndexClose()</h4>
<div>
<div class="section">
<p>Register the implementation of the <a href="ext_idx_ref.htm#GUID-2F49CDE4-C064-4644-948C-BBF014FDD8C8">ODCIIndexClose()</a> routine.</p>
<pre dir="ltr">MEMBER FUNCTION ODCIIndexClose (
  env SYS.ODCIEnv) 
RETURN NUMBER AS EXTERNAL
name &#34;qxiqtbspc&#34;
library extdemo6l
with context
parameters (
  context,
  self,
  self indicator struct,
  env,
  env indicator struct,
  return OCINumber
);
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADDCI4908"></a><a id="ADDCI4909"></a><a id="ADDCI4907"></a>
<div class="props_rev_3"><a id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE"></a>
<h3 id="ADDCI-GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE" class="sect3">Defining Additional Structures in C Implementation</h3>
<div>
<div class="section">
<p>The <code class="codeph">stuct</code> <code class="codeph">qxiqtim</code>, <code class="codeph">struct qciqtin</code>, and <code class="codeph">struct</code> <code class="codeph">qxiqtcx</code> are used for mapping the object type and its <code class="codeph">null</code> value (demonstrated in <a href="psbtree_example.htm#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">Example 15-6</a>), and for keeping state during fetching calls (demonstrated in <a href="psbtree_example.htm#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">Example 15-7</a>). These structures are used by the methods described in <a href="psbtree_example.htm#GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4">Defining C Methods in the Implementation Body</a>.</p>
<p>The C <code class="codeph">struct</code>s for mapping the ODCI types are defined in the file <code class="codeph">odci.h</code>. For example, the C <code class="codeph">struct</code> <code class="codeph">ODCIIndexInfo</code> is the mapping for the corresponding ODCI object type. The C <code class="codeph">struct</code> <code class="codeph">ODCIIndexInfo_ind</code> is the mapping for the <code class="codeph">null</code> object.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">
<p class="titleinexample">Example 15-6 Defining Mappings for the Object Type and Its Null Value</p>
<p>We have defined a C <code class="codeph">struct</code>, <code class="codeph">qxiqtim</code>, as a mapping for the object type. There is an additional C <code class="codeph">struct</code>, <code class="codeph">qxiqtin</code>, for the corresponding <code class="codeph">null</code> object. The C <code class="codeph">struct</code>s for the object type and its <code class="codeph">null</code> object can be generated from the Object Type Translator (OTT).</p>
<pre dir="ltr">/* The index implementation type is an object type with a single RAW attribute
 * used to store the context key value. 
 * C mapping of the implementation type : */

struct qxiqtim{
  OCIRaw *sctx_qxiqtim;
}; 
typedef struct qxiqtim qxiqtim;

struct qxiqtin{
  short atomic_qxiqtin;
  short scind_qxiqtin;
}; 
typedef struct qxiqtin qxiqtin;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">
<p class="titleinexample">Example 15-7 Keeping the Scan State During Fetching Calls</p>
<p>There are a set of OCI handles that must be cached away and retrieved during fetch calls. A C <code class="codeph">struct</code>, <code class="codeph">qxiqtcx</code>, is defined to hold all the necessary scan state. This structure is allocated out of <code class="codeph">OCI_DURATION_STATEMENT</code> memory to ensure that it persists till the end of <code class="codeph">fetch</code>. After populating the structure with the required info, a pointer to the structure is saved in OCI context. The context is identified by a 4-byte key that is generated by calling an OCI routine. The 4-byte key is stashed away in the scan context - <code class="codeph">exiting</code>. This object is returned back to the Oracle server and is passed in as a parameter to the next fetch call.</p>
<pre dir="ltr">/* The index scan context - should be stored in &#34;statement&#34; duration memory
 * and used by start, fetch and close routines.
 */
struct qxiqtcx
{
  OCIStmt *stmthp;
  OCIDefine *defnp;
  OCIBind *bndp;
  char ridp[19];
}; 
typedef struct qxiqtcx qxiqtcx;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADDCI4910"></a>
<div class="props_rev_3"><a id="GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4"></a>
<h3 id="ADDCI-GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4" class="sect3">Defining C Methods in the Implementation Body</h3>
<div>
<p>Consider how to implemented PSBEETree methods in the C language.</p>
</div>
<a id="CACJIECE"></a>
<div class="props_rev_3"><a id="GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C"></a>
<h4 id="ADDCI-GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C" class="sect4">Implementing a Common Error Processing Routine in C</h4>
<div>
<div class="section">
<p>This function is used to check and process the return code from all <code class="codeph">OCI</code> routines. It checks the status code and raises an exception in case of errors.</p>
<pre dir="ltr">static int qxiqtce(
  OCIExtProcContext *ctx,
  OCIError *errhp,
  sword status)
{
  text errbuf[512];
  sb4 errcode = 0;
  int errnum = 29400;  /* choose some oracle error number */
  int rc = 0;

  switch (status)
  {
    case OCI_SUCCESS: 
      rc = 0;
      break;
    case OCI_ERROR:
      (void) OCIErrorGet((dvoid *)errhp, (ub4)1, (text *)NULL, &amp;errcode,
      errbuf, (ub4)sizeof(errbuf), OCI_HTYPE_ERROR);
      /* Raise exception */
      OCIExtProcRaiseExcpWithMsg(ctx, errnum, errbuf, strlen((char *)errbuf));
      rc = 1;
      break;
    default:
      (void) sprintf((char *)errbuf, &#34;Warning - some error\n&#34;);
      /* Raise exception */
      OCIExtProcRaiseExcpWithMsg(ctx, errnum, errbuf, strlen((char *)errbuf));
      rc = 1;
      break;
  }
  return (rc);
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACJJDAC"></a>
<div class="props_rev_3"><a id="GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB"></a>
<h4 id="ADDCI-GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB" class="sect4">Implementing ODCIIndexInsert() for PSBTREE in C</h4>
<div>
<div class="section">
<p>The insert routine, <a href="ext_idx_ref.htm#GUID-EF42025B-6DE2-4F2A-90EF-62775EE0EED6">ODCIIndexInsert()</a>, parses and executes a statement that inserts a new row into the index table. The new row consists of the new value of the indexed column and the <code class="codeph">rowid</code> that have been passed in as parameters.</p>
<pre dir="ltr">OCINumber *qxiqtbspi(
  OCIExtProcContext *ctx,
  ODCIIndexInfo     *ix,
  ODCIIndexInfo_ind *ix_ind,
  char              *rid,
  short             rid_ind,
  char              *newval,
  short             newval_ind,
  ODCIEnv           *env,
  ODCIEnv_ind       *env_ind)
{
  OCIEnv *envhp = (OCIEnv *) 0;             /* env. handle */
  OCISvcCtx *svchp = (OCISvcCtx *) 0;       /* service handle */
  OCIError *errhp = (OCIError *) 0;         /* error handle */
  OCIStmt *stmthp = (OCIStmt *) 0;          /* statement handle */
  OCIBind *bndp = (OCIBind *) 0;            /* bind handle */

  int retval = (int)ODCI_SUCCESS;           /* return from this function */
  OCINumber *rval = (OCINumber *)0;

  char insstmt[2000];                       /* sql insert statement */
  ODCIColInfo  *colinfo;                    /* column info */
  ODCIColInfo_ind  *colinfo_ind;
  boolean exists = TRUE;
  unsigned int partiden;                    /* table partition iden */ 
  unsigned int idxflag;                     /* index info flag  

  /* allocate memory for OCINumber first */
  rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));

  /* Get oci handles */
  if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
    return(rval);

  /* set up return code */
  if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
      sizeof(retval), OCI_NUMBER_SIGNED, rval)))
    return(rval);

  /* Convert idxflag to integer from OCINumber */
  if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
      sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
    return(rval);

  /*****************************
  * Construct insert Statement *
  ******************************/
  if ((idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
    (void)sprintf(insstmt, &#34;INSERT into %s.%s_sbtree values (:newval, :mrid)&#34;,
      OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName));
  else
  {
    if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, (OCIColl *)ix-&gt;IndexCols,
        (sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
      return(rval);
 
  (void)sprintf(insstmt,
      &#34;INSERT into %s.%s_sbtree partition (DATAOBJ_TO_PARTITION(%s, :partiden))
        VALUES (:newval, :mrid)&#34;,
      OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
      OCIStringPtr(envhp, colinfo-&gt;TableName));
  }

  /***************************************
  * Parse and Execute Create Statement   *
  ****************************************/

  /* allocate stmt handle */
  if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;stmthp,
      (ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))
    return(rval);
 
    /* prepare the statement */
    if (qxiqtce(ctx, errhp, OCIStmtPrepare(stmthp, errhp, (text *)insstmt,
        (ub4)strlen(insstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
      return(rval);

    if ((idxflag &amp; ODCI_INDEX_RANGE_PARTN) == ODCI_INDEX_RANGE_PARTN)
    {
      /* Convert partiden to integer from OCINumber */
      if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, 
          &amp;(colinfo-&gt;TablePartitionIden), sizeof(partiden), OCI_NUMBER_UNSIGNED,
          ( void *)&amp;partiden)))
        return(rval);

      /* Set up bind for partiden */
      if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, 
          text *)&#34;:partiden&#34;, sizeof(&#34;:partiden&#34;)-1, (dvoid *)&amp;partiden,
          (sb4)(sizeof(partiden)), (ub2)SQLT_INT, (dvoid *)0, (ub2 *)0,
          (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
        return(rval);
    }

    /* Set up bind for newval */
    if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)&#34;:newval&#34;,
        sizeof(&#34;:newval&#34;)-1, (dvoid *)newval, (sb4)(strlen(newval)+1),
        (ub2)SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0,
        (ub4)OCI_DEFAULT)))
      return(rval);

    /* Set up bind for rid */
    if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)&#34;:mrid&#34;,
        sizeof(&#34;:mrid&#34;)-1, (dvoid *)rid, (sb4)(strlen(rid)+1), (ub2)SQLT_STR, 
        (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
      return(rval);

    /* Execute statement */
    if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4)1,
        (ub4)0, (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
      return(rval);
 
    /* free stmt handle */
    if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT)))
      return(rval);

    return(rval);
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACFICAJ"></a>
<div class="props_rev_3"><a id="GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19"></a>
<h4 id="ADDCI-GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19" class="sect4">Implementing ODCIIndexDelete() for PSBTREE in C</h4>
<div>
<div class="section">
<p>The delete routine constructs a SQL statement to delete a row from the index table corresponding to the row being deleted from the base table. The row in the index table is identified by the value of <code class="codeph">rowid</code> that is passed in as a parameter to this routine.</p>
<pre dir="ltr">OCINumber *qxiqtbspd(
  OCIExtProcContext *ctx,
  ODCIIndexInfo     *ix,
  ODCIIndexInfo_ind *ix_ind,
  char              *rid,
  short             rid_ind,
  char              *oldval,
  short             oldval_ind,
  ODCIEnv           *env,
  ODCIEnv_ind       *env_ind)
{
  OCIEnv *envhp = (OCIEnv *) 0;             /* env. handle */
  OCISvcCtx *svchp = (OCISvcCtx *) 0;       /* service handle */
  OCIError *errhp = (OCIError *) 0;         /* error handle */
  OCIStmt *stmthp = (OCIStmt *) 0;          /* statement handle */
  OCIBind *bndp = (OCIBind *) 0;            /* bind handle */
 
  int retval = (int)ODCI_SUCCESS;           /* return from this function */
  OCINumber *rval = (OCINumber *)0;
 
  char delstmt[2000];                       /* sql delete statement */
  ODCIColInfo  *colinfo;                    /* column info */
  ODCIColInfo_ind  *colinfo_ind;
  boolean exists = TRUE;
  unsigned int partiden;                    /* table partition iden */ 
  unsigned int idxflag;                     /* index info flag  
 
  /* Get oci handles */
  if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
    return(rval);
 
  /* set up return code */
  rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
  if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
      sizeof(retval), OCI_NUMBER_SIGNED, rval)))
    return(rval);
 
  /* Convert idxflag to integer from OCINumber */
  if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
      sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
    return(rval);
 
  /*****************************
  * Construct delete Statement *
  ******************************/
  if ((idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
    (void)sprintf(delstmt, &#34;DELETE FROM %s.%s_sbtree WHERE f2 = :rr&#34;,
      OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName));
  else
  {
    if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, (OCIColl *)ix-&gt;IndexCols,
        (sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
      return(rval);

    (void)sprintf(delstmt, 
        &#34;DELETE FROM %s.%s_sbtree partition (DATAOBJ_TO_PARTITION(%s, :partiden))
          WHERE f2 = :rr&#34;,
        OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
        OCIStringPtr(envhp, colinfo-&gt;TableName));
  }

  /***************************************
  * Parse and Execute delete Statement   *
  ****************************************/

/* allocate stmt handle */
  if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;stmthp,
      (ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))
    return(rval);

/* prepare the statement */
  if (qxiqtce(ctx, errhp, OCIStmtPrepare(stmthp, errhp, (text *)delstmt,
      (ub4)strlen(delstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
    return(rval);

  if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) == ODCI_INDEX_RANGE_PARTN)
  {
    /* Convert partiden to integer from OCINumber */
    if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(colinfo-&gt;TablePartitionIden),
        sizeof(partiden), OCI_NUMBER_UNSIGNED, ( void *)&amp;partiden)))
      return(rval);

    /* Set up bind for partiden */
    if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, 
        (text *)&#34;:partiden&#34;, sizeof(&#34;:partiden&#34;)-1, (dvoid *)&amp;partiden,
        sb4)(sizeof(partiden)), (ub2)SQLT_INT, (dvoid *)0, (ub2 *)0,
        (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
      return(rval);
  }

  /* Set up bind for rid */
  if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)&#34;:rr&#34;,
      sizeof(&#34;:rr&#34;)-1, (dvoid *)rid, (sb4)(strlen(rid)+1), (ub2)SQLT_STR, 
      (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
    return(rval);

  /* Execute statement */
  if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4)1, (ub4)0,
      (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
    return(rval);

  /* free stmt handle */
  if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT)))
    return(rval);

  return(rval);
}
</pre></div>
<!-- class="section" --></div>
</div>
<div class="props_rev_3"><a id="GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9"></a>
<h4 id="ADDCI-GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9" class="sect4">Implementing ODCIIndexUpdate() for PSBTree in C</h4>
<div>
<div class="section">
<p>The update routine constructs a SQL statement to update a row in the index table corresponding to the row being updated in the base table. The row in the index table is identified by the value of <code class="codeph">rowid</code> that is passed in as a parameter to this routine. The old column value (<code class="codeph">oldval</code>) is replaced by the new value (<code class="codeph">newval</code>).</p>
<pre dir="ltr">OCINumber *qxiqtbspu(
  OCIExtProcContext *ctx,
  ODCIIndexInfo     *ix,
  ODCIIndexInfo_ind *ix_ind,
  char              *rid,
  short             rid_ind,
  char              *oldval,
  short             oldval_ind,
  char              *newval,
  short             newval_ind,
  ODCIEnv           *env,
  ODCIEnv_ind       *env_ind)
{
  OCIEnv *envhp = (OCIEnv *) 0;             /* env. handle */
  OCISvcCtx *svchp = (OCISvcCtx *) 0;       /* service handle */
  OCIError *errhp = (OCIError *) 0;         /* error handle */
  OCIStmt *stmthp = (OCIStmt *) 0;          /* statement handle */
  OCIBind *bndp = (OCIBind *) 0;            /* bind handle */

  int retval = (int)ODCI_SUCCESS;           /* return from this function */
  OCINumber *rval = (OCINumber *)0;

  char updstmt[2000];                       /* sql upate statement */
  ODCIColInfo  *colinfo;                    /* column info */
  ODCIColInfo_ind  *colinfo_ind;
  boolean exists = TRUE;
  unsigned int partiden;                    /* table partition iden */ 
  unsigned int idxflag;                     /* index info flag  

  /* Get oci handles */
  if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
    return(rval);

  /* set up return code */
  rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
  if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
      sizeof(retval), OCI_NUMBER_SIGNED, rval)))
    return(rval);

  /* Convert idxflag to integer from OCINumber */
  if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
      sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
    return(rval);

  /*****************************
  * Construct update Statement *
  ******************************/
  if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
    (void)sprintf(updstmt, &#34;UPDATE %s.%s_sbtree SET f1 = :newval WHERE f2 = :rr&#34;,
        OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName));
  else
  {
    if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, OCIColl *)ix-&gt;IndexCols,
        (sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
      return(rval);

    (void)sprintf(updstmt, &#34;UPDATE %s.%s_sbtree partition 
        (DATAOBJ_TO_PARTITION(%s, :partiden)) SET f1 = :newval WHERE f2 = :rr&#34;,
        OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
        OCIStringPtr(envhp, colinfo-&gt;TableName));
  }

  /****************************************
  * Parse and Execute Create Statement   *
  ****************************************/

  /* allocate stmt handle */
  if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;stmthp,
      (ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))
    return(rval);

  /* prepare the statement */
  if (qxiqtce(ctx, errhp, OCIStmtPrepare(stmthp, errhp, (text *)updstmt,
      (ub4)strlen(updstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
    return(rval);

  if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) == ODCI_INDEX_RANGE_PARTN)
  {
    /* Convert partiden to integer from OCINumber */
    if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, 
        &amp;(colinfo-&gt;TablePartitionIden), sizeof(partiden), OCI_NUMBER_UNSIGNED,
        ( void *)&amp;partiden)))
      return(rval);

    /* Set up bind for partiden */
    if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, 
        (text *)&#34;:partiden&#34;, sizeof(&#34;:partiden&#34;)-1, (dvoid *)&amp;partiden,
        (sb4)(sizeof(partiden)), (ub2)SQLT_INT, (dvoid *)0, (ub2 *)0,
        (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
      return(rval);
  }

  /* Set up bind for newval */
  if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)&#34;:newval&#34;,
      sizeof(&#34;:newval&#34;)-1, (dvoid *)newval, (sb4)(strlen(newval)+1), 
      (ub2)SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (
      ub4)OCI_DEFAULT)))
    return(rval);

  /* Set up bind for rid */
  if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)&#34;:rr&#34;,
      sizeof(&#34;:rr&#34;)-1, (dvoid *)rid, (sb4)(strlen(rid)+1), (ub2)SQLT_STR, 
      (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
    return(rval);

  /* Execute statement */
  if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4)1,
      ub4)0, (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
    return(rval);

  /* free stmt handle */
  if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT)))
    return(rval);

  return(rval);
}
</pre></div>
<!-- class="section" --></div>
</div>
<div class="props_rev_3"><a id="GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83"></a>
<h4 id="ADDCI-GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83" class="sect4">Implementing ODCIIndexStart() for PSBTREE in C</h4>
<div>
<div class="section">
<p>The start routine performs the setup for an <code class="codeph">psbtree</code> index scan. The query information in terms of the operator predicate, its arguments, and the bounds on return values are passed in as parameters to this function. The scan context that is shared among the index scan routines is an instance of the type <code class="codeph">psbtree_im</code>.</p>
<p>This function sets up a cursor that scans the index table. The scan retrieves the stored rowids for the rows in the index table that satisfy the specified predicate. The predicate for the index table is generated based on the operator predicate information that is passed in as parameters. For example, if the operator predicate is of the form <code class="codeph">eq(col, &#39;joe&#39;) = 1</code>, then the predicate on the index table is set up to be <code class="codeph">f1 = &#39;joe&#39;</code>.</p>
<p>This function uses the <code class="codeph">struct</code>s <code class="codeph">qxiqtim</code>, <code class="codeph">qxiqtin</code>, and <code class="codeph">qxiqtcx</code>, which were demonstrated in <a href="psbtree_example.htm#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">Example 15-6</a> and <a href="psbtree_example.htm#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">Example 15-7</a>.</p>
<pre dir="ltr">OCINumber *qxiqtbsps(
  OCIExtProcContext *ctx,
  qxiqtim           *sctx,
  qxiqtin           *sctx_ind,
  ODCIIndexInfo     *ix,
  ODCIIndexInfo_ind *ix_ind,
  ODCIPredInfo      *pr,
  ODCIPredInfo_ind  *pr_ind,
  ODCIQueryInfo     *qy,
  ODCIQueryInfo_ind *qy_ind,
  OCINumber         *strt,
  short             strt_ind,
  OCINumber         *stop,
  short             stop_ind,
  char              *cmpval,
  short             cmpval_ind,
  ODCIEnv           *env,
  ODCIEnv_ind       *env_ind)
{
  sword status;
  OCIEnv *envhp = (OCIEnv *) 0;                               /* env. handle */
  OCISvcCtx *svchp = (OCISvcCtx *) 0;                      /* service handle */
  OCIError *errhp = (OCIError *) 0;                          /* error handle */
  OCISession *usrhp = (OCISession *) 0;                       /* user handle */
  qxiqtcx *icx = (qxiqtcx *) 0;         /* state to be saved for later calls */

  int strtval;                   /* start bound */
  int stopval;                   /* stop bound */

  int errnum = 29400;            /* choose some oracle error number */
  char errmsg[512];              /* error message buffer */
  size_t errmsglen;              /* Length of error message */

  char relop[3];                 /* relational operator used in sql stmt */
  char selstmt[2000];            /* sql select statement */

  int retval = (int)ODCI_SUCCESS;       /* return from this function */
  OCINumber *rval = (OCINumber *)0;
  ub4 key;                              /* key value set in &#34;sctx&#34; */

  ub1 *rkey;                            /* key to retrieve context */
  ub4 rkeylen;                          /* length of key */
  ODCIColInfo  *colinfo;                /* column info */
  ODCIColInfo_ind  *colinfo_ind;
  boolean exists = TRUE;
  unsigned int partiden;                /* table partition iden */ 
  unsigned int idxflag;                 /* index info flag  

  /* Get oci handles */
  if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
    return(rval);

  /* set up return code */
  rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
  if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
      sizeof(retval), OCI_NUMBER_SIGNED, rval)))
    return(rval);

  /* get the user handle */
  if (qxiqtce(ctx, errhp, OCIAttrGet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
      (dvoid *)&amp;usrhp, (ub4 *)0, (ub4)OCI_ATTR_SESSION, errhp)))
    return(rval);

  /**********************************************/
  /* Allocate memory to hold index scan context */
  /**********************************************/
  if (sctx_ind -&gt;atomic_qxiqtin == OCI_IND_NULL ||
      sctx_ind -&gt;scind_qxiqtin == OCI_IND_NULL)
  {
    if (qxiqtce(ctx, errhp, OCIMemoryAlloc((dvoid *)usrhp, errhp, (dvoid **)&amp;icx,
        OCI_DURATION_STATEMENT, (ub4)(sizeof(qxiqtcx)), OCI_MEMORY_CLEARED)))
    return(rval);

  icx-&gt;stmthp = (OCIStmt *)0;
  icx-&gt;defnp = (OCIDefine *)0;
  icx-&gt;bndp = (OCIBind *)0;
  }

  else
  {
    /*************************/
    /* Retrieve scan context */
    /*************************/
    rkey = OCIRawPtr(envhp, sctx-&gt;sctx_qxiqtim);
    rkeylen = OCIRawSize(envhp, sctx-&gt;sctx_qxiqtim);

    if (qxiqtce(ctx, errhp, OCIContextGetValue((dvoid *)usrhp, errhp,
        rkey, (ub1)rkeylen, (dvoid **)&amp;(icx))))
      return(rval);
  }

  /***********************************/
  /* Check that the bounds are valid */
  /***********************************/
  /* convert from oci numbers to native numbers */
  if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, strt, sizeof(strtval), 
      OCI_NUMBER_SIGNED, (dvoid *)&amp;strtval)))
    return(rval);

  if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, stop, sizeof(stopval),
      OCI_NUMBER_SIGNED, (dvoid *)&amp;stopval)))
    return(rval);

  /* verify that strtval/stopval are both either 0 or 1 */
  if (!(((strtval == 0) &amp;&amp; (stopval == 0)) || ((strtval == 1) &amp;&amp; (stopval == 1))))
    {
    strcpy(errmsg, (char *)&#34;Incorrect predicate for sbtree operator&#34;);
    errmsglen = (size_t)strlen(errmsg);
    if (OCIExtProcRaiseExcpWithMsg(ctx, errnum, (text *)errmsg, errmsglen)
        != OCIEXTPROC_SUCCESS)
      /* Use cartridge error services here */;
      return(rval);
    }

  /*********************************************/
  /* Generate the SQL statement to be executed */
  /*********************************************/
  if (memcmp((dvoid *)OCIStringPtr(envhp, pr-&gt;ObjectName), (dvoid *)&#34;EQ&#34;, 2) == 0)
    if (strtval == 1)
      strcpy(relop, (char *)&#34;=&#34;);
    else
      strcpy(relop, (char *)&#34;!=&#34;);
    else if 
      (memcmp((dvoid *)OCIStringPtr(envhp, pr-&gt;ObjectName), (dvoid *)&#34;LT&#34;,2) == 0)
      if (strtval == 1)
        strcpy(relop, (char *)&#34;&lt;&#34;);
      else
        strcpy(relop, (char *)&#34;&gt;=&#34;);
      else
        if (strtval == 1)
            strcpy(relop, (char *)&#34;&gt;&#34;);
          else
            strcpy(relop, (char *)&#34;&lt;=&#34;);

  /* Convert idxflag to integer from OCINumber */
  if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
      sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
    return(rval);

  if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
    (void)sprintf(selstmt, &#34;select f2 from %s.%s_sbtree where f1 %s :val&#34;,
      OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
      relop);
  else
  {
    if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, OCIColl *)ix-&gt;IndexCols,
        (sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
      return(rval);

    /* Convert partiden to integer from OCINumber */
  if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(colinfo-&gt;TablePartitionIden),
      sizeof(partiden), OCI_NUMBER_UNSIGNED, ( void *)&amp;partiden)))
    return(rval);

  (void)sprintf(selstmt, &#34;select f2 from %s.%s_sbtree partition 
      (DATAOBJ_TO_PARTITION(%s, %d)) where f1 %s :val&#34;,
      OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
      OCIStringPtr(envhp, colinfo-&gt;TableName), partiden, relop);
  }
  
  /***********************************/
  /* Parse, bind, define and execute */
  /***********************************/
  if (sctx_ind -&gt;atomic_qxiqtin == OCI_IND_NULL ||
      sctx_ind -&gt;scind_qxiqtin == OCI_IND_NULL)
  {
    /* allocate stmt handle */
    if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, 
        (dvoid **)&amp;(icx-&gt;stmthp), (ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))  
      return(rval);
  }

  /* prepare the statement */
  if (qxiqtce(ctx, errhp, OCIStmtPrepare(icx-&gt;stmthp, errhp, (text *)selstmt,
      (ub4)strlen(selstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
    return(rval);

  /* Set up bind for compare value */
  if (qxiqtce(ctx, errhp, OCIBindByName(icx-&gt;stmthp, &amp;(icx-&gt;bndp), errhp, 
      (text *)&#34;:val&#34;, sizeof(&#34;:val&#34;)-1, (dvoid *)cmpval, (sb4)(strlen(cmpval)+1),
      (ub2)SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0,
      (ub4)OCI_DEFAULT)))
    return(rval);

  /* Set up define */
  if (qxiqtce(ctx, errhp, OCIDefineByPos(icx-&gt;stmthp, &amp;(icx-&gt;defnp), errhp,
      (ub4)1, (dvoid *)(icx-&gt;ridp), (sb4) sizeof(icx-&gt;ridp), (ub2)SQLT_STR, 
      (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)OCI_DEFAULT)))
    return(rval);

  /* execute */
  if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, icx-&gt;stmthp, errhp, (ub4)0,
      (ub4)0, (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
    return(rval);

  /************************************/
  /* Set index context to be returned */
  /************************************/
  if (sctx_ind -&gt;atomic_qxiqtin == OCI_IND_NULL ||
      sctx_ind -&gt;scind_qxiqtin == OCI_IND_NULL)
  {
    /* generate a key */
    if (qxiqtce(ctx, errhp, OCIContextGenerateKey((dvoid *)usrhp, errhp, &amp;key)))
      return(rval);

    /* set the memory address of the struct to be saved in the context */
    if (qxiqtce(ctx, errhp, OCIContextSetValue((dvoid *)usrhp, errhp,
        OCI_DURATION_STATEMENT, (ub1 *)&amp;key, (ub1)sizeof(key), (dvoid *)icx)))
      return(rval);

    /* statement duration memory alloc for key */ 
    if (qxiqtce(ctx, errhp, OCIMemoryAlloc(( void *)usrhp, errhp,
        ( void **)&amp;(sctx-&gt;sctx_qxiqtim), OCI_DURATION_STATEMENT,
        (sb4)(sizeof(key)+sizeof(ub4)), OCI_MEMORY_CLEARED)))
      return(rval);

    /* set the key as the member of &#34;sctx&#34; */
    if (qxiqtce(ctx, errhp, OCIRawAssignBytes(envhp, errhp, (ub1 *)&amp;key,
        ub4)sizeof(key), &amp;(sctx-&gt;sctx_qxiqtim))))
      return(rval);

    sctx_ind-&gt;atomic_qxiqtin = OCI_IND_NOTNULL;
    sctx_ind-&gt;scind_qxiqtin = OCI_IND_NOTNULL;

    return(rval);
  }

  return(rval);
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACGCEBA"></a>
<div class="props_rev_3"><a id="GUID-9034448B-7A7C-4A11-A904-6E8954792162"></a>
<h4 id="ADDCI-GUID-9034448B-7A7C-4A11-A904-6E8954792162" class="sect4">Implementing ODCIIndexFetch() for PSBTREE in C</h4>
<div>
<div class="section">
<p>The scan context set up by the start routine is passed in as a parameter to the fetch routine. This function first retrieves the 4-byte key from the scan context. The C mapping for the scan context is <code class="codeph">qxiqtim</code> (see <a href="psbtree_example.htm#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">Example 15-6</a>). Next, key is used to look up the OCI context. This gives the memory address of the <code class="codeph">qxiqtcx</code> structure (see <a href="psbtree_example.htm#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">Example 15-7</a>) that holds the OCI handles.</p>
<p>This function returns the next batch of rowids that satisfy the operator predicate. It uses the value of the <code class="codeph">nrows</code> parameter as the size of the batch. It repeatedly fetches rowids from the open cursor and populates the <code class="codeph">rowid</code> list. When the batch is full or when there are no more rowids left, the function returns them back to the Oracle server.</p>
<pre dir="ltr">OCINumber *qxiqtbspf(
  OCIExtProcContext *ctx,
  qxiqtim           *self,
  qxiqtin           *self_ind,
  OCINumber         *nrows,
  short             nrows_ind,
  OCIArray          **rids,
  short             *rids_ind,
  ODCIEnv           *env,
  ODCIEnv_ind       *env_ind)
{
  sword status;
  OCIEnv *envhp = (OCIEnv *) 0;                               /* env. handle */
  OCISvcCtx *svchp = (OCISvcCtx *) 0;                      /* service handle */
  OCIError *errhp = (OCIError *) 0;                          /* error handle */
  OCISession *usrhp = (OCISession *) 0;                       /* user handle */
  qxiqtcx *icx = (qxiqtcx *) 0;         /* state to be saved for later calls */

  int idx = 1;
  int nrowsval;

  OCIArray *ridarrp = *rids;                  /* rowid collection */
  OCIString *ridstr = (OCIString *)0;

  int done = 0;
  int retval = (int)ODCI_SUCCESS;
  OCINumber *rval = (OCINumber *)0;

  ub1 *key;                                   /* key to retrieve context */
  ub4 keylen;                                 /* length of key */

  /*******************/
  /* Get OCI handles */
  /*******************/
  if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
    return(rval);

  /* set up return code */
  rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
  if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
      sizeof(retval), OCI_NUMBER_SIGNED, rval)))
    return(rval);

  /* get the user handle */
  if (qxiqtce(ctx, errhp, OCIAttrGet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
      (dvoid *)&amp;usrhp, (ub4 *)0, (ub4)OCI_ATTR_SESSION, errhp)))
    return(rval);

  /********************************/
  /* Retrieve context from key    */
  /********************************/
  key = OCIRawPtr(envhp, self-&gt;sctx_qxiqtim);
  keylen = OCIRawSize(envhp, self-&gt;sctx_qxiqtim);

  if (qxiqtce(ctx, errhp, OCIContextGetValue((dvoid *)usrhp, errhp, key,
      (ub1)keylen, (dvoid **)&amp;(icx))))
    return(rval);

  /* get value of nrows */
  if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, nrows, sizeof(nrowsval),
      OCI_NUMBER_SIGNED, (dvoid *)&amp;nrowsval)))
    return(rval);

  /****************/
  /* Fetch rowids */
  /****************/
  while (!done)
  {
    if (idx &gt; nrowsval)
      done = 1;
    else
    {
      status =OCIStmtFetch(icx-&gt;stmthp, errhp, (ub4)1, (ub2) 0, (ub4)OCI_DEFAULT);
      if (status == OCI_NO_DATA)
      {
        short col_ind = OCI_IND_NULL;
        /* have to create dummy oci string */
        OCIStringAssignText(envhp, errhp, (text *)&#34;dummy&#34;, (ub2)5, &amp;ridstr);
        /* append null element to collection */
        if (qxiqtce(ctx, errhp, OCICollAppend(envhp, errhp, (dvoid *)ridstr,
            (dvoid *)&amp;col_ind, (OCIColl *)ridarrp)))
          return(rval);
        done = 1;
      }
      else if (status == OCI_SUCCESS)
      {
        OCIStringAssignText(envhp, errhp, (text *)icx-&gt;ridp, (ub2)18, 
            OCIString **)&amp;ridstr);
        /* append rowid to collection */
        if (qxiqtce(ctx, errhp, OCICollAppend(envhp, errhp, (dvoid *)ridstr,
            (dvoid *)0, (OCIColl *)ridarrp)))
          return(rval);
        idx++;
      }
      else if (qxiqtce(ctx, errhp, status))
        return(rval);
    }
  }

  /* free ridstr finally */
  if (ridstr &amp;&amp;
      (qxiqtce(ctx, errhp, OCIStringResize(envhp, errhp, (ub4)0, &amp;ridstr))))
    return(rval);

  *rids_ind = OCI_IND_NOTNULL;

  return(rval);
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACBFHDA"></a>
<div class="props_rev_3"><a id="GUID-43F5A575-F265-43F0-A513-6495057E0BC4"></a>
<h4 id="ADDCI-GUID-43F5A575-F265-43F0-A513-6495057E0BC4" class="sect4">Implementing ODCIIndexClose() for PSBTREE in C</h4>
<div>
<div class="section">
<p>The scan context set up by the start routine is passed in as a parameter to the close routine. This function first retrieves the 4-byte key from the scan context. The C mapping for the scan context is <code class="codeph">qxiqtim</code> (see <a href="psbtree_example.htm#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">Example 15-6</a>). Next, the OCI context is looked up based on the key. This gives the memory address of the structure that holds the OCI handles, the <code class="codeph">qxiqtcx</code> structure (see <a href="psbtree_example.htm#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">Example 15-7</a>).</p>
<p>This function closes and frees all the OCI handles. It also frees the memory that was allocated in the start routine.</p>
<pre dir="ltr">OCINumber *qxiqtbspc(
  OCIExtProcContext *ctx,
  qxiqtim           *self,
  qxiqtin           *self_ind,
  ODCIEnv           *env,
  ODCIEnv_ind       *env_ind)
{
  sword status;
  OCIEnv *envhp = (OCIEnv *) 0;                               /* env. handle */
  OCISvcCtx *svchp = (OCISvcCtx *) 0;                      /* service handle */
  OCIError *errhp = (OCIError *) 0;                          /* error handle */
  OCISession *usrhp = (OCISession *) 0;                       /* user handle */
  qxiqtcx *icx = (qxiqtcx *) 0;         /* state to be saved for later calls */

  int retval = (int) ODCI_SUCCESS;
  OCINumber *rval = (OCINumber *)0;

  ub1 *key;                                   /* key to retrieve context */
  ub4 keylen;                                 /* length of key */

  if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
    return(rval);

  /* set up return code */
  rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
  if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
      sizeof(retval), OCI_NUMBER_SIGNED, rval)))
    return(rval);

  /* get the user handle */
  if (qxiqtce(ctx, errhp, OCIAttrGet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
      (dvoid *)&amp;usrhp, (ub4 *)0,
      (ub4)OCI_ATTR_SESSION, errhp)))
    return(rval);
  /********************************/
  /* Retrieve context using key   */
  /********************************/
  key = OCIRawPtr(envhp, self-&gt;sctx_qxiqtim);
  keylen = OCIRawSize(envhp, self-&gt;sctx_qxiqtim);

  if (qxiqtce(ctx, errhp, OCIContextGetValue((dvoid *)usrhp, errhp, key,
      (ub1)keylen, (dvoid **)&amp;(icx))))
    return(rval);

  /* Free handles and memory */
  if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)icx-&gt;stmthp, 
      (ub4)OCI_HTYPE_STMT)))
    return(rval);

  if (qxiqtce(ctx, errhp, OCIMemoryFree((dvoid *)usrhp, errhp, (dvoid *)icx)))
    return(rval);

  /* free the memory allocated for the index context. */
  if (qxiqtce(ctx, errhp, OCIContextClearValue((dvoid *)usrhp, errhp, key,
      (ub1)keylen)))
    return(rval);

    return(rval);
}
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="CACGICCC"></a>
<div class="props_rev_3"><a id="GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2"></a>
<h3 id="ADDCI-GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2" class="sect3">Implementing the Indextype for PSBTREE</h3>
<div>
<p>You should create the indextype object and specify the list of operators that it supports. In addition, specify the name of the implementation type that implements the ODCIIndexXXX() interface routines.</p>
<pre dir="ltr">CREATE INDEXTYPE psbtree
FOR
     eq(VARCHAR2, VARCHAR2),
     lt(VARCHAR2, VARCHAR2),
     gt(VARCHAR2, VARCHAR2)
USING psbtree_im
WITH LOCAL RANGE PARTITION
WITH SYSTEM MANAGED STORAGE TABLES
</pre></div>
</div>
</div>
<a id="ADDCI4920"></a>
<div class="props_rev_3"><a id="GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F"></a>
<h2 id="ADDCI-GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F" class="sect2">Using PSBTREE</h2>
<div>
<p>You should next create the indextype object and specify the list of operators that it supports. In addition, specify the name of the implementation type that implements the <code class="codeph">ODCIIndex</code><span class="italic"><code class="codeph">XXX</code></span><code class="codeph">()</code> interface routines. This step is demonstrated in the <a href="psbtree_example.htm#GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2">Implementing the Indextype for PSBTREE</a> section.</p>
<p>One typical usage scenario is to create a range partitioned table and populate it, as demonstrated in the <a href="psbtree_example.htm#GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2">Creating and Populating a Partitioned Table for PSBTREE</a> section.</p>
<p>You can then create a <code class="codeph">psbtree</code> index on column <code class="codeph">f2</code>. The <code class="codeph">CREATE INDEX</code> statement specifies the indextype that should be used, as demonstrated in the <a href="psbtree_example.htm#GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D">Creating a PSBTREE Index on a Column</a> section.</p>
<p>To execute a query that uses one of the <code class="codeph">psbtree</code> operators, use the code in the <a href="psbtree_example.htm#GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C">Using PSBTREE Operators in a Query</a> section.</p>
</div>
<a id="CACCEACF"></a>
<div class="props_rev_3"><a id="GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2"></a>
<h3 id="ADDCI-GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2" class="sect3">Creating and Populating a Partitioned Table for PSBTREE</h3>
<div>
<div class="section">
<pre dir="ltr">CREATE TABLE t1 (f1 NUMBER, f2 VARCHAR2(200))
PARTITION BY RANGE(f1)
(
  PARTITION p1 VALUES LESS THAN (101),
  PARTITION p2 VALUES LESS THAN (201),
  PARTITION p3 VALUES LESS THAN (301),
  PARTITION p4 VALUES LESS THAN (401)
 );
INSERT INTO t1 VALUES (10, &#39;aaaa&#39;);
INSERT INTO t1 VALUES (200, &#39;bbbb&#39;);
INSERT INTO t1 VALUES (100, &#39;cccc&#39;);
INSERT INTO t1 VALUES (300, &#39;dddd&#39;);
INSERT INTO t1 VALUES (400, &#39;eeee&#39;);
COMMIT;
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACJJHIG"></a>
<div class="props_rev_3"><a id="GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D"></a>
<h3 id="ADDCI-GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D" class="sect3">Creating a PSBTREE Index on a Column</h3>
<div>
<div class="section">
<pre dir="ltr">CREATE INDEX it1 ON t1(f2) iINDEXTYPE IS psbtree LOCAL 
(PARTITION pe1 PARAMETERS(&#39;test1&#39;), PARTITION pe2,
 PARTITION pe3, PARTITION pe4 PARAMETERS(&#39;test4&#39;)) 
PARAMETERS(&#39;test&#39;);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="CACHDCED"></a>
<div class="props_rev_3"><a id="GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C"></a>
<h3 id="ADDCI-GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C" class="sect3">Using PSBTREE Operators in a Query</h3>
<div>
<div class="section">
<pre dir="ltr">SELECT * FROMM t1 WHERE eq(f2, &#39;dddd&#39;) = 1 AND f1&gt;101 ;
</pre>
<p>The explain plan output for this query should look like this:</p>
<pre dir="ltr">OPERATION            OPTIONS                PARTITION_START       PARTITION_STOP
--------------------------------------------------------------------------------
SELECT STATEMENT
PARTITION RANGE      ITERATOR               2                     4
TABLE ACCESS         BY LOCAL INDEX ROWID   2                     4
DOMAIN INDEX
</pre></div>
<!-- class="section" --></div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5977">
<tr>
<td class="cellalignment5984">
<table class="cellalignment5982">
<tr>
<td class="cellalignment5981"><a href="pwr_example.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5981"><a href="pipelined_example.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5986">
<table class="cellalignment5980">
<tr>
<td class="cellalignment5981"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5981"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5981"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5981"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5981"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5981"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>