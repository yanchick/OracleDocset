<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-107475"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/XLA%20and%20TimesTen%20Event%20Management"></a><title>XLA and TimesTen Event Management</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1033"/>
<meta name="dcterms.created" content="2014-12-10T16:46:47Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen In-Memory Database C Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E21637-09"/>
<meta name="dcterms.isVersionOf" content="TTCDV"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pro_c.htm" title="Previous" type="text/html"/>
<link rel="Next" href="xa_dtp.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21637-09.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/15</span> <!-- End Header -->
<div id="TTCDV246" class="chapter"><a id="BABDBAHB"></a>
<h1 class="chapter"><span class="secnum">5</span> XLA and TimesTen Event Management <a id="sthref270"></a></h1>
<p><a id="sthref271"></a>The TimesTen Transaction Log API (XLA) is a set of C language functions that enable you to implement applications to perform the following:</p>
<ul>
<li>
<p>Monitor TimesTen for changes to specified tables in a local database.</p>
</li>
<li>
<p>Receive real-time notification of these changes.</p>
</li>
</ul>
<p>The primary purpose of XLA is as a high-performance, asynchronous alternative to triggers.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In the unlikely event that TimesTen replication solutions described in <a class="olink TTREP" href="../TTREP/toc.htm"><span class="italic">Oracle TimesTen In-Memory Database Replication Guide</span></a> do not meet your needs, it is possible to use XLA functions to build a custom data replication solution.</div>
<p>This chapter includes the following topics:</p>
<ul>
<li>
<p><a href="#BABGAJII">XLA concepts</a></p>
</li>
<li>
<p><a href="#BABIGHAJ">Writing an XLA event-handler application</a></p>
</li>
<li>
<p><a href="#BABDFIBJ">Using XLA as a replication mechanism</a></p>
</li>
<li>
<p><a href="#BABCIICJ">Other XLA features</a></p>
</li>
</ul>
<p>For a complete description of each XLA function, see <a href="xla_ref.htm#CHECFFJB">Chapter 9, &#34;XLA Reference&#34;</a>.</p>
<a id="BABGAJII"></a>
<div id="TTCDV247" class="sect1">
<h2 class="sect1">XL<a id="sthref272"></a>A concepts</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#BABCGFJI">XLA basics</a></p>
</li>
<li>
<p><a href="#BABGCDAA">How XLA reads records from the transaction log</a></p>
</li>
<li>
<p><a href="#BABIIDAF">About XLA and materialized views</a></p>
</li>
<li>
<p><a href="#BABEIFGE">About XLA bookmarks</a></p>
</li>
<li>
<p><a href="#BABFCAFA">About XLA data types</a></p>
</li>
<li>
<p><a href="#CIHIDBJJ">Access control impact on XLA</a></p>
</li>
<li>
<p><a href="#CIHJGHHB">XLA limitations</a></p>
</li>
<li>
<p><a href="#CIHEBAHG">XLA demo</a></p>
</li>
</ul>
<p>XLA functions mentioned here are documented in <a href="xla_ref.htm#CHECFFJB">Chapter 9, &#34;XLA Reference&#34;</a>.</p>
<a id="BABCGFJI"></a>
<div id="TTCDV248" class="sect2">
<h3 class="sect2">XLA basics</h3>
<p>TimesTen XLA obtains update records directly from the transaction log buffer or transaction log files, so the records are available for as long as they are needed. The logging model also enables multiple readers to simultaneously read transaction log updates.</p>
<p>The <code dir="ltr"><a href="xla_ref.htm#CHEFECEF">ttXlaPersistOpen</a></code> XLA function opens a connection to the database.</p>
<p>When initially created, TimesTen configures a transaction log handle for the same version as the TimesTen release to which the application is linked. You can also use the <code dir="ltr"><a href="xla_ref.htm#CHECDAAF">ttXlaGetVersion</a></code> and <code dir="ltr"><a href="xla_ref.htm#CHEHHHGI">ttXlaSetVersion</a></code> XLA functions to interoperate with earlier XLA versions.</p>
</div>
<!-- class="sect2" -->
<a id="BABGCDAA"></a>
<div id="TTCDV249" class="sect2">
<h3 class="sect2">How XLA reads records from the transaction log</h3>
<p>As applications modify a database, TimesTen generates transaction log records that describe the changes made to the data and other events such as transaction commits.</p>
<p>New transaction log records are always written to the end of the log buffer as they are generated.</p>
<p>Transaction log records are periodically flushed in batches from the log buffer in memory to transaction log files on disk. When XLA is initialized, the XLA application does not have to be concerned with which portions of the transaction log are on disk or in memory. Therefore, the term &#34;transaction log&#34; as used in this chapter refers to the &#34;virtual&#34; source of transaction update records, regardless of whether those records are physically located in memory or on disk.</p>
<p>Applications can use XLA to monitor the transaction log for changes to the database. XLA reads through the transaction log, filters the log records, and delivers to XLA applications a list of transaction records that contain the changes to the tables and columns of interest.</p>
<p>XLA sorts the records into discrete transactions. If multiple applications are updating the database simultaneously, transaction log records from the different applications are interleaved in the transaction log.</p>
<p>XLA transparently extracts all transaction log records associated with a particular transaction and delivers them in a contiguous list to the application.</p>
<p>Only the records for committed transactions are returned. They are returned in the order in which their final commit record appears in the transaction log. XLA filters out records associated with changes to the database that have not yet been committed.</p>
<p>If a change is made but then rolled back, XLA does not deliver the records for the aborted transaction to the application.</p>
<p>Most of these basic XLA concepts are demonstrated in <a href="#BABJGCBF">Example 5-1</a> that follows and summarized in the bulleted list following the example.</p>
<p>Consider the example transaction log illustrated in <a href="#BABFJFED">Figure 5-1</a>.</p>
<div id="TTCDV250" class="figure">
<p class="titleinfigure"><a id="BABFJFED"></a>Figure 5-1 Records extracted from the transaction log</p>
<img width="626" height="166" src="img/transaction_log.gif" alt="Description of Figure 5-1 follows"/><br/>
<a id="sthref273" href="img_text/transaction_log.htm">Description of &#34;Figure 5-1 Records extracted from the transaction log&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="TTCDV251" class="example">
<p class="titleinexample"><a id="BABJGCBF"></a>Example 5-1 Reading transaction log records</p>
<p>In this example, the transaction log contains the following records:</p>
<br/>
<code dir="ltr">CT1</code> - Application <code dir="ltr">C</code> updates row 1 of table <code dir="ltr">W</code> with value 7.7.<br/>
<code dir="ltr">BT1</code> - Application <code dir="ltr">B</code> updates row 3 of table <code dir="ltr">X</code> with value 2.<br/>
<code dir="ltr">CT2</code> - Application <code dir="ltr">C</code> updates row 9 of table <code dir="ltr">W</code> with value 5.6.<br/>
<code dir="ltr">BT2</code> - Application <code dir="ltr">B</code> updates row 2 of table <code dir="ltr">Y</code> with value &#34;XYZ&#34;.<br/>
<code dir="ltr">AT1</code> - Application <code dir="ltr">A</code> updates row 1 of table <code dir="ltr">Z</code> with value 3.<br/>
<code dir="ltr">AT2</code> - Application <code dir="ltr">A</code> updates row 3 of table <code dir="ltr">Z</code> with value 4.<br/>
<code dir="ltr">BT3</code> - Application <code dir="ltr">B</code> commits its transaction.<br/>
<code dir="ltr">AT3</code> - Application <code dir="ltr">A</code> rolls back its transaction.<br/>
<code dir="ltr">CT3</code> - Application <code dir="ltr">C</code> commits its transaction.<br/>
<p>An XLA application that is set up to detect changes to tables <code dir="ltr">W</code>, <code dir="ltr">Y</code>, and <code dir="ltr">Z</code> would see the following:</p>
<br/>
<code dir="ltr">BT2</code> and <code dir="ltr">BT3</code> - Update row 2 of table <code dir="ltr">Y</code> with value &#34;XYZ&#34; and commit.<br/>
<code dir="ltr">CT1</code> - Update row 1 of table <code dir="ltr">W</code> with value 7.7.<br/>
<code dir="ltr">CT2</code> and <code dir="ltr">CT3</code> - Update row 9 of table <code dir="ltr">W</code> with value 5.6 and commit.<br/>
<p>This example demonstrates the following:</p>
<ul>
<li>
<p>Transaction records of applications <code dir="ltr">B</code> and <code dir="ltr">C</code> all appear together.</p>
</li>
<li>
<p>Although the records for application <code dir="ltr">C</code> begin to appear in the transaction log before those for application <code dir="ltr">B</code>, the commit for application <code dir="ltr">B</code> (<code dir="ltr">BT3</code>) appears in the transaction log before the commit for application <code dir="ltr">C</code> (<code dir="ltr">CT3</code>). As a result, the records for application <code dir="ltr">B</code> are returned to the XLA application ahead of those for application <code dir="ltr">C</code>.</p>
</li>
<li>
<p>The application <code dir="ltr">B</code> update to table <code dir="ltr">X</code> (<code dir="ltr">BT1</code>) is not presented because XLA is not set up to detect changes to table <code dir="ltr">X</code>.</p>
</li>
<li>
<p>The application <code dir="ltr">A</code> updates to table <code dir="ltr">Z</code> (<code dir="ltr">AT1</code> and <code dir="ltr">AT2</code>) are never presented because it did not commit and was rolled back (<code dir="ltr">AT3</code>).</p>
</li>
</ul>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABIIDAF"></a>
<div id="TTCDV252" class="sect2">
<h3 class="sect2">About XLA and ma<a id="sthref274"></a><a id="sthref275"></a>terialized views</h3>
<p>You can use XLA to track changes to both tables and materialized views. A materialized view provides a single source from which you can track changes to selected rows and columns in multiple detail tables. Without a materialized view, the XLA application would have to monitor and filter the update records from all of the detail tables, including records reflecting updates to rows and columns of no interest to the application.</p>
<p>In general, there are no operational differences between the XLA mechanisms used to track changes to a table or a materialized view. However, for asynchronous materialized views, be aware that the order of XLA notifications for an asynchronous materialized view is not necessarily the same as it would be for the associated detail tables, or the same as it would be for a synchronous materialized view. For example, if there are two inserts to a detail table, they may be done in the opposite order in the asynchronous materialized view. Furthermore, an update to a detail table of a materialized view may be reported by XLA as a delete followed by an insert. Also, multiple operations, such as multiple inserts or multiple deletes, may be combined into a single operation. Applications that depend on precise ordering should not use asynchronous materialized views.</p>
<p>For more information about materialized views, see the following:</p>
<ul>
<li>
<p><a class="olink TTSQL293" href="../TTSQL/state.htm#TTSQL293">&#34;CREATE MATERIALIZED VIEW&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span></p>
</li>
<li>
<p><a class="olink TTOPR359" href="../TTOPR/comp.htm#TTOPR359">&#34;Understanding materialized views&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABEIFGE"></a>
<div id="TTCDV253" class="sect2">
<h3 class="sect2">About XL<a id="sthref276"></a>A bookm<a id="sthref277"></a>arks</h3>
<p>E<a id="sthref278"></a>ach XLA reader uses a bookmark to maintain its position in the log update stream. Each bookmark consists of two pointers that track update records in the transaction log by using <span class="italic">log record identifiers</span>:</p>
<ul>
<li>
<p>An Initial Read log record identifier points to the most recently acknowledged transaction log record. Initial Read log record identifiers are stored in the database, so they are persistent across database connections, shutdowns, and failures.</p>
</li>
<li>
<p>A Current Read log record identifier points to the record currently being read from the transaction log.</p>
</li>
</ul>
<p>The rest of this section covers the following:</p>
<ul>
<li>
<p><a href="#CIHIBECA">Creating or reusing a bookmark</a></p>
</li>
<li>
<p><a href="#CIHDJDAG">How bookmarks work</a></p>
</li>
<li>
<p><a href="#CIHHHECG">Replicated bookmarks</a></p>
</li>
<li>
<p><a href="#CIHGHAGE">XLA bookmarks and transaction log holds</a></p>
</li>
</ul>
<a id="CIHIBECA"></a>
<div id="TTCDV254" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Cre<a id="sthref279"></a>ating or reusing a bookmark</h4>
<p>As described in <a href="#BABBGAJJ">&#34;Initializing XLA and obtaining an XLA handle&#34;</a>, when you call the <code dir="ltr"><a href="xla_ref.htm#CHEFECEF">ttXlaPersistOpen</a></code> function to initialize an XLA handle, you have a <code dir="ltr"><span class="codeinlineitalic">tag</span></code> parameter to identify either a new bookmark or one that exists in the system, and an <code dir="ltr"><span class="codeinlineitalic">options</span></code> parameter to specify whether it is a new non-replicated bookmark, a new replicated bookmark, or an existing (reused) bookmark. At this time, the Initial Read log record identifier associated with the bookmark is read from the database and cached in the XLA handle (<code dir="ltr">ttXlaHandle_h</code>). It designates the start position of the reader in the transaction log.</p>
<p>See <a class="olink TTREF261" href="../TTREF/proced.htm#TTREF261">&#34;ttLogHolds&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for related information. That TimesTen built-in procedure returns information about transaction log holds.</p>
</div>
<!-- class="sect3" -->
<a id="CIHDJDAG"></a>
<div id="TTCDV255" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">How bo<a id="sthref280"></a>okmarks work</h4>
<p>When an application first initializes XLA and obtains an XLA handle, its Current Read log record identifier and Initial Read log record identifier both point to the last record written to the database, as shown in <a href="#BABJGIDI">Figure 5-2</a> that follows.</p>
<div id="TTCDV256" class="figure">
<p class="titleinfigure"><a id="BABJGIDI"></a>Figure 5-2 Log record indicator positions upon initializing an XLA handle</p>
<img width="626" height="116" src="img/current_read_lsn.gif" alt="Description of Figure 5-2 follows"/><br/>
<a id="sthref281" href="img_text/current_read_lsn.htm">Description of &#34;Figure 5-2 Log record indicator positions upon initializing an XLA handle&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>As described in <a href="#BABHJGCD">&#34;Retrieving update records from the transaction log&#34;</a>, use the <code dir="ltr"><a href="xla_ref.htm#CHEJGJBH">ttXlaNextUpdate</a></code> or <code dir="ltr"><a href="xla_ref.htm#CHEBCAAE">ttXlaNextUpdateWait</a></code> function to return a batch of records for committed transactions from the transaction log in the order in which they were committed. Each call to <code dir="ltr">ttXlaNextUpdate</code> resets the Current Read log record identifier of the bookmark to the last record read, as shown in <a href="#BABDEDBB">Figure 5-3</a>. The Current Read log record identifier marks the start position for the next call to <code dir="ltr">ttXlaNextUpdate</code>.</p>
<div id="TTCDV257" class="figure">
<p class="titleinfigure"><a id="BABDEDBB"></a>Figure 5-3 Records retrieved by ttXlaNextUpdate</p>
<img width="612" height="196" src="img/records_retrieved.gif" alt="Description of Figure 5-3 follows"/><br/>
<a id="sthref282" href="img_text/records_retrieved.htm">Description of &#34;Figure 5-3 Records retrieved by ttXlaNextUpdate&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>You can use the <code dir="ltr"><a href="xla_ref.htm#CHEICHBA">ttXlaGetLSN</a></code> and <code dir="ltr"><a href="xla_ref.htm#CHEDFIEI">ttXlaSetLSN</a></code> functions to reread records, as described in <a href="#BABFCJIB">&#34;Changing the location of a bookmark&#34;</a>. However, calling the <code dir="ltr"><a href="xla_ref.htm#CHEDIAFE">ttXlaAcknowledge</a></code> function permanently resets the Initial Read log record identifier of the bookmark to its Current Read log record identifier, as shown in <a href="#BABJCCEH">Figure 5-4</a>. After you have called the <code dir="ltr">ttXlaAcknowledge</code> function to reset the Initial Read log record identifier, all previously read transaction records are flagged for purging by TimesTen. Once the Initial Read log record identifier is reset, you cannot use <code dir="ltr">ttXlaSetLSN</code> to go back and reread any of the previously read transactions.</p>
<div id="TTCDV258" class="figure">
<p class="titleinfigure"><a id="BABJCCEH"></a>Figure 5-4 ttXlaAcknowledge resets bookmark</p>
<img width="612" height="218" src="img/reset_bookmark.gif" alt="Description of Figure 5-4 follows"/><br/>
<a id="sthref283" href="img_text/reset_bookmark.htm">Description of &#34;Figure 5-4 ttXlaAcknowledge resets bookmark&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
A <code dir="ltr">ttXlaAcknowledge</code> call resets the bookmark even if there are no relevant update records to acknowledge. This may be useful in managing transaction log space, but should be balanced against the expense of the operation. Be aware that XLA purges transaction logs a file at a time. Refer to <a href="xla_ref.htm#CHEDIAFE">&#34;ttXlaAcknowledge&#34;</a> for details on how the operation works.</div>
<p>The number of bookmarks created in a database is limited to 64. Each bookmark can be associated with only one active connection at a time. However, a bookmark over its lifetime may be associated with many connections. An application can open a connection, create a new bookmark, associate the bookmark with the connection, read a few records using the bookmark, disconnect from the database, reconnect to the database, create a new connection, associate this new connection with the bookmark, and continue reading transaction log records from where the old connection stopped.</p>
</div>
<!-- class="sect3" -->
<a id="CIHHHECG"></a>
<div id="TTCDV259" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Re<a id="sthref284"></a>plicated bookmarks</h4>
<p>If you are using an active standby pair replication scheme, you have the option of using <span class="italic">replicated bookmarks</span> according to the <code dir="ltr"><span class="codeinlineitalic">options</span></code> settings in your <code dir="ltr"><a href="xla_ref.htm#CHEFECEF">ttXlaPersistOpen</a></code> calls. For a replicated bookmark, operations on the bookmark are replicated to the standby database as appropriate. This results in more efficient recovery of your bookmark positions in the event of failover. Reading resumes from the stream of XLA records close to the point at which they left off before the switchover to the new active store. Without replicated bookmarks, reading must go through numerous duplicate records that were returned on the old active store.</p>
<p>When you use replicated bookmarks, steps must be taken in the following order:</p>
<ol>
<li>
<p>Create the active standby pair replication scheme. (This is accomplished by the <code dir="ltr">create active standby pair</code> operation, or by the <code dir="ltr">ttCWAdmin -create</code> command in a Clusterware-managed environment.)</p>
</li>
<li>
<p>Create the bookmarks.</p>
</li>
<li>
<p>Subscribe the bookmarks.</p>
</li>
<li>
<p>Start the active standby pair, at which time duplication to the standby occurs and replication begins. (This is accomplished by the <code dir="ltr">ttRepAdmin -duplicate</code> command, or by the <code dir="ltr">ttCWAdmin -start</code> command in a Clusterware-managed environment.)</p>
</li>
</ol>
<p>Be aware of the following usage notes:</p>
<ul>
<li>
<p>The position of the bookmark in the standby database is very close to that of the bookmark in the active database; however, because the replication of acknowledge operations is asynchronous, you may see a small window of duplicate updates in the event of a failover, depending on how often acknowledge operations are performed.</p>
</li>
<li>
<p>You should close and reopen all bookmarks on a database after it changes from standby to active status, using the <code dir="ltr"><a href="xla_ref.htm#CHEEFEGG">ttXlaClose</a></code> and <code dir="ltr"><a href="xla_ref.htm#CHEFECEF">ttXlaPersistOpen</a></code> functions. The state of a replicated bookmark on a standby database does change during normal XLA processing, as the replication agent automatically repositions bookmarks as appropriate on standby databases. If you attempt to use a bookmark that was open before the database changed to active status, you receive an error indicating that the state of the bookmark was reset and that it has been repositioned. While it is permissible to continue reading from the repositioned bookmark in this scenario, you can avoid the error by closing and reopening bookmarks.</p>
</li>
<li>
<p>It is permissible to drop the active standby pair scheme while replicated bookmarks exist. The bookmarks of course cease to be replicated at that point, but are not deleted. If you subsequently re-enable the active standby pair scheme, these bookmarks are automatically added to the scheme.</p>
</li>
<li>
<p>You cannot delete replicated bookmarks as long as the replication agent is running.</p>
</li>
<li>
<p>You can only read and acknowledge a replicated bookmark in the active database. Each time you acknowledge a replicated bookmark, the acknowledge operation is asynchronously replicated to the standby database.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CIHGHAGE"></a>
<div id="TTCDV563" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">XLA bookmarks and transaction log holds</h4>
<p>You should be aware that when XLA is in use, there is a hold on TimesTen transaction log files until the XLA bookmark advances. The hold prevents transaction log files from being purged until XLA can confirm it no longer needs them. If a bookmark becomes stuck, which can occur if an XLA application terminates unexpectedly or disconnects without first deleting its bookmark or disabling change tracking, the log hold persists and there may be an excessive accumulation of transaction log files. This accumulation may result in disk space being filled.</p>
<p>For information about monitoring and addressing this situation, see <a class="olink TTOPR711" href="../TTOPR/trans.htm#TTOPR711">&#34;Monitoring accumulation of transaction log files&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABFCAFA"></a>
<div id="TTCDV260" class="sect2">
<h3 class="sect2">Ab<a id="sthref285"></a><a id="sthref286"></a>out XLA data types</h3>
<p><a href="#BABEHJEE">Table 5-1</a> shows the data type mapping between internal SQL data types and XLA data types before release 7.0 and since release 7.0. For more information about TimesTen data types, see <a class="olink TTSQL123" href="../TTSQL/types.htm#TTSQL123">&#34;Data Types&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<div id="TTCDV261" class="tblhruleformal">
<p class="titleintable"><a id="sthref287"></a><a id="BABEHJEE"></a>Table 5-1 XLA data type mapping</p>
<table class="cellalignment4366" title="XLA data type mapping" summary="This table shows the data type mappings between internal SQL data types and XLA data types." dir="ltr">
<thead>
<tr class="cellalignment4360">
<th class="cellalignment4367" id="r1c1-t4">Internal SQL data type</th>
<th class="cellalignment4367" id="r1c2-t4">XLA data type before Release 7.0</th>
<th class="cellalignment4367" id="r1c3-t4">XLA data type since Release 7.0</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r2c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_CHAR</code></p>
</td>
<td class="cellalignment4368" headers="r2c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_CHAR</code></p>
</td>
<td class="cellalignment4368" headers="r2c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_CHAR_TT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r3c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_VARCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r3c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_VARCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r3c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_VARCHAR_TT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r4c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_NCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r4c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_WCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r4c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_NCHAR_TT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r5c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_NVARCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r5c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_WVARCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r5c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_NVARCHAR_TT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r6c1-t4" headers="r1c1-t4">
<p><code dir="ltr">CHAR</code></p>
</td>
<td class="cellalignment4368" headers="r6c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r6c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_CHAR</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r7c1-t4" headers="r1c1-t4">
<p><code dir="ltr">NCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r7c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r7c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_NCHAR</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r8c1-t4" headers="r1c1-t4">
<p><code dir="ltr">VARCHAR2</code></p>
</td>
<td class="cellalignment4368" headers="r8c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r8c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_VARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r9c1-t4" headers="r1c1-t4">
<p><code dir="ltr">NVARCHAR2</code></p>
</td>
<td class="cellalignment4368" headers="r9c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r9c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_NVARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r10c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_TINYINT</code></p>
</td>
<td class="cellalignment4368" headers="r10c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_TINYINT</code></p>
</td>
<td class="cellalignment4368" headers="r10c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_TINYINT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r11c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_SMALLINT</code></p>
</td>
<td class="cellalignment4368" headers="r11c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_SMALLINT</code></p>
</td>
<td class="cellalignment4368" headers="r11c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_SMALLINT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r12c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_INTEGER</code></p>
</td>
<td class="cellalignment4368" headers="r12c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_INTEGER</code></p>
</td>
<td class="cellalignment4368" headers="r12c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_INTEGER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r13c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_BIGINT</code></p>
</td>
<td class="cellalignment4368" headers="r13c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_BIGINT</code></p>
</td>
<td class="cellalignment4368" headers="r13c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_BIGINT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r14c1-t4" headers="r1c1-t4">
<p><code dir="ltr">BINARY_FLOAT</code></p>
</td>
<td class="cellalignment4368" headers="r14c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_REAL</code></p>
</td>
<td class="cellalignment4368" headers="r14c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_BINARY_FLOAT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r15c1-t4" headers="r1c1-t4">
<p><code dir="ltr">BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment4368" headers="r15c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_DOUBLE</code></p>
</td>
<td class="cellalignment4368" headers="r15c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_BINARY_DOUBLE</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r16c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_DECIMAL</code></p>
</td>
<td class="cellalignment4368" headers="r16c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_DECIMAL</code></p>
</td>
<td class="cellalignment4368" headers="r16c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_DECIMAL_TT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r17c1-t4" headers="r1c1-t4">
<p><code dir="ltr">NUMBER</code></p>
</td>
<td class="cellalignment4368" headers="r17c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r17c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r18c1-t4" headers="r1c1-t4">
<p><code dir="ltr">NUMBER(</code><code dir="ltr"><span class="codeinlineitalic">p,s</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment4368" headers="r18c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r18c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r19c1-t4" headers="r1c1-t4">
<p><code dir="ltr">FLOAT</code></p>
</td>
<td class="cellalignment4368" headers="r19c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r19c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r20c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_TIME</code></p>
</td>
<td class="cellalignment4368" headers="r20c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_TIME</code></p>
</td>
<td class="cellalignment4368" headers="r20c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_TIME</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r21c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_DATE</code></p>
</td>
<td class="cellalignment4368" headers="r21c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_DATE</code></p>
</td>
<td class="cellalignment4368" headers="r21c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_DATE_TT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r22c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_TIMESTAMP</code></p>
</td>
<td class="cellalignment4368" headers="r22c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_TIMESTAMP</code></p>
</td>
<td class="cellalignment4368" headers="r22c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_TIMESTAMP_TT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r23c1-t4" headers="r1c1-t4">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment4368" headers="r23c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r23c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_DATE</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r24c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment4368" headers="r24c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r24c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_TIMESTAMP</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r25c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_BINARY</code></p>
</td>
<td class="cellalignment4368" headers="r25c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_BINARY</code></p>
</td>
<td class="cellalignment4368" headers="r25c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_BINARY</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r26c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TT_VARBINARY</code></p>
</td>
<td class="cellalignment4368" headers="r26c1-t4 r1c2-t4">
<p><code dir="ltr">SQL_VARBINARY</code></p>
</td>
<td class="cellalignment4368" headers="r26c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_VARBINARY</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r27c1-t4" headers="r1c1-t4">
<p><code dir="ltr">ROWID</code></p>
</td>
<td class="cellalignment4368" headers="r27c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r27c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_ROWID</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r28c1-t4" headers="r1c1-t4">
<p><code dir="ltr">BLOB</code></p>
</td>
<td class="cellalignment4368" headers="r28c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r28c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_BLOB</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r29c1-t4" headers="r1c1-t4">
<p><code dir="ltr">CLOB</code></p>
</td>
<td class="cellalignment4368" headers="r29c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r29c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_CLOB</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r30c1-t4" headers="r1c1-t4">
<p><code dir="ltr">NCLOB</code></p>
</td>
<td class="cellalignment4368" headers="r30c1-t4 r1c2-t4">
<p>-</p>
</td>
<td class="cellalignment4368" headers="r30c1-t4 r1c3-t4">
<p><code dir="ltr">TTXLA_NCLOB</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p>XLA offers functions to convert between internal SQL data types and external programmatic data types. For example, you can use <code dir="ltr"><a href="xla_ref.htm#CHEDEBGF">ttXlaNumberToCString</a></code> to convert <code dir="ltr">NUMBER</code> columns to character strings. TimesTen provides the following XLA data type conversion functions:</p>
<ul>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEBBJGA">ttXlaDateToODBCCType</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHECEIIC">ttXlaDecimalToCString</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEDEBGF">ttXlaNumberToCString</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEHCCAB">ttXlaNumberToDouble</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEECECB">ttXlaNumberToBigInt</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEJBFAA">ttXlaNumberToInt</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEDEHAG">ttXlaNumberToSmallInt</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEIDCJA">ttXlaNumberToTinyInt</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEHJJGF">ttXlaNumberToUInt</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEHBFCG">ttXlaOraDateToODBCTimeStamp</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEDABHC">ttXlaOraTimeStampToODBCTimeStamp</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#BABCFHDF">ttXlaRowidToCString</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEDFIJH">ttXlaTimeToODBCCType</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHECCIIG">ttXlaTimeStampToODBCCType</a></code></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIHIDBJJ"></a>
<div id="TTCDV262" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Ac<a id="sthref288"></a><a id="sthref289"></a>cess control impact on XLA</h3>
<p><a href="writing_app.htm#BABFJBFE">&#34;Considering TimesTen features for access control&#34;</a> provides a brief overview of how TimesTen access control affects operations in the database. Access control impacts XLA as follows:</p>
<ul>
<li>
<p>Any XLA functionality, such as the following, requires the system privilege <code dir="ltr">XLA</code>:</p>
<ul>
<li>
<p>Connecting to TimesTen (which also requires the <code dir="ltr">CREATE SESSION</code> privilege) as an XLA reader, such as by the <code dir="ltr">ttXlaPersistOpen</code> C function</p>
</li>
<li>
<p>Executing any other XLA-related TimesTen C functions, documented in <a href="xla_ref.htm#CHECFFJB">Chapter 9, &#34;XLA Reference&#34;</a></p>
</li>
<li>
<p>Executing any XLA-related TimesTen built-in procedures</p>
<p>The procedures <code dir="ltr">ttXlaBookmarkCreate</code>, <code dir="ltr">ttXlaBookmarkDelete</code>, <code dir="ltr">ttXlaSubscribe</code>, and <code dir="ltr">ttXlaUnsubscribe</code> are documented in <a class="olink TTREF213" href="../TTREF/proced.htm#TTREF213">&#34;Built-In Procedures&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</li>
</ul>
</li>
<li>
<p>A user with the <code dir="ltr">XLA</code> privilege has capabilities equivalent to the <code dir="ltr">SELECT ANY TABLE</code>, <code dir="ltr">SELECT ANY VIEW</code>, and <code dir="ltr">SELECT ANY SEQUENCE</code> system privileges, and can capture DDL statement records that occur in the database. Note that as a result, the user can obtain information about database objects that he or she has not otherwise been granted access to.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIHJGHHB"></a>
<div id="TTCDV560" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XL<a id="sthref290"></a>A limitations</h3>
<p>Be aware of the following limitations when you use TimesTen XLA:</p>
<ul>
<li>
<p>XLA is available on all platforms supported by TimesTen. However, XLA does not support data transfer between different platforms or between 32-bit and 64-bit versions of the same platform.</p>
</li>
<li>
<p>XL<a id="sthref291"></a>A support for LOBs is limited. See <a href="#BABHGGDB">&#34;Specifying which tables to monitor for updates&#34;</a> for information.</p>
</li>
<li>
<p>XLA does not support applications linked with a driver manager library or the client/server library. (The TimesTen driver manager supplied with the Quick Start applications does support XLA but is not fully supported itself. See the note regarding this driver manager in <a href="compiling.htm#CEGEJCJJ">&#34;Linking with an ODBC driver manager&#34;</a>.)</p>
</li>
<li>
<p>An XLA reader cannot subscribe to a table that uses in-memory columnar compression.</p>
</li>
<li>
<p>Fo<a id="sthref292"></a>r autorefresh cache groups, the change-tracking trigger on Oracle Database does not have column-level resolution. (To have that would be very expensive.) Therefore, the autorefresh feature updates all the columns in the row, and XLA can only report that all the columns have changed, even if data did not actually change in all columns.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIHEBAHG"></a>
<div id="TTCDV263" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XL<a id="sthref293"></a>A demo</h3>
<p>TimesTen provides the <code dir="ltr">xlaSimple</code> demo showing how to use many of the XLA functions described in this chapter. It is located in the <code dir="ltr">quickstart/sample_code/odbc/xla</code> directory:</p>
<p>See <a href="compiling.htm#CEGCJCJG">&#34;About the TimesTen C demos&#34;</a> for an overview of TimesTen demo programs for C developers. Refer to <code dir="ltr"><span class="codeinlineitalic">install_dir</span></code><code dir="ltr">/quickstart.html</code> for details. The README file in the <code dir="ltr">odbc</code> directory contains instructions for building and running <code dir="ltr">xlaSimple</code>, among others.</p>
<p>Most of this chapter, including the sample code shown in <a href="#BABIGHAJ">&#34;Writing an XLA event-handler application&#34;</a> starting immediately below, is based on the <code dir="ltr">xlaSimple</code> demo. For this demo, a table <code dir="ltr">MYDATA</code> has been created in the <code dir="ltr">APPUSER</code> schema. While you are logged in as <code dir="ltr">APPUSER</code>, you are making updates to the table. While you are logged in as <code dir="ltr">XLAUSER</code>, the <code dir="ltr">xlaSimple</code> demo reports on the updates.</p>
<p>To run the demo, execute <code dir="ltr">xlaSimple</code> at one command prompt. You are prompted for the password of <code dir="ltr">XLAUSER</code>, which is specified when the sample database is created. Start <code dir="ltr">ttIsql</code> at a separate command prompt, connecting to the TimesTen sample database as <code dir="ltr">APPUSER</code>. Again, you are prompted for a password that is specified when the sample database is created.</p>
<p>At the <code dir="ltr">ttIsql</code> command prompt you can enter DML statements to alter the table. Then you can view the XLA output in the <code dir="ltr">xlaSimple</code> window.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABIGHAJ"></a>
<div id="TTCDV264" class="sect1">
<h2 class="sect1">Wri<a id="sthref294"></a>ting an XLA event-handler application</h2>
<p>This section describes the general procedures for writing an XLA application that detects and reports changes to selected tables in a database. With the possible exception of <a href="#BABEGHDA">&#34;Inspecting column data&#34;</a>, the procedures described in this section are applicable to most XLA applications.</p>
<p>The following procedures are described:</p>
<ul>
<li>
<p><a href="#BABGGBIC">Obtaining a database connection handle</a></p>
</li>
<li>
<p><a href="#BABBGAJJ">Initializing XLA and obtaining an XLA handle</a></p>
</li>
<li>
<p><a href="#BABHGGDB">Specifying which tables to monitor for updates</a></p>
</li>
<li>
<p><a href="#BABHJGCD">Retrieving update records from the transaction log</a></p>
</li>
<li>
<p><a href="#BABEHGIG">Inspecting record headers and locating row addresses</a></p>
</li>
<li>
<p><a href="#BABEGHDA">Inspecting column data</a></p>
</li>
<li>
<p><a href="#BABJGJCJ">Handling XLA errors</a></p>
</li>
<li>
<p><a href="#BABFHIFC">Dropping a table that has an XLA bookmark</a></p>
</li>
<li>
<p><a href="#BABCFGIE">Deleting bookmarks</a></p>
</li>
<li>
<p><a href="#BABIFJIA">Terminating an XLA application</a></p>
</li>
</ul>
<p>The example code in this section is based on the <code dir="ltr">xlaSimple</code> demo application.</p>
<p>XLA functions mentioned here are documented in <a href="xla_ref.htm#CHECFFJB">Chapter 9, &#34;XLA Reference&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
In ad<a id="sthref295"></a>dition to files noted in <a href="writing_app.htm#BABHHHCF">&#34;TimesTen include files&#34;</a>, an XLA application must include <code dir="ltr">tt_xla.h</code>.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
To simplify the code examples, routine error checking code for each function call has been omitted. See <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a> for information on error handling.</div>
<a id="BABGGBIC"></a>
<div id="TTCDV265" class="sect2">
<h3 class="sect2">Ob<a id="sthref296"></a><a id="sthref297"></a>taining a database connection handle</h3>
<p>As with every ODBC application, an XLA application must initialize ODBC, obtain an environment handle (<code dir="ltr">henv</code>), and obtain a connection handle (<code dir="ltr">hdbc</code>) to communicate with the specific database.</p>
<p>Initialize the environment and connection handles:</p>
<pre dir="ltr">SQLHENV henv = SQL_NULL_HENV;
SQLHDBC hdbc = SQL_NULL_HDBC;
</pre>
<p>Pass the address of <code dir="ltr">henv</code> to the <code dir="ltr">SQLAllocEnv</code> ODBC function to allocate an environment handle:</p>
<pre dir="ltr">rc = SQLAllocEnv(&amp;henv);
</pre>
<p>Pass the address of <code dir="ltr">hdbc</code> to the <code dir="ltr">SQLAllocConnect</code> ODBC function to allocate a connection handle for the database:</p>
<pre dir="ltr">rc = SQLAllocConnect(henv, &amp;hdbc);
</pre>
<p>Call the <code dir="ltr">SQLDriverConnect</code> ODBC function to connect to the database specified by the connection string (<code dir="ltr">connStr</code>), which in this example is passed from the command line:</p>
<pre dir="ltr">static char connstr[CONN_STR_LEN];
...
rc = SQLDriverConnect(hdbc, NULL, (SQLCHAR*)connstr, SQL_NTS, NULL, 0,
                      NULL, SQL_DRIVER_COMPLETE);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
After an ODBC connection handle is opened for use by an XLA application, the ODBC handle cannot be used for ODBC operations until the corresponding XLA handle is closed by calling <code dir="ltr"><a href="xla_ref.htm#CHEEFEGG">ttXlaClose</a></code>.</div>
<p>Call the <code dir="ltr">SQLSetConnectOption</code> ODBC function to turn autocommit off:</p>
<pre dir="ltr">rc = SQLSetConnectOption(hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF);
</pre></div>
<!-- class="sect2" -->
<a id="BABBGAJJ"></a>
<div id="TTCDV266" class="sect2">
<h3 class="sect2">Initia<a id="sthref298"></a>lizing XLA and obtaining an XLA handle</h3>
<p>After initializing ODBC and obtaining an environment and connection handle as described in the preceding section, <a href="#BABGGBIC">&#34;Obtaining a database connection handle&#34;</a>, you can initialize XLA and obtain an XLA handle to access the transaction log. Create only one XLA handle per ODBC connection. If your application uses multiple XLA reader threads (each connected to its own XLA bookmark), create a separate XLA handle and ODBC connection for each thread.</p>
<p>This section describes how to initialize XLA. Before initializing XLA, initialize a bookmark. Then initialize an XLA handle as type <a id="sthref299"></a><code dir="ltr">ttXlaHandle_h</code>:</p>
<pre dir="ltr">unsigned char bookmarkName [32];
...
strcpy((char*)bookmarkName, &#34;xlaSimple&#34;);
...
ttXlaHandle_h xla_handle = NULL;
</pre>
<p>Pass <code dir="ltr">bookmarkName</code> and the address of <code dir="ltr">xla_handle</code> to the <a id="sthref300"></a><code dir="ltr"><a href="xla_ref.htm#CHEFECEF">ttXlaPersistOpen</a></code> function to obtain an XLA handle:</p>
<pre dir="ltr">rc = ttXlaPersistOpen(hdbc, bookmarkName, XLACREAT, &amp;xla_handle);
</pre>
<p>The <code dir="ltr">XLACREAT</code> option is used to create a new non-replicated bookmark. Alternatively, use the <code dir="ltr">XLAREPL</code> option to create a replicated bookmark. In either case, the operation fails if the bookmark already exists.</p>
<p>To use a bookmark that already exists, call <code dir="ltr">ttXlaPersistOpen</code> with the <code dir="ltr">XLAREUSE</code> option, as shown in the following example.</p>
<pre dir="ltr">#include &lt;tt_errCode.h&gt;      /* TimesTen Native Error codes */
...
    if ( native_error == 907 ) { /* tt_ErrKeyExists */
      rc = ttXlaPersistOpen(hdbc, bookmarkName, XLAREUSE, &amp;xla_handle);
    ...
    }
</pre>
<p>If <code dir="ltr">ttXlaPersistOpen</code> is given invalid parameters, or the application was unable to allocate memory for the handle, the return code is <code dir="ltr">SQL_INVALID_HANDLE</code>. In this situation, <code dir="ltr"><a href="xla_ref.htm#CHEECIEI">ttXlaError</a></code> cannot be used to detect this or any further errors.</p>
<p>If <code dir="ltr">ttXlaPersistOpen</code> fails but still creates a handle, the handle must be closed to prevent memory leaks.</p>
</div>
<!-- class="sect2" -->
<a id="BABHGGDB"></a>
<div id="TTCDV267" class="sect2">
<h3 class="sect2">Spe<a id="sthref301"></a><a id="sthref302"></a>cifying which tables to monitor for updates</h3>
<p>After initializing XLA and obtaining an XLA handle as described in the preceding section, <a href="#BABBGAJJ">&#34;Initializing XLA and obtaining an XLA handle&#34;</a>, you can specify which tables or materialized views you want to monitor for update events.</p>
<p>You can determine which tables a <a id="sthref303"></a>bookmark is subscribed to by querying the <code dir="ltr">SYS.XLASUBSCRIPTIONS</code> table. You can also use <code dir="ltr">SYS.XLASUBSCRIPTIONS</code> to determine which bookmarks have subscribed to a specific table.</p>
<p><a id="sthref304"></a>The <code dir="ltr"><a href="xla_ref.htm#CHEJGJBH">ttXlaNextUpdate</a></code> and <code dir="ltr"><a href="xla_ref.htm#CHEBCAAE">ttXlaNextUpdateWait</a></code> functions retrieve XLA records associated with DDL events. DDL XLA records are available to any XLA bookmark. DDL events include <code dir="ltr">CREATAB</code>, <code dir="ltr">DROPTAB</code>, <code dir="ltr">CREAIND</code>, <code dir="ltr">DROPIND</code>, <code dir="ltr">CREATVIEW</code>, <code dir="ltr">DROPVIEW</code>, <code dir="ltr">CREATSEQ</code>, <code dir="ltr">DROPSEQ</code>, <code dir="ltr">CREATSYN</code>, <code dir="ltr">DROPSYN</code>, <code dir="ltr">ADDCOLS</code>, <code dir="ltr">DRPCOLS</code>, and <code dir="ltr">TRUNCATE</code> transactions. See <a href="xla_ref.htm#CHEGEBFI">&#34;ttXlaUpdateDesc_t&#34;</a> for information about these event types.</p>
<p>The <code dir="ltr"><a href="xla_ref.htm#CHEHAAIF">ttXlaTableStatus</a></code> function subscribes the current bookmark to updates to the specified table. Or it determines whether the current bookmark is already monitoring DML records associated with the table.</p>
<p>Call the <a id="sthref305"></a><code dir="ltr"><a href="xla_ref.htm#CHEBGDFB">ttXlaTableByName</a></code> function to obtain both the system and user identifiers for a named table or materialized view. Then call the <a id="sthref306"></a><code dir="ltr">ttXlaTableStatus</code> function to enable XLA to monitor changes to the table or materialized view.</p>
<div class="infobox-note">
<p class="notep1">No<a id="sthref307"></a><a id="sthref308"></a>te:</p>
LOB support in XLA is limited, as follows:
<ul>
<li>
<p>You can subscribe to tables containing LOB columns, but information about the LOB value itself is unavailable.</p>
</li>
<li>
<p><code dir="ltr"><a href="xla_ref.htm#CHEEJABC">ttXlaGetColumnInfo</a></code> returns information about LOB columns.</p>
</li>
<li>
<p>Columns containing LOBs are reported as empty (zero length) or null (if the value is actually <code dir="ltr">NULL</code>). In this way, you can tell the difference between a null column and a non-null column.</p>
</li>
</ul>
</div>
<div id="TTCDV268" class="example">
<p class="titleinexample"><a id="sthref309"></a>Example 5-2 Specifying a table to monitor for updates</p>
<p>This example tracks changes to the <code dir="ltr">MYDATA</code> table.</p>
<pre dir="ltr">#define TABLE_OWNER &#34;APPUSER&#34;
#define TABLE_NAME &#34;MYDATA&#34;
...
SQLUBIGINT SYSTEM_TABLE_ID = 0;
...
SQLUBIGINT userID;

rc = ttXlaTableByName(xla_handle, TABLE_OWNER, TABLE_NAME,
                      &amp;SYSTEM_TABLE_ID, &amp;userID);
</pre></div>
<!-- class="example" -->
<p>When you have the table identifiers, you can use the <code dir="ltr">ttXlaTableStatus</code> function to enable XLA update tracking to detect changes to the <code dir="ltr">MYDATA</code> table. Setting the <code dir="ltr">newstatus</code> parameter to a nonzero value results in XLA tracking changes made to the specified table.</p>
<pre dir="ltr">SQLINTEGER oldstatus;
SQLINTEGER newstatus = 1;
...
rc = ttXlaTableStatus(xla_handle, SYSTEM_TABLE_ID, 0,
                      &amp;oldstatus, &amp;newstatus);
</pre>
<p>The <code dir="ltr">oldstatus</code> parameter is output to indicate the status of the table at the time of the call.</p>
<p>At any time, you can use <code dir="ltr">ttXlaTableStatus</code> to return the current XLA status of a table by leaving <code dir="ltr">newstatus</code> null and returning only <code dir="ltr">oldstatus</code>. For example:</p>
<pre dir="ltr">rc = ttXlaTableStatus(xla_handle, SYSTEM_TABLE_ID, 0,
                      &amp;oldstatus, NULL);
...
if (oldstatus != 0)
     printf(&#34;XLA is currently tracking changes to table %s.%s\n&#34;,
             TABLE_OWNER, TABLE_NAME);
else
     printf(&#34;XLA is not tracking changes to table %s.%s\n&#34;,
             TABLE_OWNER, TABLE_NAME);
</pre></div>
<!-- class="sect2" -->
<a id="BABHJGCD"></a>
<div id="TTCDV269" class="sect2">
<h3 class="sect2">Re<a id="sthref310"></a><a id="sthref311"></a>trieving update records from the transaction log</h3>
<p>Once you have specified which tables to monitor for updates, you can call the <a id="sthref312"></a><code dir="ltr"><a href="xla_ref.htm#CHEJGJBH">ttXlaNextUpdate</a></code> or <a id="sthref313"></a><code dir="ltr"><a href="xla_ref.htm#CHEBCAAE">ttXlaNextUpdateWait</a></code> function to return a batch of records from the transaction log. Only records for committed transactions are returned. They are returned in the order in which they were committed. You must periodically call the <a id="sthref314"></a><code dir="ltr"><a href="xla_ref.htm#CHEDIAFE">ttXlaAcknowledge</a></code> function to acknowledge receipt of the transactions so that XLA can determine which records are no longer needed and can be purged from the transaction log. These functions impact the position of the application bookmark in the transaction log, as described in <a href="#CIHDJDAG">&#34;How bookmarks work&#34;</a>. Also see <a class="olink TTREF261" href="../TTREF/proced.htm#TTREF261">&#34;ttLogHolds&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for related information. That TimesTen built-in procedure returns information about transaction log holds.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">ttXlaAcknowledge</code> function is an expensive operation and should be used only as necessary.</div>
<p>Each update record in a transaction returned by <code dir="ltr">ttXlaNextUpdate</code> begins with an update header described by the <a id="sthref315"></a><code dir="ltr"><a href="xla_ref.htm#CHEGEBFI">ttXlaUpdateDesc_t</a></code> structure. This update header contains a flag indicating if the record is the first in the transaction (<code dir="ltr">TT_UPDFIRST</code>) or the last commit record (<code dir="ltr">TT_UPDCOMMIT</code>). The update header also identifies the table affected by the update. Following the update header are zero to two rows of data that describe the update made to that table in the database.</p>
<p><a href="#BABFDDBG">Figure 5-5</a> that follows shows a call to <code dir="ltr">ttXlaNextUpdate</code> that returns a transaction consisting of four update records from the transaction log. Receipt of the returned transaction is acknowledged by calling <code dir="ltr">ttXlaAcknowledge</code>, which resets the bookmark.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example is simplified for clarity. An actual XLA application would likely read records for multiple transactions before calling <code dir="ltr">ttXlaAcknowledge</code>.</div>
<div id="TTCDV270" class="figure">
<p class="titleinfigure"><a id="BABFDDBG"></a>Figure 5-5 Update records</p>
<img width="566" height="236" src="img/update_records.gif" alt="Description of Figure 5-5 follows"/><br/>
<a id="sthref316" href="img_text/update_records.htm">Description of &#34;Figure 5-5 Update records&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="TTCDV271" class="example">
<p class="titleinexample"><a id="sthref317"></a>Example 5-3 Retrieving update records from the transaction log</p>
<p>The <code dir="ltr">xlaSimple</code> demo continues to monitor our table for updates until stopped by the user.</p>
<p>Before calling <code dir="ltr">ttXlaNextUpdateWait</code>, the example initializes a pointer to the buffer to hold the returned <code dir="ltr">ttXlaUpdateDesc_t</code> records (<code dir="ltr">arry</code>) and a variable to hold the actual number of returned records (<code dir="ltr">records</code>). Because the example calls <code dir="ltr">ttXlaNextUpdateWait</code>, it also specifies the number of seconds to wait (<code dir="ltr">FETCH_WAIT_SECS</code>) if no records are found in the transaction log buffer.</p>
<p>Next, call <code dir="ltr">ttXlaNextUpdateWait</code>, passing these values to obtain a batch of <code dir="ltr">ttXlaUpdateDesc_t</code> records in <code dir="ltr">arry</code>. Then process each record in <code dir="ltr">arry</code> by passing it to the <code dir="ltr">HandleChange()</code> function described in <a href="#BABHADHC">Example 5-4</a>. After all records are processed, call <code dir="ltr">ttXlaAcknowledge</code> to reset the bookmark position.</p>
<pre dir="ltr">#define FETCH_WAIT_SECS 5
...
SQLINTEGER records;
ttXlaUpdateDesc_t** arry;
int j;

while (!StopRequested()) {

    /* Get a batch of update records */
    rc = ttXlaNextUpdateWait(xla_handle, &amp;arry, 100,
                             &amp;records, FETCH_WAIT_SECS);
    if (rc != SQL_SUCCESS {
      /* See <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a> */
    }

    /* Process the records */
    for(j=0; j &lt; records; j++){
      ttXlaUpdateDesc_t* p;
      p = arry[j];
      HandleChange(p); /* Described in the next section */
    }

    /* After each batch, Acknowledge updates to reset bookmark.*/
    rc = ttXlaAcknowledge(xla_handle);
    if (rc != SQL_SUCCESS {
      /* See <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a> */
    }
} /* end while !StopRequested() */
</pre></div>
<!-- class="example" -->
<p>The actual number of records returned by <code dir="ltr">ttXlaNextUpdate</code> or <code dir="ltr">ttXlaNextUpdateWait</code>, as indicated by the <code dir="ltr"><span class="codeinlineitalic">nreturned</span></code> output parameter of those functions, may be less than the value of the <code dir="ltr"><span class="codeinlineitalic">maxrecords</span></code> parameter. <a href="#BABFHFDE">Figure 5-6</a> shows an example where <code dir="ltr"><span class="codeinlineitalic">maxrecords</span></code> is 10, the transaction log contains transaction <code dir="ltr">AT</code> that is made up of seven records, and transaction <code dir="ltr">BT</code> that is made up of three records. In this case, both transactions are returned in the same batch and both <code dir="ltr"><span class="codeinlineitalic">maxrecords</span></code> and <code dir="ltr"><span class="codeinlineitalic">nreturned</span></code> values are 10. However, the next three transactions in the log are <code dir="ltr">CT</code> with 11 records, <code dir="ltr">DT</code> with two records, and <code dir="ltr">ET</code> with two records. Because the commit record for the <code dir="ltr">DT</code> transaction appears before the <code dir="ltr">CT</code> commit record, the next call to <code dir="ltr">ttXlaNextUpdate</code> returns the two records for the <code dir="ltr">DT</code> transaction and the value of <code dir="ltr"><span class="codeinlineitalic">nreturned</span></code> is 2. In the next call to <code dir="ltr">ttXlaNextUpdate</code>, XLA detects that the total records for the <code dir="ltr">CT</code> transaction exceeds <code dir="ltr"><span class="codeinlineitalic">maxrecords</span></code>, so it returns the records for this transaction in two batches. The first batch contains the first 10 records for <code dir="ltr">CT</code> (<code dir="ltr"><span class="codeinlineitalic">nreturned</span></code> = 10). The second batch contains the last <code dir="ltr">CT</code> record and the two records for the <code dir="ltr">ET</code> transaction, assuming no commit record for a transaction following <code dir="ltr">ET</code> is detected within the next seven records.</p>
<p>See <a href="xla_ref.htm#CHEJGJBH">&#34;ttXlaNextUpdate&#34;</a> and <a href="xla_ref.htm#CHEBCAAE">&#34;ttXlaNextUpdateWait&#34;</a> for details of the parameters of these functions.</p>
<div id="TTCDV272" class="figure">
<p class="titleinfigure"><a id="BABFHFDE"></a>Figure 5-6 Records retrieved when maxrecords=10</p>
<img width="669" height="511" src="img/maxrecords.gif" alt="Description of Figure 5-6 follows"/><br/>
<a id="sthref318" href="img_text/maxrecords.htm">Description of &#34;Figure 5-6 Records retrieved when maxrecords=10&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>XLA reads records from either a memory buffer or transaction log files on disk, as described in <a href="#BABGCDAA">&#34;How XLA reads records from the transaction log&#34;</a>. To minimize latency, records from the memory buffer are returned as soon as they are available, while records not in the buffer are returned only if the buffer is empty. This design enables XLA applications to see changes as soon as the changes are made and with minimal latency. The trade-off is that there may be times when fewer changes are returned than the number requested by the <code dir="ltr">ttXlaNextUpdate</code> or <code dir="ltr">ttXlaNextUpdateWait</code> <code dir="ltr"><span class="codeinlineitalic">maxrecords</span></code> parameter.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For optimal throughput, XLA applications should make the &#34;fetch&#34; and &#34;process record&#34; procedures asynchronous. For example, you can create one thread to fetch and store the records and one or more other threads to process the stored records.</div>
</div>
<!-- class="sect2" -->
<a id="BABEHGIG"></a>
<div id="TTCDV273" class="sect2">
<h3 class="sect2">Ins<a id="sthref319"></a><a id="sthref320"></a>pecting record headers and locating row addresses</h3>
<p>Now that there is an array of update records where the type of operation each record represents is known, the returned row data can be inspected.</p>
<p>Each record returned by the <code dir="ltr"><a href="xla_ref.htm#CHEJGJBH">ttXlaNextUpdate</a></code> or <code dir="ltr"><a href="xla_ref.htm#CHEBCAAE">ttXlaNextUpdateWait</a></code> function begins with an <a id="sthref321"></a><code dir="ltr"><a href="xla_ref.htm#CHEGEBFI">ttXlaUpdateDesc_t</a></code> header that describes the following:</p>
<ul>
<li>
<p>The table on which the operation was performed</p>
</li>
<li>
<p>Whether the record is the first or last (commit) record in the transaction</p>
</li>
<li>
<p>The type of operation it represents</p>
</li>
<li>
<p>The length of the returned row data, if any</p>
</li>
<li>
<p>Which columns in the row were updated, if any</p>
</li>
</ul>
<p><a href="#BABFHDED">Figure 5-7</a> shows one of the update records in the transaction log.</p>
<div id="TTCDV274" class="figure">
<p class="titleinfigure"><a id="BABFHDED"></a>Figure 5-7 Address of row data returned in an XLA update record</p>
<img width="494" height="302" src="img/xla_record_row_addr.gif" alt="Description of Figure 5-7 follows"/><br/>
<a id="sthref322" href="img_text/xla_record_row_addr.htm">Description of &#34;Figure 5-7 Address of row data returned in an XLA update record&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The <code dir="ltr">ttXlaUpdateDesc_t</code> header has a fixed length and, depending on the type of operation, is followed by zero to two rows (or tuples) from the database. You can locate the address of the first returned row by obtaining the address of the <code dir="ltr">ttXlaUpdateDesc_t</code> header and adding it to <code dir="ltr">sizeof(ttXlaUpdateDesc_t)</code>:</p>
<pre dir="ltr">tup1 = (void*) ((char*) <span class="italic">ttXlaUpdateDesc_t</span> + sizeof(ttXlaUpdateDesc_t));
</pre>
<p>This is shown in <a href="#BABHADHC">Example 5-4</a> below.</p>
<p>The <code dir="ltr">ttXlaUpdateDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">type</span></code> field describes the type of SQL operation that generated the update. Transaction records of type <code dir="ltr">UPDATETTUP</code> describe <code dir="ltr">UPDATE</code> operations, so they return two rows to report the row data before and after the update. You can locate the address of the second returned row that holds the value after the update by adding the address of the first row in the record to its length:</p>
<pre dir="ltr">if (<span class="italic">ttXlaUpdateDesc_t</span>-&gt;type == UPDATETUP) {
  tup2 = (void*) ((char*) tup1 + <span class="italic">ttXlaUpdateDesc_t</span>-&gt;tuple1);
}
</pre>
<p>This is also shown in <a href="#BABHADHC">Example 5-4</a>.</p>
<div id="TTCDV275" class="example">
<p class="titleinexample"><a id="BABHADHC"></a>Example 5-4 Inspecting record headers for SQL operation type</p>
<p>This example passes each record returned by the <code dir="ltr">ttXlaNextUpdateWait</code> function to a <code dir="ltr">HandleChange()</code> function, which determines whether the record is related to an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">CREATE VIEW</code> operation. To keep this example simple, all other operations are ignored.</p>
<p>The <code dir="ltr">HandleChange()</code> function handles each type of SQL operation differently before calling the <code dir="ltr">PrintColValues()</code> function described in <a href="#BABFHDID">Example 5-13</a>.</p>
<pre dir="ltr">void HandleChange(ttXlaUpdateDesc_t* xlaP)
{
  void*  tup1;
  void*  tup2;
 
  /* First confirm that the XLA update is for the table we care about. */
  if (xlaP-&gt;sysTableID != SYSTEM_TABLE_ID)
    return ;
 
  /* OK, it&#39;s for the table we&#39;re monitoring. */
 
  /* The last record in the ttXlaUpdateDesc_t record is the &#34;tuple2&#34;
   * field.  Immediately following this field is the first XLA record &#34;row&#34;. */
 
  tup1 = (void*) ((char*) xlaP + sizeof(ttXlaUpdateDesc_t));
 
  switch(xlaP-&gt;type) {
 
  case INSERTTUP:
    printf(&#34;Inserted new row:\n&#34;);
    PrintColValues(tup1);
    break;
 
  case UPDATETUP:
 
    /* If this is an update ttXlaUpdateDesc_t, then following that is
     * the second XLA record &#34;row&#34;.  
     */
 
    tup2 = (void*) ((char*) tup1 + xlaP-&gt;tuple1);
    printf(&#34;Updated row:\n&#34;);
    PrintColValues(tup1);
    printf(&#34;To:\n&#34;);
    PrintColValues(tup2);
    break;
 
  case DELETETUP:
    printf(&#34;Deleted row:\n&#34;);
    PrintColValues(tup1);
    break;
 
  default:
    /* Ignore any XLA records that are not for inserts/update/delete SQL ops. */
    break;
 
  } /* switch (xlaP-&gt;type) */
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABEGHDA"></a>
<div id="TTCDV276" class="sect2">
<h3 class="sect2">Ins<a id="sthref323"></a><a id="sthref324"></a>pecting column data</h3>
<p>As described in <a href="#BABEHGIG">&#34;Inspecting record headers and locating row addresses&#34;</a>, zero to two rows of data may be returned in an update record after the <a id="sthref325"></a><code dir="ltr"><a href="xla_ref.htm#CHEGEBFI">ttXlaUpdateDesc_t</a></code> structure. For each row, the first portion of the data is the fixed-length data, which is followed by any variable-length data, as shown in <a href="#BABEFCDE">Figure 5-8</a>.</p>
<div id="TTCDV277" class="figure">
<p class="titleinfigure"><a id="BABEFCDE"></a>Figure 5-8 Column offsets in a row returned in an XLA update record</p>
<img width="580" height="326" src="img/xla_record.gif" alt="Description of Figure 5-8 follows"/><br/>
<a id="sthref326" href="img_text/xla_record.htm">Description of &#34;Figure 5-8 Column offsets in a row returned in an XLA update record&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The procedures for inspecting column data are described in the following sections:</p>
<ul>
<li>
<p><a href="#BABEEFHF">Obtaining column descriptions</a></p>
</li>
<li>
<p><a href="#BABDCEFE">Reading fixed-length column data</a></p>
</li>
<li>
<p><a href="#BABHAIJE">Reading NOT INLINE variable-length column data</a></p>
</li>
<li>
<p><a href="#BABFAIEJ">Null-terminating returned strings</a></p>
</li>
<li>
<p><a href="#BABIGJFI">Converting complex data types</a></p>
</li>
<li>
<p><a href="#BABHJEAG">Detecting null values</a></p>
</li>
<li>
<p><a href="#BABBABBI">Putting it all together: a PrintColValues() function</a></p>
</li>
</ul>
<a id="BABEEFHF"></a>
<div id="TTCDV278" class="sect3">
<h4 class="sect3">Obtaining column descriptions</h4>
<p>To read the column values from the returned row, you must first know the offset of each column in that row. The column offsets and other column metadata can be obtained for a particular table by calling the <a id="sthref327"></a><code dir="ltr"><a href="xla_ref.htm#CHEEJABC">ttXlaGetColumnInfo</a></code> function, which returns a separate <a id="sthref328"></a><code dir="ltr"><a href="xla_ref.htm#CHEIGBDD">ttXlaColDesc_t</a></code> structure for each column in the table. You should call the <code dir="ltr">ttXlaGetColumnInfo</code> function as part of your initialization procedure. This call was omitted from the discussion in <a href="#BABBGAJJ">&#34;Initializing XLA and obtaining an XLA handle&#34;</a> for simplicity.</p>
<p>When calling <code dir="ltr">ttXlaGetColumnInfo</code>, specify a <code dir="ltr"><span class="codeinlineitalic">colinfo</span></code> parameter to create a pointer to a buffer to hold the list of returned <code dir="ltr">ttXlaColDesc_t</code> structures. Use the <code dir="ltr"><span class="codeinlineitalic">maxcols</span></code> parameter to define the size of the buffer.</p>
<div id="TTCDV279" class="example">
<p class="titleinexample"><a id="BABGEDAG"></a>Example 5-5 Using column descriptions</p>
<p>The sample code from the <code dir="ltr">xlaSimple</code> demo below guesses the maximum number of returned columns (<code dir="ltr">MAX_XLA_COLUMNS</code>), which sets the size of the buffer <code dir="ltr">xla_column_defs</code> to hold the returned <code dir="ltr">ttXlaColDesc_t</code> structures. An alternative and more precise way to set the <code dir="ltr"><span class="codeinlineitalic">maxcols</span></code> parameter would be to call the <a id="sthref329"></a><code dir="ltr"><a href="xla_ref.htm#CHEDDJIC">ttXlaGetTableInfo</a></code> function and use the value returned in <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">columns</span></code>.</p>
<pre dir="ltr">#define MAX_XLA_COLUMNS 128
...
SQLINTEGER ncols;
...
ttXlaColDesc_t xla_column_defs[MAX_XLA_COLUMNS];
...
rc = ttXlaGetColumnInfo(xla_handle, SYSTEM_TABLE_ID, userID,
             xla_column_defs, MAX_XLA_COLUMNS, &amp;ncols);
  if (rc != SQL_SUCCESS {
    /* See <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a> */
}
</pre>
<p>As shown in <a href="#BABJAJGD">Figure 5-9</a>, the <code dir="ltr">ttXlaGetColumnInfo</code> function produces the following output:</p>
<ul>
<li>
<p>A list, <code dir="ltr">xla_column_defs</code>, of <code dir="ltr">ttXlaColDesc_t</code> structures into the buffer pointed to by the <code dir="ltr">ttXlaGetColumnInfo</code> <code dir="ltr"><span class="codeinlineitalic">colinfo</span></code> parameter</p>
</li>
<li>
<p>An <code dir="ltr"><span class="codeinlineitalic">nreturned</span></code> value, <code dir="ltr">ncols</code>, that holds the actual number of columns returned in the <code dir="ltr">xla_column_defs</code> buffer</p>
</li>
</ul>
</div>
<!-- class="example" -->
<div id="TTCDV280" class="figure">
<p class="titleinfigure"><a id="BABJAJGD"></a>Figure 5-9 ttXlaColDesc_t structures returned by ttXlaGetColumnInfo</p>
<img width="656" height="308" src="img/xla_coldesc.gif" alt="Description of Figure 5-9 follows"/><br/>
<a id="sthref330" href="img_text/xla_coldesc.htm">Description of &#34;Figure 5-9 ttXlaColDesc_t structures returned by ttXlaGetColumnInfo&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Each <code dir="ltr">ttXlaColDesc_t</code> structure returned by <code dir="ltr">ttXlaGetColumnInfo</code> has an offset value that describes the offset location of that column. How you use this offset value to read the column data depends on whether the column contains fixed-length data (such as <code dir="ltr">CHAR</code>, <code dir="ltr">NCHAR</code>, <code dir="ltr">INTEGER</code>, <code dir="ltr">BINARY</code>, <code dir="ltr">DOUBLE</code>, <code dir="ltr">FLOAT</code>, <code dir="ltr">DATE</code>, <code dir="ltr">TIME</code>, <code dir="ltr">TIMESTAMP</code>, and so on) or variable-length data (such as <code dir="ltr">VARCHAR</code>, <code dir="ltr">NVARCHAR</code>, or <code dir="ltr">VARBINARY</code>).</p>
</div>
<!-- class="sect3" -->
<a id="BABDCEFE"></a>
<div id="TTCDV281" class="sect3">
<h4 class="sect3">Reading fixed-length column data</h4>
<p>For fixed-length column data, the address of a column is the offset value in the <code dir="ltr"><a href="xla_ref.htm#CHEIGBDD">ttXlaColDesc_t</a></code> structure, plus the address of the row.</p>
<div id="TTCDV282" class="figure">
<p class="titleinfigure"><a id="sthref331"></a>Figure 5-10 Locating fixed-length data in a row</p>
<img width="544" height="118" src="img/xla_char.gif" alt="Description of Figure 5-10 follows"/><br/>
<a id="sthref332" href="img_text/xla_char.htm">Description of &#34;Figure 5-10 Locating fixed-length data in a row&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="TTCDV283" class="example">
<p class="titleinexample"><a id="BABEFGDE"></a>Example 5-6 Reading fixed-length column data</p>
<p>See <a href="#BABFHDID">Example 5-13</a> for a complete working example of computations such as those shown here.</p>
<p>The first column in the <code dir="ltr">MYDATA</code> table is of type <code dir="ltr">CHAR</code>. If you use the address of the <code dir="ltr">tup1</code> row obtained earlier in the <code dir="ltr">HandleChange()</code> function (<a href="#BABHADHC">Example 5-4</a>) and the offset from the first <code dir="ltr">ttXlaColDesc_t</code> structure returned by the <code dir="ltr"><a href="xla_ref.htm#CHEEJABC">ttXlaGetColumnInfo</a></code> function (<a href="#BABGEDAG">Example 5-5</a>), you can obtain the value of the first column with computations such as the following:</p>
<pre dir="ltr">char*  Column1;

Column1 = ((unsigned char*) tup1 + xla_column_defs[0].offset);
</pre>
<p>The third column in the <code dir="ltr">MYDATA</code> table is of type <code dir="ltr">INTEGER</code>, so you can use the offset from the third <code dir="ltr">ttXlaColDesc_t</code> structure to locate the value and recast it as an integer using computations such as the following. The data is guaranteed to be aligned properly.</p>
<pre dir="ltr">int Column3;

Column3 = *((int*) ((unsigned char*) tup +
           xla_column_defs[2].offset));
</pre>
<p>The fourth column in the <code dir="ltr">MYDATA</code> table is of type <code dir="ltr">NCHAR</code>, so you can use the offset from the fourth <code dir="ltr">ttXlaColDesc_t</code> structure to locate the value and recast it as a <code dir="ltr">SQLWCHAR</code> type, with computations such as the following:</p>
<pre dir="ltr">SQLWCHAR*  Column4;

Column4 = (SQLWCHAR*) ((unsigned char*) tup +
                      xla_column_defs[3].offset);
</pre>
<p>Unlike the column values obtained in the above examples, <code dir="ltr">Column4</code> points to an array of two-byte Unicode characters. You must iterate through each element in this array to obtain the string, as shown for the <code dir="ltr">SQL_WCHAR</code> case in <a href="#BABFHDID">Example 5-13</a>.</p>
<p>Other fixed-length data types can be cast to their corresponding C types. Complex fixed-length data types, such as <code dir="ltr">DATE</code>, <code dir="ltr">TIME</code>, and <code dir="ltr">DECIMAL</code> values, are stored in an internal TimesTen format, but can be converted by applications to their corresponding ODBC C value using the XLA conversion functions, as described in <a href="#BABIGJFI">&#34;Converting complex data types&#34;</a>.</p>
</div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Strings returned by XLA are not null-terminated. See <a href="#BABFAIEJ">&#34;Null-terminating returned strings&#34;</a>.</div>
</div>
<!-- class="sect3" -->
<a id="BABHAIJE"></a>
<div id="TTCDV284" class="sect3">
<h4 class="sect3">Reading NOT INLINE variable-length column data</h4>
<p>For <code dir="ltr">NOT INLINE</code> variable-length data (<code dir="ltr">VARCHAR</code>, <code dir="ltr">NVARCHAR</code>, and <code dir="ltr">VARBINARY</code>), the data located at <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">offset</span></code> is a four-byte offset value that points to the location of the data in the variable-length portion of the returned row. By adding the offset address to the offset value, you can obtain the address of the column data in the variable-length portion of the row. The first <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes (where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is 4 on 32-bit platforms or 8 on 64-bit platforms) at this location is the length of the data, followed by the actual data. For variable-length data, the <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">size</span></code> value is the maximum allowable column size. <a href="#BABJIIJG">Figure 5-11</a> shows how to locate <code dir="ltr">NOT INLINE</code> variable-length data in a row.</p>
<div id="TTCDV285" class="figure">
<p class="titleinfigure"><a id="BABJIIJG"></a>Figure 5-11 Locating NOT INLINE variable-length data in a row</p>
<img width="662" height="206" src="img/xla_varchar.gif" alt="Description of Figure 5-11 follows"/><br/>
<a id="sthref333" href="img_text/xla_varchar.htm">Description of &#34;Figure 5-11 Locating NOT INLINE variable-length data in a row&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="TTCDV286" class="example">
<p class="titleinexample"><a id="BABEGDCB"></a>Example 5-7 Reading NOT INLINE variable-length column data</p>
<p>See <a href="#BABFHDID">Example 5-13, &#34;Complete PrintColValues() function&#34;</a> for a complete working example of computations such as those shown here.</p>
<p>Continuing with our example, the second column in the returned row (<code dir="ltr">tup1</code>) is of type <a id="sthref334"></a><code dir="ltr">VARCHAR</code>. To locate the variable-length data in the row, first locate the value at the column&#39;s <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">offset</span></code> in the fixed-length portion of the row, as shown in <a href="#BABJIIJG">Figure 5-11</a> above. The value at this address is the four-byte offset of the data in the variable-length portion of the row (<code dir="ltr">VarOffset</code>). Next, obtain a pointer to the beginning of the variable-length column data (<code dir="ltr">DataLength</code>) by adding the <code dir="ltr">VarOffset</code> offset value to the address of <code dir="ltr">VarOffset</code>. Assuming the operation is performed on a 32-bit platform, the first four bytes at the <code dir="ltr">DataLength</code> location is the length of the data. The next byte after <code dir="ltr">DataLength</code> is the beginning of the actual data (<code dir="ltr">Column2</code>).</p>
<p>The sample code here assumes the operation is performed on a 32-bit platform, so <code dir="ltr">DataLength</code> is initialized as a 32-bit type. On a 64-bit platform, <code dir="ltr">DataLength</code> must be initialized as a 64-bit type and the <code dir="ltr">Column2</code> data would appear 64 bits + 1 after the offset address, <code dir="ltr">DataLength</code>.</p>
<pre dir="ltr">void*  VarOffset; /* offset of data */
long*  DataLength; /* length of data */
char*  Column2; /* pointer to data */

VarOffset = (void*) ((unsigned char*) tup1 +
             xla_column_defs[1].offset);
     /*
      * If column is out-of-line, pColVal points to an offset
      * else column is inline so pColVal points directly to the string length.
      */

      if (xla_column_defs[1].flags &amp; TT_COLOUTOFLINE)
      DataLength = (long*)((char*)VarOffset + *((int*)VarOffset));
      else
      DataLength = (long*)VarOffset;
      Column2 = (char*)(DataLength+1);
</pre>
<p><a id="sthref335"></a><code dir="ltr">VARBINARY</code> types are handled in a manner similar to <code dir="ltr">VARCHAR</code> types. If <code dir="ltr">Column2</code> were an <a id="sthref336"></a><code dir="ltr">NVARCHAR</code> type, you could initialize it as a <code dir="ltr">SQLWCHAR</code>, get the value as shown in the above <code dir="ltr">VARCHAR</code> case, then iterate through the <code dir="ltr">Column2</code> array, as shown for the <code dir="ltr">NCHAR</code> value, <code dir="ltr">CharBuf</code>, in <a href="#BABFHDID">Example 5-13</a>.</p>
</div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
In the preceding example, <code dir="ltr">DataLength</code> is type <code dir="ltr">long</code>, which is described as being a 64-bit (eight-byte) type on 64-bit systems and a 32-bit (four-byte) type on 32-bit systems. This is true on most UNIX systems; however, on Windows 64-bit systems <code dir="ltr">long</code> is a four-byte type.</div>
</div>
<!-- class="sect3" -->
<a id="BABFAIEJ"></a>
<div id="TTCDV287" class="sect3">
<h4 class="sect3">Null-terminating returned strings</h4>
<p>Strings returned from record row data are not terminated with a null character. You can null-terminate a string by copying it into a buffer and adding a null character, &#39;<code dir="ltr">\0</code>&#39;, after the last character in the string.</p>
<p>The procedures for null-terminating fixed-length and variable-length strings are slightly different. The procedure for null-terminating fixed-length strings is described in <a href="#BABICJHC">Example 5-8</a>. <a href="#BABBHAIH">Example 5-9</a> that follows describes the procedure for null-terminating variable-length strings of a known size. <a href="#BABIHIBF">Example 5-10</a> then describes the procedure for strings of an unknown size.</p>
<div id="TTCDV288" class="example">
<p class="titleinexample"><a id="BABICJHC"></a>Example 5-8 Null-terminating fixed-length strings</p>
<p>See <a href="#BABFHDID">Example 5-13</a> for a complete working example of computations such as those shown here.</p>
<p>To null-terminate the fixed-length <code dir="ltr">CHAR(10)</code> <code dir="ltr">Column1</code> string returned in <a href="#BABEFGDE">Example 5-6</a>, establish a buffer large enough to hold the string plus null character. Next, obtain the size of the string from <code dir="ltr">ttXlaColDesc_t -</code>&gt;<code dir="ltr"><span class="codeinlineitalic">size</span></code>, copy the string into the buffer, and null-terminate the end of the string, using computations such as the following. You can now use the contents of the buffer. In this example, the string is printed:</p>
<pre dir="ltr">char buffer[10+1];
int size;

size = xla_column_defs[0].size;
memcpy(buffer, Column1, size);
buffer[size] = &#39;\0&#39;;

printf(&#34; Row %s is %s\n&#34;, ((unsigned char*) xla_column_defs[0].colName), buffer);
</pre>
<p>Null-terminating a variable-length string is similar to the procedure for fixed-length strings, only the size of the string is the value located at the beginning of the variable-length data offset, as described in <a href="#BABHAIJE">&#34;Reading NOT INLINE variable-length column data&#34;</a>.</p>
</div>
<!-- class="example" -->
<div id="TTCDV289" class="example">
<p class="titleinexample"><a id="BABBHAIH"></a>Example 5-9 Null-terminating variable-length strings of known size</p>
<p>(See <a href="#BABFHDID">Example 5-13</a> for a complete working example of computations such as those shown here.)</p>
<p>If the <code dir="ltr">Column2</code> string obtained in <a href="#BABEGDCB">Example 5-7</a> is a <code dir="ltr">VARCHAR(32)</code>, establish a buffer large enough to hold the string plus null character. Use the value located at the <code dir="ltr">DataLength</code> offset to determine the size of the string, using computations such as the following:</p>
<pre dir="ltr">char buffer[32+1];

memcpy(buffer, Column2, *DataLength);
buffer[*DataLength] = &#39;\0&#39;;

printf(&#34; Row %s is %s\n&#34;, ((unsigned char*) xla_column_defs[1].colName), buffer);
</pre>
<p>If you are writing general purpose code to read all data types, you cannot make any assumptions about the size of a returned string. For strings of an unknown size, statically allocate a buffer large enough to hold the majority of returned strings. If a returned string is larger than the buffer, dynamically allocate the correct size buffer, as shown in <a href="#BABIHIBF">Example 5-10</a>.</p>
</div>
<!-- class="example" -->
<div id="TTCDV290" class="example">
<p class="titleinexample"><a id="BABIHIBF"></a>Example 5-10 Null-terminating variable-length strings of unknown size</p>
<p>If the <code dir="ltr">Column2</code> string obtained in <a href="#BABEGDCB">Example 5-7</a> is of an unknown size, you might statically allocate a buffer large enough to hold a string of up to 10000 characters. Then check that the <code dir="ltr">DataLength</code> value obtained at the beginning of the variable-length data offset is less than the size of the buffer. If the string is larger than the buffer, use <code dir="ltr">malloc()</code> to dynamically allocate the buffer to the correct size.</p>
<pre dir="ltr">#define STACKBUFSIZE 10000
char VarStackBuf[STACKBUFSIZE];
char*  buffer;

buffer = (*DataLength+1 &lt;= STACKBUFSIZE) ? VarStackBuf :
           malloc(*DataLength+1);

memcpy(buffer,Column2,*DataLength);
buffer[*DataLength] = &#39;\0&#39;;

printf(&#34; Row %s is %s\n&#34;, ((unsigned char*) xla_column_defs[1].colName), buffer);
if (buffer != VarStackBuf) /* buffer was allocated */
        free(buffer);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABIGJFI"></a>
<div id="TTCDV291" class="sect3">
<h4 class="sect3">Converting complex data types</h4>
<p>Values for complex data types such as <code dir="ltr">TT_DATE</code>, <code dir="ltr">TT_TIME</code>, and <code dir="ltr">TT_DECIMAL</code> are stored in an internal TimesTen format that can be converted into corresponding ODBC C types using the XLA type conversion functions. <a href="#BABEFJAJ">Table 5-2</a> contains descriptions of these conversion functions.</p>
<div id="TTCDV292" class="tblhruleformal">
<p class="titleintable"><a id="sthref337"></a><a id="BABEFJAJ"></a>Table 5-2 XLA data type conversion functions</p>
<table class="cellalignment4366" title="XLA data type conversion functions" summary="This table contains descriptions of XLA data type conversion functions." dir="ltr">
<thead>
<tr class="cellalignment4360">
<th class="cellalignment4367" id="r1c1-t14">Function</th>
<th class="cellalignment4367" id="r1c2-t14">Converts</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r2c1-t14" headers="r1c1-t14">
<p><a id="sthref338"></a><code dir="ltr"><a href="xla_ref.htm#CHEBBJGA">ttXlaDateToODBCCType</a></code></p>
</td>
<td class="cellalignment4368" headers="r2c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TT_DATE</code> value to an ODBC C value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r3c1-t14" headers="r1c1-t14">
<p><a id="sthref339"></a><code dir="ltr"><a href="xla_ref.htm#CHEDFIJH">ttXlaTimeToODBCCType</a></code></p>
</td>
<td class="cellalignment4368" headers="r3c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TT_TIME</code> value to an ODBC C value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r4c1-t14" headers="r1c1-t14">
<p><a id="sthref340"></a><code dir="ltr"><a href="xla_ref.htm#CHECCIIG">ttXlaTimeStampToODBCCType</a></code></p>
</td>
<td class="cellalignment4368" headers="r4c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TT_TIMESTAMP</code> value to an ODBC C value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r5c1-t14" headers="r1c1-t14">
<p><a id="sthref341"></a><code dir="ltr"><a href="xla_ref.htm#CHECEIIC">ttXlaDecimalToCString</a></code></p>
</td>
<td class="cellalignment4368" headers="r5c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TT_DECIMAL</code> value to a string value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r6c1-t14" headers="r1c1-t14">
<p><a id="sthref342"></a><code dir="ltr"><a href="xla_ref.htm#CHEBBJGA">ttXlaDateToODBCCType</a></code></p>
</td>
<td class="cellalignment4368" headers="r6c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_DATE_TT</code> value to an ODBC C value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r7c1-t14" headers="r1c1-t14">
<p><a id="sthref343"></a><code dir="ltr"><a href="xla_ref.htm#CHECEIIC">ttXlaDecimalToCString</a></code></p>
</td>
<td class="cellalignment4368" headers="r7c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_DECIMAL_TT</code> value to a character string</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r8c1-t14" headers="r1c1-t14">
<p><a id="sthref344"></a><code dir="ltr"><a href="xla_ref.htm#CHEECECB">ttXlaNumberToBigInt</a></code></p>
</td>
<td class="cellalignment4368" headers="r8c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_NUMBER</code> value to a <code dir="ltr">TT_BIGINT</code> value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r9c1-t14" headers="r1c1-t14">
<p><a id="sthref345"></a><code dir="ltr"><a href="xla_ref.htm#CHEDEBGF">ttXlaNumberToCString</a></code></p>
</td>
<td class="cellalignment4368" headers="r9c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_NUMBER</code> value to a character string</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r10c1-t14" headers="r1c1-t14">
<p><a id="sthref346"></a><code dir="ltr"><a href="xla_ref.htm#CHEHCCAB">ttXlaNumberToDouble</a></code></p>
</td>
<td class="cellalignment4368" headers="r10c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_NUMBER</code> value to a long floating point number value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r11c1-t14" headers="r1c1-t14">
<p><a id="sthref347"></a><code dir="ltr"><a href="xla_ref.htm#CHEJBFAA">ttXlaNumberToInt</a></code></p>
</td>
<td class="cellalignment4368" headers="r11c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_NUMBER</code> value to an integer</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r12c1-t14" headers="r1c1-t14">
<p><a id="sthref348"></a><code dir="ltr"><a href="xla_ref.htm#CHEDEHAG">ttXlaNumberToSmallInt</a></code></p>
</td>
<td class="cellalignment4368" headers="r12c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_NUMBER</code> value to a <code dir="ltr">TT_SMALLINT</code> value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r13c1-t14" headers="r1c1-t14">
<p><a id="sthref349"></a><code dir="ltr"><a href="xla_ref.htm#CHEIDCJA">ttXlaNumberToTinyInt</a></code></p>
</td>
<td class="cellalignment4368" headers="r13c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_NUMBER</code> value to a <code dir="ltr">TT_TINYINT</code> value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r14c1-t14" headers="r1c1-t14">
<p><a id="sthref350"></a><code dir="ltr"><a href="xla_ref.htm#CHEHJJGF">ttXlaNumberToUInt</a></code></p>
</td>
<td class="cellalignment4368" headers="r14c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_NUMBER</code> value to an unsigned integer</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r15c1-t14" headers="r1c1-t14">
<p><a id="sthref351"></a><code dir="ltr"><a href="xla_ref.htm#CHEHBFCG">ttXlaOraDateToODBCTimeStamp</a></code></p>
</td>
<td class="cellalignment4368" headers="r15c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_DATE</code> value to an ODBC timestamp</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r16c1-t14" headers="r1c1-t14">
<p><a id="sthref352"></a><code dir="ltr"><a href="xla_ref.htm#CHEDABHC">ttXlaOraTimeStampToODBCTimeStamp</a></code></p>
</td>
<td class="cellalignment4368" headers="r16c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_TIMESTAMP</code> value to an ODBC timestamp</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r17c1-t14" headers="r1c1-t14">
<p><a id="sthref353"></a><code dir="ltr"><a href="xla_ref.htm#CHEDFIJH">ttXlaTimeToODBCCType</a></code></p>
</td>
<td class="cellalignment4368" headers="r17c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_TIME</code> value to an ODBC C value</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r18c1-t14" headers="r1c1-t14">
<p><a id="sthref354"></a><code dir="ltr"><a href="xla_ref.htm#CHECCIIG">ttXlaTimeStampToODBCCType</a></code></p>
</td>
<td class="cellalignment4368" headers="r18c1-t14 r1c2-t14">
<p>Internal <code dir="ltr">TTXLA_TIMESTAMP_TT</code> value to an ODBC C value</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p>These conversion functions can be used on row data in the <code dir="ltr"><a href="xla_ref.htm#CHEGEBFI">ttXlaUpdateDesc_t</a></code> types: <code dir="ltr">UPDATETUP</code>, <code dir="ltr">INSERTTUP</code> and <code dir="ltr">DELETETUP</code>.</p>
<div id="TTCDV293" class="example">
<p class="titleinexample"><a id="sthref355"></a>Example 5-11 Converting complex data types</p>
<p>(See <a href="#BABFHDID">Example 5-13</a> for a complete working example of computations such as those shown here.)</p>
<p>If you use the address of the <code dir="ltr">tup1</code> row obtained earlier in the <code dir="ltr">HandleChange()</code> function (<a href="#BABHADHC">Example 5-4</a>) and the offset from the fifth <code dir="ltr"><a href="xla_ref.htm#CHEIGBDD">ttXlaColDesc_t</a></code> structure returned by the <code dir="ltr"><a href="xla_ref.htm#CHEEJABC">ttXlaGetColumnInfo</a></code> function (<a href="#BABGEDAG">Example 5-5</a>), you can locate a column value of type <code dir="ltr">TIMESTAMP</code>. Use the <code dir="ltr"><a href="xla_ref.htm#CHECCIIG">ttXlaTimeStampToODBCCType</a></code> function to convert the column data from TimesTen format and store the converted time value in an ODBC <code dir="ltr">TIMESTAMP_STRUCT</code>. You could use code such as the following to print the values:</p>
<pre dir="ltr">void*  Column5;
TIMESTAMP_STRUCT timestamp;

Column5 = (void*) ((unsigned char*) tup1 +
                  xla_column_defs[4].offset);

rc = ttXlaTimeStampToODBCCType(Column5, &amp;timestamp);
  if (rc != SQL_SUCCESS) {
    /* See <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a> */
  }
printf(&#34; %s: %04d-%02d-%02d %02d:%02d:%02d.%06d\n&#34;,
      ((unsigned char*) xla_column_defs[i].colName),
        timestamp.year,timestamp.month, timestamp.day,
        timestamp.hour,timestamp.minute,timestamp.second,
        timestamp.fraction);
</pre>
<p>If you use the address of the <code dir="ltr">tup1</code> row obtained earlier in the <code dir="ltr">HandleChange()</code> function (<a href="#BABHADHC">Example 5-4</a>) and the offset from the sixth <code dir="ltr">ttXlaColDesc_t</code> structure returned by the <code dir="ltr">ttXlaGetColumnInfo</code> function (<a href="#BABGEDAG">Example 5-5</a>), you can locate a column value of type <code dir="ltr">DECIMAL</code>. Use the <code dir="ltr"><a href="xla_ref.htm#CHECEIIC">ttXlaDecimalToCString</a></code> function to convert the column data from TimesTen decimal format to a string. You could use code such as the following to print the values.</p>
<pre dir="ltr">char decimalData[50];

Column6 = (float*) ((unsigned char*) tup +
           xla_column_defs[5].offset);
precision = (short) (xla_column_defs[5].precision);
scale = (short) (xla_column_defs[5].scale);

rc = ttXlaDecimalToCString(Column6, (char*)&amp;decimalData,
                           precision, scale);
  if (rc != SQL_SUCCESS) {
    /* See <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a> */
  }

printf(&#34; %s: %s\n&#34;, ((unsigned char*) xla_column_defs[5].colName), decimalData);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABHJEAG"></a>
<div id="TTCDV294" class="sect3">
<h4 class="sect3">Detecting null values</h4>
<p>For nullable table columns, <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">nullOffset</span></code> points to the column&#39;s null byte in the record. This field is 0 (zero) if the column is not nullable, or greater than 0 if the column can be null.</p>
<p>For nullable columns (<code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">nullOffset</span></code> &gt; 0), to determine if the column is null, add the null offset to the address of <code dir="ltr">ttXlaUpdate_t*</code> and check the (<code dir="ltr">unsigned char</code>) byte there to see if it is 1 (<code dir="ltr">NULL</code>) or 0 (<code dir="ltr">NOT NULL</code>).</p>
<div id="TTCDV295" class="example">
<p class="titleinexample"><a id="sthref356"></a>Example 5-12 Detecting null values</p>
<p>Check whether <code dir="ltr">Column6</code> is null as follows:</p>
<pre dir="ltr">if (xla_column_defs[5].nullOffset != 0) {
  if (*((unsigned char*) tup +
     xla_column_defs[5].nullOffset) == 1) {
         printf(&#34;Column6 is NULL\n&#34;);
  }
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABBABBI"></a>
<div id="TTCDV296" class="sect3">
<h4 class="sect3">Putting it all together: a PrintColValues() function</h4>
<p><a href="#BABFHDID">Example 5-13</a> shows a function that checks the <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">dataType</span></code> of each column to locate columns with a data type of <code dir="ltr">CHAR</code>, <code dir="ltr">NCHAR</code>, <code dir="ltr">INTEGER</code>, <code dir="ltr">TIMESTAMP</code>, <code dir="ltr">DECIMAL</code>, and <code dir="ltr">VARCHAR</code>, then prints the values. This is just one possible approach. Another option, for example, would be to check the <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">ColName</span></code> values to locate specific columns by name.</p>
<p>The <code dir="ltr">PrintColValues()</code> function handles <code dir="ltr">CHAR</code> and <code dir="ltr">VARCHAR</code> strings up to 50 bytes in length. <code dir="ltr">NCHAR</code> characters must belong to the ASCII character set.</p>
<div id="TTCDV297" class="example">
<p class="titleinexample"><a id="BABFHDID"></a>Example 5-13 Complete PrintColValues() function</p>
<p>The function in this example first checks <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">nullOffset</span></code> to see if the column is null. Next it checks the <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">dataType</span></code> field to determine the data type for the column. For simple fixed-length data (<code dir="ltr">CHAR</code>, <code dir="ltr">NCHAR</code>, and <code dir="ltr">INTEGER</code>), it casts the value located at <code dir="ltr">ttXlaColDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">offset</span></code> to the appropriate C type. The complex data types, <code dir="ltr">TIMESTAMP</code> and <code dir="ltr">DECIMAL</code>, are converted from their TimesTen formats to ODBC C values using the <code dir="ltr"><a href="xla_ref.htm#CHECCIIG">ttXlaTimeStampToODBCCType</a></code> and <code dir="ltr"><a href="xla_ref.htm#CHECEIIC">ttXlaDecimalToCString</a></code> functions.</p>
<p>For variable-length data (<code dir="ltr">VARCHAR</code>), the function locates the data in the variable-length portion of the row, as described in <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a>.</p>
<pre dir="ltr">void PrintColValues(void* tup)
{ 
 
  SQLRETURN rc ;
  SQLINTEGER native_error;
 
  void* pColVal;
  char buffer[50+1]; /* No strings over 50 bytes */
  int i;
 
  for (i = 0; i &lt; ncols; i++)
  {
 
    if (xla_column_defs[i].nullOffset != 0) {  /* See if column is NULL */
      /* this means col could be NULL */
      if (*((unsigned char*) tup + xla_column_defs[i].nullOffset) == 1) {
        /* this means that value is SQL NULL */
        printf(&#34;  %s: NULL\n&#34;, 
               ((unsigned char*) xla_column_defs[i].colName));
        continue; /* Skip rest and re-loop */
      }
    }
 
    /* Fixed-length data types: */
    /* For INTEGER, recast as int */
 
    if (xla_column_defs[i].dataType == TTXLA_INTEGER) {
 
      printf(&#34;  %s: %d\n&#34;,
             ((unsigned char*) xla_column_defs[i].colName),
             *((int*) ((unsigned char*) tup + xla_column_defs[i].offset)));
    }

    /* For CHAR, just get value and null-terminate string */
 
    else if (   xla_column_defs[i].dataType == TTXLA_CHAR_TT
             || xla_column_defs[i].dataType == TTXLA_CHAR) {
 
      pColVal = (void*) ((unsigned char*) tup + xla_column_defs[i].offset);
 
      memcpy(buffer, pColVal, xla_column_defs[i].size);
      buffer[xla_column_defs[i].size] = &#39;\0&#39;;
 
      printf(&#34;  %s: %s\n&#34;, ((unsigned char*) xla_column_defs[i].colName), buffer);
    }
 
    /* For NCHAR, recast as SQLWCHAR.
       NCHAR strings must be parsed one character at a time */
 
    else if (   xla_column_defs[i].dataType == TTXLA_NCHAR_TT  
             || xla_column_defs[i].dataType == TTXLA_NCHAR ) {
      SQLUINTEGER j;
      SQLWCHAR* CharBuf;
 
      CharBuf = (SQLWCHAR*) ((unsigned char*) tup + xla_column_defs[i].offset);

      printf(&#34;  %s: &#34;, ((unsigned char*) xla_column_defs[i].colName));
 
      for (j = 0; j &lt; xla_column_defs[i].size / 2; j++)
      { 
        printf(&#34;%c&#34;, CharBuf[j]);
      }
      printf(&#34;\n&#34;);
    }
    /* Variable-length data types:
       For VARCHAR, locate value at its variable-length offset and null-terminate.
       VARBINARY types are handled in a similar manner.
       For NVARCHARs, initialize &#39;var_data&#39; as a SQLWCHAR, get the value as shown 
       below, then iterate through &#39;var_len&#39; as shown for NCHAR above */
 
    else if (   xla_column_defs[i].dataType == TTXLA_VARCHAR
             || xla_column_defs[i].dataType == TTXLA_VARCHAR_TT) {
 
      long*  var_len;
      char* var_data;
      pColVal = (void*) ((unsigned char*) tup + xla_column_defs[i].offset);
      /*
       * If column is out-of-line, pColVal points to an offset
       * else column is inline so pColVal points directly to the string length.
       */
      if (xla_column_defs[i].flags &amp; TT_COLOUTOFLINE)
        var_len = (long*)((char*)pColVal + *((int*)pColVal));
      else
        var_len = (long*)pColVal;
 
      var_data = (char*)(var_len+1);
 
      memcpy(buffer,var_data,*var_len);
      buffer[*var_len] = &#39;\0&#39;;
 
      printf(&#34;  %s: %s\n&#34;, ((unsigned char*) xla_column_defs[i].colName), buffer);
    }
    /* Complex data types require conversion by the XLA conversion methods
       Read and convert a TimesTen TIMESTAMP value.
       DATE and TIME types are handled in a similar manner  */
 
    else if (   xla_column_defs[i].dataType == TTXLA_TIMESTAMP
             || xla_column_defs[i].dataType == TTXLA_TIMESTAMP_TT) {
 
      TIMESTAMP_STRUCT timestamp;
      char* convFunc;
 
      pColVal = (void*) ((unsigned char*) tup + xla_column_defs[i].offset);
 
      if (xla_column_defs[i].dataType == TTXLA_TIMESTAMP_TT) {
        rc = ttXlaTimeStampToODBCCType(pColVal, &amp;timestamp);
        convFunc=&#34;ttXlaTimeStampToODBCCType&#34;;
      }
      else {
        rc = ttXlaOraTimeStampToODBCTimeStamp(pColVal, &amp;timestamp);
        convFunc=&#34;ttXlaOraTimeStampToODBCTimeStamp&#34;;
      }
 
      if (rc != SQL_SUCCESS) {
        handleXLAerror (rc, xla_handle, err_buf, &amp;native_error);
        fprintf(stderr, &#34;%s() returns an error &lt;%d&gt;: %s&#34;, 
                convFunc, rc, err_buf);
        TerminateGracefully(1);
      }

      printf(&#34;  %s: %04d-%02d-%02d %02d:%02d:%02d.%06d\n&#34;,
             ((unsigned char*) xla_column_defs[i].colName),
             timestamp.year,timestamp.month, timestamp.day,
             timestamp.hour,timestamp.minute,timestamp.second,
             timestamp.fraction);
    }
 
    /* Read and convert a TimesTen DECIMAL value to a string. */
 
    else if (xla_column_defs[i].dataType == TTXLA_DECIMAL_TT) {
 
      char decimalData[50]; 
      short precision, scale;
      pColVal = (float*) ((unsigned char*) tup + xla_column_defs[i].offset);
      precision = (short) (xla_column_defs[i].precision);
      scale = (short) (xla_column_defs[i].scale);
 
      rc = ttXlaDecimalToCString(pColVal, (char*)&amp;decimalData, precision, scale);
      if (rc != SQL_SUCCESS) {
        handleXLAerror (rc, xla_handle, err_buf, &amp;native_error);
        fprintf(stderr, &#34;ttXlaDecimalToCString() returns an error &lt;%d&gt;: %s&#34;, 
                rc, err_buf);
        TerminateGracefully(1);
      }
 
      printf(&#34;  %s: %s\n&#34;, ((unsigned char*) xla_column_defs[i].colName),
             decimalData);
    }
    else if (xla_column_defs[i].dataType == TTXLA_NUMBER) {
      char numbuf[32];
      pColVal = (void*) ((unsigned char*) tup + xla_column_defs[i].offset);
 
      rc=ttXlaNumberToCString(xla_handle, pColVal, numbuf, sizeof(numbuf));
      if (rc != SQL_SUCCESS) {
        handleXLAerror (rc, xla_handle, err_buf, &amp;native_error);
        fprintf(stderr, &#34;ttXlaNumberToDouble() returns an error &lt;%d&gt;: %s&#34;,
                rc, err_buf);
        TerminateGracefully(1);
      }
      printf(&#34;  %s: %s\n&#34;, ((unsigned char*) xla_column_defs[i].colName), numbuf);
    }
 
  } /* End FOR loop */
}
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>In the preceding example, <code dir="ltr">var_len</code> is type <code dir="ltr">long</code>, assumed to be a 64-bit (eight-byte) type on 64-bit systems and a 32-bit (four-byte) type on 32-bit systems. This is true on most UNIX systems; however, on Windows 64-bit systems <code dir="ltr">long</code> is a four-byte type.</p>
</li>
<li>
<p>See <a href="#BABIFJIA">&#34;Terminating an XLA application&#34;</a> for a sample <code dir="ltr">TerminateGracefully()</code> method.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABJGJCJ"></a>
<div id="TTCDV298" class="sect2">
<h3 class="sect2">Han<a id="sthref357"></a><a id="sthref358"></a>dling XLA errors</h3>
<p>Each time you call an ODBC or XLA function, you must check the return code for any errors. If the error is fatal, terminate the program as described in <a href="#BABIFJIA">&#34;Terminating an XLA application&#34;</a>.</p>
<p>An error can be checked using either its error code (error number) or <code dir="ltr">tt_Err</code> string. For the complete list of TimesTen error codes and error strings, see the <code dir="ltr"><span class="codeinlineitalic">install_dir</span></code><code dir="ltr">/include/tt_errCode.h</code> file. For a description of each message, see <a class="olink TTERR116" href="../TTERR/error.htm#TTERR116">&#34;List of errors and warnings&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Error Messages and SNMP Traps</span>.</p>
<p>If the return code from an XLA function is not <code dir="ltr">SQL_SUCCESS</code>, use the <code dir="ltr"><a href="xla_ref.htm#CHEECIEI">ttXlaError</a></code> function to retrieve XLA-specific errors on the XLA handle.</p>
<p>Also see <a href="writing_app.htm#BABJIHDI">&#34;Checking for errors&#34;</a>.</p>
<div id="TTCDV299" class="example">
<p class="titleinexample"><a id="sthref359"></a>Example 5-14 Checking the return code and calling the error-handling function</p>
<p>This example, after calling the XLA function <code dir="ltr"><a href="xla_ref.htm#CHEBGDFB">ttXlaTableByName</a></code>, checks to see if the return code is <code dir="ltr">SQL_SUCCESS</code>. If not, it calls an XLA error-handling function followed by a function to terminate the application. See <a href="#BABIFJIA">&#34;Terminating an XLA application&#34;</a>.</p>
<pre dir="ltr">rc = ttXlaTableByName(xla_handle, TABLE_OWNER, TABLE_NAME,
                      &amp;SYSTEM_TABLE_ID, &amp;userID);
if (rc != SQL_SUCCESS) {
  handleXLAerror (rc, xla_handle, err_buf, &amp;native_error);
  fprintf(stderr,
    &#34;ttXlaTableByName() returns an error &lt;%d&gt;: %s&#34;, rc, err_buf);
  TerminateGracefully(1);
}
</pre></div>
<!-- class="example" -->
<p>Your XLA error-handling function should repeatedly call <a id="sthref360"></a><code dir="ltr">ttXlaError</code> until all XLA errors are read from the error stack, proceeding until the return code from <code dir="ltr"><a href="xla_ref.htm#CHEECIEI">ttXlaError</a></code> is <code dir="ltr">SQL_NO_DATA_FOUND</code>. If you must reread the errors, you can call the <a id="sthref361"></a><code dir="ltr"><a href="xla_ref.htm#CHEHCIFA">ttXlaErrorRestart</a></code> function to reset the error stack pointer to the first error.</p>
<p>The error stack is cleared after a call to any XLA function other than <code dir="ltr">ttXlaError</code> or <code dir="ltr">ttXlaErrorRestart</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In cases where <code dir="ltr"><a href="xla_ref.htm#CHEFECEF">ttXlaPersistOpen</a></code> cannot create an XLA handle, it returns the error code <code dir="ltr">SQL_INVALID_HANDLE</code>. Because no XLA handle has been created, <code dir="ltr">ttXlaError</code> cannot be used to detect this error. <code dir="ltr">SQL_INVALID_HANDLE</code> is returned only in cases where no memory can be allocated or the parameters provided are invalid.</div>
<p>Depending on your application, you may be required to act on specific XLA errors, including those shown in <a href="#CIHIAGHA">Table 5-3</a>.</p>
<div id="TTCDV300" class="tblhruleformal">
<p class="titleintable"><a id="sthref362"></a><a id="CIHIAGHA"></a>Table 5-3 XLA errors and codes</p>
<table class="cellalignment4366" title="XLA errors and codes" summary="Lists XLA errors and error codes." dir="ltr">
<thead>
<tr class="cellalignment4360">
<th class="cellalignment4367" id="r1c1-t17">Error</th>
<th class="cellalignment4367" id="r1c2-t17">Code</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r2c1-t17" headers="r1c1-t17">
<p><a id="sthref363"></a><code dir="ltr">tt_ErrDbAllocFailed</code></p>
</td>
<td class="cellalignment4368" headers="r2c1-t17 r1c2-t17">
<p>802 (transient)</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r3c1-t17" headers="r1c1-t17">
<p><a id="sthref364"></a><code dir="ltr">tt_ErrCondLockConflict</code></p>
</td>
<td class="cellalignment4368" headers="r3c1-t17 r1c2-t17">
<p>6001 (transient)</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r4c1-t17" headers="r1c1-t17">
<p><a id="sthref365"></a><code dir="ltr">tt_ErrDeadlockVictim</code></p>
</td>
<td class="cellalignment4368" headers="r4c1-t17 r1c2-t17">
<p>6002 (transient)</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r5c1-t17" headers="r1c1-t17">
<p><a id="sthref366"></a><code dir="ltr">tt_ErrTimeoutVictim</code></p>
</td>
<td class="cellalignment4368" headers="r5c1-t17 r1c2-t17">
<p>6003 (transient)</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r6c1-t17" headers="r1c1-t17">
<p><a id="sthref367"></a><code dir="ltr">tt_ErrPermSpaceExhausted</code></p>
</td>
<td class="cellalignment4368" headers="r6c1-t17 r1c2-t17">
<p>6220 (transient)</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r7c1-t17" headers="r1c1-t17">
<p><a id="sthref368"></a><code dir="ltr">tt_ErrTempSpaceExhausted</code></p>
</td>
<td class="cellalignment4368" headers="r7c1-t17 r1c2-t17">
<p>6221 (transient)</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r8c1-t17" headers="r1c1-t17">
<p><a id="sthref369"></a><code dir="ltr">tt_ErrBadXlaRecord</code></p>
</td>
<td class="cellalignment4368" headers="r8c1-t17 r1c2-t17">
<p>8024</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r9c1-t17" headers="r1c1-t17">
<p><a id="sthref370"></a><code dir="ltr">tt_ErrXlaBookmarkUsed</code></p>
</td>
<td class="cellalignment4368" headers="r9c1-t17 r1c2-t17">
<p>8029</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r10c1-t17" headers="r1c1-t17">
<p><a id="sthref371"></a><code dir="ltr">tt_ErrXlaLsnBad</code></p>
</td>
<td class="cellalignment4368" headers="r10c1-t17 r1c2-t17">
<p>8031</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r11c1-t17" headers="r1c1-t17">
<p><a id="sthref372"></a><code dir="ltr">tt_ErrXlaNoSQL</code></p>
</td>
<td class="cellalignment4368" headers="r11c1-t17 r1c2-t17">
<p>8034</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r12c1-t17" headers="r1c1-t17">
<p><a id="sthref373"></a><code dir="ltr">tt_ErrXlaNoLogging</code></p>
</td>
<td class="cellalignment4368" headers="r12c1-t17 r1c2-t17">
<p>8035</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r13c1-t17" headers="r1c1-t17">
<p><a id="sthref374"></a><code dir="ltr">tt_ErrXlaParameter</code></p>
</td>
<td class="cellalignment4368" headers="r13c1-t17 r1c2-t17">
<p>8036</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r14c1-t17" headers="r1c1-t17">
<p><a id="sthref375"></a><code dir="ltr">tt_ErrXlaTableDiff</code></p>
</td>
<td class="cellalignment4368" headers="r14c1-t17 r1c2-t17">
<p>8037</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r15c1-t17" headers="r1c1-t17">
<p><a id="sthref376"></a><code dir="ltr">tt_ErrXlaTableSystem</code></p>
</td>
<td class="cellalignment4368" headers="r15c1-t17 r1c2-t17">
<p>8038</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r16c1-t17" headers="r1c1-t17">
<p><a id="sthref377"></a><code dir="ltr">tt_ErrXlaTupleMismatch</code></p>
</td>
<td class="cellalignment4368" headers="r16c1-t17 r1c2-t17">
<p>8046</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r17c1-t17" headers="r1c1-t17">
<p><a id="sthref378"></a><code dir="ltr">tt_ErrXlaDedicatedConnection</code></p>
</td>
<td class="cellalignment4368" headers="r17c1-t17 r1c2-t17">
<p>8047</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<div id="TTCDV301" class="example">
<p class="titleinexample"><a id="sthref379"></a>Example 5-15 Calling the handleXLAerror() function</p>
<p>This example shows <code dir="ltr">handleXLAerror()</code>, the error function for the <code dir="ltr">xlaSimple</code> demo program.</p>
<pre dir="ltr">void handleXLAerror(SQLRETURN rc, ttXlaHandle_h xlaHandle, 
                    SQLCHAR* err_msg, SQLINTEGER* native_error)
{
  SQLINTEGER retLen;
  SQLINTEGER code;
  char* err_msg_ptr;
 
  /* initialize return codes */
  rc = SQL_ERROR;
  *native_error = -1;
  err_msg[0] = &#39;\0&#39;;
  
  err_msg_ptr = (char*)err_msg;
  
  while (1)
  {
    int rc = ttXlaError(xlaHandle, &amp;code, err_msg_ptr,
                        ERR_BUF_LEN - (err_msg_ptr - (char*)err_msg), &amp;retLen);
    if (rc == SQL_NO_DATA_FOUND)
    {
      break;
    }
    if (rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) {
      sprintf(err_msg_ptr,
              &#34;*** Error fetching error message via ttXlaError(); rc=&lt;%d&gt;.&#34;,rc) ;
      break;
    }
    rc = SQL_ERROR;
    *native_error = code ; 
    /* append any other error messages */
    err_msg_ptr += retLen;
  }
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABFHIFC"></a>
<div id="TTCDV302" class="sect2">
<h3 class="sect2">Drop<a id="sthref380"></a><a id="sthref381"></a>ping a table that has an XLA bookmark</h3>
<p>Before you can drop a table that is subscribed to by an XLA bookmark, you must unsubscribe the table from the bookmark. There are several ways to unsubscribe a table from a bookmark, depending on whether the application is connected to the bookmark.</p>
<p>If XLA applications are connected and using bookmarks that are tracking the table to be dropped, then perform the following tasks.</p>
<ol>
<li>
<p>Each XLA application must call the <code dir="ltr"><a href="xla_ref.htm#CHEHAAIF">ttXlaTableStatus</a></code> function and set the <code dir="ltr"><span class="codeinlineitalic">newstatus</span></code> parameter to 0. This unsubscribes the table from the XLA bookmark in use by the application.</p>
</li>
<li>
<p>Drop the table.</p>
</li>
</ol>
<p>If XLA applications are not connected and using bookmarks associated with the table to be dropped, then perform the following tasks:</p>
<ol>
<li>
<p>Query the <code dir="ltr">SYS.XLASUBSCRIPTIONS</code> system table to see which bookmarks have subscribed to the table you want to drop.</p>
</li>
<li>
<p>Use the <a id="sthref382"></a><code dir="ltr">ttXlaUnsubscribe</code> built-in procedure to unsubscribe the table from each XLA bookmark with a subscription to the table.</p>
</li>
<li>
<p>Drop the table.</p>
</li>
</ol>
<p>Deleting bookmarks also unsubscribes the table from the XLA bookmarks. See the next section, <a href="#BABCFGIE">&#34;Deleting bookmarks&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABCFGIE"></a>
<div id="TTCDV303" class="sect2">
<h3 class="sect2">Del<a id="sthref383"></a>eting bookmarks</h3>
<p>You may want to delete bookmarks when you terminate an application or drop a table. Use the <a id="sthref384"></a><code dir="ltr"><a href="xla_ref.htm#CHEFCIJE">ttXlaDeleteBookmark</a></code> function to delete XLA bookmarks if the application is connected and using the bookmarks.</p>
<p>As described in <a href="#BABEIFGE">&#34;About XLA bookmarks&#34;</a>, a bookmark may be reused by a new connection after its previous connection has closed. The new connection can resume reading from the transaction log from where the previous connection stopped. Note the following:</p>
<ul>
<li>
<p>If you delete the bookmark, subsequent checkpoint operations such as the <code dir="ltr"><a id="sthref385"></a>ttCkpt</code> or <code dir="ltr"><a id="sthref386"></a>ttCkptBlocking</code> built-in procedure free the disk space associated with any unread update records in the transaction log.</p>
</li>
<li>
<p>If you do not delete the bookmark, when an XLA application connects and reuses the bookmark, all unread update records that have accumulated since the program terminated are read by the application. This is because the update records are persistent in the TimesTen transaction log. However, the danger is that these unread records can build up in the transaction log files and consume a lot of disk space.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>You cannot delete replicated bookmarks while the replication agent is running.</p>
</li>
<li>
<p>When you reuse a bookmark, you start with the Initial Read log record identifier in the transaction log file. To ensure that a connection that reuses a bookmark begins reading where the prior connection left off, the prior connection should call <code dir="ltr"><a href="xla_ref.htm#CHEDIAFE">ttXlaAcknowledge</a></code> to reset the bookmark position to the currently accessed record before disconnecting.</p>
</li>
<li>
<p>See <a class="olink TTREF261" href="../TTREF/proced.htm#TTREF261">&#34;ttLogHolds&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for related information. That TimesTen built-in procedure returns information about transaction log holds.</p>
</li>
<li>
<p>Be aware that <code dir="ltr">ttCkpt</code> and <code dir="ltr">ttCkptBlocking</code> require <code dir="ltr">ADMIN</code> privilege. TimesTen built-in procedures and any required privileges are documented in <a class="olink TTREF213" href="../TTREF/proced.htm#TTREF213">&#34;Built-In Procedures&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</li>
</ul>
</div>
<div id="TTCDV304" class="example">
<p class="titleinexample"><a id="sthref387"></a>Example 5-16 Deleting bookmarks</p>
<p>The <code dir="ltr">InitHandler()</code> function in the <code dir="ltr">xlaSimple</code> demo deletes the XLA bookmark upon exit, as shown in the following example.</p>
<pre dir="ltr">if (deleteBookmark) {
    ttXlaDeleteBookmark(xla_handle);
    if (rc != SQL_SUCCESS) {
    /* See <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a> */
    }
    xla_handle = NULL; /* Deleting the bookmark has the */
                       /* effect of disconnecting from XLA. */
}
/* Close the XLA connection as described in the next section, 
<a href="#BABIFJIA">&#34;Terminating an XLA application&#34;</a>. */
</pre>
<p>If the application is not connected and using the XLA bookmark, you can delete the bookmark either of the following ways:</p>
<ul>
<li>
<p>Close the bookmark and call the <a id="sthref388"></a><code dir="ltr">ttXlaBookmarkDelete</code> built-in procedure.</p>
</li>
<li>
<p>Close the bookmark and use the <code dir="ltr">ttIsql</code> command <code dir="ltr">xladeletebookmark</code>.</p>
</li>
</ul>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABIFJIA"></a>
<div id="TTCDV305" class="sect2">
<h3 class="sect2">Ter<a id="sthref389"></a>minating an XLA application</h3>
<p>When your XLA application has finished reading from the transaction log, gracefully exit by rolling back uncommitted transactions and freeing all handles. There are two approaches to this:</p>
<ul>
<li>
<p>Unsubscribe from all tables and materialized views, delete the XLA bookmark, and disconnect from the database.</p>
</li>
</ul>
<p>Or:</p>
<ul>
<li>
<p>Disconnect from the database but keep the XLA bookmark in place. When you reconnect at a later time, you can resume reading records from the bookmark.</p>
</li>
</ul>
<p>For the first approach, complete the following steps.</p>
<ol>
<li>
<p>Call <code dir="ltr"><a href="xla_ref.htm#CHEHAAIF">ttXlaTableStatus</a></code> to unsubscribe from each table and materialized view, setting the <code dir="ltr"><span class="codeinlineitalic">newstatus</span></code> parameter to 0.</p>
</li>
<li>
<p>Call <code dir="ltr">ttXlaDeleteBookmark</code> to delete the bookmark. See <a href="#BABCFGIE">&#34;Deleting bookmarks&#34;</a>.</p>
</li>
<li>
<p>Call <code dir="ltr"><a href="xla_ref.htm#CHEEFEGG">ttXlaClose</a></code> to disconnect the XLA handle.</p>
</li>
<li>
<p>Call the ODBC function <code dir="ltr">SQLTransact</code> with the <code dir="ltr">SQL_ROLLBACK</code> setting to roll back any uncommitted transaction.</p>
</li>
<li>
<p>Call the ODBC function <code dir="ltr">SQLDisconnect</code> to disconnect from the TimesTen database.</p>
</li>
<li>
<p>Call the ODBC function <code dir="ltr">SQLFreeConnect</code> to free memory allocated for the ODBC connection handle.</p>
</li>
<li>
<p>Call the ODBC function <code dir="ltr">SQLFreeEnv</code> to free the ODBC environment handle.</p>
</li>
</ol>
<p>For the second approach, maintaining the bookmark, skip the first two steps but complete the remaining steps.</p>
<p>Be aware that resources should be freed in reverse order of allocation. For example, the ODBC environment handle is allocated before the ODBC connection handle, so for cleanup free the connection handle before the environment handle.</p>
<div id="TTCDV306" class="example">
<p class="titleinexample"><a id="sthref390"></a>Example 5-17 Terminating an XLA application</p>
<p>This example shows <code dir="ltr">TerminateGracefully()</code>, the termination function in the <code dir="ltr">xlaSimple</code> Quick Start demo.</p>
<pre dir="ltr">void TerminateGracefully(int status)
{
 
  SQLRETURN     rc;
  SQLINTEGER    native_error ; 
  SQLINTEGER    oldstatus;
  SQLINTEGER    newstatus = 0;
    
  /* If the table has been subscribed to through XLA, unsubscribe it. */
 
  if (SYSTEM_TABLE_ID != 0) {
    rc = ttXlaTableStatus(xla_handle, SYSTEM_TABLE_ID, 0,
                          &amp;oldstatus, &amp;newstatus);
    if (rc != SQL_SUCCESS) {
      handleXLAerror (rc, xla_handle, err_buf, &amp;native_error);
      fprintf(stderr, &#34;Error when unsubscribing from &#34;TABLE_OWNER&#34;.&#34;TABLE_NAME
              &#34; table &lt;%d&gt;: %s&#34;, rc, err_buf);
    }
    SYSTEM_TABLE_ID = 0;
  }
 
  /* Close the XLA connection. */
 
  if (xla_handle != NULL) {
    rc = ttXlaClose(xla_handle);
    if (rc != SQL_SUCCESS) {
      fprintf(stderr, &#34;Error when disconnecting from XLA:&lt;%d&gt;&#34;, rc);
    }
    xla_handle = NULL;
  }
 
  if (hstmt != SQL_NULL_HSTMT) {
    rc = SQLFreeStmt(hstmt, SQL_DROP);
    if (rc != SQL_SUCCESS) {
      handleError(rc, henv, hdbc, hstmt, err_buf, &amp;native_error);
      fprintf(stderr, &#34;Error when freeing statement handle:\n%s\n&#34;, err_buf);
    }
    hstmt = SQL_NULL_HSTMT;
  }
 
  /* Disconnect from TimesTen entirely. */
    
  if (hdbc != SQL_NULL_HDBC) {
    rc = SQLTransact(henv, hdbc, SQL_ROLLBACK);
    if (rc != SQL_SUCCESS) {
      handleError(rc, henv, hdbc, hstmt, err_buf, &amp;native_error);
      fprintf(stderr, &#34;Error when rolling back transaction:\n%s\n&#34;, err_buf);
    }
 
    rc = SQLDisconnect(hdbc);
    if (rc != SQL_SUCCESS) {
      handleError(rc, henv, hdbc, hstmt, err_buf, &amp;native_error);
      fprintf(stderr, &#34;Error when disconnecting from TimesTen:\n%s\n&#34;, err_buf);
    }
 
    rc = SQLFreeConnect(hdbc);
    if (rc != SQL_SUCCESS) {
      handleError(rc, henv, hdbc, hstmt, err_buf, &amp;native_error);
      fprintf(stderr, &#34;Error when freeing connection handle:\n%s\n&#34;, err_buf);
    }
    hdbc = SQL_NULL_HDBC;
  }
 
  if (henv != SQL_NULL_HENV) {
    rc = SQLFreeEnv(henv);
    if (rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) {
      handleError(rc, henv, hdbc, hstmt, err_buf, &amp;native_error);
      fprintf(stderr, &#34;Error when freeing environment handle:\n%s\n&#34;, err_buf);
    }
    henv = SQL_NULL_HENV;
  }
  exit(status);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDFIBJ"></a>
<div id="TTCDV307" class="sect1">
<h2 class="sect1">Using XLA as a re<a id="sthref391"></a><a id="sthref392"></a><a id="sthref393"></a>plication mechanism</h2>
<p>TimesTen replication as described in <a class="olink TTREP" href="../TTREP/toc.htm"><span class="italic">Oracle TimesTen In-Memory Database Replication Guide</span></a> is sufficient for most customer needs; however, it is also possible to use XLA functions to replicate updates from one database to another. Implementing your own replication scheme on top of XLA in this way is fairly complicated, but can be considered if TimesTen replication is not feasible for some reason.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot use XLA to replicate updates between different platforms or between 32-bit and 64-bit versions of the same platform.</div>
<p>In this section, the sending database is referred to as the master and the receiving database as the subscriber. To use XLA to replicate changes between databases, first use the <code dir="ltr"><a href="xla_ref.htm#CHEFECEF">ttXlaPersistOpen</a></code> function to initialize the XLA handles, as described in <a href="#BABBGAJJ">&#34;Initializing XLA and obtaining an XLA handle&#34;</a>.</p>
<p>After the XLA handles have been initialized for the databases, take the steps described in the following sections:</p>
<ul>
<li>
<p><a href="#BABDIEEF">Checking table compatibility between databases</a></p>
</li>
<li>
<p><a href="#BABHFBHI">Replicating updates between databases</a></p>
</li>
<li>
<p><a href="#BABFFBDH">Handling timeout and deadlock errors</a></p>
</li>
<li>
<p><a href="#BABBJCIC">Checking for update conflicts</a></p>
</li>
</ul>
<p>XLA functions mentioned here are documented in <a href="xla_ref.htm#CHECFFJB">Chapter 9, &#34;XLA Reference&#34;</a>.</p>
<a id="BABDIEEF"></a>
<div id="TTCDV308" class="sect2">
<h3 class="sect2">Checking table compatibility between databases</h3>
<p>Before transferring update records from one database to the other, verify that the tables in the master and subscriber databases are compatible with one another:</p>
<ul>
<li>
<p>You can check the descriptions of a table and its columns by using the <code dir="ltr"><a href="xla_ref.htm#CHEBGDFB">ttXlaTableByName</a></code>, <code dir="ltr"><a href="xla_ref.htm#CHEDDJIC">ttXlaGetTableInfo</a></code>, and <code dir="ltr"><a href="xla_ref.htm#CHEEJABC">ttXlaGetColumnInfo</a></code> functions. See <a href="#BABEEHFE">&#34;Checking table and column descriptions&#34;</a> immediately below.</p>
</li>
<li>
<p>You can check the table and column versions of a specific XLA record by using the <code dir="ltr"><a href="xla_ref.htm#CHEDIHGI">ttXlaVersionTableInfo</a></code> and <code dir="ltr"><a href="xla_ref.htm#CHECBBBE">ttXlaVersionColumnInfo</a></code> functions. See <a href="#CIHJCDFC">&#34;Checking table and column versions&#34;</a>, following shortly.</p>
</li>
</ul>
<a id="BABEEHFE"></a>
<div id="TTCDV309" class="sect3">
<h4 class="sect3">Checking table and column descriptions</h4>
<p>Use the <code dir="ltr">ttXlaTableByName</code>, <code dir="ltr">ttXlaGetTableInfo</code>, and <code dir="ltr">ttXlaGetColumnInfo</code> functions to return <code dir="ltr"><a href="xla_ref.htm#CHEHJIAA">ttXlaTblDesc_t</a></code> and <code dir="ltr"><a href="xla_ref.htm#CHEIGBDD">ttXlaColDesc_t</a></code> descriptions for each table you want to replicate. These operations are described in <a href="#BABHGGDB">&#34;Specifying which tables to monitor for updates&#34;</a> and <a href="#BABEEFHF">&#34;Obtaining column descriptions&#34;</a>. You can then pass these descriptions to the <code dir="ltr"><a href="xla_ref.htm#CHECAIHJ">ttXlaTableCheck</a></code> function. The output parameter, <code dir="ltr">compat</code>, specifies whether the tables are compatible. A value of 1 indicates compatibility and 0 indicates non-compatibility. The following example demonstrates this.</p>
<div id="TTCDV310" class="example">
<p class="titleinexample"><a id="sthref394"></a>Example 5-18 Checking table and column descriptions for compatibility</p>
<pre dir="ltr">SQLINTEGER compat;
ttXlaTblDesc_t table;
ttXlaColDesc_t columns[20];

rc = ttXlaTableCheck(xla_handle, &amp;table, columns, &amp;compat);
if (compat) {
    /* Go ahead and start replicating */
}
else {
    /* Not compatible or some other error occurred */
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHJCDFC"></a>
<div id="TTCDV311" class="sect3">
<h4 class="sect3">Checking table and column versions</h4>
<p>Use the <code dir="ltr"><a href="xla_ref.htm#CHEDIHGI">ttXlaVersionTableInfo</a></code> and <code dir="ltr"><a href="xla_ref.htm#CHECBBBE">ttXlaVersionColumnInfo</a></code> functions to retrieve the table structure information of an update record at the time the record was generated.</p>
<p>The following example verifies that the table associated with the <code dir="ltr"><span class="codeinlineitalic">pXlaRecord</span></code> update record from the <code dir="ltr"><span class="codeinlineitalic">pCmd</span></code> source is compatible with the <code dir="ltr"><span class="codeinlineitalic">hXlaTarget</span></code> target.</p>
<div id="TTCDV312" class="example">
<p class="titleinexample"><a id="sthref395"></a>Example 5-19 Checking table and column versions for compatibility</p>
<pre dir="ltr">BOOL CUTLCheckXlaTable (SCOMMAND* pCmd,
                        ttXlaHandle_h hXlaTarget,
                        const ttXlaUpdateDesc_t* pXlaRecord)
{
  /* locals */
  ttXlaTblVerDesc_t tblVerDescSource;
  ttXlaColDesc_t colDescSource [255];
  SQLINTEGER iColsReturned = 0;
  SQLINTEGER iCompatible = 0;
  SQLRETURN rc;

  /* only certain update record types should be checked */
  if (pXlaRecord-&gt;type == INSERTTUP ||
      pXlaRecord-&gt;type == UPDATETUP ||
      pXlaRecord-&gt;type == DELETETUP)
  {
     /* Get source table description associated with this record */
     /* from the time it was generated. */
     rc = ttXlaVersionTableInfo (pCmd-&gt;pCtx-&gt;con-&gt;hXla,
             (ttXlaUpdateDesc_t*) pXlaRecord, &amp;tblVerDescSource);

     if (rc == SQL_SUCCESS)
     {
         /* Get the source column descriptors for this table */
         /* at the time the record was generated. */
         rc = ttXlaVersionColumnInfo (pCmd-&gt;pCtx-&gt;con-&gt;hXla,
                 (ttXlaUpdateDesc_t*) pXlaRecord,
                 colDescSource, 255, &amp;iColsReturned);

         if (rc == SQL_SUCCESS)
         {
             /* Check compatibility. */
             rc = ttXlaTableCheck (hXlaTarget,
                     &amp;tblVerDescSource.tblDesc, colDescSource,
                     &amp;iCompatible);
         }
     }
  }
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABHFBHI"></a>
<div id="TTCDV313" class="sect2">
<h3 class="sect2">Replicating updates between databases</h3>
<p>When you are ready to begin replication, use the <code dir="ltr"><a href="xla_ref.htm#CHEJGJBH">ttXlaNextUpdate</a></code> or <code dir="ltr"><a href="xla_ref.htm#CHEBCAAE">ttXlaNextUpdateWait</a></code> function to obtain batches of update records from the master database and <a id="sthref396"></a><code dir="ltr"><a href="xla_ref.htm#CHEHCDII">ttXlaApply</a></code> to write the records to the subscriber database. The following example shows this.</p>
<div id="TTCDV314" class="example">
<p class="titleinexample"><a id="sthref397"></a>Example 5-20 Replicating updates between databases</p>
<pre dir="ltr">int j;
ttXlaHandle_h h;
SQLINTEGER records;
ttXlaUpdateDesc_t** arry;

  do {
    /* get up to 15 updates */
    rc = ttXlaNextUpdate(h,&amp;arry,15,&amp;records);
    if (rc != SQL_SUCCESS) {
      /* See <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a> */
    }
 
    /* print number of updates returned */
    printf(&#34;Records returned by ttXlaNextUpdate : %d\n&#34;,records);
 
    /* apply the received updates */  
    for (j=0;j &lt; records;j++) {
      ttXlaUpdateDesc_t* p;
 
      p = arry[j];
      rc = ttXlaApply(h, p, 0);
      if (rc != SQL_SUCCESS){
      /* See <a href="#BABJGJCJ">&#34;Handling XLA errors&#34;</a> and */
      /* <a href="#BABFFBDH">&#34;Handling timeout and deadlock errors&#34;</a> below */
      }
    }
 
    /* print number of updates applied */
    printf(&#34;Records applied successfully : %d\n&#34;,records);
 
  } while (records != 0);
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Important:</p>
If you are packaging data to be replicated across a network, or anywhere between processes not using the same memory space, you must ensure that the <code dir="ltr">ttXlaUpdateDesc_t</code> data structure is shipped in its entirely. Its length is indicated by <code dir="ltr">ttXlaUpdateDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">header.length</span></code>, where the <code dir="ltr"><span class="codeinlineitalic">header</span></code> element is a <code dir="ltr">ttXlaNodeHdr_t</code> structure that in turn has a <code dir="ltr"><span class="codeinlineitalic">length</span></code> element. Also see <a href="xla_ref.htm#CHEGEBFI">&#34;ttXlaUpdateDesc_t&#34;</a> and <a href="xla_ref.htm#CHECJIBJ">&#34;ttXlaNodeHdr_t&#34;</a>.</div>
</div>
<!-- class="sect2" -->
<a id="BABFFBDH"></a>
<div id="TTCDV315" class="sect2">
<h3 class="sect2">Handling <a id="sthref398"></a>timeout and <a id="sthref399"></a>deadlock errors</h3>
<p>The return code from <code dir="ltr"><a href="xla_ref.htm#CHEHCDII">ttXlaApply</a></code> indicates whether the update was successful. If the return code is not <code dir="ltr">SQL_SUCCESS</code>, then the update may have encountered a transient problem, such as a deadlock or timeout, or a persistent problem. You can use <code dir="ltr"><a href="xla_ref.htm#CHEECIEI">ttXlaError</a></code> to check for errors, such as <a id="sthref400"></a><code dir="ltr">tt_ErrDeadlockVictim</code> or <a id="sthref401"></a><code dir="ltr">tt_ErrTimeoutVictim</code>. Recovery from transient errors is possible by rolling back the replicated transaction and reexecuting it. Other errors may be persistent, such as those for duplicate key violations or ke<a id="sthref402"></a>y not found. Such errors are likely to repeat if the transaction is reexecuted.</p>
<p>If <code dir="ltr">ttXlaApply</code> returns a timeout or deadlock error before applying the commit record (<code dir="ltr">ttXlaUpdateDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">flags</span></code> <code dir="ltr">= TT_UPDCOMMIT</code>) for a transaction to the subscriber database, you can do either of the following:</p>
<ul>
<li>
<p>Use <a id="sthref403"></a><code dir="ltr"><a href="xla_ref.htm#CHECECCA">ttXlaRollback</a></code> to roll back the transaction.</p>
</li>
<li>
<p>Use <a id="sthref404"></a><a id="sthref405"></a><code dir="ltr"><a href="xla_ref.htm#CHEJAJEA">ttXlaCommit</a></code> to commit the changes in the records that have been applied to the subscriber database.</p>
</li>
</ul>
<p>To enable recovery from transient errors, you should keep track of transaction boundaries on the master database and store the records associated with the transaction currently being applied to the subscriber in a user buffer, so you can reapply them if necessary. The transaction boundaries can be found by checking the <code dir="ltr"><span class="codeinlineitalic">flags</span></code> member of the <code dir="ltr"><a href="xla_ref.htm#CHEGEBFI">ttXlaUpdateDesc_t</a></code> structure. Consider the following example. If this condition is true, then the record was committed:</p>
<pre dir="ltr">(pXlaRecords [iRecordIndex]-&gt;flags &amp; TT_UPDCOMMIT)
</pre>
<p>If you encounter an error that requires you to roll back a transaction, call <code dir="ltr">ttXlaRollback</code> to roll back the records applied to the subscriber database. Then call <code dir="ltr">ttXlaApply</code> to reapply all the rolled back records stored in your buffer.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An alternative to buffering the transaction records in a user buffer is to call <a id="sthref406"></a><code dir="ltr"><a href="xla_ref.htm#CHEICHBA">ttXlaGetLSN</a></code> to get the transaction log record identifier of each commit record in the transaction log, as described in <a href="#BABFCJIB">&#34;Changing the location of a bookmark&#34;</a>. If you encounter an error that requires you to roll back a transaction, you can call <a id="sthref407"></a><code dir="ltr"><a href="xla_ref.htm#CHEDFIEI">ttXlaSetLSN</a></code> to reset the bookmark to the beginning of the transaction in the transaction log and reapply the records. However, the extra overhead associated with the <code dir="ltr">ttXlaGetLSN</code> function may make this a less efficient option.</div>
</div>
<!-- class="sect2" -->
<a id="BABBJCIC"></a>
<div id="TTCDV316" class="sect2">
<h3 class="sect2">Checking for <a id="sthref408"></a><a id="sthref409"></a>update conflicts</h3>
<p>If you have applications making simultaneous updates to both your master and subscriber databases, you may encounter update conflicts. Update conflicts are described in detail in <a class="olink TTREP519" href="../TTREP/conflict.htm#TTREP519">&#34;Resolving Replication Conflicts&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Replication Guide</span>.</p>
<p>To check for update conflicts in XLA, you can set the <code dir="ltr"><a href="xla_ref.htm#CHEHCDII">ttXlaApply</a></code> <code dir="ltr"><span class="codeinlineitalic">test</span></code> parameter to compare the old row value (<code dir="ltr">ttXlaUpdateDesc_t -&gt;</code><code dir="ltr"><span class="codeinlineitalic">tuple1</span></code>) in each record of type <code dir="ltr">UPDATETUP</code> with the existing row in the subscriber database. If the old row value in the update description does not match the corresponding row in the subscriber database, an update conflict is probably the reason. In this case, <code dir="ltr">ttXlaApply</code> does not apply the update to the subscriber and returns an <a id="sthref410"></a><code dir="ltr">sb_ErrXlaTupleMismatch</code> error.</p>
</div>
<!-- class="sect2" -->
<a id="BABCFIFC"></a>
<div id="TTCDV317" class="sect2">
<h3 class="sect2">Replicating updates to a non-TimesTen database</h3>
<p><a id="sthref411"></a>If you are replicating changes to a non-TimesTen database, you can use the <code dir="ltr"><a href="xla_ref.htm#CHEHADAC">ttXlaGenerateSQL</a></code> function to convert the record data into a SQL statement that can be read by the non-TimesTen subscriber. For update and delete records, <code dir="ltr">ttXlaGenerateSQL</code> requires a primary key or a unique index on a non-nullable column to generate the correct SQL.</p>
<p>The <code dir="ltr">ttXlaGenerateSQL</code> function accepts a <code dir="ltr"><a href="xla_ref.htm#CHEGEBFI">ttXlaUpdateDesc_t</a></code> record as a parameter and outputs its SQL equivalent into a buffer.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
The SQL returned by <code dir="ltr">ttXlaGenerateSQL</code> uses TimesTen SQL syntax. The SQL statement may fail on a non-TimesTen subscriber if there are SQL syntax incompatibilities between the two systems. In addition, the SQL statement is encoded in the connection character set associated with the XLA handle.</div>
<div id="TTCDV318" class="example">
<p class="titleinexample"><a id="sthref412"></a>Example 5-21 Replicating updates to a non-TimesTen database</p>
<p>This example translates a record (<code dir="ltr">record</code>) and stores the resulting SQL output in a 200-character buffer (<code dir="ltr">buffer</code>). The actual size of the buffer is returned in the <code dir="ltr">actualLength</code> parameter.</p>
<pre dir="ltr">ttXlaUpdateDesc_t record;
char buffer[200];
SQLINTEGER actualLength;

rc = ttXlaGenerateSQL(xla_handle, &amp;record, buffer, 200, &amp;actualLength);

if (rc != SQL_SUCCESS) {
    handleXLAerror (rc, xla_handle, err_buf, &amp;native_error);
    if ( native_error == 8034 ) { // tt_ErrXlaNoSQL
      printf(&#34;Unable to translate to SQL\n&#34;);
    }
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCIICJ"></a>
<div id="TTCDV319" class="sect1">
<h2 class="sect1">Other XLA features</h2>
<p>The following sections describe how to use additional XLA features:</p>
<ul>
<li>
<p><a href="#BABFCJIB">Changing the location of a bookmark</a></p>
</li>
<li>
<p><a href="#BABDCFBB">Passing application context</a></p>
</li>
</ul>
<a id="BABFCJIB"></a>
<div id="TTCDV320" class="sect2">
<h3 class="sect2">Chan<a id="sthref413"></a>ging the location of a bookmark</h3>
<p>At any point during a connection, you can call the <code dir="ltr"><a href="xla_ref.htm#CHEICHBA">ttXlaGetLSN</a></code> function to query the system for the Current Read log record identifier. If you must replay a set of updates, you can use the <code dir="ltr"><a href="xla_ref.htm#CHEDFIEI">ttXlaSetLSN</a></code> function to reset the Current Read log record identifier to any valid value larger than the Initial Read log record identifier set by the last <code dir="ltr"><a href="xla_ref.htm#CHEDIAFE">ttXlaAcknowledge</a></code> call. In this context, &#34;larger&#34; only applies if the log record identifiers being compared are from records in the same transaction. If that is not the case, then any log record identifier from a transaction that committed before another transaction is the &#34;smaller&#34; log record identifier, even if the numeric value of the log record identifier is larger. The only way to enable the Initial Read log record identifier to move forward to the Current Read log record identifier is by calling the <code dir="ltr">ttXlaAcknowledge</code> function, which indicates that you have received and processed all transaction log records up to the Current Read log record identifier. Once you have called <code dir="ltr">ttXlaAcknowledge</code> on a particular bookmark, you can no longer access transaction log records with a log record identifier smaller than the Current Read log record identifier.</p>
</div>
<!-- class="sect2" -->
<a id="BABDCFBB"></a>
<div id="TTCDV321" class="sect2">
<h3 class="sect2">Pas<a id="sthref414"></a><a id="sthref415"></a>sing application context</h3>
<p>Although it is not an XLA function, writers to the transaction log can call the <a id="sthref416"></a><a id="sthref417"></a><a id="sthref418"></a><code dir="ltr">ttApplicationContext</code> built-in procedure to pass binary data associated with an application to XLA readers. This procedure specifies a single <code dir="ltr">VARBINARY</code> value that is returned in the next update record produced by the current transaction. XLA readers can obtain a pointer to this value as described in <a href="#BABHAIJE">&#34;Reading NOT INLINE variable-length column data&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A context value is applied to only one update record. After it has been applied it is reset. If the same context value should be applied to multiple updates, then it must be reestablished before each update.</div>
<p>To set the context:</p>
<ol>
<li>
<p>Declare two program variables for invoking the <code dir="ltr">ttApplicationContext</code> procedure. The variable <code dir="ltr">contextBuffer</code> is a <code dir="ltr">CHAR</code> array that is declared to be large enough to accommodate the longest application context that you use. The variable <code dir="ltr">contextBufferLen</code> is of type <code dir="ltr">INTEGER</code> and is used to convey the actual length of the context on each call to <code dir="ltr">ttApplicationContext</code>.</p>
</li>
<li>
<p>Initialize a statement handle with a compiled invocation of the <code dir="ltr">ttApplicationContext</code> built-in procedure:</p>
<pre dir="ltr">rc = SQLPrepare(hstmt, &#34;call ttApplicationContext(?)&#34;, SQL_NTS);
rc = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_BINARY,
                      SQL_VARBINARY, 0, 0, &amp;contextBuffer,
                      sizeof contextBuffer, &amp;contextBufferLen);
</pre></li>
<li>
<p>When the application context must be set later, copy the context value into <code dir="ltr">contextBuffer</code>, assign the length of the context to <code dir="ltr">contextBufferLen</code>, and invoke <code dir="ltr">ttApplicationContext</code> with the call:</p>
<pre dir="ltr">rc = SQLExecute(hstmt);
</pre>
<p>The transaction is then committed with the usual call on <code dir="ltr">SQLTransact</code>:</p>
<pre dir="ltr">rc = SQLTransact(NULL, hdbc, SQL_COMMIT);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a SQL operation fails after a call to <code dir="ltr">ttApplicationContext</code>, the context may not be stored in the next SQL operation and therefore may be lost. If this happens, the application can call <code dir="ltr">ttApplicationContext</code> again before the next SQL operation.</div>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4359">
<tr>
<td class="cellalignment4368">
<table class="cellalignment4364">
<tr>
<td class="cellalignment4363"><a href="pro_c.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4363"><a href="xa_dtp.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4370">
<table class="cellalignment4362">
<tr>
<td class="cellalignment4363"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4363"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4363"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4363"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4363"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4363"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>