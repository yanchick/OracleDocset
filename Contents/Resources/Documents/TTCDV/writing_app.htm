<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-107473"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Working%20with%20TimesTen%20Databases%20in%20ODBC"></a><title>Working with TimesTen Databases in ODBC</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1033"/>
<meta name="dcterms.created" content="2014-12-10T16:46:46Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen In-Memory Database C Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E21637-09"/>
<meta name="dcterms.isVersionOf" content="TTCDV"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="compiling.htm" title="Previous" type="text/html"/>
<link rel="Next" href="oci.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21637-09.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">6/15</span> <!-- End Header -->
<div id="TTCDV112" class="chapter"><a id="BABJJEEB"></a>
<h1 class="chapter"><span class="secnum">2</span> Working with TimesTen Databases in ODBC</h1>
<p>This chapter covers TimesTen programming features and describes how to use ODBC to connect to and use the TimesTen database. It includes the following topics:</p>
<ul>
<li>
<p><a href="#CEGGJGDG">Managing TimesTen database connections</a></p>
</li>
<li>
<p><a href="#CEGBJCFA">Managing TimesTen data</a></p>
</li>
<li>
<p><a href="#BABBJIAA">Using additional TimesTen data management features</a></p>
</li>
<li>
<p><a href="#BABFJBFE">Considering TimesTen features for access control</a></p>
</li>
<li>
<p><a href="#BABCADHC">Handling Errors</a></p>
</li>
<li>
<p><a href="#BABDAABC">Using automatic client failover in your application</a></p>
</li>
</ul>
<p>Note that TimesTen supports ODBC 2.5, Extension Level 1, with additional features for Extension Level 2 where those features are included in <a href="odbc_supported.htm#BEIJHJBJ">Chapter 10, &#34;TimesTen ODBC Functions and Options&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>For using OCI to access TimesTen from a C application, see <a href="oci.htm#BABCABGH">Chapter 3, &#34;TimesTen Support for OCI&#34;</a>.</p>
</li>
<li>
<p>For using Pro*C/C++ to access TimesTen from a C application, see <a href="pro_c.htm#CIHCJHGD">Chapter 4, &#34;TimesTen Support for Pro*C/C++&#34;</a>.</p>
</li>
<li>
<p>For accessing TimesTen from a C++ application, see <a class="olink TTCLS" href="../TTCLS/toc.htm"><span class="italic">Oracle TimesTen In-Memory Database TTClasses Guide</span></a>.</p>
</li>
<li>
<p>For accessing TimesTen from a C# application, see <a class="olink TTODP" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=TTODP"><span class="italic">Oracle Data Provider for .NET Oracle TimesTen In-Memory Database Support User&#39;s Guide</span></a>.</p>
</li>
</ul>
</div>
<a id="CEGGJGDG"></a>
<div id="TTCDV113" class="sect1">
<h2 class="sect1">Mana<a id="sthref31"></a>ging TimesTen database connections</h2>
<p>The <a class="olink TTOPR" href="../TTOPR/toc.htm"><span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span></a> contains information about creating a DSN for the database. The type of DSN you create depends on whether your application connects directly to the database or connects through a client.</p>
<p>If you intend to connect directly to the database, refer to <a class="olink TTOPR120" href="../TTOPR/using.htm#TTOPR120">&#34;Managing TimesTen Databases&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>. There are sections on creating a DSN for a direct connection from UNIX or Windows.</p>
<p>If you intend to create a client connection to the database, refer to <a class="olink TTOPR177" href="../TTOPR/client_server.htm#TTOPR177">&#34;Working with the TimesTen Client and Server&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>. There are sections on creating a DSN for a client/server connection from UNIX or Windows.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>In TimesTen, the user name and password must be for a valid user who has been granted <code dir="ltr">CREATE SESSION</code> privilege to connect to the database.</p>
</li>
<li>
<p>A TimesTen connection cannot be inherited from a parent process. If a process opens a database connection before creating (forking) a child process, the child must not use the connection.</p>
</li>
</ul>
</div>
<p>The rest of this section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABFIIGF">SQLConnect, SQLDriverConnect, SQLAllocConnect, SQLDisconnect functions</a></p>
</li>
<li>
<p><a href="#BABDAAFJ">Connecting to and disconnecting from a database</a></p>
</li>
<li>
<p><a href="#BABIABBI">Setting connection attributes programmatically</a></p>
</li>
<li>
<p><a href="#BABECBAJ">Using a default DSN</a></p>
</li>
<li>
<p><a href="#BABHAGHD">Access control for connections</a></p>
</li>
</ul>
<a id="BABFIIGF"></a>
<div id="TTCDV114" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQLCon<a id="sthref32"></a><a id="sthref33"></a><a id="sthref34"></a><a id="sthref35"></a><a id="sthref36"></a>nect, SQLDriverConnect, SQLAllocConnect, SQLDisconnect functions</h3>
<p>The following ODBC functions are available for connecting to a database and related functionality:</p>
<ul>
<li>
<p><code dir="ltr">SQLConnect</code>: Loads a driver and connects to the database. The connection handle points to where information about the connection is stored, including status, transaction state, results, and error information.</p>
</li>
<li>
<p><code dir="ltr">SQLDriverConnect</code>: This is an alternative to <code dir="ltr">SQLConnect</code> when more information is required than what is supported by <code dir="ltr">SQLConnect</code>, which is just data source (the database), user name, and password.</p>
</li>
<li>
<p><code dir="ltr">SQLAllocConnect</code>: Allocates memory for a connection handle within the specified environment.</p>
</li>
<li>
<p><code dir="ltr">SQLDisconnect</code>: Disconnect from the database. Takes the existing connection handle as its only argument.</p>
</li>
</ul>
<p>Refer to ODBC API reference documentation for additional details about these functions.</p>
</div>
<!-- class="sect2" -->
<a id="BABDAAFJ"></a>
<div id="TTCDV115" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Con<a id="sthref37"></a><a id="sthref38"></a>necting to and disconnecting from a database</h3>
<p>This section provides examples of connecting to and disconnecting from the database.</p>
<div id="TTCDV116" class="example">
<p class="titleinexample"><a id="CEGJJJDF"></a>Example 2-1 Connect and disconnect (excerpt)</p>
<p>This code fragment invokes <code dir="ltr">SQLConnect</code> and <code dir="ltr">SQLDisconnect</code> to connect to and disconnect from the database named <code dir="ltr">FixedDs</code>. The first invocation of <code dir="ltr">SQLConnect</code> by any application causes the creation of the <code dir="ltr">FixedDs</code> database. Subsequent invocations of <code dir="ltr">SQLConnect</code> would connect to the existing database.</p>
<pre dir="ltr">#include &lt;sql.h&gt;
SQLRETURN retcode;
SQLHDBC hdbc;

...
retcode = SQLConnect(hdbc,
                     (SQLCHAR*)&#34;FixedDs&#34;, SQL_NTS,
                     (SQLCHAR*)&#34;johndoe&#34;, SQL_NTS,
                     (SQLCHAR*)&#34;opensesame&#34;, SQL_NTS);
...
retcode = SQLDisconnect(hdbc);
...
</pre></div>
<!-- class="example" -->
<div id="TTCDV117" class="example">
<p class="titleinexample"><a id="BABGAEJC"></a>Example 2-2 Connect and disconnect (complete program)</p>
<p>This example contains a complete program that creates, connects to, and disconnects from a database. The example uses <code dir="ltr">SQLDriverConnect</code> instead of <code dir="ltr">SQLConnect</code> to set up the connection, and uses <code dir="ltr">SQLAllocConnect</code> to allocate memory. It also shows how to get error messages. (In addition, you can refer to <a href="#BABCADHC">&#34;Handling Errors&#34;</a>.)</p>
<pre dir="ltr">#ifdef WIN32
#include &lt;windows.h&gt;
#else
#include &lt;sqlunix.h&gt;
#endif
#include &lt;sql.h&gt;
#include &lt;sqlext.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

static void chkReturnCode(SQLRETURN rc, SQLHENV henv,
                          SQLHDBC hdbc, SQLHSTMT hstmt,
                          char* msg, char* filename,
                          int lineno, BOOL err_is_fatal);
#define DEFAULT_CONNSTR &#34;DSN=sampledb_1122;PermSize=32&#34;

int
main(int ac, char** av)
{
   SQLRETURN rc = SQL_SUCCESS;
                  /* General return code for the API */
   SQLHENV henv = SQL_NULL_HENV;
                  /* Environment handle */
   SQLHDBC hdbc = SQL_NULL_HDBC;
                  /* Connection handle */
   SQLHSTMT hstmt = SQL_NULL_HSTMT;
                  /* Statement handle */
   SQLCHAR connOut[255];
                  /* Buffer for completed connection string */
   SQLSMALLINT connOutLen;
                  /* Number of bytes returned in ConnOut */
   SQLCHAR *connStr = (SQLCHAR*)DEFAULT_CONNSTR;
                  /* Connection string */
   rc = SQLAllocEnv(&amp;henv);
   if (rc != SQL_SUCCESS) {
      fprintf(stderr, &#34;Unable to allocate an &#34;
             &#34;environment handle\n&#34;);
    exit(1);
   }
   rc = SQLAllocConnect(henv, &amp;hdbc);
   chkReturnCode(rc, henv, SQL_NULL_HDBC,
              SQL_NULL_HSTMT,
              &#34;Unable to allocate a &#34;
              &#34;connection handle\n&#34;,
              __FILE__, __LINE__, 1);

   rc = SQLDriverConnect(hdbc, NULL,
                         connStr, SQL_NTS,
                         connOut, sizeof(connOut),
                         &amp;connOutLen,
                         SQL_DRIVER_NOPROMPT);
   chkReturnCode(rc, henv, hdbc, SQL_NULL_HSTMT,
                 &#34;Error in connecting to the&#34;
                 &#34; database\n&#34;,
                 __FILE__, __LINE__, 1);
   rc = SQLAllocStmt(hdbc, &amp;hstmt);
   chkReturnCode(rc, henv, hdbc, SQL_NULL_HSTMT,
                 &#34;Unable to allocate a &#34;
                 &#34;statement handle\n&#34;,
                 __FILE__, __LINE__, 1);

   /* Your application code here */

   if (hstmt != SQL_NULL_HSTMT) {
     rc = SQLFreeStmt(hstmt, SQL_DROP);
     chkReturnCode(rc, henv, hdbc, hstmt,
                   &#34;Unable to free the &#34;
                   &#34;statement handle\n&#34;,
                    __FILE__, __LINE__, 0);
   }

   rc = SQLDisconnect(hdbc);
   chkReturnCode(rc, henv, hdbc,
                 SQL_NULL_HSTMT,
                 &#34;Unable to close the &#34;
                 &#34;connection\n&#34;,
                 __FILE__, __LINE__, 0);

   rc = SQLFreeConnect(hdbc);
   chkReturnCode(rc, henv, hdbc,
                 SQL_NULL_HSTMT,
                 &#34;Unable to free the &#34;
                 &#34;connection handle\n&#34;,
                 __FILE__, __LINE__, 0);

   rc = SQLFreeEnv(henv);
   chkReturnCode(rc, henv, SQL_NULL_HDBC,
                 SQL_NULL_HSTMT,
                 &#34;Unable to free the &#34;
                 &#34;environment handle\n&#34;,
                 __FILE__, __LINE__, 0);
     return 0;
   }

   static void
   chkReturnCode(SQLRETURN rc, SQLHENV henv,
                 SQLHDBC hdbc, SQLHSTMT hstmt,
                 char* msg, char* filename,
                 int lineno, BOOL err_is_fatal)
   {
      #define MSG_LNG 512
      SQLCHAR sqlState[MSG_LNG];
      /* SQL state string */
      SQLINTEGER nativeErr;
      /* Native error code */
      SQLCHAR errMsg[MSG_LNG];
      /* Error msg text buffer pointer */
      SQLSMALLINT errMsgLen;
      /* Error msg text Available bytes */
      SQLRETURN ret = SQL_SUCCESS;
      if (rc != SQL_SUCCESS &amp;&amp;
          rc != SQL_NO_DATA_FOUND ) {
         if (rc != SQL_SUCCESS_WITH_INFO) {
          /*
           * It&#39;s not just a warning
           */
         fprintf(stderr, &#34;*** ERROR in %s, line %d:&#34;
                  &#34; %s\n&#34;,
                  filename, lineno, msg);
     }
     /*
      * Now see why the error/warning occurred
      */
     while (ret == SQL_SUCCESS ||
            ret == SQL_SUCCESS_WITH_INFO) {
       ret = SQLError(henv, hdbc, hstmt,
                      sqlState, &amp;nativeErr,
                      errMsg, MSG_LNG,
                      &amp;errMsgLen);
       switch (ret) {
         case SQL_SUCCESS:
           fprintf(stderr, &#34;*** %s\n&#34;
                    &#34;*** ODBC Error/Warning = %s, &#34;
                    &#34;TimesTen Error/Warning &#34;
                    &#34; = %d\n&#34;,
                    errMsg, sqlState,
                    nativeErr);
         break;
       case SQL_SUCCESS_WITH_INFO:
         fprintf(stderr, &#34;*** Call to SQLError&#34;
                 &#34; failed with return code of &#34;
                 &#34;SQL_SUCCESS_WITH_INFO.\n &#34;
                 &#34;*** Need to increase size of&#34;
                 &#34; message buffer.\n&#34;);
         break;
       case SQL_INVALID_HANDLE:
         fprintf(stderr, &#34;*** Call to SQLError&#34;
                 &#34; failed with return code of &#34;
                 &#34;SQL_INVALID_HANDLE.\n&#34;);
         break;
       case SQL_ERROR:
         fprintf(stderr, &#34;*** Call to SQLError&#34;
                 &#34; failed with return code of &#34;
                 &#34;SQL_ERROR.\n&#34;);
         break;
       case SQL_NO_DATA_FOUND:
         break;
        } /* switch */
      } /* while */
      if (rc != SQL_SUCCESS_WITH_INFO &amp;&amp; err_is_fatal) {
        fprintf(stderr, &#34;Exiting.\n&#34;);
        exit(-1);
      }
   }
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABIABBI"></a>
<div id="TTCDV118" class="sect2">
<h3 class="sect2">Setting connection <a id="sthref39"></a>attributes programmatically</h3>
<p>You can set or override connection attributes programmatically by specifying a connection string when you connect to a database.</p>
<p>Re<a id="sthref40"></a><a id="sthref41"></a><a id="sthref42"></a><a id="sthref43"></a><a id="sthref44"></a>fer to <a class="olink TTOPR" href="../TTOPR/toc.htm"><span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span></a> for general information about connection attributes. General connection attributes require no special privilege. First connection attributes are set when the database is first loaded, and persist for all connections. Only the instance administrator can load a database with changes to first connection attribute settings. Refer to <a class="olink TTREF114" href="../TTREF/attribute.htm#TTREF114">&#34;Connection Attributes&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for additional information, including specific information about any particular connection attribute.</p>
<div id="TTCDV119" class="example">
<p class="titleinexample"><a id="sthref45"></a>Example 2-3 Con<a id="sthref46"></a>nect and use store-level locking</p>
<p>This code fragment connects to a database named <code dir="ltr">mydsn</code> and indicates in the <code dir="ltr">SQLDriverConnect</code> call that the application should use a passthrough setting of 3. Note that <code dir="ltr">PassThrough</code> is a general connection attribute.</p>
<pre dir="ltr">SQLHDBC hdbc;
SQLCHAR ConnStrOut[512];
SQLSMALLINT cbConnStrOut;
SQLRETURN rc;

rc = SQLDriverConnect(hdbc, NULL,
    &#34;DSN=mydsn;PassThrough=3&#34;, SQL_NTS,
    ConnStrOut, sizeof (ConnStrOut),
    &amp;cbConnStrOut, SQL_DRIVER_NOPROMPT);
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Each connection to a database opens several files. An application with many threads, each with a separate connection, has several files open for each thread. Such an application can exceed the maximum allowed (or configured maximum) number of file descriptors that may be simultaneously open on the operating system. In this case, configure your system to allow a larger number of open files. See <a class="olink TTREF457" href="../TTREF/limit.htm#TTREF457">&#34;Limits on number of open files&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
</div>
<!-- class="sect2" -->
<a id="BABECBAJ"></a>
<div id="TTCDV573" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Us<a id="sthref47"></a><a id="sthref48"></a>ing a default DSN</h3>
<p>A default DSN, simply named <code dir="ltr">default</code>, can be defined in the <code dir="ltr">odbc.ini</code> or <code dir="ltr">sys.odbc.ini</code> file. See <a class="olink TTOPR759" href="../TTOPR/using.htm#TTOPR759">&#34;Setting up a default DSN&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span> for information about defining a default DSN.</p>
<p>The associated data source would be connected to in the following circumstances when <code dir="ltr">SQLConnect</code> or <code dir="ltr">SQLDriverConnect</code> is called.</p>
<p>For <code dir="ltr">SQLConnect</code>, if a default DSN has been defined, it is used if <code dir="ltr"><span class="codeinlineitalic">ServerName</span></code> specifies a data source that cannot be found, is a null pointer, or is specifically set to a value of <code dir="ltr">default</code>. For reference, here is the <code dir="ltr">SQLConnect</code> calling sequence:</p>
<pre dir="ltr">SQLRETURN SQLConnect( 
          SQLHDBC        <span class="italic">ConnectionHandle</span>, 
          SQLCHAR *      <span class="italic">ServerName</span>, 
          SQLSMALLINT    <span class="italic">NameLength1</span>, 
          SQLCHAR *      <span class="italic">UserName</span>, 
          SQLSMALLINT    <span class="italic">NameLength2</span>, 
          SQLCHAR *      <span class="italic">Authentication</span>, 
          SQLSMALLINT    <span class="italic">NameLength3</span>); 
</pre>
<p>Use <code dir="ltr">default</code> as the server name. The user name and authentication values are used as is.</p>
<p>For <code dir="ltr">SQLDriverConnect</code>, if a default DSN has been defined, it is used if the connection string does not include the <code dir="ltr">DSN</code> keyword or if the data source cannot be found. For reference, here is the <code dir="ltr">SQLDriverConnect</code> calling sequence:</p>
<pre dir="ltr">SQLRETURN SQLDriverConnect( 
          SQLHDBC         <span class="italic">ConnectionHandle</span>, 
          SQLHWND         <span class="italic">WindowHandle</span>, 
          SQLCHAR *       <span class="italic">InConnectionString</span>, 
          SQLSMALLINT     <span class="italic">StringLength1</span>, 
          SQLCHAR *       <span class="italic">OutConnectionString</span>, 
          SQLSMALLINT     <span class="italic">BufferLength</span>, 
          SQLSMALLINT *   <span class="italic">StringLength2Ptr</span>, 
          SQLUSMALLINT    <span class="italic">DriverCompletion</span>); 
</pre>
<p>Use <code dir="ltr">default</code> as the DSN keyword. The user name and password are used as is.</p>
<p>Be aware of the following usage notes when in direct mode versus client/server mode with a driver manager:</p>
<ul>
<li>
<p>When you are not using a driver manager, TimesTen manages this functionality. The default DSN must be a TimesTen database.</p>
</li>
<li>
<p>When you are using a driver manager, the driver manager manages this functionality. The default DSN need not be a TimesTen database.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABHAGHD"></a>
<div id="TTCDV120" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Ac<a id="sthref49"></a><a id="sthref50"></a>cess control for connections</h3>
<p>In order for any user (other than the instance administrator) to connect to a database, the <code dir="ltr">CREATE SESSION</code> privilege must be granted. This is a system privilege so must be granted to the user by the instance administrator or someone with <code dir="ltr">ADMIN</code> privilege, either directly or through the <code dir="ltr">PUBLIC</code> role. Refer to <a class="olink TTOPR236" href="../TTOPR/accesscontrol.htm#TTOPR236">&#34;Managing Access Control&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span> for additional information and examples.</p>
<p>To create an XLA connection and execute XLA functionality, a user must be granted the <code dir="ltr">XLA</code> privilege, discussed in <a href="xla_event.htm#CIHIDBJJ">&#34;Access control impact on XLA&#34;</a>, in addition to the <code dir="ltr">CREATE SESSION</code> privilege.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGBJCFA"></a>
<div id="TTCDV121" class="sect1">
<h2 class="sect1">Managing TimesTen data</h2>
<p>This section provides detailed information on working with data in a TimesTen database. It includes the following topics.</p>
<ul>
<li>
<p><a href="#BABHHHCF">TimesTen include files</a></p>
</li>
<li>
<p><a href="#CEGJIDHG">SQL statement execution within C applications</a></p>
</li>
<li>
<p><a href="#BABIGFCH">Preparing and executing queries and working with cursors</a></p>
</li>
<li>
<p><a href="#BABJJIGJ">TimesTen deferred prepare</a></p>
</li>
<li>
<p><a href="#CEGGBDBH">Prefetching multiple rows of data</a></p>
</li>
<li>
<p><a href="#BABDGFJI">Binding parameters and executing statements</a></p>
</li>
<li>
<p><a href="#BABGDJJJ">Working with REF CURSORs</a></p>
</li>
<li>
<p><a href="#BABHIHDG">Working with DML returning (RETURNING INTO clause)</a></p>
</li>
<li>
<p><a href="#BABJDEJG">Working with rowids</a></p>
</li>
<li>
<p><a href="#BABDBEGH">Working with LOBs</a></p>
</li>
<li>
<p><a href="#BABEFHHB">Making and committing changes to the database</a></p>
</li>
</ul>
<a id="BABHHHCF"></a>
<div id="TTCDV122" class="sect2">
<h3 class="sect2">TimesTen in<a id="sthref51"></a><a id="sthref52"></a>clude files</h3>
<p>To use TimesTen features, your application must include the TimesTen files shown in the following table, as applicable.</p>
<div class="inftblhruleinformal">
<table class="cellalignment4366" title="TimesTen #include files" summary="This table contains descriptions of TimesTen &#34;include&#34; files." dir="ltr">
<thead>
<tr class="cellalignment4360">
<th class="cellalignment4367" id="r1c1-t5">Include file</th>
<th class="cellalignment4367" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r2c1-t5" headers="r1c1-t5"><code dir="ltr">timesten.h</code></td>
<td class="cellalignment4368" headers="r2c1-t5 r1c2-t5">TimesTen ODBC features</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r3c1-t5" headers="r1c1-t5"><code dir="ltr">tt_errCode.h</code></td>
<td class="cellalignment4368" headers="r3c1-t5 r1c2-t5">TimesTen error codes
<p>This file maps TimesTen error codes to defined constants.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The standard ODBC <code dir="ltr">sql.h</code> file is included as part of <code dir="ltr">timesten.h</code>. If you are using only standard ODBC features:
<ul>
<li>
<p>On UNIX systems, it is advisable to include <code dir="ltr">timesten.h</code> in order to include the TimesTen copy of <code dir="ltr">sql.h</code>.</p>
</li>
<li>
<p>On Windows systems, it is advisable to use your system copy of <code dir="ltr">sql.h</code>.</p>
</li>
</ul>
<p>Set the include path appropriately to access any files that are to be included. See <a href="compiling.htm#CEGCFAIE">&#34;Compiling and linking applications&#34;</a> for related information.</p>
</div>
</div>
<!-- class="sect2" -->
<a id="CEGJIDHG"></a>
<div id="TTCDV123" class="sect2">
<h3 class="sect2">SQL statement execution within C applications</h3>
<p><a class="olink TTOPR327" href="../TTOPR/comp.htm#TTOPR327">&#34;Working with Data in a TimesTen Database&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span> describes how to use SQL to manage data. This section describes general formats used to execute a SQL statement within a C application. The following topics are covered:</p>
<ul>
<li>
<p><a href="#BABCBBFA">SQLExecDirect and SQLExecute functions</a></p>
</li>
<li>
<p><a href="#BABEGGCI">Executing a SQL statement</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Access control privileges are checked both when SQL is prepared and when it is executed in the database. Refer to <a href="#BABFJBFE">&#34;Considering TimesTen features for access control&#34;</a> for related information.</div>
<a id="BABCBBFA"></a>
<div id="TTCDV124" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SQL<a id="sthref53"></a><a id="sthref54"></a><a id="sthref55"></a><a id="sthref56"></a>ExecDirect and SQLExecute functions</h4>
<p>There are two ODBC functions to execute SQL statements:</p>
<ul>
<li>
<p><code dir="ltr">SQLExecute</code>: Executes a statement that has been prepared with <code dir="ltr">SQLPrepare</code>. After the application is done with the results, they can be discarded and <code dir="ltr">SQLExecute</code> can be run again using different parameter values.</p>
<p>This is typically used for DML statements with bind parameters, or statements that are being executed more than once.</p>
</li>
<li>
<p><code dir="ltr">SQLExecDirect</code>: Prepares and executes a statement.</p>
<p>This is typically used for DDL statements or for DML statements that would execute only a few times and without bind parameters.</p>
</li>
</ul>
<p>Refer to ODBC API reference documentation for details about these functions.</p>
</div>
<!-- class="sect3" -->
<a id="BABEGGCI"></a>
<div id="TTCDV125" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Exec<a id="sthref57"></a><a id="sthref58"></a>uting a SQL statement</h4>
<p>You can use the <code dir="ltr">SQLExecDirect</code> function as shown in <a href="#BABEDCJB">Example 2-4</a>.</p>
<p>The next section, <a href="#BABIGFCH">&#34;Preparing and executing queries and working with cursors&#34;</a>, shows usage of the <code dir="ltr">SQLExecute</code> and <code dir="ltr">SQLPrepare</code> functions.</p>
<div id="TTCDV126" class="example">
<p class="titleinexample"><a id="BABEDCJB"></a>Example 2-4 Executing a SQL statement with SQLExecDirect</p>
<p>This code sample creates a table, <code dir="ltr">NameID</code>, with two columns: <code dir="ltr">CustID</code> and <code dir="ltr">CustName</code>. The table maps character names to integer identifiers.</p>
<pre dir="ltr">#include &lt;sql.h&gt;
SQLRETURN rc;
SQLHSTMT hstmt;
...
rc = SQLExecDirect(hstmt, (SQLCHAR*)
     &#34;CREATE TABLE NameID (CustID INTEGER, CustName VARCHAR(50))&#34;,
     SQL_NTS);
if (rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO)
     ... /* handle error */
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABIGFCH"></a>
<div id="TTCDV127" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Preparing and executing queries and wor<a id="sthref59"></a><a id="sthref60"></a><a id="sthref61"></a><a id="sthref62"></a>king with cursors</h3>
<p>This section shows the basic steps of preparing and executing a query and working with cursors. Applications use cursors to scroll through the results of a query, examining one result row at a time.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
In TimesTen, any operation that ends your transaction, such as a commit or rollback, closes all cursors associated with the connection.</div>
<p>In the ODBC setting, a cursor is always associated with a result set. This association is made by the ODBC driver. The application can control cursor characteristics, such as the number of rows to fetch at one time, using <code dir="ltr">SQLSetStmtOption</code> options documented in <a href="odbc_supported.htm#BEIFEBEH">&#34;Option support for SQLSetStmtOption and SQLGetStmtOption&#34;</a>. The steps involved in executing a query typically include the following.</p>
<ol>
<li>
<p>Use <code dir="ltr">SQLPrepare</code> to prepare the <code dir="ltr">SELECT</code> statement for execution.</p>
</li>
<li>
<p>Use <code dir="ltr">SQLBindParameter</code>, if the statement has parameters, to bind each parameter to an application address. See <a href="#BABHBIAB">&#34;SQLBindParameter function&#34;</a>. (Note that <a href="#CEGIIHBD">Example 2-5</a> below does not bind parameters.)</p>
</li>
<li>
<p>Call <code dir="ltr">SQLBindCol</code> to assign the storage and data type for a column of results, binding column results to local variable storage in your application.</p>
</li>
<li>
<p>Call <code dir="ltr">SQLExecute</code> to execute the <code dir="ltr">SELECT</code> statement. See <a href="#BABCBBFA">&#34;SQLExecDirect and SQLExecute functions&#34;</a>.</p>
</li>
<li>
<p>Call <code dir="ltr">SQLFetch</code> to fetch the results. Specify the statement handle.</p>
</li>
<li>
<p>Call <code dir="ltr">SQLFreeStmt</code> to free the statement handle. Specify the statement handle and either <code dir="ltr">SQL_CLOSE</code>, <code dir="ltr">SQL_DROP</code>, <code dir="ltr">SQL_UNBIND</code>, or <code dir="ltr">SQL_RESET_PARAMS</code>.</p>
</li>
</ol>
<p>Refer to ODBC API reference documentation for details on these ODBC functions. Examples are shown throughout this chapter and in the TimesTen Quick Start (through the &#34;ODBC (C)&#34; link under SAMPLE PROGRAMS).</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>Access control privileges are checked both when SQL is prepared and when it is executed in the database. Refer to <a href="#BABFJBFE">&#34;Considering TimesTen features for access control&#34;</a> for related information.</p>
</li>
<li>
<p>By default (when connection attribute <code dir="ltr">PrivateCommands=0</code>), TimesTen shares prepared statements between connections, so subsequent prepares of the same statement on different connections execute very quickly.</p>
</li>
</ul>
</div>
<div id="TTCDV128" class="example">
<p class="titleinexample"><a id="CEGIIHBD"></a>Example 2-5 Executing a query and working with the cursor</p>
<p>This example illustrates how to prepare and execute a query using ODBC calls. Error checking has been omitted to simplify the example. In addition to ODBC functions mentioned previously, this example uses <code dir="ltr">SQLNumResultCols</code> to return the number of columns in the result set, <code dir="ltr">SQLDescribeCol</code> to return a description of one column of the result set (column name, type, precision, scale, and nullability), and <code dir="ltr">SQLBindCol</code> to assign the storage and data type for a column in the result set. These are all described in detail in ODBC API reference documentation.</p>
<pre dir="ltr">#include &lt;sql.h&gt;

SQLHSTMT hstmt;
SQLRETURN rc;
int i;
SQLSMALLINT numCols;
SQLCHAR colname[32];
SQLSMALLINT colnamelen, coltype, scale, nullable;
SQLULEN collen [MAXCOLS];
SQLLEN outlen [MAXCOLS];
SQLCHAR* data [MAXCOLS];

/* other declarations and program set-up here */

/* Prepare the SELECT statement */
rc = SQLPrepare(hstmt,
(SQLCHAR*) &#34;SELECT * FROM EMP WHERE AGE&gt;20&#34;,
SQL_NTS);
/* ... */

/* Determine number of columns in result rows */
rc = SQLNumResultCols(hstmt, &amp;numCols);

/* ... */

/* Describe and bind the columns */
for (i = 0; i &lt; numCols; i++) {
    rc = SQLDescribeCol(hstmt,
         (SQLSMALLINT) (i + 1),
         colname,(SQLSMALLINT)sizeof(colname), &amp;colnamelen, &amp;coltype, &amp;collen[i],
         &amp;scale, &amp;nullable);

    /* ... */

   data[i] = (SQLCHAR*) malloc (collen[i] +1);  //Allocate space for column data.
   rc = SQLBindCol(hstmt, (SQLSMALLINT) (i + 1),
                   SQL_C_CHAR, data[i],
                   COL_LEN_MAX, &amp;outlen[i]);

   /* ... */

}
/* Execute the SELECT statement */
rc = SQLExecute(hstmt);

/* ... */

/* Fe<a id="sthref63"></a>tch the rows */
if (numCols &gt; 0) {
  while ((rc = SQLFetch(hstmt)) == SQL_SUCCESS ||
          rc == SQL_SUCCESS_WITH_INFO) {
    /* ... &#34;Process&#34; the result row */
  } /* end of for-loop */
  if (rc != SQL_NO_DATA_FOUND)
    fprintf(stderr,
            &#34;Unable to fetch the next row\n&#34;);

/* Close the cursor associated with the SELECT statement */
  rc = SQLFreeStmt(hstmt, SQL_CLOSE);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABJJIGJ"></a>
<div id="TTCDV129" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">TimesTen defer<a id="sthref64"></a><a id="sthref65"></a><a id="sthref66"></a>red prepare</h3>
<p>In standard ODBC, a <code dir="ltr">SQLPrepare</code> call compiles a SQL statement so that information about the statement, such as column descriptions for the result set, is available to the application and accessible through calls such as <code dir="ltr">SQLDescribeCol</code>. To accomplish this, the <code dir="ltr">SQLPrepare</code> call must communicate with the server for processing.</p>
<p>This is in contrast, for example, to expected behavior under Oracle Call Interface (OCI), where a prepare call is expected to be a lightweight operation performed on the client to simply extract names and positions of parameters.</p>
<p>To avoid unwanted round trips between client and server, and also to make the behavior consistent with OCI expectations, the TimesTen client library implementation of <code dir="ltr">SQLPrepare</code> performs what is referred to as a &#34;deferred prepare&#34;, where the request is not sent to the server until required. Examples of when the round trip would be required:</p>
<ul>
<li>
<p>When there is a <code dir="ltr">SQLExecute</code> call. Note that if there is a deferred prepare call that has not yet been sent to the server, a <code dir="ltr">SQLExecute</code> call on the client is converted to a <code dir="ltr">SQLExecDirect</code> call.</p>
</li>
<li>
<p>When there is a request for information about the query that can only be supplied by the SQL engine, such as when there is a <code dir="ltr">SQLDescribeCol</code> call, for example. Many such calls in standard ODBC can access information previously returned by a <code dir="ltr">SQLPrepare</code> call, but with the deferred prepare functionality the <code dir="ltr">SQLPrepare</code> call is sent to the server and the information is returned to the application only as needed.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Deferred prepare functionality is not implemented (and not necessary) with the TimesTen direct driver.</div>
<p>The deferred prepare implementation requires no changes at the application or user level; however, be aware that calling any of the following functions may result in a round trip to the server if the required information from a previously prepared statement has not yet been retrieved:</p>
<ul>
<li>
<p><code dir="ltr">SQLColAttributes</code></p>
</li>
<li>
<p><code dir="ltr">SQLDescribeCol</code></p>
</li>
<li>
<p><code dir="ltr">SQLDescribeParam</code></p>
</li>
<li>
<p><code dir="ltr">SQLNumResultCols</code></p>
</li>
<li>
<p><code dir="ltr">SQLNumParams</code></p>
</li>
<li>
<p><code dir="ltr">SQLGetStmtOption</code> (for options that depend on the statement having been compiled by the SQL engine)</p>
</li>
</ul>
<p>Also be aware that when calling any of these functions, any error from an earlier <code dir="ltr">SQLPrepare</code> call may be deferred until one of these calls is executed. In addition, these calls may return errors specific to <code dir="ltr">SQLPrepare</code> as well as errors specific to themselves.</p>
</div>
<!-- class="sect2" -->
<a id="CEGGBDBH"></a>
<div id="TTCDV149" class="sect2">
<h3 class="sect2">Pref<a id="sthref67"></a><a id="sthref68"></a><a id="sthref69"></a><a id="sthref70"></a>etching multiple rows of data</h3>
<p>A TimesTen extension to ODBC enables applications to prefetch multiple rows of data into the ODBC driver buffer. This can improve performance of client/server applications.</p>
<p>The <code dir="ltr">TT_PREFETCH_COUNT</code> statement option determines how many rows a <code dir="ltr">SQLFetch</code> call prefetches. Note that this option provides no benefit for an application using a direct connection to TimesTen.</p>
<p>You can set <code dir="ltr">TT_PREFETCH_COUNT</code> in a call to either <code dir="ltr">SQLSetStmtOption</code> or <code dir="ltr">SQLSetConnectOption</code> (which sets the option default value for all statements associated with the connection). The value can be any integer from 0 to 128, inclusive. Following is an example.</p>
<pre dir="ltr">rc = SQLSetConnectOption(hdbc, TT_PREFETCH_COUNT, 100);
</pre>
<p>With this setting, the first <code dir="ltr">SQLFetch</code> call on the connection prefetches 100 rows. Subsequent <code dir="ltr">SQLFetch</code> calls fetch from the ODBC buffer instead of from the database, until the buffer is depleted. After it is depleted, the next <code dir="ltr">SQLFetch</code> call fetches another 100 rows into the buffer, and so on.</p>
<p>To disable prefetch, set <code dir="ltr">TT_PREFETCH_COUNT</code> to 1.</p>
<p>When you set the prefetch count to 0, TimesTen uses a default prefetch count according to the isolation level you have set for the database, and sets <code dir="ltr">TT_PREFETCH_COUNT</code> to that value. With Read Committed isolation level, the default prefetch value is 5. With Serializable isolation level, the default is 128. The default prefetch value is a good setting for most applications. Generally, a higher value may result in better performance for larger result sets, at the expense of slightly higher resource use.</p>
<p>Also see <a href="odbc_supported.htm#BEIFEBEH">&#34;Option support for SQLSetStmtOption and SQLGetStmtOption&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABDGFJI"></a>
<div id="TTCDV130" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Binding parameters and executing statements</h3>
<p>This section discusses how to bind input or output parameters for SQL statements. The following topics are covered.</p>
<ul>
<li>
<p><a href="#BABHBIAB">SQLBindParameter function</a></p>
</li>
<li>
<p><a href="#BABCGEJG">Determination of parameter type assignments and type conversions</a></p>
</li>
<li>
<p><a href="#BABIJEIJ">Binding input parameters</a></p>
</li>
<li>
<p><a href="#BABDIADA">Binding output parameters</a></p>
</li>
<li>
<p><a href="#BABIJIFA">Binding input/output parameters</a></p>
</li>
<li>
<p><a href="#BABFEDJH">Binding duplicate parameters in SQL statements</a></p>
</li>
<li>
<p><a href="#BABDAEAB">Binding duplicate parameters in PL/SQL</a></p>
</li>
<li>
<p><a href="#BABCEIJE">Considerations for floating point data</a></p>
</li>
<li>
<p><a href="#BABHHCBE">Using SQL_WCHAR and SQL_WVARCHAR with a driver manager</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The term &#34;bind parameter&#34; as used in TimesTen developer guides (in keeping with ODBC terminology) is equivalent to the term &#34;bind variable&#34; as used in TimesTen PL/SQL documents (in keeping with Oracle Database PL/SQL terminology).</div>
<a id="BABHBIAB"></a>
<div id="TTCDV133" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SQL<a id="sthref71"></a><a id="sthref72"></a><a id="sthref73"></a>BindParameter function</h4>
<p>The ODBC <code dir="ltr">SQLBindParameter</code> function is used to bind parameters for SQL statements. This could include input, output, or input/output parameters.</p>
<p>To bind an input parameter through ODBC, use the <code dir="ltr">SQLBindParameter</code> function with a setting of <code dir="ltr">SQL_PARAM_INPUT</code> for the <code dir="ltr"><span class="codeinlineitalic">fParamType</span></code> argument. Refer to ODBC API reference documentation for details about the <code dir="ltr">SQLBindParameter</code> function. <a href="#BABEJGII">Table 2-1</a> provides a brief summary of its arguments.</p>
<p>To bind an output or input/output parameter through ODBC, use the <code dir="ltr">SQLBindParameter</code> function with a setting of <code dir="ltr">SQL_PARAM_OUTPUT</code> or <code dir="ltr">SQL_PARAM_INPUT_OUTPUT</code>, respectively, for the <code dir="ltr"><span class="codeinlineitalic">fParamType</span></code> argument. As with input parameters, use the <code dir="ltr"><span class="codeinlineitalic">fSqlType</span></code>, <code dir="ltr"><span class="codeinlineitalic">cbColDef</span></code>, and <code dir="ltr"><span class="codeinlineitalic">ibScale</span></code> arguments (as applicable) to specify data types.</p>
<div id="TTCDV134" class="tblhruleformal">
<p class="titleintable"><a id="sthref74"></a><a id="BABEJGII"></a>Table 2-1 SQLBindParameter arguments</p>
<table class="cellalignment4366" title="SQLBindParameter arguments" summary="Summary of SQLBindParameter arguments." dir="ltr">
<thead>
<tr class="cellalignment4360">
<th class="cellalignment4367" id="r1c1-t12">Argument</th>
<th class="cellalignment4367" id="r1c2-t12">Type</th>
<th class="cellalignment4367" id="r1c3-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r2c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">hstmt</span></code></p>
</td>
<td class="cellalignment4368" headers="r2c1-t12 r1c2-t12">
<p><code dir="ltr">SQLHSTMT</code></p>
</td>
<td class="cellalignment4368" headers="r2c1-t12 r1c3-t12">
<p>Statement handle</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r3c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">ipar</span></code></p>
</td>
<td class="cellalignment4368" headers="r3c1-t12 r1c2-t12">
<p><code dir="ltr">SQLUSMALLINT</code></p>
</td>
<td class="cellalignment4368" headers="r3c1-t12 r1c3-t12">
<p>Parameter number, sequentially from left to right, starting with 1</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r4c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">fParamType</span></code></p>
</td>
<td class="cellalignment4368" headers="r4c1-t12 r1c2-t12">
<p><code dir="ltr">SQLSMALLINT</code></p>
</td>
<td class="cellalignment4368" headers="r4c1-t12 r1c3-t12">
<p>Indicating input or output: <code dir="ltr">SQL_PARAM_INPUT</code>, <code dir="ltr">SQL_PARAM_OUTPUT</code>, or <code dir="ltr">SQL_PARAM_INPUT_OUTPUT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r5c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">fCType</span></code></p>
</td>
<td class="cellalignment4368" headers="r5c1-t12 r1c2-t12">
<p><code dir="ltr">SQLSMALLINT</code></p>
</td>
<td class="cellalignment4368" headers="r5c1-t12 r1c3-t12">
<p>C data type of the parameter</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r6c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">fSqlType</span></code></p>
</td>
<td class="cellalignment4368" headers="r6c1-t12 r1c2-t12">
<p><code dir="ltr">SQLSMALLINT</code></p>
</td>
<td class="cellalignment4368" headers="r6c1-t12 r1c3-t12">
<p>SQL data type of the parameter</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r7c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">cbColDef</span></code></p>
</td>
<td class="cellalignment4368" headers="r7c1-t12 r1c2-t12">
<p><code dir="ltr">SQLULEN</code></p>
</td>
<td class="cellalignment4368" headers="r7c1-t12 r1c3-t12">
<p>T<a id="sthref75"></a><a id="sthref76"></a>he precision of the parameter, such as the maximum number of bytes for binary data, the maximum number of digits for a number, or the maximum number of characters for character data</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r8c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">ibScale</span></code></p>
</td>
<td class="cellalignment4368" headers="r8c1-t12 r1c2-t12">
<p><code dir="ltr">SQLSMALLINT</code></p>
</td>
<td class="cellalignment4368" headers="r8c1-t12 r1c3-t12">
<p>T<a id="sthref77"></a><a id="sthref78"></a>he scale of the parameter, referring to the maximum number of digits to the right of the decimal point, where applicable</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r9c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code></p>
</td>
<td class="cellalignment4368" headers="r9c1-t12 r1c2-t12">
<p><code dir="ltr">SQLPOINTER</code></p>
</td>
<td class="cellalignment4368" headers="r9c1-t12 r1c3-t12">
<p>Pointer to a buffer for the data of the parameter</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r10c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code></p>
</td>
<td class="cellalignment4368" headers="r10c1-t12 r1c2-t12">
<p><code dir="ltr">SQLLEN</code></p>
</td>
<td class="cellalignment4368" headers="r10c1-t12 r1c3-t12">
<p>Maximum length of the <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> buffer, in bytes</p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r11c1-t12" headers="r1c1-t12">
<p><code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code></p>
</td>
<td class="cellalignment4368" headers="r11c1-t12 r1c2-t12">
<p><code dir="ltr">SQLLEN*</code></p>
</td>
<td class="cellalignment4368" headers="r11c1-t12 r1c3-t12">
<p>Pointer to a buffer for the length of the parameter</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Refer to <a class="olink TTSQL123" href="../TTSQL/types.htm#TTSQL123">&#34;Data Types&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for information about precision and scale of TimesTen data types.</div>
</div>
<!-- class="sect3" -->
<a id="BABCGEJG"></a>
<div id="TTCDV505" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">De<a id="sthref79"></a><a id="sthref80"></a><a id="sthref81"></a><a id="sthref82"></a>termination of parameter type assignments and type conversions</h4>
<p>Bind parameter type assignments are determined as follows.</p>
<ul>
<li>
<p>Parameter type assignments for statements that execute in TimesTen are determined by TimesTen. Specifically:</p>
<ul>
<li>
<p>For SQL statements that execute within TimesTen, the TimesTen query optimizer determines data types of SQL parameters.</p>
</li>
</ul>
</li>
<li>
<p>Parameter type assignments for statements that execute in Oracle Database, or according to Oracle Database functionality, are determined by the application as follows.</p>
<ul>
<li>
<p>For SQL statements that execute within Oracle Database&mdash;that is, passthrough statements from the TimesTen Application-Tier Database Cache (TimesTen Cache)&mdash;the application must specify data types through its calls to the ODBC <code dir="ltr">SQLBindParameter</code> function, according to the <code dir="ltr"><span class="codeinlineitalic">fSqlType</span></code>, <code dir="ltr"><span class="codeinlineitalic">cbColDef</span></code>, and <code dir="ltr"><span class="codeinlineitalic">ibScale</span></code> arguments of that function, as applicable.</p>
</li>
<li>
<p>For PL/SQL blocks or procedures that execute within TimesTen, where the PL/SQL execution engine has the same basic functionality as in Oracle Database, the application must specify data types through its calls to <code dir="ltr">SQLBindParameter</code> (the same as for SQL statements that execute within Oracle Database).</p>
<p>So regarding host binds for PL/SQL (the variables, or parameters, that are preceded by a colon within a PL/SQL block), note that the type of a host bind is effectively declared by the call to <code dir="ltr">SQLBindParameter</code>, according to <code dir="ltr"><span class="codeinlineitalic">fSqlType</span></code> and the other arguments as applicable, and is not declared within the PL/SQL block.</p>
</li>
</ul>
</li>
</ul>
<p>The ODBC driver performs any necessary type conversions between C values and SQL or PL/SQL types. For any C-to-SQL or C-to-PL/SQL combination that is not supported, an error occurs. These conversions can be from a C type to a SQL or PL/SQL type (input parameter), from a SQL or PL/SQL type to a C type (output parameter), or both (input/output parameter).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The TimesTen binding mechanism (early binding) differs from that of Oracle Database (late binding). TimesTen requires the data types before preparing queries. As a result, there will be an error if the data type of each bind parameter is not specified or cannot be inferred from the SQL statement. This would apply, for example, to the following statement:
<pre dir="ltr">SELECT &#39;x&#39; FROM DUAL WHERE ? = ?;
</pre>
<p>You could address the issue as follows, for example:</p>
<pre dir="ltr">SELECT &#39;x&#39; from DUAL WHERE CAST(? as VARCHAR2(10)) = 
                           CAST(? as VARCHAR2(10)); 
</pre></div>
<p><a href="#BABJJDGE">Table 2-2</a> documents the mapping between ODBC types and SQL or PL/SQL types.</p>
<div id="TTCDV132" class="tblhruleformal">
<p class="titleintable"><a id="sthref83"></a><a id="BABJJDGE"></a>Table 2-2 ODBC SQL to TimesTen SQL or PL/SQL type mappings</p>
<table class="cellalignment4366" title="ODBC SQL to TimesTen SQL or PL/SQL type mappings" summary="Type mappings from ODBC SQL to PL/SQL." dir="ltr">
<thead>
<tr class="cellalignment4360">
<th class="cellalignment4367" id="r1c1-t15">ODBC type (<span class="italic">fSqlType</span>)</th>
<th class="cellalignment4367" id="r1c2-t15">SQL or PL/SQL type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r2c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_BIGINT</code></p>
</td>
<td class="cellalignment4368" headers="r2c1-t15 r1c2-t15">
<p><code dir="ltr">NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r3c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_BINARY</code></p>
</td>
<td class="cellalignment4368" headers="r3c1-t15 r1c2-t15">
<p><code dir="ltr">RAW(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r4c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_BIT</code></p>
</td>
<td class="cellalignment4368" headers="r4c1-t15 r1c2-t15">
<p><code dir="ltr">PLS_INTEGER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r5c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_CHAR</code></p>
</td>
<td class="cellalignment4368" headers="r5c1-t15 r1c2-t15">
<p><code dir="ltr">CHAR(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r6c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_DATE</code></p>
</td>
<td class="cellalignment4368" headers="r6c1-t15 r1c2-t15">
<p><code dir="ltr">DATE</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r7c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_DECIMAL</code></p>
</td>
<td class="cellalignment4368" headers="r7c1-t15 r1c2-t15">
<p><code dir="ltr">NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r8c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_DOUBLE</code></p>
</td>
<td class="cellalignment4368" headers="r8c1-t15 r1c2-t15">
<p><code dir="ltr">NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r9c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_FLOAT</code></p>
</td>
<td class="cellalignment4368" headers="r9c1-t15 r1c2-t15">
<p><code dir="ltr">BINARY_DOUBLE</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r10c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_INTEGER</code></p>
</td>
<td class="cellalignment4368" headers="r10c1-t15 r1c2-t15">
<p><code dir="ltr">PLS_INTEGER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r11c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_NUMERIC</code></p>
</td>
<td class="cellalignment4368" headers="r11c1-t15 r1c2-t15">
<p><code dir="ltr">NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r12c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_REAL</code></p>
</td>
<td class="cellalignment4368" headers="r12c1-t15 r1c2-t15">
<p><code dir="ltr">BINARY_FLOAT</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r13c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_REFCURSOR</code></p>
</td>
<td class="cellalignment4368" headers="r13c1-t15 r1c2-t15">
<p><code dir="ltr">REF CURSOR</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r14c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_ROWID</code></p>
</td>
<td class="cellalignment4368" headers="r14c1-t15 r1c2-t15">
<p><code dir="ltr">ROWID</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r15c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_SMALLINT</code></p>
</td>
<td class="cellalignment4368" headers="r15c1-t15 r1c2-t15">
<p><code dir="ltr">PLS_INTEGER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r16c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_TIMESTAMP</code></p>
</td>
<td class="cellalignment4368" headers="r16c1-t15 r1c2-t15">
<p><code dir="ltr">TIMESTAMP(</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">)</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r17c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_TINYINT</code></p>
</td>
<td class="cellalignment4368" headers="r17c1-t15 r1c2-t15">
<p><code dir="ltr">PLS_INTEGER</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r18c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_VARBINARY</code></p>
</td>
<td class="cellalignment4368" headers="r18c1-t15 r1c2-t15">
<p><code dir="ltr">RAW(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r19c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_VARCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r19c1-t15 r1c2-t15">
<p><code dir="ltr">VARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r20c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_WCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r20c1-t15 r1c2-t15">
<p><code dir="ltr">NCHAR(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code></p>
</td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r21c1-t15" headers="r1c1-t15">
<p><code dir="ltr">SQL_WVARCHAR</code></p>
</td>
<td class="cellalignment4368" headers="r21c1-t15 r1c2-t15">
<p><code dir="ltr">NVARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>The notation (<code dir="ltr"><span class="codeinlineitalic">p</span></code>) indicates precision is according to the <code dir="ltr">SQLBindParameter</code> argument <code dir="ltr"><span class="codeinlineitalic">cbColDef</span></code>.</p>
</li>
<li>
<p>The notation (<code dir="ltr"><span class="codeinlineitalic">s</span></code>) indicates scale is according to the <code dir="ltr">SQLBindParameter</code> argument <code dir="ltr"><span class="codeinlineitalic">ibScale</span></code>.</p>
</li>
<li>
<p>Most applications should use <code dir="ltr">SQL_VARCHAR</code> rather than <code dir="ltr">SQL_CHAR</code> for binding character data. Use of <code dir="ltr">SQL_CHAR</code> may result in unwanted space padding to the full precision of the parameter type.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABIJEIJ"></a>
<div id="TTCDV137" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Bind<a id="sthref84"></a><a id="sthref85"></a><a id="sthref86"></a>ing input parameters</h4>
<p>For input parameters to PL/SQL in TimesTen, use the <code dir="ltr"><span class="codeinlineitalic">fSqlType</span></code>, <code dir="ltr"><span class="codeinlineitalic">cbColDef</span></code>, and <code dir="ltr"><span class="codeinlineitalic">ibScale</span></code> arguments (as applicable) of the ODBC <code dir="ltr">SQLBindParameter</code> function to specify data types. This is in contrast to how SQL input parameters are supported, as noted in <a href="#BABCGEJG">&#34;Determination of parameter type assignments and type conversions&#34;</a>.</p>
<p>In addition, the <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code>, <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code>, and <code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code> arguments of <code dir="ltr">SQLBindParameter</code> are used as follows for input parameters:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code>: Before statement execution, points to the buffer where the application places the parameter value to be passed to the application.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code>: For character and binary data, indicates the maximum length of the incoming value that <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> points to, in bytes. For all other data types, <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code> is ignored, and the length of the value that <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> points to is determined by the length of the C data type specified in the <code dir="ltr"><span class="codeinlineitalic">fCType</span></code> argument of <code dir="ltr">SQLBindParameter</code>.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code>: Points to a buffer that contains one of the following before statement execution:</p>
<ul>
<li>
<p>The actual length of the value that <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> points to</p>
<p><span class="bold">Note:</span> For input parameters, this would be valid only for character or binary data.</p>
</li>
<li>
<p><code dir="ltr">SQL_NTS</code> for a null-terminated string</p>
</li>
<li>
<p><code dir="ltr">SQL_NULL_DATA</code> for a null value</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABDIADA"></a>
<div id="TTCDV138" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Bind<a id="sthref87"></a><a id="sthref88"></a><a id="sthref89"></a>ing output parameters</h4>
<p>For output parameters from PL/SQL in TimesTen, as noted for input parameters previously, use the <code dir="ltr"><span class="codeinlineitalic">fSqlType</span></code>, <code dir="ltr"><span class="codeinlineitalic">cbColDef</span></code>, and <code dir="ltr"><span class="codeinlineitalic">ibScale</span></code> arguments (as applicable) of the ODBC <code dir="ltr">SQLBindParameter</code> function to specify data types.</p>
<p>In addition, the <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code>, <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code>, and <code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code> arguments of <code dir="ltr">SQLBindParameter</code> are used as follows for output parameters:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code>: During statement execution, points to the buffer where the value returned from the statement should be placed.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code>: For character and binary data, indicates the maximum length of the outgoing value that <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> points to, in bytes. For all other data types, <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code> is ignored, and the length of the value that <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> points to is determined by the length of the C data type specified in the <code dir="ltr"><span class="codeinlineitalic">fCType</span></code> argument of <code dir="ltr">SQLBindParameter</code>.</p>
<p>Note that ODBC null-terminates all character data, even if the data is truncated. Therefore, when an output parameter has character data, <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code> must be large enough to accept the maximum data value plus a null terminator (one additional byte for <code dir="ltr">CHAR</code> and <code dir="ltr">VARCHAR</code> parameters, or two additional bytes for <code dir="ltr">NCHAR</code> and <code dir="ltr">NVARCHAR</code> parameters).</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code>: Points to a buffer that contains one of the following after statement execution:</p>
<ul>
<li>
<p>The actual length of the value that <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> points to (for all C types, not just character and binary data)</p>
<p><span class="bold">Note:</span> This is the length of the full parameter value, regardless of whether the value can fit in the buffer that <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> points to.</p>
</li>
<li>
<p><code dir="ltr">SQL_NULL_DATA</code> for a null value</p>
</li>
</ul>
</li>
</ul>
<div id="TTCDV139" class="example">
<p class="titleinexample"><a id="sthref90"></a>Example 2-6 Binding output parameters</p>
<p>This example shows how to prepare, bind, and execute a PL/SQL anonymous block. The anonymous block assigns bind parameter <code dir="ltr">a</code> the value &#39;<code dir="ltr">abcde</code>&#39; and bind parameter <code dir="ltr">b</code> the value <code dir="ltr">123</code>.</p>
<p><code dir="ltr">SQLPrepare</code> prepares the anonymous block. <code dir="ltr">SQLBindParameter</code> binds the first parameter (<code dir="ltr">a</code>) as an output parameter of type <code dir="ltr">SQL_VARCHAR</code> and binds the second parameter (<code dir="ltr">b</code>) as an output parameter of type <code dir="ltr">SQL_INTEGER</code>. <code dir="ltr">SQLExecute</code> executes the anonymous block.</p>
<pre dir="ltr">{
  SQLHSTMT      hstmt;
  char          aval[11];
  SQLLEN        aval_len;
  SQLINTEGER    bval;
  SQLLEN        bval_len;
 
  SQLAllocStmt(hdbc, &amp;hstmt);
 
  SQLPrepare(hstmt,
        (SQLCHAR*)&#34;begin :a := &#39;abcde&#39;; :b := 123; end;&#34;,
        SQL_NTS);
 
  SQLBindParameter(hstmt, 1, SQL_PARAM_OUTPUT, SQL_C_CHAR, SQL_VARCHAR,
         10, 0, (SQLPOINTER)aval, sizeof(aval), &amp;aval_len);
 
  SQLBindParameter(hstmt, 2, SQL_PARAM_OUTPUT, SQL_C_SLONG, SQL_INTEGER,
         0, 0, (SQLPOINTER)&amp;bval, sizeof(bval), &amp;bval_len);
 
  SQLExecute(hstmt);
  printf(&#34;aval = [%s] (length = %d), bval = %d\n&#34;, aval, (int)aval_len, bval);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABIJIFA"></a>
<div id="TTCDV140" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Bind<a id="sthref91"></a><a id="sthref92"></a><a id="sthref93"></a>ing input/output parameters</h4>
<p>For input/output parameters to and from PL/SQL in TimesTen, as noted for input parameters previously, use the <code dir="ltr"><span class="codeinlineitalic">fSqlType</span></code>, <code dir="ltr"><span class="codeinlineitalic">cbColDef</span></code>, and <code dir="ltr"><span class="codeinlineitalic">ibScale</span></code> arguments (as applicable) of the ODBC <code dir="ltr">SQLBindParameter</code> function to specify data types.</p>
<p>In addition, the <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code>, <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code>, and <code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code> arguments of <code dir="ltr">SQLBindParameter</code> are used as follows for input/output parameters:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code>: This is first used before statement execution as described in <a href="#BABIJEIJ">&#34;Binding input parameters&#34;</a>. Then it is used during statement execution as described in the preceding section, <a href="#BABDIADA">&#34;Binding output parameters&#34;</a>. Note that for an input/output parameter, the outgoing value from a statement execution is the incoming value to the statement execution that immediately follows, unless that is overridden by the application. Also, for input/output values bound when you are using data-at-execution, the value of <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> serves as both the token that would be returned by the ODBC <code dir="ltr">SQLParamData</code> function and as the pointer to the buffer where the outgoing value is placed.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code>: For character and binary data, this is first used as described in <a href="#BABIJEIJ">&#34;Binding input parameters&#34;</a>. Then it is used as described in the preceding section, <a href="#BABDIADA">&#34;Binding output parameters&#34;</a>. For all other data types, <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code> is ignored, and the length of the value that <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> points to is determined by the length of the C data type specified in the <code dir="ltr"><span class="codeinlineitalic">fCType</span></code> argument of <code dir="ltr">SQLBindParameter</code>.</p>
<p>Note that ODBC null-terminates all character data, even if the data is truncated. Therefore, when an input/output parameter has character data, <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code> must be large enough to accept the maximum data value plus a null terminator (one additional byte for <code dir="ltr">CHAR</code> and <code dir="ltr">VARCHAR</code> parameters, or two additional bytes for <code dir="ltr">NCHAR</code> and <code dir="ltr">NVARCHAR</code> parameters).</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code>: This is first used before statement execution as described in <a href="#BABIJEIJ">&#34;Binding input parameters&#34;</a>. Then it is used after statement execution as described in the preceding section, <a href="#BABDIADA">&#34;Binding output parameters&#34;</a>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Important:</p>
For character and binary data, carefully consider the value you use for <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code>. A value that is smaller than the actual buffer size may result in spurious truncation warnings. A value that is greater than the actual buffer size may cause the ODBC driver to overwrite the <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code> buffer, resulting in memory corruption.</div>
</div>
<!-- class="sect3" -->
<a id="BABFEDJH"></a>
<div id="TTCDV141" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Bin<a id="sthref94"></a><a id="sthref95"></a><a id="sthref96"></a>ding duplicate parameters in SQL statements</h4>
<p>TimesTen supports two distinct modes for binding duplicate parameters in a SQL statement. (Regarding PL/SQL statements, see <a href="#BABDAEAB">&#34;Binding duplicate parameters in PL/SQL&#34;</a>.)</p>
<ul>
<li>
<p>Oracle mode, where multiple occurrences of the same parameter name are considered to be distinct parameters</p>
</li>
<li>
<p>Traditional TimesTen mode, as in earlier releases, where multiple occurrences of the same parameter name are considered to be the same parameter</p>
</li>
</ul>
<p>Yo<a id="sthref97"></a>u can choose the desired mode through the <code dir="ltr">DuplicateBindMode</code> TimesTen general connection attribute. <code dir="ltr">DuplicateBindMode=0</code> (the default) is for the Oracle mode, and <code dir="ltr">DuplicateBindMode=1</code> is for the TimesTen mode. Because this is a general connection attribute, different connections to the same database can use different values. Refer to <a class="olink TTREF161" href="../TTREF/attribute.htm#TTREF161">&#34;DuplicateBindMode&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for additional information about this attribute.</p>
<p>The rest of this section provides details for each mode, considering the following query:</p>
<pre dir="ltr">SELECT * FROM employees
  WHERE employee_id &lt; :a AND manager_id &gt; :a AND salary &lt; :b;
</pre>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>This discussion applies only to SQL statements issued directly from ODBC (not through PL/SQL, for example).</p>
</li>
<li>
<p>The use of &#34;<code dir="ltr">?</code>&#34; for parameters, not supported in Oracle Database, is supported by TimesTen in either mode.</p>
</li>
</ul>
</div>
<div id="TTCDV142" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref98"></a>
<h5 class="sect4">Oracle mode for duplicate parameters</h5>
<p>In Oracle mode, where <code dir="ltr">DuplicateBindMode=0</code>, multiple occurrences of the same parameter name in a SQL statement are considered to be different parameters. When parameter position numbers are assigned, a number is given to each parameter occurrence without regard to name duplication. The application must, at a minimum, bind a value for the first occurrence of each parameter name. For any subsequent occurrence of a given parameter name, the application has the following choices.</p>
<ul>
<li>
<p>It can bind a different value for the occurrence.</p>
</li>
<li>
<p>It can leave the parameter occurrence unbound, in which case it takes the same value as the first occurrence.</p>
</li>
</ul>
<p>In either case, each occurrence still has a distinct parameter position number.</p>
<p>To use a different value for the second occurrence of <code dir="ltr">a</code> in the SQL statement above:</p>
<pre dir="ltr">SQLBindParameter(..., 1, ...); /* first occurrence of :a */
SQLBindParameter(..., 2, ...); /* second occurrence of :a */
SQLBindParameter(..., 3, ...); /* occurrence of :b */
</pre>
<p>To use the same value for both occurrences of <code dir="ltr">a</code>:</p>
<pre dir="ltr">SQLBindParameter(..., 1, ...); /* both occurrences of :a */
SQLBindParameter(..., 3, ...); /* occurrence of :b */
</pre>
<p>Parameter <code dir="ltr">b</code> is considered to be in position 3 regardless.</p>
<p>In Oracle mode, the <code dir="ltr">SQLNumParams</code> ODBC function returns 3 for the number of parameters in the example.</p>
</div>
<!-- class="sect4" -->
<div id="TTCDV143" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref99"></a>
<h5 class="sect4">TimesTen mode for duplicate parameters</h5>
<p>In TimesTen mode, where <code dir="ltr">DuplicateBindMode=1</code>, SQL statements containing duplicate parameters are parsed such that only distinct parameter names are considered as separate parameters.</p>
<p>Binding is based on the position of the first occurrence of a parameter name. Subsequent occurrences of the parameter name are not given their own position numbers. All occurrences of the same parameter name take on the same value.</p>
<p>For the SQL statement above, the two occurrences of <code dir="ltr">a</code> are considered to be a single parameter, so cannot be bound separately:</p>
<pre dir="ltr">SQLBindParameter(..., 1, ...); /* both occurrences of :a */
SQLBindParameter(..., 2, ...); /* occurrence of :b */
</pre>
<p>Note that in TimesTen mode, parameter <code dir="ltr">b</code> is considered to be in position 2, not position 3.</p>
<p>In TimesTen mode, the <code dir="ltr">SQLNumParams</code> ODBC function returns 2 for the number of parameters in the example.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABDAEAB"></a>
<div id="TTCDV144" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Bin<a id="sthref100"></a><a id="sthref101"></a>ding duplicate parameters in PL/SQL</h4>
<p>The preceding discussion does not apply to PL/SQL, which has its own semantics. In PL/SQL, you bind a value for each unique parameter name. An application executing the following block, for example, would bind only one parameter, corresponding to <code dir="ltr">:a</code>.</p>
<pre dir="ltr">DECLARE
   x NUMBER;
   y NUMBER;
BEGIN
   x:=:a;
   y:=:a;
END;
</pre>
<p>An application executing the following block would also bind only one parameter:</p>
<pre dir="ltr">BEGIN
   INSERT INTO tab1 VALUES(:a, :a);
END
</pre>
<p>And the same for the following <code dir="ltr">CALL</code> statement:</p>
<pre dir="ltr">...CALL proc(:a, :a)...
</pre>
<p>An application executing the following block would bind two parameters, with <code dir="ltr">:a</code> as the first parameter and <code dir="ltr">:b</code> as the second parameter. The second parameter in each <code dir="ltr">INSERT</code> statement would take the same value as the first parameter in the first <code dir="ltr">INSERT</code> statement:</p>
<pre dir="ltr">BEGIN
   INSERT INTO tab1 VALUES(:a, :a);
   INSERT INTO tab1 VALUES(:b, :a);
END
</pre></div>
<!-- class="sect3" -->
<a id="BABCEIJE"></a>
<div id="TTCDV145" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Considerations for flo<a id="sthref102"></a><a id="sthref103"></a><a id="sthref104"></a>ating point data</h4>
<p>The <code dir="ltr">BINARY_DOUBLE</code> and <code dir="ltr">BINARY_FLOAT</code> data types store and retrieve the IEEE floating point values <code dir="ltr">Inf</code>, <code dir="ltr">-Inf</code>, and <code dir="ltr">NaN</code>. If an application uses a C language facility such as <code dir="ltr">printf</code>, <code dir="ltr">scanf</code>, or <code dir="ltr">strtod</code> that requires conversion to character data, the floating point values are returned as &#34;INF&#34;, &#34;-INF&#34;, and &#34;NAN&#34;. These character strings cannot be converted back to floating point values.</p>
</div>
<!-- class="sect3" -->
<a id="BABHHCBE"></a>
<div id="TTCDV506" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using S<a id="sthref105"></a><a id="sthref106"></a><a id="sthref107"></a><a id="sthref108"></a>QL_WCHAR and SQL_WVARCHAR with a driver manager</h4>
<p>Applications using the Windows driver manager may encounter errors from <code dir="ltr">SQLBindParameter</code> with SQL state <code dir="ltr">S1004</code> (SQL data type out of range) when passing an <code dir="ltr"><span class="codeinlineitalic">fSqlType</span></code> value of <code dir="ltr">SQL_WCHAR</code> or <code dir="ltr">SQL_WVARCHAR</code>. This problem can be avoided by passing one of the following values for <code dir="ltr"><span class="codeinlineitalic">fSqlType</span></code> instead.</p>
<ul>
<li>
<p><code dir="ltr">SQL_WCHAR_DM_SQLBINDPARAMETER_BYPASS</code> instead of <code dir="ltr">SQL_WCHAR</code></p>
</li>
<li>
<p><code dir="ltr">SQL_WVARCHAR_DM_SQLBINDPARAMETER_BYPASS</code> instead of <code dir="ltr">SQL_WVARCHAR</code></p>
</li>
</ul>
<p>These type codes are semantically identical to <code dir="ltr">SQL_WCHAR</code> and <code dir="ltr">SQL_WVARCHAR</code> but avoid the error from the Windows driver manager. They can be used in applications that link with the driver manager or link directly with the TimesTen ODBC direct driver or ODBC client driver.</p>
<p>See <a href="#BABHBIAB">&#34;SQLBindParameter function&#34;</a> for information about that ODBC function.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGDJJJ"></a>
<div id="TTCDV146" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Wor<a id="sthref109"></a><a id="sthref110"></a>king with REF CURSORs</h3>
<p><span class="italic">REF CURSOR</span> is a PL/SQL concept, a handle to a cursor over a SQL result set that can be passed between PL/SQL and an application. In TimesTen, the cursor can be opened in PL/SQL then the REF CURSOR can be passed to the application. The results can be processed in the application using ODBC calls. This is an <code dir="ltr">OUT</code> REF CURSOR (an <code dir="ltr">OUT</code> parameter with respect to PL/SQL). The REF CURSOR is attached to a statement handle, enabling applications to describe and fetch result sets using the same APIs as for any result set.</p>
<p>Take the following steps to use a REF CURSOR. Assume a PL/SQL statement that returns a cursor through a REF CURSOR <code dir="ltr">OUT</code> parameter. Note that REF CURSORs use the same basic steps of prepare, bind, execute, and fetch as in the cursor example in <a href="#BABIGFCH">&#34;Preparing and executing queries and working with cursors&#34;</a>.</p>
<ol>
<li>
<p>Prepare the PL/SQL statement, using <code dir="ltr">SQLPrepare</code>, to be associated with the first statement handle.</p>
</li>
<li>
<p>Bind each parameter of the statement, using <code dir="ltr">SQLBindParameter</code>. When binding the REF CURSOR output parameter, use an allocated second statement handle as <code dir="ltr"><span class="codeinlineitalic">rgbValue</span></code>, the pointer to the data buffer.</p>
<p>The <code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code>, <code dir="ltr"><span class="codeinlineitalic">ibScale</span></code>, <code dir="ltr"><span class="codeinlineitalic">cbValueMax</span></code>, and <code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code> arguments are ignored for REF CURSORs.</p>
<p>See <a href="#BABHBIAB">&#34;SQLBindParameter function&#34;</a> and <a href="#BABDIADA">&#34;Binding output parameters&#34;</a> for information about these and other <code dir="ltr">SQLBindParameter</code> arguments.</p>
</li>
<li>
<p>Call <code dir="ltr">SQLBindCol</code> to bind result columns to local variable storage.</p>
</li>
<li>
<p>Call <code dir="ltr">SQLExecute</code> to execute the statement.</p>
</li>
<li>
<p>Call <code dir="ltr">SQLFetch</code> to fetch the results. After a REF CURSOR is passed from PL/SQL to an application, the application can describe and fetch the results as it would for any result set.</p>
</li>
<li>
<p>Use <code dir="ltr">SQLFreeStmt</code> to free the statement handle.</p>
</li>
</ol>
<p>These steps are demonstrated in the example that follows. Refer to ODBC API reference documentation for details on these functions. See <a class="olink TTPLS176" href="../TTPLS/dtypesfunc.htm#TTPLS176">&#34;PL/SQL REF CURSORs&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database PL/SQL Developer&#39;s Guide</span> for additional information about REF CURSORs.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
For passing REF CURSORs between PL/SQL and an application, TimesTen supports only <code dir="ltr">OUT</code> REF CURSORs, from PL/SQL to the application, and supports a statement returning only a single REF CURSOR.</div>
<div id="TTCDV147" class="example">
<p class="titleinexample"><a id="sthref111"></a>Example 2-7 Executing a query and working with a REF CURSOR</p>
<p>This example, using a REF CURSOR in a loop, demonstrates the basic steps of preparing a query, binding parameters, executing the query, binding results to local variable storage, and fetching the results. Error handling is omitted for simplicity. In addition to the ODBC functions summarized earlier, this example uses <code dir="ltr">SQLAllocStmt</code> to allocate memory for a statement handle.</p>
<pre dir="ltr">refcursor_example(SQLHDBC hdbc)
{
  SQLCHAR*      stmt_text;
  SQLHSTMT      plsql_hstmt;
  SQLHSTMT      refcursor_hstmt;
  SQLINTEGER    deptid;
  SQLINTEGER    depts[3] = {10,30,40};
  SQLINTEGER    empid;
  SQLCHAR       lastname[30];
  SQLINTEGER    i;
 
  /* allocate 2 statement handles: one for the plsql statement and
   * one for the ref cursor */
  SQLAllocStmt(hdbc, &amp;plsql_hstmt);
  SQLAllocStmt(hdbc, &amp;refcursor_hstmt);
 
  /* prepare the plsql statement */
  stmt_text = (SQLCHAR*)
    &#34;begin &#34;
      &#34;open :refc for &#34;
        &#34;select employee_id, last_name &#34;
        &#34;from employees &#34;
        &#34;where department_id = :dept; &#34;
    &#34;end;&#34;;
  SQLPrepare(plsql_hstmt, stmt_text, SQL_NTS);
 
  /* bind parameter 1 (:refc) to refcursor_hstmt */
  SQLBindParameter(plsql_hstmt, 1, SQL_PARAM_OUTPUT, SQL_C_REFCURSOR,
                   SQL_REFCURSOR, 0, 0, refcursor_hstmt, 0, 0);
 
  /* bind parameter 2 (:deptid) to local variable deptid */
  SQLBindParameter(plsql_hstmt, 2, SQL_PARAM_INPUT, SQL_C_SLONG,
                   SQL_INTEGER, 0, 0, &amp;deptid, 0, 0);
 
  /* loop through values for :deptid */
  for (i=0; i&lt;3; i++)
  {
     deptid = depts[i];
 
     /* execute the plsql statement */
     SQLExecute(plsql_hstmt);
     /*
      * The result set is now attached to refcursor_hstmt.
      * Bind the result columns and fetch the result set.
      */
 
     /* bind result column 1 to local variable empid */
     SQLBindCol(refcursor_hstmt, 1, SQL_C_SLONG,
                (SQLPOINTER)&amp;empid, 0, 0);
 
     /* bind result column 2 to local variable lastname */
     SQLBindCol(refcursor_hstmt, 2, SQL_C_CHAR,
                (SQLPOINTER)lastname, sizeof(lastname), 0);
 
     /* fetch the result set */
     while(SQLFetch(refcursor_hstmt) != SQL_NO_DATA_FOUND){
       printf(&#34;%d, %s\n&#34;, empid, lastname);
     }
 
     /* close the ref cursor statement handle */
     SQLFreeStmt(refcursor_hstmt, SQL_CLOSE);
  }
   
  /* drop both handles */
  SQLFreeStmt(plsql_hstmt, SQL_DROP);
  SQLFreeStmt(refcursor_hstmt, SQL_DROP);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABHIHDG"></a>
<div id="TTCDV152" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Working with D<a id="sthref112"></a><a id="sthref113"></a>ML returning (RETURNING INTO clause)</h3>
<p>You can use a <code dir="ltr">RETURNING INTO</code> clause, referred to as <span class="italic">DML returning</span>, with an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statement to return specified items from a row that was affected by the action. This eliminates the need for a subsequent <code dir="ltr">SELECT</code> statement and separate round trip in case, for example, you want to confirm what was affected by the action.</p>
<p>With ODBC, DML returning is limited to returning items from a single-row operation. The clause returns the items into a list of output parameters. Bind the output parameters as discussed in <a href="#BABDGFJI">&#34;Binding parameters and executing statements&#34;</a>.</p>
<p>SQL syntax and restrictions for the <code dir="ltr">RETURNING INTO</code> clause in TimesTen are documented as part of <a class="olink TTSQL321" href="../TTSQL/state.htm#TTSQL321">&#34;INSERT&#34;</a>, <a class="olink TTSQL336" href="../TTSQL/state.htm#TTSQL336">&#34;UPDATE&#34;</a>, and <a class="olink TTSQL306" href="../TTSQL/state.htm#TTSQL306">&#34;DELETE&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>Refer to <a class="olink LNPLS01354" href="../LNPLS/returninginto_clause.htm#LNPLS01354">&#34;RETURNING INTO Clause&#34;</a> in <span class="italic">Oracle Database PL/SQL Language Reference</span> for details about DML returning.</p>
<div id="TTCDV153" class="example">
<p class="titleinexample"><a id="sthref114"></a>Example 2-8 DML returning</p>
<p>This example is adapted from <a href="#BABFBBHE">Example 2-10</a>, with bold text highlighting key portions.</p>
<pre dir="ltr">void
update_example(SQLHDBC hdbc)
{
   SQLCHAR*      stmt_text;
   SQLHSTMT      hstmt;
   SQLINTEGER    raise_pct;
   char          hiredate_str[30];
   char          last_name[30];
   SQLLEN        hiredate_len;
   SQLLEN        numrows;

   /* allocate a statement handle */
   SQLAllocStmt(hdbc, &amp;hstmt);

   /* prepare an update statement to give a raise to one employee hired
      before a given date and return that employee&#39;s last name */
   stmt_text = (SQLCHAR*)
     &#34;update employees &#34;
     &#34;set salary = salary * ((100 + :raise_pct) / 100.0) &#34;
     &#34;where hire_date &lt; :hiredate <span class="bold">and rownum = 1 returning last_name into</span> &#34;
                       &#34;<span class="bold">:last_name</span>&#34;;
   SQLPrepare(hstmt, stmt_text, SQL_NTS);

   /* bind parameter 1 (:raise_pct) to variable raise_pct */
   SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SLONG,
                    SQL_DECIMAL, 0, 0, (SQLPOINTER)&amp;raise_pct, 0, 0);

   /* bind parameter 2 (:hiredate) to variable hiredate_str */
   SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_CHAR,
                    SQL_TIMESTAMP, 0, 0, (SQLPOINTER)hiredate_str,
                    sizeof(hiredate_str), &amp;hiredate_len);
   <span class="bold">/* bind parameter 3 (:last_name) to variable last_name */</span>
   <span class="bold">SQLBindParameter(hstmt, 3, SQL_PARAM_OUTPUT, SQL_C_CHAR,</span>
                    <span class="bold">SQL_VARCHAR, 30, 0, (SQLPOINTER)last_name,</span>
                    <span class="bold">sizeof(last_name), NULL);</span>
   /* set parameter values to give a 10% raise to an employee hired before
    * January 1, 1996. */
   raise_pct = 10;
   strcpy(hiredate_str, &#34;1996-01-01&#34;);
   hiredate_len = SQL_NTS;

   /* execute the update statement */
   SQLExecute(hstmt);

   <span class="bold">/* tell us who the lucky person is */</span>
   <span class="bold">printf(&#34;Gave raise to %s.\n&#34;, last_name );</span>

   /* drop the statement handle */
   SQLFreeStmt(hstmt, SQL_DROP);

   /* commit the changes */
   SQLTransact(henv, hdbc, SQL_COMMIT);

}
</pre>
<p>This returns &#34;King&#34; as the recipient of the raise.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABJDEJG"></a>
<div id="TTCDV148" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Wor<a id="sthref115"></a>king with rowids</h3>
<p>Each row in a database table has a unique identifier known as its <span class="italic">rowid</span>. An application can retrieve the rowid of a row from the <code dir="ltr">ROWID</code> pseudocolumn. Rowids can be represented in either binary or character format.</p>
<p>An application can specify literal rowid values in SQL statements, such as in <code dir="ltr">WHERE</code> clauses, as <code dir="ltr">CHAR</code> constants enclosed in single quotes.</p>
<p>As noted in <a href="#BABJJDGE">Table 2-2</a>, the ODBC SQL type <code dir="ltr">SQL_ROWID</code> corresponds to the SQL type <code dir="ltr">ROWID</code>.</p>
<p>For parameters and result set columns, rowids are convertible to and from the C types <code dir="ltr">SQL_C_BINARY</code>, <code dir="ltr">SQL_C_WCHAR</code>, and <code dir="ltr">SQL_C_CHAR</code>. <code dir="ltr">SQL_C_CHAR</code> is the default C type for rowids. The size of a rowid would be 12 bytes as <code dir="ltr">SQL_C_BINARY</code>, 18 bytes as <code dir="ltr">SQL_C_CHAR</code>, and 36 bytes as <code dir="ltr">SQL_C_WCHAR</code>.</p>
<p>Refer to <a class="olink TTSQL150" href="../TTSQL/types.htm#TTSQL150">&#34;ROWID data type&#34;</a> and <a class="olink TTSQL195" href="../TTSQL/express.htm#TTSQL195">&#34;ROWID&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for additional information about rowids and the <code dir="ltr">ROWID</code> data type, including usage and life.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
TimesTen does not support the PL/SQL type <code dir="ltr">UROWID</code>.</div>
</div>
<!-- class="sect2" -->
<a id="BABDBEGH"></a>
<div id="TTCDV512" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Wor<a id="sthref116"></a><a id="sthref117"></a>king with LOBs</h3>
<p>TimesTen supports LOBs (large objects). This includes CLOBs (character LOBs), NCLOBs (national character LOBs), and BLOBs (binary LOBs).</p>
<p>This section provides a brief overview of LOBs and discusses their use in ODBC, covering the following topics:</p>
<ul>
<li>
<p><a href="#BABCAFEH">About LOBs</a></p>
</li>
<li>
<p><a href="#BABDGHFJ">Differences between TimesTen LOBs and Oracle Database LOBs</a></p>
</li>
<li>
<p><a href="#BABIFJFD">LOB programming interfaces</a></p>
</li>
<li>
<p><a href="#BABFGJHE">Using the LOB simple data interface in ODBC</a></p>
</li>
<li>
<p><a href="#BABJBHAA">Using the LOB piecewise data interface in ODBC</a></p>
</li>
<li>
<p><a href="#BABGFCJJ">Passthrough LOBs in ODBC</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
TimesTen does not support CLOBs if the database character set is <code dir="ltr">TIMESTEN8</code>.</div>
<p>You can also refer to the following:</p>
<ul>
<li>
<p><a href="oci.htm#BABIIJDH">&#34;LOBs in TimesTen OCI&#34;</a> and <a href="pro_c.htm#CIHGCAFJ">&#34;LOBs in TimesTen Pro*C/C++&#34;</a> for information specific to those APIs</p>
</li>
<li>
<p><a class="olink TTSQL481" href="../TTSQL/types.htm#TTSQL481">&#34;LOB data types&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for additional information about LOBs in TimesTen</p>
</li>
<li>
<p><a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a> for general information about programming with LOBs (but not specific to TimesTen functionality)</p>
</li>
</ul>
<a id="BABCAFEH"></a>
<div id="TTCDV513" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">About LOBs</h4>
<p>A LOB is a large binary object (BLOB) or character object (CLOB or NCLOB). In TimesTen, a BLOB can be up to 16 MB in size and a CLOB or NCLOB up to 4 MB. LOBs in TimesTen have essentially the same functionality as in Oracle Database, except as noted otherwise. (See the next section, <a href="#BABDGHFJ">&#34;Differences between TimesTen LOBs and Oracle Database LOBs&#34;</a>.)</p>
<p>LOBs may be either persistent or temporary. A persistent LOB exists in a LOB column in the database. A temporary LOB exists only within an application. There are circumstances where a temporary LOB is created implicitly by TimesTen. For example, if a <code dir="ltr">SELECT</code> statement selects a LOB concatenated with an additional string of characters, TimesTen creates a temporary LOB to contain the concatenated data. In TimesTen ODBC, any temporary LOBs are managed implicitly.</p>
<p>Temporary LOBs are stored in the TimesTen temporary data region.</p>
</div>
<!-- class="sect3" -->
<a id="BABDGHFJ"></a>
<div id="TTCDV514" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Differences between TimesTen LOBs and Oracle Database LOBs</h4>
<p>Be aware of the following:</p>
<ul>
<li>
<p>A key difference between the TimesTen LOB implementation and the Oracle Database implementation is that in TimesTen, a LOB used in an application does not remain valid past the end of the transaction. All such LOBs are invalidated after a commit or rollback, whether explicit or implicit. This includes after any DDL statement if TimesTen <code dir="ltr">DDLCommitBehavior</code> is set to 0 (the default), for Oracle Database behavior.</p>
</li>
<li>
<p>TimesTen does not support BFILEs, SecureFiles, array reads and writes for LOBs, or callback functions for LOBs.</p>
</li>
<li>
<p>TimesTen does not support binding arrays of LOBs.</p>
</li>
<li>
<p>TimesTen does not support batch processing of LOBs.</p>
</li>
<li>
<p>Relevant to BLOBs, there are differences in the usage of hexadecimal literals in TimesTen. see the description of <code dir="ltr"><span class="codeinlineitalic">HexadecimalLiteral</span></code> in <a class="olink TTSQL202" href="../TTSQL/express.htm#TTSQL202">&#34;Constants&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABIFJFD"></a>
<div id="TTCDV515" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">LOB programming interfaces</h4>
<p>There are three programmatic approaches, as follows, for accessing TimesTen LOBs in a C or C++ program.</p>
<ul>
<li>
<p>Simple data interface (ODBC, OCI, Pro*C/C++, TTClasses): Use binds and defines, as with other scalar types, to transfer LOB data in a single chunk.</p>
</li>
<li>
<p>Piecewise data interface (ODBC): Use advanced forms of binds and defines to transfer LOB data in multiple pieces. This is sometimes referred to as <span class="italic">streaming</span> or using <span class="italic">data-at-exec</span> (at program execution time). TimesTen supports the piecewise data interface through polling loops to go piece-by-piece through the LOB data. (Another piecewise approach, using callback functions, is supported by Oracle Database but not by TimesTen.)</p>
</li>
<li>
<p>LOB locator interface (OCI, Pro*C/C++): Select LOB locators using SQL then access LOB data through APIs that are similar conceptually to those used in accessing a file system. Using the LOB locator interface, you can work with LOB data in pieces or in single chunks. (See <a href="oci.htm#BABIIJDH">&#34;LOBs in TimesTen OCI&#34;</a> and <a href="pro_c.htm#CIHGCAFJ">&#34;LOBs in TimesTen Pro*C/C++&#34;</a>.)</p>
</li>
</ul>
<p>The LOB locator interface offers the most utility if it is feasible for you to use it.</p>
</div>
<!-- class="sect3" -->
<a id="BABFGJHE"></a>
<div id="TTCDV516" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using the LOB simple data interface in ODBC</h4>
<p>The simple data interface enables applications to access LOB data by binding and defining, just as with other scalar types. For the simple data interface in ODBC, use <code dir="ltr">SQLBindParameter</code> to bind parameters and <code dir="ltr">SQLBindCol</code> to define result columns. The application can bind or define using a SQL type that is compatible with the corresponding variable type, as follows.</p>
<ul>
<li>
<p>For BLOB data, use SQL type <code dir="ltr">SQL_LONGVARBINARY</code> and C type <code dir="ltr">SQL_C_BINARY</code>.</p>
</li>
<li>
<p>For CLOB data, use SQL type <code dir="ltr">SQL_LONGVARCHAR</code> and C type <code dir="ltr">SQL_C_CHAR</code>.</p>
</li>
<li>
<p>For NCLOB data, use SQL type <code dir="ltr">SQL_WLONGVARCHAR</code> and C type <code dir="ltr">SQL_C_WCHAR</code>.</p>
</li>
</ul>
<p><code dir="ltr">SQLBindParameter</code> and <code dir="ltr">SQLBindCol</code> calls for LOB data would be very similar to such calls for other data types, discussed earlier in this chapter.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Binding a CLOB or NCLOB with a C type of <code dir="ltr">SQL_C_BINARY</code> is prohibited.</div>
</div>
<!-- class="sect3" -->
<a id="BABJBHAA"></a>
<div id="TTCDV517" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using the LOB piecewise data interface in ODBC</h4>
<p>The piecewise interface enables applications to access LOB data in portions, piece by piece. An application binds parameters or defines results similarly to how those actions are performed for the simple data interface, but indicates that the data is to be provided or retrieved at program execution time (&#34;at exec&#34;). In TimesTen, you can implement the piecewise data interface through a polling loop that is repeated until all the LOB data has been read or written.</p>
<p>For the piecewise data interface in ODBC, use <code dir="ltr">SQLParamData</code> with <code dir="ltr">SQLPutData</code> in a polling loop to bind parameters, as shown in <a href="#BABHHDGG">Example 2-9</a> below, and <code dir="ltr">SQLGetData</code> in a polling loop to retrieve results. See the preceding section, <a href="#BABFGJHE">&#34;Using the LOB simple data interface in ODBC&#34;</a>, for information about supported SQL and C data types for BLOBs, CLOBs, and NCLOBs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Similar piecewise data access has already been supported for the various APIs in previous releases of TimesTen, for <code dir="ltr">var</code> data types.</div>
<div id="TTCDV518" class="example">
<p class="titleinexample"><a id="BABHHDGG"></a>Example 2-9 Using SQLPutData, ODBC piecewise data interface</p>
<p>This program excerpt uses <code dir="ltr">SQLPutData</code> with <code dir="ltr">SQLParamData</code> in a polling loop to insert LOB data piece-by-piece into the database. The <code dir="ltr">CLOB</code> column contains the value &#34;123ABC&#34; when the code is executed.</p>
<pre dir="ltr">...
/* create a table */
  create_stmt = &#34;create table clobtable ( c clob )&#34;;
  rc = SQLExecDirect(hstmt, (SQLCHAR *)create_stmt, SQL_NTS);
  if(rc != SQL_SUCCESS){/* ...error handling... */}
 
  /* initialize an insert statement */
  insert_stmt = &#34;insert into clobtable values(?)&#34;;
  rc = SQLPrepare(hstmt, (SQLCHAR *)insert_stmt, SQL_NTS);
  if(rc != SQL_SUCCESS){/* ...error handling... */}
 
  /* bind the parameter and specify that we will be using
   * SQLParamData/SQLPutData */
  rc = SQLBindParameter
    hstmt,            /* statement handle */
    1,                /* colnum number */
    SQL_PARAM_INPUT,  /* param type */
    SQL_C_CHAR,       /* C type */
    SQL_LONGVARCHAR,  /* SQL type (ignored) */
    2,                /* precision (ignored) */
    0,                /* scale (ignored) */
    0,                /* putdata token */
    0,                /* ignored */
    &amp;pcbvalue);       /* indicates use of SQLPutData */
  if(rc != SQL_SUCCESS){/* ...error handling... */}
 
  pcbvalue = SQL_DATA_AT_EXEC;
 
  /* execute the statement -- this should return SQL_NEED_DATA */
  rc = SQLExecute(hstmt);
  if(rc != SQL_NEED_DATA){/* ...error handling... */}
 
  /* while we still have parameters that need data... */
  while((rc = SQLParamData(hstmt, &amp;unused)) == SQL_NEED_DATA){
 
    memcpy(char_buf, &#34;123&#34;, 3);
    rc = SQLPutData(hstmt, char_buf, 3);
    if(rc !=  SQL_SUCCESS){/* ...error handling... */}
 
    memcpy(char_buf, &#34;ABC&#34;, 3);
    rc = SQLPutData(hstmt, char_buf, 3);
    if(rc !=  SQL_SUCCESS){/* ...error handling... */}
 
  }
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABGFCJJ"></a>
<div id="TTCDV519" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Passthrough LOBs in ODBC</h4>
<p>Passthrough LOBs, which are LOBs in Oracle Database accessed through TimesTen, are exposed as TimesTen LOBs and are supported by TimesTen in much the same way that any TimesTen LOB is supported, but note the following:</p>
<ul>
<li>
<p>TimesTen LOB size limitations do not apply to storage of LOBs in the Oracle database through passthrough.</p>
</li>
<li>
<p>As with TimesTen local LOBs, a passthrough LOB used in an application does not remain valid past the end of the transaction.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABEFHHB"></a>
<div id="TTCDV150" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Making and com<a id="sthref118"></a>mitting changes to the database</h3>
<p>Autocommit is enabled by default (according to the ODBC specification), so that any DML change you make, such as an update, insert, or delete, is committed automatically. It is recommended, however, that you disable this feature and commit (or roll back) your changes explicitly. Use the <code dir="ltr">SQL_AUTOCOMMIT</code> option in a <code dir="ltr">SQLSetConnectOption</code> call to accomplish this:</p>
<pre dir="ltr">rc = SQLSetConnectOption(hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF);
</pre>
<p>With autocommit disabled, you can commit or roll back a transaction using the <code dir="ltr">SQLTransact</code> ODBC function, such as in the following example to commit:</p>
<pre dir="ltr">rc = SQLTransact(henv, hdbc, SQL_COMMIT);
</pre>
<p>Refer to ODBC API reference documentation for details about these functions.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>Autocommit mode applies only to the top-level statement executed by <code dir="ltr">SQLExecute</code> or <code dir="ltr">SQLExecDirect</code>. There is no awareness of what occurs inside the statement, and therefore no capability for intermediate autocommits of nested operations.</p>
</li>
<li>
<p>All open cursors on the connection are closed upon transaction commit or rollback in TimesTen.</p>
</li>
<li>
<p>T<a id="sthref119"></a>he <code dir="ltr">SQLRowCount</code> function can be used to return information about SQL operations. For <code dir="ltr">UPDATE</code>, <code dir="ltr">INSERT</code>, and <code dir="ltr">DELETE</code> statements, the output argument returns the number of rows affected. See <a href="#BABIGEIB">&#34;Managing cache groups&#34;</a> regarding special TimesTen functionality. Refer to ODBC API reference documentation for general information about <code dir="ltr">SQLRowCount</code> and its arguments.</p>
</li>
</ul>
</div>
<p>You can refer to <a class="olink TTOPR678" href="../TTOPR/trans.htm#TTOPR678">&#34;Transaction overview&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span> for additional information about transactions.</p>
<div id="TTCDV151" class="example">
<p class="titleinexample"><a id="BABFBBHE"></a>Example 2-10 Updating the database and committing the change</p>
<p>This example prepares and executes a statement to give raises to selected employees, then manually commits the changes. Assume autocommit has been previously disabled.</p>
<pre dir="ltr">update_example(SQLHDBC hdbc)
{
  SQLCHAR*      stmt_text;
  SQLHSTMT      hstmt;
  SQLINTEGER    raise_pct;
  char          hiredate_str[30];
  SQLLEN        hiredate_len;
  SQLLEN        numrows;
 
  /* allocate a statement handle */
  SQLAllocStmt(hdbc, &amp;hstmt);
 
  /* prepare an update statement to give raises to employees hired before a
   * given date */
  stmt_text = (SQLCHAR*)
    &#34;update employees &#34;
    &#34;set salary = salary * ((100 + :raise_pct) / 100.0) &#34;
    &#34;where hire_date &lt; :hiredate&#34;;
  SQLPrepare(hstmt, stmt_text, SQL_NTS);
 
  /* bind parameter 1 (:raise_pct) to variable raise_pct */
  SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SLONG,
                   SQL_DECIMAL, 0, 0, (SQLPOINTER)&amp;raise_pct, 0, 0);
 
  /* bind parameter 2 (:hiredate) to variable hiredate_str */
  SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_CHAR,
                   SQL_TIMESTAMP, 0, 0, (SQLPOINTER)hiredate_str,
                   sizeof(hiredate_str), &amp;hiredate_len);
 
  /* set parameter values to give a 10% raise to employees hired before
   * January 1, 1996. */
  raise_pct = 10;
  strcpy(hiredate_str, &#34;1996-01-01&#34;);
  hiredate_len = SQL_NTS;
 
  /* execute the update statement */
  SQLExecute(hstmt);
 
  /* print the number of employees who got raises  */
  SQLRowCount(hstmt, &amp;numrows);
  printf(&#34;Gave raises to %d employees.\n&#34;, numrows);
 
  /* drop the statement handle */
  SQLFreeStmt(hstmt, SQL_DROP);

  /* commit the changes */
  SQLTransact(henv, hdbc, SQL_COMMIT);

}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBJIAA"></a>
<div id="TTCDV488" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using additional TimesTen data management features</h2>
<p>Preceding sections discussed key features for managing TimesTen data. This section covers the additional features listed here.</p>
<ul>
<li>
<p><a href="#CEGHCEHB">Using CALL to execute procedures and functions</a></p>
</li>
<li>
<p><a href="#BABGEJJD">Setting a timeout or threshold for executing SQL statements</a></p>
</li>
<li>
<p><a href="#BABGCFDH">Features for use with TimesTen Cache</a></p>
</li>
<li>
<p><a href="#CEGDCHFH">Setting globalization options</a></p>
</li>
<li>
<p><a href="#CEGDACDF">Features for use with replication</a></p>
</li>
<li>
<p><a href="#BABDABFA">ODBC 3.0 data types</a></p>
</li>
</ul>
<a id="CEGHCEHB"></a>
<div id="TTCDV154" class="sect2">
<h3 class="sect2">Using CALL to execute pro<a id="sthref120"></a><a id="sthref121"></a><a id="sthref122"></a><a id="sthref123"></a>cedures and functions</h3>
<p>TimesTen supports each of the following syntax formats from any of its programming interfaces to call PL/SQL procedures (<code dir="ltr"><span class="codeinlineitalic">procname</span></code>) or PL/SQL functions (<code dir="ltr"><span class="codeinlineitalic">funcname</span></code>) that are standalone or part of a package, or to call TimesTen built-in procedures (<code dir="ltr"><span class="codeinlineitalic">procname</span></code>).</p>
<pre dir="ltr">CALL <span class="italic">procname</span>[(<span class="italic">argumentlist</span>)]

CALL <span class="italic">funcname</span>[(<span class="italic">argumentlist</span>)] INTO :<span class="italic">returnparam</span>

CALL <span class="italic">funcname</span>[(<span class="italic">argumentlist</span>)] INTO ?
</pre>
<p>TimesTen ODBC also supports each of the following syntax formats:</p>
<pre dir="ltr">{ CALL <span class="italic">procname</span>[(<span class="italic">argumentlist</span>)] }

{ ? = [CALL] <span class="italic">funcname</span>[(<span class="italic">argumentlist</span>)] }

{ :<span class="italic">returnparam</span> = [CALL] <span class="italic">funcname</span>[(<span class="italic">argumentlist</span>)] }
</pre>
<p>The following ODBC example calls the TimesTen <code dir="ltr">ttCkpt</code> built-in procedure.</p>
<pre dir="ltr">rc = SQLExecDirect (hstmt, (SQLCHAR*) &#34;call ttCkpt&#34;,SQL_NTS);
</pre>
<p>These examples call a PL/SQL procedure <code dir="ltr">myproc</code> with two parameters:</p>
<pre dir="ltr">rc = SQLExecDirect(hstmt, (SQLCHAR*) &#34;{ call myproc(:param1, :param2) }&#34;,SQL_NTS);

rc = SQLExecDirect(hstmt, (SQLCHAR*) &#34;{ call myproc(?, ?) }&#34;,SQL_NTS);
</pre>
<p>The following shows several ways to call a PL/SQL function <code dir="ltr">myfunc</code>:</p>
<pre dir="ltr">rc = SQLExecDirect (hstmt, (SQLCHAR*) &#34;CALL myfunc() INTO :retparam&#34;,SQL_NTS);

rc = SQLExecDirect (hstmt, (SQLCHAR*) &#34;CALL myfunc() INTO ?&#34;,SQL_NTS);

rc = SQLExecDirect (hstmt, (SQLCHAR*) &#34;{ :retparam = myfunc() }&#34;,SQL_NTS);

rc = SQLExecDirect (hstmt, (SQLCHAR*) &#34;{ ? = myfunc() }&#34;,SQL_NTS);
</pre>
<p>See <a class="olink TTSQL443" href="../TTSQL/state.htm#TTSQL443">&#34;CALL&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for details about <code dir="ltr">CALL</code> syntax.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>A user&#39;s own procedure takes precedence over a TimesTen built-in procedure with the same name, but it is best to avoid such naming conflicts.</p>
</li>
<li>
<p>TimesTen does not support using <code dir="ltr">SQL_DEFAULT_PARAM</code> with <code dir="ltr">SQLBindParameter</code> for a <code dir="ltr">CALL</code> statement.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABGEJJD"></a>
<div id="TTCDV155" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Setting a timeout or threshold for executing SQL statements</h3>
<p>TimesTen offers two ways to limit the time for SQL statements or procedure calls to execute, applying to any <code dir="ltr">SQLExecute</code>, <code dir="ltr">SQLExecDirect</code>, or <code dir="ltr">SQLFetch</code> call.</p>
<ul>
<li>
<p><a href="#BABHIFFD">Setting a timeout duration for SQL statements</a></p>
</li>
<li>
<p><a href="#BABJCGJC">Setting a threshold duration for SQL statements</a></p>
</li>
</ul>
<p>For the former, if the timeout duration is reached, the statement stops executing and an error is thrown. For the latter, if the threshold is reached, an SNMP trap is thrown but execution continues.</p>
<a id="BABHIFFD"></a>
<div id="TTCDV156" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Set<a id="sthref124"></a><a id="sthref125"></a><a id="sthref126"></a>ting a timeout duration for SQL statements</h4>
<p>To control how long SQL statements should execute before timing out, you can set the <code dir="ltr">SQL_QUERY_TIMEOUT</code> option using a <code dir="ltr">SQLSetStmtOption</code> or <code dir="ltr">SQLSetConnectOption</code> call to specify a timeout value, in seconds. A value of 0 indicates no timeout. Despite the name, this timeout value applies to any executable SQL statement, not just queries.</p>
<p>In TimesTen, you can specify this timeout value for a connection, and therefore any statement on the connection, by using the <code dir="ltr">SqlQueryTimeout</code> general connection attribute. (Also see <a class="olink TTREF171" href="../TTREF/attribute.htm#TTREF171">&#34;SqlQueryTimeout&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.) A call to <code dir="ltr">SQLSetConnectOption</code> with the <code dir="ltr">SQL_QUERY_TIMEOUT</code> option overrides any previous query timeout setting. A call to <code dir="ltr">SQLSetStmtOption</code> with the <code dir="ltr">SQL_QUERY_TIMEOUT</code> option overrides the connection setting for the particular statement.</p>
<p>The query timeout limit has effect only when a SQL statement is actively executing. A timeout does not occur during commit or rollback. For transactions that update, insert, or delete a large number of rows, the commit or rollback phases may take a long time to complete. During that time the timeout value is ignored.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If both a lock timeout value and a SQL query timeout value are specified, the lesser of the two values causes a timeout first. Regarding lock timeouts, you can refer to <a class="olink TTREF260" href="../TTREF/proced.htm#TTREF260">&#34;ttLockWait&#34;</a> (built-in procedure) or <a class="olink TTREF165" href="../TTREF/attribute.htm#TTREF165">&#34;LockWait&#34;</a> (general connection attribute) in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>, or to <a class="olink TTTRB200" href="../TTTRB/datastore_trouble.htm#TTTRB200">&#34;Check for deadlocks and timeouts&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Troubleshooting Guide</span>.</div>
</div>
<!-- class="sect3" -->
<a id="BABJCGJC"></a>
<div id="TTCDV157" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Set<a id="sthref127"></a><a id="sthref128"></a><a id="sthref129"></a>ting a threshold duration for SQL statements</h4>
<p>You can configure TimesTen to write a warning to the support log and throw an SNMP trap when the execution of a SQL statement exceeds a specified time duration, in seconds. Execution continues and is not affected by the threshold.</p>
<p>The name of the SNMP trap is <code dir="ltr">ttQueryThresholdWarnTrap</code>. See <a class="olink TTERR" href="../TTERR/toc.htm"><span class="italic">Oracle TimesTen In-Memory Database Error Messages and SNMP Traps</span></a> for information about configuring SNMP traps. Despite the name, this threshold applies to any executable SQL statement.</p>
<p>By default, the application obtains the threshold from the <code dir="ltr">QueryThreshold</code> general connection attribute setting (refer to <a class="olink TTREF170" href="../TTREF/attribute.htm#TTREF170">&#34;QueryThreshold&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>). Setting the <code dir="ltr">TT_QUERY_THRESHOLD</code> option in a <code dir="ltr">SQLSetConnectOption</code> call overrides the connection attribute setting for the current connection.</p>
<p>To set the threshold with <code dir="ltr">SQLSetConnectOption</code>:</p>
<pre dir="ltr"><span class="italic">RETCODE</span> SQLSetConnectOption(<span class="italic">hdbc</span>, TT_QUERY_THRESHOLD, <span class="italic">seconds</span>);
</pre>
<p>Setting the <code dir="ltr">TT_QUERY_THRESHOLD</code> option in a <code dir="ltr">SQLSetStmtOption</code> call overrides the connection attribute setting, and any setting through <code dir="ltr">SQLSetConnectOption</code>, for the statement. It applies to SQL statements executed using the ODBC statement handle.</p>
<p>To set the threshold with <code dir="ltr">SQLSetStmtOption</code>:</p>
<pre dir="ltr"><span class="italic">RETCODE</span> SQLSetStmtOption(<span class="italic">hstmt</span>, TT_QUERY_THRESHOLD, <span class="italic">seconds</span>);
</pre>
<p>You can retrieve the current value of <code dir="ltr">TT_QUERY_THRESHOLD</code> by using the <code dir="ltr">SQLGetConnectOption</code> or <code dir="ltr">SQLGetStmtOption</code> ODBC function:</p>
<pre dir="ltr"><span class="italic">RETCODE</span> SQLGetConnectOption(<span class="italic">hdbc</span>, TT_QUERY_THRESHOLD, <span class="italic">paramvalue</span>);

<span class="italic">RETCODE</span> SQLGetStmtOption(<span class="italic">hstmt</span>, TT_QUERY_THRESHOLD, <span class="italic">paramvalue</span>);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGCFDH"></a>
<div id="TTCDV507" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Features for use with TimesTen Cache</h3>
<p>This section discusses features related to the use of TimesTen Cache:</p>
<ul>
<li>
<p><a href="#BABDGDHA">Setting temporary passthrough level with the ttOptSetFlag built-in procedure</a></p>
</li>
<li>
<p><a href="#BABFDHED">Determining passthrough status</a></p>
</li>
<li>
<p><a href="#BABIGEIB">Managing cache groups</a></p>
</li>
</ul>
<p>See <a class="olink TTCAC" href="../TTCAC/toc.htm"><span class="italic">Oracle TimesTen Application-Tier Database Cache User&#39;s Guide</span></a> for information about TimesTen Cache.</p>
<p>See <a class="olink TTREF211" href="../TTREF/attribute.htm#TTREF211">&#34;PassThrough&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for information about that general connection attribute. See <a class="olink TTCAC291" href="../TTCAC/operations.htm#TTCAC291">&#34;Setting a passthrough level&#34;</a> in <span class="italic">Oracle TimesTen Application-Tier Database Cache User&#39;s Guide</span> for information about passthrough settings.</p>
<a id="BABDGDHA"></a>
<div id="TTCDV508" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Set<a id="sthref130"></a><a id="sthref131"></a>ting temporary passthrough level with the ttOptSetFlag built-in procedure</h4>
<p>TimesTen provides the <code dir="ltr">ttOptSetFlag</code> built-in procedure for setting various flags, including the <code dir="ltr">PassThrough</code> flag to temporarily set the passthrough level. You can use <code dir="ltr">ttOptSetFlag</code> to set <code dir="ltr">PassThrough</code> in a C application as in the following example that sets the passthrough level to 1. The setting affects all statements that are prepared until the end of the transaction.</p>
<pre dir="ltr">rc = SQLExecDirect (hstmt, &#34;call ttOptSetFlag (&#39;PassThrough&#39;, 1)&#34;,SQL_NTS);
</pre>
<p>See <a class="olink TTREF271" href="../TTREF/proced.htm#TTREF271">&#34;ttOptSetFlag&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for more information about that built-in procedure.</p>
</div>
<!-- class="sect3" -->
<a id="BABFDHED"></a>
<div id="TTCDV509" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">De<a id="sthref132"></a><a id="sthref133"></a>termining passthrough status</h4>
<p>You can call the <code dir="ltr">SQLGetStmtOption</code> ODBC function with the <a id="sthref134"></a><code dir="ltr">TT_STMT_PASSTHROUGH_TYPE</code> statement option to determine whether a SQL statement is to be executed in the TimesTen database or passed through to the Oracle database for execution. This is shown in the following example.</p>
<pre dir="ltr">rc = SQLGetStmtOption(hStmt, TT_STMT_PASSTHROUGH_TYPE, &amp;passThroughType);
</pre>
<p>You can make this call after preparing the SQL statement. It is useful with <code dir="ltr">PassThrough</code> settings of 1, 2, 4, or 5, where the determination of whether a statement is actually passed through is not made until compilation time. If <code dir="ltr">TT_STMT_PASSTHROUGH_NONE</code> is returned, the statement is to be executed in TimesTen. If <code dir="ltr">TT_STMT_PASSTHROUGH_ORACLE</code> is returned, the statement is to be passed through to Oracle Database for execution.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">TT_STMT_PASSTHROUGH_TYPE</code> is supported with <code dir="ltr">SQLGetStmtOption</code> only, not with <code dir="ltr">SQLSetStmtOption</code>.</div>
</div>
<!-- class="sect3" -->
<a id="BABIGEIB"></a>
<div id="TTCDV158" class="sect3">
<h4 class="sect3">Ma<a id="sthref135"></a><a id="sthref136"></a>naging cache groups</h4>
<p>In TimesTen Cache, following the execution of a <code dir="ltr">FLUSH CACHE GROUP</code>, <code dir="ltr">LOAD CACHE GROUP</code>, <code dir="ltr">REFRESH CACHE GROUP</code>, or <code dir="ltr">UNLOAD CACHE GROUP</code> statement, the ODBC function <code dir="ltr">SQLRowCount</code> returns the number of cache instances that were flushed, loaded, refreshed, or unloaded.</p>
<p>For related information, see <a class="olink TTCAC290" href="../TTCAC/operations.htm#TTCAC290">&#34;Determining the number of cache instances affected by an operation&#34;</a> in <span class="italic">Oracle TimesTen Application-Tier Database Cache User&#39;s Guide</span>.</p>
<p>Refer to ODBC API reference documentation for general information about <code dir="ltr">SQLRowCount</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CEGDCHFH"></a>
<div id="TTCDV159" class="sect2">
<h3 class="sect2">Set<a id="sthref137"></a><a id="sthref138"></a><a id="sthref139"></a>ting globalization options</h3>
<p>TimesTen extensions to ODBC enable an application to set options for linguistic sorts, length semantics for character columns, and error reporting during character set conversion. These options can be used in a call to <code dir="ltr">SQLSetConnectOption</code>. The options are defined in the <code dir="ltr">timesten.h</code> file (noted in <a href="#BABHHHCF">&#34;TimesTen include files&#34;</a>).</p>
<p>For more information about linguistic sorts, length semantics, and character sets, see <a class="olink TTOPR274" href="../TTOPR/globalization.htm#TTOPR274">&#34;Globalization Support&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>.</p>
<p>This section includes the following TimesTen ODBC globalization options.</p>
<ul>
<li>
<p><a href="#CEGDIJFB">TT_NLS_SORT</a></p>
</li>
<li>
<p><a href="#CEGIGFIC">TT_NLS_LENGTH_SEMANTICS</a></p>
</li>
<li>
<p><a href="#CEGBJGEE">TT_NLS_NCHAR_CONV_EXCP</a></p>
</li>
</ul>
<a id="CEGDIJFB"></a>
<div id="TTCDV160" class="sect3">
<h4 class="sect3">TT_NL<a id="sthref140"></a>S_SORT</h4>
<p>This option specifies the collating sequence used for linguistic comparisons. See <a class="olink TTOPR284" href="../TTOPR/globalization.htm#TTOPR284">&#34;Monolingual linguistic sorts&#34;</a> and <a class="olink TTOPR285" href="../TTOPR/globalization.htm#TTOPR285">&#34;Multilingual linguistic sorts&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span> for supported linguistic sorts.</p>
<p>It takes a string value. The default is &#34;BINARY&#34;.</p>
<p>Also see the description of the <code dir="ltr">NLS_SORT</code> general connection attribute, which has the same functionality, in <a class="olink TTREF179" href="../TTREF/attribute.htm#TTREF179">&#34;NLS_SORT&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>. Note that <code dir="ltr">TT_NLS_SORT</code>, being a runtime option, takes precedence over the <code dir="ltr">NLS_SORT</code> connection attribute.</p>
</div>
<!-- class="sect3" -->
<a id="CEGIGFIC"></a>
<div id="TTCDV161" class="sect3">
<h4 class="sect3">TT_NLS_L<a id="sthref141"></a>ENGTH_SEMANTICS</h4>
<p>This option specifies whether byte or character semantics is used. The possible values are as follows.</p>
<ul>
<li>
<p><code dir="ltr">TT_NLS_LENGTH_SEMANTICS_BYTE</code> (default)</p>
</li>
<li>
<p><code dir="ltr">TT_NLS_LENGTH_SEMANTICS_CHAR</code></p>
</li>
</ul>
<p>Also see the description of the <code dir="ltr">NLS_LENGTH_SEMANTICS</code> general connection attribute, which has the same functionality, in <a class="olink TTREF177" href="../TTREF/attribute.htm#TTREF177">&#34;NLS_LENGTH_SEMANTICS&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>. Note that <code dir="ltr">TT_NLS_LENGTH_SEMANTICS</code>, being a runtime option, takes precedence over the <code dir="ltr">NLS_LENGTH_SEMANTICS</code> connection attribute.</p>
</div>
<!-- class="sect3" -->
<a id="CEGBJGEE"></a>
<div id="TTCDV162" class="sect3">
<h4 class="sect3">TT_NLS_NC<a id="sthref142"></a>HAR_CONV_EXCP</h4>
<p>This option specifies whether an error is reported when there is data loss during an implicit or explicit character type conversion between <code dir="ltr">NCHAR</code> or <code dir="ltr">NVARCHAR2</code> data and <code dir="ltr">CHAR</code> or <code dir="ltr">VARCHAR2</code> data during SQL operations. The option does not apply to conversions done by ODBC as a result of binding.</p>
<p>The possible values are:</p>
<ul>
<li>
<p><code dir="ltr">TRUE</code>: Errors during conversion are reported.</p>
</li>
<li>
<p><code dir="ltr">FALSE</code>: Errors during conversion are not reported (default).</p>
</li>
</ul>
<p>Also see the description of the <code dir="ltr">NLS_NCHAR_CONV_EXCP</code> general connection attribute, which has the same functionality, in <a class="olink TTREF178" href="../TTREF/attribute.htm#TTREF178">&#34;NLS_NCHAR_CONV_EXCP&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>. Note that <code dir="ltr">TT_NLS_NCHAR_CONV_EXCP</code>, being a runtime option, takes precedence over the <code dir="ltr">NLS_NCHAR_CONV_EXCP</code> connection attribute.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CEGDACDF"></a>
<div id="TTCDV502" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Features for use with replic<a id="sthref143"></a>ation</h3>
<p>For applications that employ replication, you can improve performance by using <span class="italic">parallel replication</span>, which uses multiple threads acting in parallel to replicate and apply transactional changes to nodes in a replication scheme. TimesTen supports the following types of parallel replication:</p>
<ul>
<li>
<p>Automatic parallel replication (<code dir="ltr">ReplicationApplyOrdering=0</code>): Parallel replication over multiple threads that automatically enforces transactional dependencies and all changes applied in commit order. This is the default.</p>
</li>
<li>
<p>Automatic parallel replication with disabled commit dependencies (<code dir="ltr">ReplicationApplyOrdering=2</code>): Parallel replication over multiple threads that automatically enforces transactional dependencies, but does not enforce transactions to be committed in the same order on the subscriber database as on the master database. In this mode, you can optionally specify replication tracks.</p>
</li>
<li>
<p>User-defined parallel replication (<code dir="ltr">ReplicationApplyOrdering=1</code>): For applications that use a classic replication scheme, have very predictable transactional dependencies, and do not require that the commit order on the receiver is the same as that on the originating database. You can specify the number of transaction tracks and apply specific transactions to each track. All tracks are read, transmitted and applied in parallel.</p>
</li>
</ul>
<p>See <a class="olink TTREP423" href="../TTREP/setup.htm#TTREP423">&#34;Configuring parallel replication&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Replication Guide</span> for additional information and usage scenarios.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
User-defined parallel replication is generally not advisable, because special care must be taken to avoid data divergence between replication nodes.</div>
<p>In an ODBC application that uses parallel replication and specifies replication tracks, you can specify the track number for transactions on a connection through the <code dir="ltr">TT_REPLICATION_TRACK</code> connection option, as noted in <a href="odbc_supported.htm#BEIEGCFC">&#34;Option support for SQLSetConnectOption and SQLGetConnectOption&#34;</a>. (Alternatively, use the general connection attribute <code dir="ltr">ReplicationTrack</code> or the <code dir="ltr">ALTER SESSION</code> parameter <code dir="ltr">REPLICATION_TRACK</code>.)</p>
</div>
<!-- class="sect2" -->
<a id="BABDABFA"></a>
<div id="TTCDV163" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">OD<a id="sthref144"></a>BC 3.0 data types</h3>
<p>The data types used in ODBC 2.0 and prior have been renamed in ODBC 3.0 for ISO 92 standards compliance. The sample programs shipped with TimesTen have been written using SQL 3.0 data types. The following table maps 2.0 types to their 3.0 equivalents.</p>
<p>Note that TimesTen supports ODBC 2.5, Extension Level 1, with additional features for Extension Level 2 where those features are included in <a href="odbc_supported.htm#BEIJHJBJ">Chapter 10, &#34;TimesTen ODBC Functions and Options&#34;</a>.</p>
<div class="inftblhruleinformal">
<table class="cellalignment4366" title="ODBC 3.0 to 2.0 type mappings" summary="This table maps ODBC2 data types to ODBC3 data types." dir="ltr">
<thead>
<tr class="cellalignment4360">
<th class="cellalignment4367" id="r1c1-t29">ODBC 2.0 data type</th>
<th class="cellalignment4367" id="r1c2-t29">ODBC 3.0 data type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r2c1-t29" headers="r1c1-t29"><code dir="ltr">HDBC</code></td>
<td class="cellalignment4368" headers="r2c1-t29 r1c2-t29"><code dir="ltr">SQLHDBC</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r3c1-t29" headers="r1c1-t29"><code dir="ltr">HENV</code></td>
<td class="cellalignment4368" headers="r3c1-t29 r1c2-t29"><code dir="ltr">SQLHENV</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r4c1-t29" headers="r1c1-t29"><code dir="ltr">HSTMT</code></td>
<td class="cellalignment4368" headers="r4c1-t29 r1c2-t29"><code dir="ltr">SQLHSTMT</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r5c1-t29" headers="r1c1-t29"><code dir="ltr">HWND</code></td>
<td class="cellalignment4368" headers="r5c1-t29 r1c2-t29"><code dir="ltr">SQLHWND</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r6c1-t29" headers="r1c1-t29"><code dir="ltr">LDOUBLE</code></td>
<td class="cellalignment4368" headers="r6c1-t29 r1c2-t29"><code dir="ltr">SQLDOUBLE</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r7c1-t29" headers="r1c1-t29"><code dir="ltr">RETCODE</code></td>
<td class="cellalignment4368" headers="r7c1-t29 r1c2-t29"><code dir="ltr">SQLRETURN</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r8c1-t29" headers="r1c1-t29"><code dir="ltr">SCHAR</code></td>
<td class="cellalignment4368" headers="r8c1-t29 r1c2-t29"><code dir="ltr">SQLSCHAR</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r9c1-t29" headers="r1c1-t29"><code dir="ltr">SDOUBLE</code></td>
<td class="cellalignment4368" headers="r9c1-t29 r1c2-t29"><code dir="ltr">SQLFLOATS</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r10c1-t29" headers="r1c1-t29"><code dir="ltr">SDWORD</code></td>
<td class="cellalignment4368" headers="r10c1-t29 r1c2-t29"><code dir="ltr">SQLINTEGER</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r11c1-t29" headers="r1c1-t29"><code dir="ltr">SFLOAT</code></td>
<td class="cellalignment4368" headers="r11c1-t29 r1c2-t29"><code dir="ltr">SQLREAL</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r12c1-t29" headers="r1c1-t29"><code dir="ltr">SWORD</code></td>
<td class="cellalignment4368" headers="r12c1-t29 r1c2-t29"><code dir="ltr">SQLSMALLINT</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r13c1-t29" headers="r1c1-t29"><code dir="ltr">UCHAR</code></td>
<td class="cellalignment4368" headers="r13c1-t29 r1c2-t29"><code dir="ltr">SQLCHAR</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r14c1-t29" headers="r1c1-t29"><code dir="ltr">UDWORD</code></td>
<td class="cellalignment4368" headers="r14c1-t29 r1c2-t29"><code dir="ltr">SQLUINTEGER</code></td>
</tr>
<tr class="cellalignment4360">
<td class="cellalignment4368" id="r15c1-t29" headers="r1c1-t29"><code dir="ltr">UWORD</code></td>
<td class="cellalignment4368" headers="r15c1-t29 r1c2-t29"><code dir="ltr">SQLUSMALLINT</code></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<p>Either version of data types may be used with TimesTen without restriction.</p>
<p>Note also that the <code dir="ltr">FAR</code> modifier that is mentioned in ODBC 2.0 documentation is not required.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFJBFE"></a>
<div id="TTCDV164" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Consider<a id="sthref145"></a>ing TimesTen features for access control</h2>
<p>TimesTen has features to control database access with object-level resolution for database objects such as tables, views, materialized views, sequences, and synonyms. You can refer to <a class="olink TTOPR236" href="../TTOPR/accesscontrol.htm#TTOPR236">&#34;Managing Access Control&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span> for introductory information about these features.</p>
<p>This section introduces access control as it relates to SQL operations, database connections, XLA, and C utility functions.</p>
<p>For any query or SQL DML or DDL statement discussed in this document or used in an example, it is assumed that the user has appropriate privileges to execute the statement. For example, a <code dir="ltr">SELECT</code> statement on a table requires ownership of the table, <code dir="ltr">SELECT</code> privilege granted for the table, or the <code dir="ltr">SELECT ANY TABLE</code> system privilege. Similarly, any DML statement requires table ownership, the applicable DML privilege (such as <code dir="ltr">UPDATE</code>) granted for the table, or the applicable <code dir="ltr">ANY TABLE</code> privilege (such as <code dir="ltr">UPDATE ANY TABLE</code>).</p>
<p>For DDL statements, <code dir="ltr">CREATE TABLE</code> requires the <code dir="ltr">CREATE TABLE</code> privilege in the user&#39;s schema, or <code dir="ltr">CREATE ANY TABLE</code> in any other schema. <code dir="ltr">ALTER TABLE</code> requires ownership or the <code dir="ltr">ALTER ANY TABLE</code> system privilege. <code dir="ltr">DROP TABLE</code> requires ownership or the <code dir="ltr">DROP ANY TABLE</code> system privilege. There are no object-level <code dir="ltr">ALTER</code> or <code dir="ltr">DROP</code> privileges.</p>
<p>Refer to <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for the privilege required for any given SQL statement.</p>
<p>Privileges are granted through the SQL statement <code dir="ltr">GRANT</code> and revoked through the statement <code dir="ltr">REVOKE</code>. Some privileges are granted to all users through the <code dir="ltr">PUBLIC</code> role, of which each user is a member. See <a class="olink TTSQL345" href="../TTSQL/privileges.htm#TTSQL345">&#34;The PUBLIC role&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for information about that role.</p>
<p>In addition, access control affects the following topics covered in this document.</p>
<ul>
<li>
<p>Connecting to a database: Refer to <a href="#BABHAGHD">&#34;Access control for connections&#34;</a>.</p>
</li>
<li>
<p>Setting connection attributes: Refer to <a href="#BABIABBI">&#34;Setting connection attributes programmatically&#34;</a>.</p>
</li>
<li>
<p>Configuring and managing XLA and using XLA functions: Refer to <a href="xla_event.htm#CIHIDBJJ">&#34;Access control impact on XLA&#34;</a>. Also refer to <a href="xla_ref.htm#CHECFFJB">Chapter 9, &#34;XLA Reference.&#34;</a> The documentation for each XLA function notes the required privilege.</p>
</li>
<li>
<p>Executing C utility functions: Refer to <a href="c_ref.htm#CACCCIBB">Chapter 8, &#34;TimesTen Utility API.&#34;</a> The documentation for each utility mentions whether any privilege is required.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>Access control cannot be disabled.</p>
</li>
<li>
<p>Access control privileges are checked both when SQL is prepared and when it is executed in the database, with most of the performance cost coming at prepare time.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="BABCADHC"></a>
<div id="TTCDV166" class="sect1">
<h2 class="sect1">Han<a id="sthref146"></a>dling Errors</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#BABJIHDI">Checking for errors</a></p>
</li>
<li>
<p><a href="#BABJBFIC">Error and warning levels</a></p>
</li>
<li>
<p><a href="#BABFBCJC">Recovering after fatal errors</a></p>
</li>
</ul>
<a id="BABJIHDI"></a>
<div id="TTCDV167" class="sect2">
<h3 class="sect2">Checking for errors</h3>
<p>An application should check for errors and warnings on every call. This saves considerable time and effort during development and debugging. The demo programs provided with TimesTen show examples of error checking.</p>
<p>Errors can be checked using either the TimesTen error code (error number) or error string, as defined in the <code dir="ltr"><span class="codeinlineitalic">install_dir</span></code><code dir="ltr">/include/tt_errCode.h</code> file. Entries are in the following format:</p>
<pre dir="ltr">#define tt_ErrMemoryLock             712
</pre>
<p>For a description of each message, see <a class="olink TTERR116" href="../TTERR/error.htm#TTERR116">&#34;List of errors and warnings&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Error Messages and SNMP Traps</span>.</p>
<p>After calling an ODBC function, check the return code. If the return code is not <code dir="ltr">SQL_SUCCESS</code>, use an error-handling routine that calls the ODBC function <code dir="ltr">SQLError</code> to retrieve the errors on the relevant ODBC handle. A single ODBC call may return multiple errors. The application should be written to return all errors by repeatedly calling the <code dir="ltr">SQLError</code> function until all errors are read from the error stack. Continue calling <code dir="ltr">SQLError</code> until the return code is <code dir="ltr">SQL_NO_DATA_FOUND</code>.</p>
<p>Refer to ODBC API reference documentation for details about the <code dir="ltr">SQLError</code> function and its arguments.</p>
<p>For more information about writing a function to handle standard ODBC errors, see <a class="olink TTERR111" href="../TTERR/error.htm#TTERR111">&#34;Retrieving errors and warnings&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Error Messages and SNMP Traps</span>.</p>
<div id="TTCDV168" class="example">
<p class="titleinexample"><a id="sthref147"></a>Example 2-11 Checking an ODBC function call for errors</p>
<p>This example shows that after a call to <code dir="ltr">SQLAllocConnect</code>, you can check for an error condition. If one is found, an error message is displayed and program execution is terminated.</p>
<pre dir="ltr">rc = SQLAllocConnect(henv, &amp;hdbc);

if (rc != SQL_SUCCESS) {
  handleError(rc, henv, hdbc, hstmt, err_buf, &amp;native_error);
  fprintf(stderr,
          &#34;Unable to allocate a connection handle:\n%s\n&#34;,
          err_buf);
  exit(-1);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABJBFIC"></a>
<div id="TTCDV169" class="sect2">
<h3 class="sect2">Er<a id="sthref148"></a>ror and warning levels</h3>
<p>When operations are not completely successful, TimesTen can return fatal errors, non-fatal errors, or warnings.</p>
<div id="TTCDV170" class="sect3"><a id="sthref149"></a>
<h4 class="sect3">Fatal errors</h4>
<p>Fatal errors are those that make the database inaccessible until after error recovery. When a fatal error occurs, all database connections are required to disconnect. No further operations may complete. Fatal errors are indicated by TimesTen error codes 846 and 994. Error handling for these errors should be different from standard error handling. In particular, the application error-handling code should roll back the current transaction and disconnect from the database.</p>
<p>Also see <a href="#BABFBCJC">&#34;Recovering after fatal errors&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<div id="TTCDV171" class="sect3"><a id="sthref150"></a>
<h4 class="sect3">Non-fatal errors</h4>
<p>Non-fatal errors include simple errors such as an <code dir="ltr">INSERT</code> statement that violates unique constraints. This category also includes some classes of application and process failures.</p>
<p>TimesTen returns non-fatal errors through the normal error-handling process. Application should check for errors and appropriately handle them.</p>
<p>When a database is affected by a non-fatal error, an error may be returned and the application should take appropriate action.</p>
<p>An application can handle non-fatal errors by modifying its actions or, in some cases, rolling back one or more offending transactions.</p>
</div>
<!-- class="sect3" -->
<div id="TTCDV172" class="sect3"><a id="sthref151"></a>
<h4 class="sect3">Warnings</h4>
<p>TimesTen returns warnings when something unexpected occurs that you may want to know about. Here are some events that cause TimesTen to issue a warning:</p>
<ul>
<li>
<p>Checkpoint failure</p>
</li>
<li>
<p>Use of a deprecated TimesTen feature</p>
</li>
<li>
<p>Truncation of some data</p>
</li>
<li>
<p>Execution of a recovery process upon connect</p>
</li>
<li>
<p>Replication return receipt timeout</p>
</li>
</ul>
<p>Application developers should have code that checks for warnings, as they can indicate application problems.</p>
</div>
<!-- class="sect3" -->
<div id="TTCDV566" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref152"></a>
<h4 class="sect3">Abnormal termination</h4>
<p>In some cases, such as process failure, no error is returned, but TimesTen automatically rolls back the transactions of the failed process.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABFBCJC"></a>
<div id="TTCDV173" class="sect2">
<h3 class="sect2">Reco<a id="sthref153"></a>vering after fatal errors</h3>
<p>When fatal errors occur, TimesTen performs a full cleanup and recovery procedure:</p>
<ul>
<li>
<p>Every connection to the database is invalidated. To avoid out-of-memory conditions in the server, applications are required to disconnect from the invalidated database. Shared memory from the old TimesTen instance is not freed until all active connections at the time of the error have disconnected. Inactive applications still connected to the old TimesTen instance may have to be manually terminated.</p>
</li>
<li>
<p>The database is recovered from the checkpoint and transaction log files upon the first subsequent initial connection.</p>
</li>
<li>
<p>The recovered database reflects the state of all durably committed transactions and possibly some transactions that were committed non-durably.</p>
</li>
<li>
<p>No uncommitted or rolled back transactions are reflected.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDAABC"></a>
<div id="TTCDV174" class="sect1">
<h2 class="sect1">Using auto<a id="sthref154"></a><a id="sthref155"></a><a id="sthref156"></a>matic client failover in your application</h2>
<p>Automatic client failover is for use in High Availability scenarios with a TimesTen active standby pair replication configuration. If there is a failure of the active node, failover (transfer) to the new active (original standby) node occurs, and applications are automatically reconnected to the new active node. TimesTen provides features that enable applications to be alerted when this happens, so they can take any appropriate action.</p>
<p>This section discusses the TimesTen implementation of automatic client failover as it applies to application developers, covering the following topics.</p>
<ul>
<li>
<p><a href="#BABHEJDF">Functionality of automatic client failover</a></p>
</li>
<li>
<p><a href="#BABHIEJG">Configuration of automatic client failover</a></p>
</li>
<li>
<p><a href="#BABDCGHC">Failover callback functions</a></p>
</li>
</ul>
<p>See <a class="olink TTOPR736" href="../TTOPR/client_server.htm#TTOPR736">&#34;Using automatic client failover&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span> for additional information about this feature.</p>
<a id="BABHEJDF"></a>
<div id="TTCDV175" class="sect2">
<h3 class="sect2">Functionality of automatic client failover</h3>
<p>When an application first connects to the active node, the connection is registered and this registration is replicated to the standby node. If the active node fails, the standby node becomes the new active node and then notifies the client of the failover. At this point, be aware of the following:</p>
<ul>
<li>
<p>The client has a new connection to the new active node, but using the same ODBC connection handle as before. No state from the original connection, other than the handle itself, is preserved. The application must open new ODBC statement handles.</p>
</li>
<li>
<p>There is a failover listener thread at each client that invokes the failover event function associated with your application, if a function has been registered. (See <a href="#BABDCGHC">&#34;Failover callback functions&#34;</a>.)</p>
</li>
</ul>
<p>All client statement handles from the original connection are marked as invalid. API calls on these statement handles generally return <code dir="ltr">SQL_ERROR</code> with a distinctive failover error code, defined in <code dir="ltr">tt_errCode.h</code>, such as:</p>
<pre dir="ltr">SQLSTATE = S1000 &#34;General Error&#34;, native error = tt_ErrFailoverInvalidation
</pre>
<p>The exception to this is for <code dir="ltr">SQLError</code> and <code dir="ltr">SQLFreeStmt</code> calls, which behave normally.</p>
<p>In addition, note the following:</p>
<ul>
<li>
<p>The socket to the original active node is closed. There is no attempt to call <code dir="ltr">SQLDisconnect</code>.</p>
</li>
<li>
<p>In connecting to the new active (original standby) TimesTen node, the same connection string that was returned from the original connection request is used, except the new server DSN is specified.</p>
</li>
<li>
<p>It is up to the application to open new statement handles and reexecute necessary <code dir="ltr">SQLPrepare</code> calls.</p>
</li>
<li>
<p>If a failover has already occurred and the client is already connected to the new active node, the next failover request results in an attempt to reconnect to the original active node. If that fails, alternating attempts are made to connect to the two servers until there is a timeout, and the connection is blocked during this period. The timeout value is according to the TimesTen client connection attribute <code dir="ltr">TTC_Timeout</code> (default 60 seconds), but with a minimum value of 60 seconds regardless of the <code dir="ltr">TTC_Timeout</code> setting. (Refer to <a class="olink TTREF199" href="../TTREF/attribute.htm#TTREF199">&#34;TTC_Timeout&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for information about that attribute.)</p>
</li>
<li>
<p>Failover connections are created only as needed, not in advance.</p>
</li>
</ul>
<p>During failover, TimesTen makes callbacks to a user-defined function that you register. This function takes care of any custom actions you want to occur in a failover situation. (See <a href="#BABDCGHC">&#34;Failover callback functions&#34;</a>.)</p>
<p>The following public connection options are propagated to the new connection. The corresponding general connection attribute is shown in parentheses where applicable. The <code dir="ltr">TT_REGISTER_FAILOVER_CALLBACK</code> option is used to register your callback function.</p>
<pre dir="ltr">SQL_ACCESS_MODE
SQL_AUTOCOMMIT
SQL_TXN_ISOLATION (Isolation)
SQL_OPT_TRACE
SQL_QUIET_MODE
TT_PREFETCH_CLOSE
TT_CLIENT_TIMEOUT (TTC_TIMEOUT)
TT_REGISTER_FAILOVER_CALLBACK
</pre>
<p>The following options are propagated to the new connection if they were set through connection attributes or <code dir="ltr">SQLSetConnectOption</code> calls, but not if set through TimesTen built-in procedures or <code dir="ltr">ALTER SESSION</code>.</p>
<pre dir="ltr">TT_NLS_SORT (NLS_SORT)
TT_NLS_LENGTH_SEMANTICS (NLS_LENGTH_SEMANTICS)
TT_NLS_NCHAR_CONV_EXCP (NLS_NCHAR_CONV_EXCP)
TT_DYNAMIC_LOAD_ENABLE (DynamicLoadEnable)
TT_DYNAMIC_LOAD_ERROR_MODE (DynamicLoadErrorMode)
</pre>
<p>The following options are propagated to the new connection if they were set on the connection handle.</p>
<pre dir="ltr">SQL_QUERY_TIMEOUT
TT_PREFETCH_COUNT
</pre></div>
<!-- class="sect2" -->
<a id="BABHIEJG"></a>
<div id="TTCDV567" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Config<a id="sthref157"></a>uration of automatic client failover</h3>
<p>Refer to <a class="olink TTOPR193" href="../TTOPR/client_server.htm#TTOPR193">&#34;Configuring automatic client failover&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span> for information.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Setting any of <code dir="ltr">TTC_Server2</code>, <code dir="ltr">TTC_Server_DSN2</code>, or <code dir="ltr">TCP_Port2</code> implies the following:
<ul>
<li>
<p>You intend to use automatic client failover.</p>
</li>
<li>
<p>You understand that a new thread is created for your application to support the failover mechanism.</p>
</li>
<li>
<p>You have linked your application with a thread library (pthreads on UNIX systems).</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABDCGHC"></a>
<div id="TTCDV176" class="sect2">
<h3 class="sect2">Failo<a id="sthref158"></a>ver callback functions</h3>
<p>When failover occurs, TimesTen makes a callback to your user-defined function for any desired action. This function is called when the attempt to connect to the new active (original standby) node begins, and again after the attempt to connect is complete. This function could be used, for example, to cleanly restore statement handles.</p>
<p>The function API is defined as follows.</p>
<pre dir="ltr">typedef SQLRETURN (*ttFailoverCallbackFcn_t)
  (SQLHDBC,      /* <span class="italic">hdbc</span>    */
   SQLPOINTER,   /* <span class="italic">foCtx</span>   */
   SQLUINTEGER,  /* <span class="italic">foType</span>  */
   SQLUINTEGER); /* <span class="italic">foEvent</span> */
</pre>
<p>Where:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">hdbc</span></code> is the ODBC connection handle for the connection that failed.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">foCtx</span></code> is a pointer to an application-defined data structure, for use as needed.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">foType</span></code> is the type of failover. In TimesTen, the only supported value for this is <code dir="ltr">TT_FO_SESSION</code>, which results in the session being reestablished. This does not result in statements being re-prepared.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">foEvent</span></code> indicates the event that has occurred, with the following supported values:</p>
<ul>
<li>
<p><code dir="ltr">TT_FO_BEGIN</code>: Beginning failover.</p>
</li>
<li>
<p><code dir="ltr">TT_FO_ABORT</code>: Failover failed. Retries were attempted for the interval specified by <code dir="ltr">TTC_Timeout</code> (minimum value 60 seconds for active standby failover) without success.</p>
</li>
<li>
<p><code dir="ltr">TT_FO_END</code>: Successful end of failover.</p>
</li>
<li>
<p><code dir="ltr">TT_FO_ERROR</code>: A failover connection failed but will be retried.</p>
</li>
</ul>
<p>Note that <code dir="ltr">TT_FO_REAUTH</code> is <span class="italic">not</span> supported by TimesTen client failover.</p>
</li>
</ul>
<p>Use a <code dir="ltr">SQLSetConnectOption</code> call to set the Times<a id="sthref159"></a>Ten <code dir="ltr">TT_REGISTER_FAILOVER_CALLBACK</code> option to register the callback function, specifying an option value that is a pointer to a structure of C type <code dir="ltr">ttFailoverCallback_t</code> that is defined as follows in the <code dir="ltr">timesten.h</code> file and refers to the callback function.</p>
<pre dir="ltr">typedef struct{
  SQLHDBC                 appHdbc;
  ttFailoverCallbackFcn_t callbackFcn;
  SQLPOINTER              foCtx;
} ttFailoverCallback_t;
</pre>
<p>Where:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">appHdbc</span></code> is the ODBC connection handle, and should have the same value as <code dir="ltr"><span class="codeinlineitalic">hdbc</span></code> in the <code dir="ltr">SQLSetConnectOption</code> calling sequence. (It is required in the data structure due to driver manager implementation details, in case you are using a driver manager.)</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">callbackFcn</span></code> specifies the callback function. (You can set this to <code dir="ltr">NULL</code> to cancel callbacks for the given connection. The failover would still happen, but the application would not be notified.)</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">foCtx</span></code> is a pointer to an application-defined data structure, as in the function description earlier.</p>
</li>
</ul>
<p>Set <code dir="ltr">TT_REGISTER_FAILOVER_CALLBACK</code> for each connection for which a callback is desired. The values in the <code dir="ltr">ttFailoverCallback_t</code> structure are copied when the <code dir="ltr">SQLSetConnectOption</code> call is made. The structure need not be kept by the application. If <code dir="ltr">TT_REGISTER_FAILOVER_CALLBACK</code> is set multiple times for a connection, the last setting takes precedence.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>Because the callback function executes asynchronously to the main thread of your application, it should generally perform only simple tasks, such as setting flags that are polled by the application. However, there is no such restriction if the application is designed for multithreading. In that case, the function could even make ODBC calls, for example, but it is only safe to do so if the <code dir="ltr"><span class="codeinlineitalic">foEvent</span></code> value <code dir="ltr">TT_FO_END</code> has been received.</p>
</li>
<li>
<p>It is up to the application to manage the data pointed to by the <code dir="ltr"><span class="codeinlineitalic">foCtx</span></code> setting.</p>
</li>
</ul>
</div>
<div id="TTCDV177" class="example">
<p class="titleinexample"><a id="BABDGFFJ"></a>Example 2-12 Failover callback function and registration</p>
<p>This example shows the following features.</p>
<ul>
<li>
<p>A globally defined user structure type, <code dir="ltr">FOINFO</code>, and the structure variable <code dir="ltr">foStatus</code> of type <code dir="ltr">FOINFO</code></p>
</li>
<li>
<p>A callback function, <code dir="ltr">FailoverCallback()</code>, that updates the <code dir="ltr">foStatus</code> structure whenever there is a failover</p>
</li>
<li>
<p>A registration function, <code dir="ltr">RegisterCallback()</code>, that does the following:</p>
<ul>
<li>
<p>Declares a structure, <code dir="ltr">failoverCallback</code>, of type <code dir="ltr">ttFailoverCallback_t</code>.</p>
</li>
<li>
<p>Initializes <code dir="ltr">foStatus</code> values.</p>
</li>
<li>
<p>Sets the <code dir="ltr">failoverCallback</code> data values, consisting of the connection handle, a pointer to <code dir="ltr">foStatus</code>, and the callback function (<code dir="ltr">FailoverCallback</code>).</p>
</li>
<li>
<p>Registers the callback function with a <code dir="ltr">SQLSetConnectOption</code> call that sets <code dir="ltr">TT_REGISTER_FAILOVER_CALLBACK</code> as a pointer to <code dir="ltr">failoverCallback</code>.</p>
</li>
</ul>
</li>
</ul>
<pre dir="ltr">/* user defined structure */
struct FOINFO
{
 int callCount;
 SQLUINTEGER lastFoEvent;
};
/* global variable passed into the callback function */
struct FOINFO foStatus;
 
/* the callback function */
SQLRETURN FailoverCallback (SQLHDBC hdbc,
                           SQLPOINTER pCtx,
                           SQLUINTEGER FOType,
                           SQLUINTEGER FOEvent)
{
 struct FOINFO* pFoInfo = (struct FOINFO*) pCtx;
 
 /* update the user defined data */
 if (pFoInfo != NULL)
 {
   pFoInfo-&gt;callCount ++;
   pFoInfo-&gt;lastFoEvent = FOEvent;
 
   printf (&#34;Failover Call #%d\n&#34;, pFoInfo-&gt;callCount);
 }
 
 /* the ODBC connection handle */
 printf (&#34;Failover HDBC : %p\n&#34;, hdbc);
 
 /* pointer to user data */
 printf (&#34;Failover Data : %p\n&#34;, pCtx);
 
 /* the type */
 switch (FOType)
 {
   case TT_FO_SESSION:
     printf (&#34;Failover Type : TT_FO_SESSION\n&#34;);
     break;
 
   default:
     printf (&#34;Failover Type : (unknown)\n&#34;);
 }
 
 /* the event */
 switch (FOEvent)
 {
   case TT_FO_BEGIN:
     printf (&#34;Failover Event: TT_FO_BEGIN\n&#34;);
     break;
 
   case TT_FO_END:
     printf (&#34;Failover Event: TT_FO_END\n&#34;);
     break;
 
   case TT_FO_ABORT:
     printf (&#34;Failover Event: TT_FO_ABORT\n&#34;);
     break;
 
   case TT_FO_REAUTH:
     printf (&#34;Failover Event: TT_FO_REAUTH\n&#34;);
     break;
 
   case TT_FO_ERROR:
     printf (&#34;Failover Event: TT_FO_ERROR\n&#34;);
     break;
 
   default:
     printf (&#34;Failover Event: (unknown)\n&#34;);
 }
 
 return SQL_SUCCESS;
}
 
/* function to register the callback with the failover connection */
SQLRETURN RegisterCallback (SQLHDBC hdbc)
{
 SQLRETURN rc;
 ttFailoverCallback_t failoverCallback;
 
 /* initialize the global user defined structure */
 foStatus.callCount = 0;
 foStatus.lastFoEvent = -1;
 
 /* register the connection handle, callback and the user defined structure */
 failoverCallback.appHdbc = hdbc;
 failoverCallback.foCtx = &amp;foStatus;
 failoverCallback.callbackFcn = FailoverCallback;
 
 rc = SQLSetConnectOption (hdbc, TT_REGISTER_FAILOVER_CALLBACK,
   (SQLULEN)&amp;failoverCallback);
 
 return rc;
}
</pre></div>
<!-- class="example" -->
<p>When a failover occurs, the callback function would produce output such as the following:</p>
<pre dir="ltr">Failover Call #1
Failover HDBC : 0x8198f50
Failover Data : 0x818f8ac
Failover Type : TT_FO_SESSION
Failover Event: TT_FO_BEGIN
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4359">
<tr>
<td class="cellalignment4368">
<table class="cellalignment4364">
<tr>
<td class="cellalignment4363"><a href="compiling.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4363"><a href="oci.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4370">
<table class="cellalignment4362">
<tr>
<td class="cellalignment4363"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4363"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4363"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4363"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4363"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4363"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>