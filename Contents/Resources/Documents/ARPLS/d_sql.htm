<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-2350"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/DBMS_SQL"></a><title>DBMS_SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1086"/>
<meta name="dcterms.created" content="2016-09-02T5:36:35Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database PL/SQL Packages and Types Reference"/>
<meta name="dcterms.identifier" content="E41829-07"/>
<meta name="dcterms.isVersionOf" content="ARPLS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="d_spm.htm" title="Previous" type="text/html"/>
<link rel="Next" href="d_sql_trans.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41829-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">153/290</span> <!-- End Header -->
<div id="ARPLS058" class="chapter"><a id="BABEDAHF"></a>
<h1 class="chapter"><span class="secnum">149</span> DBMS_SQL</h1>
<p>The <code dir="ltr"><a id="sthref9375"></a>DBMS_SQL</code> package provides an interface to use dynamic SQL to parse any data manipulation language (DML) or data definition language (DDL) statement using PL/SQL. For example, you can enter a <code dir="ltr">DROP</code> <code dir="ltr">TABLE</code> statement from within a stored procedure by using the <a href="#i997676">PARSE Procedures</a> supplied with the <code dir="ltr">DBMS_SQL</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information on native dynamic SQL, see <a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference.</span></a></div>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BABCIDIB">Using DBMS_SQL</a></p>
<ul>
<li>
<p>Overview</p>
</li>
<li>
<p>Security Model</p>
</li>
<li>
<p>Constants</p>
</li>
<li>
<p>Exceptions</p>
</li>
<li>
<p>Operational Notes</p>
</li>
<li>
<p>Examples</p>
</li>
</ul>
</li>
<li>
<p><a href="#CHDEEDCH">Data Structures</a></p>
<ul>
<li>
<p>RECORD TYPES</p>
</li>
<li>
<p>TABLE TYPES</p>
</li>
</ul>
</li>
<li>
<p><a href="#i997453">Summary of DBMS_SQL Subprograms</a></p>
</li>
</ul>
<div class="refentry"><a id="BABCIDIB"></a>
<div id="ARPLS68176" class="refsect1">
<h2 class="refsect1">Using DBMS_SQL <a id="sthref9376"></a></h2>
<ul>
<li>
<p><a href="#i1028953">Overview</a></p>
</li>
<li>
<p><a href="#i1027587">Security Model</a></p>
</li>
<li>
<p><a href="#i1027592">Constants</a></p>
</li>
<li>
<p><a href="#i1027597">Exceptions</a></p>
</li>
<li>
<p><a href="#i1027602">Operational Notes</a></p>
</li>
<li>
<p><a href="#i996963">Examples</a></p>
</li>
</ul>
<div id="ARPLS68177" class="refsect2"><a id="i1028953"></a>
<h3 class="refsect2">Overview</h3>
<p>Oracle lets you write stored procedures and anonymous PL/SQL blocks that use dynamic SQL. Dynamic SQL statements are not embedded in your source program; rather, they are stored in character strings that are input to, or built by, the program at runtime. This enables you to create more general-purpose procedures. For example, dynamic SQL lets you create a procedure that operates on a table whose name is not known until runtime.</p>
<p>Native Dynamic SQL is an alternative to <code dir="ltr">DBMS_SQL</code> that lets you place dynamic SQL statements directly into PL/SQL blocks. In most situations, Native Dynamic SQL is easier to use and performs better than <code dir="ltr">DBMS_SQL</code>. However, Native Dynamic SQL itself has certain limitations:</p>
<ul>
<li>
<p>There is no support for so-called Method 4 (for dynamic SQL statements with an unknown number of inputs or outputs)</p>
</li>
<li>
<p>There are some tasks that can only be performed using <code dir="ltr">DBMS_SQL.</code> For tasks that require <code dir="ltr">DBMS_SQL</code>, see <a class="olink LNPLS01108" href="../LNPLS/dynamic.htm#LNPLS01108"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</li>
</ul>
<p>The ability to use dynamic SQL from within stored procedures generally follows the model of the Oracle Call Interface (OCI).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a></div>
<p>PL/SQL differs somewhat from other common programming languages, such as C. For example, addresses (also called pointers) are not user-visible in PL/SQL. As a result, there are some differences between the Oracle Call Interface and the <code dir="ltr">DBMS_SQL</code> package. These differences include the following:</p>
<ul>
<li>
<p>The OCI binds by address and the <code dir="ltr">DBMS_SQL</code> package binds by value.</p>
</li>
<li>
<p><a id="sthref9377"></a><a id="sthref9378"></a>With <code dir="ltr">DBMS_SQL</code> you must call <code dir="ltr">VARIABLE_VALUE</code> to retrieve the value of an <code dir="ltr">OUT</code> parameter for an anonymous block, and you must call <code dir="ltr">COLUMN_VALUE</code> after fetching rows to retrieve the values of the columns in the rows into your program.</p>
</li>
<li>
<p>The current release of the <code dir="ltr">DBMS_SQL</code> package does not provide <code dir="ltr">CANCEL</code> cursor procedures.</p>
</li>
<li>
<p>Indicator variables are not required, because <code dir="ltr">NULLs</code> are fully supported as values of a PL/SQL variable.</p>
</li>
</ul>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68178" class="refsect2"><a id="i1027587"></a>
<h3 class="refsect2">Security Model</h3>
<p><code dir="ltr">DBMS_SQL</code> is a <code dir="ltr">SYS</code>-owned package compiled with <code dir="ltr">AUTHID</code> <code dir="ltr">CURRENT_USER</code>. Any <code dir="ltr">DBMS_SQL</code> subprogram called from an anonymous PL/SQL block runs with the privileges of the current user.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS00809" href="../LNPLS/subprograms.htm#LNPLS00809"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about using Invoker Rights or Definer Rights</div>
<p class="subhead2"><a id="ARPLS68179"></a>Preventing Malicious or Accidental Access of Open Cursor Numbers</p>
<p>An error, <code dir="ltr">ORA-29471</code>, is raised when any <code dir="ltr">DBMS_SQL</code> subprogram is called with a cursor number that does not denote an open cursor. When the error is raised, an alert is issued to the alert log and DBMS_SQL becomes inoperable for the life of the session.</p>
<p>If the actual value for the cursor number in a call to the <a href="#i1026423">IS_OPEN Function</a> denotes a cursor currently open in the session, the return value is <code dir="ltr">TRUE</code>. If the actual value is <code dir="ltr">NULL</code>, then the return value is <code dir="ltr">FALSE</code>. Otherwise, this raises an <code dir="ltr">ORA-29471</code> error.</p>
<p class="subhead2"><a id="ARPLS68180"></a>Preventing Inappropriate Use of a Cursor</p>
<p>Cursors are protected from security breaches that subvert known existing cursors.</p>
<p>Checks are made when binding and executing. Optionally, checks may be performed for every single DBMS_SQL subprogram call. The check is:</p>
<ul>
<li>
<p>The <code dir="ltr">current_user</code> is the same on calling the subprogram as it was on calling the most recent parse.</p>
</li>
<li>
<p>The enabled roles on calling the subprogram must be identical to the enabled roles on calling the most recent parse.</p>
</li>
<li>
<p>The container is the same on calling the subprogram as it was on calling the most recent parse.</p>
</li>
</ul>
<p>Consistent with the use of definer&#39;s rights subprograms, roles do not apply.</p>
<p>If either check fails, then an <code dir="ltr">ORA-29470</code> error is raised.</p>
<p>The mechanism for defining when checks are performed is a new overload for the <code dir="ltr">OPEN_CURSOR</code> subprogram, which takes a formal parameter, <code dir="ltr">security_level</code>, with allowed values <code dir="ltr">NULL</code>, <code dir="ltr">1</code> and <code dir="ltr">2</code>.</p>
<ul>
<li>
<p>When <code dir="ltr">security_level</code> = <code dir="ltr">1</code> (or is <code dir="ltr">NULL</code>), the checks are made only when binding and executing.</p>
</li>
<li>
<p>When <code dir="ltr">security_level</code> = <code dir="ltr">2</code>, the checks are always made.</p>
</li>
</ul>
<p class="subhead2"><a id="ARPLS68181"></a>Upgrade Considerations</p>
<p>This security regime is stricter than those in the previous releases. As a consequence, users of <code dir="ltr">DBMS_SQL</code> may encounter runtime errors on upgrade.</p>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68182" class="refsect2"><a id="i1027592"></a>
<h3 class="refsect2">Constants</h3>
<p>The constants described in <a href="#CIHHIABA">Table 149-1</a> are used with the <code dir="ltr">language_flag</code> parameter of the <a href="#i997676">PARSE Procedures</a>.</p>
<div id="ARPLS68183" class="tblformal">
<p class="titleintable"><a id="sthref9379"></a><a id="CIHHIABA"></a>Table 149-1 DBMS_SQL Constants</p>
<table class="cellalignment4330" title="DBMS_SQL Constants" summary="This table describes constants used by DBMS_SQL subprograms." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t5">Name</th>
<th class="cellalignment4328" id="r1c2-t5">Type</th>
<th class="cellalignment4328" id="r1c3-t5">Value</th>
<th class="cellalignment4328" id="r1c4-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t5" headers="r1c1-t5">
<p><code dir="ltr">V6</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t5 r1c2-t5">
<p><code dir="ltr">INTEGER</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t5 r1c3-t5">
<p><code dir="ltr">0</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t5 r1c4-t5">
<p>Specifies Oracle database version 6 behavior</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t5" headers="r1c1-t5">
<p><code dir="ltr">NATIVE</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t5 r1c2-t5">
<p><code dir="ltr">INTEGER</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t5 r1c3-t5">
<p><code dir="ltr">1</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t5 r1c4-t5">
<p>Specifies normal behavior for the database to which the program is connected</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t5" headers="r1c1-t5">
<p><code dir="ltr">V7</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t5 r1c2-t5">
<p><code dir="ltr">INTEGER</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t5 r1c3-t5">
<p>2</p>
</td>
<td class="cellalignment4329" headers="r4c1-t5 r1c4-t5">
<p>Specifies Oracle database version 7 behavior</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t5" headers="r1c1-t5">
<p><code dir="ltr">FOREIGN_SYNTAX</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t5 r1c2-t5">
<p><code dir="ltr">INTEGER</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t5 r1c3-t5">
<p>4</p>
</td>
<td class="cellalignment4329" headers="r5c1-t5 r1c4-t5">
<p>Passed as the <code dir="ltr">language_flag</code> argument to the <a href="#i997676">PARSE Procedures</a> to specify that the SQL statement to be parsed needs to be translated first by the SQL translation profile set in the database session. An error is raised if a profile is not set.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68184" class="refsect2"><a id="i1027597"></a>
<h3 class="refsect2">Exceptions</h3>
<pre dir="ltr">inconsistent_type EXCEPTION;
  pragma exception_init(inconsistent_type, -6562);
</pre>
<p>This exception is raised by the <a href="#i1025449">COLUMN_VALUE Procedure</a> or the <a href="#i998371">VARIABLE_VALUE Procedures</a> when the type of the given <code dir="ltr">OUT</code> parameter (for where to put the requested value) is different from the type of the value.</p>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68185" class="refsect2"><a id="i1027602"></a>
<h3 class="refsect2">Operational Notes</h3>
<ul>
<li>
<p><a href="#BABGFFAI">Execution Flow</a></p>
</li>
</ul>
<ul>
<li>
<p><a href="#BABECIBG">Processing Queries</a></p>
</li>
</ul>
<ul>
<li>
<p><a href="#BABFJHJF">Processing Updates, Inserts, and Deletes</a></p>
</li>
</ul>
<ul>
<li>
<p><a href="#i1027496">Locating Errors</a></p>
</li>
</ul>
<div id="ARPLS68186" class="refsect3"><a id="BABGFFAI"></a>
<h4 class="refsect3">Execution Flow</h4>
<ol>
<li>
<p><a href="#i1027364">OPEN_CURSOR</a></p>
</li>
<li>
<p><a href="#i996870">PARSE</a></p>
</li>
<li>
<p><a href="#i996891">BIND_VARIABLE or BIND_ARRAY</a></p>
</li>
<li>
<p><a href="#i996897">DEFINE_COLUMN, DEFINE_COLUMN_LONG, or DEFINE_ARRAY</a></p>
</li>
<li>
<p><a href="#BABBFFFJ">EXECUTE</a></p>
</li>
<li>
<p><a href="#i996905">FETCH_ROWS or EXECUTE_AND_FETCH</a></p>
</li>
<li>
<p><a href="#i996908">VARIABLE_VALUE, COLUMN_VALUE, or COLUMN_VALUE_LONG</a></p>
</li>
<li>
<p><a href="#i996912">CLOSE_CURSOR</a></p>
</li>
</ol>
<div id="ARPLS68187" class="refsect4"><a id="i1027364"></a>
<h5 class="refsect4"><a id="sthref9380"></a><a id="sthref9381"></a>OPEN_CURSOR</h5>
<p><a id="sthref9382"></a>To process a SQL statement, you must have an open cursor. When you call the&nbsp;<a href="#i997665">OPEN_CURSOR Functions</a>, you receive a cursor <code dir="ltr">ID</code> number for the data structure representing a valid cursor maintained by Oracle. These cursors are distinct from cursors defined at the precompiler, OCI, or PL/SQL level, and are used only by the <code dir="ltr">DBMS_SQL</code> package.</p>
<br/></div>
<!-- class="refsect4" -->
<div id="ARPLS68188" class="refsect4"><a id="i996870"></a>
<h5 class="refsect4">PARSE</h5>
<p>Every SQL statement must be parsed by calling the <a href="#i997676">PARSE Procedures</a>. Parsing the statement checks the statement&#39;s syntax and associates it with the cursor in your program.</p>
<p>You can parse any DML or DDL statement. DDL statements are run on the parse, which performs the implied commit.</p>
<p>The execution flow of <code dir="ltr">DBMS_SQL</code> is shown in <a href="#BABDJEBE">Figure 149-1</a>.</p>
<div id="ARPLS68189" class="figure">
<p class="titleinfigure"><a id="BABDJEBE"></a>Figure 149-1 DBMS_SQL Execution Flow</p>
<img width="496" height="608" src="img/arpls008.gif" alt="Description of Figure 149-1 follows"/><br/>
<a id="sthref9383" href="img_text/arpls008.htm">Description of &#39;&#39;Figure 149-1 DBMS_SQL Execution Flow&#39;&#39;</a><br/>
<br/></div>
<!-- class="figure" -->
<br/></div>
<!-- class="refsect4" -->
<div id="ARPLS68190" class="refsect4"><a id="i996891"></a>
<h5 class="refsect4">BIND_VARIABLE or BIND_ARRAY</h5>
<p>Many DML statements require that data in your program be input to Oracle. When you define a SQL statement that contains input data to be supplied at runtime, you must use placeholders in the SQL statement to mark where data must be supplied.</p>
<p><a id="sthref9384"></a>For each placeholder in the SQL statement, you must call one of the <a href="#i1025085">BIND_ARRAY Procedures</a> or the <a href="#i1030093">BIND_VARIABLE Procedures</a>, to supply the value of a variable in your program (or the values of an array) to the placeholder. When the SQL statement is subsequently run, Oracle uses the data that your program has placed in the output and input, or bind, variables.</p>
<p><code dir="ltr">DBMS_SQL</code> can run a DML statement multiple times &mdash; each time with a different bind variable. The <code dir="ltr">BIND_ARRAY</code> procedure lets you bind a collection of scalars, each value of which is used as an input variable once for each <code dir="ltr">EXECUTE</code>. This is similar to the array interface supported by the OCI.</p>
<p>Note that the datatype of the values bound to placeholders cannot be PL/SQL-only datatypes.</p>
<br/></div>
<!-- class="refsect4" -->
<div id="ARPLS68191" class="refsect4"><a id="i996897"></a>
<h5 class="refsect4">DEFINE_COLUMN, DEFINE_COLUMN_LONG, or DEFINE_ARRAY</h5>
<p>The columns of the row being selected in a <code dir="ltr">SELECT</code> statement are identified by their relative positions as they appear in the select list, from left to right. For a query, you must call one of the define procedures (<a href="#i1025686">DEFINE_COLUMN Procedures</a>, <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a>, or <a href="#i1025685">DEFINE_ARRAY Procedure</a>) to specify the variables that are to receive the <code dir="ltr">SELECT</code> values, much the way an <code dir="ltr">INTO</code> clause does for a static query.</p>
<p>Use the <code dir="ltr">DEFINE_COLUMN_LONG</code> procedure to define <code dir="ltr">LONG</code> columns, in the same way that <code dir="ltr">DEFINE_COLUMN</code> is used to define non-<code dir="ltr">LONG</code> columns. You must call <code dir="ltr">DEFINE_COLUMN_LONG</code> before using the <a href="#i1025399">COLUMN_VALUE_LONG Procedure</a> to fetch from the <code dir="ltr">LONG</code> column.</p>
<p>Use the <code dir="ltr">DEFINE_ARRAY</code> procedure to define a PL/SQL collection into which you want to fetch rows in a single <code dir="ltr">SELECT</code> statement. <code dir="ltr">DEFINE_ARRAY</code> provides an interface to fetch multiple rows at one fetch. You must call <code dir="ltr">DEFINE_ARRAY</code> before using the <code dir="ltr">COLUMN_VALUE</code> procedure to fetch the&nbsp;rows.</p>
<br/></div>
<!-- class="refsect4" -->
<div id="ARPLS68192" class="refsect4"><a id="BABBFFFJ"></a>
<h5 class="refsect4">EXECUTE</h5>
<p>Call the <a href="#i1025983">EXECUTE Function</a> to run your SQL statement.</p>
<br/></div>
<!-- class="refsect4" -->
<div id="ARPLS68193" class="refsect4"><a id="i996905"></a>
<h5 class="refsect4">FETCH_ROWS or EXECUTE_AND_FETCH</h5>
<p>The <a href="#i1026065">FETCH_ROWS Function</a> retrieves the rows that satisfy the query. Each successive fetch retrieves another set of rows, until the fetch is unable to retrieve any more rows. Instead of calling <a href="#i1025983">EXECUTE Function</a> and then <code dir="ltr">FETCH_ROWS</code>, you may find it more efficient to call <a href="#i1025711">EXECUTE_AND_FETCH Function</a> if you are calling <code dir="ltr">EXECUTE</code> for a single execution.</p>
<br/></div>
<!-- class="refsect4" -->
<div id="ARPLS68194" class="refsect4"><a id="i996908"></a>
<h5 class="refsect4">VARIABLE_VALUE, COLUMN_VALUE, or COLUMN_VALUE_LONG</h5>
<p>For queries, call the <a href="#i1025449">COLUMN_VALUE Procedure</a> to determine the value of a column retrieved by the <a href="#i1026065">FETCH_ROWS Function</a>. For anonymous blocks containing calls to <code dir="ltr">PL</code>/<code dir="ltr">SQL</code> procedures or DML statements with <code dir="ltr">returning</code> clause, call the <a href="#i998371">VARIABLE_VALUE Procedures</a> to retrieve the values assigned to the output variables when statements were run.</p>
<p>To fetch only part of a <code dir="ltr">LONG</code> database column (which can be up to two gigabytes in size), use the <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a>. You can specify the offset (in bytes) into the column value, and the number of bytes to&nbsp;fetch.</p>
<br/></div>
<!-- class="refsect4" -->
<div id="ARPLS68195" class="refsect4"><a id="i996912"></a>
<h5 class="refsect4">CLOSE_CURSOR</h5>
<p>When you no longer need a cursor for a session, close the cursor by calling the <a href="#i1026299">CLOSE_CURSOR Procedure</a>. If you are using an Oracle Open Gateway, then you may need to close cursors at other times as well. Consult your <span class="italic">Oracle Open Gateway</span> documentation for additional information.</p>
<p>If you neglect to close a cursor, then the memory used by that cursor remains allocated even though it is no longer needed.</p>
<br/></div>
<!-- class="refsect4" --></div>
<!-- class="refsect3" -->
<div id="ARPLS68196" class="refsect3"><a id="BABECIBG"></a>
<h4 class="refsect3">Processing Queries</h4>
<p>If you are using dynamic SQL to process a query, then you must perform the following steps:</p>
<ol>
<li>
<p>Specify the variables that are to receive the values returned by the&nbsp;<code dir="ltr">SELECT</code> statement by calling the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, the <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a>, or the <a href="#i1025685">DEFINE_ARRAY Procedure</a>.</p>
</li>
<li>
<p>Run your <code dir="ltr">SELECT</code> statement by calling the <a href="#i1025983">EXECUTE Function</a>.</p>
</li>
<li>
<p>Call the <a href="#i1026065">FETCH_ROWS Function</a> (or <code dir="ltr">EXECUTE_AND_FETCH</code>) to retrieve the rows&nbsp;that satisfied your query.</p>
</li>
<li>
<p>Call <a href="#i1025449">COLUMN_VALUE Procedure</a> or <a href="#i1025399">COLUMN_VALUE_LONG Procedure</a> to determine the&nbsp;value of a column retrieved by the <a href="#i1026065">FETCH_ROWS Function</a> for your query. If you used anonymous blocks containing calls to PL/SQL procedures, then you must call the <a href="#i998371">VARIABLE_VALUE Procedures</a> to retrieve the values assigned to the output variables of these procedures.</p>
</li>
</ol>
</div>
<!-- class="refsect3" -->
<div id="ARPLS68197" class="refsect3"><a id="BABFJHJF"></a>
<h4 class="refsect3">Processing Updates, Inserts, and Deletes</h4>
<p>If you are using dynamic SQL to process an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code>, then you must perform the following steps:</p>
<ol>
<li>
<p>Run your <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statement by calling the <a href="#i1025983">EXECUTE Function</a>.</p>
</li>
<li>
<p>If statements have the <code dir="ltr">returning</code> clause, then you must call the <a href="#i998371">VARIABLE_VALUE Procedures</a> to retrieve the values assigned to the output variables.</p>
</li>
</ol>
</div>
<!-- class="refsect3" -->
<div id="ARPLS68198" class="refsect3"><a id="i1027496"></a>
<h4 class="refsect3">Locating Errors</h4>
<p>The <code dir="ltr">DBMS_SQL</code> package has additional functions for obtaining information about the last referenced cursor in the session. The values returned by these functions are meaningful only immediately after a SQL statement is run. In addition, some error-locating functions are meaningful only after certain <code dir="ltr">DBMS_SQL</code> calls. For example, you call the <a href="#i1026408">LAST_ERROR_POSITION Function</a> immediately after calling one of the <a href="#i997676">PARSE Procedures</a>.</p>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68199" class="refsect2"><a id="i996963"></a>
<h3 class="refsect2">Examples</h3>
<p>This section provides example procedures that use the <code dir="ltr">DBMS_SQL</code> package.</p>
<p class="subhead2"><a id="ARPLS68200"></a>Example 1</p>
<p>This example does not need dynamic SQL because the text of the statement is known at compile time, but it illustrates the basic concept underlying the package.</p>
<p>The <code dir="ltr">DEMO</code> procedure deletes all of the employees from the <code dir="ltr">EMP</code> table whose salaries are greater than the salary that you specify when you run <code dir="ltr">DEMO</code>.</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE demo(salary IN NUMBER) AS
    cursor_name INTEGER;
    rows_processed INTEGER;
BEGIN
    cursor_name := dbms_sql.open_cursor;
    DBMS_SQL.PARSE(cursor_name, &#39;DELETE FROM emp WHERE sal &gt; :x&#39;,
                   DBMS_SQL.NATIVE);
    DBMS_SQL.BIND_VARIABLE(cursor_name, &#39;:x&#39;, salary);
    rows_processed := DBMS_SQL.EXECUTE(cursor_name);
    DBMS_SQL.CLOSE_CURSOR(cursor_name);
EXCEPTION
WHEN OTHERS THEN
    DBMS_SQL.CLOSE_CURSOR(cursor_name);
END;
</pre>
<p class="subhead2"><a id="ARPLS68201"></a>Example 2</p>
<p>The following sample procedure is passed a SQL statement, which it then parses and runs:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE exec(STRING IN varchar2) AS
    cursor_name INTEGER;
    ret INTEGER;
BEGIN
   cursor_name := DBMS_SQL.OPEN_CURSOR;
  
</pre>
<p>DDL statements are run by the parse call, which performs the implied commit.</p>
<pre dir="ltr">   DBMS_SQL.PARSE(cursor_name, string, DBMS_SQL.NATIVE);
   ret := DBMS_SQL.EXECUTE(cursor_name);
   DBMS_SQL.CLOSE_CURSOR(cursor_name);
END;
</pre>
<p>Creating such a procedure enables you to perform the following operations:</p>
<ul>
<li>
<p>The SQL statement can be dynamically generated at runtime by the calling program.</p>
</li>
<li>
<p>The SQL statement can be a DDL statement or a DML without binds.</p>
</li>
</ul>
<p>For example, after creating this procedure, you could make the following call:</p>
<pre dir="ltr">exec(&#39;create table acct(c1 integer)&#39;);
</pre>
<p>You could even call this procedure remotely, as shown in the following example. This lets you perform remote DDL.</p>
<pre dir="ltr">exec@hq.com(&#39;CREATE TABLE acct(c1 INTEGER)&#39;);
</pre>
<p class="subhead2"><a id="ARPLS68202"></a>Example 3</p>
<p>The following sample procedure is passed the names of a source and a destination table, and copies the rows from the source table to the destination table. This sample procedure assumes that both the source and destination tables have the following columns:</p>
<pre dir="ltr">id        of type NUMBER
name      of type VARCHAR2(30)
birthdate of type DATE
</pre>
<p>This procedure does not need the use of dynamic SQL; however, it illustrates the concepts of this package.</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE copy ( 
     source      IN VARCHAR2, 
     destination IN VARCHAR2) IS 
     id_var             NUMBER; 
     name_var           VARCHAR2(30); 
     birthdate_var      DATE; 
     source_cursor      INTEGER; 
     destination_cursor INTEGER; 
     ignore             INTEGER; 
  BEGIN 
 
  -- Prepare a cursor to select from the source table: 
     source_cursor := dbms_sql.open_cursor; 
     DBMS_SQL.PARSE(source_cursor, 
         &#39;SELECT id, name, birthdate FROM &#39; || source, 
          DBMS_SQL.NATIVE); 
     DBMS_SQL.DEFINE_COLUMN(source_cursor, 1, id_var); 
     DBMS_SQL.DEFINE_COLUMN(source_cursor, 2, name_var, 30); 
     DBMS_SQL.DEFINE_COLUMN(source_cursor, 3, birthdate_var); 
     ignore := DBMS_SQL.EXECUTE(source_cursor); 
 
  -- Prepare a cursor to insert into the destination table: 
     destination_cursor := DBMS_SQL.OPEN_CURSOR; 
     DBMS_SQL.PARSE(destination_cursor, 
                  &#39;INSERT INTO &#39; || destination || 
                  &#39; VALUES (:id_bind, :name_bind, :birthdate_bind)&#39;, 
                   DBMS_SQL.NATIVE); 
 
  -- Fetch a row from the source table and insert it into the destination table: 
     LOOP 
       IF DBMS_SQL.FETCH_ROWS(source_cursor)&gt;0 THEN 
         -- get column values of the row 
         DBMS_SQL.COLUMN_VALUE(source_cursor, 1, id_var); 
         DBMS_SQL.COLUMN_VALUE(source_cursor, 2, name_var); 
         DBMS_SQL.COLUMN_VALUE(source_cursor, 3, birthdate_var); 
 
  -- Bind the row into the cursor that inserts into the destination table. You 
  -- could alter this example to require the use of dynamic SQL by inserting an 
  -- if condition before the bind. 
        DBMS_SQL.BIND_VARIABLE(destination_cursor, &#39;:id_bind&#39;, id_var); 
        DBMS_SQL.BIND_VARIABLE(destination_cursor, &#39;:name_bind&#39;, name_var); 
        DBMS_SQL.BIND_VARIABLE(destination_cursor, &#39;:birthdate_bind&#39;, 
                                                                   birthdate_var); 
        ignore := DBMS_SQL.EXECUTE(destination_cursor); 
      ELSE 
 
  -- No more rows to copy: 
        EXIT; 
      END IF; 
    END LOOP; 
 
  -- Commit and close all cursors: 
     COMMIT; 
     DBMS_SQL.CLOSE_CURSOR(source_cursor); 
     DBMS_SQL.CLOSE_CURSOR(destination_cursor); 
   EXCEPTION 
     WHEN OTHERS THEN 
       IF DBMS_SQL.IS_OPEN(source_cursor) THEN 
         DBMS_SQL.CLOSE_CURSOR(source_cursor); 
       END IF; 
       IF DBMS_SQL.IS_OPEN(destination_cursor) THEN 
         DBMS_SQL.CLOSE_CURSOR(destination_cursor); 
       END IF; 
       RAISE; 
  END; 
/ 
</pre>
<p class="subhead2"><a id="i997061"></a><a id="ARPLS68203"></a>Examples 3, 4, and 5:&nbsp;Bulk DML</p>
<p>This series of examples shows how to use bulk array binds (table items) in the SQL DML statements <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code> and <code dir="ltr">DELETE</code>.</p>
<p>Here is an example of a bulk <code dir="ltr">INSERT</code> statement that demonstrates adding seven new employees to the <code dir="ltr">emp</code> table:</p>
<pre dir="ltr">DECLARE
  stmt VARCHAR2(200);
  empno_array      DBMS_SQL.NUMBER_TABLE;
  empname_array    DBMS_SQL.VARCHAR2_TABLE;
  jobs_array       DBMS_SQL.VARCHAR2_TABLE;
  mgr_array        DBMS_SQL.NUMBER_TABLE;
  hiredate_array   DBMS_SQL.VARCHAR2_TABLE;
  sal_array        DBMS_SQL.NUMBER_TABLE;
  comm_array       DBMS_SQL.NUMBER_TABLE;
  deptno_array     DBMS_SQL.NUMBER_TABLE;
  c                NUMBER;
  dummy            NUMBER;
BEGIN
  empno_array(1):= 9001;
  empno_array(2):= 9002;
  empno_array(3):= 9003;
  empno_array(4):= 9004;
  empno_array(5):= 9005;
  empno_array(6):= 9006;
  empno_array(7):= 9007;

  empname_array(1) := &#39;Dopey&#39;;
  empname_array(2) := &#39;Grumpy&#39;;
  empname_array(3) := &#39;Doc&#39;;
  empname_array(4) := &#39;Happy&#39;;
  empname_array(5) := &#39;Bashful&#39;;
  empname_array(6) := &#39;Sneezy&#39;;
  empname_array(7) := &#39;Sleepy&#39;;

  jobs_array(1) := &#39;Miner&#39;;
  jobs_array(2) := &#39;Miner&#39;;
  jobs_array(3) := &#39;Miner&#39;;
  jobs_array(4) := &#39;Miner&#39;;
  jobs_array(5) := &#39;Miner&#39;;
  jobs_array(6) := &#39;Miner&#39;;
  jobs_array(7) := &#39;Miner&#39;;

  mgr_array(1) := 9003;
  mgr_array(2) := 9003;
  mgr_array(3) := 9003;
  mgr_array(4) := 9003;
  mgr_array(5) := 9003;
  mgr_array(6) := 9003;
  mgr_array(7) := 9003;

  hiredate_array(1) := &#39;06-DEC-2006&#39;;
  hiredate_array(2) := &#39;06-DEC-2006&#39;;
  hiredate_array(3) := &#39;06-DEC-2006&#39;;
  hiredate_array(4) := &#39;06-DEC-2006&#39;;
  hiredate_array(5) := &#39;06-DEC-2006&#39;;
  hiredate_array(6) := &#39;06-DEC-2006&#39;;
  hiredate_array(7) := &#39;06-DEC-2006&#39;;

  sal_array(1):= 1000;
  sal_array(2):= 1000;
  sal_array(3):= 1000;
  sal_array(4):= 1000;
  sal_array(5):= 1000;
  sal_array(6):= 1000;
  sal_array(7):= 1000;

  comm_array(1):= 0;
  comm_array(2):= 0;
  comm_array(3):= 0;
  comm_array(4):= 0;
  comm_array(5):= 0;
  comm_array(6):= 0;
  comm_array(7):= 0;

  deptno_array(1):= 11;
  deptno_array(2):= 11;
  deptno_array(3):= 11;
  deptno_array(4):= 11;
  deptno_array(5):= 11;
  deptno_array(6):= 11;
  deptno_array(7):= 11;

  stmt := &#39;INSERT INTO emp VALUES(
     :num_array, :name_array, :jobs_array, :mgr_array, :hiredate_array, 
     :sal_array, :comm_array, :deptno_array)&#39;;
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_ARRAY(c, &#39;:num_array&#39;, empno_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:name_array&#39;, empname_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:jobs_array&#39;, jobs_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:mgr_array&#39;, mgr_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:hiredate_array&#39;, hiredate_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:sal_array&#39;, sal_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:comm_array&#39;, comm_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:deptno_array&#39;, deptno_array);

  dummy := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c);
  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/
SHOW ERRORS;
</pre>
<p>Here is an example of a bulk <code dir="ltr">UPDATE</code> statement that demonstrates updating salaries for four existing employees in the <code dir="ltr">emp</code> table:</p>
<pre dir="ltr">DECLARE
  stmt VARCHAR2(200);
  empno_array     DBMS_SQL.NUMBER_TABLE;
  salary_array    DBMS_SQL.NUMBER_TABLE;
  c               NUMBER;
  dummy           NUMBER;
BEGIN
 
  empno_array(1):= 7369;
  empno_array(2):= 7876;
  empno_array(3):= 7900;
  empno_array(4):= 7934;
 
  salary_array(1) := 10000;
  salary_array(2) := 10000;
  salary_array(3) := 10000;
  salary_array(4) := 10000;
 
  stmt := &#39;update emp set sal = :salary_array
    WHERE empno = :num_array&#39;;
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_ARRAY(c, &#39;:num_array&#39;, empno_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:salary_array&#39;, salary_array);
  dummy := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c);
 
  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/
</pre>
<p>In a <code dir="ltr">DELETE</code> statement, for example, you could bind an array in the <code dir="ltr">WHERE</code> clause and have the statement be run for each element in the&nbsp;array:</p>
<pre dir="ltr">DECLARE
  stmt VARCHAR2(200);
  dept_no_array DBMS_SQL.NUMBER_TABLE;
  c NUMBER;
  dummy NUMBER;
begin
  dept_no_array(1) := 10; dept_no_array(2) := 20;
  dept_no_array(3) := 30; dept_no_array(4) := 40;
  dept_no_array(5) := 30; dept_no_array(6) := 40;
  stmt := &#39;delete from emp where deptno = :dept_array&#39;;
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_ARRAY(c, &#39;:dept_array&#39;, dept_no_array, 1, 4);
  dummy := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c); 

  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/ 
</pre>
<p>In the preceding example, only elements 1 through 4 are used as specified by the <code dir="ltr">BIND_ARRAY</code> call. Each element of the array potentially deletes a large number of employees from the database.</p>
<p class="subhead2"><a id="i997149"></a><a id="ARPLS68204"></a>Examples 6 and 7:&nbsp;Defining an Array</p>
<p>The following examples show how to use the <code dir="ltr">DEFINE_ARRAY</code> procedure:</p>
<pre dir="ltr">declare
  c       NUMBER;
  d       NUMBER;
  n_tab   DBMS_SQL.NUMBER_TABLE;
  indx    NUMBER := -10;
BEGIN
  c := DBMS_SQL.OPEN_CURSOR;
  dBMS_SQL.PARSE(c, &#39;select n from t order by 1&#39;, DBMS_SQL.NATIVE);

  DBMS_SQL.DEFINE_ARRAY(c, 1, n_tab, 10, indx);

  d := DBMS_SQL.EXECUTE(c);
  loop
    d := DBMS_SQL.FETCH_ROWS(c);

    DBMS_SQL.COLUMN_VALUE(c, 1, n_tab);

    EXIT WHEN d != 10;
  END LOOP;

  DBMS_SQL.CLOSE_CURSOR(c);

  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/
</pre>
<p>Each time the preceding example calls <a href="#i1026065">FETCH_ROWS Function</a>, it fetches 10 rows that are kept in <code dir="ltr">DBMS_SQL</code> buffers. When the <a href="#i1025449">COLUMN_VALUE Procedure</a> is called, those rows move into the PL/SQL table specified (in this case <code dir="ltr">n_tab</code>), at positions -10 to -1, as specified in the <code dir="ltr">DEFINE</code> statements. When the second batch is fetched in the loop, the rows go to positions 0 to 9; and so on.</p>
<p>A current index into each array is maintained automatically. This index is initialized to &#34;indx&#34; at <code dir="ltr">EXECUTE</code> time and is updated every time <code dir="ltr">COLUMN_VALUE</code> is called. If you reexecute at any point, then the current index for each <code dir="ltr">DEFINE</code> is reinitialized to &#34;indx&#34;.</p>
<p>In this way the entire result of the query is fetched into the table. When <code dir="ltr">FETCH_ROWS</code> cannot fetch 10 rows, it returns the number of rows actually fetched (if no rows could be fetched, then it returns zero) and exits the loop.</p>
<p>Here is another example of using the <code dir="ltr">DEFINE_ARRAY</code> procedure:</p>
<p>Consider a table <code dir="ltr">MULTI_TAB</code> defined as:</p>
<pre dir="ltr">CREATE TABLE multi_tab (num NUMBER, 
                        dat1 DATE, 
                        var VARCHAR2(24), 
                        dat2 DATE) 
</pre>
<p>To select everything from this table and move it into four PL/SQL tables, you could use the following simple program:</p>
<pre dir="ltr">DECLARE
  c       NUMBER;
  d       NUMBER;
  n_tab  DBMS_SQL.NUMBER_TABLE;
  d_tab1 DBMS_SQL.DATE_TABLE;
  v_tab  DBMS_SQL.VARCHAR2_TABLE;
  d_tab2 DBMS_SQL.DATE_TABLE;
  indx NUMBER := 10;
BEGIN

  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, &#39;select * from multi_tab order by 1&#39;, DBMS_SQL.NATIVE);

  DBMS_SQL.DEFINE_ARRAY(c, 1, n_tab,  5, indx);
  DBMS_SQL.DEFINE_ARRAY(c, 2, d_tab1, 5, indx);
  DBMS_SQL.DEFINE_ARRAY(c, 3, v_tab,  5, indx);
  DBMS_SQL.DEFINE_ARRAY(c, 4, d_tab2, 5, indx);

  d := DBMS_SQL.EXECUTE(c);

  LOOP
    d := DBMS_SQL.FETCH_ROWS(c);

    DBMS_SQL.COLUMN_VALUE(c, 1, n_tab);
    DBMS_SQL.COLUMN_VALUE(c, 2, d_tab1);
    DBMS_SQL.COLUMN_VALUE(c, 3, v_tab);
    DBMS_SQL.COLUMN_VALUE(c, 4, d_tab2);
  
    EXIT WHEN d != 5;
  END LOOP;

  DBMS_SQL.CLOSE_CURSOR(c);

/* 
</pre>
<p>The four tables can be used for anything. One usage might be to use <code dir="ltr">BIND_ARRAY</code> to move the rows to another table by using a statement such as &#39;<code dir="ltr">INSERT</code> into <code dir="ltr">SOME_T</code> values (:a, :b, :c, :d);</p>
<pre dir="ltr">*/

EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/
</pre>
<p class="subhead2"><a id="i997238"></a><a id="ARPLS68205"></a>Example 8:&nbsp;Describe Columns</p>
<p>This code can be used as a substitute to the SQL*Plus <code dir="ltr">DESCRIBE</code> call by using a <code dir="ltr">SELECT</code> * query on the table that you want to describe.</p>
<pre dir="ltr">DECLARE
  c           NUMBER;
  d           NUMBER;
  col_cnt     INTEGER;
  f           BOOLEAN;
  rec_tab     DBMS_SQL.DESC_TAB;
  col_num    NUMBER;
  PROCEDURE print_rec(rec in DBMS_SQL.DESC_REC) IS
  BEGIN
    DBMS_OUTPUT.NEW_LINE;
    DBMS_OUTPUT.PUT_LINE(&#39;col_type            =    &#39;
                         || rec.col_type);
    DBMS_OUTPUT.PUT_LINE(&#39;col_maxlen          =    &#39;
                         || rec.col_max_len);
    DBMS_OUTPUT.PUT_LINE(&#39;col_name            =    &#39;
                         || rec.col_name);
    DBMS_OUTPUT.PUT_LINE(&#39;col_name_len        =    &#39;
                         || rec.col_name_len);
    DBMS_OUTPUT.PUT_LINE(&#39;col_schema_name     =    &#39;
                         || rec.col_schema_name);
    DBMS_OUTPUT.PUT_LINE(&#39;col_schema_name_len =    &#39;
                         || rec.col_schema_name_len);
    DBMS_OUTPUT.PUT_LINE(&#39;col_precision       =    &#39;
                         || rec.col_precision);
    DBMS_OUTPUT.PUT_LINE(&#39;col_scale           =    &#39;
                         || rec.col_scale);
    DBMS_OUTPUT.PUT(&#39;col_null_ok         =    &#39;);
    IF (rec.col_null_ok) THEN
      DBMS_OUTPUT.PUT_LINE(&#39;true&#39;);
    ELSE
      DBMS_OUTPUT.PUT_LINE(&#39;false&#39;);
    END IF;
  END;
BEGIN
  c := DBMS_SQL.OPEN_CURSOR;

  DBMS_SQL.PARSE(c, &#39;SELECT * FROM scott.bonus&#39;, DBMS_SQL.NATIVE);
 
  d := DBMS_SQL.EXECUTE(c);
 
  DBMS_SQL.DESCRIBE_COLUMNS(c, col_cnt, rec_tab);

/*
 * Following loop could simply be for j in 1..col_cnt loop.
 * Here we are simply illustrating some of the PL/SQL table
 * features.
 */
  col_num := rec_tab.first;
  IF (col_num IS NOT NULL) THEN
    LOOP
      print_rec(rec_tab(col_num));
      col_num := rec_tab.next(col_num);
      EXIT WHEN (col_num IS NULL);
    END LOOP;
  END IF;
 
  DBMS_SQL.CLOSE_CURSOR(c);
END;
/
</pre>
<p class="subhead2"><a id="ARPLS68206"></a>Example 9: RETURNING clause</p>
<p>With this clause, <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, and <code dir="ltr">DELETE</code> statements can return values of expressions in bind variables.</p>
<p>If a single row is inserted, updated, or deleted, then use <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">BIND_VARIABLE</code> to bind these outbinds. To get the values in these bind variables, call <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">VARIABLE_VALUE</code></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This process is similar to <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">VARIABLE_VALUE</code>, which must be called after running a PL/SQL block with an outbind inside <code dir="ltr">DBMS_SQL</code>.</div>
<p>i) Single-row insert</p>
<pre dir="ltr">      CREATE OR REPLACE PROCEDURE single_Row_insert
           (c1 NUMBER, c2 NUMBER, r OUT NUMBER) is
      c NUMBER;
      n NUMBER;
      begin
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;INSERT INTO tab VALUES (:bnd1, :bnd2) &#39; ||
                          &#39;RETURNING c1*c2 INTO :bnd3&#39;, DBMS_SQL.NATIVE);
     DBMS_SQL.BIND_VARIABLE(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd2&#39;, c2);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd3&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd3&#39;, r); -- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
 
</pre>
<p>ii) Single-row update</p>
<pre dir="ltr">      CREATE OR REPLACE PROCEDURE single_Row_update
           (c1 NUMBER, c2 NUMBER, r out NUMBER) IS
      c NUMBER;
      n NUMBER;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;UPDATE tab SET c1 = :bnd1, c2 = :bnd2 &#39; ||
                          &#39;WHERE rownum &lt; 2 &#39; || 
                          &#39;RETURNING c1*c2 INTO :bnd3&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd2&#39;, c2);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd3&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd3&#39;, r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
</pre>
<p>iii) Single-row delete</p>
<pre dir="ltr">      CREATE OR REPLACE PROCEDURE single_Row_Delete
           (c1 NUMBER, r OUT NUMBER) is
      c NUMBER;
      n number;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;DELETE FROM tab WHERE ROWNUM = :bnd1 &#39; ||
                      &#39;RETURNING c1*c2 INTO :bnd2&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd2&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd2&#39;, r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
 
</pre>
<p>iv) Multiple-row insert</p>
<pre dir="ltr">      CREATE OR REPLACE PROCEDURE multi_Row_insert
           (c1 DBMS_SQL.NUMBER_TABLE, c2 DBMS_SQL.NUMBER_TABLE, 
            r OUT DBMS_SQL.NUMBER_TABLE) is
      c NUMBER;
      n NUMBER;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;insert into tab VALUES (:bnd1, :bnd2) &#39; ||
                          &#39;RETURNING c1*c2 INTO :bnd3&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd2&#39;, c2);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd3&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd3&#39;, r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
</pre>
<p>v) Multiple-row update.</p>
<pre dir="ltr">      CREATE OR REPLACE PROCEDURE multi_Row_update
           (c1 NUMBER, c2 NUMBER, r OUT DBMS_SQL.NUMBER_TABLE) IS
      c NUMBER;
      n NUMBER;
     BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;UPDATE tab SET c1 = :bnd1 WHERE c2 = :bnd2 &#39; ||
                          &#39;RETURNING c1*c2 INTO :bnd3&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd2&#39;, c2);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd3&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd3&#39;, r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
bnd1 and bnd2 can be arrays too. The value of the expression for all the rows updated will be in bnd3. There is no way to determine which rows were updated for each value of bnd1 and bnd2.</div>
<p>vi) Multiple-row delete</p>
<pre dir="ltr">      CREATE OR REPLACE PROCEDURE multi_row_delete
           (c1 DBMS_SQL.NUMBER_TABLE,
            r OUT DBMS_SQL.NUMBER_TABLE) is
      c NUMBER;
      n NUMBER;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;DELETE FROM tab WHERE c1 = :bnd1&#39; ||
                          &#39;RETURNING c1*c2 INTO :bnd2&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd2&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd2&#39;, r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
</pre>
<p>vii) outbind in bulk PL/SQL</p>
<pre dir="ltr">      CREATE OR REPLACE PROCEDURE foo (n NUMBER, square OUT NUMBER) IS
      BEGIN square := n * n; END;/
 
      CREATE OR REPLACE PROCEDURE bulk_plsql 
         (n DBMS_SQL.NUMBER_TABLE, square OUT DBMS_SQL.NUMBER_TABLE) IS
      c NUMBER;
      r NUMBER;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;BEGIN foo(:bnd1, :bnd2); END;&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd1&#39;, n);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd2&#39;, square);
        r := DBMS_SQL.EXECUTE(c);
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd2&#39;, square);
     END;
     /
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">DBMS_SQL</code>.<code dir="ltr">BIND_ARRAY</code> of <code dir="ltr">number_Table</code> internally binds a number. The number of times statement is run depends on the number of elements in an inbind array.</div>
<p class="subhead2"><a id="ARPLS68207"></a>Example 10: Binds and Defines of User-defined Types in DBMS_SQL</p>
<pre dir="ltr">CREATE TYPE dnames_var IS VARRAY(7) OF VARCHAR2(30)
/
 
CREATE TABLE depts (region VARCHAR2(25), dept_names dnames_var)
/
 
INSERT INTO depts VALUES(&#39;Europe&#39;, dnames_var(&#39;Shipping&#39;,&#39;Sales&#39;,&#39;Finance&#39;))
/
INSERT INTO depts VALUES(&#39;Americas&#39;, dnames_var(&#39;Sales&#39;,&#39;Finance&#39;,&#39;Shipping&#39;))
/
INSERT INTO depts 
     VALUES(&#39;Asia&#39;, dnames_var(&#39;Finance&#39;,&#39;Payroll&#39;,&#39;Shipping&#39;,&#39;Sales&#39;))
/
 
CREATE OR REPLACE PROCEDURE update_depts(new_dnames dnames_var, region VARCHAR2) IS
   some_dnames dnames_var;
   c      NUMBER;
   r      NUMBER;
   sql_stmt VARCHAR2(32767) :=
    &#39;UPDATE depts SET dept_names = :b1 WHERE region = :b2 RETURNING dept_names INTO :b3&#39;;
 
BEGIN
 
   c := DBMS_SQL.OPEN_CURSOR;
 
   DBMS_SQL.PARSE(c, sql_stmt, dbms_sql.native);
 
   DBMS_SQL.BIND_VARIABLE(c, &#39;b1&#39;, new_dnames);
   DBMS_SQL.BIND_VARIABLE(c, &#39;b2&#39;, region);
   DBMS_SQL.BIND_VARIABLE(c, &#39;b3&#39;, some_dnames);
 
   r := DBMS_SQL.EXECUTE(c);
 
   -- Get value of outbind variable
   DBMS_SQL.VARIABLE_VALUE(c, &#39;b3&#39;, some_dnames);
 
   DBMS_SQL.CLOSE_CURSOR(c);
 
   -- select dept_names
   sql_stmt := &#39;SELECT dept_names FROM depts WHERE region = :b1&#39;;
 
   c := DBMS_SQL.OPEN_CURSOR;
   DBMS_SQL.PARSE(c, sql_stmt, dbms_sql.native);
 
   DBMS_SQL.DEFINE_COLUMN(c, 1, some_dnames);
   DBMS_SQL.BIND_VARIABLE(c, &#39;b1&#39;, region);
 
   r := DBMS_SQL.EXECUTE_AND_FETCH(c);
 
   DBMS_SQL.COLUMN_VALUE(c, 1, some_dnames);
 
   DBMS_SQL.CLOSE_CURSOR(c);
 
    -- loop through some_dnames collections
    FOR i IN some_dnames.FIRST .. some_dnames.LAST  LOOP
        DBMS_OUTPUT.PUT_LINE(&#39;Dept. Name = &#39; || some_dnames(i) || &#39; Updated!&#39;);
    END LOOP;
END;
/
 
DECLARE
  new_dnames dnames_var;
BEGIN
  new_dnames := dnames_var(&#39;Benefits&#39;, &#39;Advertising&#39;, &#39;Contracting&#39;, 
                           &#39;Executive&#39;, &#39;Marketing&#39;);
  update_depts(new_dnames, &#39;Asia&#39;);
END;
/
</pre></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" -->
<a id="CHDEEDCH"></a>
<div id="ARPLS68208" class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">Data Structures</h2>
<p>The <code dir="ltr">DBMS_SQL</code> package defines the following <code dir="ltr">RECORD</code> types and <code dir="ltr">TABLE</code> types.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9385"></a>RECORD Types</p>
<ul>
<li>
<p><a href="#CHDCIIBF">DESC_REC Record Type</a></p>
</li>
<li>
<p><a href="#CHDGJIHF">DESC_REC2 Record Type</a></p>
</li>
<li>
<p><a href="#CHDDFEGC">DESC_REC3 Record Type</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9386"></a>TABLE Types</p>
<ul>
<li>
<p><a href="#CHDBDAGH">BFILE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDHGBCF">BINARY_DOUBLE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDHIDEF">BINARY_FLOAT_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDFBBED">BLOB_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDBIGIC">CLOB_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDHGGFH">DATE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDFBCDE">DESC_TAB Table Type</a></p>
</li>
<li>
<p><a href="#CHDIJCJA">DESC_TAB2 Table Type</a></p>
</li>
<li>
<p><a href="#CHDBGCBE">DESC_TAB3 Table Type</a></p>
</li>
<li>
<p><a href="#CHDIGEGH">INTERVAL_DAY_TO_SECOND_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDEHFCI">INTERVAL_YEAR_TO_MONTH_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDGFFAD">NUMBER_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDJHAEC">TIME_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CIHCABIA">TIME_WITH_TIME_ZONE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDCEDDD">TIMESTAMP_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDEDCEA">TIMESTAMP_WITH_LTZ_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CIHHGCBF">TIMESTAMP_WITH_TIME_ZONE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDICIBC">UROWID_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDHHECG">VARCHAR2_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDEGGIG">VARCHAR2A Table Type</a></p>
</li>
<li>
<p><a href="#CHDICCED">VARCHAR2S Table Type</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div id="ARPLS68209" class="refsect2"><a id="CHDCIIBF"></a>
<h3 class="refsect2"><a id="sthref9387"></a>DESC_REC Record Type</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
This type has been deprecated in favor of the <a href="#CHDGJIHF">DESC_REC2 Record Type</a>.</div>
<p>This record type holds the describe information for a single column in a dynamic query. It is the element type of the <code dir="ltr">DESC_TAB</code> table type and the <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9388"></a>Syntax</p>
<pre dir="ltr">TYPE desc_rec IS RECORD (
      col_type            BINARY_INTEGER := 0,
      col_max_len         BINARY_INTEGER := 0,
      col_name            VARCHAR2(32)   := &#39;&#39;,
      col_name_len        BINARY_INTEGER := 0,
      col_schema_name     VARCHAR2(32)   := &#39;&#39;,
      col_schema_name_len BINARY_INTEGER := 0,
      col_precision       BINARY_INTEGER := 0,
      col_scale           BINARY_INTEGER := 0,
      col_charsetid       BINARY_INTEGER := 0,
      col_charsetform     BINARY_INTEGER := 0,
      col_null_ok         BOOLEAN        := TRUE);
TYPE desc_tab IS TABLE OF desc_rec INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9389"></a>Fields</p>
<div id="ARPLS68210" class="tblformal">
<p class="titleintable"><a id="sthref9390"></a><a id="sthref9391"></a>Table 149-2 DESC_REC Fields</p>
<table class="cellalignment4330" title="DESC_REC Fields" summary="This table describes the parameters of the DBMS_DEBUG.BREAKPOINT_INFO subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t10">Field</th>
<th class="cellalignment4328" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_type</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t10 r1c2-t10">
<p>Type of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_max_len</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t10 r1c2-t10">
<p>Maximum column length</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_name</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t10 r1c2-t10">
<p>Name of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_name_len</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t10 r1c2-t10">
<p>Length of column name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_schema_name</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t10 r1c2-t10">
<p>Column schema name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_schema_name_len</code></p>
</td>
<td class="cellalignment4329" headers="r7c1-t10 r1c2-t10">
<p>Length of column schema name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r8c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_precision</code></p>
</td>
<td class="cellalignment4329" headers="r8c1-t10 r1c2-t10">
<p>Precision of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r9c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_scale</code></p>
</td>
<td class="cellalignment4329" headers="r9c1-t10 r1c2-t10">
<p>Scale of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r10c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_charsetid</code></p>
</td>
<td class="cellalignment4329" headers="r10c1-t10 r1c2-t10">
<p>Column character set id</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r11c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_charsetform</code></p>
</td>
<td class="cellalignment4329" headers="r11c1-t10 r1c2-t10">
<p>Column character set form</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r12c1-t10" headers="r1c1-t10">
<p><code dir="ltr">col_null_ok</code></p>
</td>
<td class="cellalignment4329" headers="r12c1-t10 r1c2-t10">
<p><code dir="ltr">NULL</code> column flag; <code dir="ltr">TRUE</code>, if <code dir="ltr">NULL</code> possible</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68211" class="refsect2"><a id="CHDGJIHF"></a>
<h3 class="refsect2"><a id="sthref9392"></a>DESC_REC2 Record Type</h3>
<p><code dir="ltr">DESC_REC2</code> is the element type of the <code dir="ltr">DESC_TAB2</code> table type and the <a href="#i1029368">DESCRIBE_COLUMNS2 Procedure</a>.</p>
<p>This record type is identical to <code dir="ltr">DESC_REC</code> except for the <code dir="ltr">col_name</code> field, which has been expanded to the maximum possible size for <code dir="ltr">VARCHAR2</code>. It is therefore preferred to <code dir="ltr">DESC_REC</code> because column name values can be greater than 32 characters. <code dir="ltr">DESC_REC</code> is deprecated as a result.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9393"></a>Syntax</p>
<pre dir="ltr">TYPE desc_rec2 IS RECORD (
   col_type            binary_integer := 0,
   col_max_len         binary_integer := 0,
   col_name            varchar2(32767) := &#39;&#39;,
   col_name_len        binary_integer := 0,
   col_schema_name     varchar2(32)   := &#39;&#39;,
   col_schema_name_len binary_integer := 0,
   col_precision       binary_integer := 0,
   col_scale           binary_integer := 0,
   col_charsetid       binary_integer := 0,
   col_charsetform     binary_integer := 0,
   col_null_ok         boolean        := TRUE);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9394"></a>Fields</p>
<div id="ARPLS68212" class="tblformal">
<p class="titleintable"><a id="sthref9395"></a><a id="sthref9396"></a>Table 149-3 DESC_REC2 Fields</p>
<table class="cellalignment4330" title="DESC_REC2 Fields" summary="This table describes the parameters of the DBMS_DEBUG.BREAKPOINT_INFO subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t11">Field</th>
<th class="cellalignment4328" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_type</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t11 r1c2-t11">
<p>Type of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_max_len</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t11 r1c2-t11">
<p>Maximum column length</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_name</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t11 r1c2-t11">
<p>Name of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_name_len</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t11 r1c2-t11">
<p>Length of column name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_schema_name</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t11 r1c2-t11">
<p>Column schema name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_schema_name_len</code></p>
</td>
<td class="cellalignment4329" headers="r7c1-t11 r1c2-t11">
<p>Length of column schema name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r8c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_precision</code></p>
</td>
<td class="cellalignment4329" headers="r8c1-t11 r1c2-t11">
<p>Precision of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r9c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_scale</code></p>
</td>
<td class="cellalignment4329" headers="r9c1-t11 r1c2-t11">
<p>Scale of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r10c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_charsetid</code></p>
</td>
<td class="cellalignment4329" headers="r10c1-t11 r1c2-t11">
<p>Column character set id</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r11c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_charsetform</code></p>
</td>
<td class="cellalignment4329" headers="r11c1-t11 r1c2-t11">
<p>Column character set form</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r12c1-t11" headers="r1c1-t11">
<p><code dir="ltr">col_null_ok</code></p>
</td>
<td class="cellalignment4329" headers="r12c1-t11 r1c2-t11">
<p><code dir="ltr">NULL</code> column flag; <code dir="ltr">TRUE</code>, if <code dir="ltr">NULL</code> possible</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68213" class="refsect2"><a id="CHDDFEGC"></a>
<h3 class="refsect2"><a id="sthref9397"></a>DESC_REC3 Record Type</h3>
<p><code dir="ltr">DESC_REC3</code> is the element type of the <code dir="ltr">DESC_TAB3</code> table type and the <a href="#CHDJBBFH">DESCRIBE_COLUMNS3 Procedure</a>.</p>
<p><code dir="ltr">DESC_REC3</code> is identical to <code dir="ltr">DESC_REC2</code> except for two additional fields to hold the type name (<code dir="ltr">type_name</code>) and type name len (<code dir="ltr">type_name_len</code>) of a column in a dynamic query. These two fields hold the type name and type name length when the column is a user-defined type (a collection or object type). The <code dir="ltr">col_type_name</code> and <code dir="ltr">col_type_name_len</code> fields are only populated when the <code dir="ltr">col_type</code> field&#39;s value is 109, the Oracle type number for user-defined types.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9398"></a>Syntax</p>
<pre dir="ltr">TYPE desc_rec3 IS RECORD (
   col_type               binary_integer := 0,
   col_max_len            binary_integer := 0,
   col_name               varchar2(32767) := &#39;&#39;,
   col_name_len           binary_integer := 0,
   col_schema_name        varchar2(32) := &#39;&#39;,
   col_schema_name_len    binary_integer := 0,
   col_precision          binary_integer := 0,
   col_scale              binary_integer := 0,
   col_charsetid          binary_integer := 0,
   col_charsetform        binary_integer := 0,
   col_null_ok            boolean := TRUE,
   col_type_name          varchar2(32767)   := &#39;&#39;,
   col_type_name_len      binary_integer := 0);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9399"></a>Fields</p>
<div id="ARPLS68214" class="tblformal">
<p class="titleintable"><a id="sthref9400"></a><a id="sthref9401"></a>Table 149-4 DESC_REC3 Fields</p>
<table class="cellalignment4330" title="DESC_REC3 Fields" summary="This table describes the parameters of the DBMS_DEBUG.BREAKPOINT_INFO subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t12">Field</th>
<th class="cellalignment4328" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_type</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t12 r1c2-t12">
<p>Type of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_max_len</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t12 r1c2-t12">
<p>Maximum column length</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_name</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t12 r1c2-t12">
<p>Name of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_name_len</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t12 r1c2-t12">
<p>Length of column name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_schema_name</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t12 r1c2-t12">
<p>Column schema name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_schema_name_len</code></p>
</td>
<td class="cellalignment4329" headers="r7c1-t12 r1c2-t12">
<p>Length of column schema name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r8c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_precision</code></p>
</td>
<td class="cellalignment4329" headers="r8c1-t12 r1c2-t12">
<p>Precision of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r9c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_scale</code></p>
</td>
<td class="cellalignment4329" headers="r9c1-t12 r1c2-t12">
<p>Scale of column</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r10c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_charsetid</code></p>
</td>
<td class="cellalignment4329" headers="r10c1-t12 r1c2-t12">
<p>Column character set ID</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r11c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_charsetform</code></p>
</td>
<td class="cellalignment4329" headers="r11c1-t12 r1c2-t12">
<p>Column character set form</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r12c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_null_ok</code></p>
</td>
<td class="cellalignment4329" headers="r12c1-t12 r1c2-t12">
<p><code dir="ltr">NULL</code> column flag; <code dir="ltr">TRUE</code>, if <code dir="ltr">NULL</code> possible</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r13c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_type_name</code></p>
</td>
<td class="cellalignment4329" headers="r13c1-t12 r1c2-t12">
<p>User-define type column type name, this field is valid when <code dir="ltr">col_type</code> is 109</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r14c1-t12" headers="r1c1-t12">
<p><code dir="ltr">col_type_name_len</code></p>
</td>
<td class="cellalignment4329" headers="r14c1-t12 r1c2-t12">
<p>Length of user-define type column type name, this field is valid when <code dir="ltr">col_type</code> is 109</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68215" class="refsect2"><a id="CHDBDAGH"></a>
<h3 class="refsect2"><a id="sthref9402"></a>BFILE_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">BFILE</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9403"></a>Syntax</p>
<pre dir="ltr">TYPE bfile_table IS TABLE OF BFILE INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68216" class="refsect2"><a id="CHDHGBCF"></a>
<h3 class="refsect2"><a id="sthref9404"></a>BINARY_DOUBLE_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">BINARY_DOUBLE</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9405"></a>Syntax</p>
<pre dir="ltr">TYPE binary_double_table IS TABLE OF BINARY_DOUBLE INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68217" class="refsect2"><a id="CHDHIDEF"></a>
<h3 class="refsect2"><a id="sthref9406"></a>BINARY_FLOAT_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">BINARY_FLOAT</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9407"></a>Syntax</p>
<pre dir="ltr">TYPE binary_float_table IS TABLE OF BINARY_FLOAT INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68218" class="refsect2"><a id="CHDFBBED"></a>
<h3 class="refsect2"><a id="sthref9408"></a>BLOB_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">BLOB</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9409"></a>Syntax</p>
<pre dir="ltr">TYPE blob_table IS TABLE OF BLOB INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68219" class="refsect2"><a id="CHDBIGIC"></a>
<h3 class="refsect2"><a id="sthref9410"></a>CLOB_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">CLOB</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9411"></a>Syntax</p>
<pre dir="ltr">TYPE clob_table IS TABLE OF CLOB INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68220" class="refsect2"><a id="CHDHGGFH"></a>
<h3 class="refsect2"><a id="sthref9412"></a>DATE_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">DATE</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9413"></a>Syntax</p>
<pre dir="ltr">type date_table IS TABLE OF DATE INDEX BY BINARY_INTEGER; 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68221" class="refsect2"><a id="CHDFBCDE"></a>
<h3 class="refsect2"><a id="sthref9414"></a>DESC_TAB Table Type</h3>
<p>This is a table of <a href="#CHDCIIBF">DESC_REC Record Type</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9415"></a>Syntax</p>
<pre dir="ltr">TYPE desc_tab IS TABLE OF desc_rec INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68222" class="refsect2"><a id="CHDIJCJA"></a>
<h3 class="refsect2"><a id="sthref9416"></a>DESC_TAB2 Table Type</h3>
<p>This is a table of <a href="#CHDGJIHF">DESC_REC2 Record Type</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9417"></a>Syntax</p>
<pre dir="ltr">TYPE desc_tab2 IS TABLE OF desc_rec2 INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68223" class="refsect2"><a id="CHDBGCBE"></a>
<h3 class="refsect2"><a id="sthref9418"></a>DESC_TAB3 Table Type</h3>
<p>This is a table of <a href="#CHDDFEGC">DESC_REC3 Record Type</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9419"></a>Syntax</p>
<pre dir="ltr">TYPE desc_tab3 IS TABLE OF desc_rec3 INDEX BY BINARY_INTEGER; 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68224" class="refsect2"><a id="CHDIGEGH"></a>
<h3 class="refsect2"><a id="sthref9420"></a>INTERVAL_DAY_TO_SECOND_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">DSINTERVAL_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9421"></a>Syntax</p>
<pre dir="ltr"> TYPE interval_day_to_second_Table IS TABLE OF
    DSINTERVAL_UNCONSTRAINED INDEX BY binary_integer;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68225" class="refsect2"><a id="CHDEHFCI"></a>
<h3 class="refsect2"><a id="sthref9422"></a>INTERVAL_YEAR_TO_MONTH_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">YMINTERVAL_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9423"></a>Syntax</p>
<pre dir="ltr">TYPE interval_year_to_month_table IS TABLE OF YMINTERVAL_UNCONSTRAINED 
   INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68226" class="refsect2"><a id="CHDGFFAD"></a>
<h3 class="refsect2"><a id="sthref9424"></a>NUMBER_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">NUMBER</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9425"></a>Syntax</p>
<pre dir="ltr">TYPE number_table IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68227" class="refsect2"><a id="CHDJHAEC"></a>
<h3 class="refsect2"><a id="sthref9426"></a>TIME_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">TIME_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9427"></a>Syntax</p>
<pre dir="ltr">TYPE time_table IS TABLE OF TIME_UNCONSTRAINED INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68228" class="refsect2"><a id="CIHCABIA"></a>
<h3 class="refsect2"><a id="sthref9428"></a>TIME_WITH_TIME_ZONE_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">TIME_TZ_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9429"></a>Syntax</p>
<pre dir="ltr">TYPE time_with_time_zone_table IS TABLE OF TIME_TZ_UNCONSTRAINED 
   INDEX BY BINARY_INTEGER;;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68229" class="refsect2"><a id="CHDCEDDD"></a>
<h3 class="refsect2"><a id="sthref9430"></a>TIMESTAMP_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">TIMESTAMP_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9431"></a>Syntax</p>
<pre dir="ltr">TYPE timestamp_table IS TABLE OF TIMESTAMP_UNCONSTRAINED INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68230" class="refsect2"><a id="CHDEDCEA"></a>
<h3 class="refsect2"><a id="sthref9432"></a>TIMESTAMP_WITH_LTZ_TABLE Table Type</h3>
<p>This is a table of TIMESTAMP_LTZ_UNCONSTRAINED</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9433"></a>Syntax</p>
<pre dir="ltr">TYPE timestamp_with_ltz_table IS TABLE OF
    TIMESTAMP_LTZ_UNCONSTRAINED INDEX BY binary_integer;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68231" class="refsect2"><a id="CIHHGCBF"></a>
<h3 class="refsect2"><a id="sthref9434"></a>TIMESTAMP_WITH_TIME_ZONE_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">TIMESTAMP_TZ_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9435"></a>Syntax</p>
<pre dir="ltr">TYPE timestamp_with_time_zone_Table IS TABLE OF 
    TIMESTAMP_TZ_UNCONSTRAINED INDEX BY binary_integer;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68232" class="refsect2"><a id="CHDICIBC"></a>
<h3 class="refsect2"><a id="sthref9436"></a>UROWID_TABLE Table Type</h3>
<p>This is a table of <code dir="ltr">UROWID</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9437"></a>Syntax</p>
<pre dir="ltr">TYPE urowid_table IS TABLE OF UROWID INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68233" class="refsect2"><a id="CHDHHECG"></a>
<h3 class="refsect2"><a id="sthref9438"></a>VARCHAR2_TABLE Table Type</h3>
<p>This is table of <code dir="ltr">VARCHAR2(2000)</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9439"></a>Syntax</p>
<pre dir="ltr">TYPE varchar2_table IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68234" class="refsect2"><a id="CHDEGGIG"></a>
<h3 class="refsect2"><a id="sthref9440"></a>VARCHAR2A Table Type</h3>
<p>This is table of <code dir="ltr">VARCHAR2(32767)</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9441"></a>Syntax</p>
<pre dir="ltr">TYPE varchar2a IS TABLE OF VARCHAR2(32767) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68235" class="refsect2"><a id="CHDICCED"></a>
<h3 class="refsect2"><a id="sthref9442"></a>VARCHAR2S Table Type</h3>
<p>This is table of <code dir="ltr">VARCHAR2(256)</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This type has been superseded by the <a href="#CHDEGGIG">VARCHAR2A Table Type</a>. Although it is currently retained for backward compatibility of legacy code, it is in the process of deprecation and will be de-supported in a future release.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9443"></a>Syntax</p>
<pre dir="ltr">TYPE varchar2s IS TABLE OF VARCHAR2(256) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" -->
<a id="i997453"></a>
<div id="ARPLS68236" class="refsect1">
<h2 class="refsect1">Summary of DBMS_SQL Subprograms</h2>
<div id="ARPLS68237" class="tblformal">
<p class="titleintable"><a id="sthref9444"></a><a id="sthref9445"></a>Table 149-5 <span class="bold">DBMS_SQL</span> Package Subprograms</p>
<table class="cellalignment4330" title="DBMS_SQL Package Subprograms" summary="This table lists the DBMS_SQL subprograms in alphabetical order and briefly describes them." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t14">Subprogram</th>
<th class="cellalignment4328" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t14" headers="r1c1-t14">
<p><a href="#i1025085">BIND_ARRAY Procedures</a></p>
</td>
<td class="cellalignment4329" headers="r2c1-t14 r1c2-t14">
<p>Binds a given value to a given collection</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t14" headers="r1c1-t14">
<p><a href="#i1030093">BIND_VARIABLE Procedures</a></p>
</td>
<td class="cellalignment4329" headers="r3c1-t14 r1c2-t14">
<p>Binds a given value to a given variable</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t14" headers="r1c1-t14">
<p><a href="#i1026299">CLOSE_CURSOR Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r4c1-t14 r1c2-t14">
<p>Closes given cursor and frees memory</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t14" headers="r1c1-t14">
<p><a href="#i1025449">COLUMN_VALUE Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r5c1-t14 r1c2-t14">
<p>Returns value of the cursor element for a given position in a cursor</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t14" headers="r1c1-t14">
<p><a href="#i1025399">COLUMN_VALUE_LONG Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r6c1-t14 r1c2-t14">
<p>Returns a selected part of a <code dir="ltr">LONG</code> column, that has been defined using <code dir="ltr">DEFINE_COLUMN_LONG</code></p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t14" headers="r1c1-t14">
<p><a href="#i1025685">DEFINE_ARRAY Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r7c1-t14 r1c2-t14">
<p>Defines a collection to be selected from the given cursor, used only with <code dir="ltr">SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r8c1-t14" headers="r1c1-t14">
<p><a href="#i1025686">DEFINE_COLUMN Procedures</a></p>
</td>
<td class="cellalignment4329" headers="r8c1-t14 r1c2-t14">
<p>Defines a column to be selected from the given cursor, used only with <code dir="ltr">SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r9c1-t14" headers="r1c1-t14">
<p><a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r9c1-t14 r1c2-t14">
<p>Defines a column of type <code dir="ltr">CHAR</code> to be selected from the given cursor, used only with <code dir="ltr">SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r10c1-t14" headers="r1c1-t14">
<p><a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r10c1-t14 r1c2-t14">
<p>Defines a <code dir="ltr">LONG</code> column to be selected from the given cursor, used only with <code dir="ltr">SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r11c1-t14" headers="r1c1-t14">
<p><a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r11c1-t14 r1c2-t14">
<p>Defines a column of type <code dir="ltr">RAW</code> to be selected from the given cursor, used only with <code dir="ltr">SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r12c1-t14" headers="r1c1-t14">
<p><a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r12c1-t14 r1c2-t14">
<p>Defines a column of type <code dir="ltr">ROWID</code> to be selected from the given cursor, used only with <code dir="ltr">SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r13c1-t14" headers="r1c1-t14">
<p><a href="#i1026120">DESCRIBE_COLUMNS Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r13c1-t14 r1c2-t14">
<p>Describes the columns for a cursor opened and parsed through <code dir="ltr">DBMS_SQL</code></p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r14c1-t14" headers="r1c1-t14">
<p><a href="#i1029368">DESCRIBE_COLUMNS2 Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r14c1-t14 r1c2-t14">
<p>Describes describes the specified column, an alternative to <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a></p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r15c1-t14" headers="r1c1-t14">
<p><a href="#CHDJBBFH">DESCRIBE_COLUMNS3 Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r15c1-t14 r1c2-t14">
<p>Describes describes the specified column, an alternative to <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a></p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r16c1-t14" headers="r1c1-t14">
<p><a href="#i1025983">EXECUTE Function</a></p>
</td>
<td class="cellalignment4329" headers="r16c1-t14 r1c2-t14">
<p>Executes a given cursor</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r17c1-t14" headers="r1c1-t14">
<p><a href="#i1025711">EXECUTE_AND_FETCH Function</a></p>
</td>
<td class="cellalignment4329" headers="r17c1-t14 r1c2-t14">
<p>Executes a given cursor and fetch rows</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r18c1-t14" headers="r1c1-t14">
<p><a href="#i1026065">FETCH_ROWS Function</a></p>
</td>
<td class="cellalignment4329" headers="r18c1-t14 r1c2-t14">
<p>Fetches a row from a given cursor</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r19c1-t14" headers="r1c1-t14">
<p><a href="#CIHEBDFJ">GET_NEXT_RESULT Procedures</a></p>
</td>
<td class="cellalignment4329" headers="r19c1-t14 r1c2-t14">
<p>Gets the statement of the next result returned to the caller of the recursive statement or, if this caller sets itself as the client for the recursive statement, the next result returned to this caller as client</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r20c1-t14" headers="r1c1-t14">
<p><a href="#i1026423">IS_OPEN Function</a></p>
</td>
<td class="cellalignment4329" headers="r20c1-t14 r1c2-t14">
<p>Returns <code dir="ltr">TRUE</code> if given cursor is open</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r21c1-t14" headers="r1c1-t14">
<p><a href="#i1026408">LAST_ERROR_POSITION Function</a></p>
</td>
<td class="cellalignment4329" headers="r21c1-t14 r1c2-t14">
<p>Returns byte offset in the SQL statement text where the error occurred</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r22c1-t14" headers="r1c1-t14">
<p><a href="#i1026354">LAST_ROW_COUNT Function</a></p>
</td>
<td class="cellalignment4329" headers="r22c1-t14 r1c2-t14">
<p>Returns cumulative count of the number of rows fetched</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r23c1-t14" headers="r1c1-t14">
<p><a href="#i1026364">LAST_ROW_ID Function</a></p>
</td>
<td class="cellalignment4329" headers="r23c1-t14 r1c2-t14">
<p>Returns <code dir="ltr">ROWID</code> of last row processed</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r24c1-t14" headers="r1c1-t14">
<p><a href="#i1026374">LAST_SQL_FUNCTION_CODE Function</a></p>
</td>
<td class="cellalignment4329" headers="r24c1-t14 r1c2-t14">
<p>Returns SQL function code for statement</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r25c1-t14" headers="r1c1-t14">
<p><a href="#i997665">OPEN_CURSOR Functions</a></p>
</td>
<td class="cellalignment4329" headers="r25c1-t14 r1c2-t14">
<p>Returns cursor ID number of new cursor</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r26c1-t14" headers="r1c1-t14">
<p><a href="#i997676">PARSE Procedures</a></p>
</td>
<td class="cellalignment4329" headers="r26c1-t14 r1c2-t14">
<p>Parses given statement</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r27c1-t14" headers="r1c1-t14">
<p><a href="#CIHIICAG">RETURN_RESULT Procedures</a></p>
</td>
<td class="cellalignment4329" headers="r27c1-t14 r1c2-t14">
<p>Returns the result of an executed statement to the client application</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r28c1-t14" headers="r1c1-t14">
<p><a href="#CHDJDGDG">TO_CURSOR_NUMBER Function</a></p>
</td>
<td class="cellalignment4329" headers="r28c1-t14 r1c2-t14">
<p>Takes an <code dir="ltr">OPEN</code>ed strongly or weakly-typed ref cursor and transforms it into a <code dir="ltr">DBMS_SQL</code> cursor number</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r29c1-t14" headers="r1c1-t14">
<p><a href="#CHDFDCDE">TO_REFCURSOR Function</a></p>
</td>
<td class="cellalignment4329" headers="r29c1-t14 r1c2-t14">
<p>Takes an <code dir="ltr">OPEN</code>ed, <code dir="ltr">PARSE</code>d, and <code dir="ltr">EXECUTE</code>d cursor and transforms/migrates it into a PL/SQL manageable <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> (a weakly-typed cursor) that can be consumed by PL/SQL native dynamic SQL switched to use native dynamic SQL</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r30c1-t14" headers="r1c1-t14">
<p><a href="#i998371">VARIABLE_VALUE Procedures</a></p>
</td>
<td class="cellalignment4329" headers="r30c1-t14 r1c2-t14">
<p>Returns value of named variable for given cursor</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="ARPLS68238" class="refsect2"><a id="i1025085"></a>
<h3 class="refsect2"><a id="sthref9446"></a>BIND_ARRAY Procedures</h3>
<p>This procedure binds a given value or set of values to a given variable in a cursor, based on the name of the variable in the statement.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9447"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.BIND_ARRAY ( 
   c                   IN INTEGER, 
   name                IN VARCHAR2, 
   &lt;table_variable&gt;    IN &lt;datatype&gt; 
 [,index1              IN INTEGER, 
   index2              IN INTEGER)] ); 
</pre>
<p>Where the &lt;<code dir="ltr">table_variable</code>&gt; and its corresponding &lt;<code dir="ltr">datatype</code>&gt; can be any one of the following matching pairs:</p>
<pre dir="ltr">&lt;clob_tab&gt;     Clob_Table
&lt;bflt_tab&gt;     Binary_Float_Table
&lt;bdbl_tab&gt;     Binary_Double_Table
&lt;blob_tab&gt;     Blob_Table
&lt;bfile_tab&gt;    Bfile_Table
&lt;date_tab&gt;     Date_Table
&lt;num_tab&gt;      Number_Table
&lt;urowid_tab&gt;   Urowid_Table
&lt;vchr2_tab&gt;    Varchar2_Table
&lt;tm_tab&gt;       Time_Table
&lt;ttz_tab&gt;      Time_With_Time_Zone_Table
&lt;tms_tab&gt;      Timestamp_Table
&lt;tstz_tab&gt;     Timestamp_With_ltz_Table;
&lt;tstz_tab&gt;     Timestamp_With_Time_Zone_Table
&lt;ids_tab&gt;      Interval_Day_To_Second_Table
&lt;iym_tab&gt;      Interval_Year_To_Month_Table
</pre>
<p>Notice that the <code dir="ltr">BIND_ARRAY</code> procedure is overloaded to accept different Datatype.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9448"></a>Parameters</p>
<div id="ARPLS68239" class="tblformal">
<p class="titleintable"><a id="sthref9449"></a><a id="sthref9450"></a>Table 149-6 BIND_ARRAY Procedure Parameters</p>
<table class="cellalignment4330" title="BIND_ARRAY Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.BIND_ARRAY subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t15">Parameter</th>
<th class="cellalignment4328" id="r1c2-t15">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t15" headers="r1c1-t15">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t15 r1c2-t15">
<p>ID number of the cursor to which you want to bind a value.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t15" headers="r1c1-t15">
<p><code dir="ltr">name</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t15 r1c2-t15">
<p>Name of the collection in the statement.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t15" headers="r1c1-t15">
<p><code dir="ltr">table_variable</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t15 r1c2-t15">
<p>Local variable that has been declared as &lt;<code dir="ltr">datatype</code>&gt;.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t15" headers="r1c1-t15">
<p><code dir="ltr">index1</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t15 r1c2-t15">
<p>Index for the table element that marks the lower bound of the range.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t15" headers="r1c1-t15">
<p><code dir="ltr">index2</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t15 r1c2-t15">
<p>Index for the table element that marks the upper bound of the range.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9451"></a>Usage Notes</p>
<p>The length of the bind variable name must be &lt;=30 bytes.</p>
<p>For binding a range, the table must contain the elements that specify the range &mdash; tab(index1) and tab(index2) &mdash; but the range does not have to be dense. Index1 must be less than or equal to index2. All elements between tab(index1) and tab(index2) are used in the bind.</p>
<p>If you do not specify indexes in the bind call, and two different binds in a statement specify tables that contain a different number of elements, then the number of elements actually used is the minimum number between all tables. This is also the case if you specify indexes &mdash; the minimum range is selected between the two indexes for all tables.</p>
<p>Not all bind variables in a query have to be array binds. Some can be regular binds and the same value are used for each element of the collections in expression evaluations (and so forth).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997061">&#34;Examples 3, 4, and 5:&nbsp;Bulk DML&#34;</a> for examples of how to bind collections.</div>
<p class="subhead2"><a id="ARPLS68240"></a>Bulk Array Binds</p>
<p><a id="sthref9452"></a>Bulk selects, inserts, updates, and deletes can enhance the performance of applications by bundling many calls into one. The <code dir="ltr">DBMS_SQL</code> package lets you work on collections of data using the PL/SQL table type.</p>
<p><span class="italic"><a id="sthref9453"></a><a id="sthref9454"></a>Table items</span> are unbounded homogeneous collections. In persistent storage, they are like other relational tables and have no intrinsic ordering. But when a table item is brought into the workspace (either by querying or by navigational access of persistent data), or when it is created as the value of a PL/SQL variable or parameter, its elements are given subscripts that can be used with array-style syntax to get and set the values of elements.</p>
<p>The subscripts of these elements need not be dense, and can be any number including negative numbers. For example, a table item can contain elements at locations -10, 2, and 7 only.</p>
<p>When a table item is moved from transient workspace to persistent storage, the subscripts are not stored; the table item is unordered in persistent storage.</p>
<p>At bind time the table is copied out from the PL/SQL buffers into local <code dir="ltr">DBMS_SQL</code> buffers (the same as for all scalar types) and then the table is manipulated from the local <code dir="ltr">DBMS_SQL</code> buffers. Therefore, if you change the table after the bind call, then that change does not affect the way the execute acts.</p>
<p class="subhead2"><a id="ARPLS68241"></a>Types for Scalar and LOB Collections</p>
<p>You can declare a local variable as one of the following table-item types, which are defined as public types in <code dir="ltr">DBMS_SQL</code>.</p>
<pre dir="ltr">TYPE binary_double_table 
                    IS TABLE OF BINARY_DOUBLE  INDEX BY BINARY_INTEGER;
TYPE binary_float_table 
                    IS TABLE OF BINARY_FLOAT   INDEX BY BINARY_INTEGER;
TYPE bfile_table    IS TABLE OF BFILE          INDEX BY BINARY_INTEGER;
TYPE blob_table     IS TABLE OF BLOB           INDEX BY BINARY_INTEGER;
TYPE clob_table     IS TABLE OF CLOB           INDEX BY BINARY_INTEGER;
TYPE date_table     IS TABLE OF DATE           INDEX BY BINARY_INTEGER;
TYPE interval_day_to_second_Table 
                    IS TABLE OF dsinterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE interval_year_to_MONTH_Table 
                    IS TABLE OF yminterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE number_table   IS TABLE OF NUMBER         INDEX BY BINARY_INTEGER;
TYPE time_table     IS TABLE OF time_unconstrained           
                                               INDEX BY BINARY_INTEGER;
TYPE time_with_time_zone_table 
                    IS TABLE OF time_tz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_table 
                    IS TABLE OF timestamp_unconstrained   
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_with_ltz_Table 
                    IS TABLE OF timestamp_ltz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_with_time_zone_Table 
                    IS TABLE OF timestamp_tz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE urowid_table   IS TABLE OF UROWID         INDEX BY BINARY_INTEGER;
TYPE varchar2_table IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68242" class="refsect2"><a id="i1030093"></a>
<h3 class="refsect2"><a id="sthref9455"></a>BIND_VARIABLE Procedures</h3>
<p>This procedures binds a given value or set of values to a given variable in a cursor, based on the name of the variable in the statement.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9456"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.BIND_VARIABLE (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN &lt;datatype&gt;);
</pre>
<p>Where &lt;datatype&gt; can be any one of the following types:</p>
<pre dir="ltr">BINARY_DOUBLE
BINARY_FLOAT
BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
DSINTERVAL_UNCONSTRAINED
NUMBER
TIME_UNCONSTRAINED
TIME_TZ_UNCONSTRAINED
TIMESTAMP_LTZ_UNCONSTRAINED
TIMESTAMP_TZ_UNCONSTRAINED
TIMESTAMP_UNCONSTRAINED
UROWID
VARCHAR2 CHARACTER SET ANY_CS
YMINTERVAL_UNCONSTRAINED
user-defined object types
collections (VARRAYs and nested tables)
REFs
Opaque types
</pre>
<p>Notice that <code dir="ltr">BIND_VARIABLE</code> is overloaded to accept different Datatype.</p>
<p>The following syntax is also supported for <code dir="ltr">BIND_VARIABLE</code>. The square brackets [] indicate an optional parameter for the <code dir="ltr">BIND_VARIABLE</code> function.</p>
<pre dir="ltr">DBMS_SQL.BIND_VARIABLE (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN VARCHAR2 CHARACTER SET ANY_CS [,out_value_size IN INTEGER]);
</pre>
<p>To bind <code dir="ltr">CHAR</code>, <code dir="ltr">RAW</code>, and <code dir="ltr">ROWID</code> data, you can use the following variations on the syntax:</p>
<pre dir="ltr">DBMS_SQL.BIND_VARIABLE_CHAR (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN CHAR CHARACTER SET ANY_CS [,out_value_size IN INTEGER]);

DBMS_SQL.BIND_VARIABLE_RAW (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN RAW [,out_value_size IN INTEGER]);

DBMS_SQL.BIND_VARIABLE_ROWID (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN ROWID);
</pre>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9457"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(bind_variable,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9458"></a>Parameters</p>
<div id="ARPLS68243" class="tblformal">
<p class="titleintable"><a id="sthref9459"></a><a id="sthref9460"></a>Table 149-7 BIND_VARIABLE Procedure Parameters</p>
<table class="cellalignment4330" title="BIND_VARIABLE Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.BIND_VARIABLE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t18">Parameter</th>
<th class="cellalignment4328" id="r1c2-t18">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t18" headers="r1c1-t18">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t18 r1c2-t18">
<p>ID number of the cursor to which you want to bind a value.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t18" headers="r1c1-t18">
<p><code dir="ltr">name</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t18 r1c2-t18">
<p>Name of the variable in the statement.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t18" headers="r1c1-t18">
<p><code dir="ltr">value</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t18 r1c2-t18">
<p>Value that you want to bind to the variable in the cursor.</p>
<p>For <code dir="ltr">IN</code> and <code dir="ltr">IN</code>/<code dir="ltr">OUT</code> variables, the value has the same type as the type of the value being passed in for this parameter.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t18" headers="r1c1-t18">
<p><code dir="ltr">out_value_size</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t18 r1c2-t18">
<p>Maximum expected <code dir="ltr">OUT</code> value size, in bytes, for the <code dir="ltr">VARCHAR2</code>, <code dir="ltr">RAW</code>, <code dir="ltr">CHAR</code> <code dir="ltr">OUT</code> or <code dir="ltr">IN</code>/<code dir="ltr">OUT</code> variable.</p>
<p>If no size is given, then the length of the current value is used. This parameter must be specified if the <code dir="ltr">value</code> parameter is not initialized.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9461"></a>Usage Notes</p>
<p>If the variable is an <code dir="ltr">IN</code> or <code dir="ltr">IN</code>/<code dir="ltr">OUT</code> variable or an <code dir="ltr">IN</code> collection, then the given bind value must be valid for the variable or array type. Bind values for <code dir="ltr">OUT</code> variables are ignored.</p>
</div>
<!-- class="refsubsect" -->
<p>The bind variables or collections of a SQL statement are identified by their names. When binding a value to a bind variable or bind array, the string identifying it in the statement must contain a leading colon, as shown in the following example:</p>
<pre dir="ltr">SELECT emp_name FROM emp WHERE SAL &gt; :X;
</pre>
<p>For this example, the corresponding bind call would look similar to</p>
<pre dir="ltr">BIND_VARIABLE(cursor_name, &#39;:X&#39;, 3500); 

or

BIND_VARIABLE (cursor_name, &#39;X&#39;, 3500);
</pre>
<p>The length of the bind variable name must be &lt;=30 bytes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997061">&#34;Examples 3, 4, and 5:&nbsp;Bulk DML&#34;</a> for examples of how to bind collections.</div>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68244" class="refsect2"><a id="i1026299"></a>
<h3 class="refsect2"><a id="sthref9462"></a>CLOSE_CURSOR Procedure</h3>
<p>This procedure closes a given cursor.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9463"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.CLOSE_CURSOR (
   c    IN OUT INTEGER);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9464"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(close_cursor,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9465"></a>Parameters</p>
<div id="ARPLS68245" class="tblformal">
<p class="titleintable"><a id="sthref9466"></a><a id="sthref9467"></a>Table 149-8 CLOSE_CURSOR Procedure Parameters</p>
<table class="cellalignment4330" title="CLOSE_CURSOR Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.CLOSE_CURSOR subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t20">Parameter</th>
<th class="cellalignment4328" id="r1c2-t20">Mode</th>
<th class="cellalignment4328" id="r1c3-t20">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t20" headers="r1c1-t20">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t20 r1c2-t20">
<p><code dir="ltr">IN</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t20 r1c3-t20">
<p>ID number of the cursor that you want to close.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t20" headers="r1c1-t20">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t20 r1c2-t20">
<p><code dir="ltr">OUT</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t20 r1c3-t20">
<p>Cursor is set to null.</p>
<p>After you call <code dir="ltr">CLOSE_CURSOR</code>, the memory allocated to the cursor is released and you can no longer fetch from that cursor.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68246" class="refsect2"><a id="i1025449"></a>
<h3 class="refsect2"><a id="sthref9468"></a>COLUMN_VALUE Procedure</h3>
<p>This procedure returns the value of the cursor element for a given position in a given cursor. This procedure is used to access the data fetched by calling <code dir="ltr">FETCH_ROWS</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9469"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.COLUMN_VALUE (
   c                 IN  INTEGER,
   position          IN  INTEGER,
   value             OUT &lt;datatype&gt; 
 [,column_error      OUT NUMBER] 
 [,actual_length     OUT INTEGER]);
</pre>
<p>Where square brackets [ ] indicate optional parameters and &lt;<code dir="ltr">datatype</code>&gt; can be any one of the following types:</p>
<pre dir="ltr">BINARY_DOUBLE
BINARY_FLOAT
BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
DSINTERVAL_UNCONSTRAINED
NUMBER
TIME_TZ_UNCONSTRAINED
TIME_UNCONSTRAINED
TIMESTAMP_LTZ_UNCONSTRAINED
TIMESTAMP_TZ_UNCONSTRAINED
TIMESTAMP_UNCONSTRAINED
UROWID
VARCHAR2 CHARACTER SET ANY_CS
YMINTERVAL_UNCONSTRAINED
user-defined object types
collections (VARRAYs and nested tables)
REFs
Opaque types
</pre></div>
<!-- class="refsubsect" -->
<p>For variables containing <code dir="ltr">CHAR</code>, <code dir="ltr">RAW</code>, and <code dir="ltr">ROWID</code> data, you can use the following variations on the syntax:</p>
<pre dir="ltr">DBMS_SQL.COLUMN_VALUE_CHAR (
   c               IN  INTEGER,
   position        IN  INTEGER,
   value           OUT CHAR CHARACTER SET ANY_CS
 [,column_error    OUT NUMBER]
 [,actual_length   OUT INTEGER]);
 
DBMS_SQL.COLUMN_VALUE_RAW (
   c               IN  INTEGER,
   position        IN  INTEGER,
   value           OUT RAW
 [,column_error    OUT NUMBER]
 [,actual_length   OUT INTEGER]);

DBMS_SQL.COLUMN_VALUE_ROWID (
   c               IN  INTEGER,
   position        IN  INTEGER,
   value           OUT ROWID
 [,column_error    OUT NUMBER]
 [,actual_length   OUT INTEGER]);
</pre>
<p>The following syntax enables the <code dir="ltr">COLUMN_VALUE</code> procedure to accommodate bulk operations:</p>
<pre dir="ltr">DBMS_SQL.COLUMN_VALUE( 
   c                 IN             INTEGER, 
   position          IN             INTEGER, 
   &lt;param_name&gt;      IN OUT NOCOPY  &lt;table_type&gt;);  
</pre>
<p>Where the &lt;<code dir="ltr">param_name</code>&gt; and its corresponding &lt;<code dir="ltr">table_type</code>&gt; can be any one of these matching pairs:</p>
<pre dir="ltr">bdbl_tab     Binary_Double_Table
bflt_tab     Binary_Float_Table
bf_tab       Bfile_Table
bl_tab       Blob_Table
cl_tab       Clob_Table
d_tab        Date_Table
ids_tab      Interval_Day_To_Second_Table
iym_tab      Interval_Year_To_Month_Table
n_tab        Number_Table
tm_tab       Time_Table
ttz_tab      Time_With_Time_Zone_Table
tms_tab      Timestamp_Table
tstz_tab     Timestamp_With_ltz_Table;
tstz_tab     Timestamp_With_Time_Zone_Table
ur_tab       Urowid_Table
c_tab        Varchar2_Table
</pre>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9470"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(column_value,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9471"></a>Parameters</p>
<div id="ARPLS68247" class="tblformal">
<p class="titleintable"><a id="sthref9472"></a><a id="sthref9473"></a>Table 149-9 COLUMN_VALUE Procedure Parameters (Single Row)</p>
<table class="cellalignment4330" title="COLUMN_VALUE Procedure Parameters (Single Row)" summary="This table describes Parameters used by the DBMS_SQL.COLUMN_VALUE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t21">Parameter</th>
<th class="cellalignment4328" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t21" headers="r1c1-t21">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t21 r1c2-t21">
<p>ID number of the cursor from which you are fetching the values.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t21" headers="r1c1-t21">
<p><code dir="ltr">position</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t21 r1c2-t21">
<p>Relative position of the column in the cursor.</p>
<p>The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t21" headers="r1c1-t21">
<p><code dir="ltr">value</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t21 r1c2-t21">
<p>Returns the value at the specified column.</p>
<p>Oracle raises exception <code dir="ltr">ORA-06562</code>, <code dir="ltr">inconsistent_type</code>, if the type of this output parameter differs from the actual type of the value, as defined by the call to <code dir="ltr">DEFINE_COLUMN</code>.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t21" headers="r1c1-t21">
<p><code dir="ltr">column_error</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t21 r1c2-t21">
<p>Returns any error code for the specified column value.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t21" headers="r1c1-t21">
<p><code dir="ltr">actual_length</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t21 r1c2-t21">
<p>The actual length, before any truncation, of the value in the specified column.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="ARPLS68248" class="tblformal">
<p class="titleintable"><a id="sthref9474"></a><a id="sthref9475"></a>Table 149-10 COLUMN_VALUE Procedure Parameters (Bulk)</p>
<table class="cellalignment4330" title="COLUMN_VALUE Procedure Parameters (Bulk)" summary="This table describes Parameters used by the DBMS_SQL.COLUMN_VALUE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t22">Parameter</th>
<th class="cellalignment4328" id="r1c2-t22">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t22" headers="r1c1-t22">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t22 r1c2-t22">
<p>ID number of the cursor from which you are fetching the values.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t22" headers="r1c1-t22">
<p><code dir="ltr">position</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t22 r1c2-t22">
<p>Relative position of the column in the cursor.</p>
<p>The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t22" headers="r1c1-t22">
<p><code dir="ltr">&lt;param_name&gt;</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t22 r1c2-t22">
<p>Local variable that has been declared &lt;<code dir="ltr">table_type</code>&gt;. &lt;<code dir="ltr">param_name</code>&gt; is an <code dir="ltr">IN</code> <code dir="ltr">OUT</code> <code dir="ltr">NOCOPY</code> parameter for bulk operations.</p>
<p>For bulk operations, the subprogram appends the new elements at the appropriate (implicitly maintained) index. For instance if on utilizing the <a href="#i1025685">DEFINE_ARRAY Procedure</a> a batch size (the <code dir="ltr">cnt</code> parameter) of 10 rows was specified and a start index (<code dir="ltr">lower_bound</code>) of 1 was specified, then the first call to this subprogram after calling the <a href="#i1026065">FETCH_ROWS Function</a> will populate elements at index 1..10, and the next call will populate elements 11..20, and so on.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9476"></a>Exceptions</p>
<p><code dir="ltr">INCONSISTENT_TYPE</code> (<code dir="ltr">ORA</code>-<code dir="ltr">06562</code>) is raised if the type of the given <code dir="ltr">OUT</code> parameter <code dir="ltr">value</code> is different from the actual type of the value. This type was the given type when the column was defined by calling procedure <code dir="ltr">DEFINE_COLUMN</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a></div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68249" class="refsect2"><a id="i1025399"></a>
<h3 class="refsect2"><a id="sthref9477"></a>COLUMN_VALUE_LONG Procedure</h3>
<p>This procedure gets part of the value of a long column.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9478"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.COLUMN_VALUE_LONG (
   c            IN  INTEGER, 
   position     IN  INTEGER, 
   length       IN  INTEGER, 
   offset       IN  INTEGER,
   value        OUT VARCHAR2,
   value_length OUT INTEGER);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9479"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(column_value_long,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9480"></a>Parameters</p>
<div id="ARPLS68250" class="tblformal">
<p class="titleintable"><a id="sthref9481"></a><a id="sthref9482"></a>Table 149-11 COLUMN_VALUE_LONG Procedure Parameters</p>
<table class="cellalignment4330" title="COLUMN_VALUE_LONG Procedure Parameters" summary="This table describes Parameters used by the DBMS_SQL.COLUMN_VALUE_LONG subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t24">Parameter</th>
<th class="cellalignment4328" id="r1c2-t24">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t24" headers="r1c1-t24">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t24 r1c2-t24">
<p>Cursor ID number of the cursor from which to get the value.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t24" headers="r1c1-t24">
<p><code dir="ltr">position</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t24 r1c2-t24">
<p>Position of the column of which to get the value.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t24" headers="r1c1-t24">
<p><code dir="ltr">length</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t24 r1c2-t24">
<p>Number of bytes of the long value to fetch.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t24" headers="r1c1-t24">
<p><code dir="ltr">offset</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t24 r1c2-t24">
<p>Offset into the long field for start of fetch.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t24" headers="r1c1-t24">
<p><code dir="ltr">value</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t24 r1c2-t24">
<p>Value of the column as a <code dir="ltr">VARCHAR2</code>.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t24" headers="r1c1-t24">
<p><code dir="ltr">value_length</code></p>
</td>
<td class="cellalignment4329" headers="r7c1-t24 r1c2-t24">
<p>Number of bytes actually returned in value.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68251" class="refsect2"><a id="i1025685"></a>
<h3 class="refsect2"><a id="sthref9483"></a>DEFINE_ARRAY Procedure</h3>
<p>This procedure defines the collection for column into which you want to fetch rows (with a <code dir="ltr">FETCH_ROWS</code> call). This procedure lets you do batch fetching of rows from a single <code dir="ltr">SELECT</code> statement. A single fetch call brings over a number of rows into the PL/SQL aggregate object.</p>
<p>When you fetch the&nbsp;rows, they are copied into <code dir="ltr">DBMS_SQL</code> buffers until you run a <code dir="ltr">COLUMN_VALUE</code> call, at which time the rows are copied into the table that was passed as an argument to the <code dir="ltr">COLUMN_VALUE</code> call.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9484"></a>Scalar and LOB Types for Collections</p>
<p>You can declare a local variable as one of the following table-item types, and then fetch any number of rows into it using <code dir="ltr">DBMS_SQL</code>. (These are the same types as you can specify for the <code dir="ltr">BIND_ARRAY</code> procedure.)</p>
<pre dir="ltr">TYPE binary_double_table 
                    IS TABLE OF BINARY_DOUBLE  INDEX BY BINARY_INTEGER;
TYPE binary_float_table 
                    IS TABLE OF BINARY_FLOAT   INDEX BY BINARY_INTEGER;
TYPE bfile_table    IS TABLE OF BFILE          INDEX BY BINARY_INTEGER;
TYPE blob_table     IS TABLE OF BLOB           INDEX BY BINARY_INTEGER;
TYPE clob_table     IS TABLE OF CLOB           INDEX BY BINARY_INTEGER;
TYPE date_table     IS TABLE OF DATE           INDEX BY BINARY_INTEGER;
TYPE interval_day_to_second_Table 
                    IS TABLE OF dsinterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE interval_year_to_MONTH_Table 
                    IS TABLE OF yminterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE number_table   IS TABLE OF NUMBER         INDEX BY BINARY_INTEGER;
TYPE time_table     IS TABLE OF time_unconstrained           
                                               INDEX BY BINARY_INTEGER;
TYPE time_with_time_zone_table 
                    IS TABLE OF time_tz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_table 
                    IS TABLE OF timestamp_unconstrained   
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_with_ltz_Table 
                    IS TABLE OF timestamp_ltz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_with_time_zone_Table 
                    IS TABLE OF timestamp_tz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE urowid_table   IS TABLE OF UROWID         INDEX BY BINARY_INTEGER;
TYPE varchar2_table IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9485"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.DEFINE_ARRAY (
   c           IN INTEGER, 
   position    IN INTEGER,
   &lt;table_variable&gt;    IN &lt;datatype&gt; 
   cnt         IN INTEGER, 
   lower_bnd   IN INTEGER);
</pre>
<p>Where &lt;<code dir="ltr">table_variable</code>&gt; and its corresponding &lt;datatype&gt; can be any one of the following matching pairs, <code dir="ltr">DEFINE_ARRAY</code> being overloaded to accept different datatypes:</p>
<pre dir="ltr">&lt;clob_tab&gt;     Clob_Table
&lt;bflt_tab&gt;     Binary_Float_Table
&lt;bdbl_tab&gt;     Binary_Double_Table
&lt;blob_tab&gt;     Blob_Table
&lt;bfile_tab&gt;    Bfile_Table
&lt;date_tab&gt;     Date_Table
&lt;num_tab&gt;      Number_Table
&lt;urowid_tab&gt;   Urowid_Table
&lt;vchr2_tab&gt;    Varchar2_Table
&lt;tm_tab&gt;       Time_Table
&lt;ttz_tab&gt;      Time_With_Time_Zone_Table
&lt;tms_tab&gt;      Timestamp_Table
&lt;tstz_tab&gt;     Timestamp_With_ltz_Table;
&lt;tstz_tab&gt;     Timestamp_With_Time_Zone_Table
&lt;ids_tab&gt;      Interval_Day_To_Second_Table
&lt;iym_tab&gt;      Interval_Year_To_Month_Table
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9486"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(define_array,RNDS,WNDS);
</pre>
<p>The subsequent <code dir="ltr">FETCH_ROWS</code> call fetch &#34;count&#34; rows. When the <code dir="ltr">COLUMN_VALUE</code> call is made, these rows are placed in positions <code dir="ltr">lower_bnd</code>, <code dir="ltr">lower_bnd</code>+1, <code dir="ltr">lower_bnd</code>+2, and so on. While there are still rows coming, the user keeps issuing <code dir="ltr">FETCH_ROWS</code>/<code dir="ltr">COLUMN_VALUE</code> calls. The rows keep accumulating in the table specified as an argument in the <code dir="ltr">COLUMN_VALUE</code> call.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9487"></a>Parameters</p>
<div id="ARPLS68252" class="tblformal">
<p class="titleintable"><a id="sthref9488"></a><a id="sthref9489"></a>Table 149-12 DEFINE_ARRAY Procedure Parameters</p>
<table class="cellalignment4330" title="DEFINE_ARRAY Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_ARRAY subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t25">Parameter</th>
<th class="cellalignment4328" id="r1c2-t25">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t25" headers="r1c1-t25">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t25 r1c2-t25">
<p>ID number of the cursor to which you want to bind an&nbsp;array.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t25" headers="r1c1-t25">
<p><code dir="ltr">position</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t25 r1c2-t25">
<p>Relative position of the column in the array being defined.</p>
<p>The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t25" headers="r1c1-t25">
<p><code dir="ltr">table_variable</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t25 r1c2-t25">
<p>Local variable that has been declared as &lt;<code dir="ltr">datatype</code>&gt;.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t25" headers="r1c1-t25">
<p><code dir="ltr">cnt</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t25 r1c2-t25">
<p>Number of rows that must be fetched.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t25" headers="r1c1-t25">
<p><code dir="ltr">lower_bnd</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t25 r1c2-t25">
<p>Results are copied into the collection, starting at this lower bound index.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9490"></a>Usage Notes</p>
<p>The count <code dir="ltr">(cnt)</code> must be an integer greater than zero; otherwise an exception is raised. The <code dir="ltr">lower_bnd</code> can be positive, negative, or zero. A query on which a <code dir="ltr">DEFINE_ARRAY</code> call was issued cannot contain array binds.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9491"></a>Examples</p>
<pre dir="ltr">PROCEDURE BULK_PLSQL(deptid NUMBER)
    TYPE namelist IS TABLE OF employees.last_name%TYPE;
    TYPE sallist IS TABLE OF employees.salary%TYPE;
    names    namelist;
    sals     sallist;
    c        NUMBER;
    r        NUMBER;
    sql_stmt VARCHAR2(32767) :=
        &#39;SELECT last_name, salary FROM employees WHERE department_id = :b1&#39;;
 
BEGIN
    c := DBMS_SQL.OPEN_CURSOR;
    DBMS_SQL.PARSE(c, sql_stmt, dbms_sql.native);
 
    DBMS_SQL.BIND_VARIABLE(c, &#39;b1&#39;, deptid);
 
    DBMS_SQL.DEFINE_ARRAY(c, 1, names, 5);
    DBMS_SQL.DEFINE_ARRAY(c, 2, sals, 5);
 
    r := DBMS_SQL.EXECUTE(c);
 
    LOOP
      r := DBMS_SQL.FETCH_ROWS(c);
      DBMS_SQL.COLUMN_VALUE(c, 1, names);
      DBMS_SQL.COLUMN_VALUE(c, 2, sals);
      EXIT WHEN r != 5;
    END LOOP;
 
    DBMS_SQL.CLOSE_CURSOR(c);
 
    -- loop through the names and sals collections
    FOR i IN names.FIRST .. names.LAST  LOOP
      DBMS_OUTPUT.PUT_LINE(&#39;Name = &#39; || names(i) || &#39;, salary = &#39; || sals(i));
    END LOOP;
END;
/
</pre></div>
<!-- class="refsubsect" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997149">&#34;Examples 6 and 7:&nbsp;Defining an Array&#34;</a> for examples of how to define collections.</div>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68253" class="refsect2"><a id="i1025686"></a>
<h3 class="refsect2"><a id="sthref9492"></a>DEFINE_COLUMN Procedures</h3>
<p>This procedure defines a column to be selected from the given cursor. This procedure is only used with <code dir="ltr">SELECT</code> cursors.</p>
<p>The column being defined is identified by its relative position in the <code dir="ltr">SELECT</code> list of the statement in the given cursor. The type of the <code dir="ltr">COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a>, <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a>, <a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a> and <a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9493"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.DEFINE_COLUMN (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN &lt;datatype&gt;);
</pre>
<p>Where &lt;<code dir="ltr">datatype</code>&gt; can be any one of the following types:</p>
<pre dir="ltr">BINARY_DOUBLE
BINARY_FLOAT
BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
DSINTERVAL_UNCONSTRAINED
NUMBER
TIME_UNCONSTRAINED
TIME_TZ_UNCONSTRAINED
TIMESTAMP_LTZ_UNCONSTRAINED
TIMESTAMP_TZ_UNCONSTRAINED
TIMESTAMP_UNCONSTRAINED
UROWID
YMINTERVAL_UNCONSTRAINED
user-defined object types
collections (VARRAYs and nested tables)
REFs
Opaque types
</pre>
<p>Note that <code dir="ltr">DEFINE_COLUMN</code> is overloaded to accept different datatypes.</p>
<p>The following syntax is also supported for the <code dir="ltr">DEFINE_COLUMN</code> procedure:</p>
<pre dir="ltr">DBMS_SQL.DEFINE_COLUMN (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN VARCHAR2 CHARACTER SET ANY_CS,
   column_size    IN INTEGER);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9494"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(define_column,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9495"></a>Parameters</p>
<div id="ARPLS68254" class="tblformal">
<p class="titleintable"><a id="sthref9496"></a><a id="sthref9497"></a>Table 149-13 DEFINE_COLUMN Procedure Parameters</p>
<table class="cellalignment4330" title="DEFINE_COLUMN Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t28">Parameter</th>
<th class="cellalignment4328" id="r1c2-t28">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t28" headers="r1c1-t28">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t28 r1c2-t28">
<p>ID number of the cursor for the row being defined to be selected</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t28" headers="r1c1-t28">
<p><code dir="ltr">position</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t28 r1c2-t28">
<p>Relative position of the column in the row being defined.The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t28" headers="r1c1-t28">
<p><code dir="ltr">column</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t28 r1c2-t28">
<p>Value of the column being defined. The type of this value determines the type for the column being defined.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t28" headers="r1c1-t28">
<p><code dir="ltr">column_size</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t28 r1c2-t28">
<p>Maximum expected size of the column value in bytes for columns of type <code dir="ltr">VARCHAR2</code>, and <code dir="ltr">RAW</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9498"></a>Usage Notes</p>
<p>When using character length semantics the maximum number of bytes that can be returned for a column value of type <code dir="ltr">VARCHAR2</code> is calculated as: <code dir="ltr">column_size</code> <code dir="ltr">*</code> maximum character byte size for the current character set. For example, specifying the <code dir="ltr">column_size</code> as 10 means that a maximum of 30 (10*3) bytes can be returned when using character length semantics with a UTF8 character set regardless of the number of characters this represents.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS72007" class="refsect2"><a id="CIHGCGBF"></a>
<h3 class="refsect2"><a id="sthref9499"></a>DEFINE_COLUMN_CHAR Procedure</h3>
<p>This procedure defines a column with <code dir="ltr">CHAR</code> data to be selected from the given cursor. This procedure is only used with <code dir="ltr">SELECT</code> cursors.</p>
<p>The column being defined is identified by its relative position in the <code dir="ltr">SELECT</code> list of the statement in the given cursor. The type of the <code dir="ltr">COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a>, <a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a> and <a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9500"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.DEFINE_COLUMN_CHAR (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN CHAR CHARACTER SET ANY_CS,
   column_size    IN INTEGER);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9501"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(define_column,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9502"></a>Parameters</p>
<div id="ARPLS72008" class="tblformal">
<p class="titleintable"><a id="sthref9503"></a><a id="sthref9504"></a>Table 149-14 DEFINE_COLUMN_CHAR Procedure Parameters</p>
<table class="cellalignment4330" title="DEFINE_COLUMN_CHAR Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN_CHAR subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t30">Parameter</th>
<th class="cellalignment4328" id="r1c2-t30">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t30" headers="r1c1-t30">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t30 r1c2-t30">
<p>ID number of the cursor for the row being defined to be selected</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t30" headers="r1c1-t30">
<p><code dir="ltr">position</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t30 r1c2-t30">
<p>Relative position of the column in the row being defined.The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t30" headers="r1c1-t30">
<p><code dir="ltr">column</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t30 r1c2-t30">
<p>Value of the column being defined. The type of this value determines the type for the column being defined.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t30" headers="r1c1-t30">
<p><code dir="ltr">column_size</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t30 r1c2-t30">
<p>Maximum expected size of the column value in characters for columns of type <code dir="ltr">CHAR</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68255" class="refsect2"><a id="i1025656"></a>
<h3 class="refsect2"><a id="sthref9505"></a>DEFINE_COLUMN_LONG Procedure</h3>
<p>This procedure defines a <code dir="ltr">LONG</code> column for a <code dir="ltr">SELECT</code> cursor. The column being defined is identified by its relative position in the <code dir="ltr">SELECT</code> list of the statement for the given cursor. The type of the <code dir="ltr">COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, <a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a>, <a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a> and <a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9506"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.DEFINE_COLUMN_LONG (
   c              IN INTEGER,
   position       IN INTEGER); 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9507"></a>Parameters</p>
<div id="ARPLS68256" class="tblformal">
<p class="titleintable"><a id="sthref9508"></a><a id="sthref9509"></a>Table 149-15 DEFINE_COLUMN_LONG Procedure Parameters</p>
<table class="cellalignment4330" title="DEFINE_COLUMN_LONG Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN_LONG subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t31">Parameter</th>
<th class="cellalignment4328" id="r1c2-t31">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t31" headers="r1c1-t31">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t31 r1c2-t31">
<p>ID number of the cursor for the row being defined to be selected.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t31" headers="r1c1-t31">
<p><code dir="ltr">position</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t31 r1c2-t31">
<p>Relative position of the column in the row being defined.</p>
<p>The first column in a statement has position 1.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS72009" class="refsect2"><a id="CIHECACB"></a>
<h3 class="refsect2"><a id="sthref9510"></a>DEFINE_COLUMN_RAW Procedure</h3>
<p>This procedure defines a column of type <code dir="ltr">RAW</code> to be selected from the given cursor. This procedure is only used with <code dir="ltr">SELECT</code> cursors.</p>
<p>The column being defined is identified by its relative position in the <code dir="ltr">SELECT</code> list of the statement in the given cursor. The type of the <code dir="ltr">COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, <a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a>, <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a> and <a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9511"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.DEFINE_COLUMN_RAW (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN RAW,
   column_size    IN INTEGER);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9512"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(define_column,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9513"></a>Parameters</p>
<div id="ARPLS72010" class="tblformal">
<p class="titleintable"><a id="sthref9514"></a><a id="sthref9515"></a>Table 149-16 DEFINE_COLUMN Procedure Parameters</p>
<table class="cellalignment4330" title="DEFINE_COLUMN Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN_RAW subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t33">Parameter</th>
<th class="cellalignment4328" id="r1c2-t33">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t33" headers="r1c1-t33">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t33 r1c2-t33">
<p>ID number of the cursor for the row being defined to be selected</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t33" headers="r1c1-t33">
<p><code dir="ltr">position</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t33 r1c2-t33">
<p>Relative position of the column in the row being defined.The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t33" headers="r1c1-t33">
<p><code dir="ltr">column</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t33 r1c2-t33">
<p>Value of the column being defined. The type of this value determines the type for the column being defined.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t33" headers="r1c1-t33">
<p><code dir="ltr">column_size</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t33 r1c2-t33">
<p>Maximum expected size of the column value in bytes for columns of and <code dir="ltr">RAW</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS72011" class="refsect2"><a id="CIHJJFJD"></a>
<h3 class="refsect2"><a id="sthref9516"></a>DEFINE_COLUMN_ROWID Procedure</h3>
<p>This procedure defines a column of type <code dir="ltr">ROWID</code> to be selected from the given cursor. This procedure is only used with <code dir="ltr">SELECT</code> cursors.</p>
<p>The column being defined is identified by its relative position in the <code dir="ltr">SELECT</code> list of the statement in the given cursor. The type of the <code dir="ltr">COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, <a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a>, <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a> and <a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9517"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.DEFINE_COLUMN_ROWID (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN ROWID); 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9518"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(define_column,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9519"></a>Parameters</p>
<div id="ARPLS72012" class="tblformal">
<p class="titleintable"><a id="sthref9520"></a><a id="sthref9521"></a>Table 149-17 DEFINE_COLUMN Procedure Parameters</p>
<table class="cellalignment4330" title="DEFINE_COLUMN Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t35">Parameter</th>
<th class="cellalignment4328" id="r1c2-t35">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t35" headers="r1c1-t35">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t35 r1c2-t35">
<p>ID number of the cursor for the row being defined to be selected</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t35" headers="r1c1-t35">
<p><code dir="ltr">position</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t35 r1c2-t35">
<p>Relative position of the column in the row being defined.The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t35" headers="r1c1-t35">
<p><code dir="ltr">column</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t35 r1c2-t35">
<p>Value of the column being defined. The type of this value determines the type for the column being defined.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68257" class="refsect2"><a id="i1026120"></a>
<h3 class="refsect2"><a id="sthref9522"></a>DESCRIBE_COLUMNS Procedure</h3>
<p>This procedure describes the columns for a cursor opened and parsed through <code dir="ltr">DBMS_SQL</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9523"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.DESCRIBE_COLUMNS ( 
   c              IN  INTEGER, 
   col_cnt        OUT INTEGER, 
   desc_t         OUT DESC_TAB);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9524"></a>Parameters</p>
<div id="ARPLS68258" class="tblformal">
<p class="titleintable"><a id="sthref9525"></a><a id="sthref9526"></a>Table 149-18 DESCRIBE_COLUMNS Procedure Parameters</p>
<table class="cellalignment4330" title=" DESCRIBE_COLUMNS Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DESCRIBE_COLUMNS subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t36">Parameter</th>
<th class="cellalignment4328" id="r1c2-t36">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t36" headers="r1c1-t36">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t36 r1c2-t36">
<p>ID number of the cursor for the columns being described</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t36" headers="r1c1-t36">
<p><code dir="ltr">col_cnt</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t36 r1c2-t36">
<p>Number of columns in the select list of the query</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t36" headers="r1c1-t36">
<p><code dir="ltr">desc_t</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t36 r1c2-t36">
<p>Describe table to fill in with the description of each of the columns of the query</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997238">&#34;Example 8:&nbsp;Describe Columns&#34;</a> illustrates how to use <code dir="ltr">DESCRIBE_COLUMNS</code>.</div>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68259" class="refsect2"><a id="i1029368"></a>
<h3 class="refsect2"><a id="sthref9527"></a>DESCRIBE_COLUMNS2 Procedure</h3>
<p>This procedure describes the specified column. This is an alternative to <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9528"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.DESCRIBE_COLUMNS2 ( 
   c              IN  INTEGER, 
   col_cnt        OUT INTEGER, 
   desc_t         OUT DESC_TAB2);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9529"></a>Pragmas</p>
<pre dir="ltr">PRAGMA RESTRICT_REFERENCES(describe_columns2,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9530"></a>Parameters</p>
<div id="ARPLS68260" class="tblformal">
<p class="titleintable"><a id="sthref9531"></a><a id="sthref9532"></a>Table 149-19 DESCRIBE_COLUMNS2 Procedure Parameters</p>
<table class="cellalignment4330" title="DESCRIBE_COLUMNS2 Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DESCRIBE_COLUMNS2 subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t38">Parameter</th>
<th class="cellalignment4328" id="r1c2-t38">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t38" headers="r1c1-t38">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t38 r1c2-t38">
<p>ID number of the cursor for the columns being described.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t38" headers="r1c1-t38">
<p><code dir="ltr">col_cnt</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t38 r1c2-t38">
<p>Number of columns in the select list of the query.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t38" headers="r1c1-t38">
<p><code dir="ltr">desc_t</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t38 r1c2-t38">
<p>Describe table to fill in with the description of each of the columns of the query. This table is indexed from one to the number of elements in the select list of the query.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68261" class="refsect2"><a id="CHDJBBFH"></a>
<h3 class="refsect2"><a id="sthref9533"></a>DESCRIBE_COLUMNS3 Procedure</h3>
<p>This procedure describes the specified column. This is an alternative to <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9534"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.DESCRIBE_COLUMNS3 ( 
   c              IN  INTEGER, 
   col_cnt        OUT INTEGER, 
   desc_t         OUT DESC_TAB3);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9535"></a>Pragmas</p>
<pre dir="ltr">PRAGMA RESTRICT_REFERENCES(describe_columns3,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9536"></a>Parameters</p>
<div id="ARPLS68262" class="tblformal">
<p class="titleintable"><a id="sthref9537"></a><a id="sthref9538"></a>Table 149-20 DESCRIBE_COLUMNS3 Procedure Parameters</p>
<table class="cellalignment4330" title="DESCRIBE_COLUMNS3 Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DESCRIBE_COLUMNS3 subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t39">Parameter</th>
<th class="cellalignment4328" id="r1c2-t39">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t39" headers="r1c1-t39">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t39 r1c2-t39">
<p>ID number of the cursor for the columns being described.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t39" headers="r1c1-t39">
<p><code dir="ltr">col_cnt</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t39 r1c2-t39">
<p>Number of columns in the select list of the query.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t39" headers="r1c1-t39">
<p><code dir="ltr">desc_t</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t39 r1c2-t39">
<p>Describe table to fill in with the description of each of the columns of the query. This table is indexed from one to the number of elements in the select list of the query.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9539"></a>Usage Notes</p>
<p>The cursor passed in by the cursor ID has to be <code dir="ltr">OPEN</code>ed and <code dir="ltr">PARSE</code>d, otherwise an &#34;invalid cursor id&#34; error is raised.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9540"></a>Examples</p>
<pre dir="ltr">CREATE TYPE PROJECT_T AS OBJECT
      ( projname          VARCHAR2(20),
        mgr               VARCHAR2(20))
/
 
CREATE TABLE projecttab(deptno NUMBER, project HR.PROJECT_T)
/
 
DECLARE
  curid      NUMBER;
  desctab    DBMS_SQL.DESC_TAB3;
  colcnt     NUMBER;
  sql_stmt   VARCHAR2(200) := &#39;select * from projecttab&#39;;
BEGIN
 
    curid := DBMS_SQL.OPEN_CURSOR;
 
    DBMS_SQL.PARSE(curid, sql_stmt, DBMS_SQL.NATIVE);
 
    DBMS_SQL.DESCRIBE_COLUMNS3(curid, colcnt, desctab);
 
    FOR i IN 1 .. colcnt LOOP
      IF desctab(i).col_type = 109 THEN
        DBMS_OUTPUT.PUT(desctab(i).col_name || &#39; is user-defined type: &#39;);
        DBMS_OUTPUT.PUT_LINE(desctab(i).col_schema_name || &#39;.&#39; ||
                             desctab(i).col_type_name);
      END IF;
    END LOOP;
 
    DBMS_SQL.CLOSE_CURSOR(curid);
END;
/
 
Output:
 
PROJECT is user-defined type: HR.PROJECT_T
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68263" class="refsect2"><a id="i1025983"></a>
<h3 class="refsect2"><a id="sthref9541"></a>EXECUTE Function</h3>
<p>This function executes a given cursor. This function accepts the <code dir="ltr">ID</code> number of the cursor and returns the number of rows processed. The return value is only valid for <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, and <code dir="ltr">DELETE</code> statements; for other types of statements, including DDL, the return value is undefined and must be ignored.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9542"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.EXECUTE (
   c   IN INTEGER)
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9543"></a>Parameters</p>
<div id="ARPLS73184" class="tblformal">
<p class="titleintable"><a id="sthref9544"></a><a id="sthref9545"></a>Table 149-21 EXECUTE Function Parameters</p>
<table class="cellalignment4330" title="EXECUTE Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.EXECUTE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t40">Parameter</th>
<th class="cellalignment4328" id="r1c2-t40">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t40" headers="r1c1-t40">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t40 r1c2-t40">
<p>Cursor ID number of the cursor to execute.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9546"></a>Return Values</p>
<p>Returns number of rows processed</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9547"></a>Usage Notes</p>
<p>The <code dir="ltr">DBMS_SQL</code> cursor that is returned by the <a href="#CHDJDGDG">TO_CURSOR_NUMBER Function</a> performs in the same way as a <code dir="ltr">DBMS_SQL</code> cursor that has already been executed. Consequently, calling <code dir="ltr">EXECUTE</code> for this cursor will cause an error.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68265" class="refsect2"><a id="i1025711"></a>
<h3 class="refsect2"><a id="sthref9548"></a>EXECUTE_AND_FETCH Function</h3>
<p>This function executes the given cursor and fetches rows. This function provides the same functionality as calling <code dir="ltr">EXECUTE</code> and then calling <code dir="ltr">FETCH_ROWS</code>. Calling <code dir="ltr">EXECUTE_AND_FETCH</code> instead, however, may reduce the number of network round-trips when used against a remote database.</p>
<p>The <code dir="ltr">EXECUTE_AND_FETCH</code> function returns the number of rows actually fetched.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9549"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.EXECUTE_AND_FETCH (
   c              IN INTEGER,
   exact          IN BOOLEAN DEFAULT FALSE)
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9550"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(execute_and_fetch,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9551"></a>Parameters</p>
<div id="ARPLS68266" class="tblformal">
<p class="titleintable"><a id="sthref9552"></a><a id="sthref9553"></a>Table 149-22 EXECUTE_AND_FETCH Function Parameters</p>
<table class="cellalignment4330" title="EXECUTE_AND_FETCH Function Parameters " summary="This table describes Parameters used by the DBMS_SQL.EXECUTE_AND_FETCH subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t41">Parameter</th>
<th class="cellalignment4328" id="r1c2-t41">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t41" headers="r1c1-t41">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t41 r1c2-t41">
<p>ID number of the cursor to execute and fetch.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t41" headers="r1c1-t41">
<p><code dir="ltr">exact</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t41 r1c2-t41">
<p>Set to <code dir="ltr">TRUE</code> to raise an exception if the number of rows actually matching the query differs from one.</p>
<p>Note: Oracle does not support the exact fetch TRUE option with LONG columns.</p>
<p>Even if an exception is raised, the rows are still fetched and available.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9554"></a>Return Values</p>
<p>Returns designated rows</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68267" class="refsect2"><a id="i1026065"></a>
<h3 class="refsect2"><a id="sthref9555"></a>FETCH_ROWS Function</h3>
<p>This function fetches a row from a given cursor. You can call <code dir="ltr">FETCH_ROWS</code> repeatedly as long as there are rows remaining to be fetched. These rows are retrieved into a buffer, and must be read by calling <code dir="ltr">COLUMN_VALUE</code>, for each column, after each call to <code dir="ltr">FETCH_ROWS</code>.</p>
<p>The <code dir="ltr">FETCH_ROWS</code> function accepts the ID number of the cursor to fetch, and returns the number of rows actually fetched.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9556"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.FETCH_ROWS (
   c              IN INTEGER)
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9557"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(fetch_rows,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9558"></a>Parameters</p>
<div id="ARPLS68268" class="tblformal">
<p class="titleintable"><a id="sthref9559"></a><a id="sthref9560"></a>Table 149-23 FETCH_ROWS Function Parameters</p>
<table class="cellalignment4330" title="FETCH_ROWS Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.FETCH_ROWS subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t42">Parameter</th>
<th class="cellalignment4328" id="r1c2-t42">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t42" headers="r1c1-t42">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t42 r1c2-t42">
<p>ID number.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9561"></a>Return Values</p>
<p>Returns a row from a given cursor</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73891" class="refsect2"><a id="CIHEBDFJ"></a>
<h3 class="refsect2"><a id="sthref9562"></a>GET_NEXT_RESULT Procedures</h3>
<p>This procedure gets the statement of the next result returned to the caller of the recursive statement or, if this caller sets itself as the client for the recursive statement, the next result returned to this caller as client. The statements are returned in same order as they are returned by the <a href="#CIHIICAG">RETURN_RESULT Procedures</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9563"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.GET_NEXT_RESULT(
   c            IN          INTEGER,
   rc           OUT         SYS_REFCURSOR);

DBMS_SQL.GET_NEXT_RESULT(
   c            IN          INTEGER,
   rc           OUT         INTEGER);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9564"></a>Parameters</p>
<div id="ARPLS73892" class="tblformal">
<p class="titleintable"><a id="sthref9565"></a><a id="sthref9566"></a>Table 149-24 GET_NEXT_RESULT Procedure Parameters</p>
<table class="cellalignment4330" title="GET_NEXT_RESULT Procedure Parameters" summary="This table describes Parameters used by the DBMS_SQL.GET_NEXT_RESULT subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t43">Parameter</th>
<th class="cellalignment4328" id="r1c2-t43">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t43" headers="r1c1-t43">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t43 r1c2-t43">
<p>Recursive statement cursor</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t43" headers="r1c1-t43">
<p><code dir="ltr">rc</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t43 r1c2-t43">
<p>Cursor or ref cursor of the statement of the next returned result</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9567"></a>Exceptions</p>
<p><code dir="ltr">ORA-01403 no_data_found:</code> This is raised when there is no further returned statement result.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9568"></a>Usage Notes</p>
<ul>
<li>
<p>After the cursor of a statement result is retrieved, the caller must close the cursor properly when it is no longer needed.</p>
</li>
<li>
<p>The cursors for all unretrieved returned statements will be closed after the cursor of the recursive statement is closed.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9569"></a>Examples</p>
<pre dir="ltr">DECLARE
  c  INTEGER;
  rc SYS_REFCURSOR;
BEGIN
  c := DBMS_SQL.OPEN_CURSOR(treat_as_client_for_results =&gt; TRUE);
  DBMS_SQL.PARSE(c                  =&gt; c,
                 statement          =&gt; &#39;begin proc; end;&#39;);
  DBMS_SQL.EXECUTE(c);
  LOOP
    BEGIN
      DBMS_SQL.GET_NEXT_RESULT(c, rc);
    EXCEPTIONS
      WHEN no_data_found THEN
        EXIT;
    END;
    LOOP
      FETCH rc INTO ...
      ...
    END LOOP;
  END LOOP;
END;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68269" class="refsect2"><a id="i1026423"></a>
<h3 class="refsect2"><a id="sthref9570"></a>IS_OPEN Function</h3>
<p>This function checks to see if the given cursor is currently open.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9571"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.IS_OPEN (
   c              IN INTEGER)
  RETURN BOOLEAN;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9572"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(is_open,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9573"></a>Parameters</p>
<div id="ARPLS68270" class="tblformal">
<p class="titleintable"><a id="sthref9574"></a><a id="sthref9575"></a>Table 149-25 IS_OPEN Function Parameters</p>
<table class="cellalignment4330" title="IS_OPEN Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.IS_OPEN subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t44">Parameter</th>
<th class="cellalignment4328" id="r1c2-t44">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t44" headers="r1c1-t44">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t44 r1c2-t44">
<p>Cursor ID number of the cursor to check.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9576"></a>Return Values</p>
<p>Returns <code dir="ltr">TRUE</code> for any cursor number that has been opened but not closed, and <code dir="ltr">FALSE</code> for a <code dir="ltr">NULL</code> cursor number. Note that the <a href="#i1026299">CLOSE_CURSOR Procedure</a> Procedure <code dir="ltr">NULL</code>s out the cursor variable passed to it.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9577"></a>Exceptions</p>
<p><code dir="ltr">ORA-29471 DBMS_SQL access denied:</code> This is raised if an invalid cursor ID number is detected. Once a session has encountered and reported this error, every subsequent DBMS_SQL call in the same session will raise this error, meaning that DBMS_SQL is non-operational for this session.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68271" class="refsect2"><a id="i1026408"></a>
<h3 class="refsect2"><a id="sthref9578"></a>LAST_ERROR_POSITION Function</h3>
<p>This function returns the byte offset in the SQL statement text where the error occurred. The first character in the SQL statement is at position 0.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9579"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.LAST_ERROR_POSITION 
   RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9580"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(last_error_position,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9581"></a>Return Values</p>
<p>Returns the byte offset in the SQL statement text where the error occurred</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9582"></a>Usage Notes</p>
<p>Call this function after a <code dir="ltr">PARSE</code> call, before any other <code dir="ltr">DBMS_SQL</code> procedures or functions are called.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68272" class="refsect2"><a id="i1026354"></a>
<h3 class="refsect2"><a id="sthref9583"></a>LAST_ROW_COUNT Function</h3>
<p>This function returns the cumulative count of the number of rows fetched.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9584"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.LAST_ROW_COUNT 
   RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9585"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(last_row_count,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9586"></a>Return Values</p>
<p>Returns the cumulative count of the number of rows fetched</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9587"></a>Usage Notes</p>
<p>Call this function after a <code dir="ltr">FETCH_ROWS</code> or an <code dir="ltr">EXECUTE_AND_FETCH</code> call. If called after an <code dir="ltr">EXECUTE</code> call, then the value returned is zero.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68273" class="refsect2"><a id="i1026364"></a>
<h3 class="refsect2"><a id="sthref9588"></a>LAST_ROW_ID Function</h3>
<p>This function returns the <code dir="ltr">ROWID</code> of the last row processed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9589"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.LAST_ROW_ID 
   RETURN ROWID;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9590"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(last_row_id,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9591"></a>Return Values</p>
<p>Returns the <code dir="ltr">ROWID</code> of the last row processed</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9592"></a>Usage Notes</p>
<p>Call this function after a <code dir="ltr">FETCH_ROWS</code> or an <code dir="ltr">EXECUTE_AND_FETCH</code> call.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68274" class="refsect2"><a id="i1026374"></a>
<h3 class="refsect2"><a id="sthref9593"></a>LAST_SQL_FUNCTION_CODE Function</h3>
<p>This function returns the SQL function code for the statement. These codes are listed in the <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide.</span></a></p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9594"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.LAST_SQL_FUNCTION_CODE 
   RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9595"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(last_sql_function_code,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9596"></a>Return Values</p>
<p>Returns the SQL function code for the statement</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9597"></a>Usage Notes</p>
<p>You must call this function immediately after the SQL statement is run; otherwise, the return value is undefined.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68275" class="refsect2"><a id="i997665"></a>
<h3 class="refsect2"><a id="sthref9598"></a>OPEN_CURSOR Functions</h3>
<p>This function opens a new cursor. The <code dir="ltr">security_level</code> parameter allows for application of fine-grained control to the security of the opened cursor.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9599"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.OPEN_CURSOR (
   treat_as_client_for_results    IN     BOOLEAN    DEFAULT FALSE) 
  RETURN INTEGER;

DBMS_SQL.OPEN_CURSOR (
   security_level                 IN     INTEGER,
   treat_as_client_for_results    IN     BOOLEAN    DEFAULT FALSE) 
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9600"></a>Parameters</p>
<div id="ARPLS68276" class="tblformal">
<p class="titleintable"><a id="sthref9601"></a><a id="sthref9602"></a>Table 149-26 OPEN_CURSOR Function Parameters</p>
<table class="cellalignment4330" title="OPEN_CURSOR Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.IS_OPEN subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t45">Parameter</th>
<th class="cellalignment4328" id="r1c2-t45">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t45" headers="r1c1-t45">
<p><code dir="ltr">security_level</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t45 r1c2-t45">
<p>Specifies the level of security protection to enforce on the opened cursor. Valid security level values are <code dir="ltr">0</code>, <code dir="ltr">1</code>, and <code dir="ltr">2</code>. When a <code dir="ltr">NULL</code> argument value is provided to this overload, as well as for cursors opened using the overload of open_cursor without the <code dir="ltr">security_level</code> parameter, the default security level value <code dir="ltr">1</code> will be enforced on the opened cursor.</p>
<ul>
<li>
<p><code dir="ltr">Level</code> <code dir="ltr">0</code> - allows all <code dir="ltr">DBMS_SQL</code> operations on the cursor without any security checks. The cursor may be fetched from, and even re-bound and re-executed, by code running with a different effective userid or roles than those in effect at the time the cursor was parsed. This level of security is off by default.</p>
</li>
<li>
<p><code dir="ltr">Level</code> <code dir="ltr">1</code> - requires that the referenced container, effective userid, and roles of the caller to <code dir="ltr">DBMS_SQL</code> for bind and execute operations on this cursor must be the same as those of the caller of the most recent parse operation on this cursor.</p>
</li>
<li>
<p><code dir="ltr">Level</code> <code dir="ltr">2</code> - requires that the referenced container, effective userid, and roles of the caller to <code dir="ltr">DBMS_SQL</code> for all bind, execute, define, describe, and fetch operations on this cursor must be the same as those of the caller of the most recent parse operation on this cursor.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t45" headers="r1c1-t45">
<p><code dir="ltr">treat_as_client_for results</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t45 r1c2-t45">
<p>Allows the caller of the recursive statement to set itself as the client to receive the statement results returned from the recursive statement to client. The statement results returned may be retrieved by the <a href="#CIHEBDFJ">GET_NEXT_RESULT Procedures</a>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9603"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(open_cursor,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9604"></a>Return Values</p>
<p>Returns the cursor ID number of the new cursor</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9605"></a>Usage Notes</p>
<ul>
<li>
<p>When you no longer need this cursor, you must close it explicitly by calling the <a href="#i1026299">CLOSE_CURSOR Procedure</a>.</p>
</li>
<li>
<p>You can use cursors to run the same SQL statement repeatedly or to run a new SQL statement. When a cursor is reused, the contents of the corresponding cursor data area are reset when the new SQL statement is parsed. It is never necessary to close and reopen a cursor before reusing it.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68277" class="refsect2"><a id="i997676"></a>
<h3 class="refsect2"><a id="sthref9606"></a>PARSE Procedures</h3>
<p>This procedure parses the given statement in the given cursor. All statements are parsed immediately. In addition, DDL statements are run immediately when parsed.</p>
<p>There are four versions of the <code dir="ltr">PARSE</code> procedure:</p>
<ul>
<li>
<p>Taking a <code dir="ltr">VARCHAR2</code> statement as an argument</p>
</li>
</ul>
<ul>
<li>
<p>Two versions that take a segmented string, one taking <code dir="ltr">VARCHAR2A</code>, a table of <code dir="ltr">varchar2d(32767)</code>, and another, taking <code dir="ltr">VARCHAR2S</code>, a table of <code dir="ltr">varchar2(256)</code>, as argument. Both overloads concatenate elements of a PL/SQL table statement and parse the resulting string. You can use these procedures to parse a statement that is longer than the limit for a single <code dir="ltr">VARCHAR2</code> variable by splitting up the statement.</p>
</li>
</ul>
<ul>
<li>
<p>Taking a <code dir="ltr">CLOB</code> statement as an argument. You can use the <code dir="ltr">CLOB</code> overload version of the parse procedure to parse a SQL statement larger than 32K bytes.</p>
</li>
</ul>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9607"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.PARSE (
   c                           IN   INTEGER,
   statement                   IN   VARCHAR2,
   language_flag               IN   INTEGER,
   edition                     IN   VARCHAR2 DEFAULT NULL,
   apply_crossedition_trigger  IN   VARCHAR2 DEFAULT NULL,
   fire_apply_trigger          IN   BOOLEAN DEFAULT TRUE,
   schema                      IN   VARCHAR2 DEFAULT NULL,
   container                   IN   VARCHAR2);
</pre>
<pre dir="ltr">DBMS_SQL.PARSE (
   c                           IN   INTEGER,
   statement                   IN   CLOB,
   language_flag               IN   INTEGER,
   edition                     IN   VARCHAR2 DEFAULT NULL,
   apply_crossedition_trigger  IN   VARCHAR2 DEFAULT NULL,
   fire_apply_trigger          IN   BOOLEAN DEFAULT TRUE,
   schema                      IN   VARCHAR2 DEFAULT NULL,
   container                   IN   VARCHAR2);
</pre>
<pre dir="ltr">DBMS_SQL.PARSE (
   c                           IN   INTEGER, 
   statement                   IN   VARCHAR2A,
   lb                          IN   INTEGER, 
   ub                          IN   INTEGER,
   lfflg                       IN   BOOLEAN, 
   language_flag               IN   INTEGER,
   edition                     IN   VARCHAR2 DEFAULT NULL,
   apply_crossedition_trigger  IN   VARCHAR2 DEFAULT NULL,
   fire_apply_trigger          IN   BOOLEAN DEFAULT TRUE,
   schema                      IN   VARCHAR2 DEFAULT NULL,
   container                   IN   VARCHAR2);

DBMS_SQL.PARSE (
   c                           IN   INTEGER, 
   statement                   IN   VARCHAR2s,
   lb                          IN   INTEGER, 
   ub                          IN   INTEGER,
   lfflg                       IN   BOOLEAN, 
   language_flag               IN   INTEGER,
   edition                     IN   VARCHAR2 DEFAULT NULL,
   apply_crossedition_trigger  IN   VARCHAR2 DEFAULT NULL,
   fire_apply_trigger          IN   BOOLEAN DEFAULT TRUE,
   schema                      IN   VARCHAR2 DEFAULT NULL,
   container                   IN   VARCHAR2);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9608"></a>Parameters</p>
<div id="ARPLS68278" class="tblformal">
<p class="titleintable"><a id="sthref9609"></a><a id="sthref9610"></a>Table 149-27 PARSE Procedure Parameters</p>
<table class="cellalignment4330" title="PARSE Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.PARSE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t46">Parameter</th>
<th class="cellalignment4328" id="r1c2-t46">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t46" headers="r1c1-t46">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t46 r1c2-t46">
<p>ID number of the cursor in which to parse the statement.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t46" headers="r1c1-t46">
<p><code dir="ltr">statement</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t46 r1c2-t46">
<p>SQL statement to be parsed. SQL statements larger than 32K that may be stored in <code dir="ltr">CLOB</code>s.</p>
<p>Unlike a PL/SQL statement, your SQL statement must not include a final semicolon. For example:</p>
<p><code dir="ltr">DBMS_SQL.PARSE</code>(cursor1, &#39;<code dir="ltr">BEGIN</code> proc; <code dir="ltr">END</code>;&#39;, 2);</p>
<p><code dir="ltr">DBMS_SQL.PARSE</code>(cursor1, &#39;<code dir="ltr">INSERT</code> <code dir="ltr">INTO</code> tab <code dir="ltr">VALUES</code>(1)&#39;, 2);</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t46" headers="r1c1-t46">
<p><code dir="ltr">lb</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t46 r1c2-t46">
<p>Lower bound for elements in the statement</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t46" headers="r1c1-t46">
<p><code dir="ltr">ub</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t46 r1c2-t46">
<p>Upper bound for elements in the statement</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t46" headers="r1c1-t46">
<p><code dir="ltr">lfflg</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t46 r1c2-t46">
<p>If <code dir="ltr">TRUE</code>, then insert a linefeed after each element on concatenation.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t46" headers="r1c1-t46">
<p><code dir="ltr">language_flag</code></p>
</td>
<td class="cellalignment4329" headers="r7c1-t46 r1c2-t46">
<p><span class="bold">Note:</span> This parameter is non-operative with Oracle Database 12<span class="italic">c</span>. The parameter is provided for backwards compatibility only.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r8c1-t46" headers="r1c1-t46">
<p><code dir="ltr">edition</code></p>
</td>
<td class="cellalignment4329" headers="r8c1-t46 r1c2-t46">
<p>Specifies the edition in which to run the statement under the following conditions:</p>
<ul>
<li>
<p>If <code dir="ltr">NULL</code> and <code dir="ltr">container</code> is <code dir="ltr">NULL</code>, the statement will be run in the current edition.</p>
</li>
<li>
<p>If a valid container is specified, passing <code dir="ltr">NULL</code> indicates the statement is to run in the target container&#39;s default edition.</p>
</li>
<li>
<p>Given the user and the edition with which the statement is to be executed, the user must have <code dir="ltr">USE</code> privilege on the edition.</p>
</li>
</ul>
<p>The following general conditions apply. The contents of the string are processed as a SQL identifier; double quotation marks must surround the remainder of the string if special characters or lowercase characters are present in the edition&#39;s actual name, and if double quotation marks are not used the contents will be uppercased.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r9c1-t46" headers="r1c1-t46">
<p><code dir="ltr">apply_crossedition_trigger</code></p>
</td>
<td class="cellalignment4329" headers="r9c1-t46 r1c2-t46">
<p>Specifies the unqualified name of a forward crossedition trigger that is to be applied to the specified SQL. The name is resolved using the edition and <code dir="ltr">current_schema</code> setting in which the statement is to be executed. The trigger must be owned by the user that will execute the statement.If a non-<code dir="ltr">NULL</code> value is specified, the specified crossedition trigger will be executed assuming <code dir="ltr">fire_apply_trigger</code> is <code dir="ltr">TRUE</code>, the trigger is enabled, the trigger is defined on the table which is the target of the statement, the type of the statement matches the trigger&#39;s <code dir="ltr">dml_event_clause</code>, any effective <code dir="ltr">WHEN</code> and <code dir="ltr">UPDATE</code> <code dir="ltr">OF</code> restrictions are satisfied, and so on. Other forward crossedition triggers may also be executed, selected using the &#34;crossedition trigger DML rules&#34; applied as if the specified trigger was doing a further DML to the table that is the target of the statement. Non-crossedition triggers and reverse crossedition triggers will not be executed.The contents of the string are processed as a SQL identifier; double quotation marks must surround the remainder of the string if special characters or lowercase characters are present in the trigger&#39;s actual name, and if double quotation marks are not used, the contents will be uppercased.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r10c1-t46" headers="r1c1-t46">
<p><code dir="ltr">fire_apply_trigger</code></p>
</td>
<td class="cellalignment4329" headers="r10c1-t46 r1c2-t46">
<p>Indicates whether the specified <code dir="ltr">apply_crossedition_trigger</code> is itself to be executed, or must only be a guide used in selecting other triggers. This is typically set <code dir="ltr">FALSE</code> when the statement is a replacement for the actions the <code dir="ltr">apply_crossedition_trigger</code> would itself perform. If <code dir="ltr">FALSE</code>, the specified trigger is not executed, but other triggers are still selected for firing as if the specified trigger was doing a DML to the table that is the target of the statement. The <code dir="ltr">apply_crossedition_trigger</code> and <code dir="ltr">fire_apply_trigger</code> parameters are ignored if the statement is not a DML.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r11c1-t46" headers="r1c1-t46">
<p><code dir="ltr">schema</code></p>
</td>
<td class="cellalignment4329" headers="r11c1-t46 r1c2-t46">
<p>Specifies the schema in which to resolve unqualified object names. If <code dir="ltr">NULL</code>, the current schema is the effective user&#39;s schema.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r12c1-t46" headers="r1c1-t46">
<p><code dir="ltr">container</code></p>
</td>
<td class="cellalignment4329" headers="r12c1-t46 r1c2-t46">
<p>Name of the target container in which the cursor is to run. If <code dir="ltr">NULL</code> or unspecified, the name of the target container is that of the calling container and no container switch is performed. If a valid container name is specified, the current user must be a common user with <code dir="ltr">SET</code> <code dir="ltr">CONTAINER</code> privilege to switch to the target container. If a container switch completes, the effective user will have its default roles.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9611"></a>Usage Notes</p>
<ul>
<li>
<p>Using <code dir="ltr">DBMS_SQL</code> to dynamically run DDL statements can cause the program to stop responding. For example, a call to a procedure in a package results in the package being locked until the execution returns to the user side. Any operation that results in a conflicting lock, such as dynamically trying to drop the package before the first lock is released, stops the program from running.</p>
</li>
<li>
<p>Because client-side code cannot reference remote package variables or constants, you must explicitly use the values of the constants.</p>
<p>For example, the following code does <span class="italic">not</span> compile on the client:</p>
<p><code dir="ltr">DBMS_SQL.PARSE</code>(<code dir="ltr">cur_hdl</code>, <code dir="ltr">stmt_str</code>, <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">NATIVE</code>); -- uses constant <code dir="ltr">DBMS_SQL.NATIVE</code></p>
<p>The following code works on the client, because the argument is explicitly provided:</p>
<p><code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code>(<code dir="ltr">cur_hdl</code>, <code dir="ltr">stmt_str</code>, <code dir="ltr">1</code>); -- compiles on the client</p>
</li>
<li>
<p>The <code dir="ltr">VARCHAR2S</code> type is currently supported for backward compatibility of legacy code. However, you are advised to use <code dir="ltr">VARCHAR2A</code> both for its superior capability and because <code dir="ltr">VARCHAR2S</code> will be deprecated in a future release.</p>
</li>
<li>
<p>To parse SQL statements larger than 32 KB, the new <code dir="ltr">CLOB</code> overload version of the PARSE procedure can be used instead of the <code dir="ltr">VARCHAR2A</code> overload.</p>
</li>
<li>
<p>If the <code dir="ltr">container</code> parameter value is the same as the calling container, a container switch will not occur. However, the default roles of the current user will be in effect.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9612"></a>Exceptions</p>
<p>If you create a type, procedure, function, or package using <code dir="ltr">DBMS_SQL</code> that has compilation warnings, an <code dir="ltr">ORA-24344</code> exception is raised, and the PL/SQL unit is still created.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73893" class="refsect2"><a id="CIHIICAG"></a>
<h3 class="refsect2"><a id="sthref9613"></a>RETURN_RESULT Procedures</h3>
<p>This procedure returns the result of an executed statement to the client application.</p>
<p>The result can be retrieved later by the client. Alternatively, it can return the statement result to and be retrieved later by the immediate caller that executes a recursive statement in which this statement result will be returned.</p>
<p>The caller can be:</p>
<ul>
<li>
<p>A PL/SQL stored procedure executing the recursive statement using <code dir="ltr">DBMS_SQL</code></p>
</li>
<li>
<p>A Java stored procedure using JDBC</p>
</li>
<li>
<p>A<code dir="ltr">.NET</code> stored procedure using <code dir="ltr">ADO.NET</code></p>
</li>
<li>
<p>An external procedure using the Oracle Call Interface (OCI)</p>
</li>
</ul>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9614"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.RETURN_RESULT(
   rc           IN OUT      SYS_REFCURSOR, 
   to_client    IN          BOOLEAN           DEFAULT TRUE);

DBMS_SQL.RETURN_RESULT(
   rc           IN OUT      INTEGER, 
   to_client    IN          BOOLEAN           DEFAULT TRUE);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9615"></a>Parameters</p>
<div id="ARPLS73894" class="tblformal">
<p class="titleintable"><a id="sthref9616"></a><a id="sthref9617"></a>Table 149-28 RETURN_RESULT Procedure Parameters</p>
<table class="cellalignment4330" title="RETURN_RESULT Procedure Parameters" summary="This table describes Parameters used by the DBMS_SQL.RETURN_RESULTsubprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t47">Parameter</th>
<th class="cellalignment4328" id="r1c2-t47">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t47" headers="r1c1-t47">
<p><code dir="ltr">rc</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t47 r1c2-t47">
<p>Statement cursor or ref cursor</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t47" headers="r1c1-t47">
<p><code dir="ltr">to_client</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t47 r1c2-t47">
<p>Returns (or does not return) the statement result to the client. If not, it is returned to the immediate caller.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9618"></a>Usage Notes</p>
<ul>
<li>
<p>Currently only a SQL query can be returned, and the return of statement results over remote procedure calls is not supported.</p>
</li>
<li>
<p>Once the statement is returned, it is no longer accessible except by the client or the immediate caller to which it is returned.</p>
</li>
<li>
<p>Statement results cannot be returned when the statement being executed by the client or any intermediate recursive statement is a SQL query and an error is raised.</p>
</li>
<li>
<p>A ref cursor being returned can be strongly or weakly-typed.</p>
</li>
<li>
<p>A query being returned can be partially fetched.</p>
</li>
<li>
<p>Because <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement provides no interface to retrieve the statement results returned from its recursive statement, the cursors of the statement results returned to the caller of the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement will be closed when the statement completes. To retrieve the returned statement results from a recursive statement in PL/SQL, use <code dir="ltr">DBMS_SQL</code> to execute the recursive statement.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9619"></a>Examples</p>
<pre dir="ltr">CREATE PROCEDURE proc AS
  rc1 sys_refcursor;
  rc2 sys_refcursor;
BEGIN
  OPEN rc1 FOR SELECT * FROM t1;
  DBMS_SQL.RETURN_RESULT(rc1);
  OPEN rc2 FOR SELECT * FROM t2;
  DBMS_SQL.RETURN_RESULT(rc2);
END;
/ 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68279" class="refsect2"><a id="CHDJDGDG"></a>
<h3 class="refsect2"><a id="sthref9620"></a>TO_CURSOR_NUMBER Function</h3>
<p>This function takes an <code dir="ltr">OPEN</code>ed strongly or weakly-typed ref cursor and transforms it into a <code dir="ltr">DBMS_SQL</code> cursor number.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9621"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.TO_CURSOR_NUMBER(
   rc IN OUT SYS_REFCURSOR)
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9622"></a>Parameters</p>
<div id="ARPLS68280" class="tblformal">
<p class="titleintable"><a id="sthref9623"></a><a id="sthref9624"></a>Table 149-29 TO_CURSOR_NUMBER Function Parameters</p>
<table class="cellalignment4330" title="TO_CURSOR_NUMBER Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.TO_CURSOR_NUMBER subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t48">Parameter</th>
<th class="cellalignment4328" id="r1c2-t48">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t48" headers="r1c1-t48">
<p><code dir="ltr">rc</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t48 r1c2-t48">
<p><code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> to be transformed into a cursor number</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9625"></a>Return Values</p>
<p>Returns a DBMS_SQL manageable cursor number transformed from a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code></p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9626"></a>Usage Notes</p>
<ul>
<li>
<p>The <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> passed in has to be <code dir="ltr">OPEN</code>ed, otherwise an error is raised.</p>
</li>
<li>
<p>Once the <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> is transformed into a <code dir="ltr">DBMS_SQL</code> cursor number, the <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> is no longer accessible by any native dynamic SQL operations.</p>
</li>
<li>
<p>The <code dir="ltr">DBMS_SQL</code> cursor that is returned by this subprogram performs in the same way as a <code dir="ltr">DBMS_SQL</code> cursor that has already been executed.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9627"></a>Examples</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE DO_QUERY(sql_stmt VARCHAR2) IS
  TYPE CurType IS REF CURSOR;
  src_cur         CurType;
  curid           NUMBER;
  desctab         DBMS_SQL.DESC_TAB;
  colcnt          NUMBER;
  namevar         VARCHAR2(50);
  numvar          NUMBER;
  datevar         DATE;
  empno           NUMBER := 100;
BEGIN
 
 
    -- sql_stmt := &#39;select ...... from employees where employee_id = :b1&#39;;
    OPEN src_cur FOR sql_stmt USING empno;
 
    -- Switch from native dynamic SQL to DBMS_SQL
    curid := DBMS_SQL.TO_CURSOR_NUMBER (src_cur);
 
    DBMS_SQL.DESCRIBE_COLUMNS(curid, colcnt, desctab);
 
    -- Define columns
    FOR i IN 1 .. colcnt LOOP
        IF desctab(i).col_type = 2 THEN
           DBMS_SQL.DEFINE_COLUMN(curid, i, numvar);
        ELSIF desctab(i).col_type = 12 THEN
            DBMS_SQL.DEFINE_COLUMN(curid, i, datevar);
.......
         ELSE
            DBMS_SQL.DEFINE_COLUMN(curid, i, namevar, 25);
         END IF;
    END LOOP;
 
  -- Fetch Rows
    WHILE DBMS_SQL.FETCH_ROWS(curid) &gt; 0 LOOP
        FOR i IN 1 .. colcnt LOOP
          IF (desctab(i).col_type = 1) THEN
            DBMS_SQL.COLUMN_VALUE(curid, i, namevar);
         ELSIF (desctab(i).col_type = 2) THEN
            DBMS_SQL.COLUMN_VALUE(curid, i, numvar);
          ELSIF (desctab(i).col_type = 12) THEN
            DBMS_SQL.COLUMN_VALUE(curid, i, datevar);
....
          END IF;
        END LOOP;
    END LOOP;
 
    DBMS_SQL.CLOSE_CURSOR(curid);
END;
/ 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68281" class="refsect2"><a id="CHDFDCDE"></a>
<h3 class="refsect2"><a id="sthref9628"></a>TO_REFCURSOR Function</h3>
<p>This function takes an <code dir="ltr">OPEN</code>ed, <code dir="ltr">PARSE</code>d, and <code dir="ltr">EXECUTE</code>d cursor and transforms/migrates it into a PL/SQL manageable <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> (a weakly-typed cursor) that can be consumed by PL/SQL native dynamic SQL switched to use native dynamic SQL. This subprogram is only used with <code dir="ltr">SELECT</code> cursors.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9629"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.TO_REFCURSOR(
   cursor_number IN OUT INTEGER)
  RETURN SYS_REFCURSOR;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9630"></a>Parameters</p>
<div id="ARPLS68282" class="tblformal">
<p class="titleintable"><a id="sthref9631"></a><a id="sthref9632"></a>Table 149-30 TO_REFCURSOR Function Parameters</p>
<table class="cellalignment4330" title="TO_REFCURSOR Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.IS_OPEN subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t49">Parameter</th>
<th class="cellalignment4328" id="r1c2-t49">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t49" headers="r1c1-t49">
<p><code dir="ltr">cursor_number</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t49 r1c2-t49">
<p>Cursor number of the cursor to be transformed into <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9633"></a>Return Values</p>
<p>Returns a PL/SQL <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> transformed from a <code dir="ltr">DBMS_SQL</code> cursor number</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9634"></a>Usage Notes</p>
<ul>
<li>
<p>The cursor passed in by the <code dir="ltr">cursor_number</code> has to be <code dir="ltr">OPEN</code>ed, <code dir="ltr">PARSE</code>d, and <code dir="ltr">EXECUTE</code>d; otherwise an error is raised.</p>
</li>
<li>
<p>Once the cursor_number is transformed into a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code>, the <code dir="ltr">cursor_number</code> is no longer accessible by any <code dir="ltr">DBMS_SQL</code> operations.</p>
</li>
<li>
<p>After a cursor_number is transformed into a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code>, using <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">IS_OPEN</code> to check to see if the <code dir="ltr">cursor_number</code> is still open results in an error.</p>
</li>
<li>
<p>If the cursor number was last parsed with a valid container parameter, it cannot be converted to a <code dir="ltr">REF CURSOR</code>.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9635"></a>Examples</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE DO_QUERY(mgr_id NUMBER) IS
  TYPE CurType IS REF CURSOR;
  src_cur         CurType;
  curid           NUMBER;
  sql_stmt        VARCHAR2(200);
  ret             INTEGER;
  empnos          DBMS_SQL.Number_Table;
  depts           DBMS_SQL.Number_Table;
BEGIN

  -- DBMS_SQL.OPEN_CURSOR
  curid := DBMS_SQL.OPEN_CURSOR;
 
  sql_stmt :=    &#39;SELECT EMPLOYEE_ID, DEPARTMENT_ID from employees where MANAGER_ID = :b1&#39;;

  DBMS_SQL.PARSE(curid, sql_stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_VARIABLE(curid, &#39;b1&#39;, mgr_id);
  ret := DBMS_SQL.EXECUTE(curid);

  -- Switch from DBMS_SQL to native dynamic SQL
  src_cur := DBMS_SQL.TO_REFCURSOR(curid);

  -- Fetch with native dynamic SQL
  FETCH src_cur BULK COLLECT INTO empnos, depts;

  IF empnos.COUNT &gt; 0 THEN
    DBMS_OUTPUT.PUT_LINE(&#39;EMPNO DEPTNO&#39;);
    DBMS_OUTPUT.PUT_LINE(&#39;----- ------&#39;);
    -- Loop through the empnos and depts collections
    FOR i IN 1 .. empnos.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE(empnos(i) || &#39;   &#39; || depts(i));
    END LOOP;
  END IF;
   -- Close cursor
  CLOSE src_cur;
END;
/ 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68283" class="refsect2"><a id="i998371"></a>
<h3 class="refsect2"><a id="sthref9636"></a>VARIABLE_VALUE Procedures</h3>
<p>This procedure returns the value of the named variable for a given cursor. It is used to return the values of bind variables inside PL/SQL blocks or DML statements with <code dir="ltr">returning</code> clause.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9637"></a>Syntax</p>
<pre dir="ltr">DBMS_SQL.VARIABLE_VALUE (
   c               IN  INTEGER,
   name            IN  VARCHAR2,
   value           OUT NOCOPY &lt;datatype&gt;);
 
</pre>
<p>Where &lt;datatype&gt; can be any one of the following types:</p>
<pre dir="ltr">BINARY_DOUBLE
BINARY_FLOAT
BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
DSINTERVAL_UNCONSTRAINED
NUMBER
TIME_TZ_UNCONSTRAINED
TIME_UNCONSTRAINED
TIMESTAMP_LTZ_UNCONSTRAINED
TIMESTAMP_TZ_UNCONSTRAINED
TIMESTAMP_UNCONSTRAINED
UROWID
VARCHAR2 CHARACTER SET ANY_CS
YMINTERVAL_UNCONSTRAINED
user-defined object types
collections (VARRAYs and nested tables)
REFs
Opaque types
</pre>
<p>For variables containing <code dir="ltr">CHAR</code>, <code dir="ltr">RAW</code>, and <code dir="ltr">ROWID</code> data, you can use the following variations on the syntax:</p>
<pre dir="ltr">DBMS_SQL.VARIABLE_VALUE_CHAR (
   c               IN  INTEGER,
   name            IN  VARCHAR2,
   value           OUT CHAR CHARACTER SET ANY_CS);

DBMS_SQL.VARIABLE_VALUE_RAW (
   c               IN  INTEGER,
   name            IN  VARCHAR2,
   value           OUT RAW);

DBMS_SQL.VARIABLE_VALUE_ROWID (
   c               IN  INTEGER,
   name            IN  VARCHAR2,
   value           OUT ROWID);
</pre>
<p>The following syntax enables the <code dir="ltr">VARIABLE_VALUE</code> procedure to accommodate bulk operations:</p>
<pre dir="ltr">DBMS_SQL.VARIABLE_VALUE ( 
   c                 IN   INTEGER, 
   name              IN   VARCHAR2,
   value             OUT NOCOPY &lt;table_type&gt;); 
</pre>
<p>For bulk operations, &lt;<code dir="ltr">table_type</code>&gt; can be:</p>
<pre dir="ltr">Binary_Double_Table
Binary_Float_Table
Bfile_Table
Blob_Table
Clob_Table
Date_Table
Interval_Day_To_Second_Table
Interval_Year_To_Month_Table
Number_Table
Time_Table
Time_With_Time_Zone_Table
Timestamp_Table
Timestamp_With_ltz_Table;
Timestamp_With_Time_Zone_Table
Urowid_Table
Varchar2_Table
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9638"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(variable_value,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9639"></a>Parameters</p>
<div id="ARPLS68284" class="tblformal">
<p class="titleintable"><a id="sthref9640"></a><a id="sthref9641"></a>Table 149-31 VARIABLE_VALUE Procedure Parameters</p>
<table class="cellalignment4330" title="VARIABLE_VALUE Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.VARIABLE_VALUE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t50">Parameter</th>
<th class="cellalignment4328" id="r1c2-t50">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t50" headers="r1c1-t50">
<p><code dir="ltr">c</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t50 r1c2-t50">
<p>ID number of the cursor from which to get the values.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t50" headers="r1c1-t50">
<p><code dir="ltr">name</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t50 r1c2-t50">
<p>Name of the variable for which you are retrieving the value.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t50" headers="r1c1-t50">
<p><code dir="ltr">value</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t50 r1c2-t50">
<ul>
<li>
<p>Single row option: Returns the value of the variable for the specified position. Oracle raises the exception <code dir="ltr">ORA-06562</code>, <code dir="ltr">inconsistent_type</code>, if the type of this output parameter differs from the actual type of the value, as defined by the call to <code dir="ltr">BIND_VARIABLE</code>.</p>
</li>
<li>
<p>Array option: Local variable that has been declared &lt;<code dir="ltr">table_type</code>&gt;. For bulk operations, <code dir="ltr">value</code> is an <code dir="ltr">OUT</code> <code dir="ltr">NOCOPY</code> parameter.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" --></div>
<!-- class="refentry" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4320">
<tr>
<td class="cellalignment4329">
<table class="cellalignment4325">
<tr>
<td class="cellalignment4324"><a href="d_spm.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4324"><a href="d_sql_trans.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4332">
<table class="cellalignment4323">
<tr>
<td class="cellalignment4324"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4324"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4324"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4324"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4324"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4324"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>