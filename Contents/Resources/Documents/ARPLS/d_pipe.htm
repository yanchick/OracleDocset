<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-2313"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/DBMS_PIPE"></a><title>DBMS_PIPE</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1086"/>
<meta name="dcterms.created" content="2016-09-02T5:36:27Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database PL/SQL Packages and Types Reference"/>
<meta name="dcterms.identifier" content="E41829-07"/>
<meta name="dcterms.isVersionOf" content="ARPLS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="d_perf.htm" title="Previous" type="text/html"/>
<link rel="Next" href="d_predan.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41829-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">116/290</span> <!-- End Header -->
<div id="ARPLS038" class="chapter"><a id="CHDDFCFC"></a>
<h1 class="chapter"><span class="secnum">112</span> DBMS_PIPE</h1>
<p>The <a id="sthref6976"></a><code dir="ltr">DBMS_PIPE</code> package lets two or more sessions in the same instance communicate. Oracle pipes are similar in concept to the pipes used in UNIX, but Oracle pipes are not implemented using the operating system pipe mechanisms.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDJHGEB">Using DBMS_PIPE</a></p>
<ul>
<li>
<p>Overview</p>
</li>
<li>
<p>Security Model</p>
</li>
<li>
<p>Constants</p>
</li>
<li>
<p>Operational Notes</p>
</li>
<li>
<p>Exceptions</p>
</li>
<li>
<p>Examples</p>
</li>
</ul>
</li>
<li>
<p><a href="#i1004370">Summary of DBMS_PIPE Subprograms</a></p>
</li>
</ul>
<div class="refentry"><a id="CHDJHGEB"></a>
<div id="ARPLS67392" class="refsect1">
<h2 class="refsect1">Using DBMS_PIPE</h2>
<ul>
<li>
<p><a href="#i1003916">Overview</a></p>
</li>
<li>
<p><a href="#i1004009">Security Model</a></p>
</li>
<li>
<p><a href="#i1004010">Constants</a></p>
</li>
<li>
<p><a href="#i1003879">Operational Notes</a></p>
</li>
<li>
<p><a href="#i1004025">Exceptions</a></p>
</li>
<li>
<p><a href="#i1004928">Examples</a></p>
</li>
</ul>
<div id="ARPLS67393" class="refsect2"><a id="i1003916"></a>
<h3 class="refsect2">Overview</h3>
<p>Pipe functionality has several potential applications:</p>
<ul>
<li>
<p>External service interface: You can communicate with user-written services that are external to the RDBMS. This can be done effectively in a shared server process, so that several instances of the service are executing simultaneously. Additionally, the services are available asynchronously. The requestor of the service does not need to block a waiting reply. The requestor can check (with or without time out) at a later time. The service can be written in any of the 3GL languages that Oracle supports.</p>
</li>
<li>
<p>Independent transactions: The pipe can communicate to a separate session which can perform an operation in an independent transaction (such as logging an attempted security violation detected by a trigger).</p>
</li>
<li>
<p>Alerters (non-transactional): You can post another process without requiring the waiting process to poll. If an &#34;after-row&#34; or &#34;after-statement&#34; trigger were to alert an application, then the application would treat this alert as an indication that the data probably changed. The application would then read the data to get the current value. Because this is an &#34;after&#34; trigger, the application would want to do a &#34;<code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code>&#34; to make sure it read the correct data.</p>
</li>
<li>
<p>Debugging: Triggers and stored procedures can send debugging information to a pipe. Another session can keep reading out of the pipe and display it on the screen or write it to a file.</p>
</li>
<li>
<p>Concentrator: This is useful for multiplexing large numbers of users over a fewer number of network connections, or improving performance by concentrating several user-transactions into one DBMS transaction.</p>
</li>
</ul>
</div>
<!-- class="refsect2" -->
<div id="ARPLS67394" class="refsect2"><a id="i1004009"></a>
<h3 class="refsect2">Security Model</h3>
<p>Security can be achieved by use of <code dir="ltr">GRANT</code> <code dir="ltr">EXECUTE</code> on the <code dir="ltr">DBMS_PIPE</code> package by creating a pipe using the <code dir="ltr">private</code> parameter in the <code dir="ltr">CREATE_PIPE</code> function and by writing cover packages that only expose particular features or pipenames to particular users or roles.</p>
<p>Depending upon your security requirements, you may choose to use either <a href="#i996755">Public Pipes</a> or <a href="#i1003839">Private Pipes</a>.</p>
</div>
<!-- class="refsect2" -->
<div id="ARPLS67395" class="refsect2"><a id="i1004010"></a>
<h3 class="refsect2">Constants</h3>
<pre dir="ltr">maxwait   constant integer := 86400000; /* 1000 days */ 
</pre>
<p>This is the maximum time to wait attempting to send or receive a message.</p>
</div>
<!-- class="refsect2" -->
<div id="ARPLS67396" class="refsect2"><a id="i1003879"></a>
<h3 class="refsect2">Operational Notes</h3>
<p>Information sent through Oracle pipes is buffered in the system global area (SGA). All information in pipes is lost when the instance is shut down.</p>
<div class="infoboxnotewarn">
<p class="notep1"><span class="bold">Caution</span>:</p>
<p class="warnsp">Pipes are independent of transactions. Be careful using pipes when transaction control can be affected.</p>
</div>
<p>The operation of DBMS_PIPE is considered with regard to the following topics:</p>
<ul>
<li>
<p><a href="#i996755">Public Pipes</a></p>
</li>
<li>
<p><a href="#i1003838">Writing and Reading Pipes</a></p>
</li>
<li>
<p><a href="#i1003839">Private Pipes</a></p>
</li>
</ul>
<div id="ARPLS67397" class="refsect3"><a id="i996755"></a>
<h4 class="refsect3">Public Pipes</h4>
<p>You may create a public pipe either implicitly or explicitly. For <span class="italic">implicit</span> public pipes, the pipe is automatically created when it is referenced for the first time, and it disappears when it no longer contains data. Because the pipe descriptor is stored in the SGA, there is some space usage overhead until the empty pipe is aged out of the cache.</p>
<p>You create an <span class="italic">explicit</span> public pipe by calling the <code dir="ltr">CREATE_PIPE</code> function with the <code dir="ltr">private</code> flag set to <code dir="ltr">FALSE</code>. You must deallocate explicitly-created pipes by calling the <code dir="ltr">REMOVE_PIPE</code> function.</p>
<p>The domain of a public pipe is the schema in which it was created, either explicitly or implicitly.</p>
</div>
<!-- class="refsect3" -->
<div id="ARPLS67398" class="refsect3"><a id="i1003838"></a>
<h4 class="refsect3">Writing and Reading Pipes</h4>
<p>Each public pipe works asynchronously. Any number of schema users can write to a public pipe, as long as they have <code dir="ltr">EXECUTE</code> permission on the <code dir="ltr">DBMS_PIPE</code> package, and they know the name of the public pipe. However, once buffered information is read by one user, it is emptied from the buffer, and is not available for other readers of the same pipe.</p>
<p>The sending session builds a message using one or more calls to the <code dir="ltr">PACK_MESSAGE</code> procedure. This procedure adds the message to the session&#39;s local message buffer. The information in this buffer is sent by calling the <code dir="ltr">SEND_MESSAGE</code> function, designating the pipe name to be used to send the message. When <code dir="ltr">SEND_MESSAGE</code> is called, all messages that have been stacked in the local buffer are sent.</p>
<p>A process that wants to receive a message calls the <code dir="ltr">RECEIVE_MESSAGE</code> function, designating the pipe name from which to receive the message. The process then calls the <code dir="ltr">UNPACK_MESSAGE</code> procedure to access each of the items in the message.</p>
</div>
<!-- class="refsect3" -->
<div id="ARPLS67399" class="refsect3"><a id="i1003839"></a>
<h4 class="refsect3">Private Pipes</h4>
<p>You explicitly create a private pipe by calling the <code dir="ltr">CREATE_PIPE</code> function. Once created, the private pipe persists in shared memory until you explicitly deallocate it by calling the <code dir="ltr">REMOVE_PIPE</code> function. A private pipe is also deallocated when the database instance is shut down.</p>
<p>You cannot create a private pipe if an implicit pipe exists in memory and has the same name as the private pipe you are trying to create. In this case, <code dir="ltr">CREATE_PIPE</code> returns an error.</p>
<p>Access to a private pipe is restricted to:</p>
<ul>
<li>
<p>Sessions running under the same userid as the creator of the pipe</p>
</li>
<li>
<p>Stored subprograms executing in the same userid privilege domain as the pipe creator</p>
</li>
<li>
<p>Users connected as <code dir="ltr">SYSDBA</code></p>
</li>
</ul>
<p>An attempt by any other user to send or receive messages on the pipe, or to remove the pipe, results in an immediate error. Any attempt by another user to create a pipe with the same name also causes an error.</p>
<p>As with public pipes, you must first build your message using calls to <code dir="ltr">PACK_MESSAGE</code> before calling <code dir="ltr">SEND_MESSAGE</code>. Similarly, you must call <code dir="ltr">RECEIVE_MESSAGE</code> to retrieve the message before accessing the items in the message by calling <code dir="ltr">UNPACK_MESSAGE</code>.</p>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67400" class="refsect2"><a id="i1004025"></a>
<h3 class="refsect2">Exceptions</h3>
<p><a id="i1004350"></a><code dir="ltr">DBMS_PIPE</code> package subprograms can return the following errors:</p>
<div id="ARPLS67401" class="tblformal">
<p class="titleintable"><a id="sthref6977"></a><a id="sthref6978"></a>Table 112-1 DBMS_PIPE Errors</p>
<table class="cellalignment4330" title="DBMS_PIPE Errors " summary="This table describes the Exceptions raised by the DBMS_PIPE subprograms." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t3">Error</th>
<th class="cellalignment4328" id="r1c2-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t3" headers="r1c1-t3">
<p><code dir="ltr">ORA-23321:</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t3 r1c2-t3">
<p>Pipename may not be null. This can be returned by the <code dir="ltr">CREATE_PIPE</code> function, or any subprogram that takes a pipe name as a parameter.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t3" headers="r1c1-t3">
<p><code dir="ltr">ORA-23322:</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t3 r1c2-t3">
<p>Insufficient privilege to access pipe. This can be returned by any subprogram that references a private pipe in its parameter list.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67402" class="refsect2"><a id="i1004928"></a>
<h3 class="refsect2">Examples</h3>
<ul>
<li>
<p><a href="#i1004377">Example 1: Debugging - PL/SQL</a></p>
</li>
<li>
<p><a href="#i1004912">Example 3: Execute System Commands</a></p>
</li>
<li>
<p><a href="#i1004913">Example 4: External Service Interface</a></p>
</li>
</ul>
<div id="ARPLS67403" class="refsect3"><a id="i1004377"></a>
<h4 class="refsect3">Example 1: Debugging - PL/SQL</h4>
<p>This example shows the procedure that a PL/SQL program can call to place debugging information in a pipe.</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE debug (msg VARCHAR2) AS
    status  NUMBER;
BEGIN
  DBMS_PIPE.PACK_MESSAGE(LENGTH(msg));
  DBMS_PIPE.PACK_MESSAGE(msg);
  status := DBMS_PIPE.SEND_MESSAGE(&#39;plsql_debug&#39;);
  IF status != 0 THEN
    raise_application_error(-20099, &#39;Debug error&#39;);
  END IF;
END debug;
</pre></div>
<!-- class="refsect3" -->
<div id="ARPLS67404" class="refsect3"><a id="sthref6979"></a>
<h4 class="refsect3">Example 2: Debugging - Pro*C</h4>
<p>The following Pro*C code receives messages from the <code dir="ltr">PLSQL_DEBUG</code> pipe in the previous example, and displays the messages. If the Pro*C session is run in a separate window, then it can be used to display any messages that are sent to the debug procedure from a PL/SQL program executing in a separate session.</p>
<pre dir="ltr">#include &lt;stdio.h&gt; 
#include &lt;string.h&gt; 
 
EXEC SQL BEGIN DECLARE SECTION; 
   VARCHAR username[20]; 
   int     status; 
   int     msg_length;
   char    retval[2000];
EXEC SQL END DECLARE SECTION; 
 
EXEC SQL INCLUDE SQLCA; 
 
void sql_error(); 
 
main() 
{ 

-- Prepare username:
   strcpy(username.arr, &#34;SCOTT/TIGER&#34;); 
   username.len = strlen(username.arr); 
 
   EXEC SQL WHENEVER SQLERROR DO sql_error(); 
   EXEC SQL CONNECT :username; 
 
   printf(&#34;connected\n&#34;); 
 
-- Start an endless loop to look for and print messages on the pipe:
   FOR (;;) 
   { 
      EXEC SQL EXECUTE 
         DECLARE 
            len INTEGER;
            typ INTEGER;
            sta INTEGER; 
            chr VARCHAR2(2000); 
         BEGIN 
            chr := &#39;&#39;; 
            sta := dbms_pipe.receive_message(&#39;plsql_debug&#39;); 
            IF sta = 0 THEN 
               DBMS_PIPE.UNPACK_MESSAGE(len);
               DBMS_PIPE.UNPACK_MESSAGE(chr); 
            END IF; 
            :status := sta; 
            :retval := chr; 
            IF len IS NOT NULL THEN
               :msg_length := len;
            ELSE
               :msg_length := 2000;
            END IF;
         END; 
      END-EXEC; 
      IF (status == 0) 
         printf(&#34;\n%.*s\n&#34;, msg_length, retval);
      ELSE 
         printf(&#34;abnormal status, value is %d\n&#34;, status); 
   }
}

void sql_error() 
{ 
   char msg[1024]; 
   int rlen, len; 
   len = sizeof(msg); 
   sqlglm(msg, &amp;len, &amp;rlen); 
   printf(&#34;ORACLE ERROR\n&#34;); 
   printf(&#34;%.*s\n&#34;, rlen, msg); 
   exit(1); 
} 
</pre></div>
<!-- class="refsect3" -->
<div id="ARPLS67405" class="refsect3"><a id="i1004912"></a>
<h4 class="refsect3">Example 3: Execute System Commands</h4>
<p>This example shows PL/SQL and Pro*C code let a PL/SQL stored procedure (or anonymous block) call PL/SQL procedures to send commands over a pipe to a Pro*C program that is listening for them.</p>
<p>The Pro*C program sleeps and waits for a message to arrive on the named pipe. When a message arrives, the Pro*C program processes it, carrying out the required action, such as executing a UNIX command through the <span class="italic">system</span>() call or executing a SQL command using embedded SQL.</p>
<p><code dir="ltr">DAEMON.SQL</code> is the source code for the PL/SQL package. This package contains procedures that use the <code dir="ltr">DBMS_PIPE</code> package to send and receive message to and from the Pro*C daemon. Note that full handshaking is used. The daemon always sends a message back to the package (except in the case of the <code dir="ltr">STOP</code> command). This is valuable, because it allows the PL/SQL procedures to be sure that the Pro*C daemon is running.</p>
<p>You can call the DAEMON packaged procedures from an anonymous PL/SQL block using SQL*Plus or Enterprise Manager. For example:</p>
<pre dir="ltr">SQLPLUS&gt; variable rv number
SQLPLUS&gt; execute :rv := DAEMON.EXECUTE_SYSTEM(&#39;ls -la&#39;);
</pre>
<p>On a UNIX system, this causes the Pro*C daemon to execute the command <span class="italic">system</span>(&#34;<span class="italic">ls -la</span>&#34;).</p>
<p>Remember that the daemon needs to be running first. You might want to run it in the background, or in another window beside the SQL*Plus or Enterprise Manager session from which you call it.</p>
<p>The <code dir="ltr">DAEMON</code>.<code dir="ltr">SQL</code> also uses the <code dir="ltr">DBMS_OUTPUT</code> package to display the results. For this example to work, you must have execute privileges on this package.</p>
<p>DAEMON.SQL Example. This is the code for the PL/SQL <code dir="ltr">DAEMON</code> package:</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE daemon AS
  FUNCTION execute_sql(command VARCHAR2, 
                       timeout NUMBER DEFAULT 10)
    RETURN NUMBER;

  FUNCTION execute_system(command VARCHAR2,
                          timeout NUMBER DEFAULT 10)
    RETURN NUMBER;

  PROCEDURE stop(timeout NUMBER DEFAULT 10);
END daemon;
/
CREATE OR REPLACE PACKAGE BODY daemon AS

  FUNCTION execute_system(command VARCHAR2,
                          timeout NUMBER DEFAULT 10)
  RETURN NUMBER IS

    status       NUMBER;
    result       VARCHAR2(20);
    command_code NUMBER;
    pipe_name    VARCHAR2(30);
  BEGIN
    pipe_name := DBMS_PIPE.UNIQUE_SESSION_NAME;

    DBMS_PIPE.PACK_MESSAGE(&#39;SYSTEM&#39;);
    DBMS_PIPE.PACK_MESSAGE(pipe_name);
    DBMS_PIPE.PACK_MESSAGE(command);
    status := DBMS_PIPE.SEND_MESSAGE(&#39;daemon&#39;, timeout);
    IF status &lt;&gt; 0 THEN
      RAISE_APPLICATION_ERROR(-20010,
        &#39;Execute_system: Error while sending.  Status = &#39; ||
         status);
    END IF;

    status := DBMS_PIPE.RECEIVE_MESSAGE(pipe_name, timeout);
    IF status &lt;&gt; 0 THEN
      RAISE_APPLICATION_ERROR(-20011,
        &#39;Execute_system: Error while receiving. 
         Status = &#39; || status);
    END IF;

    DBMS_PIPE.UNPACK_MESSAGE(result);
    IF result &lt;&gt; &#39;done&#39; THEN
      RAISE_APPLICATION_ERROR(-20012,
        &#39;Execute_system: Done not received.&#39;);
    END IF;

    DBMS_PIPE.UNPACK_MESSAGE(command_code);
    DBMS_OUTPUT.PUT_LINE(&#39;System command executed.  result = &#39; ||
                         command_code);
    RETURN command_code;
  END execute_system;

  FUNCTION execute_sql(command VARCHAR2,
                       timeout NUMBER DEFAULT 10)
  RETURN NUMBER IS

    status       NUMBER;
    result       VARCHAR2(20);
    command_code NUMBER;
    pipe_name    VARCHAR2(30);

  BEGIN
    pipe_name := DBMS_PIPE.UNIQUE_SESSION_NAME;

    DBMS_PIPE.PACK_MESSAGE(&#39;SQL&#39;);
    DBMS_PIPE.PACK_MESSAGE(pipe_name);
    DBMS_PIPE.PACK_MESSAGE(command);
    status := DBMS_PIPE.SEND_MESSAGE(&#39;daemon&#39;, timeout);
    IF status &lt;&gt; 0 THEN
      RAISE_APPLICATION_ERROR(-20020,
        &#39;Execute_sql: Error while sending.  Status = &#39; || status);
    END IF;

    status := DBMS_PIPE.RECEIVE_MESSAGE(pipe_name, timeout);

    IF status &lt;&gt; 0 THEN
      RAISE_APPLICATION_ERROR(-20021,
        &#39;execute_sql: Error while receiving.  
         Status = &#39; || status);
    END IF;

    DBMS_PIPE.UNPACK_MESSAGE(result);
    IF result &lt;&gt; &#39;done&#39; THEN
      RAISE_APPLICATION_ERROR(-20022,
        &#39;execute_sql: done not received.&#39;);
    END IF;

    DBMS_PIPE.UNPACK_MESSAGE(command_code);
    DBMS_OUTPUT.PUT_LINE
        (&#39;SQL command executed.  sqlcode = &#39; || command_code);
    RETURN command_code;
  END execute_sql;

  PROCEDURE stop(timeout NUMBER DEFAULT 10) IS
    status NUMBER;
  BEGIN
    DBMS_PIPE.PACK_MESSAGE(&#39;STOP&#39;);
    status := DBMS_PIPE.SEND_MESSAGE(&#39;daemon&#39;, timeout);
    IF status &lt;&gt; 0 THEN
      RAISE_APPLICATION_ERROR(-20030,
        &#39;stop: error while sending.  status = &#39; || status);
    END IF;
  END stop;
END daemon;
</pre>
<p>daemon.pc Example. This is the code for the Pro*C daemon. You must precompile this using the Pro*C Precompiler, Version 1.5.x or later. You must also specify the <code dir="ltr">USERID</code> and <code dir="ltr">SQLCHECK</code> options, as the example contains embedded PL/SQL code.</p>
<div class="infoboxnotewarn">
<p class="notep1">Note:</p>
To use a <code dir="ltr">VARCHAR</code> output host variable in a PL/SQL block, you must initialize the length component before entering the block.</div>
<pre dir="ltr">proc iname=daemon userid=scott/tiger sqlcheck=semantics
</pre>
<p>Then C-compile and link in the normal way.</p>
<pre dir="ltr">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
  char *uid = &#34;scott/tiger&#34;;
  int status;
  VARCHAR command[20];
  VARCHAR value[2000];
  VARCHAR return_name[30];
EXEC SQL END DECLARE SECTION;

void
connect_error()
{
  char msg_buffer[512];
  int msg_length;
  int buffer_size = 512;

  EXEC SQL WHENEVER SQLERROR CONTINUE;
  sqlglm(msg_buffer, &amp;buffer_size, &amp;msg_length);
  printf(&#34;Daemon error while connecting:\n&#34;);
  printf(&#34;%.*s\n&#34;, msg_length, msg_buffer);
  printf(&#34;Daemon quitting.\n&#34;);
  exit(1);
}

void
sql_error()
{
  char msg_buffer[512];
  int msg_length;
  int buffer_size = 512;

  EXEC SQL WHENEVER SQLERROR CONTINUE;
  sqlglm(msg_buffer, &amp;buffer_size, &amp;msg_length);
  printf(&#34;Daemon error while executing:\n&#34;);
  printf(&#34;%.*s\n&#34;, msg_length, msg_buffer);
  printf(&#34;Daemon continuing.\n&#34;);
}
main()
{
command.len = 20; /*initialize length components*/ 
value.len = 2000; 
return_name.len  = 30; 
  EXEC SQL WHENEVER SQLERROR DO connect_error();
  EXEC SQL CONNECT :uid;
  printf(&#34;Daemon connected.\n&#34;);

  EXEC SQL WHENEVER SQLERROR DO sql_error();
  printf(&#34;Daemon waiting...\n&#34;);
  while (1) {
    EXEC SQL EXECUTE
      BEGIN
        :status := DBMS_PIPE.RECEIVE_MESSAGE(&#39;daemon&#39;);
        IF :status = 0 THEN
          DBMS_PIPE.UNPACK_MESSAGE(:command);
        END IF;
      END;
    END-EXEC;
    IF (status == 0)
    {
      command.arr[command.len] = &#39;\0&#39;;
      IF (!strcmp((char *) command.arr, &#34;STOP&#34;))
      {
        printf(&#34;Daemon exiting.\n&#34;);
        break;
      }

      ELSE IF (!strcmp((char *) command.arr, &#34;SYSTEM&#34;))
      {
        EXEC SQL EXECUTE
          BEGIN
            DBMS_PIPE.UNPACK_MESSAGE(:return_name);
            DBMS_PIPE.UNPACK_MESSAGE(:value);
          END;
        END-EXEC;
        value.arr[value.len] = &#39;\0&#39;;
        printf(&#34;Will execute system command &#39;%s&#39;\n&#34;, value.arr);

        status = system(value.arr);
        EXEC SQL EXECUTE
          BEGIN
            DBMS_PIPE.PACK_MESSAGE(&#39;done&#39;);
            DBMS_PIPE.PACK_MESSAGE(:status);
            :status := DBMS_PIPE.SEND_MESSAGE(:return_name);
          END;
        END-EXEC;

        IF (status)
        {
          printf
           (&#34;Daemon error while responding to system command.&#34;);
          printf(&#34;  status: %d\n&#34;, status);
        }
      }
      ELSE IF (!strcmp((char *) command.arr, &#34;SQL&#34;)) {
        EXEC SQL EXECUTE
          BEGIN
            DBMS_PIPE.UNPACK_MESSAGE(:return_name);
            DBMS_PIPE.UNPACK_MESSAGE(:value);
          END;
        END-EXEC;
        value.arr[value.len] = &#39;\0&#39;;
        printf(&#34;Will execute sql command &#39;%s&#39;\n&#34;, value.arr);

        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL EXECUTE IMMEDIATE :value;
        status = sqlca.sqlcode;

        EXEC SQL WHENEVER SQLERROR DO sql_error();
        EXEC SQL EXECUTE
          BEGIN
            DBMS_PIPE.PACK_MESSAGE(&#39;done&#39;);
            DBMS_PIPE.PACK_MESSAGE(:status);
            :status := DBMS_PIPE.SEND_MESSAGE(:return_name);
          END;
        END-EXEC;

        IF (status)
        {
          printf(&#34;Daemon error while responding to sql command.&#34;);
          printf(&#34;  status: %d\n&#34;, status);
        }
      }
      ELSE
      {
        printf
          (&#34;Daemon error: invalid command &#39;%s&#39; received.\n&#34;,
            command.arr);
      }
    }
    ELSE
    {
      printf(&#34;Daemon error while waiting for signal.&#34;);
      printf(&#34;  status = %d\n&#34;, status);
    }
  }
  EXEC SQL COMMIT WORK RELEASE;
  exit(0);
</pre></div>
<!-- class="refsect3" -->
<div id="ARPLS67406" class="refsect3"><a id="i1004913"></a>
<h4 class="refsect3">Example 4: External Service Interface</h4>
<p>Put the user-written 3GL code into an OCI or Precompiler program. The program connects to the database and executes PL/SQL code to read its request from the pipe, computes the result, and then executes PL/SQL code to send the result on a pipe back to the requestor.</p>
<p>Below is an example of a stock service request. The recommended sequence for the arguments to pass on the pipe for all service requests is:</p>
<pre dir="ltr">      protocol_version      VARCHAR2        - &#39;1&#39;, 10 bytes or less
      returnpipe            VARCHAR2        - 30 bytes or less
      service               VARCHAR2        - 30 bytes or less
      arg1                  VARCHAR2/NUMBER/DATE
         ...
      argn                  VARCHAR2/NUMBER/DATE
</pre>
<p>The recommended format for returning the result is:</p>
<pre dir="ltr">      success               VARCHAR2        - &#39;SUCCESS&#39; if OK,
                                              otherwise error message
      arg1                  VARCHAR2/NUMBER/DATE
         ...
      argn                  VARCHAR2/NUMBER/DATE
</pre>
<p>The &#34;stock price request server&#34; would do, using OCI or PRO* (in pseudo-code):</p>
<pre dir="ltr">    &lt;loop forever&gt;
      BEGIN dbms_stock_server.get_request(:stocksymbol); END;
      &lt;figure out price based on stocksymbol (probably from some radio
            signal), set error if can&#39;t find such a stock&gt;
      BEGIN dbms_stock_server.return_price(:error, :price); END;
</pre>
<p>A client would do:</p>
<pre dir="ltr">    BEGIN :price := stock_request(&#39;YOURCOMPANY&#39;); end;
</pre>
<p>The stored procedure, <code dir="ltr">dbms_stock_server</code>, which is called by the preceding &#34;stock price request server&#34; is:</p>
<pre dir="ltr">    CREATE OR REPLACE PACKAGE dbms_stock_server IS
      PROCEDURE get_request(symbol OUT VARCHAR2);
      PROCEDURE return_price(errormsg IN VARCHAR2, price IN VARCHAR2);
    END;
  
    CREATE OR REPLACE PACKAGE BODY dbms_stock_server IS
      returnpipe    VARCHAR2(30);
  
      PROCEDURE returnerror(reason VARCHAR2) IS
        s INTEGER;
      BEGIN
        dbms_pipe.pack_message(reason);
        s := dbms_pipe.send_message(returnpipe);
        IF s &lt;&gt; 0 THEN
          raise_application_error(-20000, &#39;Error:&#39; || to_char(s) ||
            &#39; sending on pipe&#39;);
        END IF;
      END;
  
      PROCEDURE get_request(symbol OUT VARCHAR2) IS
        protocol_version VARCHAR2(10);
        s                INTEGER;
        service          VARCHAR2(30);
      BEGIN
        s := dbms_pipe.receive_message(&#39;stock_service&#39;);
        IF s &lt;&gt; 0 THEN
          raise_application_error(-20000, &#39;Error:&#39; || to_char(s) ||
            &#39;reading pipe&#39;);
        END IF;
        dbms_pipe.unpack_message(protocol_version);
        IF protocol_version &lt;&gt; &#39;1&#39; THEN
          raise_application_error(-20000, &#39;Bad protocol: &#39; || 
            protocol_version);
        END IF;
        dbms_pipe.unpack_message(returnpipe);
        dbms_pipe.unpack_message(service);
        IF service != &#39;getprice&#39; THEN
          returnerror(&#39;Service &#39; || service || &#39; not supported&#39;);
        END IF;
        dbms_pipe.unpack_message(symbol);
      END;
  
      PROCEDURE return_price(errormsg in VARCHAR2, price in VARCHAR2) IS
        s INTEGER;
      BEGIN
        IF errormsg is NULL THEN
          dbms_pipe.pack_message(&#39;SUCCESS&#39;);
          dbms_pipe.pack_message(price);
        ELSE
          dbms_pipe.pack_message(errormsg);
        END IF;
        s := dbms_pipe.send_message(returnpipe);
        IF s &lt;&gt; 0 THEN
          raise_application_error(-20000, &#39;Error:&#39;||to_char(s)||
            &#39; sending on pipe&#39;);
        END IF;
      END;
    END;
  
</pre>
<p>The procedure called by the client is:</p>
<pre dir="ltr">    CREATE OR REPLACE FUNCTION stock_request (symbol VARCHAR2) 
        RETURN VARCHAR2 IS
      s        INTEGER;
      price    VARCHAR2(20);
      errormsg VARCHAR2(512);
    BEGIN
      dbms_pipe.pack_message(&#39;1&#39;);  -- protocol version
      dbms_pipe.pack_message(dbms_pipe.unique_session_name); -- return pipe
      dbms_pipe.pack_message(&#39;getprice&#39;);
      dbms_pipe.pack_message(symbol);
      s := dbms_pipe.send_message(&#39;stock_service&#39;);
      IF s &lt;&gt; 0 THEN
        raise_application_error(-20000, &#39;Error:&#39;||to_char(s)||
          &#39; sending on pipe&#39;);
      END IF;
      s := dbms_pipe.receive_message(dbms_pipe.unique_session_name);
      IF s &lt;&gt; 0 THEN
        raise_application_error(-20000, &#39;Error:&#39;||to_char(s)||
          &#39; receiving on pipe&#39;);
      END IF;
      dbms_pipe.unpack_message(errormsg);
      IF errormsg &lt;&gt; &#39;SUCCESS&#39; THEN
        raise_application_error(-20000, errormsg);
      END IF;
      dbms_pipe.unpack_message(price);
      RETURN price;
    END;
</pre>
<p>You would typically only <code dir="ltr">GRANT</code> <code dir="ltr">EXECUTE</code> on <code dir="ltr">DBMS_STOCK_SERVICE</code> to the stock service application server, and would only <code dir="ltr">GRANT</code> <code dir="ltr">EXECUTE</code> on <code dir="ltr">stock_request</code> to those users allowed to use the service.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="d_alert.htm#CHDDJCJG">Chapter 20, &#34;DBMS_ALERT&#34;</a></div>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" -->
<a id="i1004370"></a>
<div id="ARPLS67407" class="refsect1">
<h2 class="refsect1">Summary of DBMS_PIPE Subprograms</h2>
<div id="ARPLS67408" class="tblformal">
<p class="titleintable"><a id="sthref6980"></a><a id="sthref6981"></a>Table 112-2 DBMS_PIPE Package Subprograms</p>
<table class="cellalignment4330" title="DBMS_PIPE Package Subprograms " summary="This table lists the DBMS_PIPE subprograms in alphabetical order and briefly describes them." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t6">Subprogram</th>
<th class="cellalignment4328" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t6" headers="r1c1-t6">
<p><a href="#CHDEICJI">CREATE_PIPE Function</a></p>
</td>
<td class="cellalignment4329" headers="r2c1-t6 r1c2-t6">
<p>Creates a pipe (necessary for private pipes)</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t6" headers="r1c1-t6">
<p><a href="#i997213">NEXT_ITEM_TYPE Function</a></p>
</td>
<td class="cellalignment4329" headers="r3c1-t6 r1c2-t6">
<p>Returns datatype of next item in buffer</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t6" headers="r1c1-t6">
<p><a href="#CHDJGGIE">PACK_MESSAGE Procedures</a></p>
</td>
<td class="cellalignment4329" headers="r4c1-t6 r1c2-t6">
<p>Builds message in local buffer</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t6" headers="r1c1-t6">
<p><a href="#i997357">PURGE Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r5c1-t6 r1c2-t6">
<p>Purges contents of named pipe</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t6" headers="r1c1-t6">
<p><a href="#i997133">RECEIVE_MESSAGE Function</a></p>
</td>
<td class="cellalignment4329" headers="r6c1-t6 r1c2-t6">
<p>Copies message from named pipe into local buffer</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t6" headers="r1c1-t6">
<p><a href="#CHDICFGD">REMOVE_PIPE Function</a></p>
</td>
<td class="cellalignment4329" headers="r7c1-t6 r1c2-t6">
<p>Removes the named pipe</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r8c1-t6" headers="r1c1-t6">
<p><a href="#i997385">RESET_BUFFER Procedure</a></p>
</td>
<td class="cellalignment4329" headers="r8c1-t6 r1c2-t6">
<p>Purges contents of local buffer</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r9c1-t6" headers="r1c1-t6">
<p><a href="#i997042">SEND_MESSAGE Function</a></p>
</td>
<td class="cellalignment4329" headers="r9c1-t6 r1c2-t6">
<p>Sends message on named pipe: This implicitly creates a public pipe if the named pipe does not exist</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r10c1-t6" headers="r1c1-t6">
<p><a href="#i997393">UNIQUE_SESSION_NAME Function</a></p>
</td>
<td class="cellalignment4329" headers="r10c1-t6 r1c2-t6">
<p>Returns unique session name</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r11c1-t6" headers="r1c1-t6">
<p><a href="#i997258">UNPACK_MESSAGE Procedures</a></p>
</td>
<td class="cellalignment4329" headers="r11c1-t6 r1c2-t6">
<p>Accesses next item in buffer</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="ARPLS67409" class="refsect2"><a id="CHDEICJI"></a>
<h3 class="refsect2"><a id="sthref6982"></a>CREATE_PIPE Function</h3>
<p>This function explicitly creates a public or private pipe. If the <code dir="ltr">private</code> flag is <code dir="ltr">TRUE</code>, then the pipe creator is assigned as the owner of the private pipe.</p>
<p>Explicitly-created pipes can only be removed by calling <code dir="ltr">REMOVE_PIPE</code>, or by shutting down the instance.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref6983"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.CREATE_PIPE (
   pipename     IN VARCHAR2,
   maxpipesize  IN INTEGER DEFAULT 8192,
   private      IN BOOLEAN DEFAULT TRUE)
RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref6984"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(create_pipe,WNDS,RNDS); 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref6985"></a>Parameters</p>
<div id="ARPLS67410" class="tblformal">
<p class="titleintable"><a id="sthref6986"></a><a id="sthref6987"></a>Table 112-3 CREATE_PIPE Function Parameters</p>
<table class="cellalignment4330" title="CREATE_PIPE Function Parameters " summary="This table describes Parameters used by the DBMS_PIPE.CREATE_PIPE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t7">Parameter</th>
<th class="cellalignment4328" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t7" headers="r1c1-t7">
<p><code dir="ltr">pipename</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t7 r1c2-t7">
<p>Name of the pipe you are creating.</p>
<p>You must use this name when you call <code dir="ltr">SEND_MESSAGE</code> and <code dir="ltr">RECEIVE_MESSAGE</code>. This name must be unique across the instance.</p>
<p>Caution: Do not use pipe names beginning with <code dir="ltr">ORA$</code>. These are reserved for use by procedures provided by Oracle. Pipename should not be longer than 128 bytes, and is case insensitive. At this time, the name cannot contain Globalization Support characters.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t7" headers="r1c1-t7">
<p><code dir="ltr">maxpipesize</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t7 r1c2-t7">
<p>The maximum size allowed for the pipe, in bytes.</p>
<p>The total size of all of the messages on the pipe cannot exceed this amount. The message is blocked if it exceeds this maximum. The default <code dir="ltr">maxpipesize</code> is 8192 bytes.</p>
<p>The <code dir="ltr">maxpipesize</code> for a pipe becomes a part of the characteristics of the pipe and persists for the life of the pipe. Callers of <code dir="ltr">SEND_MESSAGE</code> with larger values cause the <code dir="ltr">maxpipesize</code> to be increased. Callers with a smaller value use the existing, larger value.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t7" headers="r1c1-t7">
<p><code dir="ltr">private</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t7 r1c2-t7">
<p>Uses the default, <code dir="ltr">TRUE</code>, to create a private pipe.</p>
<p>Public pipes can be implicitly created when you call <code dir="ltr">SEND_MESSAGE</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref6988"></a>Return Values</p>
<div id="ARPLS67411" class="tblformal">
<p class="titleintable"><a id="sthref6989"></a><a id="sthref6990"></a>Table 112-4 CREATE_PIPE Function Return Values</p>
<table class="cellalignment4330" title="CREATE_PIPE Function Return Values " summary="This table describes values returned by the CREATE_PIPE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t8">Return</th>
<th class="cellalignment4328" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t8" headers="r1c1-t8">
<p><code dir="ltr">0</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t8 r1c2-t8">
<p>Successful.</p>
<p>If the pipe already exists and the user attempting to create it is authorized to use it, then Oracle returns 0, indicating success, and any data already in the pipe remains.</p>
<p>If a user connected as <code dir="ltr">SYSDBA</code>/<code dir="ltr">SYSOPER</code> re-creates a pipe, then Oracle returns status 0, but the ownership of the pipe remains unchanged.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t8" headers="r1c1-t8">
<p><code dir="ltr">ORA-23322</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t8 r1c2-t8">
<p>Failure due to naming conflict.</p>
<p>If a pipe with the same name exists and was created by a different user, then Oracle signals error <code dir="ltr">ORA-23322</code>, indicating the naming conflict.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref6991"></a>Exceptions</p>
<div id="ARPLS67412" class="tblformal">
<p class="titleintable"><a id="sthref6992"></a><a id="sthref6993"></a>Table 112-5 CREATE_PIPE Function Exception</p>
<table class="cellalignment4330" title="CREATE_PIPE Function Exception" summary="This table describes the Exceptions raised by the CREATE_PIPE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t9">Exception</th>
<th class="cellalignment4328" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t9" headers="r1c1-t9">
<p><code dir="ltr">Null pipe name</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t9 r1c2-t9">
<p>Permission error: Pipe with the same name already exists, and you are not allowed to use it.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67413" class="refsect2"><a id="i997213"></a>
<h3 class="refsect2"><a id="sthref6994"></a>NEXT_ITEM_TYPE Function</h3>
<p>This function determines the datatype of the next item in the local message buffer.</p>
<p>After you have called <code dir="ltr">RECEIVE_MESSAGE</code> to place pipe information in a local buffer, call <code dir="ltr">NEXT_ITEM_TYPE.</code></p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref6995"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.NEXT_ITEM_TYPE 
  RETURN INTEGER; 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref6996"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(next_item_type,WNDS,RNDS);  
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref6997"></a>Return Values</p>
<div id="ARPLS67414" class="tblformal">
<p class="titleintable"><a id="sthref6998"></a><a id="sthref6999"></a>Table 112-6 NEXT_ITEM_TYPE Function Return Values</p>
<table class="cellalignment4330" title="NEXT_ITEM_TYPE Function Return Values " summary="This table decribes Values Returned by the NEXT_ITEM_TYPE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t10">Return</th>
<th class="cellalignment4328" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t10" headers="r1c1-t10">
<p><code dir="ltr">0</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t10 r1c2-t10">
<p>No more items</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t10" headers="r1c1-t10">
<p><code dir="ltr">6</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t10 r1c2-t10">
<p><code dir="ltr">NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t10" headers="r1c1-t10">
<p><code dir="ltr">9</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t10 r1c2-t10">
<p><code dir="ltr">VARCHAR2</code></p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t10" headers="r1c1-t10">
<p><code dir="ltr">11</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t10 r1c2-t10">
<p><code dir="ltr">ROWID</code></p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t10" headers="r1c1-t10">
<p><code dir="ltr">12</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t10 r1c2-t10">
<p><code dir="ltr">DATE</code></p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t10" headers="r1c1-t10">
<p><code dir="ltr">23</code></p>
</td>
<td class="cellalignment4329" headers="r7c1-t10 r1c2-t10">
<p><code dir="ltr">RAW</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67415" class="refsect2"><a id="CHDJGGIE"></a>
<h3 class="refsect2"><a id="sthref7000"></a>PACK_MESSAGE Procedures</h3>
<p>This procedure builds your message in the local message buffer. To send a message, first make one or more calls to <code dir="ltr">PACK_MESSAGE</code>. Then, call <code dir="ltr">SEND_MESSAGE</code> to send the message in the local buffer on the named pipe.</p>
<p>The procedure is overloaded to accept items of type <code dir="ltr">VARCHAR2</code>, <code dir="ltr">NCHAR</code>, <code dir="ltr">NUMBER</code>, <code dir="ltr">DATE</code>., <code dir="ltr">RAW</code> and <code dir="ltr">ROWID</code> items. In addition to the data bytes, each item in the buffer requires one byte to indicate its type, and two bytes to store its length. One additional byte is needed to terminate the message.The overhead for all types other than <code dir="ltr">VARCHAR</code> is 4 bytes.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7001"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.PACK_MESSAGE (
   item  IN  VARCHAR2);

DBMS_PIPE.PACK_MESSAGE (
   item  IN  NCHAR);

DBMS_PIPE.PACK_MESSAGE (
   item  IN  NUMBER);

DBMS_PIPE.PACK_MESSAGE (
   item  IN  DATE);

DBMS_PIPE.PACK_MESSAGE_RAW (
   item  IN  RAW);

DBMS_PIPE.PACK_MESSAGE_ROWID (
   item  IN  ROWID);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7002"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(pack_message,WNDS,RNDS);
pragma restrict_references(pack_message_raw,WNDS,RNDS);  
pragma restrict_references(pack_message_rowid,WNDS,RNDS); 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7003"></a>Parameters</p>
<div id="ARPLS67416" class="tblformal">
<p class="titleintable"><a id="sthref7004"></a><a id="sthref7005"></a>Table 112-7 PACK_MESSAGE Procedure Parameters</p>
<table class="cellalignment4330" title="PACK_MESSAGE Procedure Parameters" summary="This table describes Parameters used by the DBMS_PIPE.PACK_MESSAGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t11">Parameter</th>
<th class="cellalignment4328" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t11" headers="r1c1-t11">
<p><code dir="ltr">item</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t11 r1c2-t11">
<p>Item to pack into the local message buffer.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7006"></a>Usage Notes</p>
<p>In Oracle database version 8.x, the char-set-id (2 bytes) and the char-set-form (1 byte) are stored with each data item. Therefore, the overhead when using Oracle database version 8.x is 7 bytes.</p>
<p>When you call <code dir="ltr">SEND_MESSAGE</code> to send this message, you must indicate the name of the pipe on which you want to send the message. If this pipe already exists, then you must have sufficient privileges to access this pipe. If the pipe does not already exist, then it is created automatically.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7007"></a>Exceptions</p>
<p><code dir="ltr">ORA-06558</code> is raised if the message buffer overflows (currently 4096 bytes). Each item in the buffer takes one byte for the type, two bytes for the length, plus the actual data. There is also one byte needed to terminate the message.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67417" class="refsect2"><a id="i997357"></a>
<h3 class="refsect2"><a id="sthref7008"></a>PURGE Procedure</h3>
<p>This procedure empties the contents of the named pipe.</p>
<p>An empty implicitly-created pipe is aged out of the shared global area according to the least-recently-used algorithm. Thus, calling <code dir="ltr">PURGE</code> lets you free the memory associated with an implicitly-created pipe.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7009"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.PURGE (
   pipename  IN  VARCHAR2);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7010"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(purge,WNDS,RNDS); 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7011"></a>Parameters</p>
<div id="ARPLS67418" class="tblformal">
<p class="titleintable"><a id="sthref7012"></a><a id="sthref7013"></a>Table 112-8 PURGE Procedure Parameters</p>
<table class="cellalignment4330" title="PURGE Procedure Parameters" summary="This table describes Parameters used by the DBMS_PIPE.PURGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t12">Parameter</th>
<th class="cellalignment4328" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t12" headers="r1c1-t12">
<p><code dir="ltr">pipename</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t12 r1c2-t12">
<p>Name of pipe from which to remove all messages.</p>
<p>The local buffer may be overwritten with messages as they are discarded. Pipename should not be longer than 128 bytes, and is case-insensitive.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7014"></a>Usage Notes</p>
<p>Because <code dir="ltr">PURGE</code> calls <code dir="ltr">RECEIVE_MESSAGE</code>, the local buffer might be overwritten with messages as they are purged from the pipe. Also, you can receive an <code dir="ltr">ORA-23322</code> (insufficient privileges) error if you attempt to purge a pipe with which you have insufficient access rights.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7015"></a>Exceptions</p>
<p>Permission error if pipe belongs to another user.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67419" class="refsect2"><a id="i997133"></a>
<h3 class="refsect2"><a id="sthref7016"></a>RECEIVE_MESSAGE Function</h3>
<p>This function copies the message into the local message buffer.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7017"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.RECEIVE_MESSAGE (
   pipename     IN VARCHAR2,
   timeout      IN INTEGER      DEFAULT maxwait)
RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7018"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(receive_message,WNDS,RNDS);  
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7019"></a>Parameters</p>
<div id="ARPLS67420" class="tblformal">
<p class="titleintable"><a id="sthref7020"></a><a id="sthref7021"></a>Table 112-9 RECEIVE_MESSAGE Function Parameters</p>
<table class="cellalignment4330" title="RECEIVE_MESSAGE Function Parameters " summary="This table describes Parameters used by the DBMS_PIPE.RECEIVE_MESSAGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t13">Parameter</th>
<th class="cellalignment4328" id="r1c2-t13">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t13" headers="r1c1-t13">
<p><code dir="ltr">pipename</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t13 r1c2-t13">
<p>Name of the pipe on which you want to receive a message.</p>
<p>Names beginning with <code dir="ltr">ORA$</code> are reserved for use by Oracle</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t13" headers="r1c1-t13">
<p><code dir="ltr">timeout</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t13 r1c2-t13">
<p>Time to wait for a message, in seconds.</p>
<p>The default value is the constant <code dir="ltr">MAXWAIT</code>, which is defined as 86400000 (1000 days). A timeout of 0 lets you read without blocking.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7022"></a>Return Values</p>
<div id="ARPLS67421" class="tblformal">
<p class="titleintable"><a id="sthref7023"></a><a id="sthref7024"></a>Table 112-10 RECEIVE_MESSAGE Function Return Values</p>
<table class="cellalignment4330" title="RECEIVE_MESSAGE Function Return Values " summary="This table decribes values returned by the RECEIVE_MESSAGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t14">Return</th>
<th class="cellalignment4328" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t14" headers="r1c1-t14">
<p><code dir="ltr">0</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t14 r1c2-t14">
<p>Success</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t14" headers="r1c1-t14">
<p><code dir="ltr">1</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t14 r1c2-t14">
<p>Timed out. If the pipe was implicitly-created and is empty, then it is removed.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t14" headers="r1c1-t14">
<p><code dir="ltr">2</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t14 r1c2-t14">
<p>Record in the pipe is too large for the buffer. (This should not happen.)</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t14" headers="r1c1-t14">
<p><code dir="ltr">3</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t14 r1c2-t14">
<p>An interrupt occurred.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t14" headers="r1c1-t14">
<p><code dir="ltr">ORA-23322</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t14 r1c2-t14">
<p>User has insufficient privileges to read from the pipe.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7025"></a>Usage Notes</p>
<p>To receive a message from a pipe, first call <code dir="ltr">RECEIVE_MESSAGE</code>. When you receive a message, it is removed from the pipe; hence, a message can only be received once. For implicitly-created pipes, the pipe is removed after the last record is removed from the pipe.</p>
<p>If the pipe that you specify when you call <code dir="ltr">RECEIVE_MESSAGE</code> does not already exist, then Oracle implicitly creates the pipe and waits to receive the message. If the message does not arrive within a designated timeout interval, then the call returns and the pipe is removed.</p>
<p>After receiving the message, you must make one or more calls to <code dir="ltr">UNPACK_MESSAGE</code> to access the individual items in the message. The <code dir="ltr">UNPACK_MESSAGE</code> procedure is overloaded to unpack items of type <code dir="ltr">DATE</code>, <code dir="ltr">NUMBER</code>, <code dir="ltr">VARCHAR2</code>, and there are two additional procedures to unpack <code dir="ltr">RAW</code> and <code dir="ltr">ROWID</code> items. If you do not know the type of data that you are attempting to unpack, then call <code dir="ltr">NEXT_ITEM_TYPE</code> to determine the type of the next item in the buffer.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7026"></a>Exceptions</p>
<div id="ARPLS67422" class="tblformal">
<p class="titleintable"><a id="sthref7027"></a><a id="sthref7028"></a>Table 112-11 RECEIVE_MESSAGE Function Exceptions</p>
<table class="cellalignment4330" title="RECEIVE_MESSAGE Function Exceptions" summary="This table describes the Exceptions raised by the RECEIVE_MESSAGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t15">Exception</th>
<th class="cellalignment4328" id="r1c2-t15">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t15" headers="r1c1-t15">
<p><code dir="ltr">Null pipe name</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t15 r1c2-t15">
<p>Permission error. Insufficient privilege to remove the record from the pipe. The pipe is owned by someone else.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67423" class="refsect2"><a id="i997385"></a>
<h3 class="refsect2"><a id="sthref7029"></a>RESET_BUFFER Procedure</h3>
<p>This procedure resets the <code dir="ltr">PACK_MESSAGE</code> and <code dir="ltr">UNPACK_MESSAGE</code> positioning indicators to 0.</p>
<p>Because all pipes share a single buffer, you may find it useful to reset the buffer before using a new pipe. This ensures that the first time you attempt to send a message to your pipe, you do not inadvertently send an expired message remaining in the buffer.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7030"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.RESET_BUFFER; 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7031"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(reset_buffer,WNDS,RNDS);  
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67424" class="refsect2"><a id="CHDICFGD"></a>
<h3 class="refsect2"><a id="sthref7032"></a>REMOVE_PIPE Function</h3>
<p>This function removes explicitly-created pipes.</p>
<p>Pipes created implicitly by <code dir="ltr">SEND_MESSAGE</code> are automatically removed when empty. However, pipes created explicitly by <code dir="ltr">CREATE_PIPE</code> are removed only by calling <code dir="ltr">REMOVE_PIPE</code>, or by shutting down the instance. All unconsumed records in the pipe are removed before the pipe is deleted.</p>
<p>This is similar to calling <code dir="ltr">PURGE</code> on an implicitly-created pipe.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7033"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.REMOVE_PIPE (
   pipename  IN  VARCHAR2)
RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7034"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(remove_pipe,WNDS,RNDS); 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7035"></a>Parameters</p>
<div id="ARPLS67425" class="tblformal">
<p class="titleintable"><a id="sthref7036"></a><a id="sthref7037"></a>Table 112-12 REMOVE_PIPE Function Parameters</p>
<table class="cellalignment4330" title="REMOVE_PIPE Function Parameters" summary="This table describes Parameters used by the DBMS_PIPE.REMOVE_PIPE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t16">Parameter</th>
<th class="cellalignment4328" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t16" headers="r1c1-t16">
<p><code dir="ltr">pipename</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t16 r1c2-t16">
<p>Name of pipe that you want to remove.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7038"></a>Return Values</p>
<div id="ARPLS67426" class="tblformal">
<p class="titleintable"><a id="sthref7039"></a><a id="sthref7040"></a>Table 112-13 REMOVE_PIPE Function Return Values</p>
<table class="cellalignment4330" title="REMOVE_PIPE Function Return Values " summary="This table decribes Values Returned by the REMOVE_PIPE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t17">Return</th>
<th class="cellalignment4328" id="r1c2-t17">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t17" headers="r1c1-t17">
<p><code dir="ltr">0</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t17 r1c2-t17">
<p>Success</p>
<p>If the pipe does not exist, or if the pipe already exists and the user attempting to remove it is authorized to do so, then Oracle returns 0, indicating success, and any data remaining in the pipe is removed.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t17" headers="r1c1-t17">
<p><code dir="ltr">ORA-23322</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t17 r1c2-t17">
<p>Insufficient privileges.</p>
<p>If the pipe exists, but the user is not authorized to access the pipe, then Oracle signals error <code dir="ltr">ORA-23322</code>, indicating insufficient privileges.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7041"></a>Exceptions</p>
<div id="ARPLS67427" class="tblformal">
<p class="titleintable"><a id="sthref7042"></a><a id="sthref7043"></a>Table 112-14 REMOVE_PIPE Function Exception</p>
<table class="cellalignment4330" title="REMOVE_PIPE Function Exception" summary="This table describes the Exceptions raised by the REMOVE_PIPE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t18">Exception</th>
<th class="cellalignment4328" id="r1c2-t18">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t18" headers="r1c1-t18">
<p><code dir="ltr">Null pipe name</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t18 r1c2-t18">
<p>Permission error: Insufficient privilege to remove pipe. The pipe was created and is owned by someone else.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67428" class="refsect2"><a id="i997042"></a>
<h3 class="refsect2"><a id="sthref7044"></a>SEND_MESSAGE Function</h3>
<p>This function sends a message on the named pipe.</p>
<p>The message is contained in the local message buffer, which was filled with calls to <code dir="ltr">PACK_MESSAGE</code>. You can create a pipe explicitly using <code dir="ltr">CREATE_PIPE</code>, otherwise, it is created implicitly.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7045"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.SEND_MESSAGE (
    pipename     IN VARCHAR2,
    timeout      IN INTEGER DEFAULT MAXWAIT,
    maxpipesize  IN INTEGER DEFAULT 8192)
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7046"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(send_message,WNDS,RNDS);  
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7047"></a>Parameters</p>
<div id="ARPLS67429" class="tblformal">
<p class="titleintable"><a id="sthref7048"></a><a id="sthref7049"></a>Table 112-15 SEND_MESSAGE Function Parameters</p>
<table class="cellalignment4330" title="SEND_MESSAGE Function Parameters " summary="This table describes Parameters used by the DBMS_PIPE.SEND_MESSAGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t19">Parameter</th>
<th class="cellalignment4328" id="r1c2-t19">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t19" headers="r1c1-t19">
<p><code dir="ltr">pipename</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t19 r1c2-t19">
<p>Name of the pipe on which you want to place the message.</p>
<p>If you are using an explicit pipe, then this is the name that you specified when you called <code dir="ltr">CREATE_PIPE</code>.</p>
<p>Caution: Do not use pipe names beginning with &#39;<code dir="ltr">ORA$</code>&#39;. These names are reserved for use by procedures provided by Oracle. Pipename should not be longer than 128 bytes, and is case-insensitive. At this time, the name cannot contain Globalization Support characters.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t19" headers="r1c1-t19">
<p><code dir="ltr">timeout</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t19 r1c2-t19">
<p>Time to wait while attempting to place a message on a pipe, in seconds.</p>
<p>The default value is the constant <code dir="ltr">MAXWAIT</code>, which is defined as 86400000 (1000 days).</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t19" headers="r1c1-t19">
<p><code dir="ltr">maxpipesize</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t19 r1c2-t19">
<p>Maximum size allowed for the pipe, in bytes.</p>
<p>The total size of all the messages on the pipe cannot exceed this amount. The message is blocked if it exceeds this maximum. The default is 8192 bytes.</p>
<p>The <code dir="ltr">maxpipesize</code> for a pipe becomes a part of the characteristics of the pipe and persists for the life of the pipe. Callers of <code dir="ltr">SEND_MESSAGE</code> with larger values cause the <code dir="ltr">maxpipesize</code> to be increased. Callers with a smaller value simply use the existing, larger value.</p>
<p>Specifying <code dir="ltr">maxpipesize</code> as part of the <code dir="ltr">SEND_MESSAGE</code> procedure eliminates the need for a separate call to open the pipe. If you created the pipe explicitly, then you can use the optional <code dir="ltr">maxpipesize</code> parameter to override the creation pipe size specifications.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7050"></a>Return Values</p>
<div id="ARPLS67430" class="tblformal">
<p class="titleintable"><a id="sthref7051"></a><a id="sthref7052"></a>Table 112-16 SEND_MESSAGE Function Return Values</p>
<table class="cellalignment4330" title="SEND_MESSAGE Function Return Values " summary="This table describes values returned by the SEND_MESSAGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t20">Return</th>
<th class="cellalignment4328" id="r1c2-t20">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t20" headers="r1c1-t20">
<p><code dir="ltr">0</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t20 r1c2-t20">
<p>Success.</p>
<p>If the pipe already exists and the user attempting to create it is authorized to use it, then Oracle returns 0, indicating success, and any data already in the pipe remains.</p>
<p>If a user connected as <code dir="ltr">SYSDBS</code>/<code dir="ltr">SYSOPER</code> re-creates a pipe, then Oracle returns status 0, but the ownership of the pipe remains unchanged.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t20" headers="r1c1-t20">
<p><code dir="ltr">1</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t20 r1c2-t20">
<p>Timed out.</p>
<p>This procedure can timeout either because it cannot get a lock on the pipe, or because the pipe remains too full to be used. If the pipe was implicitly-created and is empty, then it is removed.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t20" headers="r1c1-t20">
<p><code dir="ltr">3</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t20 r1c2-t20">
<p>An interrupt occurred.</p>
<p>If the pipe was implicitly created and is empty, then it is removed.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t20" headers="r1c1-t20">
<p><code dir="ltr">ORA-23322</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t20 r1c2-t20">
<p>Insufficient privileges.</p>
<p>If a pipe with the same name exists and was created by a different user, then Oracle signals error <code dir="ltr">ORA-23322</code>, indicating the naming conflict.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7053"></a>Exceptions</p>
<div id="ARPLS67431" class="tblformal">
<p class="titleintable"><a id="sthref7054"></a><a id="sthref7055"></a>Table 112-17 SEND_MESSAGE Function Exception</p>
<table class="cellalignment4330" title="SEND_MESSAGE Function Exception" summary="This table describes the Exceptions raised by the SEND_MESSAGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t21">Exception</th>
<th class="cellalignment4328" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t21" headers="r1c1-t21">
<p><code dir="ltr">Null pipe name</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t21 r1c2-t21">
<p>Permission error. Insufficient privilege to write to the pipe. The pipe is private and owned by someone else.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67432" class="refsect2"><a id="i997393"></a>
<h3 class="refsect2"><a id="sthref7056"></a>UNIQUE_SESSION_NAME Function</h3>
<p>This function receives a name that is unique among all of the sessions that are currently connected to a database.</p>
<p>Multiple calls to this function from the same session always return the same value. You might find it useful to use this function to supply the <code dir="ltr">PIPENAME</code> parameter for your <code dir="ltr">SEND_MESSAGE</code> and <code dir="ltr">RECEIVE_MESSAGE</code> calls.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7057"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.UNIQUE_SESSION_NAME 
  RETURN VARCHAR2;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7058"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(unique_session_name,WNDS,RNDS,WNPS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7059"></a>Return Values</p>
<p>This function returns a unique name. The returned name can be up to 30 bytes.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS67433" class="refsect2"><a id="i997258"></a>
<h3 class="refsect2"><a id="sthref7060"></a>UNPACK_MESSAGE Procedures</h3>
<p>This procedure retrieves items from the buffer.</p>
<p>After you have called <code dir="ltr">RECEIVE_MESSAGE</code> to place pipe information in a local buffer, call <code dir="ltr">UNPACK_MESSAGE</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">UNPACK_MESSAGE</code> procedure is overloaded to return items of type <code dir="ltr">VARCHAR2</code>, <code dir="ltr">NCHAR</code>, <code dir="ltr">NUMBER</code>, or <code dir="ltr">DATE</code>. There are two additional procedures to unpack <code dir="ltr">RAW</code> and <code dir="ltr">ROWID</code> items.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7061"></a>Syntax</p>
<pre dir="ltr">DBMS_PIPE.UNPACK_MESSAGE (
   item  OUT VARCHAR2);

DBMS_PIPE.UNPACK_MESSAGE (
   item  OUT NCHAR);

DBMS_PIPE.UNPACK_MESSAGE (
   item  OUT NUMBER);

DBMS_PIPE.UNPACK_MESSAGE (
   item  OUT DATE);

DBMS_PIPE.UNPACK_MESSAGE_RAW (
   item  OUT RAW);

DBMS_PIPE.UNPACK_MESSAGE_ROWID (
   item  OUT ROWID);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7062"></a>Pragmas</p>
<pre dir="ltr">pragma restrict_references(unpack_message,WNDS,RNDS);  
pragma restrict_references(unpack_message_raw,WNDS,RNDS);  
pragma restrict_references(unpack_message_rowid,WNDS,RNDS);  
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7063"></a>Parameters</p>
<div id="ARPLS67434" class="tblformal">
<p class="titleintable"><a id="sthref7064"></a><a id="sthref7065"></a>Table 112-18 UNPACK_MESSAGE Procedure Parameters</p>
<table class="cellalignment4330" title="UNPACK_MESSAGE Procedure Parameters" summary="This table describes Parameters used by the DBMS_PIPE.UNPACK_MESSAGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t23">Parameter</th>
<th class="cellalignment4328" id="r1c2-t23">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t23" headers="r1c1-t23">
<p><code dir="ltr">item</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t23 r1c2-t23">
<p>Argument to receive the next unpacked item from the local message buffer.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref7066"></a>Exceptions</p>
<p><code dir="ltr">ORA-06556</code> or <code dir="ltr">06559</code> are generated if the buffer contains no more items, or if the item is not of the same type as that requested.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" --></div>
<!-- class="refentry" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4320">
<tr>
<td class="cellalignment4329">
<table class="cellalignment4325">
<tr>
<td class="cellalignment4324"><a href="d_perf.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4324"><a href="d_predan.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4332">
<table class="cellalignment4323">
<tr>
<td class="cellalignment4324"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4324"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4324"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4324"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4324"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4324"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>