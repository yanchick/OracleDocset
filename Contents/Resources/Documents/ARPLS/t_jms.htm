<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-2456"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/JMS%20Types"></a><title>JMS Types</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1086"/>
<meta name="dcterms.created" content="2016-09-02T5:37:19Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database PL/SQL Packages and Types Reference"/>
<meta name="dcterms.identifier" content="E41829-07"/>
<meta name="dcterms.isVersionOf" content="ARPLS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="t_dburi.htm" title="Previous" type="text/html"/>
<link rel="Next" href="t_lcr.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41829-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">278/290</span> <!-- End Header -->
<div id="ARPLS136" class="chapter"><a id="sthref20399"></a>
<h1 class="chapter"><span class="secnum">274</span> JMS Types</h1>
<p>PL/SQL users can use the <code dir="ltr">DBMS_AQ</code> package to enqueue and dequeue messages from JMS queues. The JMS types member and static functions and procedures in this chapter are needed to populate JMS messages for enqueuing or to interpret a dequeued JMS message.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#BABCFGBA">Using JMS Types</a></p>
<ul>
<li>
<p>Overview</p>
</li>
<li>
<p>Security Model</p>
</li>
<li>
<p>Java Versus PL/SQL Datatypes</p>
</li>
<li>
<p>More on Bytes, Stream and Map Messages</p>
</li>
<li>
<p>Upcasting and Downcasting Between General and Specific Messages</p>
</li>
<li>
<p>JMS Types Error Reporting</p>
</li>
<li>
<p>Oracle JMS Type Constants</p>
</li>
<li>
<p>CONVERT_JMS_SELECTOR</p>
</li>
</ul>
</li>
<li>
<p><a href="#i1273865">Summary of JMS Types</a></p>
</li>
</ul>
<div class="refentry"><a id="BABCFGBA"></a>
<div id="ARPLS71769" class="refsect1">
<h2 class="refsect1">Using JMS Types</h2>
<ul>
<li>
<p><a href="#i1006251">Overview</a></p>
</li>
<li>
<p><a href="#CIHICJCH">Security Model</a></p>
</li>
<li>
<p><a href="#i1273321">Java Versus PL/SQL Datatypes</a></p>
</li>
<li>
<p><a href="#i1273342">More on Bytes, Stream and Map Messages</a></p>
</li>
<li>
<p><a href="#i1273439">Upcasting and Downcasting Between General and Specific Messages</a></p>
</li>
<li>
<p><a href="#i1273450">JMS Types Error Reporting</a></p>
</li>
<li>
<p><a href="#i1273541">Oracle JMS Type Constants</a></p>
</li>
<li>
<p><a href="#i1273450">JMS Types Error Reporting</a></p>
</li>
<li>
<p><a href="#i1273541">Oracle JMS Type Constants</a></p>
</li>
<li>
<p><a href="#i1273599">CONVERT_JMS_SELECTOR</a></p>
</li>
</ul>
<div id="ARPLS71770" class="refsect2"><a id="i1006251"></a>
<h3 class="refsect2">Overview</h3>
<p>Java Message Service (JMS) is a well known public standard interface for accessing messaging systems. Oracle JMS (OJMS) implements JMS based on Oracle Streams Advanced Queuing (AQ) and a relational database system (RDBMS). Messages are stored in queues as OJMS specific ADTs. Java clients use OJMS packages to enqueue, dequeue, and manipulate these messages.</p>
<p>PL/SQL users, on the other hand, use the <code dir="ltr">DBMS_AQ</code> package to enqueue and dequeue JMS messages and the member functions in this chapter to populate and interpret them. Oracle Database Advanced Queuing offers such member functions for the following JMS ADTs:</p>
<ul>
<li>
<p><code dir="ltr">aq$_jms_header</code></p>
</li>
<li>
<p><code dir="ltr">aq$_jms_message</code></p>
</li>
<li>
<p><code dir="ltr">aq$_jms_text_message</code></p>
</li>
<li>
<p><code dir="ltr">aq$_jms_bytes_message</code></p>
</li>
<li>
<p><code dir="ltr">aq$_jms_map_message</code></p>
</li>
<li>
<p><code dir="ltr">aq$_jms_stream_message</code></p>
</li>
</ul>
<p>In addition to these populating and interpreting member functions, Oracle Database Advanced Queuing offers:</p>
<ul>
<li>
<p>Casting between <code dir="ltr">aq$_jms_message</code> and other message ADTs.</p>
</li>
<li>
<p>PL/SQL stored procedures for converting JMS selectors to equivalent Oracle Database Advanced Queuing rules</p>
</li>
</ul>
</div>
<!-- class="refsect2" -->
<div id="ARPLS74857" class="refsect2"><a id="CIHICJCH"></a>
<h3 class="refsect2">Security Model</h3>
<p><code dir="ltr">PUBLIC</code> is granted <code dir="ltr">EXECUTE</code> privilege on the following JMS types:</p>
<ul>
<li>
<p>SYS.AQ$_JMS_MESSAGE Type</p>
</li>
<li>
<p>SYS.AQ$_JMS_TEXT_MESSAGE Type</p>
</li>
<li>
<p>SYS.AQ$_JMS_BYTES_MESSAGE Type</p>
</li>
<li>
<p>SYS.AQ$_JMS_MAP_MESSAGE Type</p>
</li>
<li>
<p>SYS.AQ$_JMS_STREAM_MESSAGE Type</p>
</li>
<li>
<p>SYS.AQ$_JMS_OBJECT_MESSAGE Type</p>
</li>
<li>
<p>SYS.AQ$_JMS_NAMEARRAY Type</p>
</li>
<li>
<p>SYS.AQ$_JMS_VALUE Type</p>
</li>
<li>
<p>SYS.AQ$_JMS_EXCEPTION Type</p>
</li>
</ul>
</div>
<!-- class="refsect2" -->
<div id="ARPLS71771" class="refsect2"><a id="i1273321"></a>
<h3 class="refsect2">Java Versus PL/SQL Datatypes</h3>
<p>Datatypes do not map one-to-one between PL/SQL and Java.</p>
<p>Some Java types, such as <code dir="ltr">BYTE</code> and <code dir="ltr">SHORT</code>, are not present in PL/SQL. PL/SQL type <code dir="ltr">INT</code> was chosen to represent these types. If a PL/SQL <code dir="ltr">INT</code> value intended to hold a Java <code dir="ltr">BYTE</code> or <code dir="ltr">SHORT</code> value exceeds the corresponding range Java enforces, an out-of-range error is thrown.</p>
<p>Other Java types have more than one counterpart in PL/SQL with different capabilities. A Java String can be represented by both <code dir="ltr">VARCHAR2</code> and <code dir="ltr">CLOB</code>, but <code dir="ltr">VARCHAR2</code> has a maximum limit of 4000 bytes. When retrieving <code dir="ltr">TEXT</code> data from map, stream, and bytes message types, a <code dir="ltr">CLOB</code> is always returned. When updating the map, stream and bytes message types, users can submit either a <code dir="ltr">VARCHAR2</code> or <code dir="ltr">CLOB</code>.</p>
<p>Similarly, a Java <code dir="ltr">BYTE</code> <code dir="ltr">ARRAY</code> can be represented by both <code dir="ltr">RAW</code> and <code dir="ltr">BLOB</code>, with <code dir="ltr">RAW</code> having a maximum size of 32767. When retrieving <code dir="ltr">BYTE</code> <code dir="ltr">ARRAY</code> data from map, stream, and bytes message types, a <code dir="ltr">BLOB</code> is always returned. When updating the map, stream and bytes message types, users can submit either a <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code>.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
JMS specification 3.11.3, Conversion Provided by StreamMessage and MapMessage</div>
<div id="ARPLS71772" class="refsect3"><a id="sthref20400"></a>
<h4 class="refsect3">New JMS Support in Oracle Database 10<span class="italic">g</span></h4>
<p>In Oracle Database 10<span class="italic">g</span>, a new <code dir="ltr">AQ$_JMS_VALUE</code> ADT has been added in the <code dir="ltr">SYS</code> schema for OJMS PL/SQL users. It is specifically used to implement the <code dir="ltr">read_object</code> procedure of <code dir="ltr">aq$_jms_stream_message</code> and <code dir="ltr">get_object</code> procedure of <code dir="ltr">aq$_jms_map_message</code>, to mimic the Java general object class <code dir="ltr">Object</code>. <code dir="ltr">AQ$_JMS_VALUE</code> ADT can represent any datatype that JMS <code dir="ltr">StreamMessage</code> and <code dir="ltr">MapMessage</code> can hold.</p>
<p>The collection ADT <code dir="ltr">AQ$_JMS_NAMEARRAY</code> was added for the <code dir="ltr">getNames</code> method of <code dir="ltr">MapMessage</code>. It holds an array of names.</p>
<p>In this release the ADT <code dir="ltr">AQ$_JMS_EXCEPTION</code> was added to represent a Java exception thrown in an OJMS JAVA stored procedure on the PL/SQL side. Now you can retrieve a Java exception thrown by an OJMS stored procedure and analyze it on the PL/SQL side.</p>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS71773" class="refsect2"><a id="i1273342"></a>
<h3 class="refsect2">More on Bytes, Stream and Map Messages</h3>
<p>Oracle uses Java stored procedure to implement some of the procedures of <code dir="ltr">AQ$_MAP_MESSAGE</code>, <code dir="ltr">AQ$_JMS_STREAM_MESSAGE</code>, and <code dir="ltr">AQ$_JMS_BYTES_MESSAGE</code> types. These types have some common functionalities that are different from <code dir="ltr">AQ$_JMS_TEXT_MESSAGE</code> type. This section discusses these common functionalities.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1273362">Using Java Stored Procedures to Encode and Decode Oracle Database Advanced Queuing Messages</a></p>
</li>
<li>
<p><a href="#i1273404">Read-Only and Write-Only Modes Enforced for Stream and Bytes Messages</a></p>
</li>
<li>
<p><a href="#i1273415">Differences Between Bytes and Stream Messages</a></p>
</li>
<li>
<p><a href="#i1273427">Getting and Setting Bytes, Map, and Stream Messages as RAW Bytes</a></p>
</li>
</ul>
<div id="ARPLS71774" class="refsect3"><a id="i1273362"></a>
<h4 class="refsect3">Using Java Stored Procedures to Encode and Decode Oracle Database Advanced Queuing Messages</h4>
<p>The major difference between map, stream, bytes, and other messages is that the message payload is encoded as a byte stream by JAVA. Retrieving and updating these payloads in PL/SQL therefore requires Oracle JAVA stored procedures.</p>
<p>A message payload is stored in two places during processing. On the PL/SQL side it is stored as the data members of a JMS message ADT, and on the Jserv side it is stored as a static variable. (Jserv is the JVM inside Oracle Database.) When the payload is processed, the payload data is first transformed to a static variable on the Jserv side. Once the static variable is initialized, all later updates on the message payload are performed on this static variable. At the end of processing, payload data is flushed back to the PL/SQL side.</p>
<p>Oracle provides member procedures that maintain the status of the Jserv static variable and enforce rules when calling these member procedures. These procedures are in the following ADTs:</p>
<ul>
<li>
<p><code dir="ltr">aq$_jms_bytes_message</code></p>
</li>
<li>
<p><code dir="ltr">aq$_jms_map_message</code></p>
</li>
<li>
<p><code dir="ltr">aq$_jms_stream_message</code></p>
</li>
</ul>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71775" class="refsect3"><a id="sthref20401"></a>
<h4 class="refsect3">Initialize the Jserv Static Variable</h4>
<p>Before you make any other calls to manipulate the payload data, the Jserv static variable must be properly initialized. This is done by calling the <code dir="ltr">prepare</code> or <code dir="ltr">clear_body</code> procedure. The <code dir="ltr">prepare</code> procedure uses the payload data in PL/SQL ADTs to initialize the static variable, while <code dir="ltr">clear_body</code> initializes the static variable to an empty payload (empty hashtable or stream).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is important to call the <code dir="ltr">prepare</code> or <code dir="ltr">clear_body</code> procedure before any other calls to properly initialize the Jserv static variables. Usually these two methods are called once at the beginning. But they can be called multiple times for one message. Any call of these two methods without first calling the <code dir="ltr">flush</code> procedure wipes out all updates made to the messages.</div>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71776" class="refsect3"><a id="sthref20402"></a>
<h4 class="refsect3">Get the Payload Data Back to PL/SQL</h4>
<p>Calling the <code dir="ltr">flush</code> procedure synchronizes changes made to the Jserv static variable back to the PL/SQL ADTs. The <code dir="ltr">flush</code> call is required when you want the changes made to be reflected in the ADT payload. It is important to synchronize the changes back to the ADT, because it is the ADT payload that matters.</p>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71777" class="refsect3"><a id="sthref20403"></a>
<h4 class="refsect3">Garbage Collect the Static Variable</h4>
<p>The <code dir="ltr">clean</code> procedure forces garbage collection of the static variable. It is there to do cleanup and free JVM memory. You can avoid memory leaks by doing it immediately after finishing processing the message.</p>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71778" class="refsect3"><a id="sthref20404"></a>
<h4 class="refsect3">Use a Message Store: A Static Variable Collection</h4>
<p>Instead of a single static variable, Oracle uses a collection of static variables to process the message payload on the Jserv side. This collection is called the message store. Each map, bytes, or stream message type has its own message store within one session.</p>
<p>Oracle uses the operation ID parameter to locate the correct static variable to work on within the message store. Initialization calls such as <code dir="ltr">prepare</code> and <code dir="ltr">clear_body</code> give users an operation ID, which is used in later message access.</p>
<p>After users complete message processing, they must call the <code dir="ltr">clean</code> procedure with the operation ID to clean up the message store. This avoids possible memory leaks. The <code dir="ltr">clean_all</code> static procedures of message ADTs <code dir="ltr">aq$_jms_bytes_message</code>, <code dir="ltr">aq$_jms_map_message</code>, and <code dir="ltr">aq$_jms_stream_message</code> clean up all static variables of their corresponding message stores.</p>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71779" class="refsect3"><a id="sthref20405"></a>
<h4 class="refsect3">Typical Calling Sequences</h4>
<p>This section describes typical procedures for retrieving and populating messages.</p>
<p>Here is a typical procedure for retrieving messages</p>
<ol>
<li>
<p>Call <code dir="ltr">prepare</code> for a message.</p>
<p>This call also gives you an operation ID if you do not specify one.</p>
</li>
<li>
<p>Call multiple retrieving procedures with the provided operation ID.</p>
</li>
<li>
<p>Call the <code dir="ltr">clean</code> procedure with the provided operation ID.</p>
</li>
</ol>
<p>Here is a typical procedure for populating messages:</p>
<ol>
<li>
<p>Call <code dir="ltr">clear_body</code> for a message.</p>
<p>For <code dir="ltr">aq$_jms_map_message</code>, you can also call <code dir="ltr">prepare</code> to update the message based on the existing payload. This call also gives you an operation ID if you do not specify one.</p>
</li>
<li>
<p>Call multiple updating procedures with the provided operation ID.</p>
</li>
<li>
<p>Call the <code dir="ltr">flush</code> method with the provided operation ID.</p>
</li>
<li>
<p>Call the <code dir="ltr">clean</code> procedure with the provided operation ID.</p>
</li>
</ol>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71780" class="refsect3"><a id="i1273404"></a>
<h4 class="refsect3">Read-Only and Write-Only Modes Enforced for Stream and Bytes Messages</h4>
<p>According to the JMS specification, when a message is received, its body is read-only. Users can call the <code dir="ltr">clear_body</code> method to make the body writable. This method erases the current message body and sets the message body to be empty.</p>
<p>The OJMS JAVA API follows the rule set by JMS specification. In updating the JMS message ADTs in PL/SQL, however, Oracle enforces the rule selectively:</p>
<ul>
<li>
<p>Map messages</p>
<p>The restriction is relaxed, because adding more entries on top of a existing map payload is a convenient way for users to update the payload. Therefore there are no read-only or write-only modes for map messages.</p>
</li>
<li>
<p>Stream and bytes messages</p>
<p>The restriction is not relaxed, because these payloads use a stream when reading and writing data. It is difficult to update the payload while in the middle of a stream. Oracle enforces read-only and write-only modes in processing stream and bytes message payloads. Calling the <code dir="ltr">prepare</code> procedure initializes the message payload in read-only mode. Calling the <code dir="ltr">clear_body</code> procedure initializes the message payload in write-only mode.</p>
<p>Calling the <code dir="ltr">reset</code> procedure resets the pointer to the beginning of the stream and switches the mode from write-only to read-only. The <code dir="ltr">reset</code> procedure keeps the updates made to the message payload in the Jserv static variable.</p>
<p>The <code dir="ltr">prepare</code> procedure, on the other hand, overwrites the message payload in the Jserv static variable with the payload in the PL/SQL ADT.</p>
<p>Oracle provides member function <code dir="ltr">get_mode</code> for users to query the mode.</p>
</li>
</ul>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71781" class="refsect3"><a id="i1273415"></a>
<h4 class="refsect3">Differences Between Bytes and Stream Messages</h4>
<p>Member functions of bytes messages are not exactly the same as those of stream messages. Stream messages are encoded using Java <code dir="ltr">ObjectOutputStream</code> and bytes messages are encoded using Java <code dir="ltr">DataOutputStream</code>. In stream messages each primitive type is written and read as a Java Object, but in a bytes message they are written and read as raw bytes according to the encoding mechanism of <code dir="ltr">DataOutputStream</code>.</p>
<p>For stream messages, the <code dir="ltr">read_bytes</code> method works on a stream of bytes to the end of the byte array field written by the corresponding <code dir="ltr">write_bytes</code> method. The <code dir="ltr">read_bytes</code> method of bytes message works on a stream of bytes to the end of the whole byte stream. This is why the <code dir="ltr">read_bytes</code> member procedure of <code dir="ltr">aq$_bytes_message</code> also requires a <code dir="ltr">length</code> parameter to tell how long it is to read.</p>
<p>You will not see a type conversion error raised by bytes message, because bytes messages do not support type conversion.</p>
<p>Methods <code dir="ltr">get_unsigned_byte</code> and <code dir="ltr">get_unsigned_short</code> are available for bytes messages, but not for stream messages. This is because stream messages read Java objects, and there are no Java objects as unsigned bytes or unsigned shorts.</p>
<p>Methods <code dir="ltr">read_string</code> and <code dir="ltr">write_string</code> methods are not available for bytes messages. The bytes message ADT must enforce some character encoding. It has methods <code dir="ltr">read_utf</code> and <code dir="ltr">write_utf</code> which support <code dir="ltr">utf-8</code> encoding.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
All data written by bytes messages use <code dir="ltr">DataOutputStream</code> as the basis. See JDK API documentation JavaSoft.com for details on how the data is encoded into bytes.</div>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71782" class="refsect3"><a id="i1273427"></a>
<h4 class="refsect3">Getting and Setting Bytes, Map, and Stream Messages as RAW Bytes</h4>
<p>The payloads of bytes, map, and stream message types are stored as either <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code> in the database. In this release Oracle Database Advanced Queuing provides the following member functions to set and get these payloads as raw bytes without interpreting them:</p>
<pre dir="ltr">set_bytes(payload IN BLOB)
set_bytes(payload IN RAW)
get_bytes(payload OUT BLOB)
get_bytes(payload OUT RAW) 
</pre>
<p>These functions were provided for bytes messages in Oracle9<span class="italic">i</span> Release 2 (9.2).</p>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS71783" class="refsect2"><a id="i1273439"></a>
<h3 class="refsect2">Upcasting and Downcasting Between General and Specific Messages</h3>
<p>OJMS ADT <code dir="ltr">aq$_jms_message</code> is used to represent a general message, so that different types of messages can reside on the same Oracle Database Advanced Queuing queue. Oracle Database Advanced Queuing supports retrieving and populating of <code dir="ltr">aq$_jms_message</code> by supporting upcasting and downcasting between this ADT and ADTs of specific message types.</p>
<p>To read an <code dir="ltr">aq$_jms_message</code>, you must first downcast it to a specific message type according to its <code dir="ltr">message_type</code> field</p>
<p>To populate an <code dir="ltr">aq$_jms_message</code>, you must first populate a specific message and upcast it to <code dir="ltr">aq$_jms_message</code>. This avoids copying all member functions of other specific message ADTs to this ADT. It also guarantees that the manipulation of this ADT is consistent with other specific message ADTs.</p>
</div>
<!-- class="refsect2" -->
<div id="ARPLS71784" class="refsect2"><a id="i1273450"></a>
<h3 class="refsect2">JMS Types Error Reporting</h3>
<p><a href="#BABCJDDG">Table 274-1</a> lists Oracle JMS types related errors.</p>
<div id="ARPLS71785" class="tblformalwide">
<p class="titleintable"><a id="sthref20406"></a><a id="BABCJDDG"></a>Table 274-1 Oracle JMS Types Errors</p>
<table class="cellalignment4327" title="Oracle JMS Types Errors" summary="This table describes Exceptions raised by JMS Types." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t5">ORA error number</th>
<th class="cellalignment4328" id="r1c2-t5">dbms_jms_plsql package constants</th>
<th class="cellalignment4328" id="r1c3-t5">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t5" headers="r1c1-t5">
<p>ORA-24190</p>
</td>
<td class="cellalignment4329" headers="r2c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_DATA_OVERFLOW</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t5 r1c3-t5">
<p>The payload data exceeds the size that an out parameter can hold. For example, the <code dir="ltr">get_text</code> procedure with a <code dir="ltr">VARCHAR2</code> parameter of <code dir="ltr">aq$_jms_text_message</code> or <code dir="ltr">get_bytes procedure</code> with a <code dir="ltr">RAW</code> parameter of <code dir="ltr">aq$_jms_bytes_message.</code></p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t5" headers="r1c1-t5">
<p>ORA-24191</p>
</td>
<td class="cellalignment4329" headers="r3c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_PROP_NAME_EXIST</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t5 r1c3-t5">
<p>Setting a property that is previous set</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t5" headers="r1c1-t5">
<p>ORA-24192</p>
</td>
<td class="cellalignment4329" headers="r4c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_PROP_NAME_NULL</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t5 r1c3-t5">
<p>Occurs when setting a property with null property name.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t5" headers="r1c1-t5">
<p>ORA-24193</p>
</td>
<td class="cellalignment4329" headers="r5c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_EXCEED_RANGE</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t5 r1c3-t5">
<p>PL/SQL number type exceeds the valid range of the respective Java type. For example <code dir="ltr">set_byte_property</code>, <code dir="ltr">set_short_property</code> of <code dir="ltr">aq$_jms_head</code> ADT; <code dir="ltr">set_byte</code> and <code dir="ltr">set_short</code> of <code dir="ltr">aq$_jms_map_messag</code>e ADT; <code dir="ltr">write_byte</code> and <code dir="ltr">write_short</code> of <code dir="ltr">aq$_jms_stream_message</code> and <code dir="ltr">aq$_jms_bytes_message</code> ADT.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t5" headers="r1c1-t5">
<p>ORA-24194</p>
</td>
<td class="cellalignment4329" headers="r6c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_TYPE_MISMATCH</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t5 r1c3-t5">
<p>The type conversion between the Java type of the retrieving method and the Java type of a field of the payload is not valid.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t5" headers="r1c1-t5">
<p>ORA-24195</p>
</td>
<td class="cellalignment4329" headers="r7c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_MAP_TOO_LARGE</code></p>
</td>
<td class="cellalignment4329" headers="r7c1-t5 r1c3-t5">
<p>The size of the map exceeds the <code dir="ltr">aq$_jms_namearray</code> ADT capacity. The current size limit is 1024. You can use the <code dir="ltr">get_names</code> function with <code dir="ltr">offset</code> and <code dir="ltr">length</code> parameters to retrieve the name array in multiple small chunks.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r8c1-t5" headers="r1c1-t5">
<p>ORA-24196</p>
</td>
<td class="cellalignment4329" headers="r8c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_WRONG_MODE</code></p>
</td>
<td class="cellalignment4329" headers="r8c1-t5 r1c3-t5">
<p>The message payload is being accessed with a wrong access mode. For example, trying to read a message payload with write-only mode or trying to write a message payload with the read-only mode.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r9c1-t5" headers="r1c1-t5">
<p>ORA-24197</p>
</td>
<td class="cellalignment4329" headers="r9c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_JAVA_EXCEPTION</code></p>
</td>
<td class="cellalignment4329" headers="r9c1-t5 r1c3-t5">
<p>ORA-24197 error is raised when a Java exception is raised that does not fit in any of the other error categories. You can use the <code dir="ltr">get_exception</code> static procedure of <code dir="ltr">aq$_jms_map_message</code>, <code dir="ltr">aq$_jms_bytes_message</code>, and <code dir="ltr">aq$_jms_stream_message</code> to retrieve the exception information last thrown by the Java stored procedure.</p>
<p>A single static variable is used to store the last exception and is overwritten if another exception is thrown before you retrieve it. A new ADT <code dir="ltr">aq$_jms_exception</code> is created to represent the exception information on the PL/SQL side.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r10c1-t5" headers="r1c1-t5">
<p>ORA-24198</p>
</td>
<td class="cellalignment4329" headers="r10c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_INVALID_ID</code></p>
</td>
<td class="cellalignment4329" headers="r10c1-t5 r1c3-t5">
<p>An invalid operation ID is being provided to access a message.</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r11c1-t5" headers="r1c1-t5">
<p>ORA-24199</p>
</td>
<td class="cellalignment4329" headers="r11c1-t5 r1c2-t5">
<p><code dir="ltr">ERROR_STORE_OVERFLOW</code></p>
</td>
<td class="cellalignment4329" headers="r11c1-t5 r1c3-t5">
<p>The number of messages (with the same type) that users are trying to manipulate exceeds the size of the message store on the Java stored procedure side. The current size of the store is 20. It unusual to need to manipulate more than 20 messages at the same time. A common mistake is to forget to call the <code dir="ltr">clean</code> procedure after using one message. The <code dir="ltr">clean</code> procedure frees the message slot for use by other messages attempting access.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" --></div>
<!-- class="refsect2" -->
<div id="ARPLS71786" class="refsect2"><a id="i1273541"></a>
<h3 class="refsect2">Oracle JMS Type Constants</h3>
<p>This section lists some useful constants when dealing with message type functions.</p>
<p class="subhead1"><a id="ARPLS71787"></a>DBMS_AQ Package Constants</p>
<p><code dir="ltr">DBMS_AQ</code> package constants specify different types of JMS messages. They are useful when dealing with general message types during upcasting and downcasting or constructing a general message with a specific message type:</p>
<pre dir="ltr">JMS_TEXT_MESSAGE   CONSTANT BINARY_INTEGER;
JMS_BYTES_MESSAGE  CONSTANT BINARY_INTEGER;
JMS_STREAM_MESSAGE CONSTANT BINARY_INTEGER;
JMS_MAP_MESSAGE    CONSTANT BINARY_INTEGER;
JMS_OBJECT_MESSAGE CONSTANT BINARY_INTEGER;
</pre>
<p class="subhead1"><a id="ARPLS71788"></a>SYS.DBMS_JMS_PLSQL Package Constants</p>
<p><code dir="ltr">SYS.DBMS_JMS_PLSQL</code> package constants are new in Oracle Database 10<span class="italic">g</span>.</p>
<p>These constants specify the mode of message payload. They are useful when interpreting the mode of the message payload returned from the <code dir="ltr">get_mode</code> function:</p>
<pre dir="ltr">MESSAGE_ACCESS_READONLY  CONSTANT PLS_INTEGER;
MESSAGE_ACCESS_WRITEONLY CONSTANT PLS_INTEGER;
</pre>
<p>These constants specify the ADT type of an Oracle Database Advanced Queuing queue. They are useful during the conversion of JMS selectors to Oracle Database Advanced Queuing rules:</p>
<pre dir="ltr">DESTPLOAD_JMSTYPE CONSTANT PLS_INTEGER;
DESTPLOAD_USERADT CONSTANT PLS_INTEGER;
DESTPLOAD_ANYDATA CONSTANT PLS_INTEGER;
</pre>
<p>These constants specify the type of data that can be held by a <code dir="ltr">aq$_jms_value</code> type. They are useful when interpreting the <code dir="ltr">aq$_jms_value</code> returned by the <code dir="ltr">get_object</code> method of <code dir="ltr">AQ$_JMS_MAP_MESSAGE</code> or <code dir="ltr">read_object</code> method of <code dir="ltr">AQ$_JMS_STREAM_MESSAGE</code>:</p>
<pre dir="ltr">DATA_TYPE_BYTE           CONSTANT PLS_INTEGER;
DATA_TYPE_SHORT          CONSTANT PLS_INTEGER;
DATA_TYPE_INTEGER        CONSTANT PLS_INTEGER;
DATA_TYPE_LONG           CONSTANT PLS_INTEGER;
DATA_TYPE_FLOAT          CONSTANT PLS_INTEGER;
DATA_TYPE_DOUBLE         CONSTANT PLS_INTEGER;
DATA_TYPE_BOOLEAN        CONSTANT PLS_INTEGER;
DATA_TYPE_CHARACTER      CONSTANT PLS_INTEGER;
DATA_TYPE_STRING         CONSTANT PLS_INTEGER;
DATA_TYPE_BYTES          CONSTANT PLS_INTEGER;
DATA_TYPE_UNSIGNED_BYTE  CONSTANT PLS_INTEGER;
DATA_TYPE_UNSIGNED_SHORT CONSTANT PLS_INTEGER;
</pre>
<p>These constants specify the error number of the ORA errors that can be raised by the functions of message type ADTs. They are useful in user error handlers:</p>
<pre dir="ltr">ERROR_DATA_OVERFLOW   CONSTANT PLS_INTEGER := -24190;
ERROR_PROP_NAME_EXIST CONSTANT PLS_INTEGER := -24191;
ERROR_PROP_NAME_NULL  CONSTANT PLS_INTEGER := -24192;
ERROR_EXCEED_RANGE    CONSTANT PLS_INTEGER := -24193;
ERROR_TYPE_MISMATCH   CONSTANT PLS_INTEGER := -24194;
ERROR_MAP_TOO_LARGE   CONSTANT PLS_INTEGER := -24195;
ERROR_WRONG_MODE      CONSTANT PLS_INTEGER := -24196;
ERROR_JAVA_EXCEPTION  CONSTANT PLS_INTEGER := -24197;
ERROR_INVALID_ID      CONSTANT PLS_INTEGER := -24198;
ERROR_STORE_OVERFLOW  CONSTANT PLS_INTEGER := -24199;
</pre></div>
<!-- class="refsect2" -->
<div id="ARPLS71789" class="refsect2"><a id="i1273599"></a>
<h3 class="refsect2">CONVERT_JMS_SELECTOR</h3>
<p>Oracle Database includes three stored procedures to help users convert JMS selectors into Oracle Database Advanced Queuing rules. These rules can be used in <code dir="ltr">ADD_SUBSCRIBER</code> operations as subscriber rules or in <code dir="ltr">DEQUEUE</code> operations as dequeue conditions. These procedures are in the <code dir="ltr">SYS.dbms_jms_plsql</code> package.</p>
<div id="ARPLS71790" class="refsect3"><a id="sthref20407"></a>
<h4 class="refsect3">Convert with Minimal Specification</h4>
<p>The first procedure assumes the destination payload type is one of the JMS ADTs whose corresponding constant is <code dir="ltr">dbms_jms_plsql.DESTPLOAD_JMSTYPE</code> and also assumes that the J2EE compliant mode is true.</p>
<p class="subhead1"><a id="ARPLS71791"></a>Syntax</p>
<pre dir="ltr">Function convert_jms_selector(selector IN VARCHAR2) RETURN VARCHAR2
</pre>
<p class="subhead1"><a id="ARPLS71792"></a>Returns</p>
<p>The converted Oracle Database Advanced Queuing rule or null if there is any conversion error.</p>
<p class="subhead1"><a id="ARPLS71793"></a>Exceptions</p>
<p>ORA-24197 if the Java stored procedure throws an exception during execution.</p>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71794" class="refsect3"><a id="sthref20408"></a>
<h4 class="refsect3">Convert with Destination Payload Type Specified</h4>
<p>The second procedure takes one more parameter: <code dir="ltr">dest_pload_type</code>. The conversion of a JMS selector to an Oracle Database Advanced Queuing rule happens only if this parameter is <code dir="ltr">SYS.dbms_jms_plsql.DESTPLOAD_JMSTYPE</code> or <code dir="ltr">SYS.dbms_jms_plsql.DESTPLOAD_ANYDATA</code>. The function returns exactly the same <code dir="ltr">VARCHAR2</code> value as the selector parameter if the <code dir="ltr">dest_pload_type</code> parameter is <code dir="ltr">SYS.dbms_jms_plsql.DESTPLOAD_USERADT</code>. The function returns null if <code dir="ltr">dest_pload_type</code> parameter is none of these three constants.</p>
<p>This function assumes that the J2EE compliant mode is true.</p>
<p class="subhead1"><a id="ARPLS71795"></a>Syntax</p>
<pre dir="ltr">Function convert_jms_selector(
   selector IN VARCHAR2, 
   dest_pload_type IN PLS_INTEGER)
RETURN VARCHAR2
</pre>
<p class="subhead1"><a id="ARPLS71796"></a>Returns</p>
<p>The converted Oracle Database Advanced Queuing rule or null if there is any conversion error.</p>
<p class="subhead1"><a id="ARPLS71797"></a>Exceptions</p>
<p>ORA-24197 if the Java stored procedure throws an exception during execution.</p>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71798" class="refsect3"><a id="sthref20409"></a>
<h4 class="refsect3">Convert with Destination Payload Type and Compliant Mode Specified</h4>
<p>The third procedure takes a <code dir="ltr">dest_pload_type</code> parameter and a <code dir="ltr">compliant</code> parameter. The conversion of a JMS selector to an Oracle Database Advanced Queuing rule happens only if the <code dir="ltr">dest_pload_type</code> parameter is <code dir="ltr">SYS.dbms_jms_plsql.DESTPLOAD_JMSTYPE</code> or <code dir="ltr">SYS.dbms_jms_plsql.DESTPLOAD_ANYDATA</code>. The function returns exactly the same <code dir="ltr">VARCHAR2</code> value as the selector parameter if the <code dir="ltr">dest_pload_type</code> parameter is <code dir="ltr">SYS.dbms_jms_plsql.DESTPLOAD_USERADT</code>. The function returns null if the <code dir="ltr">dest_pload_type</code> parameter is none of these three constants.</p>
<p>The <code dir="ltr">compliant</code> parameter controls if the conversion is in J2EE compliant mode or not. The noncompliant conversion of a JMS selector is for backward compatibility.</p>
<p class="subhead1"><a id="ARPLS71799"></a>Syntax</p>
<pre dir="ltr">Function convert_jms_selector(
   selector         IN  VARCHAR2,
   dest_pload_type  IN  PLS_INTEGER,
   compliant        IN  BOOLEAN )
</pre>
<p class="subhead1"><a id="ARPLS71800"></a>Returns</p>
<p>The converted Oracle Database Advanced Queuing rule or null if there is any conversion error.</p>
<p class="subhead1"><a id="ARPLS71801"></a>Exceptions</p>
<p>ORA-24197 if the Java stored procedure throws an exception during execution.</p>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" -->
<a id="i1273865"></a>
<div id="ARPLS71802" class="refsect1">
<h2 class="refsect1">Summary of JMS Types</h2>
<ul>
<li>
<p><a href="#i1007556">SYS.AQ$_JMS_MESSAGE Type</a></p>
</li>
<li>
<p><a href="#i996967">SYS.AQ$_JMS_TEXT_MESSAGE Type</a></p>
</li>
<li>
<p><a href="#i1244160">SYS.AQ$_JMS_BYTES_MESSAGE Type</a></p>
</li>
<li>
<p><a href="#i1022148">SYS.AQ$_JMS_MAP_MESSAGE Type</a></p>
</li>
<li>
<p><a href="#i1233993">SYS.AQ$_JMS_STREAM_MESSAGE Type</a></p>
</li>
<li>
<p><a href="#i1250011">SYS.AQ$_JMS_OBJECT_MESSAGE Type</a></p>
</li>
<li>
<p><a href="#i1243541">SYS.AQ$_JMS_NAMEARRAY Type</a></p>
</li>
<li>
<p><a href="#i1243557">SYS.AQ$_JMS_VALUE Type</a></p>
</li>
<li>
<p><a href="#i1243660">SYS.AQ$_JMS_EXCEPTION Type</a></p>
</li>
</ul>
<div id="ARPLS71803" class="refsect2"><a id="i1007556"></a>
<h3 class="refsect2">SYS.AQ$_JMS_MESSAGE Type</h3>
<p>This ADT type can represent any of five different JMS message types: text message, bytes message, stream message, map message, or object message. Queues created using this ADT can therefore store all five types of JMS messages.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1252318">CONSTRUCT Static Functions</a></p>
</li>
<li>
<p><a href="#i1252325">Cast Methods</a></p>
</li>
<li>
<p><a href="#i1252332">JMS Header Methods</a></p>
</li>
<li>
<p><a href="#i1252339">System Properties Methods</a></p>
</li>
<li>
<p><a href="#i1252346">User Properties Methods</a></p>
</li>
<li>
<p><a href="#i1269703">Payload Methods</a></p>
</li>
</ul>
<p class="subhead1"><a id="ARPLS71804"></a>Syntax</p>
<pre dir="ltr">TYPE AQ$_JMS_MESSAGE AS OBJECT(
 header        aq$_jms_header, 
 senderid      varchar2(100), 
 message_type  INT, 
 text_len      INT, 
 bytes_len     INT, 
 text_vc       varchar2(4000), 
 bytes_raw     raw(2000), 
 text_lob      clob, 
 bytes_lob     blob, 
 STATIC FUNCTION  construct (mtype      IN  INT)
   RETURN aq$_jms_message, 
 STATIC FUNCTION  construct (text_msg   IN  aq$_jms_text_message)
   RETURN aq$_jms_message,
 STATIC FUNCTION  construct (bytes_msg  IN  aq$_jms_bytes_message)
   RETURN aq$_jms_message,
 STATIC FUNCTION  construct (stream_msg IN  aq$_jms_stream_message)
   RETURN aq$_jms_message,
 STATIC FUNCTION  construct (map_msg    IN  aq$_jms_map_message)
   RETURN aq$_jms_message,
 STATIC FUNCTION  construct (object_msg IN  aq$_jms_object_message)
   RETURN aq$_jms_message,
 MEMBER FUNCTION  cast_to_bytes_msg  RETURN aq$_jms_bytes_message,
 MEMBER FUNCTION  cast_to_map_msg    RETURN aq$_jms_map_message,
 MEMBER FUNCTION  cast_to_object_msg RETURN aq$_jms_object_message,
 MEMBER FUNCTION  cast_to_stream_msg RETURN aq$_jms_stream_message,
 MEMBER FUNCTION  cast_to_text_msg   RETURN aq$_jms_text_message,
 MEMBER PROCEDURE set_replyto  (replyto IN sys.aq$_agent),
 MEMBER PROCEDURE set_type     (type     IN  VARCHAR),
 MEMBER PROCEDURE set_userid   (userid   IN  VARCHAR),
 MEMBER PROCEDURE set_appid    (appid    IN  VARCHAR),
 MEMBER PROCEDURE set_groupid  (groupid  IN  VARCHAR),
 MEMBER PROCEDURE set_groupseq (groupseq IN  INT),
 MEMBER FUNCTION  get_replyto  RETURN sys.aq$_agent,
 MEMBER FUNCTION  get_type     RETURN VARCHAR,
 MEMBER FUNCTION  get_userid   RETURN VARCHAR,
 MEMBER FUNCTION  get_appid    RETURN VARCHAR,
 MEMBER FUNCTION  get_groupid  RETURN VARCHAR,
 MEMBER FUNCTION  get_groupseq RETURN INT,
 MEMBER PROCEDURE clear_properties,
 MEMBER PROCEDURE set_boolean_property (property_name IN VARCHAR,
   property_value IN BOOLEAN),
 MEMBER PROCEDURE set_byte_property    (property_name IN VARCHAR,
   property_value IN INT), 
 MEMBER PROCEDURE set_double_property  (property_name IN VARCHAR, 
   property_value IN DOUBLE PRECISION),
 MEMBER PROCEDURE set_float_property   (property_name IN VARCHAR, 
   property_value IN FLOAT), 
 MEMBER PROCEDURE set_int_property     (property_name IN VARCHAR, 
   property_value IN INT),
 MEMBER PROCEDURE set_long_property    (property_name IN VARCHAR, 
   property_value IN NUMBER), 
 MEMBER PROCEDURE set_short_property   (property_name IN VARCHAR, 
   property_value IN INT), 
 MEMBER PROCEDURE set_string_property  (property_name IN VARCHAR, 
   property_value IN VARCHAR), 
 MEMBER FUNCTION get_boolean_property (property_name IN VARCHAR) RETURN BOOLEAN,
 MEMBER FUNCTION get_byte_property    (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_double_property  (property_name IN VARCHAR) 
   RETURN DOUBLE PRECISION, 
 MEMBER FUNCTION get_float_property   (property_name IN VARCHAR) RETURN FLOAT, 
 MEMBER FUNCTION get_int_property     (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_long_property    (property_name IN VARCHAR) RETURN NUMBER,
 MEMBER FUNCTION get_short_property   (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_string_property  (property_name IN VARCHAR) RETURN VARCHAR,
 MEMBER PROCEDURE set_text     (payload  IN  VARCHAR2),
 MEMBER PROCEDURE set_text     (payload  IN  CLOB), 
 MEMBER PROCEDURE set_bytes    (payload  IN  RAW), 
 MEMBER PROCEDURE set_bytes    (payload  IN  BLOB), 
 MEMBER PROCEDURE get_text     (payload  OUT VARCHAR2), 
 MEMBER PROCEDURE get_text     (payload  OUT CLOB), 
 MEMBER PROCEDURE get_bytes    (payload  OUT RAW), 
 MEMBER PROCEDURE get_bytes    (payload  OUT BLOB)); 
</pre>
<div id="ARPLS71805" class="refsect3"><a id="i1252318"></a>
<h4 class="refsect3">CONSTRUCT Static Functions</h4>
<p>There are six <code dir="ltr">CONSTRUCT</code> static functions in this type.</p>
<dl>
<dt>STATIC FUNCTION construct (mtype IN INT) RETURN aq$_jms_message</dt>
<dd>
<p>Creates an instance of <code dir="ltr">aq$_jms_message</code>, which can hold a specific type of JMS message (TextMessage, BytesMessage, MapMessage, StreamMessage or ObjectMessage). The message type of the created <code dir="ltr">aq$_jms_message</code> instance depends on the <code dir="ltr">mtype</code> parameter passed to the construct method. Once a message has been constructed, it can be used to store JMS messages of the type it has been constructed to hold.</p>
<p>The <code dir="ltr">mtype</code> parameter must be one of the following constants described in <a href="#i1273541">&#34;Oracle JMS Type Constants&#34;</a>:</p>
<pre dir="ltr">DBMS_AQ.JMS_TEXT_MESSAGE 
DBMS_AQ.JMS_BYTES_MESSAGE 
DBMS_AQ.JMS_STREAM_MESSAGE 
DBMS_AQ.JMS_MAP_MESSAGE 
DBMS_AQ.JMS_OBJECT_MESSAGE 
</pre></dd>
<dt>STATIC FUNCTION construct (text_msg IN aq$_jms_text_message) RETURN aq$_jms_message</dt>
<dd>
<p>Creates an <code dir="ltr">aq$_jms_message</code> from an <code dir="ltr">aq$_jms_text_message</code>.</p>
</dd>
<dt>STATIC FUNCTION construct (bytes_msg IN aq$_jms_bytes_message) RETURN aq$_jms_message;</dt>
<dd>
<p>Creates an <code dir="ltr">aq$_jms_message</code> from an <code dir="ltr">aq$_jms_bytes_message</code>.</p>
</dd>
<dt>STATIC FUNCTION construct (stream_msg IN aq$_jms_stream_message) RETURN aq$_jms_message;</dt>
<dd>
<p>Creates an <code dir="ltr">aq$_jms_message</code> from an <code dir="ltr">aq$_jms_stream_message</code>.</p>
</dd>
<dt>STATIC FUNCTION construct (map_msg IN aq$_jms_map_message) RETURN aq$_jms_message;</dt>
<dd>
<p>Creates an <code dir="ltr">aq$_jms_message</code> from an <code dir="ltr">aq$_jms_map_message</code>.</p>
</dd>
<dt>STATIC FUNCTION construct (object_msg IN aq$_jms_object_message) RETURN aq$_jms_message;</dt>
<dd>
<p>Creates an <code dir="ltr">aq$_jms_message</code> from an <code dir="ltr">aq$_jms_object_message</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71806" class="refsect3"><a id="i1252325"></a>
<h4 class="refsect3">Cast Methods</h4>
<dl>
<dt>cast_to_bytes_msg RETURN aq$_jms_bytes_message</dt>
<dd>
<p>Casts an <code dir="ltr">aq$_jms_message</code> to an <code dir="ltr">aq$_jms_bytes_message</code>. Returns an <code dir="ltr">aq$_jms_bytes_message</code> or null if the <code dir="ltr">message_type</code> attribute of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQ.JMS_BYTES_MESSAGE</code>. This function raises ORA-24198 if the <code dir="ltr">message_type</code> field of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQJMS.JMS_BYTES_MESSAGE</code>.</p>
</dd>
<dt>cast_to_map_msg RETURN aq$_jms_map_message</dt>
<dd>
<p>Casts an <code dir="ltr">aq$_jms_message</code> to an <code dir="ltr">aq$_jms_map_message</code>. Returns an <code dir="ltr">aq$_jms_map_message</code> or null if the <code dir="ltr">message_type</code> attribute of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQ.JMS_MAP_MESSAGE</code>. This function raises ORA-24198 if the <code dir="ltr">message_type</code> field of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQJMS.JMS_MAP_MESSAGE</code>.</p>
</dd>
<dt>cast_to_object_msg RETURN aq$_jms_object_message</dt>
<dd>
<p>Casts an <code dir="ltr">aq$_jms_message</code> to an <code dir="ltr">aq$_jms_object_message</code>. Returns an <code dir="ltr">aq$_jms_object_message</code> or null if the <code dir="ltr">message_type</code> attribute of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQ.JMS_OBJECT_MESSAGE</code>. This function raises ORA-24198 if the <code dir="ltr">message_type</code> field of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQJMS.JMS_OBJECT_MESSAGE</code>.</p>
</dd>
<dt>cast_to_stream_msg RETURN aq$_jms_stream_message</dt>
<dd>
<p>Casts an <code dir="ltr">aq$_jms_message</code> to an <code dir="ltr">aq$_jms_stream_message</code>. Returns an <code dir="ltr">aq$_jms_stream_message</code> or null if the <code dir="ltr">message_type</code> attribute of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQ.JMS_STREAM_MESSAGE</code>. This function raises ORA-24198 if the <code dir="ltr">message_type</code> field of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQJMS.JMS_STREAM_MESSAGE</code>.</p>
</dd>
<dt>cast_to_text_msg RETURN aq$_jms_text_message</dt>
<dd>
<p>Casts an <code dir="ltr">aq$_jms_message</code> to an <code dir="ltr">aq$_jms_text_message</code>. Returns an <code dir="ltr">aq$_jms_text_message</code> or null if the <code dir="ltr">message_type</code> attribute of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQ.JMS_TEXT_MESSAGE</code>. This function raises ORA-24198 if the <code dir="ltr">message_type</code> field of the <code dir="ltr">aq$_jms_message</code> is not <code dir="ltr">DBMS_AQJMS.JMS_TEXT_MESSAGE</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71807" class="refsect3"><a id="i1252332"></a>
<h4 class="refsect3">JMS Header Methods</h4>
<dl>
<dt>set_replyto (replyto IN sys.aq$_agent)</dt>
<dd>
<p>Sets the <code dir="ltr">replyto</code> parameter, which corresponds to <code dir="ltr">JMSReplyTo</code>.</p>
</dd>
<dt>get_replyto RETURN sys.aq$_agent</dt>
<dd>
<p>Returns <code dir="ltr">replyto</code>, which corresponds to <code dir="ltr">JMSReplyTo</code>.</p>
</dd>
<dt>set_type (type IN VARCHAR)</dt>
<dd>
<p>Sets the JMS type, which can be any text and corresponds to <code dir="ltr">JMSType</code>.</p>
</dd>
<dt>get_type RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">type</code>, which corresponds to <code dir="ltr">JMSType</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71808" class="refsect3"><a id="i1252339"></a>
<h4 class="refsect3">System Properties Methods</h4>
<dl>
<dt>set_userid (userid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code>.</p>
</dd>
<dt>set_appid (appid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code>.</p>
</dd>
<dt>set_groupid (groupid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code>.</p>
</dd>
<dt>set_groupseq (groupseq IN INT)</dt>
<dd>
<p>Sets <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code>.</p>
</dd>
<dt>get_userid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code>.</p>
</dd>
<dt>get_appid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code>.</p>
</dd>
<dt>get_groupid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code>.</p>
</dd>
<dt>get_groupseq RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71809" class="refsect3"><a id="i1252346"></a>
<h4 class="refsect3">User Properties Methods</h4>
<dl>
<dt>clear_properties</dt>
<dd>
<p>Clears all user properties. This procedure does not affect system properties.</p>
</dd>
<dt>set_boolean_property (property_name IN VARCHAR, property_value IN BOOLEAN)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If it is not null, the procedure stores <code dir="ltr">property_value</code> in an internal representation (a <code dir="ltr">NUMBER</code> type). Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_byte_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether property_name is null or exists. If it is not null, the procedure checks whether <code dir="ltr">property_value</code> is within -128 to 127 (8-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">byte</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_double_property (property_name IN VARCHAR, property_value IN DOUBLE PRECISION)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If it is not null, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_float_property (property_name IN VARCHAR, property_value IN FLOAT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If it is not null, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_int_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If it is not null, the procedure checks whether <code dir="ltr">property_value</code> is within -2147483648 to 2147483647 (32-bits). This check is necessary because the <code dir="ltr">INT</code> datatype is 38 bits in PL/SQL and Oracle Database. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_long_property (property_name IN VARCHAR, property_value IN NUMBER)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If it is not null, the procedure stores <code dir="ltr">property_value</code>. In PL/SQL and Oracle Database, the <code dir="ltr">NUMBER</code> datatype is 38 bits. In Java, the long datatype is 64 bits. Therefore, no range check is needed. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_short_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If it is not null, the procedure checks whether <code dir="ltr">property_value</code> is within -32768 to 32767 (16-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">short</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_string_property (property_name IN VARCHAR, property_value IN VARCHAR)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If it is not null, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>get_boolean_property (property_name IN VARCHAR) RETURN BOOLEAN</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BOOLEAN</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_byte_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BYTE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_double_property (property_name IN VARCHAR) RETURN DOUBLE PRECISION</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">DOUBLE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_float_property (property_name IN VARCHAR) RETURN FLOAT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">FLOAT</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_int_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">Integer</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_long_property (property_name IN VARCHAR) RETURN NUMBER</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">long</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_short_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">short</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_string_property (property_name IN VARCHAR) RETURN VARCHAR</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">STRING</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71810" class="refsect3"><a id="i1269703"></a>
<h4 class="refsect3">Payload Methods</h4>
<dl>
<dt>set_text (payload IN VARCHAR2)</dt>
<dd>
<p>Sets the payload, a <code dir="ltr">VARCHAR2</code> value, to an internal representation.</p>
</dd>
<dt>set_text (payload IN CLOB),</dt>
<dd>
<p>Sets the payload, a <code dir="ltr">CLOB</code> value, to an internal representation.</p>
</dd>
<dt>set_bytes (payload IN RAW)</dt>
<dd>
<p>Sets the payload, a <code dir="ltr">RAW</code> value, to an internal representation.</p>
</dd>
<dt>set_bytes (payload IN BLOB)</dt>
<dd>
<p>Sets the payload, a <code dir="ltr">BLOB</code> value, to an internal representation.</p>
</dd>
<dt>get_text (payload OUT VARCHAR2)</dt>
<dd>
<p>Puts the internal representation of the payload into a <code dir="ltr">VARCHAR2</code> variable payload.</p>
</dd>
<dt>get_text (payload OUT CLOB)</dt>
<dd>
<p>Puts the internal representation of the payload into a <code dir="ltr">CLOB</code> variable payload.</p>
</dd>
<dt>get_bytes (payload OUT RAW)</dt>
<dd>
<p>Puts the internal representation of the payload into a <code dir="ltr">RAW</code> variable payload.</p>
</dd>
<dt>get_bytes (payload OUT BLOB)</dt>
<dd>
<p>Puts the internal representation of the payload into a <code dir="ltr">BLOB</code> variable payload.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS71811" class="refsect2"><a id="i996967"></a>
<h3 class="refsect2">SYS.AQ$_JMS_TEXT_MESSAGE Type</h3>
<p>This type is the ADT used to store a <code dir="ltr">TextMessage</code> in an Oracle Database Advanced Queuing queue.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1252379">CONSTRUCT Function</a></p>
</li>
<li>
<p><a href="#i1252386">JMS Header Methods</a></p>
</li>
<li>
<p><a href="#i1252393">System Properties Methods</a></p>
</li>
<li>
<p><a href="#i1252400">User Properties Methods</a></p>
</li>
<li>
<p><a href="#i1252407">Payload Methods</a></p>
</li>
</ul>
<p class="subhead1"><a id="ARPLS71812"></a>Syntax</p>
<pre dir="ltr">TYPE AQ$_JMS_TEXT_MESSAGE AS OBJECT(
 header    aq$_jms_header,
 text_len  INT,
 text_vc   varchar2(4000),
 text_lob  clob,
 STATIC FUNCTION construct    RETURN aq$_jms_text_message,
 MEMBER PROCEDURE set_replyto  (replyto  IN  sys.aq$_agent),
 MEMBER PROCEDURE set_type     (type     IN  VARCHAR),
 MEMBER FUNCTION  get_replyto RETURN sys.aq$_agent,
 MEMBER FUNCTION  get_type    RETURN VARCHAR,
 MEMBER PROCEDURE set_userid   (userid   IN  VARCHAR),
 MEMBER PROCEDURE set_appid    (appid    IN  VARCHAR),
 MEMBER PROCEDURE set_groupid  (groupid  IN  VARCHAR),
 MEMBER PROCEDURE set_groupseq (groupseq IN  INT),
 MEMBER FUNCTION get_userid   RETURN VARCHAR,
 MEMBER FUNCTION get_appid    RETURN VARCHAR,
 MEMBER FUNCTION get_groupid  RETURN VARCHAR,
 MEMBER FUNCTION get_groupseq RETURN INT,
 MEMBER PROCEDURE clear_properties,
 MEMBER PROCEDURE set_boolean_property(property_name IN VARCHAR,
   property_value IN BOOLEAN),
 MEMBER PROCEDURE set_byte_property   (property_name IN VARCHAR,
   property_value IN INT),
 MEMBER PROCEDURE set_double_property (property_name IN VARCHAR,
   property_value IN DOUBLE PRECISION),
 MEMBER PROCEDURE set_float_property  (property_name IN VARCHAR,
   property_value IN FLOAT),
 MEMBER PROCEDURE set_int_property    (property_name IN VARCHAR,
   property_value IN INT),
 MEMBER PROCEDURE set_long_property   (property_name IN VARCHAR,
   property_value IN NUMBER),
 MEMBER PROCEDURE set_short_property  (property_name IN VARCHAR,
   property_value IN INT),
 MEMBER PROCEDURE set_string_property (property_name IN VARCHAR,
   property_value IN VARCHAR),
 MEMBER FUNCTION get_boolean_property (property_name IN VARCHAR) 
   RETURN BOOLEAN,
 MEMBER FUNCTION get_byte_property    (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_double_property  (property_name IN VARCHAR)
   RETURN DOUBLE PRECISION,
 MEMBER FUNCTION get_float_property   (property_name IN VARCHAR) RETURN FLOAT,
 MEMBER FUNCTION get_int_property     (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_long_property    (property_name IN VARCHAR) RETURN NUMBER,
 MEMBER FUNCTION get_short_property   (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_string_property  (property_name IN VARCHAR) 
   RETURN VARCHAR,
 MEMBER PROCEDURE set_text            (payload  IN  VARCHAR2),
 MEMBER PROCEDURE set_text            (payload  IN  CLOB),
 MEMBER PROCEDURE get_text            (payload  OUT VARCHAR2),
 MEMBER PROCEDURE get_text            (payload  OUT CLOB));
</pre>
<div id="ARPLS71813" class="refsect3"><a id="i1252379"></a>
<h4 class="refsect3">CONSTRUCT Function</h4>
<dl>
<dt>STATIC FUNCTION construct RETURN aq$_jms_text_message</dt>
<dd>
<p>Creates an empty <code dir="ltr">aq$_jms_text_message</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71814" class="refsect3"><a id="i1252386"></a>
<h4 class="refsect3">JMS Header Methods</h4>
<dl>
<dt>set_replyto (replyto IN sys.aq$_agent)</dt>
<dd>
<p>Sets the <code dir="ltr">replyto</code> parameter, which corresponds to <code dir="ltr">JMSReplyTo</code> in JMS.</p>
</dd>
<dt>set_type (type IN VARCHAR)</dt>
<dd>
<p>Sets the JMS type, which can be any text, and which corresponds to <code dir="ltr">JMSType</code> in JMS.</p>
</dd>
<dt>get_replyto RETURN sys.aq$_agent</dt>
<dd>
<p>Returns <code dir="ltr">replyto</code>, which corresponds to <code dir="ltr">JMSReplyTo</code>.</p>
</dd>
<dt>get_type RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">type</code>, which corresponds to <code dir="ltr">JMSType</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71815" class="refsect3"><a id="i1252393"></a>
<h4 class="refsect3">System Properties Methods</h4>
<dl>
<dt>set_userid (userid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code> in JMS.</p>
</dd>
<dt>set_appid (appid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code> in JMS.</p>
</dd>
<dt>set_groupid (groupid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code> in JMS.</p>
</dd>
<dt>set_groupseq (groupseq IN INT)</dt>
<dd>
<p>Sets <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code> in JMS.</p>
</dd>
<dt>get_userid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code>.</p>
</dd>
<dt>get_appid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code>.</p>
</dd>
<dt>get_groupid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code>.</p>
</dd>
<dt>get_groupseq RETURN INT</dt>
<dd>
<p>Returns <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71816" class="refsect3"><a id="i1252400"></a>
<h4 class="refsect3">User Properties Methods</h4>
<dl>
<dt>clear_properties</dt>
<dd>
<p>Clears all user properties. This procedure does not affect system properties.</p>
</dd>
<dt>set_boolean_property (property_name IN VARCHAR, property_value IN BOOLEAN)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code> in an internal representation. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_byte_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -128 to 127 (8-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">BYTE</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_double_property (property_name IN VARCHAR, property_value IN DOUBLE PRECISION)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_float_property (property_name IN VARCHAR, property_value IN FLOAT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_int_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -2147483648 to 2147483647 (32-bits). This check is necessary because in PL/SQL and Oracle Database, the <code dir="ltr">INT</code> datatype is 38 bits. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_long_property (property_name IN VARCHAR, property_value IN NUMBER)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. In PL/SQL and Oracle Database, the <code dir="ltr">NUMBER</code> datatype is 38 bits. In Java, the <code dir="ltr">long</code> datatype is 64 bits. Therefore, no range check is needed.Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_short_property property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -32768 to 32767 (16-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">short</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_string_property (property_name IN VARCHAR, property_value IN VARCHAR)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>get_boolean_property (property_name IN VARCHAR) RETURN BOOLEAN</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BOOLEAN</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_byte_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BYTE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_double_property (property_name IN VARCHAR) RETURN DOUBLE PRECISION</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">DOUBLE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_float_property (property_name IN VARCHAR) RETURN FLOAT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">FLOAT</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_int_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">Integer</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_long_property (property_name IN VARCHAR) RETURN NUMBER</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">long</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_short_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">short</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_string_property (property_name IN VARCHAR) RETURN VARCHAR)</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">STRING</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71817" class="refsect3"><a id="i1252407"></a>
<h4 class="refsect3">Payload Methods</h4>
<dl>
<dt>set_text (payload IN VARCHAR2)</dt>
<dd>
<p>Sets the payload, a <code dir="ltr">VARCHAR2</code> value, to an internal representation.</p>
</dd>
<dt>set_text (payload IN CLOB)</dt>
<dd>
<p>Sets the payload, a <code dir="ltr">CLOB</code> value, to an internal representation.</p>
</dd>
<dt>get_text (payload OUT VARCHAR2)</dt>
<dd>
<p>Puts the internal representation of the payload into a <code dir="ltr">VARCHAR2</code> variable payload.</p>
</dd>
<dt>get_text (payload OUT CLOB)</dt>
<dd>
<p>Puts the internal representation of the payload into a <code dir="ltr">CLOB</code> variable payload.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS71818" class="refsect2"><a id="i1244160"></a>
<h3 class="refsect2">SYS.AQ$_JMS_BYTES_MESSAGE Type</h3>
<p>This type is the ADT used to store a <code dir="ltr">BytesMessage</code> in an Oracle Database Advanced Queuing queue.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1252440">CONSTRUCT Function</a></p>
</li>
<li>
<p><a href="#i1252447">JMS Header Methods</a></p>
</li>
<li>
<p><a href="#i1252464">System Properties Methods</a></p>
</li>
<li>
<p><a href="#i1252473">User Properties Methods</a></p>
</li>
<li>
<p><a href="#i1252480">Payload Methods</a></p>
</li>
</ul>
<p class="subhead1"><a id="ARPLS71819"></a>Syntax</p>
<pre dir="ltr">TYPE AQ$_JMS_BYTES_MESSAGE AS OBJECT(
 header     aq$_jms_header,
 bytes_len  INT,
 bytes_raw  raw(2000),
 bytes_lob  blob,
 STATIC FUNCTION construct RETURN aq$_jms_bytes_message,
 MEMBER PROCEDURE set_replyto  (replyto IN sys.aq$_agent),
 MEMBER PROCEDURE set_type     (type    IN VARCHAR),
 MEMBER FUNCTION get_replyto RETURN sys.aq$_agent,
 MEMBER FUNCTION get_type    RETURN VARCHAR,
 MEMBER PROCEDURE set_userid   (userid   IN VARCHAR),
 MEMBER PROCEDURE set_appid    (appid    IN VARCHAR),
 MEMBER PROCEDURE set_groupid  (groupid  IN VARCHAR),
 MEMBER PROCEDURE set_groupseq (groupseq IN INT),
 MEMBER FUNCTION get_userid   RETURN VARCHAR,
 MEMBER FUNCTION get_appid    RETURN VARCHAR,
 MEMBER FUNCTION get_groupid  RETURN VARCHAR,
 MEMBER FUNCTION get_groupseq RETURN INT,
 MEMBER PROCEDURE clear_properties,
 MEMBER PROCEDURE set_boolean_property(property_name IN VARCHAR,
   property_value IN BOOLEAN),
 MEMBER PROCEDURE set_byte_property   (property_name IN VARCHAR,
   property_value IN INT),
 MEMBER PROCEDURE set_double_property (property_name IN VARCHAR,
   property_value IN DOUBLE PRECISION),
 MEMBER PROCEDURE set_float_property  (property_name IN VARCHAR,
   property_value IN FLOAT),
 MEMBER PROCEDURE set_int_property    (property_name IN VARCHAR,
   property_value IN INT),
 MEMBER PROCEDURE set_long_property   (property_name IN VARCHAR,
   property_value IN NUMBER),
 MEMBER PROCEDURE set_short_property  (property_name IN VARCHAR,
   property_valuE IN INT),
 MEMBER PROCEDURE set_string_property (property_name IN VARCHAR,
   property_value IN VARCHAR),
 MEMBER FUNCTION get_boolean_property (property_name IN VARCHAR) RETURN BOOLEAN,
 MEMBER FUNCTION get_byte_property    (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_double_property  (property_name IN VARCHAR) 
   RETURN DOUBLE PRECISION,
 MEMBER FUNCTION get_float_property   (property_name IN VARCHAR) RETURN FLOAT,
 MEMBER FUNCTION get_int_property     (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_long_property    (property_name IN VARCHAR) RETURN NUMBER,
 MEMBER FUNCTION get_short_property   (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_string_property  (property_name IN VARCHAR) RETURN VARCHAR,
 MEMBER PROCEDURE set_bytes           (payload  IN RAW),
 MEMBER PROCEDURE set_bytes           (payload  IN BLOB),
 MEMBER PROCEDURE get_bytes           (payload  OUT RAW),
 MEMBER PROCEDURE get_bytes           (payload  OUT BLOB),
 MEMBER FUNCTION  prepare             (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER PROCEDURE reset               (id IN PLS_INTEGER),
 MEMBER PROCEDURE flush               (id IN PLS_INTEGER),
 MEMBER PROCEDURE clear_body          (id IN PLS_INTEGER),
 MEMBER PROCEDURE clean               (id IN PLS_INTEGER),
 STATIC PROCEDURE clean_all,
 MEMBER FUNCTION get_mode           (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION read_boolean       (id IN PLS_INTEGER) RETURN BOOLEAN,
 MEMBER FUNCTION read_byte          (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION read_bytes         (id IN PLS_INTEGER, 
   value OUT NOCOPY BLOB, length IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION read_char          (id IN PLS_INTEGER) RETURN CHAR,
 MEMBER FUNCTION read_double        (id IN PLS_INTEGER) RETURN DOUBLE PRECISION,
 MEMBER FUNCTION read_float         (id IN PLS_INTEGER) RETURN FLOAT,
 MEMBER FUNCTION read_int           (id IN PLS_INTEGER) RETURN INT,
 MEMBER FUNCTION read_long          (id IN PLS_INTEGER) RETURN NUMBER,
 MEMBER FUNCTION read_short         (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION read_unsigned_byte  (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION read_unsigned_short (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER PROCEDURE read_utf          (id IN PLS_INTEGER, value OUT NOCOPY CLOB),
 MEMBER PROCEDURE write_boolean     (id IN PLS_INTEGER, value IN BOOLEAN),
 MEMBER PROCEDURE write_byte        (id IN PLS_INTEGER, value IN PLS_INTEGER),
 MEMBER PROCEDURE write_bytes       (id IN PLS_INTEGER, value IN RAW),
 MEMBER PROCEDURE write_bytes       (id IN PLS_INTEGER, value IN BLOB),
 MEMBER PROCEDURE write_bytes       (id IN PLS_INTEGER, value IN RAW,
   offset IN PLS_INTEGER, length IN PLS_INTEGER),
 MEMBER PROCEDURE write_bytes       (id IN PLS_INTEGER, value IN BLOB,
   offset IN INT, length IN INT), 
 MEMBER PROCEDURE write_char        (id IN PLS_INTEGER, value IN CHAR),
 MEMBER PROCEDURE write_double      (id IN PLS_INTEGER, 
   value IN DOUBLE PRECISION),
 MEMBER PROCEDURE write_float       (id IN PLS_INTEGER, value IN FLOAT),
 MEMBER PROCEDURE write_int         (id IN PLS_INTEGER, value IN PLS_INTEGER),
 MEMBER PROCEDURE write_long        (id IN PLS_INTEGER, value IN NUMBER),
 MEMBER PROCEDURE write_short       (id IN PLS_INTEGER, value IN PLS_INTEGER),
 MEMBER PROCEDURE write_utf         (id IN PLS_INTEGER, value IN VARCHAR2),
 MEMBER PROCEDURE write_utf         (id IN PLS_INTEGER, value IN CLOB));
</pre>
<div id="ARPLS71820" class="refsect3"><a id="i1252440"></a>
<h4 class="refsect3">CONSTRUCT Function</h4>
<dl>
<dt>STATIC FUNCTION construct RETURN aq$_jms_bytes_message</dt>
<dd>
<p>Creates an empty <code dir="ltr">aq$_jms_bytes_message</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71821" class="refsect3"><a id="i1252447"></a>
<h4 class="refsect3">JMS Header Methods</h4>
<dl>
<dt>set_replyto (replyto IN sys.aq$_agent)</dt>
<dd>
<p>Sets the <code dir="ltr">replyto</code> parameter, which corresponds to <code dir="ltr">JMSReplyTo</code> in JMS.</p>
</dd>
<dt>set_type (type IN VARCHAR)</dt>
<dd>
<p>Sets the JMS type, which can be any text, and which corresponds to <code dir="ltr">JMSType</code> in JMS.</p>
</dd>
<dt>get_replyto RETURN sys.aq$_agent</dt>
<dd>
<p>Returns <code dir="ltr">replyto</code>, which corresponds to <code dir="ltr">JMSReplyTo</code>.</p>
</dd>
<dt>get_type RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">type</code>, which corresponds to <code dir="ltr">JMSType</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71822" class="refsect3"><a id="i1252464"></a>
<h4 class="refsect3">System Properties Methods</h4>
<dl>
<dt>set_userid (userid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code> in JMS.</p>
</dd>
<dt>set_appid (appid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code> in JMS.</p>
</dd>
<dt>set_groupid (groupid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code> in JMS.</p>
</dd>
<dt>set_groupseq (groupseq IN INT)</dt>
<dd>
<p>Sets <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code> in JMS.</p>
</dd>
<dt>get_userid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code>.</p>
</dd>
<dt>get_appid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code>.</p>
</dd>
<dt>get_groupid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code>.</p>
</dd>
<dt>get_groupseq RETURN NUMBER</dt>
<dd>
<p>Returns <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71823" class="refsect3"><a id="i1252473"></a>
<h4 class="refsect3">User Properties Methods</h4>
<dl>
<dt>clear_properties</dt>
<dd>
<p>Clears all user properties. This procedure does not affect system properties.</p>
</dd>
<dt>set_boolean_property (property_name IN VARCHAR, property_value IN BOOLEAN)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code> in an internal representation. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_byte_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -128 to 127 (8-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">BYTE</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_double_property (property_name IN VARCHAR, property_value IN DOUBLE PRECISION)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_float_property (property_name IN VARCHAR, property_value IN FLOAT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_int_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -2147483648 to 2147483647 (32-bits). This check is necessary because in PL/SQL and Oracle Database, the <code dir="ltr">INT</code> datatype is 38 bits. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_long_property (property_name IN VARCHAR, property_value IN NUMBER)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. In PL/SQL and Oracle Database, the <code dir="ltr">NUMBER</code> datatype is 38 bits. In Java, the <code dir="ltr">long</code> datatype is 64 bits. Therefore, no range check is needed.Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_short_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -32768 to 32767 (16-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">short</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_string_property (property_name IN VARCHAR, property_value IN VARCHAR)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>get_boolean_property (property_name IN VARCHAR) RETURN BOOLEAN</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BOOLEAN</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_byte_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BYTE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_double_property (property_name IN VARCHAR) RETURN DOUBLE PRECISION</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">DOUBLE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_float_property (property_name IN VARCHAR) RETURN FLOAT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">FLOAT</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_int_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">Integer</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_long_property (property_name IN VARCHAR) RETURN NUMBER</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">long</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_short_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">short</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_string_property (property_name IN VARCHAR) RETURN VARCHAR</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">STRING</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71824" class="refsect3"><a id="i1252480"></a>
<h4 class="refsect3">Payload Methods</h4>
<dl>
<dt>set_bytes (payload in RAW)</dt>
<dd>
<p>Sets the payload, a <code dir="ltr">RAW</code> value, to an internal representation.</p>
</dd>
<dt>set_bytes (payload in BLOB)</dt>
<dd>
<p>Sets the payload, a <code dir="ltr">BLOB</code> value, to an internal representation.</p>
</dd>
<dt>get_bytes (payload out RAW)</dt>
<dd>
<p>Puts the internal representation of the payload into a <code dir="ltr">RAW</code> variable payload. Raises exception ORA-24190 if the length of the internal payload is more than 32767 (the maximum length of <code dir="ltr">RAW</code> in PL/SQL).</p>
</dd>
<dt>get_bytes (payload out BLOB)</dt>
<dd>
<p>Puts the internal representation of the payload into a <code dir="ltr">BLOB</code> variable payload.</p>
</dd>
<dt>prepare (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Takes the byte array stored in aq$_jms_bytes_message and decodes it as a Java object in the Java stored procedure. The result of the decoding is stored as a static variable in Jserv session memory. Parameter <code dir="ltr">id</code> is used to identify the slot where the Java object is stored in the Oracle Database JVM session memory. If <code dir="ltr">id</code> is null, then a new slot is created for this PL/SQL object. Subsequent JMS operations on the payload need to provide this operation ID.</p>
<p>This function also sets the message access mode to <code dir="ltr">MESSAGE_ACCESS_READONLY</code>. Subsequent calls of <code dir="ltr">write_XXX</code> procedure raise an ORA-24196 error. Users can call the <code dir="ltr">clear_body</code> procedure to set the message access mode to <code dir="ltr">MESSAGE_ACCESS_READONLY</code>.</p>
<p>This function raises ORA-24197 if the Java stored procedure throws an exception during execution, ORA-24198 if the operation ID is invalid, or ORA-24199 if the Java stored procedure message store overflows.</p>
</dd>
<dt>reset (id IN PLS_INTEGER)</dt>
<dd>
<p>Resets the starting position of the stream to the beginning and puts the bytes message in read-only mode. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>flush (id IN PLS_INTEGER)</dt>
<dd>
<p>Takes the static variable in Jserv and synchronizes the content back to the <code dir="ltr">aq$_jms_bytes_message</code>. This procedure will not affect the underlying access mode. This procedure raises ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>clear_body (id IN PLS_INTEGER)</dt>
<dd>
<p>Sets the Java stored procedure static variable to empty payload. Parameter <code dir="ltr">id</code> is used to identify the slot where the Java object is stored in the Oracle Database JVM session memory. If <code dir="ltr">id</code> is null, a new slot is created for this PL/SQL object. Subsequent JMS operations on the payload need to provide this operation ID.</p>
<p>It also sets the message access mode to <code dir="ltr">MESSAGE_ACCESS_WRITEONLY</code>. Later calls of <code dir="ltr">read_XXX</code> procedure raise ORA-24196 error. Users can call the <code dir="ltr">reset</code> or <code dir="ltr">prepare</code> procedures to set the message access mode to <code dir="ltr">MESSAGE_ACCESS_READONLY</code>. Write-only and read-only modes affect only the payload functions of <code dir="ltr">AQ$_JMS_BYTES_MESSAGE</code>. They do not affect the header functions.</p>
<p>This function raises ORA-24197 if the Java stored procedure throws an exception during execution, ORA-24198 if the operation ID is invalid, or ORA-24199 if the Java stored procedure message store overflows.</p>
</dd>
<dt>clean (id IN PLS_INTEGER)</dt>
<dd>
<p>Closes and cleans up the <code dir="ltr">DataInputStream</code> or <code dir="ltr">DataOutputStream</code> at the Java stored procedure side corresponding to the operation ID. It is very important to call this procedure to avoid memory leaks. This procedure raises ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>clean_all</dt>
<dd>
<p>Closes and cleans up all the messages in the corresponding type of message store at the Java stored procedure side. This procedure raises ORA-24197 if the Java stored procedure throws an exception during execution.</p>
</dd>
<dt>get_mode (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Returns the current mode of this message. The return value is either <code dir="ltr">SYS.dbms_jms.plsql.MESSAGE_ACCESS_READONLY</code> or <code dir="ltr">SYS.dbms_jms.plsql.MESSAGE_ACCESS_WRITEONLY</code>. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_boolean (id IN PLS_INTEGER) RETURN BOOLEAN</dt>
<dd>
<p>Reads a Boolean value from the bytes message and returns the Boolean value read. Null is returned if the end of the message stream has been reached. Parameter <code dir="ltr">id</code> is the operation ID. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_byte (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Reads a <code dir="ltr">BYTE</code> value from the bytes message and returns the <code dir="ltr">BYTE</code> value read. Null is returned if the end of the stream has been reached. Because there is no <code dir="ltr">BYTE</code> type in PL/SQL, Oracle Database uses <code dir="ltr">PLS_INTEGER</code> to represent a <code dir="ltr">BYTE</code>. Although PL/SQL users get a <code dir="ltr">PLS_INTEGER</code>, they are guaranteed that the value is in the Java <code dir="ltr">BYTE</code> value range. If this value is issued with a <code dir="ltr">write_byte</code> function, then there will not be an out of range error. Parameter <code dir="ltr">id</code> is the operation ID. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_bytes (id IN PLS_INTEGER, value OUT NO COPY BLOB, length IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Reads length of the bytes from bytes message stream into value and returns the total number of bytes read. If there is no more data (because the end of the stream has been reached), then it returns -1. Raises exceptions ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_char (id IN PLS_INTEGER) RETURN CHAR</dt>
<dd>
<p>Reads a character value from the bytes message and returns the character value read. Null is returned if the end of the stream has been reached. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_double (id IN PLS_INTEGER) RETURN DOUBLE PRECISION</dt>
<dd>
<p>Reads a double from the bytes message and returns the character value read. Null is returned if the end of the stream has been reached. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_float (id IN PLS_INTEGER) RETURN FLOAT</dt>
<dd>
<p>Reads a float from the bytes message and returns the float read. Null is returned if the end of the stream has been reached. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_int (id IN PLS_INTEGER) RETURN INT</dt>
<dd>
<p>Reads an <code dir="ltr">INT</code> from the bytes message and returns the <code dir="ltr">INT</code> read. Null is returned if the end of the stream has been reached. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_long (id IN PLS_INTEGER) RETURN NUMBER</dt>
<dd>
<p>Reads a long from the bytes message and returns the long read. Null is returned if the end of the stream has been reached. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_short (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Reads a short value from the bytes message and returns the short value read. Null is returned if the end of the stream has been reached. Because there is no short type in PL/SQL, <code dir="ltr">PLS_INTEGER</code> is used to represent a <code dir="ltr">SHORT</code>. Although PL/SQL users get an <code dir="ltr">PLS_INTEGER</code>, they are guaranteed that the value is in the Java short value range. If this value is issued with a <code dir="ltr">write_short</code> function, then there will not be an out of range error. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_unsigned_byte (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Reads an unsigned 8-bit number from the bytes message stream and returns the next byte from the bytes message stream, interpreted as an unsigned 8-bit number. Null is returned if the end of the stream has been reached. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_unsigned_short (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Reads an unsigned 16-bit number from the bytes message stream and returns the next two bytes from the bytes message stream, interpreted as an unsigned 16-bit integer. Null is returned if the end of the stream has been reached. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_utf (id IN PLS_INTEGER, value OUT NOCOPY CLOB)</dt>
<dd>
<p>Reads a string that has been encoded using a UTF-8 format from the bytes message. Null is returned if the end of the stream has been reached. Raises exception ORA-24196 if the bytes message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_boolean (id IN PLS_INTEGER, value IN BOOLEAN)</dt>
<dd>
<p>Writes a Boolean to the bytes message stream as a 1-byte value. The value <code dir="ltr">true</code> is written as the value (byte)1. The value <code dir="ltr">false</code> is written as the value (byte)0. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_byte (id IN PLS_INTEGER, value IN PLS_INTEGER)</dt>
<dd>
<p>Writes a byte to the bytes message. Because there is no <code dir="ltr">BYTE</code> type in PL/SQL, <code dir="ltr">PLS_INTEGER</code> is used to represent a <code dir="ltr">BYTE</code>. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_bytes (id IN PLS_INTEGER, value IN RAW)</dt>
<dd>
<p>Writes an array of bytes to the bytes message. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_bytes (id IN PLS_INTEGER, value IN BLOB)</dt>
<dd>
<p>Writes an array of bytes to the bytes message. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_bytes (id IN PLS_INTEGER, value IN RAW, offset IN PLS_INTEGER, length IN PLS_INTEGER)</dt>
<dd>
<p>Writes a portion of a byte array to the bytes message stream. Parameter <code dir="ltr">offset</code> is the initial offset within the byte array. If the range [offset, offset+length] exceeds the boundary of the byte array value, then a Java IndexOutOfBounds exception is thrown in the Java stored procedure and this procedure raises error ORA-24197. The index starts from 0. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_bytes (id IN PLS_INTEGER, value IN BLOB, offset IN INT, length IN INT)</dt>
<dd>
<p>Writes a portion of a byte array to the bytes message stream. Parameter <code dir="ltr">offset</code> is the initial offset within the byte array. If the range [offset, offset+length] exceeds the boundary of the byte array value, then a Java IndexOutOfBounds exception is thrown in the Java stored procedure and this procedure raises error ORA-24197. The index starts from 0. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_char (id IN PLS_INTEGER, value IN CHAR)</dt>
<dd>
<p>Writes a character value to the bytes message. If this value has multiple characters, it is the first character that is written. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_double (id IN PLS_INTEGER, value IN DOUBLE PRECISION)</dt>
<dd>
<p>Writes a double to the bytes message. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_float (id IN PLS_INTEGER, value IN FLOAT)</dt>
<dd>
<p>Writes a float to the bytes message. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_int (id IN PLS_INTEGER, value IN PLS_INTEGER)</dt>
<dd>
<p>Writes an <code dir="ltr">INT</code> to the bytes message. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_long (id IN PLS_INTEGER, value IN NUMBER)</dt>
<dd>
<p>Writes a long to the bytes message. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_short (id IN PLS_INTEGER, value IN PLS_INTEGER)</dt>
<dd>
<p>Writes a short to the bytes message as two bytes, high byte first. Because there is no short type in PL/SQL, <code dir="ltr">INT</code> is used to represent a short. Raises exception ORA-24193 if the parameter value exceeds the valid range, ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_utf (id IN PLS_INTEGER, value IN VARCHAR2)</dt>
<dd>
<p>Writes a string to the bytes message stream using UTF-8 encoding in a machine-independent manner. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_utf (id IN PLS_INTEGER, value IN CLOB)</dt>
<dd>
<p>Writes a string to the bytes message stream using UTF-8 encoding in a machine-independent manner. Raises exception ORA-24196 if the bytes message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS71825" class="refsect2"><a id="i1022148"></a>
<h3 class="refsect2">SYS.AQ$_JMS_MAP_MESSAGE Type</h3>
<p>This type is the ADT used to store a <code dir="ltr">MapMessage</code> in an Oracle Database Advanced Queuing queue.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1252513">CONSTRUCT Function</a></p>
</li>
<li>
<p><a href="#i1252520">JMS Header Methods</a></p>
</li>
<li>
<p><a href="#i1252527">System Properties Methods</a></p>
</li>
<li>
<p><a href="#i1252534">User Properties Methods</a></p>
</li>
<li>
<p><a href="#i1252541">Payload Methods</a></p>
</li>
</ul>
<p class="subhead1"><a id="ARPLS71826"></a>Syntax</p>
<pre dir="ltr">TYPE aq$_jms_map_message AS object(
 header     aq$_jms_header,
 bytes_len  int,
 bytes_raw  raw(2000),
 bytes_lob  blob,
 STATIC FUNCTION  construct   RETURN aq$_jms_map_message,
 MEMBER PROCEDURE set_replyto  (replyto IN sys.aq$_agent),
 MEMBER PROCEDURE set_type     (type    IN VARCHAR),
 MEMBER FUNCTION get_replyto  RETURN sys.aq$_agent,
 MEMBER FUNCTION get_type     RETURN VARCHAR,
 MEMBER PROCEDURE set_userid   (userid   IN VARCHAR),
 MEMBER PROCEDURE set_appid    (appid    IN VARCHAR),
 MEMBER PROCEDURE set_groupid  (groupid  IN VARCHAR),
 MEMBER PROCEDURE set_groupseq (groupseq IN INT),
 MEMBER FUNCTION get_userid   RETURN VARCHAR,
 MEMBER FUNCTION get_appid    RETURN VARCHAR,
 MEMBER FUNCTION get_groupid  RETURN VARCHAR,
 MEMBER FUNCTION get_groupseq RETURN INT,
 MEMBER PROCEDURE clear_properties,
 MEMBER PROCEDURE set_boolean_property(property_name IN VARCHAR,
   property_value IN BOOLEAN),
 MEMBER PROCEDURE set_byte_property   (property_name IN VARCHAR,
   property_value IN INT),
 MEMBER PROCEDURE set_double_property (property_name IN VARCHAR,
   property_value IN DOUBLE PRECISION),
 MEMBER PROCEDURE set_float_property  (property_name IN VARCHAR,
   property_value IN FLOAT),
 MEMBER PROCEDURE set_int_property    (property_name IN VARCHAR,
   property_value IN INT),
 MEMBER PROCEDURE set_long_property   (property_name IN VARCHAR,
   property_value IN NUMBER),
 MEMBER PROCEDURE set_short_property  (property_name IN VARCHAR,
   property_valuE IN INT),
 MEMBER PROCEDURE set_string_property (property_name IN VARCHAR,
   property_value IN VARCHAR),
 MEMBER FUNCTION get_boolean_property (property_name IN VARCHAR) RETURN BOOLEAN,
 MEMBER FUNCTION get_byte_property    (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_double_property  (property_name IN VARCHAR) 
   RETURN DOUBLE PRECISION,
 MEMBER FUNCTION get_float_property   (property_name IN VARCHAR) RETURN FLOAT,
 MEMBER FUNCTION get_int_property     (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_long_property    (property_name IN VARCHAR) RETURN NUMBER,
 MEMBER FUNCTION get_short_property   (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_string_property  (property_name IN VARCHAR) RETURN VARCHAR,
 MEMBER PROCEDURE set_bytes   (payload IN RAW),
 MEMBER PROCEDURE set_bytes   (payload IN BLOB),
 MEMBER PROCEDURE get_bytes   (payload OUT RAW),
 MEMBER PROCEDURE get_bytes   (payload OUT BLOB),
 MEMBER FUNCTION  prepare     (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER PROCEDURE flush       (id  IN  PLS_INTEGER),
 MEMBER PROCEDURE clear_body  (id IN PLS_INTEGER),
 MEMBER PROCEDURE clean       (id  IN  PLS_INTEGER),
 STATIC PROCEDURE clean_all,
 MEMBER PROCEDURE set_boolean (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN BOOLEAN),
 MEMBER PROCEDURE set_byte    (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN  PLS_INTEGER),
 MEMBER PROCEDURE set_bytes   (id IN PLS_INTEGER, name IN VARCHAR2, 
   value IN  RAW),
 MEMBER PROCEDURE set_bytes   (id IN PLS_INTEGER, name IN VARCHAR2, 
   value IN RAW, offset IN INT, length IN INT),
 MEMBER PROCEDURE set_bytes   (id IN PLS_INTEGER, name IN VARCHAR2, 
   value IN BLOB), 
 MEMBER PROCEDURE set_bytes   (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN BLOB, offset IN INT, length IN INT),
 MEMBER PROCEDURE set_char    (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN  CHAR),
 MEMBER PROCEDURE set_double  (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN  DOUBLE PRECISION), 
 MEMBER PROCEDURE set_float   (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN  FLOAT),
 MEMBER PROCEDURE set_int     (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN  PLS_INTEGER), 
 MEMBER PROCEDURE set_long    (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN  NUMBER),
 MEMBER PROCEDURE set_short   (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN  PLS_INTEGER),
 MEMBER PROCEDURE set_string  (id IN PLS_INTEGER, name IN VARCHAR2,
   value IN  VARCHAR2),
 MEMBER PROCEDURE set_string  (id IN  PLS_INTEGER, name IN VARCHAR2,
   value IN  CLOB),
 MEMBER FUNCTION get_boolean  (id IN PLS_INTEGER, name IN VARCHAR2)
   RETURN BOOLEAN,
 MEMBER FUNCTION  get_byte    (id IN PLS_INTEGER, name IN VARCHAR2) 
   RETURN PLS_INTEGER,
 MEMBER PROCEDURE get_bytes   (id IN PLS_INTEGER, name IN VARCHAR2,
   value OUT NOCOPY BLOB),
 MEMBER FUNCTION get_char     (id IN PLS_INTEGER, name IN VARCHAR2) RETURN CHAR,
 MEMBER FUNCTION get_double   (id IN PLS_INTEGER, name IN VARCHAR2)
   RETURN DOUBLE PRECISION,
 MEMBER FUNCTION get_float   (id IN PLS_INTEGER, name IN VARCHAR2) RETURN FLOAT,
 MEMBER FUNCTION get_int     (id IN PLS_INTEGER, name IN VARCHAR2)
   RETURN PLS_INTEGER,
 MEMBER FUNCTION get_long    (id IN PLS_INTEGER, name IN VARCHAR2) 
   RETURN NUMBER,
 MEMBER FUNCTION get_short   (id IN PLS_INTEGER, name IN VARCHAR2) 
   RETURN PLS_INTEGER,
 MEMBER PROCEDURE get_string (id IN PLS_INTEGER, name IN VARCHAR2,
   value OUT NOCOPY CLOB),
 MEMBER FUNCTION get_names   (id IN PLS_INTEGER) RETURN aq$_jms_namearray,
 MEMBER FUNCTION get_names   (id IN PLS_INTEGER, names OUT aq$_jms_namearray,
   offset IN  PLS_INTEGER, length IN  PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER PROCEDURE get_object (id IN PLS_INTEGER, name IN  VARCHAR2,
   value  OUT NOCOPY AQ$_JMS_VALUE), 
 MEMBER FUNCTION get_size    (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION item_exists (id IN PLS_INTEGER, name IN VARCHAR2)
   RETURN BOOLEAN);
</pre>
<div id="ARPLS71827" class="refsect3"><a id="i1252513"></a>
<h4 class="refsect3">CONSTRUCT Function</h4>
<dl>
<dt>STATIC FUNCTION construct RETURN aq$_jms_map_message</dt>
<dd>
<p>Creates an empty <code dir="ltr">aq$_jms_map_message</code> object.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71828" class="refsect3"><a id="i1252520"></a>
<h4 class="refsect3">JMS Header Methods</h4>
<dl>
<dt>set_replyto (replyto IN sys.aq$_agent)</dt>
<dd>
<p>Sets the <code dir="ltr">replyto</code> parameter, which corresponds to <code dir="ltr">JMSReplyTo</code> in JMS.</p>
</dd>
<dt>set_type (type IN VARCHAR)</dt>
<dd>
<p>Sets the JMS type, which can be any text, and which corresponds to <code dir="ltr">JMSType</code> in JMS.</p>
</dd>
<dt>get_replyto RETURN sys.aq$_agent</dt>
<dd>
<p>Returns <code dir="ltr">replyto</code>, which corresponds to <code dir="ltr">JMSReplyTo</code>.</p>
</dd>
<dt>get_type RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">type</code>, which corresponds to <code dir="ltr">JMSType</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71829" class="refsect3"><a id="i1252527"></a>
<h4 class="refsect3">System Properties Methods</h4>
<dl>
<dt>set_userid (userid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code> in JMS.</p>
</dd>
<dt>set_appid (appid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code> in JMS.</p>
</dd>
<dt>set_groupid (groupid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code> in JMS.</p>
</dd>
<dt>set_groupseq (groupseq IN INT)</dt>
<dd>
<p>Sets <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code> in JMS.</p>
</dd>
<dt>get_userid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code>.</p>
</dd>
<dt>get_appid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code>.</p>
</dd>
<dt>get_groupid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code>.</p>
</dd>
<dt>get_groupseq RETURN NUMBER</dt>
<dd>
<p>Returns <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71830" class="refsect3"><a id="i1252534"></a>
<h4 class="refsect3">User Properties Methods</h4>
<dl>
<dt>clear_properties</dt>
<dd>
<p>Clears all user properties. This procedure does not affect system properties.</p>
</dd>
<dt>set_boolean_property (property_name IN VARCHAR, property_value IN BOOLEAN)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code> in an internal representation. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_byte_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -128 to 127 (8-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">BYTE</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_double_property (property_name IN VARCHAR, property_value IN DOUBLE PRECISION)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_float_property (property_name IN VARCHAR, property_value IN FLOAT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_int_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -2147483648 to 2147483647 (32-bits). This check is necessary because in PL/SQL and Oracle Database, the <code dir="ltr">INT</code> datatype is 38 bits. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_long_property (property_name IN VARCHAR, property_value IN NUMBER)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. In PL/SQL and Oracle Database, the <code dir="ltr">NUMBER</code> datatype is 38 bits. In Java, the <code dir="ltr">long</code> datatype is 64 bits. Therefore, no range check is needed.Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_short_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -32768 to 32767 (16-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">short</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_string_property (property_name IN VARCHAR, property_value IN VARCHAR)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>get_boolean_property (property_name IN VARCHAR) RETURN BOOLEAN</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BOOLEAN</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_byte_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BYTE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_double_property (property_name IN VARCHAR) RETURN DOUBLE PRECISION</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">DOUBLE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_float_property (property_name IN VARCHAR) RETURN FLOAT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">FLOAT</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_int_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">Integer</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_long_property (property_name IN VARCHAR) RETURN NUMBER</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">long</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_short_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">short</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_string_property (property_name IN VARCHAR) RETURN VARCHAR</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">STRING</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71831" class="refsect3"><a id="i1252541"></a>
<h4 class="refsect3">Payload Methods</h4>
<dl>
<dt>set_bytes (payload IN RAW)</dt>
<dd>
<p>Sets the internal payload as a RAW variable without any interpretation. The payload of <code dir="ltr">aq$_jms_map_message</code> is stored as either <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code> in the database. This member function sets a payload as a RAW variable without interpreting it.</p>
</dd>
<dt>set_bytes (payload IN BLOB)</dt>
<dd>
<p>Sets the internal payload as a BLOB variable without any interpretation. The payload of <code dir="ltr">aq$_jms_map_message</code> is stored as either <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code> in the database. This member function sets a payload as a BLOB variable without interpreting it.</p>
</dd>
<dt>get_bytes (payload OUT RAW)</dt>
<dd>
<p>Puts the internal payload into a <code dir="ltr">RAW</code> variable without any interpretation. The payload of <code dir="ltr">aq$_jms_map_message</code> is stored as either <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code> in the database. This member function gets a payload as raw bytes without interpreting it. Raises exceptions ORA-24190 if the length of internal payload is more than 32767.</p>
</dd>
<dt>get_bytes (payload OUT BLOB)</dt>
<dd>
<p>Puts the internal payload into a <code dir="ltr">BLOB</code> variable without any interpretation. The payload of <code dir="ltr">aq$_jms_map_message</code> is stored as either <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code> in the database. This member function gets a payload as a <code dir="ltr">BLOB</code> without interpreting it.</p>
</dd>
<dt>prepare (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Takes the byte array stored in <code dir="ltr">aq$_jms_map_message</code> and decodes it as a Java object in the Java stored procedure. The result of the decoding is stored as a static variable in Jserv session memory. Parameter <code dir="ltr">id</code> is used to identify the slot where the Java object is stored in the Oracle Database JVM session memory. If <code dir="ltr">id</code> is null, then a new slot is created for this PL/SQL object. Subsequent JMS operations on the payload need to provide this operation ID.</p>
<p>This function raises ORA-24197 if the Java stored procedure throws an exception during execution, ORA-24198 if the operation ID is invalid, or ORA-24199 if the Java stored procedure message store overflows.</p>
</dd>
<dt>flush (id IN PLS_INTEGER)</dt>
<dd>
<p>Takes the static variable in Jserv and synchronizes the content back to <code dir="ltr">aq$_jms_map_message</code>. This procedure raises ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>clear_body (id IN PLS_INTEGER)</dt>
<dd>
<p>Sets the Java stored procedure static variable to empty payload. Parameter <code dir="ltr">id</code> is used to identify the slot where the Java object is stored in the Oracle Database JVM session memory. If <code dir="ltr">id</code> is null, a new slot is created for this PL/SQL object. Subsequent JMS operations on the payload need to provide this operation ID.</p>
<p>This function raises ORA-24197 if the Java stored procedure throws an exception during execution, ORA-24198 if the operation ID is invalid, or ORA-24199 if the Java stored procedure message store overflows.</p>
</dd>
<dt>clean (id IN PLS_INTEGER)</dt>
<dd>
<p>Closes and cleans up the <code dir="ltr">DataInputStream</code> or <code dir="ltr">DataOutputStream</code> at the Java stored procedure side corresponding to the operation ID. It is very important to call this procedure to avoid memory leaks. This procedure raises ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>clean_all</dt>
<dd>
<p>Closes and cleans up all the messages in the corresponding type of message store at the Java stored procedure side. This procedure raises ORA-24197 if the Java stored procedure throws an exception during execution.</p>
</dd>
<dt>set_boolean (id IN PLS_INTEGER, name IN VARCHAR2, value IN BOOLEAN)</dt>
<dd>
<p>Sets the Boolean value with the specified name in the map. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_byte (id IN PLS_INTEGER, name IN VARCHAR2, value IN PLS_INTEGER)</dt>
<dd>
<p>Sets the <code dir="ltr">BYTE</code> value with the specified name in the map. Because there is no <code dir="ltr">BYTE</code> type in PL/SQL, <code dir="ltr">PLS_INTEGER</code> is used to represent a byte. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_bytes (id IN PLS_INTEGER, name IN VARCHAR2, value IN RAW))</dt>
<dd>
<p>Sets the byte array value with the specified name in the map. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_bytes (id IN PLS_INTEGER, name IN VARCHAR2, value IN RAW, offset IN INT, length IN INT)</dt>
<dd>
<p>Sets a portion of the byte array value with the specified name in the map. Parameter <code dir="ltr">offset</code> is the initial offset within the byte array, and parameter <code dir="ltr">length</code> is the number of bytes to use. If the range [offset &hellip; offset+length] exceeds the boundary of the byte array value, then a Java <code dir="ltr">IndexOutOfBounds</code> exception is thrown in the Java stored procedure and this procedure raises an ORA-24197 error. The index starts from 0. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_bytes (id IN PLS_INTEGER, name IN VARCHAR2, value IN BLOB)</dt>
<dd>
<p>Sets the byte array value with the specified name in the map. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_bytes (id IN PLS_INTEGER, name IN VARCHAR2, value IN BLOB, offset IN INT, length IN INT)</dt>
<dd>
<p>Sets a portion of the byte array value with the specified name in the map. Parameter <code dir="ltr">offset</code> is the initial offset within the byte array, and parameter <code dir="ltr">length</code> is the number of bytes to use. If the range [offset &hellip; offset+length] exceeds the boundary of the byte array value, then a Java <code dir="ltr">IndexOutOfBounds</code> exception is thrown in the Java stored procedure, and this procedure raises an ORA-24197 error. The index starts from 0. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_char (id IN PLS_INTEGER, name IN VARCHAR2, value IN CHAR)</dt>
<dd>
<p>Sets the character value with the specified name in the map. If this value has multiple characters, then it is the first character that is used. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_double (id IN PLS_INTEGER, name IN VARCHAR2, value IN DOUBLE PRECISION)</dt>
<dd>
<p>Sets the double value with the specified name in the map. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_float (id IN PLS_INTEGER, name IN VARCHAR2, value IN FLOAT)</dt>
<dd>
<p>This procedure is to set the float value with the specified name in the map. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_int (id IN PLS_INTEGER, name IN VARCHAR2, value IN PLS_INTEGER)</dt>
<dd>
<p>Sets the int value with the specified name in the map. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_long (id IN PLS_INTEGER, name IN VARCHAR2, value IN NUMBER)</dt>
<dd>
<p>Sets the long value with the specified name in the map. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_short (id IN PLS_INTEGER, name IN VARCHAR2, value IN PLS_INTEGER)</dt>
<dd>
<p>Sets the short value with the specified name in the map. Because there is no short type in PL/SQL, <code dir="ltr">PLS_INTEGER</code> is used to represent a short. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_string (id IN PLS_INTEGER, name IN VARCHAR2, value IN VARCHAR2)</dt>
<dd>
<p>Sets the string value with the specified name in the map. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>set_string (id IN PLS_INTEGER, name IN VARCHAR2, value IN CLOB))</dt>
<dd>
<p>Sets the string value with the specified name in the map. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_boolean (id IN PLS_INTEGER, name IN VARCHAR2) RETURN BOOLEAN</dt>
<dd>
<p>Retrieves the Boolean value with the specified name. If there is no item by this name, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_byte (id IN PLS_INTEGER, name IN VARCHAR2) RETURN PLS_INTEGER</dt>
<dd>
<p>Retrieves the <code dir="ltr">BYTE</code> value with the specified name. If there is no item by this name, then null is returned. Because there is no <code dir="ltr">BYTE</code> type in PL/SQL, <code dir="ltr">PLS_INTEGER</code> is used to represent a byte. Although the PL/SQL users get an <code dir="ltr">PLS_INTEGER</code>, they are guaranteed that the value is in the Java <code dir="ltr">BYTE</code> value range. If this value is issued with a <code dir="ltr">set_byte</code> function, then there will not be an out of range error. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_bytes (id IN PLS_INTEGER, name IN VARCHAR2, value OUT NOCOPY BLOB)</dt>
<dd>
<p>Retrieves the byte array value with the specified name. If there is no item by this name, then null is returned. Because the size of the array might be larger than the limit of PL/SQL <code dir="ltr">RAW</code> type, a <code dir="ltr">BLOB</code> is always returned here. The <code dir="ltr">BLOB</code> returned is a copy, which means it can be modified without affecting the message payload. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_char (id IN PLS_INTEGER, name IN VARCHAR2) RETURN CHAR</dt>
<dd>
<p>Retrieves and returns the character value with the specified name. If there is no item by this name, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid.</p>
</dd>
<dt>get_double (id IN PLS_INTEGER, name IN VARCHAR2) RETURN DOUBLE PRECISION</dt>
<dd>
<p>Retrieves and returns the double value with the specified name. If there is no item by this name, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid.</p>
</dd>
<dt>get_float (id IN PLS_INTEGER, name IN VARCHAR2) RETURN FLOAT</dt>
<dd>
<p>Retrieves the float value with the specified name. If there is no item by this name, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_int (id IN PLS_INTEGER, name IN VARCHAR2) RETURN PLS_INTEGER</dt>
<dd>
<p>Retrieves the <code dir="ltr">INT</code> value with the specified name. If there is no item by this name, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_long (id IN PLS_INTEGER, name IN VARCHAR2) RETURN NUMBER</dt>
<dd>
<p>Retrieves the long value with the specified name. If there is no item by this name, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_short (id IN PLS_INTEGER, name IN VARCHAR2) RETURN PLS_INTEGER</dt>
<dd>
<p>Retrieves the short value with the specified name. If there is no item by this name, then null is returned. Because there is no <code dir="ltr">short</code> type in PL/SQL, <code dir="ltr">INT</code> is used to represent a <code dir="ltr">short</code>. Although the PL/SQL users get an <code dir="ltr">PLS_INTEGER</code>, they are guaranteed that the value is in the Java short value range. If this value is issued with a <code dir="ltr">set_short</code> function, then there will not be an out of range error. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_string (id IN PLS_INTEGER, name IN VARCHAR2, value OUT NOCOPY CLOB)</dt>
<dd>
<p>Retrieves the string value with the specified name. If there is no item by this name, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_names (id IN PLS_INTEGER) RETURN aq$_jms_namearray</dt>
<dd>
<p>Retrieves all the names within the map message and returns them in a varray. Because <code dir="ltr">aq$_jms_namearray</code> has a size as 1024 and each element is a <code dir="ltr">VARCHAR(200)</code>, this function will return an error if the size of the name array of the payload exceeds the limit. Raises exception ORA-24195 if the size of the name array or the size of a name exceeds the limit.</p>
</dd>
<dt>get_names (id IN PLS_INTEGER, names OUT aq$_jms_namearray, offset IN PLS_INTEGER, length IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Retrieves a portion of the names within the map message. Because <code dir="ltr">aq$_jms_namearray</code> has a size as 1024 and each element is a <code dir="ltr">VARCHAR(200)</code>, this function will return an error if either limits are exceeded during the retrieval. (This means there is no sense to put a <code dir="ltr">length</code> parameter greater than 1024.) The index of the names of a map messages begins from 0. Parameter <code dir="ltr">offset</code> is the offset from which to start retrieving.</p>
<p>The function returns the number of names that have been retrieved. The names retrieved is the intersection of the interval [offset, offset+length-1] and interval [0, size-1] where size is the size of this map message. If the intersection is an empty set, then names will be returned as null and the function returns 0 as the number of names retrieved. If users iterate the names by retrieving in small steps, then this can be used to test that there are no more names to read from map message.</p>
<p>Raises exception ORA-24195 if the size of the name array or the size of a name exceed the limit, ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_object (id IN PLS_INTEGER, name IN VARCHAR2, value OUT NOCOPY AQ$_JMS_VALUE)</dt>
<dd>
<p>Returns a general value ADT <code dir="ltr">AQ$_JMS_VALUE</code>. If there is no item by this name, then null is returned.Users can use the <code dir="ltr">type</code> attribute of this ADT to interpret the data. See the map in the <code dir="ltr">AQ$_JMS_VALUE</code> ADT for the correspondence among <code dir="ltr">dbms_jms_plsql</code> package constants, Java datatype and <code dir="ltr">AQ$_JMS_VALUE</code> attribute. Note this member procedure might bring additional overhead compared to other <code dir="ltr">get</code> member procedures or functions. It is used only if the user does not know the datatype of the fields within a message before hand. Otherwise it is a good idea to use a specific <code dir="ltr">get</code> member procedure or function. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>get_size (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Retrieves the size of the map message. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>item_exists (id IN PLS_INTEGER, name IN VARCHAR2) RETURN BOOLEAN</dt>
<dd>
<p>Indicates that an item exists in this map message by returning <code dir="ltr">TRUE</code>. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS71832" class="refsect2"><a id="i1233993"></a>
<h3 class="refsect2">SYS.AQ$_JMS_STREAM_MESSAGE Type</h3>
<p>This type is the ADT used to store a <code dir="ltr">StreamMessage</code> in an Oracle Database Advanced Queuing queue.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1252574">CONSTRUCT Function</a></p>
</li>
<li>
<p><a href="#i1252581">JMS Header Methods</a></p>
</li>
<li>
<p><a href="#i1252588">System Properties Methods</a></p>
</li>
<li>
<p><a href="#i1252595">User Properties Methods</a></p>
</li>
<li>
<p><a href="#i1253543">Payload Methods</a></p>
</li>
</ul>
<p class="subhead1"><a id="ARPLS71833"></a>Syntax</p>
<pre dir="ltr">TYPE aq$_jms_stream_message AS object(
 header     aq$_jms_header,
 bytes_len  int,
 bytes_raw  raw(2000),
 bytes_lob  blob,
 STATIC FUNCTION  construct RETURN aq$_jms_stream_message,
 MEMBER PROCEDURE set_replyto  (replyto IN sys.aq$_agent),
 MEMBER PROCEDURE set_type     (type    IN VARCHAR),
 MEMBER FUNCTION get_replyto  RETURN sys.aq$_agent,
 MEMBER FUNCTION get_type     RETURN VARCHAR,
 MEMBER PROCEDURE set_userid   (userid   IN VARCHAR),
 MEMBER PROCEDURE set_appid    (appid    IN VARCHAR),
 MEMBER PROCEDURE set_groupid  (groupid  IN VARCHAR),
 MEMBER PROCEDURE set_groupseq (groupseq IN INT),
 MEMBER FUNCTION get_userid   RETURN VARCHAR,
 MEMBER FUNCTION get_appid    RETURN VARCHAR,
 MEMBER FUNCTION get_groupid  RETURN VARCHAR,
 MEMBER FUNCTION get_groupseq RETURN INT,
 MEMBER PROCEDURE clear_properties,
 MEMBER PROCEDURE set_boolean_property(property_name IN VARCHAR,
   property_value IN BOOLEAN),
 MEMBER PROCEDURE set_byte_property   (property_name IN VARCHAR,
   property_value IN INT),
 MEMBER PROCEDURE set_double_property (property_name IN VARCHAR,
   property_value IN DOUBLE PRECISION),
 MEMBER PROCEDURE set_float_property  (property_name IN VARCHAR,
   property_value IN FLOAT),
 MEMBER PROCEDURE set_int_property    (property_name IN VARCHAR,
   property_value IN INT),
 MEMBER PROCEDURE set_long_property   (property_name IN VARCHAR,
   property_value IN NUMBER),
 MEMBER PROCEDURE set_short_property  (property_name IN VARCHAR,
   property_valuE IN INT),
 MEMBER PROCEDURE set_string_property (property_name IN VARCHAR,
   property_value IN VARCHAR),
 MEMBER FUNCTION get_boolean_property (property_name IN VARCHAR) RETURN BOOLEAN,
 MEMBER FUNCTION get_byte_property    (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_double_property  (property_name IN VARCHAR) 
   RETURN DOUBLE PRECISION,
 MEMBER FUNCTION get_float_property   (property_name IN VARCHAR) RETURN FLOAT,
 MEMBER FUNCTION get_int_property     (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_long_property    (property_name IN VARCHAR) RETURN NUMBER,
 MEMBER FUNCTION get_short_property   (property_name IN VARCHAR) RETURN INT,
 MEMBER FUNCTION get_string_property  (property_name IN VARCHAR) RETURN VARCHAR,
 MEMBER PROCEDURE set_bytes           (payload IN RAW),
 MEMBER PROCEDURE set_bytes           (payload IN BLOB),
 MEMBER PROCEDURE get_bytes           (payload OUT RAW),
 MEMBER PROCEDURE get_bytes           (payload OUT BLOB),
 MEMBER FUNCTION  prepare             (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER PROCEDURE reset               (id IN PLS_INTEGER),
 MEMBER PROCEDURE flush               (id IN PLS_INTEGER),
 MEMBER PROCEDURE clear_body          (id IN PLS_INTEGER),
 MEMBER PROCEDURE clean               (id IN PLS_INTEGER),
 STATIC PROCEDURE clean_all,
 MEMBER FUNCTION  get_mode       (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION  read_boolean   (id IN PLS_INTEGER) RETURN BOOLEAN,
 MEMBER FUNCTION  read_byte      (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION  read_bytes     (id IN PLS_INTEGER) RETURN BLOB,
 MEMBER PROCEDURE read_bytes     (id IN PLS_INTEGER, value OUT NOCOPY BLOB),
 MEMBER FUNCTION  read_char      (id IN PLS_INTEGER) RETURN CHAR,
 MEMBER FUNCTION  read_double    (id IN PLS_INTEGER) RETURN DOUBLE PRECISION,
 MEMBER FUNCTION  read_float     (id IN PLS_INTEGER) RETURN FLOAT,
 MEMBER FUNCTION  read_int       (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION  read_long      (id IN PLS_INTEGER) RETURN NUMBER,
 MEMBER FUNCTION  read_short     (id IN PLS_INTEGER) RETURN PLS_INTEGER,
 MEMBER FUNCTION  read_string RETURN CLOB,
 MEMBER PROCEDURE read_string    (id IN PLS_INTEGER, value OUT NOCOPY CLOB),
 MEMBER PROCEDURE read_object    (id IN PLS_INTEGER, 
   value OUT NOCOPY AQ$_JMS_VALUE),
 MEMBER PROCEDURE write_boolean  (id IN PLS_INTEGER, value IN BOOLEAN),
 MEMBER PROCEDURE write_byte     (id IN PLS_INTEGER, value IN INT),
 MEMBER PROCEDURE write_bytes    (id IN PLS_INTEGER, value IN RAW),
 MEMBER PROCEDURE write_bytes    (id IN PLS_INTEGER, value IN RAW, 
   offset IN INT, length IN INT),
 MEMBER PROCEDURE write_bytes    (id IN PLS_INTEGER, value IN BLOB),
 MEMBER PROCEDURE write_bytes    (id IN PLS_INTEGER, value IN BLOB,
   offset IN INT, length IN INT),
 MEMBER PROCEDURE write_char     (id IN PLS_INTEGER, value IN CHAR),
 MEMBER PROCEDURE write_double   (id IN PLS_INTEGER, value IN DOUBLE PRECISION),
 MEMBER PROCEDURE write_float    (id IN PLS_INTEGER, value IN FLOAT),
 MEMBER PROCEDURE write_int      (id IN PLS_INTEGER, value IN PLS_INTEGER),
 MEMBER PROCEDURE write_long     (id IN PLS_INTEGER, value IN NUMBER),
 MEMBER PROCEDURE write_short    (id IN PLS_INTEGER, value IN PLS_INTEGER),
 MEMBER PROCEDURE write_string   (id IN PLS_INTEGER, value IN VARCHAR2),
 MEMBER PROCEDURE write_string   (id IN PLS_INTEGER, value IN CLOB));
</pre>
<div id="ARPLS71834" class="refsect3"><a id="i1252574"></a>
<h4 class="refsect3">CONSTRUCT Function</h4>
<dl>
<dt>STATIC FUNCTION construct RETURN aq$_jms_stream_message</dt>
<dd>
<p>Creates an empty <code dir="ltr">aq$_jms_stream_message</code> object.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71835" class="refsect3"><a id="i1252581"></a>
<h4 class="refsect3">JMS Header Methods</h4>
<dl>
<dt>set_replyto (replyto IN sys.aq$_agent)</dt>
<dd>
<p>Sets the <code dir="ltr">replyto</code> parameter, which corresponds to <code dir="ltr">JMSReplyTo</code> in JMS.</p>
</dd>
<dt>set_type (type IN VARCHAR)</dt>
<dd>
<p>Sets the JMS type, which can be any text, and which corresponds to <code dir="ltr">JMSType</code> in JMS.</p>
</dd>
<dt>get_replyto RETURN sys.aq$_agent</dt>
<dd>
<p>Returns <code dir="ltr">replyto</code>, which corresponds to <code dir="ltr">JMSReplyTo</code>.</p>
</dd>
<dt>get_type RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">type</code>, which corresponds to <code dir="ltr">JMSType</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71836" class="refsect3"><a id="i1252588"></a>
<h4 class="refsect3">System Properties Methods</h4>
<dl>
<dt>set_userid (userid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code> in JMS.</p>
</dd>
<dt>set_appid (appid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code> in JMS.</p>
</dd>
<dt>set_groupid (groupid IN VARCHAR)</dt>
<dd>
<p>Sets <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code> in JMS.</p>
</dd>
<dt>set_groupseq (groupseq IN INT)</dt>
<dd>
<p>Sets <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code> in JMS.</p>
</dd>
<dt>get_userid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">userid</code>, which corresponds to <code dir="ltr">JMSXUserID</code>.</p>
</dd>
<dt>get_appid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">appid</code>, which corresponds to <code dir="ltr">JMSXAppID</code>.</p>
</dd>
<dt>get_groupid RETURN VARCHAR</dt>
<dd>
<p>Returns <code dir="ltr">groupid</code>, which corresponds to <code dir="ltr">JMSXGroupID</code>.</p>
</dd>
<dt>get_groupseq RETURN NUMBER</dt>
<dd>
<p>Returns <code dir="ltr">groupseq</code>, which corresponds to <code dir="ltr">JMSXGroupSeq</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71837" class="refsect3"><a id="i1252595"></a>
<h4 class="refsect3">User Properties Methods</h4>
<dl>
<dt>clear_properties</dt>
<dd>
<p>Clears all user properties. This procedure does not affect system properties.</p>
</dd>
<dt>set_boolean_property (property_name IN VARCHAR, property_value IN BOOLEAN)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code> in an internal representation. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_byte_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -128 to 127 (8-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">BYTE</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_double_property (property_name IN VARCHAR, property_value IN DOUBLE PRECISION)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_float_property (property_name IN VARCHAR, property_value IN FLOAT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_int_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -2147483648 to 2147483647 (32-bits). This check is necessary because in PL/SQL and Oracle Database, the <code dir="ltr">INT</code> datatype is 38 bits. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_long_property (property_name IN VARCHAR, property_value IN NUMBER)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. In PL/SQL and Oracle Database, the <code dir="ltr">NUMBER</code> datatype is 38 bits. In Java, the <code dir="ltr">long</code> datatype is 64 bits. Therefore, no range check is needed.Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>set_short_property (property_name IN VARCHAR, property_value IN INT)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure checks whether <code dir="ltr">property_value</code> is within -32768 to 32767 (16-bits). This check is necessary because neither PL/SQL nor RDBMS defines the <code dir="ltr">short</code> datatype. Raises exception ORA-24191 if the property name exists, ORA-24192 if the property name is null, or ORA-24193 if the property value exceeds the valid range.</p>
</dd>
<dt>set_string_property (property_name IN VARCHAR, property_value IN VARCHAR)</dt>
<dd>
<p>Checks whether <code dir="ltr">property_name</code> is null or exists. If not, the procedure stores <code dir="ltr">property_value</code>. Raises exception ORA-24191 if the property name exists or ORA-24192 if the property name is null.</p>
</dd>
<dt>get_boolean_property (property_name IN VARCHAR) RETURN BOOLEAN</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BOOLEAN</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_byte_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">BYTE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_double_property (property_name IN VARCHAR) RETURN DOUBLE PRECISION</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">DOUBLE</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_float_property (property_name IN VARCHAR) RETURN FLOAT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">FLOAT</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_int_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">Integer</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_long_property (property_name IN VARCHAR) RETURN NUMBER</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">long</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_short_property (property_name IN VARCHAR) RETURN INT</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">short</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
<dt>get_string_property (property_name IN VARCHAR) RETURN VARCHAR</dt>
<dd>
<p>If the property with the corresponding property name passed in exists, and if it is a <code dir="ltr">STRING</code> property, then this function returns the value of the property. Otherwise it returns a null.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" -->
<div id="ARPLS71838" class="refsect3"><a id="i1253543"></a>
<h4 class="refsect3">Payload Methods</h4>
<dl>
<dt>get_bytes (payload OUT RAW)</dt>
<dd>
<p>Puts the internal payload into a RAW variable without any interpretation. The payload of type <code dir="ltr">aq$_jms_stream_message</code> is stored as either <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code> in the database. This member function gets a payload as raw bytes without interpreting it. Raises exception ORA-24190 if the length of internal payload is more than 32767.</p>
</dd>
<dt>get_bytes (payload OUT BLOB)</dt>
<dd>
<p>Puts the internal payload into a BLOB variable without any interpretation. The payload of type <code dir="ltr">aq$_jms_stream_message</code> is stored as either <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code> in the database. This member function gets a payload as a <code dir="ltr">BLOB</code> variable without interpreting it.</p>
</dd>
<dt>set_bytes (payload IN RAW)</dt>
<dd>
<p>Sets the internal payload as the RAW variable without any interpretation. The payload of type <code dir="ltr">aq$_jms_stream_message</code> is stored as either <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code> in the database. This member function sets a payload as raw bytes without interpreting it.</p>
</dd>
<dt>set_bytes (payload IN BLOB)</dt>
<dd>
<p>Sets the internal payload as the <code dir="ltr">BLOB</code> variable without any interpretation. The payload of type <code dir="ltr">aq$_jms_stream_message</code> is stored as either <code dir="ltr">RAW</code> or <code dir="ltr">BLOB</code> in the database. This member function sets a payload as a <code dir="ltr">BLOB</code> variable without interpreting it.</p>
</dd>
<dt>prepare (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Takes the byte array stored in <code dir="ltr">aq$_jms_stream_message</code> and decodes it as a Java object in the Java stored procedure. The result of the decoding is stored as a static variable in Jserv session memory. Parameter <code dir="ltr">id</code> is used to identify the slot where the Java object is stored in the Oracle Database JVM session memory. If <code dir="ltr">id</code> is null, then a new slot is created for this PL/SQL object. Subsequent JMS operations on the payload need to provide this operation ID.</p>
<p>This function also sets the message access mode to <code dir="ltr">MESSAGE_ACCESS_READONLY</code>. Subsequent calls of <code dir="ltr">write_XXX</code> procedure raise an ORA-24196 error. Users can call the <code dir="ltr">clear_body</code> procedure to set the message access mode to <code dir="ltr">MESSAGE_ACCESS_READONLY</code>.</p>
<p>This function raises ORA-24197 if the Java stored procedure throws an exception during execution, ORA-24198 if the operation ID is invalid, or ORA-24199 if the Java stored procedure message store overflows.</p>
</dd>
<dt>reset (id IN PLS_INTEGER)</dt>
<dd>
<p>Resets the starting position of the stream to the beginning and puts the stream message in <code dir="ltr">MESSAGE_ACCESS_READONLY</code> mode.</p>
</dd>
<dt>flush (id IN PLS_INTEGER)</dt>
<dd>
<p>Takes the static variable in Jserv and synchronizes the content back to <code dir="ltr">aq$_jms_stream_message</code>. This procedure will not affect the underlying access mode. This procedure raises ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>clear_body (id IN PLS_INTEGER)</dt>
<dd>
<p>Sets the Java stored procedure static variable to empty payload. Parameter <code dir="ltr">id</code> is used to identify the slot where the Java object is stored in the Oracle Database JVM session memory. If <code dir="ltr">id</code> is null, a new slot is created for this PL/SQL object. Subsequent JMS operations on the payload need to provide this operation ID.</p>
<p>It also sets the message access mode to <code dir="ltr">MESSAGE_ACCESS_WRITEONLY</code>. Later calls of <code dir="ltr">read_XXX</code> procedure raise ORA-24196 error. Users can call the <code dir="ltr">reset</code> or <code dir="ltr">prepare</code> procedures to set the message access mode to <code dir="ltr">MESSAGE_ACCESS_READONLY</code>. Write-only and read-only modes affect only the payload functions of <code dir="ltr">AQ$_JMS_BYTES_MESSAGE</code>. They do not affect the header functions.</p>
<p>This function raises ORA-24197 if the Java stored procedure throws an exception during execution, ORA-24198 if the operation ID is invalid, or ORA-24199 if the Java stored procedure message store overflows.</p>
</dd>
<dt>clean (id IN PLS_INTEGER)</dt>
<dd>
<p>Closes and cleans up the <code dir="ltr">DataInputStream</code> or <code dir="ltr">DataOutputStream</code> at the Java stored procedure side corresponding to the operation ID. It is very important to call this procedure to avoid memory leaks. This procedure raises ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>clean_all</dt>
<dd>
<p>Closes and cleans up all the messages in the corresponding type of message store at the Java stored procedure side. This procedure raises ORA-24197 if the Java stored procedure throws an exception during execution.</p>
</dd>
<dt>get_mode (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Returns the current mode of this message. The return value is either <code dir="ltr">SYS.dbms_aqjms.READ_ONLY</code> or SYS.<code dir="ltr">dbms_aqjms.WRITE_ONLY</code>. Raises exception ORA-24197 if the Java stored procedure throws an exception during execution or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_boolean (id IN PLS_INTEGER) RETURN BOOLEAN</dt>
<dd>
<p>Reads and returns a Boolean value from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_byte (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Reads and returns a byte value from the stream message. If the end of the message stream has been reached, then null is returned. Because there is no <code dir="ltr">BYTE</code> type in PL/SQL, <code dir="ltr">INT</code> is used to represent a byte. Although PL/SQL users get an <code dir="ltr">INT</code>, they are guaranteed that the value is in the Java <code dir="ltr">BYTE</code> value range. If this value is issued with a <code dir="ltr">write_byte</code> function, then there will not be an out of range error. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_bytes (id IN PLS_INTEGER) RETURN BLOB</dt>
<dd>
<p>Reads and returns a byte array from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid or ORA-24196 if the stream message is in write-only mode.</p>
</dd>
<dt>read_bytes (id IN PLS_INTEGER, value OUT NOCOPY BLOB)</dt>
<dd>
<p>Reads a byte array from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_char (id IN PLS_INTEGER) RETURN CHAR</dt>
<dd>
<p>Reads and returns a character value from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_double (id IN PLS_INTEGER) RETURN DOUBLE PRECISION</dt>
<dd>
<p>Reads and returns a double from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_float (id IN PLS_INTEGER) RETURN FLOAT</dt>
<dd>
<p>Reads and returns a float from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_int (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Reads and returns an <code dir="ltr">INT</code> from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_long (id IN PLS_INTEGER) RETURN NUMBER</dt>
<dd>
<p>Reads and returns a long from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_short (id IN PLS_INTEGER) RETURN PLS_INTEGER</dt>
<dd>
<p>Reads and returns a short value from the stream message. If the end of the message stream has been reached, then null is returned. Because there is no short type in PL/SQL, <code dir="ltr">PLS_INTEGER</code> is used to represent a <code dir="ltr">SHORT</code>. Although PL/SQL users get an <code dir="ltr">INT</code>, they are guaranteed that the value is in the Java short value range. If this value is issued with a <code dir="ltr">write_short</code> function, then there will not be an out of range error. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_string RETURN CLOB</dt>
<dd>
<p>Reads and returns a string from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid or ORA-24196 if the stream message is in write-only mode.</p>
</dd>
<dt>read_string (id IN PLS_INTEGER, value OUT NOCOPY CLOB)</dt>
<dd>
<p>Reads a string from the stream message. If the end of the message stream has been reached, then null is returned. Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>read_object (id IN PLS_INTEGER, value OUT NOCOPY AQ$_JMS_VALUE)</dt>
<dd>
<p>Returns a general value ADT <code dir="ltr">AQ$_JMS_VALUE</code>. Users can use the type attribute of this ADT to interpret the data. See <a href="#BABGGCFA">Table 274-2</a> for the correspondence among <code dir="ltr">dbms_jms_plsql</code> package constants, Java datatype and <code dir="ltr">AQ$_JMS_VALUE</code> attribute. This member procedure might bring additional overhead compared to other read member procedures or functions. It is used only if the user does not know the datatype of the fields within a message beforehand. Otherwise it is a good idea to use a specific read member procedure or function.</p>
<p>Raises exception ORA-24194 if the type conversion between the type of real value and the expected type is invalid, ORA-24196 if the stream message is in write-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_boolean (id IN PLS_INTEGER, value IN BOOLEAN)</dt>
<dd>
<p>Writes a Boolean to the stream message. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_byte (id IN PLS_INTEGER, value IN INT)</dt>
<dd>
<p>Writes a byte to the stream message. Because there is no <code dir="ltr">BYTE</code> type in PL/SQL, <code dir="ltr">INT</code> is used to represent a byte. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_bytes (id IN PLS_INTEGER, value IN RAW)</dt>
<dd>
<p>Writes a byte array field to the stream message. Consecutively written byte array fields are treated as two distinct fields when the fields are read. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_bytes (id IN PLS_INTEGER, value IN RAW, offset IN INT, length IN INT)</dt>
<dd>
<p>Writes a portion of a byte array as a byte array field to the stream message. Consecutively written byte array fields are treated as two distinct fields when the fields are read. Parameter <code dir="ltr">offset</code> is the initial offset within the byte array, and parameter <code dir="ltr">length</code> is the number of bytes to use. If the range [offset, offset+length] exceeds the boundary of the byte array value, then a Java <code dir="ltr">IndexOutOfBounds</code> exception is thrown in the Java stored procedure. The index starts from 0.</p>
<p>Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_bytes (id IN PLS_INTEGER, value IN BLOB)</dt>
<dd>
<p>Writes a byte array field to the stream message. Consecutively written byte array fields are treated as two distinct fields when the fields are read. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_bytes (id IN PLS_INTEGER, value IN BLOB, offset IN INT, length IN INT)</dt>
<dd>
<p>Writes a portion of a byte array as a byte array field to the stream message. Consecutively written byte array fields are treated as two distinct fields when the fields are read. Parameter <code dir="ltr">offset</code> is the initial offset within the byte array, and parameter <code dir="ltr">length</code> is the number of bytes to use. If the range [offset, offset+length] exceeds the boundary of the byte array value, then a Java <code dir="ltr">IndexOutOfBounds</code> exception is thrown in the Java stored procedure. The index starts from 0.</p>
<p>Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_char (id IN PLS_INTEGER, value IN CHAR)</dt>
<dd>
<p>Writes a character value to the stream message. If this value has multiple characters, then it is the first character that is written. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_double (id IN PLS_INTEGER, value IN DOUBLE PRECISION)</dt>
<dd>
<p>Writes a double to the stream message. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_float (id IN PLS_INTEGER, value IN FLOAT)</dt>
<dd>
<p>Writes a float to the stream message. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_int (id IN PLS_INTEGER, value IN PLS_INTEGER)</dt>
<dd>
<p>Writes an <code dir="ltr">INT</code> to the stream message. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_long (id IN PLS_INTEGER, value IN NUMBER)</dt>
<dd>
<p>Writes a long to the stream message. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_short (id IN PLS_INTEGER, value IN PLS_INTEGER)</dt>
<dd>
<p>Writes a short to the stream message. Because there is no short type in PL/SQL, <code dir="ltr">INT</code> is used to represent a short. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_string (id IN PLS_INTEGER, value IN VARCHAR2)</dt>
<dd>
<p>Writes a string to the stream message. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
<dt>write_string (id IN PLS_INTEGER, value IN CLOB)</dt>
<dd>
<p>Writes a string to the stream message. Raises exceptions ORA-24196 if the stream message is in read-only mode, ORA-24197 if the Java stored procedure throws an exception during execution, or ORA-24198 if the operation ID is invalid.</p>
</dd>
</dl>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS71839" class="refsect2"><a id="i1250011"></a>
<h3 class="refsect2">SYS.AQ$_JMS_OBJECT_MESSAGE Type</h3>
<p>This type is the ADT used to store an <code dir="ltr">ObjectMessage</code> in an Oracle Database Advanced Queuing queue.</p>
<p class="subhead1"><a id="ARPLS71840"></a>Syntax</p>
<pre dir="ltr">TYPE aq$_jms_object_message AS object(
  header     aq$_jms_header,
  bytes_len  int,
  bytes_raw  raw(2000),
  bytes_lob  blob);
</pre></div>
<!-- class="refsect2" -->
<div id="ARPLS71841" class="refsect2"><a id="i1243541"></a>
<h3 class="refsect2">SYS.AQ$_JMS_NAMEARRAY Type</h3>
<p>This type represents the name array returned by the <code dir="ltr">get_names</code> procedure of <code dir="ltr">aq$_jms_map_message</code>. The maximum number of names this type can hold is 1024. The maximum length of each name is 200 characters.</p>
<p class="subhead1"><a id="ARPLS71842"></a>Syntax</p>
<pre dir="ltr">CREATE OR REPLACE TYPE AQ$_JMS_NAMEARRAY AS VARRAY(1024) OF VARCHAR(100);
</pre>
<p class="subhead1"><a id="ARPLS71843"></a>Usage Notes</p>
<p>If the names array in the message payload is greater than 1024, then use the following function to retrieve the names in multiple portions:</p>
<pre dir="ltr">MEMBER FUNCTION get_names(id IN PLS_INTEGER, names OUT aq$_jms_namearray,
   offset IN PLS_INTEGER, length IN PLS_INTEGER) RETURN PLS_INTEGER;
</pre></div>
<!-- class="refsect2" -->
<div id="ARPLS71844" class="refsect2"><a id="i1243557"></a>
<h3 class="refsect2">SYS.AQ$_JMS_VALUE Type</h3>
<p>This type represents the general data returned by the <code dir="ltr">get_object</code> procedure of <code dir="ltr">aq$_jms_map_message</code> and the <code dir="ltr">read_object</code> procedure of <code dir="ltr">aq$_jms_stream_message</code>. The <code dir="ltr">type</code> field in this ADT is used to decide which type of data this object is really holding. <a href="#BABGGCFA">Table 274-2</a> lists the mapping between the <code dir="ltr">sys.dbms_jms_plsql</code> type constants, the corresponding Java type, and the data field of ADT <code dir="ltr">aq$_jms_value</code> which effectively holds the data.</p>
<p class="subhead1"><a id="ARPLS71845"></a>Syntax</p>
<pre dir="ltr">CREATE OR REPLACE TYPE AQ$_JMS_VALUE AS object(
 type      number(2),
 num_val   number,
 char_val  char(1),
 text_val  clob,
 bytes_val blob);
</pre>
<div id="ARPLS71846" class="tblformal">
<p class="titleintable"><a id="sthref20410"></a><a id="BABGGCFA"></a>Table 274-2 AQ$_JMS_VALUE Type Fields and Java Fields</p>
<table class="cellalignment4330" title="AQ$_JMS_VALUE Type Fields and Java Fields" summary="This table describes AQ$_JMS_VALUE Type Fields and Java Fields." dir="ltr">
<thead>
<tr class="cellalignment4321">
<th class="cellalignment4328" id="r1c1-t6">Type</th>
<th class="cellalignment4328" id="r1c2-t6">Java Type</th>
<th class="cellalignment4328" id="r1c3-t6">aq$_jms_value Data Field</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r2c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_BYTE</code></p>
</td>
<td class="cellalignment4329" headers="r2c1-t6 r1c2-t6">
<p>byte</p>
</td>
<td class="cellalignment4329" headers="r2c1-t6 r1c3-t6">
<p>num_val</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r3c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_SHORT</code></p>
</td>
<td class="cellalignment4329" headers="r3c1-t6 r1c2-t6">
<p>short</p>
</td>
<td class="cellalignment4329" headers="r3c1-t6 r1c3-t6">
<p>num_val</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r4c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_INTEGER</code></p>
</td>
<td class="cellalignment4329" headers="r4c1-t6 r1c2-t6">
<p>int</p>
</td>
<td class="cellalignment4329" headers="r4c1-t6 r1c3-t6">
<p>num_val</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r5c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_LONG</code></p>
</td>
<td class="cellalignment4329" headers="r5c1-t6 r1c2-t6">
<p>long</p>
</td>
<td class="cellalignment4329" headers="r5c1-t6 r1c3-t6">
<p>num_val</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r6c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_FLOAT</code></p>
</td>
<td class="cellalignment4329" headers="r6c1-t6 r1c2-t6">
<p>float</p>
</td>
<td class="cellalignment4329" headers="r6c1-t6 r1c3-t6">
<p>num_val</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r7c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_DOUBLE</code></p>
</td>
<td class="cellalignment4329" headers="r7c1-t6 r1c2-t6">
<p>double</p>
</td>
<td class="cellalignment4329" headers="r7c1-t6 r1c3-t6">
<p>num_val</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r8c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_BOOLEAN</code></p>
</td>
<td class="cellalignment4329" headers="r8c1-t6 r1c2-t6">
<p>boolean</p>
</td>
<td class="cellalignment4329" headers="r8c1-t6 r1c3-t6">
<p>num_val:</p>
<p>0 FALSE, 1 TRUE</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r9c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_CHARACTER</code></p>
</td>
<td class="cellalignment4329" headers="r9c1-t6 r1c2-t6">
<p>char</p>
</td>
<td class="cellalignment4329" headers="r9c1-t6 r1c3-t6">
<p>char_val</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r10c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_STRING</code></p>
</td>
<td class="cellalignment4329" headers="r10c1-t6 r1c2-t6">
<p>java.lang.String</p>
</td>
<td class="cellalignment4329" headers="r10c1-t6 r1c3-t6">
<p>text_val</p>
</td>
</tr>
<tr class="cellalignment4321">
<td class="cellalignment4329" id="r11c1-t6" headers="r1c1-t6">
<p><code dir="ltr">DBMS_JMS_PLSQL.DATA_TYPE_BYTES</code></p>
</td>
<td class="cellalignment4329" headers="r11c1-t6 r1c2-t6">
<p>byte[]</p>
</td>
<td class="cellalignment4329" headers="r11c1-t6 r1c3-t6">
<p>bytes_val</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="refsect2" -->
<div id="ARPLS71847" class="refsect2"><a id="i1243660"></a>
<h3 class="refsect2">SYS.AQ$_JMS_EXCEPTION Type</h3>
<p>This type represents a Java exception thrown on the Java stored procedure side. The <code dir="ltr">id</code> field is reserved for future use. The <code dir="ltr">exp_name</code> stores the Java exception name, the <code dir="ltr">err_msg</code> field stores the Java exception error message, and the <code dir="ltr">stack</code> field stores the stack trace of the Java exception.</p>
<p class="subhead1"><a id="ARPLS71848"></a>Syntax</p>
<pre dir="ltr">CREATE OR REPLACE TYPE AQ$_JMS_EXCEPTION AS OBJECT (
   id          number, -- Reserved and not used. Right now always return 0.
   exp_name    varchar(200),
   err_msg     varchar(500),
   stack       varchar(4000));
</pre></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" --></div>
<!-- class="refentry" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4320">
<tr>
<td class="cellalignment4329">
<table class="cellalignment4325">
<tr>
<td class="cellalignment4324"><a href="t_dburi.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4324"><a href="t_lcr.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2016,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4332">
<table class="cellalignment4323">
<tr>
<td class="cellalignment4324"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4324"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4324"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4324"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4324"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4324"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>