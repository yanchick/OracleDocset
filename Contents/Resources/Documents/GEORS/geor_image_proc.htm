<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-45825"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Image%20Processing%20and%20Virtual%20Mosaic"></a><title>Image Processing and Virtual Mosaic</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="ground control points (GCPs), advanced georeferencing, reprojecting GeoRaster objects, rectification, of images, orthorectification, DEM (Digital Elevation Model), orthorectification with, Digital Elevation Model (DEM), scaling, images, stretching images, images, stretching, image segmentation, segmenting images, pyramids, image pyramiding, bitmap pyramiding, bitmap pyramiding, vegetation index computation, NDVI (Normalized Difference Vegetation Index), Normalized Difference Vegetation Index (NDVI), Tasseled Cap Computation (TCT), TCT (Tasseled Cap Computation), image masking, masking, bands, merging, merging bands, appending, appending images, mosaic, large-scale image, virtual, virtual mosaic, serving, serving images"/>
<meta name="dcterms.created" content="2017-03-13T13:19:47Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Spatial and Graph GeoRaster Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49118-05"/>
<meta name="dcterms.isVersionOf" content="GEORS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="geor_raster_algebra.htm" title="Previous" type="text/html"/>
<link rel="Next" href="geor_ref.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49118-05.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-EB60166B-6A52-4974-AF16-139CD6480EBC"></a> <span id="PAGE" style="display:none;">11/18</span> <!-- End Header -->
<a id="GEORS1217"></a>
<h1 id="GEORS-GUID-EB60166B-6A52-4974-AF16-139CD6480EBC" class="sect1"><span class="enumeration_chapter">5</span> Image Processing and Virtual Mosaic</h1>
<div>
<p>This chapter describes advanced image processing capabilities, including GCP georeferencing, reprojection, rectification, orthorectification, image scaling, stretching, masking, image segmentation, NDVI computation, Tasseled Cap Transformation, image appending, bands merging, and large-scale advanced image mosaicking.</p>
<p>This chapter also describes the concept and application of <span class="italic">virtual mosaic</span> within the context of a large-scale image database and on-the-fly spatial queries over it.</p>
<p>The operations in this chapter are most commonly used to process geospatial images, particularly raw satellite imagery and airborne photographs. However, those operations, just like the GeoRaster raster algebra, apply to all raster data types.</p>
<p>This chapter contains the following major sections:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="geor_image_proc.htm#GUID-AA625889-BB88-4633-BECD-E76FAE05EE01">Advanced Georeferencing</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-7AEE808F-F450-41C2-AB4C-AA7D740AF928">Image Reprojection</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-EFDF0FB9-9FFA-4254-997B-1C7D3D7CF897">Image Rectification</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-1EA97BE8-2B6B-4E0E-B89E-57ECD1C33F95">Image Orthorectification</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-E4C18793-CFE6-49CC-8957-6FA9DD99CB7B">Image Scaling</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-1BFCB081-6C19-4727-B07E-1127515D75CD">Image Stretching</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-21CA4981-4DFB-4918-BC1F-13803AFEAD28">Image Segmentation</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-9935029B-2ED5-4A7B-9157-336AD5F57D77">Image Pyramiding: Parallel Generation and Partial Update</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-60EC1E32-9E68-4E4D-8FFE-54A8A19A07EE">Bitmap Pyramiding</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-C2D99D00-071F-4BBC-A0A5-50C6F0FAF355">Vegetation Index Computation</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-2530F5D2-7386-4DD4-877A-F004F2109912">Tasseled Cap Transformation</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-846AEB51-5BCC-48D6-8B27-8F846F38CC15">Image Masking</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-8BE9EF2F-EAFE-4247-B8CD-50B3AD3A3807">Band Merging</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-EE1AFE0D-730E-49DC-80AF-E99504D14156">Image Appending</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA">Large-Scale Image Mosaicking</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-16C91449-1E94-4B3F-9403-EEFE483251AD">Virtual Mosaic</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-639C081E-8E7F-4467-8B89-3363810F561F">Image Serving</a></p>
</li>
</ul>
</div>
<a id="GEORS1310"></a><a id="GEORS1311"></a><a id="GEORS1218"></a>
<div class="props_rev_3"><a id="GUID-AA625889-BB88-4633-BECD-E76FAE05EE01"></a>
<h2 id="GEORS-GUID-AA625889-BB88-4633-BECD-E76FAE05EE01" class="sect2"><span class="enumeration_section">5.1</span> Advanced Georeferencing</h2>
<div>
<p>In GeoRaster, the spatial referencing capability is called SRS (spatial reference system) or georeferencing, which may or may not be related to geography or a geospatial scheme. Georeferencing is a key feature of GeoRaster and is the foundation of spatial query and operations over geospatial image and gridded raster data. See <a href="geor_intro.htm#GUID-E32BF03B-DB83-422E-B7D0-C0F3073890F9">Georeferencing</a> for a detailed description of the SRS models.</p>
<p>GeoRaster supports non-geospatial images, fine art photos, and multi-dimensional arrays, which might not be associated with any coordinate system. For those images and rasters, there is generally no need for georeferencing, but most of the GeoRaster operations still work on them, such as pyramiding, scaling, subsetting, band merging, stretching, and algebraic operations. In these cases, you address the pixels (cells) using the raster&#39;s cell space coordinates (that is, row, column, and band).</p>
<p>You can also create a user-defined coordinate system (a new SRID) that is not related to geography, and you can use that SRID as the model coordinate system for the rasters. Then, you can spatially reference these rasters to that SRID; that is, an SRS metadata component will be created for each of those rasters. Doing this causes those rasters to be spatially referenced, and thus co-located in that user-defined model coordinate system. After this is done for all related rasters, GeoRaster operations will work on those rasters as if they are georeferenced to a geographic coordinate system. For example, assume that an artist has painted a large mural on a wall, and that you want to be able to take many high-resolution photographs of different tiles of this wall and then stitch them together. You can spatially reference the tile images and then use the GeoRaster mosaicking capability to do the stitching.</p>
<p>If you do not define a new coordinate system, you can still co-locate the images in the cell space. That is, you can set up different ULT coordinates for the images by calling the <a href="geor_ref.htm#GUID-B5BF3AB1-3EB5-4D86-B417-28662B7AD00B">SDO_GEOR.setULTCoordinate</a> procedure, so that the images are aligned in the same coordinate system and then can be mosaicked.</p>
<p>Most geospatial image and raster files that you have are probably already georeferenced by other software tools, and thus they may come with georeferencing information. In those cases, the georeferencing information can be directly loaded with the rasters or afterward by using <a href="geor_ref.htm#GUID-07B69D26-239F-4C52-A2D2-E776B2BABF8B">SDO_GEOR.importFrom</a>, <a href="geor_ref.htm#GUID-0406AB05-BA9B-4331-8613-B480A9F12C09">SDO_GEOR.setSRS</a>, the GeoRaster loader tool, GDAL, or other third-party ETL tools. For more information, check <a href="geor_intro.htm#GUID-4813E3BC-2DB8-4310-82E5-3ADC467C0253">GeoRaster Tools: Viewer_ Loader_ Exporter</a> and <a href="basic-georaster-operations.htm#GUID-5E9E62CA-A4CB-4298-9345-0351F60DECC0">Georeferencing GeoRaster Objects</a>.</p>
<p>If a geospatial image does not have spatial reference information, you can use the GeoRaster Ground Control Point (GCP) support to georeference the image. GCPs are collected either automatically by the remote sensing system or manually afterward. For an image without GCP information, you can use a GeoRaster visualization tool to collection GCPs for the GeoRaster object. GCPs are described in <a href="geor_intro.htm#GUID-EC9DEF7E-54B5-488A-BBCC-932334C9FF9E">Ground Control Point (GCP) Georeferencing Model</a>.</p>
<p>After you have the GCPs and want to store them in the GeoRaster metadata, you can get and set the GCP-based georeferencing mode by using the <a href="geor_ref.htm#GUID-9150C734-101F-479C-8FE4-3B3613C54EE1">SDO_GEOR.getGCPGeorefModel</a> function and the <a href="geor_ref.htm#GUID-C6DD6322-F4C7-48B9-B009-AD92A54AFBC8">SDO_GEOR.setGCPGeorefModel</a> procedure. To get, set, and edit only GCPs, use the <a href="geor_ref.htm#GUID-C2E30658-697E-413D-9EC7-1C55814B5BBD">SDO_GEOR.getControlPoint</a> function and the <a href="geor_ref.htm#GUID-44A07135-D379-4DE1-86B1-D299388033E4">SDO_GEOR.setControlPoint</a> and <a href="geor_ref.htm#GUID-ACB2F70E-DAB7-4AFC-9DDE-F35F451A19C1">SDO_GEOR.deleteControlPoint</a> procedures. The GCPs can also be stored in the GeoRaster metadata when you call <a href="geor_ref.htm#GUID-BFA20035-A3A9-41C6-A7B0-DFB014C73F34">SDO_GEOR.georeference</a>.</p>
<p>To get and set only the geometric model, use the <a href="geor_ref.htm#GUID-A6BBF1F3-E28C-414D-BE24-8F8C8266B121">SDO_GEOR.getGCPGeorefMethod</a> function and the <a href="geor_ref.htm#GUID-7F595E4E-2770-4012-9CFE-3B4725C82EF1">SDO_GEOR.setGCPGeorefMethod</a> procedure. GeoRaster also allows you to store check points (<code class="codeph">pointType</code> = 2), which are treated and manipulated in the same way as control points (<code class="codeph">pointType</code> = 1) except that check points are not used to create the SRS coefficient when <a href="geor_ref.htm#GUID-BFA20035-A3A9-41C6-A7B0-DFB014C73F34">SDO_GEOR.georeference</a> is called with the GCPs.</p>
<p>If you have ground control points (GCPs) that are either stored in the GeoRaster object or not, and if you want to calculate the functional fitting georeferencing model, you can call the <a href="geor_ref.htm#GUID-BFA20035-A3A9-41C6-A7B0-DFB014C73F34">SDO_GEOR.georeference</a> procedure to find the solution. The functional fitting georeferencing model stores all coefficients in the GeoRaster SRS and enables the coordinate transformations between cell space and model space. To generate the functional fitting georeferencing model using GCP, you must specify an appropriate geometric model. The specific geometric models supported by <a href="geor_ref.htm#GUID-BFA20035-A3A9-41C6-A7B0-DFB014C73F34">SDO_GEOR.georeference</a> are Affine Transformation, Quadratic Polynomial, Cubic Polynomial, DLT, Quadratic Rational, and RPC. These models are described in <a href="geor_intro.htm#GUID-D07DEFFD-F25A-4D8D-8A94-9AFD05CE4256">Functional Fitting Georeferencing Model</a>.</p>
<div class="example" id="GUID-AA625889-BB88-4633-BECD-E76FAE05EE01__CHDDDIGC">
<p class="titleinexample">Example 5-1 Setting Up the GCP Georeferencing Model</p>
<p>For example, if you have a Landsat image in a plain area and want to georeference it, you might choose the Quadratic Polynomial geometric model. For that purpose, assuming you have collected 9 GCPs (at least 6 GCPs in this case) and 3 check points, you can set up the GCPs and store them in the GeoRaster&#39;s metadata using the code in <a href="geor_image_proc.htm#GUID-AA625889-BB88-4633-BECD-E76FAE05EE01__CHDDDIGC">Example 5-1</a>.</p>
<pre dir="ltr">DECLARE
   gr1         sdo_georaster;
   georefModel SDO_GEOR_GCPGEOREFTYPE;
   GCPs        SDO_GEOR_GCP_COLLECTION;
BEGIN
   SELECT georaster INTO gr1 from georaster_table WHERE georid=1 FOR UPDATE;
   GCPs := SDO_GEOR_GCP_COLLECTION( 
                 SDO_GEOR_GCP(&#39;1&#39;, &#39;&#39;, 1, 
                      2, sdo_number_array(25, 73),
                      2, sdo_number_array(237036.9, 897987.2),
                      NULL, NULL),
                 SDO_GEOR_GCP(&#39;2&#39;, &#39;&#39;, 1, 
                      2, sdo_number_array(100, 459),
                      2, sdo_number_array(237229.6, 897949.7),
                      NULL, NULL),
                 SDO_GEOR_GCP(&#39;3&#39;, &#39;&#39;, 1, 
                      2, sdo_number_array(362, 77),
                      2, sdo_number_array(237038.9, 897818.8),
                      NULL, NULL),
                 SDO_GEOR_GCP(&#39;4&#39;, &#39;&#39;, 1, 
                       2, sdo_number_array(478, 402),
                       2, sdo_number_array(237201.06, 897760.56),
                       NULL, NULL),
                 SDO_GEOR_GCP(&#39;5&#39;, &#39;&#39;, 1, 
                       2, sdo_number_array(167, 64),
                       2, sdo_number_array(237032.02, 897916.26),
                       NULL, NULL),
                 SDO_GEOR_GCP(&#39;6&#39;, &#39;&#39;, 1, 
                       2, sdo_number_array(101, 257),
                       2, sdo_number_array(237128.9, 897949.3),
                       NULL, NULL),
                 SDO_GEOR_GCP(&#39;7&#39;, &#39;&#39;, 1, 
                       2, sdo_number_array(235, 501),
                       2, sdo_number_array(237250.9, 897882.2),
                       NULL, NULL),
                 SDO_GEOR_GCP(&#39;8&#39;, &#39;&#39;, 1, 
                       2, sdo_number_array(423, 214),
                       2, sdo_number_array(237107.3, 897788.0),
                       NULL, NULL),
                 SDO_GEOR_GCP(&#39;9&#39;, &#39;&#39;, 1, 
                       2, sdo_number_array(127, 178),
                       2, sdo_number_array(237089.0, 897936.5),
                       NULL, NULL),
                 SDO_GEOR_GCP(&#39;10&#39;, &#39;&#39;, 2, 
                       2, sdo_number_array(131, 425),
                       2, sdo_number_array(237212.8, 897934.2),
                       NULL, NULL),
                 SDO_GEOR_GCP(&#39;11&#39;, &#39;&#39;, 2, 
                       2, sdo_number_array(299, 111),
                       2, sdo_number_array(237055.7, 897850.4),
                       NULL, NULL),
                 SDO_GEOR_GCP(&#39;12&#39;, &#39;&#39;, 2, 
                       2, sdo_number_array(329, 253),
                       2, sdo_number_array(237126.9,897835.4), 
                       NULL, NULL) );
   georefModel := SDO_GEOR_GCPGEOREFTYPE(&#39;QuadraticPolynomial&#39;, GCPs.count, GCPs, NULL);
   -- Set and store the GCP georeference model into the GeoRaster object&#39;s metadata
   sdo_geor.setGCPGeorefModel(gr1, georefModel);
   UPDATE georaster_table SET georaster=gr1 WHERE georid=1;
   COMMIT;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-AA625889-BB88-4633-BECD-E76FAE05EE01__CHDECJDC">
<p class="titleinexample">Example 5-2 Generating the Functional Fitting Model Using GCPs</p>
<p>After using the code in <a href="geor_image_proc.htm#GUID-AA625889-BB88-4633-BECD-E76FAE05EE01__CHDDDIGC">Example 5-1</a>, you can generate the functional fitting model coefficients by using the code in <a href="geor_image_proc.htm#GUID-AA625889-BB88-4633-BECD-E76FAE05EE01__CHDECJDC">Example 5-2</a>.</p>
<pre dir="ltr">DECLARE
   gr1  sdo_georaster;
   rms  sdo_number_array;
BEGIN
   SELECT georaster INTO gr1 from georaster_table WHERE georid=1 FOR UPDATE;
   -- georeference the image using the GCPs stored in the image&#39;s metadata
   rms := sdo_geor.georeference(gr1, null, 26986, 0, &#39;TRUE&#39;); 
   UPDATE georaster_table SET georaster=gr1 WHERE georid=1;
   COMMIT;
END;
/
</pre>
<p>The steps in <a href="geor_image_proc.htm#GUID-AA625889-BB88-4633-BECD-E76FAE05EE01__CHDDDIGC">Example 5-1</a> and <a href="geor_image_proc.htm#GUID-AA625889-BB88-4633-BECD-E76FAE05EE01__CHDECJDC">Example 5-2</a> can be combined without the need to pre-set the GCPs into the GeoRaster object&#39;s metadata (see the example for <a href="geor_ref.htm#GUID-BFA20035-A3A9-41C6-A7B0-DFB014C73F34">SDO_GEOR.georeference</a> in <a href="geor_ref.htm#GUID-587A19B6-40FF-4F1C-AC13-556891070C30">SDO_GEOR Package Reference</a>). The returned value array of <a href="geor_ref.htm#GUID-BFA20035-A3A9-41C6-A7B0-DFB014C73F34">SDO_GEOR.georeference</a> in <a href="geor_image_proc.htm#GUID-AA625889-BB88-4633-BECD-E76FAE05EE01__CHDECJDC">Example 5-2</a> contains RMS values and residuals for each GCP. Using these, you can examine the solution accuracy and identify erratic GCPs. If the accuracy is not satisfactory, recheck all GCPs to make sure they are accurate and add more GCPs as necessary, and then run the script or scripts again.</p>
<p>The GCP support in GeoRaster enables you to spatially reference any <span class="italic">non</span>-geospatial images and rasters also.</p>
<p>After geospatial images are georeferenced, you can process those images, such as applying rectification, reprojection, and mosaicking, and spatially querying and subsetting the rasters using geometry polygons in different coordinate systems.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="GEORS1327"></a><a id="GEORS1274"></a>
<div class="props_rev_3"><a id="GUID-7AEE808F-F450-41C2-AB4C-AA7D740AF928"></a>
<h2 id="GEORS-GUID-7AEE808F-F450-41C2-AB4C-AA7D740AF928" class="sect2"><span class="enumeration_section">5.2</span> Image Reprojection</h2>
<div>
<p>Image reprojection is the process of transforming an image from one SRS (spatial reference system, or coordinate system) to another. Reprojection is particularly useful with certain GeoRaster operations that combine two or more objects, because it requires that all the GeoRaster objects involved be in the same SRS.</p>
<p>Basic reprojection in GeoRaster is performed by the <a href="geor_ref.htm#GUID-9B3FA7F4-E6CA-4FDB-9DF9-EFEC63C19A55">SDO_GEOR.reproject</a> procedure and requires that the source GeoRaster SRID be different from the output SRID.</p>
<div class="example" id="GUID-7AEE808F-F450-41C2-AB4C-AA7D740AF928__CHDBGHBG">
<p class="titleinexample">Example 5-3 Image Reprojection</p>
<p><a href="geor_image_proc.htm#GUID-7AEE808F-F450-41C2-AB4C-AA7D740AF928__CHDBGHBG">Example 5-3</a> reprojects a raster image that had been loaded into a GeoRaster object with SRID 4326, but needs to be reprojected to have the same SRID as other images previously stored with SRID 23619.</p>
<pre dir="ltr">DECLARE
  gr1 sdo_georaster;
  gr2 sdo_georaster;
BEGIN
  select raster into gr1 from georaster_load_table where georid = 10;
  delete from georaster_table where georid = 54;
  insert into georaster_table 
         values(54,&#39;reprojected&#39;, sdo_geor.init()) 
         returning georaster into gr2;
  sdo_geor.reproject(inGeoRaster   =&gt; gr1,
                     pyramidLevel  =&gt; 0,
                     cropArea      =&gt; null,
                     layerNumbers  =&gt; null,
                     resampleParam =&gt; &#39;resampling=BILINEAR&#39;,
                     storageParam  =&gt; null,
                     outSRID       =&gt; 32619,
                     outGeoraster  =&gt; gr2);
  update georaster_table set georaster = gr2 where georid = 54;
  commit;
END;
</pre>
<p>The same operation can be accomplished by the <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure, producing similar results. The <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure offers more capabilities and flexibility than <a href="geor_ref.htm#GUID-9B3FA7F4-E6CA-4FDB-9DF9-EFEC63C19A55">SDO_GEOR.reproject</a>; for example, the input and output SRID can be the same and users can specify the precise resolution of the output (see <a href="geor_image_proc.htm#GUID-EFDF0FB9-9FFA-4254-997B-1C7D3D7CF897">Image Rectification</a>).</p>
<p>If a GeoRaster object does not have an associated SRS, the process for georeferencing and rectifying it is explained in <a href="basic-georaster-operations.htm#GUID-5E9E62CA-A4CB-4298-9345-0351F60DECC0">Georeferencing GeoRaster Objects</a> and <a href="geor_image_proc.htm#GUID-EFDF0FB9-9FFA-4254-997B-1C7D3D7CF897">Image Rectification</a>.</p>
<p>Parallel reprojection is supported with the <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure. See <a href="geor_image_proc.htm#GUID-8BA68795-65F7-40A6-AD9C-8E774B527176__CHDFEGEF">Example 5-23</a> in <a href="geor_image_proc.htm#GUID-8BA68795-65F7-40A6-AD9C-8E774B527176">Parallel Compression_ Copying_ Subsetting_ Reprojection_ and Rectification</a>.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="GEORS1328"></a><a id="GEORS1275"></a>
<div class="props_rev_3"><a id="GUID-EFDF0FB9-9FFA-4254-997B-1C7D3D7CF897"></a>
<h2 id="GEORS-GUID-EFDF0FB9-9FFA-4254-997B-1C7D3D7CF897" class="sect2"><span class="enumeration_section">5.3</span> Image Rectification</h2>
<div>
<p>Most raster data originating from remote sensors above the ground is usually subject to distortion caused by the terrain, the view angles of the instrument, and the irregular shape of the Earth. Image rectification as explained in this section is the process of transforming the images to reduce some of that distortion.</p>
<p>Rectification is performed by the <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure, and requires that the source GeoRaster object have at least a functional fitting georeferencing model. This means that the image does not need to be rectified, but it needs to have georeference information in the metadata (see <a href="basic-georaster-operations.htm#GUID-5E9E62CA-A4CB-4298-9345-0351F60DECC0">Georeferencing GeoRaster Objects</a>).</p>
<p>The <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure can use the information available in the source GeoRaster object to automatically establish the spatial extents, dimension, and SRID of the output GeoRaster, and users can also specify different values by using the appropriate parameters.</p>
<div class="example" id="GUID-EFDF0FB9-9FFA-4254-997B-1C7D3D7CF897__GUID-B95EF199-B348-4417-AF59-AA520AB727FB">
<p class="titleinexample">Example 5-4 Image Rectification</p>
<p><a href="geor_image_proc.htm#GUID-7AEE808F-F450-41C2-AB4C-AA7D740AF928__CHDBGHBG">Example 5-3</a> rectifies an aerial image that had been loaded into GeoRaster and later georeferenced with GCPs (see <a href="geor_image_proc.htm#GUID-AA625889-BB88-4633-BECD-E76FAE05EE01">Advanced Georeferencing</a>). The image is rectified so that the output GeoRaster object has the same SRS and resolution of an existing GeoRaster object. The image is to be restricted to the area of existing GeoRaster object, and the pixels should be perfectly aligned with the existing GeoRaster object.</p>
<pre dir="ltr">DECLARE
  gr_src sdo_georaster;
  gr_ref sdo_georaster;
  gr_out sdo_georaster;
BEGIN
  select raster into gr_src from georaster_load_table where georid = 15;
  select raster into gr_ref from georaster_table where georid = 1;
  delete from georaster_table where georid = 2;
  insert into georaster_table 
         values(2, &#39;rectified&#39;, sdo_geor.init()) 
         returning georaster into gr_out;
  sdo_geor.rectify(inGeoRaster      =&gt; gr_src,
                   pyramidLevel     =&gt; null,
                   elevationParam   =&gt; null,
                   dem              =&gt; null,
                   outSRID          =&gt; sdo_geor.getModelSRID(gr_ref),
                   outModelCoordLoc =&gt; null,
                   cropArea         =&gt; sdo_geor.generateSpatialExtent(gr_ref),
                   polygonClip      =&gt; null,
                   layerNumbers     =&gt; null,
                   outResolutions   =&gt; sdo_geor.getSpatialResolutions(gr_ref),
                   resolutionUnit   =&gt; &#39;unit=meters&#39;,
                   referencePoint   =&gt; sdo_geor.getModelCoordinate(gr_ref,
                                       0, sdo_number_array(-0.5,-0.5)),
                   resampleParam    =&gt; null,
                   storageParam     =&gt; null,
                   outGeoraster     =&gt; gr_out);
  update georaster_table set georaster = gr_out where georid = 2;
  commit;
END;
</pre>
<p>Rectification output can be significantly improved if information about elevation is passed to the <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure. (See <a href="geor_image_proc.htm#GUID-1EA97BE8-2B6B-4E0E-B89E-57ECD1C33F95">Image Orthorectification</a> for more information about elevation.)</p>
<p>Parallel rectification is supported with the <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure. See <a href="geor_image_proc.htm#GUID-8BA68795-65F7-40A6-AD9C-8E774B527176__CHDFEGEF">Example 5-23</a> in <a href="geor_image_proc.htm#GUID-8BA68795-65F7-40A6-AD9C-8E774B527176">Parallel Compression_ Copying_ Subsetting_ Reprojection_ and Rectification</a>.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="GEORS1276"></a>
<div class="props_rev_3"><a id="GUID-1EA97BE8-2B6B-4E0E-B89E-57ECD1C33F95"></a>
<h2 id="GEORS-GUID-1EA97BE8-2B6B-4E0E-B89E-57ECD1C33F95" class="sect2"><span class="enumeration_section">5.4</span> Image Orthorectification</h2>
<div>
<p>Orthorectification is a rectification transformation process where information about the elevation, the terrain, and the shape of the Earth is used to improve the quality of the output rectified image. Oracle GeoRaster supports single image orthorectification with average height value or DEM.</p>
<p>The orthorectification is done by the <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure and requires that the source GeoRaster have a 3D SRS. The <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure can execute orthorectification with just the average height of the area or with a detailed Digital Elevation Model (DEM).</p>
<p>Related topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="geor_image_proc.htm#GUID-2A0127F1-E83D-4462-B19B-52DB968F1737">Orthorectification with Average Height</a></p>
</li>
<li>
<p><a href="geor_image_proc.htm#GUID-C79FECF7-D80B-4B50-91D6-398D81315C77">Orthorectification with DEM</a></p>
</li>
</ul>
</div>
<a id="GEORS1330"></a><a id="GEORS1329"></a>
<div class="props_rev_3"><a id="GUID-2A0127F1-E83D-4462-B19B-52DB968F1737"></a>
<h3 id="GEORS-GUID-2A0127F1-E83D-4462-B19B-52DB968F1737" class="sect3"><span class="enumeration_section">5.4.1</span> Orthorectification with Average Height</h3>
<div>
<p>A GeoRaster object with a Digital Elevation Model (DEM) is optional for orthorectification. For relatively flat terrains, the 3D SRS together with the average height value might be sufficient to correct the distortion of the source image.</p>
<div class="example" id="GUID-2A0127F1-E83D-4462-B19B-52DB968F1737__CHDEFJEE">
<p class="titleinexample">Example 5-5 Orthorectification with Average Height</p>
<p><a href="geor_image_proc.htm#GUID-2A0127F1-E83D-4462-B19B-52DB968F1737__CHDEFJEE">Example 5-5</a> shows orthorectification with average height. For this example, the source image was acquired from DigitalGlobe with RPC. The DEM was not available, but the average elevation of the area is known to be 1748.0 meters.</p>
<pre dir="ltr">DECLARE
  gr_src  sdo_georaster;
  gr_out  sdo_georaster;
BEGIN
  select georaster into gr_src from georaster_table where georid = 1;
  delete from georaster_table where georid = 3;
  insert into georaster_table values(3, &#39;orthorectified without DEM&#39;,
         sdo_geor.init(&#39;rdt_4&#39;,3)) 
         returning georaster into gr_out;
  sdo_geor.rectify(inGeoRaster      =&gt; gr_src,
                   pyramidLevel     =&gt; null,
                   elevationParam   =&gt; &#39;average=1748.8&#39;,
                   dem              =&gt; null,
                   outSRID          =&gt; 32613,
                   outModelCoordLoc =&gt; null,
                   cropArea         =&gt; null,
                   polygonClip      =&gt; null,
                   layerNumbers     =&gt; null,
                   outResolutions   =&gt; null,
                   resolutionUnit   =&gt; null,
                   referencePoint   =&gt; null,
                   resampleParam    =&gt; &#39;resampling=AVERAGE4&#39;,
                   storageParam     =&gt; null,
                   outGeoraster     =&gt; gr_out);
  update georaster_table set georaster = gr_out where georid = 3;
  commit;
END;
</pre>
<p>In <a href="geor_image_proc.htm#GUID-2A0127F1-E83D-4462-B19B-52DB968F1737__CHDEFJEE">Example 5-5</a>, the <code class="codeph">dem</code> parameter is null, and the <code class="codeph">elevationParam</code> average elevation must be in the same unit as the SRS. Also, in <code class="codeph">elevationParam</code> the <code class="codeph">offset</code> and scale <code class="codeph">keywords</code> are <span class="italic">not</span> specified because they are relevant only if DEM is specified.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="GEORS1332"></a><a id="GEORS1333"></a><a id="GEORS1331"></a>
<div class="props_rev_3"><a id="GUID-C79FECF7-D80B-4B50-91D6-398D81315C77"></a>
<h3 id="GEORS-GUID-C79FECF7-D80B-4B50-91D6-398D81315C77" class="sect3"><span class="enumeration_section">5.4.2</span> Orthorectification with DEM</h3>
<div>
<p>The use of a DEM (Digital Elevation Model) layer improves the accuracy of the rectification process and therefore produces a higher quality output GeoRaster object.</p>
<p>Orthorectification with DEM requires that the source GeoRaster have a 3D SRS. The DEM must cover all the target output area, and it should be in the same SRID as the output. The resolution of the DEM should be similar to the expected resolution of the output GeoRaster object.</p>
<p>For orthorectification with DEM, the <code class="codeph">elevationParam</code> <code class="codeph">average</code> keyword is optional; and if it is not specified, the procedure estimates elevation values based on sample values extracted from the DEM on the target area.</p>
<p>The <code class="codeph">elevationParam</code> <code class="codeph">offset</code> and <code class="codeph">scale</code> values can be used to modify the values from the DEM. For example, <code class="codeph">scale</code> can be used for unit conversion if the DEM values are in a unit other than that of the source GeoRaster SRS, and <code class="codeph">offset</code> can be used to perform geoidal correction or other offsetting. However, these specifications do not apply the changes to DEM values in the GeoRaster object. An alternative is to pre-process the DEM values by applying the scaling and offsetting to the DEM data before the orthorectification, as explained in <a href="geor_raster_algebra.htm#GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B">Raster Data Scaling and Offsetting</a>.</p>
<div class="example" id="GUID-C79FECF7-D80B-4B50-91D6-398D81315C77__CHDCFHEH">
<p class="titleinexample">Example 5-6 Orthorectification with DEM</p>
<p><a href="geor_image_proc.htm#GUID-C79FECF7-D80B-4B50-91D6-398D81315C77__CHDCFHEH">Example 5-6</a> example performs orthorectification with DEM. The DEM covers all the output area in a resolution approximated to the resolution of the output GeoRaster. The DEM values are in meters but the source image SRS is in feet. There is also a geoid correction on that area of about -15.3 meters:</p>
<pre dir="ltr">DECLARE
  gr_src  sdo_georaster;
  gr_dem  sdo_georaster;
  gr_out  sdo_georaster;
BEGIN
  select georaster into gr_src from georaster_table where georid = 1;
  select georaster into gr_dem from georaster_table where georid = 5;
  delete from georaster_table where georid = 6;
  insert into georaster_table values(5, &#39;orthorectified with DEM&#39;,
         sdo_geor.init(&#39;rdt_4&#39;,6)) 
         returning georaster into gr_out;
  sdo_geor.rectify(inGeoRaster      =&gt; gr_src,
                   pyramidLevel     =&gt; null,
                   elevationParam   =&gt; &#39;average=1748.8 offset=-15.3&#39;,
                   dem              =&gt; gr_dem,
                   outSRID          =&gt; 32613,
                   outModelCoordLoc =&gt; null,
                   cropArea         =&gt; null,
                   polygonClip      =&gt; null,
                   layerNumbers     =&gt; null,
                   outResolutions   =&gt; null,
                   resolutionUnit   =&gt; null,
                   referencePoint   =&gt; null,
                   resampleParam    =&gt; &#39;resampling=BILINEAR&#39;,
                   storageParam     =&gt; null,
                   outGeoraster     =&gt; gr_out);
  update georaster_table set georaster = gr_out where georid = 6;
  commit;
END;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-C79FECF7-D80B-4B50-91D6-398D81315C77__CHDCAIHF">
<p class="titleinexample">Example 5-7 Orthorectification with Cropped DEM</p>
<p>Typically, the DEM covers an area much larger than the target area, and the resolution is coarser than the target resolution of the output GeoRaster object. Using this DEM &#34;as is&#34; would result in poor quality orthorectification. The solution to that common problem is to crop the DEM to the target area and rescale it to the desired resolution, as shown in <a href="geor_image_proc.htm#GUID-C79FECF7-D80B-4B50-91D6-398D81315C77__CHDCAIHF">Example 5-7</a>. This example uses the <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure to transform the low-resolution DEM GeoRaster object into a second DEM GeoRaster object that has the same resolution as the orthorectified GeoRaster object generated by the second call to the <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure.</p>
<pre dir="ltr">DECLARE
  height   number := 1748.8;
  gr_src   sdo_georaster;
  gr_out   sdo_georaster;
  gr_dem   sdo_georaster;
  gr_dem2  sdo_georaster;
  gm_area  sdo_geometry;
begin
  select georaster into gr_src from georaster_table where georid = 1;
  select georaster into gr_dem from georaster_table where georid = 2;
  -- Calculate crop area
  gm_area := sdo_cs.make_2d(
             sdo_geor.generateSpatialExtent(gr_src,height),
             sdo_geor.getModelSRID(gr_dem));
  -- Rectify dem ( re-project, crop area, re-escale and resample )
  delete from georaster_table where georid = 4;
  insert into georaster_table values(4, 
              &#39;rectified DEM&#39;,
              sdo_geor.init(&#39;rdt_4&#39;,4)) 
              returning georaster into gr_dem2;
  sdo_geor.rectify(inGeoRaster      =&gt; gr_dem,
                   pyramidLevel     =&gt; null,
                   elevationParam   =&gt; null,
                   dem              =&gt; null,
                   outSRID          =&gt; 32613,
                   outModelCoordLoc =&gt; null,
                   cropArea         =&gt; gm_area,
                   polygonClip      =&gt; null,
                   layerNumbers     =&gt; null,
                   outResolutions   =&gt; sdo_number_array(0.6,0.6),
                   resolutionUnit   =&gt; null,
                   referencePoint   =&gt; null,
                   resampleParam    =&gt; &#39;resampling=CUBIC&#39;,
                   storageParam     =&gt; null,
                   outGeoraster     =&gt; gr_dem2);
  update georaster_table set georaster = gr_dem2 where georid = 4;
  commit;
  -- Orthorectification with DEM
  select georaster into gr_dem2 from georaster_table where georid = 4;
  delete from georaster_table where georid = 5;
  insert into georaster_table 
         values(5, &#39;orthorectified&#39;, sdo_geor.init(&#39;rdt_4&#39;,5)) 
         returning georaster into gr_out;
  sdo_geor.rectify(inGeoRaster      =&gt; gr_src,
                   pyramidLevel     =&gt; null,
                   elevationParam   =&gt; 
                          &#39;average=&#39; || height || &#39; offset=-15.588&#39;,
                   dem              =&gt; gr_dem2,
                   outSRID          =&gt; 32613,
                   outModelCoordLoc =&gt; null,
                   cropArea         =&gt; gm_area,
                   polygonClip      =&gt; null,
                   layerNumbers     =&gt; null,
                   outResolutions   =&gt; sdo_number_array(0.6,0.6),
                   resolutionUnit   =&gt; null,
                   referencePoint   =&gt; null,
                   resampleParam    =&gt; &#39;resampling=average16&#39;,
                   storageParam     =&gt; null,
                   outGeoraster     =&gt; gr_out);
  update georaster_table set georaster = gr_out where georid = 5;
  commit;
end;
/
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="GEORS1334"></a><a id="GEORS1335"></a><a id="GEORS1277"></a>
<div class="props_rev_3"><a id="GUID-E4C18793-CFE6-49CC-8957-6FA9DD99CB7B"></a>
<h2 id="GEORS-GUID-E4C18793-CFE6-49CC-8957-6FA9DD99CB7B" class="sect2"><span class="enumeration_section">5.5</span> Image Scaling</h2>
<div>
<p>Image scaling is the process of enlarging or shrinking an image by changing the pixel size for the row and column dimensions of an image. Image scaling resamples the pixel values from the original image to construct the rescaled version of that image.</p>
<p>One way to perform image scaling is to use the <a href="geor_ref.htm#GUID-3F7A39BD-67FB-40B7-9143-32FA5DFD9628">SDO_GEOR.scaleCopy</a> procedure and specify for <code class="codeph">scaleParam</code> a <code class="codeph">scaleFactor</code> to be applied to the input image dimensions or a <code class="codeph">maxDimSize</code> for the output image.</p>
<p>Another way to perform image scaling is to use the <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> procedure and specify the resolution of the output image.</p>
<p>For both <a href="geor_ref.htm#GUID-3F7A39BD-67FB-40B7-9143-32FA5DFD9628">SDO_GEOR.scaleCopy</a> and <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a>, the <code class="codeph">resampleParam</code> parameter determines the resampling algorithm that will be performed on the input pixels values to determine the values of the output image.</p>
<div class="example" id="GUID-E4C18793-CFE6-49CC-8957-6FA9DD99CB7B__CHDCBFGA">
<p class="titleinexample">Example 5-8 Image Scaling Using SDO_GEOR.scaleCopy</p>
<p><a href="geor_image_proc.htm#GUID-E4C18793-CFE6-49CC-8957-6FA9DD99CB7B__CHDCBFGA">Example 5-8</a> performs rescaling by using <a href="geor_ref.htm#GUID-3F7A39BD-67FB-40B7-9143-32FA5DFD9628">SDO_GEOR.scaleCopy</a> and specifying the <code class="codeph">scaleFactor</code> value as 2. The input image will have 2 times more rows and 2 times more columns than the original, and the values will be resampled by the <code class="codeph">average16</code> algorithm. Note that the image will be 4 times larger than the original.</p>
<pre dir="ltr">DECLARE
  gr_src  sdo_georaster;
  gr_out  sdo_georaster;
BEGIN
  select georaster into gr_src from georaster_table where georid = 7;
  -- Rescale
  delete from georaster_table where georid = 9;
  insert into georaster_table values(9, &#39;re-scaled by scaleCopy&#39;,
              sdo_geor.init(&#39;rdt_4&#39;,9)) 
              returning georaster into gr_out;
  <span class="bold">sdo_geor.scaleCopy</span>(inGeoRaster      =&gt; null,
                     <span class="bold">scaleFactor      =&gt; &#39;scaleFactor=2&#39;</span>,
                     resampleParam    =&gt; &#39;resampling=AVERAGE16&#39;,
                     storageParam     =&gt; null,
                     outGeoraster     =&gt; gr_out);
  update georaster_table set georaster = gr_out where georid = 9;
  commit;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E4C18793-CFE6-49CC-8957-6FA9DD99CB7B__CHDJGFIF">
<p class="titleinexample">Example 5-9 Image Scaling Using SDO_GEOR.rectify</p>
<p><a href="geor_image_proc.htm#GUID-E4C18793-CFE6-49CC-8957-6FA9DD99CB7B__CHDJGFIF">Example 5-9</a> performs rescaling by using <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a> and specifying the <code class="codeph">outResolutions</code> parameter. The input image is already rectified, and the output will have the same SRID as the input.</p>
<pre dir="ltr">DECLARE
  gr_src     sdo_georaster;
  gr_out     sdo_georaster;
BEGIN
  select georaster into gr_src from georaster_table where georid = 7;
  -- Rescale
  delete from georaster_table where georid = 10;
  insert into georaster_table values(10, &#39;re-scaled by rectify&#39;,
              sdo_geor.init(&#39;rdt_4&#39;,10)) 
              returning georaster into gr_out;
  <span class="bold">sdo_geor.rectify</span>(inGeoRaster      =&gt; null,
                   pyramidLevel     =&gt; null,
                   elevationParam   =&gt; null,
                   dem              =&gt; null,
                   outSRID          =&gt; null,
                   outModelCoordLoc =&gt; null,
                   cropArea         =&gt; null,
                   polygonClip      =&gt; null,
                   layerNumbers     =&gt; null,
                   <span class="bold">outResolutions   =&gt; sdo_number_array(1.2,1.2)</span>,
                   resolutionUnit   =&gt; null,
                   referencePoint   =&gt; null,
                   resampleParam    =&gt; &#39;resampling=CUBIC&#39;,
                   storageParam     =&gt; null,
                   outGeoraster     =&gt; gr_out);
  update georaster_table set georaster = gr_out where georid = 10;
  commit;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="GEORS1337"></a><a id="GEORS1338"></a><a id="GEORS1336"></a>
<div class="props_rev_3"><a id="GUID-1BFCB081-6C19-4727-B07E-1127515D75CD"></a>
<h2 id="GEORS-GUID-1BFCB081-6C19-4727-B07E-1127515D75CD" class="sect2"><span class="enumeration_section">5.6</span> Image Stretching</h2>
<div>
<p>Simple and linear image stretching can enhance the image color or contrast. To perform image stretching, use the <a href="geor_ra_ref.htm#GUID-BB7A762E-E615-43AD-9D74-5E917D29F333">SDO_GEOR_RA.rasterMathOp</a> procedure.</p>
<div class="example" id="GUID-1BFCB081-6C19-4727-B07E-1127515D75CD__CHDGCIGA">
<p class="titleinexample">Example 5-10 Image Stretching Using Known Min and Max Cell Values</p>
<p><a href="geor_image_proc.htm#GUID-1BFCB081-6C19-4727-B07E-1127515D75CD__CHDGCIGA">Example 5-10</a> uses known or pregenerated minimum and maximum cell values to enhance the contrast of a three-band image by linear stretching.</p>
<pre dir="ltr">DECLARE
     gr1 sdo_georaster; -- source 3-band image
     gr2 sdo_georaster; -- output 3-band image
BEGIN
     select georaster into gr1 from georaster_table where georid = 1;
     select georaster into gr2 from georaster_table where georid = 2 for update;
     -- Assume the min and max cell values are (17, 163), (14, 150), and (10, 148) for the bands.
     sdo_geor_ra.rasterMathOp(gr1,
                 SDO_STRING2_ARRAY(
                              &#39;255/(163-17)*({0}-17)&#39;,
                              &#39;255/(150-14)*({1}-14)&#39;,
                              &#39;255/(148-10)*({2}-10)&#39;),
                 &#39;celldepth=8BIT_U&#39;, gr2);
     update georaster_table set georaster = gr2 where georid = 2;
     commit;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-1BFCB081-6C19-4727-B07E-1127515D75CD__CHDBFFDG">
<p class="titleinexample">Example 5-11 Image Stretching Using Dynamically Generated Min and Max Cell Values</p>
<p><a href="geor_image_proc.htm#GUID-1BFCB081-6C19-4727-B07E-1127515D75CD__CHDBFFDG">Example 5-11</a> dynamically analyzes the statistical minimum and maximum pixel values for each band of an image, and generates the <code class="codeph">arithmeticExpr</code> parameter value for the <a href="geor_ra_ref.htm#GUID-BB7A762E-E615-43AD-9D74-5E917D29F333">SDO_GEOR_RA.rasterMathOp</a> procedure, which then linearly stretches all bands of the image to the range of (0, 255).</p>
<pre dir="ltr">DECLARE
       i integer;
       bands  number;
       gr1 sdo_georaster;
       gr2 sdo_georaster;
       stmt varchar2(5024);
       mmax number;
       mmin number;
       str varchar2(664);
       win SDO_NUMBER_ARRAY;
BEGIN
       select georaster into gr1 from georaster_table where georid = 1;
       select georaster into gr2 from georaster_table where georid = 2 for update;
       i:=0;
       bands:=SDO_GEOR.getBandDimSize(gr1);
       stmt:=&#39;&#39;;
       LOOP
            str:=to_char(i);
            mmax:=sdo_geor.generateStatisticsMax(gr1,0,&#39;samplingFactor=1&#39;,win,str);
            mmin:=sdo_geor.generateStatisticsMin(gr1,0,&#39;samplingFactor=1&#39;,win,str);
            stmt:=stmt ||
                        &#39;&#39;&#39;255/((&#39; ||trim(to_char(mmax,&#39;990.999&#39;))|| &#39;)-(&#39; ||trim(to_char(mmin,&#39;990.999&#39;))|| &#39;))*({&#39; ||trim(to_char( i,&#39;999&#39; ))|| &#39;} -(&#39;  ||trim(to_char(mmin,&#39;990.999&#39;))|| &#39;))&#39;&#39;&#39;;
            IF(i&lt;(bands-1))
            THEN
                    stmt:=stmt||&#39;,&#39;;
            END if;
            i := i + 1;
            IF i &gt;=bands
            THEN   EXIT;
            END IF;
       END LOOP; 
       stmt := &#39;call sdo_geor_ra.rasterMathOp(:1,SDO_STRING2_ARRAY(&#39;||stmt||&#39;),&#39;||              
                     &#39;&#39;&#39;celldepth=8BIT_U&#39;&#39;,:2)&#39;;
       execute immediate stmt using gr1,in out gr2;
       dbms_output.put_line(stmt);
       update georaster_table set georaster = gr2 where georid = 2;
       commit;
END;
/
</pre>
<p><a id="d20348e838" class="indexterm-anchor"></a><a id="d20348e840" class="indexterm-anchor"></a>The algorithm used in <a href="geor_image_proc.htm#GUID-1BFCB081-6C19-4727-B07E-1127515D75CD__CHDGCIGA">Example 5-10</a> and <a href="geor_image_proc.htm#GUID-1BFCB081-6C19-4727-B07E-1127515D75CD__CHDBFFDG">Example 5-11</a> is called a <span class="italic">min-max stretch</span>. For color images another linear stretch algorithm, called a <span class="italic">normalization stretch</span>, provides better contrast enhancement. A normalization stretch uses a specified mean and standard deviation, but otherwise is done in a manner similar to these examples.</p>
<p>The same approach as in these examples can be used to stretch rasters in higher or lower cell depth, such a DEM in 32-bit integer or a temperature layer in 64-bit float, to the range of (0, 255) so that such rasters can be displayed properly.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="GEORS1339"></a>
<div class="props_rev_3"><a id="GUID-21CA4981-4DFB-4918-BC1F-13803AFEAD28"></a>
<h2 id="GEORS-GUID-21CA4981-4DFB-4918-BC1F-13803AFEAD28" class="sect2"><span class="enumeration_section">5.7</span> Image Segmentation</h2>
<div>
<p>Segmentation is a simple type of classification algorithm, and can be useful in classifying certain types of images into larger ground feature categories, such as land, cloud, water, or snow.</p>
<p><a id="d20348e886" class="indexterm-anchor"></a>You can use the <a href="geor_ra_ref.htm#GUID-D9DA6608-7D97-4428-B1B2-002C371846E9">SDO_GEOR_RA.classify</a> procedure to apply thresholding to images. <span class="bold">Thresholding</span> is the simplest segmentation, which classifies an image into two categories by using a single cell value as the threshold. The resulting image has only two values and can be cast into a binary bitmap mask directly in the same process.</p>
<p>You can also apply more image segmentation operations using the <a href="geor_ra_ref.htm#GUID-D9DA6608-7D97-4428-B1B2-002C371846E9">SDO_GEOR_RA.classify</a> procedure, by first applying arithmetic operations on multiple bands and then classifying the results into a number of categories.</p>
<p>For examples of using the <a href="geor_ra_ref.htm#GUID-D9DA6608-7D97-4428-B1B2-002C371846E9">SDO_GEOR_RA.classify</a> procedure, see <a href="geor_raster_algebra.htm#GUID-57DE5ACD-7DE9-4871-9DF0-CC685DF5114E">Classification Operations</a>.</p>
</div>
</div>
<a id="GEORS1341"></a><a id="GEORS1342"></a><a id="GEORS1340"></a>
<div class="props_rev_3"><a id="GUID-9935029B-2ED5-4A7B-9157-336AD5F57D77"></a>
<h2 id="GEORS-GUID-9935029B-2ED5-4A7B-9157-336AD5F57D77" class="sect2"><span class="enumeration_section">5.8</span> Image Pyramiding: Parallel Generation and Partial Update</h2>
<div>
<p>Image pyramiding is one of the most commonly used processes in building large-scale image databases. This section discusses some related techniques: pyramid generation in parallel, partial updating of pyramids, and batch and concurrent processing.</p>
<p>For working more efficiently with pyramids, you can generate pyramids in parallel and perform a partial update of a pyramid. (This section assumes you understand the concepts explained in <a href="geor_intro.htm#GUID-739D74CC-E256-4E89-AB7F-9251054B9E82">Pyramids</a>.)</p>
<div class="example" id="GUID-9935029B-2ED5-4A7B-9157-336AD5F57D77__CHDDJJHI">
<p class="titleinexample">Example 5-12 Parallel Generation of Pyramids</p>
<p>For faster pyramid generation, you can specify the <code class="codeph">parallelParam</code> parameter with the <a href="geor_ref.htm#GUID-896CB187-FAC1-4A2C-9921-B98AC4E92F3B">SDO_GEOR.generatePyramid</a> procedure. In <a href="geor_image_proc.htm#GUID-9935029B-2ED5-4A7B-9157-336AD5F57D77__CHDDJJHI">Example 5-12</a>, the degree of parallelism is set to 4. (The actual performance improvement for pyramid generation depends on the number of CPUs available to Oracle Database.)</p>
<pre dir="ltr">DECLARE
  gr sdo_georaster;
BEGIN
 
  SELECT georaster INTO gr 
    FROM georaster_table WHERE georid = 6 FOR UPDATE;
 
  -- Generate pyramids.
  sdo_geor.generatePyramid(gr, &#39;rLevel=5, resampling=NN&#39;, null, <span class="bold">&#39;parallel=4&#39;</span>);
 
  -- Update the original GeoRaster object.
  UPDATE georaster_table SET georaster = gr WHERE georid = 6;
 
  COMMIT;
END;
/
</pre>
<p>To enable parallel processing of the pyramid generation, <a href="geor_ref.htm#GUID-896CB187-FAC1-4A2C-9921-B98AC4E92F3B">SDO_GEOR.generatePyramid</a> performs an implicit commit operation. If an error during the call, the GeoRaster object may in an invalid state. If this occurs, use <a href="geor_ref.htm#GUID-351B293B-CE47-45E0-92F0-DC7A52D84FDF">SDO_GEOR.deletePyramid</a> to remove the newly generated and upper pyramid levels of the GeoRaster object.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-9935029B-2ED5-4A7B-9157-336AD5F57D77__CHDIABFI">
<p class="titleinexample">Example 5-13 Partial Updating of Pyramids</p>
<p>You can partially update pyramids by using the <a href="geor_ref.htm#GUID-ED3D72BF-B5C4-46B1-832C-287BF7696B3E">SDO_GEOR.updateRaster</a> procedure. In <a href="geor_image_proc.htm#GUID-9935029B-2ED5-4A7B-9157-336AD5F57D77__CHDIABFI">Example 5-13</a>, the target GeoRaster object at a specified area (<code class="codeph">targetArea</code> is specified as <code class="codeph">area</code>) is updated by another GeoRaster object. The <code class="codeph">updateUpperPyramids</code> parameter is set to <code class="codeph">true</code>, so the upper pyramids of the target GeoRaster object are only partially updated at the specified area. In other words, the upper pyramid levels are not regenerated in full, but only the cells in that targetArea are regenerated, and thus performance is improved.</p>
<pre dir="ltr">DECLARE
  gr1 sdo_georaster;
  gr2 sdo_georaster;
  area sdo_number_array := sdo_number_array(-200,-50,201,162);
BEGIN
  SELECT georaster INTO gr2 FROM georaster_table WHERE georid=0 FOR UPDATE;
  SELECT georaster INTO gr1 FROM georaster_table WHERE georid=1;
  SDO_GEOR.updateRaster(gr2, 0, null, <span class="bold">area</span>, gr1, 0, null, <span class="bold">&#39;true&#39;</span>);
  UPDATE GEORASTER_TABLE SET georaster=gr2 WHERE georid=0;
  COMMIT;
END;
/
</pre>
<p>Other techniques to speed up and automate the pyramiding process include batch processing and concurrent processing can be used. To batch pyramid many images in a certain area, see the example in <a href="basic-georaster-operations.htm#GUID-13578486-979A-410B-94BB-863DBB4AA7E2">Querying and Searching GeoRaster Objects</a>. To process many batches concurrently, you can start different database sessions</p>
</div>
<!-- class="example" --></div>
</div>
<a id="GEORS1344"></a><a id="GEORS1343"></a>
<div class="props_rev_3"><a id="GUID-60EC1E32-9E68-4E4D-8FFE-54A8A19A07EE"></a>
<h2 id="GEORS-GUID-60EC1E32-9E68-4E4D-8FFE-54A8A19A07EE" class="sect2"><span class="enumeration_section">5.9</span> Bitmap Pyramiding</h2>
<div>
<p>For most raster data types, image pyramiding as described in <a href="geor_image_proc.htm#GUID-9935029B-2ED5-4A7B-9157-336AD5F57D77">Image Pyramiding: Parallel Generation and Partial Update</a> results in pyramids of great quality. However, for bitmap rasters of points, lines, or polylines, which are typically stored in 1-bit cell depth, the same pyramiding approach may not create high-quality pyramids. Distorted point patterns and dashed lines are commonly seen in those pyramids.</p>
<p>To solve such problems, you can use the GeoRaster raster algebra to perform bitmap pyramiding. This approach significantly improves the pyramid quality by avoiding distorted patterns, particularly dashed lines or missing lines in a bitmap raster, such as a road raster map or utility network raster map. It stores the original raster and full pyramids back into 1-bit cell depth (instead of 8-bit), and thus does not inflate the data or waste any disk space.</p>
<p><a href="geor_image_proc.htm#GUID-60EC1E32-9E68-4E4D-8FFE-54A8A19A07EE__CHDFAFDJ">Example 5-14</a> shows how to generate high-quality pyramids for bitmap raster. Comments in the example explain the major logical steps.</p>
<div class="example" id="GUID-60EC1E32-9E68-4E4D-8FFE-54A8A19A07EE__CHDFAFDJ">
<p class="titleinexample">Example 5-14 Bitmap Pyramiding</p>
<pre dir="ltr">DECLARE 
  geor1  SDO_GEORASTER; -- source bitmap raster
  geor2  SDO_GEORASTER; -- temporary raster
  geor3  SDO_GEORASTER; -- resultant bitmap raster with fully pyramids generated
BEGIN
  -- The original 1bit raster with lines/roads value 0 and background value 1
  select georaster into geor1 
       from georaster_table where georid = 22;
 
  -- Step 1: Cast to 8bit raster while mapping 0 (roads) to 255 and 1 (bkgrd) to 0
  delete from georaster_table where georid = 21;
  insert into georaster_table values (21, null, sdo_geor.init(&#39;RDT_1&#39;,21));
  select georaster into geor2 
    from georaster_table where georid = 21 for update;
  sdo_geor_ra.classify(
        geor1,
        &#39;{0}&#39;,
        SDO_NUMBER_ARRAY(1),
        SDO_NUMBER_ARRAY(255, 0),
        &#39;celldepth = 8BIT_U&#39;, 
        geor2);
 
  -- Step 2: Generate pyramids on the 8bit raster.
  sdo_geor.generatePyramid(geor2, &#39;rLevel=15, resampling=bilinear&#39;);
 
  -- Step 3, Map value to either 0 or 1. 
  -- Depending on the source raster, adjust value 253 to a different number to improve qualtiy.
  sdo_geor_ra.rasterUpdate(
         geor2,
         null,-- update the raster&#39;s full pyramid as well
         SDO_STRING2_ARRAY(&#39;{0}&lt;253&#39;,&#39;{0}&gt;=253&#39;),
         SDO_STRING2_ARRAYSET(SDO_STRING2_ARRAY(&#39;0&#39;),SDO_STRING2_ARRAY(&#39;1&#39;)));
 
  -- Step 4, Cast back to 1bit raster with full pyramids.
  delete from georaster_table where georid = 20;
  insert into georaster_table values (20, null, sdo_geor.init(&#39;RDT_1&#39;,20));
  select georaster into geor3 
         from georaster_table where georid = 20 for update;
  sdo_geor.changeFormatCopy(geor2, &#39;celldepth=1BIT pyramid=true&#39;, geor3);
 
  -- Step 5, Optionally add a good colormap for the 1bit raster to display roads as white.
  sdo_geor.setColorMap(geor3, 1, 
         sdo_geor_colormap(sdo_number_array(0, 1),
                        sdo_number_array(0, 255),
                        sdo_number_array(0, 255),
                        sdo_number_array(0, 255),
                        sdo_number_array(255, 255)));
 
  -- Commit the resultant raster, which can be used to overwrite the original raster after quality checking.
  UPDATE georaster_table SET georaster = geor3 WHERE georid=20;
  COMMIT;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="GEORS1346"></a><a id="GEORS1345"></a>
<div class="props_rev_3"><a id="GUID-C2D99D00-071F-4BBC-A0A5-50C6F0FAF355"></a>
<h2 id="GEORS-GUID-C2D99D00-071F-4BBC-A0A5-50C6F0FAF355" class="sect2"><span class="enumeration_section">5.10</span> Vegetation Index Computation</h2>
<div>
<p>In remote sensing, the Normalized Difference Vegetation Index (NDVI) is a widely used vegetation index, enabling users to quickly identify vegetated areas and monitor the growth and &#34;condition&#34; of plants. Using Landsat TM imagery, the standard NDVI computation formula is: (TM4 - TM3) / (TM4 + TM3).</p>
<div class="example" id="GUID-C2D99D00-071F-4BBC-A0A5-50C6F0FAF355__CHDICBDG">
<p class="titleinexample">Example 5-15 Vegetation Index Computation</p>
<p><a href="geor_image_proc.htm#GUID-C2D99D00-071F-4BBC-A0A5-50C6F0FAF355__CHDICBDG">Example 5-15</a> takes a Landsat 7 ETM+ image and computes the NDVI, which is stored as another raster of floating number data type. Note that in the GeoRaster algebra language, band numbering starts with 0, so the formula translates into the expression: ({3}-{2})/({3}+{2}).</p>
<pre dir="ltr">DECLARE 
  geor1    SDO_GEORASTER; 
  geor2    SDO_GEORASTER; 
EBGIN
  -- Source ETM+ image
  select georaster into geor1 from georaster_table where georid = 2; 
  -- Store NDVI 
  select georaster into geor2 from georaster_table where georid = 3 for update; 
  sdo_geor_ra.rasterMathOp(geor1,
       SDO_STRING_ARRAY(&#39;({3}-{2})/({3}+{2})&#39;),
       &#39;celldepth=32bit_real&#39;,geor2);
  update georaster_table set georaster = geor2 where georid = 3;
  commit;
end;
/
</pre>
<p>In addition to NDVI, there are many other vegetation indexes in the area of remote sensing. Many of these can be similarly computed using the GeoRaster raster algebra.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="GEORS1348"></a><a id="GEORS1347"></a>
<div class="props_rev_3"><a id="GUID-2530F5D2-7386-4DD4-877A-F004F2109912"></a>
<h2 id="GEORS-GUID-2530F5D2-7386-4DD4-877A-F004F2109912" class="sect2"><span class="enumeration_section">5.11</span> Tasseled Cap Transformation</h2>
<div>
<p>Tasseled Cap Transformation (TCT) is a useful tool for analyzing physical ground features using remotely sensed imagery. With various Landsat imagery, it uses 5 bands of either original digital number (DN) or reflectance data to generate 6 new bands, each of which represents different ground features. The 6 resulting bands are generally called (soil) brightness, (vegetation) greenness, (soil and canopy) wetness, haze, TC5, and TC6. Each one or a combination of them is useful for different applications, such as crop growth monitoring and analysis, biomass study, and agriculture planning.</p>
<div class="example" id="GUID-2530F5D2-7386-4DD4-877A-F004F2109912__CHDGFEHH">
<p class="titleinexample">Example 5-16 Tasseled Cap Transformation</p>
<p><a href="geor_image_proc.htm#GUID-2530F5D2-7386-4DD4-877A-F004F2109912__CHDGFEHH">Example 5-16</a> takes the DN data of a Landsat 5 TM image as input, executes the TCT using the GeoRaster raster algebra, and creates a new image holding the results.</p>
<pre dir="ltr">declare
    gr1 sdo_georaster;
    gr2 sdo_georaster;
    ret varchar2(32);
begin
    select georaster into gr1 from georaster_table where georid = 2;
    select georaster into gr2 from georaster_table where georid = 4 for update;
    sdo_geor_ra.rasterMathOp(
      gr1,
      SDO_STRING2_ARRAY(
         &#39;0.3561*{0}+0.3972*{1}+0.3904*{2}+0.6966*{3}+0.2286*{4}+0.1596*{6}&#39;,
         &#39;(-0.3344)*{0}-0.3544*{1}-0.4556*{2}+0.6966*{3}-0.0242*{4}-0.2630*{6}&#39;,
         &#39;0.2626*{0}+0.2141*{1}+0.0926*{2}+0.0656*{3}-0.7629*{4}-0.5388*{6}&#39;,
         &#39;0.0805*{0}-0.0498*{1}+0.1950*{2}-0.1327*{3}+0.5752*{4}-0.7775*{6}&#39;,
         &#39;(-0.7252)*{0}-0.0202*{1}+0.6683*{2}+0.0631*{3}-0.1494*{4}-0.0274*{6}&#39;,
         &#39;0.4000*{0}-0.8172*{1}+0.3832*{2}+0.0602*{3}-0.1095*{4}+0.0985*{6}&#39; ),
      &#39;celldepth=32BIT_REAL&#39;,
      gr2); 
    update georaster_table set georaster = gr2 where georid = 4;
    commit;
end;
/
</pre>
<p>You can also use the same raster algebra language to add code in <a href="geor_image_proc.htm#GUID-2530F5D2-7386-4DD4-877A-F004F2109912__CHDGFEHH">Example 5-16</a> to convert the 32-bit floating number image into an 8-bit integer image and to apply image stretching (described in <a href="geor_image_proc.htm#GUID-1BFCB081-6C19-4727-B07E-1127515D75CD">Image Stretching</a>) on the resulting TCT image to generate a new GeoRaster object for visualization and analysis.</p>
<p>In addition to using the optimized implementation of raster algebra algorithms and the embedded parallel processing, you can further take advantage of the Oracle grid computing infrastructure to quickly compute NDVI or apply TCT on thousands of images stored in the GeoRaster database.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="GEORS1349"></a>
<div class="props_rev_3"><a id="GUID-846AEB51-5BCC-48D6-8B27-8F846F38CC15"></a>
<h2 id="GEORS-GUID-846AEB51-5BCC-48D6-8B27-8F846F38CC15" class="sect2"><span class="enumeration_section">5.12</span> Image Masking</h2>
<div>
<p>To perform image masking, an application can query the GeoRaster database for bitmap masks, retrieve the desired bitmap mask or masks, and apply the masking operation on the target GeoRaster object for the purpose of displaying the object or performing some other processing. A bitmap mask (described in <a href="geor_intro.htm#GUID-20696505-9B9E-4E08-B165-1B23A574BEB3">Bitmap Masks</a>) can be stored as an independent GeoRaster object; it can also be stored as metadata inside a GeoRaster object and be associated with a single band or with the whole GeoRaster object.</p>
<p>You can also perform masking operations inside the database to generate new GeoRaster objects, using the <a href="geor_ref.htm#GUID-A1FF83F0-481F-436C-BA4A-5C0490A4A7ED">SDO_GEOR.mask</a> procedure.</p>
</div>
</div>
<a id="GEORS1351"></a><a id="GEORS1350"></a>
<div class="props_rev_3"><a id="GUID-8BE9EF2F-EAFE-4247-B8CD-50B3AD3A3807"></a>
<h2 id="GEORS-GUID-8BE9EF2F-EAFE-4247-B8CD-50B3AD3A3807" class="sect2"><span class="enumeration_section">5.13</span> Band Merging</h2>
<div>
<p>For image classification, time series analysis, and raster GIS modeling, multiple bands or layers of different GeoRaster objects may need to be merged into a single GeoRaster object. This operation is called band or layer merging in GeoRaster, and can be performed by using the <a href="geor_ref.htm#GUID-859F107A-4D75-4C36-B9FC-690FA202789C">SDO_GEOR.mergeLayers</a> procedure. You can either append specified bands of a source GeoRaster object to a target GeoRaster object or merge different bands from two GeoRaster objects into a new GeoRaster object. By doing this merging or appending iteratively, you can merge an unlimited number of bands into a single GeoRaster object.</p>
<p><a href="geor_image_proc.htm#GUID-8BE9EF2F-EAFE-4247-B8CD-50B3AD3A3807__CHDFDJDE">Example 5-17</a> assumes there are eight GeoRaster objects, each of which contains only one band loaded from a single-band Landsat ETM+ image file in GeoTIFF format. The number of the band in each GeoRaster object is the same as the GEORID column value for the GeoRaster object. The example merges all bands into a single GeoRaster object to create a complete ETM+ scene.</p>
<div class="example" id="GUID-8BE9EF2F-EAFE-4247-B8CD-50B3AD3A3807__CHDFDJDE">
<p class="titleinexample">Example 5-17 Band Merging</p>
<pre dir="ltr">DECLARE
    gr1 sdo_georaster;
BEGIN
    select georaster into gr1 from georaster_table where georid = 1 for update;
    for rec in (select georaster from georaster_table 
                     where georid &gt;= 2 and georid &lt;= 8 
                     order by georid)
    loop
       <span class="bold">sdo_geor.mergelayers(gr1, rec.georaster)</span>;
    end loop;
    update georaster_table set georaster = gr1 where georid = 1;
    commit;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="GEORS1353"></a><a id="GEORS1352"></a>
<div class="props_rev_3"><a id="GUID-EE1AFE0D-730E-49DC-80AF-E99504D14156"></a>
<h2 id="GEORS-GUID-EE1AFE0D-730E-49DC-80AF-E99504D14156" class="sect2"><span class="enumeration_section">5.14</span> Image Appending</h2>
<div>
<p>You can append one image to another image when the two images have the same number of bands. Image appending is useful when the geospatial images are collected at intervals and the captured image later needs to be appended to the existing image to make a large image of the whole spatial area. Image appending is also useful for updating the existing image with a new image.</p>
<p>The <a href="geor_aggr_ref.htm#GUID-D47B17BE-79C2-4610-B75A-D03182FD40FB">SDO_GEOR_AGGR.append</a> procedure implements image appending by partially updating the existing GeoRaster object with another GeoRaster object. If the existing GeoRaster object contains pyramids, the pyramids with blocking are partially updated with the new data.</p>
<p><a href="geor_image_proc.htm#GUID-EE1AFE0D-730E-49DC-80AF-E99504D14156__CHDFIAID">Example 5-18</a> appends one image to another, with pyramids with blocking are updated at the same time. Because the <code class="codeph">appendParam</code> parameter specifies <code class="codeph">&#39;nodata=true&#39;</code>, the NODATA values in the overlapping area are considered transparent.</p>
<div class="example" id="GUID-EE1AFE0D-730E-49DC-80AF-E99504D14156__CHDFIAID">
<p class="titleinexample">Example 5-18 Appending One Image to Another Image</p>
<pre dir="ltr">DECLARE
    gr1 sdo_georaster;
    gr1 sdo_georaster;
BEGIN
     select georaster into gr1 from georaster_table where georid = 1 for update;
     select georaster into gr2 from georaster_table where georid = 2;
     <span class="bold">sdo_geor_aggr.append(gr1, gr2, 0, &#39;nodata=true&#39;)</span>;
     update georaster_table set georaster = gr1 where georid= 1;
     commit;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="GEORS1355"></a><a id="GEORS1357"></a><a id="GEORS1354"></a>
<div class="props_rev_3"><a id="GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA"></a>
<h2 id="GEORS-GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA" class="sect2"><span class="enumeration_section">5.15</span> Large-Scale Image Mosaicking</h2>
<div>
<p>A large geospatial area typically consists of many smaller aerial photographs or satellite images. Large-scale image mosaicking can stitch these small geospatial images into one large image to get a better view of the whole spatial area. GeoRaster provides large-scale mosaicking functions that allow gaps, overlaps, and missing source GeoRaster objects. It supports both rectified and unrectified images. It supports internal reprojection and rectification, common point rules, and simple color balancing. You can also mosaic at a certain pyramid level. This mosaicking process results in a single GeoRaster object, which is also called a <span class="bold">physical mosaic</span> as opposed to <span class="italic">virtual mosaic</span> (For information about virtual mosaic, see <a href="geor_image_proc.htm#GUID-16C91449-1E94-4B3F-9403-EEFE483251AD">Virtual Mosaic</a>).</p>
<p>The <a href="geor_ref.htm#GUID-17F61F94-A06C-41F4-A064-9243C8904F31">SDO_GEOR.mosaic</a> and <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedures provide support for image mosaicking; however, you are strongly encouraged to use <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> because it provides much more advanced features and options, and it is also implemented with parallelism. <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> can take a virtual mosaic, such as a list of GeoRaster tables, a database view with a GeoRaster column, or a REF CURSOR, as the source images.</p>
<p>The <a href="geor_ref.htm#GUID-17F61F94-A06C-41F4-A064-9243C8904F31">SDO_GEOR.mosaic</a> procedure mosaics a set of source GeoRaster images that are rectified, are geospatially aligned under the same SRID, and have the same resolution. The result of the mosaic is another GeoRaster object. If there are overlaps between the source images, the mosaic result will have the last source image&#39;s content at the overlapping area. This procedure works well for preprocessed and perfectly aligned source images.</p>
<p>In the examples in this section, the source images are stored in source GeoRaster tables GRTAB, GRTAB1, and GRTAB2, which are defined with the following columns:</p>
<pre dir="ltr">  (id          NUMBER PRIMARY KEY,
  cloud_cover  NUMBER     -- percentage of cloud coverage 
  last_update  TIMESTAMP  -- GeoRaster object&#39;s last update time
  grobj        SDO_GEORASTER )
</pre>
<p>Oracle Spatial and Graph spatial indexes have been created on the <code class="codeph">spatialExtent</code> attribute of the GeoRaster object in these tables.</p>
<p>In these examples, the mosaicked image is stored in GEORASTER_TABLE, which is defined in <a href="geor_intro.htm#GUID-4B5901B5-879D-4E5F-BE73-2242F3D7CF9D">Storage Parameters</a>.</p>
<div class="example" id="GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA__CHDBHAHJ">
<p class="titleinexample">Example 5-19 SDO_GEOR.mosaic (Table and Column Name)</p>
<p><a href="geor_image_proc.htm#GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA__CHDBHAHJ">Example 5-19</a> shows the <a href="geor_ref.htm#GUID-17F61F94-A06C-41F4-A064-9243C8904F31">SDO_GEOR.mosaic</a> procedure.</p>
<pre dir="ltr">DECLARE
  gr sdo_georaster;
BEGIN
  INSERT INTO georaster_table (georid, georaster) 
      VALUES (12, sdo_geor.init(&#39;rdt_1&#39;))
      RETURNING georaster INTO gr;
  <span class="bold">sdo_geor.mosaic(&#39;grtab&#39;, &#39;grobj&#39;, gr, &#39;blocksize=(512,512,1)&#39;)</span>;
  UPDATE georaster_table SET georaster=gr WHERE id=12;
END;
/
</pre>
<p>In the real world, however, the source images are often collected under different circumstances so as to have different resolutions or large areas of overlap, or using a different georeference system. In such cases, you can use the <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure to mosaic these source images into one uniform mosaicked image. Compared to <a href="geor_ref.htm#GUID-17F61F94-A06C-41F4-A064-9243C8904F31">SDO_GEOR.mosaic</a>, the <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure provides more features and options:</p>
<ul style="list-style-type: disc;">
<li>
<p>The source images do not have to be in the same coordinate system (SRID) and have the same georeferencing information or resolutions.</p>
</li>
<li>
<p>The source images can be mosaicked on a user-specified pyramid level.</p>
</li>
<li>
<p>The source images can be mosaicked on user-specified bands.</p>
</li>
<li>
<p>The output images can have a different coordinate system and resolution than the input images (<code class="codeph">outSRID</code> and <code class="codeph">outResolutions</code> parameters).</p>
</li>
<li>
<p>You have more control on the output of the overlapping area through the <code class="codeph">mosaicParam</code> parameter: <code class="codeph">commonPointRule</code> can specify which cell value to use for the output at the overlapping area, and <code class="codeph">NODATA</code> can indicate whether to consider the NODATA value at the overlapping area.</p>
</li>
<li>
<p>The output mosaicked image can be aligned at a specified point (the reference point). The source image can be resampled in order to align with the reference point if the source image is out of alignment more than the <code class="codeph">resampleTolerance</code> value specified in <code class="codeph">mosaicParam</code>.</p>
</li>
<li>
<p>If there is small gap between the source images that is less than 2 pixels wide, it can be filled using the neighboring pixel values when <code class="codeph">fillGap</code> is <code class="codeph">true</code> in <code class="codeph">mosaicParam</code>.</p>
</li>
<li>
<p>Limited color balancing (linear stretching and normalization) is supported.</p>
</li>
<li>
<p>Parallel processing is supported to speed up the mosaicking process.</p>
</li>
</ul>
</div>
<!-- class="example" -->
<div class="example" id="GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA__CHDCDABA">
<p class="titleinexample">Example 5-20 SDO_GEOR_AGGR.mosaicSubset</p>
<p><a href="geor_image_proc.htm#GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA__CHDCDABA">Example 5-20</a> uses <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> to mosaic all the source images from two GeoRaster tables (GRTAB1 and GRTAB2) into a large mosaicked image in SRID 4326 with a resolution of 30 meters on the x and y dimensions.</p>
<pre dir="ltr">DECLARE
  resolutions sdo_number_array;
  gr sdo_georaster;
BEGIN
    insert into georaster_table (georid, georaster)
        values (10, sdo_geor.init(&#39;RDT_1&#39;,10))
         returning georaster into gr;
 
    <span class="bold">resolutions := sdo_number_array(30, 30)</span>;
    <span class="bold">sdo_geor_aggr.mosaicSubset(&#39;grtab1, grtab2&#39;, &#39;grobj, grobj&#39;,</span>
                               <span class="bold">0, 4326, null, null, null,</span>
                               <span class="bold">null, null, null, resolutions, &#39;unit=meter&#39;,</span>
                               <span class="bold">&#39;commonPointRule = end, nodata=true, resampleTolerance=0.2, resampling=bilinear, fillGap=true&#39;,</span>
                               <span class="bold">&#39;blocksize=(512, 512, 3)&#39;, gr, null, &#39;parallel=4&#39;)</span>;
 
      update georaster_table set georaster = gr where georid=10;
      commit;                                                              
END;
/
</pre>
<p>In <a href="geor_image_proc.htm#GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA__CHDCDABA">Example 5-20</a>:</p>
<ul style="list-style-type: disc;">
<li>
<p>Any source image that is not rectified is rectified; any source image that is not in SRID 4326 is reprojected to SRID 4326.</p>
</li>
<li>
<p>Any source image that has a resolution other than 30 meters is scaled to a resolution of 30 meters.</p>
</li>
<li>
<p>The <code class="codeph">nodata</code> keyword in the <code class="codeph">mosaicParam</code> parameter is specified as <code class="codeph">true</code>, which means the NODATA values in the overlapping area are not considered.</p>
</li>
<li>
<p>The <code class="codeph">resampleTolerance</code> keyword in the <code class="codeph">mosaicParam</code> parameter is specified as 0.2, which means that if the source image is offset from the target by more than 0.2 pixel, the source image is resampled.</p>
</li>
<li>
<p>The resampling method is specified as <code class="codeph">bilinear</code> in the <code class="codeph">mosaicParam</code> parameter.</p>
</li>
<li>
<p>The degree of parallelism is specified as 4 in the <code class="codeph">parallelParam</code> parameter.</p>
</li>
</ul>
<p>You can call <a href="geor_aggr_ref.htm#GUID-517B4271-BF48-45C3-B989-88EE40CF780A">SDO_GEOR_AGGR.validateForMosaicSubset</a> before calling <a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a> to make sure that the source images can be mosaicked.</p>
</div>
<!-- class="example" --></div>
<a id="GEORS1388"></a><a id="GEORS1389"></a><a id="GEORS1390"></a><a id="GEORS1380"></a>
<div class="props_rev_3"><a id="GUID-8BA68795-65F7-40A6-AD9C-8E774B527176"></a>
<h3 id="GEORS-GUID-8BA68795-65F7-40A6-AD9C-8E774B527176" class="sect3"><span class="enumeration_section">5.15.1</span> Parallel Compression, Copying, Subsetting, Reprojection, and Rectification</h3>
<div>
<p>The <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure can take a single GeoRaster object as input. You can use this procedure to conduct several types of parallel operations, including parallel compression and decompression, parallel copying or change format copying, parallel subsetting, parallel reprojection, and parallel rectification. This section gives some examples for these operations. In all these cases, the <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure works on single GeoRaster objects.</p>
<p>To illustrate the parallelized operations, the examples in this section use a null value for most parameters. In your applications, you can apply all other parameters of the <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure; however, the <code class="codeph">mosaicParam</code> parameter has no effect when the input is a single GeoRaster object.</p>
<div class="example" id="GUID-8BA68795-65F7-40A6-AD9C-8E774B527176__CHDEDHCE">
<p class="titleinexample">Example 5-21 Parallel Compression</p>
<p><a href="geor_image_proc.htm#GUID-8BA68795-65F7-40A6-AD9C-8E774B527176__CHDEDHCE">Example 5-21</a> shows parallel compression using the <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure. This applies to both DEFLATE and JPEG compression and decompression.</p>
<pre dir="ltr">DECLARE
  gr sdo_georaster;
  cur sys_refcursor;
  crop_area sdo_geometry := null;
BEGIN
  -- create a new georaster object with georid = 2 
  -- to hold the compressed image
  delete from georaster_table where georid = 2;
  insert into georaster_table(georid, georaster) values (2, 
     sdo_geor.init(&#39;RDT2&#39;, 2)) returning georaster into gr;
 
  -- compress the image with georid = 1 into JPEG using parallel degree of 8 
  open cur for &#39;select georaster from georaster_table where georid = 1&#39;;
  sdo_geor_aggr.mosaicSubset(cur, 0, null, null, null, crop_area, 
                             null, null, null, null, null, null,
                             <span class="bold">&#39;compression=JPEG-F&#39;</span>, gr, null, <span class="bold">&#39;parallel=8&#39;</span>);
 
  update georaster_table set georaster = gr where georid = 2;
  commit;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-8BA68795-65F7-40A6-AD9C-8E774B527176__CHDIAIBB">
<p class="titleinexample">Example 5-22 Parallel Copying</p>
<p><a href="geor_image_proc.htm#GUID-8BA68795-65F7-40A6-AD9C-8E774B527176__CHDIAIBB">Example 5-22</a> shows parallel copying using the <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure.</p>
<pre dir="ltr">DECLARE
  gr sdo_georaster;
  cur sys_refcursor;
  crop_area sdo_geometry := null;
BEGIN
  -- create a new georaster object with georid = 2 to hold the copy
  delete from georaster_table where georid = 2;
  insert into georaster_table(georid, georaster) values (2, 
     sdo_geor.init(&#39;RDT2&#39;, 2)) returning georaster into gr;
 
  -- make a copy of the image with georid = 1 using parallel degree of 8 
  open cur for &#39;select georaster from georaster_table where georid = 1&#39;;
  sdo_geor_aggr.mosaicSubset(cur, 0, null, null, null, crop_area,
                             null, null, null, null, null, null,
                             &#39;pyramid=true&#39;, gr, null, <span class="bold">&#39;parallel=8&#39;</span>);
  update georaster_table set georaster = gr where georid = 2;
  commit;
END;
/
</pre>
<p>In <a href="geor_image_proc.htm#GUID-8BA68795-65F7-40A6-AD9C-8E774B527176__CHDIAIBB">Example 5-22</a>, if you adjust the <code class="codeph">storageParam</code> parameter, it works as a parallelized <a href="geor_ref.htm#GUID-9C8E8AE6-4C33-4813-B94A-A69C6206E8C4">SDO_GEOR.changeFormatCopy</a> operation. If you apply a <code class="codeph">crop_area</code> (instead of using the default value null), it works as a parallelized <a href="geor_ref.htm#GUID-827C49FA-3759-4EC3-8ED5-A9A4E623EEEB">SDO_GEOR.subset</a> operation and can do polygon clipping.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-8BA68795-65F7-40A6-AD9C-8E774B527176__CHDFEGEF">
<p class="titleinexample">Example 5-23 Parallel Rectification or Reprojection</p>
<p><a href="geor_image_proc.htm#GUID-8BA68795-65F7-40A6-AD9C-8E774B527176__CHDFEGEF">Example 5-23</a> shows parallel rectification or reprojection using the <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure. The output resolution must be between 0.75 and 1.5 times the resolution of the specified source pyramid level if this approach for rectification and reprojection is used.</p>
<pre dir="ltr">DECLARE
  gr sdo_georaster;
  cur sys_refcursor;
  crop_area sdo_geometry := null;
  out_res sdo_number_array := sdo_number_array(30, 30);
BEGIN
  -- create a new georaster object with georid = 2 to hold the result
  delete from georaster_table where georid = 2;
  insert into georaster_table(georid, georaster) values (2, 
     sdo_geor.init(&#39;RDT2&#39;, 2)) returning georaster into gr;
 
  -- rectify the image with georid = 1 into SRID 32611 and 
  -- resolution 30 by 30 using parallel degree of 4 
  open cur for &#39;select georaster from georaster_table where georid = 1&#39;;
  sdo_geor_aggr.mosaicSubset(cur, 0, 32611, null, null, crop_area,
                             null, null, null, out_res, null, 
                             &#39;resampling=bilinear&#39;, null, gr, null, 
                             <span class="bold">&#39;parallel=4&#39;</span>);
  update georaster_table set georaster = gr where georid = 2;
  commit;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="GEORS1358"></a>
<div class="props_rev_3"><a id="GUID-16C91449-1E94-4B3F-9403-EEFE483251AD"></a>
<h2 id="GEORS-GUID-16C91449-1E94-4B3F-9403-EEFE483251AD" class="sect2"><span class="enumeration_section">5.16</span> Virtual Mosaic</h2>
<div>
<p>For some applications, mosaicking a collection of images into a single physical mosaic is not necessary or desirable. For example, you might not have enough disk space for storing the mosaic separately or you simply want to save disk space. Another example is if you do not want to keep two identical copies of the same data set but prefer to have the original data set stored as is, such as a DEM data set, yet you want to query over this data set seamlessly. Yet another example is if you want to apply different processing and mosaicking rules for the same region when mosaicking the source images -- a physical mosaic has no such flexibility.</p>
<p>In such cases, instead of mosaicking a set of GeoRaster images into one large GeoRaster image and storing it in a GeoRaster table, you can create a virtual mosaic. A virtual mosaic treats a set of GeoRaster images as one large virtually mosaicked image, without storing it in a GeoRaster table.</p>
<p>In GeoRaster, a <span class="bold">virtual mosaic</span> is defined as any large collection of georeferenced GeoRaster objects, rectified or unrectified, from one or more GeoRaster tables or views that is treated as if it is a single GeoRaster object. Pyramids of virtual mosaic are supported. A virtual mosaic can contain unlimited number of images, and a whole GeoRaster database can be treated as a virtual mosaic. You issue a single call to query the virtual mosaic based on area-of-interest (that is, subsetting or cropping), and you can request the cropped images to be in different coordinate system with different resolutions. On-the-fly transformations with resampling and mosaicking with common point rules, based on user requests, are done internally and automatically during the query processes.</p>
<p>The following are ways to define a virtual mosaic:</p>
<ul style="list-style-type: disc;">
<li>
<p>As a GeoRaster table or a list of GeoRaster tables (see <a href="geor_image_proc.htm#GUID-FF053675-AB0E-47AB-8D33-418B6A153E70">Virtual Mosaic as One or a List of GeoRaster Tables</a>)</p>
</li>
<li>
<p>As a database view with a GeoRaster column (see <a href="geor_image_proc.htm#GUID-BA5D3A32-A095-4A3D-9A1F-364D7248CDD3">Virtual Mosaic as a View with a GeoRaster Column</a>)</p>
</li>
<li>
<p>As a SQL query statement (a cursor) that results in a collection of GeoRaster objects (see <a href="geor_image_proc.htm#GUID-809D9B4C-AEB7-47A2-864A-6881FB3FB6AA">Virtual Mosaic as a SQL Query Statement or a Cursor</a>)</p>
</li>
</ul>
<p>Regardless of how the virtual mosaic is defined, the GeoRaster objects in the GeoRaster tables must have the <code class="codeph">spatialExtent</code> attribute generated or set; otherwise, the <a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a> and <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedures return an empty lob locator or empty GeoRaster object. For general use cases and best query performance, you should always create a spatial index beforehand on the <code class="codeph">spatialExtent</code> attribute.</p>
<p>After a virtual mosaic is defined, you can use these procedures to query or process it:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a> to perform on-the-fly queries over the virtual mosaic</p>
<p>In spatial query of any portion of that virtually mosaicked image, the <a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a> procedure performs the mosaic operation dynamically for the queried area and returns the required result in a BLOB on-the-fly, as if it were subsetting a physically stored mosaicked image.</p>
</li>
<li>
<p><a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> to store the mosaicked subset in the database as a GeoRaster object</p>
<p>The <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> procedure performs the mosaic operation for the queried area and stores the required result in another GeoRaster object persistently</p>
</li>
</ul>
<p>For a typical workflow of using virtual mosaic, see <a href="geor_image_proc.htm#GUID-D785EAD0-F1AD-4F1F-9C4A-AF1C73012B38">Using Virtual Mosaic in Applications</a>, and <a href="geor_image_proc.htm#GUID-F59FD2B5-6E1A-4998-BF3A-2BCE3EE7F49D">Special Considerations for Large-Scale Virtual Mosaic</a> and its related topic <a href="geor_image_proc.htm#GUID-0926A2AC-B835-470D-9D73-B63F745CDA7B">Improving Query Performance Using MIN_X_RES$ and MAX_X_RES$</a>.</p>
</div>
<a id="GEORS1359"></a><a id="GEORS1368"></a>
<div class="props_rev_3"><a id="GUID-FF053675-AB0E-47AB-8D33-418B6A153E70"></a>
<h3 id="GEORS-GUID-FF053675-AB0E-47AB-8D33-418B6A153E70" class="sect3"><span class="enumeration_section">5.16.1</span> Virtual Mosaic as One or a List of GeoRaster Tables</h3>
<div>
<p>A virtual mosaic can be defined as one GeoRaster table or a list of GeoRaster tables. Applications specify each table and its GeoRaster column. In this approach, all GeoRaster objects in the specified GeoRaster columns of those GeoRaster tables are part of the virtual mosaic.</p>
<p><a href="geor_image_proc.htm#GUID-FF053675-AB0E-47AB-8D33-418B6A153E70__CHDIFABC">Example 5-24</a> specifies the source images for virtual mosaicking in a list of GeoRaster tables (GRTAB1, GRTAB2, and GRTAB3, which have the same definitions as GRTAB in <a href="geor_image_proc.htm#GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA">Large-Scale Image Mosaicking</a>).</p>
<div class="example" id="GUID-FF053675-AB0E-47AB-8D33-418B6A153E70__CHDIFABC">
<p class="titleinexample">Example 5-24 Virtual Mosaic as a List of GeoRaster Tables</p>
<pre dir="ltr">DECLARE
  lb blob;
  cropArea sdo_geometry;
  outArea  sdo_geometry := null;
  outWin   sdo_number_array:=null;
  resolutions sdo_number_array;
BEGIN
    dbms_lob.createTemporary(lb, TRUE);
 
     cropArea :=  sdo_geometry(2003, 32610, null,                 
                    sdo_elem_info_array(1, 1003, 3), 
                    sdo_ordinate_array(399180, 4247820, 
                                       496140,4353900) );
      resolutions := sdo_number_array(30, 30);
     sdo_geor_aggr.getMosaicSubset(<span class="bold">&#39;grtab1, grtab2, grtab3&#39;,</span> 
                 <span class="bold">&#39;grobj, grobj, grobj&#39;</span>, 
                 0, 32610, null, null, cropArea,
                 null, null, null, resolutions, null, 
                 &#39;commonPointRule = end, nodata=true&#39;, 
                 lb, outArea, outWin);
    dbms_lob.freeTemporary(lb);
    if outWin is not null then
        dbms_output.put_line(&#39;output window: (&#39; || outWin(1) || &#39;,&#39; || outWin(2) ||&#39;, &#39; || outWin(3) || &#39;, &#39; || outWin(4) || &#39;)&#39;);
    end if;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="GEORS1360"></a><a id="GEORS1369"></a>
<div class="props_rev_3"><a id="GUID-BA5D3A32-A095-4A3D-9A1F-364D7248CDD3"></a>
<h3 id="GEORS-GUID-BA5D3A32-A095-4A3D-9A1F-364D7248CDD3" class="sect3"><span class="enumeration_section">5.16.2</span> Virtual Mosaic as a View with a GeoRaster Column</h3>
<div>
<p>A virtual mosaic can be defined as one database view with a GeoRaster column. Applications specify the view name and its GeoRaster column. In this approach, all GeoRaster objects in the specified GeoRaster column of the view are part of the virtual mosaic. This approach allows you to select the images for the virtual mosaic in complex ways from any number of GeoRaster tables, taking advantage of the spatial index and any other relevant indexes.</p>
<p>You can also define a virtual mosaic as a list combining GeoRaster views and GeoRaster tables.</p>
<p>When a virtual mosaic is defined as a database view, the view can be specified in the <code class="codeph">georasterTableNames</code> parameter when you query it. <a href="geor_image_proc.htm#GUID-BA5D3A32-A095-4A3D-9A1F-364D7248CDD3__CHDGIHDD">Example 5-25</a> queries the virtual mosaic defined as a view. Note that in this example, the queries sort the images based on their creation time and pick the latest (newest) image for the resulting mosaic in the overlapping areas.</p>
<div class="example" id="GUID-BA5D3A32-A095-4A3D-9A1F-364D7248CDD3__CHDGIHDD">
<p class="titleinexample">Example 5-25 Using a View on GeoRaster Tables for Virtual Mosaic</p>
<pre dir="ltr">Create or replace view grview as select * from (
       Select grobj, last_update from grtab1 where cloud_cover=0 union all
       Select grobj, last_update from grtab2 where cloud_cover=0 union all
       Select grobj, last_update from grtab3 ) order by last_update;

DECLARE
  lb blob;
  cropArea sdo_geometry;
  outArea  sdo_geometry := null;
  outWin   sdo_number_array:=null;
  resolutions sdo_number_array;
BEGIN
    dbms_lob.createTemporary(lb, TRUE);
 
     cropArea :=  sdo_geometry(2003, 32610, null,                 
                    sdo_elem_info_array(1, 1003, 3), 
                    sdo_ordinate_array(399180, 4247820, 
                                       496140,4353900) );
      resolutions := sdo_number_array(30, 30);
     sdo_geor_aggr.getMosaicSubset(<span class="bold">&#39;grview&#39;, &#39;grobj&#39;</span>, 
                 0, 32610, null, null, cropArea,
                 null, null, null, resolutions, null, 
                 &#39;commonPointRule = end, nodata=true&#39;, 
                 lb, outArea, outWin);
    dbms_lob.freeTemporary(lb);
    if outWin is not null then
        dbms_output.put_line(&#39;output window: (&#39; || outWin(1) || &#39;,&#39; || outWin(2) ||&#39;, &#39; || outWin(3) || &#39;, &#39; || outWin(4) || &#39;)&#39;);
    end if;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="GEORS1361"></a><a id="GEORS1370"></a>
<div class="props_rev_3"><a id="GUID-809D9B4C-AEB7-47A2-864A-6881FB3FB6AA"></a>
<h3 id="GEORS-GUID-809D9B4C-AEB7-47A2-864A-6881FB3FB6AA" class="sect3"><span class="enumeration_section">5.16.3</span> Virtual Mosaic as a SQL Query Statement or a Cursor</h3>
<div>
<p>Instead of creating a view, you can define a virtual mosaic as a SQL statement or a runtime database cursor, which selects a collection of GeoRaster objects from the database. Applications create the cursor from the SQL statement and use the cursor as the virtual mosaic. In this definition, all GeoRaster objects in the cursor are part of the virtual mosaic. This approach allows you to select the images for the virtual mosaic in complex ways from any number of GeoRaster tables. However, the spatial indexes are not automatically used in queries over this type of virtual mosaic. To take advantage of spatial indexes, dynamically add a spatial query condition directly using the query window to the SQL statement, so that all images in that query window can be more quickly located.</p>
<p>The <a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a> and <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a>procedures accept a cursor of GeoRaster objects as the virtual mosaic, as shown in <a href="geor_image_proc.htm#GUID-809D9B4C-AEB7-47A2-864A-6881FB3FB6AA__CHDHFCBB">Example 5-26</a>. Note that in this example, the queries sort the images based on their creation time and pick the latest (newest) image for the resulting mosaic in the overlapping areas. For best performance when there are many GeoRaster objects in the table, the query of the cursor should use the spatial query window to filter out the unrelated GeoRaster objects, as described in the preceding paragraph.</p>
<div class="example" id="GUID-809D9B4C-AEB7-47A2-864A-6881FB3FB6AA__CHDHFCBB">
<p class="titleinexample">Example 5-26 Using a Cursor for Virtual Mosaic</p>
<pre dir="ltr">DECLARE
  lb blob;
  outArea  sdo_geometry := null;
  outWin   sdo_number_array:=null;
  resolutions sdo_number_array;
  mosaic_stmt  varchar2(1000);
  condition        varchar2(1000);
BEGIN
    dbms_lob.createTemporary(lb, TRUE);
 
    resolutions := sdo_number_array(30, 30);
 
   -- Define the query window (cropArea)
   cropArea := sdo_geometry(2003, 32610, null, 
                           sdo_elem_info_array(1, 1003, 3), 
                           sdo_ordinate_array(399180, 4247820, 496140,4353900) );
 
    -- Define the virtual mosaic
    mosaic_stmt := &#39;select grobj from (select grobj, last_update from grtab1 &#39; ||
                   &#39;where cloud_cover=0  union all select grobj, last_update from grtab2 &#39; ||
                   &#39;where cloud_cover=0) t &#39;;
 
   -- Apply filtering using the query window (cropArea) to speed up query performance
    condition := &#39;where sdo_anyinteract(t.grobj.spatialExtent,:1) = &#39;&#39;true&#39;&#39; &#39; ||
                 &#39; order by last_update&#39;; 
 
   -- Open the virtual mosaic for query
    open cur for mosaic_stmt || condition using cropArea;
 
   -- Query the virtual mosaic (make sure the cropArea used here is the same
   -- as the one used at opening the cursor)
    sdo_geor_aggr.getMosaicSubset(<span class="bold">cur</span>, 
                 0, 32610, null, null, cropArea,
                 null, null, null, resolutions, null, 
                 &#39;commonPointRule=end, nodata=true&#39;, 
                 lb, outArea, outWin);
    dbms_lob.freeTemporary(lb);
    close cur;
    if outWin is not null then
        dbms_output.put_line(&#39;output window: (&#39; || outWin(1) || &#39;,&#39; || outWin(2) ||&#39;, &#39; || outWin(3) || &#39;, &#39; || outWin(4) || &#39;)&#39;);
    end if;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="GEORS1371"></a>
<div class="props_rev_3"><a id="GUID-D785EAD0-F1AD-4F1F-9C4A-AF1C73012B38"></a>
<h3 id="GEORS-GUID-D785EAD0-F1AD-4F1F-9C4A-AF1C73012B38" class="sect3"><span class="enumeration_section">5.16.4</span> Using Virtual Mosaic in Applications</h3>
<div>
<div class="section">
<p>Virtual mosaic can be used as an image serving engine and in a variety of other application scenarios. The definitions of virtual mosaics can be stored by applications separately as strings or other forms. Besides the major query procedures <a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a> and <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a>, GeoRaster provides other subprograms in the SDO_GEOR_AGGR package to facilitate application development:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="geor_aggr_ref.htm#GUID-517B4271-BF48-45C3-B989-88EE40CF780A">SDO_GEOR_AGGR.validateForMosaicSubset</a></p>
</li>
<li>
<p><a href="geor_aggr_ref.htm#GUID-74A098CB-5EC9-406B-9437-FAEDEB012A2C">SDO_GEOR_AGGR.getMosaicExtent</a></p>
</li>
<li>
<p><a href="geor_aggr_ref.htm#GUID-D0BB7FCA-490F-4988-95BD-5DDF49D5B8CF">SDO_GEOR_AGGR.getMosaicResolutions</a></p>
</li>
</ul>
<p><a href="geor_aggr_ref.htm#GUID-517B4271-BF48-45C3-B989-88EE40CF780A">SDO_GEOR_AGGR.validateForMosaicSubset</a>, <a href="geor_aggr_ref.htm#GUID-74A098CB-5EC9-406B-9437-FAEDEB012A2C">SDO_GEOR_AGGR.getMosaicExtent</a>, and <a href="geor_aggr_ref.htm#GUID-D0BB7FCA-490F-4988-95BD-5DDF49D5B8CF">SDO_GEOR_AGGR.getMosaicResolutions</a> can be called in an application to make sure that the virtual mosaic is valid and that the spatial query falls inside the virtual mosaic. The following steps describe a possible workflow for virtual mosaic in an application:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Define a virtual mosaic. For example:</span>
<div>
<pre dir="ltr">Create or replace view grview as select * from (
Select grobj, last_update from grtab1 where cloud_cover=0 union all
Select grobj, last_update from grtab2 where cloud_cover=0 union all
Select grobj, last_update from grtab3 ) order by last_update;
</pre>
<p>Note that tables GRTAB1, GRTAB2, and GRTAB3 were created using the same definition as GRTAB in <a href="geor_image_proc.htm#GUID-992BAEDB-C6EC-4E0E-97AA-C18A59F960FA">Large-Scale Image Mosaicking</a>, and Oracle Spatial and Graph spatial indexes have been created on the <code class="codeph">spatialExtent</code> attribute of the GeoRaster object in these tables.</p>
</div>
</li>
<li class="stepexpand"><span>Validate the virtual mosaic data set. For example:</span>
<div>
<pre dir="ltr">EXECUTE SDO_GEOR_AGGR.validateForMosaicSubset(&#39;grview&#39;, &#39;grobj&#39;, OUTSRID, OUTResolutions);
</pre>
<p>A validation error table can be created and passed to the call if more detailed validation information is needed. See the <a href="geor_aggr_ref.htm#GUID-517B4271-BF48-45C3-B989-88EE40CF780A">SDO_GEOR_AGGR.validateForMosaicSubset</a> reference section for details.</p>
</div>
</li>
<li class="stepexpand"><span>Get the spatial extent of the virtual mosaic. For example:</span>
<div>
<pre dir="ltr">SELECT SDO_GEOR_AGGR.getMosaicExtent(&#39;grview&#39;, &#39;grobj&#39;, OUTSRID) from dual;
</pre></div>
</li>
<li class="stepexpand"><span>Get the resolution range of the existing source images. For example:</span>
<div>
<pre dir="ltr">SELECT SDO_GEOR_AGGR.getMosaicResolutions(&#39;grview&#39;, &#39;grobj&#39;, &#39;unit=meter&#39;) from dual;
</pre>
<p>The resolution range reflects the minimum and maximum resolutions of the source images, including all pyramid levels.</p>
</div>
</li>
<li class="stepexpand"><span>Based on the information acquired in the preceding two steps, pass in the spatial query window <code class="codeph">cropArea</code> and <code class="codeph">OUTResolutions</code> according to the application requests to get a subset of the virtual mosaic and optionally to apply different resampling methods, different common point rules, special nodata handling, and color balancing. For example:</span>
<div>
<pre dir="ltr">SDO_GEOR_AGGR.getMosaicSubset(&#39;grview&#39;, &#39;grobj&#39;, null, OUTSRID, null, null,
  cropArea, null, null, null, OUTResolutions, null, 
  &#39;commonPointRule=end, nodata=true&#39;, lb, outArea, outWin);
</pre>
<p>Note that <code class="codeph">OUTResolutions</code> must be within the source image resolution range. If <code class="codeph">OUTResolutions</code> is the same as the resolutions of the source image at a specified pyramid level, the pyramid data is used in the output mosaic; otherwise, the source image is scaled to the target resolution.</p>
<p>A typical application repeatedly applies this step to query different areas of interest over the same virtual mosaic for image display, image distribution, or other purposes.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="GEORS1376"></a>
<div class="props_rev_3"><a id="GUID-F59FD2B5-6E1A-4998-BF3A-2BCE3EE7F49D"></a>
<h3 id="GEORS-GUID-F59FD2B5-6E1A-4998-BF3A-2BCE3EE7F49D" class="sect3"><span class="enumeration_section">5.16.5</span> Special Considerations for Large-Scale Virtual Mosaic</h3>
<div>
<p>A virtual mosaic can contain just several images, but it can also contain tens of thousands or millions of images. Both <a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a> and <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> automatically search (using native spatial indexes) the virtual mosaic for all images touching or inside the <code class="codeph">cropArea</code> and check the resolutions of those images and their pyramids. Only those images or their appropriate pyramid levels touching or inside the <code class="codeph">cropArea</code> and with their resolutions close to the requested resolution will be used in the mosaicking process. So, the configuration of the source images and their pyramids is critical for the quality of the results and the overall query performance.</p>
<p>The guideline is to avoid too many small images from either different source images or their pyramids in the requested crop areas at the requested resolution.</p>
<p>For a smaller virtual mosaic with only a limited number of images, simply generate full pyramids for each source image, and the query performance will be good for most applications.</p>
<p>For a large area with a larger number of images (more than a few hundred images), the application can generate only a certain number of pyramid levels for each source image, mosaic their top pyramids into new GeoRaster objects, and then generate pyramids for those mosaics, and so forth. For large-scale web visualization projects, all images at source resolutions and at lower resolution levels might be stored as GeoRaster objects without any pyramids built for them.</p>
<p>In these cases (large number of images and large-scale web visualization), if each source image is small and there are many resolution levels in the virtual mosaic, a query on the lower resolution levels would involve metadata resolution queries on many unnecessary images at the higher resolution levels, which slows the query. To improve performance, applications can define many virtual mosaics, each of which includes only all the images at a specific resolution or a few resolution levels. Then, the application finds the right virtual mosaic or mosaics based on the requested resolution as the first step, and then only spatially queries those selected virtual mosaics. This approach can significantly improve performance.</p>
<p>In addition to the preceding considerations, see <a href="geor_image_proc.htm#GUID-0926A2AC-B835-470D-9D73-B63F745CDA7B">Improving Query Performance Using MIN_X_RES$ and MAX_X_RES$</a> for queries where many different resolution levels are involved for the same area.</p>
</div>
<a id="GEORS1377"></a>
<div class="props_rev_3"><a id="GUID-0926A2AC-B835-470D-9D73-B63F745CDA7B"></a>
<h4 id="GEORS-GUID-0926A2AC-B835-470D-9D73-B63F745CDA7B" class="sect4"><span class="enumeration_section">5.16.5.1</span> Improving Query Performance Using MIN_X_RES$ and MAX_X_RES$</h4>
<div>
<div class="section">
<p>A more general solution (instead of defining multiple virtual mosaics) for speeding virtual mosaic queries if there are many different resolution levels involved for the same area is to use the MIN_X_RES$ and MAX_X_RES$ columns in the GeoRaster tables or views. You must define these columns (NUMBER data type) in the GeoRaster tables of a virtual mosaic, where they specify the minimum and maximum spatial resolution values, respectively, of the source GeoRaster object. After these columns are added and populated with correct resolution data, the <a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a> procedure will (if you use the format with the <code class="codeph">georasterTableNames</code> parameter) use the resolution range stored in these columns to filter out the source GeoRaster objects that are not at the requested resolutions as specified in the <code class="codeph">outResolutions</code> parameter. This avoids parsing the metadata of each GeoRaster objects in the <code class="codeph">cropArea</code>, thus significantly improving performance.</p>
<p>To use this approach, follow these steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Add the columns MIN_X_RES$ and MAX_X_RES$ to the GeoRaster tables. For example:</span>
<div>
<pre dir="ltr">ALTER TABLE georaster_table ADD (MIN_X_RES$ number, MAX_X_RES$ number);
</pre></div>
</li>
<li class="stepexpand"><span>Populate the MIN_X_RES$ column. For example:</span>
<div>
<pre dir="ltr">UPDATE georaster_table t 
  SET min_x_res$ = (select column_value from the
    (select sdo_geor.generateSpatialResolutions(t.georaster, null,
    t.georaster.spatialextent.sdo_srid) from dual)
  WHERE rownum=1);
</pre></div>
</li>
<li class="stepexpand"><span>Populate the MAX_X_RES$ column. For example:</span>
<div>
<pre dir="ltr">UPDATE georaster_table t 
  max_x_res$ = min_x_res$ * power(2, sdo_geor.getPyramidMaxLevel(t.georaster));
</pre></div>
</li>
</ol>
<div class="section">
<p>If the virtual mosaic is defined as a view, the view should also have both columns. For example, the view definition in <a href="geor_image_proc.htm#GUID-BA5D3A32-A095-4A3D-9A1F-364D7248CDD3__CHDGIHDD">Example 5-25</a> must be changed to the following:</p>
<pre dir="ltr">Create or replace view grview as select * from ( 
       Select grobj, <span class="bold">min_x_res$, max_x_res$,</span> last_update from grtab1 where cloud_cover=0 union all
       Select grobj, <span class="bold">min_x_res$, max_x_res$,</span> last_update from grtab2 where cloud_cover=0 union all 
       Select grobj, <span class="bold">min_x_res$, max_x_res$,</span> last_update from grtab3 ) 
       order by last_update;
</pre>
<p>After a virtual mosaic is defined as described in this section, applications can query and use it in the same ways as with all other virtual mosaics, but with better performance for large-scale virtual mosaics that involve many resolution levels. For more information, see the <a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a> and <a href="geor_aggr_ref.htm#GUID-85F23FB6-7F4B-40C4-B023-25DE37FA53BF">SDO_GEOR_AGGR.mosaicSubset</a> reference sections.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<a id="GEORS1362"></a>
<div class="props_rev_3"><a id="GUID-639C081E-8E7F-4467-8B89-3363810F561F"></a>
<h2 id="GEORS-GUID-639C081E-8E7F-4467-8B89-3363810F561F" class="sect2"><span class="enumeration_section">5.17</span> Image Serving</h2>
<div>
<p>Serving of image and raster data to clients or applications is supported through many features of the GeoRaster PL/SQL and Java APIs.</p>
<p>Direct image serving includes searching and then subsetting or cropping the rasters (<a href="geor_ref.htm#GUID-CC66F0CA-96A9-4C4F-AB94-AEB5FE53C83D">SDO_GEOR.getRasterSubset</a>), applying reprojection and rectification on-the-fly while cropping the images (<a href="geor_ref.htm#GUID-9B3FA7F4-E6CA-4FDB-9DF9-EFEC63C19A55">SDO_GEOR.reproject</a> and <a href="geor_ref.htm#GUID-FAC58FA1-3707-498F-BC69-7D36C17BDFA1">SDO_GEOR.rectify</a>), and directly exporting to files (<a href="geor_ref.htm#GUID-6261233E-5E90-479C-97FD-8125C28EC838">SDO_GEOR.exportTo</a>).</p>
<p>Virtual mosaic is used mainly, and effectively, to serve an image database to various applications, particularly when you do not want to create large physical mosaics. Virtual mosaic does not require the source images to be preprocessed or mosaicked beforehand. Instead, all images are stored as is, and the whole image data set can be served based on small areas of interest using single calls (<a href="geor_aggr_ref.htm#GUID-89303715-7E1A-46B9-8CDE-0228C48388D7">SDO_GEOR_AGGR.getMosaicSubset</a>) to the server.</p>
<p>Often, one or a series of preprocessing operations are applied to multiple GeoRaster objects to create the resulting GeoRaster object, and then the features described in this section are used on the resulting GeoRaster object to serve the raster data directly to applications. Thus, a rich set of GeoRaster image manipulation and raster algebra capabilities (described in <a href="basic-georaster-operations.htm#GUID-92D80CF0-F503-40BE-B1E6-D06A1DF033B6">Basic GeoRaster Operations</a>, <a href="geor_raster_algebra.htm#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF">Raster Algebra and Analytics</a>, and this chapter) can be incorporated into the workflow to meet complex image serving requirements.</p>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4336">
<tr>
<td class="cellalignment4343">
<table class="cellalignment4341">
<tr>
<td class="cellalignment4340"><a href="geor_raster_algebra.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4340"><a href="geor_ref.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4345">
<table class="cellalignment4339">
<tr>
<td class="cellalignment4340"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4340"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4340"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4340"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4340"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4340"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>