<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-73991"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/OCI%20Programming%20Advanced%20Topics"></a><title>OCI Programming Advanced Topics</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="connection pooling, stateless sessions, stateful sessions, TAF (transparent application failover), in connection pools, connection pools and TAF, code example, session pooling, tagging, functionality, OCIAuthInfo definition, OCI_HTYPE_AUTHINFO, example, Oracle RAC, Oracle Real Application Clusters, runtime connection load balancing, database resident connection pooling, database resident, DRCP (database resident connection pooling), statement caching, OCI_ATTR_STMTCACHESIZE, bind and define in statement caching, code example, user-defined callback functions, callbacks, user-defined functions, registering, user callbacks, dynamic registrations, restrictions, external procedures, OCI callbacks, from external procedures, failover callbacks, transparent application failover, TAF, structure and parameters, registration for transparent application failover, callback registration, failover, callback example, HA event notification, custom pooling, connections enabled by, logical transaction ID (LTXID), Transaction Guard, Transaction Guard, logical transaction ID (LTXID), Oracle Streams Advanced Queuing, OCI and, description, AQ, Oracle Streams Advanced Queuing., OCI functions for, OCI descriptors for, OCI versus PL/SQL, buffered messaging, publish-subscribe notification in OCI, publish-subscribe, notification in OCI, functions, COMPATIBLE parameter, OCI_EVENTS, mode for receiving notifications, subscription handle, handle attributes, handles, subscription, IPv6 addressing, OCI_ATTR_SUBSCR_NAMESPACE, LDAP registration, LDAP registration of publish-subscribe notification, OCI_ATTR_SUBSCR_SERVER_DN, descriptor handle, OCI_SUBSCR_QOS_RELIABLE, OCI_SUBSCR_QOS_PURGE_ON_NTFN, notification callback, _SYSTEM_TRIG_ENABLED parameter"/>
<meta name="dcterms.created" content="2017-06-09T09:07:30Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Call Interface Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49886-11"/>
<meta name="dcterms.isVersionOf" content="LNOCI"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="oci08sca.htm" title="Previous" type="text/html"/>
<link rel="Next" href="oci10new.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49886-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-FD512A09-1A33-424B-AD4D-728956AFDBD8"></a> <span id="PAGE" style="display:none;">16/84</span> <!-- End Header -->
<a id="LNOCI090"></a>
<h1 id="LNOCI-GUID-FD512A09-1A33-424B-AD4D-728956AFDBD8" class="sect1"><span class="enumeration_chapter">9</span> OCI Programming Advanced Topics</h1>
<div>
<p>This chapter contains these topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-1C9A6E8F-EF5A-478D-B65E-CE39D4F00683" title="Connection pooling is the use of a group (the pool) of reusable physical connections by several sessions to balance loads.">Connection Pooling in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C" title="Session pooling means that the application creates and maintains a group of stateless sessions to the database.">Session Pooling in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF" title="Runtime connection load balancing routes work requests to sessions in a session pool that best serve the work.">Runtime Connection Load Balancing</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-1E260CD3-2EF7-49FF-97FC-041C2EF60381" title="Database resident connection pooling (DRCP) provides a connection pool in the database server for typical web application usage scenarios where the application acquires a database connection, works on it for a relatively short duration, and then releases it.">Database Resident Connection Pooling</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-8DD97D4D-C7AA-4EF7-9B55-8DC58BDC2726" title="Indicates the circumstances in which to use them or not.">When to Use Connection Pooling, Session Pooling, or Neither</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-4947CAE8-1F00-4897-BB2B-7F921E495175" title="Statement caching refers to the feature that provides and manages a cache of statements for each session.">Statement Caching in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-215B52BB-6769-4A53-A2DC-EDB36AE031B7" title="Oracle Call Interface can execute user-specific code in addition to OCI calls.">User-Defined Callback Functions in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7" title="Use HA event notification to provide a best-effort programmatic signal to the client if there is a database failure for high availability clients connected to an Oracle RAC database.">HA Event Notification</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F" title="Transaction Guard introduces the concept of at-most-once transaction execution in case of a planned or unplanned outage to help prevent an application upon failover from submitting a duplicate submission of an original submission.">OCI and Transaction Guard</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-FF4165B2-A44C-4F76-AC26-DA860F340CA8" title="OCI provides an interface to the Streams Advanced Queuing (Streams AQ) feature. Streams AQ provides message queuing as an integrated part of Oracle Database.">OCI and Streams Advanced Queuing</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-9CE58707-FC18-492E-8AA9-5314041BCEE4" title="The publish-subscribe notification feature allows an OCI application to receive client notifications directly, register an email address to which notifications can be sent, register an HTTP URL to which notifications can be posted, or register a PL/SQL procedure to be invoked on a notification.">Publish-Subscribe Notification in OCI</a></p>
</li>
</ul>
</div>
<a id="LNOCI16602"></a>
<div class="props_rev_3"><a id="GUID-1C9A6E8F-EF5A-478D-B65E-CE39D4F00683"></a>
<h2 id="LNOCI-GUID-1C9A6E8F-EF5A-478D-B65E-CE39D4F00683" class="sect2">Connection Pooling in OCI</h2>
<div>
<p>Connection pooling is the use of a group (the pool) of reusable physical connections by several sessions to balance loads.</p>
<p>The pool is managed by OCI, not the application. Applications that can use connection pooling include middle-tier applications for web application servers and email servers.</p>
<p>One use of this feature is in a web application server connected to a back-end Oracle database. Suppose that a web application server gets several concurrent requests for data from the database server. The application can create a pool (or a set of pools) in each environment during application initialization.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-C7AB12E8-E640-41F0-9C28-E68F7E683694">OCI Connection Pooling Concepts</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-322FF18E-48AE-4B94-8477-E91127F6BA86" title="Lists the steps you must follow to use connection pooling in your application.">Using OCI Calls for Connection Pooling</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-AE06BCB1-7333-458E-90F0-0761496EC5E1">Examples of OCI Connection Pooling</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16603"></a>
<div class="props_rev_3"><a id="GUID-C7AB12E8-E640-41F0-9C28-E68F7E683694"></a>
<h3 id="LNOCI-GUID-C7AB12E8-E640-41F0-9C28-E68F7E683694" class="sect3">OCI Connection Pooling Concepts</h3>
<div>
<p>Oracle Database has several transaction monitoring capabilities such as the fine-grained management of database sessions and connections. Fine-grained management of database sessions is done by separating the notion of database sessions (user handles) from connections (server handles). By using OCI calls for session switching and session migration, an application server or transaction monitor can multiplex several sessions over fewer physical connections, thus achieving a high degree of scalability by pooling connections and back-end Oracle server processes.</p>
<p>The connection pool itself is normally configured with a shared pool of physical connections, translating to a back-end server pool containing an identical number of dedicated server processes.</p>
<p>The number of physical connections is less than the number of database sessions in use by the application. The number of physical connections and back-end server processes are also reduced by using connection pooling. Thus many more database sessions can be multiplexed.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-3C6F8FF3-195D-4DCB-B684-8102004F4686">Similarities and Differences from a Shared Server</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-11F389B2-7D7A-4188-96AC-438C25139C4D">Stateless Sessions Versus Stateful Sessions</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09">Multiple Connection Pools</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-55F39E75-40EB-464B-AEFB-75FF8ABD0169">Transparent Application Failover</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16604"></a>
<div class="props_rev_3"><a id="GUID-3C6F8FF3-195D-4DCB-B684-8102004F4686"></a>
<h4 id="LNOCI-GUID-3C6F8FF3-195D-4DCB-B684-8102004F4686" class="sect4">Similarities and Differences from a Shared Server</h4>
<div>
<p>Connection pooling on the middletier is similar to what a shared server offers on the back end. Connection pooling makes a dedicated server instance behave like a shared server instance by managing the session multiplexing logic on the middle tier.</p>
<p>The connection pool on the middle tier controls the pooling of dedicated server processes including incoming connections into the dedicated server processes. The main difference between connection pooling and a shared server is that in the latter case, the connection from the client is normally to a dispatcher in the database instance. The dispatcher is responsible for directing the client request to an appropriate shared server. However, the physical connection from the connection pool is established directly from the middletier to the dedicated server process in the back-end server pool.</p>
<p>Connection pooling is beneficial only if the middle tier is multithreaded. Each thread can maintain a session to the database. The actual connections to the database are maintained by the connection pool, and these connections (including the pool of dedicated database server processes) are shared among all the threads in the middle tier.</p>
</div>
</div>
<a id="LNOCI16605"></a>
<div class="props_rev_3"><a id="GUID-11F389B2-7D7A-4188-96AC-438C25139C4D"></a>
<h4 id="LNOCI-GUID-11F389B2-7D7A-4188-96AC-438C25139C4D" class="sect4">Stateless Sessions Versus Stateful Sessions</h4>
<div>
<p>Stateless sessions are serially reusable across mid-tier threads. After a thread is done processing a database request on behalf of a three-tier user, the same database session can be reused for a completely different request on behalf of a completely different three-tier user.</p>
<p>Stateful sessions to the database, however, are not serially reusable across mid-tier threads because they may have some particular state associated with a particular three-tier user. Examples of such state may include open transactions, the fetch state from a statement, or a PL/SQL package state. So long as the state exists, the session is not reusable for a different request.</p>
<div class="infobox-note" id="GUID-11F389B2-7D7A-4188-96AC-438C25139C4D__GUID-8121CD53-9389-40B3-B6A7-F42107562E4B">
<p class="notep1">Note:</p>
<p>Stateless sessions too may have open transactions, open statement fetch state, and so on. However, such a state persists for a relatively short duration (only during the processing of a particular three-tier request by a mid-tier thread) that allows the session to be serially reused for a different three-tier user (when such state is cleaned up).</p>
<p>Stateless sessions are typically used in conjunction with statement caching.</p>
</div>
<p>What connection pooling offers is stateless connections and stateful sessions. If you must work with stateless sessions, see <span class="q">&#34;<a href="oci09adv.htm#GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C" title="Session pooling means that the application creates and maintains a group of stateless sessions to the database.">Session Pooling in OCI</a>&#34;</span>.</p>
</div>
</div>
<a id="LNOCI16607"></a><a id="LNOCI16606"></a>
<div class="props_rev_3"><a id="GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09"></a>
<h4 id="LNOCI-GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09" class="sect4">Multiple Connection Pools</h4>
<div>
<p>You can use the advanced concept of multiple connection pools for different database connections. Multiple connection pools can also be used when different priorities are assigned to users. Different service-level guarantees can be implemented using connection pooling.</p>
<p><a href="oci09adv.htm#GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09__CHDHJEDC">Figure 9-1</a> illustrates OCI connection pooling.</p>
<div class="figure" id="GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09__CHDHJEDC">
<p class="titleinfigure">Figure 9-1 OCI Connection Pooling</p>
<img width="514" height="290" src="img/GUID-90D21CEC-3FF2-4124-82BB-5783D0D01591-default.gif" alt="Description of Figure 9-1 follows" title="Description of Figure 9-1 follows"/><br/>
<a href="img_text/GUID-90D21CEC-3FF2-4124-82BB-5783D0D01591-print.htm">Description of &#34;Figure 9-1 OCI Connection Pooling&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="LNOCI16608"></a>
<div class="props_rev_3"><a id="GUID-55F39E75-40EB-464B-AEFB-75FF8ABD0169"></a>
<h4 id="LNOCI-GUID-55F39E75-40EB-464B-AEFB-75FF8ABD0169" class="sect4">Transparent Application Failover</h4>
<div>
<p>Transaction application failover (TAF) is enabled for connection pooling. The concepts of TAF apply equally well with connections in the connection pool except that the <code class="codeph">BACKUP</code> and <code class="codeph">PRECONNECT</code> clauses should not be used in the connect string and do not work with connection pooling and TAF.</p>
<p>When a connection in the connection pool fails over, it uses the primary connect string itself to connect. Sessions fail over when they use the pool for a database round-trip after their instance failure. The listener is configured to route the connection to a good instance if available, as is typical with service-based connect strings.</p>
<div class="infoboxnotealso" id="GUID-55F39E75-40EB-464B-AEFB-75FF8ABD0169__GUID-07806C44-89C5-4548-BED3-26D6214EBCDC">
<p class="notep1">See Also:</p>
<p><a class="olink NETAG0131" target="_blank" href="../NETAG/advcfg.htm#NETAG0131"><span class="italic">Oracle Database Net Services Administrator&#39;s Guide</span></a>, the chapter about configuring transparent application failover</p>
</div>
</div>
</div>
</div>
<a id="LNOCI091"></a>
<div class="props_rev_3"><a id="GUID-322FF18E-48AE-4B94-8477-E91127F6BA86"></a>
<h3 id="LNOCI-GUID-322FF18E-48AE-4B94-8477-E91127F6BA86" class="sect3">Using OCI Calls for Connection Pooling</h3>
<div>
<p>Lists the steps you must follow to use connection pooling in your application.</p>
<div class="section">
<p>To use connection pooling in your application, you must:</p>
</div>
<!-- class="section" -->
<ol>
<li><span><a href="oci09adv.htm#GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7">Allocate the Pool Handle</a></span></li>
<li><span><a href="oci09adv.htm#GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C">Create the Connection Pool</a></span></li>
<li><span><a href="oci09adv.htm#GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5">Log On to the Database</a></span></li>
<li><span><a href="oci09adv.htm#GUID-497689F0-20A0-4CEF-91DC-594DBACED921" title="With OCI_CPOOL mode (connection pooling), the session memory (UGA) in the back-end database comes out of the SGA.">Deal with SGA Limitations in Connection Pooling</a></span></li>
<li><span><a href="oci09adv.htm#GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2">Log Off from the Database</a></span></li>
<li><span><a href="oci09adv.htm#GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B">Destroy the Connection Pool</a></span></li>
<li><span><a href="oci09adv.htm#GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E" title="The pool handle is freed using OCIHandleFree().">Free the Pool Handle</a></span></li>
</ol>
</div>
<a id="LNOCI16609"></a>
<div class="props_rev_3"><a id="GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7"></a>
<h4 id="LNOCI-GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7" class="sect4">Allocate the Pool Handle</h4>
<div>
<div class="section">
<p>Connection pooling requires that the pool handle <a id="d107147e1576" class="indexterm-anchor"></a><code class="codeph">OCI_HTYPE_CPOOL</code> be allocated by <a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a>. Multiple pools can be created for a given environment handle.</p>
<p>For a single connection pool, here is an allocation example:</p>
<pre dir="ltr">OCICPool *poolhp;
OCIHandleAlloc((void *) envhp, (void **) &amp;poolhp, OCI_HTYPE_CPOOL, 
                      (size_t) 0, (void **) 0));
</pre></div>
<!-- class="section" --></div>
</div>
<a id="LNOCI16610"></a>
<div class="props_rev_3"><a id="GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C"></a>
<h4 id="LNOCI-GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C" class="sect4">Create the Connection Pool</h4>
<div>
<div class="section">
<p>The function <a href="oci16rel001.htm#GUID-7E5A69F2-0268-4655-845D-A7662902FAA2" title="Initializes the connection pool.">OCIConnectionPoolCreate()</a> <a id="d107147e1750" class="indexterm-anchor"></a>initializes the <a id="d107147e1755" class="indexterm-anchor"></a><a id="d107147e1759" class="indexterm-anchor"></a>connection pool handle. It has these <code class="codeph">IN</code> parameters:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">connMin</code>, the minimum number of connections to be opened when the pool is created.</p>
</li>
<li>
<p><code class="codeph">connIncr</code>, the incremental number of connections to be opened when all the connections are busy and a call needs a connection. This increment is used only when the total number of open connections is less than the maximum number of connections that can be opened in that pool.</p>
</li>
<li>
<p><code class="codeph">connMax</code>, the maximum number of connections that can be opened in the pool. When the maximum number of connections are open in the pool, and all the connections are busy, if a call needs a connection, it waits until it gets one. However, if the <code class="codeph">OCI_ATTR_CONN_NOWAIT</code> attribute is set for the pool, an error is returned.</p>
</li>
<li>
<p>A <code class="codeph">poolUsername</code> and a <code class="codeph">poolPassword</code>, to allow user sessions to transparently migrate between connections in the pool.</p>
</li>
<li>
<p>In addition, an attribute <a href="ociaahan.htm#GUID-400B741C-E4AA-4155-8279-09FD80A6B38F__CACFEFEB">OCI_ATTR_CONN_TIMEOUT</a>, can be set to time out the connections in the pool. Connections idle for more than this time are terminated periodically to maintain an optimum number of open connections. If this attribute is not set, then the connections are never timed out.</p>
</li>
</ul>
<div class="infobox-note" id="GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C__GUID-2A07D24D-88CC-4CC3-828D-1AFB8A3865BD">
<p class="notep1">Note:</p>
<p>Shrinkage of the pool only occurs when there is a network round-trip. If there are no operations, then the connections stay active.</p>
</div>
<p>Because all the preceding attributes can be configured dynamically, the application can read the current load (number of open connections and number of busy connections) and tune these attributes appropriately.</p>
<p>If the pool attributes (<code class="codeph">connMax</code>, <code class="codeph">connMin</code><span class="italic">,</span> <code class="codeph">connIncr</code>) are to be changed dynamically, <a href="oci16rel001.htm#GUID-7E5A69F2-0268-4655-845D-A7662902FAA2" title="Initializes the connection pool.">OCIConnectionPoolCreate()</a> must be called with <code class="codeph">mode</code> set to <code class="codeph">OCI_CPOOL_REINITIALIZE</code>.</p>
<p>The OUT parameters <code class="codeph">poolName</code> and <code class="codeph">poolNameLen</code> contain values to be used in subsequent <a href="oci16rel001.htm#GUID-B6291228-DA2F-4CE9-870A-F94243141757">OCIServerAttach()</a> and <a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a> calls in place of the database name and the database name length arguments.</p>
<p>There is no limit on the number of pools that can be created by an application. Middle-tier applications can create multiple pools to connect to the same server or to different servers, to balance the load based on the specific needs of the application.</p>
<p>Here is an example of this call:</p>
<pre dir="ltr">OCIConnectionPoolCreate((OCIEnv *)envhp,
                   (OCIError *)errhp, (OCICPool *)poolhp,
                   &amp;poolName, &amp;poolNameLen,
                   (text *)database,strlen(database),
                   (ub4) connMin, (ub4) connMax, (ub4) connIncr,
                   (text *)poolUsername,strlen(poolUserLen),
                   (text *)poolPassword,strlen(poolPassLen),
                   OCI_DEFAULT));
</pre></div>
<!-- class="section" --></div>
</div>
<a id="LNOCI16611"></a>
<div class="props_rev_3"><a id="GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5"></a>
<h4 id="LNOCI-GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5" class="sect4">Log On to the Database</h4>
<div>
<div class="section">
<p>The application must log on to the database for each thread, using one of the following interfaces.</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a></p>
<p>This is the simplest interface. Use this interface when you need a simple connection pool connection and do not need to alter any attributes of the session handle. This interface can also be used to make proxy connections to the database.</p>
<p>Here is an example using <code class="codeph">OCILogon2()</code>:</p>
<pre dir="ltr">for (i = 0; i &lt; MAXTHREADS; ++i) 
{ 
   OCILogon2(envhp, errhp, &amp;svchp[i], &#34;hr&#34;, 2, &#34;hr&#34;, 2, poolName,
             poolNameLen, OCI_LOGON2_CPOOL));

}
</pre>
<p>To use this interface to get a proxy connection, set the password parameter to <code class="codeph">NULL</code>.</p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a></p>
<p>This is the recommended interface. It gives the user the additional option of using external authentication methods, such as certificates, distinguished name, and so on. <code class="codeph">OCISessionGet()</code> is the recommended uniform function call to retrieve a session.</p>
<p>Here is an example using <code class="codeph">OCISessionGet()</code>:</p>
<pre dir="ltr">for (i = 0; i &lt; MAXTHREADS; ++i) 
{ 
        OCISessionGet(envhp, errhp, &amp;svchp, authp,
                      (OraText *) poolName,
                      strlen(poolName), NULL, 0, NULL, NULL, NULL,
                      OCI_SESSGET_CPOOL)
 }
</pre></li>
<li>
<p><a href="oci16rel001.htm#GUID-B6291228-DA2F-4CE9-870A-F94243141757">OCIServerAttach()</a> and <a href="oci16rel001.htm#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947">OCISessionBegin()</a></p>
<p>You can use another interface if the application must set any special attributes on the user session handle and server handle. For such a requirement, applications must allocate all the handles (connection pool handle, server handles, session handles, and service context handles). You would follow this sequence:</p>
<ol>
<li>
<p>Create the connection pool.</p>
<p>Connection pooling does the multiplexing of a virtual server handle over physical connections transparently, eliminating the need for users to do so. The user gets the feeling of a session having a dedicated (virtual) connection. Because the multiplexing is done transparently to the user, users must not attempt to multiplex sessions over the virtual server handles themselves. The concepts of session migration and session switching, which require explicit multiplexing at the user level, are defunct for connection pooling and should not be used.</p>
</li>
<li>
<p>Call <a href="oci16rel001.htm#GUID-B6291228-DA2F-4CE9-870A-F94243141757">OCIServerAttach()</a> with mode set to <code class="codeph">OCI_CPOOL</code>.</p>
<p>In an OCI program, the user should create (<code class="codeph">OCIServerAttach()</code> with mode set to <code class="codeph">OCI_CPOOL</code>), a unique virtual server handle for each session that is created using the connection pool. There should be a one-to-one mapping between virtual server handles and sessions.</p>
</li>
<li>
<p>Call <a href="oci16rel001.htm#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947">OCISessionBegin()</a> with mode set to <code class="codeph">OCI_DEFAULT</code>.</p>
<p>Credentials can be set to <code class="codeph">OCI_CRED_RDBMS</code>, <code class="codeph">OCI_CRED_EXT</code>, or <code class="codeph">OCI_CRED_PROXY</code> using <code class="codeph">OCISessionBegin()</code>. If the credentials are set to <code class="codeph">OCI_CRED_EXT</code>, no user name and no password need to be set on the session handle. If the credentials are set to <code class="codeph">OCI_CRED_PROXY</code>, only the user name must be set on the session handle. (no explicit primary session must be created and <code class="codeph">OCI_ATTR_MIGSESSION</code> need not be set).</p>
<p>The user should not set <code class="codeph">OCI_MIGRATE</code> flag in the call to <a href="oci16rel001.htm#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947">OCISessionBegin()</a> when the virtual server handle points to a connection pool (<a href="oci16rel001.htm#GUID-B6291228-DA2F-4CE9-870A-F94243141757">OCIServerAttach()</a> called with <code class="codeph">mode</code> set to <code class="codeph">OCI_CPOOL</code>). Oracle supports passing the <code class="codeph">OCI_MIGRATE</code> flag only for compatibility reasons. Do not use the <code class="codeph">OCI_MIGRATE</code> flag, because the perception that the user gets when using a connection pool is of sessions having their own dedicated (virtual) connections that are transparently multiplexed onto real connections.</p>
</li>
</ol>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="LNOCI16612"></a>
<div class="props_rev_3"><a id="GUID-497689F0-20A0-4CEF-91DC-594DBACED921"></a>
<h4 id="LNOCI-GUID-497689F0-20A0-4CEF-91DC-594DBACED921" class="sect4">Deal with SGA Limitations in Connection Pooling</h4>
<div>
<p>With <code class="codeph">OCI_CPOOL</code> mode (connection pooling), the session memory (UGA) in the back-end database comes out of the SGA.</p>
<p>This may require some SGA tuning on the back-end database to have a larger SGA if your application consumes more session memory than the SGA can accommodate. The memory tuning requirements for the back-end database are similar to configuring the LARGE POOL in a shared server back end except that the instance is still in dedicated mode.</p>
<p>If you are still running into the SGA limitation, you must consider:</p>
<ul style="list-style-type: disc;">
<li>
<p>Reducing the session memory consumption by having fewer open statements for each session</p>
</li>
<li>
<p>Reducing the number of sessions in the back end by pooling sessions on the mid-tier</p>
</li>
<li>
<p>Or otherwise, turning off connection pooling</p>
</li>
</ul>
<p>The application must avoid using dedicated database links on the back end with connection pooling.</p>
<p>If the back end is a dedicated server, effective connection pooling is not possible because sessions using dedicated database links are tied to a physical connection rendering that same connection unusable by other sessions. If your application uses dedicated database links and you do not see effective sharing of back-end processes among your sessions, you must consider using shared database links.</p>
<div class="infoboxnotealso" id="GUID-497689F0-20A0-4CEF-91DC-594DBACED921__GUID-914FE48C-1B62-4CFB-B15B-BDC83FB1761A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink TGDBA558" target="_blank" href="../TGDBA/tune_shared_pool.htm#TGDBA558"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a>, the section about configuring a shared server</p>
</li>
<li>
<p><a class="olink ADMIN12083" target="_blank" href="../ADMIN/ds_concepts.htm#ADMIN12083"><span><cite>Oracle Database Administrator&rsquo;s Guide</cite></span></a>, the section on shared database links for more information about distributed databases</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16613"></a>
<div class="props_rev_3"><a id="GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2"></a>
<h4 id="LNOCI-GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2" class="sect4">Log Off from the Database</h4>
<div>
<p>From the following calls, choose the one that corresponds to the logon call and use it to log off from the database in connection pooling mode.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel001.htm#GUID-567DA731-ABC9-4348-B29C-7B2C6C1D7C36" title="Releases a session that was retrieved using OCILogon2() or OCILogon().">OCILogoff()</a>:</p>
<p>If <a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a> was used to make the connection, <code class="codeph">OCILogoff()</code> must be used to log off.</p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D">OCISessionRelease()</a></p>
<p>If OCISessionGet() was called to make the connection, then <code class="codeph">OCISessionRelease()</code> must be called to log off.</p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-2AE88BDC-2C44-4958-B26A-434B0407F06F">OCISessionEnd()</a> and <a href="oci16rel001.htm#GUID-402B540A-05FF-464B-B9C8-B2E7B4ABD564">OCIServerDetach()</a></p>
<p>If <a href="oci16rel001.htm#GUID-B6291228-DA2F-4CE9-870A-F94243141757">OCIServerAttach()</a> and <a href="oci16rel001.htm#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947">OCISessionBegin()</a> were called to make the connection and start the session, then <code class="codeph">OCISessionEnd()</code> must be called to end the session and <code class="codeph">OCIServerDetach()</code> must be called to release the connection.</p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16614"></a>
<div class="props_rev_3"><a id="GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B"></a>
<h4 id="LNOCI-GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B" class="sect4">Destroy the Connection Pool</h4>
<div>
<p>Use OCIConnectionPoolDestroy() to destroy the connection pool.</p>
</div>
</div>
<a id="LNOCI16615"></a>
<div class="props_rev_3"><a id="GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E"></a>
<h4 id="LNOCI-GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E" class="sect4">Free the Pool Handle</h4>
<div>
<p>The pool handle is freed using <code class="codeph">OCIHandleFree()</code>.</p>
<p>These last three actions are illustrated in this code fragment:</p>
<pre dir="ltr"> for (i = 0; i &lt; MAXTHREADS; ++i)
  {
    checkerr(errhp, OCILogoff((void *) svchp[i], errhp));
  }
  checkerr(errhp, OCIConnectionPoolDestroy(poolhp, errhp, OCI_DEFAULT));
  checkerr(errhp, OCIHandleFree((void *)poolhp, OCI_HTYPE_CPOOL));
</pre>
<div class="infoboxnotealso" id="GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E__GUID-1B38A80D-B03C-4570-B418-705A28CBB173">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel002.htm#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A">OCIHandleFree()</a></p>
</li>
<li>
<p><a href="ociaahan.htm#GUID-400B741C-E4AA-4155-8279-09FD80A6B38F">Connection Pool Handle Attributes</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-7E5A69F2-0268-4655-845D-A7662902FAA2" title="Initializes the connection pool.">OCIConnectionPoolCreate()</a>, <a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a>, and <a href="oci16rel001.htm#GUID-46720C8F-0A9F-4300-B6C4-4E47875A95C2">OCIConnectionPoolDestroy()</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="LNOCI16616"></a>
<div class="props_rev_3"><a id="GUID-AE06BCB1-7333-458E-90F0-0761496EC5E1"></a>
<h3 id="LNOCI-GUID-AE06BCB1-7333-458E-90F0-0761496EC5E1" class="sect3">Examples of OCI Connection Pooling</h3>
<div>
<p>Examples of connection pooling in tested complete programs can be found in c<code class="codeph">democp.c and cdemocpproxy.c</code> in directory <code class="codeph">demo</code>.</p>
</div>
</div>
</div>
<a id="LNOCI16617"></a>
<div class="props_rev_3"><a id="GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C"></a>
<h2 id="LNOCI-GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C" class="sect2">Session Pooling in OCI</h2>
<div>
<p><span class="italic">Session pooling</span> means that the application creates and maintains a group of stateless sessions to the database.</p>
<p>These sessions are provided to thin clients as requested. If no sessions are available, a new one may be created. When the client is done with the session, the client releases it to the pool. Thus, the number of sessions in the pool can increase dynamically.</p>
<p>Some of the sessions in the pool may be tagged with certain properties. For instance, a user may request a default session, set certain attributes on it, label it or tag it, and return it to the pool. That user, or some other user, can require a session with the same attributes, and thus request a session with the same tag. There may be several sessions in the pool with the same tag. The tag on a session can be changed or reset.</p>
<p>Proxy sessions, too, can be created and maintained through session pooling in OCI.</p>
<p>The behavior of the application when no free sessions are available and the pool has reached its maximum size depends on certain attributes. A new session may be created or an error returned, or the thread may just block and wait for a session to become free.</p>
<p>The main benefit of session pooling is performance. Making a connection to the database is a time-consuming activity, especially when the database is remote. Thus, instead of a client spending time connecting to the server, authenticating its credentials, and then receiving a valid session, it can just pick one from the pool.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-7D5BBEC4-38CF-4C63-B616-12231EF0DCAE">Functionality of OCI Session Pooling</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-DD2C2456-5F22-4BA0-AFE6-30CCF29A3688">Homogeneous and Heterogeneous Session Pools</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9">About Using Tags in Session Pools</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-35D322F2-E576-416B-A399-3A733F5487A1" title="What are the handle types for session pooling.">OCI Handles for Session Pooling</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E">Using OCI Session Pooling</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-CE43701B-ACB2-4F3A-B7CA-332CBD01DCCE" title="Describes the usages for OCI calls for session pooling.">OCI Calls for Session Pooling</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-72D13726-61B8-4CAB-9120-4E33714688AE">Example of OCI Session Pooling</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C__GUID-18175688-A109-44F2-BE5D-B323818A1A7F">
<p class="notep1">See Also:</p>
<p><a href="oci09adv.htm#GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9">About Using Tags in Session Pools</a></p>
</div>
</div>
<a id="LNOCI16618"></a>
<div class="props_rev_3"><a id="GUID-7D5BBEC4-38CF-4C63-B616-12231EF0DCAE"></a>
<h3 id="LNOCI-GUID-7D5BBEC4-38CF-4C63-B616-12231EF0DCAE" class="sect3">Functionality of OCI Session Pooling</h3>
<div>
<p>Session pooling can perform the following tasks:</p>
<ul style="list-style-type: disc;">
<li>
<p>Create, maintain, and manage a pool of stateless sessions transparently.</p>
</li>
<li>
<p>Provide an interface for the application to create a pool and specify the minimum, increment, and maximum number of sessions in the pool.</p>
</li>
<li>
<p>Provide an interface for the user to obtain and release a default or tagged session to the pool. A tagged session is one with certain client-defined properties.</p>
</li>
<li>
<p>Allow the application to dynamically change the number of minimum and maximum number of sessions.</p>
</li>
<li>
<p>Provide a mechanism to always maintain an optimum number of open sessions, by closing sessions that have been idle for a very long time, and creating sessions when required.</p>
</li>
<li>
<p>Allow for session pooling with authentication.</p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16619"></a>
<div class="props_rev_3"><a id="GUID-DD2C2456-5F22-4BA0-AFE6-30CCF29A3688"></a>
<h3 id="LNOCI-GUID-DD2C2456-5F22-4BA0-AFE6-30CCF29A3688" class="sect3">Homogeneous and Heterogeneous Session Pools</h3>
<div>
<p>A session pool can be either homogeneous or heterogeneous. <span class="italic">Homogeneous</span> session pooling means that sessions in the pool are alike for authentication (they have the same user name, password, and privileges). <span class="italic">Heterogeneous</span> session pooling means that you must provide authentication information because the sessions can have different security attributes and privileges.</p>
</div>
</div>
<a id="LNOCI16620"></a>
<div class="props_rev_3"><a id="GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9"></a>
<h3 id="LNOCI-GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9" class="sect3">About Using Tags in Session Pools</h3>
<div>
<p>The tags provide a way for users to customize sessions in the pool. A client can get a default or untagged session from a pool, set certain attributes on the session (such as NLS settings), and return the session to the pool, labeling it with an appropriate tag in the <a href="oci16rel001.htm#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D">OCISessionRelease()</a> call.</p>
<p>The user, or some other user, can request a session with the same tags to have a session with the same attributes, and can do so by providing the same tag in the <a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a> call.</p>
<div class="infoboxnotealso" id="GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9__GUID-53C1441D-B992-4770-B865-97A57A42FAC5">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a>&#34;</span> for a further discussion of tagging sessions</p>
</div>
</div>
</div>
<a id="LNOCI16621"></a>
<div class="props_rev_3"><a id="GUID-35D322F2-E576-416B-A399-3A733F5487A1"></a>
<h3 id="LNOCI-GUID-35D322F2-E576-416B-A399-3A733F5487A1" class="sect3">OCI Handles for Session Pooling</h3>
<div>
<p>What are the handle types for session pooling.</p>
<div class="p">The following handle types are for session pooling:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-3EB716F7-7810-4E29-9F92-F5A76B88E662">OCISPool</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-0F8EA0EC-2018-476F-9353-208266BD822A" title="This is the authentication information handle.">OCIAuthInfo</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16622"></a>
<div class="props_rev_3"><a id="GUID-3EB716F7-7810-4E29-9F92-F5A76B88E662"></a>
<h4 id="LNOCI-GUID-3EB716F7-7810-4E29-9F92-F5A76B88E662" class="sect4">OCISPool</h4>
<div>
<p>This is the session pool handle. It is allocated using <a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a>. It must be passed to <a href="oci16rel001.htm#GUID-1E929CFB-9D96-4E8E-9F24-904AD539E555" title="Initializes a session pool for use with OCI session pooling and database resident connection pooling (DRCP).">OCISessionPoolCreate()</a> and <a href="oci16rel001.htm#GUID-2797C90C-C7AC-47FB-B1C2-CE41B743FB5C">OCISessionPoolDestroy()</a>. It has the attribute type <code class="codeph">OCI_HTYPE_SPOOL</code>.</p>
<p>An example of the <code class="codeph">OCIHandleAlloc()</code> call follows:</p>
<pre dir="ltr">OCISPool *spoolhp;
OCIHandleAlloc((void *) envhp, (void **) &amp;spoolhp, OCI_HTYPE_SPOOL, 
                        (size_t) 0, (void **) 0));
</pre>
<p>For an environment handle, multiple session pools can be created.</p>
</div>
</div>
<a id="LNOCI16623"></a>
<div class="props_rev_3"><a id="GUID-0F8EA0EC-2018-476F-9353-208266BD822A"></a>
<h4 id="LNOCI-GUID-0F8EA0EC-2018-476F-9353-208266BD822A" class="sect4">OCIAuthInfo</h4>
<div>
<p>This is the authentication information handle.</p>
<p>It is allocated using <code class="codeph">OCIHandleAlloc()</code>. It is passed to <code class="codeph">OCISessionGet()</code>. It supports all the attributes that are supported for a user session handle. The authentication information handle has the attribute type <code class="codeph">OCI_HTYPE_AUTHINFO</code> (see <a href="oci02bas.htm#GUID-5F13B2EC-E29C-4710-8AD7-E97E6C28085E__G466063" title="This table has 3 columns. Column 1 is the handle type description, column 2 is the C data type, and column 3 is the handle type constant.">Table 2-1</a>).</p>
<p>An example of the <code class="codeph">OCIHandleAlloc()</code> call follows:</p>
<pre dir="ltr">OCIAuthInfo *authp;
OCIHandleAlloc((void *) envhp, (void **) &amp;authp, OCI_HTYPE_AUTHINFO, 
                      (size_t) 0, (void **) 0));
</pre>
<div class="infoboxnotealso" id="GUID-0F8EA0EC-2018-476F-9353-208266BD822A__GUID-8F595AFE-3EDF-42F7-B84A-55B314C4FFD3">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a></p>
</li>
<li>
<p><a href="ociaahan.htm#GUID-FB263210-118E-4DB3-A840-1769EF0CB977">User Session Handle Attributes</a> for the attributes that belong to the authentication information handle</p>
</li>
<li>
<p><a href="ociaahan.htm#GUID-34071823-66D0-4C54-BFBB-6323BDEF8015">Session Pool Handle Attributes</a> for more information about the session pooling attributes</p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-8EDDA0CC-6755-49D8-89D0-81713E10B156" title="Initializes the connection pool.Shuts down an Oracle Database instance.Starts an Oracle Database instance.Creates and initializes an environment handle for OCI functions to work under.Creates and initializes an environment handle for OCI functions to work under. Releases a session that was retrieved using OCILogon2() or OCILogon().Initializes a session pool for use with OCI session pooling and database resident connection pooling (DRCP).">Connect, Authorize, and Initialize Functions</a> for complete information about the functions used in session pooling</p>
</li>
<li>
<p>See <span class="q">&#34;<a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a>&#34;</span> for details of the session handle attributes that you can use with this call</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="LNOCI16624"></a>
<div class="props_rev_3"><a id="GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E"></a>
<h3 id="LNOCI-GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E" class="sect3">Using OCI Session Pooling</h3>
<div>
<div class="section">
<p>The steps in writing a simple session pooling application that uses a user name and password are as follows:</p>
<ol>
<li>
<p>Allocate the session pool handle using <code class="codeph">OCIHandleAlloc()</code> for an <code class="codeph">OCISPool</code> handle. Multiple session pools can be created for an environment handle.</p>
</li>
<li>
<p>Create the session pool using <a href="oci16rel001.htm#GUID-1E929CFB-9D96-4E8E-9F24-904AD539E555" title="Initializes a session pool for use with OCI session pooling and database resident connection pooling (DRCP).">OCISessionPoolCreate()</a> with <code class="codeph">mode</code> set to <code class="codeph">OCI_DEFAULT</code> (for a new session pool). See the function for a discussion of the other modes.</p>
</li>
<li>
<p>Loop for each thread. Create the thread with a function that does the following:</p>
<ol>
<li>
<p>Allocates an authentication information handle of type <code class="codeph">OCIAuthInfo</code> using <a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a></p>
</li>
<li>
<p>Sets the user name and password in the authentication information handle using <a href="oci16rel002.htm#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="Sets the value of an attribute of a handle or a descriptor.">OCIAttrSet()</a></p>
</li>
<li>
<p>Gets a pooled session using <a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a> with <code class="codeph">mode</code> set to <code class="codeph">OCI_SESSGET_SPOOL</code></p>
</li>
<li>
<p>Performs the transaction</p>
</li>
<li>
<p>Allocates the handle</p>
</li>
<li>
<p>Prepares the statement</p>
<div class="infobox-note" id="GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E__GUID-05DB4D0E-C365-4A1E-AA5D-C0F873C13754">
<p class="notep1">Note:</p>
<p>When using service contexts obtained from OCI session pool, you are required to use the service context returned by <a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a> (or <a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a>), and not create other service contexts outside of these calls.</p>
<p>Any statement handle obtained using <a href="oci17msc001.htm#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a> with the service context should be subsequently used only in conjunction with the same service context, and never with a different service context.</p>
</div>
</li>
<li>
<p>Executes the statement</p>
</li>
<li>
<p>Commits or rolls back the transactions</p>
</li>
<li>
<p>Releases the session (log off) with <a href="oci16rel001.htm#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D">OCISessionRelease()</a></p>
</li>
<li>
<p>Frees the authentication information handle with <a href="oci16rel002.htm#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A">OCIHandleFree()</a></p>
</li>
<li>
<p>Ends the loop for each thread</p>
</li>
</ol>
</li>
<li>
<p>Destroy the session pool using <a href="oci16rel001.htm#GUID-2797C90C-C7AC-47FB-B1C2-CE41B743FB5C">OCISessionPoolDestroy()</a>.</p>
</li>
</ol>
</div>
<!-- class="section" --></div>
</div>
<a id="LNOCI16625"></a>
<div class="props_rev_3"><a id="GUID-CE43701B-ACB2-4F3A-B7CA-332CBD01DCCE"></a>
<h3 id="LNOCI-GUID-CE43701B-ACB2-4F3A-B7CA-332CBD01DCCE" class="sect3">OCI Calls for Session Pooling</h3>
<div>
<p>Describes the usages for OCI calls for session pooling.</p>
<p>OCI provides calls for session pooling to perform the following tasks:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7">Allocate the Pool Handle</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C">Create the Connection Pool</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5">Log On to the Database</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2">Log Off from the Database</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B">Destroy the Connection Pool</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E" title="The pool handle is freed using OCIHandleFree().">Free the Pool Handle</a></p>
</li>
</ul>
</div>
<a id="LNOCI16626"></a>
<div class="props_rev_3"><a id="GUID-1F691FCF-3986-43D7-AA27-82117745B105"></a>
<h4 id="LNOCI-GUID-1F691FCF-3986-43D7-AA27-82117745B105" class="sect4">Allocate the Pool Handle</h4>
<div>
<p>Session pooling requires that the pool handle <code class="codeph">OCI_HTYPE_SPOOL</code> be allocated by calling <a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a>.</p>
<p>Multiple pools can be created for a given environment handle. For a single session pool, here is an allocation example:</p>
<pre dir="ltr">OCISPool *poolhp; 
OCIHandleAlloc((void *) envhp, (void **) &amp;poolhp, OCI_HTYPE_SPOOL, (size_t) 0,
               (void **) 0));
</pre></div>
</div>
<a id="LNOCI16627"></a>
<div class="props_rev_3"><a id="GUID-15516E6A-868C-4C7E-8272-92C270C160A4"></a>
<h4 id="LNOCI-GUID-15516E6A-868C-4C7E-8272-92C270C160A4" class="sect4">Create the Pool Session</h4>
<div>
<p>You can use the function <a href="oci16rel001.htm#GUID-1E929CFB-9D96-4E8E-9F24-904AD539E555" title="Initializes a session pool for use with OCI session pooling and database resident connection pooling (DRCP).">OCISessionPoolCreate()</a> to create the session pool. Here is an example of how to use this call:</p>
<pre dir="ltr">OCISessionPoolCreate(envhp, errhp, poolhp, (OraText **)&amp;poolName, 
              (ub4 *)&amp;poolNameLen, database, 
              (ub4)strlen((const signed char *)database),
              sessMin, sessMax, sessIncr,
              (OraText *)appusername,
              (ub4)strlen((const signed char *)appusername),
              (OraText *)apppassword,
              (ub4)strlen((const signed char *)apppassword),
              OCI_DEFAULT);
</pre></div>
</div>
<a id="LNOCI16628"></a>
<div class="props_rev_3"><a id="GUID-7894AB6A-0CCD-4F22-9B84-5B40B2FC636C"></a>
<h4 id="LNOCI-GUID-7894AB6A-0CCD-4F22-9B84-5B40B2FC636C" class="sect4">Log On to the Database</h4>
<div>
<p>You can use these calls to log on to the database in session pooling mode.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a></p>
<p>This is the simplest call. However, it does not give the user the option of using tagging. Here is an example of how to use <code class="codeph">OCILogon2()</code> to log on to the database in session pooling mode:</p>
<pre dir="ltr">for (i = 0; i &lt; MAXTHREADS; ++i) 
{ 
  OCILogon2(envhp, errhp, &amp;svchp[i], &#34;hr&#34;, 2, &#34;hr&#34;, 2, poolName,
            poolNameLen, OCI_LOGON2_SPOOL));
}
</pre></li>
<li>
<p><a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a></p>
<p>This is the recommended call to use. It gives the user the option of using tagging to label sessions in the pool, which makes it easier to retrieve specific sessions. An example of using <code class="codeph">OCISessionGet()</code> follows. It is taken from <code class="codeph">cdemosp.c</code> in the <code class="codeph">demo</code> directory.</p>
<pre dir="ltr">OCISessionGet(envhp, errhp, &amp;svchp, authInfop,
             (OraText *)database,strlen(database), tag,
             strlen(tag), &amp;retTag, &amp;retTagLen, &amp;found, 
             OCI_SESSGET_SPOOL);
</pre>
<p>When using service contexts obtained from an OCI session pool, you are required to use the service context returned by <a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a> (or <a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a>), and not create other service contexts outside of these calls.</p>
<p>Any statement handle obtained using <a href="oci17msc001.htm#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a> with the service context should be subsequently used only in conjunction with the same service context, and never with a different service context.</p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16629"></a>
<div class="props_rev_3"><a id="GUID-618B7C74-0045-4170-B50E-163BB364AF04"></a>
<h4 id="LNOCI-GUID-618B7C74-0045-4170-B50E-163BB364AF04" class="sect4">Log Off from the Database</h4>
<div>
<p>From the following calls, choose the one that corresponds to the logon call and use it to log off from the database in session pooling mode.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel001.htm#GUID-567DA731-ABC9-4348-B29C-7B2C6C1D7C36" title="Releases a session that was retrieved using OCILogon2() or OCILogon().">OCILogoff()</a></p>
<p>If you used <a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a> to make the connection, you must call <code class="codeph">OCILogoff()</code> to log off.</p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D">OCISessionRelease()</a></p>
<p>If you used <a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a> to make the connection, then you must call <code class="codeph">OCISessionRelease()</code> to log off. Pending transactions are automatically committed.</p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16630"></a>
<div class="props_rev_3"><a id="GUID-4E12F09A-D461-4B10-AD8D-48C2E492D6BB"></a>
<h4 id="LNOCI-GUID-4E12F09A-D461-4B10-AD8D-48C2E492D6BB" class="sect4">Destroy the Session Pool</h4>
<div>
<p>Call <a href="oci16rel001.htm#GUID-2797C90C-C7AC-47FB-B1C2-CE41B743FB5C">OCISessionPoolDestroy()</a> to destroy the session pool, as shown in the following example:</p>
<pre dir="ltr">OCISessionPoolDestroy(poolhp, errhp, OCI_DEFAULT);
</pre></div>
</div>
<a id="LNOCI16631"></a>
<div class="props_rev_3"><a id="GUID-B28BBFF7-2965-4D2C-B554-9AAE174DB461"></a>
<h4 id="LNOCI-GUID-B28BBFF7-2965-4D2C-B554-9AAE174DB461" class="sect4">Free the Pool Handle</h4>
<div>
<p>Call <a href="oci16rel002.htm#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A">OCIHandleFree()</a> to free the session pool handle, as shown in the following example:</p>
<pre dir="ltr">OCIHandleFree((void *)poolhp, OCI_HTYPE_SPOOL);
</pre>
<div class="infobox-note" id="GUID-B28BBFF7-2965-4D2C-B554-9AAE174DB461__GUID-CD59014D-9D14-4EFE-B690-E4AC53CAC232">
<p class="notep1">Note:</p>
<p>Developers: You are advised to commit or roll back any open transaction before releasing the connection back to the pool. If this is not done, Oracle Database automatically commits any open transaction when the connection is released.</p>
<p>If an instance failure is detected while the session pool is being used, OCI tries to clean up the sessions to that instance.</p>
</div>
</div>
</div>
</div>
<a id="LNOCI16632"></a>
<div class="props_rev_3"><a id="GUID-72D13726-61B8-4CAB-9120-4E33714688AE"></a>
<h3 id="LNOCI-GUID-72D13726-61B8-4CAB-9120-4E33714688AE" class="sect3">Example of OCI Session Pooling</h3>
<div>
<p>For an example of session pooling in a tested complete program, see <code class="codeph">cdemosp.c</code> in directory <code class="codeph">demo</code>.</p>
</div>
</div>
</div>
<a id="LNOCI09100"></a>
<div class="props_rev_3"><a id="GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF"></a>
<h2 id="LNOCI-GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF" class="sect2">Runtime Connection Load Balancing</h2>
<div>
<p>Runtime connection load balancing routes work requests to sessions in a session pool that best serve the work.</p>
<p>It occurs when an application selects a session from an existing session pool and thus is a very frequent activity. For session pools that support services at one instance only, the first available session in the pool is adequate. When the pool supports services that span multiple instances, there is a need to distribute the work requests across instances so that the instances that are providing better service or have greater capacity get more requests.</p>
<p>Applications must connect to an Oracle RAC instance to enable runtime connection load balancing. Furthermore, these applications must:</p>
<ul style="list-style-type: disc;">
<li>
<p>Initialize the OCI Environment in <code class="codeph">OCI_EVENTS</code> mode</p>
</li>
<li>
<p>Connect to a service that has runtime connection load balancing enabled (use the <code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code> procedure to set <code class="codeph">GOAL</code> and <code class="codeph">CLB_GOAL</code> as appropriate)</p>
</li>
<li>
<p>Link with a thread library</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF__GUID-50651043-7613-4F36-95E2-4122F0E8CD32">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink RACAD7302" target="_blank" href="../RACAD/GUID-26E66434-7A68-4B63-B759-3E0A8CA14A8B.htm#RACAD7302"><span><cite>Oracle Real Application Clusters Administration and Deployment Guide</cite></span></a> for information about load balancing advisory</p>
</li>
<li>
<p><a class="olink ADFNS229" target="_blank" href="../ADFNS/adfns_perf_scale.htm#ADFNS229"><span><cite>Oracle Database Development Guide</cite></span></a> for information about enabling and disabling runtime connection load balancing for the supported interfaces, and receiving load balancing advisory FAN events</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI9110"></a>
<div class="props_rev_3"><a id="GUID-1E260CD3-2EF7-49FF-97FC-041C2EF60381"></a>
<h2 id="LNOCI-GUID-1E260CD3-2EF7-49FF-97FC-041C2EF60381" class="sect2">Database Resident Connection Pooling</h2>
<div>
<p>Database resident connection pooling (DRCP) provides a connection pool in the database server for typical web application usage scenarios where the application acquires a database connection, works on it for a relatively short duration, and then releases it.</p>
<p>DRCP pools server processes, each of which is the equivalent of a dedicated server process and a database session combined. (Henceforth these &#34;dedicated&#34; server processes are referred to as <span class="italic">pooled servers</span>.)</p>
<p>DRCP complements middle-tier connection pools that share connections between threads in a middle-tier process. In addition, DRCP enables sharing of database connections across middle-tier processes on the same middle-tier host and even across middle-tier hosts. This results in significant reduction in key database resources needed to support a large number of client connections, thereby reducing the database tier memory footprint and boosting the scalability of both middle-tier and database tiers. Having a pool of readily available servers has the additional benefit of reducing the cost of creating and tearing down client connections.</p>
<p>DRCP is especially relevant for architectures with multiprocess single-threaded application servers (such as PHP/Apache) that cannot do middle-tier connection pooling. Using DRCP, the database can scale to tens of thousands of simultaneous connections.</p>
<div class="infoboxnotealso" id="GUID-1E260CD3-2EF7-49FF-97FC-041C2EF60381__GUID-7437CBB6-FBC4-4A2D-96A8-B55881510B27">
<p class="notep1">See Also:</p>
<p><a class="olink ADFNS228" target="_blank" href="../ADFNS/adfns_perf_scale.htm#ADFNS228"><span><cite>Oracle Database Development Guide</cite></span></a> for complete information about DRCP</p>
</div>
</div>
</div>
<a id="LNOCI16652"></a>
<div class="props_rev_3"><a id="GUID-8DD97D4D-C7AA-4EF7-9B55-8DC58BDC2726"></a>
<h2 id="LNOCI-GUID-8DD97D4D-C7AA-4EF7-9B55-8DC58BDC2726" class="sect2">When to Use Connection Pooling, Session Pooling, or Neither</h2>
<div>
<p>Indicates the circumstances in which to use them or not.</p>
<p>If database sessions are not reusable by mid-tier threads (that is, they are stateful) and the number of back-end server processes may cause scaling problems on the database, use OCI connection pooling.</p>
<p>If database sessions are reusable by mid-tier threads (that is, they are stateless) and the number of back-end server processes may cause scaling problems on the database, use OCI session pooling.</p>
<p>If database sessions are not reusable by mid-tier threads (that is, they are stateful) and the number of back-end server processes is never large enough to potentially cause any scaling issue on the database, there is no need to use any pooling mechanism.</p>
<div class="infobox-note" id="GUID-8DD97D4D-C7AA-4EF7-9B55-8DC58BDC2726__GUID-D3E22093-F8E4-4683-B214-360F978C66BD">
<p class="notep1">Note:</p>
<p>Having nonpooled sessions or connections results in tearing down and re-creating the database session/connection for every mid-tier user request. This can cause severe scaling problems on the database side and excessive latency for the fulfillment of the request. Hence, Oracle strongly recommends that you adopt one of the pooling strategies for mid-tier applications based on whether the database session is stateful or stateless.</p>
</div>
<p>In connection pooling, the pool element is a connection and in session pooling, the pool element is a session.</p>
<p>As with any pool, the pooled resource is locked by the application thread for a certain duration until the thread has done its job on the database and the resource is released. The resource is unavailable to other threads during its period of use. Hence, application developers must be aware that any kind of pooling works effectively with relatively short tasks. However, if the application is performing a long-running transaction, it may deny the pooled resource to other sharers for long periods of time, leading to starvation. Hence, pooling should be used in conjunction with short tasks, and the size of the pool should be sufficiently large to maintain the desired concurrency of transactions.</p>
<p>Note the following additional information about connection pooling and session pooling:</p>
<ul style="list-style-type: disc;">
<li>
<p>OCI Connection Pooling</p>
<p>Connections to the database are pooled. Sessions are created and destroyed by the user. Each call to the database picks up an appropriate available connection from the pool.</p>
<p>The application is multiplexing several sessions over fewer physical connections to the database. The users can tune the pool configuration to achieve required concurrency.</p>
<p>The life-time of the application sessions is independent of the life-time of the cached pooled connections.</p>
</li>
<li>
<p>OCI Session Pooling</p>
<p>Sessions and connections are pooled by OCI. The application gets sessions from the pool and releases sessions back to the pool.</p>
</li>
</ul>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-A408F97E-C451-4D8C-BA8C-4F48DDA0EF26" title="There are a number of ways to create a session with varying functionality.">Functions for Session Creation</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-D952EB18-A7DE-4CF6-816D-E5E728AACE5E" title="How to choose the type od session to use.">About Choosing Between Different Types of OCI Sessions</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16653"></a>
<div class="props_rev_3"><a id="GUID-A408F97E-C451-4D8C-BA8C-4F48DDA0EF26"></a>
<h3 id="LNOCI-GUID-A408F97E-C451-4D8C-BA8C-4F48DDA0EF26" class="sect3">Functions for Session Creation</h3>
<div>
<p>There are a number of ways to create a session with varying functionality.</p>
<p>OCI offers the following functions for session creation:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCILogin</code></p>
<p>OCILogon() is the simplest way to get an OCI session. The advantage is ease of obtaining an OCI service context. The disadvantage is that you cannot perform any advance OCI operations, such as session migration, proxy authentication, or using a connection pool or a session pool.</p>
</li>
<li>
<p><code class="codeph">OCILogon2()</code></p>
<p>OCILogon2() includes the functionality of <code class="codeph">OCILogon()</code> to get a session. This session may be a new one with a new underlying connection, or one that is started over a virtual connection from an existing connection pool, or one from an existing session pool. The <code class="codeph">mode</code> parameter value that the function is called with determines its behavior.</p>
<p>The user cannot modify the attributes (except <code class="codeph">OCI_ATTR_</code><code class="codeph">STMTCACHESIZE</code>) of the service context returned by OCI.</p>
</li>
<li>
<p><code class="codeph">OCISessionBegin()</code></p>
<p>OCISessionBegin() supports all the various options of an OCI session, such as proxy authentication, getting a session from a connection pool or a session pool, external credentials, and migratable sessions. This is the lowest level call, where all handles must be explicitly allocated and all attributes set. <code class="codeph">OCIServerAttach()</code> must be called before this call.</p>
</li>
<li>
<p><code class="codeph">OCISessionGet()</code></p>
<p>OCISessionGet() is now the recommended method to get a session. This session may be a new one with a new underlying connection, or one that is started over a virtual connection from an existing connection pool, or one from an existing session pool. The <code class="codeph">mode</code> parameter value that the function is called with determines its behavior. This works like <code class="codeph">OCILogon2()</code> but additionally enables you to specify tags for obtaining specific sessions from the pool.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-A408F97E-C451-4D8C-BA8C-4F48DDA0EF26__GUID-C1757A87-6308-46A3-9658-BB5578DE80C4">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel001.htm#GUID-F4592576-BE9D-4583-83AD-5D56D2E592E6">OCILogon()</a></p>
</li>
<li>
<p><a href="oci02bas.htm#GUID-A4B693E9-7554-4721-A7F7-0B5B15589DEE" title="An application must call OCIEnvNlsCreate() to initialize the OCI environment handle. Existing applications may have used OCIEnvCreate().">Application Initialization, Connection, and Session Creation</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947">OCISessionBegin()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16654"></a>
<div class="props_rev_3"><a id="GUID-D952EB18-A7DE-4CF6-816D-E5E728AACE5E"></a>
<h3 id="LNOCI-GUID-D952EB18-A7DE-4CF6-816D-E5E728AACE5E" class="sect3">About Choosing Between Different Types of OCI Sessions</h3>
<div>
<p>How to choose the type od session to use.</p>
<p>OCI includes the following types of sessions:</p>
<ul style="list-style-type: disc;">
<li>
<p>Basic OCI sessions</p>
<p>The basic OCI session works by using user name and password over a dedicated OCI server handle. This is the no-pool mechanism. See When to Use Connection Pooling, Session Pooling, or Neither for information of when to use it.</p>
<p>If authentication is obtained through external credentials, then a user name or password is not required.</p>
</li>
<li>
<p>Session pool sessions</p>
<p>Session pool sessions are from the session pool cache. Some sessions may be tagged. These are stateless sessions. Each <code class="codeph">OCISessionGet()</code> and <code class="codeph">OCISessionRelease()</code> call gets and releases a session from the session cache. This saves the server from creating and destroying sessions.</p>
<p>See When to Use Connection Pooling, Session Pooling, or Neither on connection pool sessions versus session pooling sessions versus no-pooling sessions.</p>
</li>
<li>
<p>Connection pool sessions</p>
<p>Connection pool sessions are created using <code class="codeph">OCISessionGet()</code> and <code class="codeph">OCISessionBegin()</code> calls from an OCI connection pool. There is no session cache as these are stateful sessions. Each call creates a new session, and the user is responsible for terminating these sessions.</p>
<p>The sessions are automatically migratable between the server handles of the connection pool. Each session can have user name and password or be a proxy session. See When to Use Connection Pooling, Session Pooling, or Neither on connection pool sessions versus session pooling sessions versus no-pooling sessions.</p>
</li>
<li>
<p>Sessions sharing a server handle</p>
<p>You can multiplex several OCI sessions over a few physical connections. The application does this manually by having the same server handle for these multiple sessions. It is preferred to have the session multiplexing details be left to OCI by using the OCI connection pool APIs.</p>
</li>
<li>
<p>Proxy sessions</p>
<p>Proxy sessions are useful if the password of the client must be protected from the middle tier. Proxy sessions can also be part of an OCI connection pool or an OCI session pool.</p>
</li>
<li>
<p>Migratable Sessions</p>
</li>
</ul>
<p>With transaction handles being migratable, there should be no need for applications to use migratable sessions, instead use OCI connection pooling.</p>
<div class="infoboxnotealso" id="GUID-D952EB18-A7DE-4CF6-816D-E5E728AACE5E__GUID-76245F52-3F50-4D26-B3EF-6EC042C1CE38">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D">OCISessionRelease()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947">OCISessionBegin()</a></p>
</li>
<li>
<p><a href="oci08sca.htm#GUID-A5830D58-3079-45DD-BE3A-81C41991DA70" title="A middle-tier application receives requests from browser clients.">Middle-Tier Applications in OCI</a> for more information about proxy sessions</p>
</li>
<li>
<p><a href="oci08sca.htm#GUID-69A0AE8C-3F8D-4EDD-A817-730F17B3DF3E" title="Transaction servers that actively balance user load by multiplexing user sessions over a few server connections must group these connections into a server group.">OCI Session Management</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="LNOCI16655"></a>
<div class="props_rev_3"><a id="GUID-4947CAE8-1F00-4897-BB2B-7F921E495175"></a>
<h2 id="LNOCI-GUID-4947CAE8-1F00-4897-BB2B-7F921E495175" class="sect2">Statement Caching in OCI</h2>
<div>
<p>Statement caching refers to the feature that provides and manages a cache of statements for each session.</p>
<p>In the server, it means that cursors are ready to be used without the need to parse the statement again. You can use statement caching with connection pooling and with session pooling, and improve performance and scalability. You can use it without session pooling as well. OCI calls that implement statement caching are:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIStmtPrepare2()</code></p>
</li>
<li>
<p><code class="codeph">OCIStmtRelease()</code></p>
</li>
</ul>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA">Statement Caching with Session Pooling in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA">Statement Caching with Session Pooling in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-49C78457-8F76-48E1-A2CD-7EB22175042F" title="If you are using statement caching, follow these rules.">Rules for Statement Caching in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78">Bind and Define Optimization in Statement Caching</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-514CBC11-2222-43B4-A8AD-C71842DF9840">OCI Statement Caching Code Example</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-4947CAE8-1F00-4897-BB2B-7F921E495175__GUID-9191985B-BC63-438A-AE5B-360FA3DAE8B9">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci17msc001.htm#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-256034CE-2ADB-4BE5-BC8D-748307F2EA8E" title="Releases the statement handle obtained by a call to OCIStmtPrepare2().">OCIStmtRelease()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16656"></a>
<div class="props_rev_3"><a id="GUID-3525B9FE-2EE8-4016-90FF-54A684DF8198"></a>
<h3 id="LNOCI-GUID-3525B9FE-2EE8-4016-90FF-54A684DF8198" class="sect3">Statement Caching Without Session Pooling in OCI</h3>
<div>
<p>To perform statement caching without session pooling, users perform the usual OCI steps to log on. The call to obtain a session has a mode that specifies whether statement caching is enabled for the session. Initially the statement cache is empty. Developers try to find a statement in the cache using the statement text. If the statement exists, the API returns a previously prepared statement handle; otherwise, it returns a newly prepared statement handle.</p>
<p>The application developer can perform binds and defines and then simply execute and fetch the statement before returning the statement to the cache. If the statement handle is not found in the cache, the developer must set different attributes on the handle in addition to the other steps.</p>
<p><a href="oci17msc001.htm#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a> takes a mode that determines if the developer wants a prepared statement handle or a null statement handle if the statement is not found in the cache.</p>
<p>The pseudocode looks like this:</p>
<pre dir="ltr">OCISessionBegin( userhp, ... OCI_STMT_CACHE)  ;
OCIAttrset(svchp, userhp, ...);  /* Set the user handle in the service context */
OCIStmtPrepare2(svchp, &amp;stmthp, stmttext, key, ...);
OCIBindByPos(stmthp, ...);
OCIDefineByPos(stmthp, ...);
OCIStmtExecute(svchp, stmthp, ...);
OCIStmtFetch2(svchp, ...);
OCIStmtRelease(stmthp, ...);
...
</pre></div>
</div>
<a id="LNOCI16657"></a>
<div class="props_rev_3"><a id="GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA"></a>
<h3 id="LNOCI-GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA" class="sect3">Statement Caching with Session Pooling in OCI</h3>
<div>
<p>For statement caching with session pooling, the concepts remain the same, except that the statement cache is enabled at the session pool layer rather than at the session layer.</p>
<p>The attribute <code class="codeph">OCI_ATTR_SPOOL_STMTCACHESIZE</code> sets the default statement cache size for each of the sessions in the session pool. It is set on the <code class="codeph">OCI_HTYPE_SPOOL</code> handle. The statement cache size for a particular session in the pool can be overridden at any time by using <code class="codeph">OCI_ATTR_STMTCACHESIZE</code> on that session. The value of <code class="codeph">OCI_ATTR_SPOOL_STMTCACHESIZE</code> can be changed at any time. You can use this attribute to enable or disable statement caching at the pool level, after creation, just as attribute <code class="codeph">OCI_ATTR_STMTCACHESIZE</code> (on the service context) is used to enable or disable statement caching at the session level. This change is reflected on individual sessions in the pool, when they are provided to a user. Tagged sessions are an exception to this behavior. This is explained later in this section.</p>
<div class="infobox-note" id="GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA__GUID-F8243F9A-3B83-4CD4-8114-F00044ADCBD3">
<p class="notep1">Note:</p>
<p>You can change the attributes after acquiring a session. However, once an attribute is changed, it will remain set on the underlying physical session. This value will not be reset back implicitly while releasing the session back to the session pool. Hence, it is the developer&#39;s responsibility to maintain the state of the sessions before releasing the session using <code class="codeph">OCIStmtRelease()</code>.</p>
</div>
<p>Enabling or disabling of statement caching is allowed on individual pooled sessions as it is on nonpooled sessions.</p>
<p>A user can enable statement caching on a session retrieved from a non-statement cached pool in an <a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a> or <a href="oci16rel001.htm#GUID-425D4B32-257C-480E-B69C-7112BE9482E6">OCILogon2()</a> call by specifying <code class="codeph">OCI_SESSGET_STMTCACHE</code> or <a id="d107147e7548" class="indexterm-anchor"></a><code class="codeph">OCI_LOGON2_STMTCACHE</code>, respectively, in the mode argument.</p>
<p>When a user asks for a session from a session pool, the statement cache size for that session defaults to that of the pool. This may also mean enabling or disabling statement caching in that session. For example, if a pooled session (Session A) has statement caching enabled, and statement caching is turned off in the pool, and a user asks for a session, and Session A is returned, then statement caching is turned off in Session A. As another example, if Session A in a pool does not have statement caching enabled, and statement caching at the pool level is turned on, then before returning Session A to a user, statement caching on Session A with size equal to that of the pool is turned on.</p>
<p>This does not hold true if a tagged session is asked for and retrieved. In this case, the size of the statement cache is not changed. Consequently, it is not turned on or off. Moreover, if the user specifies mode <code class="codeph">OCI_SESSGET_STMTCACHE</code> in the <a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a> call, this is ignored if the session is tagged. In our earlier example, if Session A was tagged, then it is returned as is to the user.</p>
</div>
</div>
<a id="LNOCI16658"></a>
<div class="props_rev_3"><a id="GUID-49C78457-8F76-48E1-A2CD-7EB22175042F"></a>
<h3 id="LNOCI-GUID-49C78457-8F76-48E1-A2CD-7EB22175042F" class="sect3">Rules for Statement Caching in OCI</h3>
<div>
<p>If you are using statement caching, follow these rules.</p>
<p>Here are some rules to follow for statement caching in OCI:</p>
<ul style="list-style-type: disc;">
<li>
<p>Use the function <code class="codeph">OCIStmtPrepare2()</code> instead of <code class="codeph">OCIStmtPrepare()</code>. If you are using <code class="codeph">OCIStmtPrepare()</code>, you are strongly urged not to use a statement handle across different service contexts. Doing so raises an error if the statement has been obtained by <code class="codeph">OCIStmtPrepare2()</code>. Migration of a statement handle to a new service context actually closes the cursor associated with the old session and therefore no sharing is achieved. Client-side sharing is also not obtained, because OCI frees all buffers associated with the old session when the statement handle is migrated.</p>
</li>
<li>
<p>You are required to keep one service context per session. Any statement handle obtained using <code class="codeph">OCIStmtPrepare2()</code> with a certain service context should be subsequently used only in conjunction with the same service context, and never with a different service context.</p>
</li>
<li>
<p>A call to <code class="codeph">OCIStmtPrepare2()</code>, even if the session does not have a statement cache, also allocates the statement handle. Therefore, applications using only <code class="codeph">OCIStmtPrepare2()</code> must not call <code class="codeph">OCIHandleAlloc()</code> for the statement handle.</p>
</li>
<li>
<p>A call to <code class="codeph">OCIStmtPrepare2()</code> must be followed by a call to <code class="codeph">OCIStmtRelease()</code> after the user is done with the statement handle. If statement caching is used, this releases the statement to the cache. If statement caching is not used, the statement is deallocated. Do not call <code class="codeph">OCIHandleFree()</code> to free the memory.</p>
</li>
<li>
<p>If the call to <code class="codeph">OCIStmtPrepare2()</code> is made with the <code class="codeph">OCI_PREP2_CACHE_SEARCHONLY</code> mode and a <code class="codeph">NULL</code> statement was returned (statement was not found), the subsequent call to <code class="codeph">OCIStmtRelease()</code> is not required and must not be performed.</p>
</li>
<li>
<p>Do not call <code class="codeph">OCIStmtRelease()</code> for a statement that was prepared using <code class="codeph">OCIStmtPrepare()</code>.</p>
</li>
<li>
<p>The statement cache has a maximum size (number of statements) that can be modified by an attribute on the service context, <code class="codeph">OCI_ATTR_STMTCACHESIZE</code>. The default value is 20. This attribute can also be used to enable or disable statement caching for the session, pooled or nonpooled. If <code class="codeph">OCISessionBegin()</code> is called without the mode set as <code class="codeph">OCI_STMT_CACHE</code>, then <code class="codeph">OCI_ATTR_STMTCACHESIZE</code> can be set on the service context to a nonzero attribute to turn on statement caching. If statement caching is not turned on at the session pool level, <code class="codeph">OCISessionGet()</code> returns a non-statement cache-enabled session. You can use <code class="codeph">OCI_ATTR_STMTCACHESIZE</code> to turn the caching on. Similarly, you can use the same attribute to turn off statement caching by setting the cache size to zero.</p>
</li>
<li>
<p>You can tag a statement at the release time so that the next time you can request a statement of the same tag. The tag is used to search the cache. An untagged statement (tag is <code class="codeph">NULL</code>) is a special case of a tagged statement. Two statements are considered different if they differ in their tags, or if one is untagged and the other is not.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-49C78457-8F76-48E1-A2CD-7EB22175042F__GUID-C4C4DA8B-7450-45E0-977D-951DB47323DE">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci17msc001.htm#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-256034CE-2ADB-4BE5-BC8D-748307F2EA8E" title="Releases the statement handle obtained by a call to OCIStmtPrepare2().">OCIStmtRelease()</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A">OCIHandleFree()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947">OCISessionBegin()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241">OCISessionGet()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-7C0AF073-7870-4866-BBC9-D2BF3D8E5CCE" title="Lists and describes the statement functions.">Statement Functions</a></p>
</li>
<li>
<p><a href="ociaahan.htm#GUID-D8EE68EB-7E38-4068-B06E-DF5686379E5E">Service Context Handle Attributes</a></p>
</li>
<li>
<p><a href="ociaahan.htm#GUID-34071823-66D0-4C54-BFBB-6323BDEF8015">Session Pool Handle Attributes</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI72670"></a><a id="LNOCI72669"></a>
<div class="props_rev_3"><a id="GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78"></a>
<h3 id="LNOCI-GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78" class="sect3">Bind and Define Optimization in Statement Caching</h3>
<div>
<p>To avoid repeated bind and define operations on statements in the cache by the application, the application can register an opaque context with a statement taken from the statement cache and register a callback function with the service context. The application data such as bind and define buffers can be enclosed in the opaque context. This context is registered with the statement the first time it is taken from the cache. When a statement is taken from the cache the second time and onwards, the application can reuse the bind and define buffers, that it had registered with that statement. It is still the application&#39;s responsibility to manage the bind and defines. It can reuse both the bind and define data and the buffers, or it can change only the data and reuse the buffers, or it can free and reallocate the buffers if the current size is not enough. In the last case, it must rebind and redefine. To clean up the memory allocated by the application toward these bind and define buffers, the callback function is called during aging out of the statement or purging of the whole cache as part of session closure. The callback is called for every statement being purged. The application frees the memory and does any other cleanup required, inside the callback function. <a href="oci09adv.htm#GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78__CACJDEDA">Example 9-1</a> shows the pseudocode.</p>
<div class="infoboxnotealso" id="GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78__GUID-1B56ABFB-29B0-4323-AD27-DE975A7A0FB7">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="ociaahan.htm#GUID-A251CF91-EB9F-4DBC-8BB8-FB5EA92C20DE__BAJIDBEG">OCI_ATTR_STMTCACHE_CBKCTX</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="ociaahan.htm#GUID-D8EE68EB-7E38-4068-B06E-DF5686379E5E__BAJDGBHB">OCI_ATTR_STMTCACHE_CBK</a>&#34;</span></p>
</li>
</ul>
</div>
<div class="example" id="GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78__CACJDEDA">
<p class="titleinexample">Example 9-1 Optimizing Bind and Define Operations on Statements in the Cache</p>
<pre dir="ltr">Get the statement using OCIStmtPrepare2(...)
 
Get the opaque context from the statement if it exists
 
If opaque context does not exist
 
{
 
  Allocate fetch buffers, do the OCIBindByPos, OCIDefineByPos, and so forth
 
  Enclose the buffer addresses inside a context and set the context and
  callback function on the statement
 
}
Execute/Fetch using the statement, and process the data in the fetch buffers. 
 
OCIStmtRelease() that statement
 
Next OCIStmtPrepare2()
 
OCIAttrGet() opaque application context from statement handle
 
Execute/Fetch using the statement and process the data in the fetch buffers.
 
OCIStmtRelease()
 
. . .
 
void callback_fn (context, statement, mode)
 
{
 
   /* mode= OCI_CBK_STMTCACHE_STMTPURGE means this was called when statement was
      aging out of the statement cache or if the session is ended */
 
  &lt;free the buffers in the context.&gt;
 
}
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI16659"></a>
<div class="props_rev_3"><a id="GUID-514CBC11-2222-43B4-A8AD-C71842DF9840"></a>
<h3 id="LNOCI-GUID-514CBC11-2222-43B4-A8AD-C71842DF9840" class="sect3">OCI Statement Caching Code Example</h3>
<div>
<p>See <code class="codeph">cdemostc.c</code> in directory <code class="codeph">demo</code> for a working example of statement caching.</p>
</div>
</div>
</div>
<a id="LNOCI16661"></a><a id="LNOCI16660"></a>
<div class="props_rev_3"><a id="GUID-215B52BB-6769-4A53-A2DC-EDB36AE031B7"></a>
<h2 id="LNOCI-GUID-215B52BB-6769-4A53-A2DC-EDB36AE031B7" class="sect2">User-Defined Callback Functions in OCI</h2>
<div>
<p>Oracle Call Interface can execute user-specific code in addition to OCI calls.</p>
<p>You can use this functionality for:</p>
<ul style="list-style-type: disc;">
<li>
<p>Adding tracing and performance measurement code to enable users to tune their applications</p>
</li>
<li>
<p>Performing preprocessing or postprocessing code for specific OCI calls</p>
</li>
<li>
<p>Accessing other data sources with OCI by using the native OCI interface for Oracle Databases and directing the OCI calls to use user callbacks for non-Oracle data sources</p>
</li>
</ul>
<p>The OCI callback feature provides support for calling user code before or after executing the OCI calls. It also allows the user-defined code to be executed instead of executing the OCI code.</p>
<p>The user callback code can be registered dynamically without modifying the source code of the application. The dynamic registration is implemented by loading up to five user-created dynamically linked libraries after the initialization of the environment handle during the <code class="codeph">OCIEnvCreate()</code> call. These user-created libraries (such as dynamic-link libraries (DLLs) on Windows, or shared libraries on Solaris, register the user callbacks for the selected OCI calls transparently to the application.</p>
<div class="section">
<p class="subhead2">Sample Application</p>
</div>
<!-- class="section" -->
<div class="section">
<p>For a listing of the complete demonstration programs that illustrate the OCI user callback feature, see Appendix&nbsp;B.</p>
</div>
<!-- class="section" -->
<div class="section">
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-37001800-DC08-4253-8958-4F51A734FCE0" title="An application can register user callback libraries with the OCIUserCallbackRegister() function.">About Registering User Callbacks in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-163FF0B1-BAA9-4300-BA7C-170AAF0960ED">OCI Callbacks from External Procedures</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-215B52BB-6769-4A53-A2DC-EDB36AE031B7__GUID-E2BF4536-82DD-444A-8328-29435C560919">
<p class="notep1">See Also:</p>
<p><a href="oci16rel001.htm#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="Creates and initializes an environment handle for OCI functions to work under.">OCIEnvCreate()</a></p>
</div>
</div>
<!-- class="section" --></div>
<a id="LNOCI16662"></a>
<div class="props_rev_3"><a id="GUID-37001800-DC08-4253-8958-4F51A734FCE0"></a>
<h3 id="LNOCI-GUID-37001800-DC08-4253-8958-4F51A734FCE0" class="sect3">About Registering User Callbacks in OCI</h3>
<div>
<p>An application can register user callback libraries with the <code class="codeph">OCIUserCallbackRegister()</code> function.</p>
<p>Callbacks are registered in the context of the environment handle. An application can retrieve information about callbacks registered with a handle with the <code class="codeph">OCIUserCallbackGet()</code> function.</p>
<p>A user-defined callback is a subroutine that is registered against an OCI call and an environment handle. It can be specified to be either an entry callback, a replacement callback, or an exit callback.</p>
<ul style="list-style-type: disc;">
<li>
<p>If it is an entry callback, it is called when the program enters the OCI function.</p>
</li>
<li>
<p>Replacement callbacks are executed after entry callbacks. If the replacement callback returns a value of <code class="codeph">OCI_CONTINUE</code>, then a subsequent replacement callback or the normal OCI-specific code is executed. If a replacement callback returns anything other than <code class="codeph">OCI_CONTINUE</code>, then subsequent replacement callbacks and the OCI code do not execute.</p>
</li>
<li>
<p>After a replacement callback returns something other than <code class="codeph">OCI_CONTINUE</code>, or an OCI function successfully executes, program control transfers to the exit callback (if one is registered).</p>
</li>
</ul>
<p>If a replacement or exit callback returns anything other than <code class="codeph">OCI_CONTINUE</code>, then the return code from the callback is returned from the associated OCI call.</p>
<p>A user callback can return <code class="codeph">OCI_INVALID_HANDLE</code> when either an invalid handle or an invalid context is passed to it.</p>
<div class="infobox-note" id="GUID-37001800-DC08-4253-8958-4F51A734FCE0__GUID-BE2072F7-E5DD-464D-98FF-B94366948A29">
<p class="notep1">Note:</p>
<p>If any callback returns anything other than <code class="codeph">OCI_CONTINUE</code>, then that return code is passed to the subsequent callbacks. If a replacement or exit callback returns a return code other than <code class="codeph">OCI_CONTINUE</code>, then the final (not <code class="codeph">OCI_CONTINUE</code>) return code is returned from the OCI call.</p>
</div>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-7CC81F1D-0EB3-464A-B87F-CF4F18BCBA7C" title="A user callback is registered using the OCIUserCallbackRegister() call.">OCIUserCallbackRegister</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-7C13E29F-1300-47C4-96BE-142756FD6F61">User Callback Function</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-4815D8E1-B24F-4ADF-98D0-934CFC4192F8">User Callback Control Flow</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-151E2492-7F00-497F-B253-0F789E405BFB">User Callback for OCIErrorGet()</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-774331BE-507E-43B5-ABAC-F93A861C9F9C">Errors from Entry Callbacks</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-C1E8C023-F0D4-4C0A-8585-DA6CCA0DDF65">Dynamic Callback Registrations</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-C58991CA-395F-4DCC-9795-D688931DFFB5">About Loading Multiple Packages</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-46F2412A-F84C-4C2A-983A-BF0AAA36647F">Package Format</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-9E6DD6F6-FF2A-49B6-8832-3651A4C7502E">User Callback Chaining</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-63F27A12-2778-43A0-918F-35F310E0EAA6">About Accessing Other Data Sources Through OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-1E75F3F2-673D-4D80-B9C3-89119D47CCB9">Restrictions on Callback Functions</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-A817AC07-545A-4C3B-A155-027D1889CA38" title="Shows examples of using OCI callbacks.">Example of OCI Callbacks</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-37001800-DC08-4253-8958-4F51A734FCE0__GUID-9FBD9D48-595E-494F-A553-D13E3AC2B6F2">
<p class="notep1">See Also:</p>
<p><a href="oci17msc007.htm#GUID-2249B3FF-5E24-40AE-B310-EA63DBF37263" title="Determines the callback that is registered for a handle.">OCIUserCallbackGet()</a> and <a href="oci17msc007.htm#GUID-A11D635A-806B-445E-BDCF-F145E86232CF" title="Registers a user-created callback function.">OCIUserCallbackRegister()</a></p>
</div>
</div>
<a id="LNOCI16663"></a>
<div class="props_rev_3"><a id="GUID-7CC81F1D-0EB3-464A-B87F-CF4F18BCBA7C"></a>
<h4 id="LNOCI-GUID-7CC81F1D-0EB3-464A-B87F-CF4F18BCBA7C" class="sect4">OCIUserCallbackRegister</h4>
<div>
<p>A user callback is registered using the OCIUserCallbackRegister() call.</p>
<p>Currently, <code class="codeph">OCIUserCallbackRegister()</code> is only registered on the environment handle. The user&#39;s callback function of typedef <code class="codeph">OCIUserCallback</code> is registered along with its context for the OCI call identified by the OCI function code, <span class="italic">fcode</span>. The type of the callback, whether entry, replacement, or exit, is specified by the <span class="italic">when</span> parameter.</p>
<p>For example, the <code class="codeph">stmtprep_entry_dyncbk_fn</code> entry callback function and its context <code class="codeph">dynamic_context</code>, are registered against the environment handle <code class="codeph">hndlp</code> for the <code class="codeph">OCIStmtPrepare2()</code> call by calling the <code class="codeph">OCIUserCallbackRegister()</code> function with the following parameters.</p>
<pre dir="ltr">OCIUserCallbackRegister( hndlp, 
                         OCI_HTYPE_ENV, 
                         errh, 
                         stmtprep_entry_dyncbk_fn, 
                         dynamic_context, 
                         OCI_FNCODE_STMTPREPARE,
                         OCI_UCBTYPE_ENTRY
                         (OCIUcb*) NULL);
</pre>
<div class="infoboxnotealso" id="GUID-7CC81F1D-0EB3-464A-B87F-CF4F18BCBA7C__GUID-59A8DFDF-95BC-4149-B6A2-9651C72A08B2">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci17msc007.htm#GUID-A11D635A-806B-445E-BDCF-F145E86232CF" title="Registers a user-created callback function.">OCIUserCallbackRegister()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16664"></a>
<div class="props_rev_3"><a id="GUID-7C13E29F-1300-47C4-96BE-142756FD6F61"></a>
<h4 id="LNOCI-GUID-7C13E29F-1300-47C4-96BE-142756FD6F61" class="sect4">User Callback Function</h4>
<div>
<p>The user callback function must use the following syntax:</p>
<pre dir="ltr">typedef sword (*OCIUserCallback)
     (void *ctxp,      /* context for the user callback*/
      void *hndlp,     /* handle for the callback, env handle for now */
      ub4 type,         /* type of handlp, OCI_HTYPE_ENV for this release */
      ub4 fcode,        /* function code of the OCI call */
      ub1 when,         /* type of the callback, entry or exit */
      sword returnCode, /* OCI return code */
      ub4 *errnop,      /* Oracle error number */
      va_list arglist); /* parameters of the oci call */
</pre>
<p>In addition to the parameters described in the <a href="oci17msc007.htm#GUID-A11D635A-806B-445E-BDCF-F145E86232CF" title="Registers a user-created callback function.">OCIUserCallbackRegister()</a> call, the callback is called with the return code, <span class="italic">errnop</span>, and all the parameters of the original OCI as declared by the prototype definition.</p>
<p>The return code is always passed in as <code class="codeph">OCI_SUCCESS</code> and <code class="codeph">*errnop</code> is always passed in as 0 for the first entry callback. Note that <code class="codeph">*errnop</code> refers to the content of <code class="codeph">errnop</code> because <code class="codeph">errnop</code> is an IN/OUT parameter.</p>
<p>If the callback does not want to change the OCI return code, then it must return <code class="codeph">OCI_CONTINUE</code>, and the value returned in <code class="codeph">*errnop</code> is ignored. If, however, the callback returns any return code other than <code class="codeph">OCI_CONTINUE</code>, the last returned return code becomes the return code for the call. At this point, the value returned for <code class="codeph">*errnop</code> is set in the error handle, or in the environment handle if the error information is returned in the environment handle because of the absence of the error handle for certain OCI calls such as <a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a>.</p>
<p>For replacement callbacks, the <code class="codeph">returnCode</code> is the non-<code class="codeph">OCI_CONTINUE</code> return code from the previous callback or OCI call, and <code class="codeph">*errnop</code> is the value of the error number being returned in the error handle. This allows the subsequent callback to change the return code or error information if needed.</p>
<p>The processing of replacement callbacks is different in that if it returns anything other than <code class="codeph">OCI_CONTINUE</code>, then subsequent replacement callbacks and OCI code are bypassed and processing jumps to the exit callbacks.</p>
<p>Note that if the replacement callbacks return <code class="codeph">OCI_CONTINUE</code> to allow processing of OCI code, then the return code from entry callbacks is ignored.</p>
<p>All the original parameters of the OCI call are passed to the callback as variable parameters, and the callback must retrieve them using the <span class="italic">va_arg</span> macros. The callback demonstration programs provide examples.</p>
<div class="infoboxnotealso" id="GUID-7C13E29F-1300-47C4-96BE-142756FD6F61__GUID-990C8569-7ECF-4D27-86E7-927AD6279D49">
<p class="notep1">See Also:</p>
<p>Appendix&nbsp;B, &#34;OCI Demonstration Programs&#34;</p>
</div>
<p>A null value can be registered to deregister a callback. That is, if the value of the callback (<code class="codeph">OCIUserCallback()</code>) is <code class="codeph">NULL</code> in the <a href="oci17msc007.htm#GUID-A11D635A-806B-445E-BDCF-F145E86232CF" title="Registers a user-created callback function.">OCIUserCallbackRegister()</a> call, then the user callback is deregistered.</p>
<p>When using the thread-safe mode, the OCI program acquires all mutexes before calling the user callbacks.</p>
</div>
</div>
<a id="LNOCI72671"></a><a id="LNOCI16665"></a>
<div class="props_rev_3"><a id="GUID-4815D8E1-B24F-4ADF-98D0-934CFC4192F8"></a>
<h4 id="LNOCI-GUID-4815D8E1-B24F-4ADF-98D0-934CFC4192F8" class="sect4">User Callback Control Flow</h4>
<div>
<p><a href="oci09adv.htm#GUID-4815D8E1-B24F-4ADF-98D0-934CFC4192F8__CACJAFAG">Example 9-2</a> shows pseudocode that describes the overall processing of a typical OCI call.</p>
<div class="example" id="GUID-4815D8E1-B24F-4ADF-98D0-934CFC4192F8__CACJAFAG">
<p class="titleinexample">Example 9-2 Pseudocode That Describes the Overall Processing of a Typical OCI Call</p>
<pre dir="ltr">OCIXyzCall()
{
 Acquire mutexes on handles;
 retCode = OCI_SUCCESS;
 errno = 0;
 for all ENTRY callbacks do
  {
     
     EntryretCode = (*entryCallback)(..., retcode, &amp;errno, ...);
     if (retCode != OCI_CONTINUE)
      {
         set errno in error handle or environment handle;
         retCode = EntryretCode;
       }
   }
  for all REPLACEMENT callbacks do
  {
   retCode = (*replacementCallback) (..., retcode, &amp;errno, ...);
   if (retCode != OCI_CONTINUE)
      {
       set errno in error handle or environment handle
       goto executeEXITCallback;
       }
   }

   retCode = return code for XyzCall; /* normal processing of OCI call */

   errno = error number from error handle or env handle;

 executeExitCallback:
   for all EXIT callbacks do
   {
       exitRetCode = (*exitCallback)(..., retCode, &amp;errno,...);
       if (exitRetCode != OCI_CONTINUE)
       {
           set errno in error handle or environment handle;
           retCode = exitRetCode;
       }
   }
    release mutexes;
    return retCode
}
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI16666"></a>
<div class="props_rev_3"><a id="GUID-151E2492-7F00-497F-B253-0F789E405BFB"></a>
<h4 id="LNOCI-GUID-151E2492-7F00-497F-B253-0F789E405BFB" class="sect4">User Callback for OCIErrorGet()</h4>
<div>
<p>If the callbacks are a total replacement of the OCI code, then they usually maintain their own error information in the call context and use that to return error information in <code class="codeph">bufp</code> and <code class="codeph">errcodep</code> parameters of the replacement callback of the <a href="oci17msc007.htm#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="Returns an error message and an Oracle Database error code.">OCIErrorGet()</a> call.</p>
<p>If, however, the callbacks are either partially overriding OCI code, or just doing some other postprocessing, then they can use the exit callback to modify the error text and <code class="codeph">errcodep</code> parameters of the <a href="oci17msc007.htm#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="Returns an error message and an Oracle Database error code.">OCIErrorGet()</a> call by their own error message and error number. Note that the <code class="codeph">*errnop</code> passed into the exit callback is the error number in the error or the environment handle.</p>
</div>
</div>
<a id="LNOCI16667"></a>
<div class="props_rev_3"><a id="GUID-774331BE-507E-43B5-ABAC-F93A861C9F9C"></a>
<h4 id="LNOCI-GUID-774331BE-507E-43B5-ABAC-F93A861C9F9C" class="sect4">Errors from Entry Callbacks</h4>
<div>
<p>If an entry callback wants to return an error to the caller of the OCI call, then it must register a replacement or exit callback. This is because if the OCI code is executed, then the error code from the entry callback is ignored. Therefore, the entry callback must pass the error to the replacement or exit callback through its own context.</p>
</div>
</div>
<a id="LNOCI16668"></a>
<div class="props_rev_3"><a id="GUID-C1E8C023-F0D4-4C0A-8585-DA6CCA0DDF65"></a>
<h4 id="LNOCI-GUID-C1E8C023-F0D4-4C0A-8585-DA6CCA0DDF65" class="sect4">Dynamic Callback Registrations</h4>
<div>
<p>Because user callbacks are expected to be used for monitoring OCI behavior or to access other data sources, it is desirable that the registration of the callbacks be done transparently and nonintrusively. This is accomplished by loading user-created dynamically linked libraries at OCI initialization time. These dynamically linked libraries are called <span class="italic">packages</span>. The user-created packages register the user callbacks for the selected OCI calls. These callbacks can further register or deregister user callbacks as needed when receiving control at runtime.</p>
<p>A makefile (<code class="codeph">ociucb.mk</code> on Solaris) is provided with the OCI demonstration programs to create the package. The exact naming and location of this package is operating system-dependent. The source code for the package must provide code for special callbacks that are called at OCI initialization and environment creation times.</p>
<p>Setting an operating system environment variable, <code class="codeph">ORA_OCI_UCBPKG</code>, controls the loading of the package. This variable names the packages in a generic way. The packages must be located in the <code class="codeph">$ORACLE_HOME/lib</code> directory.</p>
</div>
</div>
<a id="LNOCI16669"></a>
<div class="props_rev_3"><a id="GUID-C58991CA-395F-4DCC-9795-D688931DFFB5"></a>
<h4 id="LNOCI-GUID-C58991CA-395F-4DCC-9795-D688931DFFB5" class="sect4">About Loading Multiple Packages</h4>
<div>
<p>The <code class="codeph">ORA_OCI_UCBPKG</code> variable can contain a semicolon-separated list of package names. The packages are loaded in the order they are specified in the list.</p>
<p>For example, in the past the package was specified as:</p>
<pre dir="ltr">setenv ORA_OCI_UCBPKG mypkg
</pre>
<p>Currently, you can still specify the package as before, but in addition multiple packages can be specified as:</p>
<pre dir="ltr">setenv ORA_OCI_UCBPKG &#34;mypkg;yourpkg;oraclepkg;sunpkg;msoftpkg&#34;
</pre>
<p>All these packages are loaded in order. That is, <code class="codeph">mypkg</code> is loaded first and <code class="codeph">msoftpkg</code> is loaded last.</p>
<p>A maximum of five packages can be specified.</p>
<div class="infobox-note" id="GUID-C58991CA-395F-4DCC-9795-D688931DFFB5__GUID-B774EC50-C033-4956-8EC3-93839484CF2B">
<p class="notep1">Note:</p>
<p>The sample makefile <code class="codeph">ociucb.mk</code> creates <code class="codeph">ociucb.so.1.0</code> on a Solaris or <code class="codeph">ociucb.dll</code> on a Windows system. To load the <code class="codeph">ociucb</code> package, the environmental variable <code class="codeph">ORA_OCI_UCBPKG</code> must be set to <code class="codeph">ociucb</code>. On Solaris, if the package name ends with <code class="codeph">.so</code>, OCIEnvCreate() or OCIEnvNlsCreate() fails. The package name must end with <code class="codeph">.so.1.0</code>.</p>
<p>For further details about creating the dynamic-link libraries, read the Makefiles provided in the demo directory for your operating system. For further information about user-defined callbacks, see your operating system-specific documentation on compiling and linking applications.</p>
</div>
</div>
</div>
<a id="LNOCI16670"></a>
<div class="props_rev_3"><a id="GUID-46F2412A-F84C-4C2A-983A-BF0AAA36647F"></a>
<h4 id="LNOCI-GUID-46F2412A-F84C-4C2A-983A-BF0AAA36647F" class="sect4">Package Format</h4>
<div>
<p>In the past, a package had to specify the source code for the <code class="codeph">OCIEnvCallback()</code> function. However, the <code class="codeph">OCIEnvCallback()</code> function is obsolete. Instead, the package source must provide two functions. The first function must be named as <span class="italic">packagename</span> suffixed with the word <span class="italic">Init</span>. For example, if the package is named <code class="codeph">foo</code>, then the source file (for example, but not necessarily, foo.c) must contain a <code class="codeph">fooInit()</code> function with a call to <code class="codeph">OCISharedLibInit()</code> function specified exactly as:</p>
<pre dir="ltr">sword fooInit(metaCtx, libCtx, argfmt, argc, argv)
      void *     metaCtx;         /* The metacontext */
      void *     libCtx;          /* The context for this package. */
      ub4        argfmt;          /* package argument format */
      sword      argc;            /* package arg count*/
      void *     argv[];          /* package arguments */
{
  return  (OCISharedLibInit(metaCtx, libCtx, argfmt, argc, argv,
                            fooEnvCallback));
}
</pre>
<p>The last parameter of the <code class="codeph">OCISharedLibInit()</code> function, <code class="codeph">fooEnvCallback()</code> in this case, is the name of the second function. It can be named anything, but by convention it is named <span class="italic">packagename</span> suffixed with the word <span class="italic">EnvCallback</span>.</p>
<p>This function is a replacement for <code class="codeph">OCIEnvCallback()</code>. Currently, all the dynamic user callbacks must be registered in this function. The function must be of type <code class="codeph">OCIEnvCallbackType</code>, which is specified as:</p>
<pre dir="ltr">typedef sword (*OCIEnvCallbackType)(OCIEnv *env, ub4 mode,
                                    size_t xtramem_sz, void *usrmemp,
                                    OCIUcb *ucbDesc);
</pre>
<p>When an environment handle is created, then this callback function is called at the very end. The <code class="codeph">env</code> parameter is the newly created environment handle.</p>
<p>The <code class="codeph">mode</code>, <code class="codeph">xtramem_sz</code>, and <code class="codeph">usrmempp</code> are the parameters passed to the OCIEnvCreate() call. The last parameter, <code class="codeph">ucbDesc</code>, is a descriptor that is passed to the package. The package uses this descriptor to register the user callbacks as described later.</p>
<p>A sample <code class="codeph">ociucb.c</code> file is provided in the <code class="codeph">demo</code> directory. The makefile <code class="codeph">ociucb.mk</code> is also provided (on Solaris) in the <code class="codeph">demo</code> directory to create the package. Please note that this may be different on other operating systems. The <code class="codeph">demo</code> directory also contains full user callback demo programs (<code class="codeph">cdemoucb.c, cdemoucbl.c</code>) illustrating this.</p>
</div>
</div>
<a id="LNOCI16671"></a>
<div class="props_rev_3"><a id="GUID-9E6DD6F6-FF2A-49B6-8832-3651A4C7502E"></a>
<h4 id="LNOCI-GUID-9E6DD6F6-FF2A-49B6-8832-3651A4C7502E" class="sect4">User Callback Chaining</h4>
<div>
<p>User callbacks can be registered statically in the application itself or dynamically at runtime in the DLLs. A mechanism is needed to allow the application to override a previously registered callback and then later invoke the overridden one in the newly registered callback to preserve the behavior intended by the dynamic registrations. This can result in chaining of user callbacks.</p>
<p>The <a href="oci17msc007.htm#GUID-2249B3FF-5E24-40AE-B310-EA63DBF37263" title="Determines the callback that is registered for a handle.">OCIUserCallbackGet()</a> function determines which function and context is registered for an OCI call.</p>
<div class="infoboxnotealso" id="GUID-9E6DD6F6-FF2A-49B6-8832-3651A4C7502E__GUID-DEF2F5EB-F20C-46CF-8D33-A087EE508ACF">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="oci17msc007.htm#GUID-2249B3FF-5E24-40AE-B310-EA63DBF37263" title="Determines the callback that is registered for a handle.">OCIUserCallbackGet()</a>&#34;</span></p>
</div>
</div>
</div>
<a id="LNOCI16672"></a>
<div class="props_rev_3"><a id="GUID-63F27A12-2778-43A0-918F-35F310E0EAA6"></a>
<h4 id="LNOCI-GUID-63F27A12-2778-43A0-918F-35F310E0EAA6" class="sect4">About Accessing Other Data Sources Through OCI</h4>
<div>
<p>Because Oracle Database is the predominant database software accessed, applications can take advantage of the OCI interface to access non-Oracle data by using the user callbacks to access them. This allows an application written in OCI to access Oracle data without any performance penalty. Drivers can be written that access the non-Oracle data in user callbacks. Because OCI provides a very rich interface, there is usually a straightforward mapping of OCI calls to most data sources. This solution is better than writing applications for other middle layers such as ODBC that introduce performance penalties for all data sources. Using OCI does not incur any penalty to access Oracle data sources, and incurs the same penalty that ODBC does for non-Oracle data sources.</p>
</div>
</div>
<a id="LNOCI16673"></a>
<div class="props_rev_3"><a id="GUID-1E75F3F2-673D-4D80-B9C3-89119D47CCB9"></a>
<h4 id="LNOCI-GUID-1E75F3F2-673D-4D80-B9C3-89119D47CCB9" class="sect4">Restrictions on Callback Functions</h4>
<div>
<p>There are certain restrictions on the usage of callback functions, including <code class="codeph">OCIEnvCallback()</code>:</p>
<ul style="list-style-type: disc;">
<li>
<p>A callback cannot call other OCI functions except <a href="oci17msc007.htm#GUID-A11D635A-806B-445E-BDCF-F145E86232CF" title="Registers a user-created callback function.">OCIUserCallbackRegister()</a>, <a href="oci17msc007.htm#GUID-2249B3FF-5E24-40AE-B310-EA63DBF37263" title="Determines the callback that is registered for a handle.">OCIUserCallbackGet()</a>, <a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a>, and <a href="oci16rel002.htm#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A">OCIHandleFree()</a>. Even for these functions, if they are called in a user callback, then callbacks on them are not called to avoid recursion. For example, if <code class="codeph">OCIHandleFree()</code> is called in the callback for <a href="oci16rel001.htm#GUID-567DA731-ABC9-4348-B29C-7B2C6C1D7C36" title="Releases a session that was retrieved using OCILogon2() or OCILogon().">OCILogoff()</a>, then the callback for <code class="codeph">OCIHandleFree()</code> is disabled during the execution of the callback for <code class="codeph">OCILogoff()</code>.</p>
</li>
<li>
<p>A callback cannot modify OCI data structures such as the environment or error handles.</p>
</li>
<li>
<p>A callback cannot be registered for the <a href="oci17msc007.htm#GUID-A11D635A-806B-445E-BDCF-F145E86232CF" title="Registers a user-created callback function.">OCIUserCallbackRegister()</a> call itself, or for any of the following calls:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci17msc007.htm#GUID-2249B3FF-5E24-40AE-B310-EA63DBF37263" title="Determines the callback that is registered for a handle.">OCIUserCallbackGet()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="Creates and initializes an environment handle for OCI functions to work under.">OCIEnvCreate()</a></p>
</li>
<li>
<p><a href="ociaedep001.htm#GUID-F50356A8-450D-4A96-8AB5-5726502766B2" title="This function was deprecated in a release previous to Oracle Database 11g Release 2 (11.2).">OCIInitialize()</a> (Deprecated)</p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="Creates and initializes an environment handle for OCI functions to work under.">OCIEnvNlsCreate()</a></p>
</li>
</ul>
</li>
</ul>
</div>
</div>
<a id="LNOCI72672"></a><a id="LNOCI72673"></a><a id="LNOCI72674"></a><a id="LNOCI72675"></a><a id="LNOCI72676"></a><a id="LNOCI16674"></a>
<div class="props_rev_3"><a id="GUID-A817AC07-545A-4C3B-A155-027D1889CA38"></a>
<h4 id="LNOCI-GUID-A817AC07-545A-4C3B-A155-027D1889CA38" class="sect4">Example of OCI Callbacks</h4>
<div>
<p>Shows examples of using OCI callbacks.</p>
<div class="section">
<p>Suppose that there are five packages each registering entry, replacement, and exit callbacks for the <code class="codeph">OCIStmtPrepare2()</code> call. That is, the <code class="codeph">ORA_OCI_UCBPKG</code> variable is set as shown in <a href="oci09adv.htm#GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACBICBD">Example 9-3</a>.</p>
<p>In each package <code class="codeph">pkgN</code> (where N can be 1 through 5), the <code class="codeph">pkgNInit()</code> and <code class="codeph">PkgNEnvCallback()</code> functions are specified, as shown in <a href="oci09adv.htm#GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACJEBJF">Example 9-4</a>.</p>
<p><a href="oci09adv.htm#GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACDFCCC">Example 9-5</a> shows how the <code class="codeph">pkgNEnvCallback()</code> function registers the entry, replacement, and exit callbacks.</p>
<p>Finally, <a href="oci09adv.htm#GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACBJDFA">Example 9-6</a> shows how in the source code for the application, user callbacks can be registered with the <code class="codeph">NULL</code> <span class="italic">ucbDesc</span>.</p>
<p><a href="oci09adv.htm#GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACJHCID">Example 9-7</a> shows that when the <code class="codeph">OCIStmtPrepare2()</code> call is executed, the callbacks are called in the following order.</p>
<div class="infobox-note" id="GUID-A817AC07-545A-4C3B-A155-027D1889CA38__GUID-46C97747-CAC2-40EE-BA75-668C3483997F">
<p class="notep1">Note:</p>
<p>The exit callbacks are called in the reverse order of the entry and replacement callbacks.</p>
</div>
<p>The entry and exit callbacks can return any return code and the processing continues to the next callback. However, if the replacement callback returns anything other than <code class="codeph">OCI_CONTINUE</code>, then the next callback (or OCI code if it is the last replacement callback) in the chain is bypassed and processing jumps to the exit callback. For example, if <code class="codeph">pkg3_replace_callback_fn()</code> returned <code class="codeph">OCI_SUCCESS</code>, then <code class="codeph">pkg4_replace_callback_fn()</code>, <code class="codeph">pkg5_replace_callback_fn()</code>, and the OCI processing for the <code class="codeph">OCIStmtPrepare2()</code> call are bypassed. Instead, <code class="codeph">pkg5_exit_callback_fn()</code> is executed next.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACBICBD">
<p class="titleinexample">Example 9-3 Environment Variable Setting for the ORA_OCI_UCBPKG Variable</p>
<pre dir="ltr">setenv ORA_OCI_UCBPKG &#34;pkg1;pkg2;pkg3;pkg4;pkg5&#34; 
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACJEBJF">
<p class="titleinexample">Example 9-4 Specifying the pkgNInit() and PkgNEnvCallback() Functions</p>
<pre dir="ltr">pkgNInit(void *metaCtx, void *libCtx, ub4 argfmt, sword argc, void **argv)
{
  return OCISharedLibInit(metaCtx, libCtx, argfmt, argc, argv, pkgNEnvCallback);
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACDFCCC">
<p class="titleinexample">Example 9-5 Using pkgNEnvCallback() to Register Entry, Replacement, and Exit Callbacks</p>
<pre dir="ltr">pkgNEnvCallback(OCIEnv *env, ub4 mode, size_t xtramemsz,
                                void *usrmemp, OCIUcb *ucbDesc)
{
  OCIHandleAlloc((void *)env, (void **)&amp;errh, OCI_HTYPE_ERROR, (size_t) 0,
        (void **)NULL);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, pkgN_entry_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_ENTRY, ucbDesc);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, pkgN_replace_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_REPLACE, ucbDesc);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, pkgN_exit_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_EXIT, ucbDesc);

  return OCI_CONTINUE;
}
 
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACBJDFA">
<p class="titleinexample">Example 9-6 Registering User Callbacks with the NULL ucbDesc</p>
<pre dir="ltr">  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, static_entry_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_ENTRY, (OCIUcb *)NULL);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, static_replace_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_REPLACE, (OCIUcb *)NULL);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, static_exit_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_EXIT, (OCIUcb *)NULL);
 
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-A817AC07-545A-4C3B-A155-027D1889CA38__CACJHCID">
<p class="titleinexample">Example 9-7 Using the OCIStmtPrepare() Call to Call the Callbacks in Order</p>
<pre dir="ltr">static_entry_callback_fn() 
pkg1_entry_callback_fn() 
pkg2_entry_callback_fn() 
pkg3_entry_callback_fn() 
pkg4_entry_callback_fn() 
pkg5_entry_callback_fn() 
 
static_replace_callback_fn() 
 pkg1_replace_callback_fn() 
  pkg2_replace_callback_fn() 
   pkg3_replace_callback_fn() 
    pkg4_replace_callback_fn() 
     pkg5_replace_callback_fn() 
 
      OCI code for OCIStmtPrepare call 
 
pkg5_exit_callback_fn() 
pkg4_exit_callback_fn() 
pkg3_exit_callback_fn() 
pkg2_exit_callback_fn() 
pkg1_exit_callback_fn()

static_exit_callback_fn()
</pre></div>
<!-- class="example" -->
<div class="section">
<div class="infoboxnotealso" id="GUID-A817AC07-545A-4C3B-A155-027D1889CA38__GUID-13D2CB18-469C-48D7-AC67-8CF186238E8C">
<p class="notep1">See Also:</p>
<p><a href="oci17msc001.htm#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a></p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="LNOCI16675"></a>
<div class="props_rev_3"><a id="GUID-163FF0B1-BAA9-4300-BA7C-170AAF0960ED"></a>
<h3 id="LNOCI-GUID-163FF0B1-BAA9-4300-BA7C-170AAF0960ED" class="sect3">OCI Callbacks from External Procedures</h3>
<div>
<p>There are several OCI functions that you can use as callbacks from external procedures. These functions are listed in <a href="oci20ext.htm#GUID-82822159-3CC2-47D6-BD6C-B75BB1B1BA49" title="This chapter presents the cartridge functions.">OCI Cartridge Functions</a>. For information about writing C subroutines that can be called from PL/SQL code, including a list of which OCI calls you can use and some example code, see <a class="olink ADFNS010" target="_blank" href="../ADFNS/adfns_externproc.htm#ADFNS010"><span class="italic">Oracle Database Development Guide</span></a>.</p>
</div>
</div>
</div>
<a id="LNOCI16679"></a>
<div class="props_rev_3"><a id="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F"></a>
<h2 id="LNOCI-GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F" class="sect2">Transparent Application Failover in OCI</h2>
<div>
<p>Transparent application failover (TAF) is a client-side feature designed to minimize disruptions to end-user applications that occur when database connectivity fails because of instance or network failure. TAF can be implemented on a variety of system configurations including Oracle Real Application Clusters (Oracle RAC) and Oracle Data Guard physical standby databases. TAF can also be used after restarting a single instance system (for example, when repairs are made).</p>
<p>TAF can be configured to restore database sessions and, optionally, to replay open queries. Prior to Oracle Database 10g Release 2 (10.2), TAF with the <code class="codeph">SELECT</code> failover option would be engaged only on the statement that was in use at the time of a failure. For example, if there were 10 statement handles in use by the application, and statement 7 was the failure-time statement (the statement in use when the failure happened), statements 1 through 6 and 8 through 10 would have to be reexecuted after statement 7 was failed over using TAF.</p>
<p>Starting with Oracle Database 10g Release 2 (10.2), this has been improved. Now all statements that an application attempts to use after a failure attempt failover. That is, an attempt to execute or fetch against other statements engages TAF recovery just as for the failure-time statement. Subsequent statements may now succeed (whereas in the past they failed), or the application may receive errors corresponding to an attempted TAF recovery (such as <code class="codeph">ORA-25401</code>).</p>
<div class="infobox-note" id="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F__GUID-73D1C2D4-6843-43A3-9170-3DEAB74F5BA5">
<p class="notep1">Note:</p>
<p>Oracle recommends for applications to register a callback, so when failover happens, the callback can be used to restore the session to the desired state.</p>
</div>
<div class="infobox-note" id="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F__GUID-F4ECC2C1-0DBC-4EB2-A14F-C44453ECDFE4">
<p class="notep1">Note:</p>
<p>TAF is not supported for remote database links or for DML statements.</p>
</div>
<div class="p">This section contains the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F" title="TAF can be configured on both the client side and the server side. If both are configured, server-side settings take precedence.">About Configuring Transparent Application Failover</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029" title="Because of the delay that can occur during failover, the application developer may want to inform the user that failover is in progress, and request that the user wait for notification that failover is complete.">Transparent Application Failover Callbacks in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-C3241340-0A2E-4D02-9981-A7F091051664">Failover Callback Structure and Parameters</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3">Failover Callback Registration</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-860A2B81-F867-4345-96DE-F423753D1D91">Failover Callback Example</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8">Handling OCI_FO_ERROR</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16680"></a>
<div class="props_rev_3"><a id="GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F"></a>
<h3 id="LNOCI-GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F" class="sect3">About Configuring Transparent Application Failover</h3>
<div>
<p>TAF can be configured on both the client side and the server side. If both are configured, server-side settings take precedence.</p>
<p>Configure TAF on the client side by including the <code class="codeph">FAILOVER_MODE</code> parameter in the <code class="codeph">CONNECT_DATA</code> portion of a connect descriptor.</p>
<p>Configure TAF on the server side by modifying the target service with the <code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code> packaged procedure.</p>
<p>An initial attempt at failover may not always succeed. OCI provides a mechanism for retrying failover after an unsuccessful attempt.</p>
<div class="infoboxnotealso" id="GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F__GUID-5399ECA3-3E96-456B-AB8A-58C06FF94417">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink NETRF279" target="_blank" href="../NETRF/tnsnames.htm#NETRF279"><span><cite>Oracle Database Net Services Reference</cite></span></a> for more information about client-side configuration of TAF (Connect Data Section)</p>
</li>
<li>
<p><a class="olink ARPLS092" target="_blank" href="../ARPLS/d_serv.htm#ARPLS092"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for more information about the server-side configuration of TAF (DBMS_SERVICE)</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16681"></a>
<div class="props_rev_3"><a id="GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029"></a>
<h3 id="LNOCI-GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029" class="sect3">Transparent Application Failover Callbacks in OCI</h3>
<div>
<p>Because of the delay that can occur during failover, the application developer may want to inform the user that failover is in progress, and request that the user wait for notification that failover is complete.</p>
<p>Additionally, the session on the initial instance may have received some <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> commands. These <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> commands are not automatically replayed on the second instance. Consequently, the developer may want to replay them on the second instance. <code class="codeph">OCIAttrSet()</code> calls that affect the session must also be reexecuted.</p>
<p>To accommodate these requirements, the application developer can register a failover callback function. If failover occurs, the callback function is invoked several times while reestablishing the user&#39;s session.</p>
<p>The first call to the callback function occurs when the database first detects an instance connection loss. This callback is intended to allow the application to inform the user of an upcoming delay. If failover is successful, a second call to the callback function occurs when the connection is reestablished and usable.</p>
<p>Once the connection has been reestablished, the client may want to replay <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> commands and inform the user that failover has happened. If failover is unsuccessful, then the callback is called to inform the application that failover cannot occur. Additionally, the callback is called each time a user handle besides the primary handle is reauthenticated on the new connection. Because each user handle represents a server-side session, the client may want to replay <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> commands for that session.</p>
<div class="infoboxnotealso" id="GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029__GUID-3472650E-73ED-4D3C-AAB5-ECA412AFD7F0">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel002.htm#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="Sets the value of an attribute of a handle or a descriptor.">OCIAttrSet()</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8">Handling OCI_FO_ERROR</a> for more information about this scenario</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16682"></a>
<div class="props_rev_3"><a id="GUID-C3241340-0A2E-4D02-9981-A7F091051664"></a>
<h3 id="LNOCI-GUID-C3241340-0A2E-4D02-9981-A7F091051664" class="sect3">Failover Callback Structure and Parameters</h3>
<div>
<p>The basic structure of a user-defined application failover callback function is as follows:</p>
<pre dir="ltr">sb4 appfocallback_fn ( void       * svchp, 
                       void       * envhp, 
                       void       * fo_ctx, 
                       ub4        fo_type, 
                       ub4        fo_event );
</pre>
<p>An example is provided in &#34;Failover Callback Example&#34; on page&nbsp;9‐31 for the following parameters:</p>
<dl>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73980"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-BEA274C9-256A-4618-AF1E-8B752BA5FA54"><!-- --></a>svchp</dt>
<dd>
<p>The first parameter, <code class="codeph">svchp</code>, is the service context handle. It is of type <code class="codeph">void *</code>.</p>
</dd>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73981"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-E0324FA7-6FDD-4AB3-A132-C3C6BB676F0E"><!-- --></a>envhp</dt>
<dd>
<p>The second parameter, <code class="codeph">envhp</code>, is the OCI environment handle. It is of type <code class="codeph">void *</code>.</p>
</dd>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73982"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-7BEAF6CC-5C8B-4669-B86E-AC9C71BAB580"><!-- --></a>fo_ctx</dt>
<dd>
<p>The third parameter, <code class="codeph">fo_ctx</code>, is a client context. It is a pointer to memory specified by the client. In this area the client can keep any necessary state or context. It is passed as a <code class="codeph">void *</code>.</p>
</dd>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73983"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-F02332EE-B218-4728-BE16-CE8F7120B294"><!-- --></a>fo_type</dt>
<dd>
<p>The fourth parameter, <code class="codeph">fo_type</code>, is the failover type. This lets the callback know what type of failover the client has requested. The usual values are as follows:</p>
</dd>
</dl>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCI_FO_SESSION</code> indicates that the user has requested only session failover.</p>
</li>
<li>
<p><code class="codeph">OCI_FO_SELECT</code> indicates that the user has requested select failover as well.</p>
</li>
</ul>
<dl>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73984"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-B41E338F-B047-400E-B249-F54CD38EBD55"><!-- --></a>fo_event</dt>
<dd>
<p>The last parameter is the failover event. This indicates to the callback why it is being called. It has several possible values:</p>
</dd>
</dl>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCI_FO_BEGIN</code> indicates that failover has detected a lost connection and failover is starting.</p>
</li>
<li>
<p><code class="codeph">OCI_FO_END</code> indicates successful completion of failover.</p>
</li>
<li>
<p><code class="codeph">OCI_FO_ABORT</code> indicates that failover was unsuccessful, and there is no option of retrying.</p>
</li>
<li>
<p><code class="codeph">OCI_FO_ERROR</code> also indicates that failover was unsuccessful, but it gives the application the opportunity to handle the error and retry failover.</p>
</li>
<li>
<p><code class="codeph">OCI_FO_REAUTH</code> indicates that you have multiple authentication handles and failover has occurred after the original authentication. It indicates that a user handle has been reauthenticated. To determine which one, the application checks the <code class="codeph">OCI_ATTR_SESSION</code> attribute of the service context handle (which is the first parameter).</p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16683"></a>
<div class="props_rev_3"><a id="GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3"></a>
<h3 id="LNOCI-GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3" class="sect3">Failover Callback Registration</h3>
<div>
<p>For the failover callback to be used, it must be registered on the server context handle. This registration is done by creating a callback definition structure and setting the <code class="codeph">OCI_ATTR_FOCBK</code> attribute of the server handle to this structure.</p>
<p>The callback definition structure must be of type <code class="codeph">OCIFocbkStruct</code>. It has two fields: <code class="codeph">callback_function</code>, which contains the address of the function to call, and <code class="codeph">fo_ctx</code>, which contains the address of the client context.</p>
<p>An example of callback registration is included as part of <a href="oci09adv.htm#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDAEEJ">Example 9-9</a>.</p>
</div>
</div>
<a id="LNOCI72677"></a><a id="LNOCI72678"></a><a id="LNOCI72679"></a><a id="LNOCI16684"></a>
<div class="props_rev_3"><a id="GUID-860A2B81-F867-4345-96DE-F423753D1D91"></a>
<h3 id="LNOCI-GUID-860A2B81-F867-4345-96DE-F423753D1D91" class="sect3">Failover Callback Example</h3>
<div>
<div class="section">
<p>This section shows an example of a simple user-defined callback function definition (see <a href="oci09adv.htm#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACJJHGH">Example 9-8</a>), failover callback registration (see <a href="oci09adv.htm#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDAEEJ">Example 9-9</a>), and failover callback unregistration (see <a href="oci09adv.htm#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDJGDG">Example 9-10</a>).</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACJJHGH">
<p class="titleinexample">Example 9-8 User-Defined Failover Callback Function Definition</p>
<pre dir="ltr">sb4  callback_fn(svchp, envhp, fo_ctx, fo_type, fo_event)
void * svchp;
void * envhp;
void *fo_ctx;
ub4 fo_type;
ub4 fo_event;
{
switch (fo_event) 
   {
   case OCI_FO_BEGIN:
   {
     printf(&#34; Failing Over ... Please stand by \n&#34;);
     printf(&#34; Failover type was found to be %s \n&#34;,
                     ((fo_type==OCI_FO_SESSION) ? &#34;SESSION&#34; 
                     :(fo_type==OCI_FO_SELECT) ? &#34;SELECT&#34;
                     : &#34;UNKNOWN!&#34;)); 
     printf(&#34; Failover Context is :%s\n&#34;, 
                    (fo_ctx?(char *)fo_ctx:&#34;NULL POINTER!&#34;));
     break;
   }
   case OCI_FO_ABORT:
   {
     printf(&#34; Failover stopped. Failover will not occur.\n&#34;);
     break;
   }
   case    OCI_FO_END:
   {
       printf(&#34; Failover ended ...resuming services\n&#34;);
     break;
   }
   case OCI_FO_REAUTH:
   {
       printf(&#34; Failed over user. Resuming services\n&#34;);
     break;
   }
   default:
   {
     printf(&#34;Bad Failover Event: %d.\n&#34;,  fo_event);
     break;
   }
   }
   return 0;
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDAEEJ">
<p class="titleinexample">Example 9-9 Failover Callback Registration</p>
<pre dir="ltr">int register_callback(srvh, errh)
void *srvh; /* the server handle */
OCIError *errh; /* the error handle */
{
  OCIFocbkStruct failover;                 /*  failover callback structure */
  /* allocate memory for context */
  if (!(failover.fo_ctx = (void *)malloc(strlen(&#34;my context.&#34;)+1)))
     return(1);
  /* initialize the context. */
  strcpy((char *)failover.fo_ctx, &#34;my context.&#34;);
  failover.callback_function = &amp;callback_fn;
  /* do the registration */
  if (OCIAttrSet(srvh, (ub4) OCI_HTYPE_SERVER,
                (void *) &amp;failover, (ub4) 0,
                (ub4) OCI_ATTR_FOCBK, errh)  != OCI_SUCCESS)
     return(2);
  /* successful conclusion */
  return (0);
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDJGDG">
<p class="titleinexample">Example 9-10 Failover Callback Unregistration</p>
<pre dir="ltr">OCIFocbkStruct failover;   /*  failover callback structure */
sword status;
 
  /* set the failover context to null */
  failover.fo_ctx = NULL; 
  /* set the failover callback to null */ 
  failover.callback_function = NULL; 
  /* unregister the callback */
  status = OCIAttrSet(srvhp, (ub4) OCI_HTYPE_SERVER,
                      (void *) &amp;failover, (ub4) 0,
                      (ub4) OCI_ATTR_FOCBK, errhp);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI16689"></a><a id="LNOCI72680"></a><a id="LNOCI16688"></a>
<div class="props_rev_3"><a id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8"></a>
<h3 id="LNOCI-GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8" class="sect3">Handling OCI_FO_ERROR</h3>
<div>
<div class="section">
<p>A failover attempt is not always successful. If the attempt fails, the callback function receives a value of <code class="codeph">OCI_FO_ABORT</code> or <code class="codeph">OCI_FO_ERROR</code> in the <code class="codeph">fo_event</code> parameter. A value of <code class="codeph">OCI_FO_ABORT</code> indicates that failover was unsuccessful, and no further failover attempts are possible. <code class="codeph">OCI_FO_ERROR</code>, however, provides the callback function with the opportunity to handle the error. For example, the callback may choose to wait a specified period of time and then indicate to the OCI library that it must reattempt failover.</p>
<div class="infobox-note" id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__GUID-57E6B159-985F-486D-860A-BDBC85CA75F6">
<p class="notep1">Note:</p>
<p>This functionality is only available to applications linked with the 8.0.5 or later OCI libraries running against any Oracle Database server.</p>
<p><a id="d107147e12635" class="indexterm-anchor"></a>Failover does not work if a LOB column is part of the select list.</p>
</div>
<p>Consider the timeline of events presented in <a href="oci09adv.htm#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACEHAGA" title="This table is described by 2 columns. Column 1 is the time designated as a timeline T0 through T7 and column 2 is the event that occurs for each timeline time.">Table 9-1</a>.</p>
<div class="tblformal" id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACEHAGA">
<p class="titleintable">Table 9-1 Time and Event</p>
<table class="cellalignment6175" title="Time and Event" summary="This table is described by 2 columns. Column 1 is the time designated as a timeline T0 through T7 and column 2 is the event that occurs for each timeline time.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6259" id="d107147e12657">Time</th>
<th class="cellalignment6260" id="d107147e12660">Event</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6261" id="d107147e12665" headers="d107147e12657">
<p>T0</p>
</td>
<td class="cellalignment6262" headers="d107147e12665 d107147e12660">
<p>Database fails (failure lasts until T5).</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6261" id="d107147e12672" headers="d107147e12657">
<p>T1</p>
</td>
<td class="cellalignment6262" headers="d107147e12672 d107147e12660">
<p>Failover is triggered by user activity.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6261" id="d107147e12679" headers="d107147e12657">
<p>T2</p>
</td>
<td class="cellalignment6262" headers="d107147e12679 d107147e12660">
<p>User attempts to reconnect; attempt fails.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6261" id="d107147e12686" headers="d107147e12657">
<p>T3</p>
</td>
<td class="cellalignment6262" headers="d107147e12686 d107147e12660">
<p>Failover callback is invoked with <code class="codeph">OCI_FO_ERROR</code>.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6261" id="d107147e12696" headers="d107147e12657">
<p>T4</p>
</td>
<td class="cellalignment6262" headers="d107147e12696 d107147e12660">
<p>Failover callback enters a predetermined sleep period.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6261" id="d107147e12703" headers="d107147e12657">
<p>T5</p>
</td>
<td class="cellalignment6262" headers="d107147e12703 d107147e12660">
<p>Database comes back up again.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6261" id="d107147e12710" headers="d107147e12657">
<p>T6</p>
</td>
<td class="cellalignment6262" headers="d107147e12710 d107147e12660">
<p>Failover callback triggers a new failover attempt; it is successful.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6261" id="d107147e12717" headers="d107147e12657">
<p>T7</p>
</td>
<td class="cellalignment6262" headers="d107147e12717 d107147e12660">
<p>User successfully reconnects.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The callback function triggers the new failover attempt by returning a value of <code class="codeph">OCI_FO_RETRY</code> from the function.</p>
<p><a href="oci09adv.htm#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACFEBEJ">Example 9-11</a> shows a callback function that you can use to implement the failover strategy similar to the scenario described earlier. In this case, the failover callback enters a loop in which it sleeps and then reattempts failover until it is successful:</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACFEBEJ">
<p class="titleinexample">Example 9-11 Callback Function That Implements a Failover Strategy</p>
<pre dir="ltr">/*--------------------------------------------------------------------*/
/* the user-defined failover callback  */
/*--------------------------------------------------------------------*/
sb4  callback_fn(svchp, envhp, fo_ctx, fo_type, fo_event )
void * svchp;
void * envhp;
void *fo_ctx;
ub4 fo_type;
ub4 fo_event;
{
   OCIError *errhp;
   OCIHandleAlloc(envhp, (void **)&amp;errhp, (ub4) OCI_HTYPE_ERROR,
              (size_t) 0, (void **) 0);
   switch (fo_event) 
   {
   case OCI_FO_BEGIN:
   {
     printf(&#34; Failing Over ... Please stand by \n&#34;);
     printf(&#34; Failover type was found to be %s \n&#34;,
            ((fo_type==OCI_FO_NONE) ? &#34;NONE&#34;
             :(fo_type==OCI_FO_SESSION) ? &#34;SESSION&#34; 
             :(fo_type==OCI_FO_SELECT) ? &#34;SELECT&#34;
             :(fo_type==OCI_FO_TXNAL) ? &#34;TRANSACTION&#34;
             : &#34;UNKNOWN!&#34;)); 
     printf(&#34; Failover Context is :%s\n&#34;, 
            (fo_ctx?(char *)fo_ctx:&#34;NULL POINTER!&#34;));
     break;
   }
   case OCI_FO_ABORT:
   {
     printf(&#34; Failover aborted. Failover will not occur.\n&#34;);
     break;
   }
   case    OCI_FO_END:
   { 
       printf(&#34;\n Failover ended ...resuming services\n&#34;);
     break;
   }
   case OCI_FO_REAUTH:
   { 
       printf(&#34; Failed over user. Resuming services\n&#34;);
     break;
   }
   case OCI_FO_ERROR:
   {
     /* all invocations of this can only generate one line. The newline
      * will be put at fo_end time.
      */
     printf(&#34; Failover error gotten. Sleeping...&#34;);
     sleep(3);
     printf(&#34;Retrying. &#34;);
     return (OCI_FO_RETRY);
     break;
   }
   default:
   {
     printf(&#34;Bad Failover Event: %d.\n&#34;,  fo_event);
     break;
   }
   }
   return 0;
}
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNOCI093"></a>
<div class="props_rev_3"><a id="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7"></a>
<h2 id="LNOCI-GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7" class="sect2">HA Event Notification</h2>
<div>
<p>Use HA event notification to provide a best-effort programmatic signal to the client if there is a database failure for high availability clients connected to an Oracle RAC database.</p>
<p>Suppose that a user employs a web browser to log in to an application server that accesses a back-end database server. Failure of the database instance can result in a wait that can be up to minutes in duration before the failure is known to the user. The ability to quickly detect failures of server instances, communicate this to the client, close connections, and clean up idle connections in connection pools is provided by HA event notification.</p>
<p>For high availability clients connected to an Oracle RAC database, you can use HA event notification to provide a best-effort programmatic signal to the client if there is a database failure. Client applications can register a callback on the environment handle to signal interest in this information. When a significant failure event occurs that applies to a connection made by this client, the callback is invoked, with information concerning the event (the event payload) and a list of connections (server handles) that were disconnected because of the failure.</p>
<p>For example, consider a client application that has two connections to instance A and two connections to instance B of the same database. If instance A goes down, a notification of the event is sent to the client, which then disconnects the two connections to instance B and invokes the registered callback. Note that if another instance C of the same database goes down, the client is not notified (because it does not affect any of the client&#39;s connections).</p>
<p>The HA event notification mechanism improves the response time of the application in the presence of failure. Before the mechanism was introduced in Oracle Database 10g Release 2 (10.2), a failure would result in the connection being broken only after the TCP timeout interval expired, which could take minutes. With HA event notification, the standalone, connection pool, and session pool connections are automatically broken and cleaned up by OCI, and the application callback is invoked within seconds of the failure event. If any of these server handles are TAF-enabled, failover is also automatically engaged by OCI.</p>
<p>In the current release, this functionality depends on Oracle Notification Service (ONS). It requires Oracle Clusterware to be installed and configured on the database server for the clients to receive the HA notifications through ONS. All clusterware installations (for example, Oracle Data Guard) should have the same ONS port. There is no client configuration required for ONS.</p>
<div class="infobox-note" id="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7__GUID-3B124258-ED11-4264-B861-1783110DF5A9">
<p class="notep1">Note:</p>
<p>The client transparently gets the ONS server information from the database to which it connects. The application administrator can augment or override that information using the deployment configuration file <code class="codeph">oraaccess.xml</code>.</p>
</div>
<p>Applications must connect to an Oracle RAC instance to enable HA event notification. Furthermore, these applications must:</p>
<ul style="list-style-type: disc;">
<li>
<p>Initialize the OCI Environment in <code class="codeph">OCI_EVENTS</code> mode</p>
</li>
<li>
<p>Connect to a service that has notifications enabled (use the <code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code> procedure to set <code class="codeph">AQ_HA_NOTIFICATIONS</code> to <code class="codeph">TRUE</code>)</p>
</li>
<li>
<p>Link with a thread library</p>
</li>
</ul>
<p>Then these applications can register a callback that is invoked whenever an HA event occurs.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0">OCIEvent Handle</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-F514FB5E-049B-4759-8E39-16853213F7C9">OCI Failover for Connection and Session Pools</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-9588A120-E61E-4E87-85E8-1E6D9155B581">OCI Failover for Independent Connections</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-889935A8-154F-460B-9050-1600C4B53EA7">Event Callback</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E">Custom Pooling: Tagged Server Handles</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-D34432B4-2962-48A7-9D9C-789200091B43">About Determining Transparent Application Failover (TAF) Capabilities</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7__GUID-1F9FADDE-F254-4189-BACF-D2D94DC3B0B6">
<p class="notep1">See Also:</p>
<p><a href="oci10new.htm#GUID-7F47F9F7-EF51-4D68-8B2A-2443C837710B">About Client-Side Deployment Parameters Specified in oraaccess.xml</a> for more information about <code class="codeph">oraaccess.xml</code> and details about the parameters under <code class="codeph">&lt;events&gt;</code>, <code class="codeph">&lt;fan&gt;</code> and <code class="codeph">&lt;ons&gt;</code></p>
</div>
</div>
<a id="LNOCI16690"></a>
<div class="props_rev_3"><a id="GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0"></a>
<h3 id="LNOCI-GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0" class="sect3">OCIEvent Handle</h3>
<div>
<p>The <a id="d107147e13124" class="indexterm-anchor"></a><code class="codeph">OCIEvent</code> handle encapsulates the attributes from the event payload. OCI implicitly allocates this handle before calling the event callback, which can obtain the read-only attributes of the event by calling <a href="oci16rel002.htm#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a>. Memory associated with these attributes is only valid for the duration of the event callback.</p>
<div class="infoboxnotealso" id="GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0__GUID-1B9666B6-1DDA-4C42-8026-351B232F60AD">
<p class="notep1">See Also:</p>
<p>&#34;Event Handle Attributes&#34; on page&nbsp;A‐91</p>
</div>
</div>
</div>
<a id="LNOCI16691"></a>
<div class="props_rev_3"><a id="GUID-F514FB5E-049B-4759-8E39-16853213F7C9"></a>
<h3 id="LNOCI-GUID-F514FB5E-049B-4759-8E39-16853213F7C9" class="sect3">OCI Failover for Connection and Session Pools</h3>
<div>
<p>A connection pool in an instance of Oracle RAC consists of a pool of connections connected to different instances of Oracle RAC. Upon receiving the node failure notification, all the connections connected to that particular instance should be cleaned up. For the connections that are in use, OCI must close the connections: transparent application failover (TAF) occurs immediately, and those connections are reestablished. The connections that are idle and in the free list of the pool must be purged, so that a bad connection is never returned to the user from the pool.</p>
<p>To accommodate custom connection pools, OCI provides a callback function that can be registered on the environment handle. If registered, this callback is invoked when an HA event occurs. Session pools are treated the same way as connection pools. Note that server handles from OCI connection pools or session pools are not passed to the callback. Hence in some cases, the callback could be called with an empty list of connections.</p>
</div>
</div>
<a id="LNOCI16692"></a>
<div class="props_rev_3"><a id="GUID-9588A120-E61E-4E87-85E8-1E6D9155B581"></a>
<h3 id="LNOCI-GUID-9588A120-E61E-4E87-85E8-1E6D9155B581" class="sect3">OCI Failover for Independent Connections</h3>
<div>
<p>No special handling is required for independent connections; all such connections that are connected to failed instances are immediately disconnected. For idle connections, TAF is engaged to reestablish the connection when the connection is used on a subsequent OCI call. Connections that are in use at the time of the failure event are broken out immediately, so that TAF can begin. Note that this applies for the &#34;in-use&#34; connections of connection and session pools also.</p>
</div>
</div>
<a id="LNOCI16693"></a>
<div class="props_rev_3"><a id="GUID-889935A8-154F-460B-9050-1600C4B53EA7"></a>
<h3 id="LNOCI-GUID-889935A8-154F-460B-9050-1600C4B53EA7" class="sect3">Event Callback</h3>
<div>
<p>The event callback, of type <code class="codeph">OCIEventCallback</code>, has the following signature:</p>
<pre dir="ltr">void evtcallback_fn (void      *evtctx,
                     OCIEvent  *eventhp );
</pre>
<p>In this signature <code class="codeph">evtctx</code> is the client context, and <code class="codeph">OCIEvent</code> is an event handle that is opaque to the OCI library. The other input argument is <code class="codeph">eventhp</code>, the event handle (the attributes associated with an event).</p>
<p>If registered, this function is called once for each event. For Oracle RAC HA events, this callback is invoked after the affected connections have been disconnected. The following environment handle attributes are used to register an event callback and context, respectively:</p>
<ul style="list-style-type: disc;">
<li>
<p><a id="d107147e13610" class="indexterm-anchor"></a><code class="codeph">OCI_ATTR_EVTCBK</code> is of data type <code class="codeph">OCIEventCallback</code> <code class="codeph">*</code>. It is read-only.</p>
</li>
<li>
<p><a id="d107147e13623" class="indexterm-anchor"></a><code class="codeph">OCI_ATTR_EVTCTX</code> is of data type <code class="codeph">void</code> <code class="codeph">*</code>. It is also read-only.</p>
</li>
</ul>
<pre dir="ltr">text *myctx = &#34;dummy context&#34;; /* dummy context passed to callback fn */
...
/* OCI_ATTR_EVTCBK and OCI_ATTR_EVTCTX are read-only. */
OCIAttrSet(envhp, (ub4) OCI_HTYPE_ENV, (void *) evtcallback_fn,
           (ub4) 0, (ub4) OCI_ATTR_EVTCBK, errhp);
OCIAttrSet(envhp, (ub4) OCI_HTYPE_ENV, (void *) myctx,
           (ub4) 0, (ub4) OCI_ATTR_EVTCTX, errhp);
...
</pre>
<p>Within the OCI event callback, the list of affected server handles is encapsulated in the <code class="codeph">OCIEvent</code> handle. For Oracle RAC HA DOWN events, client applications can iterate over a list of server handles that are affected by the event by using <a href="oci16rel002.htm#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a> with attribute types <code class="codeph">OCI_ATTR_HA_SRVFIRST</code> and <a id="d107147e13651" class="indexterm-anchor"></a><code class="codeph">OCI_ATTR_HA_SRVNEXT</code>:</p>
<pre dir="ltr">OCIAttrGet(eventhp, OCI_HTYPE_EVENT, (void *)&amp;srvhp, (ub4 *)0,
           OCI_ATTR_HA_SRVFIRST, errhp); 
/* or, */
OCIAttrGet(eventhp, OCI_HTYPE_EVENT, (void *)&amp;srvhp, (ub4 *)0,
           OCI_ATTR_HA_SRVNEXT, errhp);
</pre>
<p>When called with attribute <code class="codeph">OCI_ATTR_HA_SRVFIRST</code>, this function retrieves the first server handle in the list of server handles affected. When called with attribute <code class="codeph">OCI_ATTR_HA_SRVNEXT</code>, this function retrieves the next server handle in the list. This function returns <code class="codeph">OCI_NO_DATA</code> and <code class="codeph">srvhp</code> is a <code class="codeph">NULL</code> pointer, when there are no more server handles to return.</p>
<p><code class="codeph">srvhp</code> is an output pointer to a server handle whose connection has been closed because of an HA event. <code class="codeph">errhp</code> is an error handle to populate. The application returns an <code class="codeph">OCI_NO_DATA</code> error when there are no more affected server handles to retrieve.</p>
<p>When retrieving the list of server handles that have been affected by an HA event, be aware that the connection has already been closed and many server handle attributes are no longer valid. Instead, use the user memory segment of the server handle to store any per-connection attributes required by the event notification callback. This memory remains valid until the server handle is freed.</p>
</div>
</div>
<a id="LNOCI72681"></a><a id="LNOCI16694"></a>
<div class="props_rev_3"><a id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E"></a>
<h3 id="LNOCI-GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E" class="sect3">Custom Pooling: Tagged Server Handles</h3>
<div>
<p>The following features apply to custom pools:</p>
<ul style="list-style-type: disc;">
<li>
<p>You can tag a server handle with its parent connection object if it is created on behalf of a custom pool. Use the &#34;user memory&#34; parameters of <a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a> to request that the server handle be allocated with a user memory segment. A pointer to the &#34;user memory&#34; segment is returned by <code class="codeph">OCIHandleAlloc()</code>.</p>
</li>
<li>
<p>When an HA event occurs and an affected server handle has been retrieved, there is a means to retrieve the server handle&#39;s tag information so appropriate cleanup can be performed. The attribute <a id="d107147e13862" class="indexterm-anchor"></a><code class="codeph">OCI_ATTR_USER_MEMORY</code> is used to retrieve a pointer to a handle&#39;s user memory segment. <code class="codeph">OCI_ATTR_USER_MEMORY</code> is valid for all user-allocated handles. If the handle was allocated with extra memory, this attribute returns a pointer to the user memory. A <code class="codeph">NULL</code> pointer is returned for those handles not allocated with extra memory. This attribute is read-only and is of data type <code class="codeph">void*</code>.</p>
</li>
</ul>
<div class="infobox-note" id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__GUID-CECC5161-D15D-4AE2-91F9-E2FD8EB99A8F">
<p class="notep1">Note:</p>
<p>You are free to define the precise contents of the server handle&#39;s user memory segment to facilitate cleanup activities from within the HA event callback (or for other purposes if needed) because OCI does not write or read from this memory in any way. The user memory segment is freed with the <a href="oci16rel002.htm#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A">OCIHandleFree()</a> call on the server handle.</p>
</div>
<p><a href="oci09adv.htm#GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__CACCIFIF">Example 9-12</a> shows an example of event notification.</p>
<div class="example" id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__CACCIFIF">
<p class="titleinexample">Example 9-12 Event Notification</p>
<pre dir="ltr">sword retval;
OCIServer *srvhp;
struct myctx {
   void *parentConn_myctx;
   uword numval_myctx;
};
typedef struct myctx myctx; 
myctx  *myctxp;
/* Allocate a server handle with user memory - pre 10.2 functionality */
if (retval = OCIHandleAlloc(envhp, (void **)&amp;srvhp, OCI_HTYPE_SERVER,
                            (size_t)sizeof(myctx), (void **)&amp;myctxp)
/* handle error */
myctxp-&gt;parentConn_myctx = &lt;parent connection reference&gt;;
 
/* In an event callback function, retrieve the pointer to the user memory */
evtcallback_fn(void *evtctx, OCIEvent *eventhp)
{ 
  myctx *ctxp = (myctx *)evtctx;
  OCIServer *srvhp;
  OCIError *errhp;
  sb4       retcode;
  retcode = OCIAttrGet(eventhp, OCI_HTYPE_SERVER, &amp;srvhp, (ub4 *)0,
                       OCI_ATTR_HA_SRVFIRST, errhp); 
  while (!retcode) /* OCIAttrGet will return OCI_NO_DATA if no more srvhp */ 
  {  
     OCIAttrGet((void *)srvhp, OCI_HTYPE_SERVER, (void *)&amp;ctxp,
                (ub4)0, (ub4)OCI_ATTR_USER_MEMORY, errhp);
           /* Remove the server handle from the parent connection object */
     retcode = OCIAttrGet(eventhp, OCI_HTYPE_SERVER, &amp;srvhp, (ub4 *)0,
                          OCI_ATTR_HA_SRVNEXT, errhp);
...
  }
...
}
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI16696"></a>
<div class="props_rev_3"><a id="GUID-D34432B4-2962-48A7-9D9C-789200091B43"></a>
<h3 id="LNOCI-GUID-D34432B4-2962-48A7-9D9C-789200091B43" class="sect3">About Determining Transparent Application Failover (TAF) Capabilities</h3>
<div>
<p>You can have the application adjust its behavior if a connection is or is not TAF-enabled. Use <code class="codeph">OCIAttrGet()</code> as follows to determine if a server handle is TAF-enabled:</p>
<pre dir="ltr">boolean taf_capable;
...
OCIAttrGet(srvhp, (ub4) OCI_HTYPE_SERVER, (void *) &amp;taf_capable, 
           (ub4) sizeof(taf_capable), (ub4)OCI_ATTR_TAF_ENABLED, errhp);
...
</pre>
<p>In this example, <code class="codeph">taf_capable</code> is a <span>Boolean variable</span>, which this call sets to <code class="codeph">TRUE</code> if the server handle is TAF-enabled, and <code class="codeph">FALSE</code> if not; <code class="codeph">srvhp</code> is an input target server handle; <code class="codeph">OCI_ATTR_TAF_ENABLED</code> is an attribute that is a pointer to a <span>Boolean</span> variable and is read-only; <code class="codeph">errhp</code> is an input error handle.</p>
</div>
</div>
</div>
<a id="LNOCI80660"></a>
<div class="props_rev_3"><a id="GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F"></a>
<h2 id="LNOCI-GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F" class="sect2">OCI and Transaction Guard</h2>
<div>
<p>Transaction Guard introduces the concept of at-most-once transaction execution in case of a planned or unplanned outage to help prevent an application upon failover from submitting a duplicate submission of an original submission.</p>
<p>When an application opens a connection to the database using this service, the logical transaction ID (LTXID) is generated at authentication and stored in the session handle. This is a globally unique ID that identifies the database transaction from the application perspective. When there is an outage, an application using Transaction Guard can retrieve the LTXID from the previous failed session&#39;s handle and use it to determine the outcome of the transaction that was active prior to the session failure. If the LTXID is determined to be unused, then the application can replay an uncommitted transaction by first blocking the original submission using the retrieved LTXID. If the LTXID is determined to be used, then the transaction is committed and the result is returned to the application.</p>
<p>Transaction Guard is a developer API supported for JDBC Type 4 (Oracle Thin), OCI, OCCI, and Oracle Data Provider for .NET (ODP.NET) drivers. For OCI, when an application is written to support Transaction Guard, upon an outage, the OCI client driver acquires and retrieves the LTXID from the previous failed session&#39;s handle by calling <code class="codeph">OCI_ATTR_GET()</code> using the <code class="codeph">OCI_ATTR_LTXID</code> session handle attribute.</p>
<p>This section includes the following topic: <a href="oci09adv.htm#GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" title="This section describes developing OCI user applications that use Transaction Guard.">Developing Applications that Use Transaction Guard</a>.</p>
<div class="infoboxnotealso" id="GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F__GUID-E3CF22A9-BA3E-4F88-87D2-C7DF883994E7">
<p class="notep1">See Also:</p>
<p><a class="olink ADFNS8000" target="_blank" href="../ADFNS/adfns_trans_idemp_guard.htm#ADFNS8000"><span><cite>Oracle Database Development Guide</cite></span></a> for information in the chapter about using Transaction Guard in for an overview of Transaction Guard, supported transaction types, transaction types that are not supported, and database configuration information for using Transaction Guard.</p>
</div>
</div>
<a id="LNOCI80674"></a><a id="LNOCI80673"></a>
<div class="props_rev_3"><a id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23"></a>
<h3 id="LNOCI-GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" class="sect3">Developing Applications that Use Transaction Guard</h3>
<div>
<p>This section describes developing OCI user applications that use Transaction Guard.</p>
<div class="section">
<p>See the chapter about using Transaction Guard in <a class="olink ADFNS8000" target="_blank" href="../ADFNS/adfns_trans_idemp_guard.htm#ADFNS8000"><span><cite>Oracle Database Development Guide</cite></span></a> for more detailed information about developing applications using Transaction Guard.</p>
<p>For the third-party or user application to use Transaction Guard in order to be able to fail over a session for OCI, it must include several major steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Verify if Transparent Application Failover (TAF) is enabled for the connection. Do not attempt to explicitly use Transaction Guard on a TAF-enabled connection, as TAF will automatically check the <code class="codeph">LTXID</code>.</span></li>
<li class="stepexpand"><span>On receipt of an error, determine whether the error is a recoverable error - <code class="codeph">OCI_ATTR_ERROR_IS_RECOVERABLE</code> on <code class="codeph">OCI_ERROR</code> handle. If the error is recoverable, then continue to Step <a href="oci09adv.htm#GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__CACFHAAG">3</a>.</span>
<div>
<div class="infobox-note" id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__GUID-DFBE8124-9838-4780-9E59-E7F81EB3CE57">
<p class="notep1">Note:</p>
<p>Do not attempt to use the LTXID to check transaction outcome if the connection has not suffered a recoverable error.</p>
</div>
</div>
</li>
<li class="stepexpand" id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__CACFHAAG"><span>Retrieve the LTXID associated with the failed session by using OCI_ATTR_GET() to get the OCI_ATTR_LTXID from the user session handle.</span></li>
<li class="stepexpand"><span>Reconnect to the database.</span>
<div>
<div class="infobox-note" id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__GUID-82ABA5C6-B605-44B2-AD42-9FC952306A5B">
<p class="notep1">Note:</p>
<p>The new session will have a new LTXID, but you will not need it when checking the status of the original session.</p>
</div>
</div>
</li>
<li class="stepexpand"><span>Invoke the <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> PL/SQL procedure with the LTXID obtained from the <code class="codeph">OCI_ATTR_GET()</code> call. The original LTXID of the failed-over session is marked as forced if that LTXID has not been used. The return state tells the driver if the last transaction was <code class="codeph">COMMITTED (TRUE/FALSE)</code> and <code class="codeph">USER_CALL_COMPLETED (TRUE/FALSE)</code>.</span></li>
<li class="stepexpand"><span>The application can replay an uncommitted transaction or return the result to the user. If the replay itself incurs an outage, then the LTXID for the replaying session is used for the <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> procedure.</span></li>
</ol>
<div class="section">
<div class="p">See the following sections for Transaction Guard usage and examples:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0">Typical Transaction Guard Usage</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-671647AA-875B-45B6-BAA8-311B3E007EB9">Transaction Guard Examples</a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="LNOCI80675"></a>
<div class="props_rev_3"><a id="GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0"></a>
<h4 id="LNOCI-GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0" class="sect4">Typical Transaction Guard Usage</h4>
<div>
<p>The following pseudocode shows a typical usage of Transaction Guard:</p>
<ol>
<li>
<p>Receive a FAN down event (or recoverable error)</p>
</li>
<li>
<p>FAN aborts the dead session</p>
</li>
<li>
<p>Call <code class="codeph">OCIAttrGet()</code> using the <code class="codeph">OCI_ATTR_TAF_ENABLED</code> attribute on the server handle. If the value is <code class="codeph">TRUE</code>, stop. If the value is <code class="codeph">FALSE</code>, proceed to the next step.</p>
</li>
<li>
<p>If it is a recoverable error, for OCI (<code class="codeph">OCI_ATTR_ERROR_IS_RECOVERABLE</code> on <code class="codeph">OCI_ERROR</code> handle):</p>
<ol>
<li>
<p>Get the last LTXID from the dead session by calling <a href="oci16rel002.htm#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a> using the <code class="codeph">OCI_ATTR_LTXID</code> session handle attribute to retrieve the LTXID associated with the session&#39;s handle</p>
</li>
<li>
<p>Obtain a new session</p>
</li>
<li>
<p>Call <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> with the last LTXID to get the return state</p>
</li>
</ol>
</li>
<li>
<p>If the return state is:</p>
<ol>
<li>
<p><code class="codeph">COMMITTED</code> and <code class="codeph">USER_CALL_COMPLETED</code></p>
<p>Then return the result.</p>
</li>
<li>
<p><code class="codeph">ELSEIF COMMITTED</code> and <code class="codeph">NOT USER_CALL_COMPLETED</code></p>
<p>Then return the result with a warning (with details, such as out binds or row count was not returned).</p>
</li>
<li>
<p><code class="codeph">ELSEIF NOT COMMITTED</code></p>
<p>Resubmit the transaction or series of calls or both, or return error to user.</p>
</li>
</ol>
</li>
</ol>
</div>
</div>
<a id="LNOCI80677"></a><a id="LNOCI80676"></a>
<div class="props_rev_3"><a id="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9"></a>
<h4 id="LNOCI-GUID-671647AA-875B-45B6-BAA8-311B3E007EB9" class="sect4">Transaction Guard Examples</h4>
<div>
<div class="section">
<p><a href="oci09adv.htm#GUID-671647AA-875B-45B6-BAA8-311B3E007EB9__CACJFEEC">Example 9-13</a> is an OCI Transaction Guard demo program (<code class="codeph">cdemotg.c</code>) that demonstrates:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Use of the attribute <code class="codeph">OCI_ATTR_ERROR_IS_RECOVERABLE</code>. When an error occurs, the program checks if the error is recoverable.</p>
</li>
<li>
<p>Use of the packaged procedure <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>. If the error is recoverable, the program calls <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> to determine the status of the active transaction.</p>
</li>
</ul>
<p>If the transaction has not committed, the program re-executes the failed transaction.</p>
<div class="infobox-note" id="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9__GUID-42DD9B5E-8641-4B24-A9DD-1CA396998A6B">
<p class="notep1">Note:</p>
<p>This program does not modify the session state such as NLS parameters, and so forth. Programs that do so may need to reexecute such commands after obtaining a new session from the pool following the error.</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9__CACJFEEC">
<p class="titleinexample">Example 9-13 Transaction Guard Demo Program</p>
<pre dir="ltr">*/
 
#ifndef OCISP_ORACLE
# include &lt;cdemosp.h&gt; 
#endif
 
/* Maximum Number of threads  */ 
#define MAXTHREAD 1
static ub4 sessMin = 1;
static ub4 sessMax = 9;
static ub4 sessIncr = 2;
 
static OCIError   *errhp;
static OCIEnv     *envhp;
static OCISPool   *poolhp=(OCISPool *) 0;
static int employeeNum[MAXTHREAD];
 
static OraText *poolName;
static ub4 poolNameLen;
static CONST OraText *database = (text *)&#34;ltxid_service&#34;;
static CONST OraText *appusername =(text *)&#34;scott&#34;;
static CONST OraText *apppassword =(text *)&#34;tiger&#34;;
 
static CONST char getLtxid[]= 
  (&#34;BEGIN <span class="bold">DBMS_APP_CONT.GET_LTXID_OUTCOME</span> (&#34;
   &#34;:ltxid,:committed,:callComplete); END;&#34;);
 
static CONST char insertst1[] = 
  (&#34;INSERT INTO EMP(ENAME, EMPNO) values (&#39;NAME1&#39;, 1000)&#34;);
 
static void checkerr (OCIError *errhp, sword status);
static void threadFunction (dvoid *arg);
 
int main(void)
{
  int i = 0;
  sword lstat;
  int timeout =1;
  OCIEnvCreate (&amp;envhp, OCI_THREADED, (dvoid *)0,  NULL,
                NULL, NULL, 0, (dvoid *)0);
 
  (void) OCIHandleAlloc((dvoid *) envhp, (dvoid **) &amp;errhp, OCI_HTYPE_ERROR,
                        (size_t) 0, (dvoid **) 0);
 
  (void) OCIHandleAlloc((dvoid *) envhp, (dvoid **) &amp;poolhp, OCI_HTYPE_SPOOL,
                        (size_t) 0, (dvoid **) 0);
 
  /* Create the session pool */
  checkerr(errhp, OCIAttrSet((dvoid *) poolhp,
           (ub4) OCI_HTYPE_SPOOL, (dvoid *) &amp;timeout, (ub4)0, 
           OCI_ATTR_SPOOL_TIMEOUT, errhp));
 
  if (lstat = OCISessionPoolCreate(envhp, errhp,poolhp, (OraText **)&amp;poolName, 
              (ub4 *)&amp;poolNameLen, database, 
              (ub4)strlen((const char *)database),
              sessMin, sessMax, sessIncr,
              (OraText *)appusername,
              (ub4)strlen((const char *)appusername),
              (OraText *)apppassword,
              (ub4)strlen((const char *)apppassword),
              OCI_SPC_STMTCACHE|OCI_SPC_HOMOGENEOUS))
  {
    checkerr(errhp,lstat);
  }
 
  printf(&#34;Session Pool Created \n&#34;);
 
  /* Multiple threads using the session pool */
  {
    OCIThreadId *thrid[MAXTHREAD];
    OCIThreadHandle *thrhp[MAXTHREAD];
 
    OCIThreadProcessInit ();
    checkerr (errhp, OCIThreadInit (envhp, errhp));
    for (i = 0; i &lt; MAXTHREAD; ++i)
    {
      checkerr (errhp, OCIThreadIdInit (envhp, errhp, &amp;thrid[i]));
      checkerr (errhp, OCIThreadHndInit (envhp, errhp, &amp;thrhp[i]));
    }
    for (i = 0; i &lt; MAXTHREAD; ++i)
    {
      employeeNum[i]=i;
      /* Inserting into EMP table */
      checkerr (errhp, OCIThreadCreate (envhp, errhp, threadFunction,
                (dvoid *) &amp;employeeNum[i], thrid[i], thrhp[i]));
    }
    for (i = 0; i &lt; MAXTHREAD; ++i)
    {
      checkerr (errhp, OCIThreadJoin (envhp, errhp, thrhp[i]));
      checkerr (errhp, OCIThreadClose (envhp, errhp, thrhp[i]));
      checkerr (errhp, OCIThreadIdDestroy (envhp, errhp, &amp;(thrid[i])));
      checkerr (errhp, OCIThreadHndDestroy (envhp, errhp, &amp;(thrhp[i])));
    }
    checkerr (errhp, OCIThreadTerm (envhp, errhp));
  } /* ALL THE THREADS ARE COMPLETE */
  lstat =  OCISessionPoolDestroy(poolhp, errhp, OCI_DEFAULT);
 
  printf(&#34;Session Pool Destroyed \n&#34;);
  
  if (lstat != OCI_SUCCESS)
    checkerr(errhp, lstat);
    
  checkerr(errhp, OCIHandleFree((dvoid *)poolhp, OCI_HTYPE_SPOOL));
    
  checkerr(errhp, OCIHandleFree((dvoid *)errhp, OCI_HTYPE_ERROR));
  return 0;
 
} /* end of main () */
 
/* Inserts records into EMP table */ 
static void threadFunction (dvoid *arg)
{
  int empno = *(int *)arg;
  OCISvcCtx *svchp = (OCISvcCtx *) 0;
  OCISvcCtx *svchp2 = (OCISvcCtx *) 0;
  OCISession *embUsrhp = (OCISession *)0;
  OCIBind *bnd1p, *bnd2p, *bnd3p;
 
  OCIStmt *stmthp = (OCIStmt *)0;
  OCIStmt *getLtxidStm = (OCIStmt *)0;
  OCIError  *errhp2 = (OCIError *) 0;
  OCIAuthInfo *authp = (OCIAuthInfo *)0;
  sword lstat;
  text name[10];
 
  boolean callCompl, committed, isRecoverable;
  ub1 *myLtxid;
  ub4  myLtxidLen;
 
  ub4 numAttempts = 0;
 
  (void) OCIHandleAlloc((dvoid *) envhp, (dvoid **) &amp;errhp2, OCI_HTYPE_ERROR,
                     (size_t) 0, (dvoid **) 0);
 
  lstat =  OCIHandleAlloc((dvoid *) envhp,
                          (dvoid **)&amp;authp, (ub4) OCI_HTYPE_AUTHINFO,
                          (size_t) 0, (dvoid **) 0);
  if (lstat)
    checkerr(errhp2, lstat);
 
  checkerr(errhp2, OCIAttrSet((dvoid *) authp,(ub4) OCI_HTYPE_AUTHINFO, 
           (dvoid *) appusername, (ub4) strlen((char *)appusername),
           (ub4) OCI_ATTR_USERNAME, errhp2));
 
  checkerr(errhp2,OCIAttrSet((dvoid *) authp,(ub4) OCI_HTYPE_AUTHINFO, 
           (dvoid *) apppassword, (ub4) strlen((char *)apppassword),
           (ub4) OCI_ATTR_PASSWORD, errhp2));
 
restart:
  if  (lstat = OCISessionGet(envhp, errhp2, &amp;svchp, authp,
               (OraText *)poolName, (ub4)strlen((char *)poolName), NULL, 
               0, NULL, NULL, NULL, OCI_SESSGET_SPOOL))
  {
    checkerr(errhp2,lstat);
  } 
  
  /* save the ltxid from the session in case we need to call
   *  get_ltxid_outcome to determine the transaction status.
   */
  checkerr(errhp2, OCIAttrGet(svchp, OCI_HTYPE_SVCCTX,
                              (dvoid *)&amp;embUsrhp, (ub4 *)0,
                              (ub4)OCI_ATTR_SESSION, errhp2));
  checkerr(errhp2, OCIAttrGet(embUsrhp, OCI_HTYPE_SESSION,
                              (dvoid *)&amp;myLtxid, (ub4 *)&amp;myLtxidLen,
                              (ub4)OCI_ATTR_LTXID, errhp2));
  
 
  /* */
  checkerr(errhp2, OCIStmtPrepare2(svchp, &amp;stmthp, errhp2, 
                                   (CONST OraText *)insertst1, 
                                   (ub4)sizeof(insertst1),
                                   (const oratext *)0, (ub4)0,
                                   OCI_NTV_SYNTAX, OCI_DEFAULT));
 
  if (!numAttempts)
  {
    char input[1];
 
    printf(&#34;Kill SCOTT&#39;s session now. Press ENTER when complete\n&#34;);
    gets(input);
  }
  lstat = OCIStmtExecute (svchp, stmthp, errhp2, (ub4)1, (ub4)0,
                          (OCISnapshot *)0, (OCISnapshot *)0, 
                          OCI_DEFAULT );
  if (lstat == OCI_ERROR)
  {
    checkerr(errhp2, OCIAttrGet(errhp2, OCI_HTYPE_ERROR,
                                (dvoid *)&amp;isRecoverable, (ub4 *)0,
                                (ub4)<span class="bold">OCI_ATTR_ERROR_IS_RECOVERABLE</span>, errhp2));
    if (isRecoverable)
    {
 
      printf(&#34;Recoverable error occurred; checking transaction status.\n&#34;);
      /* get another session to use for the get_ltxid_outcome call */
      if  (lstat = OCISessionGet(envhp, errhp2, &amp;svchp2, authp,
                                 (OraText *)poolName, 
                                 (ub4)strlen((char *)poolName), NULL, 
                                 0, NULL, NULL, NULL, OCI_SESSGET_SPOOL))
      {
        checkerr(errhp2,lstat);
      } 
      
      checkerr(errhp2,OCIStmtPrepare2(svchp2,&amp;getLtxidStm, errhp2, 
                                      (CONST OraText *)getLtxid,
                                      (ub4)sizeof(getLtxid),
                                      (const oratext *)0, (ub4)0,
                                      OCI_NTV_SYNTAX, OCI_DEFAULT));
      checkerr(errhp, OCIBindByPos(getLtxidStm, &amp;bnd1p, errhp, 1,
                                   (dvoid *) myLtxid, (sword)myLtxidLen,
                                   SQLT_BIN, (dvoid *)0,
                                   (ub2 *) 0, (ub2 *) 0, (ub4) 0, (ub4 *) 0,
                                   OCI_DEFAULT));
      checkerr(errhp, OCIBindByPos(getLtxidStm, &amp;bnd2p, errhp, 2,
                                   (dvoid *) &amp;committed, 
                                   (sword)sizeof(committed),
                                   SQLT_BOL, (dvoid *)0,
                                   (ub2 *) 0, (ub2 *) 0, (ub4) 0, (ub4 *) 0,
                                   OCI_DEFAULT));
      checkerr(errhp, OCIBindByPos(getLtxidStm, &amp;bnd3p, errhp, 3,
                                   (dvoid *) &amp;callCompl, 
                                   (sword)sizeof(callCompl),
                                   SQLT_BOL, (dvoid *)0,
                                   (ub2 *) 0, (ub2 *) 0, (ub4) 0, (ub4 *) 0,
                                   OCI_DEFAULT));
      
      checkerr(errhp2,OCIStmtExecute(svchp2, getLtxidStm, errhp2, 
                                     (ub4)1, (ub4)0,
                                     (OCISnapshot *)0, (OCISnapshot *)0, 
                                     OCI_DEFAULT ));
      checkerr(errhp2, OCISessionRelease(svchp2, errhp2, 
                                         NULL, 0, OCI_DEFAULT));
      if (committed &amp;&amp; callCompl)
        printf(&#34;Insert successfully commited \n&#34;);
      else if (!committed)
      {
        printf(&#34;Transaction did not commit; re-executing last transaction\n&#34;);
        numAttempts++;
 
        /* As there was an outage, do not return this session to the pool */
        checkerr(errhp2, 
                 OCISessionRelease(svchp, errhp2, 
                                   NULL, 0, OCI_SESSRLS_DROPSESS));
        svchp = (OCISvcCtx *)0;
        goto restart;
      }
    }
  }
  else
  {
    checkerr(errhp2, OCITransCommit(svchp,errhp2,(ub4)0));
    printf(&#34;Transaction committed successfully\n&#34;);
  }
  if (stmthp)
    checkerr(errhp2, OCIStmtRelease((dvoid *) stmthp, errhp2,
                                    (void *)0, 0, OCI_DEFAULT));
  if (getLtxidStm)
    checkerr(errhp2, OCIStmtRelease((dvoid *) getLtxidStm, errhp2,
                                    (void *)0, 0, OCI_DEFAULT));
 
  if (svchp)
    checkerr(errhp2, OCISessionRelease(svchp, errhp2, NULL, 0, OCI_DEFAULT));
  OCIHandleFree((dvoid *)authp, OCI_HTYPE_AUTHINFO);
  OCIHandleFree((dvoid *)errhp2, OCI_HTYPE_ERROR);
 
} /* end of threadFunction (dvoid *) */
 
/* This function prints the error */
void checkerr(errhp, status)
OCIError *errhp;
sword status;
{
  text errbuf[512];
  sb4 errcode = 0;
 
  switch (status)
  {
  case OCI_SUCCESS:
    break;
  case OCI_SUCCESS_WITH_INFO:
    (void) printf(&#34;Error - OCI_SUCCESS_WITH_INFO\n&#34;);
    break;
  case OCI_NEED_DATA:
    (void) printf(&#34;Error - OCI_NEED_DATA\n&#34;);
    break;
  case OCI_NO_DATA:
    (void) printf(&#34;Error - OCI_NODATA\n&#34;);
    break;
  case OCI_ERROR:
    (void) OCIErrorGet((dvoid *)errhp, (ub4) 1, (text *) NULL, &amp;errcode,
                       errbuf, (ub4) sizeof(errbuf), OCI_HTYPE_ERROR);
    (void) printf(&#34;Error - %.*s\n&#34;, 512, errbuf);
    break;
  case OCI_INVALID_HANDLE:
    (void) printf(&#34;Error - OCI_INVALID_HANDLE\n&#34;);
    break;
  case OCI_STILL_EXECUTING:
    (void) printf(&#34;Error - OCI_STILL_EXECUTE\n&#34;);
    break;
  case OCI_CONTINUE:
    (void) printf(&#34;Error - OCI_CONTINUE\n&#34;);
    break;
  default:
    break;
  }
}
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="LNOCI16697"></a>
<div class="props_rev_3"><a id="GUID-FF4165B2-A44C-4F76-AC26-DA860F340CA8"></a>
<h2 id="LNOCI-GUID-FF4165B2-A44C-4F76-AC26-DA860F340CA8" class="sect2">OCI and Streams Advanced Queuing</h2>
<div>
<p>OCI provides an interface to the Streams Advanced Queuing (Streams AQ) feature. Streams AQ provides message queuing as an integrated part of Oracle Database.</p>
<p>Streams AQ provides this functionality by integrating the queuing system with the database, thereby creating a <span class="italic">message-enabled database.</span> By providing an integrated solution, Streams AQ frees application developers to devote their efforts to their specific business logic rather than having to construct a messaging infrastructure.</p>
<div class="infobox-note" id="GUID-FF4165B2-A44C-4F76-AC26-DA860F340CA8__GUID-338E254E-D679-4142-B350-4D50B42971DF">
<p class="notep1">Note:</p>
<p>To use Streams Advanced Queuing, you must be using the Enterprise Edition of Oracle Database.</p>
</div>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-C7DB04D8-81D1-4253-851E-1C7C389CD7F4" title="Lists the OCI Streams Advanced Queuing functions.">OCI Streams Advanced Queuing Functions</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-D4ED0510-8B6F-40F3-A142-F1DD89C49F02" title="Lists the OCI Streams Advanced Queuing descriptors and shows their usage.">OCI Streams Advanced Queuing Descriptors</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3">Streams Advanced Queuing in OCI Versus PL/SQL</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-145D489F-52D8-4D41-8319-EF1ACA19B7AD">Using Buffered Messaging</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-FF4165B2-A44C-4F76-AC26-DA860F340CA8__GUID-21E3AAFE-0383-4731-9008-76A115228B7F">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADQUE0100" target="_blank" href="../ADQUE/aq_intro.htm#ADQUE0100"><span><cite>Oracle Database Advanced Queuing User&#39;s Guide</cite></span></a></p>
</li>
<li>
<p><a class="olink ADXDK1300" target="_blank" href="../ADXDK/adx_c_gs.htm#ADXDK1300"><span><cite>Oracle XML Developer&#39;s Kit Programmer&#39;s Guide</cite></span></a></p>
</li>
<li>
<p>The description of <a href="oci17msc003.htm#GUID-AE3DB345-0A77-4922-ABBD-FBBFB6E1A9B4" title="Performs an enqueue operation using Streams Advanced Queuing.">OCIAQEnq()</a> for example code demonstrating the use of OCI with AQ</p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16698"></a>
<div class="props_rev_3"><a id="GUID-C7DB04D8-81D1-4253-851E-1C7C389CD7F4"></a>
<h3 id="LNOCI-GUID-C7DB04D8-81D1-4253-851E-1C7C389CD7F4" class="sect3">OCI Streams Advanced Queuing Functions</h3>
<div>
<p>Lists the OCI Streams Advanced Queuing functions.</p>
<p>The OCI library includes several functions related to Streams Advanced Queuing:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIAQEnq()</code></p>
</li>
<li>
<p><code class="codeph">OCIAQDeq()</code></p>
</li>
<li>
<p><code class="codeph">OCIAQListen()</code> (Deprecated)</p>
</li>
<li>
<p><code class="codeph">OCIAQListen2()</code></p>
</li>
<li>
<p><code class="codeph">OCIAQEnqArray()</code></p>
</li>
<li>
<p><code class="codeph">OCIAQDeqArray()</code></p>
</li>
</ul>
<p>You can enqueue an array of messages to a single queue. The messages all share the same enqueue options, but each message in the array can have different message properties. You can also dequeue an array of messages from a single queue. For transaction group queues, you can dequeue all messages for a single transaction group using one call.</p>
<div class="infoboxnotealso" id="GUID-C7DB04D8-81D1-4253-851E-1C7C389CD7F4__GUID-322AC3F2-FDB3-44D6-943B-8B8EA241FCBE">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci17msc003.htm#GUID-4D7FFF56-38DE-4DBF-80E8-48BF19C2B2D3" title="Lists and describes the Streams Advanced Queuing and publish-subscribe functions.">Streams Advanced Queuing and Publish-Subscribe Functions</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#GUID-AE3DB345-0A77-4922-ABBD-FBBFB6E1A9B4" title="Performs an enqueue operation using Streams Advanced Queuing.">OCIAQEnq()</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#GUID-982A4127-C23A-43E6-94CE-D3F76EC4553C">OCIAQDeq()</a></p>
</li>
<li>
<p><a href="ociaedep004.htm#GUID-D8F0FF2D-F9D7-470A-BD5A-54E88C971777" title="This function was deprecated in a release previous to Oracle Database 11g Release 2 (11.2).">OCIAQListen()</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#GUID-499ECEF6-F447-46C5-8F3F-48DE66839BD1">OCIAQListen2()</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#GUID-632ED6BA-017A-40C9-BC51-C9A547B7567C">OCIAQEnqArray()</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#GUID-F0E6A45A-AFAD-4B8F-994B-D5625D1F435A" title="Dequeues an array of messages from a queue.">OCIAQDeqArray()</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16699"></a>
<div class="props_rev_3"><a id="GUID-D4ED0510-8B6F-40F3-A142-F1DD89C49F02"></a>
<h3 id="LNOCI-GUID-D4ED0510-8B6F-40F3-A142-F1DD89C49F02" class="sect3">OCI Streams Advanced Queuing Descriptors</h3>
<div>
<p>Lists the OCI Streams Advanced Queuing descriptors and shows their usage.</p>
<p>The following descriptors are used by OCI Streams AQ operations:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIAQEnqOptions</code></p>
</li>
<li>
<p><code class="codeph">OCIAQDeqOptions</code></p>
</li>
<li>
<p><code class="codeph">OCIAQMsgProperties</code></p>
</li>
<li>
<p><code class="codeph">OCIAQAgent</code></p>
</li>
</ul>
<p>You can allocate these descriptors with the service handle using the standard <code class="codeph">OCIDescriptorAlloc()</code> call. The following code shows examples of this:</p>
<pre dir="ltr">OCIDescriptorAlloc(svch, &amp;enqueue_options, OCI_DTYPE_AQENQ_OPTIONS, 0, 0 ); 
OCIDescriptorAlloc(svch, &amp;dequeue_options, OCI_DTYPE_AQDEQ_OPTIONS, 0, 0 ); 
OCIDescriptorAlloc(svch, &amp;message_properties, OCI_DTYPE_AQMSG_PROPERTIES, 0, 0);
OCIDescriptorAlloc(svch, &amp;agent, OCI_DTYPE_AQAGENT, 0, 0 ); 
</pre>
<p>Each descriptor has a variety of attributes that can be set or read.</p>
<div class="infoboxnotealso" id="GUID-D4ED0510-8B6F-40F3-A142-F1DD89C49F02__GUID-EA903651-B715-40A1-829D-FE2FCC0A3A77">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ociaahan.htm#GUID-011A5B7A-7F24-469A-841A-2FCAF48444CB" title="Lists and describes Streams Advanced Queuing descriptor attributes">Streams Advanced Queuing Descriptor Attributes</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F">OCIDescriptorAlloc()</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16701"></a><a id="LNOCI16702"></a><a id="LNOCI16703"></a><a id="LNOCI16704"></a><a id="LNOCI16705"></a><a id="LNOCI16706"></a><a id="LNOCI16707"></a><a id="LNOCI16708"></a><a id="LNOCI16709"></a><a id="LNOCI16710"></a><a id="LNOCI16700"></a>
<div class="props_rev_3"><a id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3"></a>
<h3 id="LNOCI-GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3" class="sect3">Streams Advanced Queuing in OCI Versus PL/SQL</h3>
<div>
<div class="section">
<p>The following tables compare functions, parameters, and options for OCI Streams AQ functions and descriptors, and PL/SQL AQ functions in the DBMS_AQ package. <a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACIAFCB" title="This table is described by 2 columns. Column 1 is the PL/SQL function and column 2 is its equivalent OCI function.">Table 9-2</a> compares AQ functions.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACIAFCB">
<p class="titleintable">Table 9-2 AQ Functions</p>
<table class="cellalignment6175" title="AQ Functions " summary="This table is described by 2 columns. Column 1 is the PL/SQL function and column 2 is its equivalent OCI function.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6176" id="d107147e15754">PL/SQL Function</th>
<th class="cellalignment6280" id="d107147e15757">OCI Function</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6179" id="d107147e15762" headers="d107147e15754">
<p>DBMS_AQ.ENQUEUE</p>
</td>
<td class="cellalignment6281" headers="d107147e15762 d107147e15757">
<p><code class="codeph">OCIAQEnq()</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6179" id="d107147e15770" headers="d107147e15754">
<p>DBMS_AQ.DEQUEUE</p>
</td>
<td class="cellalignment6281" headers="d107147e15770 d107147e15757">
<p><code class="codeph">OCIAQDeq()</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6179" id="d107147e15778" headers="d107147e15754">
<p>DBMS_AQ.LISTEN</p>
</td>
<td class="cellalignment6281" headers="d107147e15778 d107147e15757">
<p><code class="codeph">OCIAQListen(), OCIAQListen2()</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6179" id="d107147e15786" headers="d107147e15754">
<p>DBMS_AQ.ENQUEUE_ARRAY</p>
</td>
<td class="cellalignment6281" headers="d107147e15786 d107147e15757">
<p><code class="codeph">OCIAQEnqArray()</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6179" id="d107147e15794" headers="d107147e15754">
<p>DBMS_AQ.DEQUEUE_ARRAY</p>
</td>
<td class="cellalignment6281" headers="d107147e15794 d107147e15757">
<p><code class="codeph">OCIAQDeqArray()</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACBJFAJ" title="This table is described by 2 columns. Column 1 is the DBMS_AQ.ENQUEUE parameter and column 2 is its equivalent OCIAQEnq() parameter.">Table 9-3</a> compares the parameters for the enqueue functions.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACBJFAJ">
<p class="titleintable">Table 9-3 Enqueue Parameters</p>
<table class="cellalignment6175" title="Enqueue Parameters " summary="This table is described by 2 columns. Column 1 is the DBMS_AQ.ENQUEUE parameter and column 2 is its equivalent OCIAQEnq() parameter.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6178" id="d107147e15818">DBMS_AQ.ENQUEUE Parameter</th>
<th class="cellalignment6213" id="d107147e15821">OCIAQEnq() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15826" headers="d107147e15818">
<pre dir="ltr">queue_name
</pre></td>
<td class="cellalignment6215" headers="d107147e15826 d107147e15821">
<pre dir="ltr">queue_name
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15833" headers="d107147e15818">
<pre dir="ltr">enqueue_options
</pre></td>
<td class="cellalignment6215" headers="d107147e15833 d107147e15821">
<pre dir="ltr">enqueue_options
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15840" headers="d107147e15818">
<pre dir="ltr">message_properties
</pre></td>
<td class="cellalignment6215" headers="d107147e15840 d107147e15821">
<pre dir="ltr">message_properties
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15847" headers="d107147e15818">
<pre dir="ltr">payload
</pre></td>
<td class="cellalignment6215" headers="d107147e15847 d107147e15821">
<pre dir="ltr">payload
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15854" headers="d107147e15818">
<pre dir="ltr">msgid
</pre></td>
<td class="cellalignment6215" headers="d107147e15854 d107147e15821">
<pre dir="ltr">msgid
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15861" headers="d107147e15818">
<p>-</p>
</td>
<td class="cellalignment6215" headers="d107147e15861 d107147e15821">
<p>Note: <code class="codeph">OCIAQEnq()</code> requires the following additional parameters: <code class="codeph">svch</code><code class="codeph">,</code> <code class="codeph">errh, payload_tdo, payload_ind</code><code class="codeph">, and</code> <code class="codeph">flags</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACIEGEG" title="This table is described by 2 columns. Column 1 is the DBMS_AQ.DEQUEUE parameter and column 2 is its equivalent OCIAQDeq() parameter.">Table 9-4</a> compares the parameters for the dequeue functions.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACIEGEG">
<p class="titleintable">Table 9-4 Dequeue Parameters</p>
<table class="cellalignment6175" title="Dequeue Parameters " summary="This table is described by 2 columns. Column 1 is the DBMS_AQ.DEQUEUE parameter and column 2 is its equivalent OCIAQDeq() parameter.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6178" id="d107147e15898">DBMS_AQ.DEQUEUE Parameter</th>
<th class="cellalignment6213" id="d107147e15901">OCIAQDeq() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15906" headers="d107147e15898">
<pre dir="ltr">queue_name
</pre></td>
<td class="cellalignment6215" headers="d107147e15906 d107147e15901">
<pre dir="ltr">queue_name
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15913" headers="d107147e15898">
<pre dir="ltr">dequeue_options
</pre></td>
<td class="cellalignment6215" headers="d107147e15913 d107147e15901">
<pre dir="ltr">dequeue_options
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15920" headers="d107147e15898">
<pre dir="ltr">message_properties
</pre></td>
<td class="cellalignment6215" headers="d107147e15920 d107147e15901">
<pre dir="ltr">message_properties
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15927" headers="d107147e15898">
<pre dir="ltr">payload
</pre></td>
<td class="cellalignment6215" headers="d107147e15927 d107147e15901">
<pre dir="ltr">payload
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15934" headers="d107147e15898">
<pre dir="ltr">msgid
</pre></td>
<td class="cellalignment6215" headers="d107147e15934 d107147e15901">
<pre dir="ltr">msgid
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15941" headers="d107147e15898">
<p>-</p>
</td>
<td class="cellalignment6215" headers="d107147e15941 d107147e15901">
<p>Note: <code class="codeph">OCIAQDeq()</code> requires the following additional parameters: <code class="codeph">svch</code><code class="codeph">,</code> <code class="codeph">errh, dequeue_options, message_properties, payload_tdo, payload, payload_ind</code><code class="codeph">, and</code> <code class="codeph">flags</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACCCDID" title="This table is described by 2 columns. Column 1 is the DBMS_AQ.LISTEN parameter and column 2 is its equivalent OCIAQListen2() parameter.">Table 9-5</a> compares parameters for the listen functions.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACCCDID">
<p class="titleintable">Table 9-5 Listen Parameters</p>
<table class="cellalignment6175" title="Listen Parameters " summary="This table is described by 2 columns. Column 1 is the DBMS_AQ.LISTEN parameter and column 2 is its equivalent OCIAQListen2() parameter.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6178" id="d107147e15978">DBMS_AQ.LISTEN Parameter</th>
<th class="cellalignment6213" id="d107147e15981">OCIAQListen2() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15986" headers="d107147e15978">
<pre dir="ltr">agent_list
</pre></td>
<td class="cellalignment6215" headers="d107147e15986 d107147e15981">
<pre dir="ltr">agent_list
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e15993" headers="d107147e15978">
<pre dir="ltr">wait
</pre></td>
<td class="cellalignment6215" headers="d107147e15993 d107147e15981">
<pre dir="ltr">wait
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e16000" headers="d107147e15978">
<pre dir="ltr">agent
</pre></td>
<td class="cellalignment6215" headers="d107147e16000 d107147e15981">
<pre dir="ltr">agent
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e16007" headers="d107147e15978">
<pre dir="ltr">listen_delivery_mode
</pre></td>
<td class="cellalignment6215" headers="d107147e16007 d107147e15981">
<p><code class="codeph">lopts</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6181" id="d107147e16015" headers="d107147e15978">
<p>-</p>
</td>
<td class="cellalignment6215" headers="d107147e16015 d107147e15981">
<p>Note: <code class="codeph">OCIAQListen2()</code> requires the following additional parameters: <code class="codeph">svchp, errhp, agent_list, num_agents, agent</code><code class="codeph">, lmops, and</code> <code class="codeph">flags</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACGGDAF" title="This table is described by 2 columns. Column 1 is the DBMS_AQ.ENQUEUE_ARRAY parameter and column 2 is its equivalent OCIAQEnqArray() parameter.">Table 9-6</a> compares parameters for the array enqueue functions.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACGGDAF">
<p class="titleintable">Table 9-6 Array Enqueue Parameters</p>
<table class="cellalignment6175" title="Array Enqueue Parameters " summary="This table is described by 2 columns. Column 1 is the DBMS_AQ.ENQUEUE_ARRAY parameter and column 2 is its equivalent OCIAQEnqArray() parameter.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6192" id="d107147e16048">DBMS_AQ.ENQUEUE_ARRAY Parameter</th>
<th class="cellalignment6233" id="d107147e16051">OCIAQEnqArray() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16056" headers="d107147e16048">
<pre dir="ltr">queue_name
</pre></td>
<td class="cellalignment6234" headers="d107147e16056 d107147e16051">
<pre dir="ltr">queue_name
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16063" headers="d107147e16048">
<pre dir="ltr">enqueue_options
</pre></td>
<td class="cellalignment6234" headers="d107147e16063 d107147e16051">
<pre dir="ltr">enqopt
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16070" headers="d107147e16048">
<pre dir="ltr">array_size
</pre></td>
<td class="cellalignment6234" headers="d107147e16070 d107147e16051">
<pre dir="ltr">iters
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16077" headers="d107147e16048">
<pre dir="ltr">message_properties_array
</pre></td>
<td class="cellalignment6234" headers="d107147e16077 d107147e16051">
<pre dir="ltr">msgprop
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16084" headers="d107147e16048">
<pre dir="ltr">payload_array
</pre></td>
<td class="cellalignment6234" headers="d107147e16084 d107147e16051">
<pre dir="ltr">payload
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16091" headers="d107147e16048">
<pre dir="ltr">msgid_array
</pre></td>
<td class="cellalignment6234" headers="d107147e16091 d107147e16051">
<pre dir="ltr">msgid
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16098" headers="d107147e16048">
<p>-</p>
</td>
<td class="cellalignment6234" headers="d107147e16098 d107147e16051">
<p>Note: <code class="codeph">OCIAQEnqArray()</code> requires the following additional parameters: <code class="codeph">svch</code><code class="codeph">,</code> <code class="codeph">errh, payload_tdo, payload_ind, ctxp, enqcbfp,</code> <code class="codeph">and</code> <code class="codeph">flags</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACFHBEI" title="This table is described by 2 columns. Column 1 is the DBMS_AQ.DEQUEUE_ARRAY parameter and column 2 is its equivalent OCIAQDeqArray() parameter.">Table 9-7</a> compares parameters for the array dequeue functions.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACFHBEI">
<p class="titleintable">Table 9-7 Array Dequeue Parameters</p>
<table class="cellalignment6175" title="Array Dequeue Parameters " summary="This table is described by 2 columns. Column 1 is the DBMS_AQ.DEQUEUE_ARRAY parameter and column 2 is its equivalent OCIAQDeqArray() parameter.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6192" id="d107147e16137">DBMS_AQ.DEQUEUE_ARRAY Parameter</th>
<th class="cellalignment6233" id="d107147e16140">OCIAQDeqArray() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16145" headers="d107147e16137">
<pre dir="ltr">queue_name
</pre></td>
<td class="cellalignment6234" headers="d107147e16145 d107147e16140">
<pre dir="ltr">queue_name
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16152" headers="d107147e16137">
<pre dir="ltr">dequeue_options
</pre></td>
<td class="cellalignment6234" headers="d107147e16152 d107147e16140">
<pre dir="ltr">deqopt
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16159" headers="d107147e16137">
<pre dir="ltr">array_size
</pre></td>
<td class="cellalignment6234" headers="d107147e16159 d107147e16140">
<pre dir="ltr">iters
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16166" headers="d107147e16137">
<pre dir="ltr">message_properties_array
</pre></td>
<td class="cellalignment6234" headers="d107147e16166 d107147e16140">
<pre dir="ltr">msgprop
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16173" headers="d107147e16137">
<pre dir="ltr">payload_array
</pre></td>
<td class="cellalignment6234" headers="d107147e16173 d107147e16140">
<pre dir="ltr">payload
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16180" headers="d107147e16137">
<pre dir="ltr">msgid_array
</pre></td>
<td class="cellalignment6234" headers="d107147e16180 d107147e16140">
<pre dir="ltr">msgid
</pre></td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16187" headers="d107147e16137">
<p>-</p>
</td>
<td class="cellalignment6234" headers="d107147e16187 d107147e16140">
<p>Note: <code class="codeph">OCIAQDeqArray()</code> requires the following additional parameters: <code class="codeph">svch</code><code class="codeph">,</code> <code class="codeph">errh,</code> <code class="codeph">msgprop, payload_tdo, payload_ind, ctxp, deqcbfp,</code> <code class="codeph">and</code> <code class="codeph">flags</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACJHHDB" title="This table is described by 2 columns. Column 1 is the PL/SQL Agent property and column 2 is its equivalent OCIAQAgent attribute.">Table 9-8</a> compares parameters for the agent attributes.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACJHHDB">
<p class="titleintable">Table 9-8 Agent Parameters</p>
<table class="cellalignment6175" title="Agent Parameters " summary="This table is described by 2 columns. Column 1 is the PL/SQL Agent property and column 2 is its equivalent OCIAQAgent attribute.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6182" id="d107147e16228">PL/SQL Agent Parameter</th>
<th class="cellalignment6183" id="d107147e16231">OCIAQAgent Attribute</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6184" id="d107147e16236" headers="d107147e16228">
<pre dir="ltr">name
</pre></td>
<td class="cellalignment6185" headers="d107147e16236 d107147e16231">
<p><code class="codeph">OCI_ATTR_AGENT_NAME</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6184" id="d107147e16244" headers="d107147e16228">
<pre dir="ltr">address
</pre></td>
<td class="cellalignment6185" headers="d107147e16244 d107147e16231">
<p><code class="codeph">OCI_ATTR_AGENT_ADDRESS</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6184" id="d107147e16252" headers="d107147e16228">
<pre dir="ltr">protocol
</pre></td>
<td class="cellalignment6185" headers="d107147e16252 d107147e16231">
<p><code class="codeph">OCI_ATTR_AGENT_PROTOCOL</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACJGGBC" title="This table is described by 2 columns. Column 1 is the PL/SQL Message property and column 2 is its equivalent OCIAQMsgProperties attribute.">Table 9-9</a> compares parameters for the message properties.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACJGGBC">
<p class="titleintable">Table 9-9 Message Properties</p>
<table class="cellalignment6175" title="Message Properties " summary="This table is described by 2 columns. Column 1 is the PL/SQL Message property and column 2 is its equivalent OCIAQMsgProperties attribute.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6192" id="d107147e16276">PL/SQL Message Property</th>
<th class="cellalignment6233" id="d107147e16279">OCIAQMsgProperties Attribute</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16284" headers="d107147e16276">
<pre dir="ltr">priority
</pre></td>
<td class="cellalignment6234" headers="d107147e16284 d107147e16279">
<p><code class="codeph">OCI_ATTR_PRIORITY</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16292" headers="d107147e16276">
<pre dir="ltr">delay
</pre></td>
<td class="cellalignment6234" headers="d107147e16292 d107147e16279">
<p><code class="codeph">OCI_ATTR_DELAY</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16300" headers="d107147e16276">
<pre dir="ltr">expiration
</pre></td>
<td class="cellalignment6234" headers="d107147e16300 d107147e16279">
<p><code class="codeph">OCI_ATTR_EXPIRATION</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16308" headers="d107147e16276">
<pre dir="ltr">correlation
</pre></td>
<td class="cellalignment6234" headers="d107147e16308 d107147e16279">
<p><code class="codeph">OCI_ATTR_CORRELATION</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16316" headers="d107147e16276">
<pre dir="ltr">attempts
</pre></td>
<td class="cellalignment6234" headers="d107147e16316 d107147e16279">
<p><code class="codeph">OCI_ATTR_ATTEMPTS</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16324" headers="d107147e16276">
<pre dir="ltr">recipient_list
</pre></td>
<td class="cellalignment6234" headers="d107147e16324 d107147e16279">
<p><code class="codeph">OCI_ATTR_RECIPIENT_LIST</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16332" headers="d107147e16276">
<pre dir="ltr">exception_queue
</pre></td>
<td class="cellalignment6234" headers="d107147e16332 d107147e16279">
<p><code class="codeph">OCI_ATTR_EXCEPTION_QUEUE</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16340" headers="d107147e16276">
<pre dir="ltr">enqueue_time
</pre></td>
<td class="cellalignment6234" headers="d107147e16340 d107147e16279">
<p><code class="codeph">OCI_ATTR_ENQ_TIME</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16348" headers="d107147e16276">
<pre dir="ltr">state
</pre></td>
<td class="cellalignment6234" headers="d107147e16348 d107147e16279">
<p><code class="codeph">OCI_ATTR_MSG_STATE</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16356" headers="d107147e16276">
<pre dir="ltr">sender_id
</pre></td>
<td class="cellalignment6234" headers="d107147e16356 d107147e16279">
<p><code class="codeph">OCI_ATTR_SENDER_ID</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16364" headers="d107147e16276">
<pre dir="ltr">transaction_group
</pre></td>
<td class="cellalignment6234" headers="d107147e16364 d107147e16279">
<p><code class="codeph">OCI_ATTR_TRANSACTION_NO</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16373" headers="d107147e16276">
<pre dir="ltr">original_msgid
</pre></td>
<td class="cellalignment6234" headers="d107147e16373 d107147e16279">
<p><code class="codeph">OCI_ATTR_ORIGINAL_MSGID</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16381" headers="d107147e16276">
<pre dir="ltr">delivery_mode
</pre></td>
<td class="cellalignment6234" headers="d107147e16381 d107147e16279">
<p><code class="codeph">OCI_ATTR_MSG_DELIVERY_MODE</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACFFHAH" title="This table is described by 2 columns. Column 1 is the PL/SQL Enqueue option and column 2 is its equivalent OCIAQEnqOptions attribute.">Table 9-10</a> compares enqueue option attributes.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACFFHAH">
<p class="titleintable">Table 9-10 Enqueue Option Attributes</p>
<table class="cellalignment6175" title="Enqueue Option Attributes " summary="This table is described by 2 columns. Column 1 is the PL/SQL Enqueue option and column 2 is its equivalent OCIAQEnqOptions attribute.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6290" id="d107147e16405">PL/SQL Enqueue Option</th>
<th class="cellalignment6298" id="d107147e16408">OCIAQEnqOptions Attribute</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6291" id="d107147e16413" headers="d107147e16405">
<pre dir="ltr">visibility
</pre></td>
<td class="cellalignment6299" headers="d107147e16413 d107147e16408">
<p><code class="codeph">OCI_ATTR_VISIBILITY</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6291" id="d107147e16421" headers="d107147e16405">
<pre dir="ltr">relative_msgid
</pre></td>
<td class="cellalignment6299" headers="d107147e16421 d107147e16408">
<p><code class="codeph">OCI_ATTR_RELATIVE_MSGID</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6291" id="d107147e16429" headers="d107147e16405">
<pre dir="ltr">sequence_deviation
</pre></td>
<td class="cellalignment6299" headers="d107147e16429 d107147e16408">
<p><code class="codeph">OCI_ATTR_SEQUENCE_DEVIATION</code></p>
<p>(deprecated)</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6291" id="d107147e16439" headers="d107147e16405">
<p><code class="codeph">transformation</code></p>
</td>
<td class="cellalignment6299" headers="d107147e16439 d107147e16408">
<p><code class="codeph">OCI_ATTR_TRANSFORMATION</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6291" id="d107147e16448" headers="d107147e16405">
<pre dir="ltr">delivery_mode
</pre></td>
<td class="cellalignment6299" headers="d107147e16448 d107147e16408">
<p><code class="codeph">OCI_ATTR_MSG_DELIVERY_MODE</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="oci09adv.htm#GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACEAIFB" title="This table is described by 2 columns. Column 1 is the PL/SQL Dequeue option and column 2 is its equivalent OCIAQDeqOptions attribute.">Table 9-11</a> compares dequeue option attributes.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__CACEAIFB">
<p class="titleintable">Table 9-11 Dequeue Option Attributes</p>
<table class="cellalignment6175" title="Dequeue Option Attributes " summary="This table is described by 2 columns. Column 1 is the PL/SQL Dequeue option and column 2 is its equivalent OCIAQDeqOptions attribute.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6192" id="d107147e16472">PL/SQL Dequeue Option</th>
<th class="cellalignment6233" id="d107147e16475">OCIAQDeqOptions Attribute</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16480" headers="d107147e16472">
<pre dir="ltr">consumer_name
</pre></td>
<td class="cellalignment6234" headers="d107147e16480 d107147e16475">
<p><code class="codeph">OCI_ATTR_CONSUMER_NAME</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16488" headers="d107147e16472">
<pre dir="ltr">dequeue_mode
</pre></td>
<td class="cellalignment6234" headers="d107147e16488 d107147e16475">
<p><code class="codeph">OCI_ATTR_DEQ_MODE</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16496" headers="d107147e16472">
<pre dir="ltr">navigation
</pre></td>
<td class="cellalignment6234" headers="d107147e16496 d107147e16475">
<p><code class="codeph">OCI_ATTR_NAVIGATION</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16504" headers="d107147e16472">
<pre dir="ltr">visibility
</pre></td>
<td class="cellalignment6234" headers="d107147e16504 d107147e16475">
<p><code class="codeph">OCI_ATTR_VISIBILITY</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16512" headers="d107147e16472">
<pre dir="ltr">wait
</pre></td>
<td class="cellalignment6234" headers="d107147e16512 d107147e16475">
<p><code class="codeph">OCI_ATTR_WAIT</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16520" headers="d107147e16472">
<pre dir="ltr">msgid
</pre></td>
<td class="cellalignment6234" headers="d107147e16520 d107147e16475">
<p><code class="codeph">OCI_ATTR_DEQ_MSGID</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16528" headers="d107147e16472">
<pre dir="ltr">correlation
</pre></td>
<td class="cellalignment6234" headers="d107147e16528 d107147e16475">
<p><code class="codeph">OCI_ATTR_CORRELATION</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16536" headers="d107147e16472">
<p><code class="codeph">deq_condition</code></p>
</td>
<td class="cellalignment6234" headers="d107147e16536 d107147e16475">
<p><code class="codeph">OCI_ATTR_DEQCOND</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16545" headers="d107147e16472">
<p><code class="codeph">transformation</code></p>
</td>
<td class="cellalignment6234" headers="d107147e16545 d107147e16475">
<p><code class="codeph">OCI_ATTR_TRANSFORMATION</code></p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6193" id="d107147e16554" headers="d107147e16472">
<pre dir="ltr">delivery_mode
</pre></td>
<td class="cellalignment6234" headers="d107147e16554 d107147e16475">
<p><code class="codeph">OCI_ATTR_MSG_DELIVERY_MODE</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<div class="infobox-note" id="GUID-BB00AF24-95F4-4BE5-A4BE-DA9C6004F1A3__GUID-B3E7CE42-2DE9-4687-B921-2A9C8A18F6B8">
<p class="notep1">Note:</p>
<p><a href="oci17msc003.htm#GUID-AE3DB345-0A77-4922-ABBD-FBBFB6E1A9B4" title="Performs an enqueue operation using Streams Advanced Queuing.">OCIAQEnq()</a> returns the error <a id="d107147e16571" class="indexterm-anchor"></a><code class="codeph">ORA-25219</code> while specifying the enqueue option <a id="d107147e16576" class="indexterm-anchor"></a><code class="codeph">OCI_ATTR_SEQUENCE</code> along with <code class="codeph">OCI_ATTR_RELATIVE_MSGID.</code> This happens when enqueuing two messages. For the second message, enqueue options <code class="codeph">OCI_ATTR_SEQUENCE</code> and <code class="codeph">OCI_ATTR_RELATIVE_MSGID</code> are set to dequeue this message before the first one. An error is not returned if you do not specify the sequence but, of course, the message is not dequeued before the relative message.</p>
<p><a href="oci17msc003.htm#GUID-AE3DB345-0A77-4922-ABBD-FBBFB6E1A9B4" title="Performs an enqueue operation using Streams Advanced Queuing.">OCIAQEnq()</a> does not return an error if the <code class="codeph">OCI_ATTR_SEQUENCE</code> attribute is not set, but the message is not dequeued before the message with relative message ID.</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="LNOCI72682"></a><a id="LNOCI72683"></a><a id="LNOCI13268"></a>
<div class="props_rev_2"><a id="GUID-145D489F-52D8-4D41-8319-EF1ACA19B7AD"></a>
<h3 id="LNOCI-GUID-145D489F-52D8-4D41-8319-EF1ACA19B7AD" class="sect3">Using Buffered Messaging</h3>
<div>
<div class="section">
<p>Buffered messaging is a nonpersistent messaging capability within Streams AQ that was first available in Oracle Database 10<span class="italic">g</span> Release 2. Buffered messages reside in shared memory and can be lost if there is an instance failure. Unlike persistent messages, redo does not get written to disk. Buffered message enqueue and dequeue is much faster than persistent message operations. Because shared memory is limited, buffered messages may have to be spilled to disk. Flow control can be enabled to prevent applications from flooding the shared memory when the message consumers are slow or have stopped for some reason. The following functions are used for buffered messaging:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="oci17msc003.htm#GUID-AE3DB345-0A77-4922-ABBD-FBBFB6E1A9B4" title="Performs an enqueue operation using Streams Advanced Queuing.">OCIAQEnq()</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="oci17msc003.htm#GUID-982A4127-C23A-43E6-94CE-D3F76EC4553C">OCIAQDeq()</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="oci17msc003.htm#GUID-499ECEF6-F447-46C5-8F3F-48DE66839BD1">OCIAQListen2()</a>&#34;</span></p>
</li>
</ul>
<p><a href="oci09adv.htm#GUID-145D489F-52D8-4D41-8319-EF1ACA19B7AD__CACBCHCE">Example 9-14</a> shows an example of enqueue buffered messaging.</p>
<p><a href="oci09adv.htm#GUID-145D489F-52D8-4D41-8319-EF1ACA19B7AD__CACJHBEE">Example 9-15</a> shows an example of dequeue buffered messaging.</p>
<div class="infobox-note" id="GUID-145D489F-52D8-4D41-8319-EF1ACA19B7AD__GUID-104265C9-6D47-46B1-BE21-F757E931B5B3">
<p class="notep1">Note:</p>
<p>Array operations are not supported for buffered messaging. Applications can use the <code class="codeph">OCIAQEnqArray()</code> and <code class="codeph">OCIAQDeqArray()</code> functions with the array size set to 1.</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-145D489F-52D8-4D41-8319-EF1ACA19B7AD__CACBCHCE">
<p class="titleinexample">Example 9-14 Enqueue Buffered Messaging</p>
<pre dir="ltr">...
OCIAQMsgProperties  *msgprop;
OCIAQEnqueueOptions *enqopt;
message              msg;    /* message is an object type */
null_message         nmsg;   /* message indicator */
...
/* Allocate descriptors */
  OCIDescriptorAlloc(envhp, (void **)&amp;enqopt, OCI_DTYPE_AQENQ_OPTIONS, 0,
                     (void **)0));
 
 OCIDescriptorAlloc(envhp, (void **)&amp;msgprop,OCI_DTYPE_AQMSG_PROPERTIES, 0,
                    (void **)0));
 
/* Set delivery mode to buffered */
 dlvm = OCI_MSG_BUFFERED;
 OCIAttrSet(enqopt,  OCI_DTYPE_AQENQ_OPTIONS, (void *)&amp;dlvm, sizeof(ub2),
            OCI_ATTR_MSG_DELIVERY_MODE, errhp);
/* Set visibility to Immediate (visibility must always be immediate for buffered
   messages) */
vis = OCI_ENQ_ON_COMMIT;
 
OCIAttrSet(enqopt, OCI_DTYPE_AQENQ_OPTIONS,(void *)&amp;vis, sizeof(ub4),
           OCI_ATTR_VISIBILITY, errhp)
 
/* Message was an object type created earlier, msg_tdo is its type
   descriptor object */
OCIAQEnq(svchp, errhp, &#34;Test_Queue&#34;, enqopt, msgprop, msg_tdo, (void **)&amp;mesg,
         (void **)&amp;nmesg, (OCIRaw **)0, 0));
...
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-145D489F-52D8-4D41-8319-EF1ACA19B7AD__CACJHBEE">
<p class="titleinexample">Example 9-15 Dequeue Buffered Messaging</p>
<pre dir="ltr">...
OCIAQMsgProperties  *msgprop;
OCIAQDequeueOptions *deqopt;
...
OCIDescriptorAlloc(envhp, (void **)&amp;mprop, OCI_DTYPE_AQMSG_PROPERTIES, 0,
                   (void **)0));
OCIDescriptorAlloc(envhp, (void **)&amp;deqopt, OCI_DTYPE_AQDEQ_OPTIONS, 0,
                   (void **)0);

/* Set visibility to Immediate (visibility must always be immediate for buffered
   message operations) */
vis = OCI_ENQ_ON_COMMIT;
OCIAttrSet(deqopt, OCI_DTYPE_AQDEQ_OPTIONS,(void *)&amp;vis, sizeof(ub4),
           OCI_ATTR_VISIBILITY, errhp)
/* delivery mode is buffered */
dlvm  = OCI_MSG_BUFFERED;
OCIAttrSet(deqopt, OCI_DTYPE_AQDEQ_OPTIONS, (void *)&amp;dlvm,  sizeof(ub2),
           OCI_ATTR_MSG_DELIVERY_MODE, errhp);
/* Set the consumer for which to dequeue the message (this must be specified
   regardless of the type of message being dequeued).
*/
consumer = &#34;FIRST_SUBSCRIBER&#34;;
OCIAttrSet(deqopt, OCI_DTYPE_AQDEQ_OPTIONS, (void *)consumer,
           (ub4)strlen((char*)consumer), OCI_ATTR_CONSUMER_NAME, errhp);
/* Dequeue the message but do not return the payload (to simplify the code
   fragment)
*/
OCIAQDeq(svchp, errhp,  &#34;test_queue&#34;, deqopt, msgprop, msg_tdo, (void **)0,
         (void **)0, (OCIRaw**)0, 0);
...
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNOCI16714"></a><a id="LNOCI16713"></a>
<div class="props_rev_3"><a id="GUID-9CE58707-FC18-492E-8AA9-5314041BCEE4"></a>
<h2 id="LNOCI-GUID-9CE58707-FC18-492E-8AA9-5314041BCEE4" class="sect2">Publish-Subscribe Notification in OCI</h2>
<div>
<p>The publish-subscribe notification feature allows an OCI application to receive client notifications directly, register an email address to which notifications can be sent, register an HTTP URL to which notifications can be posted, or register a PL/SQL procedure to be invoked on a notification.</p>
<p><a href="oci09adv.htm#GUID-9CE58707-FC18-492E-8AA9-5314041BCEE4__I457371">Figure 9-2</a> illustrates the process.</p>
<div class="figure" id="GUID-9CE58707-FC18-492E-8AA9-5314041BCEE4__I457371">
<p class="titleinfigure">Figure 9-2 Publish-Subscribe Model</p>
<img width="644" height="470" src="img/GUID-1396934A-73E5-4DDB-9365-F52C40A91351-default.gif" alt="Description of Figure 9-2 follows" title="Description of Figure 9-2 follows"/><br/>
<a href="img_text/GUID-1396934A-73E5-4DDB-9365-F52C40A91351-print.htm">Description of &#34;Figure 9-2 Publish-Subscribe Model&#34;</a></div>
<!-- class="figure" -->
<p>An OCI application can:</p>
<ul style="list-style-type: disc;">
<li>
<p>Register interest in notifications in the AQ namespace and be notified when an enqueue occurs</p>
</li>
<li>
<p>Register interest in subscriptions to database events and receive notifications when the events are triggered</p>
</li>
<li>
<p>Manage registrations, such as disabling registrations temporarily or dropping the registrations entirely</p>
</li>
<li>
<p>Post or send notifications to registered clients</p>
</li>
</ul>
<p>In all the preceding scenarios the notification can be received directly by the OCI application, or the notification can be sent to a prespecified email address, or it can be sent to a predefined HTTP URL, or a prespecified database PL/SQL procedure can be invoked because of a notification.</p>
<p>Registered clients are notified asynchronously when events are triggered or on an explicit AQ enqueue. Clients do not need to be connected to a database.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-1E9445D7-DFD9-4230-BFFD-EF3630691ECE" title="You can register directly to the database or register using Lightweight Directory Access Protocol (LDAP).">Publish-Subscribe Registration Functions in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5" title="The client must register a notification callback that gets invoked when there is some activity on the subscription for which interest has been registered.">Notification Callback in OCI</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-078F3FD1-7CAA-45FC-A93F-1CE942D27CA0" title="The PL/SQL notification procedure that is invoked when there is some activity on the subscription for which interest has been registered, must be created in the database.">Notification Procedure</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-909E21A8-A247-4E54-9069-79B3EF219D2F">Publish-Subscribe Direct Registration Example</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-9F4EEC78-5CAC-4E86-9F82-1FF9586289CF">Publish-Subscribe LDAP Registration Example</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-9CE58707-FC18-492E-8AA9-5314041BCEE4__GUID-642616AE-C0DB-4BAE-B1C3-C044AC88CDDA">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-FF4165B2-A44C-4F76-AC26-DA860F340CA8" title="OCI provides an interface to the Streams Advanced Queuing (Streams AQ) feature. Streams AQ provides message queuing as an integrated part of Oracle Database.">OCI and Streams Advanced Queuing</a> for information about Streams Advanced Queuing</p>
</li>
<li>
<p><a class="olink ADQUE0100" target="_blank" href="../ADQUE/aq_intro.htm#ADQUE0100"><span><cite>Oracle Database Advanced Queuing User&#39;s Guide</cite></span></a> for information about creating queues and about Streams AQ, including concepts, features, and examples</p>
</li>
<li>
<p>The chapter about <code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code> in the <a class="olink SQLRF01405" target="_blank" href="../SQLRF/statements_7004.htm#SQLRF01405"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about creating triggers</p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16715"></a>
<div class="props_rev_3"><a id="GUID-1E9445D7-DFD9-4230-BFFD-EF3630691ECE"></a>
<h3 id="LNOCI-GUID-1E9445D7-DFD9-4230-BFFD-EF3630691ECE" class="sect3">Publish-Subscribe Registration Functions in OCI</h3>
<div>
<p>You can register directly to the database or register using Lightweight Directory Access Protocol (LDAP).</p>
<p>Registration can be done in two ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>Direct registration. You register directly to the database. This way is simple and the registration takes effect immediately.</p>
</li>
<li>
<p>Open registration. You register using Lightweight Directory Access Protocol (LDAP), from which the database receives the registration request. This is useful when the client cannot have a database connection (the client wants to register for a database open event while the database is down), or if the client wants to register for the same event or events in multiple databases simultaneously.</p>
</li>
</ul>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4" title="The following steps are required in an OCI application to register directly and receive notifications for events.">Publish-Subscribe Register Directly to the Database</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-5C733061-A0B7-4852-B0B6-A013CB0D7739" title="Lists the prerequisites for the open registration for publish-subscribe.">Open Registration for Publish-Subscribe</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-C7ED46E0-43C2-41A3-B89E-8F05DF0C4CC8" title="Shows how to open register using LDAP registration.">Using OCI to Open Register with LDAP</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-00B6E34B-201C-4C6E-B188-238FE58836D8" title="Shows how to set QOSFLAGS to QOS levels using OCIAttrSet().">Setting QOS, Timeout Interval, Namespace, Client Address, and Port Number</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-362BE190-510B-4187-A93E-C4538E2C8A24">OCI Functions Used to Manage Publish-Subscribe Notification</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-1E9445D7-DFD9-4230-BFFD-EF3630691ECE__GUID-812E3D19-0E2E-4109-B196-4E99F51B045C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4" title="The following steps are required in an OCI application to register directly and receive notifications for events.">Publish-Subscribe Register Directly to the Database</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-5C733061-A0B7-4852-B0B6-A013CB0D7739" title="Lists the prerequisites for the open registration for publish-subscribe.">Open Registration for Publish-Subscribe</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI72684"></a><a id="LNOCI16716"></a>
<div class="props_rev_3"><a id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4"></a>
<h4 id="LNOCI-GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4" class="sect4">Publish-Subscribe Register Directly to the Database</h4>
<div>
<p>The following steps are required in an OCI application to register directly and receive notifications for events.</p>
<p>It is assumed that the appropriate event trigger or AQ queue has been set up. The initialization parameter <code class="codeph">COMPATIBLE</code> must be set to 8.1 or later.</p>
<div class="infoboxnotealso" id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__GUID-E124B95D-80B5-4B3D-A8DF-F1FCD904ADBA">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci17msc003.htm#GUID-4D7FFF56-38DE-4DBF-80E8-48BF19C2B2D3" title="Lists and describes the Streams Advanced Queuing and publish-subscribe functions.">Streams Advanced Queuing and Publish-Subscribe Functions</a></p>
</li>
<li>
<p><a href="oci09adv.htm#GUID-909E21A8-A247-4E54-9069-79B3EF219D2F">Publish-Subscribe Direct Registration Example</a> for examples of the use of these functions in an application</p>
</li>
</ul>
</div>
<div class="infobox-note" id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__GUID-45D4D6C0-A953-4C66-8CA5-EA237EB1A50B">
<p class="notep1">Note:</p>
<p>The publish-subscribe feature is only available on multithreaded operating systems.</p>
</div>
<ol>
<li>
<p>Call <code class="codeph">OCIEnvCreate()</code> or <code class="codeph">OCIEnvNlsCreate()</code> with <code class="codeph">OCI_EVENTS</code> mode to specify that the application is interested in registering for and receiving notifications. This starts a dedicated listening thread for notifications on the client.</p>
</li>
<li>
<p>Call <code class="codeph">OCIHandleAlloc()</code> with handle type <code class="codeph">OCI_HTYPE_SUBSCRIPTION</code> to allocate a subscription handle.</p>
</li>
<li>
<p>Call <code class="codeph">OCIAttrSet()</code> to set the subscription handle attributes for:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_NAME</code> - Subscription name</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_NAMESPACE</code> - Subscription namespace</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_HOSTADDR</code> - Environment handle attribute that sets the client IP (in either IPv4 or IPv6 format) to which notification is sent</p>
<p>Oracle Database components and utilities support Internet Protocol version 6 (IPv6) addresses.</p>
<div class="infoboxnotealso" id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__GUID-BC89470B-7AD1-4462-8D55-38CD92C761E4">
<p class="notep1">See Also:</p>
<p><a href="ociaahan.htm#GUID-A76BBB38-8F77-40B8-B5A6-1F9C9166C71C__BAJDBBIC">OCI_ATTR_SUBSCR_HOSTADDR</a>, <a href="ociaahan.htm#GUID-A76BBB38-8F77-40B8-B5A6-1F9C9166C71C__BAJHEBIA">OCI_ATTR_SUBSCR_IPADDR</a>, and <a class="olink NETAG1453" target="_blank" href="../NETAG/layers.htm#NETAG1453"><span><cite>Oracle Database Net Services Administrator&#39;s Guide</cite></span></a> for more information about the IPv6 format for IP addresses</p>
</div>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_CALLBACK</code> - Notification callback</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_CTX</code> - Callback context</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_PAYLOAD</code> - Payload buffer for posting</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_RECPT</code> - Recipient name</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_RECPTPROTO</code> - Protocol to receive notification with</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_RECPTPRES</code> - Presentation to receive notification with</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_QOSFLAGS</code> - QOS (quality of service) levels with the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p>If <code class="codeph">OCI_SUBSCR_QOS_PURGE_ON_NTFN</code> is set, the registration is purged on the first notification.</p>
</li>
<li>
<p>If <code class="codeph">OCI_SUBSCR_QOS_RELIABLE</code> is set, notifications are persistent. You can use surviving instances of an Oracle RAC database to send and retrieve change notification messages even after a node failure, because invalidations associated with this registration are queued persistently into the database. If <code class="codeph">FALSE</code>, then invalidations are enqueued into a fast in-memory queue. Note that this option describes the persistence of notifications and not the persistence of registrations. Registrations are automatically persistent by default.</p>
</li>
</ul>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_TIMEOUT</code> - Registration timeout interval in seconds. The default is 0 if a timeout is not set.</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_NTFN_GROUPING_CLASS</code> - notification grouping class</p>
<p>Notifications can be spaced out by using the grouping NTFN option with the following constants. A value supported for notification grouping class is:</p>
<pre dir="ltr">#define OCI_SUBSCR_NTFN_GROUPING_CLASS_TIME   1 /* time  */
</pre></li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_NTFN_GROUPING_VALUE</code> - notification grouping value in seconds</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_NTFN_GROUPING_TYPE</code> - notification grouping type</p>
<p>Supported values for notification grouping type:</p>
<pre dir="ltr">#define OCI_SUBSCR_NTFN_GROUPING_TYPE_SUMMARY 1  /* summary */
#define OCI_SUBSCR_NTFN_GROUPING_TYPE_LAST    2  /* last */ 
</pre></li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_NTFN_GROUPING_START_TIME</code> - notification grouping start time</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_NTFN_GROUPING_REPEAT_COUNT</code> - notification grouping repeat count</p>
</li>
</ul>
<p><code class="codeph">OCI_ATTR_SUBSCR_NAME</code>, <code class="codeph">OCI_ATTR_SUBSCR_NAMESPACE</code>, and <code class="codeph">OCI_ATTR_SUBSCR_RECPTPROTO</code> must be set before you register a subscription.</p>
<p>If <code class="codeph">OCI_ATTR_SUBSCR_RECPTPROTO</code> is set to <code class="codeph">OCI_SUBSCR_PROTO_OCI</code>, then <code class="codeph">OCI_ATTR_SUBSCR_CALLBACK</code> and <code class="codeph">OCI_ATTR_SUBSCR_CTX</code> also must be set.</p>
<p>If <code class="codeph">OCI_ATTR_SUBSCR_RECPTPROTO</code> is set to <code class="codeph">OCI_SUBSCR_PROTO_MAIL</code>, <code class="codeph">OCI_SUBSCR_PROTO_SERVER</code>, or <code class="codeph">OCI_SUBSCR_PROTO_HTTP</code>, then <code class="codeph">OCI_ATTR_SUBSCR_RECPT</code> also must be set.</p>
<p>Setting <code class="codeph">OCI_ATTR_SUBSCR_CALLBACK</code> and <code class="codeph">OCI_ATTR_SUBSCR_RECPT</code> at the same time causes an application error.</p>
<p><code class="codeph">OCI_ATTR_SUBSCR_PAYLOAD</code> is required before the application can perform a post to a subscription.</p>
<div class="infoboxnotealso" id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__GUID-5A5F0DBF-D62E-4D29-A8DB-93647C6DAD07">
<p class="notep1">See Also:</p>
<p><a href="ociaahan.htm#GUID-A76BBB38-8F77-40B8-B5A6-1F9C9166C71C" title="Lists and describes subscription handle attributes.">Subscription Handle Attributes</a> and <a href="oci02bas.htm#GUID-083E4689-0B45-4120-9FBD-3E5FE6BB1589" title="Each OCI function call is executed in the context of an environment that is created with the OCIEnvCreate() call.">About Creating the OCI Environment</a> for setting up the environment with <code class="codeph">mode = OCI_EVENTS | OCI_OBJECT</code>. <code class="codeph">OCI_OBJECT</code> is required for grouping notifications.</p>
</div>
</li>
<li>
<p>Set he values of QOS, timeout interval, namespace, and port (see Example&nbsp;9&ndash;15).</p>
<div class="infoboxnotealso" id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__GUID-F192A4D3-36E4-4D17-8FCD-64649859E6C5">
<p class="notep1">See Also:</p>
<p><a href="oci09adv.htm#GUID-00B6E34B-201C-4C6E-B188-238FE58836D8" title="Shows how to set QOSFLAGS to QOS levels using OCIAttrSet().">Setting QOS, Timeout Interval, Namespace, Client Address, and Port Number</a></p>
</div>
</li>
<li>
<p>Set <code class="codeph">OCI_ATTR_SUBSCR_RECPTPROTO</code> to <code class="codeph">OCI_SUBSCR_PROTO_OCI</code>, then define the callback routine to be used with the subscription handle.</p>
<div class="infoboxnotealso" id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__GUID-F81E772A-37B5-4E60-A900-824F5D590A14">
<p class="notep1">See Also:</p>
<p><a href="oci09adv.htm#GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5" title="The client must register a notification callback that gets invoked when there is some activity on the subscription for which interest has been registered.">Notification Callback in OCI</a></p>
</div>
</li>
<li>
<p>Set <code class="codeph">OCI_ATTR_SUBSCR_RECPTPROTO</code> to <code class="codeph">OCI_SUBSCR_PROTO_SERVER</code>, then define the PL/SQL procedure, to be invoked on notification, in the database.</p>
<div class="infoboxnotealso" id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__GUID-FEE7B581-AEAF-4671-A201-67C6ABC65D93">
<p class="notep1">See Also:</p>
<p><a href="oci09adv.htm#GUID-078F3FD1-7CAA-45FC-A93F-1CE942D27CA0" title="The PL/SQL notification procedure that is invoked when there is some activity on the subscription for which interest has been registered, must be created in the database.">Notification Procedure</a></p>
</div>
</li>
<li>
<p>Call <code class="codeph">OCISubscriptionRegister()</code> to register with the subscriptions. This call can register interest in several subscriptions at the same time.</p>
</li>
</ol>
<p><a href="oci09adv.htm#GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__CACFFAEH">Example 9-16</a> shows an example of setting QOS levels.</p>
<div class="example" id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__CACFFAEH">
<p class="titleinexample">Example 9-16 Setting QOS Levels, the Notification Grouping Class, Value, and Type, and the Namespace Specific Context</p>
<pre dir="ltr">/* Set QOS levels */
ub4 qosflags = OCI_SUBSCR_QOS_PAYLOAD;
 
/* Set QOS flags in subscription handle */
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) &amp;qosflags, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_QOSFLAGS, errhp);
 
/* Set notification grouping class */
ub4 ntfn_grouping_class = OCI_SUBSCR_NTFN_GROUPING_CLASS_TIME;
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) &amp;ntfn_grouping_class, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_NTFN_GROUPING_CLASS, errhp);
 
/* Set notification grouping value of 10 minutes */
ub4 ntfn_grouping_value = 600;
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) &amp;ntfn_grouping_value, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_NTFN_GROUPING_VALUE, errhp);
 
/* Set notification grouping type */
ub4 ntfn_grouping_type = OCI_SUBSCR_NTFN_GROUPING_TYPE_SUMMARY;
 
/* Set notification grouping type in subscription handle */
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) &amp;ntfn_grouping_type, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_NTFN_GROUPING_TYPE, errhp);
 
/* Set namespace specific context */
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) NULL, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_NAMESPACE_CTX, errhp);
</pre></div>
<!-- class="example" -->
<div class="section">
<p class="subhead3"></p>
<div class="infoboxnotealso" id="GUID-4D013BA8-B824-45FB-A54A-21FF42B256F4__GUID-837FCDA2-710B-4A69-8107-A7968A674D14">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel001.htm#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="Creates and initializes an environment handle for OCI functions to work under.">OCIEnvCreate()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="Creates and initializes an environment handle for OCI functions to work under.">OCIEnvNlsCreate()</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="Sets the value of an attribute of a handle or a descriptor.">OCIAttrSet()</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#GUID-36729D3E-E920-4FAA-8EAA-6E033F6D8930" title="Registers a callback for message notification.">OCISubscriptionRegister()</a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="LNOCI16718"></a>
<div class="props_rev_3"><a id="GUID-5C733061-A0B7-4852-B0B6-A013CB0D7739"></a>
<h4 id="LNOCI-GUID-5C733061-A0B7-4852-B0B6-A013CB0D7739" class="sect4">Open Registration for Publish-Subscribe</h4>
<div>
<p>Lists the prerequisites for the open registration for publish-subscribe.</p>
<div class="section">
<p>Prerequisites for the open registration for publish-subscribe are as follows:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Registering using LDAP (open registration) requires the client to be an enterprise user.</p>
<div class="infoboxnotealso" id="GUID-5C733061-A0B7-4852-B0B6-A013CB0D7739__GUID-03CE6BDB-B81B-4DA1-ADE4-24A63D764BF0">
<p class="notep1">See Also:</p>
<p><a class="olink DBIMI152" target="_blank" href="../DBIMI/concepts.htm#DBIMI152"><span><cite>Oracle Database Enterprise User Security Administrator&#39;s Guide</cite></span></a>, sections about managing enterprise user security</p>
</div>
</li>
</ul>
<ul style="list-style-type: disc;">
<li>
<p>The compatibility of the database must be 9.0 or later.</p>
</li>
<li>
<p><code class="codeph">LDAP_REGISTRATION_ENABLED</code> must be set to <code class="codeph">TRUE</code>. This can be done this way:</p>
<pre dir="ltr"> ALTER SYSTEM SET LDAP_REGISTRATION_ENABLED=TRUE
</pre>
<p>The default is <code class="codeph">FALSE</code>.</p>
</li>
<li>
<p><code class="codeph">LDAP_REG_SYNC_INTERVAL</code> must be set to the time interval (in seconds) to refresh registrations from LDAP:</p>
<pre dir="ltr"> ALTER SYSTEM SET LDAP_REG_SYNC_INTERVAL =  time_interval
</pre>
<p>The default is 0, which means do not refresh.</p>
</li>
<li>
<p>To force a database refresh of LDAP registration information immediately:</p>
<pre dir="ltr">ALTER SYSTEM REFRESH LDAP_REGISTRATION
</pre></li>
</ul>
<p>The steps for open registration using Oracle Enterprise Security Manager (OESM) are:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>In each enterprise domain, create the enterprise role, <code class="codeph">ENTERPRISE_AQ_USER_ROLE</code>.</span></li>
<li><span>For each database in the enterprise domain, add the global role <code class="codeph">GLOBAL_AQ_USER_ROLE</code> to the enterprise role <code class="codeph">ENTERPRISE_AQ_USER_ROLE</code>.</span></li>
<li><span>For each enterprise domain, add the enterprise role <code class="codeph">ENTERPRISE_AQ_USER_ROLE</code> to the privilege group <code class="codeph">cn=OracleDBAQUsers</code>, under <code class="codeph">cn=oraclecontext</code>, under the administrative context.</span></li>
<li><span>For each enterprise user that is authorized to register for events in the database, grant the enterprise role <code class="codeph">ENTERPRISE_AQ_USER_ROLE</code>.</span></li>
</ol>
</div>
</div>
<a id="LNOCI16719"></a>
<div class="props_rev_3"><a id="GUID-C7ED46E0-43C2-41A3-B89E-8F05DF0C4CC8"></a>
<h4 id="LNOCI-GUID-C7ED46E0-43C2-41A3-B89E-8F05DF0C4CC8" class="sect4">Using OCI to Open Register with LDAP</h4>
<div>
<p>Shows how to open register using LDAP registration.</p>
<ol>
<li class="stepexpand"><span>Call <code class="codeph">OCIEnvCreate()</code> or <code class="codeph">OCIEnvNlsCreate()</code> with <code class="codeph">mode</code> set to <code class="codeph">OCI_EVENTS</code> | <code class="codeph">OCI_USE_LDAP</code>.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIAttrSet()</code> to set the following environment handle attributes for accessing LDAP:</span>
<div>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCI_ATTR_LDAP_HOST</code>: the host name on which the LDAP server resides</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_LDAP_PORT</code>: the port on which the LDAP server is listening</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_BIND_DN</code>: the distinguished name to log in to the LDAP server, usually the DN of the enterprise user</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_LDAP_CRED</code>: the credential used to authenticate the client, for example, the password for simple authentication (user name and password)</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_WALL_LOC</code>: for SSL authentication, the location of the client wallet</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_LDAP_AUTH</code>: the authentication method code</p>
<div class="infoboxnotealso" id="GUID-C7ED46E0-43C2-41A3-B89E-8F05DF0C4CC8__GUID-8CC7F3BA-DA0A-46D7-AECD-3BF1ABCD839B">
<p class="notep1">See Also:</p>
<p><a href="ociaahan.htm#GUID-9CA5026C-B6A0-4233-8B22-F1DD94ACE9F8" title="Lists and describes environment handle attributes.">Environment Handle Attributes</a> for a complete list of authentication modes</p>
</div>
</li>
<li>
<p><code class="codeph">OCI_ATTR_LDAP_CTX</code>: the administrative context for Oracle Database in the LDAP server</p>
</li>
</ul>
</div>
</li>
<li class="stepexpand"><span>Call <code class="codeph">OCIHandleAlloc()</code> with handle type <code class="codeph">OCI_HTYPE_SUBSCRIPTION</code>, to allocate a subscription handle.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIArrayDescriptorAlloc()</code> with descriptor type <code class="codeph">OCI_DTYPE_SRVDN</code>, to allocate a server DN descriptor.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIAttrSet()</code>to set the server DN descriptor attributes for <code class="codeph">OCI_ATTR_SERVER_DN</code>, the distinguished name of the database in which the client wants to receive notifications. <code class="codeph">OCIAttrSet()</code> can be called multiple times for this attribute so that more than one database server is included in the registration.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIAttrSet()</code> to set the subscription handle attributes for:</span>
<div>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_NAME</code> - Subscription name</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_NAMESPACE</code> - Subscription namespace</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_CALLBACK</code>- Notification callback</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_CTX</code> - Callback context</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_PAYLOAD</code> - Payload buffer for posting</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_RECPT</code> - Recipient name</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_RECPTPROTO</code> - Protocol to receive notification with</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_RECPTRES</code> - Presentation to receive notification with</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_QOSFLAGS</code> - QOS (quality of service) levels</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_TIMEOUT</code> - Registration timeout interval in seconds. The default is 0 if a timeout is not set.</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_SUBSCR_SERVER_DN</code> - The descriptor handles you populated in Step 5</p>
</li>
</ul>
</div>
</li>
<li class="stepexpand"><span>The values of QOS, timeout interval, namespace, and port are set. See <a href="oci09adv.htm#GUID-00B6E34B-201C-4C6E-B188-238FE58836D8" title="Shows how to set QOSFLAGS to QOS levels using OCIAttrSet().">Setting QOS, Timeout Interval, Namespace, Client Address, and Port Number</a>.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCISubscriptionRegister()</code> to register the subscriptions. The registration takes effect when the database accesses LDAP to pick up new registrations. The frequency of pickups is determined by the value of <code class="codeph">LDAP_REG_SYNC_INTERVAL</code>.</span></li>
</ol>
<div class="section">
<div class="infoboxnotealso" id="GUID-C7ED46E0-43C2-41A3-B89E-8F05DF0C4CC8__GUID-8B491AC7-B5A8-4E63-B8C7-FFAAF266A59C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel001.htm#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="Creates and initializes an environment handle for OCI functions to work under.">OCIEnvCreate()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="Creates and initializes an environment handle for OCI functions to work under.">OCIEnvNlsCreate()</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="Sets the value of an attribute of a handle or a descriptor.">OCIAttrSet()</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-8218D5F2-139B-4FA9-BA4A-ED0126687C0F" title="Allocates an array of descriptors.">OCIArrayDescriptorAlloc()</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#GUID-36729D3E-E920-4FAA-8EAA-6E033F6D8930" title="Registers a callback for message notification.">OCISubscriptionRegister()</a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="LNOCI16720"></a>
<div class="props_rev_3"><a id="GUID-00B6E34B-201C-4C6E-B188-238FE58836D8"></a>
<h4 id="LNOCI-GUID-00B6E34B-201C-4C6E-B188-238FE58836D8" class="sect4">Setting QOS, Timeout Interval, Namespace, Client Address, and Port Number</h4>
<div>
<p>Shows how to set QOSFLAGS to QOS levels using <code class="codeph">OCIAttrSet()</code>.</p>
<div class="section">
<p>You can set QOSFLAGS to the following QOS levels using <code class="codeph">OCIAttrSet()</code>:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCI_SUBSCR_QOS_RELIABLE</code> - Reliable notification persists across instance and database restarts. Reliability is of the server only and is only for persistent queues or buffered messages. This option describes the persistence of the notifications. Registrations are persistent by default.</p>
</li>
<li>
<p><code class="codeph">OCI_SUBSCR_QOS_PURGE_ON_NTFN</code> - Once notification is received, purge registration on first notification. (Subscription is unregistered.)</p>
</li>
</ul>
<pre dir="ltr">/* Set QOS levels */
ub4 qosflags = OCI_SUBSCR_QOS_RELIABLE | OCI_SUBSCR_QOS_PURGE_ON_NTFN;

/* Set flags in subscription handle */
(void)OCIAttrSet((void *)subscrhp, (ub4)OCI_HTYPE_SUBSCRIPTION,
               (void *)&amp;qosflags, (ub4)0, (ub4)OCI_ATTR_SUBSCR_QOSFLAGS, errhp);

/* Set auto-expiration after 30 seconds */
ub4 timeout = 30;
(void)OCIAttrSet((void *)subscrhp, (ub4)OCI_HTYPE_SUBSCRIPTION,
                 (void *)&amp;timeout, (ub4)0, (ub4)OCI_ATTR_SUBSCR_TIMEOUT, errhp);
</pre>
<p>The registration is purged when the timeout is exceeded, and a notification is sent to the client, so that the client can invoke its callback and take any necessary action. For client failure before the timeout, the registration is purged.</p>
<p>You can set the port number on the environment handle, which is important if the client is on a system behind a firewall that can receive notifications only on certain ports. Clients can specify the port for the listener thread before the first registration, using an attribute in the environment handle. The thread is started the first time OCISubscriptionRegister() is called. If available, this specified port number is used. An error is returned if the client tries to start another thread on a different port using a different environment handle.</p>
<pre dir="ltr">ub4 port = 1581;
(void)OCIAttrSet((void *)envhp, (ub4)OCI_HTYPE_ENV, (void *)&amp;port, (ub4)0,
                 (ub4)OCI_ATTR_SUBSCR_PORTNO, errhp);
</pre>
<p>If instead, the port is determined automatically, you can get the port number at which the client thread is listening for notification by obtaining the attribute from the environment handle.</p>
<pre dir="ltr">(void)OCIAttrGet((void *)subhp, (ub4)OCI_HTYPE_ENV, (void *)&amp;port, (ub4)0, 
                 (ub4)OCI_ATTR_SUBSCR_PORTNO, errhp);
</pre>
<p>Example to set client address:</p>
<pre dir="ltr">text ipaddr[16] = &#34;10.177.246.40&#34;;
(void)(OCIAttrSet((dvoid *) envhp, (ub4) OCI_HTYPE_ENV,
       (dvoid *) ipaddr, (ub4) strlen((const char *)ipaddr),
       (ub4) OCI_ATTR_SUBSCR_IPADDR, errhp));
</pre>
<div class="infoboxnotealso" id="GUID-00B6E34B-201C-4C6E-B188-238FE58836D8__GUID-7E360654-C212-4562-8C40-B35C38BF3EF3">
<p class="notep1">See Also:</p>
<p><a href="ociaahan.htm#GUID-A76BBB38-8F77-40B8-B5A6-1F9C9166C71C__BAJHEBIA">OCI_ATTR_SUBSCR_IPADDR</a></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="LNOCI16722"></a><a id="LNOCI16721"></a>
<div class="props_rev_3"><a id="GUID-362BE190-510B-4187-A93E-C4538E2C8A24"></a>
<h4 id="LNOCI-GUID-362BE190-510B-4187-A93E-C4538E2C8A24" class="sect4">OCI Functions Used to Manage Publish-Subscribe Notification</h4>
<div>
<div class="section">
<p><a href="oci09adv.htm#GUID-362BE190-510B-4187-A93E-C4538E2C8A24__CACBABFH" title="This table is described by two columns. Column 1 is Function and column 2 is Purpose. It lists about five functions and describes the purpose of each one.">Table 9-12</a> lists the functions that are used to manage publish-subscribe notification.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-362BE190-510B-4187-A93E-C4538E2C8A24__CACBABFH">
<p class="titleintable">Table 9-12 Publish-Subscribe Functions</p>
<table class="cellalignment6175" title="Publish-Subscribe Functions " summary="This table is described by two columns. Column 1 is Function and column 2 is Purpose. It lists about five functions and describes the purpose of each one.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6186" id="d107147e18798">Function</th>
<th class="cellalignment6247" id="d107147e18801">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6189" id="d107147e18806" headers="d107147e18798">
<p><a href="oci17msc003.htm#GUID-72C51789-C48C-4F36-800B-EECC1AD98E00" title="Disables a subscription registration that turns off all notifications.">OCISubscriptionDisable()</a></p>
</td>
<td class="cellalignment6248" headers="d107147e18806 d107147e18801">
<p>Disables a subscription</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6189" id="d107147e18818" headers="d107147e18798">
<p><a href="oci17msc003.htm#GUID-5C04A301-8564-46AF-A758-9DE7246F0F53" title="Enables a subscription registration that has been disabled.">OCISubscriptionEnable()</a></p>
</td>
<td class="cellalignment6248" headers="d107147e18818 d107147e18801">
<p>Enables a subscription</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6189" id="d107147e18830" headers="d107147e18798">
<p><a href="oci17msc003.htm#GUID-EFD815F0-D669-4E01-AA54-E1499E302430" title="Posts to a subscription that allows all clients who are registered for the subscription to get notifications.">OCISubscriptionPost()</a></p>
</td>
<td class="cellalignment6248" headers="d107147e18830 d107147e18801">
<p>Posts a subscription</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6189" id="d107147e18842" headers="d107147e18798">
<p><a href="oci17msc003.htm#GUID-36729D3E-E920-4FAA-8EAA-6E033F6D8930" title="Registers a callback for message notification.">OCISubscriptionRegister()</a></p>
</td>
<td class="cellalignment6248" headers="d107147e18842 d107147e18801">
<p>Registers a subscription</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6189" id="d107147e18854" headers="d107147e18798">
<p><a href="oci17msc003.htm#GUID-C55B6743-4BB4-4E18-931C-5FBED94592D0" title="Unregisters a subscription that turns off notifications.">OCISubscriptionUnRegister()</a></p>
</td>
<td class="cellalignment6248" headers="d107147e18854 d107147e18801">
<p>Unregisters a subscription</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
<a id="LNOCI72685"></a><a id="LNOCI16723"></a>
<div class="props_rev_3"><a id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5"></a>
<h3 id="LNOCI-GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5" class="sect3">Notification Callback in OCI</h3>
<div>
<p>The client must register a notification callback that gets invoked when there is some activity on the subscription for which interest has been registered.</p>
<p>In the AQ namespace, for instance, this occurs when a message of interest is enqueued.</p>
<p>This callback is typically set through the <code class="codeph">OCI_ATTR_SUBSCR_CALLBACK</code> attribute of the subscription handle.</p>
<div class="infoboxnotealso" id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__GUID-5BCA9BCF-64F0-4AE6-8EBF-3D3DA42B857C">
<p class="notep1">See Also:</p>
<p><a href="ociaahan.htm#GUID-A76BBB38-8F77-40B8-B5A6-1F9C9166C71C" title="Lists and describes subscription handle attributes.">Subscription Handle Attributes</a></p>
</div>
<p>The callback must return a value of <code class="codeph">OCI_CONTINUE</code> and adhere to the following specification:</p>
<pre dir="ltr">typedef ub4 (*OCISubscriptionNotify) ( void            *pCtx,
                                       OCISubscription *pSubscrHp,
                                       void            *pPayload,
                                       ub4             iPayloadLen,
                                       void            *pDescriptor,
                                       ub4             iMode);
</pre>
<p>The parameters are described as follows:</p>
<dl>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73985"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__GUID-4B25411D-CB92-483B-A091-CF00C4128419"><!-- --></a>pCtx (IN)</dt>
<dd>
<p>A user-defined context specified when the callback was registered.</p>
</dd>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73986"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__GUID-D16EC5EB-632F-4B6C-A416-F100727DB181"><!-- --></a>pSubscrHp (IN)</dt>
<dd>
<p>The subscription handle specified when the callback was registered.</p>
</dd>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73987"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__GUID-D831F250-90FD-4E1B-ADF3-230BEBB29329"><!-- --></a>pPayload (IN)</dt>
<dd>
<p>The payload for this notification. Currently, only ub1 * (a sequence of bytes) for the payload is supported.</p>
</dd>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73988"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__GUID-29FAE291-172D-4417-88BE-AAD36DAECC1E"><!-- --></a>iPayloadLen (IN)</dt>
<dd>
<p>The length of the payload for this notification.</p>
</dd>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73989"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__GUID-37DE5942-26F6-4F15-B388-6EA8DB87907E"><!-- --></a>pDescriptor (IN)</dt>
<dd>
<p>The namespace-specific descriptor. Namespace-specific parameters can be extracted from this descriptor. The structure of this descriptor is opaque to the user and its type is dependent on the namespace.</p>
<p>The attributes of the descriptor are namespace-specific. For Advanced Queuing (AQ), the descriptor is <code class="codeph">OCI_DTYPE_AQNFY</code>. For the AQ namespace, the count of notifications received in the group is provided in the notification descriptor. The attributes of <code class="codeph">pDescriptor</code> are:</p>
</dd>
</dl>
<ul style="list-style-type: disc;">
<li>
<p>Notification flag (regular = 0, timeout = 1, or grouping notification = 2) - <code class="codeph">OCI_ATTR_NFY_FLAGS</code></p>
</li>
<li>
<p>Queue name - <code class="codeph">OCI_ATTR_QUEUE_NAME</code></p>
</li>
<li>
<p>Consumer name - <code class="codeph">OCI_ATTR_CONSUMER_NAME</code></p>
</li>
<li>
<p>Message ID - <code class="codeph">OCI_ATTR_NFY_MSGID</code></p>
</li>
<li>
<p>Message properties - <code class="codeph">OCI_ATTR_MSG_PROP</code></p>
</li>
<li>
<p>Count of notifications received in the group - <code class="codeph">OCI_ATTR_AQ_NTFN_GROUPING_COUNT</code></p>
</li>
<li>
<p>The group, an OCI collection - <code class="codeph">OCI_ATTR_AQ_NTFN_GROUPING_MSGID_ARRAY</code></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__GUID-436A02DC-59DE-4E18-8CA6-C12718417184">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci09adv.htm#GUID-FF4165B2-A44C-4F76-AC26-DA860F340CA8" title="OCI provides an interface to the Streams Advanced Queuing (Streams AQ) feature. Streams AQ provides message queuing as an integrated part of Oracle Database.">OCI and Streams Advanced Queuing</a></p>
</li>
<li>
<p><a href="ociaahan.htm#GUID-8C3206B2-1774-4847-B71F-C48869E0BE86">Notification Descriptor Attributes</a></p>
</li>
</ul>
</div>
<dl>
<dt class="dlterm"><a class="dashingAutolink" name="autolink-73990"></a><a class="dashAnchor" name="//apple_ref/cpp/Command/"></a><a id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__GUID-139550CE-01B1-48C1-939E-6C65BEBE03BF"><!-- --></a>iMode (IN)</dt>
<dd>
<p>Call-specific mode. The only valid value is <code class="codeph">OCI_DEFAULT</code>. This value executes the default call.</p>
</dd>
</dl>
<p><a href="oci09adv.htm#GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__CACGEABA">Example 9-17</a> shows how to use AQ grouping notification attributes in a notification callback.</p>
<div class="example" id="GUID-6A21E98D-4921-4087-A79A-7B7C8C22ABD5__CACGEABA">
<p class="titleinexample">Example 9-17 Using AQ Grouping Notification Attributes in an OCI Notification Callback</p>
<pre dir="ltr">ub4 notifyCB1(void *ctx, OCISubscription *subscrhp, void *pay, ub4 payl,
              void *desc, ub4 mode)
{
 oratext            *subname;
 ub4                 size;
 OCIColl            *msgid_array = (OCIColl *)0;
 ub4                 msgid_cnt = 0;
 OCIRaw             *msgid;
 void              **msgid_ptr;
 sb4                 num_msgid = 0;
 void               *elemind = (void *)0;
 boolean             exist;
 ub2                 flags;
 oratext            *hexit = (oratext *)&#34;0123456789ABCDEF&#34;;
 ub4                 i, j;
 
 /* get subscription name */
 OCIAttrGet(subscrhp, OCI_HTYPE_SUBSCRIPTION, (void *)&amp;subname, &amp;size,
            OCI_ATTR_SUBSCR_NAME,ctxptr-&gt;errhp);
 
 /* print subscripton name */
 printf(&#34;Got notification for %.*s\n&#34;, size, subname);
 fflush((FILE *)stdout);
 
 /* get the #ntfns received in this group */
 OCIAttrGet(desc, OCI_DTYPE_AQNFY, (void *)&amp;msgid_cnt, &amp;size,
            OCI_ATTR_AQ_NTFN_GROUPING_COUNT, ctxptr-&gt;errhp);
 
 /* get the group - collection of msgids */
 OCIAttrGet(desc, OCI_DTYPE_AQNFY, (void *)&amp;msgid_array, &amp;size,
            OCI_ATTR_AQ_NTFN_GROUPING_MSGID_ARRAY, ctxptr-&gt;errhp);
 
 /* get notification flag - regular, timeout, or grouping notification? */
 OCIAttrGet(desc, OCI_DTYPE_AQNFY, (void *)&amp;flags, &amp;size,
            OCI_ATTR_NFY_FLAGS, ctxptr-&gt;errhp);
 
 /* print notification flag */
 printf(&#34;Flag: %d\n&#34;, (int)flags);
 
 /* get group (collection) size */
 if (msgid_array)
   checkerr(ctxptr-&gt;errhp,
        OCICollSize(ctxptr-&gt;envhp, ctxptr-&gt;errhp,
        CONST OCIColl *) msgid_array, &amp;num_msgid),
        &#34;Inside notifyCB1-OCICollSize&#34;);
 else
   num_msgid =0;
 
 /* print group size */
 printf(&#34;Collection size: %d\n&#34;, num_msgid);
 
 /* print all msgids in the group */
 for(i = 0; i &lt; num_msgid; i++)
 {
   ub4  rawSize;                                             /* raw size    */
   ub1 *rawPtr;                                              /* raw pointer */
     /* get msgid from group */
   checkerr(ctxptr-&gt;errhp,
        OCICollGetElem(ctxptr-&gt;envhp, ctxptr-&gt;errhp,
               (OCIColl *) msgid_array, i, &amp;exist,
               (void **)(&amp;msgid_ptr), &amp;elemind),
        &#34;Inside notifyCB1-OCICollGetElem&#34;);
   msgid = *msgid_ptr;
   rawSize = OCIRawSize(ctxptr-&gt;envhp, msgid);
   rawPtr = OCIRawPtr(ctxptr-&gt;envhp, msgid);
 
   /* print msgid size */
   printf(&#34;Msgid size: %d\n&#34;, rawSize);
 
   /* print msgid in hexadecimal format */
   for (j = 0; j &lt; rawSize; j++)
   {                                           /* for each byte in the raw */
     printf(&#34;%c&#34;, hexit[(rawPtr[j] &amp; 0xf0) &gt;&gt; 4]);
     printf(&#34;%c&#34;, hexit[(rawPtr[j] &amp; 0x0f)]);
   }
   printf(&#34;\n&#34;);
 }
 
 /* print #ntfns received in group */
 printf(&#34;Notification Count: %d\n&#34;, msgid_cnt);
 printf(&#34;\n&#34;);
 printf(&#34;***********************************************************\n&#34;);
 fflush((FILE *)stdout);
 return 1;
}
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI16725"></a>
<div class="props_rev_3"><a id="GUID-078F3FD1-7CAA-45FC-A93F-1CE942D27CA0"></a>
<h3 id="LNOCI-GUID-078F3FD1-7CAA-45FC-A93F-1CE942D27CA0" class="sect3">Notification Procedure</h3>
<div>
<p>The PL/SQL notification procedure that is invoked when there is some activity on the subscription for which interest has been registered, must be created in the database.</p>
<p>This procedure is typically set through the <code class="codeph">OCI_ATTR_SUBSCR_RECPT</code> attribute of the subscription handle.</p>
<div class="infoboxnotealso" id="GUID-078F3FD1-7CAA-45FC-A93F-1CE942D27CA0__GUID-C77CDBAB-58A4-45B3-9737-9890BD2222D8">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="ociaahan.htm#GUID-A76BBB38-8F77-40B8-B5A6-1F9C9166C71C" title="Lists and describes subscription handle attributes.">Subscription Handle Attributes</a></p>
</li>
<li>
<p>&#34;Oracle Streams AQ PL/SQL Callback&#34; in <a class="olink ARPLS401" target="_blank" href="../ARPLS/d_aq.htm#ARPLS401"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for the PL/SQL procedure specification</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI72686"></a><a id="LNOCI72687"></a><a id="LNOCI16726"></a>
<div class="props_rev_3"><a id="GUID-909E21A8-A247-4E54-9069-79B3EF219D2F"></a>
<h3 id="LNOCI-GUID-909E21A8-A247-4E54-9069-79B3EF219D2F" class="sect3">Publish-Subscribe Direct Registration Example</h3>
<div>
<div class="section">
<p><a href="oci09adv.htm#GUID-909E21A8-A247-4E54-9069-79B3EF219D2F__CACHDEAE">Example 9-18</a> shows how system events, client notification, and Advanced Queuing work together to implement publish subscription notification.</p>
<p>The PL/SQL code in <a href="oci09adv.htm#GUID-909E21A8-A247-4E54-9069-79B3EF219D2F__CACHDEAE">Example 9-18</a> creates all objects necessary to support a publish-subscribe mechanism under the user schema <code class="codeph">pubsub</code>. In this code, the Agent <code class="codeph">snoop</code> subscribes to messages that are published at logon events. Note that the user <code class="codeph">pubsub</code> needs <code class="codeph">AQ_ADMINISTRATOR_ROLE</code> and <code class="codeph">AQ_USER_ROLE</code> privileges to use Advance Queuing functionality. The initialization parameter <code class="codeph">_SYSTEM_TRIG_ENABLED</code> must be set to <code class="codeph">TRUE</code> (the default) to enable triggers for system events. Connect as <code class="codeph">pubsub</code> before running <a href="oci09adv.htm#GUID-909E21A8-A247-4E54-9069-79B3EF219D2F__CACHDEAE">Example 9-18</a>.</p>
<p>After the subscriptions are created, the client must register for notification using callback functions. <a href="oci09adv.htm#GUID-909E21A8-A247-4E54-9069-79B3EF219D2F__CACBBGGJ">Example 9-19</a> shows sample code that performs the necessary steps for registration. The initial steps of allocating and initializing session handles are omitted here for clarity.</p>
<p>If user <code class="codeph">IX</code> logs on to the database, the client is notified by email, and the callback function <code class="codeph">notifySnoop</code> is called. An email notification is sent to the address xyz@company.com and the PL/SQL procedure <code class="codeph">plsqlnotifySnoop</code> is also called in the database.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-909E21A8-A247-4E54-9069-79B3EF219D2F__CACHDEAE">
<p class="titleinexample">Example 9-18 Implementing a Publish Subscription Notification</p>
<pre dir="ltr">----------------------------------------------------------
----create queue table for persistent multiple consumers
----------------------------------------------------------
---- Create or replace a queue table
begin
  DBMS_AQADM.CREATE_QUEUE_TABLE(
  QUEUE_TABLE=&gt;&#39;pubsub.raw_msg_table&#39;, 
  MULTIPLE_CONSUMERS =&gt; TRUE,
  QUEUE_PAYLOAD_TYPE =&gt;&#39;RAW&#39;,
  COMPATIBLE =&gt; &#39;8.1.5&#39;);
end;
/
----------------------------------------------------------
---- Create a persistent queue for publishing messages
----------------------------------------------------------
---- Create a queue for logon events
begin
  DBMS_AQADM.CREATE_QUEUE(QUEUE_NAME=&gt;&#39;pubsub.logon&#39;,
  QUEUE_TABLE=&gt;&#39;pubsub.raw_msg_table&#39;,
  COMMENT=&gt;&#39;Q for error triggers&#39;);
end;
/
----------------------------------------------------------
---- Start the queue
----------------------------------------------------------
begin
  DBMS_AQADM.START_QUEUE(&#39;pubsub.logon&#39;);
end;
/
----------------------------------------------------------
---- define new_enqueue for convenience
----------------------------------------------------------
create or replace procedure new_enqueue(queue_name  in varchar2,
                                        payload  in raw ,
correlation in varchar2 := NULL,
exception_queue in varchar2 := NULL)
as
  enq_ct     dbms_aq.enqueue_options_t;
  msg_prop   dbms_aq.message_properties_t;
  enq_msgid  raw(16);
  userdata   raw(1000);
begin
  msg_prop.exception_queue := exception_queue;
  msg_prop.correlation := correlation;
  userdata := payload;
  DBMS_AQ.ENQUEUE(queue_name,enq_ct, msg_prop,userdata,enq_msgid);
end;
/
----------------------------------------------------------
---- add subscriber with rule based on current user name, 
---- using correlation_id
----------------------------------------------------------
declare
subscriber sys.aq$_agent;
begin
  subscriber := sys.aq$_agent(&#39;SNOOP&#39;, null, null);
  dbms_aqadm.add_subscriber(queue_name =&gt; &#39;pubsub.logon&#39;,
                            subscriber =&gt; subscriber,
                            rule =&gt; &#39;CORRID = &#39;&#39;ix&#39;&#39; &#39;);
end;
/
----------------------------------------------------------
---- create a trigger on logon on database
----------------------------------------------------------
---- create trigger on after logon
create or replace trigger systrig2
   AFTER LOGON
   ON DATABASE
   begin
     new_enqueue(&#39;pubsub.logon&#39;, hextoraw(&#39;9999&#39;), dbms_standard.login_user);
   end;
/

----------------------------------------------------------
---- create a PL/SQL callback for notification of logon 
---- of user &#39;ix&#39; on database
----------------------------------------------------------
---- 
create or replace procedure plsqlnotifySnoop(
  context raw, reginfo sys.aq$_reg_info, descr sys.aq$_descriptor,
  payload raw, payloadl number)
as
begin
 dbms_output.put_line(&#39;Notification : User ix Logged on\n&#39;);
end;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-909E21A8-A247-4E54-9069-79B3EF219D2F__CACBBGGJ">
<p class="titleinexample">Example 9-19 Registering for Notification Using Callback Functions</p>
<pre dir="ltr">...
static ub4 namespace = OCI_SUBSCR_NAMESPACE_AQ;

static OCISubscription *subscrhpSnoop = (OCISubscription *)0;
static OCISubscription *subscrhpSnoopMail = (OCISubscription *)0;
static OCISubscription *subscrhpSnoopServer = (OCISubscription *)0;

/* callback function for notification of logon of user &#39;ix&#39; on database */

static ub4 notifySnoop(ctx, subscrhp, pay, payl, desc, mode)
    void *ctx;
    OCISubscription *subscrhp;
    void *pay;
    ub4 payl;
    void *desc;
    ub4 mode;
{
    printf(&#34;Notification : User ix Logged on\n&#34;);
  (void)OCIHandleFree((void *)subscrhpSnoop,
            (ub4) OCI_HTYPE_SUBSCRIPTION);
    return 1;
}

static void checkerr(errhp, status)
OCIError *errhp;
sword status;
{
  text errbuf[512];
  ub4 buflen;
  sb4 errcode;

  if (status == OCI_SUCCESS) return;

  switch (status)
  {
  case OCI_SUCCESS_WITH_INFO:
    printf(&#34;Error - OCI_SUCCESS_WITH_INFO\n&#34;);
    break;
  case OCI_NEED_DATA:
    printf(&#34;Error - OCI_NEED_DATA\n&#34;);
    break;
  case OCI_NO_DATA:
    printf(&#34;Error - OCI_NO_DATA\n&#34;);
    break;
  case OCI_ERROR:
    OCIErrorGet ((void *) errhp, (ub4) 1, (text *) NULL, &amp;errcode,
            errbuf, (ub4) sizeof(errbuf), (ub4) OCI_HTYPE_ERROR);
    printf(&#34;Error - %s\n&#34;, errbuf);
    break;
  case OCI_INVALID_HANDLE:
    printf(&#34;Error - OCI_INVALID_HANDLE\n&#34;);
    break;
  case OCI_STILL_EXECUTING:
    printf(&#34;Error - OCI_STILL_EXECUTING\n&#34;);
    break;
  case OCI_CONTINUE:
    printf(&#34;Error - OCI_CONTINUE\n&#34;);
    break;
  default:
    printf(&#34;Error - %d\n&#34;, status);
    break;
  }
}

static void initSubscriptionHn (subscrhp,
                         subscriptionName,
                         func,
                         recpproto,
                         recpaddr,
                         recppres)
OCISubscription **subscrhp;
  char * subscriptionName;
  void * func;
  ub4 recpproto;
  char * recpaddr;
  ub4 recppres;
{
    /* allocate subscription handle */
    (void) OCIHandleAlloc((void *) envhp, (void **)subscrhp,
        (ub4) OCI_HTYPE_SUBSCRIPTION,
        (size_t) 0, (void **) 0);

    /* set subscription name in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) subscriptionName,
        (ub4) strlen((char *)subscriptionName),
        (ub4) OCI_ATTR_SUBSCR_NAME, errhp);

    /* set callback function in handle */
    if (func)
      (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
          (void *) func, (ub4) 0,
          (ub4) OCI_ATTR_SUBSCR_CALLBACK, errhp);

    /* set context in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) 0, (ub4) 0,
       (ub4) OCI_ATTR_SUBSCR_CTX, errhp);

    /* set namespace in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) &amp;namespace, (ub4) 0,
        (ub4) OCI_ATTR_SUBSCR_NAMESPACE, errhp);

    /* set receive with protocol in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) &amp;recpproto, (ub4) 0,
        (ub4) OCI_ATTR_SUBSCR_RECPTPROTO, errhp);

    /* set recipient address in handle */
    if (recpaddr)
      (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
          (void *) recpaddr, (ub4) strlen(recpaddr),
          (ub4) OCI_ATTR_SUBSCR_RECPT, errhp);

    /* set receive with presentation in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) &amp;recppres, (ub4) 0,
        (ub4) OCI_ATTR_SUBSCR_RECPTPRES, errhp);

    printf(&#34;Begining Registration for subscription %s\n&#34;, subscriptionName);
    checkerr(errhp, OCISubscriptionRegister(svchp, subscrhp, 1, errhp,
        OCI_DEFAULT));
   printf(&#34;done\n&#34;);

}


int main( argc, argv)
int    argc;
char * argv[];
{
    OCISession *authp = (OCISession *) 0;

/*****************************************************
Initialize OCI Process/Environment
Initialize Server Contexts
Connect to Server
Set Service Context
******************************************************/

/* Registration Code Begins */
/* Each call to initSubscriptionHn allocates
   and initializes a Registration Handle */

/* Register for OCI notification */
    initSubscriptionHn(    &amp;subscrhpSnoop,    /* subscription handle*/
    (char*) &#34;PUBSUB.LOGON:SNOOP&#34;, /* subscription name */
                                  /*&lt;queue_name&gt;:&lt;agent_name&gt; */
        (void*)notifySnoop,  /* callback function */
        OCI_SUBSCR_PROTO_OCI, /* receive with protocol */
        (char *)0, /* recipient address */
        OCI_SUBSCR_PRES_DEFAULT); /* receive with presentation */

/* Register for email notification */
    initSubscriptionHn(    &amp;subscrhpSnoopMail,  /* subscription handle */
     (char*) &#34;PUBSUB.LOGON:SNOOP&#34;,              /* subscription name */ 
                                                /* &lt;queue_name&gt;:&lt;agent_name&gt; */
        (void*)0, /* callback function */
        OCI_SUBSCR_PROTO_MAIL, /* receive with protocol */
        (char*)  &#34;xyz@company.com&#34;, /* recipient address */
        OCI_SUBSCR_PRES_DEFAULT); /* receive with presentation */

/* Register for server to server notification */
    initSubscriptionHn(    &amp;subscrhpSnoopServer, /* subscription handle */
       (char*)  &#34;PUBSUB.LOGON:SNOOP&#34;,            /* subscription name */
                                                 /* &lt;queue_name&gt;:&lt;agent_name&gt; */
        (void*)0, /* callback function */
        OCI_SUBSCR_PROTO_SERVER, /* receive with protocol */
         (char*) &#34;pubsub.plsqlnotifySnoop&#34;, /* recipient address */
        OCI_SUBSCR_PRES_DEFAULT); /* receive with presentation */

    checkerr(errhp, OCITransCommit(svchp, errhp, (ub4) OCI_DEFAULT));

/*****************************************************
The Client Process does not need a live Session for Callbacks.
End Session and Detach from Server.
******************************************************/

    OCISessionEnd ( svchp,  errhp, authp, (ub4) OCI_DEFAULT);

    /* detach from server */
    OCIServerDetach( srvhp, errhp, OCI_DEFAULT);

   while (1)    /* wait for callback */
    sleep(1);
}
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI72688"></a><a id="LNOCI16727"></a>
<div class="props_rev_3"><a id="GUID-9F4EEC78-5CAC-4E86-9F82-1FF9586289CF"></a>
<h3 id="LNOCI-GUID-9F4EEC78-5CAC-4E86-9F82-1FF9586289CF" class="sect3">Publish-Subscribe LDAP Registration Example</h3>
<div>
<div class="section">
<p><a href="oci09adv.htm#GUID-9F4EEC78-5CAC-4E86-9F82-1FF9586289CF__CACBFFEB">Example 9-20</a> shows a code fragment that illustrates how to do LDAP registration. Please read all the program comments.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-9F4EEC78-5CAC-4E86-9F82-1FF9586289CF__CACBFFEB">
<p class="titleinexample">Example 9-20 LDAP Registration</p>
<pre dir="ltr">...

  /* To use the LDAP registration feature, OCI_EVENTS | OCI_EVENTS |OCI_USE_LDAP*/
  /*   must be set in OCIEnvCreate or OCIEnvNlsCreate */
  /*     (Note: OCIInitialize is deprecated): */
  (void) OCIInitialize((ub4) OCI_EVENTS|OCI_OBJECT|OCI_USE_LDAP, (void *)0,
                       (void * (*)(void *, size_t)) 0,
                       (void * (*)(void *, void *, size_t))0,
                       (void (*)(void *, void *)) 0 );

...

  /* set LDAP attributes in the environment handle */

  /* LDAP host name */
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)&#34;yow&#34;, 3,
                    OCI_ATTR_LDAP_HOST, (OCIError *)errhp);

  /* LDAP server port */ 
  ldap_port = 389;
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;ldap_port,
                    (ub4)0, OCI_ATTR_LDAP_PORT, (OCIError *)errhp);

  /* bind DN of the client, normally the enterprise user name */
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)&#34;cn=orcladmin&#34;,
                    12, OCI_ATTR_BIND_DN, (OCIError *)errhp);

  /* password of the client */
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)&#34;welcome&#34;,
                    7, OCI_ATTR_LDAP_CRED, (OCIError *)errhp);

  /* authentication method is &#34;simple&#34;, username/password authentication */
  ldap_auth = 0x01;
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;ldap_auth,
                    (ub4)0, OCI_ATTR_LDAP_AUTH, (OCIError *)errhp);

  /* administrative context: this is the DN above cn=oraclecontext */
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)&#34;cn=acme,cn=com&#34;,
                    14, OCI_ATTR_LDAP_CTX, (OCIError *)errhp);

...

  /* retrieve the LDAP attributes from the environment handle */

  /* LDAP host */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;buf, 
                    &amp;szp,  OCI_ATTR_LDAP_HOST,  (OCIError *)errhp);

  /* LDAP server port */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;intval, 
                    0,  OCI_ATTR_LDAP_PORT,  (OCIError *)errhp);

  /* client binding DN */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;buf, 
                    &amp;szp,  OCI_ATTR_BIND_DN,  (OCIError *)errhp);

  /* client password */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;buf, 
                    &amp;szp,  OCI_ATTR_LDAP_CRED,  (OCIError *)errhp);

  /* administrative context */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;buf, 
                    &amp;szp,  OCI_ATTR_LDAP_CTX,  (OCIError *)errhp);

  /* client authentication method */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;intval, 
                    0,  OCI_ATTR_LDAP_AUTH,  (OCIError *)errhp);
  
  ...

  /* to set up the server DN descriptor in the subscription handle */

  /* allocate a server DN descriptor, dn is of type &#34;OCIServerDNs **&#34;, 
     subhp is of type &#34;OCISubscription **&#34; */
  (void) OCIDescriptorAlloc((void *)envhp, (void **)dn, 
                         (ub4) OCI_DTYPE_SRVDN, (size_t)0, (void **)0);

  /* now *dn is the server DN descriptor, add the DN of the first database 
     that you want to register */
  (void) OCIAttrSet((void *)*dn, (ub4) OCI_DTYPE_SRVDN, 
                    (void *)&#34;cn=server1,cn=oraclecontext,cn=acme,cn=com&#34;,
                    42, (ub4)OCI_ATTR_SERVER_DN, errhp);
  /* add the DN of another database in the descriptor */
  (void) OCIAttrSet((void *)*dn, (ub4) OCI_DTYPE_SRVDN, 
                    (void *)&#34;cn=server2,cn=oraclecontext,cn=acme,cn=com&#34;,
                    42, (ub4)OCI_ATTR_SERVER_DN, errhp);

  /* set the server DN descriptor into the subscription handle */
  (void) OCIAttrSet((void *) *subhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (void *) *dn, (ub4)0, (ub4) OCI_ATTR_SERVER_DNS, errhp);

  ...

  /* now you will try to get the server DN information from the subscription
     handle */
 
  /* first, get the server DN descriptor out */
  (void) OCIAttrGet((void *) *subhp, (ub4) OCI_HTYPE_SUBSCRIPTION, 
                    (void *)dn, &amp;szp, OCI_ATTR_SERVER_DNS, errhp);

  /* then, get the number of server DNs in the descriptor */
  (void) OCIAttrGet((void *) *dn, (ub4)OCI_DTYPE_SRVDN, (void *)&amp;intval,
                    &amp;szp, (ub4)OCI_ATTR_DN_COUNT, errhp);

  /* allocate an array of char * to hold server DN pointers returned by
     an Oracle database*/
    if (intval)
    {
      arr = (char **)malloc(intval*sizeof(char *));
      (void) OCIAttrGet((void *)*dn, (ub4)OCI_DTYPE_SRVDN, (void *)arr,
                        &amp;intval, (ub4)OCI_ATTR_SERVER_DN, errhp);
    }

  /* OCISubscriptionRegister() calls have two modes: OCI_DEFAULT and 
     OCI_REG_LDAPONLY. If OCI_DEFAULT is used, there should be only one
     server DN in the server DN descriptor. The registration request will
     be sent to the database. If a database connection is not available,
     the registration request will be detoured to the LDAP server. However,
     if mode OCI_REG_LDAPONLY is used, the registration request
     will be directly sent to LDAP. This mode should be used when there is 
     more than one server DN in the server DN descriptor or you are sure
     that a database connection is not available.

     In this example, two DNs are entered, so you should use mode 
     OCI_REG_LDAPONLY in LDAP registration. */
  OCISubscriptionRegister(svchp, subhp, 1, errhp, OCI_REG_LDAPONLY);

  ...

  /* as OCISubscriptionRegister(), OCISubscriptionUnregister() also has
     mode OCI_DEFAULT and OCI_REG_LDAPONLY. The usage is the same. */

  OCISubscriptionUnRegister(svchp, *subhp, errhp, OCI_REG_LDAPONLY);
}
...
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment6150">
<tr>
<td class="cellalignment6162">
<table class="cellalignment6155">
<tr>
<td class="cellalignment6154"><a href="oci08sca.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment6154"><a href="oci10new.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment6164">
<table class="cellalignment6153">
<tr>
<td class="cellalignment6154"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment6154"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment6154"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment6154"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment6154"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment6154"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>