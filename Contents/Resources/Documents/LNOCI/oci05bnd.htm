<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-73976"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Binding%20and%20Defining%20in%20OCI"></a><title>Binding and Defining in OCI</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="This chapter describes binding and defining in OCI."/>
<meta name="keywords" content="bind operations, SQL statements, binding placeholders in, associations made, initializing variables, named versus positional, positional versus named, OCI array interface, PL/SQL, initialize, all buffers, steps used, example, using in OCI programs, binding, summary, LOBs, LOB and LONG bind restrictions, OCI_DATA_AT_EXEC mode, REF CURSOR variables, REFs, CURSOR variables, binding, define operations, SQL query, defining output variables, defining, PL/SQL output variables, piecewise fetch, arrays of structures, structures, arrays of, skip parameters, for arrays of structures, OCI calls used, indicator variables, OCIIOV struct, multiple buffers, OCI_IOV, RETURNING clause, using with OCI, binding with, error handling, with REFs, OCI_ATTR_ROWS_RETURNED, use with callbacks, NCHAR, issues, character set ID, character set form, OCI_ATTR_CHARSET_FORM, SQLCS_IMPLICIT, utext, Unicode data type, OCI_ATTR_MAXDATA_SIZE, attribute, OCI_ATTR_MAXCHAR_SIZE, use with binding, buffer expansion, buffer expansion during binding, UTF-16 data, sample code, wchar_t data type, binding and defining, binding and defining REF CURSORS, binding and defining nested tables, piecewise operations, insert, update, fetch, piecewise, updates, inserts, valid data types, data types, for piecewise operations, in PL/SQL, binds and defines for LOBs"/>
<meta name="dcterms.created" content="2017-06-09T09:07:30Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Call Interface Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E49886-11"/>
<meta name="dcterms.isVersionOf" content="LNOCI"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="oci04sql.htm" title="Previous" type="text/html"/>
<link rel="Next" href="oci06des.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49886-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-4C2BD7BB-5768-4E8A-82BF-84FB0030A8C5"></a> <span id="PAGE" style="display:none;">12/84</span> <!-- End Header -->
<a id="LNOCI050"></a>
<h1 id="LNOCI-GUID-4C2BD7BB-5768-4E8A-82BF-84FB0030A8C5" class="sect1"><span class="enumeration_chapter">5</span> Binding and Defining in OCI</h1>
<div>
<p>This chapter describes binding and defining in OCI.</p>
<p>This chapter contains these topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482" title="This chapter expands on the basic concepts of binding and defining, and provides more detailed information about the different types of binds and defines you can use in OCI applications.">Overview of Binding in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E" title="More advanced bind operations include multistep binds, and binds of named data types and REFs.">Advanced Bind Operations in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-8A09BC68-4C3D-4977-86C9-134F73121E26" title="Query statements return data from the database to your application.">Overview of Defining in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E" title="This section covers advanced define operations, including multistep defines and defines of named data types and REFs.">Advanced Define Operations in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A" title="Defining arrays of structures requires an initial call to OCIDefineByPos() or OCIDefineByPos2().">About Binding and Defining Arrays of Structures in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589">About Binding and Defining Multiple Buffers</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-C0D4318B-0768-4386-AA15-C88AE3A33C76" title="This section outlines the rules for correctly implementing DML statements with the RETURNING clause.">DML with a RETURNING Clause in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-84576558-1974-4E61-B6E6-795FA67419E3" title="This section discusses issues involving character conversions between the client and the server.">Character Conversion in OCI Binding and Defining</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-5495CEEB-17D0-4185-8879-3356A21E7888">PL/SQL REF CURSORs and Nested Tables in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-9DEC9ACB-BC16-4F4C-8EC6-E43EC47EF9CB">Natively Describe and Bind All PL/SQL Types Including Package Types</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="You can use OCI to perform piecewise inserts, updates, and fetches of data.">Runtime Data Allocation and Piecewise Operations in OCI</a></p>
</li>
</ul>
</div>
<a id="LNOCI16360"></a><a id="LNOCI16359"></a>
<div class="props_rev_3"><a id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482"></a>
<h2 id="LNOCI-GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482" class="sect2">Overview of Binding in OCI</h2>
<div>
<p>This chapter expands on the basic concepts of binding and defining, and provides more detailed information about the different types of binds and defines you can use in OCI applications.</p>
<p>Additionally, this chapter discusses the use of arrays of structures, and other issues involved in binding, defining, and character conversions.</p>
<p>For example, given the <code class="codeph">INSERT</code> statement:</p>
<pre dir="ltr">INSERT INTO emp VALUES
    (:empno, :ename, :job, :sal, :deptno)
</pre>
<p>Then given the following variable declarations:</p>
<pre dir="ltr">text     *ename, *job;
sword    empno, sal, deptno;
</pre>
<p>the bind step makes an association between the placeholder name and the address of the program variables. The bind also indicates the data type and length of the program variables, as illustrated in <a href="oci05bnd.htm#GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__I423597">Figure 5-1</a>.</p>
<div class="figure" id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__I423597">
<p class="titleinfigure">Figure 5-1 Using OCIBindByName() to Associate Placeholders with Program Variables</p>
<img width="652" height="206" src="img/GUID-86139D87-5517-4622-A3D1-CC518F7F32CB-default.gif" alt="Description of Figure 5-1 follows" title="Description of Figure 5-1 follows"/><br/>
<a href="img_text/GUID-86139D87-5517-4622-A3D1-CC518F7F32CB-print.htm">Description of &#34;Figure 5-1 Using OCIBindByName() to Associate Placeholders with Program Variables&#34;</a></div>
<!-- class="figure" -->
<p>If you change only the value of a bind variable, it is not necessary to rebind it to execute the statement again. Because the bind is by reference, as long as the address of the variable and handle remain valid, you can reexecute a statement that references the variable without rebinding.</p>
<div class="infobox-note" id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__GUID-D4FD9BAA-0D7B-4218-A41B-5E14B54C8380">
<p class="notep1">Note:</p>
<p>At the interface level, all bind variables are considered at least <code class="codeph">IN</code> and must be properly initialized. If the variable is a pure <code class="codeph">OUT</code> bind variable, you can set the variable to 0. You can also provide a <code class="codeph">NULL</code> indicator and set that indicator to -1 (<code class="codeph">NULL</code>).</p>
</div>
<p>In the Oracle database, data types have been implemented for named data types, <code class="codeph">REF</code>s and LOBs, and they can be bound as placeholders in a SQL statement.</p>
<div class="infobox-note" id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__GUID-61FD84CE-5EE2-4311-B2A7-EC63B7E6EF11">
<p class="notep1">Note:</p>
<p>For opaque data types (descriptors or locators) whose sizes are not known, pass the address of the descriptor or locator pointer. Set the size parameter to the size of the appropriate data structure, (<code class="codeph">sizeof(structure)</code>).</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-BC53FC10-66C7-4803-A90D-57647B0A0C91" title="In a named bind, each placeholder in the statement has a name associated with it, while in a positional bind, the placeholders are referred to by their position in the statement rather than by their names.">Named Binds and Positional Binds</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6">OCI Array Interface</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D" title="You process a PL/SQL block by placing the block in a string variable, binding any variables, and then executing the statement containing the block, just as you would with a single SQL statement.">About Binding Placeholders in PL/SQL</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A" title="Placeholders are bound in several steps.">Steps Used in OCI Binding</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E" title="Perhaps the most common use for PL/SQL blocks in OCI is to call stored procedures or stored functions.">PL/SQL Block in an OCI Program</a></p>
</li>
</ul>
</div>
</div>
<div class="infoboxnotealso" id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__GUID-1B6CFB3A-75CC-49A7-AE3B-B8A73BFE5889">
<p class="notep1">See Also:</p>
<p><a href="oci05bnd.htm#GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A" title="Placeholders are bound in several steps.">Steps Used in OCI Binding</a> for the code that implements this example</p>
</div>
</div>
<a id="LNOCI16361"></a>
<div class="props_rev_3"><a id="GUID-BC53FC10-66C7-4803-A90D-57647B0A0C91"></a>
<h3 id="LNOCI-GUID-BC53FC10-66C7-4803-A90D-57647B0A0C91" class="sect3">Named Binds and Positional Binds</h3>
<div>
<p>In a named bind, each placeholder in the statement has a name associated with it, while in a positional bind, the placeholders are referred to by their position in the statement rather than by their names.</p>
<p>The SQL statement in <a href="oci05bnd.htm#GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__I423597">Figure 5-1</a> is an example of a <span class="italic">named bind</span>. Each placeholder in the statement has a name associated with it, such as &#39;ename&#39; or &#39;sal&#39;. When this statement is prepared and the placeholders are associated with values in the application, the association is made by the name of the placeholder using the <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> call with the name of the placeholder passed in the <span class="italic">placeholder</span> parameter.</p>
<p>A second type of bind is known as a <span class="italic">positional bind</span>. In a positional bind, the placeholders are referred to by their position in the statement rather than by their names. For binding purposes, an association is made between an input value and the position of the placeholder, using the <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> call.</p>
<p>To use the previous example for a positional bind:</p>
<pre dir="ltr">INSERT INTO emp VALUES
    (:empno, :ename, :job, :sal, :deptno)
</pre>
<p>The five placeholders are then each bound by calling <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> and passing the position number of the placeholder in the <code class="codeph">position</code> parameter. For example, the <code class="codeph">:empno</code> placeholder would be bound by calling <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> with a position of 1, <code class="codeph">:ename</code> with a position of 2, and so on.</p>
<p>In a duplicate bind, only a single bind call may be necessary. Consider the following SQL statement, which queries the database for employees whose commission and salary are both greater than a given amount:</p>
<pre dir="ltr">SELECT empno FROM emp
    WHERE sal &gt; :some_value
    AND comm &gt; :some_value
</pre>
<p>An OCI application could complete the binds for this statement with a single call to <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> to bind the <code class="codeph">:some_value</code> placeholder by name. In this case, all bind placeholders for <code class="codeph">:some_value</code> get assigned the same value as provided by the <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> call.</p>
<p>Now consider the case where a 6th placeholder is added that is a duplicate. For example, add <code class="codeph">:ename</code> as the 6th placeholder in the first previous example:</p>
<pre dir="ltr">INSERT INTO emp VALUES
    (:empno, :ename, :job, :sal, :deptno, :ename)
</pre>
<p>If you are using the <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> call, just one bind call suffices to bind both occurrences of the <code class="codeph">:ename</code> placeholder. All occurrences of <code class="codeph">:ename</code> in the statement will get bound to the same value. Moreover, if new bind placeholders get added as a result of which bind positions for existing bind placeholders change, you do not need to change your existing bind calls in order to update bind positions. This is a distinct advantage in using the <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> call if your program evolves to add more bind variables in your statement text.</p>
<p>If you are using the <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> call, however, you have increased flexibility in terms of binding duplicate bind-parameters separately, if you need it. You have the option of binding any of the duplicate occurrences of a bind parameter separately. Any unbound duplicate occurrences of a parameter inherit the value from the first occurrence of the bind parameter with the same name. The first occurrence must be explicitly bound.</p>
<p>In the context of SQL statements, the position <span class="italic">n</span> indicates the bind parameter at the <span class="italic">n</span>th position. However, in the context of PL/SQL statements, <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> has a different interpretation for the position parameter: the position <span class="italic">n</span> in the bind call indicates a binding for the <span class="italic">n</span>th unique parameter name in the statement when scanned left to right.</p>
<p>Using the previous example again and the same SQL statement text, if you want to bind the 6th position separately, the <code class="codeph">:ename</code> placeholder would be bound by calling <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> with a position of 6. Otherwise, if left unbound, <code class="codeph">:ename</code> would inherit the value from the first occurrence of the bind parameter with the same name, in this case, from <code class="codeph">:ename</code> in position 2.</p>
<div class="infoboxnotealso" id="GUID-BC53FC10-66C7-4803-A90D-57647B0A0C91__GUID-2DF93E86-63B4-4CA8-AFB3-ABBFF78E7C6E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16362"></a>
<div class="props_rev_3"><a id="GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6"></a>
<h3 id="LNOCI-GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6" class="sect3">OCI Array Interface</h3>
<div>
<p>You can pass data to the Oracle database in various ways.</p>
<p>You can execute a SQL statement repeatedly using the <a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a> routine and supply different input values on each iteration.</p>
<p>You can use the Oracle array interface and input many values with a single statement and a single call to <a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a>. In this case, you bind an array to an input placeholder, and the entire array can be passed at the same time, under the control of the <span class="italic">iters</span> parameter.</p>
<p>The array interface significantly reduces round-trips to the database when you are updating or inserting a large volume of data. This reduction can lead to considerable performance gains in a busy client/server environment. For example, consider an application that inserts 10 rows into the database. Calling <a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a> 10 times with single values results in 10 network round-trips to insert all the data. The same result is possible with a single call to <a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a> using an input array, which involves only one network round-trip.</p>
<div class="infobox-note" id="GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6__GUID-F0528582-3A5B-43A0-846C-3A529DD3330A">
<p class="notep1">Note:</p>
<p>When you use the OCI array interface to perform inserts, row triggers in the database are fired as each row is inserted.</p>
<p><a id="d67612e1040" class="indexterm-anchor"></a>The maximum number of rows allowed in an array DML statement is 4 billion -1 (3,999,999,999).</p>
</div>
</div>
</div>
<a id="LNOCI16363"></a>
<div class="props_rev_3"><a id="GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D"></a>
<h3 id="LNOCI-GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D" class="sect3">About Binding Placeholders in PL/SQL</h3>
<div>
<p>You process a PL/SQL block by placing the block in a string variable, binding any variables, and then executing the statement containing the block, just as you would with a single SQL statement.</p>
<p>When you bind placeholders in a PL/SQL block to program variables, you must use <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> to perform the basic binds for host variables that are either scalars or arrays.</p>
<p>The following short PL/SQL block contains two placeholders, which represent <code class="codeph">IN</code> parameters to a procedure that updates an employee&#39;s salary, when given the employee number and the new salary amount:</p>
<pre dir="ltr">char plsql_statement[] = &#34;BEGIN\
                          RAISE_SALARY(:emp_number, :new_sal);\
                          END;&#34; ;
</pre>
<p>These placeholders can be bound to input variables in the same way as placeholders in a SQL statement.</p>
<p>When processing PL/SQL statements, output variables are also associated with program variables by using bind calls.</p>
<p>For example, consider the following PL/SQL block:</p>
<pre dir="ltr">BEGIN
    SELECT ename,sal,comm INTO :emp_name, :salary, :commission
    FROM emp
    WHERE empno = :emp_number;
END;
</pre>
<p>In this block, you would use <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> to bind variables in place of the <code class="codeph">:emp_name</code>, <code class="codeph">:salary</code>, and <code class="codeph">:commission</code> output placeholders, and in place of the input placeholder <code class="codeph">:emp_number</code>.</p>
<div class="infobox-note" id="GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D__GUID-33C1B6F2-2ACB-4479-89DA-49F752074914">
<p class="notep1">Note:</p>
<p>All buffers, even pure <code class="codeph">OUT</code> buffers, must be initialized by setting the buffer length to zero in the bind call, or by setting the corresponding indicator to -1.</p>
</div>
<div class="infoboxnotealso" id="GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D__GUID-636BA551-12C6-47F4-ADA3-A612FFE1D90A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
<li>
<p><a href="oci12oty.htm#GUID-BB043B77-4B3C-4A1C-A4E4-9F225E0DF1BB">Information for Named Data Type and REF Binds</a> for more information about binding PL/SQL placeholders</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI72603"></a><a id="LNOCI16364"></a>
<div class="props_rev_3"><a id="GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A"></a>
<h3 id="LNOCI-GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A" class="sect3">Steps Used in OCI Binding</h3>
<div>
<p>Placeholders are bound in several steps.</p>
<p>For a simple scalar or array bind, it is only necessary to specify an association between the placeholder and the data, by using <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code>.</p>
<p>Once the bind is complete, the OCI library detects where to find the input data or where to put the PL/SQL output data when the SQL statement is executed. Program input data does not need to be in the program variable when it is bound to the placeholder, but the data must be there when the statement is executed.</p>
<p>The following code example in <a href="oci05bnd.htm#GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A__CIHEIIBF">Example 5-1</a> shows handle allocation and binding for each placeholder in a SQL statement.</p>
<div class="infobox-note" id="GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A__GUID-312921F2-6FBA-4303-AC81-03076F5CA262">
<p class="notep1">Note:</p>
<p>The <code class="codeph">checkerr()</code> function evaluates the return code from an OCI application. The code for the function is in the Example for <code class="codeph">OCIErrorGet()</code>.</p>
</div>
<div class="example" id="GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A__CIHEIIBF">
<p class="titleinexample">Example 5-1 Handle Allocation and Binding for Each Placeholder in a SQL Statement</p>
<pre dir="ltr">...
/* The SQL statement, associated with stmthp (the statement handle)
by calling OCIStmtPrepare2() */
text *insert = (text *) &#34;INSERT INTO emp(empno, ename, job, sal, deptno)\
    VALUES (:empno, :ename, :job, :sal, :deptno)&#34;;
...

/*  Bind the placeholders in the SQL statement, one per bind handle. */
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd1p, errhp, (text *) &#34;:ENAME&#34;,
    strlen(&#34;:ENAME&#34;), (ub1 *) ename, enamelen+1, SQLT_STR, (void *) 0,
    (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd2p, errhp, (text *) &#34;:JOB&#34;,
    strlen(&#34;:JOB&#34;), (ub1 *) job, joblen+1, SQLT_STR, (void *)
    &amp;job_ind, (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd3p, errhp, (text *) &#34;:SAL&#34;,
    strlen(&#34;:SAL&#34;), (ub1 *) &amp;sal, (sword) sizeof(sal), SQLT_INT,
    (void *) &amp;sal_ind, (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0,
    OCI_DEFAULT));
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd4p, errhp, (text *) &#34;:DEPTNO&#34;,
    strlen(&#34;:DEPTNO&#34;), (ub1 *) &amp;deptno,(sword) sizeof(deptno), SQLT_INT,
    (void *) 0, (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd5p, errhp, (text *) &#34;:EMPNO&#34;,
    strlen(&#34;:EMPNO&#34;), (ub1 *) &amp;empno, (sword) sizeof(empno), SQLT_INT,
    (void *) 0, (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0,OCI_DEFAULT));
</pre>
<div class="infoboxnotealso" id="GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A__GUID-AE744F7A-D67C-4F93-8C46-19866CF28855">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
<li>
<p><a href="oci17msc007.htm#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="Returns an error message and an Oracle Database error code.">OCIErrorGet()</a></p>
</li>
</ul>
</div>
</div>
<!-- class="example" --></div>
</div>
<a id="LNOCI72604"></a><a id="LNOCI16365"></a>
<div class="props_rev_3"><a id="GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E"></a>
<h3 id="LNOCI-GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E" class="sect3">PL/SQL Block in an OCI Program</h3>
<div>
<p>Perhaps the most common use for PL/SQL blocks in OCI is to call stored procedures or stored functions.</p>
<p>Assume that there is a procedure named <code class="codeph">RAISE_SALARY</code> stored in the database, and you embed a call to that procedure in an anonymous PL/SQL block, and then process the PL/SQL block.</p>
<p>The following program fragment shows how to embed a stored procedure call in an OCI application. The program passes an employee number and a salary increase as inputs to a stored procedure called <code class="codeph">raise_salary</code>:</p>
<pre dir="ltr">raise_salary (employee_num IN, sal_increase IN, new_salary OUT);
</pre>
<p>This procedure raises a given employee&#39;s salary by a given amount. The increased salary that results is returned in the stored procedure&#39;s variable, <code class="codeph">new_salary</code>, and the program displays this value.</p>
<p>Note that the PL/SQL procedure argument, <code class="codeph">new_salary</code>, although a PL/SQL OUT variable, must be bound, not defined.</p>
<p><a href="oci05bnd.htm#GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E__CIHEBECF">Example 5-2</a> demonstrates how to perform a simple scalar bind where only a single bind call is necessary. In some cases, additional bind calls are needed to define attributes for specific bind data types or execution modes.</p>
<div class="example" id="GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E__CIHEBECF">
<p class="titleinexample">Example 5-2 Defining a PL/SQL Statement to Be Used in OCI</p>
<pre dir="ltr">/* Define PL/SQL statement to be used in program. */
text *give_raise = (text *) &#34;BEGIN\
                  RAISE_SALARY(:emp_number,:sal_increase, :new_salary);\
                     END;&#34;;
OCIBind  *bnd1p = NULL;                      /* the first bind handle */
OCIBind  *bnd2p = NULL;                     /* the second bind handle */
OCIBind  *bnd3p = NULL;                      /* the third bind handle */

static void checkerr();
sb4 status;

main()
{
  sword    empno, raise, new_sal;
  OCISession *usrhp = (OCISession *)NULL; 
...
/* attach to Oracle database, and perform necessary initializations
and authorizations */
...
      /* prepare the statement request, passing the PL/SQL text
        block as the statement to be prepared */
checkerr(errhp, OCIStmtPrepare2(svchp, &amp;stmthp, errhp, (text *) give_raise, (ub4) 
      strlen(give_raise), NULL, 0, OCI_NTV_SYNTAX, OCI_DEFAULT));

      /* bind each of the placeholders to a program variable */
checkerr( errhp, OCIBindByName(stmthp, &amp;bnd1p, errhp, (text *) &#34;:emp_number&#34;,
             -1, (ub1 *) &amp;empno,
            (sword) sizeof(empno), SQLT_INT, (void *) 0,
             (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));

checkerr( errhp, OCIBindByName(stmthp, &amp;bnd2p, errhp, (text *) &#34;:sal_increase&#34;,
             -1, (ub1 *) &amp;raise,
             (sword) sizeof(raise), SQLT_INT, (void *) 0,
             (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));

      /* remember that PL/SQL OUT variables are bound, not defined */

checkerr( errhp, OCIBindByName(stmthp, &amp;bnd3p, errhp, (text *) &#34;:new_salary&#34;,
             -1, (ub1 *) &amp;new_sal,
             (sword) sizeof(new_sal), SQLT_INT, (void *) 0,
             (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));

      /* prompt the user for input values */
printf(&#34;Enter the employee number: &#34;);
scanf(&#34;%d&#34;, &amp;empno); 
      /* flush the input buffer */
myfflush();

printf(&#34;Enter employee&#39;s raise: &#34;);
scanf(&#34;%d&#34;, &amp;raise);
      /* flush the input buffer */
myfflush();

  /* execute PL/SQL block*/
  checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0, 
      (OCISnapshot *) NULL, (OCISnapshot *) NULL, OCI_DEFAULT));

  /* display the new salary, following the raise */
printf(&#34;The new salary is %d\n&#34;, new_sal);

OCIStmtRelease(stmthp, errhp, NULL, 0, OCI_DEFAULT);
}
</pre>
<div class="infoboxnotealso" id="GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E__GUID-8584E6E0-C323-45FF-A623-8470BD9E8FB7">
<p class="notep1">See Also:</p>
Why a PL/SQL OUT variable must be bound and not defined is explained in <a href="oci05bnd.htm#GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79" title="Do not use the define calls to define output variables for select-list items in a SQL SELECT statement inside a PL/SQL block.">About Defining PL/SQL Output Variables</a> and in <a href="oci12oty.htm#GUID-1E2056EF-32BE-4875-9211-C2D4BB535D11" title="Consider the following important information as you work with named data type and REF defines. It includes pointers about memory allocation and indicator variable usage.">Information for Named Data Type and REF Defines, and PL/SQL OUT Binds</a>.</div>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNOCI16367"></a><a id="LNOCI16366"></a>
<div class="props_rev_3"><a id="GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E"></a>
<h2 id="LNOCI-GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E" class="sect2">Advanced Bind Operations in OCI</h2>
<div>
<p>More advanced bind operations include multistep binds, and binds of named data types and <code class="codeph">REFs</code>.</p>
<p><a href="oci04sql.htm#GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70" title="Most DML statements, and some queries (such as those with a WHERE clause), require a program to pass data to Oracle Database as part of a SQL or PL/SQL statement.">About Binding Placeholders in OCI</a> discussed how a basic bind operation is performed to create an association between a placeholder in a SQL statement and a program variable by using <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code>. This section covers more advanced bind operations, including multistep binds, and binds of named data types and <code class="codeph">REFs</code>.</p>
<p>In some cases, additional bind calls are necessary to define specific attributes for certain bind data types or certain execution modes.</p>
<p>The following sections describe these special cases, and the information about binding is summarized in <a href="oci05bnd.htm#GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E__CIHJBEEH" title="This table has 3 columns. Column 1 is the type of bind, column 2 is the bind data type, and column 3 is notes.">Table 5-1</a>.</p>
<div class="tblformalwide" id="GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E__CIHJBEEH">
<p class="titleintable">Table 5-1 Information Summary for Bind Types</p>
<table class="cellalignment6157" title="Information Summary for Bind Types" summary="This table has 3 columns. Column 1 is the type of bind, column 2 is the bind data type, and column 3 is notes.">
<thead>
<tr class="cellalignment6151">
<th class="cellalignment6168" id="d67612e1951">Type of Bind</th>
<th class="cellalignment6226" id="d67612e1954">Bind Data Type</th>
<th class="cellalignment6247" id="d67612e1957">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6151">
<td class="cellalignment6172" id="d67612e1962" headers="d67612e1951">
<p>Scalar</p>
</td>
<td class="cellalignment6227" headers="d67612e1962 d67612e1954">
<p>Any scalar data type</p>
</td>
<td class="cellalignment6248" headers="d67612e1962 d67612e1957">
<p>Bind a single scalar using <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code>.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6172" id="d67612e1984" headers="d67612e1951">
<p>Array of scalars</p>
</td>
<td class="cellalignment6227" headers="d67612e1984 d67612e1954">
<p>Any scalar data type</p>
</td>
<td class="cellalignment6248" headers="d67612e1984 d67612e1957">
<p>Bind an array of scalars using <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code>.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6172" id="d67612e2006" headers="d67612e1951">
<p>Named data type</p>
</td>
<td class="cellalignment6227" headers="d67612e2006 d67612e1954">
<p><code class="codeph">SQLT_NTY</code></p>
</td>
<td class="cellalignment6248" headers="d67612e2006 d67612e1957">
<p>Includes records and collections</p>
<p>Two bind calls are required:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code></p>
</li>
<li>
<p><code class="codeph">OCIBindObject()</code></p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6172" id="d67612e2037" headers="d67612e1951">
<p>Boolean</p>
</td>
<td class="cellalignment6227" headers="d67612e2037 d67612e1954">
<p><code class="codeph">SQLT_BOL</code></p>
</td>
<td class="cellalignment6248" headers="d67612e2037 d67612e1957">
<p>Bind a Boolean using <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code>.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6172" id="d67612e2060" headers="d67612e1951">
<p><code class="codeph">REF</code></p>
</td>
<td class="cellalignment6227" headers="d67612e2060 d67612e1954">
<p><code class="codeph">SQLT_REF</code></p>
</td>
<td class="cellalignment6248" headers="d67612e2060 d67612e1957">
<p>Two bind calls are required:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code></p>
</li>
<li>
<p><code class="codeph">OCIBindObject()</code></p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6172" id="d67612e2090" headers="d67612e1951">
<p>LOB</p>
<p><code class="codeph">BFILE</code></p>
</td>
<td class="cellalignment6227" headers="d67612e2090 d67612e1954">
<p><code class="codeph">SQLT_BLOB</code></p>
<p><code class="codeph">SQLT_CLOB</code></p>
</td>
<td class="cellalignment6248" headers="d67612e2090 d67612e1957">
<p>Allocate the LOB locator using <code class="codeph">OCIDescriptorAlloc()</code>, and then bind its address, <code class="codeph">OCILobLocator</code> <code class="codeph">**</code>, with <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code>, by using one of the LOB data types.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6172" id="d67612e2129" headers="d67612e1951">
<p>Array of structures or static arrays</p>
</td>
<td class="cellalignment6227" headers="d67612e2129 d67612e1954">
<p>Varies</p>
</td>
<td class="cellalignment6248" headers="d67612e2129 d67612e1957">
<p>Two bind calls are required:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code></p>
</li>
<li>
<p><code class="codeph">OCIBindArrayOfStruct()</code></p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6172" id="d67612e2157" headers="d67612e1951">
<p>Piecewise insert</p>
</td>
<td class="cellalignment6227" headers="d67612e2157 d67612e1954">
<p>Varies</p>
</td>
<td class="cellalignment6248" headers="d67612e2157 d67612e1957">
<p><code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> is required. The application may also need to call <code class="codeph">OCIBindDynamic()</code> to register piecewise callbacks.</p>
</td>
</tr>
<tr class="cellalignment6151">
<td class="cellalignment6172" id="d67612e2181" headers="d67612e1951">
<p><code class="codeph">REF CURSOR</code> variables</p>
</td>
<td class="cellalignment6227" headers="d67612e2181 d67612e1954">
<p><code class="codeph">SQLT_RSET</code></p>
</td>
<td class="cellalignment6248" headers="d67612e2181 d67612e1957">
<p>Allocate a statement handle, <code class="codeph">OCIStmt</code>, and then bind its address, <code class="codeph">OCIStmt **</code>, using the <code class="codeph">SQLT_RSET</code> data type.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-B8FD8CD2-95C1-4EA5-A896-7AA3642D01BE" title="There are two ways of binding LOBs:">About Binding LOBs</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-D9A7AC35-9CE8-4B1F-9F4C-B9BE064EAD69" title="If the mode parameter in a call to OCIBindByName() or OCIBindByName2() or OCIBindByPos() or OCIBindByPos2() is set to OCI_DATA_AT_EXEC, an additional call to OCIBindDynamic() is necessary if the application uses the callback method for providing data at run time.">About Binding in OCI_DATA_AT_EXEC Mode</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-983E7E07-7941-4A8E-A046-2F5A6A50C0E1" title="REF CURSORs are bound to a statement handle with a bind data type of SQLT_RSET.">About Binding REF CURSOR Variables</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E__GUID-B6FCD5C3-AC75-4639-8077-79D66298D5EA">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci12oty.htm#GUID-25B2139A-8F55-4256-88EB-D8F5F706904C" title="For a named data type (object type or collection) bind, a second bind call is necessary following OCIBindByName() or OCIBindByName2() or OCIBindByPos() or OCIBindByPos2().">Named Data Type Binds</a> for information about binding named data types (objects)</p>
</li>
<li>
<p><a href="oci12oty.htm#GUID-5A08B855-FB63-4457-866F-DAB035059E49" title="As with named data types, binding REFs is a two-step process.">About Binding REFs</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF">OCIBindObject()</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F">OCIDescriptorAlloc()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="Sets up the skip parameters for a static array bind.">OCIBindArrayOfStruct()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16368"></a>
<div class="props_rev_3"><a id="GUID-B8FD8CD2-95C1-4EA5-A896-7AA3642D01BE"></a>
<h3 id="LNOCI-GUID-B8FD8CD2-95C1-4EA5-A896-7AA3642D01BE" class="sect3">About Binding LOBs</h3>
<div>
<p>There are two ways of binding LOBs:</p>
<ul style="list-style-type: disc;">
<li>
<p>Bind the LOB locator, rather than the actual LOB values. In this case the LOB value is written or read by passing a LOB locator to the OCI LOB functions.</p>
</li>
<li>
<p>Bind the LOB value directly, without using the LOB locator.</p>
</li>
</ul>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-B57CC385-F279-45BA-8CF4-FBF42565C640" title="Either a single locator or an array of locators can be bound in a single bind call.">Binding LOB Locators</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" title="Oracle Database allows nonzero binds for INSERTs and UPDATEs of any size LOB.">About Binding LOB Data</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI72605"></a><a id="LNOCI72606"></a><a id="LNOCI16369"></a>
<div class="props_rev_3"><a id="GUID-B57CC385-F279-45BA-8CF4-FBF42565C640"></a>
<h4 id="LNOCI-GUID-B57CC385-F279-45BA-8CF4-FBF42565C640" class="sect4">Binding LOB Locators</h4>
<div>
<p>Either a single locator or an array of locators can be bound in a single bind call.</p>
<p>In each case, the application must pass the <span class="italic">address of a LOB locator</span> and not the locator itself. For example, suppose that an application has prepared this SQL statement where <code class="codeph">one_lob</code> is a bind variable corresponding to a LOB column:</p>
<pre dir="ltr">INSERT INTO some_table VALUES (:one_lob)
</pre>
<p>Then your application makes the following declaration:</p>
<pre dir="ltr">OCILobLocator * one_lob;
</pre>
<p>Then the calls in <a href="oci05bnd.htm#GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__CIHEEHEF">Example 5-3</a> would be used to bind the placeholder and execute the statement:</p>
<p>You can also insert an array using the same SQL <code class="codeph">INSERT</code> statement. In this case, the application would include the code shown in <a href="oci05bnd.htm#GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__CIHDCCJD">Example 5-4</a>.</p>
<p>You must allocate descriptors with the <code class="codeph">OCIDescriptorAlloc()</code> function before they can be used. In an array of locators, you must initialize each array element using <code class="codeph">OCIDescriptorAlloc()</code>. Use <code class="codeph">OCI_DTYPE_LOB</code> as the <code class="codeph">type</code> parameter when allocating <code class="codeph">BLOB</code>s, <code class="codeph">CLOB</code>s, and <code class="codeph">NCLOB</code>s. Use <code class="codeph">OCI_DTYPE_FILE</code> when allocating <code class="codeph">BFILE</code>s.</p>
<div class="example" id="GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__CIHEEHEF">
<p class="titleinexample">Example 5-3 Binding the Placeholder and Executing the Statement to Insert a Single Locator</p>
<pre dir="ltr">/* initialize single locator */
one_lob = OCIDescriptorAlloc(...OCI_DTYPE_LOB...);
...
/* pass the address of the locator */
OCIBindByName(...,(void *) &amp;one_lob,... SQLT_CLOB, ...);
OCIStmtExecute(...,1,...)                /* 1 is the iters parameter */
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__CIHDCCJD">
<p class="titleinexample">Example 5-4 Binding the Placeholder and Executing the Statement to Insert an Array of Locators</p>
<pre dir="ltr">OCILobLocator * lob_array[10];
...
for (i=0; i&lt;10, i++)
    lob_array[i] = OCIDescriptorAlloc(...OCI_DTYPE_LOB...);
                                     /* initialize array of locators */
...
OCIBindByName(...,(void *) lob_array,...);
OCIStmtExecute(...,10,...);               /* 10 is the iters parameter */
</pre></div>
<!-- class="example" -->
<div class="section">
<p>This section includes the following topic: <a href="oci05bnd.htm#GUID-B00D7494-01AE-40AD-A6D6-4434EF7710CE" title="What are the restrictions on binding LOB locators.">Restrictions on Binding LOB Locators</a></p>
<div class="infoboxnotealso" id="GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__GUID-51B36583-4A3D-4DBE-81E4-B2A9ACC77F86">
<p class="notep1">See Also:</p>
<a href="oci16rel002.htm#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F">OCIDescriptorAlloc()</a></div>
</div>
<!-- class="section" --></div>
<a id="LNOCI16370"></a>
<div class="props_rev_3"><a id="GUID-B00D7494-01AE-40AD-A6D6-4434EF7710CE"></a>
<h5 id="LNOCI-GUID-B00D7494-01AE-40AD-A6D6-4434EF7710CE" class="sect5">Restrictions on Binding LOB Locators</h5>
<div>
<p>What are the restrictions on binding LOB locators.</p>
<p>Observe the following restrictions when you bind LOB locators:</p>
<ul style="list-style-type: disc;">
<li>
<p>Piecewise and callback <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> operations are not supported.</p>
</li>
<li>
<p>When using a FILE locator as a bind variable for an <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> statement, you must first initialize the locator with a directory object and file name, by using <code class="codeph">OCILobFileSetName()</code> before issuing the <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> statement.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-B00D7494-01AE-40AD-A6D6-4434EF7710CE__GUID-94F3E17F-2294-4254-BDFA-CC844EE57C74">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci07lob.htm#GUID-0A094518-F97C-40BE-A336-259AA82BD0A2" title="This chapter describes LOB and BFILE operations.">LOB and BFILE Operations</a> for more information about the OCI LOB functions</p>
</li>
<li>
<p><a href="oci17msc002.htm#GUID-507AC0EF-4CAB-437E-BB94-1FD77EDC1B5C" title="Sets the directory object and file name in the BFILE locator.">OCILobFileSetName()</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="LNOCI16371"></a>
<div class="props_rev_3"><a id="GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4"></a>
<h4 id="LNOCI-GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" class="sect4">About Binding LOB Data</h4>
<div>
<p>Oracle Database allows nonzero binds for <code class="codeph">INSERT</code>s and <code class="codeph">UPDATE</code>s of any size LOB.</p>
<p>So you can bind data into a LOB column using <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code>, <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code>, and PL/SQL binds.</p>
<p>The bind of more than 4 kilobytes of data to a LOB column uses space from the temporary tablespace. Ensure that your temporary tablespace is big enough to hold at least the amount of data equal to the sum of all the bind lengths for LOBs. If your temporary tablespace is extendable, it is extended automatically after the existing space is fully consumed. Use the following command to create an extendable temporary tablespace:</p>
<pre dir="ltr">CREATE TABLESPACE ... AUTOEXTEND ON ... TEMPORARY ...;
</pre>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-96BB84DD-34D1-4280-A6C8-6B1A9E475A26" title="What are the restrictions on binding LOB data.">Restrictions on Binding LOB Data</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E">Examples of Binding LOB Data</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4__GUID-9AD823D9-8B7D-4A28-93EC-69830C8AF118">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16372"></a>
<div class="props_rev_3"><a id="GUID-96BB84DD-34D1-4280-A6C8-6B1A9E475A26"></a>
<h5 id="LNOCI-GUID-96BB84DD-34D1-4280-A6C8-6B1A9E475A26" class="sect5">Restrictions on Binding LOB Data</h5>
<div>
<p>What are the restrictions on binding LOB data.</p>
<p>Observe the following restrictions when you bind LOB data:</p>
<ul style="list-style-type: disc;">
<li>
<p>If a table has both <code class="codeph">LONG</code> and LOB columns, then you can have binds of greater than 4 kilobytes for either the <code class="codeph">LONG</code> column or the LOB columns, but not both in the same statement.</p>
</li>
<li>
<p>In an <code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code> operation, Oracle Database does not allow binding of any length data to LOB columns.</p>
</li>
<li>
<p>A special consideration applies on the maximum size of bind variables that are neither LONG or LOB, but that appear after any LOB or LONG bind variable in the SQL statement. You receive an <code class="codeph">ORA-24816</code> error from Oracle Database if the maximum size for such bind variables exceeds 4000 bytes. To avoid this error, you must set <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> to 4000 bytes for any such binds whose maximum size may exceed 4000 bytes on the server side after character set conversion. Alternatively, reorder the binds so that such binds are placed before any LONG or LOBs in the bind list.</p>
</li>
<li>
<p>Oracle Database does not do implicit conversions, such as <code class="codeph">HEX</code> to <code class="codeph">RAW</code> or <code class="codeph">RAW</code> to <code class="codeph">HEX</code>, for data of size more than 4000 bytes. The PL/SQL code in the following code example illustrates this:</p>
<p>Demonstrating Some Implicit Conversions That Cannot Be Done</p>
<pre dir="ltr">create table t (c1 clob, c2 blob);
declare
  text   varchar(32767);
  binbuf raw(32767);
begin
  text := lpad (&#39;a&#39;, 12000, &#39;a&#39;);
  binbuf := utl_raw.cast_to_raw(text);

  -- The following works:
  insert into t values (text, binbuf);

  -- The following does not work because Oracle dpes not do implicit 
  -- hex to raw conversion.
  insert into t (c2) values (text);  

  -- The following does not work because Oracle does not do implicit 
  -- raw to hex conversion.
  insert into t (c1) values (binbuf);  

  -- The following does not work because you cannot combine the
  -- utl_raw.cast_to_raw() operator with the &gt;4k bind.
  insert into t (c2) values (utl_raw.cast_to_raw(text));

end;
/
</pre></li>
<li>
<p>If you bind more than 4000 bytes of data to a <code class="codeph">BLOB</code> or a <code class="codeph">CLOB</code>, and the data is filtered by a SQL operator, then Oracle Database limits the size of the result to at most 4000 bytes.</p>
<p>For example:</p>
<pre dir="ltr">create table t (c1 clob, c2 blob);
-- The following command inserts only 4000 bytes because the result of
-- LPAD is limited to 4000 bytes
insert into t(c1) values (lpad(&#39;a&#39;, 5000, &#39;a&#39;)); 

-- The following command inserts only 2000 bytes because the result of
-- LPAD is limited to 4000 bytes, and the implicit hex to raw conversion
-- converts it to 2000 bytes of RAW data.
insert into t(c2) values (lpad(&#39;a&#39;, 5000, &#39;a&#39;)); 
</pre></li>
</ul>
<div class="infoboxnotealso" id="GUID-96BB84DD-34D1-4280-A6C8-6B1A9E475A26__GUID-F183A3E6-11AA-4967-925B-E13702C191AF">
<p class="notep1">See Also:</p>
<p><a href="oci05bnd.htm#GUID-AD86F080-F3A4-4D85-A20E-B81A4EF11B40">About Using the OCI_ATTR_MAXDATA_SIZE Attribute</a></p>
</div>
</div>
</div>
<a id="LNOCI72608"></a><a id="LNOCI72609"></a><a id="LNOCI72610"></a><a id="LNOCI72611"></a><a id="LNOCI72612"></a><a id="LNOCI72613"></a><a id="LNOCI72614"></a><a id="LNOCI72615"></a><a id="LNOCI16373"></a>
<div class="props_rev_3"><a id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E"></a>
<h5 id="LNOCI-GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E" class="sect5">Examples of Binding LOB Data</h5>
<div>
<p>The following SQL statements are used in <a href="oci05bnd.htm#GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__CIHBCIAD">Example 5-5</a> through <a href="oci05bnd.htm#GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__CIHGHACA">Example 5-12</a>:</p>
<pre dir="ltr">CREATE TABLE foo (a INTEGER );
CREATE TYPE lob_typ AS OBJECT (A1 CLOB );
CREATE TABLE lob_long_tab (C1 CLOB, C2 CLOB, CT3 lob_typ, L LONG);
</pre>
<div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__CIHBCIAD">
<p class="titleinexample">Example 5-5 Allowed: Inserting into C1, C2, and L Columns Up to 8000, 8000, and 2000 Byte-Sized Bind Variable Data Values, Respectively</p>
<pre dir="ltr">void insert()                 /* A function in an OCI program */
{
   /* The following is allowed */
   ub1 buffer[8000];
   text *insert_sql = (text *) &#34;INSERT INTO lob_long_tab (C1, C2, L) \
                       VALUES (:1, :2, :3)&#34;;
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[2], errhp, 3, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-6EF37483-CC42-49AF-8056-AE7A63520B03">
<p class="titleinexample">Example 5-6 Allowed: Inserting into C1 and L Columns up to 2000 and 8000 Byte-Sized Bind Variable Data Values, Respectively</p>
<pre dir="ltr">void insert()
{
   /* The following is allowed */
   ub1 buffer[8000];
   text *insert_sql = (text *) &#34;INSERT INTO lob_long_tab (C1, L) \
                      VALUES (:1, :2)&#34;;
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-9AF198E8-37AE-420B-89CF-24548C09DA2F">
<p class="titleinexample">Example 5-7 Allowed: Updating C1, C2, and L Columns up to 8000, 8000, and 2000 Byte-Sized Bind Variable Data Values, Respectively</p>
<pre dir="ltr">void update()
{
   /* The following is allowed, no matter how many rows it updates */
   ub1 buffer[8000];
   text *update_sql = (text *)&#34;UPDATE lob_long_tab SET \
                              C1 = :1, C2=:2, L=:3&#34;;
   OCIStmtPrepare(stmthp, errhp, update_sql, strlen((char*)update_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[2], errhp, 3, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-CEB318B5-9F81-4351-AF6E-5D14CABFC1F0">
<p class="titleinexample">Example 5-8 Allowed: Updating C1, C2, and L Columns up to 2000, 2000, and 8000 Byte-Sized Bind Variable Data Values, Respectively</p>
<pre dir="ltr">void update()
{
   /* The following is allowed, no matter how many rows it updates */
   ub1 buffer[8000];
   text *update_sql = (text *)&#34;UPDATE lob_long_tab SET \
                               C1 = :1, C2=:2, L=:3&#34;;
   OCIStmtPrepare(stmthp, errhp, update_sql, strlen((char*)update_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[2], errhp, 3, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                               (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-853ABC7F-C033-49B2-B488-615E66FB8C25">
<p class="titleinexample">Example 5-9 Allowed: Piecewise, Callback, and Array Insert or Update Operations</p>
<pre dir="ltr">void insert()
{
   /* Piecewise, callback and array insert/update operations similar to 
    * the allowed regular insert/update operations are also allowed */
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-DF8C7133-20E7-44C6-8F4A-F2DD81291B45">
<p class="titleinexample">Example 5-10 Not Allowed: Inserting More Than 4000 Bytes into Both LOB and LONG Columns Using the Same INSERT Statement</p>
<pre dir="ltr">void insert()
{
   /* The following is NOT allowed because you cannot insert &gt;4000 bytes
    * into both LOB and LONG columns */
   ub1 buffer[8000];
   text *insert_sql = (text *)&#34;INSERT INTO lob_long_tab (C1, L) \
                               VALUES (:1, :2)&#34;;
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-FC7D7664-AB43-485E-A2C4-A3E1A7CFA69F">
<p class="titleinexample">Example 5-11 Allowed: Inserting into the CT3 LOB Column up to 2000 Byte-Sized Bind Variable Data Values</p>
<pre dir="ltr">void insert()
{
   /* Insert of data into LOB attributes is allowed */
   ub1 buffer[8000];
   text *insert_sql = (text *)&#34;INSERT INTO lob_long_tab (CT3) \
                               VALUES (lob_typ(:1))&#34;;
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__CIHGHACA">
<p class="titleinexample">Example 5-12 Not Allowed: Binding Any Length Data to a LOB Column in an Insert As Select Operation</p>
<pre dir="ltr">void insert()
{
   /* The following is NOT allowed because you cannot do insert as
    * select character data into LOB column */
   ub1 buffer[8000];
   text *insert_sql = (text *)&#34;INSERT INTO lob_long_tab (C1) SELECT \
                               :1 from FOO&#34;;
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="LNOCI16382"></a>
<div class="props_rev_3"><a id="GUID-D9A7AC35-9CE8-4B1F-9F4C-B9BE064EAD69"></a>
<h3 id="LNOCI-GUID-D9A7AC35-9CE8-4B1F-9F4C-B9BE064EAD69" class="sect3">About Binding in OCI_DATA_AT_EXEC Mode</h3>
<div>
<p>If the <code class="codeph">mode</code> parameter in a call to <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> is set to <code class="codeph">OCI_DATA_AT_EXEC</code>, an additional call to <code class="codeph">OCIBindDynamic()</code> is necessary if the application uses the callback method for providing data at run time.</p>
<p>The call to <code class="codeph">OCIBindDynamic()</code> sets up the callback routines, if necessary, for indicating the data or piece provided. If the <code class="codeph">OCI_DATA_AT_EXEC</code> mode is chosen, but the standard OCI piecewise polling method is used instead of callbacks, the call to <code class="codeph">OCIBindDynamic()</code> is not necessary.</p>
<p>When binding <code class="codeph">RETURN</code> clause variables, an application must use <code class="codeph">OCI_DATA_AT_EXEC</code> mode, and it must provide callbacks.</p>
<div class="infoboxnotealso" id="GUID-D9A7AC35-9CE8-4B1F-9F4C-B9BE064EAD69__GUID-0D780161-95A2-4D1B-AF70-B7347919CA42">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="You can use OCI to perform piecewise inserts, updates, and fetches of data.">Runtime Data Allocation and Piecewise Operations in OCI</a> for more information about piecewise operations</p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16383"></a>
<div class="props_rev_3"><a id="GUID-983E7E07-7941-4A8E-A046-2F5A6A50C0E1"></a>
<h3 id="LNOCI-GUID-983E7E07-7941-4A8E-A046-2F5A6A50C0E1" class="sect3">About Binding REF CURSOR Variables</h3>
<div>
<p><code class="codeph">REF CURSOR</code>s are bound to a statement handle with a bind data type of <code class="codeph">SQLT_RSET</code>.</p>
<div class="infoboxnotealso" id="GUID-983E7E07-7941-4A8E-A046-2F5A6A50C0E1__GUID-158A0315-671A-4DE3-A059-B58EB9B7E346">
<p class="notep1">See Also:</p>
<p><a href="oci05bnd.htm#GUID-5495CEEB-17D0-4185-8879-3356A21E7888">PL/SQL REF CURSORs and Nested Tables in OCI</a></p>
</div>
</div>
</div>
</div>
<a id="LNOCI16384"></a>
<div class="props_rev_3"><a id="GUID-8A09BC68-4C3D-4977-86C9-134F73121E26"></a>
<h2 id="LNOCI-GUID-8A09BC68-4C3D-4977-86C9-134F73121E26" class="sect2">Overview of Defining in OCI</h2>
<div>
<p>Query statements return data from the database to your application.</p>
<p>When processing a query, you must define an output variable or an array of output variables for each item in the select list for retrieving data. The define step creates an association that determines where returned results are stored, and in what format.</p>
<p>For example, if your program processes the following statement then you would normally define two output variables: one to receive the value returned from the <code class="codeph">name</code> column, and one to receive the value returned from the <code class="codeph">ssn</code> column:</p>
<pre dir="ltr">SELECT name, ssn FROM employees
    WHERE empno = :empnum
</pre>
<p>If you were only interested in retrieving values from the <code class="codeph">name</code> column, you would not need to define an output variable for <code class="codeph">ssn</code>. If the <code class="codeph">SELECT</code> statement being processed returns more than a single row for a query, the output variables that you define can be arrays instead of scalar values.</p>
<p>Depending on the application, the define step can occur before or after an execute operation. If you know the data types of select-list items at compile time, the define can occur before the statement is executed. If your application is processing dynamic SQL statements entered by you at run time or statements that do not have a clearly defined select list, the application must execute the statement to retrieve describe information. After the describe information is retrieved, the type information for each select-list item is available for use in defining output variables.</p>
<p>OCI processes the define call locally on the client side. In addition to indicating the location of buffers where results should be stored, the define step determines what data conversions must occur when data is returned to the application.</p>
<div class="infobox-note" id="GUID-8A09BC68-4C3D-4977-86C9-134F73121E26__GUID-80848218-4F4E-4596-89A3-BBCD2B91F002">
<p class="notep1">Note:</p>
<p>Output buffers must be 2-byte aligned.</p>
</div>
<p>The <code class="codeph">dty</code> parameter of the <code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code> call specifies the data type of the output variable. OCI can perform a wide range of data conversions when data is fetched into the output variable. For example, internal data in Oracle <code class="codeph">DATE</code> format can be automatically converted to a <code class="codeph">String</code> data type on output.</p>
<p>This section includes the following topic: <a href="oci05bnd.htm#GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4" title="A basic define is done with a position call, OCIDefineByPos() or OCIDefineByPos2().">Steps Used in OCI Defining</a></p>
<div class="infoboxnotealso" id="GUID-8A09BC68-4C3D-4977-86C9-134F73121E26__GUID-2E5C9E8C-C37B-4FBF-9519-2A33A5805DD5">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci03typ.htm#GUID-027FB2E2-593C-43F1-9184-DFEF7A984A27" title="This chapter provides a reference to Oracle external data types used by OCI applications.">Data Types</a> for more information about data types and conversions</p>
</li>
<li>
<p><a href="oci04sql.htm#GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" title="If your OCI application is processing a query, you may need to obtain more information about the items in the select list.">About Describing Select-List Items</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> or <a href="oci16rel003.htm#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="Associates an item in a select list with the type and output data buffer. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIDefineByPos2()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI72616"></a><a id="LNOCI16385"></a>
<div class="props_rev_3"><a id="GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4"></a>
<h3 id="LNOCI-GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4" class="sect3">Steps Used in OCI Defining</h3>
<div>
<p>A basic define is done with a position call, <code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code>.</p>
<p>This step creates an association between a select-list item and an output variable. Additional define calls may be necessary for certain data types or fetch modes. Once the define step is complete, the OCI library determines where to put retrieved data. You can make your define calls again to redefine the output variables without having to reprepare or reexecute the SQL statement.</p>
<p><a href="oci05bnd.htm#GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4__CIHBDHGI">Example 5-13</a> shows a scalar output variable being defined following an execute and describe operation.</p>
<div class="infoboxnotealso" id="GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4__GUID-ECFDC102-889C-4296-9099-03DDE69292CF">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci04sql.htm#GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" title="If your OCI application is processing a query, you may need to obtain more information about the items in the select list.">About Describing Select-List Items</a> for an explanation of the describe step</p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> or <a href="oci16rel003.htm#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="Associates an item in a select list with the type and output data buffer. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIDefineByPos2()</a></p>
</li>
</ul>
</div>
<div class="example" id="GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4__CIHBDHGI">
<p class="titleinexample">Example 5-13 Defining a Scalar Output Variable Following an Execute and Describe Operation</p>
<pre dir="ltr">SELECT department_name FROM departments WHERE department_id = :dept_input

   /* The input placeholder was bound earlier, and the data comes from the
   user input below */

  printf(&#34;Enter employee dept: &#34;);
  scanf(&#34;%d&#34;, &amp;deptno);

 /* Execute the statement. If OCIStmtExecute() returns OCI_NO_DATA, meaning that
    no data matches the query, then the department number is invalid. */

  if ((status = OCIStmtExecute(svchp, stmthp, errhp, 0, 0, (OCISnapshot *) 0, (OCISnapshot *) 0,
       OCI_DEFAULT))
      &amp;&amp; (status != OCI_NO_DATA))
  {
    checkerr(errhp, status);
    return OCI_ERROR;
  }
  if (status == OCI_NO_DATA) {
    printf(&#34;The dept you entered does not exist.\n&#34;);
    return 0;
  }

   /* The next two statements describe the select-list item, dname, and
   return its length */
  checkerr(errhp, OCIParamGet((void *)stmthp, (ub4) OCI_HTYPE_STMT, errhp, (void **)&amp;parmdp, (ub4) 1));
  checkerr(errhp, OCIAttrGet((void*) parmdp, (ub4) OCI_DTYPE_PARAM,
        (void*) &amp;deptlen, (ub4 *) &amp;sizelen, (ub4) OCI_ATTR_DATA_SIZE,
        (OCIError *) errhp  ));

  /* Use the retrieved length of dname to allocate an output buffer, and
   then define the output variable. If the define call returns an error,
   exit the application */
  dept = (text *) malloc((int) deptlen + 1);
  if (status = OCIDefineByPos(stmthp, &amp;defnp, errhp,
             1, (void *) dept, (sb4) deptlen+1,
             SQLT_STR, (void *) 0, (ub2 *) 0,
             (ub2 *) 0, OCI_DEFAULT))
  {
    checkerr(errhp, status);
    return OCI_ERROR;
  }
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNOCI16387"></a>
<div class="props_rev_3"><a id="GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E"></a>
<h2 id="LNOCI-GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E" class="sect2">Advanced Define Operations in OCI</h2>
<div>
<p>This section covers advanced define operations, including multistep defines and defines of named data types and <code class="codeph">REF</code>s.</p>
<p>In some cases, the define step requires additional calls than just a call to <code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code>; for example, that define the attributes of an array fetch, <code class="codeph">OCIDefineArrayOfStruct()</code>, or a named data type fetch, <code class="codeph">OCIDefineObject()</code>. For example, to fetch multiple rows with a column of named data types, all the three calls must be invoked for the column. To fetch multiple rows of scalar columns only, <code class="codeph">OCIDefineArrayOfStruct()</code> and <code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code> are sufficient.</p>
<p>Oracle Database also provides predefined C data types that map object type attributes.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-16652266-2A22-43AB-8BA3-9868CCEC9271">About Defining LOB Output Variables</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79" title="Do not use the define calls to define output variables for select-list items in a SQL SELECT statement inside a PL/SQL block.">About Defining PL/SQL Output Variables</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-D667D691-52A2-457F-972C-1E659DFB6901">About Defining for a Piecewise Fetch</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E__GUID-48388339-4EF3-47B1-A7E4-26399617DAD5">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci12oty.htm#GUID-C62AEE74-0CC5-4FAB-A91F-997F71C49C2C" title="This chapter describes the purpose and structure of each of the data types that can be manipulated by the OCI data type mapping and manipulation functions.">Object-Relational Data Types in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E" title="This section covers advanced define operations, including multistep defines and defines of named data types and REFs.">Advanced Define Operations in OCI</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> or <a href="oci16rel003.htm#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="Associates an item in a select list with the type and output data buffer. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIDefineByPos2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="Specifies additional attributes necessary for a static array define, used in an array of structures (multirow, multicolumn) fetch.">OCIDefineArrayOfStruct()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" title="Sets up additional attributes necessary for a named data type or REF define.">OCIDefineObject()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16388"></a>
<div class="props_rev_3"><a id="GUID-16652266-2A22-43AB-8BA3-9868CCEC9271"></a>
<h3 id="LNOCI-GUID-16652266-2A22-43AB-8BA3-9868CCEC9271" class="sect3">About Defining LOB Output Variables</h3>
<div>
<p>There are two ways of defining LOBs:</p>
<ul style="list-style-type: disc;">
<li>
<p>Define a LOB locator, rather than the actual LOB values. In this case, the LOB value is written or read by passing a LOB locator to the OCI LOB functions.</p>
</li>
<li>
<p>Define a LOB value directly, without using the LOB locator.</p>
</li>
</ul>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-BAF35569-CC0C-45E4-BB43-4E33BA85086C">About Defining LOB Locators</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E">About Defining LOB Data</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16389"></a>
<div class="props_rev_3"><a id="GUID-BAF35569-CC0C-45E4-BB43-4E33BA85086C"></a>
<h4 id="LNOCI-GUID-BAF35569-CC0C-45E4-BB43-4E33BA85086C" class="sect4">About Defining LOB Locators</h4>
<div>
<p>Either a single locator or an array of locators can be defined in a single define call. In each case, the application must pass the address of a LOB locator and not the locator itself. For example, suppose that an application has prepared the following SQL statement:</p>
<pre dir="ltr">SELECT lob1 FROM some_table;
</pre>
<p>In this statement, <code class="codeph">lob1</code> is the LOB column, and <code class="codeph">one_lob</code> is a define variable corresponding to a LOB column with the following declaration:</p>
<pre dir="ltr">OCILobLocator * one_lob;
</pre>
<p>Then the following calls would be used to bind the placeholder and execute the statement:</p>
<pre dir="ltr">/* initialize single locator */
OCIDescriptorAlloc(...&amp;one_lob, OCI_DTYPE_LOB...);
...
/* pass the address of the locator */
OCIBindByName(...,(void *) &amp;one_lob,... SQLT_CLOB, ...);
OCIStmtExecute(...,1,...);                /* 1 is the iters parameter */
</pre>
<p>You can also insert an array using this same SQL <code class="codeph">SELECT</code> statement. In this case, the application would include the following code:</p>
<pre dir="ltr">OCILobLocator * lob_array[10];
...
for (i=0; i&lt;10, i++)
   OCIDescriptorAlloc(...&amp;lob_array[i], OCI_DTYPE_LOB...);
                                         /* initialize array of locators */
...
OCIBindByName(...,(void *) lob_array,...);
OCIStmtExecute(...,10,...);               /* 10 is the iters parameter */
</pre>
<p>Note that you must allocate descriptors with the <code class="codeph">OCIDescriptorAlloc()</code> function before they can be used. In an array of locators, you must initialize each array element using <code class="codeph">OCIDescriptorAlloc()</code>. Use <code class="codeph">OCI_DTYPE_LOB</code> as the <code class="codeph">type</code> parameter when allocating <code class="codeph">BLOB</code>s, <code class="codeph">CLOB</code>s, and <code class="codeph">NCLOB</code>s. Use <code class="codeph">OCI_DTYPE_FILE</code> when allocating <code class="codeph">BFILE</code>s.</p>
</div>
</div>
<a id="LNOCI72617"></a><a id="LNOCI72618"></a><a id="LNOCI16390"></a>
<div class="props_rev_3"><a id="GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E"></a>
<h4 id="LNOCI-GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E" class="sect4">About Defining LOB Data</h4>
<div>
<p>Oracle Database allows nonzero defines for <code class="codeph">SELECT</code>s of any size LOB. So you can select up to the maximum allowed size of data from a LOB column using <a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> and PL/SQL defines. Because there can be multiple LOBs in a row, you can select the maximum size of data from each one of those LOBs in the same <code class="codeph">SELECT</code> statement.</p>
<p>The following SQL statement is the basis for <a href="oci05bnd.htm#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E__CIHCFDCF">Example 5-14</a> and <a href="oci05bnd.htm#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E__CIHCGDAE">Example 5-15</a>:</p>
<pre dir="ltr">CREATE TABLE lob_tab (C1 CLOB, C2 CLOB);
</pre>
<div class="example" id="GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E__CIHCFDCF">
<p class="titleinexample">Example 5-14 Defining LOBs Before Execution</p>
<pre dir="ltr">void select_define_before_execute()      /* A function in an OCI program */
{
  /* The following is allowed */
   ub1 buffer1[8000];
   ub1 buffer2[8000];
   text *select_sql = (text *)&#34;SELECT c1, c2 FROM lob_tab&#34;;

   OCIStmtPrepare(stmthp, errhp, select_sql, (ub4)strlen((char*)select_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIDefineByPos(stmthp, &amp;defhp[0], errhp, 1, (void *)buffer1, 8000,
                SQLT_LNG, (void *)0, (ub2 *)0, (ub2 *)0, (ub4) OCI_DEFAULT);
   OCIDefineByPos(stmthp, &amp;defhp[1], errhp, 2, (void *)buffer2, 8000,
                SQLT_LNG, (void *)0, (ub2 *)0, (ub2 *)0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *)0, 
                 (OCISnapshot *)0, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E__CIHCGDAE">
<p class="titleinexample">Example 5-15 Defining LOBs After Execution</p>
<pre dir="ltr">void select_execute_before_define()
{
  /* The following is allowed */
   ub1 buffer1[8000];
   ub1 buffer2[8000];
   text *select_sql = (text *)&#34;SELECT c1, c2 FROM lob_tab&#34;;

   OCIStmtPrepare(stmthp, errhp, select_sql, (ub4)strlen((char*)select_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 0, 0, (OCISnapshot *)0,
                 (OCISnapshot *)0, OCI_DEFAULT);
   OCIDefineByPos(stmthp, &amp;defhp[0], errhp, 1, (void *)buffer1, 8000,
                 SQLT_LNG, (void *)0, (ub2 *)0, (ub2 *)0, (ub4) OCI_DEFAULT);
   OCIDefineByPos(stmthp, &amp;defhp[1], errhp, 2, (void *)buffer2, 8000,
                 SQLT_LNG, (void *)0, (ub2 *)0, (ub2 *)0, (ub4) OCI_DEFAULT);
   OCIStmtFetch(stmthp, errhp, 1, OCI_FETCH_NEXT, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNOCI16393"></a>
<div class="props_rev_3"><a id="GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79"></a>
<h3 id="LNOCI-GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79" class="sect3">About Defining PL/SQL Output Variables</h3>
<div>
<p>Do not use the define calls to define output variables for select-list items in a SQL <code class="codeph">SELECT</code> statement inside a PL/SQL block.</p>
<p>Use OCI bind calls instead.</p>
<div class="infoboxnotealso" id="GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79__GUID-C2923694-5664-43C3-BBC5-F2024C27518D">
<p class="notep1">See Also:</p>
<p><a href="oci12oty.htm#GUID-1E2056EF-32BE-4875-9211-C2D4BB535D11" title="Consider the following important information as you work with named data type and REF defines. It includes pointers about memory allocation and indicator variable usage.">Information for Named Data Type and REF Defines, and PL/SQL OUT Binds</a> for more information about defining PL/SQL output variables</p>
</div>
</div>
</div>
<a id="LNOCI16394"></a>
<div class="props_rev_3"><a id="GUID-D667D691-52A2-457F-972C-1E659DFB6901"></a>
<h3 id="LNOCI-GUID-D667D691-52A2-457F-972C-1E659DFB6901" class="sect3">About Defining for a Piecewise Fetch</h3>
<div>
<p>A piecewise fetch requires an initial call to <a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a>. An additional call to <a href="oci16rel003.htm#GUID-DD404526-9615-4E44-B790-1D17396C82A9" title="Sets the additional attributes required if the OCI_DYNAMIC_FETCH mode was selected in OCIDefineByPos() or OCIDefineByPos2().">OCIDefineDynamic()</a> is necessary if the application uses callbacks rather than the standard polling mechanism.</p>
</div>
</div>
</div>
<a id="LNOCI16395"></a>
<div class="props_rev_3"><a id="GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A"></a>
<h2 id="LNOCI-GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A" class="sect2">About Binding and Defining Arrays of Structures in OCI</h2>
<div>
<p>Defining arrays of structures requires an initial call to <code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code>.</p>
<p>An additional call to <code class="codeph">OCIDefineArrayOfStruct()</code> is necessary to set up each additional parameter, including the <code class="codeph">skip</code> parameter necessary for arrays of structures operations.</p>
<p>Using arrays of structures can simplify the processing of multirow, multicolumn operations. You can create a structure of related scalar data items, and then fetch values from the database into an array of these structures, or insert values into the database from an array of these structures.</p>
<p>For example, an application may need to fetch multiple rows of data from columns <code class="codeph">NAME</code>, <code class="codeph">AGE</code>, and <code class="codeph">SALARY</code>. The application can include the definition of a structure containing separate fields to hold the <code class="codeph">NAME</code>, <code class="codeph">AGE</code>, and <code class="codeph">SALARY</code> data from one row in the database table. The application would then fetch data into an array of these structures.</p>
<p>To perform a multirow, multicolumn operation using an array of structures, associate each column involved in the operation with a field in a structure. This association, which is part of <code class="codeph">OCIDefineArrayOfStruct()</code> and <code class="codeph">OCIBindArrayOfStruct()</code> calls, specifies where data is stored.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A" title="When you split column data across an array of structures, it is no longer stored contiguously in the database.">Skip Parameters</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38">OCI Calls Used with Arrays of Structures</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-5D597ED3-20FB-4092-BA99-6D43D459C34C" title="The implementation of arrays of structures in addition supports the use of indicator variables and return codes.">Arrays of Structures and Indicator Variables</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A__GUID-26FAB1B8-4E9A-4507-8152-92B5392B8C0D">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> or <a href="oci16rel003.htm#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="Associates an item in a select list with the type and output data buffer. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIDefineByPos2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="Specifies additional attributes necessary for a static array define, used in an array of structures (multirow, multicolumn) fetch.">OCIDefineArrayOfStruct()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="Sets up the skip parameters for a static array bind.">OCIBindArrayOfStruct()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16397"></a><a id="LNOCI16396"></a>
<div class="props_rev_3"><a id="GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A"></a>
<h3 id="LNOCI-GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A" class="sect3">Skip Parameters</h3>
<div>
<p>When you split column data across an array of structures, it is no longer stored contiguously in the database.</p>
<p>The single array of structures stores data as though it were composed of several arrays of scalars. For this reason, you must specify a skip parameter for each field that you are binding or defining. This skip parameter is the number of bytes that must be skipped in the array of structures before the same field is encountered again. In general, this is equivalent to the byte size of one structure.</p>
<p><a href="oci05bnd.htm#GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A__I421954">Figure 5-2</a> shows how a skip parameter is determined. In this case, the skip parameter is the sum of the sizes of the fields <code class="codeph">field1</code> (2 bytes), <code class="codeph">field2</code> (4 bytes), and <code class="codeph">field3</code> (2 bytes), which is 8 bytes. This equals the size of one structure.</p>
<div class="figure" id="GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A__I421954">
<p class="titleinfigure">Figure 5-2 Determining Skip Parameters</p>
<img width="668" height="136" src="img/GUID-07DB790D-1913-4ADF-8A3F-EBCD6C8EE9B6-default.gif" alt="Description of Figure 5-2 follows" title="Description of Figure 5-2 follows"/><br/>
<a href="img_text/GUID-07DB790D-1913-4ADF-8A3F-EBCD6C8EE9B6-print.htm">Description of &#34;Figure 5-2 Determining Skip Parameters&#34;</a></div>
<!-- class="figure" -->
<p>On some operating systems it may be necessary to set the skip parameter to <code class="codeph">sizeof</code>(<code class="codeph">one_array_element</code>) rather than <code class="codeph">sizeof</code>(<code class="codeph">struct</code>), because some compilers insert extra bytes into a structure.</p>
<p>Consider an array of C structures consisting of two fields, a <code class="codeph">ub4</code> and a <code class="codeph">ub1</code>:</p>
<pre dir="ltr">struct demo {
    ub4 field1;
    ub1 field2;
};
struct demo demo_array[MAXSIZE];
</pre>
<p>Some compilers insert 3 bytes of padding after the <code class="codeph">ub1</code> so that the <code class="codeph">ub4</code> that begins the next structure in the array is properly aligned. In this case, the following statement may return an incorrect value:</p>
<pre dir="ltr">skip_parameter = sizeof(struct demo);
</pre>
<p>On some operating systems this produces a proper skip parameter of 8. On other systems, <code class="codeph">skip_parameter</code> is set to 5 bytes by this statement. In the latter case, use the following statement to get the correct value for the skip parameter:</p>
<pre dir="ltr">skip_parameter = sizeof(demo_array[0]);
</pre>
<p>This section includes the following topic: <a href="oci05bnd.htm#GUID-DCC69B07-0EEC-4902-8321-4F402B806B47">Skip Parameters for Standard Arrays</a>.</p>
</div>
<a id="LNOCI16398"></a>
<div class="props_rev_3"><a id="GUID-DCC69B07-0EEC-4902-8321-4F402B806B47"></a>
<h4 id="LNOCI-GUID-DCC69B07-0EEC-4902-8321-4F402B806B47" class="sect4">Skip Parameters for Standard Arrays</h4>
<div>
<p>Arrays of structures <a id="d67612e6295" class="indexterm-anchor"></a><a id="d67612e6299" class="indexterm-anchor"></a>are an extension of binding and defining arrays of single variables. When you specify a single-variable array operation, the related skip equals the size of the data type of the array under consideration. For example, consider an array declared as follows:</p>
<pre dir="ltr">text emp_names[4][20];
</pre>
<p>The skip parameter for the bind or define operation is 20. Each data element in the array is then recognized as a separate unit, rather than being part of a structure.</p>
</div>
</div>
</div>
<a id="LNOCI16399"></a>
<div class="props_rev_3"><a id="GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38"></a>
<h3 id="LNOCI-GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38" class="sect3">OCI Calls Used with Arrays of Structures</h3>
<div>
<p>Two OCI calls must be used when you perform operations involving arrays of structures:</p>
<ul style="list-style-type: disc;">
<li>
<p>Use <a href="oci16rel003.htm#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="Sets up the skip parameters for a static array bind.">OCIBindArrayOfStruct()</a> for binding fields in arrays of structures for input variables</p>
</li>
<li>
<p>Use <a href="oci16rel003.htm#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="Specifies additional attributes necessary for a static array define, used in an array of structures (multirow, multicolumn) fetch.">OCIDefineArrayOfStruct()</a> for defining arrays of structures for output variables.</p>
<div class="infobox-note" id="GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38__GUID-01F0A823-8B1D-49BA-A275-DB6E021AE907">
<p class="notep1">Note:</p>
<p>Binding or defining for arrays of structures requires multiple calls. A call to <a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> must precede a call to <a href="oci16rel003.htm#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="Sets up the skip parameters for a static array bind.">OCIBindArrayOfStruct()</a>, and a call to <a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> must precede a call to <a href="oci16rel003.htm#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="Specifies additional attributes necessary for a static array define, used in an array of structures (multirow, multicolumn) fetch.">OCIDefineArrayOfStruct()</a>.</p>
</div>
</li>
</ul>
</div>
</div>
<a id="LNOCI16400"></a>
<div class="props_rev_3"><a id="GUID-5D597ED3-20FB-4092-BA99-6D43D459C34C"></a>
<h3 id="LNOCI-GUID-5D597ED3-20FB-4092-BA99-6D43D459C34C" class="sect3">Arrays of Structures and Indicator Variables</h3>
<div>
<p>The implementation of arrays of structures in addition supports the use of indicator variables and return codes.</p>
<p>You can declare parallel arrays of column-level indicator variables and return codes that correspond to the arrays of information being fetched, inserted, or updated. These arrays can have their own skip parameters, which are specified during <code class="codeph">OCIBindArrayOfStruct()</code> or <code class="codeph">OCIDefineArrayOfStruct()</code> calls.</p>
<p>You can set up arrays of structures of program values and indicator variables in many ways. Consider an application that fetches data from three database columns into an array of structures containing three fields. You can set up a corresponding array of indicator variable structures of three fields, each of which is a column-level indicator variable for one of the columns being fetched from the database. A one-to-one relationship between the fields in an indicator struct and the number of select-list items is not necessary.</p>
<div class="infoboxnotealso" id="GUID-5D597ED3-20FB-4092-BA99-6D43D459C34C__GUID-57EC908F-AE2E-4F40-BCEE-2F0EFAA5BCB9">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci02bas.htm#GUID-9966EDF7-37ED-42E5-AE57-67E394245BFA" title="Each bind and define OCI call has a parameter that associates an indicator variable, or an array of indicator variables, with a DML statement, a PL/SQL statement, or a query.">Indicator Variables</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="Sets up the skip parameters for a static array bind.">OCIBindArrayOfStruct()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="Specifies additional attributes necessary for a static array define, used in an array of structures (multirow, multicolumn) fetch.">OCIDefineArrayOfStruct()</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="LNOCI72619"></a><a id="LNOCI05100"></a>
<div class="props_rev_3"><a id="GUID-CC67A87C-A39A-400A-BF95-C32363DCD589"></a>
<h2 id="LNOCI-GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" class="sect2">About Binding and Defining Multiple Buffers</h2>
<div>
<p><a id="d67612e6884" class="indexterm-anchor"></a>You can specify multiple buffers for use with a single bind or define call. Performance is improved because the number of round-trips is decreased when data stored at different noncontiguous addresses is not copied to one contiguous location. CPU time spent and memory used are thus reduced.</p>
<p>The data type <code class="codeph">OCIIOV</code> is defined as:</p>
<pre dir="ltr">typedef struct OCIIOV
{
  void *bfp;  /* The pointer to a buffer for the data    */
  ub4  bfl;   /* The size of the buffer                  */
}OCIIOV;
</pre>
<p>The value <code class="codeph">OCI_IOV</code> for the <code class="codeph">mode</code> parameter is used in the <a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> and <a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> functions for binding multiple buffers. If this value of <code class="codeph">mode</code> is specified, the address of <code class="codeph">OCIIOV</code> must be passed in parameter <code class="codeph">valuep</code>. The size of the data type must be passed in the parameter <code class="codeph">valuesz</code>. For example:</p>
<pre dir="ltr">OCIIOV vecarr[NumBuffers];
...
/* For bind at position 1 with data type int     */
OCIBindByPos(stmthp, bindp, errhp, 1, (void *)&amp;vecarr[0],
             sizeof(int), ... OCI_IOV);
...
</pre>
<p>The value <code class="codeph">OCI_IOV</code> <span>for the mode parameter</span> is used in the <a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> function for defining multiple buffers. If this value of <code class="codeph">mode</code> is specified, the address of <code class="codeph">OCIIOV</code> is passed in parameter <code class="codeph">valuep</code>. The size of the data type must be passed in the parameter <code class="codeph">valuesz</code>. This mode is intended to be used for scatter or gather binding, which allows multiple buffers to be bound or defined to a position, for example column A for the first 10 rows in one buffer, next 5 rows in one buffer, and the remaining 25 rows in another buffer. That eliminates the need to allocate and copy all of them into one big buffer while doing the array execute operation.</p>
<div class="infoboxnotealso" id="GUID-CC67A87C-A39A-400A-BF95-C32363DCD589__GUID-5952030A-4A7A-4831-87A9-08CF7A7838A1">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a>&#34;</span></p>
</li>
</ul>
</div>
<p><a href="oci05bnd.htm#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589__CIHHIAJF">Example 5-16</a> illustrates the use of the structure <code class="codeph">OCIIOV</code> and its <code class="codeph">mode</code> values.</p>
<div class="example" id="GUID-CC67A87C-A39A-400A-BF95-C32363DCD589__CIHHIAJF">
<p class="titleinexample">Example 5-16 Using Multiple Bind and Define Buffers</p>
<pre dir="ltr">/* The following macros mention the maximum length of the data in the 
 * different buffers. */
 
#define    LENGTH_DATE      10
#define    LENGTH_EMP_NAME  100
 
 
/* These two macros represent the number of elements in each bind and define 
   array */
#define  NUM_BIND     30
#define  NUM_DEFINE   45
 
/* The bind buffers for inserting dates */
char  buf_1[NUM_BIND][LENGTH_DATE], 
char  buf_2[NUM_BIND * 2][LENGTH_DATE], 
 
/* The bind buffer for inserting emp name */
char  buf_3[NUM_BIND * 3][LENGTH_EMP_NAME], 
 
/* The define buffers */
char  buf_4[NUM_DEFINE][LENGTH_EMP_NAME];
char  buf_5[NUM_DEFINE][LENGTH_EMP_NAME];
 
/* The size of data value for buffers corresponding to the same column must be
   the same, and that value is passed in the OCIBind or Define calls.
   buf_4 and buf_5 above have the same data values; that is, LENGTH_EMP_NAME
   although the  number of elements are different in the two buffers.
   
*/
OCIBind     *bndhp1 = (OCIBind   *)0;
OCIBind     *bndhp2 = (OCIBind   *)0;
OCIDefine   *defhp  = (OCIDefine *)0;
OCIStmt     *stmthp = (OCIStmt   *)0;
OCIError    *errhp  = (OCIError  *)0;
 
OCIIOV  bvec[2], dvec[2];
 
/* 
Example of how to use indicators and return codes with this feature, 
showing the allocation when using with define. You allocate memory 
for indicator, return code, and the length buffer as one chunk of 
NUM_DEFINE * 2 elements.
*/
short *indname[NUM_DEFINE*2];            /* indicators */
ub4   *alenname[NUM_DEFINE*2];           /* return lengths */
ub2   *rcodename[NUM_DEFINE*2];          /* return codes */
 
static text *insertstr  = 
             &#34;INSERT INTO EMP (EMP_NAME, JOIN_DATE) VALUES (:1, :2)&#34;;
static text *selectstr  = &#34;SELECT EMP_NAME FROM EMP&#34;;
 
/* Allocate environment, error handles, and so on, and then initialize the 
   environment.  */
...
/* Prepare the statement with the insert query in order to show the 
   binds. */
OCIStmtPrepare  (stmthp, errhp, insertstr,
                 (ub4)strlen((char *)insertstr),
                 (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
 
/* Populate buffers with values. The following represents the simplest
 * way of populating the buffers. However, in an actual scenario 
 * these buffers may have been populated by data received from different
 * sources. */
 
/* Store the date in the bind buffers for the date. */
strcpy(buf_1[0], &#34;21-SEP-02&#34;);
...
strcpy(buf_1[NUM_BIND - 1], &#34;21-OCT-02&#34;);
...
strcpy(buf_2[0], &#34;22-OCT-02&#34;);
...
strcpy(buf_2[2*NUM_BIND - 1], &#34;21-DEC-02&#34;);
...
memset(bvec[0], 0, sizeof(OCIIOV));
memset(bvec[1], 0, sizeof(OCIIOV));
 
/* Set up the addresses in the IO Vector structure */
bvec[0].bfp = buf_1[0];                       /* Buffer address of the data */
bvec[0].bfl = NUM_BIND*LENGTH_DATE;           /* Size of the buffer */
 
/* And so on for other structures as well. */
bvec[1].bfp = buf_2[0];                       /* Buffer address of the data */
bvec[1].bfl = NUM_BIND*2*LENGTH_DATE;         /* Size of the buffer  */ 
 
/* Do the bind for date, using OCIIOV */
OCIBindByPos (stmthp, &amp;bindhp2, errhp, 2, (void *)&amp;bvec[0], 
              sizeof(buf_1[0]), SQLT_STR, 
              (void *)inddate, (ub2 *)alendate, (ub2 *)rcodedate, 0,
              (ub4 *)0,  OCI_IOV);
 
/* Store the employee names in the bind buffers, 3 for the names */
strcpy (buf_3[0], &#34;JOHN &#34;);
...
strcpy (buf_3[NUM_BIND *3 - 1], &#34;HARRY&#34;);
 
/* Do the bind for employee name */
OCIBindByPos  (stmthp,  &amp;bindhp1, errhp, 1, buf_3[0], sizeof(buf_3[0]),
      SQLT_STR, (void *)indemp, (ub2 *)alenemp, (ub2 *)rcodeemp, 0, 
      (ub4 *)0, OCI_DEFAULT);
 
OCIStmtExecute (svchp, stmthp, errhp, NUM_BIND*3, 0, 
               (OCISnapshot *)0, (OCISnapshot *)0, OCI_DEFAULT);
 
...
/* Now the statement to depict defines */
/* Prepare the statement with the select query in order to show the 
   defines */
OCIStmtPrepare(stmthp, errhp, selectstr,(ub4)strlen((char *)selectstr),
               (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
 
memset(dvec[0], 0, sizeof(OCIIOV);
memset(dvec[1], 0, sizeof(OCIIOV));
 
/* Set up the define vector */
dvec[0].bfp = buf_4[0];
dvec[0].bfl = NUM_DEFINE*LENGTH_EMP_NAME;
 
dvec[1].bfp = buf_5[0];
dvec[1].bfl = NUM_DEFINE*LENGTH_EMP_NAME;
 
/* 
Pass the buffers for the indicator, length of the data, and the 
return code.  Note that the buffer where you receive
the data is split into two locations, 
each having NUM_DEFINE number of elements. However, the indicator
buffer, the actual length buffer, and the return code buffer comprise a
single chunk of NUM_DEFINE * 2 elements.
*/
OCIDefineByPos (stmthp, &amp;defhp, errhp, 1, (void *)&amp;dvec[0], 
                sizeof(buf_4[0]), SQLT_STR, (void *)indname, 
                (ub2 *)alenname, (ub2 *)rcodename, OCI_IOV);
 
OCIStmtExecute (svchp, stmthp, errhp, NUM_DEFINE*2, 0, 
                (OCISnapshot*)0, 
                (OCISnapshot*)0, OCI_DEFAULT);
...
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI16402"></a>
<div class="props_rev_3"><a id="GUID-C0D4318B-0768-4386-AA15-C88AE3A33C76"></a>
<h2 id="LNOCI-GUID-C0D4318B-0768-4386-AA15-C88AE3A33C76" class="sect2">DML with a RETURNING Clause in OCI</h2>
<div>
<p>This section outlines the rules for correctly implementing DML statements with the <code class="codeph">RETURNING</code> clause.</p>
<p>OCI supports the use of the <code class="codeph">RETURNING</code> clause with SQL <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">DELETE</code> statements.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-F170558F-C61D-4B88-8A8C-AC9ED741BE06">About Using DML with a RETURNING Clause to Combine Two SQL Statements</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-415F2F47-03BA-4E3D-B622-A799409DA243">About Binding RETURNING...INTO Variables</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-98A7A102-0839-4814-8CC7-2F3A4C662FF9">OCI Error Handling</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-7B076B46-24FD-4F31-B1B5-A6E3B57F7FEB" title="The RETURNING clause can also be used to return a REF to an object that is being inserted into or updated in the database.">DML with RETURNING REF...INTO Clause in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-81F593FB-1C22-41FC-B1E0-EBBD7B182983">Additional Notes About OCI Callbacks</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-FBBE8A75-8EEC-4166-A574-6FEE4AC78FA3">Array Interface for DML RETURNING Statements in OCI</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-C0D4318B-0768-4386-AA15-C88AE3A33C76__GUID-159CBB0C-6F15-458C-85F8-175CD369485A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p>The Database demonstration programs included with your Oracle installation for complete examples. For additional information, see <a href="ociabdem.htm#GUID-75E18629-0C54-4495-A747-AFB346034F26" title="Lists example programs with sample code demonstrating the allocation and use of OCI handles.">OCI Demonstration Programs</a>.</p>
</li>
<li>
<p><a class="olink SQLRF55083" target="_blank" href="../SQLRF/statements_9015.htm#SQLRF55083"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for more information about the use of the <code class="codeph">RETURNING</code> clause with <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> statements</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16403"></a>
<div class="props_rev_3"><a id="GUID-F170558F-C61D-4B88-8A8C-AC9ED741BE06"></a>
<h3 id="LNOCI-GUID-F170558F-C61D-4B88-8A8C-AC9ED741BE06" class="sect3">About Using DML with a RETURNING Clause to Combine Two SQL Statements</h3>
<div>
<p>Using the <code class="codeph">RETURNING</code> clause with a DML statement enables you to combine two SQL statements into one, possibly saving a server round-trip. This is accomplished by adding an extra clause to the traditional <code class="codeph">UPDATE</code>, <code class="codeph">INSERT</code>, and <code class="codeph">DELETE</code> statements. The extra clause effectively adds a query to the DML statement.</p>
<p>In OCI, values are returned to the application as <code class="codeph">OUT</code> bind variables. In the following examples, the bind variables are indicated by a preceding colon, &#34;:&#34;. These examples assume the existence of <code class="codeph">table1</code>, a table that contains columns <code class="codeph">col1</code>, <code class="codeph">col2</code>, and <code class="codeph">col3</code>.</p>
<p>The following statement inserts new values into the database and then retrieves the column values of the affected row from the database, for manipulating inserted rows.</p>
<pre dir="ltr">INSERT INTO table1 VALUES (:1, :2, :3)
     RETURNING col1, col2, col3
     INTO :out1, :out2, :out3
</pre>
<p>The next example updates the values of all columns where the value of <code class="codeph">col1</code> falls within a given range, and then returns the affected rows that were modified.</p>
<pre dir="ltr">UPDATE table1 SET col1 = col1 + :1, col2 = :2, col3 = :3
     WHERE col1 &gt;= :low AND col1 &lt;= :high
     RETURNING col1, col2, col3
     INTO :out1, :out2, :out3
</pre>
<p>The <code class="codeph">DELETE</code> statement deletes the rows where <code class="codeph">col1</code> value falls within a given range, and then returns the data from those rows.</p>
<pre dir="ltr">DELETE FROM table1 WHERE col1 &gt;= :low AND col2 &lt;= :high 
     RETURNING col1, col2, col3
     INTO :out1, :out2, :out3
</pre></div>
</div>
<a id="LNOCI16404"></a>
<div class="props_rev_3"><a id="GUID-415F2F47-03BA-4E3D-B622-A799409DA243"></a>
<h3 id="LNOCI-GUID-415F2F47-03BA-4E3D-B622-A799409DA243" class="sect3">About Binding RETURNING...INTO Variables</h3>
<div>
<p>Because both the <code class="codeph">UPDATE</code> and <code class="codeph">DELETE</code> statements can affect multiple rows in the table, and a DML statement can be executed multiple times in a single <a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a> call, how much data is returned may not be known at run time. As a result, the variables corresponding to the <code class="codeph">RETURNING</code>...<code class="codeph">INTO</code> placeholders must be bound in <code class="codeph">OCI_DATA_AT_EXEC</code> mode. An application must define its own dynamic data handling callbacks rather than using a polling mechanism.</p>
<p>The returning clause can be particularly useful when working with LOBs. Normally, an application must insert an empty LOB locator into the database, and then select it back out again to operate on it. By using the <code class="codeph">RETURNING</code> clause, the application can combine these two steps into a single statement:</p>
<pre dir="ltr">INSERT INTO some_table VALUES (:in_locator)
    RETURNING lob_column
    INTO :out_locator
</pre>
<p>An OCI application implements the placeholders in the <code class="codeph">RETURNING</code> clause as pure <code class="codeph">OUT</code> bind variables. However, all binds in the <code class="codeph">RETURNING</code> clause are initially <code class="codeph">IN</code> and must be properly initialized. To provide a valid value, you can provide a <code class="codeph">NULL</code> indicator and set that indicator to -1.</p>
<p>An application must adhere to the following rules when working with bind variables in a <code class="codeph">RETURNING</code> clause:</p>
<ul style="list-style-type: disc;">
<li>
<p>Bind <code class="codeph">RETURNING</code> clause placeholders in <code class="codeph">OCI_DATA_AT_EXEC</code> mode using <a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a>, followed by a call to <a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a> for each placeholder.</p>
</li>
<li>
<p>When binding <code class="codeph">RETURNING</code> clause placeholders, supply a valid <code class="codeph">OUT</code> bind function as the <code class="codeph">ocbfp</code> parameter of the <a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a> call. This function must provide storage to hold the returned data.</p>
</li>
<li>
<p>The <code class="codeph">icbfp</code> parameter of <a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a> call should provide a default function that returns <code class="codeph">NULL</code> values when called.</p>
</li>
<li>
<p>The <code class="codeph">piecep</code> parameter of <a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a> must be set to <code class="codeph">OCI_ONE_PIECE</code>.</p>
</li>
</ul>
<p>No duplicate binds are allowed in a DML statement with a <code class="codeph">RETURNING</code> clause, and no duplication is allowed between bind variables in the DML section and the <code class="codeph">RETURNING</code> section of the statement.</p>
<div class="infobox-note" id="GUID-415F2F47-03BA-4E3D-B622-A799409DA243__GUID-1CB9E046-E356-42E3-92B7-FC0C1AA76A82">
<p class="notep1">Note:</p>
<p>OCI supports only the callback mechanism for <code class="codeph">RETURNING</code> clause binds. The polling mechanism is not supported.</p>
</div>
</div>
</div>
<a id="LNOCI16405"></a>
<div class="props_rev_3"><a id="GUID-98A7A102-0839-4814-8CC7-2F3A4C662FF9"></a>
<h3 id="LNOCI-GUID-98A7A102-0839-4814-8CC7-2F3A4C662FF9" class="sect3">OCI Error Handling</h3>
<div>
<p>The <code class="codeph">OUT</code> bind function provided to <code class="codeph">OCIBindDynamic()</code> must be prepared to receive partial results of a statement if there is an error. If the application has issued a DML statement that is executed 10 times, and an error occurs during the fifth iteration, the Oracle database returns the data from iterations 1 through 4. The callback function is still called to receive data for the first four iterations.</p>
</div>
</div>
<a id="LNOCI16406"></a>
<div class="props_rev_3"><a id="GUID-7B076B46-24FD-4F31-B1B5-A6E3B57F7FEB"></a>
<h3 id="LNOCI-GUID-7B076B46-24FD-4F31-B1B5-A6E3B57F7FEB" class="sect3">DML with RETURNING REF...INTO Clause in OCI</h3>
<div>
<p>The <code class="codeph">RETURNING</code> clause can also be used to return a <code class="codeph">REF</code> to an object that is being inserted into or updated in the database.</p>
<pre dir="ltr">UPDATE extaddr e SET e.zip = &#39;12345&#39;, e.state =&#39;AZ&#39;
    WHERE e.state = &#39;CA&#39; AND e.zip = &#39;95117&#39;
    RETURNING REF(e), zip
    INTO :addref, :zip
</pre>
<p>The preceding statement updates several attributes of an object in an object table and returns a <code class="codeph">REF</code> to the object (and a scalar postal code (ZIP)) in the <code class="codeph">RETURNING</code> clause.</p>
<p>This section includes the following topic: <a href="oci05bnd.htm#GUID-88C58918-C7DF-48F4-8803-763508F072E9">Binding the Output Variable</a>.</p>
</div>
<a id="LNOCI72620"></a><a id="LNOCI16407"></a>
<div class="props_rev_3"><a id="GUID-88C58918-C7DF-48F4-8803-763508F072E9"></a>
<h4 id="LNOCI-GUID-88C58918-C7DF-48F4-8803-763508F072E9" class="sect4">Binding the Output Variable</h4>
<div>
<div class="section">
<p>Binding the <code class="codeph">REF</code> output variable in an OCI application requires three steps:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>Set the initial bind information is set using <a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a>.</span></li>
<li><span>Set additional bind information for the <code class="codeph">REF</code>, including the type description object (TDO), is set with <a href="oci16rel003.htm#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF">OCIBindObject()</a>.</span></li>
<li><span>Make a call is made to <a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a>.</span></li>
</ol>
<div class="example" id="GUID-88C58918-C7DF-48F4-8803-763508F072E9__CIHDICFI">
<p class="titleinexample">Example 5-17 Binding the REF Output Variable in an OCI Application</p>
<pre dir="ltr">sword bind_output(stmthp, bndhp, errhp)
OCIStmt *stmthp;
OCIBind *bndhp[];
OCIError *errhp;
{
  ub4 i;
                                  /* get TDO for BindObject call */
  if (OCITypeByName(envhp, errhp, svchp, (CONST text *) 0,
                   (ub4) 0, (CONST text *) &#34;ADDRESS_OBJECT&#34;,
                   (ub4) strlen((CONST char *) &#34;ADDRESS_OBJECT&#34;),
                   (CONST text *) 0, (ub4) 0,
                    OCI_DURATION_SESSION, OCI_TYPEGET_HEADER, &amp;addrtdo))
  {
    return OCI_ERROR;
  }

                         /* initial bind call for both variables */
  if (OCIBindByName(stmthp, &amp;bndhp[2], errhp,
                       (text *) &#34;:addref&#34;, (sb4) strlen((char *) &#34;:addref&#34;),
                       (void *) 0, (sb4) sizeof(OCIRef *), SQLT_REF,
                       (void *) 0, (ub2 *)0, (ub2 *)0,
                       (ub4) 0, (ub4 *) 0, (ub4) OCI_DATA_AT_EXEC)
  ||  OCIBindByName(stmthp, &amp;bndhp[3], errhp,
                       (text *) &#34;:zip&#34;, (sb4) strlen((char *) &#34;:zip&#34;),
                       (void *) 0, (sb4) MAXZIPLEN, SQLT_CHR,
                       (void *) 0, (ub2 *)0, (ub2 *)0,
                       (ub4) 0, (ub4 *) 0, (ub4) OCI_DATA_AT_EXEC))
  {
    return OCI_ERROR;
  }

                                 /* object bind for REF variable */
  if (OCIBindObject(bndhp[2], errhp, (OCIType *) addrtdo,
          (void **) &amp;addrref[0], (ub4 *) 0, (void **) 0, (ub4 *) 0))
  {
    return OCI_ERROR;
  }


  for (i = 0; i &lt; MAXCOLS; i++)
    pos[i] = i;
                    /* dynamic binds for both RETURNING variables */
  if (OCIBindDynamic(bndhp[2], errhp, (void *) &amp;pos[0], cbf_no_data,
                    (void *) &amp;pos[0], cbf_get_data)
  ||  OCIBindDynamic(bndhp[3], errhp, (void *) &amp;pos[1], cbf_no_data,
                    (void *) &amp;pos[1], cbf_get_data))
  {
    return OCI_ERROR;
  }

  return OCI_SUCCESS;
}
</pre></div>
<!-- class="example" -->
<div class="section">
<p>The following pseudocode in<span><a href="oci05bnd.htm#GUID-88C58918-C7DF-48F4-8803-763508F072E9__CIHDICFI">Example 5-17</a></span> shows a function that performs the binds necessary for the preceding three steps.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="LNOCI16408"></a>
<div class="props_rev_3"><a id="GUID-81F593FB-1C22-41FC-B1E0-EBBD7B182983"></a>
<h3 id="LNOCI-GUID-81F593FB-1C22-41FC-B1E0-EBBD7B182983" class="sect3">Additional Notes About OCI Callbacks</h3>
<div>
<p>When a callback function is called, the <code class="codeph">OCI_ATTR_ROWS_RETURNED</code> attribute of the bind handle tells the application the number of rows being returned in that particular iteration. During the first callback of an iteration, you can allocate space for all rows that are returned for that bind variable. During subsequent callbacks of the same iteration, you increment the buffer pointer to the correct memory within the allocated space.</p>
</div>
</div>
<a id="LNOCI16409"></a>
<div class="props_rev_3"><a id="GUID-FBBE8A75-8EEC-4166-A574-6FEE4AC78FA3"></a>
<h3 id="LNOCI-GUID-FBBE8A75-8EEC-4166-A574-6FEE4AC78FA3" class="sect3">Array Interface for DML RETURNING Statements in OCI</h3>
<div>
<p>OCI provides additional functionality for single-row DML and array DML operations in which each iteration returns more than one row. To take advantage of this feature, you must specify an OUT buffer in the bind call that is at least as big as the iteration count specified by the <a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a> call. This is in addition to the bind buffers provided through callbacks.</p>
<p>If any of the iterations returns more than one row, then the application receives an <code class="codeph">OCI_SUCCESS_WITH_INFO</code> return code. In this case, the DML operation is successful. At this point, the application may choose to roll back the transaction or ignore the warning.</p>
</div>
</div>
</div>
<a id="LNOCI16410"></a>
<div class="props_rev_3"><a id="GUID-84576558-1974-4E61-B6E6-795FA67419E3"></a>
<h2 id="LNOCI-GUID-84576558-1974-4E61-B6E6-795FA67419E3" class="sect2">Character Conversion in OCI Binding and Defining</h2>
<div>
<p>This section discusses issues involving character conversions between the client and the server.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-54B9B929-6567-4BB6-86DD-5358CD147608" title="Each OCI bind and define handle is associated with the OCI_ATTR_CHARSET_FORM and OCI_ATTR_CHARSET_ID attributes.">About Choosing a Character Set</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28">About Setting Client Character Sets in OCI</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-59162D2A-A07D-4812-B9BE-3A9F23660E22" title="Update or insert operations are done through variable binding.">About Binding Variables in OCI</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16411"></a>
<div class="props_rev_3"><a id="GUID-54B9B929-6567-4BB6-86DD-5358CD147608"></a>
<h3 id="LNOCI-GUID-54B9B929-6567-4BB6-86DD-5358CD147608" class="sect3">About Choosing a Character Set</h3>
<div>
<p>If a database column containing character data is defined to be an <code class="codeph">NCHAR</code> or <code class="codeph">NVARCHAR2</code> column, then a bind or define involving that column must make special considerations for dealing with character set specifications.</p>
<p>These considerations are necessary in case the width of the client character set is different from the server character set, and also for proper character conversion. During conversion of data between different character sets, the size of the data may increase or decrease by a factor of four. Ensure that buffers that are provided to hold the data are of sufficient size.</p>
<p>In some cases, it may also be easier for an application to deal with <code class="codeph">NCHAR</code> or <code class="codeph">NVARCHAR2</code> data in terms of numbers of characters, rather than numbers of bytes, which is the usual case.</p>
</div>
<a id="LNOCI16412"></a>
<div class="props_rev_3"><a id="GUID-EAF88505-0ADF-4350-85EE-C9307688D75E"></a>
<h4 id="LNOCI-GUID-EAF88505-0ADF-4350-85EE-C9307688D75E" class="sect4">Character Set Form and ID</h4>
<div>
<p>Each OCI bind and define handle is associated with the <code class="codeph">OCI_ATTR_CHARSET_FORM</code> and <code class="codeph">OCI_ATTR_CHARSET_ID</code> attributes.</p>
<p>An application can set these attributes with the <code class="codeph">OCIAttrSet()</code> call to specify the character form and character set ID of the bind or define buffer.</p>
<p>The <code class="codeph">csform</code> attribute (<code class="codeph">OCI_ATTR_CHARSET_FORM</code>) indicates the character set of the client buffer for binds, and the character set in which to store fetched data for defines. It has two possible values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">SQLCS_IMPLICIT</code> - Default value indicates that the database character set ID for the bind or define buffer and the character buffer data are converted to the server database character set</p>
</li>
<li>
<p><code class="codeph">SQLCS_NCHAR</code> - Indicates that the national character set ID for the bind or define buffer and the client buffer data are converted to the server national character set.</p>
</li>
</ul>
<p>If the character set ID attribute, <code class="codeph">OCI_ATTR_CHARSET_ID</code>, is not specified, either the default value of the database or the national character set ID of the client is used, depending on the value of <code class="codeph">csform</code>. They are the values specified in the <code class="codeph">NLS_LANG</code> and <code class="codeph">NLS_NCHAR</code> environment variables, respectively.</p>
<div class="infobox-note" id="GUID-EAF88505-0ADF-4350-85EE-C9307688D75E__GUID-113509A2-C911-4EF2-88C9-EFC24F4AFE0C">
<p class="notep1">Note:</p>
<ul style="list-style-type: disc;">
<li>
<p>The data is converted and inserted into the database according to the server&#39;s database character set ID or national character set ID, regardless of the client-side character set ID.</p>
</li>
<li>
<p><code class="codeph">OCI_ATTR_CHARSET_ID</code> must never be set to 0.</p>
</li>
<li>
<p>The define handle attributes <code class="codeph">OCI_ATTR_CHARSET_FORM</code> and <code class="codeph">OCI_ATTR_CHARSET_ID</code> do not affect the LOB types. LOB locators fetched from the server retain their original <code class="codeph">csform</code>s. There is no <code class="codeph">CLOB</code>/<code class="codeph">NCLOB</code> conversion as part of define conversion based on these attributes.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-EAF88505-0ADF-4350-85EE-C9307688D75E__GUID-40AB4F23-E2A8-46CE-8C3B-B0A3F72B7341">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF50975" target="_blank" href="../SQLRF/sql_elements001.htm#SQLRF50975"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for more information about <code class="codeph">NCHAR</code> data</p>
</li>
<li>
<p><a href="oci16rel002.htm#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="Sets the value of an attribute of a handle or a descriptor.">OCIAttrSet()</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16413"></a>
<div class="props_rev_3"><a id="GUID-BB971E75-CF42-4E09-A7B5-661C3A5CF827"></a>
<h4 id="LNOCI-GUID-BB971E75-CF42-4E09-A7B5-661C3A5CF827" class="sect4">Implicit Conversion Between CHAR and NCHAR</h4>
<div>
<p>As the result of implicit conversion between database character sets and national character sets, OCI can support cross binding and cross defining between <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code>. Although the <code class="codeph">OCI_ATTR_CHARSET_FORM</code> attribute is set to <code class="codeph">SQLCS_NCHAR</code>, OCI enables conversion of data to the database character set if the data is inserted into a <code class="codeph">CHAR</code> column.</p>
</div>
</div>
</div>
<a id="LNOCI72621"></a><a id="LNOCI16414"></a>
<div class="props_rev_3"><a id="GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28"></a>
<h3 id="LNOCI-GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28" class="sect3">About Setting Client Character Sets in OCI</h3>
<div>
<p>You can set the client character sets through the <a href="oci16rel001.htm#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="Creates and initializes an environment handle for OCI functions to work under.">OCIEnvNlsCreate()</a> function parameters <code class="codeph">charset</code> and <code class="codeph">ncharset</code>. Both of these parameters can be set as <code class="codeph">OCI_UTF16ID</code>. The <code class="codeph">charset</code> parameter controls coding of the metadata and <code class="codeph">CHAR</code> data. The <code class="codeph">ncharset</code> parameter controls coding of <code class="codeph">NCHAR</code> data. The function <a href="oci22glb001.htm#GUID-70CCE086-4BF8-42F9-A6CA-E0B926C4DD11">OCINlsEnvironmentVariableGet()</a> returns the character set from <code class="codeph">NLS_LANG</code> and the national character set from <code class="codeph">NLS_NCHAR</code>.</p>
<p><a href="oci05bnd.htm#GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28__CIHFABJC">Example 5-18</a> illustrates the use of these functions (OCI provides a typedef called <code class="codeph">utext</code> to facilitate binding and defining of UTF-16 data):</p>
<div class="infoboxnotealso" id="GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28__GUID-5AF16ECD-C9D1-4A71-9E49-6AD7D32F47E8">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="oci16rel001.htm#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="Creates and initializes an environment handle for OCI functions to work under.">OCIEnvNlsCreate()</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="oci22glb001.htm#GUID-70CCE086-4BF8-42F9-A6CA-E0B926C4DD11">OCINlsEnvironmentVariableGet()</a>&#34;</span></p>
</li>
</ul>
</div>
<div class="example" id="GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28__CIHFABJC">
<p class="titleinexample">Example 5-18 Setting the Client Character Set to OCI_UTF16ID in OCI</p>
<pre dir="ltr">OCIEnv *envhp; 
ub2 ncsid = 2; /* we8dec */ 
ub2 hdlcsid, hdlncsid; 
OraText thename[20]; 
utext *selstmt = L&#34;SELECT ename FROM emp&#34;; /* UTF16 statement */ 
OCIStmt *stmthp; 
OCIDefine *defhp; 
OCIError *errhp; 
OCIEnvNlsCreate(OCIEnv **envhp, ..., OCI_UTF16ID, ncsid); 
... 
OCIStmtPrepare(stmthp, ..., selstmt, ...); /* prepare UTF16 statement */ 
OCIDefineByPos(stmthp, defnp, ..., 1, thename, sizeof(thename), SQLT_CHR,...); 
OCINlsEnvironmentVariableGet(&amp;hdlcsid, (size_t)0, OCI_NLS_CHARSET_ID, (ub2)0,
     (size_t*)NULL);
OCIAttrSet(defnp, ..., &amp;hdlcsid, 0, OCI_ATTR_CHARSET_ID, errhp); 
           /* change charset ID to NLS_LANG setting*/ 
...
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI72622"></a>
<div class="props_rev_3"><a id="GUID-59162D2A-A07D-4812-B9BE-3A9F23660E22"></a>
<h3 id="LNOCI-GUID-59162D2A-A07D-4812-B9BE-3A9F23660E22" class="sect3">About Binding Variables in OCI</h3>
<div>
<p>Update or insert operations are done through variable binding.</p>
<p>When binding variables, specify the <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> attribute and <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> attribute in the bind handle to indicate the byte and character constraints used when inserting data in to the Oracle database.</p>
<p>These attributes are defined as:</p>
<ul style="list-style-type: disc;">
<li>
<p>The <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> attribute sets the maximum number of bytes allowed in the buffer on the server side.</p>
</li>
<li>
<p>The <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> attribute sets the maximum number of characters allowed in the buffer on the server side.</p>
</li>
</ul>
<div class="p">This section includes these additional topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-2A4C92CD-74EF-4990-9786-C50E7E1B1DEA" title="Do not set OCI_ATTR_MAXDATA_SIZE for OUT binds or for PL/SQL binds. Only set OCI_ATTR_MAXDATA_SIZE for INSERT or UPDATE statements.">Buffer Expansion During OCI Binding</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-FAF088BA-9679-4F37-BF20-835ACFB1A0D4" title="To select data from columns into client buffers, OCI uses defined variables.">Constraint Checking During Defining</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-E1932F9D-9ADB-487F-A566-9C1AE05E66B8" title="Character-length semantics in OCI depends on the Oracle Database release, release 9.0 or later versus release 8.1 or earlier.">General Compatibility Issues for Character-Length Semantics in OCI</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-59162D2A-A07D-4812-B9BE-3A9F23660E22__GUID-293739F4-5441-4772-8FFB-B83B63EC6A29">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-AD86F080-F3A4-4D85-A20E-B81A4EF11B40">About Using the OCI_ATTR_MAXDATA_SIZE Attribute</a> for more information</p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A">About Using the OCI_ATTR_MAXCHAR_SIZE Attribute</a> for more information</p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16415"></a>
<div class="props_rev_3"><a id="GUID-AD86F080-F3A4-4D85-A20E-B81A4EF11B40"></a>
<h4 id="LNOCI-GUID-AD86F080-F3A4-4D85-A20E-B81A4EF11B40" class="sect4">About Using the OCI_ATTR_MAXDATA_SIZE Attribute</h4>
<div>
<p>Every bind handle has an <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> attribute that specifies the number of bytes allocated on the server to accommodate client-side bind data after character set conversions.</p>
<p>An application typically sets <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> to the maximum size of the column or the size of the PL/SQL variable, depending on how it is used. Oracle Database issues an error if <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> is not large enough to accommodate the data after conversion, and the operation fails.</p>
<p>For <code class="codeph">IN/INOUT</code> binds, when <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> attribute is set, the bind buffer must be large enough to hold the number of characters multiplied by the bytes in each character of the character set.</p>
<p>If <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> is set to a nonzero value such as 100, then if the character set has 2 bytes in each character, the minimum possible allocated size is 200 bytes.</p>
<p>The following scenarios demonstrate some uses of the <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> attribute:</p>
<ul style="list-style-type: disc;">
<li>
<p>Scenario 1: <code class="codeph">CHAR</code> (source data) converted to non-<code class="codeph">CHAR</code> (destination column)</p>
<p>There are implicit bind conversions of the data. The recommended value of <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> is the size of the source buffer multiplied by the worst-case expansion factor between the client and Oracle Database character sets.</p>
</li>
<li>
<p>Scenario 2: <code class="codeph">CHAR</code> (source data) converted to <code class="codeph">CHAR</code> (destination column) or non-<code class="codeph">CHAR</code> (source data) converted to <code class="codeph">CHAR</code> (destination column)</p>
<p>The recommended value of <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> is the size of the column.</p>
</li>
<li>
<p>Scenario 3: CHAR (source data) converted to a PL/SQL variable</p>
<p>In this case, the recommended value of <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> is the size of the PL/SQL variable.</p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16416"></a>
<div class="props_rev_3"><a id="GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A"></a>
<h4 id="LNOCI-GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A" class="sect4">About Using the OCI_ATTR_MAXCHAR_SIZE Attribute</h4>
<div>
<p><code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> enables processing to work with data in terms of number of characters, rather than number of bytes.</p>
<p>For binds, the <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> attribute sets the number of characters reserved in the Oracle database to store the bind data.</p>
<p>For example, if <span>OCI_ATTR_MAXDATA_SIZE</span> is set to 100, and <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> is set to 0, then the maximum possible size of the data in the Oracle database after conversion is 100 bytes. However, if <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> is set to 300, and <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> is set to a nonzero value, such as 100, then if the character set has 2 bytes/character, the maximum possible allocated size is 200 bytes.</p>
<p>For defines, the <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> attribute specifies the maximum number of characters that the client application allows in the return buffer. Its derived byte length overrides the <code class="codeph">maxlength</code> parameter specified in the <a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> call.</p>
<div class="infobox-note" id="GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A__GUID-A621EAE4-E909-40CB-B81F-D5E448DBDD1F">
<p class="notep1">Note:</p>
<p>Regardless of the value of the attribute <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>, the buffer lengths specified in a bind or define call are always in terms of bytes. The actual length values sent and received by you are also in bytes.</p>
</div>
</div>
</div>
<a id="LNOCI16417"></a>
<div class="props_rev_3"><a id="GUID-2A4C92CD-74EF-4990-9786-C50E7E1B1DEA"></a>
<h4 id="LNOCI-GUID-2A4C92CD-74EF-4990-9786-C50E7E1B1DEA" class="sect4">Buffer Expansion During OCI Binding</h4>
<div>
<p>Do not set <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> for <code class="codeph">OUT</code> binds or for PL/SQL binds. Only set <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> for <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> statements.</p>
<p>If neither of these two attributes is set, OCI expands the buffer using its best estimates.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-FC68A968-3B5F-4991-B676-3B8E3B78E177">IN Binds</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-32BB20E2-9229-4399-A60C-F3F88FF0F5DB">Dynamic SQL</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-56FF2C8E-8169-4FBE-B989-689B57F19555">Buffer Expansion During Inserts</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16418"></a>
<div class="props_rev_3"><a id="GUID-FC68A968-3B5F-4991-B676-3B8E3B78E177"></a>
<h5 id="LNOCI-GUID-FC68A968-3B5F-4991-B676-3B8E3B78E177" class="sect5">IN Binds</h5>
<div>
<p>For an <code class="codeph">IN</code> bind, if the underlying column was created using <a id="d67612e10604" class="indexterm-anchor"></a>character-length semantics, then it is preferable to specify the constraint using <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>. As long as the actual buffer contains fewer characters than specified in <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>, no constraints are violated at OCI level.</p>
<p>If the underlying column was created using byte-length semantics, then use <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> in the bind handle to specify the byte constraint on the server. If you also specify an <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> value, then this constraint is imposed when allocating the receiving buffer on the server side.</p>
</div>
</div>
<a id="LNOCI16419"></a>
<div class="props_rev_3"><a id="GUID-32BB20E2-9229-4399-A60C-F3F88FF0F5DB"></a>
<h5 id="LNOCI-GUID-32BB20E2-9229-4399-A60C-F3F88FF0F5DB" class="sect5">Dynamic SQL</h5>
<div>
<p>For dynamic SQL, you can use the explicit describe to get <code class="codeph">OCI_ATTR_DATA_SIZE</code> and <code class="codeph">OCI_ATTR_CHAR_SIZE</code> in parameter handles, as a guide for setting <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> and <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> attributes in bind handles. It is a good practice to specify <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> and <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> to be no more than the actual column width in bytes or characters.</p>
</div>
</div>
<a id="LNOCI16420"></a>
<div class="props_rev_3"><a id="GUID-56FF2C8E-8169-4FBE-B989-689B57F19555"></a>
<h5 id="LNOCI-GUID-56FF2C8E-8169-4FBE-B989-689B57F19555" class="sect5">Buffer Expansion During Inserts</h5>
<div>
<p>Use <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> to avoid unexpected behavior caused by buffer expansion during inserts.</p>
<p>Consider what happens when the database column has <a id="d67612e10944" class="indexterm-anchor"></a>character-length semantics, and the user tries to insert data using <a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> while setting only the <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> to 3000 bytes. The database character set is UTF8 and the client character set is ASCII. Then, in this case although 3000 characters fits in a buffer of size 3000 bytes for the client, on the server side it might expand to more than 4000 bytes. Unless the underlying column is a <code class="codeph">LONG</code> or a LOB type, the server returns an error. To avoid this problem specify the <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> to be 4000 to guarantee that the Oracle database never exceeds 4000 bytes.</p>
</div>
</div>
</div>
<a id="LNOCI16421"></a>
<div class="props_rev_3"><a id="GUID-FAF088BA-9679-4F37-BF20-835ACFB1A0D4"></a>
<h4 id="LNOCI-GUID-FAF088BA-9679-4F37-BF20-835ACFB1A0D4" class="sect4">Constraint Checking During Defining</h4>
<div>
<p>To select data from columns into client buffers, OCI uses defined variables.</p>
<p>You can set an <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> value on the define buffer to impose an additional character-length constraint. There is no <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> attribute for define handles because the buffer size in bytes serves as the limit on byte length. The define buffer size provided in the <code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code> call can be used as the byte constraint.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-9E12F114-E52B-4391-AEBF-5FDEE9FBD717">Dynamic SQL Selects</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9">Return Lengths</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-FAF088BA-9679-4F37-BF20-835ACFB1A0D4__GUID-E96B8E41-1A9C-48B7-8FD3-C1C58C1ACE7C">
<p class="notep1">See Also:</p>
<p><a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> or <a href="oci16rel003.htm#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="Associates an item in a select list with the type and output data buffer. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIDefineByPos2()</a></p>
</div>
</div>
<a id="LNOCI16422"></a>
<div class="props_rev_3"><a id="GUID-9E12F114-E52B-4391-AEBF-5FDEE9FBD717"></a>
<h5 id="LNOCI-GUID-9E12F114-E52B-4391-AEBF-5FDEE9FBD717" class="sect5">Dynamic SQL Selects</h5>
<div>
<p>When sizing buffers for dynamic SQL, always use the <code class="codeph">OCI_ATTR_DATA_SIZE</code> value in the implicit describe to avoid data loss through truncation. If the database column is created using <a id="d67612e11314" class="indexterm-anchor"></a>character-length semantics known through the <code class="codeph">OCI_ATTR_CHAR_USED</code> attribute, then you can use the <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> value to set an additional constraint on the define buffer. A maximum number of <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> characters is put in the buffer.</p>
</div>
</div>
<a id="LNOCI16423"></a>
<div class="props_rev_3"><a id="GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9"></a>
<h5 id="LNOCI-GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9" class="sect5">Return Lengths</h5>
<div>
<p>The following return length values are always in bytes regardless of the character-length semantics of the database:</p>
<ul style="list-style-type: disc;">
<li>
<p>The value returned in the <code class="codeph">alen</code>, or the actual length field in binds and defines</p>
</li>
<li>
<p>The value that appears in the length, prefixed in special data types such as <code class="codeph">VARCHAR</code> and <code class="codeph">LONG</code> <code class="codeph">VARCHAR</code></p>
</li>
<li>
<p>The value of the indicator variable in case of truncation</p>
</li>
</ul>
<p>The only exception to this rule is for string buffers in the <code class="codeph">OCI_UTF16ID</code> character set ID; then the return lengths are in UTF-16 units.</p>
<div class="infobox-note" id="GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9__GUID-912F8380-D006-42A7-B556-F64CE19063E8">
<p class="notep1">Note:</p>
<p>The buffer sizes in the bind and define calls and the piece sizes in the <a href="oci17msc001.htm#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="Returns piece information for a piecewise operation.">OCIStmtGetPieceInfo()</a> and <a href="oci17msc001.htm#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="Sets piece information for a piecewise operation.">OCIStmtSetPieceInfo()</a> and the callbacks are always in bytes.</p>
</div>
</div>
</div>
</div>
<a id="LNOCI16424"></a>
<div class="props_rev_3"><a id="GUID-E1932F9D-9ADB-487F-A566-9C1AE05E66B8"></a>
<h4 id="LNOCI-GUID-E1932F9D-9ADB-487F-A566-9C1AE05E66B8" class="sect4">General Compatibility Issues for Character-Length Semantics in OCI</h4>
<div>
<p>Character-length semantics in OCI depends on the Oracle Database release, release 9.0 or later versus release 8.1 or earlier.</p>
<ul style="list-style-type: disc;">
<li>
<p>For a release 9.0 or later client communicating with a release 8.1 or earlier Oracle Database, <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> is not known by the Oracle Database, so this value is ignored. If you specify only this value, OCI derives the corresponding <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> value based on the maximum number of bytes for each character for the client-side character set.</p>
</li>
<li>
<p>For a release 8.1 or earlier client communicating with a release 9.0 or later Oracle Database, the client can never specify an <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> value, so the Oracle Database considers the client as always expecting byte-length semantics. This is similar to the situation when the client specifies only <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>.</p>
</li>
</ul>
<p>So in both cases, the Oracle database and client can exchange information in an appropriate manner.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-2E152341-A00A-466E-82FE-1682449E6B53">Code Example for Inserting and Selecting Using OCI_ATTR_MAXCHAR_SIZE</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-D8C1F818-13E4-4695-8A84-CCE70A757076" title="The character set ID in bind and define of the CHAR or VARCHAR2, or in NCHAR or NVARCHAR2 variant handles can be set to assume that all data is passed in UTF-16 (Unicode) encoding. To specify UTF-16, set OCI_ATTR_CHARSET_ID = OCI_UTF16ID.">Code Example for UTF-16 Binding and Defining</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI72623"></a><a id="LNOCI16425"></a>
<div class="props_rev_3"><a id="GUID-2E152341-A00A-466E-82FE-1682449E6B53"></a>
<h5 id="LNOCI-GUID-2E152341-A00A-466E-82FE-1682449E6B53" class="sect5">Code Example for Inserting and Selecting Using OCI_ATTR_MAXCHAR_SIZE</h5>
<div>
<p>When a column is created by specifying a number <code class="codeph">N</code> of characters, the actual allocation in the database considers the worst case scenario, as shown in <a href="oci05bnd.htm#GUID-2E152341-A00A-466E-82FE-1682449E6B53__CIHICCAH">Example 5-19</a>. The real number of bytes allocated is a multiple of <code class="codeph">N</code>, say <code class="codeph">M</code> times <code class="codeph">N</code>. Currently, <code class="codeph">M</code> is 3 as the maximum number of bytes allocated for each character in UTF-8.</p>
<p>For example, in <a href="oci05bnd.htm#GUID-2E152341-A00A-466E-82FE-1682449E6B53__CIHICCAH">Example 5-19</a>, in the <code class="codeph">EMP</code> table, the <code class="codeph">ENAME</code> column is defined as 30 characters and the <code class="codeph">ADDRESS</code> column is defined as 80 characters. Thus, the corresponding byte lengths in the database are M*30 or 3*30=90, and M*80 or 3*80=240, respectively.</p>
<div class="example" id="GUID-2E152341-A00A-466E-82FE-1682449E6B53__CIHICCAH">
<p class="titleinexample">Example 5-19 Insert and Select Operations Using the OCI_ATTR_MAXCHAR_SIZE Attribute</p>
<pre dir="ltr">...
utext ename[31], address[81];
/* E&#39; &lt;= 30+ 1, D&#39; &lt;= 80+ 1, considering null-termination */
sb4 ename_max_chars = EC=20, address_max_chars = ED=60;
 /* EC &lt;= (E&#39; - 1), ED &lt;= (D&#39; - 1) */
sb4 ename_max_bytes = EB=80, address_max_bytes = DB=200;
 /* EB &lt;= M * EC, DB &lt;= M * DC */
text *insstmt = (text *)&#34;INSERT INTO EMP(ENAME, ADDRESS) VALUES (:ENAME, \
:ADDRESS)&#34;;
text *selstmt = (text *)&#34;SELECT ENAME, ADDRESS FROM EMP&#34;;
...
/* Inserting Column Data */
OCIStmtPrepare(stmthp1, errhp, insstmt, (ub4)strlen((char *)insstmt),
    (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (text *)&#34;:ENAME&#34;,
    (sb4)strlen((char *)&#34;:ENAME&#34;),
    (void *)ename, sizeof(ename), SQLT_STR, (void *)&amp;insname_ind,
    (ub2 *)alenp, (ub2 *)rcodep, (ub4)maxarr_len, (ub4 *)curelep, OCI_DEFAULT);
/* either */
OCIAttrSet((void *)bnd1p, (ub4)OCI_HTYPE_BIND, (void *)&amp;ename_max_bytes,
    (ub4)0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp);
/* or */
OCIAttrSet((void *)bnd1p, (ub4)OCI_HTYPE_BIND, (void *)&amp;ename_max_chars,
    (ub4)0, (ub4)OCI_ATTR_MAXCHAR_SIZE, errhp);
...
/* Retrieving Column Data */
OCIStmtPrepare(stmthp2, errhp, selstmt, strlen((char *)selstmt),
    (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
OCIDefineByPos(stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
   (sb4)sizeof (ename),
   SQLT_STR, (void *)&amp;selname_ind, (ub2 *)alenp, (ub2 *)rcodep,
   (ub4)OCI_DEFAULT);
/* if not called, byte semantics is by default */
OCIAttrSet((void *)dfn1p, (ub4)OCI_HTYPE_DEFINE, (void *)&amp;ename_max_chars,
   (ub4)0,
   (ub4)OCI_ATTR_MAXCHAR_SIZE, errhp);
...
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI72624"></a><a id="LNOCI16426"></a>
<div class="props_rev_3"><a id="GUID-D8C1F818-13E4-4695-8A84-CCE70A757076"></a>
<h5 id="LNOCI-GUID-D8C1F818-13E4-4695-8A84-CCE70A757076" class="sect5">Code Example for UTF-16 Binding and Defining</h5>
<div>
<p>The character set ID in bind and define of the <code class="codeph">CHAR</code> or <code class="codeph">VARCHAR2</code>, or in <code class="codeph">NCHAR</code> or <code class="codeph">NVARCHAR2</code> variant handles can be set to assume that all data is passed in UTF-16 (Unicode) encoding. To specify UTF-16, set <code class="codeph">OCI_ATTR_CHARSET_ID</code> = <code class="codeph">OCI_UTF16ID</code>.</p>
<p>OCI provides a typedef called <code class="codeph">utext</code> to facilitate binding and defining of UTF-16 data. The internal representation of <code class="codeph">utext</code> is a 16-bit unsigned integer, <code class="codeph">ub2</code>. Operating systems where the encoding scheme of the <code class="codeph">wchar_t</code> data type conforms to UTF-16 can easily convert <code class="codeph">utext</code> to the <code class="codeph">wchar_t</code> data type using cast operators.</p>
<p>Even for UTF-16 data, the buffer size in bind and define calls is assumed to be in bytes. Users should use the <code class="codeph">utext</code> data type as the buffer for input and output data.</p>
<p><a href="oci05bnd.htm#GUID-D8C1F818-13E4-4695-8A84-CCE70A757076__CIHDCJAF">Example 5-20</a> shows pseudocode that illustrates a bind and define for UTF-16 data.</p>
<div class="example" id="GUID-D8C1F818-13E4-4695-8A84-CCE70A757076__CIHDCJAF">
<p class="titleinexample">Example 5-20 Binding and Defining UTF-16 Data</p>
<pre dir="ltr">...
OCIStmt  *stmthp1, *stmthp2;
OCIDefine *dfn1p, *dfn2p;
OCIBind *bnd1p, *bnd2p;
text *insstmt=
      (text *) &#34;INSERT INTO EMP(ENAME, ADDRESS) VALUES (:ename, :address)&#34;; \
text *selname =
      (text *) &#34;SELECT ENAME, ADDRESS FROM EMP&#34;;
utext ename[21];   /* Name -    UTF-16 */
utext address[51]; /* Address - UTF-16 */
ub2 csid = OCI_UTF16ID;
sb4 ename_col_len = 20;
sb4 address_col_len = 50;
...
/* Inserting UTF-16 data */
OCIStmtPrepare (stmthp1, errhp, insstmt, (ub4)strlen ((char *)insstmt),
                (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
OCIBindByName (stmthp1, &amp;bnd1p, errhp, (text*)&#34;:ENAME&#34;,
              (sb4)strlen((char *)&#34;:ENAME&#34;),
              (void *) ename, sizeof(ename), SQLT_STR,
              (void *)&amp;insname_ind, (ub2 *) 0, (ub2 *) 0, (ub4) 0,
              (ub4 *)0, OCI_DEFAULT);
OCIAttrSet ((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;csid,
           (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp);
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp);
...
/* Retrieving UTF-16 data */
OCIStmtPrepare (stmthp2, errhp, selname, strlen((char *) selname),
                (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
                (sb4)sizeof(ename), SQLT_STR,
                (void *)0, (ub2 *)0, (ub2 *)0, (ub4)OCI_DEFAULT);
OCIAttrSet ((void *) dfn1p, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;csid,
            (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp);
...
</pre>
<div class="infoboxnotealso" id="GUID-D8C1F818-13E4-4695-8A84-CCE70A757076__GUID-667CCB29-4741-48BE-8E53-FC0EC1D48C83">
<p class="notep1">See Also:</p>
<p><a href="ociaahan.htm#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="Lists and describes bind handle attributes.">Bind Handle Attributes</a></p>
</div>
</div>
<!-- class="example" --></div>
</div>
</div>
</div>
</div>
<a id="LNOCI72625"></a><a id="LNOCI72626"></a><a id="LNOCI16427"></a>
<div class="props_rev_3"><a id="GUID-5495CEEB-17D0-4185-8879-3356A21E7888"></a>
<h2 id="LNOCI-GUID-5495CEEB-17D0-4185-8879-3356A21E7888" class="sect2">PL/SQL REF CURSORs and Nested Tables in OCI</h2>
<div>
<p>OCI provides the ability to bind and define PL/SQL <code class="codeph">REF</code> <code class="codeph">CURSOR</code>s and nested tables. An application can use a statement handle to bind and define these types of variables. As an example, consider this PL/SQL block:</p>
<pre dir="ltr">static const text *plsql_block = (text *)
  &#34;begin \
     OPEN :cursor1 FOR SELECT employee_id, last_name, job_id, manager_id, \
             salary, department_id \
             FROM employees WHERE job_id=:job ORDER BY employee_id; \
     OPEN :cursor2 FOR SELECT * FROM departments ORDER BY department_id;
  end;&#34;;
</pre>
<p>An application allocates a statement handle for binding by calling <a href="oci16rel002.htm#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a>, and then binds the <code class="codeph">:cursor1</code> placeholder to the statement handle, as in the following code, where <code class="codeph">:cursor1</code> is bound to <code class="codeph">stm2p</code>.</p>
<p>In this code in <a href="oci05bnd.htm#GUID-5495CEEB-17D0-4185-8879-3356A21E7888__CIHGGCFF">Example 5-21</a>, <code class="codeph">stm1p</code> is the statement handle for the PL/SQL block, whereas <code class="codeph">stm2p</code> is the statement handle that is bound as a <code class="codeph">REF</code> <code class="codeph">CURSOR</code> for later data retrieval. A value of <code class="codeph">SQLT_RSET</code> is passed for the <code class="codeph">dty</code> parameter.</p>
<p>As another example, consider the following:</p>
<pre dir="ltr">static const text *nst_tab = (text *)
       &#34;SELECT last_name, CURSOR(SELECT department_name, location_id \
        FROM  departments)  FROM employees WHERE last_name = &#39;FORD&#39;&#34;;
</pre>
<p>The second position is a nested table, which an OCI application can define as a statement handle shown in <a href="oci05bnd.htm#GUID-5495CEEB-17D0-4185-8879-3356A21E7888__CIHDFFHJ">Example 5-22</a>.</p>
<p>After execution, when you fetch a row into <code class="codeph">stm2p</code> it becomes a valid statement handle.</p>
<div class="infobox-note" id="GUID-5495CEEB-17D0-4185-8879-3356A21E7888__GUID-14683F15-E832-4F02-8A31-BF6F8D29AA56">
<p class="notep1">Note:</p>
<p>If you have retrieved multiple <code class="codeph">REF</code> <code class="codeph">CURSOR</code>s, you must take care when fetching them into <code class="codeph">stm2p</code>. If you fetch the first one, you can then perform fetches on it to retrieve its data. However, after you fetch the second <code class="codeph">REF</code> <code class="codeph">CURSOR</code> into <code class="codeph">stm2p</code>, you no longer have access to the data from the first <code class="codeph">REF</code> <code class="codeph">CURSOR</code>.</p>
<p>OCI does not support PL/SQL <code class="codeph">REF</code> <code class="codeph">CURSOR</code>s that were executed in scrollable mode.</p>
<p>OCI does not support scrollable <code class="codeph">REF</code> <code class="codeph">CURSOR</code>s because you cannot scroll back to the rows already fetched by a <code class="codeph">REF</code> <code class="codeph">CURSOR</code>.</p>
</div>
<div class="example" id="GUID-5495CEEB-17D0-4185-8879-3356A21E7888__CIHGGCFF">
<p class="titleinexample">Example 5-21 Binding the :cursor1 Placeholder to the Statement Handle stm2p as a REF CURSOR</p>
<pre dir="ltr">status = OCIStmtPrepare (stm1p, errhp, (text *) plsql_block,
             strlen((char *)plsql_block), OCI_NTV_SYNTAX, OCI_DEFAULT);
...
status = OCIBindByName (stm1p, (OCIBind **) &amp;bnd1p, errhp,
             (text *)&#34;:cursor1&#34;, (sb4)strlen((char *)&#34;:cursor1&#34;),
             (void *)&amp;stm2p, (sb4) 0,  SQLT_RSET, (void *)0,
               (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0,   (ub4)OCI_DEFAULT);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5495CEEB-17D0-4185-8879-3356A21E7888__CIHDFFHJ">
<p class="titleinexample">Example 5-22 Defining a Nested Table (Second Position) as a Statement Handle</p>
<pre dir="ltr">status = OCIStmtPrepare (stm1p, errhp, (text *) nst_tab, 
         strlen((char *)nst_tab), OCI_NTV_SYNTAX, OCI_DEFAULT);
...
status = OCIDefineByPos (stm1p, (OCIDefine **) &amp;dfn2p, errhp, (ub4)2, 
          (void *)&amp;stm2p, (sb4)0, SQLT_RSET, (void *)0, (ub2 *)0,
                     (ub2 *)0, (ub4)OCI_DEFAULT);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNOCI73038"></a>
<div class="props_rev_3"><a id="GUID-9DEC9ACB-BC16-4F4C-8EC6-E43EC47EF9CB"></a>
<h2 id="LNOCI-GUID-9DEC9ACB-BC16-4F4C-8EC6-E43EC47EF9CB" class="sect2">Natively Describe and Bind All PL/SQL Types Including Package Types</h2>
<div>
<p>Beginning with Oracle Database Release 12.1, OCI clients support the ability to natively describe and bind all PL/SQL types. This includes the base scalar type Boolean, which was previously unsupported as a bind type. This also includes types declared in PL/SQL packages, such as named record or collection type (including nested table, varray and index table) or implicit record subtype (%rowtype) declared inside of a PL/SQL package specification. Native support for these features means clients can describe and bind PL/SQL types using only the provided client-side APIs.</p>
<p>The PL/SQL typecodes for these data types (Boolean, record, index-by <code class="codeph">BINARY_INTEGER</code>, and <code class="codeph">PLS_INTEGER</code> or <code class="codeph">BINARY_INTEGER</code>) are listed in <a href="oci03typ.htm#GUID-65066795-6F95-44AE-A454-31CF70A46A1F__G454481" title="This table has 2 columns. Column 1 is Value and column 2 is its corresponding data type.">Table 3-10</a>. The equivalent <code class="codeph">SQLT</code> type for these PL/SQL typecodes is listed in <a href="oci03typ.htm#GUID-DCC693D9-23D7-4727-9A71-E5FCDABA7136__G454572" title="This table has 3 columns. Column 1 is Oracle type system tymename, column 2 is Oracle type system type, and column 3 is the equivalent SQLT type.">Table 3-11</a>. Clients must bind the specified type using the respective specified value of <code class="codeph">SQLT</code> type as the DTY of the bind. For example, for records, clients must bind package record types (<code class="codeph">OCI_TYPECODE_RECORD</code>) using <code class="codeph">SQLT_NTY</code> as the DTY of the bind; for collections, clients must bind all package collection types (<code class="codeph">OCI_TYPECODE_ITABLE</code>) using <code class="codeph">SQLT_NTY</code> as the DTY of the bind; and for Booleans, clients must bind Boolean types (<code class="codeph">OCI_TYPECODE_BOOLEAN</code>) using <code class="codeph">SQLT_BOL</code> as the DTY of the bind. Bind APIs: <a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a>, <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a>, <a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a>, and <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a> support each <code class="codeph">SQLT</code> type value in the DTY of the bind that represents these PL/SQL typecodes.</p>
</div>
</div>
<a id="LNOCI059"></a>
<div class="props_rev_3"><a id="GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558"></a>
<h2 id="LNOCI-GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" class="sect2">Runtime Data Allocation and Piecewise Operations in OCI</h2>
<div>
<p>You can use OCI to perform piecewise inserts, updates, and fetches of data.</p>
<p>You can also use OCI to provide data dynamically in case of array inserts or updates, instead of providing a static array of bind values. You can insert or retrieve a very large column as a series of chunks of smaller size, minimizing client-side memory requirements.</p>
<p>The size of individual pieces is determined at run time by the application and can be uniform or not.</p>
<p>The piecewise functionality of OCI is particularly useful when performing operations on extremely large blocks of string or binary data, operations involving database columns that store <code class="codeph">CLOB</code>, <code class="codeph">BLOB</code>, <code class="codeph">LONG</code>, <code class="codeph">RAW</code>, or <code class="codeph">LONG</code> <code class="codeph">RAW</code> data.</p>
<p>The piecewise fetch is complete when the final <code class="codeph">OCIStmtFetch2()</code> call returns a value of OCI_SUCCESS.</p>
<p>In both the piecewise fetch and insert, it is important to understand the sequence of calls necessary for the operation to complete successfully. For a piecewise insert, you must call <code class="codeph">OCIStmtExecute()</code> one time more than the number of pieces to be inserted (if callbacks are not used). This is because the first time <code class="codeph">OCIStmtExecute()</code> is called, it returns a value indicating that the first piece to be inserted is required. As a result, if you are inserting <span class="italic">n</span> pieces, you must call <code class="codeph">OCIStmtExecute()</code> a total of <span class="italic">n+1</span> times.</p>
<p>Similarly, when performing a piecewise fetch, you must call <code class="codeph">OCIStmtFetch2()</code> once more than the number of pieces to be fetched.</p>
<div class="p">This section includes the following topics:
<ul style="list-style-type: disc;">
<li>
<p><a href="oci05bnd.htm#GUID-DF7EC112-B81D-4B69-885D-5C5A59FB08D7">Valid Data Types for Piecewise Operations</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-0A316448-D51E-4BC6-B7DB-747D596D4783">Types of Piecewise Operations</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-0C9C1F54-E65C-442F-9BD6-67D14124EBF5" title="When you specify the OCI_DATA_AT_EXEC mode in a call to OCIBindByPos() or OCIBindByPos2() or OCIBindByName() or OCIBindByName2(), the value_sz parameter defines the total size of the data that can be provided at run time.">About Providing INSERT or UPDATE Data at Runtime</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-A18B68AC-7731-4826-9EFC-3C750C19B759">Piecewise Operations with PL/SQL</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-9603C427-3A19-4607-A62E-0AD06621CC17" title="PL/SQL indexed tables can be passed as IN/OUT binds into PL/SQL anonymous blocks using OCI.">PL/SQL Indexed Table Binding Support</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-25BBA0D1-689D-40FD-86E1-A10D02A3E4BB" title="When a call is made to OCIDefineByPos() or OCIDefineByPos2() with the mode parameter set to OCI_DYNAMIC_FETCH, an application can specify information about the data buffer at the time of fetch.">About Providing FETCH Information at Run Time</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-9E60B14E-920F-42E6-904D-36BAF20FDA3D" title="What are the ways of doing piecewise binds and defines for LOBs.">Piecewise Binds and Defines for LOBs</a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso" id="GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558__GUID-F9DBFA97-221D-484F-B2EE-8157E43B3622">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci17msc001.htm#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="Fetches a row from the (scrollable) result set.">OCIStmtFetch2()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16428"></a>
<div class="props_rev_3"><a id="GUID-DF7EC112-B81D-4B69-885D-5C5A59FB08D7"></a>
<h3 id="LNOCI-GUID-DF7EC112-B81D-4B69-885D-5C5A59FB08D7" class="sect3">Valid Data Types for Piecewise Operations</h3>
<div>
<p>Only some data types can be manipulated in pieces. OCI applications can perform piecewise fetches, inserts, or updates of all the following data types:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">VARCHAR2</code></p>
</li>
<li>
<p><code class="codeph">STRING</code></p>
</li>
<li>
<p><code class="codeph">LONG</code></p>
</li>
<li>
<p><code class="codeph">LONG</code> <code class="codeph">RAW</code></p>
</li>
<li>
<p><code class="codeph">RAW</code></p>
</li>
<li>
<p><code class="codeph">CLOB</code></p>
</li>
<li>
<p><code class="codeph">BLOB</code></p>
</li>
</ul>
<p>Another way of using this feature for all data types is to provide data dynamically for array inserts or updates. The callbacks should always specify <code class="codeph">OCI_ONE_PIECE</code> for the <code class="codeph">piecep</code> parameter of the callback for data types that do not support piecewise operations.</p>
</div>
</div>
<a id="LNOCI16429"></a>
<div class="props_rev_3"><a id="GUID-0A316448-D51E-4BC6-B7DB-747D596D4783"></a>
<h3 id="LNOCI-GUID-0A316448-D51E-4BC6-B7DB-747D596D4783" class="sect3">Types of Piecewise Operations</h3>
<div>
<p>You can perform piecewise operations in two ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>Use calls provided in the OCI library to execute piecewise operations under a polling paradigm.</p>
</li>
<li>
<p>Employ user-defined callback functions to provide the necessary information and data blocks.</p>
</li>
</ul>
<p>When you set the <code class="codeph">mode</code> parameter of an <a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> call to <code class="codeph">OCI_DATA_AT_EXEC</code>, it indicates that an OCI application is providing data for an <code class="codeph">INSERT</code> or <code class="codeph">UPDATE</code> operation dynamically at runtime.</p>
<p>Similarly, when you set the <code class="codeph">mode</code> parameter of an <a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> call to <code class="codeph">OCI_DYNAMIC_FETCH</code>, it indicates that an application dynamically provides allocation space for receiving data at the time of the fetch.</p>
<p>In each case, you can provide the runtime information for the <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">FETCH</code> operation in one of two ways: through callback functions, or by using piecewise operations. If callbacks are desired, an additional bind or define call is necessary to register the callbacks.</p>
<p>The following sections give specific information about runtime data allocation and piecewise operations for inserts, updates, and fetches.</p>
<div class="infobox-note" id="GUID-0A316448-D51E-4BC6-B7DB-747D596D4783__GUID-7E8A166F-2100-4EE4-A8CC-90C892CA29D2">
<p class="notep1">Note:</p>
<p>Piecewise operations are also valid for SQL and PL/SQL blocks.</p>
</div>
</div>
</div>
<a id="LNOCI16430"></a>
<div class="props_rev_3"><a id="GUID-0C9C1F54-E65C-442F-9BD6-67D14124EBF5"></a>
<h3 id="LNOCI-GUID-0C9C1F54-E65C-442F-9BD6-67D14124EBF5" class="sect3">About Providing INSERT or UPDATE Data at Runtime</h3>
<div>
<p>When you specify the <code class="codeph">OCI_DATA_AT_EXEC</code> mode in a call to <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code> or <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code>, the <code class="codeph">value_sz</code> parameter defines the total size of the data that can be provided at run time.</p>
<p>The application must be ready to provide to the OCI library the run time <code class="codeph">IN</code> data buffers on demand as many times as is necessary to complete the operation. When the allocated buffers are no longer required, they must be freed by the client.</p>
<p>Runtime data is provided in one of two ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>You can define a callback using the <code class="codeph">OCIBindDynamic()</code> function, which when called at run time returns either a piece of the data or all of it.</p>
</li>
<li>
<p>If no callbacks are defined, the call to <code class="codeph">OCIStmtExecute()</code> to process the SQL statement returns the <code class="codeph">OCI_NEED_DATA</code> error code. The client application then provides the <code class="codeph">IN/OUT</code> data buffer or piece using the <code class="codeph">OCIStmtSetPieceInfo()</code> call that specifies which bind and piece are being used.</p>
</li>
</ul>
<p>This section includes the following topic: <a href="oci05bnd.htm#GUID-7673D7A7-C691-451B-8DDE-D21437BFA751" title="Once the OCI environment has been initialized, and a database connection and session have been established, a piecewise insert begins with calls to prepare a SQL or PL/SQL statement and to bind input values.">Performing a Piecewise Insert or Update</a>.</p>
<div class="infoboxnotealso" id="GUID-0C9C1F54-E65C-442F-9BD6-67D14124EBF5__GUID-DA1593BC-F35F-41AD-BDF9-CF8EB6947293">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="Sets piece information for a piecewise operation.">OCIStmtSetPieceInfo()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16432"></a><a id="LNOCI16431"></a>
<div class="props_rev_3"><a id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751"></a>
<h4 id="LNOCI-GUID-7673D7A7-C691-451B-8DDE-D21437BFA751" class="sect4">Performing a Piecewise Insert or Update</h4>
<div>
<p>Once the OCI environment has been initialized, and a database connection and session have been established, a piecewise insert begins with calls to prepare a SQL or PL/SQL statement and to bind input values.</p>
<div class="section">
<p>Piecewise operations using standard OCI calls rather than user-defined callbacks do not require a call to <code class="codeph">OCIBindDynamic()</code>.</p>
<div class="infobox-note" id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__GUID-FB5C166F-ECC1-4CB4-A05F-3E2BB26A3C32">
<p class="notep1">Note:</p>
<p>Additional bind variables that are not part of piecewise operations may require additional bind calls, depending on their data types.</p>
</div>
<p>Following the statement preparation and bind, the application performs a series of calls to <code class="codeph">OCIStmtExecute()</code>, <code class="codeph">OCIStmtGetPieceInfo()</code>, and <code class="codeph">OCIStmtSetPieceInfo()</code> to complete the piecewise operation. Each call to <code class="codeph">OCIStmtExecute()</code> returns a value that determines what action should be performed next. In general, the application retrieves a value indicating that the next piece must be inserted, populates a buffer with that piece, and then executes an insert. When the last piece has been inserted, the operation is complete.</p>
<p>Keep in mind that the insert buffer can be of arbitrary size and is provided at run time. In addition, each inserted piece does not need to be of the same size. The size of each piece to be inserted is established by each <code class="codeph">OCIStmtSetPieceInfo()</code> call.</p>
<div class="infobox-note" id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__GUID-82F9AB65-3A54-427A-A9EC-4BBB425083C2">
<p class="notep1">Note:</p>
<p>If the same piece size is used for all inserts, and the size of the data being inserted is not evenly divisible by the piece size, the final inserted piece is expected to be smaller. You must account for this by indicating the smaller size in the final <code class="codeph">OCIStmtSetPieceInfo()</code> call.</p>
</div>
<p>The procedure is illustrated in <a href="oci05bnd.htm#GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__I440828">Figure 5-3</a> and expanded in the steps following the figure.</p>
<div class="figure" id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__I440828">
<p class="titleinfigure">Figure 5-3 Performing Piecewise Insert</p>
<img width="539" height="244" src="img/GUID-962A0E95-0CAF-41B9-95AA-C0A359CD62FA-default.gif" alt="Description of Figure 5-3 follows" title="Description of Figure 5-3 follows"/><br/>
<a href="img_text/GUID-962A0E95-0CAF-41B9-95AA-C0A359CD62FA-print.htm">Description of &#34;Figure 5-3 Performing Piecewise Insert&#34;</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Initialize the OCI environment, allocate the necessary handles, connect to a server, authorize a user, and prepare a statement request by using <code class="codeph">OCIStmtPrepare2()</code>.</span></li>
<li class="stepexpand"><span>Bind a placeholder by using <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code>. You do not need to specify the actual size of the pieces you use, but you must provide the total size of the data that can be provided at run time.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIStmtExecute()</code> for the first time. No data is being inserted here, and the <code class="codeph">OCI_NEED_DATA</code> error code is returned to the application. If any other value is returned, it indicates that an error occurred.</span></li>
<li class="stepexpand"><span>Call <code class="codeph">OCIStmtGetPieceInfo()</code> to retrieve information about the piece that must be inserted. The parameters of <code class="codeph">OCIStmtGetPieceInfo()</code> include a pointer to a value indicating if the required piece is the first piece, <code class="codeph">OCI_FIRST_PIECE</code>, or a subsequent piece, <code class="codeph">OCI_NEXT_PIECE</code>.</span></li>
<li class="stepexpand"><span>The application populates a buffer with the piece of data to be inserted and calls <code class="codeph">OCIStmtSetPieceInfo()</code> with these parameters:</span>
<div>
<ul style="list-style-type: disc;">
<li>
<p>A pointer to the piece</p>
</li>
<li>
<p>A pointer to the length of the piece</p>
</li>
<li>
<p>A value indicating whether this is the first piece (<code class="codeph">OCI_FIRST_PIECE</code>), an intermediate piece (<code class="codeph">OCI_NEXT_PIECE</code>), or the last piece (<code class="codeph">OCI_LAST_PIECE</code>)</p>
</li>
</ul>
</div>
</li>
<li class="stepexpand"><span>Call <code class="codeph">OCIStmtExecute()</code> again. If <code class="codeph">OCI_LAST_PIECE</code> was indicated in Step 5 and <code class="codeph">OCIStmtExecute()</code> returns <code class="codeph">OCI_SUCCESS</code>, all pieces were inserted successfully. If <code class="codeph">OCIStmtExecute()</code> returns <code class="codeph">OCI_NEED_DATA</code>, go back to Step 3 for the next insert. If <code class="codeph">OCIStmtExecute()</code> returns any other value, an error occurred.</span></li>
</ol>
<div class="section">
<p>The piecewise operation is complete when the final piece has been successfully inserted. This is indicated by the <code class="codeph">OCI_SUCCESS</code> return value from the final <code class="codeph">OCIStmtExecute()</code> call.</p>
<p>Piecewise updates are performed in a similar manner. In a piecewise update operation the insert buffer is populated with data that is being updated, and <code class="codeph">OCIStmtExecute()</code> is called to execute the update.</p>
<div class="infoboxnotealso" id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__GUID-D40FD163-2463-402E-AD53-13C7FA0104F3">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci02bas.htm#GUID-83F4D3B1-56A7-4EEE-A905-BB84D399713D">Polling Mode Operations in OCI</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="Returns piece information for a piecewise operation.">OCIStmtGetPieceInfo()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="Sets piece information for a piecewise operation.">OCIStmtSetPieceInfo()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="Prepares a SQL or PL/SQL statement for execution.">OCIStmtPrepare2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="LNOCI16433"></a>
<div class="props_rev_3"><a id="GUID-A18B68AC-7731-4826-9EFC-3C750C19B759"></a>
<h3 id="LNOCI-GUID-A18B68AC-7731-4826-9EFC-3C750C19B759" class="sect3">Piecewise Operations with PL/SQL</h3>
<div>
<p>An OCI application can perform piecewise operations with PL/SQL for <code class="codeph">IN</code>, <code class="codeph">OUT</code>, and <code class="codeph">IN/OUT</code> bind variables in a method similar to that outlined previously. Keep in mind that all placeholders in PL/SQL statements are bound, rather than defined. The call to <a href="oci16rel003.htm#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="Registers user callbacks for dynamic data allocation.">OCIBindDynamic()</a> specifies the appropriate callbacks for <code class="codeph">OUT</code> or <code class="codeph">IN/OUT</code> parameters.</p>
</div>
</div>
<a id="LNOCI72627"></a>
<div class="props_rev_3"><a id="GUID-9603C427-3A19-4607-A62E-0AD06621CC17"></a>
<h3 id="LNOCI-GUID-9603C427-3A19-4607-A62E-0AD06621CC17" class="sect3">PL/SQL Indexed Table Binding Support</h3>
<div>
<p>PL/SQL indexed tables can be passed as <code class="codeph">IN/OUT</code> binds into PL/SQL anonymous blocks using OCI.</p>
<p>The procedure for binding PL/SQL indexed tables is quite similar to performing an array bind for SQL statements. The OCI program must bind the location of an array with other metadata for the array as follows, using either <code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code> or <code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code>. The process of binding a C array into a PL/SQL indexed table bind variable must provide the following information during the bind call:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">void *valuep (IN/OUT)</code> - A pointer to a location that specifies the beginning of the array in client memory</p>
</li>
<li>
<p><code class="codeph">ub2 dty (IN)</code> - The data type of the elements of the array as represented on the client</p>
</li>
<li>
<p><code class="codeph">sb4 value_sz (IN)</code> - The maximum size (in bytes) of each element of the array as represented on the client</p>
</li>
<li>
<p><code class="codeph">ub4 maxarr_len (IN)</code> - The maximum number of elements of the data type the array is expected to hold in its lifetime</p>
<p>If allocating the entire array up front for doing static bindings, the array must be sized sufficiently to contain <code class="codeph">maxarr_len</code> number of elements, each of size <code class="codeph">value_sz</code>. This information is also used to constrain the indexed table as seen by PL/SQL. PL/SQL cannot look up the indexed table (either for read or write) beyond this specified limit.</p>
</li>
<li>
<p><code class="codeph">ub4 *curelep (IN/OUT)</code> - A pointer to the number of elements in the array (from the beginning of the array) that are currently valid.</p>
<p>This should be less than or equal to the maximum array length. Note that this information is also used to constrain the indexed table as seen by PL/SQL. For <code class="codeph">IN</code> binds, PL/SQL cannot read from the indexed table beyond this specified limit. For <code class="codeph">OUT</code> binds, PL/SQL can write to the indexed table beyond this limit, but not beyond the <code class="codeph">maxarr_len</code> limit.</p>
</li>
</ul>
<p>For <code class="codeph">IN</code> indexed table binds, before performing <code class="codeph">OCIStmtExecute()</code>, the user must set up the current array length (<code class="codeph">*curelep</code>) for that execution. In addition, the user also must set up the actual length and indicator as applicable for each element of the array.</p>
<p>For <code class="codeph">OUT</code> binds, OCI must return the current array length (<code class="codeph">*curelep</code>) and the actual length, indicator and return code as applicable for each element of the array.</p>
<p>For best performance, keep the array allocated with maximum array length, and then vary the current array length between executes based on how many elements are actually being passed back and forth. Such an approach does not require repeatedly deallocating and reallocating the array for every execute, thereby helping overall application performance.</p>
<p>It is also possible to bind using OCI piecewise calls for PL/SQL indexed tables. Such an approach does not require preallocating the entire array up front. The <code class="codeph">OCIStmtSetPieceInfo()</code> and <code class="codeph">OCIStmtGetPieceInfo()</code> calls can be used to pass in individual elements piecewise.</p>
<p>This section includes the following topic: <a href="oci05bnd.htm#GUID-07228A70-6E2C-442D-A563-E246EF5B4926" title="What are the restrictions for the PL/SQL indexed table OCI binding interface.">Restrictions for PL/SQL Indexed Table Binding Interface</a>.</p>
<div class="infoboxnotealso" id="GUID-9603C427-3A19-4607-A62E-0AD06621CC17__GUID-4BCD4485-C039-4ED5-A2EE-84D44B172A9E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="Sets piece information for a piecewise operation.">OCIStmtSetPieceInfo()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="Returns piece information for a piecewise operation.">OCIStmtGetPieceInfo()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI72628"></a>
<div class="props_rev_3"><a id="GUID-07228A70-6E2C-442D-A563-E246EF5B4926"></a>
<h4 id="LNOCI-GUID-07228A70-6E2C-442D-A563-E246EF5B4926" class="sect4">Restrictions for PL/SQL Indexed Table Binding Interface</h4>
<div>
<p>What are the restrictions for the PL/SQL indexed table OCI binding interface.</p>
<p>The PL/SQL indexed table OCI binding interface does not support binding:</p>
<ul style="list-style-type: disc;">
<li>
<p>Arrays of ADTs or <code class="codeph">REF</code>s</p>
</li>
<li>
<p>Arrays of descriptor types such as LOB descriptors, ROWID descriptors, datetime or interval descriptors</p>
</li>
<li>
<p>Arrays of PLSQL record types</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNOCI16434"></a>
<div class="props_rev_3"><a id="GUID-25BBA0D1-689D-40FD-86E1-A10D02A3E4BB"></a>
<h3 id="LNOCI-GUID-25BBA0D1-689D-40FD-86E1-A10D02A3E4BB" class="sect3">About Providing FETCH Information at Run Time</h3>
<div>
<p>When a call is made to <code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code> with the <code class="codeph">mode</code> parameter set to <code class="codeph">OCI_DYNAMIC_FETCH</code>, an application can specify information about the data buffer at the time of fetch.</p>
<p>You may also need to call <code class="codeph">OCIDefineDynamic()</code> to set a callback function that is invoked to get information about your data buffer.</p>
<p>Runtime data is provided in one of two ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>You can define a callback using the <code class="codeph">OCIDefineDynamic()</code> function. The <code class="codeph">value_sz</code> parameter defines the maximum size of the data that is provided at run time. When the client library needs a buffer to return the fetched data, the callback is invoked to provide a runtime buffer into which either a piece of the data or all of it is returned.</p>
</li>
<li>
<p>If no callbacks are defined, the <code class="codeph">OCI_NEED_DATA</code> error code is returned and the <code class="codeph">OUT</code> data buffer or piece can then be provided by the client application by using <code class="codeph">OCIStmtSetPieceInfo()</code>. The <code class="codeph">OCIStmtGetPieceInfo()</code> call provides information about which define and which piece are involved.</p>
</li>
</ul>
<p>This section includes the following topic: <a href="oci05bnd.htm#GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11" title="The fetch buffer can be of arbitrary size. In addition, each fetched piece does not need to be of the same size.">Performing a Piecewise Fetch</a></p>
<div class="infoboxnotealso" id="GUID-25BBA0D1-689D-40FD-86E1-A10D02A3E4BB__GUID-8350770A-C27B-427F-92AB-8283FA10697F">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> or <a href="oci16rel003.htm#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="Associates an item in a select list with the type and output data buffer. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIDefineByPos2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-DD404526-9615-4E44-B790-1D17396C82A9" title="Sets the additional attributes required if the OCI_DYNAMIC_FETCH mode was selected in OCIDefineByPos() or OCIDefineByPos2().">OCIDefineDynamic()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="Sets piece information for a piecewise operation.">OCIStmtSetPieceInfo()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="Returns piece information for a piecewise operation.">OCIStmtGetPieceInfo()</a></p>
</li>
</ul>
</div>
</div>
<a id="LNOCI16436"></a><a id="LNOCI16435"></a>
<div class="props_rev_3"><a id="GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11"></a>
<h4 id="LNOCI-GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11" class="sect4">Performing a Piecewise Fetch</h4>
<div>
<p>The fetch buffer can be of arbitrary size. In addition, each fetched piece does not need to be of the same size.</p>
<div class="section">
<p>The only requirement is that the size of the final fetch must be exactly the size of the last remaining piece. The size of each piece to be fetched is established by each <code class="codeph">OCIStmtSetPieceInfo()</code> call. This process is illustrated in <a href="oci05bnd.htm#GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11__I430634">Figure 5-4</a> and explained in the steps following the figure.</p>
<div class="figure" id="GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11__I430634">
<p class="titleinfigure">Figure 5-4 Performing Piecewise Fetch</p>
<img width="539" height="244" src="img/GUID-AB8466A9-78B5-456C-8B34-E4137E2D1CAC-default.gif" alt="Description of Figure 5-4 follows" title="Description of Figure 5-4 follows"/><br/>
<a href="img_text/GUID-AB8466A9-78B5-456C-8B34-E4137E2D1CAC-print.htm">Description of &#34;Figure 5-4 Performing Piecewise Fetch&#34;</a></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<ol>
<li><span>Initialize the OCI environment, allocate necessary handles, connect to a database, authorize a user, prepare a statement, and execute the statement by using <code class="codeph">OCIStmtExecute()</code>.</span></li>
<li><span>Define an output variable by using <code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code>, with <code class="codeph">mode</code> set to <code class="codeph">OCI_DYNAMIC_FETCH</code>. At this point you do not need to specify the actual size of the pieces you use, but you must provide the total size of the data that is to be fetched at run time.</span></li>
<li><span>Call <code class="codeph">OCIStmtFetch2()</code> for the first time. No data is retrieved, and the <code class="codeph">OCI_NEED_DATA</code> error code is returned to the application. If any other value is returned, then an error occurred.</span></li>
<li><span>Call <code class="codeph">OCIStmtGetPieceInfo()</code> to obtain information about the piece to be fetched. The <code class="codeph">piecep</code> parameter indicates whether it is the first piece (<code class="codeph">OCI_FIRST_PIECE</code>), a subsequent piece (<code class="codeph">OCI_NEXT_PIECE</code>), or the last piece (<code class="codeph">OCI_LAST_PIECE</code>).</span></li>
<li><span>Call <code class="codeph">OCIStmtSetPieceInfo()</code> to specify the fetch buffer.</span></li>
<li><span>Call <code class="codeph">OCIStmtFetch2()</code> again to retrieve the actual piece. If <code class="codeph">OCIStmtFetch2()</code> returns <code class="codeph">OCI_SUCCESS</code>, all the pieces have been fetched successfully. If <code class="codeph">OCIStmtFetch2()</code> returns <code class="codeph">OCI_NEED_DATA</code>, return to Step 4 to process the next piece. If any other value is returned, an error occurred.</span></li>
</ol>
<div class="section">
<div class="infoboxnotealso" id="GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11__GUID-CD4065E8-7451-40E5-85B5-C9379FE8D467">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci02bas.htm#GUID-83F4D3B1-56A7-4EEE-A905-BB84D399713D">Polling Mode Operations in OCI</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="Sets piece information for a piecewise operation.">OCIStmtSetPieceInfo()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="Associates an application request with a server.">OCIStmtExecute()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> or <a href="oci16rel003.htm#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="Associates an item in a select list with the type and output data buffer. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIDefineByPos2()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="Returns piece information for a piecewise operation.">OCIStmtGetPieceInfo()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="Fetches a row from the (scrollable) result set.">OCIStmtFetch2()</a></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="LNOCI16437"></a>
<div class="props_rev_3"><a id="GUID-9E60B14E-920F-42E6-904D-36BAF20FDA3D"></a>
<h3 id="LNOCI-GUID-9E60B14E-920F-42E6-904D-36BAF20FDA3D" class="sect3">Piecewise Binds and Defines for LOBs</h3>
<div>
<p>What are the ways of doing piecewise binds and defines for LOBs.</p>
<p>There are two:</p>
<ul style="list-style-type: disc;">
<li>
<p><span>Using the data interface</span></p>
<p>You can bind or define character data for <code class="codeph">CLOB</code> columns using <code class="codeph">SQLT_CHR</code> (<code class="codeph">VARCHAR2</code>) or <code class="codeph">SQLT_LNG</code> (<code class="codeph">LONG</code>) as the input data type for the following functions. You can also bind or define raw data for <code class="codeph">BLOB</code> columns using <code class="codeph">SQLT_LBI</code> (<code class="codeph">LONG</code> <code class="codeph">RAW</code>), and <code class="codeph">SQLT_BIN</code> (<code class="codeph">RAW</code>) as the input data type for these functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code></p>
</li>
<li>
<p><code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code></p>
</li>
<li>
<p><code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code></p>
</li>
</ul>
<p>All the piecewise operations described later are supported for <code class="codeph">CLOB</code> and <code class="codeph">BLOB</code> columns in this case.</p>
</li>
<li>
<p><span>Using the LOB locator</span></p>
<p>You can bind or define a LOB locator for <code class="codeph">CLOB</code> and <code class="codeph">BLOB</code> columns using <code class="codeph">SQLT_CLOB</code> (<code class="codeph">CLOB</code>) or <code class="codeph">SQLT_BLOB</code> (<code class="codeph">BLOB</code>) as the input data type for the following functions.</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OCIDefineByPos()</code> or <code class="codeph">OCIDefineByPos2()</code></p>
</li>
<li>
<p><code class="codeph">OCIBindByName()</code> or <code class="codeph">OCIBindByName2()</code></p>
</li>
<li>
<p><code class="codeph">OCIBindByPos()</code> or <code class="codeph">OCIBindByPos2()</code></p>
</li>
</ul>
<p>You must then call OCILob* functions to read and manipulate the data. <code class="codeph">OCILobRead2()</code> and <code class="codeph">OCILobWrite2()</code> support piecewise and callback modes.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-9E60B14E-920F-42E6-904D-36BAF20FDA3D__GUID-1451BE6F-0520-4504-B0A3-FA04A2307091">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oci16rel003.htm#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="Associates an item in a select list with the type and output data buffer.">OCIDefineByPos()</a> or <a href="oci16rel003.htm#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="Associates an item in a select list with the type and output data buffer. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIDefineByPos2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByName()</a> or <a href="oci16rel003.htm#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this function when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByName2()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.">OCIBindByPos()</a> or <a href="oci16rel003.htm#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block. Use this call when working with data types when actual lengths exceed UB2MAXVAL on the client.">OCIBindByPos2()</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" title="Oracle Database allows nonzero binds for INSERTs and UPDATEs of any size LOB.">About Binding LOB Data</a> for usage and examples for both <code class="codeph">INSERT</code> and <code class="codeph">UPDATE statements</code></p>
</li>
<li>
<p><a href="oci05bnd.htm#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E">About Defining LOB Data</a> for usage and examples of <code class="codeph">SELECT</code> statements</p>
</li>
<li>
<p><a href="oci17msc002.htm#GUID-6AC6E6DA-236B-4BF9-942F-9FCC4178FEDA" title="Reads a portion of a LOB or BFILE, as specified by the call, into a buffer. This function must be used for LOBs of size greater than 4 GB.">OCILobRead2()</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#GUID-77F056CA-9EEE-4550-8A8E-0155DF994DBE" title="Writes a buffer into a LOB. This function must be used for LOBs of size greater than 4 GB.">OCILobWrite2()</a></p>
</li>
<li>
<p><a href="oci07lob.htm#GUID-FFFD9E4C-03CE-469C-AA47-DFD73C0C9C69" title="OCI supports read and write callback functions.">LOB Read and Write Callbacks</a> for information about streaming using callbacks with <code class="codeph">OCILobWrite2()</code> and <code class="codeph">OCILobRead2()</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment6150">
<tr>
<td class="cellalignment6162">
<table class="cellalignment6155">
<tr>
<td class="cellalignment6154"><a href="oci04sql.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment6154"><a href="oci06des.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment6164">
<table class="cellalignment6153">
<tr>
<td class="cellalignment6154"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment6154"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment6154"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment6154"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment6154"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment6154"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>