<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="Content-Script-Type" content="text/javascript"/>
<meta name="generator" content="DITA Open Toolkit version 1.8.5"/>
<a class="dashingAutolink" name="autolink-73958"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Description%20of%20the%20illustration%20xstrm045.eps"></a><title>Description of the illustration xstrm045.eps</title>
<link rel="stylesheet" href="../../dcommon/css/blafdoc.css" title="Oracle BLAFDoc" type="text/css"/>
</head>
<body>
<div>
<p>This illustration shows two long, rectangular, vertically-standing boxes separated by a large space. The left box is labeled &ldquo;client code&rdquo;, while the right box is labeled &ldquo;LCRCallbackReceive&rdquo;. The execution flow is shown beginning at Step 1 by an arrow labelled LCRCallbackReceive going from the left box toward the right box near their tops. This flow shows the user invokes the OCIXStreamOutLCRCallbackReceive() providing two callbacks: processlcr_cb and processchunk_cb. This function initiates an LCR outbound stream from the server shown as a large arrow outside the right box pointing toward its right outside edge labeled &ldquo;receive from outbound server&rdquo;.</p>
<p>The execution flow continues with Step 2 situated beneath Step 1 and shown as an arrow labelled processlcr_cb flowing from the right box to a small box within the left box labeled &ldquo;process LCR&rdquo; indicating that this function receives an LCR from the stream and invokes the processlcr_cb() procedure with the LCR just received. It passes OCI_XSTREAM_MORE_ROW_DATA flag to processlcr_cb() if the current LCR has additional data. If the current LCR has no additional chunk data, then this function repeats Step 2 for the next LCR in the stream shown as an arrow within the right box pointing to Step 2.</p>
<p>The execution flow continues with Step 3 situated beneath Step 2 and shown as an arrow labelled processchunk_cb flowing from the right box to a small box labeled &ldquo;process chunk&rdquo; within the left box, indicating that if the current LCR contains additional chunk data, then this function invokes processchunk_cb() for each chunk received with the OCI_XSTREAM_MORE_ROW_DATA flag. This flag is cleared when the callback is invoked on the last chunk of the current LCR. If there is more LCR in the stream, then it loops back to Step 2 shown as a line pointing to Step 2 in the right box. This process continues until the end of the current call, or when there is no LCR in the stream for one second, or if a callback function returns any value other than OCI_CONTINUE.</p>
</div>
<div class="footer"><img class="copyrightlogo" src="../../dcommon/gifs/oracle.gif" alt="Oracle Logo"/> <a href="../../dcommon/html/cpyr.htm"><br/>
<span class="copyrightlogo">Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.</span></a></div>


</body></html>