<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-71045"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Java%20Applications%20on%20Oracle%20Database"></a><title>Java Applications on Oracle Database</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="description" content="This book describes how to develop, load, and run Java applications in Oracle Database."/>
<meta name="dcterms.created" content="2014-06-30T4:24:59Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Java Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E50793-03"/>
<meta name="dcterms.isVersionOf" content="JJDEV"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="chone.htm" title="Previous" type="text/html"/>
<link rel="Next" href="chthree.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E50793-03.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/23</span> <!-- End Header -->
<div id="JJDEV02000" class="chapter"><a id="BABHGJFI"></a>
<h1 class="chapter"><span class="secnum">2</span> <a id="sthref101"></a><a id="sthref102"></a>Java Applications on Oracle Database</h1>
<p>Oracle Database runs standard Java applications. However, the Java-integrated Oracle Database environment is different from a typical Java development environment. This chapter describes the basic differences for writing, installing, and deploying Java applications within Oracle Database. This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#BABBDCDI">Database Sessions Imposed on Java Applications</a></p>
</li>
<li>
<p><a href="#BABFCDAD">Execution Control of Java Applications</a></p>
</li>
<li>
<p><a href="#BABHBBBI">Java Code, Binaries, and Resources Storage</a></p>
</li>
<li>
<p><a href="#BABHJJJE">Preparing Java Class Methods for Execution</a></p>
</li>
<li>
<p><a href="#BABFAEJI">User Interfaces on the Server</a></p>
</li>
<li>
<p><a href="#BABEGDFJ">Shortened Class Names</a></p>
</li>
<li>
<p><a href="#BABHHJDJ">Class.forName() in Oracle Database</a></p>
</li>
<li>
<p><a href="#BABEFEBH">Managing Your Operating System Resources</a></p>
</li>
<li>
<p><a href="#CEGJEEEA">Using the Runtime.exec Functionality in Oracle Database</a></p>
</li>
<li>
<p><a href="#CHDFAJIG">Managing Your Applications Using JMX</a></p>
</li>
<li>
<p><a href="#BABHHHDG">Threading in Oracle Database</a></p>
</li>
<li>
<p><a href="#CEGDEAGB">Shared Servers Considerations</a></p>
</li>
</ul>
<a id="BABBDCDI"></a>
<div id="JJDEV02010" class="sect1">
<h2 class="sect1">Database <a id="sthref103"></a>Sessions Imposed on Java Applications</h2>
<p>In the Java-integrated Oracle Database, your Java applications exist within the context of a database session. Oracle JVM sessions are entirely analogous to traditional Oracle sessions. Each Oracle JVM session maintains the state of the Java applications accessed by the client across calls within the session.</p>
<p><a href="#BABDIBDG">Figure 2-1</a> i<a id="sthref104"></a>llustrates how each Java client starts a database session as the environment for running Java applications within the database. Each Java database session has a separate garbage collector, session memory, and call memory.</p>
<div id="JJDEV13059" class="figure">
<p class="titleinfigure"><a id="BABDIBDG"></a>Figure 2-1 Java Environment Within Each Database Session</p>
<img width="384" height="378" src="img/au_over.gif" alt="Description of Figure 2-1 follows"/><br/>
<a id="sthref105" href="img_text/au_over.htm">Description of &#34;Figure 2-1 Java Environment Within Each Database Session&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Within the context of a session, the client performs the following:</p>
<ol>
<li>
<p>Connects to the database and opens a session.</p>
</li>
<li>
<p>Runs Java within the database. This is referred to as a call.</p>
</li>
<li>
<p>Continues to work within the session, performing as many calls as required.</p>
</li>
<li>
<p>Ends the session.</p>
</li>
</ol>
<p><a id="sthref106"></a>Within a session, the client has its own Java environment. It appears to the client as if a separate, individual JVM was started for each session, although the implementation is more efficient than this seems to imply. Within a session, Oracle JVM manages the scalability of applications. Every call from a single client is managed within its own session, and calls from each client is handled separately. Oracle JVM maximizes sharing read-only data between clients and emphasizes a minimum amount of per-session incremental <a id="sthref107"></a>footprint, to maximize performance for multiple clients.</p>
<p>The underlying server environment hides the details associated with session, network, state, and other shared resource management issues from the Java code. Fields defined as <code><a id="sthref108"></a>static</code> are local to the client. No client can access the <code>static</code> fields of other clients, because the memory is not available across session boundaries. Because each client runs the Java application calls within its own session, activities of each client are separate from any other client. During a call, you can store objects in <code>static</code> fields of different classes, which will be available in the next call. The entire state of your Java program is private and exists for your entire session.</p>
<p>Oracle JVM manages the following within the session:</p>
<ul>
<li>
<p><a id="sthref109"></a>All the objects referenced by <code>static</code> Java fields, all the objects referred to by these objects, and so on, till their transitive closure</p>
</li>
<li>
<p><a id="sthref110"></a>Garbage collection for the client that created the session</p>
</li>
<li>
<p><a id="sthref111"></a><a id="sthref112"></a>Session memory for <code>static</code> fields and across call memory needs</p>
</li>
<li>
<p><a id="sthref113"></a><a id="sthref114"></a>Call memory for fields that exist within a call</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BABFCDAD"></a>
<div id="JJDEV02020" class="sect1">
<h2 class="sect1">Execution<a id="sthref115"></a><a id="sthref116"></a><a id="sthref117"></a><a id="sthref118"></a> Control of Java Applications</h2>
<p><a id="sthref119"></a><a id="sthref120"></a><a id="sthref121"></a><a id="sthref122"></a>In the Java 2 Platform, Standard Edition (J2SE) environment, you develop Java <a id="sthref123"></a>applications with a <code>main()</code> method, which is called by the interpreter when the class is run. The <code>main()</code> method is called when you enter the following command on the command-line:</p>
<pre>java <span class="italic">classname</span>
</pre>
<p>This command starts the Java interpreter and passes the desired class, that is, the class specified by <code><span class="codeinlineitalic">classname</span></code>, to the Java interpreter. The interpreter loads the class and starts running the application by calling <code>main()</code>. However, Java applications within the database do not start by a call to the <code>main()</code> method.</p>
<p>After loading your Java application within the database, you can run it by calling any <code>static</code> method within the loaded class. The class or methods must be published before you can run them. In Oracle Database, the entry point for Java applications is not assumed to be <code>main()</code>. Instead, when you run your Java application, you specify a method name within the loaded class as your entry point.</p>
<p>For example, in a standard Java environment, you would start the Java object on the server by running the following command:</p>
<pre>java <span class="italic">myprogram</span>
</pre>
<p>where, <code><span class="codeinlineitalic">myprogram</span></code> is the name of a class that contains the <code>main()</code> method. In <code><span class="codeinlineitalic">myprogram</span></code>, <code>main()</code> immediately calls <code>mymethod()</code> for processing incoming information.</p>
<p>In Oracle Database, you load the <code>myprogram.class</code> file into the database and <a id="sthref124"></a>publish <code>mymethod()</code> as an entry-point. Then, the client or trigger can invoke <code>mymethod()</code> explicitly.</p>
</div>
<!-- class="sect1" -->
<a id="BABHBBBI"></a>
<div id="JJDEV02030" class="sect1">
<h2 class="sect1"><a id="sthref125"></a><a id="sthref126"></a>Java Code, Binaries, and Resources Storage</h2>
<p><a id="sthref127"></a><a id="sthref128"></a>In the standard Java development environment, Java source code, binaries, and resources are stored as files in a file system, as follows:</p>
<ul>
<li>
<p>Source code files are saved as <code>.java</code> files.</p>
</li>
<li>
<p>Compiled Java binary files are saved as <code>.class</code> files.</p>
</li>
<li>
<p>Resources are any data files, such as <code>.properties</code> or <code>.ser</code> files, that are stored in the file system hierarchy and are loaded and used at run time.</p>
</li>
</ul>
<p><a id="sthref129"></a>In addition, when you run a Java application, you specify the <code><a id="sthref130"></a>CLASSPATH</code>, which is a file or directory path in the file system that contains your <code>.class</code> files. Java also provides a way to group these files into a single archive form, a ZIP or Java Archive (JAR) file.</p>
<p>Both these concepts are different in Oracle Database environment.</p>
<p><a href="#BABFADFB">Table 2-1</a> describes how Oracle Database handles Java classes and locates dependent classes.</p>
<div id="JJDEV13060" class="tblformal">
<p class="titleintable"><a id="sthref131"></a><a id="BABFADFB"></a>Table 2-1 Description of Java Code and Classes</p>
<table class="cellalignment4009" title="Description of Java Code and Classes" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t2">Java Code and Classes</th>
<th class="cellalignment4003" id="r1c2-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t2" headers="r1c1-t2">
<p>Storing Java code, binaries, and resources</p>
</td>
<td class="cellalignment4004" headers="r2c1-t2 r1c2-t2">
<p>In Oracle Database, source code, classes, and resources reside within the database and are known as Java schema objects, where a schema corresponds to a database user. There are three types of Java schema objects: source, class, and resource. There are no <code>.java</code>, <a id="sthref132"></a><a id="sthref133"></a><a id="sthref134"></a><a id="sthref135"></a><a id="sthref136"></a><code>.class</code>, <code>.sqlj</code>, <code>.properties</code>, or <code>.ser</code> files on the server. Instead, these files map to the appropriate Java schema objects.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t2" headers="r1c1-t2">
<p>Locating Java classes</p>
</td>
<td class="cellalignment4004" headers="r3c1-t2 r1c2-t2">
<p>Instead of the <code>CLASSPATH</code>, you use a resolver to specify one or more schemas to search for Java source, class, and resource schema objects.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="JJDEV13061"></a>Java Classes Loaded in the Database</p>
<p>If you are not using the command-line interface, you must load Java files into the database as schema objects, to make them available to Oracle JVM. As <a href="#BABBJJAA">Figure 2-2</a> illustrates, the <code>loadjava</code> tool can call the Java compiler of Oracle JVM, which compiles source files into standard class files.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chthree.htm#CHDJHBGH">&#34;Using Command-Line Interface&#34;</a></div>
<p><a href="#BABBJJAA">Figure 2-2</a> shows that the <code>loadjava</code> tool can set the values of options stored in a system database table. Among other things, these options affect the processing of Java source files.</p>
<div id="JJDEV13062" class="figure">
<p class="titleinfigure"><a id="BABBJJAA"></a>Figure 2-2 Loading Java into Oracle Database</p>
<img width="211" height="273" src="img/loading_java.gif" alt="Description of Figure 2-2 follows"/><br/>
<a id="sthref137" href="img_text/loading_java.htm">Description of &#34;Figure 2-2 Loading Java into Oracle Database&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Each Java class is stored as a schema object. The name of the object is derived from the fully qualified name of the class, which includes the names of containing packages. For example, the full name of the class <code>Handle</code> is:</p>
<pre>oracle.aurora.rdbms.Handle
</pre>
<p>In the Java schema object name, slashes replace periods, so the full name of the class becomes:</p>
<pre>oracle/aurora/rdbms/Handle
</pre>
<p><a id="sthref138"></a><a id="sthref139"></a><a id="sthref140"></a><a id="sthref141"></a>Oracle Database accepts Java names up to 4000 characters long. However, the names of Java schema objects cannot be longer than 30 characters. Therefore, if a schema object name is longer than 30 characters, then the system generates a short name, or alias, for the schema object. Otherwise, the fully qualified name, also called full name, is used. You can specify the full name in any context that requires it. When needed, name mapping is handled by Oracle Database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABEGDFJ">&#34;Shortened Class Names&#34;</a> and <a href="chone.htm#CBBEDCBF">&#34;System Classes&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="BABHJJJE"></a>
<div id="JJDEV02040" class="sect1">
<h2 class="sect1">Preparing Java Class Methods for Execution</h2>
<p><a id="sthref142"></a><a id="sthref143"></a><a id="sthref144"></a><a id="sthref145"></a>To ensure that your Java methods run, you must do the following:</p>
<ol>
<li>
<p>Decide when the Java source code is going to be compiled.</p>
</li>
<li>
<p>Decide if you are going to use the default resolver or another resolver for locating supporting Java classes within the database.</p>
</li>
<li>
<p>Load the classes into the database. If you do not wish to use the default resolver for your classes, then you should specify a separate resolver with the load command.</p>
</li>
<li>
<p>Publish your class or method.</p>
</li>
</ol>
<p>This sections covers the following topics:</p>
<ul>
<li>
<p><a href="#BABHBDCI">Compiling Java Classes</a></p>
</li>
<li>
<p><a href="#BABGJCAJ">Resolving Class Dependencies</a></p>
</li>
<li>
<p><a href="#BABIAIIA">Loading Classes</a></p>
</li>
<li>
<p><a href="#BABBIEBH">Granting Execute Rights</a></p>
</li>
<li>
<p><a href="#BABGIEBA">Controlling the Current User</a></p>
</li>
<li>
<p><a href="#BABEFGAD">Checking Java Uploads</a></p>
</li>
<li>
<p><a href="#BABBFBFG">Publishing</a></p>
</li>
<li>
<p><a href="#CEGFFFCB">Auditing</a></p>
</li>
</ul>
<a id="BABHBDCI"></a>
<div id="JJDEV02041" class="sect2">
<h3 class="sect2">Compiling <a id="sthref146"></a><a id="sthref147"></a>Java Classes</h3>
<p>Compilation of the Java source code can be done in one of the following ways:</p>
<ul>
<li>
<p><a id="sthref148"></a>You can compile the source explicitly on a client system before loading it into the database, through a Java compiler, such as <code>javac</code>.</p>
</li>
<li>
<p>You can ask the database to compile the source during the loading process, which is managed by the <code>loadjava</code> tool.</p>
</li>
<li>
<p><a id="sthref149"></a>You can force the compilation to occur dynamically at run time.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you decide to compile through the <code>loadjava</code> tool, then you can specify the compiler options. Refer to <a href="#BABIGFGA">&#34;Specifying Compiler Options&#34;</a> for more information.</div>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#BABCAIBA">Compiling Source Through javac</a></p>
</li>
<li>
<p><a href="#BABJJECI">Compiling Source Through the loadjava Tool</a></p>
</li>
<li>
<p><a href="#BABGGBIA">Compiling Source at Run Time</a></p>
</li>
<li>
<p><a href="#BABIGFGA">Specifying Compiler Options</a></p>
</li>
<li>
<p><a href="#BABEFFIE">Recompiling Automatically</a></p>
</li>
</ul>
<a id="BABCAIBA"></a>
<div id="JJDEV13063" class="sect3">
<h4 class="sect3">Compiling Source Through javac</h4>
<p>You can compile Java source code with a conventional Java compiler, such as <code>javac</code>. After compilation, you load the compiled binary into the database, rather than the source itself. This is a better option, because it is usually easier to debug the Java code on your own system, rather than debugging it on the database.</p>
</div>
<!-- class="sect3" -->
<a id="BABJJECI"></a>
<div id="JJDEV13064" class="sect3">
<h4 class="sect3">Compiling Source Through the loadjava Tool</h4>
<p>When you specify the <code>-resolve</code> option with the <code>loadjava</code> tool for a source file, the following occurs:</p>
<ol>
<li>
<p>The source file is loaded as a source schema object.</p>
</li>
<li>
<p>The source file is compiled.</p>
</li>
<li>
<p>Class schema objects are created for each class defined in the compiled <code>.java</code> file.</p>
</li>
<li>
<p>The compiled code is stored in the class schema objects.</p>
</li>
</ol>
<p><a id="sthref150"></a><a id="sthref151"></a>Oracle Database writes all compilation errors to the <a id="sthref152"></a>log file of the <code>loadjava</code> tool as well as the <code><a id="sthref153"></a>USER_ERRORS</code> view.</p>
</div>
<!-- class="sect3" -->
<a id="BABGGBIA"></a>
<div id="JJDEV13065" class="sect3">
<h4 class="sect3"><a id="sthref154"></a>Compiling Source at Run Time</h4>
<p>When you load the Java source into the database without the <code>-resolve</code> option, Oracle Database compiles the source automatically when the class is needed during run time. The source file is loaded into a source schema object.</p>
<p>Oracle Database writes all compilation errors to the log file of the <code>loadjava</code> tool as well as the <code>USER_ERRORS</code> view.</p>
</div>
<!-- class="sect3" -->
<a id="BABIGFGA"></a>
<div id="JJDEV13066" class="sect3">
<h4 class="sect3"><a id="sthref155"></a>Specifying Compiler Options</h4>
<p>You can specify the compiler options in the following ways:</p>
<ul>
<li>
<p><a id="sthref156"></a>Specify compiler options on the command line with the <code>loadjava</code> tool. You can also specify the encoding option with the <code>loadjava</code> tool.</p>
</li>
<li>
<p>Specify persistent compiler options in the <a id="sthref157"></a><code>JAVA$OPTIONS</code> table. The <code>JAVA$OPTIONS</code> table exists for each schema. Every time you compile, the compiler uses these options. However, any compiler options specified with the <code>loadjava</code> tool override the options defined in this table. You must create this table yourself if you wish to specify compiler options in this manner.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABHIGJD">&#34;Compiler Options Specified in a Database Table&#34;</a></div>
</li>
</ul>
<p class="subhead2"><a id="JJDEV13067"></a>Default Compiler Options</p>
<p>When compiling a source schema object for which neither a <code>JAVA$OPTIONS</code> entry exists nor a command-line value for any option is specified, the compiler assumes a default value as follows:</p>
<ul>
<li>
<p><code><a id="sthref158"></a>encoding=System.getProperty(&#34;file.encoding&#34;);</code></p>
</li>
<li>
<p><code><a id="sthref159"></a>online=true</code></p>
<p>This option applies only to Java sources that contain SQLJ constructs.</p>
</li>
<li>
<p><code><a id="sthref160"></a>debug=true</code></p>
<p>This option is equivalent to:</p>
<pre>javac -g
</pre></li>
</ul>
<p class="subhead2"><a id="JJDEV13068"></a>Compiler Options on the Command Line</p>
<p>The <code>encoding</code> compiler option specified with the <code>loadjava</code> tool identifies the encoding of the <code>.java</code> file. This option overrides any matching value in the <code>JAVA$OPTIONS</code> table. The values are identical to:</p>
<pre>javac -encoding
</pre>
<p>This option is relevant only when loading a source file.</p>
<p class="subhead2"><a id="BABHIGJD"></a><a id="JJDEV13069"></a>Compiler Options Specified in a Database Table</p>
<p>Each <code>JAVA$OPTIONS</code> entry contains the names of source schema objects to which an option setting applies. You can use multiple rows to set the options differently for different source schema objects.</p>
<p>You can set <code>JAVA$OPTIONS</code> entries by using the following procedures and functions, which are defined in the database package <code>DBMS_JAVA</code>:</p>
<pre>PROCEDURE <a id="sthref161"></a>set_compiler_option(name VARCHAR2, option VARCHAR2, value VARCHAR2);

FUNCTION <a id="sthref162"></a>get_compiler_option(name VARCHAR2, option VARCHAR2) RETURNS VARCHAR2;

PROCEDURE <a id="sthref163"></a>reset_compiler_option(name VARCHAR2, option VARCHAR2);
</pre>
<p><a href="#CEGJBDHI">Table 2-2</a> describes the parameters for these methods.</p>
<div id="JJDEV13070" class="tblformal">
<p class="titleintable"><a id="sthref164"></a><a id="CEGJBDHI"></a>Table 2-2 Definitions for the Name and Option Parameters</p>
<table class="cellalignment4009" title="Definitions for the Name and Option Parameters" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t7">Parameter</th>
<th class="cellalignment4003" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t7" headers="r1c1-t7">
<p>name</p>
</td>
<td class="cellalignment4004" headers="r2c1-t7 r1c2-t7">
<p>This is a Java package name, a fully qualified class name, or an empty string. When the compiler searches the <code>JAVA$OPTIONS</code> table for the options to use for compiling a Java source schema object, it uses the row that has a value for <code>name</code> that most closely matches the fully qualified class name of a schema object. A <code>name</code> whose value is the empty string matches any schema object name.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t7" headers="r1c1-t7">
<p>option</p>
</td>
<td class="cellalignment4004" headers="r3c1-t7 r1c2-t7">
<p>The <code>option</code> parameter is either <code>online</code>, <code>encoding</code>, or <code>debug</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Initially, a schema does not have a <code>JAVA$OPTIONS</code> table. To create a <code>JAVA$OPTIONS</code> table, use the <code>java.set_compiler_option</code> procedure from the <code>DBMS_JAVA</code> package to set a value. The procedure will create the table, if it does not exist. Specify parameters in single quotes. For example:</p>
<pre>SQL&gt; execute dbms_java.set_compiler_option(&#39;x.y&#39;, &#39;online&#39;, &#39;false&#39;);
</pre>
<p><a href="#BABBIFHD">Table 2-3</a> represents a hypothetical <code>JAVA$OPTIONS</code> database table. The pattern match rule is to match as much of the schema name against the table entry as possible. The schema name with a higher resolution for the pattern match is the entry that applies. Because the table has no entry for the <code>encoding</code> option, the compiler uses the default or the value specified on the command line. The <code>online</code> option shown in the table matches schema object names as follows:</p>
<ul>
<li>
<p>The name <code>a.b.c.d</code> matches class and package names beginning with <code>a.b.c.d</code>. The packages and classes are compiled with <code>online=true</code>.</p>
</li>
<li>
<p>The name <code>a.b</code> matches class and package names beginning with <code>a.b</code>. The name <code>a.b</code> does not match <code>a.b.c.d</code>. The packages and classes are compiled with <code>online=false</code>.</p>
</li>
<li>
<p>All other packages and classes match the empty string entry and are compiled with <code>online=true</code>.</p>
</li>
</ul>
<div id="JJDEV13071" class="tblformal">
<p class="titleintable"><a id="sthref165"></a><a id="BABBIFHD"></a>Table 2-3 Example JAVA$OPTIONS Table</p>
<table class="cellalignment4009" title="Example JAVA$OPTIONS Table" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t8">Name</th>
<th class="cellalignment4003" id="r1c2-t8">Option</th>
<th class="cellalignment4003" id="r1c3-t8">Value</th>
<th class="cellalignment4003" id="r1c4-t8">Match Examples</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t8" headers="r1c1-t8">
<p>a.b.c.d</p>
</td>
<td class="cellalignment4004" headers="r2c1-t8 r1c2-t8">
<p><code>online</code></p>
</td>
<td class="cellalignment4004" headers="r2c1-t8 r1c3-t8">
<p><code>true</code></p>
</td>
<td class="cellalignment4004" headers="r2c1-t8 r1c4-t8">
<ul>
<li>
<p><code>a.b.c.d</code></p>
<p>Matches the pattern exactly.</p>
</li>
<li>
<p><code>a.b.c.d.e</code></p>
<p>First part matches the pattern exactly. No other rule matches the full qualified name.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t8" headers="r1c1-t8">
<p>a.b</p>
</td>
<td class="cellalignment4004" headers="r3c1-t8 r1c2-t8">
<p><code>online</code></p>
</td>
<td class="cellalignment4004" headers="r3c1-t8 r1c3-t8">
<p><code>false</code></p>
</td>
<td class="cellalignment4004" headers="r3c1-t8 r1c4-t8">
<ul>
<li>
<p><code>a.b</code></p>
<p>Matches the pattern exactly</p>
</li>
<li>
<p><code>a.b.c.x</code></p>
<p>First part matches the pattern exactly. No other rule matches beyond this rule.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t8" headers="r1c1-t8">
<p>Empty string</p>
</td>
<td class="cellalignment4004" headers="r4c1-t8 r1c2-t8">
<p><code>online</code></p>
</td>
<td class="cellalignment4004" headers="r4c1-t8 r1c3-t8">
<p><code>true</code></p>
</td>
<td class="cellalignment4004" headers="r4c1-t8 r1c4-t8">
<ul>
<li>
<p><code>a.c</code></p>
<p>No pattern match with any defined name. Defaults to the empty string rule.</p>
</li>
<li>
<p><code>x.y</code></p>
<p>No pattern match with any defined name. Defaults to the empty string rule.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<a id="BABEFFIE"></a>
<div id="JJDEV13072" class="sect3">
<h4 class="sect3">Recompiling Automatically</h4>
<p>Oracle Database provides a dependency management and automatic build facility that transparently recompiles source programs when you make changes to the source or binary programs upon which they depend. Consider the following example:</p>
<pre>public class A
{
  B b;
  public void assignB()
  {
    b = new B()
  }
}
public class B
{
  C c;
  public void assignC()
  {
    c = new C()
  }
}
public class C
{
  A a;
  public void assignA()
  {
    a = new A()
  }
}
</pre>
<p>The system tracks dependencies at a class level of granularity. In the preceding example, you can see that classes <code>A</code>, <code>B</code>, and <code>C</code> depend on one another, because <code>A</code> holds an instance of <code>B</code>, <code>B</code> holds an instance of <code>C</code>, and <code>C</code> holds an instance of <code>A</code>. If you change the definition of class <code>A</code> by adding a new field to it, then the dependency mechanism in Oracle Database flags classes <code>B</code> and <code>C</code> as invalid. Before you use any of these classes again, Oracle Database attempts to resolve them and recompile, if necessary. Note that classes can be recompiled only if the source file is present on the server.</p>
<p>The dependency system enables you to rely on Oracle Database to manage dependencies between classes, to recompile, and to resolve automatically. You must force compilation and resolution yourself only if you are developing and you want to find problems early. The <code>loadjava</code> tool also provides the facilities for forcing compilation and resolution if you do not want the dependency management facilities to perform this for you.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGJCAJ"></a>
<div id="JJDEV02042" class="sect2">
<h3 class="sect2">Resolving <a id="ABC2729817"></a><a id="ABC2729817SRI1"></a><a id="ABC2729817SRI12"></a><a id="ABC2729817SRI123"></a>Class Dependencies</h3>
<p>Many Java classes contain references to other classes, which is the essence of reusing code. A conventional JVM searches for <code>.class</code>, <code>.zip</code>, and <code>.jar</code> files within the directories specified in <code>CLASSPATH</code>. In contrast, Oracle JVM searches database schemas for class objects. In Oracle Database, because you load all Java classes into the database, you may need to specify where to find the dependent classes for your Java class within the database.</p>
<p>All classes loaded within the database are referred to as class schema objects and are loaded within certain schemas. All predefined Java application programming interfaces (APIs), such as <code>java.lang.*</code> , are loaded within the <code>PUBLIC</code> schema. If your classes depend on other classes you have defined, then you will probably load them all within your own schema. For example, if your schema is <code>HR</code>, then the database resolver searches the <code>HR</code> schema before searching the <code>PUBLIC</code> schema. The listing of schemas to search is known as a <a id="sthref166"></a><span class="bold">resolver specification</span>. Resolver specifications are defined for each class. This is in contrast to a classic JVM, where <code>CLASSPATH</code> is global to all classes.</p>
<p>When locating and resolving the interclass dependencies for classes, the resolver marks each class as valid or invalid, depending on whether all interdependent classes are located. If the class that you load contains a reference to a class that is not found within the appropriate schemas, then the class is listed as invalid. Unsuccessful resolution at run time produces a <code>ClassNotFound</code> exception. Also, run-time resolution can fail for lack of database resources, if the tree of classes is very large.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
As with the Java compiler, the <code>loadjava</code> tool resolves references to classes, but not to resources. Ensure that you correctly load the resource files that your classes require.</div>
<p><a id="sthref167"></a>For each interclass reference in a class, the resolver searches the schemas specified by the resolver specification for a valid <a id="sthref168"></a>class schema object that satisfies the reference. If all references are resolved, then the resolver marks the class valid. A class that has never been resolved, or has been resolved unsuccessfully, is marked invalid. A class that depends on a schema object that becomes invalid is also marked invalid.</p>
<p><a id="sthref169"></a><a id="sthref170"></a>To make searching for dependent classes easier, Oracle Database provides a default resolver and resolver specification that searches the definer&#39;s schema first and then searches the <code>PUBLIC</code> schema. This covers most of the classes loaded within the database. However, if you are accessing classes within a schema other than your own or <code>PUBLIC</code>, you must define your own resolver specification.</p>
<p>Classes can be resolved in the following ways:</p>
<ul>
<li>
<p>Loading using the default resolver, which searches the definer&#39;s schema and <code>PUBLIC</code>:</p>
<pre>loadjava -resolve
</pre></li>
<li>
<p>Loading using your own resolver specification definition:</p>
<pre>loadjava-resolve -resolver &#34;((* HR)(* OTHER)(* PUBLIC))&#34;
</pre>
<p>In the preceding example, the resolver specification definition includes the <code>HR</code> schema, <code>OTHER</code> schema, and <code>PUBLIC</code>.</p>
</li>
</ul>
<p>The <code>-resolver</code> option specifies the objects to search within the schemas defined. In the preceding example, all class schema objects are searched within <code>HR</code>, <code>OTHER</code>, and <code>PUBLIC</code>. However, if you want to search for only a certain class or group of classes within the schema, then you could narrow the scope for the search. For example, to search only for the <code>my/gui/*</code> classes within the <code>OTHER</code> schema, you would define the resolver specification as follows:</p>
<pre>loadjava -resolve -resolver &#39;((* HR) (&#34;my/gui/*&#34; OTHER) (* PUBLIC))&#39;
</pre>
<p>The first parameter within the resolver specification is for the class schema object, and the second parameter defines the schema within which to search for these class schema objects.</p>
<p class="subhead2"><a id="CHDDFFEJ"></a><a id="JJDEV13073"></a>Allowing References to Nonexistent Classes</p>
<p>You can specify a special option within a resolver specification that allows an unresolved reference to a nonexistent class. Sometimes, internal classes are never used within a product. In a standard Java environment, this is not a problem, because as long as the methods are not called, JVM ignores them. However, when resolving a class, Oracle JVM tries to resolve all names referenced by that class, including names that may never be used. If Oracle JVM cannot find a matching class for each such names referenced by that class, then the class being resolved is marked as invalid and cannot be run.</p>
<p>To ignore references, you can specify the wildcard, minus sign (<code>-</code>), within the resolver specification. The following example specifies that any references to classes within <code>my/gui</code> are to be allowed, even if it is not present within the resolver specification schema list.</p>
<pre>loadjava -resolve -resolver &#39;((* HR) (* PUBLIC) (&#34;my/gui/*&#34; -))&#39;
</pre>
<p>Without the wildcard, if a dependent class is not found within one of the schemas, your class is listed as invalid and cannot be run.</p>
<p>In addition, you can define that all classes not found are to be ignored. However, this is dangerous, because a class that has a dependent class will be marked as valid, even if the dependent class does not exist. However, the class can never run without the dependent class. In this case, you will receive an exception at run time.</p>
<p>To ignore all classes not found within <code>HR</code> or <code>PUBLIC</code>, specify the following resolver specification:</p>
<pre>loadjava -resolve -resolver &#34;((* HR) (* PUBLIC) (* -))&#34;
</pre>
<p>If you later intend to load the nonexistent classes that required you to use such a resolver, then you should not use a resolver containing the minus sign (-) wildcard. Instead, include all referenced classes in the schema before resolving.</p>
<p>Even when a minus sign (-) wildcard is used, the super class of a class can never be nonexistent. If the super class is not found, then the class will be invalid regardless of the use of a minus sign (-) wildcard in the resolver.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An alternative mechanism for dealing with nonexistent classes is using the <code>-gemissing</code> option of the <code>loadjava</code> tool. This option causes the <code>loadjava</code> tool to create and load definitions of classes that are referenced, but not defined.</div>
<p class="subhead2"><a id="JJDEV13074"></a>Bytecode <a id="sthref171"></a><a id="sthref172"></a>Verifier</p>
<p>According to JVM specification, <code>.class</code> files are subject to verification before the class they define is available in a JVM. In Oracle JVM, the verification process occurs at class resolution.</p>
<p><a href="#CEGFGFAC">Table 2-4</a> describes the problems the resolver may find and the appropriate Oracle error code issued.</p>
<div id="JJDEV13075" class="tblformal">
<p class="titleintable"><a id="sthref173"></a><a id="CEGFGFAC"></a>Table 2-4 ORA Errors</p>
<table class="cellalignment4009" title="ORA Errors" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t11">Error Code</th>
<th class="cellalignment4003" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t11" headers="r1c1-t11">
<p><code>ORA-29545</code></p>
</td>
<td class="cellalignment4004" headers="r2c1-t11 r1c2-t11">
<p>If the resolver determines that the class is malformed, then the resolver does not mark it valid. When the resolver rejects a class, it issues an <code>ORA-29545</code> error. The <code>loadjava</code> tool reports the error. For example, this error is thrown if the contents of a <code>.class</code> file are not the result of a Java compilation or if the file has been corrupted.</p>
<p>The <code>ORA-29545</code> error may also show up if you used the minus sign (-) wild card expression with the resolver and the validity of some classes was not verified.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t11" headers="r1c1-t11">
<p><code>ORA-29552</code></p>
</td>
<td class="cellalignment4004" headers="r3c1-t11 r1c2-t11">
<p>In some situations, the resolver allows a class to be marked valid, but will replace bytecodes in the class to throw an exception at run time. In these cases, the resolver issues an <code>ORA-29552</code> warning that the <code>loadjava</code> tool reports. The <code>loadjava</code> tool issues this warning when the Java Language Specification (JLS) requires an <code>IncompatibleClassChangeError</code> to be thrown. Oracle JVM relies on the resolver to detect these situations, supporting the proper run-time behavior that the JLS requires.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><a id="sthref174"></a>A resolver with the minus sign (<code>-</code>) wildcard marks your class valid, regardless of whether classes referenced by your class are present. Because of inheritance and interfaces, you may want to write valid Java methods that use an instance of a class as if it were an instance of a superclass or of a specific interface. When the method being verified uses a reference to class <code>A</code> as if it were a reference to class <code>B</code>, the resolver must check that <code>A</code> either extends or implements <code>B</code>. For example, consider the following potentially valid method, whose signature implies a return of an instance of <code>B</code>, but whose body returns an instance of <code>A</code>:</p>
<pre>B myMethod(A a)
{ 
  return a; 
}
</pre>
<p>The method is valid only if <code>A</code> extends the class <code>B</code> or <code>A</code> implements the interface <code>B</code>. If <code>A</code> or <code>B</code> have been resolved using the minus sign (-) wildcard, then the resolver does not know that this method is safe. In this case, the resolver replaces the bytecodes of <code>myMethod</code> with bytecodes that throw an exception if <code>myMethod</code> is called.</p>
<p>A resolver without the minus sign (<code>-)</code> wildcard ensures that the class definitions of <code>A</code> and <code>B</code> are found and resolved properly if they are present in the schemas they specifically identify. The only time you may consider using the alternative resolver is if you must load an existing JAR file containing classes that reference other nonsystem classes, which are not included in the JAR file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cheleven.htm#CACCBHIC">Chapter 12, &#34;Schema Objects and Oracle JVM Utilities&#34;</a> for more information about class resolution and loading your classes within the database.<a id="sthref175"></a></div>
</div>
<!-- class="sect2" -->
<a id="CEGFJBJC"></a>
<div id="JJDEV13565" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref176"></a>Logging in Oracle JVM</h3>
<p>Oracle JVM extends the JDK Java Logging API in the area of logging properties lookup to enhance security of logging configuration management and to support logging configurations on a user basis.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about Java Logging APIs, visit the following site:
<p><code><a href="http://docs.oracle.com/javase/7/docs/">http://docs.oracle.com/javase/7/docs/</a></code></p>
</div>
<p>You must activate the <a id="sthref177"></a><code>LogManager</code> in the session to initialize the logging properties in Oracle JVM. The logging properties are initialized once per session with the <code>LogManager</code> API that is extended with the database resident resource lookup.</p>
<p>Oracle JVM performs the following steps to configure logging options:</p>
<ol>
<li id="CEGDJFCG">
<p>If the <code>java.util.logging.config.class</code> property is set, then the logging behavior is the same as in standard JDK.</p>
</li>
<li id="CEGGCACF">
<p>If the <code>java.util.logging.config.class</code> property is not set, then Oracle JVM inspects the availability of the <code>javavm/lib/<a id="sthref178"></a>logging.properties</code> resource in the current user schema.</p>
<p>If available, this resource is used as the configuration setting for the <code>LogManager</code> and the <code>java.util.logging.config.file</code> property is set.</p>
</li>
<li id="CEGBGJHC">
<p>If both the above conditions do not hold true, then the <code>java.util.logging.config.file</code> property is inspected and if specified, it is used as described in <code>LogManager</code> API.</p>
</li>
<li>
<p>If none of the conditions in step <a href="#CEGDJFCG">1</a>, <a href="#CEGGCACF">2</a>, and <a href="#CEGBGJHC">3</a> holds true, then the <code>javavm/lib/logging.properties</code> resource in the <code>SYS</code> schema is used. This resource is a copy of the <code>$(java.home)/lib/logging.properties</code> file that is loaded into the <code>SYS</code> schema at database creation time. This means, by default, the <code>LogManager</code> behaves as if it is configured as per the <code>$(java.home)/javavm/lib/logging.properties</code> file. However, altering this file has no effect until the database is re-created</p>
</li>
</ol>
<p>If you are not satisfied with the default settings in the <code>javavm/lib/logging.properties</code> file, then prepare a different set of properties and load them in your schema using the <code>loadjava</code> command. For example, if your schema is <code>HR</code> and your current file directory is <code>mydir</code>, then create a directory <code>javavm/lib/</code> under <code>mydir</code> and specify the required properties in the <code>logging.properties</code> file under the <code>mydir/javavm/lib/</code> directory. Then, invoke the <code>loadjava</code> command from <code>mydir</code> as follows:</p>
<pre>mydir% loadjava -u HR -v -r javavm/lib/logging.properties
password:<span class="italic">&lt;password&gt;</span>
</pre>
<p>After invoking the <code>loadjava</code> command, you can delete the <code>mydir/javavm/lib/logging.properties</code> file. Any session running as <code>HR</code> and performing activation of <code>LogManager</code> will have the <code>LogManager</code> configured with properties coming from this database resident resource private to <code>HR</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle JVM always runs with a security manager. So, <code>HR</code> must be granted logging permissions, regardless of the logging configuration method used. In most cases, the following call issued by a privileged user is sufficient to grant these permissions:
<pre>call dbms_java.grant_permission( &#39;HR&#39;,  &#39;SYS:java.util.logging.LoggingPermission&#39;, &#39;control&#39;, &#39;&#39; );
</pre></div>
</div>
<!-- class="sect2" -->
<a id="BABIAIIA"></a>
<div id="JJDEV02043" class="sect2">
<h3 class="sect2">Loading <a id="sthref179"></a><a id="sthref180"></a><a id="sthref181"></a><a id="sthref182"></a><a id="sthref183"></a><a id="sthref184"></a>Classes</h3>
<p><a id="ABC2731000"></a>This section gives an overview of loading your classes into the database using the <code>loadjava</code> tool. You can use the <code>loadjava</code> tool to create schema objects from files and load the schema objects to different schemas. For example,</p>
<pre>loadjava -u HR -schema TEST MyClass.java
Password: <span class="italic">password</span>
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You do <span class="italic">not</span> have to load the classes to the database as schema objects if you use the command-line interface. For example,
<pre>C:\oraclehome\bin&gt;loadjava -u HR MyClass.java
Password: <span class="italic">password</span>
</pre>
<p>For more information about the command-line interface, refer to <a href="chthree.htm#CHDJHBGH">&#34;Using Command-Line Interface&#34;</a>.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cheleven.htm#CACCBHIC">Chapter 12, &#34;Schema Objects and Oracle JVM Utilities&#34;</a></div>
<p>You can also run the <code>loadjava</code> tool from within SQL commands. Unlike a conventional JVM, which compiles and loads from files, Oracle JVM compiles and loads from database schema objects.</p>
<p><a href="#CEGFBCFA">Table 2-5</a> describes database schema objects that correspond to the files used by a conventional JVM.</p>
<div id="JJDEV13076" class="tblformal">
<p class="titleintable"><a id="sthref185"></a><a id="CEGFBCFA"></a>Table 2-5 Description of Java Files</p>
<table class="cellalignment4009" title="Description of Java Files" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t17">Java File Types</th>
<th class="cellalignment4003" id="r1c2-t17">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t17" headers="r1c1-t17">
<p><a id="sthref186"></a><a id="sthref187"></a><code>.java</code> source files or <code>.sqlj</code> source files</p>
</td>
<td class="cellalignment4004" headers="r2c1-t17 r1c2-t17">
<p>correspond to Java s<a id="sthref188"></a>ource schema objects</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t17" headers="r1c1-t17">
<p><a id="sthref189"></a><code>.class</code> compiled Java files</p>
</td>
<td class="cellalignment4004" headers="r3c1-t17 r1c2-t17">
<p>correspond to Java <a id="sthref190"></a><a id="sthref191"></a>class schema objects</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t17" headers="r1c1-t17">
<p><code><a id="sthref192"></a><a id="sthref193"></a>.properties</code> Java resource files, <code>.ser</code> SQLJ profile files, or data files</p>
</td>
<td class="cellalignment4004" headers="r4c1-t17 r1c2-t17">
<p>correspond to Java <a id="sthref194"></a>resource schema objects</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>You must load all classes or resources into the database to be used by other classes within the database. In addition, at load time, you define who can run your classes within the database.</p>
<p><a href="#CEGEDDGB">Table 2-6</a> describes the activities the <code>loadjava</code> tool performs for each type of file.</p>
<div id="JJDEV13077" class="tblformal">
<p class="titleintable"><a id="sthref195"></a><a id="CEGEDDGB"></a>Table 2-6 loadjava Operations on Schema Objects</p>
<table class="cellalignment4009" title="loadjava Operations on Schema Objects" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t18">Schema Object</th>
<th class="cellalignment4003" id="r1c2-t18">loadjava Operations on Objects</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t18" headers="r1c1-t18">
<p><a id="sthref196"></a><code>.java</code> source files</p>
</td>
<td class="cellalignment4004" headers="r2c1-t18 r1c2-t18">
<ol>
<li>
<p>Creates a Java <a id="sthref197"></a>source schema object in the definer&#39;s schema unless another schema is specified.</p>
</li>
<li>
<p>Loads the contents of the source file into a schema object.</p>
</li>
<li>
<p>Creates a class schema object for all classes defined in the source file.</p>
</li>
<li>
<p>If <code>-resolve</code> is requested, compiles the source schema object and resolves the class and its dependencies. It then stores the compiled class into a class schema object.</p>
</li>
</ol>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t18" headers="r1c1-t18">
<p><code><a id="sthref198"></a>.sqlj</code> source files</p>
</td>
<td class="cellalignment4004" headers="r3c1-t18 r1c2-t18">
<ol>
<li>
<p>Creates a <a id="sthref199"></a>source schema object in the definer&#39;s schema unless another schema is specified.</p>
</li>
<li>
<p>Loads contents of the source file into the schema object.</p>
</li>
<li>
<p>Creates a class schema object for all classes and resources defined in the source file.</p>
</li>
<li>
<p>If <code>-resolve</code> is requested, translates and compiles the source schema object and stores the compiled class into a class schema object. It then stores the profile into a <code>.ser</code> resource schema object and customizes it.</p>
</li>
</ol>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t18" headers="r1c1-t18">
<p><a id="sthref200"></a><code>.class</code> compiled Java files</p>
</td>
<td class="cellalignment4004" headers="r4c1-t18 r1c2-t18">
<ol>
<li>
<p>Creates a <a id="sthref201"></a><a id="sthref202"></a>class schema object in the definer&#39;s schema unless another schema is specified.</p>
</li>
<li>
<p>Loads the class file into the schema object.</p>
</li>
<li>
<p>Resolves and verifies the class and its dependencies if <code>-resolve</code> is specified.</p>
</li>
</ol>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r5c1-t18" headers="r1c1-t18">
<p><code><a id="sthref203"></a>.properties</code> Java resource files</p>
</td>
<td class="cellalignment4004" headers="r5c1-t18 r1c2-t18">
<ol>
<li>
<p>Creates a <a id="sthref204"></a>resource schema object in the definer&#39;s schema unless another schema is specified.</p>
</li>
<li>
<p>Loads a resource file into a schema object.</p>
</li>
</ol>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r6c1-t18" headers="r1c1-t18">
<p><code><a id="sthref205"></a>.ser</code> SQLJ profile</p>
</td>
<td class="cellalignment4004" headers="r6c1-t18 r1c2-t18">
<ol>
<li>
<p>Creates a <a id="sthref206"></a>resource schema object in the definer&#39;s schema unless another schema is specified.</p>
</li>
<li>
<p>Loads the <code>.ser</code> resource file into a schema object and customizes it.</p>
</li>
</ol>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><a id="sthref207"></a>The <code>dropjava</code> tool performs the reverse of the <code>loadjava</code> tool. It deletes schema objects that correspond to Java files. Always use the <code>dropjava</code> tool to delete a Java schema object created with the <code>loadjava</code> tool. For example,</p>
<pre>dropjava -u HR -schema TEST MyClass.java
Password: <span class="italic">password</span>
</pre>
<p>Dropping with SQL data definition language (DDL) commands will not update the auxiliary data maintained by the <code>loadjava</code> tool and the <code>dropjava</code> tool. You can also run the <code>dropjava</code> tool from within SQL commands.</p>
<p><a id="sthref208"></a>After loading the classes and resources, you can access the <code><a id="sthref209"></a>USER_OBJECTS</code> view in your database schema to verify whether your classes and resources have been loaded properly.</p>
<p class="subhead2"><a id="BEJECHIJ"></a><a id="JJDEV13078"></a>Sharing of Metadata for User Classloaded Classes</p>
<p>Classes loaded by the built-in mechanism for loading database resident classes are known as <span class="bold">system classloaded</span>, whereas those loaded by other means are called <span class="bold">user classloaded</span>. When you load a class into the database, a representation of the class is created in memory, part of which is referred to here as the class metadata. The class metadata is the same for any session using the class and is potentially sharable. Earlier, such sharing was available only for system classloaded classes. Since Oracle Database 11<span class="italic">g</span>, you can also share class metadata of user classloaded classes, at the discretion of the system administrator.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="appendixb.htm#BGBBBJAE">Appendix B, &#34;Classpath Extensions and User Classloaded Metadata&#34;</a></div>
<p class="subhead2"><a id="JJDEV13079"></a>Defining the Same Class Twice</p>
<p><a id="sthref210"></a>You cannot have two class objects with the same name in the same schema. This rule affects you in two ways:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An exception to this rule is when you use the <code>-prependjarnames</code> option for database resident JARs. If you use this option, then you can have two classes with the same class name in the same schema. For more information about database resident JARs, see <a href="#BEJCBAHI">&#34;Database Resident JARs&#34;</a>.</div>
<ul>
<li>
<p>You can load either a particular Java <code>.class</code> file or its <code>.java</code> file, but not both.</p>
<p>Oracle Database tracks whether you loaded a class file or a source file. If you want to update the class, then you must load the same type of file that you originally loaded. If you want to update the other type, then you must drop the first before loading the second. For example, if you loaded <code>x.java</code> as the source for class <code>y</code>, then to load <code>x.class</code>, you must first drop <code>x.java</code>.</p>
</li>
<li>
<p>You cannot define the same class within two different schema objects in the same schema. For example, suppose <code>x.java</code> defines class <code>y</code> and you want to move the definition of <code>y</code> to <code>z.java</code>. If <code>x.java</code> has already been loaded, then the <code>loadjava</code> tool rejects any attempt to load <code>z.java</code>, which also defines <code>y</code>. Instead, do either of the following:</p>
<ul>
<li>
<p>Drop <code>x.java</code>, load <code>z.java</code>, which defines <code>y</code>, and then load the new <code>x.java</code>, which does not define <code>y</code>.</p>
</li>
<li>
<p>Load the new <code>x.java</code>, which does not define <code>y</code>, and then load <code>z.java</code>, which defines <code>y</code>.</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chone.htm#CBBEDCBF">&#34;System Classes&#34;</a></div>
<p class="subhead2"><a id="JJDEV13080"></a><a id="sthref211"></a>Designating Database Privileges and JVM Permissions</p>
<p>You must have the following SQL database privileges to load classes:</p>
<ul>
<li>
<p><code>CREATE PROCEDURE</code> and <code>CREATE TABLE</code> privileges to load into your schema.</p>
</li>
<li>
<p><code>CREATE ANY PROCEDURE</code> and <code>CREATE ANY TABLE</code> privileges to load into another schema.</p>
</li>
<li>
<p><code>oracle.aurora.security.JServerPermission.loadLibraryInClass.</code> <code><span class="codeinlineitalic">classname</span></code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chten.htm#BABCFFIB">&#34;Permission for Loading Classes&#34;</a></div>
</li>
</ul>
<p class="subhead2"><a id="JJDEV13081"></a><a id="sthref212"></a>Loading JAR or ZIP Files</p>
<p>The <code>loadjava</code> tool accepts <code>.class</code>, <code>.java</code>, <code>.properties</code>, <code>.sqlj</code>, <code>.ser</code>, <code>.jar</code>, or <code>.zip</code> files. The JAR or ZIP files can contain source, class, and data files. When you pass a JAR or ZIP file to the <code>loadjava</code> tool, it opens the archive and loads the members of the archive individually. There is no JAR or ZIP schema object. If the JAR or ZIP content has not changed since the last time it was loaded, then it is not reloaded. Therefore, there is little performance penalty for loading JAR or ZIP files. In fact, loading JAR or ZIP files is the simplest way to use the <code>loadjava</code><a id="sthref213"></a> tool.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
O<a id="sthref214"></a>racle Database does not reload a class if it has not changed since the last load. However, you can force a class to be reloaded using the <code>-force</code> option.</div>
<p class="subhead2"><a id="BEJCBAHI"></a><a id="JJDEV13082"></a>Database Resident JARs</p>
<p>Starting with 11<span class="italic">g</span> release 1 (11.1), when you load the contents of a JAR into the database, you have the option of creating a database object representing the JAR itself. In this way, you can retain an association between this JAR object and the class, resource, and source objects loaded from the JAR. This enables you to:</p>
<ul>
<li>
<p>Use signed JARs and JAR namespace segregation in the same way as you use them in standard JVM.</p>
</li>
<li>
<p>Manage the classes that you have derived from a JAR while loading it into the database as a single unit. This helps you to prevent individual redefinition of the classes loaded from the JAR. It also enables you to drop the whole set of classes loaded from the JAR, irrespective of the contents or the continued existence of the JAR on the external file system, at the time of dropping it.</p>
</li>
</ul>
<p>In order to load a JAR into the database, you have the following options of the <code>loadjava</code> tool:</p>
<ul>
<li>
<p><code>-jarsasdbobjects</code></p>
</li>
<li>
<p><code>-prependjarnames</code></p>
</li>
</ul>
<p>For more information regarding the <code>loadjava</code> tool options, refer to <a href="cheleven.htm#CACFHDJE">&#34;The loadjava Tool&#34;</a> section.</p>
</div>
<!-- class="sect2" -->
<a id="BABBIEBH"></a>
<div id="JJDEV13083" class="sect2">
<h3 class="sect2">Granting <a id="sthref215"></a><a id="sthref216"></a>Execute Rights</h3>
<p><a id="sthref217"></a>If you load all classes within your own schema and do not reference any class outside your schema, then you already have rights to run the classes. You have the privileges necessary for your objects to call other objects loaded in the same schema. That is, the ability for class <code>A</code> to call class <code>B</code>. Class <code>A</code> must be given the right to call class <code>B</code>.</p>
<p><a id="sthref218"></a>The classes that define a Java application are stored within Oracle Database under the SQL schema of their owner. By default, classes that reside in one user&#39;s schema cannot be run by other users, because of security concerns. You can provide other users the right to run your class in the following ways:</p>
<ul>
<li>
<p>Using the <code>loadjava -grant</code> option</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cheleven.htm#CACFHDJE">&#34;The loadjava Tool&#34;</a></div>
</li>
<li>
<p>Using the following command:</p>
<pre>SQL&gt; grant execute on myclass to HR;
</pre>
<p>where, <code>myclass</code> is the name of the underlying Java class.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prior to Oracle Database 11<span class="italic">g</span> release 1 (11.1), granting execute right to a stored procedure meant granting execute right to both the stored procedure and the Java class referred by the stored procedure. Since Oracle Database 11<span class="italic">g</span> release, if you want to grant execute right on the underlying Java class as well, then you must grant execute right on the class explicitly. This is implemented for better security.</div>
<p><a href="#CEGFCIGG">Figure 2-3</a> illustrates the rights required to run classes.</p>
<div id="JJDEV13084" class="figure">
<p class="titleinfigure"><a id="CEGFCIGG"></a>Figure 2-3 Rights to Run Classes</p>
<img width="266" height="99" src="img/exeright.gif" alt="Description of Figure 2-3 follows"/><br/>
<a id="sthref219" href="img_text/exeright.htm">Description of &#34;Figure 2-3 Rights to Run Classes&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chnine.htm#BABDCIBH">Chapter 9, &#34;Oracle Database Java Application Performance&#34;</a> for information about JVM security permissions</div>
</div>
<!-- class="sect2" -->
<a id="BABGIEBA"></a>
<div id="JJDEV13085" class="sect2">
<h3 class="sect2">Controlling the Current User</h3>
<p>During the execution of PL/SQL code, there is always a current user. The same concept is used for the execution of Java code. Initially, the current user is the user, who creates the session that invokes the Java code. A Java method is called from SQL or PL/SQL through a corresponding wrapper. Java wrappers are special PL/SQL entities, which expose Java methods to SQL and PL/SQL as PL/SQL stored procedures or functions. Such a wrapper might change the current effective user. The wrappers that change the current effective user to the owner of the wrapper are called definer&#39;s rights wrappers. If a wrapper does not change the current effective user, then the effective user remains unchanged.</p>
<p>By default, Java wrappers are <a id="sthref220"></a>definer&#39;s rights wrappers. If you want to override this, then create the wrapper using the <code>AUTHID CURRENT_USER</code> option.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chsix.htm#BABBDIEF">&#34;Writing Top-Level Call Specifications&#34;</a> for more information about the <code>AUTHID CURRENT_USER</code> option</div>
<p>At any time during the execution of Java code, a Java call stack is maintained. The stack contains frames corresponding to Java methods entered, with the innermost frame corresponding to the currently executing method. By default, Java methods execute on the stack without changing the current user, that is, with the privileges of their current effective invoker, not their definer.</p>
<p>You can load a Java class to the database with the <code>loadjava -definer</code> option. Any method of a class having the definer attribute marked, becomes a definer&#39;s rights method. When such a method is entered, a special kind of frame called a definer&#39;s frame is created onto the Java stack. This frame switches the current effective user to the owner (definer) of such a class. A new user ID remains effective for all inner frames until either the definer&#39;s frame is popped off the stack or a nested definer&#39;s frame is entered.</p>
<p>Thus, at any given time during the execution of a Java method that is called from SQL or PL/SQL through its wrapper, the effective user is one of the following:</p>
<ul>
<li>
<p>The innermost definer&#39;s frame on the Java stack</p>
</li>
<li>
<p>Either the owner of the PL/SQL wrapper of the topmost Java method, if it is definer&#39;s rights, or the user who called the wrapper.</p>
</li>
</ul>
<p>Consider a company that uses a definer&#39;s rights procedure to analyze sales. To provide local sales statistics, the procedure <code>analyze</code> must access <code>sales</code> tables that reside at each regional site. To do this, the procedure must also reside at each regional site. This causes a maintenance problem. To solve the problem, the company installs an invoker&#39;s rights version of the procedure <code>analyze</code> at headquarters.</p>
<p><a href="#BABFBIBJ">Figure 2-4</a> shows how all regional sites can use the same procedure to query their own <code>sales</code> tables.</p>
<div id="JJDEV13086" class="figure">
<p class="titleinfigure"><a id="BABFBIBJ"></a>Figure 2-4 Invoker&#39;s rights Solution</p>
<img width="349" height="144" src="img/invoker_rights_solution.gif" alt="Description of Figure 2-4 follows"/><br/>
<a id="sthref221" href="img_text/invoker_rights_solution.htm">Description of &#34;Figure 2-4 Invoker&#39;s rights Solution&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Occasionally, you may want to override the default invoker&#39;s rights behavior. Suppose headquarters wants the <code>analyze</code> procedure to calculate sales commissions and update a central <code>payroll</code> table. This presents a problem, because invokers of <code>analyze</code> should not have direct access to the <code>payroll</code> table, which stores employee salaries and other sensitive data.</p>
<p><a href="#BABDDBAD">Figure 2-5</a> illustrates the solution, where the <code>analyze</code> procedure call the definer&#39;s rights procedure, <code>calcComm</code>, which in turn updates the <code>payroll</code> table.</p>
<div id="JJDEV13087" class="figure">
<p class="titleinfigure"><a id="BABDDBAD"></a>Figure 2-5 Indirect Access</p>
<img width="349" height="203" src="img/controlled_access.gif" alt="Description of Figure 2-5 follows"/><br/>
<a id="sthref222" href="img_text/controlled_access.htm">Description of &#34;Figure 2-5 Indirect Access&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="BABEFGAD"></a>
<div id="JJDEV13088" class="sect2">
<h3 class="sect2"><a id="sthref223"></a><a id="sthref224"></a>Checking Java Uploads</h3>
<p>You can query the <code><a id="sthref225"></a>USER_OBJECTS</code> database view to obtain information about schema objects that you own, including Java sources, classes, and resources. This enables you, for example, to verify whether sources, classes, or resources that you load are properly stored in schema objects.</p>
<p><a href="#BABJHIGG">Table 2-7</a> lists the key columns in <code>USER_OBJECTS</code> and their description.</p>
<div id="JJDEV13089" class="tblformal">
<p class="titleintable"><a id="sthref226"></a><a id="BABJHIGG"></a>Table 2-7 Key USER_OBJECT Columns</p>
<table class="cellalignment4009" title="Key USER_OBJECT Columns" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t28">Name</th>
<th class="cellalignment4003" id="r1c2-t28">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t28" headers="r1c1-t28">
<p><code>OBJECT_NAME</code></p>
</td>
<td class="cellalignment4004" headers="r2c1-t28 r1c2-t28">
<p>Name of the object</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t28" headers="r1c1-t28">
<p><code>OBJECT_TYPE</code></p>
</td>
<td class="cellalignment4004" headers="r3c1-t28 r1c2-t28">
<p>Type of the object, such as <code>JAVA SOURCE</code>, <code>JAVA CLASS</code>, or <code>JAVA RESOURCE</code>.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t28" headers="r1c1-t28">
<p><code>STATUS</code></p>
</td>
<td class="cellalignment4004" headers="r4c1-t28 r1c2-t28">
<p>Status of the object. The values can be either <code>VALID</code> or <code>INVALID</code>. It is always <code>VALID</code> for <code>JAVA RESOURCE</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="JJDEV13090"></a>Object Name and Type</p>
<p>An <code>OBJECT_NAME</code> in <code>USER_OBJECTS</code> is the alias. The fully qualified name is stored as an alias if it exceeds 30 characters.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABEGDFJ">&#34;Shortened Class Names&#34;</a> for information about fully qualified names and aliases.</div>
<p><a id="sthref227"></a><a id="sthref228"></a>If the server uses an alias for a schema object, then you can use the <code><a id="sthref229"></a>LONGNAME()</code> function of the <code>DBMS_JAVA</code> package to receive it from a query as a fully qualified name, without having to know the alias or the conversion rules.</p>
<pre>SQL&gt; SELECT dbms_java.longname(object_name) FROM user_objects WHERE object_type=&#39;JAVA SOURCE&#39;;
</pre>
<p>This statement displays the fully qualified name of the Java source schema objects. Where no alias is used, no conversion occurs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL and PL/SQL are <span class="italic">not</span> case-sensitive.</div>
<p><a id="sthref230"></a>You can use the <code>SHORTNAME()</code> function of the <code>DBMS_JAVA</code> package to use a fully qualified name as a query criterion, without having to know whether it was converted to an alias in the database.</p>
<pre>SQL*Plus&gt; SELECT object_type FROM user_objects WHERE object_name=dbms_java.shortname(&#39;known_fullname&#39;);
</pre>
<p>This statement displays the <code>OBJECT_TYPE</code> of the schema object with the specified fully qualified name. This presumes that the fully qualified name is representable in the database character set.</p>
<pre>SQL&gt; select * from javasnm;
SHORT LONGNAME
----------------------------------------------------------------------
/78e6d350_BinaryExceptionHandl sun/tools/java/BinaryExceptionHandler
/b6c774bb_ClassDeclaration sun/tools/java/ClassDeclaration
/af5a8ef3_JarVerifierStream1 sun/tools/jar/JarVerifierStream$1
</pre>
<p>This statement displays all the data stored in the <code>javasnm</code> view.</p>
<p class="subhead2"><a id="JJDEV13091"></a>Status</p>
<p><code>STATUS</code> is a character string that indicates the validity of a Java schema object. A Java source schema object is <code>VALID</code> if it compiled successfully, and a Java class schema object is <code>VALID</code> if it was resolved successfully. A Java resource schema object is always <code>VALID</code>, because resources are not resolved.</p>
<p class="subhead2"><a id="JJDEV13092"></a>Example: Accessing <a id="sthref231"></a>USER_OBJECTS</p>
<p>The following SQL*Plus script accesses the <code>USER_OBJECTS</code> view to display information about uploaded Java sources, classes, and resources:</p>
<pre>COL object_name format a30
COL object_type format a15
SELECT object_name, object_type, status
       FROM user_objects
       WHERE object_type IN (&#39;JAVA SOURCE&#39;, &#39;JAVA CLASS&#39;, &#39;JAVA RESOURCE&#39;)
       ORDER BY object_type, object_name;
</pre>
<p>You can optionally use wildcards in querying <code>USER_OBJECTS</code>, as in the following example:</p>
<pre>SELECT object_name, object_type, status
       FROM user_objects
       WHERE object_name LIKE &#39;%Alerter&#39;;
</pre>
<p>The preceding statement finds any <code>OBJECT_NAME</code> entries that end with the characters <code>Alerter</code>.</p>
</div>
<!-- class="sect2" -->
<a id="BABBFBFG"></a>
<div id="JJDEV13093" class="sect2">
<h3 class="sect2">Publis<a id="sthref232"></a><a id="sthref233"></a>hing</h3>
<p>Oracle Database enables clients and SQL to call Java methods that are loaded in the database after they are published. You publish either the object itself or individual methods. If you write a Java stored procedure that you intend to call with a trigger, directly or indirectly in SQL data manipulation language (DML) or in PL/SQL, then you must publish individual methods in the class. Using a call specification, specify how to access the method. Java programs consist of many methods in many classes. However, only a few <code>static</code> methods are typically exposed with call specifications.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chsix.htm#BABEBDGB">Chapter 6, &#34;Publishing Java Classes With Call Specifications&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="CEGFFFCB"></a>
<div id="JJDEV13094" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref234"></a>Auditing</h3>
<p>In releases prior to Oracle Database 10g release 2 (10.2), Java classes in the database cannot be audited directly. However, you can audit the PL/SQL wrapper. Typically, all Java stored procedures are started from some wrappers. Therefore, all Java stored procedures can be audited, though not directly.</p>
<p>Since Oracle Database 10g release 2 (10.2), you can audit DDL statements for creating, altering, or dropping Java source, class, and resource schema objects, as with any other DDL statement. Oracle Database provides auditing options for auditing Java activities easily and directly. You can also audit any modification of Java sources, classes, and resources.</p>
<p><a id="sthref235"></a>You can audit database activities related to Java schema objects at two different levels, statement level and object level. At the statement level you can audit all activities related to a special pattern of statements.</p>
<p><a href="#CEGCDDIG">Table 2-8</a> lists the statement auditing options and the corresponding SQL statements related to Java schema objects.</p>
<div id="JJDEV13095" class="tblformal">
<p class="titleintable"><a id="sthref236"></a><a id="CEGCDDIG"></a>Table 2-8 Statement Auditing Options Related to Java Schema Objects</p>
<table class="cellalignment4009" title="Statement Auditing Options Related to Java Schema Objects" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t32">Statement Option</th>
<th class="cellalignment4003" id="r1c2-t32">SQL Statements</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t32" headers="r1c1-t32">
<p><code>CREATE JAVA SOURCE</code></p>
</td>
<td class="cellalignment4004" headers="r2c1-t32 r1c2-t32">
<p><code>CREATE JAVA SOURCE</code></p>
<p><code>CREATE OR REPLACE JAVA SOURCE</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t32" headers="r1c1-t32">
<p><code>ALTER JAVA SOURCE</code></p>
</td>
<td class="cellalignment4004" headers="r3c1-t32 r1c2-t32">
<p><code>ALTER JAVA SOURCE</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t32" headers="r1c1-t32">
<p><code>DROP JAVA SOURCE</code></p>
</td>
<td class="cellalignment4004" headers="r4c1-t32 r1c2-t32">
<p><code>DROP JAVA SOURCE</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r5c1-t32" headers="r1c1-t32">
<p><code>CREATE JAVA CLASS</code></p>
</td>
<td class="cellalignment4004" headers="r5c1-t32 r1c2-t32">
<p><code>CREATE JAVA CLASS</code></p>
<p><code>CREATE OR REPLACE JAVA CLASS</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r6c1-t32" headers="r1c1-t32">
<p><code>ALTER JAVA CLASS</code></p>
</td>
<td class="cellalignment4004" headers="r6c1-t32 r1c2-t32">
<p><code>ALTER JAVA CLASS</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r7c1-t32" headers="r1c1-t32">
<p><code>DROP JAVA CLASS</code></p>
</td>
<td class="cellalignment4004" headers="r7c1-t32 r1c2-t32">
<p><code>DROP JAVA CLASS</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r8c1-t32" headers="r1c1-t32">
<p><code>CREATE JAVA RESOURCE</code></p>
</td>
<td class="cellalignment4004" headers="r8c1-t32 r1c2-t32">
<p><code>CREATE JAVA RESOURCE</code></p>
<p><code>CREATE OR REPLACE JAVA RESOURCE</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r9c1-t32" headers="r1c1-t32">
<p><code>ALTER JAVA RESOURCE</code></p>
</td>
<td class="cellalignment4004" headers="r9c1-t32 r1c2-t32">
<p><code>ALTER JAVA RESOURCE</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r10c1-t32" headers="r1c1-t32">
<p><code>DROP JAVA RESOURCE</code></p>
</td>
<td class="cellalignment4004" headers="r10c1-t32 r1c2-t32">
<p><code>DROP JAVA RESOURCE</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>For example, if you want to audit the <code>ALTER JAVA SOURCE</code> DDL statement, then enter the following statement at the SQL prompt:</p>
<pre>AUDIT ALTER JAVA SOURCE
</pre>
<p><a id="sthref237"></a>Object level auditing provides finer granularity. It enables you to identify specific problems by zooming into specific objects.</p>
<p><a href="#CEGBGHFF">Table 2-9</a> lists the object auditing options for each Java schema object. The entry X in a cell indicates that the corresponding SQL command can be audited for that Java schema object. The entry NA indicates that the corresponding SQL command is not applicable for that Java schema object.</p>
<div id="JJDEV13096" class="tblformal">
<p class="titleintable"><a id="sthref238"></a><a id="CEGBGHFF"></a>Table 2-9 Object Auditing Options Related to Java Schema Options</p>
<table class="cellalignment4009" title="Object Auditing Options Related to Java Schema Options" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t33">Object Option</th>
<th class="cellalignment4003" id="r1c2-t33">Java Source</th>
<th class="cellalignment4003" id="r1c3-t33">Java Resource</th>
<th class="cellalignment4003" id="r1c4-t33">Java Class</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t33" headers="r1c1-t33">
<p><code>ALTER</code></p>
</td>
<td class="cellalignment4004" headers="r2c1-t33 r1c2-t33">
<p>X</p>
</td>
<td class="cellalignment4004" headers="r2c1-t33 r1c3-t33">
<p>NA</p>
</td>
<td class="cellalignment4004" headers="r2c1-t33 r1c4-t33">
<p>X</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t33" headers="r1c1-t33">
<p><code>EXECUTE</code></p>
</td>
<td class="cellalignment4004" headers="r3c1-t33 r1c2-t33">
<p>NA</p>
</td>
<td class="cellalignment4004" headers="r3c1-t33 r1c3-t33">
<p>NA</p>
</td>
<td class="cellalignment4004" headers="r3c1-t33 r1c4-t33">
<p>X</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t33" headers="r1c1-t33">
<p><code>AUDIT</code></p>
</td>
<td class="cellalignment4004" headers="r4c1-t33 r1c2-t33">
<p>X</p>
</td>
<td class="cellalignment4004" headers="r4c1-t33 r1c3-t33">
<p>X</p>
</td>
<td class="cellalignment4004" headers="r4c1-t33 r1c4-t33">
<p>X</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r5c1-t33" headers="r1c1-t33">
<p><code>GRANT</code></p>
</td>
<td class="cellalignment4004" headers="r5c1-t33 r1c2-t33">
<p>X</p>
</td>
<td class="cellalignment4004" headers="r5c1-t33 r1c3-t33">
<p>X</p>
</td>
<td class="cellalignment4004" headers="r5c1-t33 r1c4-t33">
<p>X</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DBSEG006" href="../DBSEG/part_6.htm#DBSEG006"><span class="italic">Oracle Database Security Guide</span></a></p>
</li>
<li>
<p><a class="olink SQLRF01107" href="../SQLRF/statements_4007.htm#SQLRF01107"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFAEJI"></a>
<div id="JJDEV13097" class="sect1">
<h2 class="sect1">User <a id="sthref239"></a><a id="sthref240"></a>Interfaces on the Server</h2>
<p>Oracle Database furnishes all core Java class libraries on the server, including those associated with presentation of the user interfaces. However, it is inappropriate for code running on the server to attempt to materialize or display a user interface on the server. Users running applications in Oracle JVM environment should not be expected nor allowed to interact with or depend on the display and input hardware of the server where Oracle Database is running.</p>
<p>To address compatibility issues on platforms that do not support display, keyboard, or mouse, Java 1.4 outlines Headless Abstract Window Toolkit (AWT) support. The Headless AWT API introduces a new <code>public</code> run-time exception class, <code>java.awt.HeadlessException</code>. The constructors of the <code>Applet</code> class, all heavy-weight components, and many of the methods in the <code>Toolkit</code> and <code>GraphicsEnvironment</code> classes, which rely on the native display devices, are changed to throw <code>HeadlessException</code> if the platform does not support a display. In Oracle Database, user interfaces are supported only on client applications. Accordingly, Oracle JVM is a Headless Platform and throws <code>HeadlessException</code> if these methods are called.</p>
<p>Most AWT computation that does not involve accessing the underlying native display or input devices is allowed in Headless AWT. In fact, Headless AWT is quite powerful as it provides programmers access to fonts, imaging, printing, and color and ICC manipulation. For example, applications running in Oracle JVM can parse, manipulate, and write out images as long as they do not try to physically display it on the server. The standard JVM implementation can be started in the Headless mode, by supplying the <code>-Djava.awt.headless=true</code> property, and run with the same Headless AWT restrictions as Oracle JVM does. Oracle JVM fully complies with the Java Compatibility Kit (JCK) with respect to Headless AWT.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<code><a href="http://www.oracle.com/technetwork/articles/javase/headless-136834.html">http://www.oracle.com/technetwork/articles/javase/headless-136834.html</a></code></div>
<p>Oracle JVM takes a similar approach for sound support. Applications in Oracle JVM are not allowed to access the underlying sound system for purposes of sound playback or recording. Instead, the system sound resources appear to be unavailable in a manner consistent with the sound API specification of the methods that are trying to access the resources. For example, methods in <code>javax.sound.midi.MidiSystem</code> that attempt to access the underlying system sound resources throw the <code>MidiUnavailableException</code> checked exception to signal that the system is unavailable. However, similar to the Headless AWT support, Oracle Database supports the APIs that allow sound file manipulation, free of the native sound devices. Oracle JVM also fully complies with the JCK, when it implements the sound API.</p>
</div>
<!-- class="sect1" -->
<a id="BABEGDFJ"></a>
<div id="JJDEV13098" class="sect1">
<h2 class="sect1">Shortened <a id="sthref241"></a><a id="sthref242"></a>Class Names</h2>
<p>Each Java source, class, and resource is stored in its own schema object in the server. The name of the schema object is derived from the fully qualified name, which includes relevant path or package information. Dots are replaced by slashes.</p>
<p>Schema object names, however, have a maximum of only 30 characters, and all characters must be legal and convertible to characters in the database character set. If any fully qualified name is longer than 30 characters or contains illegal or nonconvertible characters, then Oracle Database converts it to a short name, or alias, to use as the name of the schema object. Oracle Database keeps track of both the names and how to convert between them. If the fully qualified name is 30 characters or less and has no illegal or inconvertible characters, then it is used as the schema object name.</p>
<p><a id="sthref243"></a>Because Java classes and methods can have names exceeding the maximum SQL identifier length, Oracle Database uses abbreviated names internally for SQL access. Oracle Database provides the <code>LONGNAME()</code> function within the <code>DBMS_JAVA</code> package for retrieving the original Java class name for any truncated name.</p>
<pre>FUNCTION longname (shortname VARCHAR2) RETURN VARCHAR2
</pre>
<p>This function returns the fully qualified name of the Java schema object, which is specified using its alias. The following is an example of a statement used to display the fully qualified name of classes that are invalid:</p>
<pre>SELECT dbms_java.<a id="sthref244"></a>longname (object_name) FROM user_objects WHERE object_type = &#39;JAVA CLASS&#39; and status = &#39;INVALID&#39;;
</pre>
<p><a id="sthref245"></a>You can also specify a full name to the database by using the <code>SHORTNAME()</code> function of the <code>DBMS_JAVA</code> package. The function takes a full name as input and returns the corresponding short name. This function is useful for verifying whether the classes are loaded successfully, by querying the <code>USER_OBJECTS</code> view.</p>
<pre>FUNCTION shortname (longname VARCHAR2) RETURN VARCHAR2
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chone.htm#CBBEDCBF">&#34;System Classes&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="BABHHJDJ"></a>
<div id="JJDEV13099" class="sect1">
<h2 class="sect1"><a id="sthref246"></a>Class.<a id="sthref247"></a>forName() in Oracle Database</h2>
<p>The JLS provides the following description of <code>Class.forName()</code>:</p>
<p>Given the fully qualified name of a class, this method attempts to locate, load, and link the class. If it succeeds, then a reference to the <code>Class</code> object for the class is returned. If it fails, then an instance of <code><a id="sthref248"></a><a id="sthref249"></a>ClassNotFoundException</code> is thrown.</p>
<p>Class lookup is always on behalf of a referencing class and is done through an instance of <code>ClassLoader</code>. The difference between the Java Development Kit (JDK) implementation and Oracle JVM implementation is the method in which the class is found:</p>
<ul>
<li>
<p><a id="sthref250"></a>The JDK uses one instance of <code>ClassLoader</code> that searches the set of directory tree roots specified by the <code><a id="sthref251"></a>CLASSPATH</code> environment variable.</p>
</li>
<li>
<p>Oracle JVM defines several resolvers that specify how to locate classes. Every class has a resolver associated with it, and each class can, potentially, have a different resolver. When you run a method that calls <code>Class.forName()</code>, the resolver of the currently running class, which is <code>this</code>, is used to locate the class.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABGJCAJ">&#34;Resolving Class Dependencies&#34;</a></div>
</li>
</ul>
<p>You can receive unexpected results if you try to locate a class with an incorrect resolver. For example, if a class <code>X</code> in schema <code>X</code> requests a class <code>Y</code> in schema <code>Y</code> to look up class <code>Z</code>, you will experience an error if you expected the resolver of class <code>X</code> to be used. Because class <code>Y</code> is performing the lookup, the resolver associated with class <code>Y</code> is used to locate class <code>Z</code>. In summary, if the class exists in another schema and you specified different resolvers for different classes, as would happen by default if they are in different schemas, you may not find the class.</p>
<p>You can solve this resolver problem as follows:</p>
<ul>
<li>
<p>Avoid any class name lookup by passing the <code>Class</code> object itself.</p>
</li>
<li>
<p>Supply the <code>ClassLoader</code> instance in the <code>Class.forName()</code> method.</p>
</li>
<li>
<p>Supply the class and the schema it resides in to the <code>classForNameAndSchema()</code> method.</p>
</li>
<li>
<p>Supply the schema and class name to <code><a id="sthref252"></a>ClassForName.lookupClass()</code>.</p>
</li>
<li>
<p>Serialize your objects with the schema name and the class name.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Another unexpected behavior can occur if system classes invoke <code>Class.forName()</code>. The desired class is found only if it resides in <code>SYS</code> or in <code>PUBLIC</code>. If your class does not exist in either <code>SYS</code> or <code>PUBLIC</code>, then you can declare a <code>PUBLIC</code> synonym for the class.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABBHHBA">Supply ClassLoader in Class.forName()</a></p>
</li>
<li>
<p><a href="#BABJDCFF">Supply Class and Schema Names to classForNameAndSchema()</a></p>
</li>
<li>
<p><a href="#BABCEJDH">Supply Class and Schema Names to lookupClass()</a></p>
</li>
<li>
<p><a href="#BABCCACJ">Supply Class and Schema Names when Serializing</a></p>
</li>
<li>
<p><a href="#BABGBHGB">Class.forName Example</a></p>
</li>
</ul>
<a id="BABBHHBA"></a>
<div id="JJDEV13100" class="sect2">
<h3 class="sect2">Supply ClassLoader in Class.forName()</h3>
<p>Oracle Database uses resolvers for locating classes within schemas. Every class has a specified resolver associated with it, and each class can have a different resolver associated with it. As a result, the locating of classes is dependent on the definition of the associated resolver. The <code>ClassLoader</code> instance knows which resolver to use, based on the class that is specified. When you supply a <code>ClassLoader</code> instance to <code>Class.forName()</code>, your class is looked up in the schemas defined in the resolver of the class. The syntax of this variant of <code>Class.forName()</code> is as follows:</p>
<pre>Class.forName (String name, boolean initialize, ClassLoader loader);
</pre>
<p>The following examples show how to supply the class loader of either the current class instance or the calling class instance.</p>
<div id="JJDEV13101" class="example">
<p class="titleinexample"><a id="sthref253"></a>Example 2-1 Retrieve Resolver from Current Class</p>
<p>You can retrieve the class loader of any instance by using the <code>Class.getClassLoader()</code> method. The following example retrieves the class loader of the class represented by instance <code>x</code>:</p>
<pre>Class c1 = Class.forName (x.whatClass(), true, x.getClass().getClassLoader());
</pre></div>
<!-- class="example" -->
<div id="JJDEV13102" class="example">
<p class="titleinexample"><a id="sthref254"></a>Example 2-2 Retrieve Resolver from Calling Class</p>
<p>You can retrieve the class of the instance that called the running method by using the <code>oracle.aurora.vm.OracleRuntime.<a id="sthref255"></a><a id="sthref256"></a>getCallerClass()</code> method. After you retrieve the class, call the <code>Class.<a id="sthref257"></a><a id="sthref258"></a>getClassLoader()</code> method on the returned class. The following example retrieves the class of the instance that called the <code>workForCaller()</code> method. Then, its class loader is retrieved and supplied to the <code>Class.forName()</code> method. As a result, the resolver used for looking up the class is the resolver of the calling class.</p>
<pre>void workForCaller()
{
  ClassLoader c1=oracle.aurora.vm.OracleRuntime.getCallerClass().getClassLoader();
  ...
  Class c=Class.forName(name, true, c1);
  ...
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABJDCFF"></a>
<div id="JJDEV13103" class="sect2">
<h3 class="sect2">Supply Class and Schema Names to <a id="sthref259"></a>classForNameAndSchema()</h3>
<p>You can resolve the problem of where to find the class by supplying the resolver, which can identify the schemas to be searched. Alternatively, you can supply the schema in which the class is loaded. If you know in which schema the class is loaded, then you can use the <code>classForNameAndSchema()</code> method, which is in the <code>DbmsJava</code> class provided by Oracle Database. This method takes both the name of the class and the schema in which the class resides and locates the class within the designated schema.</p>
<div id="JJDEV13104" class="example">
<p class="titleinexample"><a id="sthref260"></a>Example 2-3 Providing Schema and Class Names</p>
<p>The following example shows how you can save the schema and class names using the <code>save()</code> method. Both names are retrieved, and the class is located using the <code>DbmsJava.classForNameAndSchema()</code> method.</p>
<pre>import oracle.aurora.rdbms.ClassHandle;
import oracle.aurora.rdbms.Schema;
import oracle.aurora.rdbms.DbmsJava;

void save (Class c1)
{
  ClassHandle handle = ClassHandle.lookup(c1);
  Schema schema = handle.schema();
  writeName (schema.getName());
  writeName (c1.getName());
}

Class restore()
{
  String schemaName = readName();
  String className = readName();
  return DbmsJava.classForNameAndSchema (schemaName, className);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABCEJDH"></a>
<div id="JJDEV13105" class="sect2">
<h3 class="sect2">Supply Class and Schema Names to l<a id="sthref261"></a><a id="sthref262"></a>ookupClass()</h3>
<p>You can supply a <code>String</code> value containing both the schema and class names to the <code>oracle.aurora.util.ClassForName.lookupClass()</code> method. When called, this method locates the class in the specified schema. The string must be in the following format:</p>
<pre>&#34;&lt;schema&gt;:&lt;class&gt;&#34;
</pre>
<p>For example, to locate <code>com.package.myclass</code> in the <code>HR</code> schema, use the following:</p>
<pre>oracle.aurora.util.ClassForName.lookupClass(&#34;HR:com.package.myclass&#34;);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Use uppercase characters for the schema name. In this case, the schema name is case-sensitive.</div>
</div>
<!-- class="sect2" -->
<a id="BABCCACJ"></a>
<div id="JJDEV13106" class="sect2">
<h3 class="sect2">Supply Class and Schema Names when Serializing</h3>
<p><a id="sthref263"></a>When you deserialize a class, part of the operation is to lookup a class based on a name. To ensure that the lookup is successful, the serialized object must contain both the class and schema names.</p>
<p>Oracle Database provides the following classes for serializing and deserializing objects:</p>
<ul>
<li>
<p><code>oracle.aurora.rdbms.<a id="sthref264"></a>DbmsObjectOutputStream</code></p>
<p>This class extends <code>java.io.<a id="sthref265"></a>ObjectOutputStream</code> and adds schema names in the appropriate places.</p>
</li>
<li>
<p><code>oracle.aurora.rdbms.<a id="sthref266"></a>DbmsObjectInputStream</code></p>
<p>This class extends <code>java.io.<a id="sthref267"></a>ObjectInputStream</code> and reads streams written by <code>DbmsObjectOutputStream</code>. You can use this class in any environment. If used within Oracle Database, then the schema names are read out and used when performing the class lookup. If used on a client, then the schema names are ignored.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABGBHGB"></a>
<div id="JJDEV13107" class="sect2">
<h3 class="sect2">Class.forName Example</h3>
<p>The following example shows several methods for looking up a class:</p>
<pre>import oracle.aurora.vm.OracleRuntime;
import oracle.aurora.rdbms.Schema;
import oracle.aurora.rdbms.DbmsJava;

public class ForName
{
  private Class from;
  
  /* Supply an explicit class to the constructor */
  public ForName(Class from)
  {
    this.from = from;
  }
  
  /* Use the class of the code containing the &#34;new ForName()&#34; */
  public ForName()
  {
    from = OracleRuntime.getCallerClass();
  }

  /* lookup relative to Class supplied to constructor */
  public Class lookupWithClassLoader(String name) throws ClassNotFoundException
  {
    /* A ClassLoader uses the resolver associated with the class*/
    return Class.forName(name, true, from.getClassLoader());
  }

  /* In case the schema containing the class is known */
  static Class lookupWithSchema(String name, String schema)
  {
    Schema s = Schema.lookup(schema);
    return DbmsJava.classForNameAndSchema(name, s);
  }
}
</pre>
<p>The preceding example uses the following methods for locating a class:</p>
<ul>
<li>
<p>To use the resolver of the class of an instance, call <code>lookupWithClassLoader()</code>. This method supplies a class loader to the <code>Class.forName()</code> method in the <code>from</code> variable. The class loader specified in the <code>from</code> variable defaults to this class.</p>
</li>
<li>
<p>To use the resolver from a specific class, call <code>ForName()</code> with the designated class name, followed by <code>lookupWithClassLoader()</code>. The <code>ForName()</code> method sets the <code>from</code> variable to the specified class. The <code>lookupWithClassLoader()</code> method uses the class loader from the specified class.</p>
</li>
<li>
<p>To use the resolver from the calling class, first call the <code>ForName()</code> method without any parameters. It sets the <code>from</code> variable to the calling class. Then, call the <code>lookupWithClassLoader()</code> method to locate the class using the resolver of the calling class.</p>
</li>
<li>
<p>To lookup a class in a specified schema, call the <code>lookupWithSchema()</code> method. This provides the class and schema name to the <code>classForNameAndSchema()</code> method.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABEFEBH"></a>
<div id="JJDEV13108" class="sect1">
<h2 class="sect1">Managing Your Operating System Resources</h2>
<p><a id="sthref268"></a><a id="sthref269"></a>Operating system resources are a limited commodity on any computer. Because Java is targeted at providing a computing platform as well as a programming language, it contains platform-independent classes and frameworks for accessing platform-specific resources. <a id="sthref270"></a>The Java class methods access operating system resources through JVM. Java has potential problems with this model because programmers rely on the garbage collector to manage all resources, when all that the garbage collector manages is Java objects and not the operating system resources that the Java objects hold on to.</p>
<p>In addition, when you use shared servers, your operating system resources, which are contained within Java objects, can be invalidated if they are maintained across calls within a session.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABHEHAJ">&#34;Operating System Resources Affected Across Calls&#34;</a></div>
<p>The following sections discuss these potential problems:</p>
<ul>
<li>
<p><a href="#BABECGHF">Overview of Operating System Resources</a></p>
</li>
<li>
<p><a href="#BABHEFBC">Garbage Collection and Operating System Resources</a></p>
</li>
</ul>
<a id="BABECGHF"></a>
<div id="JJDEV13109" class="sect2">
<h3 class="sect2">Overview <a id="sthref271"></a>of Operatin<a id="sthref272"></a>g System Resources</h3>
<p><a id="sthref273"></a>In general, your operating system resources contain the following:</p>
<div class="inftblhruleinformalwide">
<table class="cellalignment4002" title="table" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t41">Operating System Resources</th>
<th class="cellalignment4003" id="r1c2-t41">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t41" headers="r1c1-t41">memory</td>
<td class="cellalignment4004" headers="r2c1-t41 r1c2-t41">Oracle Database manages memory internally, allocating memory as you create objects and freeing objects as you no longer need them. The language and class libraries do not support a direct means to allocate and free memory.
<p><span class="bold">See Also:</span> <a href="chone.htm#BABFHGBJ">&#34;Memory Spaces Management&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t41" headers="r1c1-t41">files and sockets</td>
<td class="cellalignment4004" headers="r3c1-t41 r1c2-t41">Java contains classes that represent file or socket resources. Instances of these classes hold on to the file or socket constructs, such as file handles, of the operating system.</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t41" headers="r1c1-t41">threads</td>
<td class="cellalignment4004" headers="r4c1-t41 r1c2-t41"><a id="sthref274"></a>Oracle JVM threads provide no additional scalability over what is provided by the database support of multiple concurrently executing sessions. However, Oracle JVM supports the full Java threading API.
<p><span class="bold">See Also:</span> <a href="#BABHHHDG">&#34;Threading in Oracle Database&#34;</a>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformalwide" -->
<p class="subhead2"><a id="JJDEV13110"></a>Operating System<a id="sthref275"></a> Resource Access</p>
<p>By default, a Java user does not have direct access to most operating system resources. A system administrator can give permissions to a user to access these resources by modifying JVM security restrictions. JVM security enforced upon system resources conforms to Java 2 security.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chten.htm#BABJBJGE">&#34;Java 2 Security&#34;</a></div>
<p class="subhead2"><a id="JJDEV13111"></a>Operating System Resourc<a id="sthref276"></a>e Lifetime</p>
<p>You can access operating system resources using the standard core Java classes and methods. Once you access a resource, the time that it remains active varies according to the type of resource. Memory is garbage collected. Files, threads, and sockets persist across calls when you use a dedicated mode server. In shared server mode, files, threads, and sockets terminate when the call ends.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABHEHAJ">&#34;Operating System Resources Affected Across Calls&#34;</a>.</div>
</div>
<!-- class="sect2" -->
<a id="BABHEFBC"></a>
<div id="JJDEV13112" class="sect2">
<h3 class="sect2">Garbage Collection and Operating <a id="sthref277"></a>System Resources</h3>
<p>Imagine that memory is divided into two realms: Java object memory and operating system constructs. The Java object memory realm contains all objects and variables. Operating system constructs include resources that the operating system allocates to the object when it asks. These resources include files, sockets, and so on.</p>
<p>Basic programming rules dictate that you close all memory, both Java objects and operating system constructs. Java programmers incorrectly assume that memory is freed by the garbage collector. The <a id="sthref278"></a><a id="sthref279"></a>garbage collector was created to collect all unused Java object memory. However, it does not close operating system constructs. All operating system constructs must be closed by the program before the Java object is garbage collected.</p>
<p><a id="sthref280"></a>For example, whenever an object opens a file, the operating system creates the file and gives the object a file handle. If the file is not closed, then the operating system holds <a id="sthref281"></a>the file handle construct open until the call ends or JVM exits. This may cause you to run out of these constructs earlier than necessary. There are a finite number of handles within each operating system. To guarantee that you do not run out of handles, close your resources before exiting the method. This includes closing the streams attached to your sockets before closing the socket.</p>
<p>For performance reasons, the garbage collector cannot examine each object to see if it contains a handle. As a result, the garbage collector collects Java objects and variables, but does not issue the appropriate operating system methods for freeing any handles.</p>
<p><a href="#BABEGIJC">Example 2-4</a> shows how to close the operating system constructs.</p>
<div id="JJDEV13113" class="example">
<p class="titleinexample"><a id="BABEGIJC"></a>Example 2-4 Closing Your <a id="sthref282"></a>Operating System Resources</p>
<pre>public static void addFile(String[] newFile)
{
  File inFile = new File(newFile);
  FileReader in = new FileReader(inFile);
  int i;

  while ((i = in.read()) != -1)
    out.write(i);

  /*closing the file, which frees up the operating system file handle*/
  in.close();
}
</pre></div>
<!-- class="example" -->
<p>If you do not close <code>inFile</code>, then eventually the <code>File</code> object will be garbage collected. Even after the <code>File</code> object is garbage collected, the operating system treats the file as if it were in use, because it was not closed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You may want to use Java finalizers to close resources. However, <a id="sthref283"></a>finalizers are not guaranteed to run in a timely manner. Instead, finalizers are put on a queue to run when the garbage collector has time. If you close your resources within your finalizer, then it might not be freed until JVM exits. The best approach is to close your resources within the method.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGJEEEA"></a>
<div id="JJDEV13632" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref284"></a>Using the Runtime.exec Functionality in Oracle Database</h2>
<p>Java Virtual Machine fully supports the family of Java Standard Edition <code>java.lang.Runtime.exec</code> methods. These methods spawn a new operating system (OS) process to run a user-supplied command. On the server, you must use these methods with caution. In Java Virtual Machine, OS command execution permissions are not granted to all database users by default and are issued only by privileged administrators. If you are a DBA, then you must go through the <a href="chten.htm#CACIGEEJ">&#34;Secure Use of Runtime.exec Functionality in Oracle Database&#34;</a> section and follow the recommendations. Also, you must be selective about issuing these permissions to database users.</p>
</div>
<!-- class="sect1" -->
<a id="CHDFAJIG"></a>
<div id="JJDEV13114" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Managing Your Applications Using JMX</h2>
<p>This section contain the following topics:</p>
<ul>
<li>
<p><a href="#BABDEBIG">Overview of JMX</a></p>
</li>
<li>
<p><a href="#BEJHFDAI">Enabling and Starting JMX in a Session</a></p>
</li>
<li>
<p><a href="#BEJDAJAE">Oracle JVM JMX Defaults and Configurability</a></p>
</li>
<li>
<p><a href="#BEJEJHAD">Examples of SQL calls to dbms_java.start_jmx_agent</a></p>
</li>
<li>
<p><a href="#BABECFEC">Using JConsole to Monitor and Control Oracle JVM</a></p>
</li>
<li>
<p><a href="#BEJGCCIA">Important Security Notes</a></p>
</li>
<li>
<p><a href="#CEGGDJFG">Shared Server Limitations for JMX</a></p>
</li>
</ul>
<a id="BABDEBIG"></a>
<div id="JJDEV13115" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Overview of JMX</h3>
<p>JMX (Java Management Extensions) is a Java technology that supplies tools for managing and monitoring applications, system objects, devices, service-oriented networks, and JVM (Java Virtual Machine). This API allows its classes to be dynamically constructed and changed. So, you can use this technology to monitor and manage resources as they are created, installed, and implemented. The JMX API also includes remote access, so a remote management program can interact with a running application for these purposes.</p>
<p>In JMX, a given resource is instrumented by one or more Java objects known as MBeans (Managed Beans). These MBeans are registered in a core managed object server, known as an MBean server, that acts as a management agent and can run on most devices enabled for the Java programming language. A JMX agent consists of an MBean server, in which MBeans are registered, and a set of services for handling MBeans.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><code><a href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html</a></code></p>
</li>
<li>
<p><code><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html">http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html</a></code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BEJHFDAI"></a>
<div id="JJDEV13116" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Enabling and Starting JMX in a Session</h3>
<p>To help in enabling and running JMX services in sessions running Java, the <code>JMXSERVER</code> role and the <code>dbms_java.start_jmx_agent</code> procedure are provided. The <code>JMXSERVER</code> role is granted specific Java permissions that enable you to start and run MBeanServer and JMX agent in a session. The procedure <code>dbms_java.start_jmx_agent</code> starts the agent in a specific session that generally remains active for the duration of the session. Perform the following to enable and start JMX:</p>
<ol>
<li>
<p>Obtain <code>JMXSERVER</code> from <code>SYS</code> or <code>SYSTEM</code>:</p>
<pre>SQL&gt; grant jmxserver to HR;
</pre>
<p>where, <code>HR</code> is the user name.</p>
</li>
<li>
<p>Invoke the procedure <code>dbms_java.start_jmx_agent</code> to startup JMX in the session. The <code>dbms_java.start_jmx_agent</code> procedure can be invoked with the following arguments:</p>
<p><code>port</code>: the port for the JMX listener. The value of this parameter sets the Java property <code>com.sun.management.jmxremote.port</code>.</p>
<p><code>ssl</code>: sets the value for the Java property <code>com.sun.management.jmxremote.ssl</code>. Case for <code>true</code> and <code>false</code> values is ignored.</p>
<p><code>auth</code>: the value for the property <code>com.sun.management.jmxremote.authenticate</code>, otherwise a semicolon-separated list of Java Authentication and Authorization Service (JAAS) credentials. The value is not case-sensitive.</p>
<p>Each of these arguments can be <code>null</code> or omitted, with <code>null</code> as the default value. when an argument is <code>null</code>, it does not alter the previously present value of the corresponding property in the session.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Java properties corresponding to the parameters of <code>dbms_java.start_jmx_agent</code> are from the set of Java properties specified in standard Java 5.0 JMX documentation. For the full list of Java JMX properties please refer to <code><a href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html</a></code></div>
<p>The <code>dbms_java.start_jmx_agent</code> procedure starts an agent activating OJVM JMX server and a listener. The JMX server runs as one or more daemon threads in the current session and in general is available for the duration of the session. Once JMX Agent is started in a session, Java code running in the session can be monitored.</p>
<p>The <code>dbms_java.start_jmx_agent</code> procedure is a PL/SQL wrapper for the Java method <code>oracle.aurora.rdbms.JMXAgent.startOJVMAgent</code>, which by itself can also be called programmatically from Java stored procedures. The <code>startOJVMAgent</code> method starts the JMX Server and the JMX connectivity daemon threads, and then exits. On dedicated servers, these threads may remain active for the duration of the session, but go into an inert state for the time intervals between calls. When these intervals are short, then the same socket connections resume transparently. This enables clients such as JConsole to remain connected across multiple calls.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CEGGDJFG">&#34;Shared Server Limitations for JMX&#34;</a></div>
<p>A different mode of JMX monitoring is possible with the <code>EXIT_CALL_WHEN_ALL_THREADS_TERMINATE</code> policy. By setting the call exit policy to <code>OracleRuntime.EXIT_CALL_WHEN_ALL_THREADS_TERMINATE</code>, you can configure the session to run JMX server continuously in a call that invokes the <code>startOJVMAgent</code> method till the Java call is exited programmatically. This mode is convenient when various Java tasks are fired up from a JMX client as operations of specific MBeans. This way, continuous JMX management and monitoring is driven by these operations. Please refer to the JVM JMX demo for such a bean, for example, <code>jmxserv.Load</code>.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BEJDAJAE"></a>
<div id="JJDEV13117" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle JVM JMX Defaults and Configurability</h3>
<p>When <code>dbms_java.start_jmx_agent</code> is activated, the property <code>com.sun.management.jmxremote</code> is set to <code>true</code>. Before invoking <code>start_jmx_agent</code>, a JMXSERVER-privileged user can preset various management properties in the following ways:</p>
<ul>
<li>
<p>Using the PL/SQL function <code>dbms_java.set_property</code></p>
</li>
<li>
<p>Invoking method <code>java.lang.System.setProperty</code></p>
</li>
</ul>
<p>The <code>JMXSERVER</code> role user can also preset the properties in database resident Java resource specified by Java property <code>com.sun.management.config.file</code>. The default name for this resource, tried when <code>com.sun.management.config.file</code> is not set, is <code>lib.management.management.properties</code>. This resource mechanism is Oracle JVM extension of standard file-based JMX configuration management. This mechanism is superior for Oracle JVM as it provides more security and per-schema management. When the resource does not exist in schema, a file-read is attempted as a fall-back. The default file path, tried when <code>com.sun.management.config.file</code> is not set, is <code>$(java.home)/lib/management/management.properties</code>. In Oracle Database 12<span class="italic">c</span> this file contains the following presets:</p>
<pre>com.sun.management.jmxremote.ssl.need.client.auth = true
com.sun.management.jmxremote.authenticate = false
</pre>
<p>The property <code>com.sun.management.jmxremote.ssl.need.client.auth</code> in conjunction with <code>com.sun.management.jmxremote.ssl</code>, sets JMX for two-way encrypted SSL authentication with client and server certificates. The default value of <code>com.sun.management.jmxremote.ssl</code> is <code>true</code>. This configuration is the default and is preferred over JAAS password authentication.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information visit the following:
<ul>
<li>
<p><code><a href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html</a></code></p>
</li>
<li>
<p><code><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html">http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html</a></code></p>
</li>
</ul>
</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The default JMX Login Module providing file-based store for passwords is not supported in Oracle JVM for security reasons. So, if JAAS password authentication must be used instead of SSL client authentication, then pass transient JAAS credentials securely as the <code>auth</code> parameter to <code>dbms_java.start_jmx_agent</code> as illustrated in this section, or configure JMX to use a secure custom LDAP login module.</div>
</div>
<!-- class="sect2" -->
<a id="BEJEJHAD"></a>
<div id="JJDEV13118" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Examples of SQL calls to dbms_java.start_jmx_agent</h3>
<p>Following are some examples of starting the JMX server:</p>
<ul>
<li>
<p>Starts the JMX server and the listener using the default settings as described in the preceding sections or the values set earlier in the same session:</p>
<pre>call dbms_java.start_jmx_agent();
</pre></li>
<li>
<p>Starts the JMX server and the listener using the default settings as described in the preceding sections or the values set earlier in the same session:</p>
<pre>call dbms_java.start_jmx_agent(null, null, null);
</pre></li>
<li>
<p>Starts the JMX server and the listener on port 9999 with the other JMX settings having the default values or the values set earlier in the same session:</p>
<pre>call dbms_java.start_jmx_agent(&#39;9999&#39;);
</pre></li>
<li>
<p>Starts the JMX server and the listener on port 9999 with the other JMX settings having the default values or the values set earlier in the same session:</p>
<pre>call dbms_java.start_jmx_agent(&#39;9999&#39;, null, null);
</pre></li>
<li>
<p>Starts the JMX server and the listener with the JMX settings having the default values or the values set earlier in the same session and with JAAS credentials <code>monitorRole/1z2x</code> and <code>controlRole/2p3o</code>:</p>
<pre>call dbms_java.start_jmx_agent(null, null, &#39;monitorRole/1z2x;controlRole/2p3o&#39;);
</pre>
<p>These credentials are transient. The property <code>com.sun.management.jmxremote.authenticate</code> is set to <code>true</code>.</p>
</li>
<li>
<p>Starts JMX listener on port 9999 with no SSL and no JAAS authentication. Used only for development or demonstration.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BEJGCCIA">&#34;Important Security Notes&#34;</a></div>
<pre>call dbms_java.start_jmx_agent(&#39;9999&#39;, &#39;false&#39;, &#39;false&#39;);
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABECFEC"></a>
<div id="JJDEV13119" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using JConsole to Monitor and Control Oracle JVM</h3>
<p>This section describes how to use JConsole, a standard JMX client tool, for monitoring and controlling Oracle JVM. JConsole is a part of standard Java JDK.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#BABIDDHF">The jconsole Command</a></p>
</li>
<li>
<p><a href="#BABBHCGJ">The JConsole interface</a></p>
</li>
<li>
<p><a href="#BABBECEI">The OracleRuntime MBean</a></p>
</li>
<li>
<p><a href="#BABBIAEA">Memory Thresholds</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
To monitor Java in the database with JConsole, you should have a server-side Java session running JMX Agent. For more information refer <a href="#BEJHFDAI">Enabling and Starting JMX in a Session</a>.</div>
<a id="BABIDDHF"></a>
<div id="JJDEV13120" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">The jconsole Command</h4>
<p>Use the <code>jconsole</code> command syntax to start JConsole. The simplest format to start the JConsole tool is the following:</p>
<pre>jconsole [hostName:portNum]
</pre>
<p>where:</p>
<ul>
<li>
<p><code>hostname</code> is the name of the system running the application</p>
</li>
<li>
<p><code>portNum</code> is the port number of the JMX listener</p>
</li>
</ul>
<p>In the following examples, we connect to a host with name <code>example.com</code> through default port 9999. This mode assumes no authentication and encryption. This mode is adequate only for demo or testing, and can be used to connect to Oracle JVM JMX sessions that are started with the following command:</p>
<pre>call dbms_java.start_jmx_agent(<span class="italic">portNum</span>, false, false);
</pre>
<p>Remember that you can connect to and interact with Oracle JVM from JConsole, only when the daemon threads of the server are running and are not dormant. This means that there should be an active Java call in the session, which is running the JMX server on the specified port. During the time interval between subsequent Java calls, JMX server preserves its state and statistics, but is unable to communicate with JConsole.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BEJGCCIA">Important Security Notes</a></div>
</div>
<!-- class="sect3" -->
<a id="BABBHCGJ"></a>
<div id="JJDEV13121" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">The JConsole interface</h4>
<p>The JConsole interface consists of the following tabs:</p>
<ul>
<li>
<p>Summary tab</p>
<p>It displays summary information on Oracle JVM and the values monitored by JMX. For more information see <a href="#BABFIFIJ">Viewing Oracle JVM Summary Information</a>.</p>
</li>
<li>
<p>Memory tab</p>
<p>It displays information on memory usage. For more information see <a href="#BABDCJDG">Monitoring Memory Consumption</a>.</p>
</li>
<li>
<p>Threads tab</p>
<p>It displays information on thread usage. For more information see <a href="#BABJCGJB">Monitoring Thread Use</a>.</p>
</li>
<li>
<p>Classes tab</p>
<p>It displays information on class loading. For more information see <a href="#BABIEGAA">Monitoring Class Loading</a>.</p>
</li>
<li>
<p>MBeans tab</p>
<p>It displays information on MBeans. For more information see <a href="#BABGFHAD">Monitoring and Managing MBeans</a>.</p>
</li>
<li>
<p>VM tab</p>
<p>It displays information on Oracle JVM. For more information see <a href="#BABCJCAG">Viewing VM Information</a>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Important:</p>
In Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the data collected and passed to JConsole is limited to the Oracle JVM session that runs the JMX agent. This data does not include the attributes of other sessions that may be running in Oracle JVM. One exception is the <code>OracleRuntime</code> MBean that provides information about many WholeJVM_ Attributes and operations of Oracle JVM. For more information on <code>OracleRuntime</code> MBean, refer to <a href="#BABBECEI">&#34;The OracleRuntime MBean&#34;</a>.</div>
<p class="subhead2"><a id="BABFIFIJ"></a><a id="JJDEV13122"></a>Viewing Oracle JVM Summary Information</p>
<p>You can use the Summary tab of the JConsole interface to view Oracle JVM Summary Information. This tab displays key monitoring information on thread usage, memory consumption, class loading, and other VM and operating system specifics.</p>
<p>If JConsole successfully connects to an Oracle JVM session running a JMX Agent, then the Overview Tab looks the following figure:</p>
<div id="JJDEV13123" class="figure">
<p class="titleinfigure"><a id="sthref285"></a>Figure 2-6 The Overview Tab of the JConsole Interface</p>
<img width="900" height="723" src="img/summary_tab.gif" alt="Description of Figure 2-6 follows"/><br/>
<a id="sthref286" href="img_text/summary_tab.htm">Description of &#34;Figure 2-6 The Overview Tab of the JConsole Interface&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p><a href="#BABBHEFH">Table 2-10</a> provides description of the fields present in the Overview tab.</p>
<div id="JJDEV13124" class="tblhruleformal">
<p class="titleintable"><a id="sthref287"></a><a id="BABBHEFH"></a>Table 2-10 Description of the Overview Tab Fields in JConsole Interface</p>
<table class="cellalignment4002" title="Description of the Overview Tab Fields in JConsole Interface" summary="Description of the Summary tab field." dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t54">Field</th>
<th class="cellalignment4003" id="r1c2-t54">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t54" headers="r1c1-t54">
<p>Uptime</p>
</td>
<td class="cellalignment4004" headers="r2c1-t54 r1c2-t54">
<p>The duration for which the Oracle JVM session has been running.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t54" headers="r1c1-t54">
<p>Process CPU time</p>
</td>
<td class="cellalignment4004" headers="r3c1-t54 r1c2-t54">
<p>This information is not gathered for Oracle JVM sessions in Oracle Database 12<span class="italic">c</span> Release 1 (12.1).</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t54" headers="r1c1-t54">
<p>Live threads</p>
</td>
<td class="cellalignment4004" headers="r4c1-t54 r1c2-t54">
<p>The current number of live daemon and non-daemon threads.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r5c1-t54" headers="r1c1-t54">
<p>Peak</p>
</td>
<td class="cellalignment4004" headers="r5c1-t54 r1c2-t54">
<p>Highest number of live threads since Oracle JVM started.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r6c1-t54" headers="r1c1-t54">
<p>Daemon threads</p>
</td>
<td class="cellalignment4004" headers="r6c1-t54 r1c2-t54">
<p>Current number of live daemon threads.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r7c1-t54" headers="r1c1-t54">
<p>Total started</p>
</td>
<td class="cellalignment4004" headers="r7c1-t54 r1c2-t54">
<p>Total number of threads started since Oracle JVM started. It includes daemon, non-daemon, and terminated threads.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r8c1-t54" headers="r1c1-t54">
<p>Current heap size</p>
</td>
<td class="cellalignment4004" headers="r8c1-t54 r1c2-t54">
<p>Number of kilobytes currently occupied by the heap.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r9c1-t54" headers="r1c1-t54">
<p>Committed memory</p>
</td>
<td class="cellalignment4004" headers="r9c1-t54 r1c2-t54">
<p>Total amount of memory allocated for use by the heap.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r10c1-t54" headers="r1c1-t54">
<p>Maximum heap size</p>
</td>
<td class="cellalignment4004" headers="r10c1-t54 r1c2-t54">
<p>Maximum number of kilobytes occupied by the heap.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r11c1-t54" headers="r1c1-t54">
<p>Objects pending for finalization</p>
</td>
<td class="cellalignment4004" headers="r11c1-t54 r1c2-t54">
<p>Number of objects pending for finalization.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r12c1-t54" headers="r1c1-t54">
<p>Garbage collector information</p>
</td>
<td class="cellalignment4004" headers="r12c1-t54 r1c2-t54">
<p>Information about the garbage collector, which includes name, number of collections performed, and total time spent performing garbage collection.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r13c1-t54" headers="r1c1-t54">
<p>Current classes loaded</p>
</td>
<td class="cellalignment4004" headers="r13c1-t54 r1c2-t54">
<p>Number of classes currently loaded into memory for execution.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r14c1-t54" headers="r1c1-t54">
<p>Total classes loaded</p>
</td>
<td class="cellalignment4004" headers="r14c1-t54 r1c2-t54">
<p>Total number of classes loaded into session memory since the session started.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r15c1-t54" headers="r1c1-t54">
<p>Total classes unloaded</p>
</td>
<td class="cellalignment4004" headers="r15c1-t54 r1c2-t54">
<p>Number of classes unloaded from memory. Typically this is zero for Oracle Database 12<span class="italic">c</span> Release 1 (12.1).</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r16c1-t54" headers="r1c1-t54">
<p>Total physical memory</p>
</td>
<td class="cellalignment4004" headers="r16c1-t54 r1c2-t54">
<p>This information is not gathered for Oracle JVM sessions in Oracle Database 12<span class="italic">c</span> Release 1 (12.1). So, the value displayed is zero.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r17c1-t54" headers="r1c1-t54">
<p>Free physical memory</p>
</td>
<td class="cellalignment4004" headers="r17c1-t54 r1c2-t54">
<p>This information is not gathered for Oracle JVM sessions in Oracle Database 12<span class="italic">c</span> Release 1 (12.1). So, the value displayed is zero.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r18c1-t54" headers="r1c1-t54">
<p>Committed virtual memory</p>
</td>
<td class="cellalignment4004" headers="r18c1-t54 r1c2-t54">
<p>This information is not gathered for Oracle JVM sessions in Oracle Database 12<span class="italic">c</span> Release 1 (12.1). So, the value displayed is zero.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="subhead2"><a id="BABDCJDG"></a><a id="JJDEV13125"></a>Monitoring Memory Consumption</p>
<p>You can use the Memory tab of the JConsole interface to monitor memory consumption. This tab provides information on memory consumption and memory pools.</p>
<p><a href="#BABIJHFD">Figure 2-7</a> shows the Memory tab.</p>
<div id="JJDEV13126" class="figure">
<p class="titleinfigure"><a id="BABIJHFD"></a>Figure 2-7 The Memory Tab of the JConsole Interface</p>
<img width="664" height="504" src="img/memory_tab.gif" alt="Description of Figure 2-7 follows"/><br/>
<a id="sthref288" href="img_text/memory_tab.htm">Description of &#34;Figure 2-7 The Memory Tab of the JConsole Interface&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The chart on the Memory tab shows Oracle JVM memory usages versus time, for the whole memory space and also for specific memory pools. The memory pools available for Oracle JVM reflect the internal organization of Oracle JVM and correspond to object memories of Oracle JVM Memory Manager. The available memory pools in this release of Oracle Database are:</p>
<ul>
<li>
<p>New Generation Space</p>
<p>This is the memory pool from which memory is initially allocated for most objects. This pool is also referred to as the Eden Space.</p>
</li>
<li>
<p>Old Generation Space</p>
<p>This memory pool contains objects that have survived the garbage collection process in Eden Space. This pool is also referred to as the Survival Space.</p>
</li>
<li>
<p>Malloc/Free Space</p>
<p>This memory pool contains objects for which memory is allocated and freed in malloc/free fashion.</p>
</li>
<li>
<p>End of Migration Space</p>
<p>This memory pool contains objects surviving end-of-session migration.</p>
</li>
<li>
<p>Dedicated Session Space</p>
<p>This memory pool is used to allocate memory to session objects in Oracle Dedicated Sessions mode.</p>
</li>
<li>
<p>Paged Session Space</p>
<p>This memory pool is used to allocate memory to session objects that are big and paged.</p>
</li>
<li>
<p>Run space</p>
<p>This memory pool is used to allocate memory to temporary and auxiliary objects.</p>
</li>
<li>
<p>Stack space</p>
<p>This memory pool is used to allocate memory to temporary objects for which memory is allocated and freed in stack-like fashion.</p>
</li>
</ul>
<p>The Details area in the Memory tab displays current memory matrixes that include the following:</p>
<ul>
<li>
<p>Used</p>
<p>This matrix indicates the amount of memory currently used by the process running the session.</p>
</li>
<li>
<p>Committed</p>
<p>This matrix indicates the amount of memory guaranteed to be available for use by Oracle JVM, as if the memory has already been allocated. The amount of Committed memory may change over time. But Committed memory will always be greater than or equal to Used memory.</p>
</li>
<li>
<p>Max</p>
<p>This matrix indicates the maximum amount of memory that can be used for memory management. It usually corresponds to the initial configuration of Oracle JVM.</p>
</li>
</ul>
<p>The bar chart at the lower right corner of the Memory tab shows memory consumed by the individual memory pools. The bar turns red when the memory used exceeds the memory usage threshold. You can set the memory usage threshold through an attribute of the <code>MemoryMXBean</code>. For more information, see <a href="#BABBIAEA">Memory Thresholds</a>.</p>
<p class="subhead2"><a id="BABJCGJB"></a><a id="JJDEV13127"></a>Monitoring Thread Use</p>
<p>You can use the Threads tab of the JConsole interface to monitor thread usage.</p>
<div id="JJDEV13128" class="figure">
<p class="titleinfigure"><a id="sthref289"></a>Figure 2-8 The Threads Tab of the JConsole Interface</p>
<img width="666" height="504" src="img/thread_tab.gif" alt="Description of Figure 2-8 follows"/><br/>
<a id="sthref290" href="img_text/thread_tab.htm">Description of &#34;Figure 2-8 The Threads Tab of the JConsole Interface&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The chart on the Threads tab displays the number of live threads versus time, with a particular color representing a particular type of thread:</p>
<ul>
<li>
<p>Magenta signifies total number of threads</p>
</li>
<li>
<p>Red signifies peak number of threads</p>
</li>
<li>
<p>Blue signifies number of live threads</p>
</li>
</ul>
<p>The list of threads on this tab displays the active threads. Select a thread in the list to display information about that thread on the right pane. This information includes name, state, and stack trace of the thread.</p>
<p>The Filter field helps to narrow the threads.</p>
<p class="subhead2"><a id="BABIEGAA"></a><a id="JJDEV13129"></a>Monitoring Class Loading</p>
<p>You can use the Classes tab of the JConsole interface to monitor class loading. The chart on this tab plots the number of classes loaded versus time.</p>
<div id="JJDEV13130" class="figure">
<p class="titleinfigure"><a id="sthref291"></a>Figure 2-9 The Classes tab of the JConsole interface</p>
<img width="672" height="529" src="img/classes_tab.gif" alt="Description of Figure 2-9 follows"/><br/>
<a id="sthref292" href="img_text/classes_tab.htm">Description of &#34;Figure 2-9 The Classes tab of the JConsole interface&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p class="subhead2"><a id="BABGFHAD"></a><a id="JJDEV13131"></a>Monitoring and Managing MBeans</p>
<p>You can use the MBeans tab to monitor and manage MBeans. This tab displays information on all the MBeans registered with the platform MBean server.</p>
<p>The tree on the left pane of the MBean tab is called the MBean tree and it shows all the MBeans, organized according to their object Names. When you select an MBean in the MBean tree, then its attributes, operations, notifications, and other information are displayed on the right pane. For example, in <a href="#CEGBGEDE">Figure 2-10</a>, we have selected the <code>Old Generation</code> MemoryPool MBean in the MBean tree on the left and the attributes of the <code>Old Generation</code> MemoryPool MBean are displayed on the right.</p>
<div id="JJDEV13132" class="figure">
<p class="titleinfigure"><a id="CEGBGEDE"></a>Figure 2-10 Displaying the Attributes of an MBean</p>
<img width="576" height="411" src="img/mbeans_tab.gif" alt="Description of Figure 2-10 follows"/><br/>
<a id="sthref293" href="img_text/mbeans_tab.htm">Description of &#34;Figure 2-10 Displaying the Attributes of an MBean&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>You can set the values of an attribute, if it is writeable. The writeable values are displayed in blue color. For example, in <a href="#CEGBGEDE">Figure 2-10</a>, the attributes <code>CollectionUaageThreshold</code> and <code>UsageThreshold</code> are writable.</p>
<p>You can also display a chart of the values of an attribute versus time, by double-clicking on the attribute value. For example, if you click on the value of the <code>CollectionTime</code> property of the <code>GCManager</code> MBean, then you will see a chart similar to <a href="#BABHFJIC">Figure 2-11</a>:</p>
<div id="JJDEV13133" class="figure">
<p class="titleinfigure"><a id="BABHFJIC"></a>Figure 2-11 Displaying a Chart of the Values of an Attribute</p>
<img width="744" height="524" src="img/chart.gif" alt="Description of Figure 2-11 follows"/><br/>
<a id="sthref294" href="img_text/chart.htm">Description of &#34;Figure 2-11 Displaying a Chart of the Values of an Attribute&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>You can display the details of a complex attribute by clicking on the attribute. For example, you can display the details of <code>Usage</code> and <code>PeakUsage</code> attributes of the Memory Pools as shown in <a href="#BABEDCDH">Figure 2-12</a>:</p>
<div id="JJDEV13134" class="figure">
<p class="titleinfigure"><a id="BABEDCDH"></a>Figure 2-12 Displaying Details of a Complex Attribute in the MBeans Tab</p>
<img width="627" height="598" src="img/complex_attr.gif" alt="Description of Figure 2-12 follows"/><br/>
<a id="sthref295" href="img_text/complex_attr.htm">Description of &#34;Figure 2-12 Displaying Details of a Complex Attribute in the MBeans Tab&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The Operations tab of an MBean provides manageability interface. For example, garbage collection can be invoked on a Memory Pool or Memory Manager by clicking <span class="bold">Perform Garbage Collection</span>. The JMX demo of Oracle JVM, namely, <code>javavm/demo/jmx/</code>, provides several additional custom MBeans that are loaded into Oracle JVM. Here is an example shows the result of the <code>getProp</code> operation of the <code>DBProps</code> Mbean:</p>
<div id="JJDEV13135" class="figure">
<p class="titleinfigure"><a id="sthref296"></a>Figure 2-13 Operations Tab of the MBeans Tab of the JConsole Interface</p>
<img width="787" height="473" src="img/operations.gif" alt="Description of Figure 2-13 follows"/><br/>
<a id="sthref297" href="img_text/operations.htm">Description of &#34;Figure 2-13 Operations Tab of the MBeans Tab of the JConsole Interface&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p class="subhead2"><a id="BABCJCAG"></a><a id="JJDEV13136"></a>Viewing VM Information</p>
<p>You can use the VM tab of the JConsole interface to view VM information.</p>
<div id="JJDEV13137" class="figure">
<p class="titleinfigure"><a id="sthref298"></a>Figure 2-14 The VM Tab of the JConsole Interface</p>
<img width="596" height="590" src="img/vm_tab.gif" alt="Description of Figure 2-14 follows"/><br/>
<a id="sthref299" href="img_text/vm_tab.htm">Description of &#34;Figure 2-14 The VM Tab of the JConsole Interface&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="BABBECEI"></a>
<div id="JJDEV13138" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">The OracleRuntime MBean</h4>
<p>Starting from Oracle Database 11<span class="italic">g</span> Release 2 (11.2), a new MBean, <code>OracleRuntime</code> is added to the list of Oracle JVM platform MBeans, when the <code>dbms_java.start_jmx_agent</code> procedure is called. This MBean is specific to Oracle JVM.</p>
<p>The Attributes Tab of the <code>OracleRuntime</code> MBean exposes most of the parameters manipulated by the <code>oracle.aurora.vm.OracleRuntime</code> class. <a href="#BABGEHFG">Figure 2-15</a> shows the Attributes tab of the <code>OracleRuntime</code> MBean.</p>
<div id="JJDEV13139" class="figure">
<p class="titleinfigure"><a id="BABGEHFG"></a>Figure 2-15 Attributes Tab of the OracleRuntime MBean</p>
<img width="777" height="493" src="img/oracleruntimembean1.gif" alt="Description of Figure 2-15 follows"/><br/>
<a id="sthref300" href="img_text/oracleruntimembean1.htm">Description of &#34;Figure 2-15 Attributes Tab of the OracleRuntime MBean&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The parameters displayed in black color are read-only and cannot be modified. For example, <code>JavaPoolSize</code>, <code>Platform</code>, and so on. Values in blue color are read/write, which means you can modify them. Most of the attributes of the <code>OracleRuntime</code> MBean are local to the current session.</p>
<p>The <code>WholeJVM_</code> attributes of the <code>OracleRuntime</code> MBean are global. These attributes reflect the totals of Oracle JVM memory usage statistics across all Java-enabled sessions in the Database instance, as gathered from the <code>v$session</code> and <code>v$sesstat</code> performance views. <a href="#BABICDGG">Figure 2-16</a> displays the <code>WholeJVM_</code> attributes of the <code>OracleRuntime</code> MBean.</p>
<div id="JJDEV13140" class="figure">
<p class="titleinfigure"><a id="BABICDGG"></a>Figure 2-16 OracleRuntime MBean</p>
<img width="776" height="480" src="img/oracleruntimembean2.gif" alt="Description of Figure 2-16 follows"/><br/>
<a id="sthref301" href="img_text/oracleruntimembean2.htm">Description of &#34;Figure 2-16 OracleRuntime MBean&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The Operations Tab of the <code>OracleRuntime</code> MBean exposes many of the operations of the <code>oracle.aurora.vm.OracleRuntime</code> class.</p>
<p>In addition, individual memory consumption statistics of a specific Java-active Database session can be monitored using the <code>sessionsRunningJava</code> and <code>sessionDetailsBySID</code> operations as shown in <a href="#BABJFCEC">Figure 2-17</a> and <a href="#BABHDBFC">Figure 2-18</a>.</p>
<div id="JJDEV13141" class="figure">
<p class="titleinfigure"><a id="BABJFCEC"></a>Figure 2-17 Operation sessionsRunningJava</p>
<img width="778" height="484" src="img/oracleruntimembean3.gif" alt="Description of Figure 2-17 follows"/><br/>
<a id="sthref302" href="img_text/oracleruntimembean3.htm">Description of &#34;Figure 2-17 Operation sessionsRunningJava&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="JJDEV13142" class="figure">
<p class="titleinfigure"><a id="BABHDBFC"></a>Figure 2-18 Operation sessionDetailsBySID</p>
<img width="778" height="469" src="img/oracleruntimembean4.gif" alt="Description of Figure 2-18 follows"/><br/>
<a id="sthref303" href="img_text/oracleruntimembean4.htm">Description of &#34;Figure 2-18 Operation sessionDetailsBySID&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="BABBIAEA"></a>
<div id="JJDEV13143" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Memory Thresholds</h4>
<p>The usage threshold is a manageable attribute of the memory pools. Collection usage threshold is a manageable attribute of some of the garbage-collected memory pools. You can set each of these to a positive value to enable corresponding threshold checking for a pool. Setting a threshold to zero disables the threshold checking for the memory pool. By default, threshold checking for all Oracle JVM pools is disabled.</p>
<p>The usage threshold and the collection usage threshold are set in the MBeans tab. For example, if you select the Old Generation memory pool from the tree on the left pane, and set the usage threshold of this memory pool to 20 megabytes and the collection threshold to 1 megabyte, then after a while, the threshold counts will show the number of threshold crossing events as shown in <a href="#BABCIIBF">Figure 2-19</a>:</p>
<div id="JJDEV13144" class="figure">
<p class="titleinfigure"><a id="BABCIIBF"></a>Figure 2-19 Setting the Usage Threshold and Collection Usage Threshold in the MBeans Tab</p>
<img width="725" height="498" src="img/memory_threshold.gif" alt="Description of Figure 2-19 follows"/><br/>
<a id="sthref304" href="img_text/memory_threshold.htm">Description of &#34;Figure 2-19 Setting the Usage Threshold and Collection Usage Threshold in the MBeans Tab&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>When the memory usage of the Old Generation memory pool exceeds 20 megabytes, then part of the bar representing the Old Generation memory pool in the JConsole interface turns red. The red portion indicates the portion of used memory that exceeds the usage threshold. The bar representing the heap memory also turns red as shown in <a href="#BABHDHFJ">Figure 2-20</a>:</p>
<div id="JJDEV13145" class="figure">
<p class="titleinfigure"><a id="BABHDHFJ"></a>Figure 2-20 Memory Tab of the JConsole Interface When Used Memory Exceeds the Usage Threshold</p>
<img width="723" height="495" src="img/exceed_usage.gif" alt="Description of Figure 2-20 follows"/><br/>
<a id="sthref305" href="img_text/exceed_usage.htm">Description of &#34;Figure 2-20 Memory Tab of the JConsole Interface When Used Memory Exceeds the Usage Threshold&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BEJGCCIA"></a>
<div id="JJDEV13146" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Important Security Notes</h3>
<p>By starting the remote listener with disabled SSL and authentication you violate the general security guidelines and hence make server vulnerable to attacks. Therefore, it is always advisable not to use such mode in production environment. This mode is supported for compatibility with JDK and for development; any production use of JMX in Oracle JVM must use secure JMX connections.</p>
<p>When supplying security-related property values to <code>dbms_java.set_property</code>, <code>System.setProperty</code>, or <code>dbms_java.start_jmx_agent</code>, use a non-echo listener or invoke these through an encrypted JDBC connection from a secure application layer, such as Oracle Application Server. Do not store passwords in clear-text files. Use Oracle Wallet to create and manage certificates. Use client certificates for SSL authentication for better security.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DBSEG" href="../DBSEG/toc.htm"><span class="italic">Oracle Database Security Guide</span></a> for more information about Oracle database security features</div>
</div>
<!-- class="sect2" -->
<a id="CEGGDJFG"></a>
<div id="JJDEV13633" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Shared Server Limitations for JMX</h3>
<p>On dedicated mode servers, JMX connectivity is supported for the duration of a session. Shared server JMX connectivity is typically limited to a single call. The main factor causing this limitation is the fact that JMX connectivity intrinsically depends on operating system resources such as threads and sockets. These resources do not survive shared server call boundaries. As the result, JMX connectivity is fully supported only for the duration of a single call.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This restriction only affects agent connectivity and not the state of the MBeanSrver and Mbeans registered in it. The state of the MBeanSrver and Mbeans, and in particular, the statistics, are persevered across shared server call boundaries.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CEGDEAGB">&#34;Shared Servers Considerations&#34;</a></div>
<p>If using dedicated server mode is not feasible, you can still establish JMX connectivity and monitor shared servers by following these guidelines:</p>
<ul>
<li>
<p>Plan for all JMX management and monitoring activities to happen within a single Java call.</p>
</li>
<li>
<p>Do not set the <code>com.sun.management.jmxremote.port</code> property by calling the <code>DBMS_JAVA.set_property</code> function and do not use the <code>DBMS_JAVA.start_jmx_agent</code> method because these calls activate JMX and introduce a shared server call boundary. Instead, start the JMX agent by calling the <code>oracle.aurora.rdbms.JMXAgent.startOJVMAgent</code> method directly from the Java code to be monitored. The value for the <code>com.sun.management.jmxremote.port</code> property should be passed to the <code>startOJVMAgent</code> method. JMX-related properties other than the <code>com.sun.management.jmxremote.port</code> property do not wake up a JMX Agent and can be set using any means.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABHHHDG"></a>
<div id="JJDEV13147" class="sect1">
<h2 class="sect1">Th<a id="sthref306"></a>reading <a id="sthref307"></a><a id="sthref308"></a>in Oracle Database</h2>
<p>Oracle JVM is based on the database session model, which is a single-client, nonpreemptive threading model. Although Java in Oracle Database allows running threaded programs, it is single-threaded at the execution level. In this model, JVM runs all Java threads associated with a database session on a single operating system thread. Once dispatched, a thread continues execution until it explicitly yields by calling <code>Thread.yield(),</code> blocks by calling <code>Socket.read(),</code> or is preempted by the execution engine. Once a thread yields, blocks or is preempted, JVM dispatches another thread.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting with 11<span class="italic">g</span> release 1 (11.1), Oracle JVM supports thread preemption. Thread preemption is not mandated by the Java specification, but is needed to support the new <code>java.util.concurrent</code> API, present in JDK1.5, properly.</div>
<p>Oracle JVM has added the following features for better performance and thread management:</p>
<ul>
<li>
<p>System calls are at a minimum. Oracle JVM has exchanged some of the standard system calls with nonsystem solutions. For example, entering a monitor-synchronized block or method does not require a system call.</p>
</li>
<li>
<p>Deadlocks are detected.</p>
<ul>
<li>
<p>Oracle JVM monitors for deadlocks between threads. If a <a id="sthref309"></a>deadlock occurs, then Oracle JVM terminates one of the threads and throws the <a id="sthref310"></a><a id="sthref311"></a><code>oracle.aurora.vm.DeadlockError</code> exception.</p>
</li>
<li>
<p>Single-threaded applications cannot suspend. If the application has only a single thread and you try to suspend it, then the <a id="sthref312"></a><a id="sthref313"></a><code>oracle.aurora.vm.LimboError</code> exception is thrown.</p>
</li>
</ul>
</li>
</ul>
<p class="subhead2"><a id="JJDEV13148"></a>Thread <a id="sthref314"></a>Life Cycle</p>
<p>In a single-threaded application, a call ends when one of the following events occurs:</p>
<ul>
<li>
<p>The thread returns to its caller.</p>
</li>
<li>
<p>An exception is thrown and is not caught in Java code.</p>
</li>
<li>
<p><a id="sthref315"></a>The <code>System.exit(),</code> <code>OracleRuntime.exitSession(),</code> or <code>oracle.aurora.vm.<a id="sthref316"></a>OracleRuntime.exitCall()</code> method is called.</p>
</li>
<li>
<p>The <code>DBMS_JAVA.endsession()</code> or <code>DBMS_JAVA.endsession_and_related_state()</code> method is called.</p>
</li>
</ul>
<p>If the initial thread creates and starts other Java threads, then the call ends in one of the following ways:</p>
<ul>
<li>
<p>The main thread returns to its caller or an exception is thrown and not caught in this thread and in either case all other non-daemon threads are processed. Non-daemon threads complete either by returning from their initial method or because an exception is thrown and not caught in the thread.</p>
</li>
<li>
<p>Any thread calls the <code>System.exit(),</code> <code>OracleRuntime.exitSession(),</code> or <code>oracle.aurora.vm.<a id="sthref317"></a>OracleRuntime.exitCall()</code> method.</p>
</li>
<li>
<p>A call to <code>DBMS_JAVA.endsession()</code> or <code>DBMS_JAVA.endsession_and_related_state()</code> method.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABHEHAJ">&#34;Operating System Resources Affected Across Calls&#34;</a>.</div>
<p>Prior to 11<span class="italic">g</span> release 1 (11.1), when a call ended because of a call to <code>System.exit()</code> or <code>oracle.aurora.vm.OracleRuntime.exitCall()</code>, Oracle JVM ended the call abruptly and terminated all threads, in both the dedicated and shared server modes. Since 11<span class="italic">g</span> release 1 (11.1), this is addressed by the addition of the following PL/SQL functions to the <code>DBMS_JAVA</code> package:</p>
<ul>
<li>
<p><code>FUNCTION endsession RETURN VARCHAR2;</code></p>
</li>
<li>
<p><code>FUNCTION endsession_and_related_state RETURN VARCHAR2;</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chfour.htm#BABICDHE">&#34;Two-Tier Duration for Java Session State&#34;</a>.</div>
<p>During a call, a Java program can recursively cause more Java code to be run. For example, your program can issue a SQL query using JDBC or SQLJ that, in turn, calls a trigger written in Java. All the preceding remarks regarding call lifetime apply to the top-most call to Java code, not to the recursive call. For example, a call to <code>System.exit()</code> from within a recursive call exits the entire top-most call to Java, not just the recursive call.</p>
<p class="subhead2"><a id="JJDEV13149"></a>System.exit(), OracleRuntime.exitSession(), and OracleRuntime.exitCall()</p>
<p>The <code>System.exit()</code> method terminates JVM, preserving no Java state. It does not cause the database session to terminate or the client to disconnect. However, the database session may, and often does, terminate itself immediately afterward. <code>OracleRuntime.exitSession()</code> also terminates JVM, preserving no Java state. However, it also terminates the database session and disconnects the client.</p>
<p>The behavior of <code>OracleRuntime.exitCall()</code> varies depending on <code>OracleRuntime.threadTerminationPolicy()</code>. This method returns a <code>boolean</code> value. If this value is <code>true</code>, then any active thread should be terminated, rather than left quiescent, at the end of a database call.</p>
<ul>
<li>
<p>In a shared server process, <code>threadTerminationPolicy()</code> is always <code>true</code>.</p>
</li>
<li>
<p>In a shadow (dedicated) process, the default value is <code>false</code>. You can change the value by calling <code>OracleRuntime.setThreadTerminationPolicy()</code>.</p>
<ul>
<li>
<p>If you set the value to false, that is the default value, all threads are left quiescent but receive a <code>ThreadDeath</code> exception for graceful termination.</p>
</li>
<li>
<p>If the value is true, all threads are terminated abruptly.</p>
</li>
</ul>
</li>
</ul>
<p>In addition, there is another method, <code>OracleRuntime.callExitPolicy()</code>. This method determines when a call is exited if none of the <code>OracleRuntime.exitSession()</code>, <code>OracleRuntime.exitCall()</code>, or <code>System.exit()</code> methods were ever called. The call exit policy can be set to one of the following, using <code>OracleRuntime.setCallExitPolicy()</code>:</p>
<ul>
<li>
<p><code>OracleRuntime.EXIT_CALL_WHEN_MAIN_THREAD_TERMINATES</code></p>
<p>If set to this value, then as soon as the main thread returns or an uncaught exception occurs on the main thread, all remaining threads, both daemon and non-daemon are:</p>
<ul>
<li>
<p>Killed, if <code>threadTerminationPolicy()</code> is true, always in shared server mode.</p>
</li>
<li>
<p>Left quiescent, if <code>threadTerminationPolicy()</code> is false.</p>
</li>
</ul>
</li>
<li>
<p><code>OracleRuntime.EXIT_CALL_WHEN_ALL_NON_DAEMON_THREADS_TERMINATE</code></p>
<p>This is the default value. If this value is set, then the call ends when only daemon threads are left running. At this point:</p>
<ul>
<li>
<p>If the <code>threadTerminationPolicy()</code> is <code>true</code>, always in shared server mode, then the daemon threads are killed.</p>
</li>
<li>
<p>If the <code>threadTerminationPolicy()</code> is <code>false</code>, then the daemon threads are left quiescent until the next call. This is the default setting for shadow (dedicated) server mode.</p>
</li>
</ul>
</li>
<li>
<p><code>OracleRuntime.EXIT_CALL_WHEN_ALL_THREADS_TERMINATE</code></p>
<p>If set to this value, then the call ends only when all threads have either returned or ended due to an uncaught exception. At this point, the call ends regardless of the value of <code>threadTerminationPolicy()</code>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
In Oracle database 9.x and earlier database releases, JVM behaves as if the <code>callExitPolicy()</code> were <code>OracleRuntime.EXIT_CALL_WHEN_ALL_NON_DAEMON_THREADS_TERMINATE</code> and the <code>threadTerminationPolicy()</code> were <code>true</code> for both shared and dedicated server processes. This means kill the daemon threads at this point. Also, if <code>exitCall()</code> were executed, then all threads are killed before the call is ended, in both shared and dedicated server processes.</div>
</div>
<!-- class="sect1" -->
<a id="CEGDEAGB"></a>
<div id="JJDEV13150" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Shared Servers Considerations</h2>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle recommends dedicated servers for performance reasons. Additionally, dedicated servers support a class of applications that rely on threads and sockets that stay open across calls. For example, the JMX agent connectivity functionality. Refer to <a href="#CHDFAJIG">&#34;Managing Your Applications Using JMX&#34;</a> for more information about the JMX agent.</div>
<p>For sessions that use shared servers, certain limitations exist across calls. The reason is that a session that uses a shared server is not guaranteed to connect to the same process on a subsequent database call, and hence the session-specific memory and objects that need to live across calls are saved in the SGA. This means that process-specific resources, such as threads, open files, and sockets, must be cleaned up at the end of each call, and therefore, will not be available for the next call.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABIFAAI">End-of-Call Migration</a></p>
</li>
<li>
<p><a href="#BABDDAHD">Oracle-Specific Support for End-of-Call Optimization</a></p>
</li>
<li>
<p><a href="#BABFFJAF">The EndOfCallRegistry.registerCallback() Method</a></p>
</li>
<li>
<p><a href="#BABJGEGG">The EndOfCallRegistry.runCallbacks() Method</a></p>
</li>
<li>
<p><a href="#BABFEDFA">The Callback Interface</a></p>
</li>
<li>
<p><a href="#BABDAHJI">The Callback.act() method</a></p>
</li>
<li>
<p><a href="#BABHEHAJ">Operating System Resources Affected Across Calls</a></p>
</li>
</ul>
<a id="BABIFAAI"></a>
<div id="JJDEV13151" class="sect2">
<h3 class="sect2"><a id="sthref318"></a>End-of-Call Migration</h3>
<p>In the shared server mode, Oracle Database preserves the state of your Java program between calls by migrating all objects that are reachable from <code>static</code> variables to session space at the end of the call. Session space exists within the session of the client to store <code>static</code> variables and objects that exist between calls. Oracle JVM automatically performs this migration operation at the end of every call.</p>
<p>This migration operation is a memory and performance consideration. Hence, you should be aware of what you designate to exist between calls and keep the <code>static</code> variables and objects to a minimum. If you store objects in <code>static</code> variables needlessly, then you impose an unnecessary burden on the memory manager to perform the migration and consume per-session resources. By limiting your <code>static</code> variables to only what is necessary, you help the memory manager and improve the performance of your server.</p>
<p>To maximize the number of users who can run your Java program at the same time, it is important to minimize the footprint of a session. In particular, to achieve maximum scalability, an inactive session should take up as little memory space as possible. A simple technique to minimize footprint is to release large data structures at the end of every call. You can lazily re-create many data structures when you need them again in another call. For this reason, Oracle JVM has a mechanism for calling a specified Java method when a session is about to become inactive, such as at the end of a call.</p>
<p>This mechanism is the <code><a id="sthref319"></a>EndOfCallRegistry</code> notification. It enables you to clear <code>static</code> variables at the end of the call and reinitialize the variables using a lazy initialization technique when the next call comes in. You should run this only if you are concerned about the amount of storage you require the memory manager to store in between calls. It becomes a concern only for complex stateful server applications that you implement in Java.</p>
<p>The decision of whether to null-out data structures at the end of the call and then re-create them for each new call is a typical time and space trade-off. There is some extra time spent in re-creating the structure, but you can save significant space by not holding on to the structure between calls. In addition, there is a time consideration, because objects, especially large objects, are more expensive to access after they have been migrated to session space. The penalty results from the differences in representation of session, as opposed to objects based on call-space.</p>
<p>Examples of data structures that are candidates for this type of optimization include:</p>
<ul>
<li>
<p>Buffers or caches.</p>
</li>
<li>
<p>Static fields, such as arrays, which once initialized can remain unchanged during the course of the program.</p>
</li>
<li>
<p>Any dynamically built data structure that can have a space-efficient representation between calls and a more speed-efficient representation for the duration of a call. This can be tricky and may complicate your code, making it hard to maintain. Therefore, you should consider doing this only after demonstrating that the space saved is worth the effort.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABDDAHD"></a>
<div id="JJDEV13152" class="sect2">
<h3 class="sect2">Oracle-Specific Support for End-of-Call Optimization</h3>
<p><a id="sthref320"></a>Y<a id="sthref321"></a>ou can register the <code>static</code> variables that you want cleared at the end of the call when the buffer, field, or data structure is created. Within the <code>oracle.aurora.memoryManager.EndOfCallRegistry</code> class, the <a id="sthref322"></a><code>registerCallback()</code> method takes an object that implements a <code>Callback</code> object. The <code>registerCallback()</code> method stores this object until the end of the call. At the end of the call, Oracle JVM calls the <a id="sthref323"></a><code>act()</code> method within all registered <code>Callback</code> objects. The <code>act()</code> method within the <code>Callback</code> object is implemented to clear the user-defined buffer, field, or data structure. Once cleared, the <code>Callback</code> object is removed from the registry.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the end of the call is also the end of the session, then callbacks are not started, because the session space will be cleared anyway.</div>
<p>A weak table holds the registry of end-of-call callbacks. If either the <code>Callback</code> object or value are not reachable from the Java program, then both the object and the value will be dropped from the table. The use of a weak table to hold callbacks also means that registering a callback will not prevent the garbage collector from reclaiming that object. Therefore, you must hold on to the callback yourself if you need it, and you cannot rely on the table holding it back.</p>
<p>The way you use <code>EndOfCallRegistry</code> depends on whether you are dealing with objects held in <code>static</code> fields or instance fields.</p>
<p class="subhead2"><a id="JJDEV13153"></a>Static fields</p>
<p>Use <code>EndOfCallRegistry</code> to clear state associated with an entire class. In this case, the <code>Callback</code> object should be held in a <code>private</code> <code>static</code> field. Any code that requires access to the cached data that was dropped between calls must call a method that lazily creates, or re-creates, the cached data.</p>
<p>C<a id="sthref324"></a>onsider the following example:</p>
<pre>import oracle.aurora.memoryManager.Callback;
import oracle.aurora.memoryManager.EndOfCallRegistry;

class Example
{
  static Object cachedField = null;
  private static Callback thunk = null;

  static void clearCachedField()
  {
    // clear out both the cached field, and the thunk so they don&#39;t
    // take up session space between calls
    cachedField = null;
    thunk = null;
  }

  private static Object getCachedField()
  {
    if (cachedField == null) 
    {
      // save thunk in static field so it doesn&#39;t get reclaimed
      // by garbage collector
      thunk = new Callback () {
        public void act(Object obj)
        {
          Example.clearCachedField();
        }
      };
      
      // register thunk to clear cachedField at end-of-call.
      EndOfCallRegistry.registerCallback(thunk);
      // finally, set cached field
      cachedField = createCachedField();
    }
    return cachedField;
  }

  private static Object createCachedField()
  {
    ...
  }
}
</pre>
<p>The preceding example does the following:</p>
<ol>
<li>
<p>Creates a <code>Callback</code> object within a <code>static</code> field, <code>thunk</code>.</p>
</li>
<li>
<p>Registers this <code>Callback</code> object for end-of-call migration.</p>
</li>
<li>
<p>Implements the <code>Callback.act()</code> method to free up all <code>static</code> variables, including the <code>Callback</code> object itself.</p>
</li>
<li>
<p>Provides a method, <code>createCachedField()</code>, for lazily re-creating the cache.</p>
</li>
</ol>
<p>When you create the cache, the <code>Callback</code> object is automatically registered within the <code>getCachedField()</code> method. At end-of-call, Oracle JVM calls the registered <code>Callback.act()</code> method, which frees the static memory.</p>
<p class="subhead2"><a id="JJDEV13154"></a>Instance fields</p>
<p>Use <code>EndOfCallRegistry</code> to clear state in data structures held in instance fields. For example, when a state is associated with each instance of a class, each instance has a field that holds the cached state for the instance and fills in the cached field as necessary. You can access the cached field with a method that ensures the state is cached.</p>
<p>Consider the following example:</p>
<pre>import oracle.aurora.memoryManager.Callback;
import oracle.aurora.memoryManager.EndOfCallRegistry;

class Example2 implements Callback
{
  private Object cachedField = null;

  public voidact (Object obj)
  {
    // clear cached field
    cachedField = null;
    obj = null;
  }

  // our accessor method
  private static Object getCachedField()
  {
    if (cachedField == null)
    {
      // if cachedField is not filled in then you must
      // register self, and fill it in.
      EndOfCallRegistry.registerCallback(self);
      cachedField = createCachedField();
    }
    return cachedField;
  }

  private Object createCachedField()
  {
    ...
  }
}
</pre>
<p>The preceding example does the following:</p>
<ol>
<li>
<p>Implements the instance as a <code>Callback</code> object.</p>
</li>
<li>
<p>Implements the <code>Callback.act()</code> method to free up the instance fields.</p>
</li>
<li>
<p>When you request a cache, the <code>Callback</code> object registers itself for the end-of-call migration.</p>
</li>
<li>
<p>Provides a method, <code>createCachedField()</code>, for lazily re-creating the cache.</p>
</li>
</ol>
<p>When you create the cache, the <code>Callback</code> object is automatically registered within the <code>getCachedField()</code> method. At end-of-call, Oracle JVM calls the registered <code>Callback.act()</code> method, which frees the cache.</p>
<p>This approach ensures that the lifetime of the <code>Callback</code> object is identical to the lifetime of the instance, because they are the same object.</p>
</div>
<!-- class="sect2" -->
<a id="BABFFJAF"></a>
<div id="JJDEV13155" class="sect2">
<h3 class="sect2">The EndOfCallRegistry.registerCallback() Method</h3>
<p>The <code>registerCallback()</code> method installs a <code>Callback</code> object within a registry. At the end of the call, Oracle JVM calls the <code>act()</code> method of all registered <code>Callback</code> objects.</p>
<p>You can register your <code>Callback</code> object by itself or with an <code>Object</code> instance. If you need additional information stored within an object to be passed into <code>act()</code>, then you can register this object with the <code>value</code> parameter, which is an instance of <code>Object</code>.</p>
<p>The following are the valid signatures of the <code>registerCallback()</code> method:</p>
<pre>public static void registerCallback(Callback thunk, Object value);

public static void registerCallback(Callback thunk);
</pre>
<p>The following table lists the parameters of <code>registerCallback</code> and their description:</p>
<div class="inftblinformal">
<table class="cellalignment4002" title="table" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t64">Parameter</th>
<th class="cellalignment4003" id="r1c2-t64">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t64" headers="r1c1-t64"><code>thunk</code></td>
<td class="cellalignment4004" headers="r2c1-t64 r1c2-t64">The <code>Callback</code> object to be called at the end-of-call migration.</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t64" headers="r1c1-t64"><code>value</code></td>
<td class="cellalignment4004" headers="r3c1-t64 r1c2-t64">If you need additional information stored within an object to be passed into <code>act()</code>, then you can register this object with the <code>value</code> parameter. In some cases, the <code>value</code> parameter is necessary to hold the state that the callback needs. However, most users do not need to specify a value for this parameter.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<a id="BABJGEGG"></a>
<div id="JJDEV13156" class="sect2">
<h3 class="sect2">The EndOfCallRegistry.runCallbacks() Method</h3>
<p>The signature of the <code>runCallbacks()</code> method is as follows:</p>
<pre>static void runCallbacks()
</pre>
<p>JVM calls this method at end-of-call and calls <code>act()</code> for every <code>Callback</code> object registered using <code>registerCallback()</code>. It is called at end-of-call, before object migration and before the last finalization step.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not call this method in your code.</div>
</div>
<!-- class="sect2" -->
<a id="BABFEDFA"></a>
<div id="JJDEV13157" class="sect2">
<h3 class="sect2">The Callback Interface</h3>
<p>The interface is declared as follows:</p>
<pre>Interface oracle.aurora.memoryManager.Callback
</pre>
<p>Any object you want to register using <code>EndOfCallRegistry.registerCallback()</code> must implement the <code>Callback</code> interface. This interface can be useful in your application, where you require notification at end-of-call.</p>
</div>
<!-- class="sect2" -->
<a id="BABDAHJI"></a>
<div id="JJDEV13158" class="sect2">
<h3 class="sect2">The Callback.act() method</h3>
<p>The signature of the <code>act()</code> method is as follows:</p>
<pre>public void act(Object value)
</pre>
<p>You can implement any activity that you require to occur at the end of the call. Usually, this method contains procedures for clearing any memory that would be saved to session space.</p>
</div>
<!-- class="sect2" -->
<a id="BABHEHAJ"></a>
<div id="JJDEV13159" class="sect2">
<h3 class="sect2">Operating <a id="sthref325"></a>System Resources Affected Across Calls</h3>
<p><a id="sthref326"></a>In the shared server mode, Oracle JVM closes any open operating system resources <a id="sthref327"></a><a id="sthref328"></a>at the end of a database call, as shown in the following table:</p>
<div class="inftblinformal">
<table class="cellalignment4002" title="table" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t66">Resource</th>
<th class="cellalignment4003" id="r1c2-t66">Lifetime</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t66" headers="r1c1-t66">Files</td>
<td class="cellalignment4004" headers="r2c1-t66 r1c2-t66">The system closes all files left open when a database call ends.</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t66" headers="r1c1-t66">Threads</td>
<td class="cellalignment4004" headers="r3c1-t66 r1c2-t66">All threads are terminated when a call ends.</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t66" headers="r1c1-t66">Sockets</td>
<td class="cellalignment4004" headers="r4c1-t66 r1c2-t66">
<ul>
<li>Client sockets can exist across calls.</li>
<li>
<p>Server sockets terminate when the call ends.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r5c1-t66" headers="r1c1-t66">Objects that depend on operating system resources</td>
<td class="cellalignment4004" headers="r5c1-t66 r1c2-t66">Regardless of the usable lifetime of the object, the Java object can be valid for the duration of the session. This can occur, for example, if the Java object is stored in a <code>static</code> class variable, or a class variable references it directly or indirectly. If you attempt to use one of these Java objects after its usable lifetime is over, then Oracle Database will throw an exception. This is true for the following examples:
<ul>
<li>
<p>If an attempt is made to read from a <code>java.io.FileInputStream</code> that was closed at the end of a previous call, then a <code>java.io.<a id="sthref329"></a>IOException</code> is raised.</p>
</li>
<li>
<p><code>java.lang.Thread.isAlive()</code> is <code>false</code> for any <code>Thread</code> object running in a previous call and still accessible in a subsequent call.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p><a id="sthref330"></a>You should close resources that are local to a single call when the call ends. However, for <code>static</code> objects that hold on to operating system resources, you must be aware of how these resources are affected after the call ends.</p>
<p class="subhead2"><a id="JJDEV13160"></a>Files</p>
<p>In the shared server mode, Oracle JVM automatically closes open operating system constructs when the call ends. This can affect any operating system resources within your Java object. If you have a file opened within a <code>static</code> variable, then the file handle is closed at the end of the call for you. Therefore, if you hold on to the <code>File</code> object across calls, then the next usage of the file handle throws an exception.</p>
<p>In <a href="#BABGIEJC">Example 2-5</a>, the <code>Concat</code> class enables multiple files to be written into a single file, <code>outFile</code>. On the first call, <code>outFile</code> is created. The first input file is opened, read, written to <code>outFile</code>, and the call ends. Because <code>outFile</code> is defined as a <code>static</code> variable, it is moved into session space between call invocations. However, the file handle is closed at the end of the call. The next time you call <code>addFile()</code>, you will get an exception.</p>
<div id="JJDEV13161" class="example">
<p class="titleinexample"><a id="BABGIEJC"></a>Example 2-5 Compromising Your Operating System Resources</p>
<pre>public class Concat
{
  static File outFile = new File(&#34;outme.txt&#34;);
  FileWriter out = new FileWriter(outFile);

  public static void addFile(String[] newFile)
  {
    File inFile = new File(newFile);
    FileReader in = new FileReader(inFile);
    int i;

    while ((i = in.read()) != -1)
      out.write(i);
    in.close();
  }
}
</pre></div>
<!-- class="example" -->
<p>There are workarounds. To ensure that your handles stay valid, close your files, buffers, and so on, at the end of every call, and reopen the resource at the beginning of the next call. Another option is to use the database rather than using operating system resources. For example, try to use database tables rather than a file. Alternatively, do not store operating system resources within <code>static</code> objects that are expected to live across calls. Instead, use operating system resources only within objects local to the call.</p>
<p><a href="#BABGCDBC">Example 2-6</a> shows how you can perform concatenation, as in <a href="#BABGIEJC">Example 2-5</a>, without compromising your operating system resources. The <code>addFile()</code> method opens the <code>outme.txt</code> file within each call, ensuring that anything written into the file is appended to the end. At the end of each call, the file is closed. Two things occur:</p>
<ul>
<li>
<p>The <code>File</code> object no longer exists outside a call.</p>
</li>
<li>
<p>The operating system resource, the <code>outme.txt</code> file, is reopened for each call. If you had made the <code>File</code> object a <code>static</code> variable, then the closing of <code>outme.txt</code> within each call would ensure that the operating system resource is not compromised.</p>
</li>
</ul>
<div id="JJDEV13162" class="example">
<p class="titleinexample"><a id="BABGCDBC"></a>Example 2-6 Correctly Managing Your Operating System Resources</p>
<pre>public class Concat
{

  public static void addFile(String[] newFile)
  {
    /*open the output file each call; make sure the input*/
    /*file is written out to the end by making it &#34;append=true&#34;*/
    FileWriter out = new FileWriter(&#34;outme.txt&#34;, TRUE);
    File inFile = new File(newFile);
    FileReader in = new FileReader(inFile);
    int i;

    while ((i = in.read()) != -1)
      out.write(i);
    in.close();
    
    /*close the output file between calls*/
    out.close();
  }
}
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="JJDEV13163"></a>Sockets</p>
<p>Sockets are used in setting up a connection between a client and a server. For each database connection, sockets are used at either end of the connection. Your application does not set up the connection. The connection is set up by the underlying networking protocol, TTC or IIOP of Oracle Net.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chfour.htm#BABFJJBC">&#34;Configuring Oracle JVM&#34;</a> for information about how to configure your connection.</div>
<p>You may also want to set up another connection, for example, connecting to a specified URL from within one of the classes stored within the database. To do so, instantiate sockets for servicing the client and server sides of the connection using the following:</p>
<ul>
<li>
<p>The <code>java.net.Socket()</code> constructor creates a client socket.</p>
</li>
<li>
<p>The <code>java.net.ServerSocket()</code> constructor creates a server socket.</p>
</li>
</ul>
<p>A socket exists at each end of the connection. The server side of the connection that listens for incoming calls is serviced by a <code>ServerSocket</code> instance. The client side of the connection that sends requests is serviced through a <code>Socket</code> instance. You can use sockets as defined within JVM with the restriction that a <code>ServerSocket</code> instance within a shared server cannot exist across calls.</p>
<p>The following table lists the socket types and their description:</p>
<div class="inftblinformal">
<table class="cellalignment4002" title="table" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t68">Socket Type</th>
<th class="cellalignment4003" id="r1c2-t68">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t68" headers="r1c1-t68">Socket</td>
<td class="cellalignment4004" headers="r2c1-t68 r1c2-t68">Because the client side of the connection is outbound, the <code>Socket</code> instance can be serviced across calls within a shared server.</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t68" headers="r1c1-t68">ServerSocket</td>
<td class="cellalignment4004" headers="r3c1-t68 r1c2-t68">The server side of the connection is a listener. The <code>ServerSocket</code> instance is closed at the end of a call within a shared server. The shared servers move on to another client at the end of every call. You will receive an I/O exception stating that the socket was closed, if you try to use the <code>ServerSocket</code> instance outside of the call it was created in.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p class="subhead2"><a id="JJDEV13164"></a><a id="sthref331"></a>Threads</p>
<p>In the shared server mode, when a call ends because of a return or uncaught exceptions, Oracle JVM throws <code>ThreadDeathException</code> in all daemon threads. <code>ThreadDeathException</code> essentially forces threads to stop running. Code that depends on threads living across calls does not behave as expected in the shared server mode. For example, the value of a <code>static</code> variable that tracks initialization of a thread may become incorrect in subsequent calls because all threads are killed at the end of a database call.</p>
<p>As a specific example, the standard RMI Server functions in the shared server mode. However, it is useful only within the context of a single call. This is because the RMI Server forks daemon threads, which are in the shared server mode, are killed at the end of call, that is, the daemon thread are killed when all non-daemon threads return. If the RMI server session is reentered in a subsequent call, then these daemon threads are not restarted and the RMI server fails to function properly.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3995">
<tr>
<td class="cellalignment4004">
<table class="cellalignment4000">
<tr>
<td class="cellalignment3999"><a href="chone.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3999"><a href="chthree.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4006">
<table class="cellalignment3998">
<tr>
<td class="cellalignment3999"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3999"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3999"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3999"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3999"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3999"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>