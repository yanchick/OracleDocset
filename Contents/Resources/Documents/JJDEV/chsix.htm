<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-71041"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Publishing%20Java%20Classes%20With%20Call%20Specifications"></a><title>Publishing Java Classes With Call Specifications</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="description" content="This book describes how to develop, load, and run Java applications in Oracle Database."/>
<meta name="dcterms.created" content="2014-06-30T4:25:0Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Java Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E50793-03"/>
<meta name="dcterms.isVersionOf" content="JJDEV"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="chfive.htm" title="Previous" type="text/html"/>
<link rel="Next" href="chseven.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E50793-03.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/23</span> <!-- End Header -->
<div id="JJDEV13255" class="chapter"><a id="BABEBDGB"></a>
<h1 class="chapter"><span class="secnum">6</span> Publishing<a id="sthref404"></a><a id="sthref405"></a><a id="sthref406"></a> Java Classes With Call Specifications</h1>
<p>When you load a Java class into the database, its methods are not published automatically, because Oracle Database does not know which methods are safe entry points for calls from SQL. To publish the methods, you must write call specifications, which map Java method names, parameter types, and return types to their SQL counterparts. This chapter describes how to publish Java classes with call specifications.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#BABDIBID">Understanding Call Specifications</a></p>
</li>
<li>
<p><a href="#BABHAEHE">Defining Call Specifications</a></p>
</li>
<li>
<p><a href="#BABBDIEF">Writing Top-Level Call Specifications</a></p>
</li>
<li>
<p><a href="#BABFJFCD">Writing Packaged Call Specifications</a></p>
</li>
<li>
<p><a href="#BABJJFJC">Writing Object Type Call Specifications</a></p>
</li>
</ul>
<a id="BABDIBID"></a>
<div id="JJDEV13256" class="sect1">
<h2 class="sect1">Understanding <a id="sthref407"></a>Call Specifications</h2>
<p>To publish Java methods, you write call specifications. For a given Java method, you declare a function or procedure call specification using the SQL <code>CREATE FUNCTION</code> or <code>CREATE PROCEDURE</code> statement. Inside a PL/SQL package or SQL object type, you use similar declarations.</p>
<p>You publish Java methods that return a value as functions and <code>void</code> Java methods as procedures. The function or procedure body contains the <code>LANGUAGE JAVA</code> clause. This clause records information about the Java method including its full name, its parameter types, and its return type. Mismatches are detected only at run time.</p>
<p><a href="#BABBFCFC">Figure 6-1</a> shows applications calling the Java method through its call specification, that is, by referencing the name of the call specification. The run-time system looks up the call specification definition in the Oracle data dictionary and runs the corresponding Java method.</p>
<div id="JJDEV13257" class="figure">
<p class="titleinfigure"><a id="BABBFCFC"></a>Figure 6-1 Calling a Java Method</p>
<img width="276" height="226" src="img/call_spec_rev.gif" alt="Description of Figure 6-1 follows"/><br/>
<a id="sthref408" href="img_text/call_spec_rev.htm">Description of &#34;Figure 6-1 Calling a Java Method&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>As an alternative, you can use the native Java interface to directly call Java methods in the database from a Java client.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chthree.htm#CBBEJGIH">&#34;Using the Client-Side Stub&#34;</a></div>
</div>
<!-- class="sect1" -->
<a id="BABHAEHE"></a>
<div id="JJDEV13258" class="sect1">
<h2 class="sect1">Defining <a id="sthref409"></a>Call Specifications</h2>
<p>A call specification and the Java method it publishes must reside in the same schema, unless the Java method has a <code>PUBLIC</code> synonym. You can declare the call specification as a:</p>
<ul>
<li>
<p>Standalone PL/SQL function or procedure</p>
</li>
<li>
<p>Packaged PL/SQL function or procedure</p>
</li>
<li>
<p>Member method of a SQL object type</p>
</li>
</ul>
<p>A call specification exposes the top-level entry point of a Java method to Oracle Database. As a result, you can publish only <code>public</code> <code>static</code> methods. However, there is an exception. You can publish instance methods as member methods of a SQL object type.</p>
<p>Packaged call specifications perform as well as top-level call specifications. As a result, to ease maintenance, you may want to place call specifications in a package body. This will help you to modify call specifications without invalidating other schema objects. Also, you can overload the call specifications.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABIJJAB">Setting Parameter Modes</a></p>
</li>
<li>
<p><a href="#BABJIJEB">Mapping Data Types</a></p>
</li>
<li>
<p><a href="#BABJGIIC">Using the Server-Side Internal JDBC Driver</a></p>
</li>
</ul>
<a id="BABIJJAB"></a>
<div id="JJDEV13259" class="sect2">
<h3 class="sect2">Setting <a id="sthref410"></a><a id="sthref411"></a>Parameter Modes</h3>
<p>In Java and other object-oriented languages, a method cannot assign values to objects passed as arguments. When calling a method from SQL or PL/SQL, to change the value of an argument, you must declare it as an <code>OUT</code> or <code>IN OUT</code> parameter in the call specification. The corresponding Java parameter must be an array with only one element.</p>
<p>You can replace the element value with another Java object of the appropriate type, or you can modify the value, if the Java type permits. Either way, the new value propagates back to the caller. For example, you map a call specification <code>OUT</code> parameter of the <code>NUMBER</code> type to a Java parameter declared as <code>float[]</code> <code>p</code>, and then assign a new value to <code>p[0]</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A function that declares <code>OUT</code> or <code>IN</code> <code>OUT</code> parameters cannot be called from SQL data manipulation language (DML) statements.</div>
</div>
<!-- class="sect2" -->
<a id="BABJIJEB"></a>
<div id="JJDEV13260" class="sect2">
<h3 class="sect2">Mapping <a id="sthref412"></a><a id="sthref413"></a>Data Types</h3>
<p>In a call specification, the corresponding SQL and Java parameters and function results must have compatible data types.</p>
<p><a href="#BABHCEIG">Table 6-1</a> lists the legal data type mappings. Oracle Database converts between the SQL types and Java classes automatically.</p>
<div id="JJDEV13261" class="tblformal">
<p class="titleintable"><a id="sthref414"></a><a id="BABHCEIG"></a>Table 6-1 Legal Data Type Mappings</p>
<table class="cellalignment4009" title="Legal Data Type Mappings" summary="Legal data type mappings table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t4">SQL Type</th>
<th class="cellalignment4003" id="r1c2-t4">Java Class</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t4" headers="r1c1-t4">
<p><code>CHAR</code>, <code>VARCHAR2</code>, <code>LONG</code></p>
</td>
<td class="cellalignment4004" headers="r2c1-t4 r1c2-t4">
<p><code>java.lang.String</code></p>
<p><code>oracle.sql.CHAR</code></p>
<p><code>oracle.sql.ROWID</code></p>
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment4004" headers="r3c1-t4 r1c2-t4">
<p><code>boolean</code></p>
<p><code>char</code></p>
<p><code>byte</code></p>
<p><code>byte[]</code></p>
<p><code>short</code></p>
<p><code>int</code></p>
<p><code>long</code></p>
<p><code>float</code></p>
<p><code>double</code></p>
<p><code>java.lang.Byte</code></p>
<p><code>java.lang.Short</code></p>
<p><code>java.lang.Integer</code></p>
<p><code>java.lang.Long</code></p>
<p><code>java.lang.Float</code></p>
<p><code>java.lang.Double</code></p>
<p><code>java.math.BigDecimal</code></p>
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t4" headers="r1c1-t4">
<p><code>BINARY_INTEGER</code></p>
</td>
<td class="cellalignment4004" headers="r4c1-t4 r1c2-t4">
<p><code>boolean</code></p>
<p><code>char</code></p>
<p><code>byte</code></p>
<p><code>byte[]</code></p>
<p><code>short</code></p>
<p><code>int</code></p>
<p><code>long</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r5c1-t4" headers="r1c1-t4">
<p><code>BINARY_FLOAT</code></p>
</td>
<td class="cellalignment4004" headers="r5c1-t4 r1c2-t4">
<p><code>oracle.sql.BINARY_FLOAT</code></p>
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r6c1-t4" headers="r1c1-t4">
<p><code>BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment4004" headers="r6c1-t4 r1c2-t4">
<p><code>oracle.sql.BINARY_DOUBLE</code></p>
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r7c1-t4" headers="r1c1-t4">
<p><code>DATE</code></p>
</td>
<td class="cellalignment4004" headers="r7c1-t4 r1c2-t4">
<p><code>oracle.sql.DATE</code></p>
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r8c1-t4" headers="r1c1-t4">
<p><code>RAW</code></p>
</td>
<td class="cellalignment4004" headers="r8c1-t4 r1c2-t4">
<p><code>oracle.sql.RAW</code></p>
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r9c1-t4" headers="r1c1-t4">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment4004" headers="r9c1-t4 r1c2-t4">
<p><code>oracle.sql.BLOB</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r10c1-t4" headers="r1c1-t4">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment4004" headers="r10c1-t4 r1c2-t4">
<p><code>oracle.sql.CLOB</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r11c1-t4" headers="r1c1-t4">
<p><code>BFILE</code></p>
</td>
<td class="cellalignment4004" headers="r11c1-t4 r1c2-t4">
<p><code>oracle.sql.BFILE</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r12c1-t4" headers="r1c1-t4">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment4004" headers="r12c1-t4 r1c2-t4">
<p><code>oracle.sql.ROWID</code></p>
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r13c1-t4" headers="r1c1-t4">
<p><code>TIMESTAMP</code></p>
</td>
<td class="cellalignment4004" headers="r13c1-t4 r1c2-t4">
<p><code>oracle.sql.TIMESTAMP</code></p>
<p><code>byte[]</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r14c1-t4" headers="r1c1-t4">
<p><code>TIMESTAMP WITH TIME ZONE</code></p>
</td>
<td class="cellalignment4004" headers="r14c1-t4 r1c2-t4">
<p><code>oracle.sql.TIMESTAMPTZ</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r15c1-t4" headers="r1c1-t4">
<p><code>TIMESTAMP WITH LOCAL TIME ZONE</code></p>
</td>
<td class="cellalignment4004" headers="r15c1-t4 r1c2-t4">
<p><code>oracle.sql.TIMESTAMPLTZ</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r16c1-t4" headers="r1c1-t4">
<p>ref cursor</p>
</td>
<td class="cellalignment4004" headers="r16c1-t4 r1c2-t4">
<p>j<code>ava.sql.ResultSet</code></p>
<p><code>sqlj.runtime.ResultSetIterator</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r17c1-t4" headers="r1c1-t4">
<p>user defined named types, ADTs</p>
</td>
<td class="cellalignment4004" headers="r17c1-t4 r1c2-t4">
<p><code>oracle.sql.STRUCT</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r18c1-t4" headers="r1c1-t4">
<p>opaque named types</p>
</td>
<td class="cellalignment4004" headers="r18c1-t4 r1c2-t4">
<p><code>oracle.sql.OPAQUE</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r19c1-t4" headers="r1c1-t4">
<p>nested tables and VARRAY named types</p>
</td>
<td class="cellalignment4004" headers="r19c1-t4 r1c2-t4">
<p><code>oracle.sql.ARRAY</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r20c1-t4" headers="r1c1-t4">
<p>references to named types</p>
</td>
<td class="cellalignment4004" headers="r20c1-t4 r1c2-t4">
<p><code>oracle.sql.REF</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>You also must consider the following:</p>
<ul>
<li>
<p>The last four SQL types are collectively referred to as named types.</p>
</li>
<li>
<p>All SQL types except <code>BLOB</code>, <code>CLOB</code>, <code>BFILE</code>, <code>REF</code> <code>CURSOR</code>, and the named types can be mapped to the Java type <code>byte[]</code>, which is a Java byte array. In this case, the argument conversion means copying the raw binary representation of the SQL value to or from the Java byte array.</p>
</li>
<li>
<p>Java classes that implement the <code>ORAData</code> interface and related methods, or Java classes that are subclasses of the <code>oracle.sql</code> classes appearing in the table, can be mapped from SQL types other than <code>BINARY_INTEGER</code> and <code>REF</code> <code>CURSOR</code>. This is generally used for mapping named types to corresponding Java classes generated by JPublisher.</p>
</li>
<li>
<p>The <code>UROWID</code> type and the <code>NUMBER</code> subtypes, such as <code>INTEGER</code> and <code>REAL</code>, are not supported.</p>
</li>
<li>
<p>A value larger than 32 KB cannot be retrieved from a <code>LONG</code> or <code>LONG RAW</code> column into a Java stored procedure.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABJGIIC"></a>
<div id="JJDEV13262" class="sect2">
<h3 class="sect2">Using the Server-Side Internal JDBC Driver</h3>
<p>Java Database Connectivity (JDBC) enables you establish a connection to the database using the <code>DriverManager</code> class, which manages a set of JDBC drivers. You can use the <code>getConnection()</code> method after loading the JDBC drivers. When the <code>getConnection()</code> method finds the right driver, it returns a <code>Connection</code> object that represents a database session. All SQL statements are run within the context of that session.</p>
<p>However, the server-side internal JDBC driver runs within a default session and a default transaction context. As a result, you are already connected to the database, and all your SQL operations are part of the default transaction. You need not register the driver because it comes preregistered. To get a <code>Connection</code> object, run the following line of code:</p>
<pre>Connection conn = DriverManager.getConnection(&#34;jdbc:default:connection:&#34;);
</pre>
<p>Use the <code>Statement</code> class for SQL statements that do not take <code>IN</code> parameters and are run only once. When called on a <code>Connection</code> object, the <code>createStatement()</code> method returns a new <code>Statement</code> object, as follows:</p>
<pre>String sql = &#34;DROP &#34; + object_type + &#34; &#34; + object_name;
Statement stmt = conn.createStatement();
stmt.executeUpdate(sql);
</pre>
<p>Use the <code>PreparedStatement</code> class for SQL statements that take <code>IN</code> parameters or are run more than once. The SQL statement, which can contain one or more parameter placeholders, is precompiled. A question mark (?) serves as a placeholder. When called on a <code>Connection</code> object, the <code>prepareStatement()</code> method returns a new <code>PreparedStatement</code> object, which contains the precompiled SQL statement. For example:</p>
<pre>String sql = &#34;DELETE FROM dept WHERE deptno = ?&#34;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setInt(1, deptID);
pstmt.executeUpdate();
</pre>
<p>A <code>ResultSet</code> object contains SQL query results, that is, the rows that meet the search condition. You can use the <code>next()</code> method to move to the next row, which then becomes the current row. You can use the <code>get</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> methods to retrieve column values from the current row. For example:</p>
<pre>String sql = &#34;SELECT COUNT(*) FROM &#34; + tabName;
int rows = 0;
Statement stmt = conn.createStatement();
ResultSet rset = stmt.executeQuery(sql);
while (rset.next())
{
  rows = rset.getInt(1);
}
</pre>
<p>A <code>CallableStatement</code> object lets you call stored procedures. It contains the call text, which can include a return parameter and any number of <code>IN</code>, <code>OUT</code>, and <code>IN OUT</code> parameters. The call is written using an escape clause, which is delimited by braces (<code>{}</code>). As the following examples show, the escape syntax has three forms:</p>
<pre>// parameterless stored procedure
CallableStatement cstmt = conn.prepareCall(&#34;{CALL proc}&#34;);

// stored procedure
CallableStatement cstmt = conn.prepareCall(&#34;{CALL proc(?,?)}&#34;);

// stored function
CallableStatement cstmt = conn.prepareCall(&#34;{? = CALL func(?,?)}&#34;);
</pre>
<p class="subhead2"><a id="JJDEV13263"></a>Important Points</p>
<p>When developing JDBC applications that access stored procedures, you must consider the following:</p>
<ul>
<li>
<p>Each Oracle JVM session has a single implicit native connection to the Database session in which it exists. This connection is conceptual and is not a Java object. It is an inherent aspect of the session and cannot be opened or closed from within the JVM.</p>
</li>
<li>
<p>The server-side internal JDBC driver runs within a default transaction context. You are already connected to the database, and all your SQL operations are part of the default transaction. Note that this transaction is a local transaction and not part of a global transaction, such as that implemented by Java Transaction API (JTA) or Java Transaction Service (JTS).</p>
</li>
<li>
<p>Statements and result sets persist across calls and their finalizers do not release database cursors. To avoid running out of cursors, close all statements and result sets after you have finished using them. Alternatively, you can ask your DBA to raise the limit set by the initialization parameter, <code>OPEN_CURSORS</code>.</p>
</li>
<li>
<p>The server-side internal JDBC driver does not support auto-commits. As a result, your application must explicitly commit or roll back database changes.</p>
</li>
<li>
<p>You cannot connect to a remote database using the server-side internal JDBC driver. You can connect only to the server running your Java program. For server-to-server connections, use the server-side JDBC Thin driver. For client/server connections, use the client-side JDBC Thin or JDBC Oracle Call Interface (OCI) driver.</p>
</li>
<li>
<p>Typically, you should not close the default connection instance because it is a single instance that can be stored in multiple places, and if you close the instance, each would become unusable. If it is closed, a later call to the <code>OracleDriver.defaultConnection</code> method gets a new, open instance. The <code>OracleDataSource.getConnection</code> method returns a new object every time you call it, but, it does not create a new database connection every time. They all utilize the same implicit native connection and share the same session state, in particular, the local transaction.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBDIEF"></a>
<div id="JJDEV13264" class="sect1">
<h2 class="sect1">Writing <a id="sthref415"></a><a id="sthref416"></a>Top-Level Call Specifications</h2>
<p>In SQL*Plus, you can define top-level call specifications interactively, using the following syntax:</p>
<pre>CREATE [OR REPLACE]
{ PROCEDURE procedure_name [(param[, param]...)]
| FUNCTION function_name [(param[, param]...)] RETURN sql_type}
[AUTHID {DEFINER | CURRENT_USER}]
[PARALLEL_ENABLE]
[DETERMINISTIC]
{IS | AS} LANGUAGE JAVA
NAME &#39;method_fullname (java_type_fullname[, java_type_fullname]...)
[return java_type_fullname]&#39;;
</pre>
<p>where <code>param</code> is represented by the following syntax:</p>
<pre>parameter_name [IN | OUT | IN OUT] sql_type
</pre>
<p>The <a id="sthref417"></a><code>AUTHID</code> clause determines the following:</p>
<ul>
<li>
<p>Whether a stored procedure runs with the privileges of its definer (<code>AUTHID DEFINER</code>) or invoker (<code>AUTHID CURRENT_USER</code>)</p>
</li>
<li>
<p>Whether its unqualified references to schema objects are resolved in the schema of the definer or invoker</p>
</li>
</ul>
<p>If you do not specify the <code>AUTHID</code>, then the default behavior is <code>DEFINER</code>, that is, the stored procedure runs with the privileges of its definer. You can override the default behavior by specifying the <code>AUTHID</code> as <code>CURRENT_USER</code>. However, you cannot override the <code>loadjava</code> option <code>-definer</code> by specifying <code>CURRENT_USER</code>.</p>
<p>The <a id="sthref418"></a><code>PARALLEL_ENABLE</code> option declares that a stored function can be used safely in the slave sessions of parallel DML evaluations. The state of a main session is never shared with slave sessions. Each slave session has its own state, which is initialized when the session begins. The function result should not depend on the state of session variables. Otherwise, results might vary across sessions.</p>
<p><a id="sthref419"></a>The <code>DETERMINISTIC</code> option helps the optimizer avoid redundant function calls. If a stored function was called previously with the same arguments, then the optimizer can decide to use the previous result. The function result should not depend on the state of session variables or schema objects. Otherwise, results can vary across calls. Only <code>DETERMINISTIC</code> functions can be called from a function-based index or a materialized view that has query-rewrite enabled.</p>
<p>The string in the <a id="sthref420"></a><code>NAME</code> clause uniquely identifies the Java method. The fully-qualified Java names and the call specification parameters, which are mapped by position, must correspond. However, this rule does not apply to the <code>main()</code> method. If the Java method does not take any arguments, then write an empty parameter list for it, but not for the function or procedure.</p>
<p>Write fully-qualified Java names using the dot notation. The following example shows that the fully-qualified names can be broken across lines at dot boundaries:</p>
<pre>artificialIntelligence.neuralNetworks.patternClassification.
RadarSignatureClassifier.computeRange()
</pre>
<p>This section provides the following examples:</p>
<ul>
<li>
<p><a href="#BABDIHJC">Example 6-1, &#34;Publishing a Simple JDBC Stored Procedure&#34;</a></p>
</li>
<li>
<p><a href="#BABFGCDC">Example 6-2, &#34;Publishing the main() Method&#34;</a></p>
</li>
<li>
<p><a href="#BABIBHCI">Example 6-3, &#34;Publishing a Method That Returns an Integer Value&#34;</a></p>
</li>
<li>
<p><a href="#BABBEAJI">Example 6-4, &#34;Publishing a Method That Switches the Values of Its Arguments&#34;</a></p>
</li>
</ul>
<div id="JJDEV13265" class="example">
<p class="titleinexample"><a id="BABDIHJC"></a>Example 6-1 Publishing a Simple JDBC Stored Procedure</p>
<p>Assume that the executable for the following Java class has been loaded into the database:</p>
<pre>import java.sql.*;
import java.io.*;
import oracle.jdbc.*;

public class GenericDrop
{
  public static void dropIt(String object_type, String object_name)
                                                         throws SQLException
  {
    // Connect to Oracle using JDBC driver
    Connection conn = DriverManager.getConnection(&#34;jdbc:default:connection:&#34;);
    // Build SQL statement
    String sql = &#34;DROP &#34; + object_type + &#34; &#34; + object_name;
    try 
    {
      Statement stmt = conn.createStatement();
      stmt.executeUpdate(sql);
      stmt.close();
    }
    catch (SQLException e)
    {
      System.err.println(e.getMessage());
    }
  }
}
</pre>
<p>The <code>GenericDrop</code> class has one method, <code>dropIt()</code>, which drops any kind of schema object. For example, if you pass the <code>table</code> and <code>employees</code> arguments to <code>dropIt()</code>, then the method drops the database table <code>employees</code> from your schema.</p>
<p>The call specification for the <code>dropIt()</code> method is as follows:</p>
<pre>CREATE OR REPLACE PROCEDURE drop_it (obj_type VARCHAR2, obj_name VARCHAR2)
AS LANGUAGE JAVA
NAME &#39;GenericDrop.dropIt(java.lang.String, java.lang.String)&#39;;
</pre>
<p>Note that you must fully qualify the reference to <code>String</code>. The <code>java.lang</code> package is automatically available to Java programs, but must be named explicitly in the call specifications.</p>
</div>
<!-- class="example" -->
<div id="JJDEV13266" class="example">
<p class="titleinexample"><a id="BABFGCDC"></a>Example 6-2 Publishing the main() Method</p>
<p>As a rule, Java names and call specification parameters must correspond. However, that rule does not apply to the <code>main()</code> method. Its <code>String[]</code> parameter can be mapped to multiple <code>CHAR</code> or <code>VARCHAR2</code> call specification parameters. Consider the <code>main()</code> method in the following class, which displays its arguments:</p>
<pre>public class EchoInput
{
  public static void main (String[] args)
  {
    for (int i = 0; i &lt; args.length; i++)
      System.out.println(args[i]);
  }
}
</pre>
<p>To publish <code>main()</code>, write the following call specification:</p>
<pre>CREATE OR REPLACE PROCEDURE echo_input(s1 VARCHAR2, s2 VARCHAR2, s3 VARCHAR2)
AS LANGUAGE JAVA
NAME &#39;EchoInput.main(java.lang.String[])&#39;;
</pre>
<p>You cannot impose constraints, such as precision, size, and <code>NOT NULL</code>, on the call specification parameters. As a result, you cannot specify a maximum size for the <code>VARCHAR2</code> parameters. However, you must do so for <code>VARCHAR2</code> variables, as in:</p>
<pre>DECLARE last_name VARCHAR2(20); -- size constraint required
</pre></div>
<!-- class="example" -->
<div id="JJDEV13267" class="example">
<p class="titleinexample"><a id="BABIBHCI"></a>Example 6-3 Publishing a Method That Returns an Integer Value</p>
<p>In the following example, the <code>rowCount()</code> method, which returns the number of rows in a given database table, is published:</p>
<pre>import java.sql.*;
import java.io.*;
import oracle.jdbc.*;

public class RowCounter
{
  public static int rowCount (String tabName) throws SQLException
  {
    Connection conn = DriverManager.getConnection(&#34;jdbc:default:connection:&#34;);
    String sql = &#34;SELECT COUNT(*) FROM &#34; + tabName;
    int rows = 0;
    try
    {
      Statement stmt = conn.createStatement();
      ResultSet rset = stmt.executeQuery(sql);
      while (rset.next())
      {
        rows = rset.getInt(1);
      }
      rset.close();
      stmt.close();
    }
    catch (SQLException e)
    {
      System.err.println(e.getMessage());
    }
    return rows;
  }
}
</pre>
<p><code>NUMBER</code> subtypes, such as <code>INTEGER</code>, <code>REAL</code>, and <code>POSITIVE</code>, are not allowed in a call specification. As a result, in the following call specification, the return type is <code>NUMBER</code> and not <code>INTEGER</code>:</p>
<pre>CREATE FUNCTION row_count (tab_name VARCHAR2) RETURN NUMBER
AS LANGUAGE JAVA
NAME &#39;RowCounter.rowCount(java.lang.String) return int&#39;;
</pre></div>
<!-- class="example" -->
<div id="JJDEV13268" class="example">
<p class="titleinexample"><a id="BABBEAJI"></a>Example 6-4 Publishing a Method That Switches the Values of Its Arguments</p>
<p>Consider the <code>swap()</code> method in the following <code>Swapper</code> class, which switches the values of its arguments:</p>
<pre>public class Swapper
{
  public static void swap (int[] x, int[] y)
  {
    int hold = x[0];
    x[0] = y[0];
    y[0] = hold;
  }
}
</pre>
<p>The call specification publishes the <code>swap()</code> method as a call specification, <code>swap()</code>. The call specification declares <code>IN OUT</code> formal parameters, because values must be passed in and out. All call specification <code>OUT</code> and <code>IN OUT</code> parameters must map to Java array parameters.</p>
<pre>CREATE PROCEDURE swap (x IN OUT NUMBER, y IN OUT NUMBER)
AS LANGUAGE JAVA
NAME &#39;Swapper.swap(int[], int[])&#39;;
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
A Java method and its call specification can have the same name.</div>
</div>
<!-- class="sect1" -->
<a id="BABFJFCD"></a>
<div id="JJDEV13269" class="sect1">
<h2 class="sect1">Writing <a id="sthref421"></a><a id="sthref422"></a>Packaged Call Specifications</h2>
<p>A <a id="sthref423"></a>PL/SQL package is a schema object that groups logically related types, items, and subprograms. Usually, packages have two parts, a specification and a <a id="sthref424"></a>body. The specification is the interface to your applications and declares the types, constants, variables, exceptions, cursors, and subprograms available for use. The body defines the cursors and subprograms.</p>
<p>In SQL*Plus, you can define PL/SQL packages interactively, using the following syntax:</p>
<pre>CREATE [OR REPLACE] PACKAGE package_name
  [AUTHID {CURRENT_USER | DEFINER}] {IS | AS}
  [type_definition [type_definition] ...]
  [cursor_spec [cursor_spec] ...]
  [item_declaration [item_declaration] ...]
  [{subprogram_spec | call_spec} [{subprogram_spec | call_spec}]...]
END [package_name];

[CREATE [OR REPLACE] PACKAGE BODY package_name {IS | AS}
  [type_definition [type_definition] ...]
  [cursor_body [cursor_body] ...]
  [item_declaration [item_declaration] ...]
  [{subprogram_spec | call_spec} [{subprogram_spec | call_spec}]...]
[BEGIN
  sequence_of_statements]
END [package_name];]
</pre>
<p>The specification holds public declarations, which are visible to your application. The body contains implementation details and private declarations, which are hidden from your application. Following the declarative part of the package is the body, which is the optional initialization part. It holds statements that initialize package variables. It is run only once, the first time you reference the package.</p>
<p>A call specification declared in a package specification cannot have the same signature, that is, the name and parameter list, as a subprogram in the package body. If you declare all the subprograms in a package specification as call specifications, then the package body is not required, unless you want to define a cursor or use the initialization part.</p>
<p>The <a id="sthref425"></a><code>AUTHID</code> clause determines whether all the packaged subprograms run with the privileges of their definer (<code>AUTHID DEFINER</code>), which is the default, or invoker (<code>AUTHID CURRENT_USER</code>). It also determines whether unqualified references to schema objects are resolved in the schema of the definer or invoker.</p>
<p><a href="#BABEGFAG">Example 6-5</a> provides an example of packaged call specification.</p>
<div id="JJDEV13270" class="example">
<p class="titleinexample"><a id="BABEGFAG"></a>Example 6-5 Packaged Call Specification</p>
<p>Consider a Java class, <code>DeptManager</code>, which consists of methods for adding a new department, dropping a department, and changing the location of a department. Note that the <code>addDept()</code> method uses a database sequence to get the next department number. The three methods are logically related, and therefore, you may want to group their call specifications in a PL/SQL package.</p>
<pre>import java.sql.*;
import java.io.*;
import oracle.jdbc.*;

public class DeptManager
{
  public static void addDept (String deptName, String deptLoc) throws SQLException
  {
    Connection conn = DriverManager.getConnection(&#34;jdbc:default:connection:&#34;);
    String sql = &#34;SELECT deptnos.NEXTVAL FROM dual&#34;;
    String sql2 = &#34;INSERT INTO dept VALUES (?, ?, ?)&#34;;
    int deptID = 0;
    try
    {
      PreparedStatement pstmt = conn.prepareStatement(sql);
      ResultSet rset = pstmt.executeQuery();
      while (rset.next())
      {
        deptID = rset.getInt(1);
      }
      pstmt = conn.prepareStatement(sql2);
      pstmt.setInt(1, deptID);
      pstmt.setString(2, deptName);
      pstmt.setString(3, deptLoc);
      pstmt.executeUpdate();
      rset.close();
      pstmt.close();
    }
    catch (SQLException e)
    {
      System.err.println(e.getMessage());
    }
  }

  public static void dropDept (int deptID) throws SQLException
  {
    Connection conn = DriverManager.getConnection(&#34;jdbc:default:connection:&#34;);
    String sql = &#34;DELETE FROM dept WHERE deptno = ?&#34;;
    try
    {
      PreparedStatement pstmt = conn.prepareStatement(sql);
      pstmt.setInt(1, deptID);
      pstmt.executeUpdate();
      pstmt.close();
    }
    catch (SQLException e)
    {
      System.err.println(e.getMessage());
    }
  }

  public static void changeLoc (int deptID, String newLoc) throws SQLException
  {
    Connection conn = DriverManager.getConnection(&#34;jdbc:default:connection:&#34;);
    String sql = &#34;UPDATE dept SET loc = ? WHERE deptno = ?&#34;;
    try
    {
      PreparedStatement pstmt = conn.prepareStatement(sql);
      pstmt.setString(1, newLoc);
      pstmt.setInt(2, deptID);
      pstmt.executeUpdate();
      pstmt.close();
    }
    catch (SQLException e)
    {
      System.err.println(e.getMessage());
    }
  }
}
</pre>
<p>Suppose you want to package the methods <code>addDept()</code>, <code>dropDept()</code>, and <code>changeLoc()</code>. First, you must create the package specification, as follows:</p>
<pre>CREATE OR REPLACE PACKAGE dept_mgmt AS
PROCEDURE add_dept (dept_name VARCHAR2, dept_loc VARCHAR2);
PROCEDURE drop_dept (dept_id NUMBER);
PROCEDURE change_loc (dept_id NUMBER, new_loc VARCHAR2);
END dept_mgmt;
</pre>
<p>Then, you must create the package body by writing the call specifications for the Java methods, as follows:</p>
<pre>CREATE OR REPLACE PACKAGE BODY dept_mgmt AS
PROCEDURE add_dept (dept_name VARCHAR2, dept_loc VARCHAR2)
AS LANGUAGE JAVA
NAME &#39;DeptManager.addDept(java.lang.String, java.lang.String)&#39;;

PROCEDURE drop_dept (dept_id NUMBER)
AS LANGUAGE JAVA
NAME &#39;DeptManager.dropDept(int)&#39;;

PROCEDURE change_loc (dept_id NUMBER, new_loc VARCHAR2)
AS LANGUAGE JAVA
NAME &#39;DeptManager.changeLoc(int, java.lang.String)&#39;;
END dept_mgmt;
</pre>
<p>To reference the stored procedures in the <code>dept_mgmt</code> package, use the dot notation, as follows:</p>
<pre>CALL dept_mgmt.add_dept(&#39;PUBLICITY&#39;, &#39;DALLAS&#39;);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="BABJJFJC"></a>
<div id="JJDEV13271" class="sect1">
<h2 class="sect1">Writing <a id="sthref426"></a>Object Type Call Specifications</h2>
<p><a id="sthref427"></a>In SQL, object-oriented programming is based on object types, which are user-defined composite data types that encapsulate a data structure along with the functions and procedures required to manipulate the data. The variables that form the data structure are known as a<a id="sthref428"></a>ttributes. The functions and procedures that characterize the behavior of the object type are known as <a id="sthref429"></a>methods, which can be written in Java.</p>
<p>As with a package, an object type has two parts: a specification and a <a id="sthref430"></a>body. The specification is the interface to your applications and declares a data structure, which is a set of attributes, along with the operations or methods required to manipulate the data. The body implements the specification by defining PL/SQL subprogram bodies or call specifications.</p>
<p>If the specification declares only attributes or call specifications, then the body is not required. If you implement all your methods in Java, then you can place their call specifications in the specification part of the object type and omit the body part.</p>
<p>In SQL*Plus, you can define SQL object types interactively, using the following syntax:</p>
<pre>CREATE [OR REPLACE] TYPE type_name
  [AUTHID {CURRENT_USER | DEFINER}] {IS | AS} OBJECT (
  attribute_name data_type[, attribute_name data_type]...
  [{MAP | ORDER} MEMBER {function_spec | call_spec},]
  [{MEMBER | STATIC} {subprogram_spec | call_spec}
  [, {MEMBER | STATIC} {subprogram_spec | call_spec}]...]
);

[CREATE [OR REPLACE] TYPE BODY type_name {IS | AS}
  { {MAP | ORDER} MEMBER function_body;
   | {MEMBER | STATIC} {subprogram_body | call_spec};}
  [{MEMBER | STATIC} {subprogram_body | call_spec};]...
END;]
</pre>
<p>The <a id="sthref431"></a><code>AUTHID</code> clause determines whether all member methods of the type run with the privileges of their definer (<code>AUTHID</code> <code>DEFINER</code>), which is the default, or invoker (<code>AUTHID</code> <code>CURRENT_USER</code>). It also determines whether unqualified references to schema objects are resolved in the schema of the definer or invoker.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABECFAC">Declaring Attributes</a></p>
</li>
<li>
<p><a href="#BABFBCBD">Declaring Methods</a></p>
</li>
</ul>
<a id="BABECFAC"></a>
<div id="JJDEV13272" class="sect2">
<h3 class="sect2">Declaring<a id="sthref432"></a> Attributes</h3>
<p>In an object type specification, all attributes must be declared before any methods are. In addition, you must declare at least one attribute. The maximum number of attributes that can be declared is 1000. Methods are optional.</p>
<p>As with a Java variable, you declare an attribute with a name and data type. The name must be unique within the object type, but can be reused in other object types. The data type can be any SQL type, except <code>LONG</code>, <code>LONG RAW</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>NCLOB</code>, <code>ROWID</code>, and <code>UROWID</code>.</p>
<p>You cannot initialize an attribute in its declaration using the assignment operator or <code>DEFAULT</code> clause. Furthermore, you cannot impose the <code>NOT NULL</code> constraint on an attribute. However, objects can be stored in database tables on which you can impose constraints.</p>
</div>
<!-- class="sect2" -->
<a id="BABFBCBD"></a>
<div id="JJDEV13273" class="sect2">
<h3 class="sect2">Declaring <a id="sthref433"></a>Methods</h3>
<p>After declaring attributes, you can declare methods. <code>MEMBER</code> methods accept a built-in parameter known as <code>SELF</code>, which is an instance of the object type. Whether declared implicitly or explicitly, it is always the first parameter passed to a <code>MEMBER</code> method. In the method body, <code>SELF</code> denotes the object whose method was called. <code>MEMBER</code> methods are called on instances, as follows:</p>
<pre>instance_expression.method()
</pre>
<p><code>STATIC</code> methods, which cannot accept or reference <code>SELF</code>, are invoked on the object type and not its instances, as follows:</p>
<pre>object_type_name.method()
</pre>
<p>If you want to call a Java method that is not <code>static</code>, then you must specify the keyword <code>MEMBER</code> in its call specification. Similarly, if you want to call a <code>static</code> Java method, then you must specify the keyword <code>STATIC</code> in its call specification.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BABBDHEB">Map and Order Methods</a></p>
</li>
<li>
<p><a href="#BABECHAF">Constructor Methods</a></p>
</li>
<li>
<p><a href="#BABGIHCC">Examples</a></p>
</li>
</ul>
<a id="BABBDHEB"></a>
<div id="JJDEV13274" class="sect3">
<h4 class="sect3">Map<a id="sthref434"></a> and O<a id="sthref435"></a><a id="sthref436"></a>rder Methods</h4>
<p>The values of a SQL scalar data type, such as <code>CHAR</code>, have a predefined order and, therefore, can be compared with other values. However, instances of an object type have no predefined order. To put them in order, SQL calls a user-defined <code>map</code> method.</p>
<p>SQL uses the ordering to evaluate boolean expressions, such as <code>x &gt; y</code>, and to make comparisons implied by the <code>DISTINCT</code>, <code>GROUP BY</code>, and <code>ORDER BY</code> clauses. A map method returns the relative position of an object in the ordering of all such objects. An object type can contain only one map method, which must be a function without any parameters and with one of the following return types: <code>DATE</code>, <code>NUMBER</code>, or <code>VARCHAR2</code>.</p>
<p>Alternatively, you can supply SQL with an <code>order</code> method, which compares two objects. An <code>order</code> method takes only two parameters: the built-in parameter, <code>SELF</code>, and another object of the same type. If <code>o1</code> and <code>o2</code> are objects, then a comparison, such as <code>o1 &gt; o2</code>, calls the <code>order</code> method automatically. The method returns a negative number, zero, or a positive number signifying that <code>SELF</code> is less than, equal to, or greater than the other parameter, respectively. An object type can contain only one <code>order</code> method, which must be a function that returns a numeric result.</p>
<p>You can declare a <code>map</code> method or an <code>order</code> method, but not both. If you declare either of these methods, then you can compare objects in SQL and PL/SQL. However, if you do not declare both methods, then you can compare objects only in SQL and solely for equality or inequality.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Two objects of the same type are equal if the values of their corresponding attributes are equal.</div>
</div>
<!-- class="sect3" -->
<a id="BABECHAF"></a>
<div id="JJDEV13275" class="sect3">
<h4 class="sect3"><a id="sthref437"></a>Constructor M<a id="sthref438"></a>ethods</h4>
<p>Every object type has a constructor, which is a system-defined function with the same name as the object type. The constructor initializes and returns an instance of that object type.</p>
<p>Oracle Database generates a default constructor for every object type. The formal parameters of the constructor match the attributes of the object type. That is, the parameters and attributes are declared in the same order and have the same names and data types. SQL never calls a constructor implicitly. As a result, you must call it explicitly. Constructor calls are allowed wherever function calls are allowed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To invoke a Java constructor from SQL, you must wrap calls to it in a <code>static</code> method and declare the corresponding call specification as a <code>STATIC</code> member of the object type.</div>
</div>
<!-- class="sect3" -->
<a id="BABGIHCC"></a>
<div id="JJDEV13276" class="sect3">
<h4 class="sect3">Examples</h4>
<p>In this section, each example builds on the previous one. To begin, you create two SQL object types to represent departments and employees. First, you write the specification <a id="sthref439"></a>for the object type <code>Department</code>. The body is not required, because the specification declares only attributes. The specification is as follows:</p>
<pre>CREATE TYPE Department AS OBJECT ( 
deptno NUMBER(2),
dname VARCHAR2(14),
loc VARCHAR2(13)
);
</pre>
<p>Then, you create the object type <code>Employee</code>. The <code>deptno</code> attribute stores a handle, called a <code><a id="sthref440"></a>REF</code>, to objects of the type <code>Department</code>. A <code>REF</code> indicates the location of an object in an object table, which is a database table that stores instances of an object type. The <code>REF</code> does not point to a specific instance copy in memory. To declare a <code>REF</code>, you specify the data type <code>REF</code> and the object type that <code>REF</code> targets. The <code>Employee</code> type is created as follows:</p>
<pre>CREATE TYPE Employee AS OBJECT (
empno NUMBER(4),
ename VARCHAR2(10),
job VARCHAR2(9),
mgr NUMBER(4),
hiredate DATE,
sal NUMBER(7,2),
comm NUMBER(7,2),
deptno REF Department
);
</pre>
<p>Next, you create the SQL object tables to hold objects of type <code>Department</code> and <code>Employee</code>. Create the <code>depts</code> object table, which will hold objects of the <code>Department</code> type. Populate the object table by selecting data from the <code>dept</code> relational table and passing it to a constructor, which is a system-defined function with the same name as the object type. Use the constructor to initialize and return an instance of that object type. The <code>depts</code> table is created as follows:</p>
<pre>CREATE TABLE depts OF Department AS
SELECT Department(deptno, dname, loc) FROM dept;
</pre>
<p>Create the <code>emps</code> object table, which will hold objects of type <code>Employee</code>. The last column in the <code>emps</code> object table, which corresponds to the last attribute of the <code>Employee</code> object type, holds references to objects of type <code>Department</code>. To fetch the references into this column, use the operator <code>REF</code>, which takes a table alias associated with a row in an object table as its argument. The <code>emps</code> table is created as follows:</p>
<pre>CREATE TABLE emps OF Employee AS
SELECT Employee(e.employee_id, e.first_name, e.job_id, e.manager_id, e.hire_date, e.salary, e.commission_pct, 
(SELECT REF(d) FROM departments d WHERE d.department_id = e.department_id))
FROM employees e;
</pre>
<p>Selecting a <code>REF</code> returns a handle to an object. It does not materialize the object itself. To do that, you can use methods in the <code>oracle.sql.REF</code> class, which supports Oracle object references. This class, which is a subclass of <code>oracle.sql.Datum</code>, extends the standard JDBC interface, <code>oracle.jdbc2.Ref</code>.</p>
<p class="subhead2"><a id="JJDEV13277"></a>Using Class oracle.sql.STRUCT</p>
<p>To continue, you write a Java stored procedure. The <code>Paymaster</code> class has one method, which computes an employee&#39;s wages. The <code>getAttributes()</code> method defined in the <code>oracle.sql.STRUCT</code> class uses the default JDBC mappings for the attribute types. For example, <code>NUMBER</code> maps to <code>BigDecimal</code>. The <code>Paymaster</code> class is created as follows:</p>
<pre>import java.sql.*;
import java.io.*;
import oracle.sql.*;
import oracle.jdbc.*;
import oracle.oracore.*;
import oracle.jdbc2.*;
import java.math.*;

public class Paymaster
{
  public static BigDecimal wages(STRUCT e) throws java.sql.SQLException
  {
    // Get the attributes of the Employee object.
    Object[] attribs = e.getAttributes();
    // Must use numeric indexes into the array of attributes.
    BigDecimal sal = (BigDecimal)(attribs[5]); // [5] = sal
    BigDecimal comm = (BigDecimal)(attribs[6]); // [6] = comm
    BigDecimal pay = sal;
    if (comm != null)
      pay = pay.add(comm);
    return pay;
  }
}
</pre>
<p>Because the <code>wages()</code> method returns a value, you write a function call specification for it, as follows:</p>
<pre>CREATE OR REPLACE FUNCTION wages (e Employee) RETURN NUMBER AS
LANGUAGE JAVA
NAME &#39;Paymaster.wages(oracle.sql.STRUCT) return BigDecimal&#39;;
</pre>
<p>This is a top-level call specification, because it is not defined inside a package or object type.</p>
<p class="subhead2"><a id="JJDEV13278"></a>Implementing the SQLData Interface</p>
<p>To make access to object attributes more natural, create a Java class that implements the <code>SQLData</code> interface. To do so, you must provide the <code>readSQL()</code> and <code>writeSQL()</code> methods as defined by the <code>SQLData</code> interface. The JDBC driver calls the <code>readSQL()</code> method to read a stream of database values and populate an instance of your Java class. In the following example, you revise <code>Paymaster</code> by adding a second method, <code>raiseSal()</code>:</p>
<pre>import java.sql.*;
import java.io.*;
import oracle.sql.*;
import oracle.jdbc.*;
import oracle.oracore.*;
import oracle.jdbc2.*;
import java.math.*;

public class Paymaster implements SQLData
{
  // Implement the attributes and operations for this type.
  private BigDecimal empno;
  private String ename;
  private String job;
  private BigDecimal mgr;
  private Date hiredate;
  private BigDecimal sal;
  private BigDecimal comm;
  private Ref dept;

  public static BigDecimal wages(Paymaster e)
  {
    BigDecimal pay = e.sal;
    if (e.comm != null)
      pay = pay.add(e.comm);
    return pay;
  }

  public static void raiseSal(Paymaster[] e, BigDecimal amount)
  {
    e[0].sal = // IN OUT passes [0]
    e[0].sal.add(amount); // increase salary by given amount
  }

  // Implement SQLData interface.

  private String sql_type;

  public String getSQLTypeName() throws SQLException
  {
    return sql_type;
  }

  public void readSQL(SQLInput stream, String typeName) throws SQLException
  {
    sql_type = typeName;
    empno = stream.readBigDecimal();
    ename = stream.readString();
    job = stream.readString();
    mgr = stream.readBigDecimal();
    hiredate = stream.readDate();
    sal = stream.readBigDecimal();
    comm = stream.readBigDecimal();
    dept = stream.readRef();
  }

  public void writeSQL(SQLOutput stream) throws SQLException
  {
    stream.writeBigDecimal(empno);
    stream.writeString(ename);
    stream.writeString(job);
    stream.writeBigDecimal(mgr);
    stream.writeDate(hiredate);
    stream.writeBigDecimal(sal);
    stream.writeBigDecimal(comm);
    stream.writeRef(dept);
  }
}
</pre>
<p>You must revise the call specification for <code>wages()</code>, as follows, because its parameter has changed from <code>oracle.sql.STRUCT</code> to <code>Paymaster</code>:</p>
<pre>CREATE OR REPLACE FUNCTION wages (e Employee) RETURN NUMBER AS
LANGUAGE JAVA
NAME &#39;Paymaster.wages(Paymaster) return BigDecimal&#39;;
</pre>
<p>Because the new method, <code>raiseSal()</code>, is <code>void</code>, write a procedure call specification for it, as follows:</p>
<pre>CREATE OR REPLACE PROCEDURE raise_sal (e IN OUT Employee, r NUMBER)
AS LANGUAGE JAVA
NAME &#39;Paymaster.raiseSal(Paymaster[], java.math.BigDecimal)&#39;;
</pre>
<p>Again, this is a top-level call specification.</p>
<p class="subhead2"><a id="BABDJIHE"></a><a id="JJDEV13279"></a>Implementing Object Type Methods</p>
<p>Assume you decide to drop the top-level call specifications <code>wages</code> and <code>raise_sal</code> and redeclare them as methods of the object type <code>Employee</code>. In an object type specification, all methods must be declared after the attributes. The body of the object type is not required, because the specification declares only attributes and call specifications. The <code>Employee</code> object type can be re-created as follows:</p>
<pre>CREATE TYPE Employee AS OBJECT (
empno NUMBER(4),
ename VARCHAR2(10),
job VARCHAR2(9),
mgr NUMBER(4),
hiredate DATE,
sal NUMBER(7,2),
comm NUMBER(7,2),
deptno REF Department
MEMBER FUNCTION wages RETURN NUMBER
AS LANGUAGE JAVA
NAME &#39;Paymaster.wages() return java.math.BigDecimal&#39;,
MEMBER PROCEDURE raise_sal (r NUMBER)
AS LANGUAGE JAVA
NAME &#39;Paymaster.raiseSal(java.math.BigDecimal)&#39;
);
</pre>
<p>Then, you revise <code>Paymaster</code> accordingly. You need not pass an array to <code>raiseSal()</code>, because the SQL parameter <code>SELF</code> corresponds directly to the Java parameter <code>this</code>, even when <code>SELF</code> is declared as <code>IN OUT</code>, which is the default for procedures.</p>
<pre>import java.sql.*;
import java.io.*;
import oracle.sql.*;
import oracle.jdbc.*;
import oracle.oracore.*;
import oracle.jdbc2.*;
import java.math.*;

public class Paymaster implements SQLData
{
  // Implement the attributes and operations for this type.
  private BigDecimal empno;
  private String ename;
  private String job;
  private BigDecimal mgr;
  private Date hiredate;
  private BigDecimal sal;
  private BigDecimal comm;
  private Ref dept;

  public BigDecimal wages()
  {
    BigDecimal pay = sal;
    if (comm != null)
      pay = pay.add(comm);
    return pay;
  }

  public void raiseSal(BigDecimal amount)
  {
    // For SELF/this, even when IN OUT, no array is needed.
    sal = sal.add(amount);
  }

  // Implement SQLData interface.

  String sql_type;

  public String getSQLTypeName() throws SQLException
  {
    return sql_type;
  }

  public void readSQL(SQLInput stream, String typeName) throws SQLException
  {
    sql_type = typeName;
    empno = stream.readBigDecimal();
    ename = stream.readString();
    job = stream.readString();
    mgr = stream.readBigDecimal();
    hiredate = stream.readDate();
    sal = stream.readBigDecimal();
    comm = stream.readBigDecimal();
    dept = stream.readRef();
  }

  public void writeSQL(SQLOutput stream) throws SQLException
  {
    stream.writeBigDecimal(empno);
    stream.writeString(ename);
    stream.writeString(job);
    stream.writeBigDecimal(mgr);
    stream.writeDate(hiredate);
    stream.writeBigDecimal(sal);
    stream.writeBigDecimal(comm);
    stream.writeRef(dept);
  }
}
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3995">
<tr>
<td class="cellalignment4004">
<table class="cellalignment4000">
<tr>
<td class="cellalignment3999"><a href="chfive.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3999"><a href="chseven.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4006">
<table class="cellalignment3998">
<tr>
<td class="cellalignment3999"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3999"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3999"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3999"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3999"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3999"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>