<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-71043"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Calling%20Java%20Methods%20in%20Oracle%20Database"></a><title>Calling Java Methods in Oracle Database</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="description" content="This book describes how to develop, load, and run Java applications in Oracle Database."/>
<meta name="dcterms.created" content="2014-06-30T4:25:0Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Java Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E50793-03"/>
<meta name="dcterms.isVersionOf" content="JJDEV"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="chtwo.htm" title="Previous" type="text/html"/>
<link rel="Next" href="chfour.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E50793-03.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">10/23</span> <!-- End Header -->
<div id="JJDEV13165" class="chapter"><a id="CACJJHGI"></a>
<h1 class="chapter"><span class="secnum">3</span> Calling Java Methods in Oracle Database</h1>
<p>This chapter provides an overview and examples of calling Java methods that reside in Oracle Database. It contains the following sections:</p>
<ul>
<li>
<p><a href="#CACFGDCI">Invoking Java Methods</a></p>
</li>
<li>
<p><a href="#CACFDCIH">How To Tell You Are Running on the Server</a></p>
</li>
<li>
<p><a href="#CACIIEDH">Redirecting Output on the Server</a></p>
</li>
<li>
<p><a href="#CACEGFCH">Calling Java in the Database Directly</a></p>
</li>
</ul>
<a id="CACFGDCI"></a>
<div id="JJDEV13166" class="sect1">
<h2 class="sect1">Invoking <a id="sthref332"></a><a id="sthref333"></a><a id="sthref334"></a>Java Methods</h2>
<p>The type of the Java application determines how the client calls a Java method. The following sections discuss each of the Java application programming interfaces (APIs) available for calling a Java method:</p>
<ul>
<li>
<p><a href="#CACICFFB">Using PL/SQL Wrappers</a></p>
</li>
<li>
<p><a href="#CACFCDJF">JNI Support</a></p>
</li>
<li>
<p><a href="#CACCIEAH">Utilizing SQLJ and JDBC with Java in the Database</a></p>
</li>
<li>
<p><a href="#CHDJHBGH">Using Command-Line Interface</a></p>
</li>
<li>
<p><a href="#CBBEJGIH">Using the Client-Side Stub</a></p>
</li>
</ul>
<a id="CACICFFB"></a>
<div id="JJDEV13167" class="sect2">
<h3 class="sect2">Using PL/SQL Wrappers</h3>
<p><a id="sthref335"></a>You can run Java stored procedures in the same way as PL/SQL stored procedures. In Oracle Database, Java is usually invoked through PL/SQL interface.</p>
<p>To call a Java stored procedure, you must publish it through a <a id="sthref336"></a>call specification. The following example shows how to create, resolve, load, and publish a simple Java stored procedure that returns a string:</p>
<ol>
<li>
<p>Define a class, <code>Hello</code>, as follows:</p>
<pre>public class Hello
{
  public static String world()
  {
    return &#34;Hello world&#34;;
  }
}
</pre>
<p>Save the file as a <code>Hello.java</code> file.</p>
</li>
<li>
<p>Compile the class on your client system using the standard Java compiler, as follows:</p>
<pre>javac Hello.java
</pre>
<p>It is a good idea to specify the <code>CLASSPATH</code> on the command line with the <code>javac</code> command, especially when writing shell scripts or make files. The Java compiler produces a Java binary file, in this case, <code>Hello.class</code>.</p>
<p>You must determine the location at which this Java code will run. If you run <code>Hello.class</code> on your client system, then it searches the <code>CLASSPATH</code> for all the supporting core classes that <code>Hello.class</code> needs for running. This search should result in locating the dependent classes in one of the following:</p>
<ul>
<li>
<p>As individual files in one or more directories, where the directories are specified in the <code>CLASSPATH</code></p>
</li>
<li>
<p>Within <code>.jar</code> or <code>.zip</code> files, where the directories containing these files are specified in the <code>CLASSPATH</code></p>
</li>
</ul>
</li>
<li>
<p><a id="sthref337"></a>Decide on the resolver for the <code>Hello</code> class.</p>
<p>In this case, load <code>Hello.class</code> on the server, where it is stored in the database as a Java schema object. When you call the <code>world()</code> method, Oracle JVM locates the necessary supporting classes, such as <code>String</code>, using a resolver. In this case, Oracle JVM uses the default resolver. The default resolver looks for these classes, first in the current schema, and then in <code>PUBLIC</code>. All core class libraries, including the <code>java.lang</code> package, are found in <code>PUBLIC</code>. You may need to specify different resolvers. You can trace problems earlier, rather than at run time, by forcing resolution to occur when you use the <code>loadjava</code> tool.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chtwo.htm#BABGJCAJ">&#34;Resolving Class Dependencies&#34;</a> and <a href="cheleven.htm#CACCBHIC">Chapter 12, &#34;Schema Objects and Oracle JVM Utilities&#34;</a></div>
</li>
<li>
<p><a id="sthref338"></a>Load the class on the server using the <code>loadjava</code> tool. You must specify the user name and password. Run the <code>loadjava</code> tool as follows:</p>
<pre>loadjava -user HR Hello.class
Password: <span class="italic">password</span>
</pre></li>
<li>
<p><a id="sthref339"></a>Publish the stored procedure through a call specification.</p>
<p>To call a Java <code>static</code> method with a SQL call, you must publish the method with a call specification. A call specification defines the arguments that the method takes and the SQL types that it returns.</p>
<p>In SQL*Plus, connect to the database and define a top-level call specification for <code>Hello.world()</code> as follows:</p>
<pre>sqlplus HR
Enter password: <span class="italic">password</span>
connected
SQL&gt; CREATE OR REPLACE FUNCTION helloworld RETURN VARCHAR2 AS
  2  LANGUAGE JAVA NAME &#39;Hello.world () return java.lang.String&#39;;
  3  /
Function created.
</pre></li>
<li>
<p>Call the stored procedure, as follows:</p>
<pre>SQL&gt; VARIABLE myString VARCHAR2(20);
SQL&gt; CALL helloworld() INTO :myString;
Call completed.
SQL&gt; PRINT myString;

MYSTRING
---------------------------------------
Hello world

SQL&gt;
</pre>
<p>The <code>call helloworld() into :myString</code> statement performs a top-level call in Oracle Database. SQL and PL/SQL see no difference between a stored procedure that is written in Java, PL/SQL, or any other language. The call specification provides a means to tie inter-language calls together in a consistent manner. Call specifications are necessary only for entry points that are called with triggers or SQL and PL/SQL calls. Furthermore, JDeveloper can automate the task of writing call specifications.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="chfive.htm#BABGCGBG">Chapter 5, &#34;Developing Java Stored Procedures&#34;</a></div>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CACFCDJF"></a>
<div id="JJDEV13168" class="sect2">
<h3 class="sect2">JNI Support</h3>
<p>The <a id="sthref340"></a>Java Native Interface (JNI) is a standard programming interface for writing Java native methods and embedding the JVM into native applications. The primary goal of JNI is to provide binary compatibility of Java applications that use platform-specific native libraries.</p>
<p>Oracle Database does not support the use of JNI in Java applications. If you use JNI, then your application is not 100 percent pure Java and the native methods require porting between platforms. Native methods can cause server failure, violate security, and corrupt data.</p>
</div>
<!-- class="sect2" -->
<a id="CACCIEAH"></a>
<div id="JJDEV13169" class="sect2">
<h3 class="sect2">Utilizing SQLJ and JDBC with Java in the Database</h3>
<p>You can use SQLJ and Java Database Connectivity (JDBC) APIs from a Java client. Both APIs establish a session with a given user name and password on the database and run SQL queries against the database. The following table lists the APIs and their description:</p>
<div class="inftblinformal">
<table class="cellalignment4002" title="table" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t4">API</th>
<th class="cellalignment4003" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t4" headers="r1c1-t4"><a id="sthref341"></a>JDBC</td>
<td class="cellalignment4004" headers="r2c1-t4 r1c2-t4">Use this API for more complex or dynamic SQL queries. JDBC requires you to establish the session, construct the query, and so on.</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t4" headers="r1c1-t4">SQLJ</td>
<td class="cellalignment4004" headers="r3c1-t4 r1c2-t4">Use this API for easy SQL queries, both static and dynamic. SQLJ typically runs against a known table with known column names.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CACFBAEG">JDBC</a></p>
</li>
<li>
<p><a href="#CACEJBBC">SQLJ</a></p>
</li>
<li>
<p><a href="#CACHFBBF">Example Comparing JDBC and SQLJ</a></p>
</li>
<li>
<p><a href="#CACFIGBE">Complete SQLJ Example</a></p>
</li>
<li>
<p><a href="#CACEEHEH">SQLJ Strong Typing Paradigm</a></p>
</li>
<li>
<p><a href="#CACCGCCG">Translating a SQLJ Program</a></p>
</li>
<li>
<p><a href="#CACFGHJJ">Running a SQLJ Program in the Server</a></p>
</li>
<li>
<p><a href="#CACIJCDI">Converting a Client Application to Run on the Server</a></p>
</li>
<li>
<p><a href="#CACBBDJD">Interacting with PL/SQL</a></p>
</li>
</ul>
<a id="CACFBAEG"></a>
<div id="JJDEV13170" class="sect3">
<h4 class="sect3">JDBC</h4>
<p>JDBC is an industry-standard API that lets you embed SQL statements as Java method arguments. JDBC is based on the X/Open SQL Call Level Interface (CLI) and complies with the Entry Level of SQL-92 standard. Each vendor, such as Oracle, creates its JDBC implementation by implementing the <a id="sthref342"></a>interfaces of the standard <code>java.sql</code> package. Oracle provides the following JDBC drivers that implement these standard interfaces:</p>
<ul>
<li>
<p>The JDBC Thin driver, a 100 percent pure Java solution that you can use for either client-side applications or applets and requires no Oracle client installation.</p>
</li>
<li>
<p>The JDBC OCI driver, which you use for client-side applications and requires an Oracle client installation.</p>
</li>
<li>
<p>The server-side JDBC driver embedded in Oracle Database.</p>
</li>
</ul>
<p>Using JDBC is a step-by-step process of performing the following tasks:</p>
<ol>
<li>
<p>Obtaining a connection handle</p>
</li>
<li>
<p>Creating a statement object of some type for your desired SQL operation</p>
</li>
<li>
<p>Assigning any local variables that you want to bind to the SQL operation</p>
</li>
<li>
<p>Carrying out the operation</p>
</li>
<li>
<p>Optionally retrieving the result sets</p>
</li>
</ol>
<p>This process is sufficient for many applications, but becomes cumbersome for any complicated statements. Dynamic SQL operations, where the operations are not known until run time, require JDBC. However, in typical applications, this represents a minority of the SQL operations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../JJDBC/toc.htm"><span class="italic">Oracle Database JDBC Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect3" -->
<a id="CACEJBBC"></a>
<div id="JJDEV13171" class="sect3">
<h4 class="sect3">SQLJ</h4>
<p>SQLJ offers an industry-standard way to embed any static SQL operation directly into the Java source code in one simple step, without requiring the multiple steps of JDBC. Oracle SQLJ complies with the X3H2-98-320 American National Standards Institute (ANSI) standard.</p>
<p>SQLJ consists of a translator, which is a precompiler that supports standard SQLJ programming syntax, and a run-time component. After creating your SQLJ source code in a <code>.sqlj</code> file, you process it with the translator. The translator translates the SQLJ source code to standard Java source code, with SQL operations converted to calls to the SQLJ run time. In Oracle Database SQLJ implementation, the translator calls a Java compiler to compile the Java source code. When your SQLJ application runs, the SQLJ run time calls JDBC to communicate with the database.</p>
<p>SQLJ also enables you to catch errors in your SQL statements before run time. JDBC code, being pure Java, is compiled directly. The compiler cannot detect SQL errors. On the other hand, when you translate SQLJ code, the translator analyzes the embedded SQL statements semantically and syntactically, catching SQL errors during development, instead of allowing an end user to catch them when running the application.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JSQLJ" href="../JSQLJ/toc.htm"><span class="italic">Oracle Database SQLJ Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect3" -->
<a id="CACHFBBF"></a>
<div id="JJDEV13172" class="sect3">
<h4 class="sect3">Example Comparing JDBC and SQLJ</h4>
<p>The following is an example of a JDBC code and a SQLJ code that perform a simple operation:</p>
<p class="subhead2"><a id="JJDEV13173"></a><a id="sthref343"></a>JDBC:</p>
<pre>// Assume you already have a JDBC Connection object conn
// Define Java variables
String name;
int id=37115;
float salary=20000;

// Set up JDBC prepared statement.
PreparedStatement pstmt = conn.prepareStatement
(&#34;SELECT first_name FROM employees WHERE employee_id=? AND salary&gt;?&#34;);
pstmt.setInt(1, id);
pstmt.setFloat(2, salary);

// Execute query; retrieve name and assign it to Java variable.
ResultSet rs = pstmt.executeQuery();
while (rs.next())
{
  name=rs.getString(1);
  System.out.println(&#34;Name is: &#34; + name);
}

// Close result set and statement objects.
rs.close()
pstmt.close();
</pre>
<p>Assume that you have established a JDBC connection, <code>conn</code>. Next, you must do the following:</p>
<ol>
<li>
<p>Define the Java variables, <code>name</code>, <code>id</code>, and <code>salary</code>.</p>
</li>
<li>
<p>Create a <code>PreparedStatement</code> instance.</p>
<p>You can use a prepared statement whenever values in the SQL statement must be dynamically set. You can use the same prepared statement repeatedly with different variable values. The question marks (?) in the prepared statement are placeholders for Java variables. In the preceding example, these variables are assigned values using the <code>pstmt.setInt()</code> and <code>pstmt.setFloat()</code> methods. The first ? refers to the <code>int</code> variable <code>id</code> and is set to a value of <code>37115</code>. The second ? refers to the <code>float</code> variable <code>salary</code> and is set to a value of <code>20000</code>.</p>
</li>
<li>
<p>Run the query and return the data into a <code>ResultSet</code> object.</p>
</li>
<li>
<p>Retrieve the data of interest from the <code>ResultSet</code> object and display it. In this case, the <code>first_name</code> column. A result set usually contains multiple rows of data, although this example has only one row.</p>
</li>
</ol>
<p class="subhead2"><a id="JJDEV13174"></a>SQLJ:</p>
<pre>String name;
int id=37115;
float salary=20000;
#sql {SELECT first_name INTO :name FROM employees WHERE employee_id=:id AND salary&gt;:salary};
System.out.println(&#34;Name is: &#34; + name);
</pre>
<p>In addition to allowing SQL statements to be directly embedded in Java code, SQLJ supports Java host expressions, also known as bind expressions, to be used directly in the SQL statements. In the simplest case, a host expression is a simple variable, as in this example. However, more complex expressions are allowed as well. Each host expression is preceded by colon (:). This example uses Java host expressions, <code>name</code>, <code>id</code>, and <code>salary</code>. In SQLJ, because of its host expression support, you do not need a result set or equivalent when you are returning only a single row of data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
All SQLJ statements, including declarations, start with the <code>#sql</code> token.</div>
</div>
<!-- class="sect3" -->
<a id="CACFIGBE"></a>
<div id="JJDEV13175" class="sect3">
<h4 class="sect3">Complete SQLJ Example</h4>
<p>This section presents a complete example of a simple SQLJ program:</p>
<pre>import java.sql.*;
import sqlj.runtime.ref.DefaultContext;
import oracle.sqlj.runtime.Oracle;

#sql iterator MyIter (String first_name, int employee_id, float salary);

public class MyExample
{
  public static void main (String args[]) throws SQLException
  {
    Oracle.connect(&#34;jdbc:oracle:thin:@localhost:5521:orcl&#34;, &#34;HR&#34;, &#34;<span class="italic">&lt;password&gt;</span>&#34;);
    #sql { INSERT INTO employees (first_name, employee_id, salary) VALUES (&#39;SMITH&#39;, 32, 20000) };
    MyIter iter;
    #sql iter={ SELECT first_name, employee_id, salary FROM employees };
    while (iter.next())
    {
      System.out.println(iter.first_name()+&#34; &#34;+iter.employee_id()+&#34; &#34;+iter.salary());
    }
  }
}
</pre>
<p>In the preceding example, you do the following:</p>
<ol>
<li>
<p>Declare your iterators.</p>
<p>SQLJ uses a strongly-typed version of JDBC result sets, known as iterators. An iterator has a specific number of columns of specific data types. You must define your iterator types before using them, as in this example.</p>
<pre>#sql ITERATOR MyIter (String first_name, int employee_id, float salary);
</pre>
<p>This declaration results in SQLJ creating an iterator class, <code>MyIter</code>. Iterators of type <code>MyIter</code> can store results whose first column maps to a Java <code>String</code>, second column maps to a Java <code>int</code>, and third column maps to a Java <code>float</code>. This definition also names the three columns as <code>first_name</code>, <code>employee_id</code>, and <code>salary</code>, to match the column names of the referenced table in the database. <code>MyIter</code> is a named iterator.</p>
</li>
<li>
<p>Connect to the database.</p>
<pre>Oracle.connect(&#34;jdbc:oracle:thin:@localhost:5521:orcl&#34;,&#34;HR&#34;, &#34;<span class="italic">&lt;password&gt;</span>&#34;);
</pre>
<p>SQLJ provides the <code>Oracle</code> class and its <code>connect()</code> method accomplishes the following important tasks:</p>
<ol>
<li>
<p>Registers Oracle JDBC drivers that SQLJ uses to access the database, in this case, the JDBC Thin driver.</p>
</li>
<li>
<p>Opens a database connection for the specified schema, in this case, user <code>HR</code> with the specified password, at the specified URL. In this case, the URL points to host <code>localhost</code>, port <code>5521</code>, and SID <code>orcl</code>.</p>
</li>
<li>
<p>Establishes this connection as the default connection for the SQLJ statements. Although each JDBC statement must explicitly specify a connection object, a SQLJ statement can either implicitly use a default connection or optionally specify a different connection.</p>
</li>
</ol>
</li>
<li>
<p>Process a SQL statement. The following is accomplished:</p>
<ol>
<li>
<p>Insert a row into the <code>employees</code> table:</p>
<pre>#sql {INSERT INTO employees (first_name, employee_id, salary) VALUES (&#39;SMITH&#39;, 32, 20000)};
</pre></li>
<li>
<p>Instantiate and populate the iterator:</p>
<pre>MyIter iter;
#sql iter={SELECT first_name, employee_id, salary FROM employees};
</pre></li>
</ol>
</li>
<li>
<p>Access the data that was populated within the iterator.</p>
<pre>while (iter.next())
{
  System.out.println(iter.first_name()+&#34; &#34;+iter.employee_id()+&#34; &#34;+iter.salary());
}
</pre>
<p>The <code>next()</code> method is common to all iterators and plays the same role as the <code>next()</code> method of a JDBC result set, returning <code>true</code> and moving to the next row of data, if any rows remain. You can access the data in each row by calling iterator accessor methods whose names match the column names. This is a characteristic of all named iterators. In this example, you access the data using the methods <code>first_name()</code>, <code>employee_id()</code>, and <code>salary()</code>.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="CACEEHEH"></a>
<div id="JJDEV13176" class="sect3">
<h4 class="sect3">SQLJ Strong Typing Paradigm</h4>
<p>SQLJ uses strong typing, such as iterators, instead of result sets. This enables the SQL instructions to be checked against the database during translation. For example, SQLJ can connect to a database and check your iterators against the database tables that will be queried. The translator will verify that they match, enabling you to catch SQL errors during translation that would otherwise not be caught until a user runs your application. Furthermore, if changes are subsequently made to the schema, then you can determine if these changes affect the application by rerunning the translator.</p>
</div>
<!-- class="sect3" -->
<a id="CACCGCCG"></a>
<div id="JJDEV13177" class="sect3">
<h4 class="sect3">Translating a SQLJ Program</h4>
<p>Integrated development environments (IDEs), such as Oracle JDeveloper, can translate, compile, and customize your SQLJ program as you build it. Oracle JDeveloper is a Microsoft Windows-based visual development environment for Java programming. If you are not using an IDE, then use the front-end SQLJ utility, <code>sqlj</code>. You can run it as follows:</p>
<pre>%sqlj MyExample.sqlj
</pre>
<p>The SQLJ translator checks the syntax and semantics of your SQL operations. You can enable online checking to check your operations against the database. If you choose to do this, then you must specify an example database schema in your translator option settings. It is not necessary for the schema to have data identical to the one that the program will eventually run against. However, the tables must have columns with corresponding names and data types. Use the user option to enable online checking and specify the user name, password, and URL of your schema, as in the following example:</p>
<pre>%sqlj -user=HR@jdbc:oracle:thin:@localhost:5521:orcl MyExample.sqlj
Password: <span class="italic">password</span>
</pre></div>
<!-- class="sect3" -->
<a id="CACFGHJJ"></a>
<div id="JJDEV13178" class="sect3">
<h4 class="sect3">Running a SQLJ Program in the Server</h4>
<p>Many SQLJ applications run on a client. However, SQLJ offers an advantage in programming stored procedures, which are usually SQL-intensive, to run on the server.</p>
<p>There is almost no difference between writing a client-side SQLJ program and a server-side SQLJ program. The SQLJ run-time packages are automatically available on the server. However, you must consider the following:</p>
<ul>
<li>
<p>There are no explicit database connections for code running on the server. There is only a single implicit connection. You do not need the usual connection code. If you are porting an existing client-side application, then you do not have to remove the connection code, because it will be ignored.</p>
</li>
<li>
<p>The JDBC server-side internal driver does not support auto-commit functionality. Use SQLJ syntax for manual commits and rollbacks of your transactions.</p>
</li>
<li>
<p>On the server, the default output device is a trace file, not the user screen. This is, typically, an issue only for development, because you would not write to <code>System.out</code> in a deployed server application.</p>
</li>
</ul>
<p>To run a SQLJ program on the server, presuming you developed the code on a client, you have two options:</p>
<ul>
<li>
<p>Translate your SQLJ source code on the client and load the individual components, such as the Java classes and resources, on the server. In this case, it is easy to bundle them into a <code>.jar</code> file first and then load them on the server.</p>
</li>
<li>
<p>Load your SQLJ source code on the server for the embedded translator to translate.</p>
</li>
</ul>
<p>In either case, use the <code>loadjava</code> tool to load the file or files to the server.</p>
</div>
<!-- class="sect3" -->
<a id="CACIJCDI"></a>
<div id="JJDEV13179" class="sect3">
<h4 class="sect3">Converting a Client Application to Run on the Server</h4>
<p>To convert an existing SQLJ client-side application to run on the server, after the application has already been translated on the client, perform the following steps:</p>
<ol>
<li>
<p>Create a <code>.jar</code> file for your application components.</p>
</li>
<li>
<p>Use the <code>loadjava</code> tool to load the <code>.jar</code> file on the server.</p>
</li>
<li>
<p>Create a SQL wrapper in the server for your application. For example, to run the preceding <code>MyExample</code> application on the server, run the following statement:</p>
<pre>CREATE OR REPLACE PROCEDURE sqlj_myexample AS LANGUAGE JAVA NAME `MyExample.main(java.lang.String[])&#39;;
</pre></li>
</ol>
<p>You can then run <code>sqlj_myexample</code>, similar to any other stored procedure.</p>
</div>
<!-- class="sect3" -->
<a id="CACBBDJD"></a>
<div id="JJDEV13180" class="sect3">
<h4 class="sect3">Interacting with PL/SQL</h4>
<p>All Oracle JDBC drivers communicate seamlessly with Oracle SQL and PL/SQL, and it is important to note that SQLJ interoperates with PL/SQL. You can start using SQLJ without having to rewrite any PL/SQL stored procedures. Oracle SQLJ includes syntax for calling PL/SQL stored procedures and also lets you embed anonymous PL/SQL blocks in SQLJ statements.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDJHBGH"></a>
<div id="JJDEV03140" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using Command-Line Interface</h3>
<p>The command-line interface to Oracle JVM is analogous to using the JDK or JRE shell commands. You can:</p>
<ul>
<li>
<p>Use the standard <code>-classpath</code> syntax to indicate where to find the classes to load</p>
</li>
<li>
<p>Set the system properties by using the standard <code>-D</code> syntax</p>
</li>
</ul>
<p>The interface is a PL/SQL function that takes a string (<code>VARCHAR2</code>) argument, parses it as a command-line input and if it is properly formed, runs the indicated Java method in Oracle JVM. To do this, PL/SQL package <code>DBMS_JAVA</code> provides the following functions:</p>
<ul>
<li>
<p><a href="#CHDBJEFD">runjava</a></p>
</li>
<li>
<p><a href="#CHDCFCGH">runjava_in_current_session</a></p>
</li>
</ul>
<p class="subhead2"><a id="CHDBJEFD"></a><a id="JJDEV13181"></a>runjava</p>
<p>This function takes the Java command line as its only argument and runs it in Oracle JVM. The return value is null on successful completion, otherwise an error message. The format of the command line is the same as that taken by the JDK shell command, that is:</p>
<pre>[option switches] name_of_class_to_execute [arg1 arg2 ... argn]
</pre>
<p>You can use the option switches <code>-classpath, -D, -Xbootclasspath,</code> and <code>-jar.</code> This function differs from the <code>runjava_in_current_session</code> function in that it clears any Java state remaining from previous use of Java in the session, prior to running the current command. This is necessary, in particular, to guarantee that static variable values derived at class initialization time from <code>-classpath</code> and <code>-D</code> arguments reflect the values of those switches in the current command line.</p>
<pre>FUNCTION runjava(cmdline VARCHAR2) RETURN VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDCFCGH"></a><a id="JJDEV13182"></a>runjava_in_current_session</p>
<p>This function is the same as the <code>runjava</code> function, except that it does not clear Java state remaining from previous use of Java in the session, prior to executing the current command line.</p>
<pre>FUNCTION runjava_in_current_session(cmdline VARCHAR2) RETURN VARCHAR2;
</pre>
<p class="subhead2"><a id="JJDEV13183"></a>Syntax</p>
<p>The syntax of the command line is of the following form:</p>
<pre>[-options] classname [arguments...]
[-options] -jar jarfile [arguments...]
</pre>
<p class="subhead2"><a id="JJDEV13184"></a>Options</p>
<pre>-classpath
-D
-Xbootclasspath
-Xbootclasspath/a
-Xbootclasspath/p
-cp
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The effect of the first form is to run the main method of the class identified by classname with the arguments. The effect of the second form is to run the main method of the class identified by the <code>Main-Class</code> attribute in the manifest of the JAR file identified by JAR. This is analogous to how the JDK/JRE interprets this syntax.</div>
<p class="subhead2"><a id="JJDEV13185"></a>Argument Summary</p>
<p><a href="#CACBBFHC">Table 3-1</a> summarizes the command-line arguments.</p>
<div id="JJDEV13186" class="tblformal">
<p class="titleintable"><a id="sthref344"></a><a id="CACBBFHC"></a>Table 3-1 Command Line Argument Summary</p>
<table class="cellalignment4009" title="Command Line Argument Summary" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t9">Argument</th>
<th class="cellalignment4003" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t9" headers="r1c1-t9">
<p>classpath</p>
</td>
<td class="cellalignment4004" headers="r2c1-t9 r1c2-t9">
<p>Accepts a colon (:) separated (semicolon-separated on Windows systems) list of directories, JAR archives, and ZIP archives to search for class files. In general, the value of <code>-classpath</code> or similar arguments refer to file system locations as they would in a standard Java runtime. You also have an extension to this syntax to allow for terms that refer to database resident Java objects and sets of bytes. Refer to <a href="appendixb.htm#BGBBBJAE">Appendix B, &#34;Classpath Extensions and User Classloaded Metadata&#34;</a> for more information about <code>-classpath</code> extensions.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t9" headers="r1c1-t9">
<p>D</p>
</td>
<td class="cellalignment4004" headers="r3c1-t9 r1c2-t9">
<p>Establishes values for system properties when there is no existing Java session state. The default behavior of the command-line interface, that is, the <code>runjava</code> function, is to terminate any existing Java session prior to running the new command. On the other hand, the alternative function, <code>runjava_in_current_session</code> leaves any existing session in place. So, values established with the <code>-D</code> option always take effect when <code>runjava</code> function is used, but the values may not take effect when <code>runjava_in_current_session</code> function is used.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t9" headers="r1c1-t9">
<p>Xbootclasspath</p>
</td>
<td class="cellalignment4004" headers="r4c1-t9 r1c2-t9">
<p>Accepts a colon (:) separated (semicolon-separated on Windows systems) list of directories, JAR archives, and ZIP archives. This option is used to set search path for bootstrap classes and resources.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r5c1-t9" headers="r1c1-t9">
<p><code>Xbootclasspath/a</code></p>
</td>
<td class="cellalignment4004" headers="r5c1-t9 r1c2-t9">
<p>Accepts a colon (:) separated (semicolon-separated on Windows systems) list of directories, JAR archives, and ZIP archives. This is appended to the end of bootstrap class path.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r6c1-t9" headers="r1c1-t9">
<p><code>Xbootclasspath/p</code></p>
</td>
<td class="cellalignment4004" headers="r6c1-t9 r1c2-t9">
<p>Accepts a colon (:) separated (semicolon-separated on Windows systems) list of directories, JAR archives, and ZIP archives. This is added in front of bootstrap class path.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r7c1-t9" headers="r1c1-t9">
<p><code>cp</code></p>
</td>
<td class="cellalignment4004" headers="r7c1-t9 r1c2-t9">
<p>Acts as a synonym of <code>-classpath</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
System classes created by <code>create java system</code> are always used before using any file or folder that are found using the <code>-Xbootclasspath</code> option.</div>
</div>
<!-- class="sect2" -->
<a id="CBBEJGIH"></a>
<div id="JJDEV13187" class="sect2">
<h3 class="sect2">Using the <a id="sthref345"></a>Client-Side Stub</h3>
<p>Oracle Database 10g introduced the client-side stub, formerly known as native Java interface, for calls to server-side Java code. It is a simplified application integration. Client-side and middle-tier Java applications can directly call Java in the database without defining a PL/SQL wrapper. The client-side stub uses the server-side Java class reflection capability.</p>
<p>In previous releases, calling Java stored procedures and functions from a database client required Java Database Connectivity (JDBC) calls to the associated PL/SQL wrappers. Each wrapper had to be manually published with a SQL signature and a Java implementation. This had the following disadvantages:</p>
<ul>
<li>
<p>The signatures permitted only Java types that had direct SQL equivalents</p>
</li>
<li>
<p>Exceptions issued in Java were not properly returned</p>
</li>
</ul>
<p>The JPublisher <code>-java</code> option provides functionality to overcome these disadvantages. To remedy the deficiencies of JDBC calls to associated PL/SQL wrappers, the <code>-java</code> option uses an API for direct invocation of <code>static</code> Java methods. This functionality is also useful for Web services.</p>
<p>The functionality of the <code>-java</code> option mirrors that of the <code>-sql</code> option, creating a client-side Java stub class to access a server-side Java class, as opposed to creating a client-side Java class to access a server-side SQL object or PL/SQL package. The client-side stub class uses JPublisher code that mirrors the server-side class and includes the following features:</p>
<ul>
<li>
<p>Methods corresponding to the <code>public</code> <code>static</code> methods of the server class</p>
</li>
<li>
<p>Two constructors, one that takes a JDBC connection and one that takes the JPublisher default connection context instance</p>
</li>
</ul>
<p>At run time, the stub class is instantiated with a JDBC connection. Calls to the methods of the stub class result in calls to the corresponding methods of the server-side class. Any Java types used in these published methods must be primitive or serializable.</p>
<p><a href="#BABCIIHB">Figure 3-1</a> demonstrates a client-side stub API for direct invocation of <code>static</code> server-side Java methods. JPublisher transparently takes care of stub generation.</p>
<div id="JJDEV13188" class="figure">
<p class="titleinfigure"><a id="BABCIIHB"></a>Figure 3-1 Client-Side Stub Interface</p>
<img width="662" height="310" src="img/webservices_calling_db.gif" alt="Description of Figure 3-1 follows"/><br/>
<a id="sthref346" href="img_text/webservices_calling_db.htm">Description of &#34;Figure 3-1 Client-Side Stub Interface&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>You can use the <code>-java</code> option to publish a server-side Java class, as follows:</p>
<pre>-java=className
</pre>
<p>Consider the <code>oracle.sqlj.checker.JdbcVersion</code> server-side Java class, with the following APIs:</p>
<pre>public class oracle.sqlj.checker.JdbcVersion
{
 ...
 public java.lang.String toString();
 public static java.lang.String to_string();
 ...
}
</pre>
<p>As an example, assume that you want to call the following method on the server:</p>
<pre>public String oracle.sqlj.checker.JdbcVersion.to_string();
</pre>
<p>Use the following command to publish <code>JdbcVersion</code> for client-side invocation, using JPublisher:</p>
<pre>% jpub -sql=HR -java=oracle.sqlj.checker.JdbcVersion:JdbcVersion Client
Enter HR password: <span class="italic">password</span>
</pre>
<p>This command generates the client-side Java class, <code>JdbcVersionClient</code>, which contains the following APIs:</p>
<pre>public class JdbcVersionClient
{
 ...
 public java.lang.String toString(long _handle);
 public java.lang.String to_string();
 ...
}
</pre>
<p>All static methods are mapped to instance methods in the client-side code. A instance method in the server-side class, <code>toString()</code> for example, is mapped to a method with an extra handle. A handle represents an instance of <code>oracle.sqlj.checker.JdbcVersion</code> in the server. The handle is used to call the instance method on the server-side.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJPUB24000" href="../JJPUB/usejpub.htm#JJPUB24000"><span class="italic">Oracle Database JPublisher User&#39;s Guide</span></a></div>
<p class="subhead2"><a id="CHDGFAEE"></a><a id="JJDEV13189"></a>Using the Default Service Feature</p>
<p>Starting from Oracle Database 11<span class="italic">g</span> release 1 (11.1), Oracle Database client provides a new default connection feature. If you install Oracle Database client, then you need not specify all the details of the database server in the connection URL. Under certain conditions, Oracle Database connection adapter requires only the host name of the computer where the database is installed.</p>
<p>For example, in the JDBC connection URL syntax, that is:</p>
<pre>jdbc:oracle:driver_type:[username/password]@[//]host_name[:port][:ORCL]
</pre>
<p>,the following have become optional:</p>
<ul>
<li>
<p><code>//</code> is optional.</p>
</li>
<li>
<p><code>:port</code> is optional.</p>
<p>You must specify a port only if the default Oracle Net listener port (1521) is not used.</p>
</li>
<li>
<p><code>:ORCL</code> or the service name is optional.</p>
<p>The connection adapter for Oracle Database Client connects to the default service on the host. On the host, this is set to <code>ORCL</code> in the <code>listener.ora</code> file.</p>
</li>
</ul>
<p class="subhead2"><a id="JJDEV13190"></a>Testing the Default Service with a Basic Configuration</p>
<p>The following code snippet shows a basic configuration of the <code>listener.ora</code> file, where the default service is defined.</p>
<div id="JJDEV13191" class="example">
<p class="titleinexample"><a id="sthref347"></a>Example 3-1 Basic Configuration of listener.ora with the Default Service Defined</p>
<pre>MYLISTENER = (ADDRESS_LIST=(ADDRESS=(PROTOCOL=tcp)(HOST=testserver1)(PORT=1521)))
DEFAULT_SERVICE_MYLISTENER=dbjf.app.myserver.com
SID_LIST_MYLISTENER = (SID_LIST=(SID_DESC=(SID_NAME=dbjf)
(GLOBAL_DBNAME=dbjf.app.myserver.com)(ORACLE_HOME=/test/oracle))
)
</pre></div>
<!-- class="example" -->
<p>After defining the <code>listener.ora</code> file, restart the listener with the following command:</p>
<pre>lsnrctl start mylistener
</pre>
<p>Now, any of the following URLs should work with this configuration of the <code>listener.ora</code> file:</p>
<ul>
<li>
<p><code>jdbc:oracle:thin:@//testserver1.myserver.com.com</code></p>
</li>
<li>
<p><code>jdbc:oracle:thin:@//testserver1.myserver.com:1521</code></p>
</li>
<li>
<p><code>jdbc:oracle:thin:@testserver1.myserver.com</code></p>
</li>
<li>
<p><code>jdbc:oracle:thin:@testserver1.myserver.com:1521</code></p>
</li>
<li>
<p><code>jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=testserver1.myserver.com)(PORT=1521)))</code></p>
</li>
<li>
<p><code>jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=testserver1.myserver.com)))</code></p>
</li>
<li>
<p><code>jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=testserver1.myserver.com)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=)))</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Default service is a feature since Oracle Database 11<span class="italic">g</span> Release 1 (11.1). If you use any version prior to Oracle Database 11<span class="italic">g</span> Client to connect to the database, then you must specify the <code>SID</code>.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CACFDCIH"></a>
<div id="JJDEV13193" class="sect1">
<h2 class="sect1">How To <a id="sthref348"></a>Tell You Are Running on the Server</h2>
<p>You may want to write Java code that runs in a certain way on the server and in another way on the client. In general, Oracle does not recommend this. In fact, JDBC and SQLJ enable you to write portable code that avoids this problem, even though the drivers used in the server and client are different.</p>
<p><a id="sthref349"></a>If you want to determine whether your code is running on the server, then use the <code>System.<a id="sthref350"></a>getProperty()</code> method, as follows:</p>
<pre>System.getProperty (&#34;oracle.jserver.version&#34;)
</pre>
<p>The getProperty() method returns the following:</p>
<ul>
<li>
<p>A <code>String</code> that represents Oracle Database release, if running on the server</p>
</li>
<li>
<p><code>null</code>, if running on the client</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CACIIEDH"></a>
<div id="JJDEV13194" class="sect1">
<h2 class="sect1"><a id="sthref351"></a><a id="sthref352"></a>Redirecting Output on the Server</h2>
<p>You can pass Java output to SQL statements to provide more extensive control over the destination of output from Oracle JVM. The PL/SQL package <code>DBMS_JAVA</code> has been enhanced by adding the following new functions, which provide extended functionality to what was previously available only with the <code>DBMS_JAVA.SET_OUTPUT</code> procedure:</p>
<ul>
<li>
<p><a href="#CHDIEICB">set_output_to_sql</a></p>
</li>
<li>
<p><a href="#CHDGGBAC">remove_output_to_sql</a></p>
</li>
<li>
<p><a href="#CHDDJEIF">enable_output_to_sql</a></p>
</li>
<li>
<p><a href="#CHDFEEBE">disable_output_to_sql</a></p>
</li>
<li>
<p><a href="#CHDFGBBJ">query_output_to_sql</a></p>
</li>
</ul>
<p class="subhead2"><a id="CHDIEICB"></a><a id="JJDEV13195"></a>set_output_to_sql</p>
<p><code>set_output_to_sql</code> defines a named output specification that constitutes an instruction for executing a SQL statement, whenever output to the default <code>System.out</code> and <code>System.err</code> streams occurs. The specification is defined either for the duration of the current session, or till the <code>remove_output_to_sql</code> function is called with its ID. The SQL actions prescribed by the specification occur whenever there is Java output. This can be stopped and started by calling the <code>disable_output_to_sql</code> and <code>enable_output_to_sql</code> functions respectively. The return value of this function is null on success, otherwise an error message.</p>
<pre>FUNCTION set_output_to_sql (id VARCHAR2,
stmt VARCHAR2,
bindings VARCHAR2,
no_newline_stmt VARCHAR2 default null,
no_newline_bindings VARCHAR2 default null,
newline_only_stmt VARCHAR2 default null,
newline_only_bindings VARCHAR2 default null,
maximum_line_segment_length NUMBER default 0,
allow_replace NUMBER default 1,
from_stdout NUMBER default 1,
from_stderr NUMBER default 1,
include_newlines NUMBER default 0,
eager NUMBER default 0) return VARCHAR2;
</pre>
<p><a href="#BABBDJHC">Table 3-2</a> describes the arguments the <code>set_output_to_sql</code> function takes.</p>
<div id="JJDEV13196" class="tblformal">
<p class="titleintable"><a id="sthref353"></a><a id="BABBDJHC"></a>Table 3-2 set_output_to_sql Argument Summary</p>
<table class="cellalignment4009" title="set_output_to_sql Argument Summary" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t13">Argument</th>
<th class="cellalignment4003" id="r1c2-t13">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t13" headers="r1c1-t13">
<p>id</p>
</td>
<td class="cellalignment4004" headers="r2c1-t13 r1c2-t13">
<p>The name of the specification. Multiple specifications may exist in the same session, but each must have a distinct ID. The ID is used to identify the specification in the functions <code>remove_output_to_sql, enable_output_to_sql, disable_output_to_sql,</code> and <code>query_output_to_sql.</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t13" headers="r1c1-t13">
<p>stmt</p>
</td>
<td class="cellalignment4004" headers="r3c1-t13 r1c2-t13">
<p>The default SQL statement to execute when Java output occurs.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t13" headers="r1c1-t13">
<p>bindings</p>
</td>
<td class="cellalignment4004" headers="r4c1-t13 r1c2-t13">
<p>A string containing tokens from the set <span class="italic">ID, TEXT, LENGTH, LINENO, SEGNO, NL,</span> and <span class="italic">ERROUT.</span> This string defines how the SQL statement <code>stmt</code> is bound. The position of a token in the bindings string corresponds to the bind position in the SQL statement. The meanings of the tokens are:</p>
<ul>
<li>
<p>ID is the ID of the specification. It is bound as a VARCHAR2.</p>
</li>
<li>
<p>TEXT is the text being output. It is bound as a VARCHAR2.</p>
</li>
<li>
<p>LENGTH is the length of the text. It is bound as a NUMBER.</p>
</li>
<li>
<p>LINENO is the line number since the beginning of session output. It is bound as a NUMBER.</p>
</li>
<li>
<p>SEGNO is the segment number within a line that is being output in more than one piece. It is bound as a NUMBER.</p>
</li>
<li>
<p>NL is a boolean indicating whether the text is to be regarded as newline terminated. It is bound as a NUMBER. The newline may or may not actually be included in the text, depending on the value of the <code>include_newlines</code> argument.</p>
</li>
<li>
<p>ERROUT is a boolean indicating whether the output came from <code>System.out</code> or <code>System.err.</code> It is bound as a NUMBER. The value is 0, if the output came from <code>System.out.</code></p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r5c1-t13" headers="r1c1-t13">
<p>no_newline_stmt</p>
</td>
<td class="cellalignment4004" headers="r5c1-t13 r1c2-t13">
<p>An optional alternate SQL statement to execute, when the output is not newline terminated.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r6c1-t13" headers="r1c1-t13">
<p>no_newline_bindings</p>
</td>
<td class="cellalignment4004" headers="r6c1-t13 r1c2-t13">
<p>A string with the same syntax as for the bindings argument discussed previously, describing how the <code>no_newline_stmt</code> is bound.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r7c1-t13" headers="r1c1-t13">
<p>newline_only_stmt</p>
</td>
<td class="cellalignment4004" headers="r7c1-t13 r1c2-t13">
<p>An optional alternate SQL statement to execute when the output is a single newline.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r8c1-t13" headers="r1c1-t13">
<p>newline_only_bindings</p>
</td>
<td class="cellalignment4004" headers="r8c1-t13 r1c2-t13">
<p>A string with the same syntax as for the bindings argument discussed previously, describing how the <code>newline_only_stmt</code> is bound.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r9c1-t13" headers="r1c1-t13">
<p>maximum_line_segment_length</p>
</td>
<td class="cellalignment4004" headers="r9c1-t13 r1c2-t13">
<p>The maximum number of characters that is bound in a given execution of the SQL statement. Longer output sequences are broken up into separate calls with distinct SEGNO values. A value of 0 means <code>no maximum.</code></p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r10c1-t13" headers="r1c1-t13">
<p>allow_replace</p>
</td>
<td class="cellalignment4004" headers="r10c1-t13 r1c2-t13">
<p>Controls behavior when a previously defined specification with the same ID exists. A value of 1 means replacing the old specification. 0 means returning an error message without modifying the old specification.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r11c1-t13" headers="r1c1-t13">
<p>from_stdout</p>
</td>
<td class="cellalignment4004" headers="r11c1-t13 r1c2-t13">
<p>Controls whether output from <code>System.out</code> causes execution of the SQL statement prescribed by the specification. A value of 0 means that if the output came from <code>System.out,</code> then the statement is not executed, even if the specification is otherwise enabled.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r12c1-t13" headers="r1c1-t13">
<p>from_stderr</p>
</td>
<td class="cellalignment4004" headers="r12c1-t13 r1c2-t13">
<p>Controls whether output from <code>System.err</code> causes execution of the SQL statement prescribed by the specification. A value of 0 means that if the output came from <code>System.err,</code> then the statement is not executed, even if the specification is otherwise enabled.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r13c1-t13" headers="r1c1-t13">
<p>include_newlines</p>
</td>
<td class="cellalignment4004" headers="r13c1-t13 r1c2-t13">
<p>Controls whether newline characters are left in the output when they are bound to text. A value of 0 means new lines are not included. But the presence of the newline is still indicated by the NL binding and the use of <code>no_newline_stmt</code>.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r14c1-t13" headers="r1c1-t13">
<p>eager</p>
</td>
<td class="cellalignment4004" headers="r14c1-t13 r1c2-t13">
<p>Controls whether output not terminated by a newline causes execution of the SQL statement every time it is received, or accumulates such output until a newline is received. A value of 0 means that unterminated output is accumulated.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="CHDGGBAC"></a><a id="JJDEV13197"></a>remove_output_to_sql</p>
<p><code>remove_output_to_sql</code> deletes a specification created by <code>set_output_to_sql.</code> If no such specification exists, an error message is returned.</p>
<pre>FUNCTION remove_output_to_sql (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDDJEIF"></a><a id="JJDEV13198"></a>enable_output_to_sql</p>
<p><code>enable_output_to_sql</code> reenables a specification created by <code>set_output_to_sql</code> and subsequently disabled by <code>disable_output_to_sql.</code> If no such specification exists, an error message is returned. If the specification is not currently disabled, there is no change.</p>
<pre>FUNCTION enable_output_to_sql (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDFEEBE"></a><a id="JJDEV13199"></a>disable_output_to_sql</p>
<p><code>disable_output_to_sql</code> disables a specification created by <code>set_output_to_sql.</code> You can enable the specification by calling <code>enable_output_to_sql</code>. While disabled, the SQL statement prescribed by the specification is not executed. If no such specification exists, an error message is returned. If the specification is already disabled, there is no change.</p>
<pre>FUNCTION disable_output_to_sql (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDFGBBJ"></a><a id="JJDEV13200"></a>query_output_to_sql</p>
<p><code>query_output_to_sql</code> returns a message describing a specification created by <code>set_output_to_sql.</code> If no such specification exists, then an error message is returned. Passing <code>null</code> to this function causes all existing specifications to be displayed.</p>
<pre>FUNCTION query_output_to_sql (id VARCHAR2) return VARCHAR2;
</pre>
<p>Another way of achieving control over the destination of output from Oracle JVM is to pass your Java output to an autonomous Java session. This provides a very general mechanism for propagating the output to various kinds of targets, such as disk files, sockets, and URLS. But, you must keep in mind that the Java session that processes the output is logically distinct from the main session, so that there are no other, unwanted interactions between them. To do this, PL/SQL package <code>DBMS_JAVA</code> provides the following functions:</p>
<ul>
<li>
<p><a href="#CHDCEAAI">set_output_to_java</a></p>
</li>
<li>
<p><a href="#CHDFDAJF">remove_output_to_java</a></p>
</li>
<li>
<p><a href="#CHDCBDGE">enable_output_to_java</a></p>
</li>
<li>
<p><a href="#CHDHCJEC">disable_output_to_java</a></p>
</li>
<li>
<p><a href="#CHDCIGJB">query_output_to_java</a></p>
</li>
<li>
<p><a href="#CHDIFCAA">set_output_to_file</a></p>
</li>
<li>
<p><a href="#CHDCEAFA">remove_output_to_file</a></p>
</li>
<li>
<p><a href="#CHDBDHJD">enable_output_to_file</a></p>
</li>
<li>
<p><a href="#CHDHHEAE">disable_output_to_file</a></p>
</li>
<li>
<p><a href="#CHDGHJAB">query_output_to_file</a></p>
</li>
</ul>
<p class="subhead2"><a id="CHDCEAAI"></a><a id="JJDEV13201"></a>set_output_to_java</p>
<p><code>set_output_to_java</code> defines a named output specification that gives an instruction for executing a Java method whenever output to the default <code>System.out</code> and <code>System.err</code> streams occurs. The Java method prescribed by the specification is executed in a separate VM context with separate Java session state from the rest of the session.</p>
<pre>FUNCTION set_output_to_java (id VARCHAR2,
class_name VARCHAR2,
class_schema VARCHAR2,
method VARCHAR2,
bindings VARCHAR2,
no_newline_method VARCHAR2 default null,
no_newline_bindings VARCHAR2 default null,
newline_only_method VARCHAR2 default null,
newline_only_bindings VARCHAR2 default null,
maximum_line_segment_length NUMBER default 0,
allow_replace NUMBER default 1,
from_stdout NUMBER default 1,
from_stderr NUMBER default 1,
include_newlines NUMBER default 0,
eager NUMBER default 0,
initialization_statement VARCHAR2 default null,
finalization_statement VARCHAR2 default null)return VARCHAR2;
</pre>
<p><a href="#BABHCEAE">Table 3-3</a> describes the arguments the <code>set_output_to_java</code> method takes.</p>
<div id="JJDEV13202" class="tblformal">
<p class="titleintable"><a id="sthref354"></a><a id="BABHCEAE"></a>Table 3-3 set_output_to_java Argument Summary</p>
<table class="cellalignment4009" title="set_output_to_java Argument Summary" summary="table" dir="ltr">
<thead>
<tr class="cellalignment3996">
<th class="cellalignment4003" id="r1c1-t14">Argument</th>
<th class="cellalignment4003" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r2c1-t14" headers="r1c1-t14">
<p>class_name</p>
</td>
<td class="cellalignment4004" headers="r2c1-t14 r1c2-t14">
<p>The name of the class defining one or more methods.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r3c1-t14" headers="r1c1-t14">
<p>class_schema</p>
</td>
<td class="cellalignment4004" headers="r3c1-t14 r1c2-t14">
<p>The schema in which the class is defined. A null value means the class is defined in the current schema, or PUBLIC.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r4c1-t14" headers="r1c1-t14">
<p>method</p>
</td>
<td class="cellalignment4004" headers="r4c1-t14 r1c2-t14">
<p>The name of the method.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r5c1-t14" headers="r1c1-t14">
<p>bindings</p>
</td>
<td class="cellalignment4004" headers="r5c1-t14 r1c2-t14">
<p>A string that defines how the arguments to the method are bound. This is a string of tokens with the same syntax as <code>set_output_to_sql.</code> The position of a token in the string determines the position of the argument it describes. All arguments must be of type INT, except for those corresponding to the tokens ID or TEXT, which must be of type <code>java.lang.String</code>.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r6c1-t14" headers="r1c1-t14">
<p>no_newline_method</p>
</td>
<td class="cellalignment4004" headers="r6c1-t14 r1c2-t14">
<p>An optional alternate method to execute when the output is not newline terminated.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r7c1-t14" headers="r1c1-t14">
<p>newline_only_method</p>
</td>
<td class="cellalignment4004" headers="r7c1-t14 r1c2-t14">
<p>An optional alternate method to execute when the output is a single newline.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r8c1-t14" headers="r1c1-t14">
<p>initialization_statement</p>
</td>
<td class="cellalignment4004" headers="r8c1-t14 r1c2-t14">
<p>An optional SQL statement that is executed once per Java session prior to the first time the methods that receive output are executed. This statement is executed in same Java VM context as the output methods are executed. Typically such a statement is used to run a Java stored procedure that initializes conditions in the separate VM context so that the methods that receive output can function as intended. For example, such a procedure might open a stream that the output methods write to.</p>
</td>
</tr>
<tr class="cellalignment3996">
<td class="cellalignment4004" id="r9c1-t14" headers="r1c1-t14">
<p>finalization_statement</p>
</td>
<td class="cellalignment4004" headers="r9c1-t14 r1c2-t14">
<p>An optional SQL statement that is executed once when the output specification is about to be removed or the session is ending. Like the <code>initialization_statement,</code> this runs in the same JVM context as the methods that receive output. It runs only if the initialization method has run, or if there is no initialization method.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="CHDFDAJF"></a><a id="JJDEV13203"></a>remove_output_to_java</p>
<p><code>remove_output_to_java</code> deletes a specification created by <code>set_output_to_java</code>. If no such specification exists, an error message is returned</p>
<pre>FUNCTION remove_output_to_java (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDCBDGE"></a><a id="JJDEV13204"></a>enable_output_to_java</p>
<p><code>enable_output_to_java</code> reenables a specification created by <code>set_output_to_java</code> and subsequently disabled by <code>disable_output_to_java.</code> If no such specification exists, an error message is returned. If the specification is not currently disabled, there is no change.</p>
<pre>FUNCTION enable_output_to_java (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDHCJEC"></a><a id="JJDEV13205"></a>disable_output_to_java</p>
<p><code>disable_output_to_java</code> disables a specification created by <code>set_output_to_java</code>. The specification may be reenabled by <code>enable_output_to_java.</code> While disabled, the SQL statement prescribed by the specification is not executed. If no such specification exists, an error message is returned. If the specification is already disabled, there is no change.</p>
<pre>FUNCTION disable_output_to_java (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDCIGJB"></a><a id="JJDEV13206"></a>query_output_to_java</p>
<p><code>query_output_to_java</code> returns a message describing a specification created by <code>set_output_to_java.</code> If no such specification exists, an error message is returned. Passing <code>null</code> to this function causes all existing specifications to be displayed.</p>
<pre>FUNCTION query_output_to_java (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDIFCAA"></a><a id="JJDEV13207"></a>set_output_to_file</p>
<p><code>set_output_to_file</code> defines a named output specification that constitutes an instruction to capture any output sent to the default <code>System.out</code> and <code>System.err</code> streams and append it to a specified file. This is implemented using a special case of <code>set_output_to_java.</code> The argument <code>file_path</code> specifies the path to the file to which to append the output. The arguments <code>allow_replace, from_stdout,</code> and <code>from_stderr</code> are all analogous to the arguments having the same name as in <code>set_output_to_sql.</code></p>
<pre>FUNCTION set_output_to_file (id VARCHAR2,
file_path VARCHAR2,
allow_replace NUMBER default 1,
from_stdout NUMBER default 1,
from_stderr NUMBER default 1) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDCEAFA"></a><a id="JJDEV13208"></a>remove_output_to_file</p>
<p>This function is analogous to <code>remove_output_to_java</code>.</p>
<pre>FUNCTION remove_output_to_file (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDBDHJD"></a><a id="JJDEV13209"></a>enable_output_to_file</p>
<p>This function is analogous to <code>enable_output_to_java.</code></p>
<pre>FUNCTION enable_output_to_file (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDHHEAE"></a><a id="JJDEV13210"></a>disable_output_to_file</p>
<p>This function is analogous to <code>disable_output_to_java.</code></p>
<pre>FUNCTION disable_output_to_file (id VARCHAR2) return VARCHAR2;
</pre>
<p class="subhead2"><a id="CHDGHJAB"></a><a id="JJDEV13211"></a>query_output_to_file</p>
<p>This function is analogous to <code>query_output_to_java.</code></p>
<pre>FUNCTION query_output_to_file (id VARCHAR2) return VARCHAR2;
</pre>
<p>The following <code>DBMS_JAVA</code> functions control whether Java output appears in the <code>.trc</code> file:</p>
<ul>
<li>
<p><code>PROCEDURE enable_output_to_trc;</code></p>
</li>
<li>
<p><code>PROCEDURE disable_output_to_trc;</code></p>
</li>
<li>
<p><code>FUNCTION query_output_to_trc return VARCHAR2;</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prior to 11<span class="italic">g</span> release 1 (11.1), the fact that Java output appeared in the <code>.trc</code> file was not modifiable.</div>
<p class="subhead2"><a id="CHDGIBEF"></a><a id="JJDEV13212"></a>Redirecting the output to SQL*Plus Text Buffer</p>
<p>As in previous releases, you can use the <code>DBMS_JAVA</code> package procedure <code>SET_OUTPUT</code> to redirect output to the SQL*Plus text buffer:</p>
<pre>SQL&gt; SET SERVEROUTPUT ON
SQL&gt; CALL dbms_java.set_output(2000);
</pre>
<p>The minimum and default buffer size is 2,000 bytes and the maximum size is 1,000,000 bytes. In the following example, the buffer size is increased to 5,000 bytes:</p>
<pre>SQL&gt; SET SERVEROUTPUT ON SIZE 5000
SQL&gt; CALL dbms_java.set_output(5000);
</pre>
<p>The output is displayed at the end of the call.</p>
</div>
<!-- class="sect1" -->
<a id="CACEGFCH"></a>
<div id="JJDEV13213" class="sect1">
<h2 class="sect1">Calling Java in the Database Directly</h2>
<p>In releases prior to Oracle Database 10<span class="italic">g</span>, calling Java stored procedures and functions from a database client required JDBC calls to the associated PL/SQL wrappers. Each wrapper had to be manually published with a SQL signature and a Java implementation. This had the following disadvantages:</p>
<ul>
<li>
<p>A separate step was required for publishing the SQL signatures for Java methods.</p>
</li>
<li>
<p>The signatures permitted only Java types with SQL equivalents.</p>
</li>
<li>
<p>Exceptions issued in Java were not properly returned.</p>
</li>
<li>
<p>Only a single method invocation could be performed for each database round trip.</p>
</li>
</ul>
<p>To remedy these deficiencies, a simple API has been implemented since Oracle Database 11<span class="italic">g</span> to directly call <code>static</code> Java stored procedures and functions. This new functionality is useful for general applications, but is particularly useful for Web services.</p>
<p>Classes for the simple API are located in the <code>oracle.jpub.reflect</code> package. Import this package into the client-side code.</p>
<p>The following is the Java interface for the API:</p>
<pre>public class Client
{
  public static String getSignature(Class[]);
  public static Object invoke(Connection, String, String, String, Object[]);
  public static Object invoke(Connection, String, String, Class[], Object[]);
}
</pre>
<p>As an example, consider a call to the following method in the server:</p>
<pre>public String oracle.sqlj.checker.JdbcVersion.to_string();
</pre>
<p>You can call the method, as follows:</p>
<pre>Connection conn = ...;
String serverSqljVersion = (String)
Client.invoke(conn, &#34;oracle.sqlj.checker.JdbcVersion&#34;,&#34;to_string&#34;, new Class[]{}, new Object[]{});
</pre>
<p>The <code>Class[]</code> array is for the method parameter types and the <code>Object[]</code> array is for the parameter values. In this case, because <code>to_string</code> has no parameters, the arrays are empty.</p>
<p>Note the following:</p>
<ul>
<li>
<p>Any serializable type, such as <code>int[]</code> and <code>String[]</code>, can be passed as an argument.</p>
</li>
<li>
<p>As an optimization, parameter values can be represented as <code>String</code>:</p>
<pre>String sig = oracle.jpub.reflect.Client.getSignature(new Class[]{});
...
Client.invoke(conn, &#34;oracle.sqlj.checker.JdbcVersion&#34;, &#34;to_string&#34;,sig, new Object[]{});
</pre></li>
<li>
<p>The semantics of this API are different from the semantics for calling stored procedures or functions through a PL/SQL wrapper, in the following ways:</p>
<ul>
<li>
<p>Arguments cannot be <code>OUT</code> or <code>IN OUT</code>. Returned values must all be part of the function result.</p>
</li>
<li>
<p>Exceptions are properly returned.</p>
</li>
<li>
<p>The method invocation uses invoker&#39;s rights. There is no tuning to obtain the definer&#39;s rights.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3995">
<tr>
<td class="cellalignment4004">
<table class="cellalignment4000">
<tr>
<td class="cellalignment3999"><a href="chtwo.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3999"><a href="chfour.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4006">
<table class="cellalignment3998">
<tr>
<td class="cellalignment3999"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3999"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3999"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3999"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3999"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3999"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>