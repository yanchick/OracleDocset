<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114727"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Writing%20a%20Pro%2AFORTRAN%20Program"></a><title>Writing a Pro*FORTRAN Program</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 726"/>
<meta name="dcterms.created" content="2013-04-08T7:43:56Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*FORTRAN&reg; Supplement to the Oracle Precompilers Guide"/>
<meta name="dcterms.identifier" content="E18411-05"/>
<meta name="dcterms.isVersionOf" content="ZZFOR"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1994, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Prev" href="preface.htm" title="Previous" type="text/html"/>
<link rel="Next" href="ch_two.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E18411-05.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">4/8</span> <!-- End Header -->
<div id="ZZFOR107" class="chapter"><a id="BIHIIFCA"></a>
<h1 class="chapter"><span class="secnum">1</span> Writing a Pro*FORTRAN Program</h1>
<p>This chapter provides basic information for writing a Pro*FORTRAN program:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Pro*Fortran Precompiler is NOT supported in 64 bit Oracle Database installations.
<p>The Pro*Fortran Precompiler is only supported and available in Oracle Database 32 bit Client installations.</p>
</div>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BABEECHH">Programming Guidelines</a></p>
</li>
<li>
<p><a href="#BABCCCGG">Required Declarations and SQL Statements</a></p>
</li>
<li>
<p><a href="#BABBABIB">Host Variable Names</a></p>
</li>
<li>
<p><a href="#BABEIJGE">Scope of Host Variables</a></p>
</li>
<li>
<p><a href="#BABHJCCH">Host Variables</a></p>
</li>
<li>
<p><a href="#BABECBHG">Referencing Host Variables</a></p>
</li>
<li>
<p><a href="#BABCACBI">Indicator Variables</a></p>
</li>
<li>
<p><a href="#BABFGDAH">Host Arrays</a></p>
</li>
<li>
<p><a href="#BABCJDFE">VARCHAR Host Variables</a></p>
</li>
<li>
<p><a href="#BABHCCFD">Handling Character Data</a></p>
</li>
<li>
<p><a href="#BABHACJB">The Oracle Datatypes</a></p>
</li>
<li>
<p><a href="#BABJBHBI">Datatype Conversion</a></p>
</li>
<li>
<p><a href="#BABFBCFA">Datatype Equivalencing</a></p>
</li>
<li>
<p><a href="#BABHJHJE">Embedding PL/SQL</a></p>
</li>
<li>
<p><a href="#BABBIIAH">Declaring a Cursor Variable</a></p>
</li>
<li>
<p><a href="#BABCBBAG">Connecting to Oracle</a></p>
</li>
</ul>
<a id="BABEECHH"></a>
<div id="ZZFOR108" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Programming Guidelines</h2>
<p>This section deals with embedded SQL syntax, coding conventions, and FORTRAN-specific features and restrictions. Topics are arranged alphabetically.</p>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref4"></a>
<h3 class="sect2">32 bit vs 64 bit</h3>
<p>The Pro*Fortran Precompiler is NOT supported in 64 bit Oracle environments.</p>
<p>The Pro*Fortran Precompiler is only supported and available in Oracle Database 32 bit Client installations.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR109" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref5"></a>
<h3 class="sect2">Case-sensitivity</h3>
<p>Though the standard FORTRAN character set excludes lowercase alpha characters, many compilers allow them in identifiers, comments, and quoted literals.</p>
<p>The Pro*FORTRAN Precompiler is not case-sensitive; however, some compilers are. If your compiler is case-sensitive, you must declare and reference variables in the same uppercase/lowercase format. Check your FORTRAN compiler user&#39;s guide.</p>
<p>You must code EXEC SQL and EXEC ORACLE statements in columns 7 through 72 (columns 73 through 80 are ignored). The other columns are used for the following purposes:</p>
<ul>
<li>
<p>Column 1 can indicate a comment line or can be part of an optional statement label.</p>
</li>
<li>
<p>Columns 2 through 5 can contain an optional statement label.</p>
</li>
<li>
<p>Column 6 indicates continuation lines.</p>
</li>
</ul>
<p>On some systems, <span class="italic">terminal format</span> is supported; that is, entry is not restricted to certain columns. In this manual, the program fragments and sample programs are in ANSI format (FORMAT=ANSI).</p>
<p>No more than one statement can appear on a single line.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR110" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref6"></a>
<h3 class="sect2">Comments</h3>
<p>You can place FORTRAN comment lines within SQL statements. FORTRAN comment lines start with the letter C or an asterisk (*) in column 1. You can place ANSI SQL-style comments (- - ...) in SQL statements at the end of a line, and you can also place C-style comments (/* ... */) in SQL statements.</p>
<p>The following example shows all three styles of comments:</p>
<pre>EXEC SQL SELECT ENAME, SAL
C Assign column values to host variables.
 1 INTO :ENAM, :ESAL -- output host variables
 2 FROM EMP
 3 /* Use input host variable in
 4 search condition */
 5 WHERE DEPTNO = :DNUM
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot nest comments. Blank lines are treated as comments, but are <span class="italic">not</span> allowed within a continued statement.</div>
</div>
<!-- class="sect2" -->
<div id="ZZFOR111" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref7"></a>
<h3 class="sect2">Continuation Lines</h3>
<p>You can continue SQL statements from one line to the next, according to the rules of FORTRAN. To code a continuation line, place a nonzero, non-blank character in column 6. In this manual, digits are used as continuation characters, as the following example shows:</p>
<pre>* Retrieve employee data.
 EXEC SQL SELECT EMPNO, ENAME, JOB, SAL
 1 INTO :ENUM, :ENAM, :EJOB, :ESAL
 2 FROM EMP
 3 WHERE DEPTNO = :DNUM
</pre>
<p>To continue a string literal from one line to the next, code the literal through column 72. On the next line, code a continuation character and the rest of the literal. An example follows:</p>
<pre>* Execute dynamic SQL statement.
 EXEC SQL EXECUTE IMMEDIATE &#39;UPDATE EMP SET COMM = 500 WHERE
 1 DEPTNO=20&#39;
</pre>
<p>Most FORTRAN implementations allow up to 19 continuation lines. Check your FORTRAN compiler user&#39;s guide.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR112" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref8"></a>
<h3 class="sect2">Delimiters</h3>
<p>Though FORTRAN does not require blanks to delimit keywords, you must use blanks to delimit keywords in SQL statements. FORTRAN uses apostrophes to delimit string literals, as in</p>
<pre>* Display employee name.
 IF (ENAM .LT. &#39;ZZZZZ&#39;) THEN
 PRINT *, &#39; Employee Name: &#39;, ENAM
 END IF
</pre>
<p>SQL also uses apostrophes to delimit string literals, as in</p>
<pre>* Retrieve employee data.
 EXEC SQL SELECT ENAME, SAL
 1 INTO :ENAM, :ESAL
 2 FROM EMP
 3 WHERE JOB = &#39;CLERK&#39;
</pre>
<p>SQL also uses quotation marks to delimit identifiers containing special or lowercase characters.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR113" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref9"></a>
<h3 class="sect2">Embedded SQL Syntax</h3>
<p>To use a SQL statement in your host program, precede the SQL statement with the EXEC SQL clause. Embedded SQL syntax is described in the <a class="olink LNPCC" href="../LNPCC/toc.htm"><span class="italic">Pro*C/C++ Programmer&#39;s Guide</span></a>. The precompiler translates all EXEC SQL statements into calls to the runtime library SQLLIB.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR114" class="sect2"><!-- infolevel="all" infotype="General" --><a id="title"></a>
<h3 class="sect2">File Length</h3>
<p>The Pro*FORTRAN Precompiler cannot process arbitrarily long source files. Some of the variables used internally limit the size of the generated file. There is no absolute limit to the number of lines allowed, but the following aspects of the source files are contributing factors to the file-size constraint:</p>
<a id="list"></a>
<ul>
<li>
<p><a id="l1"></a>complexity of the embedded SQL statements (for example, the number of bind and define variables)</p>
</li>
<li>
<p><a id="l2"></a>whether a database name is used (for example, connecting to a database with an AT clause)</p>
</li>
<li>
<p><a id="l3"></a>number of embedded SQL statements</p>
</li>
</ul>
<p>To prevent problems related to this limitation, use multiple program units to reduce the size of the source files as required.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR115" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref10"></a>
<h3 class="sect2">File Naming Restrictions</h3>
<p>Avoid using filenames starting with &#34;sql,&#34; because errors might occur. For example, if you name a file SQLERROR.PFO, some linkers return name conflicts because there will be an array named SQLERD and a common block named SQLERD.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR116" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref11"></a>
<h3 class="sect2">FORTRAN Versions</h3>
<p>The Pro*FORTRAN Precompiler supports the standard implementation of FORTRAN for your operating system (usually FORTRAN 77). For more information, see your Oracle system-specific documentation.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCCCGG"></a>
<div id="ZZFOR117" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Required Declarations and SQL Statements</h2>
<p>Passing data between Oracle and your application program requires host variables and event handling. This section shows you how to meet these requirements.</p>
<div id="ZZFOR118" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref12"></a>
<h3 class="sect2">The Declare Section</h3>
<p>You must declare all program variables to be used in SQL statements in the <span class="italic">Declare Section</span>, which begins with the statement</p>
<pre>EXEC SQL BEGIN DECLARE SECTION
</pre>
<p>and ends with the statement</p>
<pre>EXEC SQL END DECLARE SECTION
</pre>
<p>Between these two statements only the following are allowed:</p>
<ul>
<li>
<p>host variable and indicator variable declarations</p>
</li>
<li>
<p>EXEC SQL DECLARE statements</p>
</li>
<li>
<p>EXEC SQL INCLUDE statements</p>
</li>
<li>
<p>EXEC SQL VAR statements</p>
</li>
<li>
<p>EXEC ORACLE statements</p>
</li>
<li>
<p>FORTRAN comments</p>
</li>
</ul>
<p>In a Pro*FORTRAN source file, multiple program units can contain SQL statements. So, multiple Declare Sections are allowed for each precompiled unit. Furthermore, a Pro*FORTRAN program can contain multiple files.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR119" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref13"></a>
<h3 class="sect2">Using the INCLUDE Statement</h3>
<p>FORTRAN INCLUDEs are processed by the FORTRAN compiler, while EXEC SQL INCLUDE statements are processed by Pro*FORTRAN to copy files into your host program, as illustrated in the following example:</p>
<pre>* Copy in the SQL Communications Area (SQLCA)
* and the Oracle Communications Area (ORACA).
 EXEC SQL INCLUDE SQLCA
 EXEC SQL INCLUDE ORACA
</pre>
<p>You can INCLUDE any file. When you precompile a Pro*FORTRAN program, each EXEC SQL INCLUDE statement is replaced by a copy of the file named in the statement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR120" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref14"></a>
<h3 class="sect2">Filename Extensions</h3>
<p>If your system uses file extensions but you do not specify one, the Pro*FORTRAN Precompiler assumes the default extension for source files (usually FOR or F). The default extension is system dependent. For more information, see your Oracle system-specific documentation.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR121" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref15"></a>
<h3 class="sect2">Search Paths</h3>
<p>If your system uses directories, you can set a search path for INCLUDE files using the INCLUDE precompiler option, as follows:</p>
<pre>INCLUDE=<span class="italic">path</span> 
</pre>
<p>where <span class="italic">path</span> defaults to the current directory.</p>
<p>The precompiler first searches the current directory, then the directory specified by the INCLUDE option, and finally the directory for standard INCLUDE files. You need not specify a path for standard files such as the SQLCA and ORACA. However, a path is required for nonstandard files unless they are stored in the current directory.</p>
<p>You can also specify multiple paths on the command line, as follows:</p>
<pre>... INCLUDE=&lt;path1&gt; INCLUDE=&lt;path2&gt; ...
</pre>
<p>When multiple paths are specified, the precompiler searches the current directory first, then the <span class="italic">path1</span> directory, then the <span class="italic">path2</span> directory, and so on. The directory containing standard INCLUDE files is searched last. The path syntax is system specific. Check the Oracle installation or user&#39;s guide for your system.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR122" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref16"></a>
<h3 class="sect2">Caution</h3>
<p>Remember, the precompiler searches for a file in the current directory first even if you specify a search path. If the file you want to INCLUDE is in another directory, make sure no file with the same name is in the current directory or any other directory that precedes it in the search path. Also, if your operating system is case-sensitive, you must specify the same upper or lower case filename under which the file is stored.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR123" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref17"></a>
<h3 class="sect2">Event and Error Handling</h3>
<p>Pro*FORTRAN provides forward and backward compatibility when checking the outcome of executing SQL statements. However, there are restrictions on using SQLCA, SQLCODE, and SQLSTATE depending on the MODE and DBMS option settings. For more information, see <a href="ch_two.htm#CFADJFHD">Chapter 2</a> of this manual and Chapter 8 of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBABIB"></a>
<div id="ZZFOR124" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Host Variable Names</h2>
<p>Host variable names must consist only of letters and digits, and must begin with a letter. They can be of any length, but only the first 31 characters are significant. Some compilers prohibit variable names longer than six characters, or ignore characters after the sixth. Check your FORTRAN compiler user&#39;s guide.</p>
<div id="ZZFOR125" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref18"></a>
<h3 class="sect2">Logical and Relational Operators</h3>
<p>Logical and relational operators are different for FORTRAN and SQL, as shown in the following tables, respectively. For example, the SQL operators do not have leading and trailing periods, as shown in table 1-1 and table 1-2.</p>
<div id="ZZFOR126" class="tblformal">
<p class="titleintable"><a id="sthref19"></a><a id="sthref20"></a>Table 1-1 Logical Operators</p>
<table class="cellalignment1640" title="Logical Operators" summary="Logical Operators" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t4">SQL Operators</th>
<th class="cellalignment1639" id="r1c2-t4">FORTRAN Operators</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t4" headers="r1c1-t4">
<p>NOT</p>
</td>
<td class="cellalignment1633" headers="r2c1-t4 r1c2-t4">
<p>.NOT.</p>
</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t4" headers="r1c1-t4">
<p>AND</p>
</td>
<td class="cellalignment1633" headers="r3c1-t4 r1c2-t4">
<p>.AND.</p>
</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t4" headers="r1c1-t4">
<p>OR</p>
</td>
<td class="cellalignment1633" headers="r4c1-t4 r1c2-t4">
<p>.OR.</p>
</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t4" headers="r1c1-t4">
<p>--</p>
</td>
<td class="cellalignment1633" headers="r5c1-t4 r1c2-t4">
<p>.EQV.</p>
</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t4" headers="r1c1-t4">
<p>--</p>
</td>
<td class="cellalignment1633" headers="r6c1-t4 r1c2-t4">
<p>.NEQV.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="ZZFOR127" class="tblformal">
<p class="titleintable"><a id="sthref21"></a><a id="sthref22"></a>Table 1-2 Relational Operator</p>
<table class="cellalignment1640" title="Relational Operator" summary="Relational Operator" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t5">SQL Operators</th>
<th class="cellalignment1639" id="r1c2-t5">FORTRAN operators</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t5" headers="r1c1-t5">
<p>=</p>
</td>
<td class="cellalignment1633" headers="r2c1-t5 r1c2-t5">
<p>.EQ.</p>
</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t5" headers="r1c1-t5">
<p>&lt;&gt;, !=, ^=</p>
</td>
<td class="cellalignment1633" headers="r3c1-t5 r1c2-t5">
<p>.NE.</p>
</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t5" headers="r1c1-t5">
<p>&gt;</p>
</td>
<td class="cellalignment1633" headers="r4c1-t5 r1c2-t5">
<p>.GT.</p>
</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t5" headers="r1c1-t5">
<p>&lt;</p>
</td>
<td class="cellalignment1633" headers="r5c1-t5 r1c2-t5">
<p>.LT.</p>
</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t5" headers="r1c1-t5">
<p>&gt;=</p>
</td>
<td class="cellalignment1633" headers="r6c1-t5 r1c2-t5">
<p>.GE.</p>
</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r7c1-t5" headers="r1c1-t5">
<p>&lt;=</p>
</td>
<td class="cellalignment1633" headers="r7c1-t5 r1c2-t5">
<p>.LE.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Logical and relational FORTRAN operators are <span class="italic">not</span> allowed in SQL statements.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR128" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref23"></a>
<h3 class="sect2">MAXLITERAL Default</h3>
<p>With the MAXLITERAL precompiler option, you can specify the maximum length of string literals generated by the precompiler, so that compiler limits are not exceeded. For Pro*FORTRAN, the default value is 1000, but you might need to specify a lower value.</p>
<p>For example, if your FORTRAN compiler cannot handle string literals longer than 512 characters, specify MAXLITERAL=512. Check your FORTRAN compiler user&#39;s guide.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR129" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref24"></a>
<h3 class="sect2">Nulls</h3>
<p>In SQL, a null represents a missing, unknown, or inapplicable column value; it equates neither to zero nor to a blank. Use the NVL function to convert nulls to non-null values, use the IS [NOT] NULL comparison operator to search for nulls, and use indicator variables to insert and test for nulls.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR130" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref25"></a>
<h3 class="sect2">Program Units</h3>
<p>In FORTRAN, a <span class="italic">program unit</span> is a function, subroutine, or main program. In Pro*FORTRAN, an input file contains one or more program units.</p>
<p>If a program unit contains SQL statements, it must</p>
<ul>
<li>
<p>define all local host variables in its Declare Section</p>
</li>
<li>
<p>INCLUDE the SQLCA when MODE={ORACLE|ANSI13}</p>
</li>
<li>
<p>declare a variable named SQLATA or SQLCOD inside or outside the Declare Section when MODE={ANSI|ANSI14}</p>
</li>
<li>
<p>INCLUDE the ORACA if you specify ORACA=YES</p>
</li>
</ul>
<p>Multiple program units can contain SQL statements. For example, you can DECLARE a cursor in one program unit, OPEN it in another, FETCH from it in yet another, and CLOSE it in still another as long as they are in the same file.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABEIJGE"></a>
<div id="ZZFOR131" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Scope of Host Variables</h2>
<p>The scoping rules for FORTRAN identifiers apply to host variables. Host variables declared in a program unit are local to that unit, and host variables declared in the main program are <span class="italic">not</span> global. So, all host variables used in a program unit must be declared in that unit in the Declare Section.</p>
<div id="ZZFOR132" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref26"></a>
<h3 class="sect2">Statement Labels</h3>
<p>You can associate FORTRAN numeric statement labels (1 - 99999) with SQL statements, as shown in the following example:</p>
<pre>* Insert row into employee table.
 500 EXEC SQL INSERT INTO EMP (EMPNO, ENAME, JOB, DEPTNO)
 1 VALUES (:ENUM, :ENAM, :EJOB, :DNUM)
</pre>
<p>And, you can reference statement labels in a WHENEVER DO or WHENEVER GOTO statement, as this example shows:</p>
<pre>* Handle SQL execution errors.
 EXEC SQL WHENEVER SQLERROR GOTO 900
 ...
* SQLEMC stores the Oracle error code and message.
 900 WRITE (*, 8500) SQLEMC
 8500 FORMAT (1X, 70A1)
 ...
</pre>
<p>Statement labels must be coded in columns 1 through 5, and must <span class="italic">not</span> appear in continuation lines. Statement labels may consist of alphanumeric characters, only; the special characters, underscore ( _ ), hyphen (-), and dollar sign ($) are not allowed.</p>
<p>The Pro*FORTRAN Precompiler does not use statement labels in generated code. Therefore, the BEGLABEL and ENDLABEL options that were available in earlier Pro*FORTRAN versions are not supported in this version and will return an informational message if found.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR133" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref27"></a>
<h3 class="sect2">Statement Terminator</h3>
<p>Embedded SQL statements are terminated by an end-of-line, as the following example shows:</p>
<pre>* Delete employee.
 EXEC SQL DELETE FROM EMP WHERE EMPNO = :ENUM
</pre>
<p>However, a continuation character on the next line overrides an end-of-line.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABHJCCH"></a>
<div id="ZZFOR134" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Host Variables</h2>
<p>Host variables are the key to communication between your host program and Oracle. Typically, a host program inputs data to Oracle, and Oracle outputs data to the program. Oracle stores input data in database columns and stores output data in program host variables.</p>
<div id="ZZFOR135" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref28"></a>
<h3 class="sect2">Declaring Host Variables</h3>
<p>Host variables are declared according to FORTRAN rules, using the FORTRAN datatypes that are supported by Oracle. FORTRAN datatypes must be compatible with the source/target database column. The supported FORTRAN datatypes are shown in the following table. One-dimensional arrays of FORTRAN types are also supported.</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="variable declaration" summary="variable declaration" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t6">Variable Declaration</th>
<th class="cellalignment1639" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t6" headers="r1c1-t6">BYTE <span class="italic">var</span> CHARACTER <span class="italic">var</span></td>
<td class="cellalignment1633" headers="r2c1-t6 r1c2-t6">single character</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t6" headers="r1c1-t6">CHARACTER <span class="italic">var</span>*<span class="italic">n</span> CHARACTER*<span class="italic">n var</span></td>
<td class="cellalignment1633" headers="r3c1-t6 r1c2-t6"><span class="italic">n</span>-byte character string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t6" headers="r1c1-t6">CHARACTER(*) <span class="italic">var</span></td>
<td class="cellalignment1633" headers="r4c1-t6 r1c2-t6">character string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t6" headers="r1c1-t6">INTEGER <span class="italic">var</span> INTEGER*2 <span class="italic">var</span> INTEGER*4 <span class="italic">var</span></td>
<td class="cellalignment1633" headers="r5c1-t6 r1c2-t6">default-length integer 2-byte integer 4-byte integer</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t6" headers="r1c1-t6">LOGICAL <span class="italic">var</span> LOGICAL*1 <span class="italic">var</span> LOGICAL*2 <span class="italic">var</span> LOGICAL*4 <span class="italic">var</span></td>
<td class="cellalignment1633" headers="r6c1-t6 r1c2-t6">single character 2-byte character string 4-byte character string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r7c1-t6" headers="r1c1-t6">REAL <span class="italic">var</span> REAL*4 <span class="italic">var</span> REAL*8 <span class="italic">var</span> DOUBLE PRECISION <span class="italic">var</span></td>
<td class="cellalignment1633" headers="r7c1-t6 r1c2-t6">4-byte real number 8-byte real number</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r8c1-t6" headers="r1c1-t6">VARCHAR*<span class="italic">n</span></td>
<td class="cellalignment1633" headers="r8c1-t6 r1c2-t6">&lt;= 32765-byte, variable length character string (3)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r9c1-t6" headers="r1c1-t6">SQLCURSOR</td>
<td class="cellalignment1633" headers="r9c1-t6 r1c2-t6">cursor variable</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p><span class="bold">Notes</span>:</p>
<ol>
<li>
<p>The size of FORTRAN numeric types is implementation-dependent. The sizes given in the table are typical but not universal. Check your FORTRAN compiler user&#39;s guide.</p>
</li>
<li>
<p>CHARACTER(*) variables have no predetermined length. They are used to specify dummy arguments in a subroutine declaration. The maximum length of an actual argument is returned by the LEN intrinsic function.</p>
</li>
<li>
<p>Variables declared with VARCHAR*<span class="italic">n</span> (not native to FORTRAN) are assigned the VARCHAR external datatype. See &#34;Declaring VARCHAR Variables&#34; for more information.</p>
</li>
</ol>
<p>The following table lists the compatible Oracle internal datatypes.</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="internal type" summary="internal type" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t7">Internal Type</th>
<th class="cellalignment1639" id="r1c2-t7">FORTRAN Type</th>
<th class="cellalignment1639" id="r1c3-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t7" headers="r1c1-t7">CHAR(<span class="italic">x</span>) (1)VARCHAR2(<span class="italic">y</span>) (1)</td>
<td class="cellalignment1633" headers="r2c1-t7 r1c2-t7">BYTE CHARACTER CHARACTER*<span class="italic">n</span> VARCHAR*<span class="italic">n var1</span>, <span class="italic">var2</span>, <span class="italic">var3</span></td>
<td class="cellalignment1633" headers="r2c1-t7 r1c3-t7">single character variable-length string variable-length string variable-length string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t7" headers="r1c1-t7">NUMBER NUMBER (<span class="italic">p</span>,<span class="italic">s</span>) (2)</td>
<td class="cellalignment1633" headers="r3c1-t7 r1c2-t7">CHARACTER*<span class="italic">n</span><span class="italic">var</span> CHARACTER <span class="italic">var</span> *<span class="italic">n</span> CHARACTER(*) DOUBLE PRECISION INTEGER INTEGER*2 INTEGER*4 LOGICAL <span class="italic">var</span> LOGICAL*1 <span class="italic">var</span> LOGICAL*2 <span class="italic">var</span> LOGICAL*4 <span class="italic">var</span>REAL REAL*4 REAL*8 VARCHAR*<span class="italic">n</span><span class="italic">var1</span>, <span class="italic">var2</span>, <span class="italic">var3</span></td>
<td class="cellalignment1633" headers="r3c1-t7 r1c3-t7"><span class="italic">n</span>-byte character string (3) character string (as parameter) 8-byte float number integer (default size) 2-byte integer 4-byte integer single character 2-byte character string 4-byte character string float number 4-byte float number 8-byte float number variable-length string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t7" headers="r1c1-t7">DATE (4)LONG RAW (1)LONG RAW ROWID (5)MLSLABEL (6)</td>
<td class="cellalignment1633" headers="r4c1-t7 r1c2-t7">CHARACTER*<span class="italic">n var</span> CHARACTER*<span class="italic">n var</span> VARCHAR*<span class="italic">n var1</span>, <span class="italic">var2</span>, <span class="italic">var3</span></td>
<td class="cellalignment1633" headers="r4c1-t7 r1c3-t7"><span class="italic">n</span>-byte character string <span class="italic">n</span>-byte variable-length string variable-length string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t7" headers="r1c1-t7">CURSOR</td>
<td class="cellalignment1633" headers="r5c1-t7 r1c2-t7">SQLCURSOR</td>
<td class="cellalignment1633" headers="r5c1-t7 r1c3-t7">cursor variable</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p><span class="bold">Notes</span>:</p>
<ol>
<li>
<p><span class="italic">x</span> ranges from 1 to 255, and 1 is the default. <span class="italic">y</span> ranges from 1 to 2000.</p>
</li>
<li>
<p><span class="italic">p</span> ranges from 2 to 38. <span class="italic">s</span> ranges from -84 to 127.</p>
</li>
<li>
<p>Strings can be converted to NUMBERs only if they consist of convertible characters -- 0 to 9, period (.), +, -, E, e. The NLS settings for your system might change the decimal point from a period (.) to a comma (,).</p>
</li>
<li>
<p>When converted to a string type, the default size of a DATE depends on the NLS settings in effect on your system. When converted to a binary value, the length is 7 bytes.</p>
</li>
<li>
<p>When converted to a string type, a ROWID requires from 18 to 256 bytes.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<div id="ZZFOR136" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref29"></a>
<h3 class="sect2">Example Declarations</h3>
<p>In the following example, several host variables are declared to be used later in a Pro*FORTRAN program:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 INTEGER*2 DNUM
 CHARACTER*15 DNAM
 EXEC SQL END DECLARE SECTION
</pre>
<p>You can also declare one-dimensional arrays of FORTRAN types, as the next example shows:</p>
<pre>* Declare host arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(100)
 CHARACTER*10 ENAM(100)
 REAL*4 ESAL(100)
 EXEC SQL END DECLARE SECTION
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR137" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref30"></a>
<h3 class="sect2">Repeating Definitions</h3>
<p>You can use repeating definitions for datatypes, as in the following example:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 ESAL, ECOM, EBON
 EXEC SQL END DECLARE SECTION
</pre>
<p>which is equivalent to</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 ESAL
 REAL*4 ECOM
 REAL*4 EBON
 EXEC SQL END DECLARE SECTION 
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR138" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref31"></a>
<h3 class="sect2">Initialization</h3>
<p>While it is not necessary to initialize host variables inside the Declare Section, you can use the FORTRAN DATA statement to initialize host variables, as shown in the following example:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 MINSAL
 REAL*4 MAXSAL
 DATA MINSAL, MAXSAL /1000.00, 5000.00/
 EXEC SQL END DECLARE SECTION
</pre>
<p>DATA statements must come before the first executable FORTRAN statement but after any variable and PARAMETER declarations. Later in your program, you can change the values of variables initialized by a DATA statement. You cannot, however, reuse a DATA statement to reset the changed values.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR139" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref32"></a>
<h3 class="sect2">Constants</h3>
<p>You can use the FORTRAN PARAMETER statement inside or outside the Declare Section to assign constant values to host variables, as the following example shows:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*5 UID
 CHARACTER*5 PWD
 PARAMETER (UID = &#39;SCOTT&#39;, PWD = &#39;TIGER&#39;)
 EXEC SQL END DECLARE SECTION 
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR140" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref33"></a>
<h3 class="sect2">COMMON Blocks</h3>
<p>Using the FORTRAN COMMON statement, you can keep host variables and arrays in a common storage area as if they were globally defined, so that you can use their values in different program units. The COMMON statement must appear <span class="italic">outside</span> the Declare Section, and before the first executable FORTRAN statement but after variable declarations. An example follows:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 REAL*4 ECOM
 EXEC SQL END DECLARE SECTION
* Define COMMON block.
 COMMON /EMPBLK/ ENUM, ESAL, ECOM
</pre>
<p>In this example, EMPBLK is the COMMON block name. The names of COMMON blocks, subroutines, and functions are the only globally defined identifiers in a FORTRAN program. You should avoid using blank COMMON blocks.</p>
<p>You can make a COMMON block available to other program units by redefining it in those units. You must repeat the type declarations for variables in a COMMON block in all units where the block is used.</p>
<p>Only the order and datatypes of variables in the COMMON block matter, not their names. Therefore, the variable names can differ from unit to unit. However, it is good programming practice to use the same names for corresponding variables in each occurrence of a COMMON block.</p>
<p>The following restrictions apply to COMMON blocks:</p>
<ul>
<li>
<p>You cannot put VARCHAR variables in a COMMON block.</p>
</li>
<li>
<p>Host arrays cannot be dimensioned in a COMMON statement.</p>
</li>
<li>
<p>You cannot use a DATA statement to initialize variables in a blank COMMON block.</p>
</li>
<li>
<p>With most compilers, CHARACTER variables must appear in their own COMMON blocks; that is, they cannot be mixed with other variables in a COMMON block.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ZZFOR141" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref34"></a>
<h3 class="sect2">EQUIVALENCE Statement</h3>
<p>With the FORTRAN EQUIVALENCE statement, you can use two or more host variable names for the same storage location. The EQUIVALENCE statement must appear before the first executable FORTRAN statement.</p>
<p>You can equivalence CHARACTER variables only to other CHARACTER variables. You <span class="italic">cannot</span> equivalence VARCHAR variables.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR142" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref35"></a>
<h3 class="sect2">Special Requirements for Subroutines</h3>
<p>You must explicitly declare host variables in the Declare Section of the program unit that uses them in SQL statements. Thus, variables passed to a subroutine and used in SQL statements within the subroutine must be declared in the subroutine Declare Section, as illustrated in the following example:</p>
<pre>...
 CALL LOGON (UID, PWD)
 ...
 SUBROUTINE LOGON (UID, PWD) 
* Declare host variables in subroutine.
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 UID
 CHARACTER*10 PWD
 EXEC SQL END DECLARE SECTION
 ...
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD 
 WRITE(*, 1000) UID
 1000 FORMAT(/,&#39; Connected to Oracle as user: &#39;, A10, /)
 RETURN
 END
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR143" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref36"></a>
<h3 class="sect2">Restrictions</h3>
<p>The following restrictions apply with respect to Declarations:</p>
<p class="subhead2"><a id="ZZFOR144"></a>Implicit Declarations</p>
<p>FORTRAN allows implicit declaration of INTEGER and REAL variables. Unless explicitly declared otherwise, identifiers starting with I, J, K, L, M, or N are assumed to be of type INTEGER, and other identifiers are assumed to be of type REAL.</p>
<p>However, implicit declaration of host variables is <span class="italic">not</span> allowed; it triggers an &#34;undeclared host variable&#34; error message at precompile time. Every variable referenced in a SQL statement must be defined in the Declare Section.</p>
<p class="subhead2"><a id="ZZFOR145"></a>Complex Numbers</p>
<p>These are numbers including a real and an imaginary part. In FORTRAN, complex numbers are represented using the datatype COMPLEX. Pro*FORTRAN, however, does <span class="italic">not</span> support the use of COMPLEX host variables in SQL statements.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABECBHG"></a>
<div id="ZZFOR146" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Referencing Host Variables</h2>
<p>You use host variables in SQL data manipulation statements. A host variable must be prefixed with a colon (:) in SQL statements but must not be prefixed with a colon in FORTRAN statements, as shown in the following example:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 CHARACTER*10 EJOB
 EXEC SQL END DECLARE SECTION
 ...
 WRITE (*, 3100)
 3100 FORMAT (&#39; Enter employee number: &#39;)
 READ (*, 3200) ENUM
 3200 FORMAT (I4) 
 EXEC SQL SELECT ENAME, SAL, JOB
 1 INTO :ENAM, :ESAL, :EJOB
 2 FROM EMP
 3 WHERE EMPNO = :ENUM 
 BONUS = ESAL / 10
 ...
</pre>
<p>Though it might be confusing, you can provide the same name to a host variable as that of an Oracle table or column, as the following example shows:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 EXEC SQL END DECLARE SECTION
 ...
 EXEC SQL SELECT ENAME, SAL
 1 INTO :ENAM, :ESAL
 2 FROM EMP
 3 WHERE EMPNO = :ENUM
</pre>
<div id="ZZFOR147" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref37"></a>
<h3 class="sect2">Restrictions</h3>
<p>A host variable cannot substitute for a column, table, or other Oracle objects in a SQL statement and must not be an Oracle reserved word. See Appendix B of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a> for a list of Oracle reserved words and keywords.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCACBI"></a>
<div id="ZZFOR148" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Indicator Variables</h2>
<p>You use indicator variables to provide information to Oracle about the status of a host variable, or to monitor the status of data returned from Oracle. An indicator variable is always associated with a host variable.</p>
<p>You use indicator variables in the VALUES or SET clauses to assign nulls to input host variables and in the INTO clause to detect nulls or truncated values in output host variables.</p>
<div id="ZZFOR149" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref38"></a>
<h3 class="sect2">Declaring Indicator Variables</h3>
<p>An indicator variable must be explicitly declared in the Declare Section as a 2-byte integer (INTEGER*2) and must not be an Oracle reserved word. In the following example, you declare two indicator variables (the names IESAL and IECOM are arbitrary):</p>
<pre>* Declare host and indicator variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 REAL*4 ECOM
 INTEGER*2 IESAL
 INTEGER*2 IECOM
 EXEC SQL END DECLARE SECTION
</pre>
<p>You can define an indicator variable anywhere in the Declare Section. It need not follow its associated host variable.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR150" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref39"></a>
<h3 class="sect2">Referencing Indicator Variables</h3>
<p>In SQL statements, an indicator variable must be prefixed with a colon and appended to its associated host variable. In FORTRAN statements, an indicator variable must <span class="italic">not</span> be prefixed with a colon or appended to its associated host variable. An example follows:</p>
<pre>* Retrieve employee data.
 EXEC SQL SELECT SAL, COMM
 1 INTO :ESAL, :ECOM:IECOM
 2 FROM EMP
 3 WHERE EMPNO = :ENUM 
* When an indicator variable equals -1, its associated
* host variable is null.
 IF (IECOM .EQ. -1) THEN
 PAY = ESAL
 ELSE
 PAY = ESAL + ECOM
 END IF
</pre>
<p>To improve readability, you can precede any indicator variable with the optional keyword INDICATOR. You must still prefix the indicator variable with a colon. The correct syntax is</p>
<pre>:&lt;host_variable&gt; INDICATOR :&lt;indicator_variable&gt;
</pre>
<p>, which is equivalent to</p>
<pre>:&lt;host_variable&gt;:&lt;indicator_variable&gt;
</pre>
<p>You can use both forms of the expression in your host program.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR151" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref40"></a>
<h3 class="sect2">Restrictions</h3>
<p>Indicator variables cannot be used in the WHERE clause to search for nulls. For example, the following DELETE statement triggers an Oracle error at run time:</p>
<pre>* Set indicator variable.
 IECOM = -1
 EXEC SQL DELETE FROM EMP WHERE COMM = :ECOM:IECOM
</pre>
<p>The correct syntax follows:</p>
<pre>EXEC SQL DELETE FROM EMP WHERE COMM IS NULL
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR152" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref41"></a>
<h3 class="sect2">Oracle Restrictions</h3>
<p>When DBMS=V6, Oracle does not issue an error if you SELECT or FETCH a null into a host variable not associated with an indicator variable. However, when DBMS=V7, if you SELECT or FETCH a null into a host variable that has no indicator, Oracle issues the following error message:</p>
<pre>ORA-01405: fetched column value is NULL
</pre>
<p>When precompiling with MODE=ORACLE and DBMS=V7, you can disable the ORA-01405 message by also specifying UNSAFE_NULL=YES on the command line. For more information, see the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR153" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref42"></a>
<h3 class="sect2">ANSI Requirements</h3>
<p>When MODE=ORACLE, if you SELECT or FETCH a truncated column value into a host variable not associated with an indicator variable, Oracle issues the following error message:</p>
<pre>ORA-01406: fetched column value was truncated
</pre>
<p>However, when MODE={ANSI|ANSI14|ANSI13}, no error is generated. Values for indicator variables are discussed in Chapter 3 of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFGDAH"></a>
<div id="ZZFOR154" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Host Arrays</h2>
<p>Host arrays can boost performance by letting you manipulate an entire collection of data items with a single SQL statement. With few exceptions, you can use host arrays wherever scalar host variables are allowed. And, you can associate an indicator array with any host array.</p>
<div id="ZZFOR155" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref43"></a>
<h3 class="sect2">Declaring Host Arrays</h3>
<p>You declare and dimension host arrays in the Declare Section. In the following example, three host arrays are declared, each with an upper dimension bound of 50 (the lower bound defaults to 1):</p>
<pre>* Declare and dimension host arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(50)
 CHARACTER*10 ENAM(50)
 REAL*4 ESAL(50)
 EXEC SQL END DECLARE SECTION 
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR156" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref44"></a>
<h3 class="sect2">Restrictions</h3>
<p>You cannot specify a lower dimension bound for host arrays. For example, the following declaration is <span class="italic">invalid</span>:</p>
<pre>* Invalid dimensioning of host array
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 VECTOR(0:10)
 EXEC SQL END DECLARE SECTION
</pre>
<p>Multi-dimensional host arrays are <span class="italic">not</span> allowed. Therefore, the two-dimensional host array declared in the following example is <span class="italic">invalid</span>:</p>
<pre>* Invalid declaration of host array
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 MATRIX(50, 100)
 EXEC SQL END DECLARE SECTION
</pre>
<p>You cannot dimension host arrays using the FORTRAN DIMENSION statement. For example, the following usage is <span class="italic">invalid</span>:</p>
<pre>* Invalid use of DIMENSION statement
 EXEC SQL BEGIN DECLARE SECTION
 REAL*4 ESAL
 REAL*4 ECOM
 DIMENSION ESAL(50), ECOM(50)
 EXEC SQL END DECLARE SECTION 
</pre>
<p>Also, you cannot dimension a host array in a COMMON statement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR157" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref45"></a>
<h3 class="sect2">Referencing Host Arrays</h3>
<p>If you use multiple host arrays in a single SQL statement, their dimensions should be the same. However, this is not a requirement because the Pro*FORTRAN Precompiler always uses the <span class="italic">smallest</span> dimension for the SQL operation. In the following example, only 50 rows are INSERTed:</p>
<pre>* Declare host arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(100)
 CHARACTER*10 ENAM(100)
 INTEGER*4 DNUM(100)
 REAL*4 ECOM(50)
 EXEC SQL END DECLARE SECTION
 ...
* Populate host arrays here.
 ...
 EXEC SQL INSERT INTO EMP (EMPNO, ENAME, COMM, DEPTNO)
 1 VALUES (:ENUM, :ENAM, :ECOM, :DNUM)
</pre>
<p>Host arrays must <span class="italic">not</span> be subscripted in SQL statements. For example, the following INSERT statement is invalid:</p>
<pre>* Declare host arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(50)
 REAL*4 ESAL(50)
 INTEGER*4 DNUM(50)
 EXEC SQL END DECLARE SECTION
 ...
 DO 200 J = 1, 50
* Invalid use of host arrays
 EXEC SQL INSERT INTO EMP (EMPNO, SAL, DEPTNO)
 1 VALUES (:ENUM(J), :ESAL(J), :DNUM(J))
 200 CONTINUE
</pre>
<p>You need not process host arrays in a loop. Instead, use unsubscripted array names in your SQL statement. Oracle treats a SQL statement containing host arrays of dimension <span class="italic">n</span> like the same statement executed <span class="italic">n</span> times with <span class="italic">n</span> different scalar variables. For more information, see Chapter 8 of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR158" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref46"></a>
<h3 class="sect2">Using Indicator Arrays</h3>
<p>You can use indicator arrays to assign nulls to input host arrays and to detect nulls or truncated values in output host arrays. The following example shows how to INSERT with indicator arrays:</p>
<pre>* Declare host and indicator arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(50)
 INTEGER*4 DNUM(50)
 REAL*4 ECOM(50)
 INTEGER*2 IECOM(50) -- indicator array
 EXEC SQL END DECLARE SECTION
 ...
* Populate the host and indicator arrays. To insert
* a null into the COMM column, assign -1 to the
* appropriate element in the indicator array.
 ...
 EXEC SQL INSERT INTO EMP (EMPNO, DEPTNO, COMM)
 1 VALUES (:ENUM, :DNUM, :ECOM:IECOM)
</pre>
<p>The dimension of the indicator array must be greater than, or equal to, the dimension of the host array.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCJDFE"></a>
<div id="ZZFOR159" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">VARCHAR Host Variables</h2>
<p>FORTRAN string datatypes are of fixed length. However, Pro*FORTRAN lets you declare a variable-length string pseudotype called VARCHAR.</p>
<div id="ZZFOR160" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref47"></a>
<h3 class="sect2">Declaring VARCHAR Variables</h3>
<p>A VARCHAR is a set of three variables declared using the syntax</p>
<pre>* Declare a VARCHAR.
 EXEC SQL BEGIN DECLARE SECTION
 VARCHAR*&lt;n&gt; &lt;VARNAM&gt;, &lt;VARLEN&gt;, &lt;VARARR&gt;
 EXEC SQL END DECLARE SECTION
</pre>
<p>where:</p>
<pre>n
</pre>
<p>Is the maximum length of the VARCHAR; <span class="italic">n</span> must be in the range 1 through 32765.</p>
<pre>VARNAM
</pre>
<p>Is the name used to reference the VARCHAR in SQL statements; it is called an <span class="italic">aggregate name</span> because it identifies a set of variables.</p>
<pre>VARLEN
</pre>
<p>Is a 2-byte signed integer variable that stores the actual length of the string variable.</p>
<pre>VARARR
</pre>
<p>Is the string variable used in FORTRAN statements.</p>
<p>The advantage of using VARCHAR variables is that you can explicitly set and reference VARLEN. With input host variables, Oracle reads the value of VARLEN and uses the same number of characters of VARARR. With output host variables, Oracle sets VARLEN to the length of the character string stored in VARARR.</p>
<p>You can declare a VARCHAR only in the Declare Section. In the following example, you declare a VARCHAR named EJOB with a maximum length of 15 characters:</p>
<pre>* Declare a VARCHAR.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 VARCHAR*15 EJOB, EJOBL, EJOBA
 EXEC SQL END DECLARE SECTION
</pre>
<p>The precompiler expands this declaration to</p>
<pre>* Expanded VARCHAR declaration
 INTEGER*2 EJOBL
 LOGICAL*1 EJOBA(15)
 INTEGER*2 SQXXX(2)
 EQUIVALENCE (SQXXX(1), EJOBL), (SQXXX(2), EJOBA(1))
</pre>
<p>where SQXXX is an array generated by the precompiler and XXX denotes three arbitrary characters. Notice that the aggregate name EJOB is not declared. The EQUIVALENCE statement forces the compiler to store EJOBL and EJOBA contiguously.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR161" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref48"></a>
<h3 class="sect2">Referencing VARCHAR Variables</h3>
<p>In SQL statements, you can reference a VARCHAR variable by using the aggregate name prefixed with a colon, as the following example shows:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 INTEGER*4 ENUM
 VARCHAR*15 EJOB, EJOBL, EJOBA
 EXEC SQL END DECLARE SECTION
 ...
 EXEC SQL SELECT JOB
 1 INTO :EJOB
 2 FROM EMP
 3 WHERE EMPNO = :ENUM
</pre>
<p>After the query executes, EJOBL holds the actual length of the character string retrieved from the database and stored in EJOBA. In FORTRAN statements, you reference VARCHAR variables using the length variable and string variable names, as this example shows:</p>
<pre>* Display job title.
 WRITE (*, 5200) (EJOBA(J), J = 1, EJOBL)
 5200 FORMAT (15A1)
 ...
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR162" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref49"></a>
<h3 class="sect2">Overcoming the Length Limit</h3>
<p>Recall that the length variable of a VARCHAR must be a 2-byte integer. FORTRAN provides a 2-byte signed integer datatype, which can represent numbers in the range -32768 through 32767. However, FORTRAN lacks a 2-byte <span class="italic">unsigned</span> integer datatype, which can represent numbers in the range 0 through 65535. Therefore, the maximum length of a VARCHAR character string is 32765 bytes (32767 minus 2 for the length variable).</p>
<p>With other host languages, the maximum length of a VARCHAR character string is 65533 bytes. If you want to use 65533-byte VARCHAR variables, try the technique shown in the following example:</p>
<pre>* Declare a VARCHAR.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 VARCHAR*65533 BUF, BUFL, BUFA
 EXEC SQL END DECLARE SECTION
 ...
* Equivalence two 2-byte integers to one 4-byte integer.
 INTEGER*2 INT2(2)
 INTEGER*4 INT4
 EQUIVALENCE (INT2(1), INT4)
 INTEGER*4 I
 ...
 INT4 = 65533
* Set the VARCHAR length variable equal to the
* equivalenced value of INT4.
 BUFL = INT2(1)
 DO 100 I = 1, 65533
 BUFA(I) = 32
 100 CONTINUE
 EXEC SQL INSERT INTO LONG_TABLE VALUES (:BUF)
 ...
 BUFL = 0
 EXEC SQL SELECT COL1 INTO :BUF FROM LONG_TABLE
 INT2(1) = BUFL
 ...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The way integers are stored varies from system to system. On some systems, the least significant digits are stored at the low address; on other systems they are stored at the high address. In the last example, this determines whether the length is stored in INT2(1) or INT2(2).</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABHCCFD"></a>
<div id="ZZFOR163" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Handling Character Data</h2>
<p>This section explains how the Pro*FORTRAN Precompiler handles character host variables. There are two types of character host variables:</p>
<ul>
<li>
<p>CHARACTER*<span class="italic">n</span></p>
</li>
<li>
<p>VARCHAR</p>
</li>
</ul>
<p>Do not confuse VARCHAR, which is a host variable data structure supplied by the precompiler, with VARCHAR2, which is an Oracle column datatype for variable-length character strings.</p>
<div id="ZZFOR164" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref50"></a>
<h3 class="sect2">Effects of the MODE Option</h3>
<p>The MODE option has the following effects:</p>
<ul>
<li>
<p>It determines how the Pro*FORTRAN Precompiler treats data in character arrays and strings. The MODE option allows the program to use ANSI fixed-length strings or to maintain compatibility with previous versions of the Oracle Server and the Pro*FORTRAN Precompiler.</p>
</li>
<li>
<p>With respect to character handling, MODE={ANSI14|ANSI13} is equivalent to MODE=ORACLE. The MODE option affects character data on input (from host variables to Oracle) and on output (from Oracle to host variables).</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The MODE option does not affect the way Pro*FORTRAN handles VARCHAR host variables.</div>
</div>
<!-- class="sect2" -->
<div id="ZZFOR165" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref51"></a>
<h3 class="sect2">CHARACTER*<span class="italic">n</span></h3>
<p>Character variables are declared using the CHARACTER*<span class="italic">n</span> datatype. These types of variables handle character data based on their roles as input or output variables.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR166" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref52"></a>
<h3 class="sect2">On Input</h3>
<p>When MODE=ORACLE, the program interface strips trailing blanks before sending the value to the database. If you insert into a fixed-length CHAR column, Oracle re-appends trailing blanks up to the length of the database column. However, if you insert into a variable-length VARCHAR2 column, Oracle never appends blanks.</p>
<p>When MODE=ANSI, trailing blanks are never stripped.</p>
<p>Make sure that the input value is not trailed by extraneous characters. For example, nulls are not stripped and are inserted into the database. Normally, this is not a problem because when a value is READ into or assigned to a CHARACTER*<span class="italic">n</span> variable, FORTRAN appends blanks up to the length of the variable.</p>
<p>The following example illustrates the point:</p>
<pre>* Declare host variables
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER ENAM *10, EJOB *8
 ...
 EXEC SQL END DECLARE SECTION
 ...
 WRITE (*, 300)
 300 FORMAT (/, &#39;$Employee name? &#39;)
* Assume the name &#39;MILLER&#39; is entered
 READ (*, 400)
 400 FORMAT (A10)
 EJOB = &#39;SALES&#39;
 EXEC SQL INSERT INTO emp (empno, ename, deptno, job)
 VALUES (1234, :ENAM, 20, :EJOB)
</pre>
<p>If you precompile the last example with MODE=ORACLE and the target database columns are VARCHAR2, the program interface strips the trailing blanks on input and inserts just the 6-character string &#34;MILLER&#34; and the 5-character string &#34;SALES&#34; into the database. However, if the target database columns are CHAR, the strings are blank-padded to the width of the columns.</p>
<p>If you precompile the last example with MODE=ANSI and the JOB column is defined as CHAR(10), the value inserted into that column is &#34;SALES#####&#34; (five trailing blanks). However, if the JOB column is defined as VARCHAR2(10), the value inserted is &#34;SALES###&#34; (three trailing blanks) because the host variable is a CHARACTER*8. This might not be what you want, so be careful.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR167" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref53"></a>
<h3 class="sect2">On Output</h3>
<p>The MODE option has no effect on output to character variables. When you use a CHARACTER*<span class="italic">n</span> variable as an output host variable, Oracle blank-pads it. In our example, when your program fetches the string &#34;MILLER&#34; from the database, ENAM contains the value &#34;MILLER####&#34; (with four trailing blanks). This character string can be used without change as input to another SQL statement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR168" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref54"></a>
<h3 class="sect2">VARCHAR Variables</h3>
<p>VARCHAR variables handle character data based on their roles as input or output variables</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR169" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref55"></a>
<h3 class="sect2">On Input</h3>
<p>When you use a VARCHAR variable as an input host variable, your program must assign values to the length and string variables, as shown in the following example:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 VARCHAR*15 EJOB, EJOBL, EJOBA
 INTEGER*2 IEJOB
 INTEGER*4 DNUM
 EXEC SQL END DECLARE SECTION
 ...
 WRITE (*, 4300)
 4300 FORMAT (/, &#39; Enter job title: &#39;)
 READ (*, 4400) EJOBA
 4400 FORMAT (15A1) 
* Scan backward for last non-blank character, then
* set length to that position. If input is all blank,
* set indicator variable to -1 to indicate a null.
 DO 5000 J = 15, 1, -1
 IF (EJOBA(J) .NE. &#39; &#39;) GOTO 5100
 5000 CONTINUE
 J = 0
 5100 IF (J .EQ. 0) THEN
 IEJOB = -1
 ELSE
 IEJOB = 0
 END IF 
 EJOBL = J 
 EXEC SQL INSERT INTO EMP (EMPNO, JOB, DEPTNO)
 1 VALUES (:ENUM, :EJOB:IEJOB, :DNUM)
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR170" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref56"></a>
<h3 class="sect2">On Output</h3>
<p>When you use a VARCHAR variable as an output host variable, Oracle sets the length variable. An example follows:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 VARCHAR*15 EJOB, EJOBL, EJOBA
 INTEGER*4 ESAL
 EXEC SQL END DECLARE SECTION
 ...
 EXEC SQL SELECT JOB, SAL INTO :EJOB, :ESAL FROM EMP
 1 WHERE EMPNO = :ENUM
 ...
 IF (EJOBL .EQ. 0) GOTO ...
 ...
</pre>
<p>An advantage of VARCHAR variables over fixed-length strings is that the length of the value returned by Oracle is available immediately. With fixed-length strings, to get the length of the value, your program must count the number of characters. (The intrinsic function LEN returns the length of a string including blanks, not its current length.)</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABHACJB"></a>
<div id="ZZFOR171" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">The Oracle Datatypes</h2>
<p>Oracle recognizes two kinds of datatypes: <span class="italic">internal</span> and <span class="italic">external</span>. Internal datatypes specify how Oracle stores data in database columns. Oracle also uses internal datatypes to represent database pseudocolumns. An external datatype specifies how data is stored in a host variable. For descriptions of the Oracle datatypes, see Chapter 3 of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
<div id="ZZFOR172" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref57"></a>
<h3 class="sect2">Internal Datatypes</h3>
<p>For values stored in database columns, Oracle uses the following internal datatypes:</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="name" summary="name" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t10">Name</th>
<th class="cellalignment1639" id="r1c2-t10">Code</th>
<th class="cellalignment1639" id="r1c3-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t10" headers="r1c1-t10">CHAR</td>
<td class="cellalignment1633" headers="r2c1-t10 r1c2-t10">96</td>
<td class="cellalignment1633" headers="r2c1-t10 r1c3-t10">&lt;= 255-byte, fixed-length string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t10" headers="r1c1-t10">DATE</td>
<td class="cellalignment1633" headers="r3c1-t10 r1c2-t10">12</td>
<td class="cellalignment1633" headers="r3c1-t10 r1c3-t10">7-byte, fixed-length date/time value</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t10" headers="r1c1-t10">LONG</td>
<td class="cellalignment1633" headers="r4c1-t10 r1c2-t10">8</td>
<td class="cellalignment1633" headers="r4c1-t10 r1c3-t10">&lt;= 2147483647-byte, variable-length string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t10" headers="r1c1-t10">LONG RAW</td>
<td class="cellalignment1633" headers="r5c1-t10 r1c2-t10">24</td>
<td class="cellalignment1633" headers="r5c1-t10 r1c3-t10">&lt;= 2147483647-byte, variable-length binary data</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t10" headers="r1c1-t10">MLSLABEL</td>
<td class="cellalignment1633" headers="r6c1-t10 r1c2-t10">105</td>
<td class="cellalignment1633" headers="r6c1-t10 r1c3-t10">&lt;= 5-byte, variable-length binary label</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r7c1-t10" headers="r1c1-t10">NUMBER</td>
<td class="cellalignment1633" headers="r7c1-t10 r1c2-t10">2</td>
<td class="cellalignment1633" headers="r7c1-t10 r1c3-t10">fixed or floating point number</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r8c1-t10" headers="r1c1-t10">RAW</td>
<td class="cellalignment1633" headers="r8c1-t10 r1c2-t10">23</td>
<td class="cellalignment1633" headers="r8c1-t10 r1c3-t10">&lt;= 255-byte, variable-length binary data</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r9c1-t10" headers="r1c1-t10">ROWID</td>
<td class="cellalignment1633" headers="r9c1-t10 r1c2-t10">11</td>
<td class="cellalignment1633" headers="r9c1-t10 r1c3-t10">fixed-length binary value</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r10c1-t10" headers="r1c1-t10">VARCHAR2</td>
<td class="cellalignment1633" headers="r10c1-t10 r1c2-t10">1</td>
<td class="cellalignment1633" headers="r10c1-t10 r1c3-t10">&lt;= 2000-byte, variable-length string</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>Table 1 - 5. Internal Datatypes</p>
<p>These internal datatypes can be quite different from FORTRAN datatypes. For example, FORTRAN has no equivalent to the NUMBER datatype, which was specially designed for portability and high precision.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR173" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref58"></a>
<h3 class="sect2">External Datatypes</h3>
<p>As the following table shows, the external datatypes include all the internal datatypes plus several datatypes found in other supported host languages. For example, the STRING external datatype refers to a C null-terminated string. You use the datatype names in datatype equivalencing, and you use the datatype codes in dynamic SQL Method 4.</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="name" summary="name" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t11">Name</th>
<th class="cellalignment1639" id="r1c2-t11">Code</th>
<th class="cellalignment1639" id="r1c3-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t11" headers="r1c1-t11">CHAR</td>
<td class="cellalignment1633" headers="r2c1-t11 r1c2-t11">1 96</td>
<td class="cellalignment1633" headers="r2c1-t11 r1c3-t11">&lt;= 65535-byte, variable-length character string (1)&lt;= 65535-byte, fixed-length character string (1)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t11" headers="r1c1-t11">CHARF</td>
<td class="cellalignment1633" headers="r3c1-t11 r1c2-t11">96</td>
<td class="cellalignment1633" headers="r3c1-t11 r1c3-t11">&lt;= 65535-byte, fixed-length character string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t11" headers="r1c1-t11">CHARZ</td>
<td class="cellalignment1633" headers="r4c1-t11 r1c2-t11">97</td>
<td class="cellalignment1633" headers="r4c1-t11 r1c3-t11">&lt;= 65535-byte, fixed-length, null-terminated string (2)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t11" headers="r1c1-t11">DATE</td>
<td class="cellalignment1633" headers="r5c1-t11 r1c2-t11">12</td>
<td class="cellalignment1633" headers="r5c1-t11 r1c3-t11">7-byte, fixed-length date/time value</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t11" headers="r1c1-t11">DECIMAL</td>
<td class="cellalignment1633" headers="r6c1-t11 r1c2-t11">7</td>
<td class="cellalignment1633" headers="r6c1-t11 r1c3-t11">COBOL packed decimal</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r7c1-t11" headers="r1c1-t11">DISPLAY</td>
<td class="cellalignment1633" headers="r7c1-t11 r1c2-t11">91</td>
<td class="cellalignment1633" headers="r7c1-t11 r1c3-t11">COBOL numeric character string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r8c1-t11" headers="r1c1-t11">FLOAT</td>
<td class="cellalignment1633" headers="r8c1-t11 r1c2-t11">4</td>
<td class="cellalignment1633" headers="r8c1-t11 r1c3-t11">4-byte or 8-byte floating-point number</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r9c1-t11" headers="r1c1-t11">INTEGER</td>
<td class="cellalignment1633" headers="r9c1-t11 r1c2-t11">3</td>
<td class="cellalignment1633" headers="r9c1-t11 r1c3-t11">2-byte or 4-byte signed integer</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r10c1-t11" headers="r1c1-t11">LONG</td>
<td class="cellalignment1633" headers="r10c1-t11 r1c2-t11">8</td>
<td class="cellalignment1633" headers="r10c1-t11 r1c3-t11">&lt;= 2147483647-byte, fixed-length string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r11c1-t11" headers="r1c1-t11">LONG RAW</td>
<td class="cellalignment1633" headers="r11c1-t11 r1c2-t11">24</td>
<td class="cellalignment1633" headers="r11c1-t11 r1c3-t11">&lt;= 217483647-byte, fixed-length binary data</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r12c1-t11" headers="r1c1-t11">LONG VARCHAR</td>
<td class="cellalignment1633" headers="r12c1-t11 r1c2-t11">94</td>
<td class="cellalignment1633" headers="r12c1-t11 r1c3-t11">&lt;= 217483643-byte, variable-length string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r13c1-t11" headers="r1c1-t11">LONG VARRAW</td>
<td class="cellalignment1633" headers="r13c1-t11 r1c2-t11">95</td>
<td class="cellalignment1633" headers="r13c1-t11 r1c3-t11">&lt;= 217483643-byte, variable-length binary data</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r14c1-t11" headers="r1c1-t11">MLSLABEL</td>
<td class="cellalignment1633" headers="r14c1-t11 r1c2-t11">106</td>
<td class="cellalignment1633" headers="r14c1-t11 r1c3-t11">2..5-byte, variable-length binary data</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r15c1-t11" headers="r1c1-t11">NUMBER</td>
<td class="cellalignment1633" headers="r15c1-t11 r1c2-t11">2</td>
<td class="cellalignment1633" headers="r15c1-t11 r1c3-t11">integer or floating-point number</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r16c1-t11" headers="r1c1-t11">RAW</td>
<td class="cellalignment1633" headers="r16c1-t11 r1c2-t11">23</td>
<td class="cellalignment1633" headers="r16c1-t11 r1c3-t11">&lt;= 65535-byte, fixed-length binary data (2)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r17c1-t11" headers="r1c1-t11">ROWID</td>
<td class="cellalignment1633" headers="r17c1-t11 r1c2-t11">11</td>
<td class="cellalignment1633" headers="r17c1-t11 r1c3-t11">(typically) 13-byte, fixed-length binary value</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r18c1-t11" headers="r1c1-t11">STRING</td>
<td class="cellalignment1633" headers="r18c1-t11 r1c2-t11">5</td>
<td class="cellalignment1633" headers="r18c1-t11 r1c3-t11">&lt;= 65535-byte, null-terminated character string (2)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r19c1-t11" headers="r1c1-t11">UNSIGNED</td>
<td class="cellalignment1633" headers="r19c1-t11 r1c2-t11">68</td>
<td class="cellalignment1633" headers="r19c1-t11 r1c3-t11">2-byte or 4-byte unsigned integer</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r20c1-t11" headers="r1c1-t11">VARCHAR</td>
<td class="cellalignment1633" headers="r20c1-t11 r1c2-t11">9</td>
<td class="cellalignment1633" headers="r20c1-t11 r1c3-t11">&lt;= 65533-byte, variable-length character string</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r21c1-t11" headers="r1c1-t11">VARCHAR2</td>
<td class="cellalignment1633" headers="r21c1-t11 r1c2-t11">1</td>
<td class="cellalignment1633" headers="r21c1-t11 r1c3-t11">&lt;= 65535-byte, variable-length character string (2)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r22c1-t11" headers="r1c1-t11">VARNUM</td>
<td class="cellalignment1633" headers="r22c1-t11 r1c2-t11">6</td>
<td class="cellalignment1633" headers="r22c1-t11 r1c3-t11">variable-length binary number</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r23c1-t11" headers="r1c1-t11">VARRAW</td>
<td class="cellalignment1633" headers="r23c1-t11 r1c2-t11">15</td>
<td class="cellalignment1633" headers="r23c1-t11 r1c3-t11">&lt;= 65533-byte, variable-length binary data</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p><span class="bold">Notes</span>:</p>
<ol>
<li>
<p>CHAR is datatype 1 when MODE={ORACLE|ANSI13|ANSI14} and datatype 96 when MODE=ANSI.</p>
</li>
<li>
<p>Maximum size is 32767 (32K) on some platforms.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJBHBI"></a>
<div id="ZZFOR174" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Datatype Conversion</h2>
<p>At precompile time, an external datatype is assigned to each host variable in the Declare Section. For example, the precompiler assigns the FLOAT external datatype to host variables of type REAL. At run time, the datatype code of every host variable used in a SQL statement is passed to Oracle. Oracle uses the codes to convert between internal and external datatypes.</p>
<p>Before assigning a SELECTed column value to an output host variable, Oracle must convert the internal datatype of the source column to the datatype of the host variable. Likewise, before assigning or comparing the value of an input host variable to a column, Oracle must convert the external datatype of the host variable to the internal datatype of the target column.</p>
<p>Conversions between internal and external datatypes follow the usual data conversion rules. For example, you can convert a CHAR value of &#34;1234&#34; to a INTEGER*2 value. You cannot, however, convert a CHAR value of &#34;65543&#34; (number too large) or &#34;10F&#34; (number not decimal) to a INTEGER*2 value. Likewise, you cannot convert a CHARACTER*<span class="italic">n</span> value that contains alphabetic characters to a NUMBER value.</p>
<p>For more information about datatype conversion, see Chapter 3 of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="BABFBCFA"></a>
<div id="ZZFOR175" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Datatype Equivalencing</h2>
<p>Datatype equivalencing lets you control the way Oracle interprets input data and the way Oracle formats output data. You can equivalence supported FORTRAN datatypes to Oracle external datatypes on a variable-by-variable basis.</p>
<div id="ZZFOR176" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref59"></a>
<h3 class="sect2">Host Variable Equivalencing</h3>
<p>By default, the Pro*FORTRAN Precompiler assigns a specific external datatype to every host variable. The default assignments are shown in the following table. For more information about datatype equivalencing, see Chapter 3 in the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="host type" summary="host type" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t12">Host Type</th>
<th class="cellalignment1639" id="r1c2-t12">External Type</th>
<th class="cellalignment1639" id="r1c3-t12">Code</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t12" headers="r1c1-t12">BYTE <span class="italic">var</span> LOGICAL <span class="italic">var</span> LOGICAL*1 <span class="italic">var</span> LOGICAL*2 <span class="italic">var</span> LOGICAL*4 <span class="italic">var</span> CHARACTER <span class="italic">var</span> CHARACTER <span class="italic">var</span>*<span class="italic">n</span> CHARACTER*<span class="italic">n var</span> CHARACTER(*) <span class="italic">var</span></td>
<td class="cellalignment1633" headers="r2c1-t12 r1c2-t12">VARCHAR2 CHARF</td>
<td class="cellalignment1633" headers="r2c1-t12 r1c3-t12">1 (when MODE != ANSI) 96 (when MODE=ANSI)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t12" headers="r1c1-t12">VARCHAR*<span class="italic">n</span></td>
<td class="cellalignment1633" headers="r3c1-t12 r1c2-t12">VARCHAR</td>
<td class="cellalignment1633" headers="r3c1-t12 r1c3-t12">9</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t12" headers="r1c1-t12">INTEGER <span class="italic">var</span> INTEGER*2 <span class="italic">var</span> INTEGER*4 <span class="italic">var</span></td>
<td class="cellalignment1633" headers="r4c1-t12 r1c2-t12">INTEGER</td>
<td class="cellalignment1633" headers="r4c1-t12 r1c3-t12">3</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t12" headers="r1c1-t12">REAL <span class="italic">var</span> REAL*4 <span class="italic">var</span> REAL*8 <span class="italic">var</span> DOUBLE PRECISION <span class="italic">var</span></td>
<td class="cellalignment1633" headers="r5c1-t12 r1c2-t12">FLOAT</td>
<td class="cellalignment1633" headers="r5c1-t12 r1c3-t12">4</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>With the VAR statement, you can override the default assignments by equivalencing host variables to Oracle external datatypes in the Declare Section. The syntax you use is</p>
<pre>EXEC SQL
 VAR &lt;host_variable&gt;
 IS &lt;ext_type_name&gt; [({&lt;length&gt; | &lt;precision&gt;,&lt;scale&gt;})]
</pre>
<p>where <span class="italic">host_variable</span> is an input or output host variable (or host array) declared earlier in the Declare Section, <span class="italic">ext_type_name</span> is the name of a valid external datatype, and <span class="italic">length</span> is an integer literal specifying a valid length in bytes.</p>
<p>When <span class="italic">ext_type_name</span> is FLOAT, use <span class="italic">length</span>; when <span class="italic">ext_type_name</span> is DECIMAL, you must specify <span class="italic">precision</span> and <span class="italic">scale</span> instead of <span class="italic">length</span>.</p>
<p>Host variable equivalencing is useful in several ways. For example, you can use it when you want Oracle to store but not interpret data. Suppose you want to store a host array of 4-byte integers in a RAW database column. Simply equivalence the host array to the RAW external datatype, as follows:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(50)
 ...
* Reset default datatype (INTEGER) to RAW.
 EXEC SQL VAR ENUM IS RAW (200);
 EXEC SQL END DECLARE SECTION
 ...
</pre>
<p>With host arrays, the length you specify must match the buffer size required to hold the array. In the last example, you specified a length of 200, which is the buffer size required to hold 50 4-byte integers.</p>
<p>For more information about datatype equivalencing, see Chapter 3 in the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABHJHJE"></a>
<div id="ZZFOR177" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Embedding PL/SQL</h2>
<p>The Pro*FORTRAN Precompiler treats a PL/SQL block like a single embedded SQL statement. As a result, you can place a PL/SQL block anywhere in a host program that you can place a SQL statement.</p>
<p>To embed a PL/SQL block in your host program, declare the variables to be shared with PL/SQL and bracket the PL/SQL block with the EXEC SQL EXECUTE and END-EXEC keywords.</p>
<div id="ZZFOR178" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref60"></a>
<h3 class="sect2">Host Variables</h3>
<p>Inside a PL/SQL block, host variables are global to the entire block and can be used anywhere a PL/SQL variable is allowed. Like host variables in a SQL statement, host variables in a PL/SQL block must be prefixed with a colon. The colon sets host variables apart from PL/SQL variables and database objects.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR179" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref61"></a>
<h3 class="sect2">VARCHAR Variables</h3>
<p>When entering a PL/SQL block, Oracle automatically checks the length fields of VARCHAR host variables. So, you must set the length fields <span class="italic">before</span> the block is entered. For input variables, set the length field to the length of the value stored in the string field. For output variables, set the length field to the maximum length allowed by the string field.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR180" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref62"></a>
<h3 class="sect2">Indicator Variables</h3>
<p>In a PL/SQL block, you cannot refer to an indicator variable by itself; it must be appended to its associated host variable. In addition, if you refer to a host variable with its indicator variable, you must always refer to it the same way within the same block.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR181" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref63"></a>
<h3 class="sect2">Handling Nulls</h3>
<p>When entering a block, if an indicator variable has a value of -1, PL/SQL automatically assigns a null to the host variable. When exiting the block, if a host variable is null, PL/SQL automatically assigns a value of -1 to the indicator variable.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR182" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref64"></a>
<h3 class="sect2">Handling Truncated Values</h3>
<p>PL/SQL does not raise an exception when a truncated string value is assigned to a host variable. However, if you use an indicator variable, PL/SQL sets it to the original length of the string.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR183" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref65"></a>
<h3 class="sect2">SQLCHECK</h3>
<p>You must specify SQLCHECK=SEMANTICS when precompiling a program with an embedded PL/SQL block. You must also use the USERID option. For more information, see Chapter 6 of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR184" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref66"></a>
<h3 class="sect2">Cursor Variables</h3>
<p>Starting with Release 1.7 of the Pro*FORTRAN Precompiler, you can use <span class="italic">cursor variables</span> in your Pro*FORTRAN programs to process multi-row queries using static embedded SQL. A cursor variable identifies a <span class="italic">cursor reference</span> that is defined and opened on the Oracle Database Server, using PL/SQL. See the <span class="italic">Oracle Database PL/SQL Language Reference</span> for complete information about cursor variables.</p>
<p>The advantages of cursor variables are:</p>
<ul>
<li>
<p><span class="italic">Encapsulation</span>: queries are centralized in the stored procedure that opens the cursor variable.</p>
</li>
<li>
<p><span class="italic">Ease of maintenance</span>: only the stored procedure needs to be changed if the table changes.</p>
</li>
<li>
<p><span class="italic">Security</span>: the user of the application (the username when the Pro*FORTRAN application connected to the database) must have execute permission on the stored procedure that opens the cursor. This user, however, does not need to have read permission on the tables used in the query. This capability can be used to limit access to the columns in the table.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBIIAH"></a>
<div id="ZZFOR185" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Declaring a Cursor Variable</h2>
<p>You declare a Pro*FORTRAN cursor variable using the SQLCURSOR pseudotype. For example:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION
 ...
 SQLCURSOR CURVAR
 ...
 EXEC SQL END DECLARE SECTION
</pre>
<p>A SQLCURSOR variable is implemented using a FORTRAN INTEGER*4 array in the code that Pro*FORTRAN generates. A cursor variable is just like any other Pro*FORTRAN host variable.</p>
<div id="ZZFOR186" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref67"></a>
<h3 class="sect2">Allocating a Cursor Variable</h3>
<p>Before you can OPEN or FETCH a cursor variable, you must allocate it by using the Pro*FORTRAN ALLOCATE command. For example, to allocate the cursor variable CURVAR that was declared in the previous section, write the following statement:</p>
<pre>EXEC SQL ALLOCATE :CURVAR
</pre>
<p>Allocating a cursor variable does <span class="italic">not</span> require a call to the server, either at precompile time or at run time.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Allocating a cursor variable <span class="italic">does</span> cause heap memory to be used. For this reason, avoid allocating a cursor variable in a program loop.</div>
</div>
<!-- class="sect2" -->
<div id="ZZFOR187" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref68"></a>
<h3 class="sect2">Opening a Cursor Variable</h3>
<p>You must use an embedded anonymous PL/SQL block to open a cursor variable on the Oracle Server. The anonymous PL/SQL block may open the cursor either indirectly by calling a PL/SQL stored procedure that opens the cursor (and defines it in the same statement) or directly from the Pro*FORTRAN program.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR188" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref69"></a>
<h3 class="sect2">Opening Indirectly through a Stored PL/SQL Procedure</h3>
<p>Consider the following PL/SQL package stored in the database:</p>
<pre>CREATE PACKAGE demo_cur_pkg AS
 TYPE EmpName IS RECORD (name VARCHAR2(10));
 TYPE cur_type IS REF CURSOR RETURN EmpName;
 PROCEDURE open_emp_cur (
 curs IN OUT curtype,
 dept_num IN NUMBER);
END;
CREATE PACKAGE BODY demo_cur_pkg AS
 CREATE PROCEDURE open_emp_cur (
 curs IN OUT curtype,
 dept_num IN NUMBER) IS
 BEGIN
 OPEN curs FOR
 SELECT ename FROM emp
 WHERE deptno = dept_num
 ORDER BY ename ASC;
 END;
END;
</pre>
<p>After this package has been stored, you can open the variable <span class="italic">curs</span> by calling the <span class="italic">open_emp_cur</span> stored procedure from your Pro*FORTRAN program, and FETCH from the cursor variable ECUR in the program. For example:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION
 SQLCURSOR ECUR
 INTEGER*4 DNUM
 VARCHAR*10 ENAM, ENAML, ENAMA
 EXEC SQL END DECLARE SECTION
 ...
* Allocate the cursor variable.
 EXEC SQL ALLOCATE :ECUR
 ...
 DNUM=30
* Open the cursor on the Oracle Database Server.
 EXEC SQL EXECUTE
 1 BEGIN
 2 demo_cur_pkg.open_emp_cur(:ECUR, :DNUM);
 3 END;
 4 END-EXEC
 EXEC SQL WHENEVER NOTFOUND DO CALL SIGNOFF
*
 1000 EXEC SQL FETCH :ECUR INTO :ENAM
 PRINT *, &#34;Employee Name: &#34;, ENAM
 GOTO 1000
 ...
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR189" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref70"></a>
<h3 class="sect2">Opening Directly from Your Pro*FORTRAN Application</h3>
<p>To open a cursor by using a PL/SQL anonymous block in a Pro*FORTRAN program, define the cursor in the anonymous block. Consider the following example:</p>
<pre>EXEC SQL EXECUTE
 1 BEGIN
 2 OPEN :ECUR FOR SELECT ENAME FROM EMP
 3 WHERE DEPTNO = :DNUM;
 4 END;
 5 END-EXEC
 ...
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR190" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref71"></a>
<h3 class="sect2">Return Types</h3>
<p>When you define a reference cursor (REF CURSOR) in a PL/SQL stored procedure, you must declare the type that the cursor returns. The return types allowed for reference cursors are described in the <a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">PL/SQL User&#39;s Guide and Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR191" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref72"></a>
<h3 class="sect2">Fetching from a Cursor Variable</h3>
<p>Use the embedded SQL FETCH .... INTO command to retrieve the rows SELECTed when you opened the cursor variable. For example:</p>
<pre>EXEC SQL FETCH :ECUR INTO :EINFO:IEINFO
</pre>
<p>Before you can FETCH from a cursor variable, the variable must be initialized and opened. You cannot FETCH from an unopened cursor variable.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR192" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref73"></a>
<h3 class="sect2">Closing a Cursor Variable</h3>
<p>Use the embedded SQL CLOSE command to close a cursor variable. For example:</p>
<pre>EXEC SQL BEGIN DECLARE SECTION
* Declare the cursor variable.
 SQLCURSOR ECUR
 ...
 EXEC SQL END DECLARE SECTION
* Allocate and open the cursor variable, then
* fetch one or more rows.
 ...
* Close the cursor variable.
 EXEC SQL CLOSE :ECUR
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR193" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref74"></a>
<h3 class="sect2">Restrictions</h3>
<p>The following restrictions apply to the use of cursor variables:</p>
<ul>
<li>
<p>You can only use cursor variables with the ALLOCATE, FETCH, and CLOSE commands. The DECLARE CURSOR command does <span class="italic">not</span> apply to cursor variables.</p>
</li>
<li>
<p>You cannot FETCH from a CLOSEd or unALLOCATEd cursor variable.</p>
</li>
<li>
<p>If you precompile with MODE=ANSI, it is an error to close a cursor variable that is already closed.</p>
</li>
<li>
<p>You cannot use the AT clause with the ALLOCATE command.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ZZFOR194" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref75"></a>
<h3 class="sect2">Error Conditions</h3>
<p>Do <span class="italic">not</span> perform any of the following operations:</p>
<ul>
<li>
<p>FETCH from a closed cursor variable</p>
</li>
<li>
<p>use a cursor variable that is not ALLOCATEd</p>
</li>
<li>
<p>CLOSE a cursor variable that is not open</p>
</li>
</ul>
<p>These operations on cursor variables result in errors.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR195" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref76"></a>
<h3 class="sect2">Sample Programs</h3>
<p>The following sample programs -- a SQL script (SAMPLE11.SQL) and a Pro*FORTRAN program (SAMPLE11.PFO) -- demonstrate how you can use cursor variables in Pro*FORTRAN.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For simplicity in demonstrating this feature, this example does not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <a class="olink DBSEG50053" href="../DBSEG/app_devs.htm#DBSEG50053"><span class="italic">Oracle Database Security Guide</span></a> for password management guidelines and other security recommendations.</div>
</div>
<!-- class="sect2" -->
<div id="ZZFOR196" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref77"></a>
<h3 class="sect2">SAMPLE11.SQL</h3>
<p>Following is the PL/SQL source code for a creating a package that declares and opens a cursor variable:</p>
<pre>CONNECT SCOTT/TIGER
CREATE OR REPLACE PACKAGE emp_demo_pkg AS
 TYPE emp_cur_type IS REF CURSOR RETURN emp%ROWTYPE;
 PROCEDURE open_cur (
 cursor IN OUT emp_cur_type,
 dept_num IN number);
END emp_demo_pkg;
/ 
CREATE OR REPLACE PACKAGE BODY emp_demo_pkg AS
 PROCEDURE open_cur (
 cursor IN OUT emp_cur_type, 
 dept_num IN number) IS
 BEGIN 
 OPEN cursor FOR SELECT * FROM emp
 WHERE deptno = dept_num
 ORDER BY ename ASC;
 END;
END emp_demo_pkg;
/
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR197" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref78"></a>
<h3 class="sect2">SAMPLE11.PFO</h3>
<p>Following is a Pro*FORTRAN sample program that uses the cursor declared in the SAMPLE11.SQL example to fetch employee names, salaries, and commissions from the EMP table.</p>
<pre>PROGRAM SAMPLE11
 EXEC SQL BEGIN DECLARE SECTION
* Declare the cursor variable.
 SQLCURSOR ECUR
* EMPINFO
 INTEGER ENUM
 CHARACTER*10 ENAM
 VARCHAR*9 EJOB, EJOBL, EJOBA
 INTEGER EMGR
 VARCHAR*10 EDAT, EDATL, EDATA
 REAL ESAL
 REAL ECOM
 INTEGER EDEP
* EMPINFO INDICATORS
 INTEGER*2 IENUM
 INTEGER*2 IENAM
 INTEGER*2 IEJOB
 INTEGER*2 IEMGR
 INTEGER*2 IEDAT
 INTEGER*2 IESAL
 INTEGER*2 IECOM
 INTEGER*2 IEDEP
 EXEC SQL END DECLARE SECTION
 EXEC SQL INCLUDE SQLCA
 COMMON /CURSOR/ ECUR
 EXEC SQL WHENEVER SQLERROR DO CALL SQLERR

* LOG ON TO ORACLE.
 CALL LOGON

* Initialize the cursor variable.
 EXEC SQL ALLOCATE :ECUR
 TYPE 1000
 1000 FORMAT (/, &#39;Enter department number (0 to exit): &#39;, $)
 ACCEPT 1100, EDEP
 1100 FORMAT (I10)
 IF (EDEP .LE. 0) THEN
 CALL SIGNOFF
 ENDIF

* Open the cursor by calling a PL/SQL stored procedure.
 EXEC SQL EXECUTE
 1 BEGIN
 2 emp_demo_pkg.open_cur (:ECUR, :EDEP);
 3 END;
 4 END-EXEC
 PRINT 1200, EDEP
 1200 FORMAT (/, &#39;For department &#39;, I, &#39;:&#39;,/)
 PRINT 1300
 1300 FORMAT (/, &#39;EMPLOYEE SALARY COMMISSION&#39;,
 + /, &#39;---------- ---------- ----------&#39;)

* Fetch data from the cursor into the host variables.
 2000 EXEC SQL WHENEVER NOT FOUND DO CALL SIGNOFF
 EXEC SQL FETCH :ECUR
 1 INTO :ENUM:IENUM,
 2 :ENAM:IENAM,
 3 :EJOB:IEJOB,
 4 :EMGR:IEMGR,
 5 :EDAT:IEDAT,
 6 :ESAL:IESAL,
 7 :ECOM:IECOM,
 8 :EDEP:IEDEP

* Check for commission and print results.
 IF (IECOM .EQ. 0) THEN
 PRINT 2100, ENAM, ESAL, ECOM
 2100 FORMAT (A10, 2X, F10.2, 2X, F10.2)
 ELSE
 PRINT 2200, ENAM, ESAL
 2200 FORMAT (A10, 2X, F10.2, 2X, &#39; N/A&#39;)
 ENDIF
 GOTO 2000
 END

* LOG ON TO ORACLE.
 SUBROUTINE LOGON
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 UID
 CHARACTER*10 PWD
 EXEC SQL END DECLARE SECTION
 EXEC SQL INCLUDE SQLCA
 UID = &#39;SCOTT&#39;
 PWD = &#39;TIGER&#39;
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 PRINT 3000, UID
 3000 FORMAT (/, &#39;CONNECTED TO ORACLE AS USER: &#39;, A)
 END
* Close the cursor variable.
 SUBROUTINE SIGNOFF
 EXEC SQL BEGIN DECLARE SECTION
 SQLCURSOR ECUR
 EXEC SQL END DECLARE SECTION
 EXEC SQL INCLUDE SQLCA
 COMMON /CURSOR/ ECUR
 EXEC SQL CLOSE :ECUR
 PRINT 4100
 4100 FORMAT (/, &#39;HAVE A GOOD DAY.&#39;, /)
 EXEC SQL COMMIT WORK RELEASE
 STOP
 END

 SUBROUTINE SQLERR
 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR CONTINUE
 PRINT*, &#39; &#39;
 PRINT *, &#39;ORACLE ERROR DETECTED: &#39;
 PRINT &#39;(70A1)&#39;, SQLEMC
 PRINT*, &#39; &#39;
 EXEC SQL ROLLBACK WORK RELEASE
 STOP
 END
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCBBAG"></a>
<div id="ZZFOR198" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Connecting to Oracle</h2>
<p>Your Pro*FORTRAN program must log on to Oracle before querying or manipulating data. To log on, you use the CONNECT statement, as in</p>
<pre>* Log on to Oracle.
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
</pre>
<p>where UID and PWD are CHARACTER or VARCHAR host variables. Alternatively, you can use the statement</p>
<pre>* Log on to Oracle.
 EXEC SQL CONNECT :UIDPWD
</pre>
<p>where the host variable UIDPWD contains your username and password separated by a slash (/).</p>
<p>The CONNECT statement must be the first SQL statement executed by the program. That is, other executable SQL statements can positionally, but not logically, precede the CONNECT statement.</p>
<p>To supply the Oracle username and password separately, you define two host variables in the Declare Section as character strings or VARCHAR variables. If you supply a userid containing both username and password, only one host variable is needed.</p>
<p>Make sure to set the username and password variables before the CONNECT is executed or it will fail. Your program can prompt for the values or you can hard code them as follows:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*5 UID
 CHARACTER*5 PWD
 ...
 EXEC SQL END DECLARE SECTION
 UID = &#39;SCOTT&#39;
 PWD = &#39;TIGER&#39;
* Handle logon errors.
 EXEC SQL WHENEVER SQLERROR GOTO ...
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
</pre>
<p>However, you cannot hard code a username and password into the CONNECT statement or use quoted literals. For example, both of the following statements are <span class="italic">invalid</span>:</p>
<pre>* Invalid CONNECT statements
 EXEC SQL CONNECT SCOTT IDENTIFIED BY TIGER
 EXEC SQL CONNECT &#39;SCOTT&#39; IDENTIFIED BY &#39;TIGER&#39;
</pre>
<div id="ZZFOR199" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref79"></a>
<h3 class="sect2">Automatic Logons</h3>
<p>You can automatically log on to the Oracle using the following userid:</p>
<pre>&lt;prefix&gt;&lt;username&gt;
</pre>
<p>where <span class="italic">prefix</span> is the value of the Oracle initialization parameter OS_AUTHENT_PREFIX (the default value is OPS$) and <span class="italic">username</span> is your operating system user or task name. For example, if the prefix is OPS$, your user name is TBARNES, and OPS$TBARNES is a valid Oracle userid, you log on to Oracle as user OPS$TBARNES.</p>
<p>To take advantage of the automatic logon feature, you simply pass a slash (/) character to the precompiler, as follows:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 CHARACTER*1 ORAID
 EXEC SQL END DECLARE SECTION 
 ORAID = &#39;/&#39; 
 EXEC SQL CONNECT :ORAID
</pre>
<p>This automatically connects you as user OPS$<span class="italic">username</span>. For example, if your operating system username is RHILL, and OPS$RHILL is a valid Oracle username, connecting with a slash (/) automatically logs you on to Oracle as user OPS$RHILL.</p>
<p>You can also pass a character string to the precompiler. However, the string cannot contain trailing blanks. For example, the following CONNECT statement will fail:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 CHARACTER*5 ORAID
 EXEC SQL END DECLARE SECTION 
 ORAID = &#39;/ &#39; 
 EXEC SQL CONNECT :ORAID 
</pre>
<p>For more information about operating system authentication, see the <span class="italic">Oracle Database Administrator&#39;s Guide</span>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR200" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref80"></a>
<h3 class="sect2">Concurrent Logons</h3>
<p>Your application can use Oracle Net Services to access any combination of remote and local databases concurrently or make multiple connections to the same database. In the following example, you connect to two nondefault databases concurrently:</p>
<pre>* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*5 UID
 CHARACTER*5 PWD
 CHARACTER*12 DBSTR1
 CHARACTER*12 DBSTR2
 EXEC SQL END DECLARE SECTION
 UID = &#39;SCOTT&#39;
 PWD = &#39;TIGER&#39;
 DBSTR1 = &#39;NEWYORK&#39;
 DBSTR2 = &#39;BOSTON&#39;
* Give each database connection a unique name.
 EXEC SQL DECLARE DBNAM1 DATABASE
 EXEC SQL DECLARE DBNAM2 DATABASE
* Connect to the two non-default databases.
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 1 AT DBNAM1 USING :DBSTR1
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 1 AT DBNAM2 USING :DBSTR2
</pre>
<p>The string syntax in DBSTR1 and DBSTR2 depends on your network driver and how it is configured. DBNAM1 and DBNAM2 name the nondefault connections; they can be undeclared identifiers or host variables.</p>
<p>For step-by-step instructions on connecting to Oracle through Oracle Net Services, see Chapter 3 in the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1626">
<tr>
<td class="cellalignment1633">
<table class="cellalignment1637">
<tr>
<td class="cellalignment1630"><a href="preface.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1630"><a href="ch_two.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1994, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1635">
<table class="cellalignment1636">
<tr>
<td class="cellalignment1630"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1630"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1630"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1630"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1630"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>