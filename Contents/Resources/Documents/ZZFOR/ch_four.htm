<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114726"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Implementing%20Dynamic%20SQL%20Method%204"></a><title>Implementing Dynamic SQL Method 4</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 726"/>
<meta name="dcterms.created" content="2013-04-08T7:43:56Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*FORTRAN&reg; Supplement to the Oracle Precompilers Guide"/>
<meta name="dcterms.identifier" content="E18411-05"/>
<meta name="dcterms.isVersionOf" content="ZZFOR"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1994, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Prev" href="ch_three.htm" title="Previous" type="text/html"/>
<link rel="Next" href="appendix.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E18411-05.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/8</span> <!-- End Header -->
<div id="ZZFOR245" class="chapter"><a id="BCEDFCCA"></a>
<h1 class="chapter"><span class="secnum">4</span> Implementing Dynamic SQL Method 4</h1>
<p>This chapter shows you how to implement dynamic SQL Method 4, which lets your program accept or build dynamic SQL statements that contain a varying number of host variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For a discussion of dynamic SQL Methods 1, 2, and 3, and an overview of Method 4, see Chapter 10 of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers.</span></a></div>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#BABCDJJE">Meeting the Special Requirements of Method 4</a></p>
</li>
<li>
<p><a href="#BABEDDIE">Understanding the SQL Descriptor Area (SQLDA)</a></p>
</li>
<li>
<p><a href="#BABHAJCG">Using the SQLDA Variables and Arrays</a></p>
</li>
<li>
<p><a href="#BABDBIIJ">Some Preliminaries</a></p>
</li>
<li>
<p><a href="#BABGGBEG">The Basic Steps</a></p>
</li>
<li>
<p><a href="#BABHHGJH">A Closer Look at Each Step</a></p>
</li>
<li>
<p><a href="#BABJCBIA">Using Host Arrays with Method 4</a></p>
</li>
<li>
<p><a href="#BABICDGG">Sample Program 10: Dynamic SQL Method 4</a></p>
</li>
</ul>
<a id="BABCDJJE"></a>
<div id="ZZFOR246" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Meeting the Special Requirements of Method 4</h2>
<p>Before looking into the requirements of Method 4, you should feel comfortable with the terms <span class="italic">select-list item</span> and <span class="italic">placeholder</span>. Select-list items are the columns or expressions following the keyword SELECT in a query. For example, the following dynamic query contains three select-list items:</p>
<pre>SELECT ENAME, JOB, SAL + COMM FROM EMP WHERE DEPTNO = 20
</pre>
<p>Placeholders are dummy bind (input) variables that hold places in a SQL statement for actual bind variables. You do not declare placeholders and can name them anything you like. Placeholders for bind variables are most often used in the SET, VALUES, and WHERE clauses. For example, the following dynamic SQL statements each contain two placeholders:</p>
<pre>INSERT INTO EMP (EMPNO, DEPTNO) VALUES (:E, :D)
DELETE FROM DEPT WHERE DEPTNO = :DNUM AND LOC = :DLOC
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Placeholders cannot reference table or column names.</div>
<div id="ZZFOR247" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref109"></a>
<h3 class="sect2">What Makes Method 4 Special?</h3>
<p>Unlike Methods 1, 2, and 3, dynamic SQL Method 4 lets your program</p>
<ul>
<li>
<p>accept or build dynamic SQL statements that contain an unknown number of select-list items or placeholders</p>
</li>
<li>
<p>take explicit control over datatype conversion between Oracle and FORTRAN types</p>
</li>
</ul>
<p>To add this flexibility to your program, you must give the Oracle runtime library additional information.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR248" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref110"></a>
<h3 class="sect2">What Information Does Oracle Need?</h3>
<p>The Pro*FORTRAN Precompiler generates calls to Oracle for all executable dynamic SQL statements. If a dynamic SQL statement contains no select-list items or placeholders, Oracle needs no additional information to execute the statement. The following DELETE statement falls into this category:</p>
<pre>* Dynamic SQL statement
 STMT = &#39;DELETE FROM EMP WHERE DEPTNO = 30&#39;
</pre>
<p>However, most dynamic SQL statements contain select-list items or placeholders for bind variables, as shown in the following UPDATE statement:</p>
<pre>* Dynamic SQL statement with placeholders
 STMT = &#39;UPDATE EMP SET COMM = :C WHERE EMPNO = :E&#39;
</pre>
<p>To execute a dynamic SQL statement that contains select-list items and/or placeholders for bind variables, Oracle needs information about the program variables that will hold output or input values. Specifically, Oracle needs the following information:</p>
<ul>
<li>
<p>the number of select-list items and the number of bind variables</p>
</li>
<li>
<p>the length of each select-list item and bind variable</p>
</li>
<li>
<p>the datatype of each select-list item and bind variable</p>
</li>
<li>
<p>the memory address of each output variable that will store the value of a select-list item, and the address of each bind variable</p>
</li>
</ul>
<p>For example, to write the value of a select-list item, Oracle needs the address of the corresponding output variable.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR249" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref111"></a>
<h3 class="sect2">Where Is the Information Stored?</h3>
<p>All the information Oracle needs about select-list items or placeholders for bind variables, except their values, is stored in a program data structure called the SQL Descriptor Area (SQLDA).</p>
<p>Descriptions of select-list items are stored in a <span class="italic">select SQLDA,</span> and descriptions of placeholders for bind variables are stored in a <span class="italic">bind SQLDA</span>.</p>
<p>The values of select-list items are stored in output buffers; the values of bind variables are stored in input buffers. You use the library routine SQLADR to store the addresses of these data buffers in a select or bind SQLDA, so that Oracle knows where to write output values and read input values.</p>
<p>How do values get stored in these data buffers? Output values are FETCHed using a cursor, and input values are filled in by your program, typically from information entered interactively by the user.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR250" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref112"></a>
<h3 class="sect2">How Is the Information Obtained?</h3>
<p>You use the DESCRIBE statement to help get the information Oracle needs. The DESCRIBE SELECT LIST statement examines each select-list item to determine its name, datatype, constraints, length, scale, and precision, then stores this information in the select SQLDA for your use. For example, you might use select-list names as column headings in a printout. DESCRIBE also stores the total number of select-list items in the SQLDA.</p>
<p>The DESCRIBE BIND VARIABLES statement examines each placeholder to determine its name and length, then stores this information in an input buffer and bind SQLDA for your use. For example, you might use placeholder names to prompt the user for the values of bind variables.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABEDDIE"></a>
<div id="ZZFOR251" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Understanding the SQL Descriptor Area (SQLDA)</h2>
<p>This section describes the SQLDA data structure in detail. You learn how to declare it, what variables it contains, how to initialize them, and how to use them in your program.</p>
<div id="ZZFOR252" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref113"></a>
<h3 class="sect2">Purpose of the SQLDA</h3>
<p>Method 4 is required for dynamic SQL statements that contain an unknown number of select-list items or placeholders for bind variables. To process this kind of dynamic SQL statement, your program must explicitly declare SQLDAs, also called <span class="italic">descriptors</span> (not to be confused with the CHARACTER variable descriptors generated by some FORTRAN compilers). Each descriptor is a named COMMON block, which you must copy or hard code into your program.</p>
<p>A <span class="italic">select descriptor</span> holds descriptions of select-list items and the addresses of output buffers where the names and values of select-list items are stored.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The name of a select-list item can be a column name, a column alias, or the text of an expression such as SAL + COMM.</div>
<p>A <span class="italic">bind descriptor</span> holds descriptions of bind variables and indicator variables and the addresses of input buffers where the names and values of bind variables and indicator variables are stored.</p>
<p>Remember, some descriptor variables contain addresses, not values. So, you must declare data buffers to hold the values. You decide the sizes of the required input and output buffers. Because FORTRAN does not support pointers, you must use the library subroutine SQLADR to get the addresses of input and output buffers. You learn how to call SQLADR in the section <a href="#BABIEGGE">&#34;Using SQLADR&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR253" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref114"></a>
<h3 class="sect2">Multiple SQLDAs</h3>
<p>If your program has more than one active dynamic SQL statement, each statement must have its own SQLDA(s). You can declare any number of SQLDAs with different names. For example, you might declare three select SQLDAs named SEL1, SEL2, and SEL3, so that you can FETCH from three concurrently open cursors. However, non-concurrent cursors can reuse SQLDAs.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR254" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref115"></a>
<h3 class="sect2">Naming Conventions</h3>
<p>You can name select and bind descriptors anything you like. Typically, the names SEL and BND are used. The precompiler references descriptor variables by appending single-character suffixes to the descriptor name (see Table 4 - 1). You use the descriptor name in the DESCRIBE, OPEN, and FETCH statements.</p>
<p>For example, the statement</p>
<pre>* Open a cursor.
 EXEC SQL OPEN CUR1 USING DESCRIPTOR BND
* Fetch select-list values.
 EXEC SQL FETCH CUR1 USING DESCRIPTOR SEL
</pre>
<p>fetches select-list values into output data buffers.</p>
<p>You decide the names and sizes of the required data buffers. The variable and buffer names shown in the following tables, respectively, are used in the following discussion. For example, the elements of descriptor array SELS address the elements of data buffer array SELSB.</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="variable and buffer names" summary="variable and buffer names" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t5">Suffix</th>
<th class="cellalignment1639" id="r1c2-t5">Host Datatype</th>
<th class="cellalignment1639" id="r1c3-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t5" headers="r1c1-t5">N</td>
<td class="cellalignment1633" headers="r2c1-t5 r1c2-t5">INTEGER var</td>
<td class="cellalignment1633" headers="r2c1-t5 r1c3-t5">maximum number of select-list items or placeholders</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t5" headers="r1c1-t5">F</td>
<td class="cellalignment1633" headers="r3c1-t5 r1c2-t5">INTEGER var</td>
<td class="cellalignment1633" headers="r3c1-t5 r1c3-t5">actual number of select-list items or placeholders</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t5" headers="r1c1-t5">S</td>
<td class="cellalignment1633" headers="r4c1-t5 r1c2-t5">INTEGER*4 var(n)</td>
<td class="cellalignment1633" headers="r4c1-t5 r1c3-t5">addresses of select-list or placeholder names</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t5" headers="r1c1-t5">M</td>
<td class="cellalignment1633" headers="r5c1-t5 r1c2-t5">INTEGER*2 var(n)</td>
<td class="cellalignment1633" headers="r5c1-t5 r1c3-t5">maximum lengths of select-list or placeholder names</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t5" headers="r1c1-t5">C</td>
<td class="cellalignment1633" headers="r6c1-t5 r1c2-t5">INTEGER*2 var(n)</td>
<td class="cellalignment1633" headers="r6c1-t5 r1c3-t5">actual lengths of select-list or placeholder names</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r7c1-t5" headers="r1c1-t5">L</td>
<td class="cellalignment1633" headers="r7c1-t5 r1c2-t5">INTEGER*4 var(n)</td>
<td class="cellalignment1633" headers="r7c1-t5 r1c3-t5">lengths of select-list or bind-variable values</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r8c1-t5" headers="r1c1-t5">T</td>
<td class="cellalignment1633" headers="r8c1-t5 r1c2-t5">INTEGER*2 var(n)</td>
<td class="cellalignment1633" headers="r8c1-t5 r1c3-t5">datatypes of select-list or bind-variable values</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r9c1-t5" headers="r1c1-t5">V</td>
<td class="cellalignment1633" headers="r9c1-t5 r1c2-t5">INTEGER*4 var(n)</td>
<td class="cellalignment1633" headers="r9c1-t5 r1c3-t5">addresses of select-list or bind-variable values</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r10c1-t5" headers="r1c1-t5">I</td>
<td class="cellalignment1633" headers="r10c1-t5 r1c2-t5">INTEGER*4 var(n)</td>
<td class="cellalignment1633" headers="r10c1-t5 r1c3-t5">addresses of indicator-variable values (1)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r11c1-t5" headers="r1c1-t5">X (2)</td>
<td class="cellalignment1633" headers="r11c1-t5 r1c2-t5">INTEGER*4 var(n)</td>
<td class="cellalignment1633" headers="r11c1-t5 r1c3-t5">addresses of indicator-variable names (1)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r12c1-t5" headers="r1c1-t5">Y (2)</td>
<td class="cellalignment1633" headers="r12c1-t5 r1c2-t5">INTEGER*2 var(n)</td>
<td class="cellalignment1633" headers="r12c1-t5 r1c3-t5">maximum lengths of indicator-variable names (1)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r13c1-t5" headers="r1c1-t5">Z (2)</td>
<td class="cellalignment1633" headers="r13c1-t5 r1c2-t5">INTEGER*2 var(n)</td>
<td class="cellalignment1633" headers="r13c1-t5 r1c3-t5">actual lengths of indicator-variable names (1)</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
1. Indicator-variable names apply only in a bind SQLDA.
<p>2. These suffixes apply only to bind variables.</p>
</div>
<div class="inftblinformal">
<table class="cellalignment1638" title="SQLDA variables" summary="SQLDA variables" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t7">Buffer</th>
<th class="cellalignment1639" id="r1c2-t7">Host Datatype</th>
<th class="cellalignment1639" id="r1c3-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t7" headers="r1c1-t7">SELSB</td>
<td class="cellalignment1633" headers="r2c1-t7 r1c2-t7">LOGICAL*1 var(m,n)</td>
<td class="cellalignment1633" headers="r2c1-t7 r1c3-t7">select-list names</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t7" headers="r1c1-t7">SELVB</td>
<td class="cellalignment1633" headers="r3c1-t7 r1c2-t7">LOGICAL*1 var(m,n)</td>
<td class="cellalignment1633" headers="r3c1-t7 r1c3-t7">select-list names</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t7" headers="r1c1-t7">SELIV</td>
<td class="cellalignment1633" headers="r4c1-t7 r1c2-t7">INTEGER*2 var(n)</td>
<td class="cellalignment1633" headers="r4c1-t7 r1c3-t7">indicator-variable values</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t7" headers="r1c1-t7">BNDSB</td>
<td class="cellalignment1633" headers="r5c1-t7 r1c2-t7">LOGICAL*1 var(m,n)</td>
<td class="cellalignment1633" headers="r5c1-t7 r1c3-t7">placeholder names</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t7" headers="r1c1-t7">BNDVB</td>
<td class="cellalignment1633" headers="r6c1-t7 r1c2-t7">LOGICAL*1 var(m,n)</td>
<td class="cellalignment1633" headers="r6c1-t7 r1c3-t7">bind-variable values</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r7c1-t7" headers="r1c1-t7">BNDXB</td>
<td class="cellalignment1633" headers="r7c1-t7 r1c2-t7">LOGICAL*1 var(m,n)</td>
<td class="cellalignment1633" headers="r7c1-t7 r1c3-t7">indicator-variable names</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r8c1-t7" headers="r1c1-t7">BNDIV</td>
<td class="cellalignment1633" headers="r8c1-t7 r1c2-t7">INTEGER*2 var(n)</td>
<td class="cellalignment1633" headers="r8c1-t7 r1c3-t7">indicator-variable names</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
There is no SELXB buffer because indicator-variable names cannot be associated with select-list items.</div>
</div>
<!-- class="sect2" -->
<div id="ZZFOR255" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref116"></a>
<h3 class="sect2">Declaring a SQLDA</h3>
<p>To declare select and bind SQLDAs, you can hardcode them into your program using the sample SQLDA shown in <a href="#BCEHGBJI">Figure 4-1</a>.</p>
<div id="ZZFOR256" class="figure">
<p class="titleinfigure"><a id="BCEHGBJI"></a>Figure 4-1 Sample Pro*FORTRAN SQLDA Variables and Data Buffers</p>
<img width="536" height="769" src="img/image004.gif" alt="Sample SQLDA Variables and Data Buffers"/><br/>
<a id="sthref117" href="img_text/image004.htm">Description of &#34;Figure 4-1 Sample Pro*FORTRAN SQLDA Variables and Data Buffers&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>You can modify the array dimensions to suit your needs. The following example uses a parameter to specify array dimensions; which makes changing the dimensions easy:</p>
<pre>INTEGER SIZE
* Set dimension of descriptor arrays.
 PARAMETER (SIZE = 25)
* Declare select descriptor.
 INTEGER SELN
 INTEGER SELF
 INTEGER*4 SELV(SIZE)
 INTEGER*4 SELL(SIZE)
 ...
</pre>
<p>You might want to store the SQLDAs in files (named SELDSC and BNDDSC, for example), revise them as needed, then copy the files into your program with the INCLUDE statement as follows:</p>
<pre>* Declare select and bind SQLDAs.
 EXEC SQL INCLUDE SELDSC
 EXEC SQL INCLUDE BNDDSC
</pre>
<p>Because they are COMMON blocks, SQLDAs must be declared <span class="italic">outside</span> the Declare Section. How the data buffers are declared is up to you. You need not include them in the SQLDA COMMON blocks. For example, you might want to declare one large data buffer to store all names and values, then access them using byte offsets.</p>
<p><a href="#BCEEGFAD">Figure 4-2</a> shows whether variables are set by SQLADR calls, DESCRIBE commands, FETCH commands, or program assignments.</p>
<div id="ZZFOR257" class="figure">
<p class="titleinfigure"><a id="BCEEGFAD"></a>Figure 4-2 How Variables Are Set</p>
<img width="536" height="540" src="img/image005.gif" alt="How Variables Are Set"/><br/>
<a id="sthref118" href="img_text/image005.htm">Description of &#34;Figure 4-2 How Variables Are Set&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABHAJCG"></a>
<div id="ZZFOR258" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the SQLDA Variables and Arrays</h2>
<p>This section explains the purpose and use of each SQLDA variable. In examples, the arbitrary SQLDA file names, descriptor names, and data buffer names given earlier are used.</p>
<div id="ZZFOR259" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref119"></a>
<h3 class="sect2">The N Variable</h3>
<p>This variable specifies the maximum number of select-list items or placeholders that can be DESCRIBEd. For example, SELN determines the number of elements in the select descriptor arrays.</p>
<p>Before issuing a DESCRIBE command, you must set this variable to the dimension of the descriptor arrays. After the DESCRIBE, you must reset it to the actual number of variables DESCRIBEd, which is stored in the F variable.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR260" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref120"></a>
<h3 class="sect2">The F Variable</h3>
<p>This is the actual number of select-list items or placeholders found by the DESCRIBE command.</p>
<p>The F variable is set by DESCRIBE. If the F variable is negative, the DESCRIBE command found too many select-list items or placeholders for the size of the descriptor. For example, if you set SELN to 10 but DESCRIBE finds 11 select-list items, SELF is set to -11. If this happens, you cannot process the SQL statement without reallocating the descriptor.</p>
<p>After the DESCRIBE command, you must set the N variable equal to the F variable.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR261" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref121"></a>
<h3 class="sect2">The S Array</h3>
<p>This array contains the addresses of data buffers that store select-list or placeholder names as they appear in dynamic SQL statements.</p>
<p>You must set the elements of the S array using SQLADR before issuing the DESCRIBE command.</p>
<p>DESCRIBE directs Oracle to store the name of the Jth select-list item or placeholder in the buffer addressed by SELS(J) or BNDS(J). If the elements of SELS and BNDS address elements of data buffer arrays named SELSB and BNDSB, Oracle stores the Jth select-list or placeholder name in SELSB(J) or BNDSB(J).</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR262" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref122"></a>
<h3 class="sect2">The M Array</h3>
<p>This array contains the lengths of the data buffers that store select-list or placeholder names. The buffers are addressed by elements of the S array.</p>
<p>You must set the elements of the M array before issuing the DESCRIBE command. Each select-list or placeholder name buffer can have a different length.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR263" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref123"></a>
<h3 class="sect2">The C Array</h3>
<p>This array contains the actual lengths of select-list or placeholder names. DESCRIBE sets the array of actual lengths to the number of characters in each select-list or placeholder name.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR264" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref124"></a>
<h3 class="sect2">The L Array</h3>
<p>This array contains the lengths of select-list or bind-variable values stored in the data buffers.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR265" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref125"></a>
<h3 class="sect2">Select Descriptors</h3>
<p>DESCRIBE sets the array of lengths to the maximum expected for each select-list item. However, you might want to reset some lengths before issuing a FETCH command. FETCH returns at most <span class="italic">n</span> characters, where <span class="italic">n</span> is the value of SELL(J) before the FETCH.</p>
<p>The format of the length differs among Oracle datatypes. For character select-list items, DESCRIBE sets SELL(J) to the maximum length in bytes of the select-list item. For NUMBER select-list items, scale and precision are returned respectively in the low and next-higher bytes of the variable. You can use the library subroutine SQLPRC to extract precision and scale values from SELL. See the section Extracting Precision and Scale.</p>
<p>You must reset SELL(J) to the required length of the data buffer before the FETCH. For example, when coercing a NUMBER to a FORTRAN CHARACTER string, set SELL(J) to the precision of the number plus two for the sign and decimal point. When coercing a NUMBER to a FORTRAN REAL, set SELL(J) to the length of REALs on your system. For more information about the lengths of coerced datatypes, see the section &#34;Converting Data&#34;.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR266" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref126"></a>
<h3 class="sect2">Bind Descriptors</h3>
<p>You must set the array of lengths before issuing the OPEN command.</p>
<p>Because Oracle accesses a data buffer indirectly, using the address in SELV(J) or BNDV(J), it does not know the length of the value in that buffer. If you want to change the length Oracle uses for the Jth select-list or bind-variable value, reset SELL(J) or BNDL(J) to the length you need. Each input or output buffer can have a different length.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR267" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref127"></a>
<h3 class="sect2">The T Array</h3>
<p>This array contains the datatype codes of select-list or bind-variable values. These codes determine how Oracle data is converted when stored in the data buffers addressed by elements of SELV. This topic is covered in the section &#34;Converting Data&#34;.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR268" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref128"></a>
<h3 class="sect2">Select Descriptors</h3>
<p>DESCRIBE sets the array of datatype codes to the <span class="italic">internal</span> datatype (for example, VARCHAR2, CHAR, NUMBER, or DATE) of the items in the select list.</p>
<p>Before FETCHing, you might want to reset some datatypes because the internal format of Oracle datatypes can be difficult to handle. For display purposes, it is usually a good idea to coerce the datatype of select-list values to VARCHAR2. For calculations, you might want to coerce numbers from Oracle to FORTRAN format. See the section &#34;Coercing Datatypes&#34;.</p>
<p>The high bit of SELT(J) is set to indicate the null/not null status of the Jth select-list column. You must always clear this bit before issuing an OPEN or FETCH command. You use the library subroutine SQLNUL to retrieve the datatype code and clear the null/not null bit. See the section &#34;Handling Null/Not Null Datatypes&#34;.</p>
<p>You should change the Oracle NUMBER internal datatype to an external datatype compatible with that of the FORTRAN data buffer addressed by SELV(J).</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR269" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref129"></a>
<h3 class="sect2">Bind Descriptors</h3>
<p>DESCRIBE sets the array of datatype codes to zeros. You must reset the datatype code stored in each element before issuing the OPEN command. The code represents the external (FORTRAN) datatype of the data buffer addressed by BNDV(J). Often, bind-variable values are stored in character strings, so the datatype array elements are set to 1 (the VARCHAR2 datatype code).</p>
<p>To change the datatype of the Jth select-list or bind-variable value, reset SELT(J) or BNDT(J) to the datatype you want.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR270" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref130"></a>
<h3 class="sect2">The V Array</h3>
<p>This array contains the addresses of data buffers that store select-list or bind-variable values. You must set the elements of the V array using SQLADR.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR271" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref131"></a>
<h3 class="sect2">Select Descriptors</h3>
<p>You must set this array before issuing the FETCH command. The following statement</p>
<pre>* Fetch select-list values.
 EXEC SQL FETCH ... USING DESCRIPTOR SEL
</pre>
<p>directs Oracle to store FETCHed select-list values in the data buffers addressed by SELV(1) through SELV(SELN). If the elements of SELV address elements of a data buffer array named SELVB, Oracle stores the Jth select-list value in SELVB(J).</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR272" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref132"></a>
<h3 class="sect2">Bind Descriptors</h3>
<p>You must set this array before issuing the OPEN command. The following statement</p>
<pre>* Open cursor.
 EXEC SQL OPEN ... USING DESCRIPTOR BND
</pre>
<p>directs Oracle to execute the dynamic SQL statement using the bind-variable values addressed by BNDV(1) through BNDV(BNDN). If the elements of BNDV address elements of a data buffer array named BNDVB, Oracle finds the Jth bind-variable value in data buffer BNDVB(J).</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR273" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref133"></a>
<h3 class="sect2">The I Array</h3>
<p>This array contains the addresses of data buffers that store indicator-variable values.</p>
<p>You must set the elements of the I array using SQLADR.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR274" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref134"></a>
<h3 class="sect2">Select Descriptors</h3>
<p>You must set this array before issuing the FETCH command. When Oracle executes the statement</p>
<pre>* Fetch select-list values.
 EXEC SQL FETCH ... USING DESCRIPTOR SEL
</pre>
<p>if the Jth returned select-list value is null, the buffer addressed by SELI(J) is set to -1. Otherwise, it is set to zero (the value is not null) or a positive integer (the value was truncated). For example, if the elements of SELI address elements of a data buffer array named SELIV, and the Jth returned select-list value is null, SELIV(J) is set to -1.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR275" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref135"></a>
<h3 class="sect2">Bind Descriptors</h3>
<p>You must initialize this array and set the associated indicator variables before issuing the OPEN command. When Oracle executes the following statement</p>
<pre>* Open cursor.
 EXEC SQL OPEN ... USING DESCRIPTOR BND
</pre>
<p>the buffer addressed by BNDI(J) determines whether the Jth bind variable is a null. If the value of an indicator variable is -1, its associated host variable is null. For example, if the elements of BNDI address elements of a data buffer array named BNDIV, and the value of BNDIV(J) is -1, the value of the Jth bind variable is set to NULL.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR276" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref136"></a>
<h3 class="sect2">The X Array</h3>
<p>This array contains the addresses of data buffers that store indicator-variable names. You can associate indicator-variable <span class="italic">values</span> with select-list items and bind variables. However, you can associate indicator-variable <span class="italic">names</span> only with bind variables. So, you can use the X array only with bind descriptors.</p>
<p>You must set the elements of the X array using SQLADR before issuing the DESCRIBE command.</p>
<p>DESCRIBE directs Oracle to store any indicator-variable names in the buffers addressed by BNDX(1) through BNDX(BNDN). If the elements of BNDX address elements of a data buffer array named BNDXB, Oracle stores the Jth indicator-variable name in BNDXB(J).</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR277" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref137"></a>
<h3 class="sect2">The Y Array</h3>
<p>This array contains the maximum lengths of the data buffers that store indicator-variable names. The buffers are addressed by elements of the X array. Like the X array, you can use the Y array only with bind descriptors.</p>
<p>You must set the elements BNDY(1) through BNDY(BNDN) before issuing the DESCRIBE command. Each indicator-variable name buffer can have a different length.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR278" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref138"></a>
<h3 class="sect2">The Z Array</h3>
<p>This array contains the actual lengths of indicator-variable names. Like the X and Y arrays, you can use the Z array only with bind descriptors.</p>
<p>DESCRIBE sets the array of actual lengths to the number of characters in each indicator-variable name.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDBIIJ"></a>
<div id="ZZFOR279" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Some Preliminaries</h2>
<p>You need a working knowledge of the following subjects to implement dynamic SQL Method 4:</p>
<ul>
<li>
<p>using the library subroutine SQLADR</p>
</li>
<li>
<p>converting data</p>
</li>
<li>
<p>coercing datatypes</p>
</li>
<li>
<p>handling null/not null datatypes</p>
</li>
</ul>
<a id="BABIEGGE"></a>
<div id="ZZFOR280" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using SQLADR</h3>
<p>You must call the library subroutine SQLADR to get the addresses of data buffers that store input and output values. You store the addresses in a select or bind SQLDA so that Oracle knows where to read bind-variable values or write select-list values.</p>
<p>Call SQLADR using the syntax</p>
<pre>CALL SQLADR (BUFF, ADDR)
</pre>
<p>where:</p>
<p>BUFF</p>
<p>Is a data buffer that stores the value or name of a select-list item, bind variable, or indicator variable.</p>
<p>ADDR</p>
<p>Is an integer variable that returns the address of the data buffer.</p>
<p>A call to SQLADR stores the address of BUFF in ADDR. In the following example, you use SQLADR to initialize the select descriptor arrays SELV, SELS, and SELI. Their elements address data buffers for select-list values, select-list names, and indicator values.</p>
<pre>* Initialize select descriptor arrays.
 DO 100 J = 1, SELN
 CALL SQLADR (SELVB(1, J), SELV(J))
 CALL SQLADR (SELSB(1, J), SELS(J))
 CALL SQLADR (SELIV(J), SELI(J))
100 CONTINUE
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR281" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref139"></a>
<h3 class="sect2">Restriction</h3>
<p>You cannot use CHARACTER variables with SQLADR if your FORTRAN compiler generates descriptors for CHARACTER variables and passes the descriptor address (rather than the data address) to SQLADR. Check your FORTRAN compiler user&#39;s guide. In such cases, SQLADR gets the wrong address. Instead, use LOGICAL*1 variables, because they always have simple addresses.</p>
<p>However, you can (cautiously) use SQLADR with CHARACTER variables if your compiler provides a built-in function to access the data address. For example, if your compiler provides a function named %REF, and X is a CHARACTER variable, you call SQLADR as follows:</p>
<pre>* Use %REF built-in function.
 CALL SQLADR (%REF(X), ...)
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR282" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref140"></a>
<h3 class="sect2">Converting Data</h3>
<p>This section provides more detail about the datatype descriptor array. In host programs that use neither datatype equivalencing nor dynamic SQL Method 4, the conversion between Oracle internal and external datatypes is determined at precompile time. By default, the precompiler assigns a specific external datatype to each host variable in the Declare Section. For example, the precompiler assigns the FLOAT external datatype to host variables of type REAL.</p>
<p>However, Method 4 lets you control data conversion and formatting. You specify conversions by setting datatype codes in the datatype descriptor array.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR283" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref141"></a>
<h3 class="sect2">Internal Datatypes</h3>
<p>Internal datatypes specify the formats used by Oracle to store column values in database tables and the formats to represent pseudocolumn values.</p>
<p>When you issue a DESCRIBE SELECT LIST command, Oracle returns the internal datatype code for each select-list item to the SELT (datatype) descriptor array. For example, the datatype code for the Jth select-list item is returned to SELT(J).</p>
<p>The following table shows the Oracle internal datatypes and their codes.</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="internal datatypes and their codes" summary="internal datatypes and their codes" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t9">Oracle Internal Datatype</th>
<th class="cellalignment1639" id="r1c2-t9">Code</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t9" headers="r1c1-t9">VARCHAR2</td>
<td class="cellalignment1633" headers="r2c1-t9 r1c2-t9">1</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t9" headers="r1c1-t9">NUMBER</td>
<td class="cellalignment1633" headers="r3c1-t9 r1c2-t9">2</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t9" headers="r1c1-t9">LONG</td>
<td class="cellalignment1633" headers="r4c1-t9 r1c2-t9">8</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t9" headers="r1c1-t9">ROWID</td>
<td class="cellalignment1633" headers="r5c1-t9 r1c2-t9">11</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t9" headers="r1c1-t9">DATE</td>
<td class="cellalignment1633" headers="r6c1-t9 r1c2-t9">12</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r7c1-t9" headers="r1c1-t9">RAW</td>
<td class="cellalignment1633" headers="r7c1-t9 r1c2-t9">23</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r8c1-t9" headers="r1c1-t9">LONG RAW</td>
<td class="cellalignment1633" headers="r8c1-t9 r1c2-t9">24</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r9c1-t9" headers="r1c1-t9">CHAR</td>
<td class="cellalignment1633" headers="r9c1-t9 r1c2-t9">96</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r10c1-t9" headers="r1c1-t9">MLSLABEL</td>
<td class="cellalignment1633" headers="r10c1-t9 r1c2-t9">105</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<div id="ZZFOR284" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref142"></a>
<h3 class="sect2">External Datatypes</h3>
<p>External datatypes specify the formats used to store values in input and output host variables.</p>
<p>The DESCRIBE BIND VARIABLES command sets the BNDT array of datatype codes to zeros. So, you must reset the codes <span class="italic">before</span> issuing the OPEN command. The codes tell Oracle which external datatypes to expect for the various bind variables. For the Jth bind variable, reset BNDT(J) to the external datatype you want.</p>
<p>The following table shows the Oracle external datatypes and their codes, as well as the corresponding FORTRAN datatypes:</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="internal data types and FORTRAN data types" summary="internal data types and FORTRAN data types" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t10">Name</th>
<th class="cellalignment1639" id="r1c2-t10">Code</th>
<th class="cellalignment1639" id="r1c3-t10">FORTRAN Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t10" headers="r1c1-t10">VARCHAR2</td>
<td class="cellalignment1633" headers="r2c1-t10 r1c2-t10">1</td>
<td class="cellalignment1633" headers="r2c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span> when MODE != ANSI</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t10" headers="r1c1-t10">NUMBER</td>
<td class="cellalignment1633" headers="r3c1-t10 r1c2-t10">2</td>
<td class="cellalignment1633" headers="r3c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t10" headers="r1c1-t10">INTEGER</td>
<td class="cellalignment1633" headers="r4c1-t10 r1c2-t10">3</td>
<td class="cellalignment1633" headers="r4c1-t10 r1c3-t10">INTEGER</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t10" headers="r1c1-t10">FLOAT</td>
<td class="cellalignment1633" headers="r5c1-t10 r1c2-t10">4</td>
<td class="cellalignment1633" headers="r5c1-t10 r1c3-t10">REAL</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t10" headers="r1c1-t10">STRING (1)</td>
<td class="cellalignment1633" headers="r6c1-t10 r1c2-t10">5</td>
<td class="cellalignment1633" headers="r6c1-t10 r1c3-t10">CHARACTER*(<span class="italic">n</span>+1)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r7c1-t10" headers="r1c1-t10">VARNUM</td>
<td class="cellalignment1633" headers="r7c1-t10 r1c2-t10">6</td>
<td class="cellalignment1633" headers="r7c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r8c1-t10" headers="r1c1-t10">DECIMAL</td>
<td class="cellalignment1633" headers="r8c1-t10 r1c2-t10">7</td>
<td class="cellalignment1633" headers="r8c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r9c1-t10" headers="r1c1-t10">LONG</td>
<td class="cellalignment1633" headers="r9c1-t10 r1c2-t10">8</td>
<td class="cellalignment1633" headers="r9c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r10c1-t10" headers="r1c1-t10">VARCHAR (2)</td>
<td class="cellalignment1633" headers="r10c1-t10 r1c2-t10">9</td>
<td class="cellalignment1633" headers="r10c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r11c1-t10" headers="r1c1-t10">ROWID</td>
<td class="cellalignment1633" headers="r11c1-t10 r1c2-t10">11</td>
<td class="cellalignment1633" headers="r11c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r12c1-t10" headers="r1c1-t10">DATE</td>
<td class="cellalignment1633" headers="r12c1-t10 r1c2-t10">12</td>
<td class="cellalignment1633" headers="r12c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r13c1-t10" headers="r1c1-t10">VARRAW (2)</td>
<td class="cellalignment1633" headers="r13c1-t10 r1c2-t10">15</td>
<td class="cellalignment1633" headers="r13c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r14c1-t10" headers="r1c1-t10">RAW</td>
<td class="cellalignment1633" headers="r14c1-t10 r1c2-t10">23</td>
<td class="cellalignment1633" headers="r14c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r15c1-t10" headers="r1c1-t10">LONG RAW</td>
<td class="cellalignment1633" headers="r15c1-t10 r1c2-t10">24</td>
<td class="cellalignment1633" headers="r15c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r16c1-t10" headers="r1c1-t10">UNSIGNED</td>
<td class="cellalignment1633" headers="r16c1-t10 r1c2-t10">68</td>
<td class="cellalignment1633" headers="r16c1-t10 r1c3-t10">INTEGER</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r17c1-t10" headers="r1c1-t10">DISPLAY</td>
<td class="cellalignment1633" headers="r17c1-t10 r1c2-t10">91</td>
<td class="cellalignment1633" headers="r17c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r18c1-t10" headers="r1c1-t10">LONG VARCHAR (2)</td>
<td class="cellalignment1633" headers="r18c1-t10 r1c2-t10">94</td>
<td class="cellalignment1633" headers="r18c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r19c1-t10" headers="r1c1-t10">LONG VARRAW (2)</td>
<td class="cellalignment1633" headers="r19c1-t10 r1c2-t10">95</td>
<td class="cellalignment1633" headers="r19c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r20c1-t10" headers="r1c1-t10">CHARF</td>
<td class="cellalignment1633" headers="r20c1-t10 r1c2-t10">96</td>
<td class="cellalignment1633" headers="r20c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span> when MODE = ANSI</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r21c1-t10" headers="r1c1-t10">CHARZ (1)</td>
<td class="cellalignment1633" headers="r21c1-t10 r1c2-t10">97</td>
<td class="cellalignment1633" headers="r21c1-t10 r1c3-t10">CHARACTER*(<span class="italic">n</span>+1)</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r22c1-t10" headers="r1c1-t10">CURSOR</td>
<td class="cellalignment1633" headers="r22c1-t10 r1c2-t10">102</td>
<td class="cellalignment1633" headers="r22c1-t10 r1c3-t10">SQLCURSOR</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r23c1-t10" headers="r1c1-t10">MLSLABEL</td>
<td class="cellalignment1633" headers="r23c1-t10 r1c2-t10">106</td>
<td class="cellalignment1633" headers="r23c1-t10 r1c3-t10">CHARACTER*<span class="italic">n</span></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
1. For use in an EXEC SQL VAR statement only.
<p>2. Include the <span class="italic">n</span>-byte length field.</p>
</div>
<p>For more information about the Oracle datatypes and their formats, see Chapter 3 of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR285" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref143"></a>
<h3 class="sect2">PL/SQL Datatypes</h3>
<p>PL/SQL provides a variety of predefined scalar and composite datatypes. A <span class="italic">scalar</span> type has no internal components. A <span class="italic">composite</span> type has internal components that can be manipulated individually. The following table shows the predefined PL/SQL scalar datatypes and their Oracle internal datatype equivalences.</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="predefined PL/SQL scalar datatypes" summary="predefined PL/SQL scalar datatypes" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t12">PL/SQL Datatype</th>
<th class="cellalignment1639" id="r1c2-t12">Oracle Internal Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t12" headers="r1c1-t12">VARCHAR VARCHAR2</td>
<td class="cellalignment1633" headers="r2c1-t12 r1c2-t12">VARCHAR2</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t12" headers="r1c1-t12">BINARY_INTEGER DEC DECIMAL DOUBLE PRECISION FLOAT INT INTEGER NATURAL NUMBER NUMERIC POSITIVE REAL SMALLINT</td>
<td class="cellalignment1633" headers="r3c1-t12 r1c2-t12">NUMBER</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t12" headers="r1c1-t12">LONG</td>
<td class="cellalignment1633" headers="r4c1-t12 r1c2-t12">LONG</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t12" headers="r1c1-t12">ROWID</td>
<td class="cellalignment1633" headers="r5c1-t12 r1c2-t12">ROWID</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r6c1-t12" headers="r1c1-t12">DATE</td>
<td class="cellalignment1633" headers="r6c1-t12 r1c2-t12">DATE</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r7c1-t12" headers="r1c1-t12">RAW</td>
<td class="cellalignment1633" headers="r7c1-t12 r1c2-t12">RAW</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r8c1-t12" headers="r1c1-t12">LONG RAW</td>
<td class="cellalignment1633" headers="r8c1-t12 r1c2-t12">LONG RAW</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r9c1-t12" headers="r1c1-t12">CHAR CHARACTER STRING</td>
<td class="cellalignment1633" headers="r9c1-t12 r1c2-t12">CHAR</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r10c1-t12" headers="r1c1-t12">MLSLABEL</td>
<td class="cellalignment1633" headers="r10c1-t12 r1c2-t12">MLSLABEL</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<div id="ZZFOR286" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref144"></a>
<h3 class="sect2">Coercing Datatypes</h3>
<p>For a select descriptor, DESCRIBE SELECT LIST can return any of the Oracle internal datatypes. Often, as in the case of character data, the internal datatype corresponds exactly to the external datatype you want to use. However, a few internal datatypes map to external datatypes that can be difficult to handle. So, you might want to reset some elements in the SELT descriptor array.</p>
<p>For example, you might want to reset NUMBER values to FLOAT values, which correspond to REAL values in FORTRAN. Oracle does any necessary conversion between internal and external datatypes at FETCH time. So, be sure to reset the datatypes <span class="italic">after</span> the DESCRIBE SELECT LIST but <span class="italic">before</span> the FETCH.</p>
<p>For a bind descriptor, DESCRIBE BIND VARIABLES does <span class="italic">not</span> return the datatypes of bind variables, only their number and names. Therefore, you must explicitly set the BNDT array of datatype codes to tell Oracle the external datatype of each bind variable. Oracle does any necessary conversion between external and internal datatypes at OPEN time.</p>
<p>When you reset datatype codes in the SELT or BNDT descriptor array, you are &#34;coercing datatypes.&#34; For example, to coerce the Jth select-list value to VARCHAR2, use the following statement:</p>
<pre>* Coerce select-list value to VARCHAR2.
 SELT(J) = 1
</pre>
<p>When coercing a NUMBER select-list value to VARCHAR2 for display purposes, you must also extract the precision and scale bytes of the value and use them to compute a maximum display length. Then, before the FETCH, you must reset the appropriate element of the SELL (length) descriptor array to tell Oracle the buffer length to use. To specify the length of the Jth select-list value, set SELL(J) to the length you need.</p>
<p>For example, if DESCRIBE SELECT LIST finds that the Jth select-list item is of type NUMBER, and you want to store the returned value in a FORTRAN variable declared as REAL, simply set SELT(J) to 4 and SELL(J) to the length of REAL numbers on your system.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR287" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref145"></a>
<h3 class="sect2">Exceptions</h3>
<p>In some cases, the internal datatypes that DESCRIBE SELECT LIST returns might not suit your purposes. Two examples of this are DATE and NUMBER. When you DESCRIBE a DATE select-list item, Oracle returns the datatype code 12 to the SELT array. Unless you reset the code before the FETCH, the date value is returned in its 7-byte internal format. To get the date in its default character format, you must change the datatype code from 12 to 1 (VARCHAR2), and increase the SELL value from 7 to 9.</p>
<p>Similarly, when you DESCRIBE a NUMBER select-list item, Oracle returns the datatype code 2 to the SELT array. Unless you reset the code before the FETCH, the numeric value is returned in its internal format, which is probably not what you want. So, change the code from 2 to 1 (VARCHAR2), 3 (INTEGER), 4 (FLOAT), or some other appropriate datatype.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR288" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref146"></a>
<h3 class="sect2">Extracting Precision and Scale</h3>
<p>The library subroutine SQLPRC extracts precision and scale. Normally, it is used after the DESCRIBE SELECT LIST, and its first argument is SELL(J). You call SQLPRC using the syntax</p>
<pre>CALL SQLPRC (LENGTH, PREC, SCALE)
</pre>
<p>where:</p>
<p>LENGTH</p>
<p>Is an integer variable that stores the length of an Oracle NUMBER value. The scale and precision of the value are stored in the low and next-higher bytes, respectively.</p>
<p>PREC</p>
<p>Is an integer variable that returns the <span class="italic">precision</span> of the NUMBER value. Precision is the number of significant digits. It is set to zero if the select-list item refers to a NUMBER of unspecified size. In this case, because the size is unspecified, you might want to assume the maximum precision, 38.</p>
<p>SCALE</p>
<p>Is an integer variable that returns the <span class="italic">scale</span> of the NUMBER value. Scale specifies where rounding will occur. For example, a scale of 2 means the value is rounded to the nearest hundredth (3.456 becomes 3.46); a scale of -3 means the number is rounded to the nearest thousand (3456 becomes 3000).</p>
<p>The following example shows how SQLPRC is used to compute maximum display lengths for NUMBER values that will be coerced to VARCHAR2:</p>
<pre>* Declare variables for function call.
 INTEGER PREC
 INTEGER SCALE
 EXEC SQL DESCRIBE SELECT LIST FOR S INTO SEL
 DO 1300 J = 1, SELN
 IF (SELT(J) .NE. 2) GOTO 1300
* If datatype is NUMBER, extract precision and scale.
 CALL SQLPRC (SELL(J), PREC, SCALE)
* If no precision was specified, assign a maximum.
 IF (PREC .NE. 0) GOTO 1100
 SELL(J) = 10
 GOTO 1300
 1100 CONTINUE
 SELL(J) = PREC
* Allow for possible sign and decimal point.
 SELL(J) = SELL(J) + 2
 1300 CONTINUE
 ...
</pre>
<p>The SQLPRC subroutine returns zero as the precision and scale values for certain SQL datatypes. The SQLPR2 subroutine is similar to SQLPRC in that it has the same syntax and returns the same binary values, except for the datatypes shown in the following table.</p>
<div class="inftblinformal">
<table class="cellalignment1638" title="datatypes" summary="datatypes" dir="ltr">
<thead>
<tr class="cellalignment1627">
<th class="cellalignment1639" id="r1c1-t13">SQL Datatype</th>
<th class="cellalignment1639" id="r1c2-t13">Binary Precision</th>
<th class="cellalignment1639" id="r1c3-t13">Binary Scale</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r2c1-t13" headers="r1c1-t13">FLOAT</td>
<td class="cellalignment1633" headers="r2c1-t13 r1c2-t13">126</td>
<td class="cellalignment1633" headers="r2c1-t13 r1c3-t13">-127</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r3c1-t13" headers="r1c1-t13">FLOAT(<span class="italic">n</span>)</td>
<td class="cellalignment1633" headers="r3c1-t13 r1c2-t13"><span class="italic">n</span> (range is 1 .. 126)</td>
<td class="cellalignment1633" headers="r3c1-t13 r1c3-t13">-127</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r4c1-t13" headers="r1c1-t13">REAL</td>
<td class="cellalignment1633" headers="r4c1-t13 r1c2-t13">63</td>
<td class="cellalignment1633" headers="r4c1-t13 r1c3-t13">-127</td>
</tr>
<tr class="cellalignment1627">
<td class="cellalignment1633" id="r5c1-t13" headers="r1c1-t13">DOUBLE PRECISION</td>
<td class="cellalignment1633" headers="r5c1-t13 r1c2-t13">126</td>
<td class="cellalignment1633" headers="r5c1-t13 r1c3-t13">-127</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<div id="ZZFOR289" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref147"></a>
<h3 class="sect2">Handling Null/Not Null Datatypes</h3>
<p>For every select-list column (not expression), DESCRIBE SELECT LIST returns a null/not null indication in the datatype array (SELT) of the select descriptor. If the Jth select-list column is constrained to be not null, the high-order bit of SELT(J) is clear; otherwise, it is set.</p>
<p>Before using the datatype in an OPEN or FETCH statement, if the null status bit is set, you must clear it. Never set the bit.</p>
<p>You can use the library subroutine SQLNUL to find out if a column allows nulls, and to clear the datatype&#39;s null status bit. You call SQLNUL using the syntax</p>
<pre>CALL SQLNUL (VALTYP, TYPCODE, NULSTAT)
</pre>
<p>where:</p>
<p>VALTYP</p>
<p>Is a 2-byte integer variable that stores the datatype code of a select-list column.</p>
<p>TYPCODE</p>
<p>Is a 2-byte integer variable that returns the datatype code of the select-list column with the high-order bit cleared.</p>
<p>NULSTAT</p>
<p>Is an integer variable that returns the null status of the select-list column. 1 means the column allows nulls; 0 means it does not.</p>
<p>The following example shows how to use SQLNUL:</p>
<pre>* Declare variable for subroutine call.
 INTEGER*2 DATYPE
 INTEGER NULLOK
 DO 1500 J = 1, SELN
* Find out if column is NOT NULL, and
* clear high-order bit.
 CALL SQLNUL (SELT(J), DATYPE, NULLOK)
 SELT(J) = DATYPE
* If NULLOK equals 1, nulls are allowed.
 ...
 1500 CONTINUE
 ...
</pre>
<p>The first argument in the subroutine is the Jth element of the SELT datatype array before its null/not null bit is cleared. Though some systems let you use SELT(J) as the second argument too, it is poor programming practice to use the same variable as multiple arguments.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABGGBEG"></a>
<div id="ZZFOR290" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">The Basic Steps</h2>
<p>Method 4 can be used to process <span class="italic">any</span> dynamic SQL statement. In the example, a query is processed so that you can see how both input and output host variables are handled. Again, the arbitrary SQLDA file names, descriptor names, and data buffer names given earlier are used.</p>
<p>To process the dynamic query, our sample program performs the following:</p>
<ol>
<li>
<p>Declare a host string in the Declare Section to hold the query text.</p>
</li>
<li>
<p>Declare select and bind descriptors.</p>
</li>
<li>
<p>Set the maximum number of select-list items and placeholders that can be DESCRIBEd.</p>
</li>
<li>
<p>Initialize the select and bind descriptors.</p>
</li>
<li>
<p>Store the query text in the host string.</p>
</li>
<li>
<p>PREPARE the query from the host string.</p>
</li>
<li>
<p>DECLARE a cursor FOR the query.</p>
</li>
<li>
<p>DESCRIBE the bind variables INTO the bind descriptor.</p>
</li>
<li>
<p>Reset the number of placeholders to the number actually found by the DESCRIBE command.</p>
</li>
<li>
<p>Get values for the bind variables found by DESCRIBE.</p>
</li>
<li>
<p>OPEN the cursor USING the bind descriptor.</p>
</li>
<li>
<p>DESCRIBE the select list INTO the select descriptor.</p>
</li>
<li>
<p>Reset the number of select-list items to the number actually found by the DESCRIBE command.</p>
</li>
<li>
<p>Reset the length and datatype of each select-list item for display purposes.</p>
</li>
<li>
<p>FETCH a row from the database INTO data buffers using the select descriptor.</p>
</li>
<li>
<p>Process the select-list values returned by FETCH.</p>
</li>
<li>
<p>CLOSE the cursor when there are no more rows to FETCH.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the dynamic SQL statement is <span class="italic">not</span> a query or contains a known number of select-list items or placeholders, then some of the steps are unnecessary.</div>
</div>
<!-- class="sect1" -->
<a id="BABHHGJH"></a>
<div id="ZZFOR291" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">A Closer Look at Each Step</h2>
<p>This section discusses each step in more detail. Also, at the end of this chapter is a full-length program illustrating Method 4.</p>
<p>With Method 4, you use the following sequence of embedded SQL statements:</p>
<pre>EXEC SQL
 PREPARE &lt;statement_name&gt;
 FROM {:&lt;host_string&gt;|&lt;string_literal&gt;}
EXEC SQL DECLARE &lt;cursor_name&gt; CURSOR FOR &lt;statement_name&gt;
EXEC SQL
 DESCRIBE BIND VARIABLES FOR &lt;statement_name&gt;
 INTO &lt;bind_descriptor_name&gt;
EXEC SQL
 OPEN &lt;cursor_name&gt;
 [USING DESCRIPTOR &lt;bind_descriptor_name&gt;]
EXEC SQL
 DESCRIBE [SELECT LIST FOR] &lt;statement_name&gt;
 INTO &lt;select_descriptor_name&gt;
EXEC SQL
 FETCH &lt;cursor_name&gt;
 USING DESCRIPTOR &lt;select_descriptor_name&gt;
EXEC SQL CLOSE &lt;cursor_name&gt;
</pre>
<p>If the number of select-list items in a dynamic query is known, you can omit DESCRIBE SELECT LIST and use the following Method 3 FETCH statement:</p>
<pre>EXEC SQL FETCH &lt;cursor_name&gt; INTO &lt;host_variable_list&gt;
</pre>
<p>If the number of placeholders for bind variables in a dynamic SQL statement is known, you can omit DESCRIBE BIND VARIABLES and use the following Method 3 OPEN statement:</p>
<pre>EXEC SQL OPEN &lt;cursor_name&gt; [USING &lt;host_variable_list&gt;]
</pre>
<p>Next, you see how these statements allow your host program to accept and process a dynamic SQL statement using descriptors.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Several figures accompany the following discussion. To avoid cluttering the figures, it was necessary to confine descriptor arrays to 3 elements and to limit the maximum length of names and values to 5 and 10 characters, respectively.</div>
<div id="ZZFOR292" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref148"></a>
<h3 class="sect2">Declare a Host String</h3>
<p>Your program needs a host variable to store the text of the dynamic SQL statement. The host variable (SELSTM in our example) must be declared as a character string.</p>
<pre>EXEC SQL BEGIN DECLARE SECTION
 ...
 CHARACTER*120 SELSTM
 EXEC SQL END DECLARE SECTION
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR293" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref149"></a>
<h3 class="sect2">Declare the SQLDAs</h3>
<p>Because the query in our example might contain an unknown number of select-list items or placeholders, you must declare select and bind descriptors. Instead of hard coding the SQLDAs, you use the INCLUDE statement to copy them into your program, as follows:</p>
<pre>EXEC SQL INCLUDE SELDSC
 EXEC SQL INCLUDE BNDDSC
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR294" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref150"></a>
<h3 class="sect2">Set the Maximum Number to DESCRIBE</h3>
<p>Next, you set the maximum number of select-list items or placeholders that can be DESCRIBEd, as follows:</p>
<pre>SELN = 3
BNDN = 3 
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR295" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref151"></a>
<h3 class="sect2">Initialize the Descriptors</h3>
<p>You must initialize several descriptor variables; some require the library subroutine SQLADR. In our example, you store the maximum lengths of name buffers in the M and Y arrays, and use SQLADR to store the addresses of value and name buffers in the V, S, I, and X arrays:</p>
<pre>* Initialize select descriptor arrays.
* Store addresses of select-list value and name
* buffers in SELV and SELS, addresses of indicator
* value buffers in SELI, and maximum length of
* select-list name buffers in SELM.
 DO 100 J = 1, SELN
 CALL SQLADR (SELVB(1, J), SELV(J))
 CALL SQLADR (SELSB(1, J), SELS(J))
 CALL SQLADR (SELIV(J), SELI(J))
 SELM(J) = 5
 100 CONTINUE
* Initialize bind descriptor arrays.
* Store addresses of bind-variable value and name
* buffers in BNDV and BNDS, addresses of indicator
* value and name buffers in BNDI and BNDX, and maximum
* lengths of placeholder and indicator name buffers in
* BNDM and BNDY.
 DO 200 J = 1, BNDN
 CALL SQLADR (BNDVB(1, J), BNDV(J))
 CALL SQLADR (BNDSB(1, J), BNDS(J))
 CALL SQLADR (BNDIV(J), BNDI(J))
 CALL SQLADR (BNDXB(1, J), BNDX(J))
 BNDM(J) = 5
 BNDY(J) = 5
 200 CONTINUE
 ...
</pre>
<p><a href="#BCEHCBFH">Figure 4-3</a> and <a href="#BCEGIIGF">Figure 4-4</a>represent the resulting descriptors.</p>
<div id="ZZFOR296" class="figure">
<p class="titleinfigure"><a id="BCEHCBFH"></a>Figure 4-3 Initialized Select Descriptor</p>
<img width="734" height="670" src="img/image006.gif" alt="Initialized Select Descriptor"/><br/>
<a id="sthref152" href="img_text/image006.htm">Description of &#34;Figure 4-3 Initialized Select Descriptor&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="ZZFOR297" class="figure">
<p class="titleinfigure"><a id="BCEGIIGF"></a>Figure 4-4 Initialized Bind Descriptor</p>
<img width="734" height="873" src="img/image007.gif" alt="Initialized Bind Descriptor"/><br/>
<a id="sthref153" href="img_text/image007.htm">Description of &#34;Figure 4-4 Initialized Bind Descriptor&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ZZFOR298" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref154"></a>
<h3 class="sect2">Store the Query Text in the Host String</h3>
<p>Continuing our example, you prompt the user for a SQL statement, then store the input string in SELSTM as follows:</p>
<pre>WRITE (*, 1900)
 1900 FORMAT (&#39; Enter query: &#39;)
 READ (*, 2000) SELSTM
 2000 FORMAT (A120)
</pre>
<p>We assume the user entered the following string:</p>
<pre>SELECT ENAME, EMPNO, COMM FROM EMP WHERE COMM &lt; :BONUS
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR299" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref155"></a>
<h3 class="sect2">PREPARE the Query from the Host String</h3>
<p>PREPARE parses the SQL statement and gives it a name. In our example, PREPARE parses the host string SELSTM and gives it the name DYNSTMT, as follows:</p>
<pre>EXEC SQL PREPARE DYNSTMT FROM :SELSTM
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR300" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref156"></a>
<h3 class="sect2">DECLARE a Cursor</h3>
<p>DECLARE CURSOR defines a cursor by giving it a name and associating it with a specific SELECT statement.</p>
<p>To declare a cursor for <span class="italic">static</span> queries, you use the following syntax:</p>
<pre>EXEC SQL DECLARE cursor_name CURSOR FOR SELECT ...
</pre>
<p>To declare a cursor for <span class="italic">dynamic</span> queries, you substitute the statement name given to the dynamic query by PREPARE for the static query. In our example, DECLARE CURSOR defines a cursor named EMPCUR and associates it with DYNSTMT, as follows:</p>
<pre>EXEC SQL DECLARE EMPCUR CURSOR FOR DYNSTMT
</pre>
<p><span class="bold">Note</span>: You must declare a cursor for all dynamic SQL statements, not just queries. With non-queries, OPENing the cursor executes the dynamic SQL statement.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR301" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref157"></a>
<h3 class="sect2">DESCRIBE the Bind Variables</h3>
<p>DESCRIBE BIND VARIABLES puts descriptions of bind variables into a bind descriptor. In our example, DESCRIBE readies BND as follows:</p>
<pre>EXEC SQL DESCRIBE BIND VARIABLES FOR DYNSTMT INTO BND 
</pre>
<p>The DESCRIBE BIND VARIABLES statement must follow the PREPARE statement but precede the OPEN statement.</p>
<p><a href="#BCEEIBJC">Figure 4-5</a> shows the bind descriptor in our example after the DESCRIBE. Notice that DESCRIBE has set BNDF to the actual number of placeholders found in the processed SQL statement.</p>
<div id="ZZFOR302" class="figure">
<p class="titleinfigure"><a id="BCEEIBJC"></a>Figure 4-5 Bind Descriptor after the DESCRIBE</p>
<img width="734" height="873" src="img/image008.gif" alt="Bind Descriptor after the DESCRIBE"/><br/>
<a id="sthref158" href="img_text/image008.htm">Description of &#34;Figure 4-5 Bind Descriptor after the DESCRIBE&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ZZFOR303" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref159"></a>
<h3 class="sect2">Reset Number of Placeholders</h3>
<p>Next, you must reset the maximum number of placeholders to the number actually found by DESCRIBE, as follows:</p>
<pre>BNDN = BNDF
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR304" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref160"></a>
<h3 class="sect2">Get Values for Bind Variables</h3>
<p>Your program must get values for the bind variables in the SQL statement. How the program gets the values is up to you. For example, they can be hard coded, read from a file, or entered interactively.</p>
<p>In our example, a value must be assigned to the bind variable that replaces the placeholder BONUS in the query&#39;s WHERE clause. Prompt the user for the value, then process it as follows:</p>
<pre>CHARACTER*1 COLON
 COLON = &#39;:&#39;
* BNDN was set equal to BNDF after the DESCRIBE.
 DO 500 J = 1, BNDN
* Prompt user for value of bind variable.
 WRITE (*, 10200) (BNDSB(K,J), K = 1, BNDC(J)), COLON
10200 FORMAT (1X, &#39;Enter value for &#39;, 6A1)
* Get value for bind variable.
 READ (*, 10300) (BNDVB(K,J), K = 1, 10)
10300 FORMAT (10A1)
* Find length of value by scanning backward for first
* non-blank character.
 DO 200 K = 1, 10
 IF (BNDVB(BNDL(J),J) .NE. &#39; &#39;) GOTO 300
 BNDL(J) = BNDL(J) - 1
 200 CONTINUE
* Set datatype of bind variable to VARCHAR2 (code 1), and set
* indicator variable to NOT NULL.
 300 BNDT(J) = 1
 BNDIV(J) = 0
 500 CONTINUE
</pre>
<p>Assuming that the user supplied a value of 625 for BONUS, <a href="#BCEJEDFF">Figure 4-6</a> shows the resulting bind descriptor.</p>
<div id="ZZFOR305" class="figure">
<p class="titleinfigure"><a id="BCEJEDFF"></a>Figure 4-6 Bind Descriptor After Assigning Values</p>
<img width="734" height="873" src="img/image009.gif" alt="Bind Descriptor After Assigning Values"/><br/>
<a id="sthref161" href="img_text/image009.htm">Description of &#34;Figure 4-6 Bind Descriptor After Assigning Values&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ZZFOR306" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref162"></a>
<h3 class="sect2">OPEN the Cursor</h3>
<p>The OPEN statement for dynamic queries is similar to the one for static queries, except the cursor is associated with a bind descriptor. Values determined at run time and stored in buffers addressed by elements of the bind descriptor arrays are used to evaluate the SQL statement. With queries, the values are also used to identify the active set.</p>
<p>In our example, OPEN associates EMPCUR with BND as follows:</p>
<pre>EXEC SQL OPEN EMPCUR USING DESCRIPTOR BND
</pre>
<p>Remember, BND must <span class="italic">not</span> be prefixed with a colon.</p>
<p>Then, OPEN executes the SQL statement. With queries, OPEN also identifies the active set and positions the cursor at the first row.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR307" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref163"></a>
<h3 class="sect2">DESCRIBE the Select List</h3>
<p>If the dynamic SQL statement is a query, the DESCRIBE SELECT LIST statement must follow the OPEN statement and must precede the FETCH statement.</p>
<p>DESCRIBE SELECT LIST puts descriptions of select-list items into a select descriptor. In our example, DESCRIBE readies SEL as follows:</p>
<pre>EXEC SQL DESCRIBE SELECT LIST FOR DYNSTMT INTO SEL
</pre>
<p>Accessing the Oracle data dictionary, DESCRIBE sets the length and datatype of each select-list value.</p>
<p><a href="#BCEBJIHH">Figure 4-7</a> shows the select descriptor in our example after the DESCRIBE. Notice that DESCRIBE has set SELF to the actual number of items found in the query select list. If the SQL statement is not a query, SELF is set to zero.</p>
<p>Also notice that the NUMBER lengths are not usable yet. For columns defined as NUMBER, you must use the library subroutine SQLPRC to extract precision and scale. See the section &#34;Coercing Datatypes&#34;.</p>
<div id="ZZFOR308" class="figure">
<p class="titleinfigure"><a id="BCEBJIHH"></a>Figure 4-7 Select Descriptor after the DESCRIBE</p>
<img width="734" height="670" src="img/image010.gif" alt="Select Descriptor after the DESCRIBE"/><br/>
<a id="sthref164" href="img_text/image010.htm">Description of &#34;Figure 4-7 Select Descriptor after the DESCRIBE&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ZZFOR309" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref165"></a>
<h3 class="sect2">Reset Number of Select-List Items</h3>
<p>Next, you must reset the maximum number of select-list items to the number actually found by DESCRIBE, as follows:</p>
<pre>SELN = SELF
</pre></div>
<!-- class="sect2" -->
<div id="ZZFOR310" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref166"></a>
<h3 class="sect2">Reset Length/Datatype of Each Select-List Item</h3>
<p>In our example, before fetching the select-list values, you reset some elements in the length and datatype arrays for display purposes.</p>
<pre>DO 500 J = 1, SELN
* Clear null/not null bit.
 CALL SQLNUL (SELT(J), DATYPE, NULLOK)
 SELT(J) = DATYPE
* If datatype is NUMBER, extract precision and scale.
 IF (SELT(J) .NE. 2) GOTO 400
 CALL SQLPRC (SELL(J), PREC, SCALE)
* Allow for maximum precision.
 IF (PREC .NE. 0) GOTO 200
* Although maximum precision is 38, we use 10 because
* that is our buffer size.
 SELL(J) = 10
 GOTO 400
 200 CONTINUE
 SELL(J) = PREC
* Allow for possible sign and decimal point.
 SELL(J) = SELL(J) + 2
* Adjust length if it exceeds size of buffer. This
* applies to character as well as numeric data.
 400 IF (SELL(J) .GT. 10) SELL(J) = 10
* Coerce datatype to VARCHAR2.
 SELT(J) = 1
 500 CONTINUE
</pre>
<p><a href="#BCEDFHBG">Figure 4-8</a> shows the resulting select descriptor. Notice that the NUMBER lengths are now usable and that all the datatypes are VARCHAR2. The lengths in SELL(2) and SELL(3) are 6 and 9 because we increased the DESCRIBEd lengths of 4 and 7 by two to allow for a possible sign and decimal point.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When the datatype code returned by DESCRIBE is 2 (NUMBER), it must be coerced to a compatible FORTRAN type. The FORTRAN type need not be CHARACTER. For example, you can coerce a NUMBER to a REAL by setting SELT(J) to 4, and SELL(J) to the length of REALs on your system.</div>
<div id="ZZFOR311" class="figure">
<p class="titleinfigure"><a id="BCEDFHBG"></a>Figure 4-8 Select Descriptor before the FETCH</p>
<img width="734" height="670" src="img/image011.gif" alt="Select Descriptor before the FETCH"/><br/>
<a id="sthref167" href="img_text/image011.htm">Description of &#34;Figure 4-8 Select Descriptor before the FETCH&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ZZFOR312" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref168"></a>
<h3 class="sect2">FETCH Rows from the Active Set</h3>
<p>FETCH returns a row from the active set, stores select-list values in the data buffers, and advances the cursor to the next row in the active set. If there are no more rows, FETCH sets SQLCDE in the SQLCA, the SQLCODE variable, or the SQLSTATE variable to the &#34;no data found&#34; Oracle error code. In the following example, FETCH returns the values of columns ENAME, EMPNO, and COMM to SEL:</p>
<pre>EXEC SQL FETCH EMPCUR USING DESCRIPTOR SEL
</pre>
<p><a href="#BCEEIDBC">Figure 4-9</a> shows the select descriptor in our example after the FETCH. Notice that Oracle has stored the select-list and indicator values in the data buffers addressed by the elements of SELV and SELI.</p>
<p>For output buffers of datatype 1, Oracle, using the lengths stored in SELL, left-justifies CHAR or VARCHAR2 data, and right-justifies NUMBER data.</p>
<p>The value &#39;MARTIN&#39; was retrieved from a VARCHAR2(10) column in the EMP table. Using the length in SELL(1), Oracle left-justifies the value in a 10-byte field, filling the buffer.</p>
<p>The value 7654 was retrieved from a NUMBER(4) column and coerced to &#34;7654.&#34; However, the length in SELL(2) was increased by two to allow for a possible sign and decimal point, so Oracle right-justifies the value in a 6-byte field.</p>
<p>The value 482.50 was retrieved from a NUMBER(7,2) column and coerced to &#34;482.50.&#34; Again, the length in SELL(3) was increased by two, so Oracle right-justifies the value in a 9-byte field.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR313" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref169"></a>
<h3 class="sect2">Get and Process Select-List Values</h3>
<p>After the FETCH, your program can process the select-list values returned by FETCH. In our example, values for columns ENAME, EMPNO, and COMM are processed.</p>
</div>
<!-- class="sect2" -->
<div id="ZZFOR314" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref170"></a>
<h3 class="sect2">CLOSE the Cursor</h3>
<p>CLOSE disables the cursor. In our example, CLOSE disables EMPCUR as follows:</p>
<pre>EXEC SQL CLOSE EMPCUR
</pre>
<div id="ZZFOR315" class="figure">
<p class="titleinfigure"><a id="BCEEIDBC"></a>Figure 4-9 Select Descriptor after the FETCH</p>
<img width="734" height="670" src="img/image012.gif" alt="Select Descriptor after the FETCH"/><br/>
<a id="sthref171" href="img_text/image012.htm">Description of &#34;Figure 4-9 Select Descriptor after the FETCH&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJCBIA"></a>
<div id="ZZFOR316" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Host Arrays with Method 4</h2>
<p>To use input or output host arrays with Method 4, you must use the optional FOR clause to tell Oracle the size of your host array. For more information about the FOR clause, see Chapter 9 of the <a class="olink ZZPRE" href="../ZZPRE/toc.htm"><span class="italic">Programmer&#39;s Guide to the Oracle Precompilers</span></a>.</p>
<p>Set descriptor entries for the Jth select-list item or bind variable, but instead of addressing a single data buffer, SELV(J) or BNDV(J) addresses the first element of a data buffer array. Then use a FOR clause in the EXECUTE or FETCH statement, as appropriate, to tell Oracle the number of table elements you want to process.</p>
<p>This procedure is necessary, because Oracle has no other way of knowing the size of your host ARRAY.</p>
<p>In the following example, an input host array is used to DELETE rows from the EMP table. Note that EXECUTE can be used for non-queries with Method 4.</p>
<pre>* Use host arrays with Method 4.
 PROGRAM DYN4HA
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*20 UID
 CHARACTER*20 PWD
 CHARACTER*60 STMT
 INTEGER*4 SIZE
 EXEC SQL END DECLARE SECTION 
 EXEC SQL INCLUDE SQLCA
 CHARACTER*10 NAMES(5)
 INTEGER*2 NUMBERS(5)
 INTEGER*2 DEPTS(5)
 EXEC SQL INCLUDE BNDDSC
 EXEC SQL WHENEVER SQLERROR GOTO 9000
 UID = &#39;SCOTT&#39;
 PWD = &#39;TIGER&#39; 
* Log on to Oracle.
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 WRITE (*, 10000)
10000 FORMAT (&#39; Connected to Oracle&#39;)
 SIZE = 5
 STMT = &#39;INSERT INTO EMP (EMPNO, ENAME, DEPTNO)
 1 VALUES (:E, :N, :D)&#39;
* Prepare and describe the SQL statement.
 EXEC SQL PREPARE S FROM :STMT
 BNDN = 3
 EXEC SQL DESCRIBE BIND VARIABLES FOR S INTO BND
* Initialize bind descriptor items.
 BNDN = BNDF
 CALL SQLADR(NUMBERS(1), BNDV(1))
 BNDL(1) = 2
 BNDT(1) = 3
 BNDI(1) = 0
* %REF is used to pass the address of the data, not
* of the FORTRAN compiler-generated descriptor of
* CHARACTER variable NAMES. (See the section &#34;Using
* SQLADR&#34; earlier in this chapter.)
 CALL SQLADR(%REF(NAMES(1)), BNDV(2))
 BNDL(2) = 10
 BNDT(2) = 1
 BNDI(2) = 0
 CALL SQLADR(DEPTS(1), BNDV(3))
 BNDL(3) = 2
 BNDT(3) = 3
 BNDI(3) = 0
 DO 110 I = 1, SIZE
 BNDM(I) = 0
 BNDY(I) = 0
 BNDX(I) = 0
 110 CONTINUE 
* Fill the data buffers. Normally, this data would
* be entered interactively by the user, or read from
* a file.
 NAMES(1) = &#39;TRUSDALE&#39;
 NUMBERS(1) = 1014
 DEPTS(1) = 30
 NAMES(2) = &#39;WILKES&#39;
 NUMBERS(2) = 1015
 DEPTS(2) = 30
 NAMES(3) = &#39;BERNSTEIN&#39;
 NUMBERS(3) = 1016
 DEPTS(3) = 30
 NAMES(4) = &#39;FRAZIER&#39;
 NUMBERS(4) = 1017
 DEPTS(4) = 30
 NAMES(5) = &#39;MCCOMB&#39;
 NUMBERS(5) = 1018
 DEPTS(5) = 30
* Do the INSERT.
 WRITE (*, 10020)
10020 FORMAT(1X, &#39;Adding to Sales force ...&#39;)
 EXEC SQL FOR :SIZE EXECUTE S USING DESCRIPTOR BND
 EXEC SQL COMMIT RELEASE
 GOTO 150
* Here if SQLERROR occurred.
 9000 CONTINUE
 WRITE (*, 10030) SQLEMC
10030 FORMAT (1X, 70A1)
 EXEC SQL WHENEVER SQLERROR CONTINUE
 EXEC SQL ROLLBACK RELEASE
* Here when ready to exit the program.
 150 CONTINUE
 STOP
 END 
</pre></div>
<!-- class="sect1" -->
<a id="BABICDGG"></a>
<div id="ZZFOR317" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 10: Dynamic SQL Method 4</h2>
<p>This program shows the basic steps required to use dynamic SQL Method 4. After logging on to Oracle, the program prompts the user for a SQL statement, PREPAREs the statement, DECLAREs a cursor, checks for any bind variables using DESCRIBE BIND, OPENs the cursor, and DESCRIBEs any select-list items. If the input SQL statement is a query, the program FETCHes each row of data, then CLOSEs the cursor. Notice that a VARCHAR is used to store the dynamic SQL statement.</p>
<pre>PROGRAM DYN4
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*20 UID
 CHARACTER*20 PWD
 VARCHAR *1024 STMT, STMTL, STMTA
 EXEC SQL END DECLARE SECTION
 CHARACTER*1 ANS
 EXEC SQL INCLUDE SQLCA
 EXEC SQL INCLUDE BNDDSC
 EXEC SQL INCLUDE SELDSC

* INITIALIZE.
 CALL INIT

* LOG ON TO ORACLE.
10 PRINT *, &#39;ENTER USERNAME:&#39;
 READ &#39;(20A)&#39;, UID
 PRINT *, &#39;ENTER PASSWORD:&#39;
 READ &#39;(20A)&#39;, PWD
 EXEC SQL WHENEVER SQLERROR GOTO 8500
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD

 EXEC SQL WHENEVER SQLERROR GOTO 9000
 PRINT *, 
 1&#39;TO EXIT, TYPE NULL SQL STATEMENT (;) AT DSQL PROMPT.&#39;

* GET SQL STATEMENT FROM USER.
100 CONTINUE
 CALL GETSQL (STMTA, STMTL)
 IF (STMTL .EQ. 0) GOTO 9500

* PREPARE THE SQL STATEMENT, AND DECLARE A CURSOR FOR IT.
 EXEC SQL PREPARE S FROM :STMT
 EXEC SQL DECLARE C CURSOR FOR S

* DESCRIBE THE BIND VARIABLES. FIRST, INITIALIZE BNDN TO
* THE MAXIMUM NUMBER OF VARIABLES THAT CAN BE DESCRIBED.
 BNDN = 20
 EXEC SQL DESCRIBE BIND VARIABLES FOR S INTO BND
 IF (BNDF .GE. 0) GOTO 125
 PRINT *, &#39;TOO MANY BIND VARIABLE - TRY AGAIN...&#39;
 GOTO 300

* HAVE DESCRIBED BIND VARIABLES. GET VALUES FOR ANY
* BIND VARIABLES.
125 BNDN = BNDF
 IF (BNDN .GT. 0) CALL GETBND

* OPEN CURSOR TO EXECUTE THE SQL STATEMENT.
 EXEC SQL OPEN C USING DESCRIPTOR BND

* DESCRIBE THE SELECT-LIST ITEMS. FIRST, INITIALIZE SELN TO
* THE MAXIMUM NUMBER OF ITEMS THAT CAN BE DESCRIBED.
 SELN = 20
 EXEC SQL DESCRIBE SELECT LIST FOR S INTO SEL
 IF (SELF .GE. 0) GOTO 150
 PRINT *, &#39;TOO MANY SELECT-LIST ITEMS. TRY AGAIN...&#39;
 GOTO 300

* HAVE DESCRIBED SELECT LIST. IF THIS IS A SELECT STATEMENT,
* RESET LENGTHS AND DATATYPES OF FETCHED VALUES, AND OUTPUT
* COLUMN HEADINGS.
150 SELN = SELF
 IF (SELN .EQ. 0) GO TO 300
 CALL PRCOLH

* FETCH EACH ROW, AND PRINT IT.
 EXEC SQL WHENEVER NOT FOUND GOTO 300
200 EXEC SQL FETCH C USING DESCRIPTOR SEL
 CALL PRROW
 GOTO 200

* THERE ARE NO MORE ROWS (ROW NOT FOUND), OR NON-SELECT
* STATEMENT COMPLETED.
300 EXEC SQL CLOSE C
 IF (SELN .EQ. 0) GOTO 310

* THERE WERE SOME SELECT-LIST ITEMS, SO SQL STATEMENT
* MUST BE A SELECT.
 PRINT *, SQLERD(3), &#39; ROW(S) SELECTED.&#39;
 GOTO 100

* THERE WERE NO SELECT-LIST ITEMS, SO SQL STATEMENT
* CANNOT BE A SELECT.
310 PRINT *, SQLERD(3), &#39; ROW(S) PROCESSED.&#39;
 GOTO 100

* A SQL EXECUTION ERROR (SQLERROR) OCCURRED.
* CONNECT ERROR
8500 PRINT &#39;(70A1)&#39;, SQLEMC
 PRINT *, &#39;TRY AGAIN (Y OR N)?&#39;
 READ &#39;(A1)&#39;, ANS
 IF ((ANS .EQ. &#39;Y&#39;) .OR. (ANS .EQ. &#39;Y&#39;)) GOTO 10
 GOTO 9500

* OTHER SQL ERRORS
9000 PRINT &#39;(70A1)&#39;, SQLEMC
 GOTO 100

* NOW READY TO EXIT PROGRAM.
9500 EXEC SQL WHENEVER SQLERROR CONTINUE
 EXEC SQL COMMIT WORK RELEASE
 PRINT *, &#39;HAVE A GOOD DAY.&#39;
9600 CONTINUE
 END

*********************************************************
* NAME: INIT (INITIALIZE)
* FUNCTION: INITIALIZES THE BIND AND SELECT DESCRIPTORS.
* RETURNS: NONE
*********************************************************
 SUBROUTINE INIT

 EXEC SQL INCLUDE BNDDSC
 EXEC SQL INCLUDE SELDSC

* INITIALIZE BIND DESCRIPTOR ITEMS.
 DO 100 I = 1, 20
 CALL SQLADR (BNDSB(1,I), BNDS(I))
 CALL SQLADR (BNDVB(1,I), BNDV(I))
 CALL SQLADR (BNDXB(1,I), BNDX(I))
 CALL SQLADR (BNDIV(I), BNDI(I))
 BNDM(I) = 30
 BNDY(I) = 30
100 CONTINUE

* INITIALIZE SELECT DESCRIPTOR ITEMS.
 DO 200 I = 1, 20
 CALL SQLADR (SELSB(1,I), SELS(I))
 CALL SQLADR (SELVB(1,I), SELV(I))
 CALL SQLADR (SELIV(I), SELI(I))
 SELM(I) = 30
200 CONTINUE
 RETURN
 END

*********************************************************
* NAME: GETSQL (GET SQL STATEMENT FROM TERMINAL)
* FUNCTION: ASKS THE USER TO TYPE IN A SQL STATEMENT.
* RETURNS: SARR IS A STRING (LOGICAL*1) CONTAINING
* THE SQL STATEMENT. SLEN IS THE NUMBER OF
* CHARACTERS IN SARR. IF SLEN IS 0, THEN NO
* SQL STATEMENT WAS ENTERED (DSQL USES THIS
* TO INDICATE THAT USER WANTS TO LOG OFF).
*********************************************************
 SUBROUTINE GETSQL (SARR, SLEN)

 LOGICAL*1 SARR(1)
 INTEGER*2 SLEN
 LOGICAL*1 INP(80)
 INTEGER INPL
 INTEGER CNTLIN

 CNTLIN = 0
 SLEN = 0
 PRINT *, &#39;DSQL&gt;&#39;
50 READ &#39;(80A1)&#39;, (INP(I), I = 1, 80)

* FIND LENGTH OF SQL STATEMENT BY SCANNING BACKWARD FOR
* FIRST NON-BLANK CHARACTER.
 INPL = 80
 DO 100 I = 1, 80
 IF (INP(INPL) .NE. &#39; &#39;) GOTO 150
 INPL = INPL - 1
100 CONTINUE

* MOVE THIS PIECE OF THE SQL STATEMENT TO SQL STATEMENT
* BUFFER.
150 CONTINUE
 DO 200 I = 1, INPL
 SLEN = SLEN + 1
 IF (SLEN .GT. 1024) GOTO 1000
 SARR(SLEN) = INP(I)
200 CONTINUE
 IF (SARR(SLEN) .EQ. &#39;;&#39;) GOTO 1000
* LINE NOT TERMINATED BY &#39;;&#39;. REQUEST CONTINUED LINE.
 CNTLIN = CNTLIN + 1
 WRITE (*, 10300) CNTLIN
10300 FORMAT (&#39;$&#39;, I5, &#39;:&#39;)

 SLEN = SLEN + 1
 IF (SLEN .GT. 1024) GOTO 1000
 SARR(SLEN) = &#39; &#39;
 GOTO 50
1000 CONTINUE
 SLEN = SLEN - 1
 RETURN
 END

*********************************************************
* NAME: PRCOLH (PRINT COLUMN HEADINGS)
* FUNCTION: RESETS LENGTH AND DATATYPE ARRAYS IN SELECT
* DESCRIPTOR, AND PRINTS COLUMN HEADINGS FOR
* SELECT-LIST ITEMS.
* NOTES: FOR EXAMPLE, GIVEN THE STATEMENT
*
* SELECT TNAME, TABTYPE FROM TAB
*
* AND ASSUMING TNAME COLUMN IS 30 CHARACTERS
* WIDE AND TABTYPE COLUMN IS 7 CHARACTERS WIDE,
* PRCOLH PRINTS:
*
* TNAME TABTYPE
* ----------------------------- -------
*********************************************************
 SUBROUTINE PRCOLH

 EXEC SQL INCLUDE SELDSC
 LOGICAL*1 LINE(132)
 INTEGER LINESZ
 INTEGER PREC, SCALE, NULLOK
 INTEGER*2 DATYPE

 PREC = 26
 SCALE = 0
 LINESZ = 132
 L = 0

 DO 500 I = 1, SELN

* SQLPRC IS USED TO EXTRACT PRECISION AND SCALE FROM THE
* LENGTH (SELL(I)).

* SQLNUL IS USED TO RESET HIGH ORDER BIT OF THE DATATYPE
* AND TO CHECK IF THE COLUMN IS NOT NULL.

* CHAR DATATYPES HAVE LENGTH, BUT ZERO PRECISION AND
* SCALE. THE LENGTH IS THAT DEFINED AT CREATE TIME.

* NUMBER DATATYPES HAVE PRECISION AND SCALE IF DEFINED
* AT CREATE TIME. HOWEVER, IF THE COLUMN DEFINITION
* WAS JUST NUMBER, THE PRECISION AND SCALE ARE ZERO,
* SO WE DEFAULT THE COLUMN WIDTH TO 10.

* RIGHT JUSTIFY COLUMN HEADING FOR NUMBERS.

 CALL SQLNUL (SELT(I), DATYPE, NULLOK)
 SELT(I) = DATYPE
 IF (SELT(I) .NE. 2) GOTO 150
 CALL SQLPRC (SELL(I), PREC, SCALE)

* IF NO PRECISION, USE DEFAULT.
 IF (PREC .EQ. 0) PREC = 10
 SELL(I) = PREC

* ADD 2 FOR POSSIBLE SIGN AND DECIMAL POINT.
 SELL(I) = SELL(I) + 2

* BLANK-PAD COLUMN NAME TO RIGHT-JUSTIFY COLUMN HEADING.
 NBLANKS = SELL(I) - SELC(I)
 DO 130 J = 1, NBLANKS
 L = L + 1
 IF (L .GT. LINESZ - 1) GOTO 450
 LINE(L) = &#39; &#39;
130 CONTINUE
 GOTO 190

* CHECK FOR LONG COLUMN, AND SET DATA BUFFER
* LENGTH TO 240.
150 IF (SELT(I) .NE. 8) GOTO 153
 SELL(I) = 240
 GOTO 190

* CHECK FOR LONG RAW COLUMN, AND SET DATA BUFFER
* LENGTH TO 240.
153 IF (SELT(I) .NE. 24) GOTO 155
 SELL(I) = 240
 GOTO 190
* CHECK FOR ROWID COLUMN, AND SET DATA BUFFER
* LENGTH TO 18 (DISPLAY LENGTH).
155 IF (SELT(I) .NE. 11) GOTO 160
 SELL(I) = 18
 GOTO 190

* CHECK FOR DATE COLUMN, AND SET DATA BUFFER LENGTH
* TO 9 (DEFAULT FORMAT IS DD-MON-YY).
160 IF (SELT(I) .NE. 12) GOTO 165
 SELL(I) = 9
 GOTO 190

* CHECK FOR RAW COLUMN, AND ADD 1 TO DATA BUFFER LENGTH.
165 IF (SELT(I) .NE. 23) GOTO 190
 SELL(I) = SELL(I) + 1

* COPY COLUMN NAME TO OUTPUT LINE.
190 DO 200 J = 1, MIN (SELC(I), SELL(I))
 L = L + 1
 IF (L .GT. LINESZ - 1) GOTO 450
 LINE(L) = SELSB(J, I)
200 CONTINUE

* PAD COLUMN NAME WITH BLANKS PLUS 1 FOR INTER-COLUMN
* SPACING. NOTE THAT NUMBER COLUMNS ARE RIGHT-JUSTIFIED
* SO JUST ONE BLANK IS NEEDED FOR INTER-COLUMN SPACING.
 NBLANKS = 1
 IF (SELT(I) .EQ. 2) GOTO 210
 NBLANKS = MAX (SELL(I) - SELC(I) + 1, 1)
210 DO 300 J = 1, NBLANKS
 L = L + 1
 IF (L .GT. LINESZ - 1) GOTO 450
 LINE(L) = &#39; &#39;
300 CONTINUE

* EXCEPT FOR LONG RAW COLUMNS, COERCE COLUMN
* DATATYPE TO VARCHAR2 TO SIMPLIFY PRINTING ROW.
450 IF (SELT(I) .NE. 24) SELT(I) = 1
500 CONTINUE

* NOW READY TO PRINT THE HEADING LINE.
1000 WRITE (*, 10100) (LINE(I), I = 1, L)
10100 FORMAT (/, 1X, 132A1)

* UNDERLINE THE COLUMN HEADINGS.
 L = 0
 DO 1500 I = 1, SELN
 NUNDER = SELL(I)
 DO 1250 J = 1, NUNDER
 L = L + 1
 IF (L .GT. LINESZ - 1) GOTO 2000
 LINE(L) = &#39;-&#39;
1250 CONTINUE
 L = L + 1
 IF (L .GT. LINESZ - 1) GOTO 2000
 LINE(L) = &#39; &#39;
1500 CONTINUE

* NOW READY TO PRINT THE UNDERLINE.
2000 WRITE (*, 10200) (LINE(I), I = 1, L)
10200 FORMAT (1X, 132A1)
 RETURN
 END

*********************************************************
* NAME: PRROW (PRINT ROW)
* FUNCTION: PRINTS A SINGLE FETCHED ROW.
*********************************************************
 SUBROUTINE PRROW
 EXEC SQL INCLUDE SELDSC
 LOGICAL*1 LINE(132)
 INTEGER LINESZ

 LINESZ = 132
 L = 0
 DO 500 I = 1, SELN

* CHECK FOR NULL COLUMN. IF NULL, BLANK-PAD COLUMN.
 IF (SELIV(I) .GE. 0) GOTO 100
 DO 90 J = 1, SELL(I)
 L = L + 1
 IF (L .GT. LINESZ - 1) GOTO 1000
 LINE(L) = &#39; &#39;
90 CONTINUE
 GOTO 250

* COLUMN DATATYPE IS VARCHAR2. COPY COLUMN VALUE TO
* OUTPUT LINE.
100 CONTINUE
 DO 200 J = 1, SELL(I)
 L = L + 1
 IF (L .GT. LINESZ - 1) GOTO 1000
 LINE(L) = SELVB(J, I)
200 CONTINUE

* APPEND ONE BLANK FOR INTER-COLUMN SPACING.
250 CONTINUE
 L = L + 1
 IF (L .GT. LINESZ - 1) GOTO 1000
 LINE(L) = &#39; &#39;
500 CONTINUE

* NOW READY TO PRINT THE LINE.
1000 WRITE (*, 10100) (LINE(I), I = 1, L)
10100 FORMAT (1X, 132A1)
 RETURN
 END

*********************************************************
* NAME: GETBND (GET BIND VARIABLES)
* FUNCTION: USING THE DESCRIPTOR BND, SET UP BY
* THE DESCRIBE BIND VARIABLES STATEMENT,
* GETBND PROMPTS THE USER FOR VALUES OF BIND
* VARIABLES.
* RETURNS: BNDVB AND BNDL ARRAYS SET UP WITH VALUES
* FOR BIND VARIABLES.
*********************************************************
 SUBROUTINE GETBND
 EXEC SQL INCLUDE BNDDSC
 CHARACTER*1 CLN, SPC

 CLN = &#39;:&#39;
 SPC = &#39; &#39;
 WRITE (*, 10100)
10100 FORMAT (/, &#39;PLEASE ENTER VALUES OF BIND VARIABLES.&#39;, /)
 DO 500 I = 1, BNDN
 WRITE (*, 10200)(BNDSB(J, I), J = 1, BNDC(I)), CLN, SPC
10200 FORMAT (&#39;ENTER VALUE FOR &#39;, 32A1)

* GET VALUE FOR BIND VARIABLE.

 READ &#39;(80A1)&#39;, (BNDVB(J, I), J = 1, 80)

* FIND LENGTH OF VALUE BY SCANNING BACKWARD
* FOR FIRST NON-BLANK CHARACTER.
 BNDL(I) = 80
 DO 200 J = 1, 80
 IF (BNDVB(BNDL(I), I) .NE. &#39; &#39;) GOTO 300
 BNDL(I) = BNDL(I) - 1
200 CONTINUE

* SET DATATYPE OF BIND VARIABLE TO VARCHAR2, AND SET
* INDICATOR VARIABLE TO NOT NULL.
300 CONTINUE
 BNDT(I) = 1
 BNDIV(I) = 0
500 CONTINUE
 RETURN
 END
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1626">
<tr>
<td class="cellalignment1633">
<table class="cellalignment1637">
<tr>
<td class="cellalignment1630"><a href="ch_three.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1630"><a href="appendix.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1994, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1635">
<table class="cellalignment1636">
<tr>
<td class="cellalignment1630"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1630"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1630"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1630"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1630"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>