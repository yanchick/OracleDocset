<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114076"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Data%20Types"></a><title>Data Types</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1040"/>
<meta name="dcterms.created" content="2015-03-12T19:51:43Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen In-Memory Database SQL Reference"/>
<meta name="dcterms.identifier" content="E21642-12"/>
<meta name="dcterms.isVersionOf" content="TTSQL"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2011, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="whatsnew.htm" title="Previous" type="text/html"/>
<link rel="Next" href="names.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21642-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">5/13</span> <!-- End Header -->
<div id="TTSQL123" class="chapter"><a id="i1008748"></a>
<h1 class="chapter"><span class="secnum">1</span> Data Types</h1>
<p><a id="sthref14"></a>A data type defines a set of values. A reference to a data type specifies the set of values that can occur in a given context. A data type is associated with each value retrieved from a table or computed in an expression and each constant.</p>
<p>TimesTen follows the ODBC standard for type conversion. For more information, refer to ODBC API reference documentation, which is available from Microsoft or a variety of third parties. The following site contains Microsoft&#39;s ODBC API reference documentation:</p>
<p><code dir="ltr"><a href="http://msdn.microsoft.com/en-us/library/ms714562(VS.85).aspx">http://msdn.microsoft.com/en-us/library/ms714562(VS.85).aspx</a></code></p>
<p>If you are using TimesTen Cache, see <a class="olink TTCAC362" href="../TTCAC/oracle_tt.htm#TTCAC362">&#34;Mappings between Oracle Database and TimesTen data types&#34;</a> in <span class="italic">Oracle TimesTen Application-Tier Database Cache User&#39;s Guide</span>. This section compares valid data types for creating cache group columns and type conversions for passthrough queries.</p>
<p>The following subjects describe data types in TimesTen:</p>
<ul>
<li>
<p><a href="#i987176">Type specifications</a></p>
</li>
<li>
<p><a href="#BABFDHCG">ANSI SQL data types</a></p>
</li>
<li>
<p><a href="#i1028151">Types supported for backward compatibility in Oracle type mode</a></p>
</li>
<li>
<p><a href="#BABIIACI">TimesTen type mapping</a></p>
</li>
<li>
<p><a href="#i1035539">Character data types</a></p>
</li>
<li>
<p><a href="#i1029200">Numeric data types</a></p>
</li>
<li>
<p><a href="#BABIDFJF">BINARY and VARBINARY data types</a></p>
</li>
<li>
<p><a href="#BABEDCJC">Numeric precedence</a></p>
</li>
<li>
<p><a href="#BABBGIFA">LOB data types</a></p>
</li>
<li>
<p><a href="#BABBDGFE">ROWID data type</a></p>
</li>
<li>
<p><a href="#BABGDDBI">Datetime data types</a></p>
</li>
<li>
<p><a href="#BABECJIA">TimesTen intervals</a></p>
</li>
<li>
<p><a href="#BABEDECD">Storage requirements</a></p>
</li>
<li>
<p><a href="#BABJEBAC">Data type comparison rules</a></p>
</li>
<li>
<p><a href="#BABIDFCD">Data type conversion</a></p>
</li>
<li>
<p><a href="#i992648">Null values</a></p>
</li>
<li>
<p><a href="#i1036375">INF and NAN</a></p>
</li>
<li>
<p><a href="#i987705">Overflow and truncation</a></p>
</li>
<li>
<p><a href="#i987763">Underflow</a></p>
</li>
<li>
<p><a href="#BABBBFDC">Replication limits</a></p>
</li>
<li>
<p><a href="#i1033906">TimesTen type mode (backward compatibility)</a></p>
</li>
</ul>
<a id="i987176"></a>
<div id="TTSQL124" class="sect1">
<h2 class="sect1"><a id="sthref15"></a>Type specifications</h2>
<p>TimesTen supports the data types in <a href="#BABCCAFA">Table 1-1</a> in the default Oracle type <a id="sthref16"></a><a id="sthref17"></a><a id="sthref18"></a>mode. Type mode is a data store attribute, where <code dir="ltr">TypeMode=0</code> indicates Oracle type mode and <code dir="ltr">TypeMode=1</code> indicates TimesTen mode. For more information on data type modes, see <a href="#i1033906">&#34;TimesTen type mode (backward compatibility)&#34;</a>. Also see <a class="olink TTREF134" href="../TTREF/attribute.htm#TTREF134">&#34;TypeMode&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference.</span></p>
<div id="TTSQL125" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref19"></a><a id="BABCCAFA"></a>Table 1-1 Data types supported in Oracle type mode</p>
<table class="cellalignment6330" title="Data types supported in Oracle type mode" summary="This table contains descriptions of data types in Oracle type mode." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t2">Data type</th>
<th class="cellalignment6331" id="r1c2-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t2" headers="r1c1-t2">
<p><a id="sthref20"></a><code dir="ltr">BINARY</code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r2c1-t2 r1c2-t2">
<p>Fixed-length binary value of <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes</p>
<p>Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> range from 1 to 8300. <code dir="ltr">BINARY</code> data is padded to the maximum column size with trailing zeroes. Alternatively, specify <code dir="ltr">TT_BINARY</code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code>.</p>
<p>For more details, see <a href="#BABIDFJF">&#34;BINARY and VARBINARY data types&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t2" headers="r1c1-t2">
<p><a id="sthref21"></a><code dir="ltr">BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment6332" headers="r3c1-t2 r1c2-t2">
<p>A 64-bit floating-point number</p>
<p><code dir="ltr">BINARY_DOUBLE</code> is a double-precision native floating point number that supports <code dir="ltr">+Inf</code>, <code dir="ltr">-Inf</code>, and <code dir="ltr">NaN</code> values. <code dir="ltr">BINARY_DOUBLE</code> is an approximate numeric value consisting of an exponent and mantissa. You can use exponential or E-notation. <code dir="ltr">BINARY_DOUBLE</code> has binary precision 53.</p>
<p>Minimum positive finite value: 2.22507485850720E-308</p>
<p>Maximum positive finite value: 1.79769313486231E+308</p>
<p>For more details, see <a href="#BABIGDEA">&#34;BINARY_DOUBLE&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t2" headers="r1c1-t2">
<p><a id="sthref22"></a><code dir="ltr">BINARY_FLOAT</code></p>
</td>
<td class="cellalignment6332" headers="r4c1-t2 r1c2-t2">
<p>A 32-bit floating-point number</p>
<p><code dir="ltr">BINARY_FLOAT</code> is a single-precision native floating-point type that supports <code dir="ltr">+Inf</code>, <code dir="ltr">-Inf</code>, and <code dir="ltr">NaN</code> values. <code dir="ltr">BINARY_FLOAT</code> is an approximate numeric value consisting of an exponent and mantissa. You can use exponential or E-notation. <code dir="ltr">BINARY_FLOAT</code> has binary precision 24.</p>
<p>Minimum positive finite value: 1.17549E-38F</p>
<p>Maximum positive finite value: 3.40282E+38F</p>
<p>For more details, see <a href="#BABGAEGB">&#34;BINARY_FLOAT&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t2" headers="r1c1-t2">
<p><code dir="ltr"><a id="sthref23"></a><a id="sthref24"></a>BLOB</code></p>
</td>
<td class="cellalignment6332" headers="r5c1-t2 r1c2-t2">
<p>A binary large object</p>
<p>Variable-length binary value with a maximum size of 16 MB.</p>
<p>For more details, see <a href="#BABBJJEH">&#34;BLOB&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t2" headers="r1c1-t2">
<p><a id="sthref25"></a><code dir="ltr">CHAR</code><code dir="ltr">[ACTER][(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])]</code></p>
</td>
<td class="cellalignment6332" headers="r6c1-t2 r1c2-t2">
<p>Fixed-length character string of length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes or characters</p>
<p>Default is one byte.</p>
<p><code dir="ltr">BYTE</code> indicates that the column has byte-length semantics. Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> range from a minimum of one byte to a maximum of 8300 bytes.</p>
<p><code dir="ltr">CHAR</code> indicates that the column has character-length semantics. The minimum <code dir="ltr">CHAR</code> length is one character. The maximum <code dir="ltr">CHAR</code> length depends on how many characters fit in 8300 bytes. This is determined by the database character set in use. For character set <code dir="ltr">AL32UTF8</code>, up to four bytes per character may be needed, so the <code dir="ltr">CHAR</code> length limit ranges from 2075 to 8300 depending on the character set.</p>
<p>A zero-length string is interpreted as <code dir="ltr">NULL</code>.</p>
<p><code dir="ltr">CHAR</code> data is padded to the maximum column size with trailing blanks. Blank-padded comparison semantics are used.</p>
<p>Alternatively, specify <code dir="ltr">ORA_CHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])]</code>.</p>
<p>For more details, see <a href="#BABCDEJC">&#34;CHAR&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r7c1-t2" headers="r1c1-t2">
<p><code dir="ltr"><a id="sthref26"></a><a id="sthref27"></a>CLOB</code></p>
</td>
<td class="cellalignment6332" headers="r7c1-t2 r1c2-t2">
<p>A character large object containing single-byte or multibyte characters</p>
<p>Variable-length large object with a maximum size of 4 MB.</p>
<p>For more details, see <a href="#BABGCJHJ">&#34;CLOB&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r8c1-t2" headers="r1c1-t2">
<p><a id="sthref28"></a><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment6332" headers="r8c1-t2 r1c2-t2">
<p>Date and time information: century, year, month, day, hour, minute, and second</p>
<p>Format is:</p>
<p><code dir="ltr">YYYY-MM-DD HHMISS</code>.</p>
<p>Valid date range is from January 1, 4712 BC to December 31, 9999 AD.</p>
<p>There are no fractional seconds.</p>
<p>Alternatively, specify <code dir="ltr">ORA_</code><code dir="ltr">DATE</code>.</p>
<p>For more details, see <a href="#BABIACDC">&#34;DATE&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r9c1-t2" headers="r1c1-t2">
<p><a id="sthref29"></a><code dir="ltr">INTERVAL [+/-]</code> <code dir="ltr"><span class="codeinlineitalic">IntervalQualifier</span></code></p>
</td>
<td class="cellalignment6332" headers="r9c1-t2 r1c2-t2">
<p>Interval type</p>
<p>TimesTen partially supports interval types, expressed with the type <code dir="ltr">INTERVAL</code> and an <code dir="ltr"><span class="codeinlineitalic">IntervalQualifier</span></code>. An <code dir="ltr"><span class="codeinlineitalic">IntervalQualifier</span></code> can only specify a single field type with no precision. The default leading precision is eight digits for all interval types. The single field type can be: year, month, day, hour, minute, or second. Currently, interval types can be specified only with a constant.</p>
<p><span class="bold">Note</span>: You cannot specify a column of an interval type. These are non-persistent types used in SQL expressions at runtime. In addition, for those comparisons where an interval data type is returned, the interval data type cannot be the final result of a complete expression. The <code dir="ltr"><a href="function.htm#i1017701">EXTRACT</a></code> function must be used to extract the desired component of this interval result.</p>
<p>For more details, see <a href="#BABECJIA">&#34;TimesTen intervals&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r10c1-t2" headers="r1c1-t2">
<p><a id="sthref30"></a><code dir="ltr">NCHAR</code><code dir="ltr">[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code><code dir="ltr">]</code></p>
</td>
<td class="cellalignment6332" headers="r10c1-t2 r1c2-t2">
<p>Fixed-length string of <code dir="ltr"><span class="codeinlineitalic">n</span></code> two-byte Unicode characters</p>
<p>The number of bytes required is 2*<code dir="ltr"><span class="codeinlineitalic">n</span></code> where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is the specified number of characters. <code dir="ltr">NCHAR</code> character limits are half the byte limits so the maximum size is 4150.</p>
<p>A zero-length string is interpreted as <code dir="ltr">NULL</code>.</p>
<p><code dir="ltr">NCHAR</code> data is padded to the maximum column size with <code dir="ltr">U+0020 SPACE</code>. Blank-padded comparison semantics are used.</p>
<p>Alternatively, specify <code dir="ltr">ORA_NCHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)]</code>.</p>
<p>For more details, see <a href="#BABDFECH">&#34;NCHAR&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r11c1-t2" headers="r1c1-t2">
<p><code dir="ltr"><a id="sthref31"></a><a id="sthref32"></a>NCLOB</code></p>
</td>
<td class="cellalignment6332" headers="r11c1-t2 r1c2-t2">
<p>A national character large object containing Unicode characters</p>
<p>Variable-length character value with a maximum size of 4 MB.</p>
<p>For more details, see <a href="#BABFCIED">&#34;NCLOB&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r12c1-t2" headers="r1c1-t2">
<p><a id="sthref33"></a><code dir="ltr">NUMBER[(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code> <code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code></p>
</td>
<td class="cellalignment6332" headers="r12c1-t2 r1c2-t2">
<p>Number having precision and scale</p>
<p>The precision ranges from 1 to 38 decimal. The scale ranges from -84 to 127. Both precision and scale are optional.</p>
<p>If you do not specify a precision or a scale, TimesTen assumes the maximum precision of 38 and flexible scale.</p>
<p><code dir="ltr">NUMBER</code> supports negative scale and scale greater than precision.</p>
<p><code dir="ltr">NUMBER</code> stores both zero and positive and negative fixed numbers with absolute values from 1.0 x 10<sup>-130</sup> to (but not including) 1.0 x 10<sup>126</sup>. If you specify an arithmetic expression whose value has an absolute value greater than or equal to 1.0 x 10<sup>126</sup>, then TimesTen returns an error.</p>
<p>For more details, see <a href="#BABCBDFI">&#34;NUMBER&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r13c1-t2" headers="r1c1-t2">
<p><a id="sthref34"></a><code dir="ltr">NVARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r13c1-t2 r1c2-t2">
<p>Variable-length string of <code dir="ltr"><span class="codeinlineitalic">n</span></code> two-byte Unicode characters</p>
<p>The number of bytes required is 2*<code dir="ltr"><span class="codeinlineitalic">n</span></code> where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is the specified number of characters. <code dir="ltr">NVARCHAR2</code> character limits are half the byte limits so the maximum size is 2,097,152 (2<sup>21</sup>). You must specify <code dir="ltr"><span class="codeinlineitalic">n</span></code>.</p>
<p>A zero-length string is interpreted as <code dir="ltr">NULL</code>.</p>
<p>Nonpadded comparison semantics are used.</p>
<p>Alternatively, specify <code dir="ltr">ORA_NVARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code>.</p>
<p>For more details, see <a href="#BABHGCBA">&#34;NVARCHAR2&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r14c1-t2" headers="r1c1-t2">
<p><a id="sthref35"></a><code dir="ltr">ROWID</code></p>
</td>
<td class="cellalignment6332" headers="r14c1-t2 r1c2-t2">
<p>An 18-byte character string that represents the address of a table row or materialized view row</p>
<p>Specify a literal <code dir="ltr">ROWID</code> value as a <code dir="ltr">CHAR</code> constant enclosed in single quotes.</p>
<p>For more details, see <a href="#BABBDGFE">&#34;ROWID data type&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r15c1-t2" headers="r1c1-t2">
<p><a id="sthref36"></a><code dir="ltr">TIME</code></p>
</td>
<td class="cellalignment6332" headers="r15c1-t2 r1c2-t2">
<p>A time of day between 00:00:00 (midnight) and 23:59:59 (11:59:59 pm), inclusive</p>
<p>The format is: <code dir="ltr"><span class="codeinlineitalic">HH:MI:SS</span></code>.</p>
<p>Alternatively, specify <code dir="ltr">TT_TIME</code>.</p>
<p>For more details, see <a href="#BABFEDEC">&#34;TIME&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r16c1-t2" headers="r1c1-t2">
<p><a id="sthref37"></a><code dir="ltr">TIMESTAMP</code></p>
<p><code dir="ltr">[(</code><code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code><code dir="ltr">)]</code></p>
</td>
<td class="cellalignment6332" headers="r16c1-t2 r1c2-t2">
<p>Year, month, and day values of the date plus hour, minute, and second values of the time</p>
<p>The <code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code> is the number of digits in the fractional part of the seconds field. Valid date range is from January 1, 4712 BC to December 31, 9999 AD.</p>
<p><code dir="ltr">TT_TIMESTAMP</code> has a smaller storage size than <code dir="ltr">TIMESTAMP</code>. <code dir="ltr">TT_TIMESTAMP</code> is faster than <code dir="ltr">TIMESTAMP</code> because <code dir="ltr">TT_TIMESTAMP</code> is an eight-byte integer containing the number of microseconds since January 1, 1753. Comparisons are very fast. <code dir="ltr">TIMESTAMP</code> has a larger range than <code dir="ltr">TT_TIMESTAMP</code> in that <code dir="ltr">TIMESTAMP</code> can store date and time data as far back as 4712 BC. <code dir="ltr">TIMESTAMP</code> also supports up to nine digits of fractional second precision whereas <code dir="ltr">TT_TIMESTAMP</code> supports six digits of fractional second precision.</p>
<p>The fractional seconds precision range is 0 to 9. The default is 6. Format is:</p>
<p><code dir="ltr">YYYY-MM-DD HH:MI:SS [.FFFFFFFFF]</code></p>
<p>Alternatively, specify <code dir="ltr">ORA_TIMESTAMP[(</code><code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code><code dir="ltr">)]</code></p>
<p>For more details, see <a href="#BABFHCFB">&#34;TIMESTAMP&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r17c1-t2" headers="r1c1-t2">
<p><a id="i1013087"></a><code dir="ltr">T<a id="sthref38"></a>T_BIGINT</code></p>
</td>
<td class="cellalignment6332" headers="r17c1-t2 r1c2-t2">
<p>A signed eight-byte integer in the range -9,223,372,036,854,775,808 (-2<sup>63</sup>) to 9,223,372,036,854,775,807 (2<sup>63</sup>-1)</p>
<p>Use <code dir="ltr">TT_BIGINT</code> rather than the <code dir="ltr">NUMBER</code> data type. <code dir="ltr">TT_BIGINT</code> is more compact and offers faster performance than the <code dir="ltr">NUMBER</code> type. If you need to store greater than 19-digit integers, use <code dir="ltr">NUMBER</code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code> where <code dir="ltr"><span class="codeinlineitalic">p</span></code> &gt; 19.</p>
<p>For more details, see <a href="#BABJGDFA">&#34;TT_BIGINT&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r18c1-t2" headers="r1c1-t2">
<p><a id="sthref39"></a><code dir="ltr">TT_DATE</code></p>
</td>
<td class="cellalignment6332" headers="r18c1-t2 r1c2-t2">
<p>Date information: century, year, month, and day</p>
<p>The format is <code dir="ltr">YYYY-MM-DD</code>, where <code dir="ltr">MM</code> is expressed as an integer such as 2006-10-28.</p>
<p>Valid dates are between 1753-01-01 (January 1, 1753) and 9999-12-31 (December 31, 9999).</p>
<p>For more details, see <a href="#BABEDEJF">&#34;TT_DATE&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r19c1-t2" headers="r1c1-t2">
<p><a id="sthref40"></a><code dir="ltr">TT_INTEGER</code></p>
</td>
<td class="cellalignment6332" headers="r19c1-t2 r1c2-t2">
<p>A signed integer in the range -2,147,483,648 (-2<sup>31</sup>) to 2,147,483,647 (2<sup>31</sup>-1)</p>
<p><code dir="ltr">TT_INTEGER</code> is a native signed integer data type. Use <code dir="ltr">TT_INTEGER</code> rather than <code dir="ltr">INTEGER</code>. <code dir="ltr">INTEGER</code> maps to the <code dir="ltr">NUMBER</code> data type. <code dir="ltr">TT_INTEGER</code> is more compact and offers faster performance than the <code dir="ltr">NUMBER</code> type. If you need to store greater than 19-digit integers, use <code dir="ltr">NUMBER</code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code> where <code dir="ltr"><span class="codeinlineitalic">p</span></code> &gt; 19.</p>
<p>For more details, see <a href="#BABBDGDD">&#34;TT_INTEGER&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r20c1-t2" headers="r1c1-t2">
<p><a id="i1013077"></a><code dir="ltr">TT_SMALLINT</code></p>
</td>
<td class="cellalignment6332" headers="r20c1-t2 r1c2-t2">
<p>A native signed 16-bit integer in the range -32,768 (-2<sup>15</sup>) to 32,767 (2<sup>15</sup>-1)</p>
<p>Use <code dir="ltr">TT_SMALLINT</code> rather than <code dir="ltr">SMALLINT</code>. <code dir="ltr">SMALLINT</code> maps to the <code dir="ltr">NUMBER</code> data type.</p>
<p><code dir="ltr">TT_SMALLINT</code> is more compact and offers faster performance than the <code dir="ltr">NUMBER</code> type. If you need to store greater than 19-digit integers, use <code dir="ltr">NUMBER</code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code> where <code dir="ltr"><span class="codeinlineitalic">p</span></code> &gt; 19.</p>
<p>For more details, see <a href="#BABEDBHD">&#34;TT_SMALLINT&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r21c1-t2" headers="r1c1-t2">
<p><a id="sthref41"></a><code dir="ltr">TT_TIMESTAMP</code></p>
</td>
<td class="cellalignment6332" headers="r21c1-t2 r1c2-t2">
<p>A date and time between 1753-01-01 00:00:00 (midnight on January 1, 1753) and 9999-12-31 23:59:59 pm (11:59:59 pm on December 31, 9999), inclusive</p>
<p>Any values for the fraction not specified in full microseconds result in a &#34;<code dir="ltr">Data Truncated</code>&#34; error. The format is <code dir="ltr">YYYY-MM-DD HH:MI:SS [.FFFFFFFFF]</code>.</p>
<p><code dir="ltr">TT_TIMESTAMP</code> has a smaller storage size than <code dir="ltr">TIMESTAMP</code> and is faster than <code dir="ltr">TIMESTAMP</code> because <code dir="ltr">TT_TIMESTAMP</code> is an eight-byte integer containing the number of microseconds since January 1, 1753. Comparisons are very fast. <code dir="ltr">TIMESTAMP</code> has a larger range than <code dir="ltr">TT_TIMESTAMP</code> in that <code dir="ltr">TIMESTAMP</code> can store date and time data as far back as 4712 BC. <code dir="ltr">TIMESTAMP</code> also supports up to nine digits of fractional second precision whereas <code dir="ltr">TT_TIMESTAMP</code> supports six digits of fractional second precision.</p>
<p>You can specify <code dir="ltr">TT_TIMESTAMP(6)</code>.</p>
<p>For more details, see <a href="#BABJAIII">&#34;TT_TIMESTAMP&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r22c1-t2" headers="r1c1-t2">
<p><a id="i1013071"></a><code dir="ltr">T<a id="sthref42"></a>T_TINYINT</code></p>
</td>
<td class="cellalignment6332" headers="r22c1-t2 r1c2-t2">
<p>Unsigned integer ranging from 0 to 255 (2<sup>8</sup>-1)</p>
<p>Use <code dir="ltr">TT_TINYINT</code> rather than the <code dir="ltr">NUMBER</code> data type. <code dir="ltr">TT_TINYINT</code> is more compact and offers faster performance than the <code dir="ltr">NUMBER</code> type. If you need to store greater than 19-digit integers, use <code dir="ltr">NUMBER(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code> where <code dir="ltr"><span class="codeinlineitalic">p</span></code> &gt; 19.</p>
<p>Since <code dir="ltr">TT_TINYINT</code> is unsigned, the negation of a <code dir="ltr">TT_TINYINT</code> is a <code dir="ltr">TT_SMALLINT</code>.</p>
<p>For more details, see <a href="#BABBIIGG">&#34;TT_TINYINT&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r23c1-t2" headers="r1c1-t2">
<p><a id="sthref43"></a><code dir="ltr">VARBINARY</code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r23c1-t2 r1c2-t2">
<p>Variable-length binary value having maximum length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes, ranging from 1 to 4194304 (2<sup>22</sup>)</p>
<p>Alternatively, specify <code dir="ltr">TT_VARBINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code>.</p>
<p>For more details, see <a href="#BABIDFJF">&#34;BINARY and VARBINARY data types&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r24c1-t2" headers="r1c1-t2">
<p><a id="sthref44"></a><a id="sthref45"></a><code dir="ltr">VARCHAR[2](</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code></p>
</td>
<td class="cellalignment6332" headers="r24c1-t2 r1c2-t2">
<p>Variable-length character string having maximum length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes or characters, in the range from a minimum of one byte to a maximum 4194304 (2<sup>22</sup>) bytes</p>
<p>You must specify <code dir="ltr"><span class="codeinlineitalic">n</span></code>. <code dir="ltr">BYTE</code> indicates that the column has byte-length semantics.</p>
<p><code dir="ltr">CHAR</code> indicates that the column has character-length semantics.</p>
<p>A zero-length string is interpreted as <code dir="ltr">NULL</code>.</p>
<p>Nonpadded comparison semantics are used.</p>
<p>Do not use the <code dir="ltr">VARCHAR</code> type. Although it is currently synonymous with <code dir="ltr">VARCHAR2</code>, the <code dir="ltr">VARCHAR</code> type is scheduled to be redefined.</p>
<p>Alternatively, specify <code dir="ltr">ORA_VARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code>.</p>
<p>For more details, see <a href="#BABFCCHG">&#34;VARCHAR2&#34;</a>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect1" -->
<a id="BABFDHCG"></a>
<div id="TTSQL126" class="sect1">
<h2 class="sect1"><a id="sthref46"></a><a id="sthref47"></a>ANSI SQL data types</h2>
<p>TimesTen supports ANSI SQL data types in Oracle type mode. These data types are converted to TimesTen data types with data stored as TimesTen data types. <a href="#BABBFBEI">Table 1-2</a> shows how the ANSI SQL data types are mapped to TimesTen data types.</p>
<div id="TTSQL127" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref48"></a><a id="BABBFBEI"></a>Table 1-2 Data type mapping: ANSI SQL to TImesTen</p>
<table class="cellalignment6330" title="Data type mapping: ANSI SQL to TImesTen" summary="This table maps ANSI SQL data types to TimesTen data types." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t3">ANSI SQL data type</th>
<th class="cellalignment6331" id="r1c2-t3">TimesTen data type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t3" headers="r1c1-t3">
<p><a id="sthref49"></a><code dir="ltr">CHARACTER VARYING(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code> or</p>
<p><a id="sthref50"></a><code dir="ltr">CHAR VARYING(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code></p>
</td>
<td class="cellalignment6332" headers="r2c1-t3 r1c2-t3">
<p><code dir="ltr">VARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code></p>
<p>Character semantics is supported.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t3" headers="r1c1-t3">
<p><a id="sthref51"></a><code dir="ltr">DOUBLE [PRECISION]</code></p>
</td>
<td class="cellalignment6332" headers="r3c1-t3 r1c2-t3">
<p><code dir="ltr">NUMBER</code></p>
<p>Floating-point number with a binary precision of 126.</p>
<p>Alternatively, specify <code dir="ltr">FLOAT(126)</code> or <code dir="ltr">ORA_FLOAT(126)</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t3" headers="r1c1-t3">
<p><a id="sthref52"></a><code dir="ltr">FLOAT[(</code><code dir="ltr"><span class="codeinlineitalic">b</span></code><code dir="ltr">)]</code></p>
</td>
<td class="cellalignment6332" headers="r4c1-t3 r1c2-t3">
<p><code dir="ltr">NUMBER</code></p>
<p>Floating-point number with binary precision <code dir="ltr"><span class="codeinlineitalic">b</span></code>. Acceptable values for <code dir="ltr"><span class="codeinlineitalic">b</span></code> are between 1 and 126 (binary digits).</p>
<p><code dir="ltr">FLOAT</code> is an exact numeric type. Use <code dir="ltr">FLOAT</code> to define a column with a floated scale and a specified precision. A floated scale is supported with the <code dir="ltr">NUMBER</code> type, but you cannot specify the precision. A lower precision requires less space, so because you can specify a precision with <code dir="ltr">FLOAT</code>, it may be more desirable than <code dir="ltr">NUMBER</code>. If you do not specify <code dir="ltr"><span class="codeinlineitalic">b</span></code>, then the default precision is 126 binary (38 decimal).</p>
<p><code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> are inexact numeric types and are therefore different floating types than <code dir="ltr">FLOAT</code>. In addition, the semantics are different between <code dir="ltr">FLOAT</code> and <code dir="ltr">BINARY_FLOAT</code>/<code dir="ltr">BINARY_DOUBLE</code> because <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> conform to the IEEE standard.</p>
<p>Internally, <code dir="ltr">FLOAT</code> is implemented as type <code dir="ltr">NUMBER</code>.</p>
<p>Alternatively, specify <code dir="ltr">ORA_FLOAT</code>. For example:</p>
<p><code dir="ltr">FLOAT(24) = ORA_FLOAT(24)</code></p>
<p><code dir="ltr">FLOAT(53) = ORA_FLOAT(53</code>)</p>
<p><code dir="ltr">FLOAT(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">) = ORA_FLOAT(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t3" headers="r1c1-t3">
<p><a id="sthref53"></a><code dir="ltr">INT[EGER]</code></p>
</td>
<td class="cellalignment6332" headers="r5c1-t3 r1c2-t3">
<p><code dir="ltr">NUMBER</code><code dir="ltr">(38,0)</code></p>
<p><code dir="ltr">TT_INTEGER</code> is a native 32-bit integer type. Use <code dir="ltr">TT_INTEGER</code>, as this data type is more compact and offers faster performance than the <code dir="ltr">NUMBER</code> type.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t3" headers="r1c1-t3">
<p><a id="sthref54"></a><code dir="ltr">NATIONAL CHARACTER(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> or</p>
<p><a id="sthref55"></a><code dir="ltr">NATIONAL</code> <code dir="ltr">CHAR</code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r6c1-t3 r1c2-t3">
<p><code dir="ltr">NCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r7c1-t3" headers="r1c1-t3">
<p><a id="sthref56"></a><code dir="ltr">NATIONAL CHARACTER VARYING(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> or</p>
<p><a id="sthref57"></a><code dir="ltr">NATIONAL CHAR VARYING(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> or</p>
<p><a id="sthref58"></a><code dir="ltr">NCHAR VARYING(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r7c1-t3 r1c2-t3">
<p><code dir="ltr">NVARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r8c1-t3" headers="r1c1-t3">
<p><a id="sthref59"></a><code dir="ltr">NUMERIC</code><code dir="ltr">[(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code> or</p>
<p><a id="sthref60"></a><code dir="ltr">DEC[IMAL][(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code></p>
</td>
<td class="cellalignment6332" headers="r8c1-t3 r1c2-t3">
<p><code dir="ltr">NUMBER(</code><code dir="ltr"><span class="codeinlineitalic">p,s</span></code><code dir="ltr">)</code></p>
<p>Specifies a fixed-point number with precision <code dir="ltr"><span class="codeinlineitalic">p</span></code> and scale <code dir="ltr"><span class="codeinlineitalic">s.</span></code> This can only be used for fixed-point numbers. If no scale is specified, <code dir="ltr"><span class="codeinlineitalic">s</span></code> defaults to 0.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r9c1-t3" headers="r1c1-t3">
<p><a id="sthref61"></a><code dir="ltr">REAL</code></p>
</td>
<td class="cellalignment6332" headers="r9c1-t3 r1c2-t3">
<p><code dir="ltr">NUMBER</code></p>
<p>Floating-point number with a binary precision of 63.</p>
<p>Alternatively, specify <code dir="ltr">ORA_FLOAT(63)</code> or <code dir="ltr">FLOAT(63)</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r10c1-t3" headers="r1c1-t3">
<p><a id="sthref62"></a><code dir="ltr">SMALLINT</code></p>
</td>
<td class="cellalignment6332" headers="r10c1-t3 r1c2-t3">
<p><code dir="ltr">NUMBER(38,0)</code></p>
<p><code dir="ltr">TT_SMALLINT</code> is a native signed integer data type. Using <code dir="ltr">TT_SMALLINT</code> is more compact and offers faster performance than the <code dir="ltr">NUMBER</code> type.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect1" -->
<a id="i1028151"></a>
<div id="TTSQL128" class="sect1">
<h2 class="sect1"><a id="sthref63"></a><a id="sthref64"></a><a id="sthref65"></a><a id="sthref66"></a><a id="sthref67"></a>Types supported for backward compatibility in Oracle type mode</h2>
<p>TimesTen supports the data types shown in <a href="#BABCFGBG">Table 1-3</a> for backward compatibility in Oracle type mode.</p>
<div id="TTSQL129" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref68"></a><a id="BABCFGBG"></a>Table 1-3 Data types supported for backward compatibility in Oracle type mode</p>
<table class="cellalignment6330" title="Data types supported for backward compatibility in Oracle type mode" summary="This table contains descriptions of data types that are supported for backward compatibility in Oracle type mode." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t4">Data type</th>
<th class="cellalignment6331" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t4" headers="r1c1-t4">
<p><a id="i1028137"></a><a id="sthref69"></a><code dir="ltr">TT_CHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])]</code></p>
</td>
<td class="cellalignment6332" headers="r2c1-t4 r1c2-t4">
<p>Fixed-length character string of length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes or characters</p>
<p>Default is one byte.</p>
<p><code dir="ltr">BYTE</code> indicates that the column has byte-length semantics. Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> range from a minimum of one byte to a maximum 8300 bytes.</p>
<p><code dir="ltr">CHAR</code> indicates that the column has character-length semantics. The minimum <code dir="ltr">CHAR</code> length is one character. The maximum <code dir="ltr">CHAR</code> length depends on how many characters fit in 8300 bytes. This is determined by the database character set in use. For character set <code dir="ltr">AL32UTF8</code>, up to four bytes per character may be needed, so the <code dir="ltr">CHAR</code> length limit ranges from 2075 to 8300 depending on the character set.</p>
<p>If you insert a zero-length (empty) string into a column, the SQL <code dir="ltr">NULL</code> value is inserted. This is true in Oracle type mode only.</p>
<p><code dir="ltr">TT_CHAR</code> data is padded to the maximum column size with trailing blanks. Blank-padded comparison semantics are used.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t4" headers="r1c1-t4">
<p><a id="sthref70"></a><code dir="ltr">TT_DECIMAL[(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code></p>
</td>
<td class="cellalignment6332" headers="r3c1-t4 r1c2-t4">
<p>An exact numeric value with a fixed maximum precision (total number of digits) and scale (number of digits to the right of the decimal point)</p>
<p>The precision <code dir="ltr"><span class="codeinlineitalic">p</span></code> must be between 1 and 40. The scale <code dir="ltr"><span class="codeinlineitalic">s</span></code> must be between 0 and <code dir="ltr"><span class="codeinlineitalic">p</span></code>. The default precision is 40 and the default scale is 0.</p>
<p>Use the <code dir="ltr">NUMBER</code> data type, which offers better performance, rather than <code dir="ltr">TT_DECIMAL</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t4" headers="r1c1-t4">
<p><a id="sthref71"></a><code dir="ltr">TT_NCHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)]</code></p>
</td>
<td class="cellalignment6332" headers="r4c1-t4 r1c2-t4">
<p>Fixed-length string of <code dir="ltr"><span class="codeinlineitalic">n</span></code> two-byte Unicode characters</p>
<p>The number of bytes required is 2*<code dir="ltr"><span class="codeinlineitalic">n</span></code> where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is the specified number of characters. <code dir="ltr">NCHAR</code> character limits are half the byte limits so the maximum size is 4150.</p>
<p>If you insert a zero-length (empty) string into a column, the SQL <code dir="ltr">NULL</code> value is inserted. This is true in Oracle type mode only.</p>
<p><code dir="ltr">TT_NCHAR</code> data is padded to the maximum column size with <code dir="ltr">U+0020 SPACE</code>. Blank-padded comparison semantics are used.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t4" headers="r1c1-t4">
<p><a id="sthref72"></a><code dir="ltr">TT_NVARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r5c1-t4 r1c2-t4">
<p>Variable-length string of <code dir="ltr"><span class="codeinlineitalic">n</span></code> two-byte Unicode characters</p>
<p>The number of bytes required is 2*<code dir="ltr"><span class="codeinlineitalic">n</span></code> where n is the specified number of characters. <code dir="ltr">TT_NVARCHAR</code> character limits are half the byte limits so the maximum size is 2,097,152 (2<sup>21</sup>). You must specify <code dir="ltr"><span class="codeinlineitalic">n</span></code>.</p>
<p>If you insert a zero-length (empty) string into a column, the SQL <code dir="ltr">NULL</code> value is inserted. This is true in Oracle type mode only.</p>
<p>Blank-padded comparison semantics are used.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t4" headers="r1c1-t4">
<p><a id="sthref73"></a><code dir="ltr">TT_VARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code></p>
</td>
<td class="cellalignment6332" headers="r6c1-t4 r1c2-t4">
<p>Variable-length character string having maximum length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes or characters</p>
<p>You must specify <code dir="ltr"><span class="codeinlineitalic">n</span></code>. <code dir="ltr">BYTE</code> indicates that the column has byte-length semantics. Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> range from a minimum of 1 byte to a maximum 4194304 (2<sup>22</sup>) bytes.</p>
<p><code dir="ltr">CHAR</code> indicates that the column has character-length semantics.</p>
<p>If you insert a zero-length (empty) string into a column, the SQL <code dir="ltr">NULL</code> value is inserted. This is true in Oracle type mode only.</p>
<p>Blank-padded comparison semantics are used.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect1" -->
<a id="BABIIACI"></a>
<div id="TTSQL130" class="sect1">
<h2 class="sect1"><a id="sthref74"></a><a id="sthref75"></a>TimesTen type mapping</h2>
<p>The names of the data types listed in the left column of <a href="#BABCBAFD">Table 1-4</a> are the data types that existed in previous releases of TimesTen. If <code dir="ltr">TypeMode</code> is set to 0 (the default), indicating Oracle type mode, the name of the data type may be changed to a new name in Oracle type mode. The name of the data type in Oracle type mode is listed in the right column. The table illustrates the mapping of the data type in the left column to the corresponding data type in the right column.</p>
<div id="TTSQL131" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref76"></a><a id="BABCBAFD"></a>Table 1-4 Data type mapping: TimesTen data type to TimesTen data type in Oracle type mode</p>
<table class="cellalignment6330" title="Data type mapping: TimesTen data type to TimesTen data type in Oracle type mode" summary="The table illustrates the mapping of the data type in the left column to the corresponding data type in the right column." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t5">TimesTen data type</th>
<th class="cellalignment6331" id="r1c2-t5">TimesTen data type in Oracle type mode</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t5" headers="r1c1-t5">
<p><code dir="ltr">BIGINT</code></p>
</td>
<td class="cellalignment6332" headers="r2c1-t5 r1c2-t5">
<p><code dir="ltr">TT_BIGINT</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_BIGINT</code>. For more information on <code dir="ltr">TT_BIGINT</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t5" headers="r1c1-t5">
<p><code dir="ltr">BINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r3c1-t5 r1c2-t5">
<p><code dir="ltr">BINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
<p>In Oracle type mode, the data type has the same name. For more information on <code dir="ltr">BINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t5" headers="r1c1-t5">
<p><code dir="ltr">CHAR[ACTER][(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)]</code></p>
</td>
<td class="cellalignment6332" headers="r4c1-t5 r1c2-t5">
<p><code dir="ltr">TT_CHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])]</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_CHAR</code>. Character semantics is supported. For more information on type <code dir="ltr">TT_CHAR</code>, see <a href="#i1028151">&#34;Types supported for backward compatibility in Oracle type mode&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t5" headers="r1c1-t5">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment6332" headers="r5c1-t5 r1c2-t5">
<p><code dir="ltr">TT_DATE</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_DATE</code>. For more information on <code dir="ltr">TT_DATE</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t5" headers="r1c1-t5">
<p><code dir="ltr">DEC[IMAL][(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code> or</p>
<p><code dir="ltr">NUMERIC[(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code></p>
</td>
<td class="cellalignment6332" headers="r6c1-t5 r1c2-t5">
<p><code dir="ltr">TT_DECIMAL[(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_DECIMAL</code>.</p>
<p>For more information on <code dir="ltr">TT_DECIMAL</code>, see <a href="#i1028151">&#34;Types supported for backward compatibility in Oracle type mode&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r7c1-t5" headers="r1c1-t5">
<p><code dir="ltr">DOUBLE [PRECISION]</code> or</p>
<p><code dir="ltr">FLOAT[(53)]</code></p>
</td>
<td class="cellalignment6332" headers="r7c1-t5 r1c2-t5">
<p><code dir="ltr">BINARY_DOUBLE</code></p>
<p>In Oracle type mode, specify <code dir="ltr">BINARY_DOUBLE</code>. For more information on <code dir="ltr">BINARY_DOUBLE</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r8c1-t5" headers="r1c1-t5">
<p><code dir="ltr">INT[EGER]</code></p>
</td>
<td class="cellalignment6332" headers="r8c1-t5 r1c2-t5">
<p><code dir="ltr">TT_INT[EGER]</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_INTEGER</code>. For more information on <code dir="ltr">TT_INTEGER</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r9c1-t5" headers="r1c1-t5">
<p><code dir="ltr">INTERVAL</code> <code dir="ltr"><span class="codeinlineitalic">IntervalQualifier</span></code></p>
</td>
<td class="cellalignment6332" headers="r9c1-t5 r1c2-t5">
<p><code dir="ltr">INTERVAL</code> <code dir="ltr"><span class="codeinlineitalic">IntervalQualifier</span></code></p>
<p>In Oracle type mode, the data type has the same name. For more information on interval types, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r10c1-t5" headers="r1c1-t5">
<p><code dir="ltr">NCHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)]</code></p>
</td>
<td class="cellalignment6332" headers="r10c1-t5 r1c2-t5">
<p><code dir="ltr">TT_NCHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)]</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_CHAR</code>. For more information on <code dir="ltr">TT_NCHAR</code>, see <a href="#i1028151">&#34;Types supported for backward compatibility in Oracle type mode&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r11c1-t5" headers="r1c1-t5">
<p><code dir="ltr">NVARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r11c1-t5 r1c2-t5">
<p><code dir="ltr">TT_NVARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_NVARCHAR</code>. For more information on <code dir="ltr">TT_NVARCHAR</code>, see <a href="#i1028151">&#34;Types supported for backward compatibility in Oracle type mode&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r12c1-t5" headers="r1c1-t5">
<p><code dir="ltr">REAL</code> or</p>
<p><code dir="ltr">FLOAT(24)</code></p>
</td>
<td class="cellalignment6332" headers="r12c1-t5 r1c2-t5">
<p><code dir="ltr">BINARY_FLOAT</code></p>
<p>In Oracle type mode, specify <code dir="ltr">BINARY_FLOAT</code>. For more information on <code dir="ltr">BINARY_FLOAT</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r13c1-t5" headers="r1c1-t5">
<p><code dir="ltr">SMALLINT</code></p>
</td>
<td class="cellalignment6332" headers="r13c1-t5 r1c2-t5">
<p><code dir="ltr">TT_SMALLINT</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_SMALLINT</code>. For more information on <code dir="ltr">TT_SMALLINT</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r14c1-t5" headers="r1c1-t5">
<p><code dir="ltr">TIME</code></p>
</td>
<td class="cellalignment6332" headers="r14c1-t5 r1c2-t5">
<p><code dir="ltr">TIME</code></p>
<p>In Oracle type mode, the data type has the same name. For more information on <code dir="ltr">TIME</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r15c1-t5" headers="r1c1-t5">
<p><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment6332" headers="r15c1-t5 r1c2-t5">
<p><code dir="ltr">TT_TIMESTAMP</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_TIMESTAMP</code>. For more information on <code dir="ltr">TT_TIMESTAMP</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r16c1-t5" headers="r1c1-t5">
<p><code dir="ltr">TINYINT</code></p>
</td>
<td class="cellalignment6332" headers="r16c1-t5 r1c2-t5">
<p><code dir="ltr">TT_TINYINT</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_TINYINT</code>. For more information on <code dir="ltr">TT_TINYINT</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r17c1-t5" headers="r1c1-t5">
<p><code dir="ltr">VARBINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r17c1-t5 r1c2-t5">
<p><code dir="ltr">VARBINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
<p>In Oracle type mode, the data type has the same name. For more information on <code dir="ltr">VARBINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code>, see <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r18c1-t5" headers="r1c1-t5">
<p><code dir="ltr">VARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r18c1-t5 r1c2-t5">
<p><code dir="ltr">TT_VARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code></p>
<p>In Oracle type mode, specify <code dir="ltr">TT_VARCHAR</code>. Character semantics is supported. For more information on <code dir="ltr">TT_VARCHAR</code>, see <a href="#i1028151">&#34;Types supported for backward compatibility in Oracle type mode&#34;</a>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect1" -->
<a id="i1035539"></a>
<div id="TTSQL132" class="sect1">
<h2 class="sect1"><a id="sthref77"></a><a id="sthref78"></a>Character data types</h2>
<p>Character data types store character (alphanumeric) data either in the database character set or the UTF-16 format. Character data is stored in strings with byte values. The byte values correspond to one of the database character sets defined when the database is created. TimesTen supports both single and multibyte character sets.</p>
<p>The character types are as follows:</p>
<ul>
<li>
<p><a href="#BABCDEJC">CHAR</a></p>
</li>
<li>
<p><a href="#BABDFECH">NCHAR</a></p>
</li>
<li>
<p><a href="#BABFCCHG">VARCHAR2</a></p>
</li>
<li>
<p><a href="#BABHGCBA">NVARCHAR2</a></p>
</li>
</ul>
<a id="BABCDEJC"></a>
<div id="TTSQL133" class="sect2">
<h3 class="sect2"><a id="sthref79"></a>CHAR</h3>
<p>The <code dir="ltr">CHAR</code> type specifies a fixed length character string. If you insert a value into a <code dir="ltr">CHAR</code> column and the value is shorter than the defined column length, then TimesTen blank-pads the value to the column length. If you insert a value into a <code dir="ltr">CHAR</code> column and the value is longer than the defined length, TimesTen returns an error.</p>
<p>By default, the column length is defined in bytes. Use the <code dir="ltr">CHAR</code> qualifier to define the column length in characters. The size of a character ranges from one byte to four bytes depending on the database character set. The <code dir="ltr">BYTE</code> and <code dir="ltr">CHAR</code> qualifiers override the <code dir="ltr">NLS_LENGTH_SEMANTICS</code> parameter setting. For more information about <code dir="ltr">NLS_LENGTH_SEMANTICS</code>, see <a href="state.htm#i1333852">&#34;ALTER SESSION&#34;</a>. Also see <a class="olink TTOPR290" href="../TTOPR/globalization.htm#TTOPR290">&#34;Setting globalization support attributes&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
With the <code dir="ltr">CHAR</code> type, a zero-length string is interpreted as <code dir="ltr">NULL</code>. With the <code dir="ltr">TT_CHAR</code> type, a zero-length string is a valid non-<code dir="ltr">NULL</code> value. Both <code dir="ltr">CHAR</code> and <code dir="ltr">TT_CHAR</code> use blank padded comparison semantics. The <code dir="ltr">TT_CHAR</code> type is supported for backward compatibility.</div>
<p>The following example creates a table. Columns are defined with type <code dir="ltr">CHAR</code> and <code dir="ltr">TT_CHAR</code>. Blank padded comparison semantics are used for these types.</p>
<pre dir="ltr">Command&gt; CREATE TABLE typedemo (name CHAR (20), nnme2 TT_CHAR (20));
Command&gt; INSERT INTO typedemo VALUES (&#39;SMITH     &#39;,&#39;SMITH     &#39;);
1 row inserted.
Command&gt; DESCRIBE typedemo;
Table USER.TYPEDEMO:
  Columns:
    NAME                            CHAR (20)
    NAME2                           TT_CHAR (20)
1 table found.
(primary key columns are indicated with *)
Command&gt; SELECT * FROM typedemo;
&lt; SMITH     , SMITH      &gt;
1 row found.
Command&gt; # Expect 1 row found; blank-padded comparison semantics
Command&gt; SELECT * FROM typedemo WHERE name = &#39;SMITH&#39;;
&lt; SMITH     , SMITH      &gt;
1 row found.
Command&gt; SELECT * FROM typedemo WHERE name2 = &#39;SMITH&#39;;
&lt; SMITH     , SMITH      &gt;
1 row found.
Command&gt; # Expect 0 rows; blank padded comparison semantics.
Command&gt; SELECT * FROM typedemo WHERE name &gt; &#39;SMITH&#39;;
0 rows found.
Command&gt; SELECT * FROM typedemo WHERE name2 &gt; &#39;SMITH&#39;;
0 rows found.
</pre>
<p>The following example alters table <code dir="ltr">typedemo</code> adding column <code dir="ltr">name3</code>. The column <code dir="ltr">name3</code> is defined with character semantics.</p>
<pre dir="ltr">Command&gt; ALTER TABLE typedemo ADD COLUMN name3 CHAR (10 CHAR);
Command&gt; DESCRIBE typedemo;
Table USER.TYPEDEMO:
  Columns:
    NAME                            CHAR (20)
    NAME2                           TT_CHAR (20)
    NAME3                           CHAR (10 CHAR)
1 table found.
</pre></div>
<!-- class="sect2" -->
<a id="BABDFECH"></a>
<div id="TTSQL134" class="sect2">
<h3 class="sect2"><a id="sthref80"></a>NCHAR</h3>
<p>The <code dir="ltr">NCHAR</code> data type is a fixed length string of two-byte Unicode characters. <code dir="ltr">NCHAR</code> data types are padded to the specified length with the Unicode space character <code dir="ltr">U+0020 SPACE</code>. Blank-padded comparison semantics are used.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
With the <code dir="ltr">NCHAR</code> type, a zero-length string is interpreted as <code dir="ltr">NULL</code>. With the <code dir="ltr">TT_NCHAR</code> type, a zero-length string is a valid non-null value. Both <code dir="ltr">NCHAR</code> and <code dir="ltr">TT_NCHAR</code> use blank padded comparison semantics. The <code dir="ltr">TT_NCHAR</code> type is supported for backward compatibility.</div>
<p>The following example alters table <code dir="ltr">typedemo</code> to add column <code dir="ltr">Name4</code>. Data type is <code dir="ltr">NCHAR</code>.</p>
<pre dir="ltr">Command&gt; ALTER TABLE typedemo ADD COLUMN Name4 NCHAR (10);
Command&gt; DESCRIBE typedemo;

Table USER.TYPEDEMO:
  Columns:
    NAME                            CHAR (20)
    NAME2                           TT_CHAR (20)
    NAME3                           CHAR (10 CHAR)
    NAME4                           NCHAR (10)
1 table found.
</pre></div>
<!-- class="sect2" -->
<a id="BABFCCHG"></a>
<div id="TTSQL135" class="sect2">
<h3 class="sect2"><a id="sthref81"></a>VARCHAR2</h3>
<p>The <code dir="ltr">VARCHAR2</code> data type specifies a variable length character string. When you define a <code dir="ltr">VARCHAR2</code> column, you define the maximum number of bytes or characters. Each value is stored exactly as you specify it. The value cannot exceed the maximum length of the column.</p>
<p>You must specify the maximum length. The minimum must be at least one byte. Use the <code dir="ltr">CHAR</code> qualifier to specify the maximum length in characters. For example, <code dir="ltr">VARCHAR2(10 CHAR)</code>.</p>
<p>The size of a character ranges from one byte to four bytes depending on the database character set. The <code dir="ltr">BYTE</code> and <code dir="ltr">CHAR</code> qualifiers override the <code dir="ltr">NLS_LENGTH_SEMANTICS</code> parameter setting. For more information on <code dir="ltr">NLS_LENGTH_SEMANTICS</code>, see <a href="state.htm#i1333852">&#34;ALTER SESSION&#34;</a>. Also see <a class="olink TTOPR290" href="../TTOPR/globalization.htm#TTOPR290">&#34;Setting globalization support attributes&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>.</p>
<p>The <a id="sthref82"></a><code dir="ltr">NULL</code> value is stored as a single bit for each nullable field within the row. A <code dir="ltr">NOT INLINE VARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> whose value is <code dir="ltr">NULL</code> takes (null bit) + four bytes of storage on 32-bit platforms, whereas an <code dir="ltr">INLINE VARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> whose value is <code dir="ltr">NULL</code> takes (null bit) + four bytes + <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes of storage, or <code dir="ltr"><span class="codeinlineitalic">n</span></code> more bytes of storage than a <code dir="ltr">NOT INLINE VARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> whose value is <code dir="ltr">NULL</code>. This storage principal holds for all variable length data types: <code dir="ltr">TT_VARCHAR</code>, <code dir="ltr">TT_NVARCHAR</code>, <code dir="ltr">VARCHAR2</code>, <code dir="ltr">NVARCHAR2</code>, <code dir="ltr">VARBINARY</code>.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>Do not use the <code dir="ltr">VARCHAR</code> data type. Use <code dir="ltr">VARCHAR2</code>. Even though both data types are currently synonymous, the <code dir="ltr">VARCHAR</code> data type may be redefined as a different data type with different semantics.</p>
</li>
<li>
<p>With the <code dir="ltr">VARCHAR2</code> type, a zero-length string is interpreted as <code dir="ltr">NULL</code>. With the <code dir="ltr">TT_VARCHAR</code> type, a zero-length string is a valid non-NULL value. <code dir="ltr">VARCHAR2</code> uses nonpadded comparison semantics. <code dir="ltr">TT_VARCHAR</code> uses blank-padded comparison semantics. The <code dir="ltr">TT_VARCHAR</code> type is supported for backward compatibility.</p>
</li>
</ul>
</div>
<p>The following example alters table <code dir="ltr">typedemo</code>, adding columns <code dir="ltr">name5</code> and <code dir="ltr">name6</code>. The <code dir="ltr">name5</code> column is defined with type <code dir="ltr">VARCHAR2</code>. The <code dir="ltr">name6</code> column is defined with <code dir="ltr">TT_VARCHAR</code>. The example illustrates the use of nonpadded comparison semantics with column <code dir="ltr">name5</code> and blank-padded comparison semantics with column <code dir="ltr">name6</code>:</p>
<pre dir="ltr">Command&gt; ALTER TABLE typedemo ADD COLUMN name5 VARCHAR2 (20);
Command&gt; ALTER TABLE typedemo ADD COLUMN name6 TT_VARCHAR (20);
Command&gt; DESCRIBE typedemo;
Table USER.TYPEDEMO:
  Columns:
    NAME                            CHAR (20)
    NAME2                           TT_CHAR (20)
    NAME3                           CHAR (10 CHAR)
    NAME4                           NCHAR (10)
    NAME5                           VARCHAR2 (20) INLINE
    NAME6                           TT_VARCHAR (20) INLINE
1 table found.
(primary key columns are indicated with *)
Command&gt; #Insert SMITH followed by 5 spaces into all columns
Command&gt; INSERT INTO typedemo VALUES
       &gt; (&#39;SMITH     &#39;, &#39;SMITH     &#39;, &#39;SMITH     &#39;, &#39;SMITH     &#39;,&#39;SMITH     &#39;,
       &gt; &#39;SMITH&#39;);
1 row inserted.
Command&gt; # Expect 0; Nonpadded comparison semantics
Command&gt; SELECT COUNT (*) FROM typedemo WHERE name5 = &#39;SMITH&#39;;
&lt; 0 &gt;
1 row found.
Command&gt; # Expect 1; Blank-padded comparison semantics
Command&gt; SELECT COUNT (*) FROM typedemo WHERE name6 = &#39;SMITH&#39;;
&lt; 1 &gt;
1 row found.
Command&gt; # Expect 1; Nonpadded comparison semantics
Command&gt; SELECT COUNT (*) FROM typedemo WHERE name5 &gt; &#39;SMITH&#39;;
&lt; 1 &gt;
1 row found.
Command&gt; # Expect 0; Blank-padded comparison semantics
Command&gt; SELECT COUNT (*) FROM typedemo WHERE name6 &gt; &#39;SMITH&#39;;
&lt; 0 &gt;
1 row found.
</pre></div>
<!-- class="sect2" -->
<a id="BABHGCBA"></a>
<div id="TTSQL136" class="sect2">
<h3 class="sect2"><a id="sthref83"></a>NVARCHAR2</h3>
<p>The <code dir="ltr">NVARCHAR2</code> data type is a variable length string of two-byte Unicode characters. When you define an <code dir="ltr">NVARCHAR2</code> column, you define the maximum number of characters. Each value is stored exactly as you specify it. The value cannot exceed the maximum length of the column.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
With the <code dir="ltr">NVARCHAR2</code> type, a zero-length string is interpreted as <code dir="ltr">NULL</code>. With the <code dir="ltr">TT_NVARCHAR</code> type, a zero-length string is a valid non-NULL value. <code dir="ltr">NVARCHAR2</code> uses nonpadded comparison semantics. <code dir="ltr">TT_NVARCHAR</code> uses blank-padded comparison semantics. The <code dir="ltr">TT_NVARCHAR</code> type is supported for backward compatibility.</div>
<p>The following example alters table <code dir="ltr">typedemo</code> to add column <code dir="ltr">name7</code>. Data type is <code dir="ltr">NVARCHAR2</code>.</p>
<pre dir="ltr">Command&gt; ALTER TABLE typedemo ADD COLUMN Nnme7 NVARCHAR2 (20);
Command&gt; DESCRIBE typedemo;
Table USER1.TYPEDEMO:
  Columns:
    NAME                            CHAR (20)
    NAME2                           TT_CHAR (20)
    NAME3                           CHAR (10 CHAR)
    NAME4                           NCHAR (10)
    NAME5                           VARCHAR2 (20) INLINE
    NAME6                           TT_VARCHAR (20) INLINE
    NAME7                           NVARCHAR2 (20) INLINE
1 table found.
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1029200"></a>
<div id="TTSQL137" class="sect1">
<h2 class="sect1"><a id="sthref84"></a><a id="sthref85"></a>Numeric data types</h2>
<p>Numeric types store positive and negative fixed and floating-point numbers, zero, infinity, and values that are the undefined result of an operation (<code dir="ltr">NaN</code>, meaning not a number).</p>
<p>TimesTen supports both exact and approximate numeric data types. Arithmetic operations can be performed on numeric types only. Similarly, <code dir="ltr">SUM</code> and <code dir="ltr">AVG</code> aggregates require numeric types.</p>
<p>Fol<a id="sthref86"></a>lowing are the exact numeric types.</p>
<ul>
<li>
<p><a href="#BABCBDFI">NUMBER</a></p>
</li>
<li>
<p><a href="#BABJGDFA">TT_BIGINT</a></p>
</li>
<li>
<p><a href="#BABBDGDD">TT_INTEGER</a></p>
</li>
<li>
<p><a href="#BABEDBHD">TT_SMALLINT</a></p>
</li>
<li>
<p><a href="#BABBIIGG">TT_TINYINT</a></p>
</li>
</ul>
<p>The <a id="sthref87"></a>approximate types are:</p>
<ul>
<li>
<p><a href="#BABIGDEA">BINARY_DOUBLE</a></p>
</li>
<li>
<p><a href="#BABGAEGB">BINARY_FLOAT</a></p>
</li>
<li>
<p><a href="#BABIIIGI">FLOAT and FLOAT(<span class="italic">n</span>)</a></p>
</li>
</ul>
<a id="BABCBDFI"></a>
<div id="TTSQL139" class="sect2">
<h3 class="sect2"><a id="sthref88"></a>NUMBER</h3>
<p>The <code dir="ltr">NUMBER</code> data type stores both zero and positive and negative fixed numbers with absolute values from 1.0 x 10 <sup>-130</sup> up to but not including 1.0 x 10 <sup>126</sup>. Each <code dir="ltr">NUMBER</code> value requires from five to 22 bytes.</p>
<p>Specify a fixed-point number as <code dir="ltr">NUMBER(</code><code dir="ltr"><span class="codeinlineitalic">p,s</span></code><code dir="ltr">)</code>, where the following holds:</p>
<ul>
<li>
<p>The argument <code dir="ltr"><span class="codeinlineitalic">p</span></code> is the precision or the total number of significant decimal digits, where the most significant digit is the left-most nonzero digit and the least significant digit is the right-most known digit.</p>
</li>
<li>
<p>The argument <code dir="ltr"><span class="codeinlineitalic">s</span></code> is the scale, or the number of digits from the decimal point to the least significant digit. The scale ranges from -84 to 127.</p>
<ul>
<li>
<p>Positive scale is the number of significant digits to the right of the decimal point up to and including the least significant digit.</p>
</li>
<li>
<p>Negative scale is the number of significant digits to the left of the decimal point up to but not including the least significant digit. For negative scale, the least significant digit is on the left side of the decimal point, because the number is rounded to the specified number of places to the left of the decimal point.</p>
</li>
</ul>
</li>
</ul>
<p>Scale can be greater than precision. For example, in the case of E-notation. When scale is greater than precision, the precision specifies the maximum number of significant digits to the right of the decimal point. For example, if you define the column as type <code dir="ltr">NUMBER(4,5)</code> and you insert .000127 into the column, the value is stored as .00013. A zero is required for the first digit after the decimal point. TimesTen rounds values after the fifth digit to the right of the decimal point.</p>
<p>If a value exceeds the precision, then TimesTen returns an error. If a value exceeds the scale, then TimesTen rounds the value.</p>
<p><code dir="ltr">NUMBER(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code> represents a fixed-point number with precision <code dir="ltr"><span class="codeinlineitalic">p</span></code> and scale 0 and is equivalent to <code dir="ltr">NUMBER(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">,0)</code>.</p>
<p>Specify a floating-point number as <code dir="ltr">NUMBER</code>. If you do not specify precision and scale, TimesTen uses the maximum precision and scale.</p>
<p>The following example alters table <code dir="ltr">numerics</code> by adding columns <code dir="ltr">col6</code>, <code dir="ltr">col7</code>, <code dir="ltr">col8</code>, and <code dir="ltr">col9</code> defined with the <code dir="ltr">NUMBER</code> data type and specified with different precisions and scales.</p>
<pre dir="ltr">Command&gt; ALTER TABLE numerics ADD col6 NUMBER;
Command&gt; ALTER TABLE numerics ADD col7 NUMBER (4,2);
Command&gt; ALTER TABLE numerics ADD col8 NUMBER (4,-2);
Command&gt; ALTER TABLE numerics ADD col8 NUMBER (2,4);
Command&gt; ALTER TABLE numerics ADD col9 NUMBER (2,4);
Command&gt; DESCRIBE numerics;
Table USER1.NUMERICS:
  Columns:
    COL1                            TT_TINYINT
    COL2                            TT_SMALLINT
    COL3                            TT_INTEGER
    COL4                            TT_INTEGER
    COL5                            TT_BIGINT
    COL6                            NUMBER
    COL7                            NUMBER (4,2)
    COL8                            NUMBER (4,-2)
    COL9                            NUMBER (2,4)
1 table found.
(primary key columns are indicated with *)
</pre>
<p>The next example creates table <code dir="ltr">numbercombo</code> and defines columns with the <code dir="ltr">NUMBER</code> data type using different precisions and scales. The value 123.89 is inserted into the columns.</p>
<pre dir="ltr">Command&gt; CREATE TABLE numbercombo (col1 NUMBER, col2 NUMBER (3), 
       &gt; col3 NUMBER (6,2), col4 NUMBER (6,1), col5 NUMBER (6,-2));
Command&gt; DESCRIBE numbercombo;
Table USER1.NUMBERCOMBO:
  Columns:
    COL1                            NUMBER
    COL2                            NUMBER (3)
    COL3                            NUMBER (6,2)
    COL4                            NUMBER (6,1)
    COL5                            NUMBER (6,-2)
1 table found.
(primary key columns are indicated with *)
Command&gt; INSERT INTO numbercombo VALUES (123.89,123.89,123.89,123.89,123.89);
1 row inserted.
Command&gt; VERTICAL ON;
Command&gt; SELECT * FROM numbercombo;
COL1:   123.89
  COL2:   124
  COL3:   123.89
  COL4:   123.9
  COL5:   100
1 row found.
</pre>
<p>The next example creates a table and defines a column with data type <code dir="ltr">NUMBER(4,2)</code>. An attempt to insert a value of 123.89 results in an overflow error.</p>
<pre dir="ltr">Command&gt; CREATE TABLE invnumbervalue (col6 NUMBER (4,2));
Command&gt; INSERT INTO invnumbervalue VALUES (123.89);
 2923: Number type value overflow
The command failed.
</pre>
<p>The next example creates a table and defines columns with the <code dir="ltr">NUMBER</code> data type using a scale that is greater than the precision. Values are inserted into the columns.</p>
<pre dir="ltr">Command&gt; CREATE TABLE numbercombo2 (col1 NUMBER (4,5), col2 NUMBER (4,5), 
       &gt; col3 NUMBER (4,5), col4 NUMBER (2,7), col5 NUMBER (2,7), 
       &gt; col6 NUMBER (2,5), col7 NUMBER (2,5));
Command&gt; INSERT INTO numbercombo2 VALUES 
       &gt; (.01234, .00012, .000127, .0000012, .00000123, 1.2e-4, 1.2e-5);
1 row inserted.
Command&gt; DESCRIBE numbercombo2;
Table USER1.NUMBERCOMBO2:
  Columns:
    COL1                            NUMBER (4,5)
    COL2                            NUMBER (4,5)
    COL3                            NUMBER (4,5)
    COL4                            NUMBER (2,7)
    COL5                            NUMBER (2,7)
    COL6                            NUMBER (2,5)
    COL7                            NUMBER (2,5)
1 table found.

(primary key columns are indicated with *)
Command&gt; SELECT * FROM numbercombo2;
COL1:   .01234
  COL2:   .00012
  COL3:   .00013
  COL4:   .0000012
  COL5:   .0000012
  COL6:   .00012
  COL7:   .00001
1 row found.
</pre></div>
<!-- class="sect2" -->
<a id="BABJGDFA"></a>
<div id="TTSQL140" class="sect2">
<h3 class="sect2"><a id="sthref89"></a>TT_BIGINT</h3>
<p>The <code dir="ltr">TT_BIGINT</code> data type is a signed integer that ranges from -9,223,372,036,854,775,808 (-2<sup>63</sup>) to 9,223,372,036,854,775,807 (2<sup>63</sup>-1). It requires eight bytes of storage and thus is more compact than the <code dir="ltr">NUMBER</code> data type. It also has better performance than the <code dir="ltr">NUMBER</code> data type. You cannot specify <code dir="ltr">BIGINT</code>.</p>
<p>This example alters table <code dir="ltr">numerics</code> and attempts to add <code dir="ltr">col5</code> with a data type of <code dir="ltr">BIGINT</code>. TimesTen generates an error. A second <code dir="ltr">ALTER TABLE</code> successfully adds <code dir="ltr">col5</code> with the data type <code dir="ltr">TT_BIGINT</code>.</p>
<pre dir="ltr">Command&gt; ALTER TABLE numerics ADD COLUMN col5 BIGINT;
 3300: BIGINT is not a valid type name; use TT_BIGINT instead
The command failed.
Command&gt; ALTER TABLE numerics ADD COLUMN col5 TT_BIGINT;
Command&gt; DESCRIBE numerics;
Table USER1.NUMERICS:
  Columns:
    COL1                            TT_TINYINT
    COL2                            TT_SMALLINT
    COL3                            TT_INTEGER
    COL4                            TT_INTEGER
    COL5                            TT_BIGINT
1 table found.
(primary key columns are indicated with *)
</pre></div>
<!-- class="sect2" -->
<a id="BABBDGDD"></a>
<div id="TTSQL141" class="sect2">
<h3 class="sect2"><a id="sthref90"></a>TT_INTEGER</h3>
<p>The <code dir="ltr">TT_INTEGER</code> data type is a signed integer that ranges from -2,147,483,648 (-2<sup>31</sup>) to 2,147,483,647 (2<sup>31</sup> -1). It requires four bytes of storage and thus is more compact than the <code dir="ltr">NUMBER</code> data type. It also has better performance than the <code dir="ltr">NUMBER</code> <code dir="ltr">data</code> type. You can specify <code dir="ltr">TT_INT</code> for <code dir="ltr">TT_INTEGER</code>. If you specify either <code dir="ltr">INTEGER</code> or <code dir="ltr">INT</code>, these types are mapped to <code dir="ltr">NUMBER(38)</code>.</p>
<p>The following example alters the table <code dir="ltr">numerics</code> and adds <code dir="ltr">col3</code> with the data type <code dir="ltr">INT</code>. Describing the table shows that the data type is <code dir="ltr">NUMBER(38)</code>. The column <code dir="ltr">col3</code> is dropped. A second <code dir="ltr">ALTER TABLE</code> adds <code dir="ltr">col2</code> with the data type <code dir="ltr">INTEGER</code>. Describing the table shows that the data type is <code dir="ltr">NUMBER(38)</code>. The column <code dir="ltr">col3</code> is dropped. Columns <code dir="ltr">col3</code> and <code dir="ltr">col4</code> are then added with the data types <code dir="ltr">TT_INTEGER</code> and <code dir="ltr">TT_INT</code>. Describing the table shows both data types as <code dir="ltr">TT_INTEGER</code>.</p>
<pre dir="ltr">Command&gt; ALTER TABLE numerics ADD col3 INT;
Command&gt; DESCRIBE numerics;
Table USER1.NUMERICS:
  Columns:
    COL1                            TT_TINYINT
    COL2                            TT_SMALLINT
    COL3                            NUMBER (38)
1 table found.
(primary key columns are indicated with *)
Command&gt; ALTER TABLE numerics  col3;
Command&gt; ALTER TABLE numerics ADD col3 INTEGER;
Command&gt; DESCRIBE numerics;
Table USER1.NUMERICS:
Columns:
    COL1                            TT_TINYINT
    COL2                            TT_SMALLINT
    COL3                            NUMBER (38)
1 table found.
(primary key columns are indicated with *)
Command&gt; ALTER TABLE numerics  col3;
Command&gt; ALTER TABLE numerics ADD COLUMN col3 TT_INTEGER;
Command&gt; DESCRIBE numerics;
Table USER1.NUMERICS:
Columns:
    COL1                            TT_TINYINT
    COL2                            TT_SMALLINT
    COL3                            TT_INTEGER
1 table found.
(primary key columns are indicated with *)
Command&gt; ALTER TABLE numerics ADD col4 TT_INT;
Command&gt; DESCRIBE numerics;
Table USER1.NUMERICS:
Columns:
    COL1                            TT_TINYINT
    COL2                            TT_SMALLINT
    COL3                            TT_INTEGER
    COL4                            TT_INTEGER
1 table found.
(primary key columns are indicated with *)
</pre></div>
<!-- class="sect2" -->
<a id="BABEDBHD"></a>
<div id="TTSQL142" class="sect2">
<h3 class="sect2"><a id="sthref91"></a>TT_SMALLINT</h3>
<p>The <code dir="ltr">TT_SMALLINT</code> data type is a signed integer that ranges from -32,768 (-2<sup>15</sup>) to 32,767 (2<sup>15</sup>-1). It requires two bytes of storage and thus is more compact than the <code dir="ltr">NUMBER</code> data type. It also has better performance than the <code dir="ltr">NUMBER</code> data type. You can specify the data type <code dir="ltr">SMALLINT</code>, but it maps to <code dir="ltr">NUMBER(38)</code>.</p>
<p>The following example alters the table <code dir="ltr">numerics</code> and adds <code dir="ltr">col2</code> with the data type <code dir="ltr">SMALLINT</code>. Describing the table shows that the data type is <code dir="ltr">NUMBER(38)</code>. The column <code dir="ltr">col2</code> is dropped. A second <code dir="ltr">ALTER TABLE</code> adds <code dir="ltr">col2</code> with the data type <code dir="ltr">TT_SMALLINT</code>.</p>
<pre dir="ltr">Command&gt; ALTER TABLE numerics ADD COLUMN col2 SMALLINT;
Command&gt; DESCRIBE Numerics;
Table USER1.NUMERICS:
  Columns:
    COL1                            TT_TINYINT
    COL2                            NUMBER (38)
1 table found.
(primary key columns are indicated with *)
Command&gt; ALTER TABLE numerics  COLUMN col2;
Command&gt; ALTER TABLE numerics ADD COLUMN col2 TT_SMALLINT;
Command&gt; DESCRIBE numerics;
Table USER1.NUMERICS:
  Columns:
    COL1                            TT_TINYINT
    COL2                            TT_SMALLINT
1 table found.
(primary key columns are indicated with *)
</pre></div>
<!-- class="sect2" -->
<a id="BABBIIGG"></a>
<div id="TTSQL143" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref92"></a>TT_TINYINT</h3>
<p>The <code dir="ltr">TT_TINYINT</code> data type is an unsigned integer that ranges from 0 to 255 (2<sup>8</sup> -1). It requires one byte of storage and thus is more compact than the <code dir="ltr">NUMBER</code> data type. It also has better performance than the <code dir="ltr">NUMBER</code> data type. The data type of a negative <code dir="ltr">TT_TINYINT</code> is <code dir="ltr">TT_SMALLINT</code>. You cannot specify <code dir="ltr">TINYINT</code>.</p>
<p>The following example first attempts to create a table named <code dir="ltr">numerics</code> that defines a column named <code dir="ltr">col1</code> with data type <code dir="ltr">TINYINT</code>. TimesTen returns an error. The example then redefines the column with data type <code dir="ltr">TT_TINYINT</code>.</p>
<pre dir="ltr">Command&gt; CREATE TABLE numerics (col1 TINYINT);
 3300: TINYINT is not a valid type name; use TT_TINYINT instead
The command failed.
Command&gt; CREATE TABLE numerics (col1 TT_TINYINT);
Command&gt; DESCRIBE numerics;
Table USER1.NUMERICS:
  Columns:
    COL1                            TT_TINYINT
1 table found.
(primary key columns are indicated with *)
</pre></div>
<!-- class="sect2" -->
<div id="TTSQL144" class="sect2"><a id="sthref93"></a>
<h3 class="sect2"><a id="sthref94"></a><a id="sthref95"></a>Floating-point numbers</h3>
<p>Floating-point numbers can be with or without a decimal point. An exponent may be used to increase the range (for example, 1.2E-20).</p>
<p>Floating-point numbers do not have a scale because the number of digits that can appear after the decimal point is not restricted.</p>
<p>Binary floating-point numbers are stored using binary precision (the digits 0 and 1). For the <code dir="ltr">NUMBER</code> data type, values are stored using decimal precision (the digits 0 through 9).</p>
<p>Literal values that are within the range and precision supported by <code dir="ltr">NUMBER</code> are stored as <code dir="ltr">NUMBER</code> because literals are expressed using decimal precision.</p>
<p>Use one of the following data types for floating-point numbers:</p>
<ul>
<li>
<p><a href="#BABIGDEA">BINARY_DOUBLE</a></p>
</li>
<li>
<p><a href="#BABGAEGB">BINARY_FLOAT</a></p>
</li>
<li>
<p><a href="#BABIIIGI">FLOAT and FLOAT(<span class="italic">n</span>)</a></p>
</li>
</ul>
<a id="BABIGDEA"></a>
<div id="TTSQL145" class="sect3">
<h4 class="sect3"><a id="sthref96"></a>BINARY_DOUBLE</h4>
<p><code dir="ltr">BINARY_DOUBLE</code> is a 64-bit, double-precision, floating-point number.</p>
<p>Both <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> support the special values <code dir="ltr">Inf</code>, <code dir="ltr">-Inf</code>, and <code dir="ltr">NaN</code> (not a number) and conform to the IEEE standard.</p>
<p>Floating-point number limits:</p>
<ul>
<li>
<p><code dir="ltr">BINARY_FLOAT</code></p>
<ul>
<li>
<p>Minimum positive finite value: 1.17549E-38F</p>
</li>
<li>
<p>Maximum positive finite value: 3.40282E+38F</p>
</li>
</ul>
</li>
<li>
<p><code dir="ltr">BINARY_DOUBLE</code></p>
<ul>
<li>
<p>Minimum positive finite value: 2.22507485850720E-308</p>
</li>
<li>
<p>Maximum positive finite value: 1.79769313486231E+308</p>
</li>
</ul>
</li>
</ul>
<p>The following example creates a table and defines two columns with the <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> data types.</p>
<pre dir="ltr">Command&gt; CREATE TABLE BfBd (Col1 BINARY_FLOAT, Col2 BINARY_DOUBLE);
Command&gt; DESCRIBE BfBd;
Table UISER1.BFBD:
  Columns:
    COL1                            BINARY_FLOAT
    COL2                            BINARY_DOUBLE
1 table found.
(primary key columns are indicated with *)
</pre></div>
<!-- class="sect3" -->
<a id="BABGAEGB"></a>
<div id="TTSQL146" class="sect3">
<h4 class="sect3"><a id="sthref97"></a>BINARY_FLOAT</h4>
<p><code dir="ltr">BINARY_FLOAT</code> is a 32-bit, single-precision, floating-point number.</p>
</div>
<!-- class="sect3" -->
<a id="BABIIIGI"></a>
<div id="TTSQL147" class="sect3">
<h4 class="sect3"><a id="sthref98"></a>FLOAT and FLOAT(<span class="italic">n</span>)</h4>
<p>TimesTen also supports the ANSI type <code dir="ltr">FLOAT</code>. <code dir="ltr">FLOAT</code> is an exact numeric type and is implemented as the <code dir="ltr">NUMBER</code> type. The value of <code dir="ltr"><span class="codeinlineitalic">n</span></code> indicates the number of bits of precision that can be stored, from 1 to 126. To convert from binary precision to decimal precision, multiply <code dir="ltr"><span class="codeinlineitalic">n</span></code> by 0.30103. To convert from decimal precision to binary precision, multiply the decimal precision by 3.32193. The maximum 126 digits of binary precision is equivalent to approximately 38 digits of decimal precision.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABIDFJF"></a>
<div id="TTSQL148" class="sect1">
<h2 class="sect1"><a id="sthref99"></a><a id="sthref100"></a>BINARY and VARBINARY data types</h2>
<p>The <code dir="ltr">BINARY</code> data type is a fixed-length binary value with a length of <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes, where the value of <code dir="ltr"><span class="codeinlineitalic">n</span></code> ranges from 1 to 8300 bytes. The <code dir="ltr">BINARY</code> data type requires <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes of storage. Data is padded to the maximum column size with trailing zeros. Zero padded comparison semantics are used.</p>
<p>The <code dir="ltr">VARBINARY</code> data type is a variable-length binary value having a maximum length of <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes, where the value of <code dir="ltr"><span class="codeinlineitalic">n</span></code> ranges from 1 to 4,194,304 (2<sup>22</sup>) bytes.</p>
<p>The following example creates a table and defines two columns: <code dir="ltr">col1</code> is defined with data type <code dir="ltr">BINARY</code> and <code dir="ltr">col2</code> with data type <code dir="ltr">VARBINARY</code>. Then, binary data is inserted into each column. Note that the <code dir="ltr">BINARY</code> value is padded to the right with zeros.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For details on assigning hexadecimal literals as binary data in TimesTen, see the description for the <code dir="ltr"><span class="codeinlineitalic">HexadecimalLiteral</span></code> in <a href="express.htm#i1043723">&#34;Constants&#34;</a>.</div>
<pre dir="ltr">Command&gt; CREATE TABLE bvar (col1 BINARY (10), col2 VARBINARY (10));
Command&gt; DESCRIBE bvar;
Table USER1.BVAR:
  Columns:
    COL1                            BINARY (10)
    COL2                            VARBINARY (10) INLINE
1 table found.
(primary key columns are indicated with *)

Command&gt; INSERT INTO bvar (col1, col2)
 &gt; VALUES (0x4D7953514C, 0x39274D);
1 row inserted.

Command&gt; select * from bvar;
 &lt; 4D7953514C0000000000, 39274D &gt;
1 row found.
</pre></div>
<!-- class="sect1" -->
<a id="BABEDCJC"></a>
<div id="TTSQL149" class="sect1">
<h2 class="sect1"><a id="sthref101"></a>Numeric precedence</h2>
<p>The result type of an expression is determined by the operand with the highest type precedence. The numeric precedence order is as follows (highest to lowest):</p>
<ul>
<li>
<p><code dir="ltr">BINARY_DOUBLE</code></p>
</li>
<li>
<p><code dir="ltr">BINARY_FLOAT</code></p>
</li>
<li>
<p><code dir="ltr">NUMBER</code></p>
</li>
<li>
<p><code dir="ltr">TT_BIGINT</code></p>
</li>
<li>
<p><code dir="ltr">TT_INTEGER</code></p>
</li>
<li>
<p><code dir="ltr">TT_SMALLINT</code></p>
</li>
<li>
<p><code dir="ltr">TT_TINYINT</code></p>
</li>
</ul>
<p>For example, the sum of <code dir="ltr">TT_INTEGER</code> and <code dir="ltr">BINARY_FLOAT</code> values is type <code dir="ltr">BINARY_FLOAT</code> because <code dir="ltr">BINARY_FLOAT</code> has higher numeric precedence. Similarly, the product of <code dir="ltr">NUMBER</code> and <code dir="ltr">BINARY_DOUBLE</code> values is type <code dir="ltr">BINARY_DOUBLE</code>.</p>
</div>
<!-- class="sect1" -->
<a id="BABBGIFA"></a>
<div id="TTSQL481" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">LO<a id="sthref102"></a><a id="sthref103"></a>B data types</h2>
<p>The large object (LOB) data types can store large and unstructured data such as text, image, video, and spatial data. LOBs include the <code dir="ltr">BLOB</code>, <code dir="ltr">CLOB</code> and <code dir="ltr">NCLOB</code> data types.</p>
<p>You can insert or update data in a column that is of a LOB data type. For update operations, you can set the LOB value to <code dir="ltr">NULL</code>, an empty value through <code dir="ltr">EMPTY_CLOB</code> or <code dir="ltr">EMPTY_BLOB</code>, or replace the entire LOB with new data. You can update a LOB value with another LOB value. If you delete a row containing a LOB column, you also delete the LOB value.</p>
<p>LOB data type semantics are similar to the following SQL semantics:</p>
<ul>
<li>
<p><code dir="ltr">BLOB</code> data types use SQL <code dir="ltr">VARBINARY</code> semantics.</p>
</li>
<li>
<p><code dir="ltr">CLOB</code> data types use SQL <code dir="ltr">VARCHAR2</code> semantics.</p>
</li>
<li>
<p><code dir="ltr">NCLOB</code> data types use SQL <code dir="ltr">NVARCHAR2</code> semantics.</p>
</li>
</ul>
<p>The following SQL statements, operators, and functions accept one or more of the LOB data types as arguments.</p>
<ul>
<li>
<p>SQL statements: <code dir="ltr">CREATE TABLE</code>, <code dir="ltr">SELECT</code>, <code dir="ltr">INSERT</code>, and <code dir="ltr">UPDATE</code></p>
</li>
<li>
<p>Operators: <code dir="ltr">LIKE</code> and <code dir="ltr">IS [NOT] NULL</code></p>
</li>
<li>
<p>Functions: <code dir="ltr">ASCIISTR</code>, <code dir="ltr">CONCAT</code>, <code dir="ltr">INSTR</code>, <code dir="ltr">INSTRB</code>, <code dir="ltr">INSTR4</code>, <code dir="ltr">LENGTH</code>, <code dir="ltr">LENGTHB</code>, <code dir="ltr">LOWER</code>, <code dir="ltr">LPAD</code>, <code dir="ltr">NLSSORT</code>, <code dir="ltr">NVL</code>, <code dir="ltr">TRIM</code>, <code dir="ltr">LTRIM</code>, <code dir="ltr">RTRIM</code>, <code dir="ltr">SUBSTR</code>, <code dir="ltr">SUBSTRB</code>, <code dir="ltr">SUBSTR4</code>, <code dir="ltr">REPLACE</code>, <code dir="ltr">RPAD</code>, <code dir="ltr">SOUNDEX</code>, <code dir="ltr">TO_DATE</code>, <code dir="ltr">TO_NUMBER</code>, <code dir="ltr">TO_CHAR</code>, and <code dir="ltr">UPPER</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Support for LOB data types is detailed in documentation for the above statements, operators, and functions. Refer to <a href="state.htm#i1165937">Chapter 6, &#34;SQL Statements&#34;</a>, <a href="search.htm#i994763">Chapter 5, &#34;Search Conditions&#34;</a>, and <a href="function.htm#CACFCGCD">Chapter 4, &#34;Functions&#34;</a>, respectively.</div>
<p><span class="bold">Description</span></p>
<ul>
<li>
<p>LOB conversion SQL functions (<a href="function.htm#CACHJAJE">TO_BLOB</a>, <a href="function.htm#CACJCCDJ">TO_CLOB</a>, and <a href="function.htm#CACFFDIF">TO_LOB</a>) convert to the desired LOB data type.</p>
</li>
<li>
<p>LOB columns are always stored out of line, so you cannot use the <code dir="ltr">INLINE</code> attribute when declaring LOB columns.</p>
</li>
<li>
<p>You can define multiple columns of the LOB data type within a single table.</p>
</li>
<li>
<p>You cannot create a primary key on a LOB column. You cannot define an index (range, hash, bitmap) on a LOB column.</p>
</li>
<li>
<p>You cannot create a materialized view if the detail table contains a LOB column.</p>
</li>
<li>
<p>In addition to SQL, you can use LOB specific APIs in PL/SQL, ODBC, JDBC, OCI, and PRO*C/C++ for creating and updating LOBs. See the appropriate TimesTen developer&#39;s guide for more information on these APIs.</p>
</li>
</ul>
<p>The following sections describe each LOB data type in more detail:</p>
<ul>
<li>
<p><a href="#BABBJJEH">BLOB</a></p>
</li>
<li>
<p><a href="#BABGCJHJ">CLOB</a></p>
</li>
<li>
<p><a href="#BABFCIED">NCLOB</a></p>
</li>
</ul>
<p>In addition, the following sections provide more details on LOBs in general:</p>
<ul>
<li>
<p><a href="#BABFCEJB">Difference between NULL and empty LOBs</a></p>
</li>
<li>
<p><a href="#BABDAIDD">Initializing LOBs</a></p>
</li>
</ul>
<a id="BABBJJEH"></a>
<div id="TTSQL482" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">BLOB</h3>
<p>The Binary LOB (<code dir="ltr">BLOB</code>) data type stores unstructured binary large objects. The maximum size for <code dir="ltr">BLOB</code> data is 16 MB.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For details on assigning hexadecimal literals as binary data in TimesTen, see the description for the <code dir="ltr"><span class="codeinlineitalic">HexadecimalLiteral</span></code> in <a href="express.htm#i1043723">&#34;Constants&#34;</a>.</div>
<p>When you define a <code dir="ltr">BLOB</code> in a column, you do not define the maximum number of characters as you would with <code dir="ltr">VARBINARY</code> and other variable length data types. Instead, the definition for the column would be as follows:</p>
<pre dir="ltr">Command&gt; CREATE TABLE blob_content ( 
 &gt; id NUMBER PRIMARY KEY, 
 &gt; blob_column BLOB ); 
</pre>
<p>To manipulate a <code dir="ltr">BLOB</code>, the following functions are provided:</p>
<ul>
<li>
<p>There are two methods to initialize a <code dir="ltr">BLOB</code>, including the <code dir="ltr">EMPTY_BLOB</code> function to initialize an empty <code dir="ltr">BLOB</code>. For details on initializing a <code dir="ltr">BLOB</code>, see <a href="#BABDAIDD">&#34;Initializing LOBs&#34;</a>. For details on how an empty LOB is different from a <code dir="ltr">NULL</code> LOB, see <a href="#BABFCEJB">&#34;Difference between NULL and empty LOBs&#34;</a>.</p>
</li>
<li>
<p>To convert a binary value to a <code dir="ltr">BLOB</code>, use the <code dir="ltr">TO_LOB</code> or <code dir="ltr">TO_BLOB</code> functions. See <a href="function.htm#CACHJAJE">&#34;TO_BLOB&#34;</a> and <a href="function.htm#CACFFDIF">&#34;TO_LOB&#34;</a> for more details.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABGCJHJ"></a>
<div id="TTSQL483" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">CLOB</h3>
<p>The Character LOB (<code dir="ltr">CLOB</code>) data type stores single-byte and multibyte character data. The maximum size for <code dir="ltr">CLOB</code> data is 4 MB. The maximum number of characters that can be stored in the <code dir="ltr">CLOB</code> depends on whether you are using a single or multibyte character set.</p>
<p>When you define a <code dir="ltr">CLOB</code> in a column, you do not define the maximum number of characters as you would with <code dir="ltr">VARCHAR</code> and other variable length data types. Instead, the definition for the column would be as follows:</p>
<pre dir="ltr">Command&gt; CREATE TABLE clob_content ( 
 &gt; id NUMBER PRIMARY KEY, 
 &gt; clob_column CLOB ); 
</pre>
<p>To manipulate a <code dir="ltr">CLOB</code>, the following functions are provided:</p>
<ul>
<li>
<p>There are two methods to initialize a <code dir="ltr">CLOB</code>, including the <code dir="ltr">EMPTY_CLOB</code> function to initialize an empty <code dir="ltr">CLOB</code>. For details on initializing a <code dir="ltr">CLOB</code>, see <a href="#BABDAIDD">&#34;Initializing LOBs&#34;</a>. For details on how an empty LOB is different from a <code dir="ltr">NULL</code> LOB, see <a href="#BABFCEJB">&#34;Difference between NULL and empty LOBs&#34;</a> below.</p>
</li>
<li>
<p>To convert a character string to a <code dir="ltr">CLOB</code>, use the <code dir="ltr">TO_LOB</code> or <code dir="ltr">TO_CLOB</code> functions. See <a href="function.htm#CACJCCDJ">&#34;TO_CLOB&#34;</a> and <a href="function.htm#CACFFDIF">&#34;TO_LOB&#34;</a> for more details.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABFCIED"></a>
<div id="TTSQL484" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">NCLOB</h3>
<p>The National Character LOB (<code dir="ltr">NCLOB</code>) data type stores Unicode data. The maximum size for an <code dir="ltr">NCLOB</code> data is 4 MB.</p>
<p>When you define a <code dir="ltr">NCLOB</code> in a column, you do not define the maximum number of characters as you would with <code dir="ltr">VARCHAR</code> and other variable length data types. Instead, the definition for the column would be as follows:</p>
<pre dir="ltr">Command&gt; CREATE TABLE nclob_content ( 
 &gt; id NUMBER PRIMARY KEY, 
 &gt; nclob_column NCLOB ); 
</pre>
<p>The following functions support the <code dir="ltr">NCLOB</code> data type:</p>
<ul>
<li>
<p>There are two methods to initialize an <code dir="ltr">NCLOB</code>, including the <code dir="ltr">EMPTY_CLOB</code> function to initialize an empty <code dir="ltr">NCLOB</code>. For details on initializing a <code dir="ltr">NCLOB</code>, see <a href="#BABDAIDD">&#34;Initializing LOBs&#34;</a>. For details on how an empty LOB is different from a <code dir="ltr">NULL</code> LOB, see <a href="#BABFCEJB">&#34;Difference between NULL and empty LOBs&#34;</a>, immediately below.</p>
</li>
<li>
<p>To convert a character string to an <code dir="ltr">NCLOB</code>, use the <code dir="ltr">TO_LOB</code> or <code dir="ltr">TO_CLOB</code> functions. See <a href="function.htm#CACJCCDJ">&#34;TO_CLOB&#34;</a> and <a href="function.htm#CACFFDIF">&#34;TO_LOB&#34;</a> for more details.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABFCEJB"></a>
<div id="TTSQL506" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Difference between NULL and empty LOBs</h3>
<p>A <code dir="ltr">NULL</code> LOB has a different meaning than an empty LOB.</p>
<ul>
<li>
<p>A <code dir="ltr">NULL</code> LOB has the value of <code dir="ltr">NULL</code>, so <code dir="ltr">NULL</code> is returned if you request a <code dir="ltr">NULL</code> <a id="sthref104"></a>LOB.</p>
</li>
<li>
<p>An empty LOB is initialized with either the <code dir="ltr">EMPTY_CLOB</code> or <code dir="ltr">EMPTY_BLOB</code> functions. These functions initialize the LOB to be a zero-length, non-<code dir="ltr">NULL</code> value. You can also use the <code dir="ltr">EMPTY_CLOB</code> or <code dir="ltr">EMPTY_BLOB</code> functions to initialize a LOB in a non-nullable column.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABDAIDD"></a>
<div id="TTSQL507" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Initializing LOBs</h3>
<p>You can initialize a LOB in one of two ways:</p>
<ul>
<li>
<p>You can insert an empty LOB into a <code dir="ltr">BLOB</code>, <code dir="ltr">CLOB</code> or <code dir="ltr">NCLOB</code> column by using the <code dir="ltr">EMPTY_BLOB</code> or <code dir="ltr">EMPTY_CLOB</code> functions. This is useful when you do not have any data, but want to create the LOB in preparation for data. It is also useful for initializing non-nullable LOB columns.</p>
</li>
<li>
<p>Initialize the LOB by inserting data directly. There is no need to initialize a LOB using the <code dir="ltr">EMPTY_BLOB</code> or <code dir="ltr">EMPTY_CLOB</code> functions, you can simply insert the data directly.</p>
</li>
</ul>
<p>The following demonstrates examples of each type of initialization:</p>
<p>You can initialize a LOB with the <code dir="ltr">EMPTY_CLOB</code> function, as shown with the following example:</p>
<pre dir="ltr">Command&gt; INSERT INTO clob_content (id, clob_column)
       &gt; VALUES (1, EMPTY_CLOB( ) );
1 row inserted.
</pre>
<p>You can initialize a LOB by inserting data directly, as shown with the following example:</p>
<pre dir="ltr">Command&gt; INSERT INTO clob_content(id, clob_column)
 &gt; VALUES (4, &#39;Demonstration of the LOB initialization.&#39;);
1 row inserted.
</pre>
<p>You can initialize or update an existing LOB value with the <code dir="ltr">UPDATE</code> statement, as shown with the following examples:</p>
<pre dir="ltr">Command&gt; UPDATE blob_content
 &gt; SET blob_column = 0x000AF4511
 &gt; WHERE id = 1;
1 row updated.

Command&gt; select * from blob_content;
 &lt; 1, 0000AF4511 &gt;
1 rows found.

Command&gt; UPDATE clob_content
 &gt; SET clob_column = &#39;Demonstration of the CLOB data type &#39;
 &gt; WHERE id = 1;
1 row updated.

Command&gt; SELECT * FROM clob_content;
 &lt; 1, Demonstration of the CLOB data type &gt;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBDGFE"></a>
<div id="TTSQL150" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">RO<a id="sthref105"></a>WID data type</h2>
<p>The address of a row in a table or materialized view is called a <span class="italic">rowid</span>. The rowid data type is <code dir="ltr">ROWID</code>. You can examine a rowid by querying the <code dir="ltr">ROWID</code> pseudocolumn. See <a href="express.htm#i1052771">&#34;ROWID&#34;</a> for details on the <code dir="ltr">ROWID</code> pseudocolumn.</p>
<p>Specify literal <code dir="ltr">ROWID</code> values in SQL statements as constants enclosed in single quotes, as follows:</p>
<pre dir="ltr">Command&gt; SELECT ROWID, last_name 
&gt; FROM employees 
&gt; WHERE department_id = 20;

&lt; BMUFVUAAACOAAAALhM, Hartstein &gt;
&lt; BMUFVUAAACOAAAAMhM, Fay &gt;
2 rows found.

Command&gt; SELECT ROWID, last_name FROM employees
       &gt; WHERE ROWID=&#39;BMUFVUAAACOAAAALhM&#39;;
&lt; BMUFVUAAACOAAAALhM, Hartstein &gt;
1 row found.
</pre>
<p>Use the <code dir="ltr">ROWID</code> data type as follows:</p>
<ul>
<li>
<p>As the data type for a table column or materialized view column</p>
</li>
<li>
<p>In <a id="sthref106"></a>these types of expressions:</p>
<ul>
<li>
<p>Literals</p>
</li>
<li>
<p>Comparisons: <code dir="ltr">&lt;</code>, <code dir="ltr">&lt;=</code>, <code dir="ltr">&gt;</code>, <code dir="ltr">&gt;=</code>, <code dir="ltr">BETWEEN</code></p>
</li>
<li>
<p><a href="express.htm#i1040507">CASE expressions</a></p>
</li>
<li>
<p><a href="function.htm#i1000097">CAST</a></p>
</li>
<li>
<p><a href="function.htm#i1051444">COALESCE</a></p>
</li>
<li>
<p><a href="function.htm#CACIBBFB">COUNT</a></p>
</li>
<li>
<p><a href="function.htm#i1035748">DECODE</a></p>
</li>
<li>
<p><a href="function.htm#CIHHGEHE">GREATEST</a></p>
</li>
<li>
<p>IN</p>
</li>
<li>
<p>IS NULL</p>
</li>
<li>
<p><a href="function.htm#CIHHIIHJ">LEAST</a></p>
</li>
<li>
<p><a href="function.htm#CACGHBHB">MAX</a></p>
</li>
<li>
<p><a href="function.htm#CACBFFGF">MIN</a></p>
</li>
<li>
<p><a href="function.htm#i1027380">NVL</a></p>
</li>
<li>
<p><a href="function.htm#i1000743">TO_CHAR</a></p>
</li>
<li>
<p><a href="function.htm#i1041970">TT_HASH</a></p>
</li>
</ul>
</li>
<li>
<p>In <code dir="ltr">ORDER BY</code> and <code dir="ltr">GROUP BY</code> clauses</p>
</li>
<li>
<p>In <a id="sthref107"></a><code dir="ltr">INSERT...SELECT</code> statements. Column <code dir="ltr">col1</code> has been defined with the <code dir="ltr">ROWID</code> data type for these examples:</p>
<pre dir="ltr">Command&gt; DESCRIBE master;
 
Table MYUSER.MASTER:
  Columns:
   *ID                              ROWID NOT NULL
    NAME                            CHAR (30)
 
1 table found.
(primary key columns are indicated with *)

Command&gt; INSERT INTO master(id, name) SELECT ROWID, last_name FROM employees;
107 rows inserted.
Command&gt; SELECT * FROM master;
&lt; BMUFVUAAACOAAAAGhG, King                           &gt;
&lt; BMUFVUAAACOAAAAHhG, Kochhar                        &gt;
&lt; BMUFVUAAACOAAAAIhG, De Haan                        &gt;
...
107 rows found.
</pre>
<p>You can use the <code dir="ltr">TO_CHAR</code> function with the <code dir="ltr">ROWID</code> pseudocolumn as shown below:</p>
<pre dir="ltr">Command&gt; INSERT INTO master(id, name) 
&gt; SELECT TO_CHAR(ROWID), last_name FROM employees;
107 rows inserted.
Command&gt; SELECT * FROM master;
&lt; BMUFVUAAACOAAAAGhG, King                           &gt;
&lt; BMUFVUAAACOAAAAHhG, Kochhar                        &gt;
...
107 rows found.
</pre>
<p>You can use the <code dir="ltr">CAST</code> function with the <code dir="ltr">ROWID</code> pseudocolumn as shown below:</p>
<pre dir="ltr">Command&gt; CREATE TABLE master (id CHAR(20) NOT NULL PRIMARY KEY, 
&gt; name CHAR(30));
Command&gt; INSERT INTO master(id, name) SELECT CAST(ROWID AS CHAR(20)), 
&gt; last_name from employees;
107 rows inserted.
</pre></li>
</ul>
<p><a id="sthref108"></a><a id="sthref109"></a>Implicit type conversions are supported for assigning values and comparison operations between <code dir="ltr">ROWID</code> and <code dir="ltr">CHAR</code> or between <code dir="ltr">ROWID</code> and <code dir="ltr">VARCHAR2</code> data.</p>
<p>When <code dir="ltr">CHAR</code>, <code dir="ltr">VARCHAR2</code>, and <code dir="ltr">ROWID</code> operands are combined in <code dir="ltr"><a href="function.htm#i1051444">COALESCE</a></code>, <code dir="ltr"><a href="function.htm#i1035748">DECODE</a></code>, <code dir="ltr"><a href="function.htm#i1027380">NVL</a></code>, or <code dir="ltr">CASE</code> expressions (see <a href="express.htm#i1040507">&#34;CASE expressions&#34;</a>), the result data type is <code dir="ltr">ROWID</code>. Expressions with <code dir="ltr">CHAR</code> and <code dir="ltr">VARCHAR2</code> values are converted to <code dir="ltr">ROWID</code> values to evaluate the expression.</p>
<p>To use <code dir="ltr">ROWID</code> values with string functions such as <code dir="ltr"><a href="function.htm#i1000740">CONCAT</a></code>, the application must convert <code dir="ltr">ROWID</code> values explicitly to <code dir="ltr">CHAR</code> values using the SQL <code dir="ltr"><a href="function.htm#i1000743">TO_CHAR</a></code> function.</p>
</div>
<!-- class="sect1" -->
<a id="BABGDDBI"></a>
<div id="TTSQL151" class="sect1">
<h2 class="sect1"><a id="sthref110"></a><a id="sthref111"></a>Datetime data types</h2>
<p>The datetime data types are as follows:</p>
<ul>
<li>
<p><a href="#BABIACDC">DATE</a></p>
</li>
<li>
<p><a href="#BABFEDEC">TIME</a></p>
</li>
<li>
<p><a href="#BABFHCFB">TIMESTAMP</a></p>
</li>
<li>
<p><a href="#BABEDEJF">TT_DATE</a></p>
</li>
<li>
<p><a href="#BABJAIII">TT_TIMESTAMP</a></p>
</li>
</ul>
<a id="BABIACDC"></a>
<div id="TTSQL152" class="sect2">
<h3 class="sect2"><a id="sthref112"></a>DATE</h3>
<p>The format of a <code dir="ltr">DATE</code> value is <code dir="ltr">YYYY-MM-DD HH:MI:SS</code> and ranges from -4712-01-01 (January 1, 4712 BC) to 9999-12-31 (December 31, 9999 AD). There are no fractional seconds. The <code dir="ltr">DATE</code> type requires seven bytes of storage.</p>
<p>TimesTen does not support user-specified <code dir="ltr">NLS_DATE_FORMAT</code> settings. You can use the SQL <code dir="ltr"><a href="function.htm#i1000743">TO_CHAR</a></code> and <code dir="ltr"><a href="function.htm#i1058153">TO_DATE</a></code> functions to specify other formats.</p>
</div>
<!-- class="sect2" -->
<a id="BABFEDEC"></a>
<div id="TTSQL153" class="sect2">
<h3 class="sect2"><a id="sthref113"></a>TIME</h3>
<p>The format of a <code dir="ltr">TIME</code> value is <code dir="ltr"><span class="codeinlineitalic">HH:MI:SS</span></code> and ranges from 00:00:00 (midnight) to 23:59:59 (11:59:59 pm). The <code dir="ltr">TIME</code> data type requires eight bytes of storage.</p>
</div>
<!-- class="sect2" -->
<a id="BABFHCFB"></a>
<div id="TTSQL154" class="sect2">
<h3 class="sect2">T<a id="sthref114"></a>IMESTAMP</h3>
<p>The format of a <code dir="ltr">TIMESTAMP</code> value is <code dir="ltr">YYYY-MM-DD HH:MI:SS [.FFFFFFFFF]</code>. The fractional seconds precision range is 0 to 9. The default is 6. The date range is from -4712-01-01 (January 1, 4712 BC) to 9999-12-31 (December 31, 9999 AD). The <code dir="ltr">TIMESTAMP</code> type requires 12 bytes of storage. The <code dir="ltr">TIMESTAMP</code> type has a larger date range and supports more precision than <code dir="ltr">TT_TIMESTAMP</code>.</p>
<p>TimesTen does not support user-specified <code dir="ltr">NLS_TIMESTAMP_FORMAT</code> settings. The SQL <code dir="ltr"><a href="function.htm#i1000743">TO_CHAR</a></code> and <code dir="ltr"><a href="function.htm#i1058153">TO_DATE</a></code> functions can be used to specify other formats.</p>
</div>
<!-- class="sect2" -->
<a id="BABEDEJF"></a>
<div id="TTSQL155" class="sect2">
<h3 class="sect2"><a id="sthref115"></a>TT_DATE</h3>
<p>The format of a <code dir="ltr">TT_DATE</code> value is <code dir="ltr">YYYY-MM-DD</code> and ranges from 1753-01-01 (January 1, 1753 AD) to 9999-12-31 (December 31, 9999 AD). The <code dir="ltr">TT_DATE</code> data type requires four bytes of storage.</p>
</div>
<!-- class="sect2" -->
<a id="BABJAIII"></a>
<div id="TTSQL156" class="sect2">
<h3 class="sect2">T<a id="sthref116"></a>T_TIMESTAMP</h3>
<p>The format of a <code dir="ltr">TT_TIMESTAMP</code> value is <code dir="ltr">YYYY-MM-DD HH:MI:SS [.FFFFFFFFF]</code>. The fractional seconds precision is 6. The range is from 1753-01-01 00:00:00 (January 1, 1753, midnight) to 9999-12-31 23:59:59 (December 31, 9999, 11:59:59 PM). The <code dir="ltr">TT_TIMESTAMP</code> type requires eight bytes of storage. <code dir="ltr">TT_TIMESTAMP</code> is faster than the <code dir="ltr">TIMESTAMP</code> data type and has a smaller storage size.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABECJIA"></a>
<div id="TTSQL157" class="sect1">
<h2 class="sect1">T<a id="sthref117"></a>imesTen intervals</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#BABFCDCA">Using interval data types</a></p>
</li>
<li>
<p><a href="#BABGFFCB">Using DATE and TIME data types</a></p>
</li>
<li>
<p><a href="#i1033323">Handling time zone conversions</a></p>
</li>
<li>
<p><a href="#BABCHCFB">Datetime and interval data types in arithmetic operations</a></p>
</li>
</ul>
<a id="BABFCDCA"></a>
<div id="TTSQL158" class="sect2">
<h3 class="sect2"><a id="sthref118"></a>Using interval data types</h3>
<p>If you are using TimesTen type mode, refer to the <span class="italic">Oracle TimesTen In-Memory Database API and SQL Reference Guide</span>, Release 6.0.3, for information on interval types.</p>
<p>TimesTen supports interval types only in a constant specification or intermediate expression result. Interval types cannot be the final result. Columns cannot be defined with an interval type. See <a href="#i987176">&#34;Type specifications&#34;</a>.</p>
<p>You can specify a single-field literal that is an interval in an expression, but you cannot specify a complete expression that returns an interval data type. Instead, the <code dir="ltr"><a href="function.htm#i1017701">EXTRACT</a></code> function must be used to extract the desired component of the interval result.</p>
<p>TimesTen supports interval literals of the following form:</p>
<p><code dir="ltr">INTERVAL [+/-]</code> <code dir="ltr"><span class="codeinlineitalic">CharString</span></code> <code dir="ltr"><span class="codeinlineitalic">IntervalQualifier</span></code></p>
</div>
<!-- class="sect2" -->
<a id="BABGFFCB"></a>
<div id="TTSQL159" class="sect2">
<h3 class="sect2"><a id="sthref119"></a><a id="sthref120"></a><a id="sthref121"></a><a id="sthref122"></a>Using DATE and TIME data types</h3>
<p>This section shows some <code dir="ltr">DATE</code>, <code dir="ltr">TIME</code>, and <code dir="ltr">TIMESTAMP</code> data type examples:</p>
<p>To create a table named <code dir="ltr">sample</code> that contains a column <code dir="ltr">dcol</code> of type <code dir="ltr">DATE</code> and a column <code dir="ltr">tcol</code> of type <code dir="ltr">TIME</code>, use the following:</p>
<pre dir="ltr">CREATE TABLE sample (tcol TIME, dcol DATE);
</pre>
<p>To insert <code dir="ltr">DATE</code> and <code dir="ltr">TIME</code> values into the <code dir="ltr">sample</code> table, use this:</p>
<pre dir="ltr">INSERT INTO sample VALUES (TIME &#39;12:00:00&#39;, DATE &#39;1998-10-28&#39;);
</pre>
<p>To select all rows in the <code dir="ltr">sample</code> table that are between noon and 4:00 p.m. on October 29, 1998, use the following:</p>
<pre dir="ltr">SELECT * FROM sample WHERE dcol = DATE &#39;1998-10-29&#39; 
AND tcol BETWEEN TIME &#39;12:00:00&#39; AND TIME &#39;16:00:00&#39;;
</pre>
<p>To create a table named <code dir="ltr">sample2</code> that contains a column <code dir="ltr">tscol</code> of type <code dir="ltr">TIMESTAMP</code> and then select all rows in the table that are between noon and 4:00 p.m. on October 29, 1998, use these statements:</p>
<pre dir="ltr">CREATE TABLE sample2 (tscol TIMESTAMP);
INSERT INTO sample2 VALUES (TIMESTAMP &#39;1998-10-28 12:00:00&#39;);
SELECT * FROM sample2 WHERE tscol
BETWEEN TIMESTAMP &#39;1998-10-29 12:00:00&#39; AND &#39;1998-10-29 16:00:00&#39;;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
TimesTen enables both literal and string formats of the <code dir="ltr">TIME</code>, <code dir="ltr">DATE</code>, and <code dir="ltr">TIMESTAMP</code> types. For example, <code dir="ltr">timestring (&#39;12:00:00&#39;)</code> and <code dir="ltr">timeliteral (TIME &#39;16:00:00&#39;)</code> are both valid ways to specify a <code dir="ltr">TIME</code> value. TimesTen reads the first value as <code dir="ltr">CHAR</code> type and later converts it to <code dir="ltr">TIME</code> type as needed. TimesTen reads the second value as <code dir="ltr">TIME</code>. The examples above use the literal format. Any values for the fraction not specified in full microseconds result in a &#34;<code dir="ltr">Data truncated</code>&#34; error.</div>
</div>
<!-- class="sect2" -->
<a id="i1033323"></a>
<div id="TTSQL160" class="sect2">
<h3 class="sect2">Handling <a id="sthref123"></a><a id="sthref124"></a><a id="sthref125"></a><a id="sthref126"></a>time zone conversions</h3>
<p>TimesTen does not support <code dir="ltr">TIMEZONE</code>. <code dir="ltr">TIME</code> and <code dir="ltr">TIMESTAMP</code> data type values are stored without making any adjustment for time difference. Applications must assume one time zone and convert <code dir="ltr">TIME</code> and <code dir="ltr">TIMESTAMP</code> to that time zone before sending values to the database. For example, an application can assume its time zone to be Pacific Standard Time. If the application is using <code dir="ltr">TIME</code> and <code dir="ltr">TIMESTAMP</code> values from Pacific Daylight Time or Eastern Standard Time, for example, the application must convert <code dir="ltr">TIME</code> and <code dir="ltr">TIMESTAMP</code> to Pacific Standard Time.</p>
</div>
<!-- class="sect2" -->
<a id="BABCHCFB"></a>
<div id="TTSQL161" class="sect2">
<h3 class="sect2"><a id="sthref127"></a><a id="sthref128"></a><a id="sthref129"></a>Datetime and interval data types in arithmetic operations</h3>
<p>If you are using TimesTen type mode, see <span class="italic">Oracle TimesTen In-Memory Database API and SQL Reference Guide</span>, Release 6.0.3, for information about datetime and interval types in arithmetic operations</p>
<p>You can perform numeric operations on date, timestamp and interval data. TimesTen calculates the results based on the rules:</p>
<ul>
<li>
<p>You can add or subtract a numeric value to or from a <code dir="ltr">ORA_DATE</code> or <code dir="ltr">ORA_TIMESTAMP</code> value. TimesTen internally converts <code dir="ltr">ORA_TIMESTAMP</code> values to <code dir="ltr">ORA_DATE</code> values.</p>
</li>
<li>
<p>You can add or subtract a numeric value to or from a <code dir="ltr">TT_DATE</code> or <code dir="ltr">TT_TIMESTAMP</code> value and the resulting value is <code dir="ltr">TT_DATE</code> or <code dir="ltr">TT_TIMESTAMP</code> respectively.</p>
</li>
<li>
<p>Numeric values are treated as number of days. For example, <code dir="ltr">SYSDATE</code> + 1 is tomorrow. <code dir="ltr">SYSDATE</code> - 7 is one week ago.</p>
</li>
<li>
<p>Subtracting two date columns results in the number of days between the two dates. The return type is numeric.</p>
</li>
<li>
<p>You cannot add date values. You cannot multiple or divide date or timestamp values.</p>
</li>
</ul>
<p><a href="#CIHDHIAD">Table 1-5</a> is a matrix of datetime arithmetic operations. Dashes represent operations that are not supported. The matrix assumes that you are using Oracle type mode:</p>
<div id="TTSQL513" class="tblhruleformalwidemax">
<p class="titleintable"><a id="sthref130"></a><a id="CIHDHIAD"></a>Table 1-5 DateTime arithmetic operations</p>
<table class="cellalignment6330" title="DateTime arithmetic operations" summary="This table summarizes date time arithmetic." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t14"><br/></th>
<th class="cellalignment6331" id="r1c2-t14">DATE</th>
<th class="cellalignment6331" id="r1c3-t14">TT_DATE</th>
<th class="cellalignment6331" id="r1c4-t14">TIMESTAMP</th>
<th class="cellalignment6331" id="r1c5-t14">TT_TIMESTAMP</th>
<th class="cellalignment6331" id="r1c6-t14">NUMERIC</th>
<th class="cellalignment6331" id="r1c7-t14">INTERVAL</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t14" headers="r1c1-t14">
<p><span class="bold">DATE</span></p>
</td>
<td class="cellalignment6332" headers="r2c1-t14 r1c2-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r2c1-t14 r1c3-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r2c1-t14 r1c4-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r2c1-t14 r1c5-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r2c1-t14 r1c6-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r2c1-t14 r1c7-t14">&nbsp;</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t14" headers="r1c1-t14">
<p><span class="bold">+ (plus)</span></p>
</td>
<td class="cellalignment6332" headers="r3c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r3c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r3c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r3c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r3c1-t14 r1c6-t14">
<p>DATE</p>
</td>
<td class="cellalignment6332" headers="r3c1-t14 r1c7-t14">
<p>DATE</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t14" headers="r1c1-t14">
<p>- <span class="bold">(minus)</span></p>
</td>
<td class="cellalignment6332" headers="r4c1-t14 r1c2-t14">
<p>NUMBER</p>
</td>
<td class="cellalignment6332" headers="r4c1-t14 r1c3-t14">
<p>NUMBER</p>
</td>
<td class="cellalignment6332" headers="r4c1-t14 r1c4-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r4c1-t14 r1c5-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r4c1-t14 r1c6-t14">
<p>DATE</p>
</td>
<td class="cellalignment6332" headers="r4c1-t14 r1c7-t14">
<p>DATE</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t14" headers="r1c1-t14">
<p><span class="bold">* (multiply)</span></p>
</td>
<td class="cellalignment6332" headers="r5c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r5c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r5c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r5c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r5c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r5c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t14" headers="r1c1-t14">
<p><span class="bold">/ (divide)</span></p>
</td>
<td class="cellalignment6332" headers="r6c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r6c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r6c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r6c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r6c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r6c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r7c1-t14" headers="r1c1-t14">
<p><span class="bold">TT_DATE</span></p>
</td>
<td class="cellalignment6332" headers="r7c1-t14 r1c2-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r7c1-t14 r1c3-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r7c1-t14 r1c4-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r7c1-t14 r1c5-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r7c1-t14 r1c6-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r7c1-t14 r1c7-t14">&nbsp;</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r8c1-t14" headers="r1c1-t14">
<p><span class="bold">+ (plus)</span></p>
</td>
<td class="cellalignment6332" headers="r8c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r8c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r8c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r8c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r8c1-t14 r1c6-t14">
<p>TT_DATE</p>
</td>
<td class="cellalignment6332" headers="r8c1-t14 r1c7-t14">
<p>TT_DATE</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r9c1-t14" headers="r1c1-t14">
<p><span class="bold">- (minus</span>)</p>
</td>
<td class="cellalignment6332" headers="r9c1-t14 r1c2-t14">
<p>NUMBER</p>
</td>
<td class="cellalignment6332" headers="r9c1-t14 r1c3-t14">
<p>TT_BIGINT</p>
</td>
<td class="cellalignment6332" headers="r9c1-t14 r1c4-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r9c1-t14 r1c5-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r9c1-t14 r1c6-t14">
<p>TT_DATE</p>
</td>
<td class="cellalignment6332" headers="r9c1-t14 r1c7-t14">
<p>TT_DATE</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r10c1-t14" headers="r1c1-t14">
<p><span class="bold">* (multiply)</span></p>
</td>
<td class="cellalignment6332" headers="r10c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r10c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r10c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r10c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r10c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r10c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r11c1-t14" headers="r1c1-t14">
<p><span class="bold">/ (divide)</span></p>
</td>
<td class="cellalignment6332" headers="r11c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r11c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r11c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r11c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r11c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r11c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r12c1-t14" headers="r1c1-t14">
<p><span class="bold">TIMESTAMP</span></p>
</td>
<td class="cellalignment6332" headers="r12c1-t14 r1c2-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r12c1-t14 r1c3-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r12c1-t14 r1c4-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r12c1-t14 r1c5-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r12c1-t14 r1c6-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r12c1-t14 r1c7-t14">&nbsp;</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r13c1-t14" headers="r1c1-t14">
<p><span class="bold">+ (plus)</span></p>
</td>
<td class="cellalignment6332" headers="r13c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r13c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r13c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r13c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r13c1-t14 r1c6-t14">
<p>DATE</p>
</td>
<td class="cellalignment6332" headers="r13c1-t14 r1c7-t14">
<p>TIMESTAMP</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r14c1-t14" headers="r1c1-t14">
<p><span class="bold">- (minus)</span></p>
</td>
<td class="cellalignment6332" headers="r14c1-t14 r1c2-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r14c1-t14 r1c3-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r14c1-t14 r1c4-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r14c1-t14 r1c5-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r14c1-t14 r1c6-t14">
<p>DATE</p>
</td>
<td class="cellalignment6332" headers="r14c1-t14 r1c7-t14">
<p>TIMESTAMP</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r15c1-t14" headers="r1c1-t14">
<p><span class="bold">* (multiply)</span></p>
</td>
<td class="cellalignment6332" headers="r15c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r15c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r15c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r15c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r15c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r15c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r16c1-t14" headers="r1c1-t14">
<p><span class="bold">/ (divide)</span></p>
</td>
<td class="cellalignment6332" headers="r16c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r16c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r16c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r16c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r16c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r16c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r17c1-t14" headers="r1c1-t14">
<p><span class="bold">TT_TIMESTAMP</span></p>
</td>
<td class="cellalignment6332" headers="r17c1-t14 r1c2-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r17c1-t14 r1c3-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r17c1-t14 r1c4-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r17c1-t14 r1c5-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r17c1-t14 r1c6-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r17c1-t14 r1c7-t14">&nbsp;</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r18c1-t14" headers="r1c1-t14">
<p><span class="bold">+ (plus)</span></p>
</td>
<td class="cellalignment6332" headers="r18c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r18c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r18c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r18c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r18c1-t14 r1c6-t14">
<p>TT_TIMESTAMP</p>
</td>
<td class="cellalignment6332" headers="r18c1-t14 r1c7-t14">
<p>TT_TIMESTAMP</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r19c1-t14" headers="r1c1-t14">
<p><span class="bold">- (minus)</span></p>
</td>
<td class="cellalignment6332" headers="r19c1-t14 r1c2-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r19c1-t14 r1c3-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r19c1-t14 r1c4-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r19c1-t14 r1c5-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r19c1-t14 r1c6-t14">
<p>TT_TIMESTAMP</p>
</td>
<td class="cellalignment6332" headers="r19c1-t14 r1c7-t14">
<p>TT_TIMESTAMP</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r20c1-t14" headers="r1c1-t14">
<p><span class="bold">* (multiply)</span></p>
</td>
<td class="cellalignment6332" headers="r20c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r20c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r20c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r20c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r20c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r20c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r21c1-t14" headers="r1c1-t14">
<p><span class="bold">/ (divide)</span></p>
</td>
<td class="cellalignment6332" headers="r21c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r21c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r21c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r21c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r21c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r21c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r22c1-t14" headers="r1c1-t14">
<p><span class="bold">NUMERIC</span></p>
</td>
<td class="cellalignment6332" headers="r22c1-t14 r1c2-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r22c1-t14 r1c3-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r22c1-t14 r1c4-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r22c1-t14 r1c5-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r22c1-t14 r1c6-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r22c1-t14 r1c7-t14">&nbsp;</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r23c1-t14" headers="r1c1-t14">
<p><span class="bold">+ (plus)</span></p>
</td>
<td class="cellalignment6332" headers="r23c1-t14 r1c2-t14">
<p>DATE</p>
</td>
<td class="cellalignment6332" headers="r23c1-t14 r1c3-t14">
<p>TT_DATE</p>
</td>
<td class="cellalignment6332" headers="r23c1-t14 r1c4-t14">
<p>DATE</p>
</td>
<td class="cellalignment6332" headers="r23c1-t14 r1c5-t14">
<p>TT_TIMESTAMP</p>
</td>
<td class="cellalignment6332" headers="r23c1-t14 r1c6-t14">
<p>Not applicable</p>
</td>
<td class="cellalignment6332" headers="r23c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r24c1-t14" headers="r1c1-t14">
<p><span class="bold">- (minus)</span></p>
</td>
<td class="cellalignment6332" headers="r24c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r24c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r24c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r24c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r24c1-t14 r1c6-t14">
<p>Not applicable</p>
</td>
<td class="cellalignment6332" headers="r24c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r25c1-t14" headers="r1c1-t14">
<p><span class="bold">* (multiply)</span></p>
</td>
<td class="cellalignment6332" headers="r25c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r25c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r25c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r25c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r25c1-t14 r1c6-t14">
<p>Not applicable</p>
</td>
<td class="cellalignment6332" headers="r25c1-t14 r1c7-t14">
<p>INTERVAL</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r26c1-t14" headers="r1c1-t14">
<p><span class="bold">/ (divide)</span></p>
</td>
<td class="cellalignment6332" headers="r26c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r26c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r26c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r26c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r26c1-t14 r1c6-t14">
<p>Not applicable</p>
</td>
<td class="cellalignment6332" headers="r26c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r27c1-t14" headers="r1c1-t14">
<p><span class="bold">INTERVAL</span></p>
</td>
<td class="cellalignment6332" headers="r27c1-t14 r1c2-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r27c1-t14 r1c3-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r27c1-t14 r1c4-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r27c1-t14 r1c5-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r27c1-t14 r1c6-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r27c1-t14 r1c7-t14">&nbsp;</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r28c1-t14" headers="r1c1-t14">
<p><span class="bold">+ (plus)</span></p>
</td>
<td class="cellalignment6332" headers="r28c1-t14 r1c2-t14">
<p>DATE</p>
</td>
<td class="cellalignment6332" headers="r28c1-t14 r1c3-t14">
<p>TT_DATE</p>
</td>
<td class="cellalignment6332" headers="r28c1-t14 r1c4-t14">
<p>TIMESTAMP</p>
</td>
<td class="cellalignment6332" headers="r28c1-t14 r1c5-t14">
<p>TT_TIMESTAMP</p>
</td>
<td class="cellalignment6332" headers="r28c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r28c1-t14 r1c7-t14">
<p>INTERVAL</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r29c1-t14" headers="r1c1-t14">
<p><span class="bold">- (minus)</span></p>
</td>
<td class="cellalignment6332" headers="r29c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r29c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r29c1-t14 r1c4-t14">&nbsp;</td>
<td class="cellalignment6332" headers="r29c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r29c1-t14 r1c6-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r29c1-t14 r1c7-t14">
<p>INTERVAL</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r30c1-t14" headers="r1c1-t14">
<p><span class="bold">* (multiply)</span></p>
</td>
<td class="cellalignment6332" headers="r30c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r30c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r30c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r30c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r30c1-t14 r1c6-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r30c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r31c1-t14" headers="r1c1-t14">
<p><span class="bold">/ (divide)</span></p>
</td>
<td class="cellalignment6332" headers="r31c1-t14 r1c2-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r31c1-t14 r1c3-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r31c1-t14 r1c4-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r31c1-t14 r1c5-t14">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r31c1-t14 r1c6-t14">
<p>INTERVAL</p>
</td>
<td class="cellalignment6332" headers="r31c1-t14 r1c7-t14">
<p>&mdash;</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwidemax" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
An interval data type cannot be the final result of a complete expression. The <code dir="ltr"><a href="function.htm#i1017701">EXTRACT</a></code> function must be used to extract the desired component of this interval result.</div>
<pre dir="ltr">SELECT tt_date1 - tt_date2 FROM t1;
SELECT EXTRACT(DAY FROM timestamp1-timestamp2) FROM t1;
SELECT * FROM t1 WHERE timestamp1 - timestamp2 = NUMTODSINTERVAL(10, &#39;DAY&#39;);
SELECT SYSDATE + NUMTODSINTERVAL(20,&#39;SECOND&#39;) FROM dual;
SELECT EXTRACT (SECOND FROM timestamp1-timestamp2) FROM dual;
/* select the microsecond difference between two timestamp values d1 and d2 */
SELECT 1000000*(EXTRACT(DAY FROM d1-d2)*24*3600+
EXTRACT(HOUR FROM d1-d2)*3600+
EXTRACT(MINUTE FROM d1-d2)*60+EXTRACT(SECOND FROM d1-d2) FROM d1;
</pre>
<p>This example inserts <code dir="ltr">TIMESTAMP</code> values into two columns and then subtracts the two values using the <code dir="ltr"><a href="function.htm#i1017701">EXTRACT</a></code> function:</p>
<pre dir="ltr">Command&gt; CREATE TABLE ts (id TIMESTAMP, id2 TIMESTAMP);
Command&gt; INSERT INTO ts VALUES (TIMESTAMP &#39;2007-01-20 12:45:23&#39;, 
       &gt; TIMESTAMP &#39;2006-12-25 17:34:22&#39;);
1 row inserted.
Command&gt; SELECT EXTRACT (DAY FROM id - id2) FROM ts;
&lt; 25 &gt;
1 row found.
</pre>
<p>The following queries return errors. You cannot select an interval result:</p>
<pre dir="ltr">SELECT timestamp1 - timestamp2 FROM t1;
</pre>
<p>You cannot compare an <code dir="ltr">INTERVAL YEAR TO MONTH</code> with an <code dir="ltr">INTERVAL DAY TO SECOND</code>:</p>
<pre dir="ltr">SELECT * FROM t1 WHERE timestamp1 - timestamp2 = NUMTOYMINTERVAL(10, &#39;YEAR&#39;);
</pre>
<p>You cannot compare an <code dir="ltr">INTERVAL DAY TO SECOND</code> with an <code dir="ltr">INTERVAL DAY</code>:</p>
<pre dir="ltr">SELECT * FROM t1 WHERE timestamp1 - timestamp2 = INTERVAL &#39;10&#39; DAY;
</pre>
<p>You cannot extract <code dir="ltr">YEAR</code> from an <code dir="ltr">INTERVAL DAY TO SECOND</code>:</p>
<pre dir="ltr">SELECT EXTRACT (YEAR FROM timestamp1 - timestamp2) FROM dual;
</pre></div>
<!-- class="sect2" -->
<div id="TTSQL162" class="sect2"><a id="sthref131"></a>
<h3 class="sect2">Restrictions on datetime and interval arithmetic operations</h3>
<p>Consider these restrictions when performing datetime and interval arithmetic:</p>
<ul>
<li>
<p>The results for addition and subtraction with <code dir="ltr">DATE</code> and <code dir="ltr">TIMESTAMP</code> types for <code dir="ltr">INTERVAL YEAR</code> and <code dir="ltr">INTERVAL MONTH</code> are not closed. For example, adding one year to the <code dir="ltr">DATE</code> or <code dir="ltr">TIMESTAMP</code> of &#39;2004-02-29&#39; results in a date arithmetic error (TimesTen error 2787) because February 29, 2005 does not exist (2005 is not a leap year). Adding <code dir="ltr">INTERVAL &#39;1&#39;</code> month to <code dir="ltr">DATE &#39;2005-01-30&#39;</code> also results in the same error because February never has 30 days.</p>
</li>
<li>
<p>The results are closed for <code dir="ltr">INTERVAL DAY</code>.</p>
</li>
<li>
<p>An interval data type cannot be the final result of a complete expression. The <code dir="ltr"><a href="function.htm#i1017701">EXTRACT</a></code> function must be used to extract the desired component of the interval result.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABEDECD"></a>
<div id="TTSQL163" class="sect1">
<h2 class="sect1"><a id="sthref132"></a><a id="sthref133"></a>Storage requirements</h2>
<p>Variable-length columns whose declared column length is greater than 128 bytes are stored out of line. Variable-length columns whose declared column length is less than or equal to 128 bytes are stored inline. All LOB data types are stored out of line.</p>
<p>For character semantics, the number of bytes stored out of line depends on the character set. For example, for a character set with four bytes per character, variable-length columns whose declared column length is greater than 32 (128/4) are stored out of line.</p>
<p><a href="#BABBACIH">Table 1-6</a> shows the storage requirements of the various data types.</p>
<div id="TTSQL164" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref134"></a><a id="BABBACIH"></a>Table 1-6 Data type storage requirements</p>
<table class="cellalignment6330" title="Data type storage requirements" summary="This table lists the storage requirements for each data type." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t16">Type</th>
<th class="cellalignment6331" id="r1c2-t16">Storage required</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t16" headers="r1c1-t16">
<p><a id="sthref135"></a><code dir="ltr">BINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r2c1-t16 r1c2-t16">
<p><code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t16" headers="r1c1-t16">
<p><code dir="ltr">BINARY_DOUBLE</code><a id="sthref136"></a></p>
</td>
<td class="cellalignment6332" headers="r3c1-t16 r1c2-t16">
<p>Eight bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t16" headers="r1c1-t16">
<p><code dir="ltr">BINARY_FLOAT</code><a id="sthref137"></a></p>
</td>
<td class="cellalignment6332" headers="r4c1-t16 r1c2-t16">
<p>Four bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t16" headers="r1c1-t16">
<p><code dir="ltr">CHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code><a id="sthref138"></a></p>
</td>
<td class="cellalignment6332" headers="r5c1-t16 r1c2-t16">
<p><code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes or, if character semantics, <code dir="ltr"><span class="codeinlineitalic">n</span></code> characters</p>
<p>If character semantics, the length of the column (<code dir="ltr"><span class="codeinlineitalic">n</span></code>) is based on length semantics and character set.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t16" headers="r1c1-t16">
<p><a id="sthref139"></a><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment6332" headers="r6c1-t16 r1c2-t16">
<p>Seven bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r7c1-t16" headers="r1c1-t16">
<p><a id="sthref140"></a>Interval</p>
</td>
<td class="cellalignment6332" headers="r7c1-t16 r1c2-t16">
<p>An interval type cannot be stored in TimesTen</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r8c1-t16" headers="r1c1-t16">
<p><code dir="ltr">NCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code><a id="sthref141"></a></p>
</td>
<td class="cellalignment6332" headers="r8c1-t16 r1c2-t16">
<p>Bytes required is 2*<code dir="ltr"><span class="codeinlineitalic">n</span></code> where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is the number of characters</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r9c1-t16" headers="r1c1-t16">
<p><code dir="ltr">NUM<a id="sthref142"></a>BER</code></p>
</td>
<td class="cellalignment6332" headers="r9c1-t16 r1c2-t16">
<p>Five to 22 bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r10c1-t16" headers="r1c1-t16">
<p><code dir="ltr">NVARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code><a id="sthref143"></a></p>
</td>
<td class="cellalignment6332" headers="r10c1-t16 r1c2-t16">
<p>For <code dir="ltr">NOT INLINE</code> columns:</p>
<p>On 32-bit platforms, 2*(length of value) + 20 bytes (minimum of 28 bytes).</p>
<p>On 64-bit platforms, 2*(length of value) + 24 bytes (minimum of 40 bytes).</p>
<p>For <code dir="ltr">INLINE</code> columns:</p>
<p>On 32-bit platforms, 2*(length of column) + 4 bytes.</p>
<p>On 64-bit platforms, 2*(length of column) + 8 bytes.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r11c1-t16" headers="r1c1-t16">
<p><code dir="ltr">RO<a id="sthref144"></a>WID</code></p>
</td>
<td class="cellalignment6332" headers="r11c1-t16 r1c2-t16">
<p>Twelve bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r12c1-t16" headers="r1c1-t16">
<p><a id="sthref145"></a><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment6332" headers="r12c1-t16 r1c2-t16">
<p>Twelve bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r13c1-t16" headers="r1c1-t16">
<p><code dir="ltr">TT_BIGINT</code><a id="sthref146"></a></p>
</td>
<td class="cellalignment6332" headers="r13c1-t16 r1c2-t16">
<p>Eight bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r14c1-t16" headers="r1c1-t16">
<p><a id="sthref147"></a><code dir="ltr">TT_DATE</code></p>
</td>
<td class="cellalignment6332" headers="r14c1-t16 r1c2-t16">
<p>Four bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r15c1-t16" headers="r1c1-t16">
<p><a id="sthref148"></a><code dir="ltr">TT_DECIMAL(</code><code dir="ltr"><span class="codeinlineitalic">p,s</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r15c1-t16 r1c2-t16">
<p>Approximately <code dir="ltr"><span class="codeinlineitalic">p</span></code>/2 bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r16c1-t16" headers="r1c1-t16">
<p><code dir="ltr">TT_INT[EG<a id="sthref149"></a>ER]</code></p>
</td>
<td class="cellalignment6332" headers="r16c1-t16 r1c2-t16">
<p>Four bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r17c1-t16" headers="r1c1-t16">
<p><code dir="ltr">TT_SMALLINT</code><a id="sthref150"></a></p>
</td>
<td class="cellalignment6332" headers="r17c1-t16 r1c2-t16">
<p>Two bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r18c1-t16" headers="r1c1-t16">
<p><a id="sthref151"></a><code dir="ltr">TT_TIME</code></p>
</td>
<td class="cellalignment6332" headers="r18c1-t16 r1c2-t16">
<p>Eight bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r19c1-t16" headers="r1c1-t16">
<p><code dir="ltr">TT_TIMESTAMP</code><a id="sthref152"></a></p>
</td>
<td class="cellalignment6332" headers="r19c1-t16 r1c2-t16">
<p>Eight bytes</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r20c1-t16" headers="r1c1-t16">
<p><code dir="ltr">TT_TINYINT</code><a id="sthref153"></a></p>
</td>
<td class="cellalignment6332" headers="r20c1-t16 r1c2-t16">
<p>One byte</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r21c1-t16" headers="r1c1-t16">
<p><a id="sthref154"></a><code dir="ltr">VARBINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r21c1-t16 r1c2-t16">
<p>For <code dir="ltr">NOT INLINE</code> columns:</p>
<p>On 32-bit platforms, length of value + 20 bytes (minimum of 28 bytes).</p>
<p>On 64-bit platforms, length of value + 24 bytes (minimum of 40 bytes).</p>
<p>For <code dir="ltr">INLINE</code> columns:</p>
<p>On 32-bit platforms, length of column + 4 bytes.</p>
<p>On 64-bit platforms, length of column + 8 bytes.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r22c1-t16" headers="r1c1-t16">
<p><code dir="ltr">VARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])<a id="sthref155"></a></code></p>
</td>
<td class="cellalignment6332" headers="r22c1-t16 r1c2-t16">
<p>For <code dir="ltr">NOT INLINE</code> columns:</p>
<p>On 32-bit platforms, length of value + 20 bytes (minimum of 28 bytes). <a id="sthref156"></a><code dir="ltr">NULL</code> value is stored as (null bit) + 4 bytes, or 4.125 bytes.</p>
<p>On 64-bit platforms, length of value + 24 bytes (minimum of 40 bytes). <code dir="ltr">NULL</code> value is stored as (null bit) + 8 bytes, or 8.125 bytes.</p>
<p>This storage principal holds for all variable length <code dir="ltr">NOT INLINE</code> data types: <code dir="ltr">TT_VARCHAR</code>, <code dir="ltr">TT_NVARCHAR</code>, <code dir="ltr">VARCHAR2</code>, <code dir="ltr">NVARCHAR2</code>, and <code dir="ltr">VARBINARY</code>.</p>
<p>For <code dir="ltr">INLINE</code> columns:</p>
<p>On 32-bit platforms, <code dir="ltr"><span class="codeinlineitalic">n</span></code> + 4 bytes. <code dir="ltr">NULL</code> value is stored as (null bit) + <code dir="ltr"><span class="codeinlineitalic">n</span></code> + 4 bytes.</p>
<p>On 64-bit platforms, n + 8 bytes. <code dir="ltr">NULL</code> value is stored as (null bit) + <code dir="ltr"><span class="codeinlineitalic">n</span></code> + 8 bytes.</p>
<p>If character semantics, the length of the column (<code dir="ltr"><span class="codeinlineitalic">n</span></code>) is based on length semantics and character set.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r23c1-t16" headers="r1c1-t16">
<p><code dir="ltr">BL<a id="sthref157"></a><a id="sthref158"></a>OB</code> and <code dir="ltr">CLOB</code></p>
</td>
<td class="cellalignment6332" headers="r23c1-t16 r1c2-t16">
<p>On 32-bit platforms, length of value + 36 bytes (minimum of 40 bytes)</p>
<p>On 64-bit platforms, length of value + 48 bytes (minimum of 56 bytes)</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r24c1-t16" headers="r1c1-t16">
<p><code dir="ltr">NC<a id="sthref159"></a>LOB</code></p>
</td>
<td class="cellalignment6332" headers="r24c1-t16 r1c2-t16">
<p>On 32-bit platforms, 2 * (length of value) + 36 bytes (minimum of 40 bytes)</p>
<p>On 64-bit platforms, 2 * (length of value) + 48 bytes (minimum of 56 bytes)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect1" -->
<a id="BABJEBAC"></a>
<div id="TTSQL165" class="sect1">
<h2 class="sect1"><a id="sthref160"></a><a id="sthref161"></a>Data type comparison rules</h2>
<p>This section describes how values of each data type are compared in TimesTen.</p>
<div id="TTSQL166" class="sect2"><a id="sthref162"></a>
<h3 class="sect2">Nu<a id="sthref163"></a>meric values</h3>
<p>A larger value is greater than a smaller value: -1 is less than 10, and -10 is less than -1.</p>
<p>The floating-point value <code dir="ltr">NaN</code> is greater than any other numeric value and is equal to itself.</p>
</div>
<!-- class="sect2" -->
<div id="TTSQL167" class="sect2"><a id="sthref164"></a>
<h3 class="sect2">Da<a id="sthref165"></a>te values</h3>
<p>A later date is considered greater than an earlier one. For example, the date equivalent of &#39;10-AUG-2005&#39; is less than that of &#39;30-AUG-2006&#39;, and &#39;30-AUG-2006 1:15 pm&#39; is greater than &#39;30-AUG-2006 10:10 am&#39;.</p>
</div>
<!-- class="sect2" -->
<div id="TTSQL168" class="sect2"><a id="sthref166"></a>
<h3 class="sect2">Ch<a id="sthref167"></a>aracter values</h3>
<p>Character values are compared in the following ways:</p>
<ul>
<li>
<p><a href="#BABDCHFJ">Binary and linguistic sorting</a></p>
</li>
<li>
<p><a href="#i1035598">Blank-padded and nonpadded comparison semantics</a></p>
</li>
</ul>
<a id="BABDCHFJ"></a>
<div id="TTSQL169" class="sect3">
<h4 class="sect3">Binary and linguistic sorting</h4>
<p>In binary sorting, TimesTen compares character strings according to the concatenated value of the numeric codes of the characters in the database character set. One character is greater than the other if it has a greater numeric values than the other in the character set. Blanks are less than any character.</p>
<p>Linguistic sorting is useful if the binary sequence of numeric codes does not match the linguistic sequence of the characters you are comparing. In linguistic sorting, SQL sorting and comparison are based on the linguistic rule set by <code dir="ltr">NLS_SORT</code>. For more information on linguistic sorts, see <a class="olink TTOPR283" href="../TTOPR/globalization.htm#TTOPR283">&#34;Linguistic sorts&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>.</p>
<p>The default is binary sorting.</p>
</div>
<!-- class="sect3" -->
<a id="i1035598"></a>
<div id="TTSQL170" class="sect3">
<h4 class="sect3">Blank-padded and nonpadded comparison semantics</h4>
<p>With blank-padded semantics, if two values have different lengths, TimesTen adds blanks to the shorter value until both lengths are equal. Values are then compared character by character up to the first character that differs. The value with the greater character in the first differing position is considered greater. If two values have no differing characters, then they are considered equal. Thus, two values are considered equal if they differ only in the number of trailing blanks.</p>
<p>Blank-padded semantics are used when both values in the comparison are expressions of type <code dir="ltr">CHAR</code> or <code dir="ltr">NCHAR</code> or text literals.</p>
<p>With nonpadded semantics, two values are compared, character by character, up to the first character that differs. The value with the greater character in that position is considered greater. If two values that have differing lengths are identical up to the end of the shorter one, then the longer one is considered greater. If two values of equal length have no differing characters, they are considered equal.</p>
<p>Nonpadded semantics are used when both values in the comparison have the type <code dir="ltr">VARCHAR2</code> or <code dir="ltr">NVARCHAR2</code>.</p>
<p>An example with blank-padded semantics:</p>
<pre dir="ltr">&#39;a   &#39; = &#39;a&#39;
</pre>
<p>An example with nonpadded semantics:</p>
<pre dir="ltr">&#39;a   &#39; &gt; &#39;a&#39;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABIDFCD"></a>
<div id="TTSQL171" class="sect1">
<h2 class="sect1"><a id="sthref168"></a><a id="sthref169"></a>Data type conversion</h2>
<p>Generally an expression cannot contain values of different data types. However, TimesTen supports both implicit and explicit conversion from one data type to another. Because algorithms for implicit conversion are subject to change across software releases and the behavior of explicit conversions is more predictable, TimesTen recommends explicit conversion.</p>
<a id="BABEJEJB"></a>
<div id="TTSQL172" class="sect2">
<h3 class="sect2">Implicit data type conversion</h3>
<p>TimesTen converts a value from one data type to another when such a conversion is sensible.</p>
<p><a href="#CIHGCGHA">Table 1-7</a> and <a href="#CIHCIGIB">Table 1-8</a> use a matrix to illustrate TimesTen implicit data type conversions. <code dir="ltr">YES</code> in the cell indicates the conversion is supported. <code dir="ltr">NO</code> in the cell indicates the conversion is not supported. The rules for implicit conversion follow the table.</p>
<div id="TTSQL514" class="tblhruleformalwidemax">
<p class="titleintable"><a id="sthref170"></a><a id="CIHGCGHA"></a>Table 1-7 Implicit data type conversion</p>
<table class="cellalignment6330" title="Implicit data type conversion" summary="This table shows a matrix of implicit data type conversions." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t17"><br/></th>
<th class="cellalignment6331" id="r1c2-t17">CHAR</th>
<th class="cellalignment6331" id="r1c3-t17">VARCHAR2</th>
<th class="cellalignment6331" id="r1c4-t17">NCHAR</th>
<th class="cellalignment6331" id="r1c5-t17">NVARCHAR2</th>
<th class="cellalignment6331" id="r1c6-t17">DATE</th>
<th class="cellalignment6331" id="r1c7-t17">TT_DATE</th>
<th class="cellalignment6331" id="r1c8-t17">TIMESTAMP</th>
<th class="cellalignment6331" id="r1c9-t17">TT_TIMESTAMP</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t17" headers="r1c1-t17">
<p><span class="bold">CHAR</span></p>
</td>
<td class="cellalignment6332" headers="r2c1-t17 r1c2-t17">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r2c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t17 r1c6-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t17 r1c7-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t17 r1c8-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t17 r1c9-t17">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t17" headers="r1c1-t17">
<p><span class="bold">VARCHAR2</span></p>
</td>
<td class="cellalignment6332" headers="r3c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t17 r1c3-t17">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r3c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t17 r1c6-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t17 r1c7-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t17 r1c8-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t17 r1c9-t17">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t17" headers="r1c1-t17">
<p><span class="bold">NCHAR</span></p>
</td>
<td class="cellalignment6332" headers="r4c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t17 r1c4-t17">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r4c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t17 r1c6-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t17 r1c7-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t17 r1c8-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t17 r1c9-t17">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t17" headers="r1c1-t17">
<p><span class="bold">NVARCHAR2</span></p>
</td>
<td class="cellalignment6332" headers="r5c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t17 r1c5-t17">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r5c1-t17 r1c6-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t17 r1c7-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t17 r1c8-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t17 r1c9-t17">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t17" headers="r1c1-t17">
<p><span class="bold">DATE</span></p>
</td>
<td class="cellalignment6332" headers="r6c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r6c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r6c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r6c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r6c1-t17 r1c6-t17">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r6c1-t17 r1c7-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r6c1-t17 r1c8-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r6c1-t17 r1c9-t17">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r7c1-t17" headers="r1c1-t17">
<p><span class="bold">TT_DATE</span></p>
</td>
<td class="cellalignment6332" headers="r7c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r7c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r7c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r7c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r7c1-t17 r1c6-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r7c1-t17 r1c7-t17">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r7c1-t17 r1c8-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r7c1-t17 r1c9-t17">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r8c1-t17" headers="r1c1-t17">
<p><span class="bold">TIMESTAMP</span></p>
</td>
<td class="cellalignment6332" headers="r8c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r8c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r8c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r8c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r8c1-t17 r1c6-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r8c1-t17 r1c7-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r8c1-t17 r1c8-t17">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r8c1-t17 r1c9-t17">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r9c1-t17" headers="r1c1-t17">
<p><span class="bold">TT_</span><span class="bold">TIMESTAMP</span></p>
</td>
<td class="cellalignment6332" headers="r9c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r9c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r9c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r9c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r9c1-t17 r1c6-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r9c1-t17 r1c7-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r9c1-t17 r1c8-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r9c1-t17 r1c9-t17">
<p>&mdash;</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r10c1-t17" headers="r1c1-t17">
<p><span class="bold">NUMERIC</span></p>
</td>
<td class="cellalignment6332" headers="r10c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r10c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r10c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r10c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r10c1-t17 r1c6-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r10c1-t17 r1c7-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r10c1-t17 r1c8-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r10c1-t17 r1c9-t17">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r11c1-t17" headers="r1c1-t17">
<p><span class="bold">BLOB</span></p>
</td>
<td class="cellalignment6332" headers="r11c1-t17 r1c2-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t17 r1c3-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t17 r1c4-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t17 r1c5-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t17 r1c6-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t17 r1c7-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t17 r1c8-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t17 r1c9-t17">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r12c1-t17" headers="r1c1-t17">
<p><span class="bold">CLOB</span></p>
</td>
<td class="cellalignment6332" headers="r12c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r12c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r12c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r12c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r12c1-t17 r1c6-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r12c1-t17 r1c7-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r12c1-t17 r1c8-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r12c1-t17 r1c9-t17">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r13c1-t17" headers="r1c1-t17">
<p><span class="bold">NCLOB</span></p>
</td>
<td class="cellalignment6332" headers="r13c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r13c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r13c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r13c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r13c1-t17 r1c6-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r13c1-t17 r1c7-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r13c1-t17 r1c8-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r13c1-t17 r1c9-t17">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r14c1-t17" headers="r1c1-t17">
<p><span class="bold">BINARY</span>/ <span class="bold">VARBINARY</span></p>
</td>
<td class="cellalignment6332" headers="r14c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r14c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r14c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r14c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r14c1-t17 r1c6-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r14c1-t17 r1c7-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r14c1-t17 r1c8-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r14c1-t17 r1c9-t17">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r15c1-t17" headers="r1c1-t17">
<p><span class="bold">ROWID</span></p>
</td>
<td class="cellalignment6332" headers="r15c1-t17 r1c2-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r15c1-t17 r1c3-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r15c1-t17 r1c4-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r15c1-t17 r1c5-t17">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r15c1-t17 r1c6-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r15c1-t17 r1c7-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r15c1-t17 r1c8-t17">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r15c1-t17 r1c9-t17">
<p>NO</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwidemax" -->
<div id="TTSQL515" class="tblhruleformalmax">
<p class="titleintable"><a id="sthref171"></a><a id="CIHCIGIB"></a>Table 1-8 Implicit data type conversion (continuation of preceding table)</p>
<table class="cellalignment6330" title="Implicit data type conversion (continuation of preceding table)" summary="This table is a continuation of the implict data type conversion matrix." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t18"><br/></th>
<th class="cellalignment6331" id="r1c2-t18">NUMERIC</th>
<th class="cellalignment6331" id="r1c3-t18">BLOB</th>
<th class="cellalignment6331" id="r1c4-t18">CLOB</th>
<th class="cellalignment6331" id="r1c5-t18">NCLOB</th>
<th class="cellalignment6331" id="r1c6-t18">BINARY/ VARBINARY</th>
<th class="cellalignment6331" id="r1c7-t18">ROWID</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t18" headers="r1c1-t18">
<p><span class="bold">CHAR</span></p>
</td>
<td class="cellalignment6332" headers="r2c1-t18 r1c2-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t18 r1c3-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t18 r1c4-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t18 r1c5-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t18 r1c6-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r2c1-t18 r1c7-t18">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t18" headers="r1c1-t18">
<p><span class="bold">VARCHAR2</span></p>
</td>
<td class="cellalignment6332" headers="r3c1-t18 r1c2-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t18 r1c3-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t18 r1c4-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t18 r1c5-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t18 r1c6-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r3c1-t18 r1c7-t18">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t18" headers="r1c1-t18">
<p><span class="bold">NCHAR</span></p>
</td>
<td class="cellalignment6332" headers="r4c1-t18 r1c2-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t18 r1c3-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t18 r1c4-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t18 r1c5-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t18 r1c6-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r4c1-t18 r1c7-t18">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t18" headers="r1c1-t18">
<p><span class="bold">NVARCHAR2</span></p>
</td>
<td class="cellalignment6332" headers="r5c1-t18 r1c2-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t18 r1c3-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t18 r1c4-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t18 r1c5-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t18 r1c6-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r5c1-t18 r1c7-t18">
<p>YES</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t18" headers="r1c1-t18">
<p><span class="bold">DATE</span></p>
</td>
<td class="cellalignment6332" headers="r6c1-t18 r1c2-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r6c1-t18 r1c3-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r6c1-t18 r1c4-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r6c1-t18 r1c5-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r6c1-t18 r1c6-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r6c1-t18 r1c7-t18">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r7c1-t18" headers="r1c1-t18">
<p><span class="bold">TT_DATE</span></p>
</td>
<td class="cellalignment6332" headers="r7c1-t18 r1c2-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r7c1-t18 r1c3-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r7c1-t18 r1c4-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r7c1-t18 r1c5-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r7c1-t18 r1c6-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r7c1-t18 r1c7-t18">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r8c1-t18" headers="r1c1-t18">
<p><span class="bold">TIMESTAMP</span></p>
</td>
<td class="cellalignment6332" headers="r8c1-t18 r1c2-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r8c1-t18 r1c3-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r8c1-t18 r1c4-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r8c1-t18 r1c5-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r8c1-t18 r1c6-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r8c1-t18 r1c7-t18">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r9c1-t18" headers="r1c1-t18">
<p><span class="bold">TT_TIMESTAMP</span></p>
</td>
<td class="cellalignment6332" headers="r9c1-t18 r1c2-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r9c1-t18 r1c3-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r9c1-t18 r1c4-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r9c1-t18 r1c5-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r9c1-t18 r1c6-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r9c1-t18 r1c7-t18">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r10c1-t18" headers="r1c1-t18">
<p><span class="bold">NUMERIC</span></p>
</td>
<td class="cellalignment6332" headers="r10c1-t18 r1c2-t18">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r10c1-t18 r1c3-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r10c1-t18 r1c4-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r10c1-t18 r1c5-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r10c1-t18 r1c6-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r10c1-t18 r1c7-t18">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r11c1-t18" headers="r1c1-t18">
<p><span class="bold">BLOB</span></p>
</td>
<td class="cellalignment6332" headers="r11c1-t18 r1c2-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t18 r1c3-t18">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r11c1-t18 r1c4-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t18 r1c5-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r11c1-t18 r1c6-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r11c1-t18 r1c7-t18">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r12c1-t18" headers="r1c1-t18">
<p><span class="bold">CLOB</span></p>
</td>
<td class="cellalignment6332" headers="r12c1-t18 r1c2-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r12c1-t18 r1c3-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r12c1-t18 r1c4-t18">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r12c1-t18 r1c5-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r12c1-t18 r1c6-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r12c1-t18 r1c7-t18">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r13c1-t18" headers="r1c1-t18">
<p><span class="bold">NCLOB</span></p>
</td>
<td class="cellalignment6332" headers="r13c1-t18 r1c2-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r13c1-t18 r1c3-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r13c1-t18 r1c4-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r13c1-t18 r1c5-t18">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r13c1-t18 r1c6-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r13c1-t18 r1c7-t18">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r14c1-t18" headers="r1c1-t18">
<p><span class="bold">BINARY/</span> <span class="bold">VARBINARY</span></p>
</td>
<td class="cellalignment6332" headers="r14c1-t18 r1c2-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r14c1-t18 r1c3-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r14c1-t18 r1c4-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r14c1-t18 r1c5-t18">
<p>YES</p>
</td>
<td class="cellalignment6332" headers="r14c1-t18 r1c6-t18">
<p>&mdash;</p>
</td>
<td class="cellalignment6332" headers="r14c1-t18 r1c7-t18">
<p>NO</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r15c1-t18" headers="r1c1-t18">
<p><span class="bold">ROWID</span></p>
</td>
<td class="cellalignment6332" headers="r15c1-t18 r1c2-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r15c1-t18 r1c3-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r15c1-t18 r1c4-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r15c1-t18 r1c5-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r15c1-t18 r1c6-t18">
<p>NO</p>
</td>
<td class="cellalignment6332" headers="r15c1-t18 r1c7-t18">
<p>&mdash;</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalmax" -->
<p>The following rules apply:</p>
<ul>
<li>
<p>During arithmetic operations on and comparisons between character and non-character data types, TimesTen converts from any character data type to a numeric or datetime data type as appropriate. In arithmetic operations between <code dir="ltr">CHAR</code>/<code dir="ltr">VARCHAR2</code> and <code dir="ltr">NCHAR</code>/<code dir="ltr">NVARCHAR2</code>, TimesTen converts to a <code dir="ltr">NUMBER</code>.</p>
</li>
<li>
<p>During arithmetic operations, floating point values <code dir="ltr">INF</code> and <code dir="ltr">NAN</code> are not supported when converting character values to numeric values.</p>
</li>
<li>
<p>During concatenation operations, TimesTen converts non-character data types to <code dir="ltr">CHAR</code>, <code dir="ltr">NCHAR</code>, <code dir="ltr">VARCHAR2</code>, or <code dir="ltr">NVARCHAR2</code> depending on the other operand.</p>
</li>
<li>
<p>When comparing a character value with a numeric value, TimesTen converts the character data to a numeric value.</p>
</li>
<li>
<p>When comparing a character value with a datetime value, TimesTen converts the character data to a datetime value.</p>
</li>
<li>
<p>During conversion from a timestamp value to a <code dir="ltr">DATE</code> value, the fractional seconds portion of the timestamp value is truncated.</p>
</li>
<li>
<p>Conversions from <code dir="ltr">BINARY_FLOAT</code> to <code dir="ltr">BINARY_DOUBLE</code> are exact.</p>
</li>
<li>
<p>Conversions from <code dir="ltr">BINARY_DOUBLE</code> to <code dir="ltr">BINARY_FLOAT</code> are inexact if the <code dir="ltr">BINARY_DOUBLE</code> value uses more bits of precision that supported by the <code dir="ltr">BINARY_FLOAT</code>.</p>
</li>
<li>
<p>Conversions between either character values or exact numeric values (<code dir="ltr">TT_TINYINT</code>, <code dir="ltr">TT_SMALLINT</code>, <code dir="ltr">TT_INTEGER</code>, <code dir="ltr">TT_BIGINT</code>, <code dir="ltr">NUMBER</code>) and floating-point values (<code dir="ltr">BINARY_FLOAT</code>, <code dir="ltr">BINARY_DOUBLE</code>) can be inexact because the character values and the exact numeric values use decimal precision whereas the floating-point numbers use binary precision.</p>
</li>
<li>
<p>When manipulating numeric values, TimesTen usually adjusts precision and scale to allow for maximum capacity. In such cases, the numeric data type resulting from such operations can differ from the numeric data type found in the underlying tables.</p>
</li>
<li>
<p>When making assignments, TimesTen converts the value on the right side of the equal sign (=) to the data type of the target of the assignment on the left side.</p>
</li>
<li>
<p>When you use a SQL function or operator with an argument of a data type other than the one it accepts, TimesTen converts the argument to the accepted data type as long as TimesTen supports the implicit conversion.</p>
</li>
<li>
<p>During <code dir="ltr">INSERT</code>, <code dir="ltr">INSERT... SELECT</code>, and <code dir="ltr">UPDATE</code> operations, TimesTen converts the value to the data type of the affected column.</p>
</li>
<li>
<p>Implicit and explicit <code dir="ltr">CHAR</code>/<code dir="ltr">VARCHAR2</code> &lt;-&gt; <code dir="ltr">NCHAR</code>/<code dir="ltr">NVARCHAR</code>2 conversions are supported unless the character set is <code dir="ltr">TIMESTEN8</code>. An example of implicit conversion:</p>
<pre dir="ltr">Command&gt; CREATE TABLE convdemo (c1 CHAR (10), x1 TT_INTEGER);
Command&gt; CREATE TABLE convdemo2 (c1 NCHAR (10), x2 TT_INTEGER);
Command&gt; INSERT INTO convdemo VALUES (&#39;ABC&#39;, 10);
1 row inserted.
Command&gt; INSERT INTO convdemo VALUES (&#39;def&#39;, 100);
1 row inserted.
Command&gt; INSERT INTO convdemo2 SELECT * FROM convdemo;
2 rows inserted.
Command&gt; SELECT x1,x2,convdemo.c1, convdemo2.c1 
       &gt; FROM convdemo, convdemo2 where Convdemo.c1 = convdemo2.c1;
X1, X2, C1, C1
&lt; 10, 10, ABC       , ABC        &gt;
&lt; 100, 100, def       , def        &gt;
2 rows found.
</pre></li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i992648"></a>
<div id="TTSQL173" class="sect1">
<h2 class="sect1">Nu<a id="sthref172"></a>ll values</h2>
<p>The value <code dir="ltr">NULL</code> indicates the absence of a value. It is a placeholder for a value that is missing. Use a <code dir="ltr">NULL</code> when the actual value is not known or when a value would not be meaningful. Do not use <code dir="ltr">NULL</code> to represent a numeric value of zero, because they are not equivalent. Any parameter in an expression can contain <code dir="ltr">NULL</code> regardless of its data type. In addition, any column in a table can contain <code dir="ltr">NULL</code>, regardless of its data type, unless you specify <code dir="ltr">NOT NULL</code> or <code dir="ltr">PRIMARY KEY</code> integrity constraints for the column when you create the table.</p>
<p>The following properties of <code dir="ltr">NULL</code> affect operations on rows, parameters, or local variables:</p>
<ul>
<li>
<p><a id="sthref173"></a>By default, <code dir="ltr">NULL</code> is sorted as the highest value in a sequence of values. However, you can modify the sort order value for <code dir="ltr">NULL</code> with <code dir="ltr">NULLS FIRST</code> or <code dir="ltr">NULLS LAST</code> in the <code dir="ltr">ORDER BY</code> clause.</p>
</li>
<li>
<p>Two <code dir="ltr">NULL</code> values are not equal to each other except in a <code dir="ltr">GROUP BY</code> or <code dir="ltr">SELECT DISTINCT</code> operation.</p>
</li>
<li>
<p>An arithmetic expression containing a <code dir="ltr">NULL</code> evaluates to <code dir="ltr">NULL</code>. In fact, all operators (except concatenation) return <code dir="ltr">NULL</code> when given a <code dir="ltr">NULL</code> operand. For example, <code dir="ltr">(5-col)</code>, where <code dir="ltr">col</code> is <code dir="ltr">NULL</code>, evaluates to <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p>To test for <code dir="ltr">NULL</code>, use the comparison conditions <code dir="ltr">IS NULL</code> or <code dir="ltr">IS NOT NULL</code>. Because <code dir="ltr">NULL</code> represents a lack of data, a <code dir="ltr">NULL</code> cannot be equal or unequal to any value or to another <code dir="ltr">NULL</code>. Thus, the statement <code dir="ltr">select * from employees where mgr_id = NULL</code> evaluates to 0, since you cannot use this comparison to <code dir="ltr">NULL</code>. However, the statement <code dir="ltr">select * from employees where mgr_id is NULL</code> provides the CEO of the company, since that is the only employee without a manager. For details, see <a href="search.htm#CHDFJAGI">&#34;IS NULL predicate&#34;</a>.</p>
</li>
<li>
<p>You can use the <code dir="ltr">NULL</code> value itself directly as an operand of an operator or predicate. For example, the <code dir="ltr">(1 = NULL)</code> comparison is supported. This is the same as if you cast <code dir="ltr">NULL</code> to the appropriate data type, as follows: <code dir="ltr">(1 = CAST(NULL AS INT))</code>. Both methods are supported and return the same results.</p>
</li>
</ul>
<p>Because of these properties, TimesTen ignores columns, rows, or parameters containing <code dir="ltr">NULL</code> when:</p>
<ul>
<li>
<p>Joining tables if the join is on a column containing <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p>Executing aggregate functions.</p>
</li>
</ul>
<p>In se<a id="sthref174"></a><a id="sthref175"></a>veral SQL predicates, described in <a href="search.htm#i994763">Chapter 5, &#34;Search Conditions,&#34;</a> you can explicitly test for <code dir="ltr">NULL</code>. APIs supported by TimesTen offer ways to handle null values. For example, in an ODBC application, use the functions <code dir="ltr">SQLBindCol</code>, <code dir="ltr">SQLBindParameter</code>, <code dir="ltr">SQLGetData</code>, and <code dir="ltr">SQLParamData</code> to handle input and output of <code dir="ltr">NULL</code> values.</p>
</div>
<!-- class="sect1" -->
<a id="i1036375"></a>
<div id="TTSQL174" class="sect1">
<h2 class="sect1"><a id="sthref176"></a><a id="sthref177"></a>INF and NAN</h2>
<p>TimesTen supports the IEEE floating-point values <code dir="ltr">Inf</code> (positive infinity), <code dir="ltr">-Inf</code> (negative infinity), and <code dir="ltr">NaN</code> (not a number).</p>
<div id="TTSQL175" class="sect2"><a id="sthref178"></a>
<h3 class="sect2">Constant values</h3>
<p>You can use constant values in places where a floating-point constant is allowed. The following constants are supported:</p>
<ul>
<li>
<p><code dir="ltr">BINARY_FLOAT_INFINITY</code></p>
</li>
<li>
<p><code dir="ltr">-BINARY_FLOAT_INFINITY</code></p>
</li>
<li>
<p><code dir="ltr">BINARY_DOUBLE_INFINITY</code></p>
</li>
<li>
<p><code dir="ltr">-BINARY_DOUBLE_INFINITY</code></p>
</li>
<li>
<p><code dir="ltr">BINARY_FLOAT_NAN</code></p>
</li>
<li>
<p><code dir="ltr">BINARY_DOUBLE_NAN</code></p>
</li>
</ul>
<p>In the following example, a table is created with a column of type <code dir="ltr">BINARY_FLOAT</code> and a column of type <code dir="ltr">TT_INTEGER</code>. <code dir="ltr">BINARY_FLOAT_INFINITY</code> and <code dir="ltr">BINARY_FLOAT_NAN</code> are inserted into the column of type <code dir="ltr">BINARY_FLOAT</code>.</p>
<pre dir="ltr">Command&gt; CREATE TABLE bfdemo (id BINARY_FLOAT, Ii2 TT_INTEGER);
Command&gt; INSERT INTO bfdemo VALUES (BINARY_FLOAT_INFINITY, 50);
1 row inserted.
Command&gt; INSERT INTO bfdemo VALUES (BINARY_FLOAT_NAN, 100);
1 row inserted.
Command&gt; SELECT * FROM bfdemo;
&lt; INF, 50 &gt;
&lt; NAN, 100 &gt;
2 rows found.
</pre></div>
<!-- class="sect2" -->
<div id="TTSQL176" class="sect2"><a id="sthref179"></a>
<h3 class="sect2">Primary key values</h3>
<p><code dir="ltr">Inf</code>, <code dir="ltr">-Inf</code>, and <code dir="ltr">NaN</code> are acceptable values in columns defined with a primary key. This is different from <code dir="ltr">NULL</code>, which is not allowed in columns defined with a primary key.</p>
<p>You can only insert <code dir="ltr">Inf</code>, <code dir="ltr">-Inf</code>, and <code dir="ltr">NaN</code> values into <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> columns.</p>
</div>
<!-- class="sect2" -->
<div id="TTSQL177" class="sect2"><a id="sthref180"></a>
<h3 class="sect2">Selecting Inf and NaN (floating-point conditions)</h3>
<p>Floating-point conditions determine whether an expression is infinite or is the undefined result of an operation (<code dir="ltr">NaN</code>, meaning not a number).</p>
<p>Consider the following syntax:</p>
<pre dir="ltr"><span class="italic">Expression</span> IS [NOT] {NAN|INFINITE}
</pre>
<p><code dir="ltr"><span class="codeinlineitalic">Expression</span></code> must either resolve to a numeric data type or to a data type that can be implicitly converted to a numeric data type.</p>
<p>The following table describes the floating-point conditions.</p>
<div class="inftblhruleinformal">
<table class="cellalignment6330" title="Descriptions of floating point conditions" summary="This table contains a description and an example for each floating point condition." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t19">Condition</th>
<th class="cellalignment6331" id="r1c2-t19">Operation</th>
<th class="cellalignment6331" id="r1c3-t19">Example</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t19" headers="r1c1-t19"><code dir="ltr">IS [NOT] NAN</code></td>
<td class="cellalignment6332" headers="r2c1-t19 r1c2-t19">Returns <code dir="ltr">TRUE</code> if <code dir="ltr"><span class="codeinlineitalic">Expression</span></code> is the value <code dir="ltr">NaN</code> when <code dir="ltr">NOT</code> is not specified. Returns <code dir="ltr">TRUE</code> if <code dir="ltr"><span class="codeinlineitalic">Expression</span></code> is not the value <code dir="ltr">NaN</code> when <code dir="ltr">NOT</code> is specified.</td>
<td class="cellalignment6332" headers="r2c1-t19 r1c3-t19">
<pre dir="ltr">SELECT * FROM bfdemo WHERE id IS
NOT NAN;
ID, ID2
&lt; INF, 50 &gt;
1 row found.
</pre></td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t19" headers="r1c1-t19"><code dir="ltr">IS [NOT] INFINITE</code></td>
<td class="cellalignment6332" headers="r3c1-t19 r1c2-t19">Returns <code dir="ltr">TRUE</code> if <code dir="ltr"><span class="codeinlineitalic">Expression</span></code> is the value <code dir="ltr">+Inf</code> or <code dir="ltr">-Inf</code> when <code dir="ltr">NOT</code> is not specified. Returns <code dir="ltr">TRUE</code> if <code dir="ltr"><span class="codeinlineitalic">Expression</span></code> is neither <code dir="ltr">+Inf</code> nor <code dir="ltr">-Inf</code> when <code dir="ltr">NOT</code> is specified.</td>
<td class="cellalignment6332" headers="r3c1-t19 r1c3-t19">
<pre dir="ltr">SELECT * FROM bfdemo WHERE id IS
NOT INFINITE;
ID, ID2
&lt; NAN, 100 &gt;
1 row found.
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The constant keywords represent specific <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> values. The comparison keywords correspond to properties of a value and are not specific to any type, although they can only evaluate to <code dir="ltr">TRUE</code> for <code dir="ltr">BINARY_FLOAT</code> or <code dir="ltr">BINARY_DOUBLE</code> types or types that can be converted to <code dir="ltr">BINARY_FLOAT</code> or <code dir="ltr">BINARY_DOUBLE</code>.</div>
<p>The following rules apply to comparisons with <code dir="ltr">Inf</code> and <code dir="ltr">NaN</code>:</p>
<ul>
<li>
<p>Comparison between <code dir="ltr">Inf</code> (or <code dir="ltr">-Inf</code>) and a finite value are as expected. For example, 5 &gt; <code dir="ltr">-Inf</code>.</p>
</li>
<li>
<p><code dir="ltr">(Inf = Inf)</code> and <code dir="ltr">(Inf &gt; -Inf)</code> both evaluate to <code dir="ltr">TRUE</code>.</p>
</li>
<li>
<p><code dir="ltr">(NaN = NaN)</code> evaluates to <code dir="ltr">TRUE</code>.</p>
</li>
</ul>
<p>In reference to collating sequences:</p>
<ul>
<li>
<p><code dir="ltr">-Inf</code> sorts lower than any other value.</p>
</li>
<li>
<p><code dir="ltr">Inf</code> sorts lower than <code dir="ltr">NaN</code> and <code dir="ltr">NULL</code> and higher than any other value.</p>
</li>
<li>
<p><code dir="ltr">NaN</code> sorts higher than <code dir="ltr">Inf</code>.</p>
</li>
<li>
<p><code dir="ltr">NULL</code> sorts higher than <code dir="ltr">NaN</code>. <code dir="ltr">NULL</code> is always the largest value in any collating sequence.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="TTSQL178" class="sect2"><a id="sthref181"></a>
<h3 class="sect2">Expressions involving Inf and NaN</h3>
<ul>
<li>
<p>Expressions containing floating-point values may generate <code dir="ltr">Inf</code>, <code dir="ltr">-Inf</code>, or <code dir="ltr">NaN</code>. This can occur either because the expression generated overflow or exceptional conditions or because one or more of the values in the expression was <code dir="ltr">Inf</code>, <code dir="ltr">-Inf</code>, or <code dir="ltr">NaN</code>. <code dir="ltr">Inf</code> and <code dir="ltr">NaN</code> are generated in overflow or division-by-zero conditions.</p>
</li>
<li>
<p><code dir="ltr">Inf</code>, <code dir="ltr">-Inf</code>, and <code dir="ltr">NaN</code> values are not ignored in aggregate functions. <code dir="ltr">NULL</code> values are. If you want to exclude <code dir="ltr">Inf</code> and <code dir="ltr">NaN</code> from aggregates, or from any <code dir="ltr">SELECT</code> result, use both the <code dir="ltr">IS NOT NAN</code> and <code dir="ltr">IS NOT INFINITE</code> predicates.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i987705"></a>
<div id="TTSQL179" class="sect1">
<h2 class="sect1"><a id="sthref182"></a><a id="sthref183"></a><a id="sthref184"></a><a id="sthref185"></a>Overflow and truncation</h2>
<p>Some operations can result in data overflow or truncation. Overflow results in an error and can generate <code dir="ltr">Inf</code>. Truncation results in loss of least significant data.</p>
<p>Exact values are truncated only when they are stored in the database by an <code dir="ltr"><a href="state.htm#g1513888">INSERT</a></code> or <code dir="ltr"><a href="state.htm#i994046">UPDATE</a></code> statement, and if the target column has smaller scale than the value. TimesTen returns a warning when such truncation occurs. If the value does not fit because of overflow, TimesTen returns the special value <code dir="ltr">Inf</code> and does not insert the specified value.</p>
<p>TimesTen may truncate approximate values during computations, when values are inserted into the database, or when database values are updated. TimesTen returns an error only upon <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code>. When overflow with approximate values occurs, TimesTen returns the special value <code dir="ltr">Inf</code>.</p>
<p>There are several circumstances that can cause overflow:</p>
<ul>
<li>
<p>D<a id="sthref186"></a>uring arithmetic operations, overflow can occur when multiplication results in a number larger than the maximum value allowed in its type. Arithmetic operations are defined in <a href="express.htm#i996218">Chapter 3, &#34;Expressions.&#34;</a></p>
</li>
<li>
<p>When <a id="sthref187"></a>aggregate functions are used, overflow can occur when the sum of several numbers exceeds the maximum allowable value of the result type. Aggregate functions are defined in <a href="express.htm#i996218">Chapter 3, &#34;Expressions.&#34;</a></p>
</li>
<li>
<p>During type conversion, overflow can also occur when, for example, a <code dir="ltr">TT_INTEGER</code> value is converted to a <code dir="ltr">TT_SMALLINT</code> value.</p>
</li>
</ul>
<p>Truncation can cause an error or warning for alphanumeric or numeric data types, as follows.</p>
<ul>
<li>
<p>For character<a id="sthref188"></a> data, an error occurs if a string is truncated because it is too long for its target type. For <code dir="ltr">NCHAR</code> and <code dir="ltr">NVARCHAR2</code> types, truncation always occurs on Unicode character boundaries. In the <code dir="ltr">NCHAR</code> data types, a single-byte value (half a Unicode character) has no meaning and is not possible.</p>
</li>
<li>
<p>For numeric <a id="sthref189"></a>data, a warning occurs when any trailing nonzero digit is dropped from the fractional part of a numeric value.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i987763"></a>
<div id="TTSQL180" class="sect1">
<h2 class="sect1">Und<a id="sthref190"></a><a id="sthref191"></a>erflow</h2>
<p>When an approximate numeric value is too close to zero to be represented by the hardware, TimesTen underflows to zero and returns a truncation warning.</p>
</div>
<!-- class="sect1" -->
<a id="BABBBFDC"></a>
<div id="TTSQL181" class="sect1">
<h2 class="sect1">Re<a id="sthref192"></a><a id="sthref193"></a><a id="sthref194"></a><a id="sthref195"></a>plication limits</h2>
<p>TimesTen places the following limits on the size of data types in a database that is being replicated:</p>
<ul>
<li>
<p><code dir="ltr">VARCHAR2</code> and <code dir="ltr">VARBINARY</code> columns cannot exceed 4 MB. For character-length semantics, the limit is 4 MB. The database character set determines how many characters can be represented by 4 MB. The minimum number of characters is 1,000,000/ 4 = 250,000 characters.</p>
</li>
<li>
<p><code dir="ltr">NVARCHAR2</code> columns cannot exceed 500,000 characters (4 MB).</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1033906"></a>
<div id="TTSQL182" class="sect1">
<h2 class="sect1"><a id="sthref196"></a><a id="sthref197"></a>TimesTen type mode (backward compatibility)</h2>
<p>TimesTen supports a data type backward compatibility mode called TimesTen type mode. This is specified using the data store creation attribute <code dir="ltr">TypeMode</code>, where <code dir="ltr">TypeMode=1</code> indicates TimesTen mode. Type mode determines the default data type. For example, <code dir="ltr">DATE</code> in TimesTen type mode defaults to <code dir="ltr">TT_DATE</code>; <code dir="ltr">DATE</code> in Oracle type mode defaults to <code dir="ltr">ORA_DATE</code>.</p>
<p>For more information on type modes, see <a class="olink TTREF134" href="../TTREF/attribute.htm#TTREF134">&#34;TypeMode&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>. For information on data type usage in TimesTen type mode, refer to <span class="italic">Oracle TimesTen In-Memory Database API and SQL Reference Guide</span>, Release 6.0.3.</p>
<div id="TTSQL183" class="sect2"><a id="sthref198"></a>
<h3 class="sect2">Da<a id="sthref199"></a>ta types supported in TimesTen type mode</h3>
<div id="TTSQL184" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref200"></a><a id="sthref201"></a>Table 1-9 Data types supported in TimesTen type mode</p>
<table class="cellalignment6330" title="Data types supported in TimesTen type mode" summary="This table contains descriptions of data types supported in TimesTen typde mode." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t21">Data type</th>
<th class="cellalignment6331" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t21" headers="r1c1-t21">
<p><a id="sthref202"></a><a id="sthref203"></a><code dir="ltr">BIGINT</code></p>
</td>
<td class="cellalignment6332" headers="r2c1-t21 r1c2-t21">
<p>A signed eight-byte integer in the range -9,223,372,036,854,775,808 (-2<sup>63</sup>) to 9,223,372,036,854,775,807 (2<sup>63</sup>-1)</p>
<p>Alternatively, specify <code dir="ltr">TT_BIGINT</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t21" headers="r1c1-t21">
<p><a id="sthref204"></a><code dir="ltr">BINARY(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r3c1-t21 r1c2-t21">
<p>Fixed-length binary value of <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes. Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> range from 1 to 8300</p>
<p><code dir="ltr">BINARY</code> data is padded to the maximum column size with trailing zeroes.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t21" headers="r1c1-t21">
<p><a id="sthref205"></a><a id="sthref206"></a><a id="sthref207"></a><code dir="ltr">BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment6332" headers="r4c1-t21 r1c2-t21">
<p>A 64-bit floating-point number</p>
<p><code dir="ltr">BINARY_DOUBLE</code> is a double-precision native floating point number. Supports <code dir="ltr">+Inf</code>, <code dir="ltr">-Inf</code>, and <code dir="ltr">NaN</code> values. <code dir="ltr">BINARY_DOUBLE</code> is an approximate numeric value consisting of an exponent and mantissa. You can use exponential or E-notation. <code dir="ltr">BINARY_DOUBLE</code> has binary precision 53.</p>
<p>Minimum positive finite value: 2.22507485850720E-308</p>
<p>Maximum positive finite value: 1.79769313486231E+308</p>
<p>Alternatively, specify <code dir="ltr">DOUBLE [PRECISION]</code> or <code dir="ltr">FLOAT[(53)]</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t21" headers="r1c1-t21">
<p><a id="sthref208"></a><a id="sthref209"></a><a id="sthref210"></a><code dir="ltr">BINARY_FLOAT</code></p>
</td>
<td class="cellalignment6332" headers="r5c1-t21 r1c2-t21">
<p>A 32-bit floating-point number</p>
<p><code dir="ltr">BINARY_FLOAT</code> is a single-precision native floating-point type. Supports <code dir="ltr">+Inf</code>, <code dir="ltr">-Inf</code>, and <code dir="ltr">NaN</code> values. <code dir="ltr">BINARY_FLOAT</code> is an approximate numeric value consisting of an exponent and mantissa. You can use exponential or E-notation. <code dir="ltr">BINARY_FLOAT</code> has binary precision 24.</p>
<p>Minimum positive finite value: 1.17549E-38F</p>
<p>Maximum positive finite value: 3.40282E+38F</p>
<p>Alternatively, specify <code dir="ltr">REAL</code> or <code dir="ltr">FLOAT(24)</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t21" headers="r1c1-t21">
<p><a id="sthref211"></a><a id="sthref212"></a><a id="sthref213"></a><code dir="ltr">CHAR[ACTER][(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code> <code dir="ltr">[BYTE|CHAR])]</code></p>
</td>
<td class="cellalignment6332" headers="r6c1-t21 r1c2-t21">
<p>Fixed-length character string of length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes or characters</p>
<p>Default is one byte.</p>
<p><code dir="ltr">BYTE</code> indicates that the column has byte-length semantics. Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes range from 1 to 8300.</p>
<p><code dir="ltr">CHAR</code> indicates that the column has character-length semantics. The minimum <code dir="ltr">CHAR</code> length is one character. The maximum <code dir="ltr">CHAR</code> length depends on how many characters fit in 8300 bytes. This is determined by the database character set in use. For character set <code dir="ltr">AL32UTF8</code>, up to four bytes per character may be needed, so the <code dir="ltr">CHAR</code> length limit ranges from 2075 to 8300 depending on the character set.</p>
<p>A zero-length string is a valid non-null value. The string value &#34;&#34; is an empty, zero-length string, but not a null value. However, in PL/SQL, a zero-length string is always considered to be <code dir="ltr">NULL</code>. Therefore, when you use PL/SQL, any empty string parameter in SQL is converted to <code dir="ltr">NULL</code> by PL/SQL before the value is passed to the TimesTen database.</p>
<p><code dir="ltr">CHAR</code> data is padded to the maximum column size with trailing blanks. Blank-padded comparison semantics are used. For information on blank-padded and nonpadded semantics, see <a href="#i1035598">&#34;Blank-padded and nonpadded comparison semantics&#34;</a>.</p>
<p>Alternatively, specify <code dir="ltr">TT_CHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code> <code dir="ltr">[BYTE|CHAR])]</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r7c1-t21" headers="r1c1-t21">
<p><a id="sthref214"></a><a id="sthref215"></a><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment6332" headers="r7c1-t21 r1c2-t21">
<p>Date information: century, year, month, and day</p>
<p>The format is <code dir="ltr">YYYY-MM-DD</code>, where <code dir="ltr">MM</code> is expressed as an integer. For example: 2006-10-28.</p>
<p>Storage size is four bytes.</p>
<p>Valid dates are between 1753-01-01 (January 1,1753) and 9999-12-31 (December 31, 9999).</p>
<p>Alternatively, specify <code dir="ltr">TT_DATE</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r8c1-t21" headers="r1c1-t21">
<p><code dir="ltr">D<a id="sthref216"></a><a id="sthref217"></a>EC[IMAL][(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code> or</p>
<p><code dir="ltr">NUMERIC[(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code></p>
</td>
<td class="cellalignment6332" headers="r8c1-t21 r1c2-t21">
<p>An exact numeric value with a fixed maximum precision (total number of digits) and scale (number of digits to the right of the decimal point)</p>
<p>The value of precision <code dir="ltr"><span class="codeinlineitalic">p</span></code> must be between 1 and 40. The value of scale <code dir="ltr"><span class="codeinlineitalic">s</span></code> must be between 0 and <code dir="ltr"><span class="codeinlineitalic">p</span></code>. The default precision is 40 and the default scale is 0.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r9c1-t21" headers="r1c1-t21">
<p><a id="sthref218"></a><code dir="ltr">INTERVAL [+/-]</code> <code dir="ltr"><span class="codeinlineitalic">IntervalQualifier</span></code></p>
</td>
<td class="cellalignment6332" headers="r9c1-t21 r1c2-t21">
<p>Interval</p>
<p>TimesTen partially supports interval types, expressed with <code dir="ltr">INTERVAL</code> and an <code dir="ltr"><span class="codeinlineitalic">IntervalQualifier</span></code>. An <code dir="ltr"><span class="codeinlineitalic">IntervalQualifier</span></code> can specify only a single field type with no precision. The default leading precision is eight digits for all interval types. The single field type can be one of: <code dir="ltr">YEAR</code>, <code dir="ltr">MONTH</code>, <code dir="ltr">DAY</code>, <code dir="ltr">HOUR</code>, <code dir="ltr">MINUTE</code>, or <code dir="ltr">SECOND</code>. Currently, interval types can be specified only with a constant.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r10c1-t21" headers="r1c1-t21">
<p><a id="sthref219"></a><a id="sthref220"></a><code dir="ltr">NCHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)]</code></p>
</td>
<td class="cellalignment6332" headers="r10c1-t21 r1c2-t21">
<p>Fixed-length string of <code dir="ltr"><span class="codeinlineitalic">n</span></code> two-byte Unicode characters</p>
<p>The number of bytes required is 2*<code dir="ltr"><span class="codeinlineitalic">n</span></code> where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is the specified number of characters. <code dir="ltr">NCHAR</code> character limits are half the byte limits, so the maximum size is 4150. Default and minimum bytes of storage is 2<code dir="ltr"><span class="codeinlineitalic">n</span></code> (2).</p>
<p>A zero-length string is a valid non-NULL value. The string value &#34;&#34; is an empty, zero-length string, but not a NULL value. However, in PL/SQL, a zero-length string is always considered to be <code dir="ltr">NULL</code>. Therefore, when you use PL/SQL, any empty string parameter in SQL is converted to <code dir="ltr">NULL</code> by PL/SQL before the value is passed to the TimesTen database.</p>
<p><code dir="ltr">NCHAR</code> data is padded to the maximum column size with <code dir="ltr">U+0020 SPACE</code>. Blank-padded comparison semantics are used. For information on blank-padded and nonpadded semantics, see <a href="#i1035598">&#34;Blank-padded and nonpadded comparison semantics&#34;</a>.</p>
<p>Alternatively, specify <code dir="ltr">TT_NCHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)]</code>.</p>
<p><code dir="ltr">NATIONAL CHARACTER</code> and <code dir="ltr">NATIONAL CHAR</code> are synonyms for <code dir="ltr">NCHAR</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r11c1-t21" headers="r1c1-t21">
<p><a id="sthref221"></a><a id="sthref222"></a><code dir="ltr">SMALLINT</code></p>
</td>
<td class="cellalignment6332" headers="r11c1-t21 r1c2-t21">
<p>A native signed 16-bit integer in the range -32,768 (-2<sup>15</sup>) to 32,767 (2<sup>15</sup>-1)</p>
<p>Alternatively, specify <code dir="ltr">TT_SMALLINT</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r12c1-t21" headers="r1c1-t21">
<p><a id="sthref223"></a><code dir="ltr">TIME</code></p>
</td>
<td class="cellalignment6332" headers="r12c1-t21 r1c2-t21">
<p>A time of day between 00:00:00 (midnight) and 23:59:59 (11:59:59 pm), inclusive</p>
<p>The format is: <code dir="ltr"><span class="codeinlineitalic">HH:MI:SS</span></code>. Storage size is eight bytes.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r13c1-t21" headers="r1c1-t21">
<p><a id="sthref224"></a><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment6332" headers="r13c1-t21 r1c2-t21">
<p>A date and time between 1753-01-01 00:00:00 (midnight on January 1, 1753) and 9999-12-31 23:59:59 pm (11:59:59 pm on December 31, 9999), inclusive</p>
<p>Any values for the fraction not specified in full microseconds result in a &#34;<code dir="ltr">Data Truncated</code>&#34; error. The format is <code dir="ltr">YYYY-MM-DD HH:MI:SS [.FFFFFFFFF]</code>.</p>
<p>Storage size is eight bytes.</p>
<p>Alternatively, specify <code dir="ltr">TT_TIMESTAMP</code> or <code dir="ltr">[TT_]TIMESTAMP(6)</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r14c1-t21" headers="r1c1-t21">
<p><a id="sthref225"></a><a id="sthref226"></a><code dir="ltr">TINYINT</code></p>
</td>
<td class="cellalignment6332" headers="r14c1-t21 r1c2-t21">
<p>Unsigned integer ranging from 0 to 255 (2<sup>8</sup>-1)</p>
<p>Since <code dir="ltr">TINYINT</code> is unsigned, the negation of a <code dir="ltr">TINYINT</code> is <code dir="ltr">SMALLINT</code>.</p>
<p>Alternatively, specify <code dir="ltr">TT_TINYINT</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r15c1-t21" headers="r1c1-t21">
<p><code dir="ltr"><a id="sthref227"></a><a id="sthref228"></a>INT[EGER]</code></p>
</td>
<td class="cellalignment6332" headers="r15c1-t21 r1c2-t21">
<p>A signed integer in the range -2,147,483,648 (-2<sup>31</sup>) to 2,147,483,647 (2<sup>31</sup>-1)</p>
<p>Alternatively, specify <code dir="ltr">TT_INTEGER</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r16c1-t21" headers="r1c1-t21">
<p><a id="sthref229"></a><a id="sthref230"></a><code dir="ltr">NVARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r16c1-t21 r1c2-t21">
<p>Variable-length string of <code dir="ltr"><span class="codeinlineitalic">n</span></code> two-byte Unicode characters</p>
<p>The number of bytes required is 2*<code dir="ltr"><span class="codeinlineitalic">n</span></code> where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is the specified number of characters. <code dir="ltr">NVARCHAR</code> character limits are half the byte limits so the maximum size is 2,097,152 (2<sup>21</sup>). You must specify <code dir="ltr"><span class="codeinlineitalic">n</span></code>.</p>
<p>A zero-length string is a valid non-NULL value. The string value &#34;&#34; is an empty, zero-length string, but not a NULL value. However, in PL/SQL, a zero-length string is always considered to be <code dir="ltr">NULL</code>. Therefore, when you use PL/SQL, any empty string parameter in SQL is converted to <code dir="ltr">NULL</code> by PL/SQL before the value is passed to the TimesTen database.</p>
<p>Blank-padded comparison semantics are used. For information on blank-padded and nonpadded semantics, see <a href="#i1035598">&#34;Blank-padded and nonpadded comparison semantics&#34;</a>.</p>
<p>Alternatively, specify <code dir="ltr">TT_NVARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code>.</p>
<p><code dir="ltr">NATIONAL CHARACTER VARYING</code>, <code dir="ltr">NATIONAL CHAR VARYING</code>, and <code dir="ltr">NCHAR</code> <code dir="ltr">VARYING</code> are synonyms for <code dir="ltr">NVARCHAR</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r17c1-t21" headers="r1c1-t21">
<p><a id="sthref231"></a><a id="sthref232"></a><code dir="ltr">VARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code></p>
</td>
<td class="cellalignment6332" headers="r17c1-t21 r1c2-t21">
<p>Variable-length character string having maximum length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes or characters. You must specify <code dir="ltr"><span class="codeinlineitalic">n</span></code></p>
<p><code dir="ltr">BYTE</code> indicates that the column has byte-length semantics. Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes range from 1 to 4194304 (2<sup>22</sup>).</p>
<p><code dir="ltr">CHAR</code> indicates that the column has character-length semantics.</p>
<p>A zero-length string is a valid non-NULL value. The string value &#34;&#34; is an empty, zero-length string, but not a NULL value. However, in PL/SQL, a zero-length string is always considered to be <code dir="ltr">NULL</code>. Therefore, when you use PL/SQL, any empty string parameter in SQL is converted to <code dir="ltr">NULL</code> by PL/SQL before the value is passed to the TimesTen database.</p>
<p>Blank-padded comparison semantics are used. For information on blank-padded and nonpadded semantics, see <a href="#i1035598">&#34;Blank-padded and nonpadded comparison semantics&#34;</a>.</p>
<p>Alternatively, specify <code dir="ltr">TT_VARCHAR(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r18c1-t21" headers="r1c1-t21">
<p><a id="sthref233"></a><code dir="ltr">VARBINARY</code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r18c1-t21 r1c2-t21">
<p>Variable-length binary value having maximum length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes</p>
<p>Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> range from 1 to 4194304 (2<sup>22</sup>).</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect2" -->
<div id="TTSQL185" class="sect2"><a id="sthref234"></a>
<h3 class="sect2"><a id="sthref235"></a><a id="sthref236"></a>Oracle data types supported in TimesTen type mode</h3>
<div id="TTSQL186" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref237"></a><a id="sthref238"></a>Table 1-10 Oracle data types supported in TimesTen type mode</p>
<table class="cellalignment6330" title="Oracle data types supported in TimesTen type mode" summary="This table contains descriptions of Oracle data types supported in TimesTen type mode." dir="ltr">
<thead>
<tr class="cellalignment6324">
<th class="cellalignment6331" id="r1c1-t22">Data type</th>
<th class="cellalignment6331" id="r1c2-t22">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r2c1-t22" headers="r1c1-t22">
<p><a id="sthref239"></a><code dir="ltr">NUMBER[(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code> <code dir="ltr">[,</code><code dir="ltr"><span class="codeinlineitalic">s</span></code><code dir="ltr">])]</code></p>
</td>
<td class="cellalignment6332" headers="r2c1-t22 r1c2-t22">
<p>Number having precision and scale</p>
<p>The precision value ranges from 1 to 38 decimal. The scale value ranges from -84 to 127. Both precision and scale are optional.</p>
<p>If you do not specify a precision or a scale, then maximum precision of 38 and flexible scale are assumed.</p>
<p><code dir="ltr">NUMBER</code> supports scale &gt; precision and negative scale.</p>
<p><code dir="ltr">NUMBER</code> stores both zero and positive and negative fixed numbers with absolute values from 1.0 x 10<sup>-130</sup> up to but not including 1.0 x 10<sup>126</sup>. If you specify an arithmetic expression whose value has an absolute value greater than or equal to 1.0 x 10<sup>126</sup>, then TimesTen returns an error.</p>
<p>In TimesTen type mode, the <code dir="ltr">NUMBER</code> data type stores 10E-89 as its smallest (closest to zero) value.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r3c1-t22" headers="r1c1-t22">
<p><a id="sthref240"></a><code dir="ltr">ORA_CHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code> <code dir="ltr">[BYTE|CHAR])]</code></p>
</td>
<td class="cellalignment6332" headers="r3c1-t22 r1c2-t22">
<p>Fixed-length character string of length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes or characters</p>
<p>Default is one byte.</p>
<p><code dir="ltr">BYTE</code> indicates that the column has byte-length semantics. Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes range from 1 to 8300.</p>
<p><code dir="ltr">CHAR</code> indicates that the column has character-length semantics. The minimum <code dir="ltr">CHAR</code> length is one character. The maximum <code dir="ltr">CHAR</code> length depends on how many characters fit in 8300 bytes. This is determined by the database character set in use. For character set <code dir="ltr">AL32UTF8</code>, up to four bytes per character may be needed, so the <code dir="ltr">CHAR</code> length limit ranges from 2075 to 8300 depending on the character set.</p>
<p>A zero-length string is a valid non-NULL value. The string value &#34;&#34; is an empty, zero-length string, but not a NULL value. However, in PL/SQL, a zero-length string is always considered to be <code dir="ltr">NULL</code>. Therefore, when you use PL/SQL, any empty string parameter in SQL is converted to <code dir="ltr">NULL</code> by PL/SQL before the value is passed to the TimesTen database.</p>
<p><code dir="ltr">ORA_CHAR</code> data is padded to the maximum column size with trailing blanks. Blank-padded comparison semantics are used. For information on blank-padded and nonpadded semantics, see <a href="#i1035598">&#34;Blank-padded and nonpadded comparison semantics&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r4c1-t22" headers="r1c1-t22">
<p><a id="sthref241"></a><code dir="ltr">ORA_DATE</code></p>
</td>
<td class="cellalignment6332" headers="r4c1-t22 r1c2-t22">
<p>Date and time information: century, year, month, date, hour, minute, and second</p>
<p>Format is <code dir="ltr">YYYY-MM-DD HHMISS</code>.</p>
<p>Valid date range is from January 1, 4712 BC to December 31, 9999 AD.</p>
<p>The storage size is seven bytes. There are no fractional seconds.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r5c1-t22" headers="r1c1-t22">
<p><a id="sthref242"></a><code dir="ltr">ORA_NCHAR[(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)]</code></p>
</td>
<td class="cellalignment6332" headers="r5c1-t22 r1c2-t22">
<p>Fixed-length string of length <code dir="ltr"><span class="codeinlineitalic">n</span></code> two-byte Unicode characters</p>
<p>The number of bytes required is 2*<code dir="ltr"><span class="codeinlineitalic">n</span></code> where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is the specified number of characters. <code dir="ltr">NCHAR</code> character limits are half the byte limits so the maximum size is 4150. Default and minimum bytes of storage is 2<code dir="ltr"><span class="codeinlineitalic">n</span></code> (2).</p>
<p>A zero-length string is a valid non-NULL value. The string value &#34;&#34; is an empty, zero-length string, but not a NULL value. However, in PL/SQL, a zero-length string is always considered to be <code dir="ltr">NULL</code>. Therefore, when you use PL/SQL, any empty string parameter in SQL is converted to <code dir="ltr">NULL</code> by PL/SQL before the value is passed to the TimesTen database.</p>
<p><code dir="ltr">ORA_NCHAR</code> data is padded to the maximum column size with <code dir="ltr">U+0020 SPACE</code>. Blank-padded comparison semantics are used. For information on blank-padded and nonpadded semantics, see <a href="#i1035598">&#34;Blank-padded and nonpadded comparison semantics&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r6c1-t22" headers="r1c1-t22">
<p><a id="sthref243"></a><code dir="ltr">ORA_NVARCHAR2</code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment6332" headers="r6c1-t22 r1c2-t22">
<p>Variable-length string of <code dir="ltr"><span class="codeinlineitalic">n</span></code> two-byte Unicode characters</p>
<p>The number of bytes required is 2*<code dir="ltr"><span class="codeinlineitalic">n</span></code> where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is the specified number of characters. <code dir="ltr">ORA_NVARCHAR2</code> character limits are half the byte limits so the maximum size is 2,097,152 (2<sup>21</sup>). You must specify <code dir="ltr"><span class="codeinlineitalic">n</span></code>.</p>
<p>A zero-length string is a valid non-NULL value. The string value &#34;&#34; is an empty, zero-length string, but not a NULL value. However, in PL/SQL, a zero-length string is always considered to be <code dir="ltr">NULL</code>. Therefore, when you use PL/SQL, any empty string parameter in SQL is converted to <code dir="ltr">NULL</code> by PL/SQL before the value is passed to the TimesTen database.</p>
<p>Nonpadded comparison semantics are used.</p>
<p>For information on blank-padded and nonpadded semantics, see <a href="#i1035598">&#34;Blank-padded and nonpadded comparison semantics&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r7c1-t22" headers="r1c1-t22">
<p><a id="sthref244"></a><code dir="ltr">ORA_VARCHAR2(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">[BYTE|CHAR])</code></p>
</td>
<td class="cellalignment6332" headers="r7c1-t22 r1c2-t22">
<p>Variable-length character string having maximum length <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes or characters</p>
<p><code dir="ltr">BYTE</code> indicates that the column has byte-length semantics. Legal values for <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes range from 1 to 4194304 (2<sup>22</sup>). You must specify <code dir="ltr"><span class="codeinlineitalic">n</span></code>.</p>
<p><code dir="ltr">CHAR</code> indicates that the column has character-length semantics.</p>
<p>A zero-length string is a valid non-NULL value. The string value &#34;&#34; is an empty, zero-length string, but not a NULL value. However, in PL/SQL, a zero-length string is always considered to be <code dir="ltr">NULL</code>. Therefore, when you use PL/SQL, any empty string parameter in SQL is converted to <code dir="ltr">NULL</code> by PL/SQL before the value is passed to the TimesTen database.</p>
<p>Nonpadded comparison semantics are used. For information on blank-padded and nonpadded semantics, see <a href="#i1035598">&#34;Blank-padded and nonpadded comparison semantics&#34;</a>.</p>
</td>
</tr>
<tr class="cellalignment6324">
<td class="cellalignment6332" id="r8c1-t22" headers="r1c1-t22">
<p><a id="sthref245"></a><code dir="ltr">ORA_TIMESTAMP</code></p>
<p><code dir="ltr">[(</code><code dir="ltr"><span class="codeinlineitalic">fractional_seconds_precision</span></code><code dir="ltr">)]</code></p>
</td>
<td class="cellalignment6332" headers="r8c1-t22 r1c2-t22">
<p>Year, month, and day values of the date data type plus hour, minute, and second values of time</p>
<p><code dir="ltr"><span class="codeinlineitalic">Fractional_seconds_precision</span></code> is the number of digits in the fractional part of the seconds field. Valid date range is from January 1, 4712 BC to December 31, 9999 AD.</p>
<p>The fractional seconds precision range is 0 to 9. The default is 6. Format is:</p>
<p><code dir="ltr">YYYY-MM-DD HH:MI:SS [.FFFFFFFFF]</code></p>
<p>Storage size is 12 bytes.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment6323">
<tr>
<td class="cellalignment6332">
<table class="cellalignment6328">
<tr>
<td class="cellalignment6327"><a href="whatsnew.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment6327"><a href="names.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2011, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment6334">
<table class="cellalignment6326">
<tr>
<td class="cellalignment6327"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment6327"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment6327"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment6327"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment6327"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment6327"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>