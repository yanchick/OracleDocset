<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77855"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Datatypes%20and%20Host%20Variables"></a><title>Datatypes and Host Variables</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:14Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pco03dbc.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pco05sql.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/27</span> <!-- End Header -->
<div id="LNPCB004" class="chapter"><a id="g61130"></a> <a id="i18280"></a>
<h1 class="chapter"><span class="secnum">4</span> Datatypes and Host Variables</h1>
<p>This chapter provides the basic information you need to write a Pro*COBOL program, including:</p>
<ul>
<li>
<p><a href="#i22898">The Oracle Database Datatypes</a></p>
</li>
<li>
<p><a href="#i27774">Datetime and Interval Datatype Descriptors</a></p>
</li>
<li>
<p><a href="#i13081">Host Variables</a></p>
</li>
<li>
<p><a href="#i18673">Indicator Variables</a></p>
</li>
<li>
<p><a href="#i7848">VARCHAR Variables</a></p>
</li>
<li>
<p><a href="#i13105">Handling Character Data</a></p>
</li>
<li>
<p><a href="#i20247">Universal ROWIDs</a></p>
</li>
<li>
<p><a href="#i20335">Globalization Support</a></p>
</li>
<li>
<p><a href="#i20438">Unicode Support for Pro*COBOL</a></p>
</li>
<li>
<p><a href="#i22939">Datatype Conversion</a></p>
</li>
<li>
<p><a href="#i21911">Explicit Control Over DATE String Format</a></p>
</li>
<li>
<p><a href="#i21973">Datatype Equivalencing</a></p>
</li>
<li>
<p><a href="#CHDDBGHB">Platform Endianness Support</a></p>
</li>
<li>
<p><a href="#i22676">Sample Program 4: Datatype Equivalencing</a></p>
</li>
</ul>
<a id="i22898"></a>
<div id="LNPCB238" class="sect1">
<h2 class="sect1">The Oracle Database Datatypes</h2>
<p>Oracle Database recognizes two kinds of datatypes: <span class="italic">internal</span> and <span class="italic">external</span>. Internal datatypes specify how Oracle Database stores data in database columns.</p>
<p>For complete descriptions of the Oracle internal (also called <span class="italic">built-in</span>) datatypes, see <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference.</span></a></p>
<p>Oracle Database also uses internal datatypes to represent database pseudocolumns. An external datatype specifies how data is stored in a host variable.</p>
<a id="i23006"></a>
<div id="LNPCB239" class="sect2">
<h3 class="sect2">Internal Datatypes</h3>
<p><a href="#g46835">Table 4-1</a> summarizes the information about each Oracle built-in datatype.</p>
<div id="LNPCB240" class="tblformal">
<p class="titleintable"><a id="sthref380"></a><a id="g46835"></a>Table 4-1 Summary of Oracle Built-In Datatypes</p>
<table class="cellalignment4971" title="Summary of Oracle Built-In Datatypes " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t2">Datatype</th>
<th class="cellalignment4972" id="r1c2-t2">Description</th>
<th class="cellalignment4972" id="r1c3-t2">Column Length and Default</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t2" headers="r1c1-t2">
<p>CHAR (size)</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c2-t2">
<p>Fixed-length character data of length <span class="italic">size</span> in characters or bytes, depending on the national character set</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c3-t2">
<p>Fixed for every row in the table (with trailing blanks.) Column size is the number of characters for a fixed-width national character set or the number of bytes required to store one character, with an upper limit of 2000 bytes for each row. Default size is 1 character or 1 byte for each row, depending on the national character set. Consider the character set (one-byte or multibyte) before setting <span class="italic">size.</span></p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t2" headers="r1c1-t2">
<p>VARCHAR2 (size)</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c2-t2">
<p>Fixed-length character data of length <span class="italic">size</span> in characters or bytes, depending on the national character set. A maximum size must be specified.</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c3-t2">
<p>Variable for each row. Column size is the number of characters for a fixed-width national character set or the number of bytes for a varying-width national character set. Maximum size is determined by the number of bytes required to store one character, with an upper limit of 4000 bytes for each row. Default size is 1 character or 1 byte, depending on the national character set.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t2" headers="r1c1-t2">
<p>NCHAR (size)</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c2-t2">
<p>Fixed-length character data of length <span class="italic">size</span> in characters or bytes, depending on national character set.</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c3-t2">
<p>Fixed for every row in the table (with trailing blanks). Column <span class="italic">size</span> is the number of bytes for a national character set or the number of bytes for a varying-width national character set. Maximum <span class="italic">size</span> is determined by the number of bytes required to store one character, with an upper limit of 2000 bytes for each row. Default is 1 character or 1 byte, depending on the character set.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t2" headers="r1c1-t2">
<p>NVARCHAR2 (size)</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c2-t2">
<p>Variable-length character data of length <span class="italic">size</span> in characters or bytes, depending on national character set. A maximum <span class="italic">size</span> must be specified.</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c3-t2">
<p>Variable for each row. Column <span class="italic">size</span> is the number of bytes for a national character set. Maximum <span class="italic">size</span> is determined by the number of bytes required to store one character, with an upper limit of 4000 bytes for each row. Default is 1 character or 1 byte, depending on the character set.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t2" headers="r1c1-t2">
<p>CLOB</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c2-t2">
<p>Single-byte character data</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c3-t2">
<p>Up to 2^32 - 1&nbsp;bytes, or 4 gigabytes.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t2" headers="r1c1-t2">
<p>NCLOB</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c2-t2">
<p>Single-byte or fixed-length multibyte national character set (<code>NCHAR</code>) data</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c3-t2">
<p>Up to 2^32 - 1&nbsp;bytes, or 4 gigabytes.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t2" headers="r1c1-t2">
<p>LONG</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c2-t2">
<p>Variable-length character data</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c3-t2">
<p>Variable for each row in the table, up to 2^31 - 1&nbsp;bytes, or 2 gigabytes, for each row. Provided for backward compatibility.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t2" headers="r1c1-t2">
<p>NUMBER(p,s)</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c2-t2">
<p>Variable-length numeric data.: Maximum precision <span class="italic">p</span>, or scale <span class="italic">s</span> is 38, or both.</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c3-t2">
<p>Variable for each row. The maximum space required for a given column is 21 bytes for each row.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t2" headers="r1c1-t2">
<p>DATE</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c2-t2">
<p>Fixed-length date and time data, ranging from Jan. 1, 4712 B.C.E. to Dec. 31, 4712 C.E.</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c3-t2">
<p>Fixed at 7 bytes for each row in the table. Default format is a string (such as <code>DD</code>-<code>MON</code>-<code>YY</code>) specified by <code>NLS_DATE_FORMAT</code> parameter.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t2" headers="r1c1-t2">
<p>BLOB</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c2-t2">
<p>Unstructured binary data</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c3-t2">
<p>Up to 2^32 - 1&nbsp;bytes, or 4 gigabytes.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t2" headers="r1c1-t2">
<p>BFILE</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c2-t2">
<p>Binary data stored in an external file</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c3-t2">
<p>Up to 2^32 - 1&nbsp;bytes, or 4 gigabytes.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t2" headers="r1c1-t2">
<p>RAW (size)</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c2-t2">
<p>Variable-length raw binary data</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c3-t2">
<p>Variable for each row in the table, up to 2000 bytes for each row. A maximum <span class="italic">size</span> must be specified. Provided for backward compatibility.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t2" headers="r1c1-t2">
<p>LONG RAW</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c2-t2">
<p>Variable-length raw binary data</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c3-t2">
<p>Variable for each row in the table, up to 2^31 - 1&nbsp;bytes, or 2 gigabytes, for each row. Provided for backward compatibility.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t2" headers="r1c1-t2">
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c2-t2">
<p>Binary data representing row addresses</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c3-t2">
<p>Fixed at 10 bytes (extended <code>ROWID</code>) or 6 bytes (restricted <code>ROWID</code>) for each row in the table.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="i20902"></a>
<div id="LNPCB241" class="sect2">
<h3 class="sect2">External Datatypes</h3>
<p>The external datatypes include all the internal datatypes plus several datatypes found in other supported host languages. Use the datatype names in datatype equivalencing, and the datatype codes in dynamic SQL Method 4.<a id="sthref381"></a> The following table lists external datatypes.</p>
<div id="LNPCB242" class="tblformal">
<p class="titleintable"><a id="sthref382"></a><a id="sthref383"></a>Table 4-2 External Datatypes</p>
<table class="cellalignment4971" title="External Datatypes " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t3">Name</th>
<th class="cellalignment4972" id="r1c2-t3">Code</th>
<th class="cellalignment4972" id="r1c3-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t3" headers="r1c1-t3">
<p>CHAR</p>
</td>
<td class="cellalignment4973" headers="r2c1-t3 r1c2-t3">
<p>1</p>
<p>96</p>
</td>
<td class="cellalignment4973" headers="r2c1-t3 r1c3-t3">
<p>&lt;= 65535-byte, variable-length character string ()</p>
<p>&lt;= 65535-byte, fixed-length character string ()</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t3" headers="r1c1-t3">
<p>CHARF</p>
</td>
<td class="cellalignment4973" headers="r3c1-t3 r1c2-t3">
<p>96</p>
</td>
<td class="cellalignment4973" headers="r3c1-t3 r1c3-t3">
<p>&lt;= 65535-byte, fixed-length character string</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t3" headers="r1c1-t3">
<p>CHARZ</p>
</td>
<td class="cellalignment4973" headers="r4c1-t3 r1c2-t3">
<p>97</p>
</td>
<td class="cellalignment4973" headers="r4c1-t3 r1c3-t3">
<p>&lt;= 65535-byte, fixed-length, null-terminated string ()</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t3" headers="r1c1-t3">
<p>DATE</p>
</td>
<td class="cellalignment4973" headers="r5c1-t3 r1c2-t3">
<p>12</p>
</td>
<td class="cellalignment4973" headers="r5c1-t3 r1c3-t3">
<p>7-byte, fixed-length date/time value</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t3" headers="r1c1-t3">
<p>DECIMAL</p>
</td>
<td class="cellalignment4973" headers="r6c1-t3 r1c2-t3">
<p>7</p>
</td>
<td class="cellalignment4973" headers="r6c1-t3 r1c3-t3">
<p>COBOL packed decimal</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t3" headers="r1c1-t3">
<p>DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r7c1-t3 r1c2-t3">
<p>91</p>
</td>
<td class="cellalignment4973" headers="r7c1-t3 r1c3-t3">
<p>COBOL numeric character string with leading sign</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t3" headers="r1c1-t3">
<p>DISPLAY TRAILING</p>
</td>
<td class="cellalignment4973" headers="r8c1-t3 r1c2-t3">
<p>152</p>
</td>
<td class="cellalignment4973" headers="r8c1-t3 r1c3-t3">
<p>COBOL numeric with trailing sign</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t3" headers="r1c1-t3">
<p>FLOAT</p>
</td>
<td class="cellalignment4973" headers="r9c1-t3 r1c2-t3">
<p>4</p>
</td>
<td class="cellalignment4973" headers="r9c1-t3 r1c3-t3">
<p>4-byte or 8-byte floating-point number</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t3" headers="r1c1-t3">
<p>INTEGER</p>
</td>
<td class="cellalignment4973" headers="r10c1-t3 r1c2-t3">
<p>3</p>
</td>
<td class="cellalignment4973" headers="r10c1-t3 r1c3-t3">
<p>2-byte, 4-byte, or 8-byte signed integer.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t3" headers="r1c1-t3">
<p>LONG</p>
</td>
<td class="cellalignment4973" headers="r11c1-t3 r1c2-t3">
<p>8</p>
</td>
<td class="cellalignment4973" headers="r11c1-t3 r1c3-t3">
<p>&lt;= 2147483647-byte, fixed-length string</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t3" headers="r1c1-t3">
<p>LONG RAW</p>
</td>
<td class="cellalignment4973" headers="r12c1-t3 r1c2-t3">
<p>24</p>
</td>
<td class="cellalignment4973" headers="r12c1-t3 r1c3-t3">
<p>&lt;= 217483647-byte, fixed-length binary data</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t3" headers="r1c1-t3">
<p>LONG VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r13c1-t3 r1c2-t3">
<p>94</p>
</td>
<td class="cellalignment4973" headers="r13c1-t3 r1c3-t3">
<p>&lt;= 217483643-byte, variable-length string</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t3" headers="r1c1-t3">
<p>LONG VARRAW</p>
</td>
<td class="cellalignment4973" headers="r14c1-t3 r1c2-t3">
<p>95</p>
</td>
<td class="cellalignment4973" headers="r14c1-t3 r1c3-t3">
<p>&lt;= 217483643-byte, variable-length binary data</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t3" headers="r1c1-t3">
<p>NUMBER</p>
</td>
<td class="cellalignment4973" headers="r15c1-t3 r1c2-t3">
<p>2</p>
</td>
<td class="cellalignment4973" headers="r15c1-t3 r1c3-t3">
<p>Internal Oracle Format Number represented in binary coded decimal format.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r16c1-t3" headers="r1c1-t3">
<p>OVERPUNCH LEADING</p>
</td>
<td class="cellalignment4973" headers="r16c1-t3 r1c2-t3">
<p>172</p>
</td>
<td class="cellalignment4973" headers="r16c1-t3 r1c3-t3">
<p>COBOL numeric character string with embedded leading sign</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r17c1-t3" headers="r1c1-t3">
<p>OVERPUNCH TRAILING</p>
</td>
<td class="cellalignment4973" headers="r17c1-t3 r1c2-t3">
<p>154</p>
</td>
<td class="cellalignment4973" headers="r17c1-t3 r1c3-t3">
<p>COBOL numeric character string with embedded trailing sign (equivalent to declarations of the form PIC S9(n)V9(m) DISPLAY)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r18c1-t3" headers="r1c1-t3">
<p>RAW</p>
</td>
<td class="cellalignment4973" headers="r18c1-t3 r1c2-t3">
<p>23</p>
</td>
<td class="cellalignment4973" headers="r18c1-t3 r1c3-t3">
<p>&lt;= 65535-byte, fixed-length binary data ()</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r19c1-t3" headers="r1c1-t3">
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r19c1-t3 r1c2-t3">
<p>11</p>
</td>
<td class="cellalignment4973" headers="r19c1-t3 r1c3-t3">
<p>fixed-length binary value (system-specific)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r20c1-t3" headers="r1c1-t3">
<p>STRING</p>
</td>
<td class="cellalignment4973" headers="r20c1-t3 r1c2-t3">
<p>5</p>
</td>
<td class="cellalignment4973" headers="r20c1-t3 r1c3-t3">
<p>&lt;= 65535-byte, null-terminated character string ()</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r21c1-t3" headers="r1c1-t3">
<p>UNSIGNED</p>
</td>
<td class="cellalignment4973" headers="r21c1-t3 r1c2-t3">
<p>68</p>
</td>
<td class="cellalignment4973" headers="r21c1-t3 r1c3-t3">
<p>2-byte or 4-byte unsigned integer</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r22c1-t3" headers="r1c1-t3">
<p>UNSIGNED DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r22c1-t3 r1c2-t3">
<p>153</p>
</td>
<td class="cellalignment4973" headers="r22c1-t3 r1c3-t3">
<p>COBOL unsigned numeric</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r23c1-t3" headers="r1c1-t3">
<p>VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r23c1-t3 r1c2-t3">
<p>9</p>
</td>
<td class="cellalignment4973" headers="r23c1-t3 r1c3-t3">
<p>&lt;= 65533-byte, variable-length character string</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r24c1-t3" headers="r1c1-t3">
<p>VARCHAR2</p>
</td>
<td class="cellalignment4973" headers="r24c1-t3 r1c2-t3">
<p>1</p>
</td>
<td class="cellalignment4973" headers="r24c1-t3 r1c3-t3">
<p>&lt;= 65535-byte, variable-length character string ()</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r25c1-t3" headers="r1c1-t3">
<p>VARNUM</p>
</td>
<td class="cellalignment4973" headers="r25c1-t3 r1c2-t3">
<p>6</p>
</td>
<td class="cellalignment4973" headers="r25c1-t3 r1c3-t3">
<p>variable-length binary number</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r26c1-t3" headers="r1c1-t3">
<p>VARRAW</p>
</td>
<td class="cellalignment4973" headers="r26c1-t3 r1c2-t3">
<p>15</p>
</td>
<td class="cellalignment4973" headers="r26c1-t3 r1c3-t3">
<p>&lt;= 65533-byte, variable-length binary data</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><span class="bold">Notes</span>:</p>
<p><a id="i28159"></a>CHAR is datatype 1 when PICX=VARCHAR2 and datatype 96 when PICX=CHARF.</p>
<p><a id="i21097"></a>Maximum size is 32767 (32K) on some platforms.</p>
<a id="i21099"></a>
<div id="LNPCB243" class="sect3">
<h4 class="sect3">CHAR</h4>
<p>CHAR behavior depends on the settings of the option PICX. See <a href="pco14opt.htm#BCEFJFDA">&#34;PICX&#34;</a>.<a id="sthref384"></a><a id="sthref385"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB244" class="sect3"><a id="sthref386"></a>
<h4 class="sect3">CHARF</h4>
<p>By default, the CHARF datatype represents all non-varying character host variables. You use the CHARF datatype to store fixed-length character strings. On most platforms, the maximum length of a CHARF value is 65535 (64K) bytes. See <a href="pco14opt.htm#BCEFJFDA">&#34;PICX&#34;</a>.<a id="sthref387"></a><a id="sthref388"></a></p>
<p><span class="bold">On Input</span>. Oracle reads the number of bytes specified for the input host variable, does <span class="italic">not</span> strip trailing blanks, then stores the input value in the target database column.</p>
<p>If the input value is longer than the defined width of the database column, Oracle generates an error. If the input value is all-blank, then a string of spaces is stored.</p>
<p><span class="bold">On Output</span>. Oracle returns the number of bytes specified for the output host variable, blank-padding if necessary, then assigns the output value to the target host variable. If a NULL is returned, then the original value of the variable is not overwritten.</p>
<p>If the output value is longer than the declared length of the host variable, Oracle truncates the value before assigning it to the host variable. If an indicator variable is available, Oracle sets it to the original length of the output value.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB245" class="sect3"><a id="sthref389"></a>
<h4 class="sect3">CHARZ<a id="sthref390"></a><a id="sthref391"></a></h4>
<p>The CHARZ datatype represents fixed-length, null-terminated character strings. On most platforms, the maximum length of a CHARZ value is 65535 bytes. You usually will not need this external type in Pro*COBOL.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB246" class="sect3"><a id="sthref392"></a>
<h4 class="sect3">DATE</h4>
<p>The DATE datatype represents dates and times in 7-byte, fixed-length fields. As <a href="#g46804">Table 4-3</a> shows, the century, year, month, day, hour (in 24-hour format), minute, and second are stored in that order from left to right.</p>
<div id="LNPCB247" class="tblformal">
<p class="titleintable"><a id="sthref393"></a><a id="g46804"></a>Table 4-3 Date Format</p>
<table class="cellalignment4971" title="Date Format" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t4">Byte</th>
<th class="cellalignment4972" id="r1c2-t4">1</th>
<th class="cellalignment4972" id="r1c3-t4">2</th>
<th class="cellalignment4972" id="r1c4-t4">3</th>
<th class="cellalignment4972" id="r1c5-t4">4</th>
<th class="cellalignment4972" id="r1c6-t4">5</th>
<th class="cellalignment4972" id="r1c7-t4">6</th>
<th class="cellalignment4972" id="r1c8-t4">7</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t4" headers="r1c1-t4">
<p>Meaning</p>
</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c2-t4">
<p>Century</p>
</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c3-t4">
<p>Year</p>
</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c4-t4">
<p>Month</p>
</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c5-t4">
<p>Day</p>
</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c6-t4">
<p>Hour</p>
</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c7-t4">
<p>Minute</p>
</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c8-t4">
<p>Second</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t4" headers="r1c1-t4">
<p>Example</p>
<p>17-Oct-1994 at 1:23:12 PM</p>
</td>
<td class="cellalignment4973" headers="r3c1-t4 r1c2-t4">
<p>119</p>
</td>
<td class="cellalignment4973" headers="r3c1-t4 r1c3-t4">
<p>194</p>
</td>
<td class="cellalignment4973" headers="r3c1-t4 r1c4-t4">
<p>10</p>
</td>
<td class="cellalignment4973" headers="r3c1-t4 r1c5-t4">
<p>17</p>
</td>
<td class="cellalignment4973" headers="r3c1-t4 r1c6-t4">
<p>14</p>
</td>
<td class="cellalignment4973" headers="r3c1-t4 r1c7-t4">
<p>24</p>
</td>
<td class="cellalignment4973" headers="r3c1-t4 r1c8-t4">
<p>13</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The century and year bytes are in excess-100 notation. The hour, minute, and second are in excess-1 notation. Dates before the Common Era (B.C.E.) are less than 100. The epoch is January 1, 4712 B.C.E. For this date, the century byte is 53 and the year byte is 88. The hour byte ranges from 1 to 24. The minute and second bytes range from 1 to 60. The time defaults to midnight (1, 1, 1). Pro*COBOL also supports five additional datetime datetypes, as described in <a href="#i27774">&#34;Datetime and Interval Datatype Descriptors&#34;</a> .</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB248" class="sect3"><a id="sthref394"></a>
<h4 class="sect3">DECIMAL</h4>
<p>The DECIMAL datatype represents packed decimal numbers for calculation. In COBOL, the host variable must be a signed COMP-3 field with an implied decimal point. If significant digits are lost during data conversion, the value is truncated to the declared length.<a id="sthref395"></a><a id="sthref396"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB249" class="sect3"><a id="sthref397"></a>
<h4 class="sect3">DISPLAY</h4>
<p>The DISPLAY datatype represents numeric character data. The DISPLAY datatype refers to a COBOL &#34;DISPLAY SIGN LEADING SEPARATE&#34; number, which requires <span class="italic">n</span> + 1 bytes of storage for PIC S9(<span class="italic">n</span>), and <span class="italic">n</span> + <span class="italic">d</span> + 1 bytes of storage for PIC S9(<span class="italic">n</span>)V9(<span class="italic">d</span>). <a id="sthref398"></a><a id="sthref399"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB250" class="sect3"><a id="sthref400"></a>
<h4 class="sect3">FLOAT</h4>
<p>The FLOAT datatype represents numbers that have a fractional part or that exceed the capacity of the INTEGER datatype. FLOAT relates to the COBOL datatypes COMP-1 (4-byte floating point) and COMP-2 (8-byte floating point). <a id="sthref401"></a><a id="sthref402"></a></p>
<p>Oracle can represent numbers with greater precision than floating point implementations because the internal format of Oracle numbers is decimal.</p>
<p><span class="bold">Note:</span> In SQL statements, when comparing FLOAT values, use the SQL function ROUND because FLOAT stores binary (not decimal) numbers; so, fractions do not convert exactly.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB251" class="sect3"><a id="sthref403"></a>
<h4 class="sect3">INTEGER</h4>
<p>The INTEGER datatype represents numbers that have no fractional part. An integer is a signed, 2-byte, 4-byte, or 8-byte binary number. The order of the bytes in a word is platform-dependent. You must specify a length for input and output host variables. On output, if the column has a fractional part, the digits after the decimal point are truncated. <a id="sthref404"></a><a id="sthref405"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB252" class="sect3"><a id="sthref406"></a>
<h4 class="sect3">LONG</h4>
<p>The LONG datatype represents fixed-length character strings. The LONG datatype is like the VARCHAR2 datatype, except that the maximum length of a LONG value is 2147483647 bytes (two gigabytes).<a id="sthref407"></a><a id="sthref408"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB253" class="sect3"><a id="sthref409"></a>
<h4 class="sect3">LONG RAW</h4>
<p>The LONG RAW datatype represents fixed-length, binary data or byte strings. The maximum length of a LONG RAW value is 2147483647 bytes (two gigabytes).<a id="sthref410"></a><a id="sthref411"></a></p>
<p>LONG RAW data is like LONG data, except that Oracle assumes nothing about the meaning of LONG RAW data and does no character set conversions when you transmit LONG RAW data from one system to another.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB254" class="sect3"><a id="sthref412"></a>
<h4 class="sect3">LONG VARCHAR</h4>
<p>The LONG VARCHAR datatype represents variable-length character strings. LONG VARCHAR variables have a 4-byte length field followed by a string field. The maximum length of the string field is 2147483643 bytes. In an EXEC SQL VAR statement, do <span class="italic">not</span> include the 4-byte length field.<a id="sthref413"></a><a id="sthref414"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB255" class="sect3"><a id="sthref415"></a>
<h4 class="sect3">LONG VARRAW</h4>
<p>The LONG VARRAW datatype represents binary data or byte strings. LONG VARRAW variables have a 4-byte length field followed by a data field. The maximum length of the data field is 2147483643 bytes. In an EXEC SQL VAR statement, do <span class="italic">not</span> include the 4-byte length field.<a id="sthref416"></a><a id="sthref417"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB256" class="sect3"><a id="sthref418"></a>
<h4 class="sect3">NUMBER</h4>
<p>The NUMBER datatype represents the internal Oracle NUMBER format which cannot be represented by a COBOL datatype.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB257" class="sect3"><a id="sthref419"></a>
<h4 class="sect3">OVER-PUNCH</h4>
<p>OVER-PUNCH is the default signed numeric for the COBOL language. Digits are held in ASCII or EBCDIC format in radix 10, with one digit for each byte of computer storage. The sign is held in the high order nibble of one of the bytes. It is called OVER-PUNCH because the sign is &#34;punched-over&#34; the digit in either the first or last byte. The default sign position will be over the trailing byte. PIC S9(n)V9(m) TRAILING or PIC S9(n)V9(m) LEADING is used to specify the over-punch.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB258" class="sect3"><a id="sthref420"></a>
<h4 class="sect3">RAW</h4>
<p>The RAW datatype represents fixed-length binary data or byte strings. On most platforms, the maximum length of a RAW value is 65535 bytes. <a id="sthref421"></a><a id="sthref422"></a></p>
<p>RAW data is like CHAR data, except that Oracle assumes nothing about the meaning of RAW data and does no character set conversions when you transmit RAW data from one system to another.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB259" class="sect3"><a id="sthref423"></a>
<h4 class="sect3">ROWID</h4>
<p>The ROWID datatype is the database row identifier in COBOL. To support both logical and physical ROWIDs (as well as ROWIDs of non-Oracle tables) the Universal ROWID (UROWID) was defined. Use the SQL-ROWID pseudotype for this datatype (see <a href="#i20247">&#34;Universal ROWIDs&#34;</a>).</p>
<p>You can use VARCHAR2 host variables to store ROWIDs in a readable format. When you select or fetch a ROWID into a VARCHAR2 host variable, Oracle converts the binary value to an 18-byte character string and returns it in the format:</p>
<p>BBBBBBBB.RRRR.FFFF</p>
<pre></pre>
<p>where BBBBBBBB is the block in the database file, RRRR is the row in the block (the first row is 0), and FFFF is the database file. These numbers are hexadecimal. For example, the ROWID:</p>
<pre>0000000E.000A.0007 
</pre>
<p>points to the 11th row in the 15th block in the 7th database file.</p>
<p>Typically, you fetch a ROWID into a VARCHAR2 host variable, and hen compare the host variable to the ROWID pseudocolumn in the WHERE clause of an UPDATE or DELETE statement. That way, you can identify the latest row fetched by a cursor. For an example, see <a href="pco07tab.htm#i3051">&#34;Mimicking the CURRENT OF Clause&#34;</a>.</p>
<p><span class="bold">Note:</span> If you need full portability or your application communicates with a non-Oracle database through Transparent Gateway, specify a maximum length of 256 (not 18) bytes when declaring the VARCHAR2 host variable. If your application communicates with a non-Oracle data source through Oracle Open Gateway, specify a maximum length of 256 bytes. Though you can assume nothing about its contents, the host variable will behave normally in SQL statements.<a id="sthref424"></a><a id="sthref425"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB260" class="sect3"><a id="sthref426"></a>
<h4 class="sect3">STRING</h4>
<p>The STRING datatype is like the VARCHAR2 datatype except that a STRING value is always terminated by a LOW-VALUE character. This datatype is usually not used in Pro*COBOL. <a id="sthref427"></a><a id="sthref428"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB261" class="sect3"><a id="sthref429"></a>
<h4 class="sect3">UNSIGNED</h4>
<p>The UNSIGNED datatype represents unsigned integers. This datatype is usually not used in Pro*COBOL. <a id="sthref430"></a><a id="sthref431"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB262" class="sect3"><a id="sthref432"></a>
<h4 class="sect3">VARCHAR</h4>
<p>The VARCHAR datatype represents variable-length character strings. VARCHAR variables have a 2-byte length field followed by a 65533-byte string field. However, for VARCHAR array elements, the maximum length of the string field is 65530 bytes. When you specify the length of a VARCHAR variable, be sure to include 2 bytes for the length field. For longer strings, use the LONG VARCHAR datatype. In an EXEC SQL VAR statement, do <span class="italic">not</span> include the 2-byte length field.<a id="sthref433"></a><a id="sthref434"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB263" class="sect3"><a id="sthref435"></a>
<h4 class="sect3">VARCHAR2</h4>
<p>The VARCHAR2 datatype represents variable-length character strings. On most platforms, the maximum length of a VARCHAR2 value is 65535 bytes.<a id="sthref436"></a><a id="sthref437"></a></p>
<p>Specify the maximum length of a VARCHAR2(<span class="italic">n</span>) value in bytes, not characters. So, if a VARCHAR2(<span class="italic">n</span>) variable stores multibyte characters, its maximum length is less than <span class="italic">n</span> characters.</p>
<p><span class="bold">On Input.</span> Oracle reads the number of bytes specified for the input host variable, strips any trailing blanks, and then stores the input value in the target database column.</p>
<p>If the input value is longer than the defined width of the database column, Oracle generates an error. If the input value is all SPACES, Oracle treats it like a NULL.</p>
<p>Oracle can convert a character value to a NUMBER column value if the character value represents a valid number. Otherwise, Oracle generates an error.</p>
<p><span class="bold">On Output.</span> Oracle returns the number of bytes specified for the output host variable, blank-padding if necessary, and then assigns the output value to the target host variable. If a NULL is returned, Oracle fills the host variable with blanks.</p>
<p>If the output value is longer than the declared length of the host variable, Oracle truncates the value before assigning it to the host variable. If an indicator variable is available, Oracle sets it to the original length of the output value.</p>
<p>Oracle can convert NUMBER column values to character values. The length of the character host variable determines precision. If the host variable is too short for the number, scientific notation is used. For example, if you select the column value 123456789 into a host variable of length 6, Oracle returns the value <code>1.2E08</code> to the host variable.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB264" class="sect3"><a id="sthref438"></a>
<h4 class="sect3">VARNUM</h4>
<p>The VARNUM datatype is similar in format to NUMBER and is usually not used in Pro*COBOL. <a id="sthref439"></a><a id="sthref440"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB265" class="sect3"><a id="sthref441"></a>
<h4 class="sect3">VARRAW</h4>
<p>The VARRAW datatype represents variable-length binary data or byte strings. The VARRAW datatype is like the RAW datatype, except that VARRAW variables have a 2-byte length field followed by a &lt;= 65533-byte data field. For longer strings, use the LONG VARRAW datatype. In an EXEC SQL VAR statement, do <span class="italic">not</span> include the 2-byte length field. To get the length of a VARRAW variable, simply refer to its length field.<a id="sthref442"></a><a id="sthref443"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB266" class="sect3"><a id="sthref444"></a>
<h4 class="sect3">SQL Pseudocolumns and Functions</h4>
<p>SQL recognizes the pseudocolumns listed in <a href="#g46056">Table 4-4</a>, which return specific data items.</p>
<div id="LNPCB267" class="tblformal">
<p class="titleintable"><a id="sthref445"></a><a id="g46056"></a>Table 4-4 Pseudocolumns and Internal Datatypes</p>
<table class="cellalignment4971" title="Pseudocolumns and Internal Datatypes" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t5">Pseudocolumn</th>
<th class="cellalignment4972" id="r1c2-t5">Internal Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t5" headers="r1c1-t5">
<p>CURRVAL</p>
</td>
<td class="cellalignment4973" headers="r2c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t5" headers="r1c1-t5">
<p>LEVEL</p>
</td>
<td class="cellalignment4973" headers="r3c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t5" headers="r1c1-t5">
<p>NEXTVAL</p>
</td>
<td class="cellalignment4973" headers="r4c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t5" headers="r1c1-t5">
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r5c1-t5 r1c2-t5">
<p>ROWID</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t5" headers="r1c1-t5">
<p>ROWNUM</p>
</td>
<td class="cellalignment4973" headers="r6c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Pseudocolumns are not actual columns in a table. However, pseudocolumns are treated like columns, so their values must be SELECTed from a table. Sometimes it is convenient to select pseudocolumn values from a dummy table. <a id="sthref446"></a></p>
<p>In addition, SQL recognizes the functions without parameters listed in <a href="#g46078">Table 4-5</a>, which also return specific data items.</p>
<div id="LNPCB268" class="tblformal">
<p class="titleintable"><a id="sthref447"></a><a id="g46078"></a>Table 4-5 Functions and Internal Datatypes</p>
<table class="cellalignment4971" title="Functions and Internal Datatypes" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t6">Function</th>
<th class="cellalignment4972" id="r1c2-t6">Internal Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t6" headers="r1c1-t6">
<p>SYSDATE</p>
</td>
<td class="cellalignment4973" headers="r2c1-t6 r1c2-t6">
<p>DATE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t6" headers="r1c1-t6">
<p>UID</p>
</td>
<td class="cellalignment4973" headers="r3c1-t6 r1c2-t6">
<p>NUMBER</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t6" headers="r1c1-t6">
<p>USER</p>
</td>
<td class="cellalignment4973" headers="r4c1-t6 r1c2-t6">
<p>VARCHAR2</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>You can refer to SQL pseudocolumns and functions in SELECT, INSERT, UPDATE, and DELETE statements. In the following example, you use SYSDATE to compute the number of months since an employee was hired:</p>
<pre>     EXEC SQL SELECT MONTHS_BETWEEN(SYSDATE, HIREDATE) 
         INTO :MONTHS-OF-SERVICE 
         FROM EMP 
         WHERE EMPNO = :EMP-NUMBER
     END EXEC. 
</pre>
<p>Brief descriptions of the SQL pseudocolumns and functions follow. For details, see the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p><span class="bold">CURRVAL</span> returns the current number in a specified sequence. Before you can reference CURRVAL, you must use NEXTVAL to generate a sequence number.<a id="sthref448"></a><a id="sthref449"></a></p>
<p><span class="bold">LEVEL</span> returns the level number of a node in a tree structure. The root is level 1, children of the root are level 2, grandchildren are level 3, and so on.<a id="sthref450"></a><a id="sthref451"></a></p>
<p>LEVEL is used in the SELECT CONNECT BY statement to incorporate some or all the rows of a table into a tree structure. In an ORDER BY or GROUP BY clause, LEVEL segregates the data at each level in the tree.</p>
<p>Specify the direction in which the query walks the tree (down from the root or up from the branches) with the PRIOR operator. In the START WITH clause, you can specify a condition that identifies the root of the tree.</p>
<p><span class="bold">NEXTVAL</span> returns the next number in a specified sequence. After creating a sequence, you can use it to generate unique sequence numbers for transaction processing. In the following example, the sequence named <span class="italic">partno</span> assigns part numbers:<a id="sthref452"></a><a id="sthref453"></a></p>
<pre>     EXEC SQL INSERT INTO PARTS 
         VALUES (PARTNO.NEXTVAL, :DESCRIPTION, :QUANTITY, :PRICE
     END EXEC.
</pre>
<p>If a transaction generates a sequence number, the sequence is incremented when you commit or roll back the transaction. A reference to NEXTVAL stores the current sequence number in CURRVAL.</p>
<p><span class="bold">ROWNUM</span> returns a number indicating the sequence in which a row was selected from a table. The first row selected has a ROWNUM of 1, the second row has a ROWNUM of 2, and so on. If a SELECT statement includes an ORDER BY clause, ROWNUMs are assigned to the selected rows <span class="italic">before</span> the sort is done. <a id="sthref454"></a><a id="sthref455"></a></p>
<p>You can use ROWNUM to limit the number of rows returned by a SELECT statement. Also, you can use ROWNUM in an UPDATE statement to assign unique values to each row in a table. Using ROWNUM in the WHERE clause does not stop the processing of a SELECT statement; it just limits the number of rows retrieved. The only meaningful use of ROWNUM in a WHERE clause is:</p>
<pre>     ... WHERE ROWNUM &lt; constant END-EXEC. 
</pre>
<p>because the value of ROWNUM increases only when a row is retrieved. The following search condition can never be met because the first four rows are not retrieved:</p>
<pre>     ... WHERE ROWNUM = 5 END-EXEC. 
</pre>
<p><span class="bold">SYSDATE</span> returns the current date and time. <a id="sthref456"></a></p>
<p><span class="bold">UID</span> returns the unique ID number assigned to an Oracle user. <a id="sthref457"></a></p>
<p><span class="bold">USER</span> returns the username of the current Oracle user. <a id="sthref458"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i27774"></a>
<div id="LNPCB269" class="sect1">
<h2 class="sect1">Datetime and Interval Datatype Descriptors</h2>
<p>The OCI datetime and interval datatypes supported by Pro*COBOL are briefly summarized here.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> <span class="italic">f</span>or more a more complete discussion datetime datatype descriptors</div>
<p class="subhead1"><a id="LNPCB270"></a>ANSI DATE<a id="sthref459"></a><a id="sthref460"></a></p>
<p>The <code>ANSI</code> <code>DATE</code> is based on the <code>DATE</code>, but contains no time portion. (Therefore, it also has no time zone.) <code>ANSI</code> <code>DATE</code> follows the <code>ANSI</code> specification for the <code>DATE</code> datatype. When assigning an <code>ANSI</code> <code>DATE</code> to a <code>DATE</code> or a timestamp datatype, the time portion of the Oracle <code>DATE</code> and the timestamp are set to zero. When assigning a <code>DATE</code> or a timestamp to an <code>ANSI</code> <code>DATE</code>, the time portion is ignored.</p>
<p>You are encouraged to instead use the <code>TIMESTAMP</code> datatype which contains both date and time.</p>
<p class="subhead1"><a id="LNPCB271"></a>TIMESTAMP<a id="sthref461"></a><a id="sthref462"></a></p>
<p>The <code>TIMESTAMP</code> datatype is an extension of the <code>DATE</code> datatype. It stores the year, month, and day of the <code>DATE</code> datatype, plus the hour, minute, and second values. It has no time zone. The <code>TIMESTAMP</code> datatype has the form:</p>
<pre>TIMESTAMP(fractional_seconds_precision) 
</pre>
<p>where <code><span class="codeinlineitalic">fractional_seconds_precision</span></code> (which is optional) specifies the number of digits in the fractional part of the <code>SECOND</code> datetime field and can be a number in the range 0 to 9. The default is 6.</p>
<p class="subhead1"><a id="LNPCB272"></a>TIMESTAMP WITH TIME ZONE<a id="sthref463"></a><a id="sthref464"></a></p>
<p><code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> (<code>TSTZ</code>) is a variant of <code>TIMESTAMP</code> that includes an explicit time zone displacement in its value. The time zone displacement is the difference (in hours and minutes) between local time and UTC (Coordinated Universal Time&mdash;formerly Greenwich Mean Time). The <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> ZONE datatype has the form:</p>
<pre>TIMESTAMP(fractional_seconds_precision) WITH TIME ZONE
</pre>
<p>where <code><span class="codeinlineitalic">fractional_seconds_precision</span></code> optionally specifies the number of digits in the fractional part of the <code>SECOND</code> datetime field and can be a number in the range 0 to 9. The default is 6.</p>
<p>Two <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values are considered identical if they represent the same instant in UTC, regardless of the <code>TIME</code> <code>ZONE</code> offsets stored in the data.</p>
<p class="subhead1"><a id="LNPCB273"></a>TIMESTAMP WITH LOCAL TIME ZONE<a id="sthref465"></a><a id="sthref466"></a></p>
<p><code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code> (<code>TSLTZ</code>) is another variant of <code>TIMESTAMP</code> that includes a time zone displacement in its value. Storage is in the same format as for <code>TIMESTAMP</code>. This type differs from <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> in that data stored in the database is normalized to the database time zone, and the time zone displacement is not stored as part of the column data. When users retrieve the data, Oracle returns it in the users&#39; local session time zone.</p>
<p>The time zone displacement is the difference (in hours and minutes) between local time and UTC (Coordinated Universal Time&mdash;formerly Greenwich Mean Time). The <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> ZONE datatype has the form:</p>
<pre>TIMESTAMP(fractional_seconds_precision) WITH LOCAL TIME ZONE
</pre>
<p>where <code><span class="codeinlineitalic">fractional_seconds_precision</span></code> optionally specifies the number of digits in the fractional part of the <code>SECOND</code> datetime field and can be a number in the range 0 to 9. The default is 6.</p>
<p class="subhead1"><a id="LNPCB274"></a>INTERVAL YEAR TO MONTH<a id="sthref467"></a><a id="sthref468"></a></p>
<p><code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> stores a period of time using the <code>YEAR</code> and <code>MONTH</code> datetime fields. The <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> datatype has the form:</p>
<pre>INTERVAL YEAR(year_precision) TO MONTH
</pre>
<p>where the optional <code><span class="codeinlineitalic">year_precision</span></code> is the number of digits in the <code>YEAR</code> datetime field. The default value of <code><span class="codeinlineitalic">year_precision</span></code> is 2.</p>
<p class="subhead1"><a id="LNPCB275"></a>INTERVAL DAY TO SECOND<a id="sthref469"></a><a id="sthref470"></a></p>
<p><code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> stores a period of time in terms of days, hours, minutes, and seconds. The <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> datatype has the form:</p>
<pre>INTERVAL DAY (day_precision) TO SECOND(fractional_seconds_precision)
</pre>
<p>where:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">day_precision</span></code> is the number of digits in the <code>DAY</code> datetime field. It is optional. Accepted values are 0 to 9. The default is 2.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">fractional_seconds_precision</span></code> is the number of digits in the fractional part of the <code>SECOND</code> datetime field. It is optional. Accepted values are 0 to 9. The default is 6.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
To avoid unexpected results in your DML operations on datetime data, you can verify the database and session time zones by querying the built-in SQL functions <code>DBTIMEZONE</code> and <code>SESSIONTIMEZONE</code>. If the time zones have not been set manually, Oracle uses the operating system time zone by default. If the operating system time zone is not a valid Oracle time zone, Oracle uses UTC as the default value.</div>
</div>
<!-- class="sect1" -->
<a id="i13081"></a>
<div id="LNPCB276" class="sect1">
<h2 class="sect1">Host Variables</h2>
<p>Host variables are the key to communication between your host program and the server. Typically, a host program inputs data to the server, and the server outputs data to the program. The server stores input data in database columns and stores output data in program host variables.</p>
<div id="LNPCB277" class="sect2"><a id="sthref471"></a>
<h3 class="sect2">Declaring Host Variables</h3>
<p>Host variables are declared according to COBOL rules, using the COBOL datatypes that are supported by Pro*COBOL. COBOL datatypes must be compatible with the source/target database column.</p>
<p>The supported COBOL variable declarations, descriptions, corresponding external datatypes, and Oracle datatype codes are shown in <a href="#g46094">Table 4-6</a>.</p>
<div id="LNPCB278" class="tblformalwide">
<p class="titleintable"><a id="sthref472"></a><a id="g46094"></a>Table 4-6 Host Variable Declarations</p>
<table class="cellalignment4974" title="Host Variable Declarations " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t9">Variable Declaration</th>
<th class="cellalignment4972" id="r1c2-t9">Description</th>
<th class="cellalignment4972" id="r1c3-t9">External Datatype</th>
<th class="cellalignment4972" id="r1c4-t9">Type Code</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t9" headers="r1c1-t9">
<p>PIC X...X</p>
<p>PIC X(<span class="italic">n</span>)</p>
<p>PIC X...X VARYING</p>
<p>PIC X(<span class="italic">n</span>) VARYING</p>
</td>
<td class="cellalignment4973" headers="r2c1-t9 r1c2-t9">
<p>fixed-length string of 1-byte characters (<a href="#BEHIFHJF">1</a>)</p>
<p><span class="italic">n</span>-length string of 1-byte characters</p>
<p>variable-length string of 1-byte characters (<a href="#BEHIFHJF">1</a>,<a href="#i26079">2</a>)</p>
<p>variable-length (<span class="italic">n</span> max.) string of 1-byte characters (<a href="#i26079">2</a>)</p>
</td>
<td class="cellalignment4973" headers="r2c1-t9 r1c3-t9">
<p>CHARF</p>
<p>VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r2c1-t9 r1c4-t9">
<p>96</p>
<p>9</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t9" headers="r1c1-t9">
<p>PIC N...N</p>
<p>PIC G...G</p>
<p>PIC N(<span class="italic">n</span>)</p>
<p>PIC G(n)</p>
<p>PIC N...N VARYING</p>
<p>PIC N(n) VARYING</p>
<p>PIC G...G VARYING</p>
<p>PIC G(n) VARYING</p>
</td>
<td class="cellalignment4973" headers="r3c1-t9 r1c2-t9">
<p>fixed-length string of multibyte NCHAR</p>
<p>characters (<a href="#BEHIFHJF">1</a>,<a href="#i26080">3</a>)</p>
<p><span class="italic">n</span>-length string of multibyte NCHAR characters</p>
<p>(<a href="#i26080">3</a>)</p>
<p>variable-length string of multibyte characters (<a href="#i26079">2</a>,<a href="#i26080">3</a>)</p>
<p>variable-length (<span class="italic">n</span> max.) string of multibyte</p>
<p>characters (<a href="#i26079">2</a>,<a href="#i26080">3</a>)</p>
</td>
<td class="cellalignment4973" headers="r3c1-t9 r1c3-t9">
<p>CHARF</p>
<p>VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r3c1-t9 r1c4-t9">
<p>96</p>
<p>9</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t9" headers="r1c1-t9">
<p>PIC S9...9 BINARY</p>
<p>PIC S9(<span class="italic">n</span>) BINARY</p>
<p>PIC S9...9 COMP</p>
<p>PIC S9(<span class="italic">n</span>) COMP</p>
<p>PIC S9...9 COMP-4</p>
<p>PIC S9(<span class="italic">n</span>) COMP-4</p>
</td>
<td class="cellalignment4973" headers="r4c1-t9 r1c2-t9">
<p>integer (<a href="#i26151">4</a>,<a href="#i26166">5</a>,<a href="#i26182">7</a>)</p>
</td>
<td class="cellalignment4973" headers="r4c1-t9 r1c3-t9">
<p>INTEGER</p>
</td>
<td class="cellalignment4973" headers="r4c1-t9 r1c4-t9">
<p>3</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t9" headers="r1c1-t9">
<p>PIC S9...9 COMP-5</p>
<p>PIC S9(<span class="italic">n</span>) COMP-5</p>
</td>
<td class="cellalignment4973" headers="r5c1-t9 r1c2-t9">
<p>byte-swapped integer (<a href="#i26151">4</a>,<a href="#i26166">5</a>,<a href="#i26181">6</a>,<a href="#i26182">7</a>)</p>
</td>
<td class="cellalignment4973" headers="r5c1-t9 r1c3-t9">
<p>INTEGER</p>
</td>
<td class="cellalignment4973" headers="r5c1-t9 r1c4-t9">
<p>3</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t9" headers="r1c1-t9">
<p>COMP-1</p>
<p>COMP-2</p>
</td>
<td class="cellalignment4973" headers="r6c1-t9 r1c2-t9">
<p>floating-point number (<a href="#i26166">5</a>)</p>
</td>
<td class="cellalignment4973" headers="r6c1-t9 r1c3-t9">
<p>FLOAT</p>
</td>
<td class="cellalignment4973" headers="r6c1-t9 r1c4-t9">
<p>4</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t9" headers="r1c1-t9">
<p>PIC S9...9[V9...9] COMP-3</p>
<p>PIC S9(<span class="italic">n</span>)[V9(<span class="italic">n</span>)] COMP-3</p>
<p>PIC S9...9[V9...9]</p>
<p>PACKED-DECIMAL</p>
<p>PIC S9(<span class="italic">n</span>)[V9(<span class="italic">n</span>)]</p>
<p>PACKED-DECIMAL</p>
</td>
<td class="cellalignment4973" headers="r7c1-t9 r1c2-t9">
<p>packed-decimal (<a href="#i26151">4</a>,<a href="#i26166">5</a>)</p>
</td>
<td class="cellalignment4973" headers="r7c1-t9 r1c3-t9">
<p>DECIMAL</p>
</td>
<td class="cellalignment4973" headers="r7c1-t9 r1c4-t9">
<p>7</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t9" headers="r1c1-t9">
<p>PIC S9...9[V9...9] DISPLAY</p>
<p>SIGN LEADING SEPARATE</p>
<p>PIC S9(<span class="italic">n</span>)[V9(<span class="italic">m</span>)] DISPLAY</p>
<p>SIGN LEADING SEPARATE</p>
<p>PIC S9...9[V9...9] DISPLAY</p>
<p>SIGN TRAILING SEPARATE</p>
<p>PIC S9(<span class="italic">n</span>)[V9(<span class="italic">m</span>)] DISPLAY</p>
<p>SIGN TRAILING SEPARATE</p>
</td>
<td class="cellalignment4973" headers="r8c1-t9 r1c2-t9">
<p>display leading (<a href="#i26183">8</a>,<a href="#i26194">11</a>)</p>
<p>display trailing (<a href="#i26183">8</a>)</p>
</td>
<td class="cellalignment4973" headers="r8c1-t9 r1c3-t9">
<p>DISPLAY</p>
<p>DISPLAY TRAILING</p>
</td>
<td class="cellalignment4973" headers="r8c1-t9 r1c4-t9">
<p>91</p>
<p>152</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t9" headers="r1c1-t9">
<p>PIC 9...9 DISPLAY</p>
<p>PIC 9(n)[V9(m)] DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r9c1-t9 r1c2-t9">
<p>unsigned display (<a href="#i26198">9</a>)</p>
</td>
<td class="cellalignment4973" headers="r9c1-t9 r1c3-t9">
<p>UNSIGNED DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r9c1-t9 r1c4-t9">
<p>153</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t9" headers="r1c1-t9">
<p>PIC S9...9[V9...9] DISPLAY</p>
<p>SIGN TRAILING</p>
<p>PIC S9(n)[V9(m)] DISPLAY</p>
<p>SIGN TRAILING</p>
<p>PIC S9...9[V9...9] DISPLAY</p>
<p>SIGN LEADING</p>
<p>PIC S9(n)[V9(m)] DISPLAY</p>
<p>SIGN LEADING</p>
</td>
<td class="cellalignment4973" headers="r10c1-t9 r1c2-t9">
<p>over-punch trailing (9)</p>
<p>over-punch leading (<a href="#i26198">9</a>)</p>
</td>
<td class="cellalignment4973" headers="r10c1-t9 r1c3-t9">
<p>OVER-PUNCH</p>
<p>TRAILING</p>
<p>OVER-PUNCH LEADING</p>
</td>
<td class="cellalignment4973" headers="r10c1-t9 r1c4-t9">
<p>154</p>
<p>172</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t9" headers="r1c1-t9">
<p>SQL-CURSOR</p>
</td>
<td class="cellalignment4973" headers="r11c1-t9 r1c2-t9">
<p>cursor variable</p>
</td>
<td class="cellalignment4973" headers="r11c1-t9 r1c3-t9">&nbsp;</td>
<td class="cellalignment4973" headers="r11c1-t9 r1c4-t9">&nbsp;</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t9" headers="r1c1-t9">
<p><a id="sthref473"></a>SQL-CONTEXT</p>
</td>
<td class="cellalignment4973" headers="r12c1-t9 r1c2-t9">
<p>runtime context</p>
</td>
<td class="cellalignment4973" headers="r12c1-t9 r1c3-t9">&nbsp;</td>
<td class="cellalignment4973" headers="r12c1-t9 r1c4-t9">&nbsp;</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t9" headers="r1c1-t9">
<p>SQL-ROWID</p>
</td>
<td class="cellalignment4973" headers="r13c1-t9 r1c2-t9">
<p>universal ROWID</p>
</td>
<td class="cellalignment4973" headers="r13c1-t9 r1c3-t9">
<p>UROWID</p>
</td>
<td class="cellalignment4973" headers="r13c1-t9 r1c4-t9">
<p>104</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t9" headers="r1c1-t9">
<p>SQL-BFILE</p>
</td>
<td class="cellalignment4973" headers="r14c1-t9 r1c2-t9">
<p>external binary file</p>
</td>
<td class="cellalignment4973" headers="r14c1-t9 r1c3-t9">
<p>BFILE</p>
</td>
<td class="cellalignment4973" headers="r14c1-t9 r1c4-t9">
<p>112</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t9" headers="r1c1-t9">
<p>SQL-BLOB</p>
</td>
<td class="cellalignment4973" headers="r15c1-t9 r1c2-t9">
<p>binary LOB</p>
</td>
<td class="cellalignment4973" headers="r15c1-t9 r1c3-t9">
<p>BLOB</p>
</td>
<td class="cellalignment4973" headers="r15c1-t9 r1c4-t9">
<p>113</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r16c1-t9" headers="r1c1-t9">
<p>SQL-CLOB</p>
</td>
<td class="cellalignment4973" headers="r16c1-t9 r1c2-t9">
<p>character LOB</p>
</td>
<td class="cellalignment4973" headers="r16c1-t9 r1c3-t9">
<p>CLOB</p>
</td>
<td class="cellalignment4973" headers="r16c1-t9 r1c4-t9">
<p>114</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" -->
<p><span class="bold">Notes</span>:</p>
<a id="i26058"></a>
<ol>
<li id="BEHIFHJF">
<p>X...X and 9...9 stand for a given number (<span class="italic">n</span>) of Xs or 9s. For variable-length strings, <span class="italic">n</span> is the maximum length.</p>
</li>
<li id="i26079">
<p>The keyword VARYING assigns the VARCHAR external datatype to a character string. For more information, see <a href="#i5391">&#34;Declaring VARCHAR Variables&#34;</a>.</p>
</li>
<li id="i26080">
<p>Before using the PIC N or PIC G datatype in your Pro*COBOL source files, verify that it is supported by your COBOL compiler.</p>
</li>
<li id="i26151">
<p>Only signed numbers (PIC S...) are allowed. For floating-point numbers, however, PIC strings are not accepted.</p>
</li>
<li id="i26166">
<p>Not all COBOL compilers support all of these datatypes.</p>
</li>
<li id="i26181">
<p>With COMP or COMP-5, the number cannot have a fractional part; scaled binary numbers are not supported. COMP-5 is not supported on the SPARC Solaris 64 bit platform, use COMP instead.</p>
</li>
<li id="i26182">
<p>The maximum value of <span class="italic">the integer</span> is <span class="italic">n</span> to 18. This may vary, depending on the operating system and the compilers for Pro*Cobol and Cobol.</p>
</li>
<li id="i26183">
<p>Both DISPLAY and SIGN are optional.</p>
</li>
<li id="i26198">
<p>DISPLAY is optional</p>
</li>
<li id="i26222">
<p>If TRAILING is omitted, the embedded sign position is operating-system dependent.</p>
</li>
<li id="i26194">
<p>LEADING is optional.</p>
</li>
</ol>
<p>In <a href="#g46094">Table 4-6</a> and <a href="#g46018">Table 4-7</a> the symbols &#39;[&#39; and &#39;]&#39; denote that an optional entry is contained inside. The symbols &#39;{&#39; and &#39;}&#39; denote that a choice must be made between tokens separated by the symbol &#39;|&#39;.</p>
<p><a href="#g46018">Table 4-7</a> shows all the COBOL datatypes that can be converted to and from each internal datatype.</p>
<div id="LNPCB279" class="tblformal">
<p class="titleintable"><a id="sthref474"></a><a id="g46018"></a>Table 4-7 Compatible Oracle Internal Datatypes</p>
<table class="cellalignment4971" title="Compatible Oracle Internal Datatypes" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t10">Internal Datatype</th>
<th class="cellalignment4972" id="r1c2-t10">Notes</th>
<th class="cellalignment4972" id="r1c3-t10">COBOL Datatype</th>
<th class="cellalignment4972" id="r1c4-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t10" headers="r1c1-t10">
<p>CHAR(<span class="italic">x)</span> VARCHAR2(<span class="italic">y</span>)</p>
</td>
<td class="cellalignment4973" headers="r2c1-t10 r1c2-t10">
<p>(<a href="#BEHBHIAE">1</a>)</p>
<p>(<a href="#BEHBHIAE">1</a>)</p>
</td>
<td class="cellalignment4973" headers="r2c1-t10 r1c3-t10">
<p>PIC X(n)</p>
<p>PIC X...X</p>
<p>PIC X(<span class="italic">n</span>) VARYING</p>
<p>PIC X...X VARYING</p>
<p>PIC S9...9 COMP</p>
<p>PIC S9(<span class="italic">n</span>) COMP</p>
<p>PIC S9...9 BINARY</p>
<p>PIC S9(<span class="italic">n</span>) BINARY</p>
<p>PIC S9...9 COMP-5</p>
<p>PIC S9(<span class="italic">n</span>) COMP-5</p>
<p>COMP-1</p>
<p>COMP-2</p>
<p>PIC S9...9[V9...9] COMP-3</p>
<p>PIC S9(<span class="italic">n</span>)[V9(<span class="italic">n</span>)] COMP-3</p>
<p>PIC S9...9[V9...9] DISPLAY</p>
<p>PIC S9(<span class="italic">n</span>)[V9(<span class="italic">n</span>)] DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r2c1-t10 r1c4-t10">
<p>character string</p>
<p><span class="italic">n</span>-character string</p>
<p>variable-length string</p>
<p>integer</p>
<p>integer</p>
<p>integer</p>
<p>floating point number</p>
<p>packed decimal</p>
<p>display</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t10" headers="r1c1-t10">
<p>NCHAR(u) NVARCHAR2(v)</p>
</td>
<td class="cellalignment4973" headers="r3c1-t10 r1c2-t10">
<p>(2)</p>
<p>(2)</p>
</td>
<td class="cellalignment4973" headers="r3c1-t10 r1c3-t10">
<p>PIC {N...N | G...G}</p>
<p>PIC { N(n) | G(n)}</p>
</td>
<td class="cellalignment4973" headers="r3c1-t10 r1c4-t10">
<p>national character string</p>
<p>n-national character string</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t10" headers="r1c1-t10">
<p>BLOB</p>
<p>CLOB</p>
<p>NCLOB</p>
<p>BFILE</p>
</td>
<td class="cellalignment4973" headers="r4c1-t10 r1c2-t10">&nbsp;</td>
<td class="cellalignment4973" headers="r4c1-t10 r1c3-t10">
<p>SQL-BLOB</p>
<p>SQL-CLOB</p>
<p>SQL-NCLOB</p>
<p>SQL-BFILE</p>
</td>
<td class="cellalignment4973" headers="r4c1-t10 r1c4-t10">
<p>binary LOB</p>
<p>character LOB</p>
<p>national character LOB</p>
<p>external binary file</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t10" headers="r1c1-t10">
<p>NUMBER</p>
<p>NUMBER (<span class="italic">p</span>,<span class="italic">s</span>)</p>
</td>
<td class="cellalignment4973" headers="r5c1-t10 r1c2-t10">
<p>(<a href="#i2197">3</a>)</p>
</td>
<td class="cellalignment4973" headers="r5c1-t10 r1c3-t10">
<p>PIC S9...9 COMP</p>
<p>PIC S9(<span class="italic">n</span>) COMP</p>
<p>PIC S9...9 BINARY</p>
<p>PIC S9(<span class="italic">n</span>) BINARY</p>
<p>PIC S9...9 COMP-5</p>
<p>PIC S9(<span class="italic">n</span>) COMP-5</p>
<p>COMP-1</p>
<p>COMP-2</p>
<p>PIC S9...9V9...9 COMP-3</p>
<p>PIC S9(<span class="italic">n</span>)V9(<span class="italic">n</span>) COMP-3</p>
<p>PIC S9...9V9...9 DISPLAY</p>
<p>PIC S9(<span class="italic">n</span>)V9(<span class="italic">n</span>) DISPLAY</p>
<p>PIC [X...X | N...N | G...G]</p>
<p>PIC [X(<span class="italic">n</span>) | N(<span class="italic">n</span>) | G(n)]</p>
<p>PIC X...X VARYING</p>
<p>PIC X(<span class="italic">n</span>) VARYING</p>
</td>
<td class="cellalignment4973" headers="r5c1-t10 r1c4-t10">
<p>integer</p>
<p>integer</p>
<p>integer</p>
<p>floating point number</p>
<p>packed decimal</p>
<p>display</p>
<p>character string (<a href="#i2201">4</a>)</p>
<p><span class="italic">n</span>-character string (<a href="#i2201">4</a>)</p>
<p>variable-length string</p>
<p><span class="italic">n</span>-byte variable-length string</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t10" headers="r1c1-t10">
<p>DATE</p>
<p>LONG</p>
<p>RAW</p>
<p>LONG RAW</p>
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r6c1-t10 r1c2-t10">
<p>(<a href="#i2205">5</a>)</p>
<p>(<a href="#BEHBHIAE">1</a>)</p>
<p>(<a href="#i2209">6</a>)</p>
</td>
<td class="cellalignment4973" headers="r6c1-t10 r1c3-t10">
<p>PIC X(<span class="italic">n</span>)</p>
<p>PIC X...X</p>
<p>PIC X(n)</p>
<p>PIC X(n) VARYING</p>
<p>PIC X...X VARYING</p>
<p>SQL-ROWID</p>
</td>
<td class="cellalignment4973" headers="r6c1-t10 r1c4-t10">
<p><span class="italic">n</span>-byte character string</p>
<p>character string</p>
<p><span class="italic">n</span>-byte variable-length string</p>
<p>universal rowid</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><span class="bold">Notes:</span></p>
<a id="i2193"></a>
<ol>
<li id="BEHBHIAE">
<p>1&lt;= <span class="italic">x</span> &lt; =2000 bytes, default is 1. 1&lt;=<span class="italic">y</span> &lt;=4000 bytes, default is 1.</p>
</li>
<li>
<p>1&lt;=u&lt;=2000 bytes, default is 1. 1&lt;=v&lt;=4000 bytes, default is 1.</p>
</li>
<li id="i2197">
<p><span class="italic">p</span> ranges from 2 to 38. <span class="italic">s</span> ranges from -84 to 127.</p>
</li>
<li id="i2201">
<p>Strings can be converted to NUMBERs only if they consist of convertible characters &mdash; 0 to 9, period (.), +, -, E, e. The Globalization Support (formerly called National Language Support or NLS) settings for your system might change the decimal point from a period (.) to a comma (,).</p>
</li>
<li id="i2205">
<p>When converted to a string type, the default size of a DATE depends on the NCHAR settings in effect on your system. When converted to a binary value, the length is 7 bytes.</p>
</li>
<li id="i2209">
<p>When converted to a string type, a ROWID requires from 18 to 4000 bytes. ROWID can also be converted to a character type. Oracle recommends the use of SQL-ROWID for all new programs.</p>
</li>
</ol>
<div id="LNPCB280" class="sect3"><a id="sthref475"></a>
<h4 class="sect3">Example Declarations</h4>
<p>The following example declares several host variables for later use:</p>
<pre>    ... 
 01  STR1  PIC X(3). 
 01  STR2  PIC X(3) VARYING. 
 01  NUM1  PIC S9(5) COMP. 
 01  NUM2  COMP-1. 
 01  NUM3  COMP-2. 
     ... 
</pre>
<p>You can also declare one-dimensional tables of simple COBOL types, as the next example shows:<a id="sthref476"></a></p>
<pre>     ... 
 01  XMP-TABLES. 
     05  TAB1  PIC XXX OCCURS 3 TIMES. 
     05  TAB2  PIC XXX VARYING OCCURS 3 TIMES. 
     05  TAB3  PIC S999 COMP-3 OCCURS 3 TIMES. 
     ... 
</pre></div>
<!-- class="sect3" -->
<div id="LNPCB281" class="sect3"><a id="sthref477"></a>
<h4 class="sect3">Initialization</h4>
<p>You can initialize host variables, except pseudotype host variables, using the VALUE clause, as shown in the following example:<a id="sthref478"></a><a id="sthref479"></a></p>
<pre> 01  USERNAME    PIC X(10) VALUE &#34;SCOTT&#34;. 
 01  MAX-SALARY  PIC S9(4) COMP VALUE 5000.
 
</pre>
<p>If a string value assigned to a character variable is shorter than the declared length of the variable, the string is blank-padded on the right. If the string value assigned to a character variable is longer than the declared length, the string is truncated.</p>
<p>No error or warning is issued, but any VALUES clause on a pseudotype variable is ignored and discarded.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB282" class="sect3"><a id="sthref480"></a>
<h4 class="sect3">Restrictions</h4>
<p>You cannot use alphabetic character (PIC A) variables or edited data items as host variables. Therefore, the following variable declarations cannot be made for <span class="italic">host</span> variables:</p>
<pre>     .... 
 01  AMOUNT-OF-CHECK  PIC ****9.99. 
 01  FIRST-NAME       PIC A(10). 
 01  BIRTH-DATE       PIC 99/99/99.
 
     .... 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB283" class="sect2"><a id="sthref481"></a>
<h3 class="sect2">Referencing Host Variables</h3>
<p>Host variables are used in SQL data manipulation statements. A host variable must be prefixed with a colon (:) in SQL statements but must not be prefixed with a colon in COBOL statements, as this example shows:<a id="sthref482"></a><a id="sthref483"></a><a id="sthref484"></a></p>
<pre> WORKING-STORAGE SECTION. 
     ... 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMP-NUMBER  PIC S9(4) COMP VALUE ZERO. 
 01  EMP-NAME    PIC X(10) VALUE SPACE. 
 01  SALARY      PIC S9(5)V99 COMP-3. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 
     DISPLAY &#34;Employee number? &#34; WITH NO ADVANCING. 
     ACCEPT EMP-NUMBER. 
     EXEC SQL SELECT ENAME, SAL 
         INTO :EMP-NAME, :SALARY FROM EMP 
         WHERE EMPNO = :EMP-NUMBER 
     END-EXEC. 
     COMPUTE BONUS = SALARY / 10. 
     ... 
</pre>
<p>Though it might be confusing, you can give a host variable the same name as a table or column, as the following example shows:<a id="sthref485"></a></p>
<pre> WORKING-STORAGE SECTION. 
     ... 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMPNO  PIC S9(4) COMP VALUE ZERO. 
 01  ENAME  PIC X(10) VALUE SPACE. 
 01  COMM   PIC S9(5)V99 COMP-3. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 
     EXEC SQL SELECT ENAME, COMM 
         INTO :ENAME, :COMM FROM EMP 
         WHERE EMPNO = :EMPNO 
     END-EXEC.  
</pre>
<a id="i7335"></a>
<div id="LNPCB284" class="sect3">
<h4 class="sect3"><a id="sthref486"></a>Group Items as Host Variables</h4>
<p>Pro*COBOL allows the use of group items in embedded SQL statements. Group items with elementary items (containing only one level) can be used as host variables. The host group items (also referred to as host structures) can be referenced in the INTO clause of a SELECT or a FETCH statement, and in the VALUES list of an INSERT statement. When a group item is used as a host variable, only the group name is used in the SQL statement. For example, given the following declaration</p>
<pre> 01  DEPARTURE.
     05 HOUR    PIC X(2).
     05 MINUTE  PIC X(2).
</pre>
<p>the following statement is valid:</p>
<pre>     EXEC SQL SELECT DHOUR, DMINUTE
         INTO :DEPARTURE
         FROM SCHEDULE
         WHERE ...
</pre>
<p>The order that the members are declared in the group item must match the order that the associated columns occur in the SQL statement, or in the database table if the column list in the INSERT statement is omitted. Using a group item as a host variable has the semantics of substituting the group item with elementary items. In the preceding example, it would mean substituting :DEPARTURE with :DEPARTURE.HOUR, :DEPARTURE.MINUTE.</p>
<p>Group items used as host variables can contain host tables. In the following example, the group item containing tables is used to INSERT three entries into the SCHEDULE table:</p>
<pre> 01  DEPARTURE.
     05  HOUR    PIC X(2) OCCURS 3 TIMES.
     05  MINUTE  PIC X(2) OCCURS 3 TIMES.
 ...
     EXEC SQL INSERT INTO SCHEDULE (DHOUR, DMINUTE) 
          VALUES (:DEPARTURE) END-EXEC.
</pre>
<p>If VARCHAR=YES is specified, Pro*COBOL will recognize implicit VARCHARs. If the nested group item declaration resembles a VARCHAR host variable, then the entire group item is treated like an elementary item of VARYING type. See <a href="pco14opt.htm#i7627">&#34;VARCHAR&#34;</a>.</p>
<p>When referencing elementary items instead of the group items as host variables elementary names need not be unique because you can qualify them using the following syntax:</p>
<pre><span class="italic">group_item.elementary_item</span>
</pre>
<p>This naming convention is allowed only in SQL statements. It is similar to the IN (or OF) clause in COBOL, examples of which follow:</p>
<pre>          MOVE MINUTE IN DEPARTURE TO MINUTE-OUT.
          DISPLAY HOUR OF DEPARTURE.
</pre>
<p>The COBOL IN (or OF) clause is <span class="italic">not</span> allowed in SQL statements. Qualify elementary names to avoid ambiguity. For example:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  DEPARTURE. 
     05  HOUR    PIC X(2). 
     05  MINUTE  PIC X(2). 
 01  ARRIVAL. 
     05  HOUR    PIC X(2). 
     05  MINUTE  PIC X(2). 
     EXEC SQL END DECLARE SECTION END-EXEC. 
  ...
     EXEC SQL SELECT DHR, DMIN INTO :DEPARTURE.HOUR, :DEPARTURE.MINUTE
         FROM TIMETABLE
         WHERE ...
</pre></div>
<!-- class="sect3" -->
<div id="LNPCB285" class="sect3"><a id="sthref487"></a>
<h4 class="sect3">Restrictions</h4>
<p>A host variable cannot substitute for a column, table, or other object in a SQL statement and must not be an Oracle reserved word. See <a href="pcoacres.htm#g26115">Appendix B, &#34;Reserved Words, Keywords, and Namespaces&#34;</a> for a list of reserved words and keywords.<a id="sthref488"></a><a id="sthref489"></a><a id="sthref490"></a><a id="sthref491"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i18673"></a>
<div id="LNPCB286" class="sect1">
<h2 class="sect1">Indicator Variables</h2>
<p>You can associate any host variable with an optional indicator variable. Each time the host variable is used in a SQL statement, a result code is stored in its associated indicator variable. Thus, indicator variables let you monitor host variables.<a id="sthref492"></a><a id="sthref493"></a></p>
<p>You use indicator variables in the VALUES or SET clause to assign NULLs to input host variables and in the INTO clause to detect NULLs (or truncated values for character columns) in output host variables.</p>
<div id="LNPCB287" class="sect2"><a id="sthref494"></a>
<h3 class="sect2">Using Indicator Variables</h3>
<p><a id="sthref495"></a><a id="sthref496"></a> Here are the values indicator variables can take on.</p>
<div id="LNPCB288" class="sect3"><a id="sthref497"></a>
<h4 class="sect3">On Input</h4>
<p>The values your program can assign to an indicator variable have the following meanings:</p>
<div class="inftblinformal">
<table class="cellalignment4974" title="possible values of input indicator variables" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t11">Indicator Variables</th>
<th class="cellalignment4972" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t11" headers="r1c1-t11">-1</td>
<td class="cellalignment4973" headers="r2c1-t11 r1c2-t11">Oracle will assign a NULL to the column, ignoring the value of the host variable.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t11" headers="r1c1-t11">&gt;=0</td>
<td class="cellalignment4973" headers="r3c1-t11 r1c2-t11">Oracle will assign the value of the host variable to the column.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect3" -->
<div id="LNPCB289" class="sect3"><a id="sthref498"></a>
<h4 class="sect3"><a id="sthref499"></a>On Output</h4>
<p>The values Oracle can assign to an indicator variable have the following meanings:</p>
<div class="inftblinformal">
<table class="cellalignment4974" title="possible values of output indicator variables" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t12">Indicator Variables</th>
<th class="cellalignment4972" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t12" headers="r1c1-t12">-1</td>
<td class="cellalignment4973" headers="r2c1-t12 r1c2-t12">The column value is NULL, so the value of the host variable is indeterminate.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t12" headers="r1c1-t12">0</td>
<td class="cellalignment4973" headers="r3c1-t12 r1c2-t12">Oracle assigned an intact column value to the host variable.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t12" headers="r1c1-t12">&gt;0</td>
<td class="cellalignment4973" headers="r4c1-t12 r1c2-t12">Oracle assigned a truncated column value to the host variable. The integer returned by the indicator variable is the original length of the column value, and SQLCODE in SQLCA is set to zero.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t12" headers="r1c1-t12">-2</td>
<td class="cellalignment4973" headers="r5c1-t12 r1c2-t12">Oracle assigned a truncated column variable to the host variable, but the original column value could not be determined (a LONG column, for example).</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB290" class="sect2"><a id="sthref500"></a>
<h3 class="sect2"><a id="sthref501"></a><a id="sthref502"></a><a id="sthref503"></a><a id="sthref504"></a>Declaring Indicator Variables</h3>
<p>An indicator variable must be explicitly declared as PIC S9(4) COMP and must not be a reserved word. In the following example, you declare an indicator variable named COMM-IND (the name is arbitrary):<a id="sthref505"></a><a id="sthref506"></a><a id="sthref507"></a></p>
<pre> WORKING-STORAGE SECTION.
 ...
 01  EMP-NAME    PIC X(10) VALUE SPACE.
 01  SALARY      PIC S9(5)V99 COMP-3. 
 01  COMMISSION  PIC S9(5)V99 COMP-3. 
 01  COMM-IND    PIC S9(4) COMP. 
 ... 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB291" class="sect2"><a id="sthref508"></a>
<h3 class="sect2">Referencing Indicator Variables</h3>
<p>In SQL statements, an indicator variable must be prefixed with a colon and appended to its associated host variable. In COBOL statements, an indicator variable must <span class="italic">not</span> be prefixed with a colon or appended to its associated host variable. An example follows:<a id="sthref509"></a><a id="sthref510"></a><a id="sthref511"></a></p>
<pre>     EXEC SQL SELECT SAL, COMM 
        INTO :SALARY, :COMMISSION:COMM-IND FROM EMP 
        WHERE EMPNO = :EMP-NUMBER 
     END-EXEC. 
     IF COMM-IND = -1 
        COMPUTE PAY = SALARY 
     ELSE 
        COMPUTE PAY = SALARY + COMMISSION. 
 
</pre>
<p>To improve readability, you can precede any indicator variable with the optional keyword INDICATOR. You must still prefix the indicator variable with a colon. The correct syntax is</p>
<pre>:<span class="italic">host_variable</span>INDICATOR:<span class="italic">indicator_variable</span>
</pre>
<p>and is equivalent to</p>
<pre>:<span class="italic">host_variable:indicator_variable</span>
</pre>
<p>You can use both forms of expression in your host program.</p>
<div id="LNPCB292" class="sect3"><a id="sthref512"></a>
<h4 class="sect3">Use in Where Clauses</h4>
<p>Indicator variables <span class="italic">cannot</span> be used in the WHERE clause to search for NULLs. For example, the following DELETE statement triggers an error at run time:</p>
<pre>*    Set indicator variable. 
     COMM-IND = -1 
     EXEC SQL 
         DELETE FROM EMP WHERE COMM = :COMMISSION:COMM-IND 
     END-EXEC. 
</pre>
<p>The correct syntax follows:</p>
<pre>     EXEC SQL 
         DELETE FROM EMP WHERE COMM IS NULL 
     END-EXEC. 
</pre></div>
<!-- class="sect3" -->
<div id="LNPCB293" class="sect3"><a id="sthref513"></a>
<h4 class="sect3">Avoid Error Messages</h4>
<p>If you SELECT or FETCH a NULL into a host variable that has no indicator, Oracle issues an error message.</p>
<p>You can disable the error message by also specifying UNSAFE_NULL=YES on the command line. For more information, see <a href="pco14opt.htm#g27880">Chapter 14, &#34;Precompiler Options&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB294" class="sect3"><a id="sthref514"></a>
<h4 class="sect3">ANSI Requirements</h4>
<p><a id="i2604"></a>When MODE=ORACLE, if you SELECT or FETCH a truncated column value into a host variable that is not associated with an indicator variable, Oracle issues an error message.</p>
<p>However, when MODE={ANSI | ANSI14 | ANSI13}, no error is generated. Values for indicator variables are discussed in <a href="pco05sql.htm#g16518">Chapter 5, &#34;Embedded SQL&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB295" class="sect3"><a id="sthref515"></a>
<h4 class="sect3">Indicator Variables for Multibyte NCHAR Variables</h4>
<p>Indicator variables for multibyte NCHAR character variables can be used as with any other host variable. However, a positive value (the result of a SELECT or FETCH was truncated) represents the string length in multibyte characters instead of 1-byte characters.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB296" class="sect3"><a id="sthref516"></a>
<h4 class="sect3">Indicator Variables with Host Group Items</h4>
<p>To use indicator variables with a host group item, either setup a second group item that contains an indicator variable for each nullable variable in the group item or use a table of half-word integer variables. You do NOT have to have an indicator variable for each variable in the group item, but the nullable fields which you wish to use indicators for must be placed at the beginning of the data group item. The following indicator group item can be used with the DEPARTURE group item:</p>
<pre> 01  DEPARTURE-IND.
     05  HOUR-IND   PIC S9(4) COMP.
     05  MINUTE-IND PIC S9(4) COMP.
</pre>
<p>If you use an indicator table, you do NOT have to declare a table of as many elements as there are members in the host group item. The following indicator table can be used with the DEPARTURE group item:</p>
<pre> 01 DEPARTURE-IND PIC S9(4) COMP OCCURS 2 TIMES.
</pre>
<p>Reference the indicator group item in the SQL statement in the same way that a host indicator variable is referenced:</p>
<pre>     EXEC SQL SELECT DHOUR, DMINUTE
        INTO :DEPARTURE:DEPARTURE-IND
          FROM SCHEDULE
            WHERE ...
</pre>
<p>When the query completes, the NULL/NOT NULL status of each selected component is available in the host indicator group item. The restrictions on indicator host variables and the ANSI requirements also apply to host indicator group items.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7848"></a>
<div id="LNPCB297" class="sect1">
<h2 class="sect1">VARCHAR Variables</h2>
<p>COBOL string datatypes are fixed length. However, Pro*COBOL lets you declare a variable-length string pseudotype called VARCHAR. A VARCHAR variable is a pseudotype that enables you to specify the exact length of the data stored in the database and to specify the exact length of the data to be passed to the database.</p>
<a id="i5391"></a>
<div id="LNPCB298" class="sect2">
<h3 class="sect2">Declaring VARCHAR Variables</h3>
<p>You define a VARCHAR host variable by adding the keyword VARYING to its declaration, as shown in the following example:<a id="sthref517"></a><a id="sthref518"></a></p>
<pre> 01  ENAME  PIC X(15) VARYING. 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
PIC N and PIC G are not allowed in definitions that use VARYING. To see how to correctly use PIC N and PIC G in VARCHAR variables, see <a href="#i23011">&#34;Implicit VARCHAR Group Items&#34;</a>.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Pro*COBOL adds 4 characters to variable names declared with VARYING. So, if your COBOL compiler supports a variable name length of <code>n</code>, then Pro*COBOL supports a variable name that is four characters less (<code>n</code>-4).</div>
<p>The COBOL VARYING phrase is used in PERFORM and SEARCH statements to increment subscripts and indexes. Do not confuse this with the Pro*COBOL VARYING clause in the preceding example.<a id="sthref519"></a></p>
<p>VARCHAR is an extended Pro*COBOL datatype or pre-declared group item. For example, Pro*COBOL expands the VARCHAR declaration<a id="sthref520"></a></p>
<pre> 01  ENAME  PIC X(15) VARYING. 
</pre>
<p>into a group item with length and string fields, as follows:</p>
<pre> 01  ENAME. 
     05  ENAME-LEN  PIC S9(4) COMP.
     05  ENAME-ARR  PIC X(15). 
</pre>
<p>The <span class="italic">length</span> field (suffixed with -LEN) holds the current length of the value stored in the <span class="italic">string</span> field (suffixed with -ARR). The maximum length in the VARCHAR host-variable declaration must be in the range of 1 to 9,999 bytes.<a id="sthref521"></a></p>
<p>The advantage of using VARCHAR variables is that you can explicitly set and reference the length field. With input host variables, Pro*COBOL reads the value of the length field and uses that many characters of the string field. With output host variables, Pro*COBOL sets the length value to the length of the character string stored in the string field.<a id="sthref522"></a><a id="sthref523"></a></p>
</div>
<!-- class="sect2" -->
<a id="i23011"></a>
<div id="LNPCB299" class="sect2">
<h3 class="sect2">Implicit VARCHAR Group Items</h3>
<p>Pro*COBOL implicitly recognizes some group items as VARCHAR host variables when the precompiler option VARCHAR=YES is specified on the command line. For variable-length single-byte character types, use the following structure (<span class="italic">length</span> expressed in single-byte characters):<a id="sthref524"></a><a id="sthref525"></a><a id="sthref526"></a></p>
<pre>  nn   data-name-1.
       49  data-name-2 PIC S9(4) COMP.
       49  data-name-3 PIC X(length).
</pre>
<p>nn must be 01 through 48.</p>
<p>For variable-length multibyte NCHAR characters, use these formats (length is expressed in double-byte characters):</p>
<pre> nn  DATA-NAME-1.
     49 DATA-NAME-2  PIC  S9(4)  COMP.
     49 DATA-NAME-3  PIC  N(<span class="italic">length</span>).

 nn  DATA-NAME-1.
     49 DATA-NAME-2  PIC  S9(4)  COMP.
     49 DATA-NAME-3  PIC  G(<span class="italic">length</span>).

The elementary items in these group-item structures <span class="italic">must</span> be declared as level 49 for Pro*COBOL to recognize them as VARCHAR host variables.
</pre>
<p>The VARCHAR=YES command line option must be specified for Pro*COBOL to recognize the extended form of the VARCHAR group items. If VARCHAR=NO, then any declarations that resemble the preceding formats will be interpreted as regular group items. If VARCHAR=YES and a group item declaration format looks similar (but not identical) to the extended VARCHAR format, then the item will be interpreted as a regular group item rather than a VARCHAR group item. For example, if VARCHAR=YES is specified and you write the following:</p>
<pre>  01  LASTNAME.
      48 LASTNAME-LEN  PIC S9(4) COMP.
      48 LASTNAME-TEXT PIC X(15).
</pre>
<p>then, since level 48 instead of 49 is used for the group item elements, the item is interpreted as a regular group item rather than a VARCHAR group item.</p>
<p>For more information about the Pro*COBOL VARCHAR option, see <a href="pco14opt.htm#g27880">Chapter 14, &#34;Precompiler Options&#34;</a></p>
</div>
<!-- class="sect2" -->
<a id="i5545"></a>
<div id="LNPCB300" class="sect2">
<h3 class="sect2">Referencing VARCHAR Variables</h3>
<p>In SQL statements, you reference a VARCHAR variable using the group name prefixed with a colon, as the following example shows:<a id="sthref527"></a><a id="sthref528"></a></p>
<pre> WORKING-STORAGE SECTION. 
     ... 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
         ... 
 01  PART-NUMBER  PIC X(5). 
 01  PART-DESC    PIC X(20) VARYING. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 

     EXEC SQL
         SELECT PDESC INTO :PART-DESC FROM PARTS
         WHERE PNUM = :PART-NUMBER 
     END-EXEC. 
</pre>
<p>After the query executes, PART-DESC-LEN holds the actual length of the character string retrieved from the database and stored in PART-DESC-ARR.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i13105"></a>
<div id="LNPCB301" class="sect1">
<h2 class="sect1">Handling Character Data</h2>
<p><a id="i2981"></a>This section explains how Pro*COBOL handles character host variables. There are two kinds of single-byte character host variables and two kinds of multibyte Globalization Support (formerly called NLS) character host variables:<span class="bold"><a id="sthref529"></a><a id="sthref530"></a></span></p>
<ul>
<li>
<p>PIC X(<span class="italic">n</span>) (or PIC X...X)</p>
</li>
<li>
<p>PIC X(<span class="italic">n</span>) VARYING (or PIC X...X VARYING)</p>
</li>
<li>
<p>PIC N(<span class="italic">n</span>) (or PIC N...N) or PIC G(n) (or PIC G...G)&thinsp;</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="i11633"></a>Before using multibyte NCHAR datatypes, verify that the PIC N or PIC G datatype is supported by your COBOL compiler.</div>
<a id="i24085"></a>
<div id="LNPCB302" class="sect2">
<h3 class="sect2"><a id="sthref531"></a><a id="sthref532"></a>Default for PIC X</h3>
<p>The default datatype of PIC X variables is CHARF (was VARCHAR2 before release 8.0.) The precompiler command line option, PICX, is provided for backward compatibility. PICX can be entered only on the command line or in a configuration file. See <a href="pco14opt.htm#BCEFJFDA">&#34;PICX&#34;</a> for more details.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB303" class="sect2"><a id="sthref533"></a>
<h3 class="sect2">Effects of the PICX Option</h3>
<p>The PICX option determines how Pro*COBOL treats data in character strings. The PICX option enables your program to use ANSI fixed-length strings or to maintain compatibility with previous versions of the database server and Pro*COBOL.</p>
<p>You must use PICX=VARCHAR2 (not the default) to obtain the same results as releases of Pro*COBOL before 8.0.<a id="sthref534"></a> Or, use</p>
<pre>     EXEC SQL <span class="italic">varname</span> IS VARCHAR2 END-EXEC.
</pre>
<p>for each variable.<a id="sthref535"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB304" class="sect2"><a id="sthref536"></a>
<h3 class="sect2">Fixed-Length Character Variables</h3>
<p>Fixed-length character variables are declared using the PIC X(<span class="italic">n</span>) and PIC G(n) and PIC N(n) datatypes. These types of variables handle character data based on their roles as input or output variables.</p>
<div id="LNPCB305" class="sect3"><a id="sthref537"></a>
<h4 class="sect3">On Input</h4>
<p>When PICX=VARCHAR2, the program interface strips trailing blanks before sending the value to the database. If you insert into a fixed-length CHAR column, Pro*COBOL re-appends trailing blanks up to the length of the database column. However, if you insert into a variable-length VARCHAR2 column, Pro*COBOL never appends blanks.</p>
<p>When PICX=CHARF, trailing blanks are never stripped.</p>
<p>Host input variables for multibyte Globalization Support data are <span class="italic">not</span> stripped of trailing double-byte spaces. The length component is assumed to be the length of the data in characters, not bytes.</p>
<p>Make sure that the input value is not trailed by extraneous characters. Normally, this is not a problem because when a value is ACCEPTed or MOVEd into a PIC X(<span class="italic">n</span>) variable, COBOL appends blanks up to the length of the variable.</p>
<p><a id="i3030"></a>The following example illustrates the point:</p>
<pre> WORKING-STORAGE SECTION.
     ...
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMPLOYEES. 
     05  EMP-NAME     PIC X(10). 
     05  DEPT-NUMBER  PIC S9(4) VALUE 20 COMP. 
     05  EMP-NUMBER   PIC S9(9) VALUE 9999 COMP. 
     05  JOB-NAME     PIC X(8). 
             ... 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION.
     ...
     DISPLAY &#34;Employee name? &#34; WITH NO ADVANCING. 
     ACCEPT EMP-NAME. 
*    Assume that the name MILLER was entered 
*    EMP-NAME contains &#34;MILLER    &#34; (4 trailing blanks) 
     MOVE &#34;SALES&#34; TO JOB-NAME. 
*    JOB-NAME now contains &#34;SALES   &#34; (3 trailing blanks) 
     EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO, JOB) 
         VALUES (:EMP-NUMBER, :EMP-NAME, :DEPT-NUMBER, :JOB-NAME
     END-EXEC. 
     ...
</pre>
<p>If you precompile the last example with PICX=VARCHAR2 and the target database columns are VARCHAR2, the program interface strips the trailing blanks on input and inserts just the 6-character string &#34;MILLER&#34; and the 5-character string &#34;SALES&#34; into the database. However, if the target database columns are CHAR, the strings are blank-padded to the width of the columns.</p>
<p>If you precompile the last example with PICX=CHARF and the JOB column is defined as CHAR(10), the value inserted into that column is &#34;SALES#####&#34; (five trailing blanks). However, if the JOB column is defined as VARCHAR2(10), the value inserted is &#34;SALES###&#34; (three trailing blanks), because the host variable is declared as PIC X(8). This might not be what you want, so be careful.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB306" class="sect3"><a id="sthref538"></a>
<h4 class="sect3">On Output</h4>
<p>The PICX option has no effect on output to fixed-length character variables. When you use a PIC X(<span class="italic">n</span>) variable as an output host variable, Pro*COBOL blank-pads it. In our example, when your program fetches the string &#34;MILLER&#34; from the database, EMP-NAME contains the value &#34;MILLER####&#34; (with four trailing blanks). This character string can be used without change as input to another SQL statement.<a id="sthref539"></a><a id="sthref540"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BEHEGFIH"></a>
<div id="LNPCB307" class="sect2">
<h3 class="sect2">Varying-Length Variables</h3>
<p>VARCHAR variables handle character data based on their roles as input or output variables.</p>
<div id="LNPCB308" class="sect3"><a id="sthref541"></a>
<h4 class="sect3">On Input</h4>
<p>When you use a VARCHAR variable as an input host variable, your program must assign values to the length and string fields of the expanded VARCHAR declaration, as shown in the following example:<a id="sthref542"></a><a id="sthref543"></a></p>
<pre>     IF ENAME-IND = -1 
         MOVE &#34;NOT AVAILABLE&#34; TO ENAME-ARR 
         MOVE 13 TO ENAME-LEN. 
</pre>
<p>You need not blank-pad the string variable. In SQL operations, Pro*COBOL uses exactly the number of characters given by the length field, counting any spaces.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB309" class="sect3"><a id="sthref544"></a>
<h4 class="sect3">On Output</h4>
<p>When you use a VARCHAR variable as an output host variable, Pro*COBOL sets the length field. An example follows:<a id="sthref545"></a><a id="sthref546"></a></p>
<pre> WORKING-STORAGE SECTION. 
     ... 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMPNO  PIC S9(4) COMP. 
 01  ENAME  PIC X(15) VARYING. 
         ... 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 
     EXEC SQL
         SELECT ENAME INTO :ENAME FROM EMP 
         WHERE EMPNO = :EMPNO 
     END-EXEC. 
     IF ENAME-LEN = 0 
         MOVE FALSE TO VALID-DATA.  
</pre>
<p>An advantage of VARCHAR variables over fixed-length strings is that the length of the value returned by Pro*COBOL is available right away. With fixed-length strings, to get the length of the value, your program must count the number of characters.<a id="sthref547"></a><a id="sthref548"></a></p>
<p><a id="i11898"></a>Host output variables for multibyte NCHAR data are <span class="italic">not</span> padded at all. The length of the buffer is set to the length in bytes, not characters.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When <code>PICN_ENDIAN=OS</code>, the length of the buffer for multibyte NCHAR data is set to the length in characters, not bytes.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i20247"></a>
<div id="LNPCB310" class="sect1">
<h2 class="sect1">Universal ROWIDs<a id="sthref549"></a><a id="sthref550"></a><a id="sthref551"></a></h2>
<p>There are two kinds of table organization used in the database server: <span class="italic">heap tables</span> and <span class="italic">index-organized tables</span>.</p>
<p><a id="sthref552"></a>Heap tables are the default. This is the organization used in all tables before Oracle. The physical row address (ROWID) is a permanent property that is used to identify a row in a heap table. The external character format of the physical ROWID is an 18-byte character string in base-64 encoding.</p>
<p><a id="sthref553"></a><a id="sthref554"></a>An index-organized table does not have physical row addresses as permanent identifiers. A <span class="italic">logical</span> ROWID is defined for these tables. When you use a SELECT ROWID ... statement from an index-organized table the ROWID is an opaque structure that contains the primary key of the table, control information, and an optional physical &#34;guess&#34;. You can use this ROWID in a SQL statement containing a clause such as &#34;WHERE ROWID = ...&#34; to retrieve values from the table.</p>
<p><a id="sthref555"></a><a id="sthref556"></a>The <span class="italic">universal</span> ROWID was introduced in the Oracle 8.1 Database release. Universal ROWID can be used for both physical ROWID and logical ROWID. You can use universal ROWIDs to access data in heap tables, or index-organized tables, since the table organization can change with no effect on applications. The column datatype used for ROWID is UROWID(<span class="italic">length</span>), where length is optional.</p>
<p>Use the universal ROWID in all new applications.</p>
<p>For more information on universal ROWIDs, see <a class="olink CNCPT88811" href="../CNCPT/tablecls.htm#CNCPT88811"><span class="italic">Oracle Database Concepts</span></a>.</p>
<p>Declare a universal ROWID, which uses the pseudotype SQL-ROWID, this way:</p>
<pre> 01  MY-ROWID SQL-ROWID.
</pre>
<p><a id="sthref557"></a><a id="sthref558"></a><a id="sthref559"></a>Memory for the universal ROWID is allocated with the ALLOCATE statement:</p>
<pre>     EXEC SQL ALLOCATE :MY-ROWID END-EXEC.
</pre>
<p>Use MY-ROWID in SQL DML statements like this:</p>
<pre>     EXEC SQL SELECT ROWID INTO :MY-ROWID FROM MYTABLE WHERE ... END-EXEC.
...
     EXEC SQL UPDATE MYTABLE SET ... WHERE ROWID = :MY-ROWID END-EXEC.
...
</pre>
<p>Free the memory when you no longer need it with the FREE directive:</p>
<pre>     EXEC SQL FREE :MY-ROWID END-EXEC.
</pre>
<p>You also have the option of using a character host variable of width between 18 and 4000 as the host bind variable for universal ROWID. Character-based universal ROWIDs are supported for heap tables only for backward compatibility. Because a universal ROWID can be variable length there can be truncation when it is selected.</p>
<p>Use the character variable like this:</p>
<pre> 01  MY-ROWID-CHAR PIC X(4000) VARYING.
... 
     EXEC SQL ALLOCATE :MY-ROWID-CHAR END-EXEC.
     EXEC SQL SELECT ROWID INTO :MY-ROWID-CHAR FROM MYTABLE WHERE ... END-EXEC.
...
     EXEC SQL UPDATE MYTABLE SET ... WHERE ROWID = :MY-ROWID-CHAR END-EXEC.
...
     EXEC SQL FREE :MY-ROWID-CHAR END-EXEC.
</pre>
<p>For an example of a <span class="italic">positioned update</span> using the universal ROWID, see <a href="pco05sql.htm#i6778">&#34;Positioned Update&#34;</a>.</p>
<div id="LNPCB311" class="sect2"><a id="sthref560"></a>
<h3 class="sect2">Subprogram SQLROWIDGET</h3>
<p><a id="sthref561"></a><a id="sthref562"></a>The Oracle subprogram SQLROWIDGET enables you to retrieve the ROWID of the last row inserted, updated, or selected. SQLROWIDGET requires a context or NULL and a ROWID as its arguments.</p>
<p>To use the default context, pass the figurative constant NULL as the first parameter in the call to SQLROWIDGET.</p>
<p>Note that the universal ROWID must be declared and allocated <span class="bold">before</span> the call. The context, if used must be declared and allocated before the call. Here is the syntax:</p>
<pre>     CALL &#34;SQLROWIDGET&#34; USING NULL <span class="italic">rowid</span>. 
</pre>
<p>or</p>
<pre>     CALL &#34;SQLROWIDGET&#34; USING <span class="italic">context rowid</span>. 
</pre>
<p>where</p>
<p><span class="italic">context</span> (IN)</p>
<p>is the runtime context variable, of pseudotype SQL-CONTEXT, or the figurative constant NULL for the default context. For a discussion of runtime contexts, see <a href="pco12thr.htm#i998018">&#34;Embedded SQL Statements and Directives for Runtime Contexts&#34;</a>.</p>
<p><span class="italic">rowid</span> (OUT)</p>
<p>is a universal ROWID variable, of pseudotype SQL-ROWID. When a normal execution finishes, this will point to a valid universal ROWID. In case of an error, <span class="italic">rowid</span> is undefined.</p>
<p>Here is a sample showing its use with the default context:</p>
<pre> 01  MY-ROWID SQL-ROWID.  
 ...
     EXEC SQL ALLOCATE :MY-ROWID END-EXEC. 

* INSERT, or UPDATE or DELETE Goes here: 
 ...
     CALL &#34;SQLROWIDGET&#34; USING NULL MY-ROWID. 
* MY-ROWID now has the universal rowid descriptor for the last row
 ...
     EXEC SQL FREE :MY-ROWID END-EXEC. 
 ... 
</pre>
<p>If your compiler does not allow using the figurative constant NULL in a CALL statement, you can declare a variable with picture S9(9) COMP VALUE 0 and use that with the BY VALUE clause in the call to SQLROWIDGET, as follows:</p>
<pre> 01 NULL-CONTEXT  PIC S9(9) COMP VALUE ZERO.
 01 MY-ROWID SQLROWID.
....
        CALL &#34;SQLROWIDGET&#34; USING BY VALUE NULL-CONTEXT BY REFERENCE MY-ROWID.
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i20335"></a>
<div id="LNPCB312" class="sect1">
<h2 class="sect1">Globalization Support</h2>
<p>Although the widely-used 7-bit or 8-bit ASCII and EBCDIC character sets are adequate to represent the Roman alphabet, some Asian languages, such as Japanese, contain thousands of characters. These languages require 16 bits or more, to represent each character. How does Oracle deal with such dissimilar languages? <a id="sthref563"></a><a id="sthref564"></a></p>
<p>Oracle provides Globalization Support (formerly called National Language Support or NLS), which lets you process single-byte and multibyte character data and convert between character sets. It also lets your applications run in different language environments. With Globalization Support, number and date formats adapt automatically to the language conventions specified for a user session. Thus, Globalization Support enables users around the world to interact with Oracle in their native languages.</p>
<p>You control the operation of language-dependent features by specifying various Globalization Support parameters. You can set default parameter values in the initialization file. <a href="#BEHJBDJI">Table 4-8</a> shows what each Globalization Support parameter specifies.</p>
<div id="LNPCB313" class="tblformal">
<p class="titleintable"><a id="sthref565"></a><a id="BEHJBDJI"></a>Table 4-8 Globalization Support Parameters</p>
<table class="cellalignment4971" title="Globalization Support Parameters" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t17">Globalization Support Parameter</th>
<th class="cellalignment4972" id="r1c2-t17">Specifies</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t17" headers="r1c1-t17">
<p>NLS_LANGUAGE</p>
</td>
<td class="cellalignment4973" headers="r2c1-t17 r1c2-t17">
<p>language-dependent conventions</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t17" headers="r1c1-t17">
<p>NLS_TERRITORY</p>
</td>
<td class="cellalignment4973" headers="r3c1-t17 r1c2-t17">
<p>territory-dependent conventions</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t17" headers="r1c1-t17">
<p>NLS_DATE_FORMAT</p>
</td>
<td class="cellalignment4973" headers="r4c1-t17 r1c2-t17">
<p>date format</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t17" headers="r1c1-t17">
<p>NLS_DATE_LANGUAGE</p>
</td>
<td class="cellalignment4973" headers="r5c1-t17 r1c2-t17">
<p>language for day and month names</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t17" headers="r1c1-t17">
<p>NLS_NUMERIC_CHARACTERS</p>
</td>
<td class="cellalignment4973" headers="r6c1-t17 r1c2-t17">
<p>decimal character and group separator</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t17" headers="r1c1-t17">
<p>NLS_CURRENCY</p>
</td>
<td class="cellalignment4973" headers="r7c1-t17 r1c2-t17">
<p>local currency symbol</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t17" headers="r1c1-t17">
<p>NLS_ISO_CURRENCY</p>
</td>
<td class="cellalignment4973" headers="r8c1-t17 r1c2-t17">
<p>ISO currency symbol</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t17" headers="r1c1-t17">
<p>NLS_SORT</p>
</td>
<td class="cellalignment4973" headers="r9c1-t17 r1c2-t17">
<p>sort sequence</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The main parameters are NLS_LANGUAGE and NLS_TERRITORY. NLS_LANGUAGE specifies the default values for language-dependent features, which include</p>
<ul>
<li>
<p>language for Server messages</p>
</li>
<li>
<p>language for day and month names</p>
</li>
<li>
<p>sort sequence</p>
</li>
</ul>
<p>NLS_TERRITORY specifies the default values for territory-dependent features, which include</p>
<ul>
<li>
<p>Date format</p>
</li>
<li>
<p>Decimal character</p>
</li>
<li>
<p>Group separator</p>
</li>
<li>
<p>Local currency symbol</p>
</li>
<li>
<p>ISO currency symbol</p>
</li>
</ul>
<p>You can control the operation of language-dependent Globalization Support features for a user session by specifying the parameter NLS_LANG as follows<a id="sthref566"></a></p>
<pre>NLS_LANG = <span class="italic">language_territory.character set</span> 
</pre>
<p>where <span class="italic">language</span> specifies the value of NLS_LANGUAGE for the user session, territory specifies the value of NLS_TERRITORY, and <span class="italic">character set</span> specifies the encoding scheme used for the terminal. An <span class="italic">encoding scheme</span> (usually called a character set or code page) is a range of numeric codes that corresponds to the set of characters a terminal can display. It also includes codes that control communication with the terminal.<a id="sthref567"></a><a id="sthref568"></a></p>
<p>You define NLS_LANG as an environment variable (or the equivalent on your system). For example, on UNIX using the C shell, you might define NLS_LANG as follows:</p>
<pre>setenv NLS_LANG French_France.WE8ISO8859P1
 
</pre>
<p>To change the values of Globalization Support parameters during a session, you use the ALTER SESSION statement as follows:</p>
<pre>ALTER SESSION SET <span class="italic">nls_parameter</span> = <span class="italic">value</span> 
</pre>
<p>Pro*COBOL fully supports all the Globalization Support features that allow your applications to process multilingual data stored in an Oracle database. For example, you can declare foreign-language character variables and pass them to string functions such as INSTRB, LENGTHB, and SUBSTRB. These functions have the same syntax as the INSTR, LENGTH, and SUBSTR functions, respectively, but operate on a per-byte basis rather than a per-character basis.<a id="sthref569"></a></p>
<p>You can use the functions NLS_INITCAP, NLS_LOWER, and NLS_UPPER to handle special instances of case conversion. And, you can use the function NLSSORT to specify WHERE-clause comparisons based on linguistic rather than binary ordering. You can even pass Globalization Support parameters to the TO_CHAR, TO_DATE, and TO_NUMBER functions. For more information about Globalization Support, see the <a class="olink NLSPG" href="../NLSPG/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="i20438"></a>
<div id="LNPCB314" class="sect1">
<h2 class="sect1">Unicode Support for Pro*COBOL<a id="sthref570"></a><a id="sthref571"></a><a id="sthref572"></a></h2>
<p>Pro*COBOL does not support source code written with Unicode. If you want to set UTF8 to locale, source code should be written with only ASCII code.</p>
<p>If you want to use Unicode variables, you need to remember the following:</p>
<ul>
<li>
<p>Pro*COBOL does not support &#34;USAGE NATIONAL&#34;. If you want to use Unicode variables, use -C NSYMBOL=&#34;NATIONAL&#34; for compiling Cobol programs with MF Cobol.</p>
</li>
<li>
<p>Unicode can be used with PIC X and PIC N:</p>
<ul>
<li>
<p>AL32UTF8 and UTF8 can be used with PIC X.</p>
</li>
<li>
<p>AL16UTF16 can be used with PIC N.</p>
</li>
</ul>
</li>
<li>
<p>Equate NLS_NCHAR environment variable to the client-side character set used in PIC N. If NLS_NCHAR is not set, then NLS_LANG is used.</p>
</li>
<li>
<p>Equate NLS_LANG environment variable to the client-side character set used in PIC X.</p>
</li>
<li>
<p>AL16UTF16, JA16SJISFIXED and JA16EUCFIXED can be set in NLS_NCHAR.</p>
</li>
<li>
<p>JA16SJIS and JA16SJISTILDE can also be set in NLS_NCHAR.</p>
</li>
<li>
<p>JA16EUC and JA16EUCTILDE cannot be used with NLS_NCHAR.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For the character sets that can be used in NLS_LANG, refer to the Globalization Support Guide.</div>
<p>PICX=charf/varchar2 works for unicode PIC X variables and for PIC N it works with the restrictions mentioned in the aforementioned list.</p>
<div id="LNPCB315" class="sect2"><a id="sthref573"></a>
<h3 class="sect2">NLS_LOCAL=YES Restrictions</h3>
<p>When the precompiler option NLS_LOCAL is YES, the runtime library (SQLLIB) performs blank-padding and blank-stripping for Globalization Support multibyte datatypes.</p>
<p>When NLS_LOCAL=YES, multibyte NCHAR features are not supported within a PL/SQL block. These features include N-quoted character literals and fixed-length character variables.<a id="sthref574"></a><a id="sthref575"></a></p>
<p>These restrictions then apply:</p>
<p><span class="bold">Tables Disallowed.</span> Host variables declared using the PIC N or PIC G datatype must not be tables.</p>
<p><span class="bold">No Odd-Byte Widths.</span> Oracle CHAR columns should not be used to store multibyte NCHAR characters. A run-time error is generated if data with an odd number of bytes is FETCHed from a single-byte column into a multibyte NCHAR host variable.</p>
<p><span class="bold">No Host Variable Equivalencing.</span> Multibyte NCHAR character variables cannot be equivalenced using an EXEC SQL VAR statement.</p>
<p><span class="bold">No Dynamic SQL.</span> Dynamic SQL is not available for NCHAR multibyte character string host variables in Pro*COBOL.</p>
<p>Functions should not be used on columns that store multibyte Globalization Support data.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB316" class="sect2"><a id="sthref576"></a>
<h3 class="sect2">Character Strings in Embedded SQL <a id="sthref577"></a></h3>
<p>A multibyte Globalization Support character string in an embedded SQL statement consists of the letter <span class="italic">N</span>, followed by the string enclosed in single quotes.</p>
<p>For example,</p>
<pre>     EXEC SQL 
         SELECT EMPNO INTO :EMP-NUM FROM EMP
         WHERE ENAME=N&#39;<span class="italic">NLS_string</span>&#39;
     END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB317" class="sect2"><a id="sthref578"></a>
<h3 class="sect2">Embedded DDL</h3>
<p>When the precompiler option, NLS_LOCAL=YES, columns storing NCHAR data cannot be used in embedded data definition language (DDL) statements. This restriction cannot be enforced when precompiling, so the use of extended column types, such as NCHAR, within embedded DDL statements results in an execution error rather than a precompile error.</p>
<p>For more information about these options, see their entries in <a href="pco14opt.htm#g27880">Chapter 14, &#34;Precompiler Options&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB318" class="sect2"><a id="sthref579"></a>
<h3 class="sect2">Blank Padding</h3>
<p>When a Pro*COBOL character variable is defined as a multibyte Globalization Support variable, the following blank padding and blank stripping rules apply, depending on the external datatype of the variable. See the section <a href="#i13105">&#34;Handling Character Data&#34;</a>.</p>
<p><span class="bold">CHARF.</span> Input data is stripped of any trailing double-byte spaces. However, if a string consists only of multibyte spaces, a single multibyte space is left in the buffer to act as a sentinel.</p>
<p>Output host variables are blank padded with multibyte spaces.</p>
<p><span class="bold">VARCHAR.</span> On input, host variables are <span class="italic">not</span> stripped of trailing double-byte spaces. The length component is assumed to be the length of the data in characters, not bytes.</p>
<p>On output, the host variable is not blank padded at all. The length of the buffer is set to the length of the data in characters, not bytes.</p>
<p><span class="bold">STRING</span>/<span class="bold">LONG VARCHAR.</span> These host variables are not supported for Globalization Support data, since they can only be specified using dynamic SQL or datatype equivalencing, neither of which is supported for Globalization Support data.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB319" class="sect2"><a id="sthref580"></a>
<h3 class="sect2">Indicator Variables</h3>
<p>You can use indicator variables with multibyte Globalization Support character variables as use you would with any other variable, except column length values are expressed in characters instead of bytes. For a list of possible values, see <a href="pco05sql.htm#i3617">&#34;Using Indicator Variables&#34;</a>.<a id="sthref581"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB320" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref582"></a>
<h3 class="sect2">Various Combinations of PIC X/PIC N Variables and NCHAR/CHAR Columns</h3>
<p>Pro*Cobol supports various combinations of PIC X /PIC N variables and NCHAR/CHAR columns for select, insert and update statements through command line options <code>charset_picx</code> and <code>charset_picn</code>.</p>
<div id="LNPCB321" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref583"></a>
<h4 class="sect3">PIC X and NCHAR Column</h4>
<p>By default, PIC X variables are converted to the server-side Database Character Set so that these variables can be used with CHAR columns. Therefore, when you use the PIC X variables with NCHAR columns, there can be some data loss. To avoid this, use the following command to set the character set form used by PIC X variables to NCHAR:</p>
<pre>charset_picx=nchar_charset
</pre></div>
<!-- class="sect3" -->
<div id="LNPCB322" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref584"></a>
<h4 class="sect3">PIC N and CHAR column</h4>
<p>By default, PIC N variables are converted to the server-side National Character Set so that these variables can be used with CHAR columns. Therefore, when you use the PIC N variables with NCHAR columns, there may be some performance impact. To avoid this, use the following command to set the character set form used by PIC N variables to CHAR:</p>
<pre>charset_picn=db_charset
</pre>
<p>For more information on CHARSET_PICX and CHARSET_PICN, see section <a href="pco14opt.htm#i12295">Using Pro*COBOL Precompiler Options</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB323" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref585"></a>
<h3 class="sect2">Working With New Options</h3>
<p>The following table shows how to work with the new options:</p>
<ul>
<li>
<p>Host var : Host variables type</p>
</li>
<li>
<p>DB column type : CHAR/NCHAR</p>
</li>
<li>
<p>charset_picx : value for charset_picx option</p>
</li>
<li>
<p>charset_picn : value for charset_picn option</p>
</li>
<li>
<p>NLS_NCHAR : value for NLS_NCHAR</p>
</li>
<li>
<p>data charset : character set of host variables</p>
</li>
</ul>
<div class="inftblinformal">
<table class="cellalignment4974" title="matrix of new options" summary="matrix of new options" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t19">Host var</th>
<th class="cellalignment4972" id="r1c2-t19">DB col type</th>
<th class="cellalignment4972" id="r1c3-t19">charset_picx</th>
<th class="cellalignment4972" id="r1c4-t19">charset_picN</th>
<th class="cellalignment4972" id="r1c5-t19">NLS_NCHAR</th>
<th class="cellalignment4972" id="r1c6-t19">Data charset</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t19" headers="r1c1-t19">PIC X</td>
<td class="cellalignment4973" headers="r2c1-t19 r1c2-t19">CHAR</td>
<td class="cellalignment4973" headers="r2c1-t19 r1c3-t19">nchar_charset</td>
<td class="cellalignment4973" headers="r2c1-t19 r1c4-t19">-</td>
<td class="cellalignment4973" headers="r2c1-t19 r1c5-t19">set</td>
<td class="cellalignment4973" headers="r2c1-t19 r1c6-t19">NLS_NCHAR</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r3c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r3c1-t19 r1c3-t19">db_charset</td>
<td class="cellalignment4973" headers="r3c1-t19 r1c4-t19">-</td>
<td class="cellalignment4973" headers="r3c1-t19 r1c5-t19">set</td>
<td class="cellalignment4973" headers="r3c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r4c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r4c1-t19 r1c3-t19">nchar_charset</td>
<td class="cellalignment4973" headers="r4c1-t19 r1c4-t19">-</td>
<td class="cellalignment4973" headers="r4c1-t19 r1c5-t19">not set</td>
<td class="cellalignment4973" headers="r4c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r5c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r5c1-t19 r1c3-t19">db_charset</td>
<td class="cellalignment4973" headers="r5c1-t19 r1c4-t19">-</td>
<td class="cellalignment4973" headers="r5c1-t19 r1c5-t19">not set</td>
<td class="cellalignment4973" headers="r5c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r6c1-t19 r1c2-t19">NCHAR</td>
<td class="cellalignment4973" headers="r6c1-t19 r1c3-t19">nchar_charset</td>
<td class="cellalignment4973" headers="r6c1-t19 r1c4-t19">-</td>
<td class="cellalignment4973" headers="r6c1-t19 r1c5-t19">set</td>
<td class="cellalignment4973" headers="r6c1-t19 r1c6-t19">NLS_NCHAR</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r7c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r7c1-t19 r1c3-t19">db_charset</td>
<td class="cellalignment4973" headers="r7c1-t19 r1c4-t19">-</td>
<td class="cellalignment4973" headers="r7c1-t19 r1c5-t19">set</td>
<td class="cellalignment4973" headers="r7c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r8c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r8c1-t19 r1c3-t19">nchar_charset</td>
<td class="cellalignment4973" headers="r8c1-t19 r1c4-t19">-</td>
<td class="cellalignment4973" headers="r8c1-t19 r1c5-t19">not set</td>
<td class="cellalignment4973" headers="r8c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r9c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r9c1-t19 r1c3-t19">db_charset</td>
<td class="cellalignment4973" headers="r9c1-t19 r1c4-t19">-</td>
<td class="cellalignment4973" headers="r9c1-t19 r1c5-t19">not set</td>
<td class="cellalignment4973" headers="r9c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t19" headers="r1c1-t19">PIC N</td>
<td class="cellalignment4973" headers="r10c1-t19 r1c2-t19">CHAR</td>
<td class="cellalignment4973" headers="r10c1-t19 r1c3-t19">-</td>
<td class="cellalignment4973" headers="r10c1-t19 r1c4-t19">nchar_charset</td>
<td class="cellalignment4973" headers="r10c1-t19 r1c5-t19">set</td>
<td class="cellalignment4973" headers="r10c1-t19 r1c6-t19">NLS_NCHAR</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r11c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r11c1-t19 r1c3-t19">-</td>
<td class="cellalignment4973" headers="r11c1-t19 r1c4-t19">db_charset</td>
<td class="cellalignment4973" headers="r11c1-t19 r1c5-t19">set</td>
<td class="cellalignment4973" headers="r11c1-t19 r1c6-t19">NLS_NCHAR</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r12c1-t19 r1c2-t19">NCHAR</td>
<td class="cellalignment4973" headers="r12c1-t19 r1c3-t19">-</td>
<td class="cellalignment4973" headers="r12c1-t19 r1c4-t19">nchar_charset</td>
<td class="cellalignment4973" headers="r12c1-t19 r1c5-t19">not set</td>
<td class="cellalignment4973" headers="r12c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r13c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r13c1-t19 r1c3-t19">-</td>
<td class="cellalignment4973" headers="r13c1-t19 r1c4-t19">db_charset</td>
<td class="cellalignment4973" headers="r13c1-t19 r1c5-t19">not set</td>
<td class="cellalignment4973" headers="r13c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r14c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r14c1-t19 r1c3-t19">-</td>
<td class="cellalignment4973" headers="r14c1-t19 r1c4-t19">nchar_charset</td>
<td class="cellalignment4973" headers="r14c1-t19 r1c5-t19">set</td>
<td class="cellalignment4973" headers="r14c1-t19 r1c6-t19">NLS_NCHAR</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r15c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r15c1-t19 r1c3-t19">-</td>
<td class="cellalignment4973" headers="r15c1-t19 r1c4-t19">db_charset</td>
<td class="cellalignment4973" headers="r15c1-t19 r1c5-t19">set</td>
<td class="cellalignment4973" headers="r15c1-t19 r1c6-t19">NLS_NCHAR</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r16c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r16c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r16c1-t19 r1c3-t19">-</td>
<td class="cellalignment4973" headers="r16c1-t19 r1c4-t19">nchar_charset</td>
<td class="cellalignment4973" headers="r16c1-t19 r1c5-t19">not set</td>
<td class="cellalignment4973" headers="r16c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r17c1-t19" headers="r1c1-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r17c1-t19 r1c2-t19">&nbsp;</td>
<td class="cellalignment4973" headers="r17c1-t19 r1c3-t19">-</td>
<td class="cellalignment4973" headers="r17c1-t19 r1c4-t19">db_charset</td>
<td class="cellalignment4973" headers="r17c1-t19 r1c5-t19">not set</td>
<td class="cellalignment4973" headers="r17c1-t19 r1c6-t19">NLS_LANG</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i22939"></a>
<div id="LNPCB324" class="sect1">
<h2 class="sect1">Datatype Conversion</h2>
<p>At precompile time, an external datatype is assigned to each host variable. For example, Pro*COBOL assigns the INTEGER external datatype to host variables of type PIC S9(<span class="italic">n</span>) COMP. At run time, the datatype code of every host variable used in a SQL statement is passed to Oracle. Oracle uses the codes to convert between internal and external datatypes.</p>
<p>Before assigning a SELECTed column value to an output host variable, Oracle must convert the internal datatype of the source column to the datatype of the host variable. Likewise, before assigning or comparing the value of an input host variable to a column, Oracle must convert the external datatype of the host variable to the internal datatype of the target column.<a id="sthref586"></a></p>
<p>Conversions between internal and external datatypes follow the usual data conversion rules. For example, you can convert a CHAR value of 1234 to a PIC S9(4) COMP value. You cannot, however, convert a CHAR value of 123465543 (number too large) or 10F (number not decimal) to a PIC S9(4) COMP value. Likewise, you cannot convert a PIC X(<span class="italic">n</span>) value that contains alphabetic characters to a NUMBER value.</p>
<p>The datatype of the host variable must be compatible with that of the database column. It is your responsibility to make sure that values are convertible. For example, if you try to convert the string value <code>YESTERDAY</code> to a DATE column value, you get an error. Conversions between internal and external datatypes follow the usual data conversion rules. For instance, you can convert a CHAR value of <code>1234</code> to a 2-byte integer. But, you cannot convert a CHAR value of <code>65543</code> (number too large) or <code>10F</code> (number not decimal) to a 2-byte integer. Likewise, you cannot convert a string value that contains alphabetic characters to a NUMBER value.</p>
<p>Number conversion follows the conventions specified by Globalization Support parameters in the Oracle initialization file. For example, your system might be configured to recognize a comma (,) instead of a period (.) as the decimal character. For more information about Globalization Support, see the <a class="olink NLSPG" href="../NLSPG/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a>.</p>
<p>The following table shows the supported conversions between internal and external datatypes.</p>
<div id="LNPCB325" class="tblformal">
<p class="titleintable"><a id="sthref587"></a><a id="g46570"></a>Table 4-9 Conversions Between Internal and External Datatypes</p>
<table class="cellalignment4971" title="Conversions Between Internal and External Datatypes " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t20">External</th>
<th class="cellalignment4972" id="r1c2-t20">Internal</th>
<th class="cellalignment4972" id="r1c3-t20">-</th>
<th class="cellalignment4972" id="r1c4-t20">-</th>
<th class="cellalignment4972" id="r1c5-t20">-</th>
<th class="cellalignment4972" id="r1c6-t20">-</th>
<th class="cellalignment4972" id="r1c7-t20">-</th>
<th class="cellalignment4972" id="r1c8-t20">-</th>
<th class="cellalignment4972" id="r1c9-t20">-</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t20" headers="r1c1-t20">
<p>CHAR</p>
</td>
<td class="cellalignment4973" headers="r2c1-t20 r1c2-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r2c1-t20 r1c3-t20">
<p>I/O (2)</p>
</td>
<td class="cellalignment4973" headers="r2c1-t20 r1c4-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r2c1-t20 r1c5-t20">
<p>I(3)</p>
</td>
<td class="cellalignment4973" headers="r2c1-t20 r1c6-t20">&nbsp;</td>
<td class="cellalignment4973" headers="r2c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r2c1-t20 r1c8-t20">
<p>I/O (3)</p>
</td>
<td class="cellalignment4973" headers="r2c1-t20 r1c9-t20">
<p>I/O (1)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t20" headers="r1c1-t20">
<p>CHARF</p>
</td>
<td class="cellalignment4973" headers="r3c1-t20 r1c2-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r3c1-t20 r1c3-t20">
<p>I/O (2)</p>
</td>
<td class="cellalignment4973" headers="r3c1-t20 r1c4-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r3c1-t20 r1c5-t20">
<p>I (3)</p>
</td>
<td class="cellalignment4973" headers="r3c1-t20 r1c6-t20">&nbsp;</td>
<td class="cellalignment4973" headers="r3c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r3c1-t20 r1c8-t20">
<p>I/O (3)</p>
</td>
<td class="cellalignment4973" headers="r3c1-t20 r1c9-t20">
<p>I/O (1)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t20" headers="r1c1-t20">
<p>CHARZ</p>
</td>
<td class="cellalignment4973" headers="r4c1-t20 r1c2-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r4c1-t20 r1c3-t20">
<p>I/O (2)</p>
</td>
<td class="cellalignment4973" headers="r4c1-t20 r1c4-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r4c1-t20 r1c5-t20">
<p>I (3)</p>
</td>
<td class="cellalignment4973" headers="r4c1-t20 r1c6-t20">&nbsp;</td>
<td class="cellalignment4973" headers="r4c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r4c1-t20 r1c8-t20">
<p>I/O (3)</p>
</td>
<td class="cellalignment4973" headers="r4c1-t20 r1c9-t20">
<p>I/O (1)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t20" headers="r1c1-t20">
<p>DATE</p>
</td>
<td class="cellalignment4973" headers="r5c1-t20 r1c2-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r5c1-t20 r1c3-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r5c1-t20 r1c4-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r5c1-t20 r1c5-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r5c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r5c1-t20 r1c7-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r5c1-t20 r1c8-t20">
<p>--</p>
</td>
<td class="cellalignment4973" headers="r5c1-t20 r1c9-t20">&nbsp;</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t20" headers="r1c1-t20">
<p>DECIMAL</p>
</td>
<td class="cellalignment4973" headers="r6c1-t20 r1c2-t20">
<p>I/O (4)</p>
</td>
<td class="cellalignment4973" headers="r6c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t20 r1c4-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r6c1-t20 r1c5-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r6c1-t20 r1c8-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t20" headers="r1c1-t20">
<p>DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r7c1-t20 r1c2-t20">
<p>I/O (4))</p>
</td>
<td class="cellalignment4973" headers="r7c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t20 r1c4-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r7c1-t20 r1c5-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r7c1-t20 r1c8-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t20" headers="r1c1-t20">
<p>FLOAT</p>
</td>
<td class="cellalignment4973" headers="r8c1-t20 r1c2-t20">
<p>I/O (4)</p>
</td>
<td class="cellalignment4973" headers="r8c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t20 r1c4-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r8c1-t20 r1c5-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r8c1-t20 r1c8-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t20" headers="r1c1-t20">
<p>INTEGER</p>
</td>
<td class="cellalignment4973" headers="r9c1-t20 r1c2-t20">
<p>I/O (4)</p>
</td>
<td class="cellalignment4973" headers="r9c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t20 r1c4-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r9c1-t20 r1c5-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r9c1-t20 r1c8-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t20" headers="r1c1-t20">
<p>LONG</p>
</td>
<td class="cellalignment4973" headers="r10c1-t20 r1c2-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r10c1-t20 r1c3-t20">
<p>I/O (2)</p>
</td>
<td class="cellalignment4973" headers="r10c1-t20 r1c4-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r10c1-t20 r1c5-t20">
<p>I (3.5)</p>
</td>
<td class="cellalignment4973" headers="r10c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r10c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r10c1-t20 r1c8-t20">
<p>I/O (3)</p>
</td>
<td class="cellalignment4973" headers="r10c1-t20 r1c9-t20">
<p>I/O (1)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t20" headers="r1c1-t20">
<p>LONG RAW</p>
</td>
<td class="cellalignment4973" headers="r11c1-t20 r1c2-t20">
<p>O(6)</p>
</td>
<td class="cellalignment4973" headers="r11c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r11c1-t20 r1c4-t20">
<p>I (5,6)</p>
</td>
<td class="cellalignment4973" headers="r11c1-t20 r1c5-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r11c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r11c1-t20 r1c7-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r11c1-t20 r1c8-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r11c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t20" headers="r1c1-t20">
<p>LONG VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r12c1-t20 r1c2-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r12c1-t20 r1c3-t20">
<p>I/O(2)</p>
</td>
<td class="cellalignment4973" headers="r12c1-t20 r1c4-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r12c1-t20 r1c5-t20">
<p>I (3,5)</p>
</td>
<td class="cellalignment4973" headers="r12c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r12c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r12c1-t20 r1c8-t20">
<p>I/O(3))</p>
</td>
<td class="cellalignment4973" headers="r12c1-t20 r1c9-t20">
<p>I/O (1)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t20" headers="r1c1-t20">
<p>LONG VARRAW</p>
</td>
<td class="cellalignment4973" headers="r13c1-t20 r1c2-t20">
<p>I/O (6)</p>
</td>
<td class="cellalignment4973" headers="r13c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r13c1-t20 r1c4-t20">
<p>I (5,6)</p>
</td>
<td class="cellalignment4973" headers="r13c1-t20 r1c5-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r13c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r13c1-t20 r1c7-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r13c1-t20 r1c8-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r13c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t20" headers="r1c1-t20">
<p>NUMBER</p>
</td>
<td class="cellalignment4973" headers="r14c1-t20 r1c2-t20">
<p>I/O (4)</p>
</td>
<td class="cellalignment4973" headers="r14c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r14c1-t20 r1c4-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r14c1-t20 r1c5-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r14c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r14c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r14c1-t20 r1c8-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r14c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t20" headers="r1c1-t20">
<p>RAW</p>
</td>
<td class="cellalignment4973" headers="r15c1-t20 r1c2-t20">
<p>I/O (6)</p>
</td>
<td class="cellalignment4973" headers="r15c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r15c1-t20 r1c4-t20">
<p>I (5,6)</p>
</td>
<td class="cellalignment4973" headers="r15c1-t20 r1c5-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r15c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r15c1-t20 r1c7-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r15c1-t20 r1c8-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r15c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r16c1-t20" headers="r1c1-t20">
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r16c1-t20 r1c2-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r16c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r16c1-t20 r1c4-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r16c1-t20 r1c5-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r16c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r16c1-t20 r1c7-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r16c1-t20 r1c8-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r16c1-t20 r1c9-t20">
<p>I/O</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r17c1-t20" headers="r1c1-t20">
<p>STRING</p>
</td>
<td class="cellalignment4973" headers="r17c1-t20 r1c2-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r17c1-t20 r1c3-t20">
<p>I/O (2)</p>
</td>
<td class="cellalignment4973" headers="r17c1-t20 r1c4-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r17c1-t20 r1c5-t20">
<p>I (3.5)</p>
</td>
<td class="cellalignment4973" headers="r17c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r17c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r17c1-t20 r1c8-t20">
<p>I/O (3)</p>
</td>
<td class="cellalignment4973" headers="r17c1-t20 r1c9-t20">
<p>I/O (1)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r18c1-t20" headers="r1c1-t20">
<p>UNSIGNED</p>
</td>
<td class="cellalignment4973" headers="r18c1-t20 r1c2-t20">
<p>I/O (4)</p>
</td>
<td class="cellalignment4973" headers="r18c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r18c1-t20 r1c4-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r18c1-t20 r1c5-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r18c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r18c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r18c1-t20 r1c8-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r18c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r19c1-t20" headers="r1c1-t20">
<p>VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r19c1-t20 r1c2-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r19c1-t20 r1c3-t20">
<p>I/O (2)</p>
</td>
<td class="cellalignment4973" headers="r19c1-t20 r1c4-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r19c1-t20 r1c5-t20">
<p>I (3,5)</p>
</td>
<td class="cellalignment4973" headers="r19c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r19c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r19c1-t20 r1c8-t20">
<p>I/O (3)</p>
</td>
<td class="cellalignment4973" headers="r19c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r20c1-t20" headers="r1c1-t20">
<p>VARCHAR2</p>
</td>
<td class="cellalignment4973" headers="r20c1-t20 r1c2-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r20c1-t20 r1c3-t20">
<p>I/O (2)</p>
</td>
<td class="cellalignment4973" headers="r20c1-t20 r1c4-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r20c1-t20 r1c5-t20">
<p>I (3)</p>
</td>
<td class="cellalignment4973" headers="r20c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r20c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r20c1-t20 r1c8-t20">
<p>I/O (3)</p>
</td>
<td class="cellalignment4973" headers="r20c1-t20 r1c9-t20">
<p>I/O (1)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r21c1-t20" headers="r1c1-t20">
<p>VARNUM</p>
</td>
<td class="cellalignment4973" headers="r21c1-t20 r1c2-t20">
<p>I/O (4)</p>
</td>
<td class="cellalignment4973" headers="r21c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r21c1-t20 r1c4-t20">
<p>I</p>
</td>
<td class="cellalignment4973" headers="r21c1-t20 r1c5-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r21c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r21c1-t20 r1c7-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r21c1-t20 r1c8-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r21c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r22c1-t20" headers="r1c1-t20">
<p>VARRAW</p>
</td>
<td class="cellalignment4973" headers="r22c1-t20 r1c2-t20">
<p>I/O (6)</p>
</td>
<td class="cellalignment4973" headers="r22c1-t20 r1c3-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r22c1-t20 r1c4-t20">
<p>I (5,6)</p>
</td>
<td class="cellalignment4973" headers="r22c1-t20 r1c5-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r22c1-t20 r1c6-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r22c1-t20 r1c7-t20">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r22c1-t20 r1c8-t20">
<p>I/O</p>
</td>
<td class="cellalignment4973" headers="r22c1-t20 r1c9-t20">
<p>-</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>In the preceding table:</p>
<ul>
<li>
<p>I = input only</p>
</li>
<li>
<p>O = output only</p>
</li>
<li>
<p>I/O = input or output</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
On input, host string must be in Oracle&#39;BBBBBBBB.RRRR.FFFF&#39; format.
<p>On output, column value is returned in same format.</p>
<p>On input, host string must be the default DATE character format.</p>
<p>On output, column value is returned in same format</p>
<p>On input, host string must be in hex format.</p>
<p>On output, column value is returned in same format.</p>
<p>On output, column value must represent a valid number.</p>
<p>On input, length must be less than or equal to 2000.</p>
</div>
</div>
<!-- class="sect1" -->
<a id="i21911"></a>
<div id="LNPCB326" class="sect1">
<h2 class="sect1"><a id="sthref588"></a>Explicit Control Over DATE String Format<a id="sthref589"></a></h2>
<p>When you select a DATE column value into a character host variable, Oracle must convert the internal binary value to an external character value. So, Oracle implicitly calls the SQL function TO_CHAR, which returns a character string in the default date format. The default is set by the Oracle initialization parameter NLS_DATE_FORMAT. To get other information such as the time or Julian date, you must explicitly call TO_CHAR with a format mask.<a id="sthref590"></a><a id="sthref591"></a><a id="sthref592"></a></p>
<p>A conversion is also necessary when you insert a character host value into a DATE column. Oracle implicitly calls the SQL function TO_DATE, which expects the default date format. To insert dates in other formats, you must explicitly call TO_DATE with a format mask.</p>
<p>For compatibility with other versions of SQL Pro*COBOL now provides the following precompiler option to specify date strings:</p>
<p>DATE_FORMAT={ISO | USA | EUR | JIS | LOCAL | &#39;<span class="italic">fmt</span>&#39;</p>
<p>The DATE_FORMAT option must be used on the command line or in a configuration file. The date strings are shown in the following table:</p>
<div id="LNPCB327" class="tblformal">
<p class="titleintable"><a id="sthref593"></a><a id="sthref594"></a>Table 4-10 Formats for Date Strings</p>
<table class="cellalignment4971" title="Formats for Date Strings" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t22">Format Name</th>
<th class="cellalignment4972" id="r1c2-t22">Abbreviation</th>
<th class="cellalignment4972" id="r1c3-t22">Date Format</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t22" headers="r1c1-t22">
<p>International Standards Organization</p>
</td>
<td class="cellalignment4973" headers="r2c1-t22 r1c2-t22">
<p>ISO</p>
</td>
<td class="cellalignment4973" headers="r2c1-t22 r1c3-t22">
<p>yyyy-mm-dd</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t22" headers="r1c1-t22">
<p>USA standard</p>
</td>
<td class="cellalignment4973" headers="r3c1-t22 r1c2-t22">
<p>USA</p>
</td>
<td class="cellalignment4973" headers="r3c1-t22 r1c3-t22">
<p>mm/dd/yyyy</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t22" headers="r1c1-t22">
<p>European standard</p>
</td>
<td class="cellalignment4973" headers="r4c1-t22 r1c2-t22">
<p>EUR</p>
</td>
<td class="cellalignment4973" headers="r4c1-t22 r1c3-t22">
<p>dd.mm.yyyy</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t22" headers="r1c1-t22">
<p>Japanese Industrial Standard</p>
</td>
<td class="cellalignment4973" headers="r5c1-t22 r1c2-t22">
<p>JIS</p>
</td>
<td class="cellalignment4973" headers="r5c1-t22 r1c3-t22">
<p>yyyy-mm-dd</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t22" headers="r1c1-t22">
<p>installation-defined</p>
</td>
<td class="cellalignment4973" headers="r6c1-t22 r1c2-t22">
<p>LOCAL</p>
</td>
<td class="cellalignment4973" headers="r6c1-t22 r1c3-t22">
<p>Any installation-defined form.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>&#39;<span class="italic">fmt</span>&#39; is a date format model, such as &#39;Month dd, yyyy&#39;. See the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for the list of date format model elements. Note that all separately compiled units linked together must use the same DATE_FORMAT value.</p>
</div>
<!-- class="sect1" -->
<a id="i21973"></a>
<div id="LNPCB328" class="sect1">
<h2 class="sect1">Datatype Equivalencing</h2>
<p>Datatype equivalencing lets you control the way Oracle interprets input data and the way Oracle formats output data. You can equivalence supported COBOL datatypes to external datatypes on a variable-by-variable basis.<a id="sthref595"></a><a id="sthref596"></a>&thinsp;</p>
<div id="LNPCB329" class="sect2"><a id="sthref597"></a>
<h3 class="sect2">Usefulness of Equivalencing</h3>
<p>Datatype equivalencing is useful in several ways. For example, suppose you want to use a variable-length string in a COBOL program. You can declare a PIC X host variable, then equivalence it to the external datatype VARCHAR2.<a id="sthref598"></a></p>
<p>In addition, you can use datatype equivalencing to override default datatype conversions. Unless Globalization Support parameters in the initialization file specify otherwise, if you select a DATE column value into a character host variable, Oracle returns a 9-byte string formatted as follows:</p>
<pre>DD-MON-YY 
</pre>
<p>However, if you equivalence the character host variable to the DATE external datatype, Oracle returns a 7-byte value in the internal format.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB330" class="sect2"><a id="sthref599"></a>
<h3 class="sect2">Host Variable Equivalencing</h3>
<p>By default, Pro*COBOL assigns a specific external datatype to every host variable. You can override the default assignments by equivalencing host variables to external datatypes. This is called <span class="italic">host variable equivalencing</span>. <a id="sthref600"></a></p>
<p>The syntax of the VAR embedded SQL statement is:</p>
<pre>      EXEC SQL
          VAR <span class="italic">host_variable</span> IS <span class="italic">datatype</span> [CONVBUFSZ [IS] (<span class="italic">size</span>)]
      END-EXEC
</pre>
<p>or</p>
<pre>      EXEC SQL VAR <span class="italic">host_variable</span> [CONVBUFSZ [IS] (<span class="italic">size</span>)] END-EXEC
</pre>
<p>where <span class="italic">datatype</span> is:</p>
<pre><span class="italic">SQL datatype [ ( {length | precision, scale</span> } ) ]
</pre>
<p>There must be at least one of the two clauses, or both.</p>
<p>where:</p>
<div id="LNPCB331" class="tblformalwidemax">
<p class="titleintable"><a id="sthref601"></a><a id="sthref602"></a>Table 4-11 Host Variable Equivalencing</p>
<table class="cellalignment4974" title="Host Variable Equivalencing " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t23">Variable</th>
<th class="cellalignment4972" id="r1c2-t23">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t23" headers="r1c1-t23">
<p><span class="italic">precision and scale</span></p>
</td>
<td class="cellalignment4973" headers="r2c1-t23 r1c2-t23">
<p>Integer literals that represent, respectively, the number of significant digits and the point at which rounding will occur. For example, a scale of 2 means the value is rounded to the nearest hundredth (3.456 becomes 3.46); a scale of -3 means the number is rounded to the nearest thousand (3456 becomes 3000).<a id="sthref603"></a><a id="sthref604"></a><a id="sthref605"></a></p>
<p>You can specify a <span class="italic">precision</span> of 1 .. 99 and a <span class="italic">scale</span> of -84 .. 99. However, the maximum precision and scale of a database column are 38 and 127, respectively. So, if <span class="italic">precision</span> exceeds 38, you cannot insert the value of <span class="italic">host_variable</span> into a database column. On the other hand, if the scale of a column value exceeds 99, you cannot select or fetch the value into <span class="italic">host_variable</span>.</p>
<p>Specify <span class="italic">precision</span> and <span class="italic">scale</span> only when <span class="italic">type_name</span> is DECIMAL or DISPLAY</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t23" headers="r1c1-t23">
<p><span class="italic">length</span></p>
</td>
<td class="cellalignment4973" headers="r3c1-t23 r1c2-t23">
<p>Input or output host variable (or host table) declared earlier.</p>
<p>The VARCHAR and VARRAW external datatypes have a 2-byte length field followed by an <span class="italic">n</span>-byte data field, where <span class="italic">n</span> lies in the range 1 .. 65533. So, if <span class="italic">type_name</span> is VARCHAR or VARRAW, <span class="italic">host_variable</span> must be at least 3 bytes long.</p>
<p>The LONG VARCHAR and LONG VARRAW external datatypes have a 4-byte length field followed by an <span class="italic">n</span>-byte data field, where <span class="italic">n</span> lies in the range 1 .. 2147483643. So, if <span class="italic">type_name</span> is LONG VARCHAR or LONG VARRAW, <span class="italic">host_variable</span> must be at least 5 bytes long.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t23" headers="r1c1-t23">
<p><span class="italic">size</span></p>
</td>
<td class="cellalignment4973" headers="r4c1-t23 r1c2-t23">
<p>An integer which is the size, in bytes, of a buffer used to perform conversion of the specified host_variable to another character set.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t23" headers="r1c1-t23">
<p><span class="italic">SQL datatype</span></p>
</td>
<td class="cellalignment4973" headers="r5c1-t23 r1c2-t23">
<p>Name of a valid external datatype such as RAW or STRING.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t23" headers="r1c1-t23">
<p><span class="italic">host_variable</span></p>
</td>
<td class="cellalignment4973" headers="r6c1-t23 r1c2-t23">
<p>Input or output host variable or host table declared earlier.</p>
<p>The VARCHAR and VARRAW external datatypes have a 2-byte length field followed by an <span class="italic">n</span>-byte data field, where <span class="italic">n</span> lies in the range 1 .. 65533. So, if <span class="italic">type_name</span> is VARCHAR or VARRAW, <span class="italic">host_variable</span> must be at least 3 bytes long.</p>
<p>The LONG VARCHAR and LONG VARRAW external datatypes have a 4-byte length field followed by an <span class="italic">n</span>-byte data field, where <span class="italic">n</span> lies in the range 1 .. 2147483643. So, if <span class="italic">type_name</span> is LONG VARCHAR or LONG VARRAW, <span class="italic">host_variable</span> must be at least 5 bytes long.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwidemax" -->
<p><a href="#g46394">Table 4-12</a> shows which parameters to use with each external datatype.<a id="sthref606"></a></p>
<p>The CONVBUFSZ clause is explained in <a href="#i22074">&#34;CONVBUFSZ Clause in VAR Statement&#34;</a>.</p>
<p>You cannot use EXEC SQL VAR with NCHAR host variables (those containing PIC G or PIC N clauses).</p>
<p>If DECLARE_SECTION=TRUE then you must have a Declare Section and you must place EXEC SQL VAR statements in the Declare Section.</p>
<p>For a syntax diagram of this statement, see <a href="pcoafemb.htm#i12996">&#34;VAR (Oracle Embedded SQL Directive)&#34;</a>.</p>
<p>When <span class="italic">ext_type_name</span> is FLOAT, use <span class="italic">length</span>; when <span class="italic">ext_type_name</span> is DECIMAL, you must specify <span class="italic">precision</span> and <span class="italic">scale</span> instead of <span class="italic">length</span>.</p>
<p>Host variable equivalencing is useful in several ways. For example, you can use it when you want Oracle to store but not interpret data. Suppose you want to store a host table of 4-byte integers in a RAW database column. Simply equivalence the host table to the RAW external datatype, as follows:<a id="sthref607"></a></p>
<pre> WORKING-STORAGE SECTION. 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMP-TABLES. 
     05  EMP-NUMBER  PIC S9(4) COMP OCCURS 50 TIMES. 
             ... 
*    Reset default datatype (INTEGER) to RAW.
     EXEC SQL VAR EMP-NUMBER IS RAW (200) END-EXEC.
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre>
<p>With host tables, the length you specify must match the buffer size required to hold the table. In the last example, you specified a length of 200, which is the buffer size needed to hold 50 4-byte integers.</p>
<p>You can also declare a group item to be used as a LONG VARCHAR:</p>
<pre> 01  MY-LONG-VARCHAR.
     05 UC-LEN PIC S9(9) COMP.
     05 UC-ARR PIC X(6000).
     EXEC SQL VAR MY-LONG-VARCHAR IS LONG VARCHAR(6000).
</pre>
<a id="i22074"></a>
<div id="LNPCB332" class="sect3">
<h4 class="sect3"><a id="sthref608"></a><a id="sthref609"></a>CONVBUFSZ Clause in VAR Statement</h4>
<p>The EXEC SQL VAR statement can have an optional <span class="italic">CONVBUFSZ</span> clause. You specify the size, in bytes, of the buffer in the runtime library used to perform conversion of the specified host variable between character sets.</p>
<p>When you have not used the CONVBUFSZ clause, the runtime automatically determines a buffer size based on the ratio of the host variable character size (determined by NLS_LANG) and the character size of the database character set. This can sometimes result in the creation of a buffer of LONG size. Databases are allowed to have only one LONG column. An error is raised if there is more than one LONG value.</p>
<p>To avoid such errors, you use a length shorter than the size of a LONG. If a character set conversion results in a value longer than the length specified by CONVBUFSZ, then Pro*COBOL returns an error.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB333" class="sect3"><a id="sthref610"></a>
<h4 class="sect3">An Example</h4>
<p>Suppose you want to select employee names from the EMP table, then pass them to a C-language routine that expects null-terminated strings. You need not explicitly null-terminate the names. Simply equivalence a host variable to the STRING external datatype, as follows:<a id="sthref611"></a></p>
<pre>      EXEC SQL BEGIN DECLARE SECTION END-EXEC.
      ... 
 01   EMP-NAME  PIC X(11).
<span class="bold">     </span>EXEC SQL VAR EMP-NAME IS STRING (11) END-EXEC. 
      EXEC SQL END DECLARE SECTION END-EXEC. 
</pre>
<p>The width of the ENAME column is 10 characters, so you allocate the new <span class="italic">EMP-NAME</span> 11 characters to accommodate the null terminator. (Here, <span class="italic">length</span> is optional because it defaults to the length of the host variable.) When you select a value from the ENAME column into <span class="italic">EMP-NAME</span>, Oracle null-terminates the value for you.</p>
<div id="LNPCB334" class="tblformal">
<p class="titleintable"><a id="sthref612"></a><a id="g46394"></a>Table 4-12 Parameters for Host Variable Equivalencing</p>
<table class="cellalignment4971" title="Parameters for Host Variable Equivalencing " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t24">External Datatype</th>
<th class="cellalignment4972" id="r1c2-t24">Length</th>
<th class="cellalignment4972" id="r1c3-t24">Precision</th>
<th class="cellalignment4972" id="r1c4-t24">Scale</th>
<th class="cellalignment4972" id="r1c5-t24">Default Length</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t24" headers="r1c1-t24">
<p>CHAR</p>
</td>
<td class="cellalignment4973" headers="r2c1-t24 r1c2-t24">
<p>optional</p>
</td>
<td class="cellalignment4973" headers="r2c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r2c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r2c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t24" headers="r1c1-t24">
<p>CHARZ</p>
</td>
<td class="cellalignment4973" headers="r3c1-t24 r1c2-t24">
<p>optional</p>
</td>
<td class="cellalignment4973" headers="r3c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r3c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r3c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t24" headers="r1c1-t24">
<p>DATE</p>
</td>
<td class="cellalignment4973" headers="r4c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r4c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r4c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r4c1-t24 r1c5-t24">
<p>7 bytes</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t24" headers="r1c1-t24">
<p>DECIMAL</p>
</td>
<td class="cellalignment4973" headers="r5c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r5c1-t24 r1c3-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r5c1-t24 r1c4-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r5c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t24" headers="r1c1-t24">
<p>DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r6c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r6c1-t24 r1c3-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r6c1-t24 r1c4-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r6c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t24" headers="r1c1-t24">
<p>DISPLAY TRAILING</p>
</td>
<td class="cellalignment4973" headers="r7c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r7c1-t24 r1c3-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r7c1-t24 r1c4-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r7c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t24" headers="r1c1-t24">
<p>UNSIGNED DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r8c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r8c1-t24 r1c3-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r8c1-t24 r1c4-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r8c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t24" headers="r1c1-t24">
<p>OVERPUNCH TRAILING</p>
</td>
<td class="cellalignment4973" headers="r9c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r9c1-t24 r1c3-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r9c1-t24 r1c4-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r9c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t24" headers="r1c1-t24">
<p>OVERPUNCH LEADING</p>
</td>
<td class="cellalignment4973" headers="r10c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r10c1-t24 r1c3-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r10c1-t24 r1c4-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r10c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t24" headers="r1c1-t24">
<p>FLOAT</p>
</td>
<td class="cellalignment4973" headers="r11c1-t24 r1c2-t24">
<p>optional (4 or 8)</p>
</td>
<td class="cellalignment4973" headers="r11c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r11c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r11c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t24" headers="r1c1-t24">
<p>INTEGER</p>
</td>
<td class="cellalignment4973" headers="r12c1-t24 r1c2-t24">
<p>optional (1, 2, 4 or 8)</p>
</td>
<td class="cellalignment4973" headers="r12c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r12c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r12c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t24" headers="r1c1-t24">
<p>LONG</p>
</td>
<td class="cellalignment4973" headers="r13c1-t24 r1c2-t24">
<p>optional</p>
</td>
<td class="cellalignment4973" headers="r13c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r13c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r13c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t24" headers="r1c1-t24">
<p>LONG RAW</p>
</td>
<td class="cellalignment4973" headers="r14c1-t24 r1c2-t24">
<p>optional</p>
</td>
<td class="cellalignment4973" headers="r14c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r14c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r14c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t24" headers="r1c1-t24">
<p>LONG VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r15c1-t24 r1c2-t24">
<p>required (note <a href="#BEHCEJCI">1</a>)</p>
</td>
<td class="cellalignment4973" headers="r15c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r15c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r15c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r16c1-t24" headers="r1c1-t24">
<p>LONG VARRAW</p>
</td>
<td class="cellalignment4973" headers="r16c1-t24 r1c2-t24">
<p>required (note <a href="#BEHCEJCI">1</a>)</p>
</td>
<td class="cellalignment4973" headers="r16c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r16c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r16c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r17c1-t24" headers="r1c1-t24">
<p>NUMBER</p>
</td>
<td class="cellalignment4973" headers="r17c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r17c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r17c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r17c1-t24 r1c5-t24">
<p>not available</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r18c1-t24" headers="r1c1-t24">
<p>STRING</p>
</td>
<td class="cellalignment4973" headers="r18c1-t24 r1c2-t24">
<p>optional</p>
</td>
<td class="cellalignment4973" headers="r18c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r18c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r18c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r19c1-t24" headers="r1c1-t24">
<p>RAW</p>
</td>
<td class="cellalignment4973" headers="r19c1-t24 r1c2-t24">
<p>optional</p>
</td>
<td class="cellalignment4973" headers="r19c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r19c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r19c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r20c1-t24" headers="r1c1-t24">
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r20c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r20c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r20c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r20c1-t24 r1c5-t24">
<p>18 bytes (see note <a href="#i22364">2</a>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r21c1-t24" headers="r1c1-t24">
<p>UNSIGNED</p>
</td>
<td class="cellalignment4973" headers="r21c1-t24 r1c2-t24">
<p>optional (1, 2, or 4)</p>
</td>
<td class="cellalignment4973" headers="r21c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r21c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r21c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r22c1-t24" headers="r1c1-t24">
<p>VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r22c1-t24 r1c2-t24">
<p>required</p>
</td>
<td class="cellalignment4973" headers="r22c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r22c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r22c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r23c1-t24" headers="r1c1-t24">
<p>VARCHAR2</p>
</td>
<td class="cellalignment4973" headers="r23c1-t24 r1c2-t24">
<p>optional</p>
</td>
<td class="cellalignment4973" headers="r23c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r23c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r23c1-t24 r1c5-t24">
<p>declared length of variable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r24c1-t24" headers="r1c1-t24">
<p>VARNUM</p>
</td>
<td class="cellalignment4973" headers="r24c1-t24 r1c2-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r24c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r24c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r24c1-t24 r1c5-t24">
<p>22 bytes</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r25c1-t24" headers="r1c1-t24">
<p>VARRAW</p>
</td>
<td class="cellalignment4973" headers="r25c1-t24 r1c2-t24">
<p>optional</p>
</td>
<td class="cellalignment4973" headers="r25c1-t24 r1c3-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r25c1-t24 r1c4-t24">
<p>n/a</p>
</td>
<td class="cellalignment4973" headers="r25c1-t24 r1c5-t24">
<p>none</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<a id="i22362"></a>
<ol>
<li id="BEHCEJCI">
<p>If the data field exceeds 65533 bytes, pass -1.</p>
</li>
<li id="i22364">
<p>This length is typical but the default is port-specific.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB335" class="sect2"><a id="sthref613"></a>
<h3 class="sect2">Using the CHARF Datatype Specifier</h3>
<p>You can use the datatype specifier CHARF in VAR statements to equivalence COBOL datatypes to the fixed-length ANSI datatype CHAR.<a id="sthref614"></a><a id="sthref615"></a>s<a id="sthref616"></a><a id="sthref617"></a><a id="sthref618"></a></p>
<p>When PICX=CHARF, specifying the datatype CHAR in a VAR statement equivalences the host-language datatype to the fixed-length ANSI datatype CHAR (Oracle external datatype code 96). However, when PICX=VARCHAR2, the host-language datatype is equivalenced to the variable-length datatype VARCHAR2 (code 1).</p>
<p>However, you can always equivalence host-language datatypes to the fixed-length ANSI datatype CHAR. Simply specify the datatype CHARF in the VAR statement. If you use CHARF, the host-language datatype is equivalenced to the fixed-length ANSI datatype CHAR even when PICX=VARCHAR2.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB336" class="sect2"><a id="sthref619"></a>
<h3 class="sect2">Guidelines</h3>
<p>To input VARNUM or DATE values, you must use the Oracle internal format. Keep in mind that Oracle uses the internal format to output VARNUM and DATE values.<a id="sthref620"></a><a id="sthref621"></a></p>
<p>After selecting a column value into a VARNUM host variable, you can check the first byte to get the length of the value. <a href="#g46835">Table 4-1</a> gives some examples of returned VARNUM values.</p>
<div id="LNPCB337" class="tblformal">
<p class="titleintable"><a id="sthref622"></a><a id="sthref623"></a>Table 4-13 VARNUM Examples</p>
<table class="cellalignment4971" title="VARNUM Examples" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t25">Decimal Value</th>
<th class="cellalignment4972" id="r1c2-t25">Length Byte</th>
<th class="cellalignment4972" id="r1c3-t25">Exponent Byte</th>
<th class="cellalignment4972" id="r1c4-t25">Mantissa Bytes</th>
<th class="cellalignment4972" id="r1c5-t25">Terminator Byte</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t25" headers="r1c1-t25">
<p>5</p>
</td>
<td class="cellalignment4973" headers="r2c1-t25 r1c2-t25">
<p>2</p>
</td>
<td class="cellalignment4973" headers="r2c1-t25 r1c3-t25">
<p>193</p>
</td>
<td class="cellalignment4973" headers="r2c1-t25 r1c4-t25">
<p>6</p>
</td>
<td class="cellalignment4973" headers="r2c1-t25 r1c5-t25">
<p>n/a</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t25" headers="r1c1-t25">
<p>-5</p>
</td>
<td class="cellalignment4973" headers="r3c1-t25 r1c2-t25">
<p>3</p>
</td>
<td class="cellalignment4973" headers="r3c1-t25 r1c3-t25">
<p>62</p>
</td>
<td class="cellalignment4973" headers="r3c1-t25 r1c4-t25">
<p>96</p>
</td>
<td class="cellalignment4973" headers="r3c1-t25 r1c5-t25">
<p>102</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t25" headers="r1c1-t25">
<p>2767</p>
</td>
<td class="cellalignment4973" headers="r4c1-t25 r1c2-t25">
<p>3</p>
</td>
<td class="cellalignment4973" headers="r4c1-t25 r1c3-t25">
<p>194</p>
</td>
<td class="cellalignment4973" headers="r4c1-t25 r1c4-t25">
<p>28, 68</p>
</td>
<td class="cellalignment4973" headers="r4c1-t25 r1c5-t25">
<p>n/a</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t25" headers="r1c1-t25">
<p>-2767</p>
</td>
<td class="cellalignment4973" headers="r5c1-t25 r1c2-t25">
<p>4</p>
</td>
<td class="cellalignment4973" headers="r5c1-t25 r1c3-t25">
<p>61</p>
</td>
<td class="cellalignment4973" headers="r5c1-t25 r1c4-t25">
<p>74, 34</p>
</td>
<td class="cellalignment4973" headers="r5c1-t25 r1c5-t25">
<p>102</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t25" headers="r1c1-t25">
<p>100000</p>
</td>
<td class="cellalignment4973" headers="r6c1-t25 r1c2-t25">
<p>2</p>
</td>
<td class="cellalignment4973" headers="r6c1-t25 r1c3-t25">
<p>195</p>
</td>
<td class="cellalignment4973" headers="r6c1-t25 r1c4-t25">
<p>11</p>
</td>
<td class="cellalignment4973" headers="r6c1-t25 r1c5-t25">
<p>n/a</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t25" headers="r1c1-t25">
<p>1234567</p>
</td>
<td class="cellalignment4973" headers="r7c1-t25 r1c2-t25">
<p>5</p>
</td>
<td class="cellalignment4973" headers="r7c1-t25 r1c3-t25">
<p>196</p>
</td>
<td class="cellalignment4973" headers="r7c1-t25 r1c4-t25">
<p>2, 24, 46, 68</p>
</td>
<td class="cellalignment4973" headers="r7c1-t25 r1c5-t25">
<p>n/a</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>For converting DATE values, see <a href="#i21911">&#34;Explicit Control Over DATE String Format&#34;</a>.</p>
<p>If no Oracle external datatype suits your needs exactly, use a VARCHAR2-based or RAW-based external datatype.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB338" class="sect2"><a id="sthref624"></a>
<h3 class="sect2">RAW and LONG RAW Values</h3>
<p>When you select a RAW or LONG RAW column value into a character host variable, Oracle must convert the internal binary value to an external character value. In this case, Oracle returns each binary byte of RAW or LONG RAW data as a pair of characters. Each character represents the hexadecimal equivalent of a nibble (half a byte). For example, Oracle returns the binary byte 11111111 as the pair of characters &#34;FF&#34;. The SQL function RAWTOHEX performs the same conversion.<a id="sthref625"></a><a id="sthref626"></a><a id="sthref627"></a><a id="sthref628"></a></p>
<p>A conversion is also necessary when you insert a character host value into a RAW or LONG RAW column. Each pair of characters in the host variable must represent the hexadecimal equivalent of a binary byte. If a character does not represent the hexadecimal value of a nibble, Oracle issues an error message.</p>
<p>For more information about datatype conversion, see <a href="#i22676">&#34;Sample Program 4: Datatype Equivalencing&#34;</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDBGHB"></a>
<div id="LNPCB339" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Platform Endianness Support</h2>
<p>Oracle stored unicode data (UTF16) is always in big endian. Currently, client applications run on different platforms. Linux and Windows have little endian representation and Solaris has big endian representation. When UTF16 data is inserted or selected, Pro*Cobol doesn&#39;t convert endian form between server and the client. This leads to corrupted UTF16 (UCS2) strings in the PIC N variable.</p>
<p>Platform endianness (Little endian for Linux and Windows, Big endian for Solaris) in PIC N variables can be maintained using the command line option <code>picn_endian</code>.</p>
<p class="subhead2"><a id="LNPCB340"></a>New Command Line Option</p>
<pre>picn_endian={BIG|OS}
</pre>
<p>If picn_endian=big, then PIC N variables are bound with character set ID AL16UTF16.</p>
<p>If picn_endian=os then PIC N variables are bound with character set ID UCS2.</p>
<p>The default value for this option is &#34;big&#34; to preserve the current behavior. This option is ignored if NLS_NCHAR is not AL16UTF16.</p>
<p>Character set form for PIC N variables can be set by using the existing Pro*Cobol command line option:</p>
<pre>charset_picn={nchar_charset|db_charset}
</pre>
<p>For more information about varchar host variable if <code>PICN_ENDIAN=OS</code>, see <a href="#BEHEGFIH">&#34;Varying-Length Variables&#34;</a>.</p>
</div>
<!-- class="sect1" -->
<a id="i22676"></a>
<div id="LNPCB341" class="sect1">
<h2 class="sect1">Sample Program 4: Datatype Equivalencing<a id="sthref629"></a><a id="sthref630"></a></h2>
<p>After connecting to Oracle, this program creates a database table named IMAGE in the SCOTT account, then simulates the insertion of bitmap images of employee numbers into the table. Datatype equivalencing lets the program use the Oracle external datatype LONG RAW to represent the images. Later, when the user enters an employee number, the number&#39;s &#34;bitmap&#34; is selected from the IMAGE table and displayed on the terminal screen.<a id="sthref631"></a></p>
<pre>* This program simulates the storage and retrieval of bitmap images into table
* IMAGE, which is created in the SCOTT account after logging on to ORACLE.
* Datatype equivalencing allows an ORACLE external type of LONG RAW to be
* specified for the programs representation of the images.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. DTY-EQUIV.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
       01  EMP-REC-VARS.
           05  EMP-NUMBER    PIC S9(4) COMP.
           05  EMP-NAME      PIC X(10) VARYING.
           05  SALARY        PIC S9(6)V99
                               DISPLAY SIGN LEADING SEPARATE.
           05  COMMISSION    PIC S9(6)V99
                               DISPLAY SIGN LEADING SEPARATE.
           05  COMM-IND      PIC S9(4) COMP.

           EXEC SQL VAR SALARY IS DISPLAY(8,2) END-EXEC.
           EXEC SQL VAR COMMISSION IS DISPLAY(8,2) END-EXEC.

       01  BUFFER-VAR.
           05  BUFFER        PIC X(8192).
           EXEC SQL VAR BUFFER IS LONG RAW END-EXEC.

       01  INEMPNO           PIC S9(4) COMP.
           EXEC SQL END DECLARE SECTION END-EXEC.
           EXEC SQL INCLUDE SQLCA END-EXEC.

       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME    PIC X(10).
           05  D-SALARY      PIC $Z(4)9.99.
           05  D-COMMISSION  PIC $Z(4)9.99.
           05  D-INEMPNO     PIC 9(4).
       01  REPLY             PIC X(10).
       01  INDX              PIC S9(9) COMP.
       01  PRT-QUOT          PIC S9(9) COMP.
       01  PRT-MOD           PIC S9(9) COMP.

       PROCEDURE DIVISION.

       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR
               DO PERFORM SQL-ERROR END-EXEC.

           PERFORM LOGON.
           DISPLAY &#34;OK TO DROP THE IMAGE TABLE? (Y/N)  &#34;
               WITH NO ADVANCING.

           ACCEPT REPLY.

           IF (REPLY NOT = &#34;Y&#34;) AND (REPLY NOT = &#34;y&#34;)
               GO TO SIGN-OFF-EXIT.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           EXEC SQL DROP TABLE IMAGE END-EXEC.
           DISPLAY &#34; &#34;.
           IF (SQLCODE = 0) DISPLAY
               &#34;TABLE IMAGE DROPPED - CREATING NEW TABLE.&#34;
           ELSE IF (SQLCODE = -942) DISPLAY
               &#34;TABLE IMAGE DOES NOT EXIST - CREATING NEW TABLE.&#34;
           ELSE PERFORM SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR
               DO PERFORM SQL-ERROR END-EXEC.
           EXEC SQL CREATE TABLE IMAGE
               (EMPNO NUMBER(4) NOT NULL, BITMAP LONG RAW)
           END-EXEC.
           EXEC SQL DECLARE EMPCUR CURSOR FOR
               SELECT EMPNO, ENAME FROM EMP
           END-EXEC.
           EXEC SQL OPEN EMPCUR END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY
             &#34;INSERTING BITMAPS INTO IMAGE FOR ALL EMPLOYEES ...&#34;.
           DISPLAY &#34; &#34;.

       INSERT-LOOP.
           EXEC SQL WHENEVER NOT FOUND GOTO NOT-FOUND END-EXEC.
           EXEC SQL FETCH EMPCUR
               INTO :EMP-NUMBER, :EMP-NAME
           END-EXEC.
           MOVE EMP-NAME-ARR TO D-EMP-NAME.
           DISPLAY &#34;EMPLOYEE &#34;, D-EMP-NAME WITH NO ADVANCING.
           PERFORM GET-IMAGE.
           EXEC SQL INSERT INTO IMAGE
               VALUES (:EMP-NUMBER, :BUFFER)
           END-EXEC.
           DISPLAY &#34; IS DONE!&#34;.
           MOVE SPACES TO EMP-NAME-ARR.
           GO TO INSERT-LOOP.

       NOT-FOUND.
           EXEC SQL CLOSE EMPCUR END-EXEC.
           EXEC SQL COMMIT WORK END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY
             &#34;DONE INSERTING BITMAPS.  NEXT, LET&#39;S DISPLAY SOME.&#34;.

       DISP-LOOP.
           MOVE 0 TO INEMPNO.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ENTER EMPLOYEE NUMBER (0 TO QUIT):  &#34;
               WITH NO ADVANCING.

           ACCEPT D-INEMPNO.

           MOVE D-INEMPNO TO INEMPNO.
           IF (INEMPNO = 0)
               GO TO SIGN-OFF.
           EXEC SQL WHENEVER NOT FOUND GOTO NO-EMP END-EXEC.
           EXEC SQL SELECT EMP.EMPNO, ENAME, SAL, NVL(COMM, 0), BITMAP
               INTO :EMP-NUMBER, :EMP-NAME, :SALARY,
                    :COMMISSION:COMM-IND, :BUFFER
               FROM EMP, IMAGE
               WHERE EMP.EMPNO = :INEMPNO
                 AND EMP.EMPNO = IMAGE.EMPNO
           END-EXEC.
           DISPLAY &#34; &#34;.
           PERFORM SHOW-IMAGE.
           MOVE EMP-NAME-ARR TO D-EMP-NAME.
           MOVE SALARY TO D-SALARY.
           MOVE COMMISSION TO D-COMMISSION.
           DISPLAY &#34;EMPLOYEE &#34;, D-EMP-NAME, &#34; HAS SALARY &#34;, D-SALARY
               WITH NO ADVANCING.
           IF COMM-IND = -1
               DISPLAY &#34; AND NO COMMISSION.&#34;
           ELSE
               DISPLAY &#34; AND COMMISSION &#34;, D-COMMISSION, &#34;.&#34;
           END-IF.
           MOVE SPACES TO EMP-NAME-ARR.
           GO TO DISP-LOOP.

       NO-EMP.
           DISPLAY &#34;NOT A VALID EMPLOYEE NUMBER - TRY AGAIN.&#34;.
           GO TO DISP-LOOP.

       LOGON.
           MOVE &#34;SCOTT&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;TIGER&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER:  &#34;, USERNAME-ARR.
           DISPLAY &#34; &#34;.

       GET-IMAGE.
           PERFORM MOVE-IMAGE
               VARYING INDX FROM 1 BY 1 UNTIL INDX &gt; 8192.

       MOVE-IMAGE.
           STRING &#39;*&#39; DELIMITED BY SIZE
               INTO BUFFER
               WITH POINTER INDX.
           DIVIDE 256 INTO INDX
               GIVING PRT-QUOT REMAINDER PRT-MOD.
           IF (PRT-MOD = 0) DISPLAY &#34;.&#34; WITH NO ADVANCING.

       SHOW-IMAGE.
           PERFORM VARYING INDX FROM 1 BY 1 UNTIL INDX &gt; 10
               DISPLAY &#34;               *************************&#34;
           END-PERFORM.
           DISPLAY &#34; &#34;.

       SIGN-OFF.
           EXEC SQL DROP TABLE IMAGE END-EXEC.
       SIGN-OFF-EXIT.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY.&#34;.
           DISPLAY &#34; &#34;.
           EXEC SQL COMMIT WORK RELEASE END-EXEC.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:  &#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pco03dbc.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pco05sql.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>