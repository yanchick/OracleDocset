<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77856"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Embedded%20SQL"></a><title>Embedded SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:15Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pco04dat.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pco06pls.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">10/27</span> <!-- End Header -->
<div id="LNPCB005" class="chapter"><a id="g16518"></a> <a id="i10958"></a>
<h1 class="chapter"><span class="secnum">5</span> Embedded SQL</h1>
<p>This chapter describes the basic techniques of embedded SQL programming. Topics are:</p>
<ul>
<li>
<p><a href="#i3766">Using Host Variables</a></p>
</li>
<li>
<p><a href="#i3617">Using Indicator Variables</a></p>
</li>
<li>
<p><a href="#i3311">The Basic SQL Statements</a></p>
</li>
<li>
<p><a href="#i3779">Cursors</a></p>
</li>
<li>
<p><a href="#i13177">Scrollable Cursors</a></p>
</li>
<li>
<p><a href="#CHDHFAEE">Flexible B Area Length</a></p>
</li>
<li>
<p><a href="#CHDDDBJH">Fix Execution Plans</a></p>
</li>
<li>
<p><a href="#i7431">Sample Program 2: Cursor Operations</a></p>
</li>
</ul>
<a id="i3766"></a>
<div id="LNPCB342" class="sect1">
<h2 class="sect1">Using Host Variables</h2>
<p>Use host variables to pass data and status information to your program from the database, and to pass data to the database.<a id="sthref632"></a><a id="sthref633"></a></p>
<a id="i5616"></a>
<div id="LNPCB343" class="sect2">
<h3 class="sect2">Output Versus Input Host Variables</h3>
<p>Depending on how they are used, host variables are called output or input host variables. Host variables in the INTO clause of a SELECT or FETCH statement are called <span class="italic">output</span> host variables because they hold column values output by Oracle. Oracle assigns the column values to corresponding output host variables in the INTO clause.<a id="sthref634"></a><a id="sthref635"></a><a id="sthref636"></a></p>
<p>All other host variables in a SQL statement are called <span class="italic">input</span> host variables because your program inputs their values to Oracle. For example, you use input host variables in the VALUES clause of an INSERT statement and in the SET clause of an UPDATE statement. They are also used in the WHERE, HAVING, and FOR clauses. In fact, input host variables can appear in a SQL statement wherever a value or expression is allowed.<a id="sthref637"></a></p>
<p>You cannot use input host variables to supply SQL keywords or the names of database objects. Thus, you cannot use input host variables in data definition statements (sometimes called <span class="italic">DDL</span>) such as ALTER, CREATE, and DROP. In the following example, the DROP TABLE statement is <span class="italic">invalid</span>:<a id="sthref638"></a><a id="sthref639"></a><a id="sthref640"></a><a id="sthref641"></a></p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
         01 TABLE-NAME    PIC X(30) VARYING.
          ... 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ...
     DISPLAY &#39;Table name? &#39;. 
     ACCEPT TABLE-NAME. 
     EXEC SQL DROP TABLE :TABLE-NAME END-EXEC.
*  -- host variable not allowed 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
In an ORDER BY clause, you <span class="italic">can</span> use a host variable, but it is treated as a constant or literal, and hence the contents of the host variable have no effect. For example, the SQL statement:
<pre>     EXEC SQL SELECT ENAME, EMPNO INTO :NAME, :NUMBER
         FROM EMP
         ORDER BY :ORD
     END-EXEC.
</pre>
<p>appears to contain an input host variable, <span class="italic">ORD</span>. However, the host variable in this case is treated as a constant, and regardless of the value of ORD, no ordering is done.</p>
</div>
<p>Before Oracle executes a SQL statement containing input host variables, your program must assign values to them. Consider the following example:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01     EMP-NUMBER   PIC S9(4) COMP. 
 01     EMP-NAME     PIC X(20) VARYING.
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ...
* -- get values for input host variables 
     DISPLAY &#39;Employee number? &#39;. 
     ACCEPT EMP-NUMBER. 
     DISPLAY &#39;Employee name? &#39;. 
     ACCEPT EMP-NAME. 
     EXEC SQL INSERT INTO EMP (EMPNO, ENAME) 
         VALUES (:EMP-NUMBER, :EMP-NAME) 
     END-EXEC. 
</pre>
<p>Notice that the input host variables in the VALUES clause of the INSERT statement are prefixed with colons.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3617"></a>
<div id="LNPCB344" class="sect1">
<h2 class="sect1">Using Indicator Variables</h2>
<p>You can associate any host variable with an optional indicator variable. Each time the host variable is used in a SQL statement, a result code is stored in its associated indicator variable. Thus, indicator variables let you monitor host variables.<a id="sthref642"></a></p>
<p>You use indicator variables in the VALUES or SET clause to assign NULLs to input host variables and in the INTO clause to detect NULLs or truncated values in output host variables.</p>
<div id="LNPCB345" class="sect2"><a id="sthref643"></a>
<h3 class="sect2">Input Variables</h3>
<p>For input host variables, the values your program can assign to an indicator variable have the following meanings:</p>
<div class="inftblinformal">
<table class="cellalignment4974" title="possible values of input indicator variables" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t3">Variable</th>
<th class="cellalignment4972" id="r1c2-t3">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t3" headers="r1c1-t3">-1</td>
<td class="cellalignment4973" headers="r2c1-t3 r1c2-t3">Oracle will assign a NULL to the column, ignoring the value of the host variable.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t3" headers="r1c1-t3">&gt;= 0</td>
<td class="cellalignment4973" headers="r3c1-t3 r1c2-t3">Oracle will assigns the value of the host variable to the column.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<div id="LNPCB346" class="sect2"><a id="sthref644"></a>
<h3 class="sect2"><a id="sthref645"></a>Output Variables</h3>
<p>For output host variables, the values Oracle can assign to an indicator variable have the following meanings:</p>
<div class="inftblinformal">
<table class="cellalignment4974" title="possible values of output indicator variables" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t4"><span class="bold">Variable</span></th>
<th class="cellalignment4972" id="r1c2-t4">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t4" headers="r1c1-t4">-2</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c2-t4">Oracle assigned a truncated column value to the host variable, but could not assign the original length of the column value to the indicator variable because the number was too large.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t4" headers="r1c1-t4">-1</td>
<td class="cellalignment4973" headers="r3c1-t4 r1c2-t4">The column value is NULL, so the value of the host variable is indeterminate.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t4" headers="r1c1-t4">0</td>
<td class="cellalignment4973" headers="r4c1-t4 r1c2-t4">Oracle assigned an intact column value to the host variable.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t4" headers="r1c1-t4"><span class="italic">&gt;</span> 0</td>
<td class="cellalignment4973" headers="r5c1-t4 r1c2-t4">Oracle assigned a truncated column value to the host variable, assigned the original column length (expressed in characters, instead of bytes, for multibyte Globalization Support host variables) to the indicator variable, and set SQLCODE in the SQLCA to zero.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>Remember, an indicator variable must be declared as a 2-byte integer and, in SQL statements, must be prefixed with a colon and appended to its host variable (unless you use the keyword INDICATOR).</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB347" class="sect2"><a id="sthref646"></a>
<h3 class="sect2">Inserting NULLs</h3>
<p>You can use indicator variables to insert NULLs. Before the insert, for each column you want to be NULL, set the appropriate indicator variable to -1, as shown in the following example:<a id="sthref647"></a><a id="sthref648"></a></p>
<pre>      MOVE -1 TO IND-COMM.
      EXEC SQL INSERT INTO EMP (EMPNO, COMM) 
          VALUES (:EMP-NUMBER, :COMMISSION:IND-COMM)
      END-EXEC. 
</pre>
<p>The indicator variable <span class="italic">IND-COMM</span> specifies that a NULL is to be stored in the COMM column.</p>
<p>You can hard-code the NULL instead, as follows:<a id="sthref649"></a></p>
<pre>      EXEC SQL INSERT INTO EMP (EMPNO, COMM) 
          VALUES (:EMP-NUMBER, NULL)
      END-EXEC. 
</pre>
<p>But this is less flexible.</p>
<p>Typically, you insert NULLs conditionally, as the next example shows:</p>
<pre>      DISPLAY &#39;Enter employee number or 0 if not available: &#39;
          WITH NO ADVANCING.
      ACCEPT EMP-NUMBER. 
      IF EMP-NUMBER = 0
         MOVE -1 TO IND-EMPNUM 
      ELSE 
          MOVE 0 TO IND-EMPNUM
      END-IF.
      EXEC SQL INSERT INTO EMP (EMPNO, SAL) 
         VALUES (:EMP-NUMBER:IND-EMPNUM, :SALARY)
      END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB348" class="sect2"><a id="sthref650"></a>
<h3 class="sect2">Handling Returned NULLs</h3>
<p>You can also use indicator variables to manipulate returned NULLs, as the following example shows:<a id="sthref651"></a><a id="sthref652"></a></p>
<pre>      EXEC SQL SELECT ENAME, SAL, COMM 
         INTO :EMP-NAME, :SALARY, :COMMISSION:IND-COMM 
          FROM EMP
          WHERE EMPNO = :EMP_NUMBER
      END-EXEC. 
      IF IND-COMM = -1 
          MOVE SALARY TO PAY. 
*   -- commission is null; ignore it 
      ELSE 
          ADD SALARY TO COMMISSION GIVING PAY.
      END-IF. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB349" class="sect2"><a id="sthref653"></a>
<h3 class="sect2">Fetching NULLs</h3>
<p>Using the precompiler option UNSAFE_NULL=YES, you can select or fetch NULLs into a host variable that lacks an indicator variable, as the following example shows:</p>
<pre>* --  assume that commission is NULL 
      EXEC SQL SELECT ENAME, SAL, COMM 
         INTO :EMP-NAME, :SALARY, :COMMISSION 
         FROM EMP 
         WHERE EMPNO = :EMP-NUMBER
      END-EXEC. 
</pre>
<p>SQLCODE in the SQLCA is set to zero indicating that Oracle executed the statement without detecting an error or exception.</p>
<p>Without an indicator variable there is no way to know whether or not a NULL was returned. The value of the host variable is undefined. If you do not use indicator variables, set the precompiler option UNSAFE_NULL=YES. Oracle therefore advises that UNSAFE_NULL=YES only be used to upgrade existing programs and that indicator variables be used for all new programs.</p>
<p>When UNSAFE_NULL=NO, if you select or fetch NULLs into a host variable that lacks an indicator variable, Oracle issues an error message.</p>
<p>For more information, see <a href="pco14opt.htm#i10781">&#34;UNSAFE_NULL&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB350" class="sect2"><a id="sthref654"></a>
<h3 class="sect2">Testing for NULLs</h3>
<p>You can use indicator variables in the WHERE clause to test for NULLs, as the following example shows:</p>
<pre>      EXEC SQL SELECT ENAME, SAL 
         INTO :EMP-NAME, :SALARY 
         FROM EMP 
         WHERE :COMMISSION:IND-COMM IS NULL ... 
</pre>
<p>However, you cannot use a relational operator to compare NULLs with each other or with other values. For example, the following SELECT statement fails if the COMM column contains one or more NULLs:<a id="sthref655"></a><a id="sthref656"></a><a id="sthref657"></a></p>
<pre>      EXEC SQL SELECT ENAME, SAL 
         INTO :EMP-NAME, :SALARY 
          FROM EMP 
          WHERE COMM = :COMMISSION:IND-COMM
      END-EXEC. 
</pre>
<p>The next example shows how to compare values for equality when some of them might be NULLs:</p>
<pre>      EXEC SQL SELECT ENAME, SAL 
         INTO :EMP_NAME, :SALARY 
         FROM EMP 
         WHERE (COMM = :COMMISSION) OR ((COMM IS NULL) AND 
             (:COMMISSION:IND-COMM IS NULL))
      END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB351" class="sect2"><a id="sthref658"></a>
<h3 class="sect2">Fetching Truncated Values</h3>
<p>If a value is truncated when fetched into a host variable, no error is generated.<a id="sthref659"></a> In all cases a WARNING will be signaled (see <a href="pco08err.htm#i14854">&#34;Warning Flags&#34;</a>). if an indicator variable is used with a character string, when a value is truncated, the indicator variable is set to the length of the value in the database. Note that no warning is flagged if a numeric value is truncated.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3311"></a>
<div id="LNPCB352" class="sect1">
<h2 class="sect1">The Basic SQL Statements</h2>
<p>Executable SQL statements let you query, manipulate, and control Oracle data and create, define, and maintain Oracle objects such as tables, views, and indexes. This chapter focuses on statements which manipulate data in database tables (sometimes called <span class="italic">DML</span>) and cursor control statements.</p>
<p>The following SQL statements let you query and manipulate Oracle data:</p>
<div class="inftblinformal">
<table class="cellalignment4974" title="four sql statements and their descriptions" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t5">SQL Statements</th>
<th class="cellalignment4972" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t5" headers="r1c1-t5">SELECT</td>
<td class="cellalignment4973" headers="r2c1-t5 r1c2-t5">Returns rows from one or more tables.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t5" headers="r1c1-t5">INSERT</td>
<td class="cellalignment4973" headers="r3c1-t5 r1c2-t5">Adds new rows to a table.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t5" headers="r1c1-t5">UPDATE</td>
<td class="cellalignment4973" headers="r4c1-t5 r1c2-t5">Modifies rows in a table.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t5" headers="r1c1-t5">DELETE</td>
<td class="cellalignment4973" headers="r5c1-t5 r1c2-t5">Removes rows from a table.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>When executing a data manipulation statement such as INSERT, UPDATE, or DELETE, you want to know how many rows have been updated as well as whether it succeeded. To find out, you simply check the SQLCA. (Executing any SQL statement sets the SQLCA variables.) You can check in the following two ways:</p>
<ul>
<li>
<p>Implicit checking with the WHENEVER statement</p>
</li>
<li>
<p>Explicit checking of SQLCA variables</p>
</li>
</ul>
<p>Alternatively, when MODE={ANSI | ANSI14}, you can check the status variable SQLSTATE or SQLCODE. For more information, see <a href="pco08err.htm#i8662">&#34;ANSI SQLSTATE Variable&#34;</a>.</p>
<p>When executing a SELECT statement (query), however, you must also deal with the rows of data it returns. Queries can be classified as follows:<a id="sthref660"></a></p>
<ul>
<li>
<p>queries that return no rows (that is, merely check for existence)</p>
</li>
<li>
<p>queries that return only one row</p>
</li>
<li>
<p>queries that return more than one row</p>
</li>
</ul>
<p>Queries that return more than one row require an explicitly declared cursor or cursor variable. The following embedded SQL statements let you define and control an explicit cursor:</p>
<div class="inftblinformal">
<table class="cellalignment4974" title="four sql statements and their descriptions" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t6">SQL Statements</th>
<th class="cellalignment4972" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t6" headers="r1c1-t6">DECLARE</td>
<td class="cellalignment4973" headers="r2c1-t6 r1c2-t6">Names the cursor and associates it with a query.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t6" headers="r1c1-t6">OPEN</td>
<td class="cellalignment4973" headers="r3c1-t6 r1c2-t6">Executes the query and identifies the active set.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t6" headers="r1c1-t6">FETCH</td>
<td class="cellalignment4973" headers="r4c1-t6 r1c2-t6">Advances the cursor and retrieves each row in the active set, one by one.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t6" headers="r1c1-t6">CLOSE</td>
<td class="cellalignment4973" headers="r5c1-t6 r1c2-t6">Disables the cursor (the active set becomes undefined.)</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p><a id="sthref661"></a>In the coming sections, first you learn how to code INSERT, UPDATE, DELETE, and single-row SELECT statements. Then, you progress to multirow SELECT statements. For a detailed discussion of each statement and its clauses, see the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span>.</a></p>
<div id="LNPCB353" class="sect2"><a id="sthref662"></a>
<h3 class="sect2">Selecting Rows</h3>
<p>Querying the database is a common SQL operation. To issue a query you use the SELECT statement. In the following example, you query the EMP table:<a id="sthref663"></a><a id="sthref664"></a></p>
<pre>      EXEC SQL SELECT ENAME, JOB, SAL + 2000 
         INTO :emp_name, :JOB-TITLE, :SALARY
         FROM EMP 
         WHERE EMPNO = :EMP-NUMBER
      END-EXEC. 
</pre>
<p>The column names and expressions following the keyword SELECT make up the <span class="italic">select list</span>. The select list in our example contains three items. Under the conditions specified in the WHERE clause (and following clauses, if present), Oracle returns column values to the host variables in the INTO clause. The number of items in the select list should equal the number of host variables in the INTO clause, so there is a place to store every returned value.<a id="sthref665"></a><a id="sthref666"></a><a id="sthref667"></a><a id="sthref668"></a></p>
<p>In the simplest case, when a query returns one row, its form is that shown in the last example (in which EMPNO is a unique key). However, if a query can return more than one row, you must fetch the rows using a cursor or select them into a host array.<a id="sthref669"></a></p>
<p>If a query is written to return only one row but might actually return several rows, the result depends on how you specify the option SELECT_ERROR. When SELECT_ERROR=YES (the default), Oracle issues an message if more than one row is returned.<a id="sthref670"></a></p>
<p>When SELECT_ERROR=NO, a row is returned and Oracle generates no error.</p>
<div id="LNPCB354" class="sect3"><a id="sthref671"></a>
<h4 class="sect3">Available Clauses</h4>
<p>You can use all of the following standard SQL clauses in your SELECT statements: INTO, FROM, WHERE, CONNECT BY, START WITH, GROUP BY, HAVING, ORDER BY, and FOR UPDATE OF.<a id="sthref672"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i5615"></a>
<div id="LNPCB355" class="sect2">
<h3 class="sect2">Inserting Rows</h3>
<p>You use the INSERT statement to add rows to a table or view. In the following example, you add a row to the EMP table:<a id="sthref673"></a><a id="sthref674"></a></p>
<pre>      EXEC SQL INSERT INTO EMP (EMPNO, ENAME, SAL, DEPTNO) 
         VALUES (:EMP_NUMBER, :EMP-NAME, :SALARY, :DEPT-NUMBER)
      END-EXEC. 
</pre>
<p>Each column you specify in the column list must belong to the table named in the INTO clause. The VALUES clause specifies the row of values to be inserted. The values can be those of constants, host variables, SQL expressions, or pseudocolumns, such as USER and SYSDATE.</p>
<p>The number of values in the VALUES clause must equal the number of names in the column list. You can omit the column list if the VALUES clause contains a value for each column in the table in the same order they were defined by CREATE TABLE, but this is not recommended because a table&#39;s definition can change.</p>
</div>
<!-- class="sect2" -->
<a id="i6276"></a>
<div id="LNPCB356" class="sect2">
<h3 class="sect2">DML Returning Clause<a id="sthref675"></a><a id="sthref676"></a></h3>
<p><a id="sthref677"></a><a id="sthref678"></a><a id="sthref679"></a><a id="sthref680"></a><a id="sthref681"></a><a id="sthref682"></a><a id="sthref683"></a>The INSERT, UPDATE, and DELETE statements can have an optional <a id="sthref684"></a><span class="italic">DML returning clause</span> which returns column value expressions <span class="italic">expr</span>, into host variables <span class="italic">hv</span>, with host indicator variables <span class="italic">iv.</span> The returning clause has this syntax:</p>
<pre>{RETURNING | RETURN} {expr [,expr]}
    INTO {:hv [[INDICATOR]:iv] [, :hv [[INDICATOR]:iv]]}
</pre>
<p>The number of expressions must equal the number of host variables. This clause eliminates the need for selecting the rows after an INSERT or UPDATE, and before a DELETE when you need to record that information for your application. The <code>DML returning clause</code> eliminates inefficient network round-trips, extra processing, and server memory. You will also note, for example, when a trigger inserts default values or a primary key value.</p>
<p>The returning_clause is not allowed with a subquery. It is only allowed after the VALUES clause.</p>
<p>For example, our INSERT could have a clause at its end such as:</p>
<pre>RETURNING EMPNO, ENAME, DEPTNO INTO :NEW-EMP-NUMBER, :NEW-EMP-NAME, :DEPT
</pre>
<p>See the DELETE, INSERT, and UPDATE entries in the appendix <a href="pcoafemb.htm#g65199">Appendix E, &#34;Embedded SQL Statements and Precompiler Directives&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB357" class="sect2"><a id="sthref685"></a>
<h3 class="sect2">Using Subqueries</h3>
<p>A <span class="italic">subquery</span> is a nested SELECT statement. Subqueries let you conduct multi-part searches. They can be used to<a id="sthref686"></a></p>
<ul>
<li>
<p>supply values for comparison in the WHERE, HAVING, and START WITH clauses of SELECT, UPDATE, and DELETE statements</p>
</li>
<li>
<p>define the set of rows to be inserted by a CREATE TABLE or INSERT statement</p>
</li>
<li>
<p>define values for the SET clause of an UPDATE statement</p>
</li>
</ul>
<p>For example, to copy rows from one table to another, replace the VALUES clause in an INSERT statement with a subquery, as follows:<a id="sthref687"></a><a id="sthref688"></a><a id="sthref689"></a></p>
<pre>     EXEC SQL INSERT INTO EMP2 (EMPNO, ENAME, SAL, DEPTNO) 
         SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP 
         WHERE JOB = :JOB-TITLE
     END-EXEC. 
</pre>
<p>Notice how the INSERT statement uses the subquery to obtain intermediate results.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB358" class="sect2"><a id="sthref690"></a>
<h3 class="sect2">Updating Rows</h3>
<p>You use the UPDATE statement to change the values of specified columns in a table or view. In the following example, you update the SAL and COMM columns in the EMP table:<a id="sthref691"></a><a id="sthref692"></a></p>
<pre>      EXEC SQL UPDATE EMP 
         SET SAL = :SALARY, COMM = :COMMISSION 
         WHERE EMPNO = :EMP-NUMBER
      END-EXEC. 
</pre>
<p>You can use the optional WHERE clause to specify the conditions under which rows are updated. See <a href="#i1964">&#34;Using the WHERE Clause&#34;</a>.<a id="sthref693"></a></p>
<p>The SET clause lists the names of one or more columns for which you must provide values. You can use a subquery to provide the values, as the following example shows:<a id="sthref694"></a><a id="sthref695"></a><a id="sthref696"></a><a id="sthref697"></a><a id="sthref698"></a></p>
<pre>      EXEC SQL UPDATE EMP 
      SET SAL = (SELECT AVG(SAL)*1.1 FROM EMP WHERE DEPTNO = 20)
      WHERE EMPNO = :EMP-NUMBER
      END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB359" class="sect2"><a id="sthref699"></a>
<h3 class="sect2">Deleting Rows</h3>
<p>You use the DELETE statement to remove rows from a table or view. In the following example, you delete all employees in a given department from the EMP table:<a id="sthref700"></a><a id="sthref701"></a></p>
<pre>      EXEC SQL DELETE FROM EMP 
         WHERE DEPTNO = :DEPT-NUMBER
      END-EXEC. 
</pre>
<p>You can use the optional WHERE clause to specify the condition under which rows are deleted.<a id="sthref702"></a><a id="sthref703"></a></p>
</div>
<!-- class="sect2" -->
<a id="i1964"></a>
<div id="LNPCB360" class="sect2">
<h3 class="sect2">Using the WHERE Clause</h3>
<p>You use the WHERE clause to select, update, or delete only those rows in a table or view that meet your search condition. The WHERE-clause <span class="italic">search condition</span> is a Boolean expression, which can include scalar host variables, host arrays (not in SELECT statements), and subqueries.<a id="sthref704"></a><a id="sthref705"></a><a id="sthref706"></a><a id="sthref707"></a></p>
<p>If you omit the WHERE clause, all rows in the table or view are processed. If you omit the WHERE clause in an UPDATE or DELETE statement, Oracle sets SQLWARN(5) in the SQLCA to &#39;W&#39; to warn that all rows were processed.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3779"></a>
<div id="LNPCB361" class="sect1">
<h2 class="sect1">Cursors</h2>
<p>To process a SQL statement, Oracle opens a work area called a <span class="italic">private SQL area</span>. The private SQL area stores information needed to execute the SQL statement. An identifier called a <span class="italic">cursor</span> lets you name a SQL statement, access the information in its private SQL area, and, to some extent, control its processing.<a id="sthref708"></a><a id="sthref709"></a></p>
<p>For static SQL statements, there are two types of cursors: <span class="italic">implicit</span> and <span class="italic">explicit</span>. Oracle implicitly declares a cursor for all data definition and data manipulation statements, including SELECT statements that use the INTO clause.</p>
<p>The set of rows retrieved is called the <span class="italic">results set</span>; its size depends on how many rows meet the query search condition. You use an explicit cursor to identify the row currently being processed, which is called the <span class="italic">current row</span>.<a id="sthref710"></a><a id="sthref711"></a><a id="sthref712"></a></p>
<p>When a query returns multiple rows, you can explicitly define a cursor to<a id="sthref713"></a><a id="sthref714"></a></p>
<ul>
<li>
<p>Process beyond the first row returned by the query</p>
</li>
<li>
<p>Keep track of which row is currently being processed</p>
</li>
</ul>
<p>A cursor identifies the current row in the set of rows returned by the query. This allows your program to process the rows one at a time. The following statements let you define and manipulate a cursor:<a id="sthref715"></a></p>
<ul>
<li>
<p>DECLARE</p>
</li>
<li>
<p>OPEN</p>
</li>
<li>
<p>FETCH</p>
</li>
<li>
<p>CLOSE</p>
</li>
</ul>
<p>First you use the DECLARE statement (more precisely, a directive) to name the cursor and associate it with a query.<a id="sthref716"></a><a id="sthref717"></a></p>
<p>The OPEN statement executes the query and identifies all the rows that meet the query search condition. These rows form a set called the active set of the cursor. After opening the cursor, you can use it to retrieve the rows returned by its associated query.<a id="sthref718"></a></p>
<p>Rows of the active set are retrieved one by one (unless you use host arrays). You use a FETCH statement to retrieve the current row in the active set. You can execute FETCH repeatedly until all rows have been retrieved.</p>
<p>When done fetching rows from the active set, you disable the cursor with a CLOSE statement, and the active set becomes undefined.</p>
<a id="i3478"></a>
<div id="LNPCB362" class="sect2">
<h3 class="sect2">Declaring a Cursor</h3>
<p>You use the DECLARE statement to define a cursor by giving it a name, as the following example shows:<a id="sthref719"></a><a id="sthref720"></a><a id="sthref721"></a><a id="sthref722"></a></p>
<pre>      EXEC SQL DECLARE EMPCURSOR CURSOR FOR 
         SELECT ENAME, EMPNO, SAL 
         FROM EMP 
         WHERE DEPTNO = :DEPT_NUMBER
      END-EXEC. 
</pre>
<p>The cursor name is an identifier used by the precompiler, <span class="italic">not</span> a host or program variable, and should not be declared in a COBOL statement. Therefore, cursor names cannot be passed from one precompilation unit to another. Cursor names <span class="italic">cannot</span> be hyphenated. They can be any length, but only the first 31 characters are significant. For ANSI compatibility, use cursor names no longer than 18 characters. <a id="sthref723"></a><a id="sthref724"></a></p>
<p>The precompiler option CLOSE_ON_COMMIT is provided for use in the command line or in a configuration file. Any cursor not declared with the WITH HOLD clause is closed after a COMMIT or ROLLBACK when CLOSE_ON_COMMIT=YES. See <a href="pco03dbc.htm#i4014">&#34;WITH HOLD Clause in DECLARE CURSOR Statements&#34;</a>, and <a href="pco14opt.htm#i8871">&#34;CLOSE_ON_COMMIT&#34;</a>.<a id="sthref725"></a><a id="sthref726"></a></p>
<p>If MODE is specified at a higher level than CLOSE_ON_COMMIT, then MODE takes precedence. The defaults are MODE=ORACLE and CLOSE_ON_COMMIT=NO. If you specify MODE=ANSI then any cursors not using the WITH HOLD clause will be closed on COMMIT. The application will run more slowly because cursors are closed and re-opened many times. Setting CLOSE_ON_COMMIT=NO when MODE=ANSI results in performance improvement. To see how macro options such as MODE affect micro options such as CLOSE_ON_COMMIT, see <a href="pco14opt.htm#i7608">&#34;Precedence of Option Values&#34;</a>.</p>
<p>The SELECT statement associated with the cursor cannot include an INTO clause. Rather, the INTO clause and list of output host variables are part of the FETCH statement.</p>
<p>Because it is declarative, the DECLARE statement must physically (not just logically) precede all other SQL statements referencing the cursor. That is, forward references to the cursor are not allowed. In the following example, the OPEN statement is misplaced:<a id="sthref727"></a><a id="sthref728"></a></p>
<pre>      EXEC SQL OPEN EMPCURSOR END-EXEC.
*    -- MISPLACED OPEN STATEMENT
      EXEC SQL DECLARE EMPCURSOR CURSOR FOR 
         SELECT ENAME, EMPNO, SAL 
         FROM EMP 
         WHERE ENAME = :EMP-NAME
      END-EXEC.
</pre>
<p>The cursor control statements (DECLARE, OPEN, FETCH, CLOSE) must all occur within the same precompiled unit. For example, you cannot declare a cursor in source file A.PCO, then open it in source file B.PCO.<a id="sthref729"></a><a id="sthref730"></a></p>
<p>Your host program can declare as many cursors as it needs. However, in a given file, every DECLARE statement must be unique. That is, you cannot declare two cursors with the same name in one precompilation unit, even across blocks or procedures, because the scope of a cursor is global within a file.<a id="sthref731"></a><a id="sthref732"></a></p>
<p><a id="sthref733"></a>For users of MODE=ANSI or CLOSE_ON_COMMIT=YES, the WITH HOLD clause can be used in a DECLARE section to override the behavior defined by the two options. With these options set, the behavior will be for all cursors to be closed when a COMMIT is issued. This can have performance implications due to the overhead of re-opening the cursor to continue processing. The careful use of WITH HOLD can speed up programs that need to conform to the ANSI standard for precompilers in most respects.</p>
</div>
<!-- class="sect2" -->
<a id="i3312"></a>
<div id="LNPCB363" class="sect2">
<h3 class="sect2">Opening a Cursor</h3>
<p>Use the OPEN statement to execute the query and identify the active set. In the following example, a cursor named <span class="italic">EMPCURSOR</span> is opened.<a id="sthref734"></a><a id="sthref735"></a></p>
<pre>     EXEC SQL OPEN EMPCURSOR END-EXEC. 
</pre>
<p>OPEN positions the cursor just before the first row of the active set. However, none of the rows is actually retrieved at this point. That will be done by the FETCH statement.</p>
<p>Once you open a cursor, the query&#39;s input host variables are not reexamined until you reopen the cursor. Thus, the active set does not change. To change the active set, you must reopen the cursor.<a id="sthref736"></a><a id="sthref737"></a></p>
<p>The amount of work done by OPEN depends on the values of three precompiler options: HOLD_CURSOR, RELEASE_CURSOR, and MAXOPENCURSORS. For more information, see their alphabetized entries in <a href="pco14opt.htm#i12295">&#34;Using Pro*COBOL Precompiler Options&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB364" class="sect2"><a id="sthref738"></a>
<h3 class="sect2">Fetching from a Cursor</h3>
<p>You use the FETCH statement to retrieve rows from the active set and specify the output host variables that will contain the results. Recall that the SELECT statement associated with the cursor cannot include an INTO clause. Rather, the INTO clause and list of output host variables are part of the FETCH statement. In the following example, you fetch into three host variables:<a id="sthref739"></a><a id="sthref740"></a><a id="sthref741"></a><a id="sthref742"></a><a id="sthref743"></a></p>
<pre>      EXEC SQL FETCH EMPCURSOR 
         INTO :EMP-NAME, :EMP-NUMBER, :SALARY
      END-EXEC. 
</pre>
<p>The cursor must have been previously declared and opened. The first time you execute FETCH, the cursor moves from before the first row in the active set to the first row. This row becomes the current row. Each subsequent execution of FETCH advances the cursor to the next row in the active set, changing the current row. The cursor can only move forward in the active set. To return to a row that has already been fetched, you must reopen the cursor, then begin again at the first row of the active set.</p>
<p>If you want to change the active set, you must assign new values to the input host variables in the query associated with the cursor, then reopen the cursor. When MODE=ANSI, you must close the cursor before reopening it.<a id="sthref744"></a></p>
<p>As the next example shows, you can fetch from the same cursor using different sets of output host variables. However, corresponding host variables in the INTO clause of each FETCH statement must have the same datatype.</p>
<pre>     EXEC SQL DECLARE EMPCURSOR CURSOR FOR 
         SELECT ENAME, SAL FROM EMP WHERE DEPTNO = 20
     END-EXEC.
     ... 
     EXEC SQL OPEN EMPCURSOR END-EXEC.
     EXEC SQL WHENEVER NOT FOUND DO ...
 LOOP. 
     EXEC SQL FETCH EMPCURSOR INTO :EMP-NAME1, :SAL1 END-EXEC 
     EXEC SQL FETCH EMPCURSOR INTO :EMP-NAME2, :SAL2 END-EXEC 
     EXEC SQL FETCH EMPCURSOR INTO :EMP-NAME3, :SAL3 END-EXEC 
     ...
     GO TO LOOP.
     ... 
 END-PERFORM. 
</pre>
<p>If the active set is empty or contains no more rows, FETCH returns the &#34;no data found&#34; Oracle warning code to SQLCODE in the SQLCA (if MODE=ANSI then the optional SQLSTATE variable will also be set.) The status of the output host variables is indeterminate. (In a typical program, the WHENEVER NOT FOUND statement detects this error.) To reuse the cursor, you must reopen it.<a id="sthref745"></a><a id="sthref746"></a><a id="sthref747"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB365" class="sect2"><a id="sthref748"></a>
<h3 class="sect2">Closing a Cursor</h3>
<p>When finished fetching rows from the active set, you close the cursor to free the resources, such as storage, acquired by opening the cursor. When a cursor is closed, parse locks are released. What resources are freed depends on how you specify the options HOLD_CURSOR and RELEASE_CURSOR. In the following example, you close the cursor named <span class="italic">EMPCURSOR</span>:<a id="sthref749"></a><a id="sthref750"></a></p>
<pre>     EXEC SQL CLOSE EMPCURSOR END-EXEC. 
</pre>
<p>You cannot fetch from a closed cursor because its active set becomes undefined. If necessary, you can reopen a cursor (with new values for the input host variables, for example).</p>
<p>When CLOSE_ON_COMMIT=NO (the default when MODE=ORACLE), issuing a COMMIT or ROLLBACK will only close cursors declared using the FOR UPDATE clause or referred to by the CURRENT OF clause. Other cursors that are not affected by the COMMIT or ROLLBACK statement, remain open, if they are open already. However, when CLOSE_ON_COMMIT=YES (the default when MODE=ANSI), issuing a COMMIT or ROLLBACK closes <span class="italic">all</span> cursors.<a id="sthref751"></a> For more information, see <a href="pco14opt.htm#i8871">&#34;CLOSE_ON_COMMIT&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i2016"></a>
<div id="LNPCB366" class="sect2">
<h3 class="sect2">Using the CURRENT OF Clause</h3>
<p>You use the CURRENT OF <span class="italic">cursor_name</span> clause in a DELETE or UPDATE statement to refer to the latest row fetched from the named cursor. The cursor must be open and positioned on a row. If no fetch has been done or if the cursor is not open, the CURRENT OF clause results in an error and processes no rows.<a id="sthref752"></a><a id="sthref753"></a></p>
<p>The FOR UPDATE OF clause is optional when you declare a cursor that is referenced in the CURRENT OF clause of an UPDATE or DELETE statement. The CURRENT OF clause signals the precompiler to add a FOR UPDATE clause if necessary. For more information, see<a href="pco07tab.htm#i3051">&#34;Mimicking the CURRENT OF Clause&#34;</a>.</p>
<p>In the following example, you use the CURRENT OF clause to refer to the latest row fetched from a cursor named <span class="italic">EMPCURSOR</span>:<a id="sthref754"></a></p>
<pre>     EXEC SQL DECLARE EMPCURSOR CURSOR FOR 
         SELECT ENAME, SAL FROM EMP WHERE JOB = &#39;CLERK&#39;
     END-EXEC. 
     ... 
     EXEC SQL OPEN EMPCURSOR END-EXEC.
     EXEC SQL WHENEVER NOT FOUND DO ... 
 LOOP.
     EXEC SQL FETCH EMPCURSOR INTO :EMP-NAME, :SALARY
     END-EXEC. 
     ... 
     EXEC SQL UPDATE EMP SET SAL = :NEW-SALARY 
         WHERE CURRENT OF EMPCURSOR
     END-EXEC.
     GO TO LOOP.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB367" class="sect2"><a id="sthref755"></a>
<h3 class="sect2">Restrictions</h3>
<p>An explicit FOR UPDATE OF or an implicit FOR UPDATE acquires exclusive row locks. All rows are locked at the open, not as they are fetched, and are released when you commit or rollback. If you try to fetch from a FOR UPDATE cursor after a commit, Oracle generates an error.<a id="sthref756"></a><a id="sthref757"></a></p>
<p>You cannot use the CURRENT OF clause with a cursor declared with a join since internally, the CURRENT OF mechanism uses the ROWID pseudocolumn and there is no way to specify which table the ROWID relates to. For an alternative, see <a href="pco07tab.htm#i3051">&#34;Mimicking the CURRENT OF Clause&#34;</a>. Finally, you cannot use the CURRENT OF clause in dynamic SQL.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB368" class="sect2"><a id="sthref758"></a>
<h3 class="sect2">A Typical Sequence of Statements</h3>
<p>The following example shows the typical sequence of cursor control statements using the CURRENT OF clause and the FOR UPDATE OF clause:</p>
<pre>* --  Define a cursor.
     EXEC SQL DECLARE EMPCURSOR CURSOR FOR 
         SELECT ENAME, JOB FROM EMP 
         WHERE EMPNO = :EMP-NUMBER
         FOR UPDATE OF JOB
     END-EXEC.
* --  Open the cursor and identify the active set.
     EXEC SQL OPEN EMPCURSOR END-EXEC.
* --  Exit if the last row was already fetched.
     EXEC SQL
         WHENEVER NOT FOUND GOTO NO-MORE
     END-EXEC.
* --  Fetch and process data in a loop.
 LOOP.
<span class="bold">     </span> EXEC SQL FETCH EMPCURSOR INTO :EMP-NAME, :JOB-TITLE
       END-EXEC. 
* -- host-language statements that operate on the fetched data
       EXEC SQL UPDATE EMP 
          SET JOB = :NEW-JOB-TITLE 
          WHERE CURRENT OF EMPCURSOR
       END-EXEC. 
       GO TO LOOP.
     ...
 MO-MORE.
* --  Disable the cursor.
   <span class="bold"> </span>   EXEC SQL CLOSE EMPCURSOR END-EXEC. 
       EXEC SQL COMMIT WORK RELEASE END-EXEC.
    STOP RUN.
</pre></div>
<!-- class="sect2" -->
<a id="i6778"></a>
<div id="LNPCB369" class="sect2">
<h3 class="sect2">Positioned Update</h3>
<p>The following skeletal example demonstrates positioned update using the universal ROWID, which is defined in <a href="pco04dat.htm#i20247">&#34;Universal ROWIDs&#34;</a>:</p>
<pre>...
 01  MY-ROWID SQL-ROWID.
...
     EXEC SQL ALLOCATE :MY-ROWID END-EXEC.
     EXEC SQL DECLARE C CURSOR FOR
        SELECT ROWID, ... FROM MYTABLE FOR UPDATE OF ... END-EXEC.
     EXEC SQL OPEN C END-EXEC.
     EXEC SQL FETCH C INTO :MY-ROWID ... END-EXEC.
* Process retrieved data.
...
     EXEC SQL UPDATE MYTABLE SET ... WHERE ROWID = :MY-ROWID END-EXEC.
 ...
 NO-MORE-DATA:
     EXEC SQL CLOSE C END-EXEC.
     EXEC SQL FREE :MY-ROWID END-EXEC.
...
</pre></div>
<!-- class="sect2" -->
<a id="i6941"></a>
<div id="LNPCB370" class="sect2">
<h3 class="sect2">The PREFETCH Precompiler Option<a id="sthref759"></a><a id="sthref760"></a></h3>
<p>The precompiler option PREFETCH allows for more efficient queries by pre-fetching rows. This decreases the number of server round-trips needed and reduces memory required. The number of rows set by the PREFETCH option value in a configuration file or on the command line is used for all queries involving explicit cursors, subject to the standard precedence rules.</p>
<p>When used inline, the PREFETCH option must precede any of these cursor statements:</p>
<ul>
<li>
<p>EXEC SQL OPEN <span class="italic">cursor</span></p>
</li>
<li>
<p>EXEC SQL OPEN <span class="italic">cursor</span> USING <span class="italic">host_var_list</span></p>
</li>
<li>
<p>EXEC SQL OPEN <span class="italic">cursor</span> USING DESCRIPTOR <span class="italic">desc_name</span></p>
</li>
</ul>
<p>When an OPEN is executed, the value of PREFETCH gives the number of rows to be pre-fetched when the query is executed. You can set the value from 0 (no pre-fetching) to 9999. The default value is 1.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
The PREFETCH precompiler option is specifically designed for enhancing the performance of single row fetches. PREFETCH values have no effect when doing array fetches, regardless of which value is assigned.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i13177"></a>
<div id="LNPCB371" class="sect1">
<h2 class="sect1">Scrollable Cursors</h2>
<p>A scrollable cursor is a work area where Oracle executes SQL statements and stores information that is processed during execution.</p>
<p>When a cursor is executed, the results of the query are placed into a a set of rows called the result set. The result set can be fetched either sequentially or non-sequentially. Non-sequential result sets are called scrollable cursors.</p>
<p>A scrollable cursor enables users to access the rows of a database result set in a forward, backward, and random manner. This enables the program to fetch any row in the result set. See <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a>.</p>
<div id="LNPCB372" class="sect2"><a id="sthref761"></a>
<h3 class="sect2">Using Scrollable Cursors</h3>
<p>The following statements let you define and manipulate a scrollable cursor.</p>
<div id="LNPCB373" class="sect3"><a id="sthref762"></a>
<h4 class="sect3">DECLARE SCROLL CURSOR</h4>
<p>You can use the DECLARE &lt;cursor name&gt; SCROLL CURSOR statement to name the scrollable cursor and associate it with a query.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB374" class="sect3"><a id="sthref763"></a>
<h4 class="sect3">OPEN</h4>
<p>You can use the OPEN statement in the same way as in the case of a non-scrollable cursor.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB375" class="sect3"><a id="sthref764"></a>
<h4 class="sect3">FETCH</h4>
<p>You can use the FETCH statement to fetch required rows in a random manner. An application can fetch rows up or down, first or last row directly, or fetch any single row in a random manner.</p>
<p>The following options are available with the FETCH statement.</p>
<ol>
<li>
<p>FETCH FIRST</p>
<p>Fetches the first row from the result set.</p>
</li>
<li>
<p>FETCH PRIOR</p>
<p>Fetches the row prior to the current row.</p>
</li>
<li>
<p>FETCH NEXT</p>
<p>Fetches the next row from the current position. This is same as the non-scrollable cursor FETCH.</p>
</li>
<li>
<p>FETCH LAST</p>
<p>Fetches the last row from the result set.</p>
</li>
<li>
<p>FETCH CURRENT</p>
<p>Fetches the current row.</p>
</li>
<li>
<p>FETCH RELATIVE <span class="italic">n</span></p>
<p>Fetches the <span class="italic">n</span>th row relative to the current row, where <span class="italic">n</span> is the offset.</p>
</li>
<li>
<p>FETCH ABSOLUTE <span class="italic">n</span></p>
<p>Fetches the <span class="italic">n</span>th row, where <span class="italic">n</span> is the offset from the start of the result set.</p>
</li>
</ol>
<p>The following example describes how to FETCH the last record from a result set.</p>
<pre>EXEC SQL DECLARE emp_cursor SCROLL CURSOR FOR
SELECT ename, sal FROM emp WHERE deptno=20;
...
EXEC SQL OPEN emp_cursor;
EXEC SQL FETCH LAST emp_cursor INTO :emp_name, :sal;
EXEC SQL CLOSE emp_cursor;
</pre></div>
<!-- class="sect3" -->
<div id="LNPCB376" class="sect3"><a id="sthref765"></a>
<h4 class="sect3">CLOSE</h4>
<p>You can use the CLOSE statement in the same way as in the case of a non-scrollable cursor.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot use scrollable cursors for REF cursors.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB377" class="sect2"><a id="sthref766"></a>
<h3 class="sect2">The CLOSE_ON_COMMIT Precompiler Option<a id="sthref767"></a></h3>
<p>The CLOSE_ON_COMMIT micro precompiler option provides the ability to choose whether or not to close all cursors when a COMMIT is executed and the macro option MODE=ANSI. When MODE=ANSI, CLOSE_ON_COMMIT has the default value YES. Explicitly setting CLOSE_ON_COMMIT=NO results in better performance because cursors will not be closed when a COMMIT is executed, removing the need to re-open the cursors and incur extra parsing.</p>
</div>
<!-- class="sect2" -->
<a id="i4711"></a>
<div id="LNPCB378" class="sect2">
<h3 class="sect2">The <a id="sthref768"></a>PREFETCH Precompiler Option</h3>
<p>The precompiler option PREFETCH allows for more efficient queries by pre-fetching a given number of rows. This decreases the number of server round trips needed and reduces overall memory usage. The number of rows set by the PREFETCH option value is used for all queries involving explicit cursors, subject to the standard precedence rules. When used inline, the PREFETCH option must precede any of these cursor statements:</p>
<ul>
<li>
<p>EXEC SQL OPEN <span class="italic">cursor</span></p>
</li>
<li>
<p>EXEC SQL OPEN <span class="italic">cursor</span> USING <span class="italic">host_var_list</span></p>
</li>
<li>
<p>EXEC SQL OPEN <span class="italic">cursor</span> USING DESCRIPTOR <span class="italic">desc_name</span></p>
</li>
</ul>
<p>When an OPEN is executed, the value of PREFETCH gives the number of rows to be pre-fetched when the query is executed. You can set the value from 0 (no pre-fetching) to 65535. The default value is 1.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The default value of the PREFETCH option is 1 - return a single row for each round-trip. If you choose not to use the PREFETCH option, using the command line, you must explicitly disable it by setting the PREFETCH option to 0.
<p>PREFETCH is automatically disabled when LONG or LOB columns are being retrieved.</p>
</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
PREFETCH is used primarily to enhance the performance of single row fetches. PREFETCH has no effect when array fetches are used.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The PREFETCH option should be used wisely, and on a case-by-case basis. Select an appropriate prefetch value that will optimize performance of a specific FETCH statement. To accomplish this, use the inline prefetch option instead of the command line prefetch option.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The performance of many large applications can be improved simply by using indicator variables with host variables in FETCH statements.
<p>To enable precompiler applications to obtain the maximum advantage from the use of the PREFETCH option on single row fetches, it is strongly recommended that you use indicator variables.</p>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDHFAEE"></a>
<div id="LNPCB379" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Flexible B Area Length</h2>
<p>The length of B Area for a Pro*Cobol program is limited to 72 when the format is set to ANSI. Cobol compilers now can support B Area length up to 253. This provides a programmer with the flexibility to type a line that is longer than 72 columns. Pro*Cobol now supports B area length up to 253 when a Pro*Cobol application is precompiled with the</p>
<p><code>FORMAT=VARIABLE</code> <code>IRECLEN=300</code></p>
<p>options.</p>
</div>
<!-- class="sect1" -->
<a id="CHDDDBJH"></a>
<div id="LNPCB380" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Fix Execution Plans</h2>
<p>In application development environments where modules are developed in one environment, and then integrated and deployed into another, the performance of the applications are affected. At times, the performance of the precompiler applications are affected by changes in the database environment. These may include changes in the optimizer statistics, changes to the optimizer settings, or changes to parameters affecting the sizes of memory structures.</p>
<p>To fix execution plans for SQL&#39;s used in Pro*Cobol in the development environment, you need to use the outline feature of Oracle at the time of precompiling. An outline is implemented as a set of optimizer hints that are associated with the SQL statement. If you enable the use of the outline for the statement, Oracle automatically considers the stored hints and tries to generate an execution plan in accordance with those hints. In this way, you can ensure that the performance is not affected when the modules are integrated or deployed into different environments.</p>
<p>You can use the following SQL statements to create outlines in Pro*Cobol:</p>
<ul>
<li>
<p><code>SELECT</code></p>
</li>
<li>
<p><code>DELETE</code></p>
</li>
<li>
<p><code>UPDATE</code></p>
</li>
<li>
<p><code>INSERT... SELECT</code></p>
</li>
<li>
<p><code>CREATE TABLE... AS SELECT</code></p>
</li>
</ul>
<p>If the outline option is set, then the precompiler generates two files, a SQL file and a LOG file at the end of successful precompilation. Command line options <code>outline</code> and <code>outlnprefix</code> control the generation of the outlines.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pco14opt.htm#g27880">Chapter 14, &#34;Precompiler Options&#34;</a> for more details on these command line options</div>
<p>Each generated outline name is unique. Because the file names used in the application are unique, this information is used in generating the outline name. In addition, the category name is also prefixed.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Oracle allows only 30 bytes for the outline name. If you exceed the limit, the precompiler will flag an error. You can restrict the length of the outline name by using the <code>outlnprefix</code> option.</div>
<div id="LNPCB381" class="example">
<p class="titleinexample"><a id="sthref769"></a>Example 5-1 Generating a SQL File Containing Outlines</p>
<p>You need to precompile the following program by using the outline option to generate SQL files containing the outlines for all the outline-supported SQL statements in this program.</p>
<pre> *****************************************************************
      * outlndemo:                                                    *

      * Outlines will be created for the following SQL operations,    *
      * 1. CREATE ... SELECT                                          *
      * 2. INSERT ... SELECT                                          *
      * 3. UPDATE                                                     *
      * 4. DELETE                                                     *
      * 5. SELECT                                                     *
      *****************************************************************
 
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  outlndemo.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
 
      * EMBEDDED COBOL (file &#34;OUTNDEMO.PCO&#34;)  
 
           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
 
       01  ENAME PIC  X(10).
       01  JOB PIC  X(9).
       01  SAL PIC  X(6).
       01  COMM PIC  X(6).
 
           EXEC SQL END DECLARE SECTION END-EXEC.
 
       01  STRINGFIELDS.
           02 STR PIC X(18) VARYING.
 
           EXEC SQL INCLUDE SQLCA END-EXEC.
 
       PROCEDURE DIVISION.
       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR END-EXEC.
 
           PERFORM LOGON.
 
 EXEC SQL INSERT INTO BONUS
 SELECT ENAME, JOB, SAL, COMM FROM EMP
 WHERE JOB LIKE &#39;SALESMAN&#39;
 END-EXEC.
 
 EXEC SQL UPDATE BONUS
 SET SAL = SAL * 1.1 WHERE SAL &lt; 1500
           END-EXEC.
 
 EXEC SQL DECLARE C1 CURSOR FOR
 SELECT ENAME, JOB, SAL, COMM FROM BONUS ORDER BY SAL
 END-EXEC.
 EXEC SQL OPEN C1 END-EXEC.
 DISPLAY &#34;Contents of updated BONUS table&#34;.
 DISPLAY &#34;ENAME       JOB     SAL  COMM&#34;.
 DISPLAY &#34; &#34;.
 
 EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.
       FETCH-DATA.
 EXEC SQL FETCH C1 INTO :ENAME, :JOB, :SAL, :COMM END-EXEC.
 DISPLAY ENAME, JOB, SAL, COMM.
 GO TO FETCH-DATA.
 
       END-FETCH.
 EXEC SQL CLOSE C1 END-EXEC.
           EXEC SQL WHENEVER NOT FOUND DO PERFORM SQL-ERROR END-EXEC.
 
 EXEC SQL DELETE FROM BONUS END-EXEC.
 
 EXEC SQL CREATE TABLE OUTLNDEMO_TAB AS
 SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO = 10
 END-EXEC.
 
 EXEC SQL DROP TABLE OUTLNDEMO_TAB END-EXEC.
 
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
 
       LOGON.
           MOVE &#34;scott&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;tiger&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
 
      * HANDLES SQL ERROR CONDITIONS
       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="example" -->
<div id="LNPCB382" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref770"></a>
<h3 class="sect2">SQL File</h3>
<p>The generated file name has the following format:</p>
<pre>&lt;filename&gt;_&lt;filetype&gt;.sql
</pre>
<p>In Pro*Cobol, for the file &#34;abc.pco&#34;, the generated SQL file will be abc_pco.sql.</p>
<p class="subhead2"><a id="LNPCB383"></a>Generated file format</p>
<p>If the outlnprefix option is not used, then the format of the unique identifier used as outline name and comment is:</p>
<pre>&lt;category_name&gt;_&lt;filename&gt;_&lt;filetype&gt;_&lt;sequence no.&gt;
</pre>
<p>If the outlnprefix option is used (outlnprefix=&lt;prefix_name&gt;), then the format of the unique identifier used as outline name and comment is:</p>
<pre>&lt;prefix_name&gt;_&lt;sequence no.&gt;
</pre>
<p>If outline=yes, which is the default category, then &lt;category_name&gt; will be DEFAULT and outline name will be:</p>
<pre>DEFAULT_&lt;filename&gt;_&lt;filetype&gt;_&lt;sequence no.&gt;
</pre>
<p>or</p>
<pre>&lt;prefix_name&gt;_&lt;sequence no.&gt;
</pre>
<p>The allowed range for <code>&lt;sequence no.&gt;</code> is 0000 to 9999.</p>
<p>SQL in the generated precompiled file will have the comment appended to it as it appears in the outline for that SQL.</p>
<div id="LNPCB384" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref771"></a>
<h4 class="sect3">Examples</h4>
<p>Consider the following examples.</p>
<p class="subhead2"><a id="LNPCB385"></a>Example 1</p>
<p>If abc.pco has the statements</p>
<pre>EXEC SQL select * from emp where empno=:var END-EXEC.
EXEC SQL select * from dept END-EXEC.
</pre>
<p>and if outline=mycat1 and outlnprefix is not used, then:</p>
<p class="subhead2"><a id="LNPCB386"></a>Contents of abc_pco.sql</p>
<p>create or replace outline mycat1_abc_pco_0000 for category mycat1 on <code>select * from emp where empno=:b1 /* mycat1_abc_pco_0000 */;</code></p>
<p>create or replace outline mycat1_abc_pco_0001 for category mycat1 on <code>select * from dept /* mycat1_abc_pco_0001 */;</code></p>
<p class="subhead2"><a id="LNPCB387"></a>Contents of abc.cob</p>
<pre>01 SQ0001 GLOBAL.
  02 FILLER PIC X(60) VALUE &#34;select * from emp where empno=:b1
  -  /* mycat1_abc_pco_0000 */
-    &#34;&#34;.
</pre>
<p class="subhead2"><a id="LNPCB388"></a>Example 2</p>
<p>If abc.pco has the statements</p>
<pre>EXEC SQL select * from emp where empno=:var END-EXEC.
EXEC SQL select * from dept END-EXEC.
</pre>
<p>and if outline=mycat1 and outlnprefix=myprefix, then:</p>
<p class="subhead2"><a id="LNPCB389"></a>Contents of abc_pco.sql</p>
<p>create or replace outline myprefix_0000 for category mycat1 on <code>select * from emp where empno=:b1 /* myprefix_0000 */;</code></p>
<p>create or replace outline myprefix_0001 for category mycat1 on <code>select * from dept /* myprefix_0001 */;</code></p>
<p class="subhead2"><a id="LNPCB390"></a>Contents of abc.cob</p>
<pre>01 SQ0001 GLOBAL.
  02 FILLER PIC X(60) VALUE &#34;select * from emp where empno=:b1
  -  /* myprefix_0000 */
- &#34;&#34;.
</pre>
<p class="subhead2"><a id="LNPCB391"></a>Example 3</p>
<p>If abc.pco has the statements</p>
<pre>EXEC SQL select * from emp where empno=:var END-EXEC.
EXEC SQL select * from dept END-EXEC.
</pre>
<p>and if outline=yes and outlnprefix=myprefix, then:</p>
<p class="subhead2"><a id="LNPCB392"></a>Contents of abc_pco.sql</p>
<p>create or replace outline myprefix_0000 on <code>select * from emp where empno=:b1 /* myprefix_0000 */;</code></p>
<p>create or replace outline myprefix_0001 on <code>select * from dept /* myprefix_0001 */;</code></p>
<p class="subhead2"><a id="LNPCB393"></a>Contents of abc.cob</p>
<pre>01 SQ0001 GLOBAL.
  03 FILLER PIC X(60) VALUE &#34;select * from emp where empno=:b1
  -  /* myprefix_0000 */
- &#34;&#34;.
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB394" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref772"></a>
<h3 class="sect2">LOG File</h3>
<p>The generated file name has the following format:</p>
<pre>&lt;filename&gt;_&lt;filetype&gt;.log
</pre>
<p>In Pro*Cobol, for the file &#34;abc.pco&#34;, the generated LOG file will be abc_pco.log.</p>
<p>Consider the following example.</p>
<p class="subhead2"><a id="LNPCB395"></a>Example 1</p>
<p>If abc.pco has the statement</p>
<pre>EXEC SQL select * from emp END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB396"></a>Contents of abc_pco.log</p>
<pre>CATEGORY &lt;Category_name&gt; 
     Source SQL_0
        SELECT * FROM emp
     OUTLINE NAME
        abc_pco_0000
     OUTLINE SQL_0
        Select * from emp /* abc_pco_0000 */
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7431"></a>
<div id="LNPCB397" class="sect1">
<h2 class="sect1">Sample Program 2: Cursor Operations<a id="sthref773"></a><a id="sthref774"></a></h2>
<p>This program logs on to Oracle, declares and opens a cursor, fetches the names, salaries, and commissions of all salespeople, displays the results, then closes the cursor</p>
<p>All fetches except the final one return a row and, if no errors were detected during the fetch, a success status code. The final fetch fails and returns the &#34;no data found&#34; Oracle warning code to SQLCODE in the SQLCA. The cumulative number of rows actually fetched is found in SQLERRD(3) in the SQLCA.</p>
<pre>      *****************************************************************
      * Sample Program 2:  Cursor Operations                          *
      *                                                               *
      * This program logs on to ORACLE, declares and opens a cursor,  *
      * fetches the names, salaries, and commissions of all           *
      * salespeople, displays the results, then closes the cursor.    *
      *****************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID. CURSOR-OPS.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
       01  EMP-REC-VARS.
           05  EMP-NAME      PIC X(10) VARYING.
           05  SALARY        PIC S9(6)V99
                             DISPLAY SIGN LEADING SEPARATE.
           05  COMMISSION    PIC S9(6)V99
                             DISPLAY SIGN LEADING SEPARATE.
           EXEC SQL VAR SALARY IS DISPLAY(8,2) END-EXEC.
           EXEC SQL VAR COMMISSION IS DISPLAY(8,2) END-EXEC.
           EXEC SQL END DECLARE SECTION END-EXEC.

           EXEC SQL INCLUDE SQLCA END-EXEC.

       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME    PIC X(10).
           05  D-SALARY      PIC Z(4)9.99.
           05  D-COMMISSION  PIC Z(4)9.99.

       PROCEDURE DIVISION.

       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR
               DO PERFORM SQL-ERROR END-EXEC.
           PERFORM LOGON.
           EXEC SQL DECLARE SALESPEOPLE CURSOR FOR
               SELECT ENAME, SAL, COMM
               FROM EMP
               WHERE JOB LIKE &#39;SALES%&#39;
           END-EXEC.
           EXEC SQL OPEN SALESPEOPLE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;SALESPERSON  SALARY      COMMISSION&#34;.
           DISPLAY &#34;-----------  ----------  ----------&#34;.

       FETCH-LOOP.
           EXEC SQL WHENEVER NOT FOUND
               DO PERFORM SIGN-OFF END-EXEC.
           EXEC SQL FETCH SALESPEOPLE
               INTO :EMP-NAME, :SALARY, :COMMISSION
           END-EXEC.
           MOVE EMP-NAME-ARR TO D-EMP-NAME.
           MOVE SALARY TO D-SALARY.
           MOVE COMMISSION TO D-COMMISSION.
           DISPLAY D-EMP-NAME, &#34;     &#34;, D-SALARY, &#34;    &#34;, D-COMMISSION.
           MOVE SPACES TO EMP-NAME-ARR.
           GO TO FETCH-LOOP.

       LOGON.
           MOVE &#34;SCOTT&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;TIGER&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER:  &#34;, USERNAME-ARR.

       SIGN-OFF.
           EXEC SQL CLOSE SALESPEOPLE END-EXEC. 
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY.&#34;.
           DISPLAY &#34; &#34;.
           EXEC SQL COMMIT WORK RELEASE END-EXEC.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pco04dat.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pco06pls.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>