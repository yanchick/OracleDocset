<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77858"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Host%20Tables"></a><title>Host Tables</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:16Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pco06pls.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pco08err.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/27</span> <!-- End Header -->
<div id="LNPCB007" class="chapter"><a id="g12783"></a>
<h1 class="chapter"><span class="secnum">7</span> Host Tables</h1>
<p>This chapter looks at using host tables to simplify coding and improve program performance. You learn how to manipulate Oracle data using host tables, how to operate on all the elements of a host table with a single SQL statement, how to limit the number of table elements processed, and how to use tables of group items.</p>
<p>The main sections are:</p>
<ul>
<li>
<p><a href="#i12678">Host Tables</a></p>
</li>
<li>
<p><a href="#i3032">Advantages of Host Tables</a></p>
</li>
<li>
<p><a href="#i3154">Selecting into Tables</a></p>
</li>
<li>
<p><a href="#i3154">Selecting into Tables</a></p>
</li>
<li>
<p><a href="#i3159">Inserting with Tables</a></p>
</li>
<li>
<p><a href="#i3164">Updating with Tables</a></p>
</li>
<li>
<p><a href="#i3169">Deleting with Tables</a></p>
</li>
<li>
<p><a href="#i3174">Using Indicator Tables</a></p>
</li>
<li>
<p><a href="#i3048">The FOR Clause</a></p>
</li>
<li>
<p><a href="#i3061">The WHERE Clause</a></p>
</li>
<li>
<p><a href="#i3051">Mimicking the CURRENT OF Clause</a></p>
</li>
<li>
<p><a href="#i5458">Tables of Group Items as Host Variables</a></p>
</li>
<li>
<p><a href="#CHDCCHAE">Additional Array Insert/Select Syntax</a></p>
</li>
<li>
<p><a href="#CHDIBDFD">Using Implicit Buffered Insert</a></p>
</li>
</ul>
<a id="i12678"></a>
<div id="LNPCB451" class="sect1">
<h2 class="sect1">Host Tables</h2>
<p>A <span class="italic">host table</span> (also known as an array) is a set of related data items, called <span class="italic">elements</span>, associated with a single variable. An indicator variable defined as a table is called an <span class="italic">indicator table</span>. An indicator table can be associated with any host table that is NULLABLE.<a id="sthref915"></a><a id="sthref916"></a><a id="sthref917"></a><a id="sthref918"></a></p>
</div>
<!-- class="sect1" -->
<a id="i3032"></a>
<div id="LNPCB452" class="sect1">
<h2 class="sect1">Advantages of Host Tables</h2>
<p>Host tables can ease programming and can offer greatly improved performance. When writing an application, you are usually faced with the problem of storing and manipulating large amounts of data. Host tables simplify the task of accessing multiple return values.<a id="sthref919"></a></p>
<p>Host tables let you manipulate multiple rows with a single SQL statement. Thus, communications overhead is reduced markedly, especially in a networked environment. For example, suppose you want to insert information about 300 employees into the EMP table. Without host tables your program must do 300 individual INSERTs&mdash;one for each employee. With host tables, only one INSERT need be done.</p>
</div>
<!-- class="sect1" -->
<div id="LNPCB453" class="sect1"><a id="sthref920"></a>
<h2 class="sect1">Tables in Data Manipulation Statements</h2>
<p>Pro*COBOL allows the use of host tables in data manipulation statements. You can use host tables as input variables in the INSERT, UPDATE, and DELETE statements and as output variables in the INTO clause of SELECT and FETCH statements.</p>
<p>The syntax used for host tables and for simple host variables is nearly the same. One difference is the optional FOR clause, which lets you control table processing. Also, there are restrictions on mixing host tables and simple host variables in a SQL statement.</p>
<div id="LNPCB454" class="sect2"><a id="sthref921"></a>
<h3 class="sect2">Declaring Host Tables</h3>
<p>You declare and dimension host tables in the Data Division. In the following example, three host tables are declared, each dimensioned with 50 elements:<a id="sthref922"></a><a id="sthref923"></a></p>
<pre>     .... 
 01  EMP-TABLES. 
     05  EMP-NUMBER  OCCURS 50 TIMES PIC S9(4) COMP. 
     05  EMP-NAME    OCCURS 50 TIMES PIC X(10. 
     05  SALARY      OCCURS 50 TIMES PIC S9(5)V99 COMP-3. 
     .... 
</pre>
<p>You can use the INDEXED BY phrase in the OCCURS clause to specify an index, as the next example shows:</p>
<pre>     ... 
 01  EMP-TABLES. 
     05  EMP-NUMBER  PIC X(10) OCCURS 50 TIMES 
         INDEXED BY EMP-INDX. 
             ... 
     ... 
</pre>
<p>The INDEXED BY phrase implicitly declares the index item EMP-INDX.</p>
<div id="LNPCB455" class="sect3"><a id="sthref924"></a>
<h4 class="sect3">Restrictions</h4>
<p>Multi-dimensional host tables are not allowed. Thus, the two-dimensional host table declared in the following example is <span class="italic">invalid</span>:<a id="sthref925"></a><a id="sthref926"></a><a id="sthref927"></a><a id="sthref928"></a><a id="sthref929"></a><a id="sthref930"></a></p>
<pre>     ... 
 01  NATION.
     05  STATE                OCCURS 50 TIMES. 
         10  STATE-NAME       PIC X(25).
         10  COUNTY           OCCURS 25 TIMES.
             15  COUNTY-NAME  PIX X(25).
     ... 
</pre>
<p>Variable-length host tables are not allowed either. For example, the following declaration of EMP-REC is <span class="italic">invalid for a host variable</span>:<a id="sthref931"></a><a id="sthref932"></a></p>
<pre>     ... 
 01  EMP-FILE. 
     05  REC-COUNT  PIC S9(3) COMP. 
     05  EMP-REC    OCCURS 0 TO 250 TIMES 
         DEPENDING ON REC-COUNT. 
     ... 
</pre>
<p><a id="sthref933"></a><a id="sthref934"></a>The maximum number of host table elements in a SQL statement that is accessible in one fetch is 32K (or possibly greater, depending on your platform and the available memory). If you try to access a number that exceeds the maximum, you get a &#34;parameter out of range&#34; runtime error. If the statement is an anonymous PL/SQL block, the number of elements accessible is limited to 32512 divided by the size of the datatype.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB456" class="sect2"><a id="sthref935"></a>
<h3 class="sect2">Referencing Host Tables</h3>
<p>If you use multiple host tables in a single SQL statement, their dimensions should be the same. This is not a requirement, however, because Pro*COBOL always uses the <span class="italic">smallest</span> dimension for the SQL operation. In the following example, only 25 rows are <a id="sthref936"></a><a id="sthref937"></a>inserted<a id="sthref938"></a></p>
<pre> WORKING-STORAGE SECTION. 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMP-TABLES. 
     05  EMP-NUMBER   PIC S9(4) COMP OCCURS 50 TIMES. 
     05  EMP-NAME     PIC X(10) OCCURS 50 TIMES. 
     05  DEPT-NUMBER  PIC S9(4) COMP OCCURS 25 TIMES. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 
*    Populate host tables here. 
     ... 
     EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO) 
         VALUES (:EMP-NUMBER, :EMP-NAME, :DEPT-NUMBER) 
     END-EXEC. 
</pre>
<p>Host tables must <span class="italic">not</span> be subscripted in SQL statements. For example, the following INSERT statement is <span class="italic">invalid</span>:</p>
<pre> WORKING-STORAGE SECTION. 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMP-TABLES. 
     05  EMP-NUMBER   PIC S9(4) COMP OCCURS 50 TIMES. 
     05  EMP-NAME     PIC X(10) OCCURS 50 TIMES. 
     05  DEPT-NUMBER  PIC S9(4) COMP OCCURS 50 TIMES. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 
     PERFORM LOAD-EMP VARYING J FROM 1 BY 1 UNTIL J &gt; 50. 
     ... 
 LOAD-EMP. 
     EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO) 
         VALUES (:EMP-NUMBER(J), :EMP-NAME(J), 
             :DEPT-NUMBER(J)) 
     END-EXEC. 
</pre>
<p>You need not process host tables in a PERFORM VARYING statement. Instead, use the un-subscripted table names in your SQL statement. Pro*COBOL treats a SQL statement containing host tables of dimension <span class="italic">n</span> like the same statement executed <span class="italic">n</span> times with <span class="italic">n</span> different scalar host variables, but more efficiently.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB457" class="sect2"><a id="sthref939"></a>
<h3 class="sect2">Using Indicator Tables</h3>
<p>You can use indicator tables to assign NULLs to elements in input host tables and to detect NULLs or truncated values (of character columns only) in output host tables. The following example shows how to conduct an INSERT with indicator tables:<a id="sthref940"></a><a id="sthref941"></a></p>
<pre> WORKING-STORAGE SECTION. 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  EMP-TABLES. 
     05  EMP-NUMBER   PIC S9(4) COMP OCCURS 50 TIMES. 
     05  DEPT-NUMBER  PIC S9(4) COMP OCCURS 50 TIMES. 
     05  COMMISSION   PIC S9(5)V99 COMP-3 OCCURS 50 TIMES. 
     05  COMM-IND     PIC S9(4) COMP OCCURS 50 TIMES. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
 PROCEDURE DIVISION. 
     ... 
*    Populate the host and indicator tables. 
*    Set indicator table to all zeros.
     ... 
     EXEC SQL INSERT INTO EMP (EMPNO, DEPTNO, COMM) 
         VALUES (:EMP-NUMBER, :DEPT-NUMBER, 
             :COMMISSION:COMM-IND) 
     END-EXEC. 
</pre>
<p>The dimension of the indicator table must be greater than or equal to the dimension of the host table.</p>
<p>When using host table SELECT and FETCH, it is recommended that you use indicator variables. That way you can test for NULLs in the associated output host table.</p>
<p>If a NULL is selected or fetched into a host variable that has no associated indicator variable, your program stops processing, sets <span class="italic">sqlca.sqlerrd(3)</span> to the number of rows processed, and returns an error.</p>
<p>NULL is selected by default, but you can switch it off by using the UNSAFE_NULL = YES option.</p>
<p>When DBMS=V7 or V8, your program does not consider truncation to be an error.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB458" class="sect2"><a id="sthref942"></a>
<h3 class="sect2">Host Group Item Containing Tables</h3>
<p><span class="bold">Note:</span> If you have a host group item containing tables, then you must use a corresponding group item of tables for an indicator. For example, if your group item is the following:</p>
<pre> 01  DEPARTURE.
     05 HOUR    PIC X(2) OCCURS 3 TIMES.
     05 MINUTE  PIC X(2) OCCURS 3 TIMES.
</pre>
<p>the following indicator variable <span class="italic">cannot</span> be used:</p>
<pre> 01  DEPARTURE-IND PIC S9(4) COMP OCCURS 6 TIMES.
</pre>
<p>The indicator variable you use with the group item of tables must itself be a group item of tables such as the following:</p>
<pre>  01  DEPARTURE-IND.
      05 HOUR-IND   PIC S9(4) COMP OCCURS 3 TIMES.
      05 MINUTE-IND PIC S9(4) COMP OCCURS 3 TIMES.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB459" class="sect2"><a id="sthref943"></a>
<h3 class="sect2">Oracle Restrictions</h3>
<p>Mixing scalar host variables with host tables in the VALUES, SET, INTO, or WHERE clause is <span class="italic">not</span> allowed. If any of the host variables is a host table, all must be host tables.<a id="sthref944"></a><a id="sthref945"></a></p>
<p>You cannot use host tables with the <a id="sthref946"></a><a id="sthref947"></a>CURRENT OF clause in an UPDATE or DELETE statement.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB460" class="sect2"><a id="sthref948"></a>
<h3 class="sect2">ANSI Restriction and Requirements</h3>
<p>The array interface is an Oracle extension to the ANSI/ISO embedded SQL standard. However, when you precompile with MODE=ANSI, array SELECTs and FETCHes are still allowed. The use of arrays can be flagged using the FIPS flagger precompiler option, if desired. <a id="sthref949"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3154"></a>
<div id="LNPCB461" class="sect1">
<h2 class="sect1">Selecting into Tables</h2>
<p>You can use host tables as output variables in the SELECT statement. If you know the maximum number of rows the select will return, simply define the host tables with that number of elements. In the following example, you select directly into three host tables. The table was defined with 50 rows, with the knowledge that the select will return no more than 50 rows.<a id="sthref950"></a><a id="sthref951"></a><a id="sthref952"></a></p>
<pre>     01  EMP-REC-TABLES.
         05  EMP-NUMBER   OCCURS 50 TIMES PIC S9(4) COMP.
         05  EMP-NAME     OCCURS 50 TIMES PIC X(10) VARYING.
         05  SALARY       OCCURS 50 TIMES PIC S9(6)V99
                          DISPLAY SIGN LEADING SEPARATE.
     ...
     EXEC SQL SELECT ENAME, EMPNO, SAL
         INTO :EMP-NAME, :EMP-NUMBER, :SALARY
         FROM EMP
         WHERE SAL &gt; 1000
     END-EXEC.
</pre>
<p>In this example, the SELECT statement returns up to 50 rows. If there are fewer than 50 eligible rows or you want to retrieve only 50 rows, this method will suffice. However, if there are more than 50 eligible rows, you cannot retrieve all of them this way. If you reexecute the SELECT statement, it just returns the first 50 rows again, even if more are eligible. You must either define a larger table or declare a cursor for use with the FETCH statement.</p>
<p>If a SELECT INTO statement returns more rows than the size of the table you defined, Oracle issues an error message unless you specify SELECT_ERROR=NO. For more information about the option, see <a href="pco14opt.htm#i5833">&#34;SELECT_ERROR&#34;</a>.</p>
<div id="LNPCB462" class="sect2"><a id="sthref953"></a>
<h3 class="sect2">Batch Fetches</h3>
<p>Use batch fetches when the size of data you are processing is large (greater than about 100 rows) as well as when you do not know how many rows will be returned.</p>
<p>If you do not know the maximum number of rows a select will return, you can declare and open a cursor, and then fetch from it in &#34;batches.&#34; Batch fetches within a loop let you retrieve a large number of rows with ease. Each fetch returns the next batch of rows from the current active set. In the following example, you fetch in 20-row batches:<a id="sthref954"></a><a id="sthref955"></a><a id="sthref956"></a></p>
<pre> ...
 01  EMP-REC-TABLES.
     05  EMP-NUMBER    OCCURS 20 TIMES PIC S9(4) COMP.
     05  EMP-NAME      OCCURS 20 TIMES PIC X(10) VARYING.
     05  SALARY        OCCURS 20 TIMES PIC S9(6)V99
                       DISPLAY SIGN LEADING SEPARATE.
     ...
     EXEC SQL DECLARE EMPCURSOR CURSOR FOR
     SELECT EMPNO, SAL FROM EMP
     END-EXEC.
     ...
     EXEC SQL OPEN EMPCURSOR END-EXEC.
     ...
     EXEC SQL WHENEVER NOT FOUND DO PERFORM END-IT.
 LOOP.
     EXEC SQL FETCH EMPCURSOR INTO :EMP-NUMBER, :SALARY END-EXEC.
* --  process batch of rows
     ...
     GO TO LOOP.
 END-IT.
...
</pre>
<p>Do not forget to check how many rows were actually returned in the last fetch and to process them. See <a href="#i7302">&#34;Sample Program 3: Fetching in Batches&#34;</a> for a complete example.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB463" class="sect2"><a id="sthref957"></a>
<h3 class="sect2">Using SQLERRD(3)</h3>
<p>For INSERT, UPDATE, and DELETE statements, SQLERRD(3) records the number of rows processed.</p>
<p>SQLERRD(3) is also useful when an error occurs during a table operation. Processing stops at the row that caused the error, so SQLERRD(3) gives the number of rows processed successfully.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB464" class="sect2"><a id="sthref958"></a>
<h3 class="sect2">Number of Rows Fetched</h3>
<p>Each fetch returns, at most, the number of entries in the table. Fewer rows are returned in the following cases:<a id="sthref959"></a></p>
<ul>
<li>
<p>The end of the active set is reached. The &#34;no data found&#34; warning code is returned to SQLCODE in the SQLCA. For example, this happens if you fetch into a table of number of entries 100, but only 20 rows are returned.</p>
</li>
<li>
<p>Fewer than a full batch of rows remain to be fetched. For example, this happens if you fetch 70 rows into a table of number of entries 20 because after the third fetch, only 10 rows remain to be fetched.</p>
</li>
<li>
<p>An error is detected while processing a row. The fetch fails and the applicable error code is returned to SQLCODE.</p>
</li>
</ul>
<p>The cumulative number of rows returned can be found in the third element of SQLERRD in the SQLCA, called SQLERRD(3) in this guide. This applies to each open cursor. In the following example, notice how the status of each cursor is maintained separately:<a id="sthref960"></a></p>
<pre>     EXEC SQL OPEN CURSOR1 END-EXEC.
     EXEC SQL OPEN CURSOR2 END-EXEC.
     EXEC SQL FETCH CURSOR1 INTO :TABLE-OF-20 END-EXEC.
* --  now running total in SQLERRD(3) is 20
     EXEC SQL FETCH CURSOR2 INTO :TABLE-OF-30 END-EXEC.
* --  now running total in SQLERRD(3) is 30, not 50
     EXEC SQL FETCH CURSOR1 INTO :TABLE-OF-20 END-EXEC.
* --  now running total in SQLERRD(3) is 40 (20 + 20)
     EXEC SQL FETCH CURSOR2 INTO :TABLE-OF-30 END-EXEC.
* --  now running total in SQLERRD(3) is 60 (30 + 30)
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB465" class="sect2"><a id="sthref961"></a>
<h3 class="sect2">Restrictions on Using Host Tables</h3>
<p>Using host tables in the WHERE clause of a SELECT statement is allowed only in a sub-query. (For an example, see <a href="#i3061">&#34;The WHERE Clause&#34;</a>.) Also, since Pro*COBOL always takes the smallest dimension of table, do not mix simple host variables with host tables in the INTO clause of a SELECT or FETCH statement because only one row will be retrieved. If any of the host variables is a table, then all must be tables.<a id="sthref962"></a><a id="sthref963"></a></p>
<p><a href="#i6325">Table 7-1</a> shows which uses of host tables are valid in a SELECT INTO statement.</p>
<div id="LNPCB466" class="tblformal">
<p class="titleintable"><a id="sthref964"></a><a id="sthref965"></a>Table 7-1 <a id="i6325"></a><span class="bolditalic">Host Tables Valid in SELECT INTO</span></p>
<table class="cellalignment4971" title="Host Tables Valid in SELECT INTO" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t2">INTO Clause</th>
<th class="cellalignment4972" id="r1c2-t2">WHERE Clause</th>
<th class="cellalignment4972" id="r1c3-t2">Valid?</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t2" headers="r1c1-t2">
<p>table</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c2-t2">
<p>table</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c3-t2">
<p>no</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t2" headers="r1c1-t2">
<p>scalar</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c2-t2">
<p>scalar</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c3-t2">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t2" headers="r1c1-t2">
<p>table</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c2-t2">
<p>scalar</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c3-t2">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t2" headers="r1c1-t2">
<p>scalar</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c2-t2">
<p>table</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c3-t2">
<p>no</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNPCB467" class="sect2"><a id="sthref966"></a>
<h3 class="sect2">Fetching NULLs</h3>
<p>When UNSAFE_NULL=YES, if you select or fetch a NULL into a host table that lacks an indicator table, no error is generated. So, when doing table selects and fetches, Oracle recommends that you use indicator tables. This is because this makes it NULLs easier to find in the associated output host table. (To learn how to find NULLs and truncated values, see <a href="pco05sql.htm#i3617">&#34;Using Indicator Variables&#34;</a>.)</p>
<p>When UNSAFE_NULL=NO, if you select or fetch a NULL into a host table that lacks an indicator table, Oracle stops processing, sets SQLERRD(3) to the number of rows processed, and issues an error message:</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB468" class="sect2"><a id="sthref967"></a>
<h3 class="sect2">Fetching Truncated Values</h3>
<p>If you select or fetch a truncated column value into a host table that lacks an indicator table, Oracle sets SQLWARN(2).</p>
<p>You can check SQLERRD(3) for the number of rows processed before the truncation occurred. The rows-processed count includes the row that caused the truncation error.</p>
<p>When doing table selects and fetches, you can use indicator tables. That way, if Oracle assigns one or more truncated column values to an output host table, you can find the original lengths of the column values in the associated indicator table.</p>
</div>
<!-- class="sect2" -->
<a id="i7302"></a>
<div id="LNPCB469" class="sect2">
<h3 class="sect2"><a id="sthref968"></a>Sample Program 3: Fetching in Batches<a id="sthref969"></a><a id="sthref970"></a></h3>
<p>The following host table sample program can be found in the demo directory.</p>
<pre>      *****************************************************************
      * Sample Program 3:  Host Tables                                *
      *                                                               *
      * This program logs on to ORACLE, declares and opens a cursor,  *
      * fetches in batches using host tables, and prints the results. *
      *****************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID. HOST-TABLES.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(15) VARYING.
       01  PASSWD            PIC X(15) VARYING.
       01  EMP-REC-TABLES.
           05  EMP-NUMBER    OCCURS 5 TIMES PIC S9(4) COMP.
           05  EMP-NAME      OCCURS 5 TIMES PIC X(10) VARYING.
           05  SALARY        OCCURS 5 TIMES PIC S9(6)V99
                             DISPLAY SIGN LEADING SEPARATE.
           EXEC SQL VAR SALARY IS DISPLAY(8,2) END-EXEC.
           EXEC SQL END DECLARE SECTION END-EXEC.
           EXEC SQL INCLUDE SQLCA END-EXEC.
       01  NUM-RET           PIC S9(9) COMP VALUE ZERO.
       01  PRINT-NUM         PIC S9(9) COMP VALUE ZERO.
       01  COUNTER           PIC S9(9) COMP.
       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME    PIC X(10).
           05  D-EMP-NUMBER  PIC 9(4).
           05  D-SALARY      PIC Z(4)9.99.

       PROCEDURE DIVISION.

       BEGIN-PGM.
           EXEC SQL 
               WHENEVER SQLERROR DO PERFORM SQL-ERROR
           END-EXEC.
           PERFORM LOGON.
           EXEC SQL 
               DECLARE C1 CURSOR FOR
               SELECT EMPNO, SAL, ENAME 
               FROM EMP
           END-EXEC.
           EXEC SQL
               OPEN C1
           END-EXEC.

       FETCH-LOOP.
           EXEC SQL 
               WHENEVER NOT FOUND DO PERFORM SIGN-OFF
           END-EXEC.
           EXEC SQL 
               FETCH C1 
               INTO :EMP-NUMBER, :SALARY, :EMP-NAME
           END-EXEC.
           SUBTRACT NUM-RET FROM SQLERRD(3) GIVING PRINT-NUM.
           PERFORM PRINT-IT.
           MOVE SQLERRD(3) TO NUM-RET.
           GO TO FETCH-LOOP.

       LOGON.
           MOVE &#34;SCOTT&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;TIGER&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
              CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER:  &#34;, USERNAME-ARR.

       PRINT-IT.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;EMPLOYEE NUMBER  SALARY   EMPLOYEE NAME&#34;.
           DISPLAY &#34;---------------  -------  -------------&#34;.
           PERFORM PRINT-ROWS
               VARYING COUNTER FROM 1 BY 1
               UNTIL COUNTER &gt; PRINT-NUM.

       PRINT-ROWS.      
           MOVE EMP-NUMBER(COUNTER) TO D-EMP-NUMBER.
           MOVE SALARY(COUNTER) TO D-SALARY.
           DISPLAY &#34;           &#34;, D-EMP-NUMBER, &#34; &#34;, D-SALARY, &#34;  &#34;,
               EMP-NAME-ARR IN EMP-NAME(COUNTER).
           MOVE SPACES TO EMP-NAME-ARR IN EMP-NAME(COUNTER).

       SIGN-OFF.
           SUBTRACT NUM-RET FROM SQLERRD(3) GIVING PRINT-NUM.
           IF (PRINT-NUM &gt; 0) PERFORM PRINT-IT.
           EXEC SQL 
               CLOSE C1 
           END-EXEC. 
           EXEC SQL 
               COMMIT WORK RELEASE 
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY.&#34;.
           DISPLAY &#34; &#34;.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL 
               WHENEVER SQLERROR CONTINUE 
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL 
               ROLLBACK WORK RELEASE 
           END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3159"></a>
<div id="LNPCB470" class="sect1">
<h2 class="sect1">Inserting with Tables</h2>
<p>You can use host tables as input variables in an INSERT statement. Just make sure your program populates the tables with data before executing the INSERT statement. If some elements in the tables are irrelevant, you can use the FOR clause to control the number of rows inserted. See <a href="#i3048">&#34;The FOR Clause&#34;</a>.<a id="sthref971"></a><a id="sthref972"></a><a id="sthref973"></a></p>
<p>An example of inserting with host tables follows:</p>
<pre> 01  EMP-REC-TABLES.
     05  EMP-NUMBER    OCCURS 50 TIMES PIC S9(4) COMP.
     05  EMP-NAME      OCCURS 50 TIMES PIC X(10) VARYING.
     05  SALARY        OCCURS 50 TIMES PIC S9(6)V99
                       DISPLAY SIGN LEADING SEPARATE.
* -- populate the host tables
     EXEC SQL INSERT INTO EMP (ENAME, EMPNO, SAL)
         VALUES (:EMP-NAME, :EMP-NUMBER, :SALARY)
     END-EXEC.
</pre>
<p>The number of rows inserted will be available in SQLERRD(3).</p>
<p>Host tables must <span class="italic">not</span> be subscripted in SQL statements. For example the following INSERT statement is invalid:</p>
<pre>     PERFORM VARYING I FROM 1 BY 1 UNTIL I = TABLE-DIMENSION.
        EXEC SQL INSERT INTO EMP (ENAME, EMPNO, SAL)
            VALUES (:EMP-NAME(I), :EMP-NUMBER(I), :SALARY(I))
        END_EXEC
     END-PERFORM.
</pre>
<div id="LNPCB471" class="sect2"><a id="sthref974"></a>
<h3 class="sect2">Restrictions on Host Tables</h3>
<p>Mixing simple host variables with host tables in the VALUES clause of an INSERT, UPDATE, or DELETE statement causes only the first element of any host table to be processed because simple host variables are treated as host tables of dimension one and Pro*COBOL always uses the smallest declared dimension. You receive a warning when this occurs.<a id="sthref975"></a><a id="sthref976"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3164"></a>
<div id="LNPCB472" class="sect1">
<h2 class="sect1">Updating with Tables</h2>
<p>You can also use host tables as input variables in an UPDATE statement, as the following example shows:<a id="sthref977"></a><a id="sthref978"></a></p>
<pre> 01  EMP-REC-TABLES.
     05  EMP-NUMBER    OCCURS 50 TIMES PIC S9(4) COMP.
     05  SALARY        OCCURS 50 TIMES PIC S9(6)V99 
                           DISPLAY SIGN LEADING SEPARATE.
 ...
* --  populate the host tables
     EXEC SQL
         UPDATE EMP SET SAL = :SALARY WHERE EMPNO = :EMP-NUMBER
     END-EXEC.
</pre>
<p>The number of rows updated by issuing this statement is available in SQLERRD(3). This is not necessarily the number of rows in the host table. The number does <span class="italic">not</span> include rows processed by an update cascade (which causes subsequent updates.)</p>
<p>If some elements in the tables are irrelevant, you can use the FOR clause to limit the number of rows updated.</p>
<p>The last example showed a typical update using a unique key (<span class="italic">EMP-NUMBER</span>). Each table element qualified just one row for updating. In the following example, each table element qualifies multiple rows:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ...
            05  JOB-TITLE      OCCURS 10 TIMES PIC X(10) VARYING.
            05  COMMISSION     OCCURS 50 TIMES PIC S9(6)V99
                              DISPLAY SIGN LEADING SEPARATE.
     EXEC SQL END DECLARE SECTION END-EXEC.
* --  populate the host tables
     EXEC SQL
         UPDATE EMP SET COMM = :COMMISSION WHERE JOB = :JOB-TITLE
     END-EXEC.
</pre>
<div id="LNPCB473" class="sect2"><a id="sthref979"></a>
<h3 class="sect2">Restrictions in UPDATE</h3>
<p>You cannot use host tables with the CURRENT OF clause in an UPDATE statement. For an alternative, see <a href="#i3051">&#34;Mimicking the CURRENT OF Clause&#34;</a>.</p>
<p><a href="#g12833">Table 7-2</a> shows which uses of host tables are valid in an UPDATE statement:</p>
<div id="LNPCB474" class="tblformal">
<p class="titleintable"><a id="sthref980"></a><a id="g12833"></a>Table 7-2 Host Tables Valid in UPDATE</p>
<table class="cellalignment4971" title="Host Tables Valid in UPDATE" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t3">SET Clause</th>
<th class="cellalignment4972" id="r1c2-t3">WHERE Clause</th>
<th class="cellalignment4972" id="r1c3-t3">Valid?</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t3" headers="r1c1-t3">
<p>table</p>
</td>
<td class="cellalignment4973" headers="r2c1-t3 r1c2-t3">
<p>table</p>
</td>
<td class="cellalignment4973" headers="r2c1-t3 r1c3-t3">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t3" headers="r1c1-t3">
<p>scalar</p>
</td>
<td class="cellalignment4973" headers="r3c1-t3 r1c2-t3">
<p>scalar</p>
</td>
<td class="cellalignment4973" headers="r3c1-t3 r1c3-t3">
<p>yes</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t3" headers="r1c1-t3">
<p>table</p>
</td>
<td class="cellalignment4973" headers="r4c1-t3 r1c2-t3">
<p>scalar</p>
</td>
<td class="cellalignment4973" headers="r4c1-t3 r1c3-t3">
<p>no</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t3" headers="r1c1-t3">
<p>scalar</p>
</td>
<td class="cellalignment4973" headers="r5c1-t3 r1c2-t3">
<p>table</p>
</td>
<td class="cellalignment4973" headers="r5c1-t3 r1c3-t3">
<p>no</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3169"></a>
<div id="LNPCB475" class="sect1">
<h2 class="sect1">Deleting with Tables</h2>
<p>You can also use host tables as input variables in a DELETE statement. Doing so is like executing the DELETE statement repeatedly using successive elements of the host table in the WHERE clause. Thus, each execution might delete zero, one, or more rows from the table. An example of deleting with host tables follows:<a id="sthref981"></a><a id="sthref982"></a></p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ... 
         05  EMP-NUMBER    OCCURS 50 TIMES PIC S9(4) COMP.
     EXEC SQL END DECLARE SECTION END-EXEC.
* --  populate the host table
     EXEC SQL
         DELETE FROM EMP WHERE EMPNO = :EMP-NUMBER
     END-EXEC.
</pre>
<p>The cumulative number of rows deleted can be found in SQLERRD(3). That number does <span class="italic">not</span> include rows processed by a delete cascade.</p>
<p>The last example showed a typical delete using a unique key (<span class="italic">EMP-NUMBER</span>). Each table element qualified just one row for deletion. In the following example, each table element qualifies multiple rows:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ...
            05  JOB-TITLE    OCCURS 10 TIMES PIC X(10) VARYING.
     EXEC SQL END DECLARE SECTION END-EXEC.
* --  populate the host table
     EXEC SQL
        DELETE FROM EMP WHERE JOB = :JOB-TITLE
     END-EXEC.
</pre>
<div id="LNPCB476" class="sect2"><a id="sthref983"></a>
<h3 class="sect2">Restrictions in DELETE<a id="sthref984"></a></h3>
<p>You cannot use host tables with the CURRENT OF clause in a DELETE statement. For an alternative, see <a href="#i3051">&#34;Mimicking the CURRENT OF Clause&#34;</a>.<a id="sthref985"></a><a id="sthref986"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3174"></a>
<div id="LNPCB477" class="sect1">
<h2 class="sect1">Using Indicator Tables</h2>
<p>You use indicator tables to assign NULLs to input host tables and to detect NULL or truncated values in output host tables. The following example shows how to insert with indicator tables:</p>
<pre> 01  EMP-REC-VARS.
     05  EMP-NUMBER  OCCURS 50 TIMES PIC S9(4) COMP.
     05  DEPT-NUMBER OCCURS 50 TIMES PIC S9(4) COMP.
     05  COMMISSION  OCCURS 50 TIMES  PIC S9(6)V99
                            DISPLAY SIGN LEADING SEPARATE.
* -- indicator table:
     05  COMM-IND    OCCURS 50 TIMES  PIC S9(4) COMP.
* --  populate the host tables
* --  populate the indicator table; to insert a NULL into 
* --  the COMM column, assign -1 to the appropriate element in
* --  the indicator table
     EXEC SQL
         INSERT INTO EMP (EMPNO, DEPTNO, COMM)
         VALUES (:EMP_NUMBER, :DEPT-NUMBER, :COMMISSION:COMM-IND)
     END-EXEC.
</pre>
<p>The number of entries of the indicator table cannot be smaller than the number of entries of the host table.</p>
</div>
<!-- class="sect1" -->
<a id="i3048"></a>
<div id="LNPCB478" class="sect1">
<h2 class="sect1">The FOR Clause</h2>
<p>You can use the optional FOR clause to set the number of table elements processed by any of the following SQL statements:</p>
<ul>
<li>
<p>DELETE</p>
</li>
<li>
<p>EXECUTE (See information on Oracle dynamic SQL in <a href="pco11ody.htm#i9695">Chapter 11, &#34;Oracle Dynamic SQL: Method 4&#34;</a>.</p>
</li>
<li>
<p>FETCH</p>
</li>
<li>
<p>INSERT</p>
</li>
<li>
<p>OPEN</p>
</li>
<li>
<p>UPDATE</p>
</li>
</ul>
<p>The FOR clause is especially useful in UPDATE, INSERT, and DELETE statements. With these statements you might not want to use the entire table. The FOR clause lets you limit the elements used to just the number you need, as the following example shows:<a id="sthref987"></a><a id="sthref988"></a><a id="sthref989"></a><a id="sthref990"></a></p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01  EMP-REC-VARS.
     05  EMP-NAME  OCCURS 1000 TIMES  PIC X(20) VARYING.
     05  SALARY    OCCURS 100  TIMES  PIC S9(6)V99
                   DISPLAY SIGN LEADING SEPARATE.
 01 ROWS-TO-INSERT PIC S9(4) COMP.
     EXEC SQL END DECLARE SECTION END-EXEC.
* --  populate the host tables
     MOVE 25 TO ROWS-TO-INSERT.
* -- set FOR-clause variable
* -- will process only 25 rows
     EXEC SQL FOR :ROWS-TO-INSERT  
         INSERT INTO EMP (ENAME, SAL)
         VALUES (:EMP-NAME, :SALARY)
     END-EXEC.
</pre>
<p>The FOR clause must use an integer host variable to count table elements. For example, the following statement is illegal:</p>
<pre>* -- illegal
     EXEC SQL FOR 25           
     INSERT INTO EMP (ENAME, EMPNO, SAL)
         VALUES (:EMP-NAME, :EMP-NUMBER, :SALARY)
     END-EXEC.
</pre>
<p>The FOR clause variable specifies the number of table elements to be processed. Make sure the number does not exceed the smallest table dimension. Internally, the value is treated as an unsigned quantity. An attempt to pass a negative value through the use of a signed host variable will result in unpredictable behavior.</p>
<div id="LNPCB479" class="sect2"><a id="sthref991"></a>
<h3 class="sect2">Restrictions</h3>
<p>Two restrictions keep FOR clause semantics clear: you cannot use the FOR clause in a SELECT statement or with the CURRENT OF clause.<a id="sthref992"></a><a id="sthref993"></a></p>
<div id="LNPCB480" class="sect3"><a id="sthref994"></a>
<h4 class="sect3">In a SELECT Statement</h4>
<p>If you use the FOR clause in a SELECT statement, you receive an error message.</p>
<p>The FOR clause is not allowed in SELECT statements because its meaning is unclear. Does it mean &#34;execute this SELECT statement <span class="italic">n</span> times&#34;? Or, does it mean &#34;execute this SELECT statement once, but return <span class="italic">n</span> rows&#34;? The problem in the former case is that each execution might return multiple rows. In the latter case, it is better to declare a cursor and use the FOR clause in a FETCH statement, as follows:</p>
<pre>     EXEC SQL FOR :LIMIT FETCH EMPCURSOR INTO ...
</pre></div>
<!-- class="sect3" -->
<div id="LNPCB481" class="sect3"><a id="sthref995"></a>
<h4 class="sect3">With the CURRENT OF Clause</h4>
<p>You can use the CURRENT OF clause in an UPDATE or DELETE statement to refer to the latest row returned by a FETCH statement, as the following example shows:</p>
<pre>     EXEC SQL DECLARE EMPCURSOR CURSOR FOR 
         SELECT ENAME, SAL FROM EMP WHERE EMPNO = :EMP-NUMBER
     END-EXEC.
     ... 
     EXEC SQL OPEN EMPCURSOR END-EXEC.
     ...
     EXEC SQL FETCH emp_cursor INTO :EM-NAME, :SALARY END-EXEC.
     ...
     EXEC SQL UPDATE EMP SET SAL = :NEW-SALARY
         WHERE CURRENT OF EMPCURSOR
     END-EXEC.
</pre>
<p>However, you cannot use the FOR clause with the CURRENT OF clause. The following statements are invalid because the only logical value of <span class="italic">LIMIT</span> is 1 (you can only update or delete the current row once):</p>
<pre>     EXEC SQL FOR :LIMIT UPDA-CURSOR END-EXEC.
     ...
     EXEC SQL FOR :LIMIT DELETE FROM EMP 
         WHERE CURRENT OF emp_cursor
     END-EXEC.
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3061"></a>
<div id="LNPCB482" class="sect1">
<h2 class="sect1">The WHERE Clause</h2>
<p>Pro*COBOL treats a SQL statement containing host tables of number of entries <span class="italic">n</span> like the same SQL statement executed <span class="italic">n</span> times with <span class="italic">n</span> different scalar variables (the individual table elements). The precompiler issues an error message only when such treatment is ambiguous:<a id="sthref996"></a><a id="sthref997"></a></p>
<p>For example, assuming the declarations:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ...
     05  MGRP-NUMBER  OCCURS 50 TIMES  PIC S9(4) COMP.
     05  JOB-TITLE    OCCURS 50 TIMES  PIC X(20) VARYING.
 01  I PIC S9(4) COMP.
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre>
<p>it would be ambiguous if the statement:</p>
<pre>     EXEC SQL SELECT MGR INTO :MGR-NUMBER FROM EMP
         WHERE JOB = :JOB-TITLE
     END-EXEC.
</pre>
<p>were treated like the following statement</p>
<pre>     PERFORM VARYING I FROM 1 BY 1 UNTIL I = 50
     SELECT MGR INTO :MGR-NUMBER(I) FROM EMP
         WHERE JOB = :JOB_TITLE(I)
     END-EXEC
     END-PERFORM.
</pre>
<p>because multiple rows might meet the WHERE-clause search condition, but only one output variable is available to receive data. Therefore, an error message is issued.</p>
<p>On the other hand, it would not be ambiguous if the statement</p>
<pre>      EXEC SQL
         UPDATE EMP SET MGR = :MGR_NUMBER
         WHERE EMPNO IN (SELECT EMPNO FROM EMP WHERE
         JOB = :JOB-TITLE)
     END-EXEC.
</pre>
<p>were treated like the following statement</p>
<pre>     PERFORM VARYING I FROM 1 BY 1 UNTIL I = 50
<span class="bold">         </span>UPDATE EMP SET MGR = :MGR_NUMBER(I)
             WHERE EMPNO IN
             (SELECT EMPNO FROM EMP WHERE JOB = :JOB-TITLE(I))
         END-EXEC
     END-PERFORM.
</pre>
<p>because there is a <span class="italic">MGR-NUMBER</span> in the SET clause for each row matching <span class="italic">JOB-TITLE</span> in the WHERE clause, even if each <span class="italic">JOB-TITLE</span> matches multiple rows. All rows matching each <span class="italic">JOB-TITLE</span> can be SET to the same <span class="italic">MGR-NUMBER</span>, so no error message is issued.</p>
</div>
<!-- class="sect1" -->
<a id="i3051"></a>
<div id="LNPCB483" class="sect1">
<h2 class="sect1">Mimicking the CURRENT OF Clause</h2>
<p>The CURRENT OF clause enables you to do UPDATEs or DELETEs of the most recent row in the cursor. Use of the CURRENT OF clause causes the FOR UPDATE clause to be added to the cursor. Adding this clause has the effect of locking all rows identified by the cursor in exclusive mode. Note that you cannot use CURRENT OF with host tables. Instead, append FOR UPDATE to the definition of the cursor and explicitly select the ROWID column, then use that value to identify the current row during the update or delete. An example follows:<a id="sthref998"></a><a id="sthref999"></a></p>
<pre>         05  EMP-NAME    OCCURS 25 TIMES PIC X(20) VARYING.
         05  JOB-TITLE   OCCURS 25 TIMES PIC X(15) VARYING.
         05  OLD-TITLE   OCCURS 25 TIMES PIC X(15) VARYING.
         05  ROW-ID      OCCURS 25 TIMES PIC X(18) VARYING.
     ...
     EXEC SQL DECLARE EMPCURSOR CURSOR FOR
         SELECT ENAME, JOB, ROWID FROM EMP
         FOR UPDATE
     END-EXEC.
     ...
     EXEC SQL OPEN EMPCURSOR END-EXEC.
     ...
     EXEC SQL WHENEVER NOT FOUND GOTO <span class="bold">...</span>
     ...
     PERFORM
        <span class="bold"> </span>EXEC SQL
             FETCH EMPCURSOR
             INTO :EMP-NAME, :JOB-TITLE, :ROW-ID
         END-EXEC
         ...
         EXEC SQL
             DELETE FROM EMP
             WHERE JOB = :OLD-TITLE AND ROWID = :ROW-ID
         END-EXEC
         EXEC SQL COMMIT WORK END-EXEC
      END-PERFORM.
</pre></div>
<!-- class="sect1" -->
<a id="i5458"></a>
<div id="LNPCB484" class="sect1">
<h2 class="sect1">Tables of Group Items as Host Variables</h2>
<p>Pro*COBOL allows the use of tables of group items (also called <span class="italic">records</span>) in embedded SQL statements. The tables of group items can be referenced in the INTO clause of a SELECT or a FETCH statement, and in the VALUES list of an INSERT statement.</p>
<p>For example, given the following declaration:</p>
<pre> 01    TABLES.
       05   EMP-TABLE           OCCURS 20 TIMES.
            10    EMP-NUMBER    PIC S9(4) COMP.
            10    EMP-NAME      PIC X(10).
            10    DEPT-NUMBER   PIC S9(4) COMP.
</pre>
<p>the following statement is valid:</p>
<pre>       EXEC SQL INSERT INTO EMP(EMPNO, ENAME, DEPTNO)
            VALUES(:EMP-TABLE)
       END-EXEC.
</pre>
<p>Assuming that the group item has been filled with data already, the statement bulk inserts 20 rows consisting of the employee number, employee name, and department number into the EMP table.</p>
<p>Make sure that the order of the group items corresponds to the order in the SQL statement.</p>
<p>To use an indicator variable, set up a second table of a group item that contains an indicator variable for each variable in the group item:</p>
<pre> 01     TABLES-IND.
        05   EMP-TABLE-IND  OCCURS 20 TIMES.
             10   EMP-NUMBER-IND       PIC S9(4) COMP.
             10   EMP-NAME-IND         PIC S9(4) COMP.
             10   DEPT-NUMBER_IND      PIC S9(4) COMP.
</pre>
<p>The host indicator table of a group item can be used as follows:</p>
<pre>        EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO)
            VALUES (:EMP-TABLE:EMP-TABLE-IND)
        END-EXEC.
</pre>
<p>If the exact characteristics of the data are known, it is convenient to specify an elementary item indicator for a group item:</p>
<pre>        05    EMP-TABLE-IND     PIC S9(4) COMP
                                OCCURS 20 TIMES.
</pre>
<p>Host tables of group items cannot have group items that are tables. For example:</p>
<pre> 01   TABLES.
      05   EMP-TABLE               OCCURS 20 TIMES.
           10  EMP-NUMBER          PIC S9(4) COMP OCCURS 10 TIMES.
           10  EMP-NAME            PIC X(10).
           10  DEPT-NUMBER         PIC S9(4) COMP.
</pre>
<p><code>EMP-TABLE</code> <span class="italic">cannot</span> be used as a host variable because <code>EMP-NUMBER</code> is a table.</p>
<p>Host tables of nested group items are not allowed. For example:</p>
<pre> 01   TABLES.
      05   TEAM-TABLE                   OCCURS 20 TIMES
           10   EMP-TABLE
                15   EMP-NUMBER         PIC S9(4) COMP.
                15   EMP-NAME           PIC X(10).
           10   DEPT-TABLE.
                15   DEPT-NUMBER        PIC S9(4) COMP.
                15   DEPT-NAME          PIC X(10).
</pre>
<p><code>TEAM-TABLE</code> cannot be used as a host variable because its members (<code>EMP-TABLE</code> and <code>DEPT-TABLE</code>) are group items themselves.</p>
<p>Finally, the restrictions that apply to host tables in Pro*COBOL also apply to tables of group items:</p>
<ul>
<li>
<p>Multi-dimensional and variable-length tables are not allowed.</p>
</li>
<li>
<p>If multiple tables are used in a single SQL statement, their dimensions should be the same.</p>
</li>
<li>
<p>Host tables in SQL statements must not be subscripted.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i6870"></a>
<div id="LNPCB485" class="sect1">
<h2 class="sect1">Sample Program 14: Tables of Group Items<a id="sthref1000"></a><a id="sthref1001"></a></h2>
<p>This program logs on, declares and opens a cursor, fetches in batches using a table of group items. Read the initial comments for details.<a id="sthref1002"></a></p>
<pre>      *****************************************************************
      * Sample Program 14:  Tables of group items                     *
      *                                                               *
      * This program logs on to ORACLE, declares and opens a cursor,  *
      * fetches in batches using a table of group items , and prints  *
      * the results.  This sample is identical to sample3 except that *
      * instead of using three separate host tables of five elements  *
      * each, it uses a five-element table of three group items.      *
      * The output should be identical.                               *
      *****************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID. TABLE-OF-GROUP-ITEMS.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(15) VARYING.
       01  PASSWD            PIC X(15) VARYING.
       01  EMP-REC-TABLE OCCURS 5 TIMES.
           05  EMP-NUMBER    PIC S9(4) COMP.
           05  SALARY        PIC S9(6)V99
                             DISPLAY SIGN LEADING SEPARATE.
           05  EMP-NAME      PIC X(10) VARYING.
           EXEC SQL VAR SALARY IS DISPLAY(8,2) END-EXEC.
           EXEC SQL END DECLARE SECTION END-EXEC.
           EXEC SQL INCLUDE SQLCA END-EXEC.
       01  NUM-RET           PIC S9(9) COMP VALUE ZERO.
       01  PRINT-NUM         PIC S9(9) COMP VALUE ZERO.
       01  COUNTER           PIC S9(9) COMP.
       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME    PIC X(10).
           05  D-EMP-NUMBER  PIC 9(4).
           05  D-SALARY      PIC Z(4)9.99.

       PROCEDURE DIVISION.

       BEGIN-PGM.
           EXEC SQL 
               WHENEVER SQLERROR DO PERFORM SQL-ERROR
           END-EXEC.
           PERFORM LOGON.
           EXEC SQL 
               DECLARE C1 CURSOR FOR
               SELECT EMPNO, SAL, ENAME 
               FROM EMP
           END-EXEC.
           EXEC SQL
               OPEN C1
           END-EXEC.

       FETCH-LOOP.
           EXEC SQL 
               WHENEVER NOT FOUND DO PERFORM SIGN-OFF
           END-EXEC.
           EXEC SQL 
               FETCH C1 
               INTO :EMP-REC-TABLE
           END-EXEC.
           SUBTRACT NUM-RET FROM SQLERRD(3) GIVING PRINT-NUM.
           PERFORM PRINT-IT.
           MOVE SQLERRD(3) TO NUM-RET.
           GO TO FETCH-LOOP.

       LOGON.
           MOVE &#34;SCOTT&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;TIGER&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
              CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER:  &#34;, USERNAME-ARR.

       PRINT-IT.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;EMPLOYEE NUMBER  SALARY   EMPLOYEE NAME&#34;.
           DISPLAY &#34;---------------  -------  -------------&#34;.
           PERFORM PRINT-ROWS
               VARYING COUNTER FROM 1 BY 1
               UNTIL COUNTER &gt; PRINT-NUM.

       PRINT-ROWS.      
           MOVE EMP-NUMBER(COUNTER) TO D-EMP-NUMBER.
           MOVE SALARY(COUNTER) TO D-SALARY.
           DISPLAY &#34;           &#34;, D-EMP-NUMBER, &#34; &#34;, D-SALARY, &#34;  &#34;,
               EMP-NAME-ARR IN EMP-NAME(COUNTER).
           MOVE SPACES TO EMP-NAME-ARR IN EMP-NAME(COUNTER).

       SIGN-OFF.
           SUBTRACT NUM-RET FROM SQLERRD(3) GIVING PRINT-NUM.
           IF (PRINT-NUM &gt; 0) PERFORM PRINT-IT.
           EXEC SQL 
               CLOSE C1 
           END-EXEC. 
           EXEC SQL 
               COMMIT WORK RELEASE 
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY.&#34;.
           DISPLAY &#34; &#34;.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL 
               WHENEVER SQLERROR CONTINUE 
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL 
               ROLLBACK WORK RELEASE 
           END-EXEC.
           STOP RUN.
 
</pre></div>
<!-- class="sect1" -->
<a id="CHDCCHAE"></a>
<div id="LNPCB486" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Additional Array Insert/Select Syntax</h2>
<p>The Oracle precompiler also supports the DB2 insert and fetch syntax for the host tables. The supported additional array insert and fetch syntax are shown in the following images, respectively.</p>
<div id="LNPCB487" class="figure">
<p class="titleinfigure"><a id="sthref1003"></a>Figure 7-1 Additional Insert Syntax</p>
<img width="720" height="256" src="img/insert2.gif" alt="Additional Insert Syntax"/><br/>
<a id="sthref1004" href="img_text/insert2.htm">Description of &#34;Figure 7-1 Additional Insert Syntax&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="LNPCB488" class="figure">
<p class="titleinfigure"><a id="sthref1005"></a>Figure 7-2 Additional Fetch Syntax</p>
<img width="720" height="218" src="img/fetch2.gif" alt="Additional Fetch Syntax"/><br/>
<a id="sthref1006" href="img_text/fetch2.htm">Description of &#34;Figure 7-2 Additional Fetch Syntax&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The optional ROWSET and ROWSET STARTING AT clauses are used in the fetch-orientation (FIRST, PRIOR, NEXT, LAST, CURRENT, RELATIVE and ABSOLUTE). Consider the following examples:</p>
<ul>
<li>
<p>FIRST ROWSET</p>
</li>
<li>
<p>PRIOR ROWSET</p>
</li>
<li>
<p>NEXT ROWSET</p>
</li>
<li>
<p>LAST ROWSET</p>
</li>
<li>
<p>CURRENT ROWSET</p>
</li>
<li>
<p>ROWSET STARTING AT RELATIVEn</p>
</li>
<li>
<p>ROWSET STARTING AT ABSOLUTEn</p>
</li>
</ul>
<p>Examples of the DB2 array insert/fetch syntax and their comparison with the corresponding Oracle precompiler syntax are shown in <a href="#BABHDBHI">Table 7-3</a>:</p>
<div id="LNPCB489" class="tblformal">
<p class="titleintable"><a id="sthref1007"></a><a id="BABHDBHI"></a>Table 7-3 DB2 Array Syntax vs. Oracle Precompiler Syntax</p>
<table class="cellalignment4971" title="DB2 Array Syntax vs. Oracle Precompiler Syntax" summary="DB2 vs. Oracle Precompiler syntax" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t4">DB2 Array Syntax</th>
<th class="cellalignment4972" id="r1c2-t4">Oracle Precompiler Syntax</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t4" headers="r1c1-t4">
<pre>EXEC SQL
  INSERT INTO DSN8810.ACT 
  (ACTNO, ACTKWD, ACTDESC) 
  VALUES (:HVA1, :HVA2, :HVA3)
  FOR :NUM_ROWS ROWS  
END-EXEC.
</pre></td>
<td class="cellalignment4973" headers="r2c1-t4 r1c2-t4">
<pre>EXEC SQL FOR :NUM_ROWS
  INSERT INTO DSN8810.ACT
  (ACTNO, ACTKWD, ACTDESC)
  VALUES (:HVA1, :HVA2, :HVA3)
END-EXEC.
</pre></td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t4" headers="r1c1-t4">
<pre>EXEC SQL
  FETCH NEXT ROWSET FROM C1 
  FOR 20 ROWS 
  INTO :HVA_EMPNO, :HVA_LASTNAME, 
       :HVA_SALARY 
END-EXEC.
</pre></td>
<td class="cellalignment4973" headers="r3c1-t4 r1c2-t4">
<pre>EXEC SQL
   FOR :TWENTY
   FETCH c1 
   INTO :HVA_EMPNO, :HVA_LASTNAME,
        :HVA_SALARY
END-EXEC.
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>In DB2 syntax, a row-set positioned cursor should be first declared before retrieving row sets of data. To enable a cursor to fetch row sets, &#39;WITH ROWSET POSITIONING&#39; clause has to be used in the DECLARE CURSOR statement, which is not required and relevant in the Oracle precompiler syntax, as shown in the following table.</p>
<div class="inftblinformal">
<table class="cellalignment4974" title="Difference between DB2 and Oracle precompiler syntax" summary="table for difference between DB2 and Oracle precompiler syntax" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t5">DB2 Array Syntax</th>
<th class="cellalignment4972" id="r1c2-t5">Oracle Precompiler Syntax</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t5" headers="r1c1-t5">
<pre>EXEC SQL
 DECLARE C1 CURSOR
  WITH ROWSET POSITIONING FOR
  SELECT EMPNO, LASTNAME, SALARY
      FROM DSN8810.EMP
END-EXEC.
</pre></td>
<td class="cellalignment4973" headers="r2c1-t5 r1c2-t5">
<pre>EXEC SQL
   DECLARE C1 CURSOR FOR
   SELECT EMPNO, LASTNAME, SALARY
        FROM DSN8810.EMP
END-EXEC.
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>This additional array syntax support can be enabled with the precompiler option &#34;db2_array&#34;, whose default option is &#34;no&#34;. The DB2 array syntax support cannot be used together with the Oracle precompiler syntax; only one of the syntax, either Oracle precompiler, or DB2 syntax, will be supported at a time.</p>
<div id="LNPCB490" class="example">
<p class="titleinexample"><a id="sthref1008"></a>Example 7-1 Inserting and Fetching Rows by Using the DB2 Array Syntax</p>
<p>This program inserts INSCNT rows into the EMP table by using the DB2 array insert syntax, and then fetches the inserted rows by using the DB2 array fetch syntax.</p>
<pre>      *****************************************************************
      * db2arrdemo:                                                   *
      *****************************************************************
 
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  db2arrdemo.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
 
      * EMBEDDED COBOL (file &#34;DB2ARRDEMO.PCO&#34;)  
 
           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
       01  EMPINDATA.
           02  EMPIN OCCURS 25 TIMES.
              03  EMPNO PIC  9(4) COMP.
              03  ENAME PIC  X(10).
              03  JOB PIC  X(9).
              03  MGR PIC 9(4).
              03  HIREDATE PIC  X(9).
              03  SAL PIC  X(6).
              03  COMM PIC  X(6).
              03  DEPTNO PIC  9(2).
 
       01  EMPOUTDATA.
           02  EMPOUT OCCURS 5 TIMES.
              03  EMPNO1 PIC  9(4) COMP.
              03  ENAME1 PIC  X(10).
              03  JOB1 PIC  X(9).
              03  MGR1 PIC 9(4).
              03  HIREDATE1 PIC  X(9).
              03  SAL1 PIC  X(6).
              03  COMM1 PIC  X(6).
              03  DEPTNO1 PIC  9(2).
 
           EXEC SQL END DECLARE SECTION END-EXEC.
 
       01  INSCNT PIC  9(3) COMP VALUE 25.
       01  FETCHCNT PIC  9(3) COMP VALUE 5.
       01  CNT PIC  9(4).
       01  CNT2 PIC  9(2).
 
       01  STRINGFIELDS.
           02 STR PIC X(18) VARYING.
 
           EXEC SQL INCLUDE SQLCA END-EXEC.
 
       PROCEDURE DIVISION.
       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR END-EXEC.
 
           PERFORM LOGON.
 
      * Fill the array elements to insert.
   PERFORM FILL-DATA VARYING CNT FROM 1 BY 1 
           UNTIL CNT &gt; INSCNT.
 
      * Inserting data using DB2 array insert syntax.
   DISPLAY &#34;Inserting data using DB2 array insert syntax&#34;.
   EXEC SQL INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE,
            SAL, COMM, DEPTNO) VALUES (:EMPIN)
    FOR :INSCNT ROWS
   END-EXEC.
 
   EXEC SQL SELECT COUNT(*) INTO :CNT FROM EMP
            WHERE ENAME LIKE &#39;EMP_%&#39;
   END-EXEC.
   DISPLAY &#34;Number of rows successfully inserted into EMP &#34;
           &#34;table:&#34;, CNT.
 
   DISPLAY &#34; &#34;.
      * Declares scrollable cursor to fetch data.
           EXEC SQL DECLARE C1 SCROLL CURSOR FOR
                    SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL,
    COMM, DEPTNO 
    FROM EMP
            WHERE ENAME LIKE &#39;EMP_%&#39;
    ORDER BY EMPNO
   END-EXEC.
 
           EXEC SQL OPEN C1 END-EXEC.
 
   DISPLAY &#34;Fetching data using DB2 array fetch syntax &#34;. 
         PERFORM FETCH-TAB.
       ENDFETCH-TAB.
 
   EXEC SQL CLOSE C1 END-EXEC.
 
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
 
       LOGON.
           MOVE &#34;scott&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;tiger&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
 
      * FILLS ARRAY TO INSERT INTO EMP TABLE
       FILL-DATA.
           MOVE CNT TO EMPNO(CNT).
 
   MOVE &#34; &#34; TO STR.
   STRING &#34;EMP_&#34;, CNT INTO STR
   END-STRING.
   MOVE STR TO ENAME(CNT).
 
   MOVE &#34; &#34; TO STR.
   STRING &#34;JOB_&#34;, CNT INTO STR
   END-STRING.
   MOVE STR TO JOB(CNT).
 
   MOVE 100 TO MGR(CNT).
 
   IF CNT &gt; 30 THEN
       COMPUTE CNT2 = 30
   ELSE 
       MOVE CNT TO CNT2
   END-IF
 
   MOVE &#34; &#34; TO STR.
   STRING CNT2, &#34;-JAN-06&#34; INTO STR
   END-STRING.
   MOVE STR TO HIREDATE(CNT).
 
   MOVE &#34; &#34; TO STR.
   STRING CNT2, &#34;000&#34; INTO STR
   END-STRING.
   MOVE STR TO SAL(CNT).
 
   MOVE 1000 TO COMM(CNT).
 
   MOVE 10 TO DEPTNO(CNT).
 
      * FETCHES DATA FROM EMP TABLE
       FETCH-TAB.
           EXEC SQL WHENEVER NOT FOUND GOTO ENDFETCH-TAB END-EXEC.
   DISPLAY &#34;Fetch using FETCH FIRST ROWSET&#34;. 
           EXEC SQL FETCH FIRST ROWSET FROM C1 FOR :FETCHCNT ROWS 
            INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY &#34; &#34;.
   DISPLAY &#34;Fetch using FETCH NEXT ROWSET&#34;. 
           EXEC SQL FETCH NEXT ROWSET FROM C1 FOR 5 ROWS 
            INTO :EMPOUT END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY &#34; &#34;.
   DISPLAY &#34;Fetch using FETCH CURRENT ROWSET&#34;. 
           EXEC SQL FETCH CURRENT ROWSET FROM C1 FOR :FETCHCNT ROWS 
            INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY &#34; &#34;.
   DISPLAY &#34;Fetch using FETCH LAST ROWSET&#34;. 
           EXEC SQL FETCH LAST ROWSET FROM C1 FOR :FETCHCNT ROWS 
            INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY &#34; &#34;.
   DISPLAY &#34;Fetch using FETCH ROWSET STARTING AT ABSOLUTE&#34;. 
   COMPUTE CNT = 4 * FETCHCNT.
           EXEC SQL FETCH ROWSET STARTING AT ABSOLUTE :CNT FROM C1
            FOR 5 ROWS INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY &#34; &#34;.
   DISPLAY &#34;Fetch using FETCH ROWSET STARTING AT RELATIVE&#34;. 
           EXEC SQL FETCH ROWSET STARTING AT RELATIVE -3 FROM C1
            FOR :FETCHCNT ROWS INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
   DISPLAY &#34; &#34;.
   DISPLAY &#34;Fetch using FETCH PRIOR ROWSET &#34;. 
           EXEC SQL FETCH PRIOR ROWSET FROM C1 FOR :FETCHCNT ROWS 
            INTO :EMPOUT
   END-EXEC.
   PERFORM PRINTDATA.
 
      * Prints fetched data
       PRINTDATA.
   PERFORM VARYING CNT FROM 1 BY 1 UNTIL CNT &gt; FETCHCNT
             DISPLAY &#34;Empno=&#34;, EMPNO1(CNT), &#34;, Ename=&#34;, ENAME1(CNT),
             &#34;, Job=&#34;, JOB1(CNT), &#34;, Mgr=&#34;, MGR1(CNT),
                     &#34;, Hiredate=&#34;, HIREDATE1(CNT)
             DISPLAY &#34;Sal=&#34;, SAL1(CNT), &#34;, Comm=&#34;, COMM1(CNT),
             &#34;, Deptno=&#34;, DEPTNO1(CNT)
           END-PERFORM.
 
      * HANDLES SQL ERROR CONDITIONS
       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="CHDIBDFD"></a>
<div id="LNPCB491" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Implicit Buffered Insert</h2>
<p>For improved performance, Pro*Cobol application developers can reference host arrays in their embedded SQL statements. This provides a means to execute an array of SQL statements with a single round-trip to the database. Despite the significant performance improvements afforded by array execution, some developers choose not to use this capability because it is not ANSI standard. For example, an application written to exploit array execution in Oracle cannot be precompiled using IBM&#39;s precompiler.</p>
<p>One workaround is to use buffered INSERT statements, which enable you to gain performance benefits while retaining ANSI standard embedded SQL syntax.</p>
<p>The command line option &#34;max_row_insert&#34; controls the number of rows to be buffered before executing the INSERT statement. By default it is zero and the feature is disabled. To enable this feature, specify any number greater than zero.</p>
<p>If insert bufering is enabled, precompiler runtime will flag the corresponding cursor and:</p>
<ul>
<li>
<p>Allocate or re-allocate extra memory to hold bind values (first execute only).</p>
</li>
<li>
<p>Copy bind values from program host variables to internal runtime bind structures.</p>
</li>
<li>
<p>Increment the rows buffered count.</p>
</li>
<li>
<p>Flush the buffered INSERT statements if MAX_INSERT_ROWS has been buffered.</p>
</li>
<li>
<p>If MAX_INSERT_ROWS has not been hit, then return after copying the values to the internal bind buffers without flushing.</p>
</li>
</ul>
<p>If you are executing a new embedded SQL statement that results in a flush of the buffered insert statements:</p>
<ul>
<li>
<p>Flush the buffers.</p>
</li>
<li>
<p>Continue with the call that prompted the flush</p>
</li>
</ul>
<p>The application is informed of the error through the standard precompiler error mechanisms such as SQLCODE or SQLSTATE in Pro*Cobol.</p>
<p>The &#34;implicit_svpt&#34; option controls whether an implicit savepoint is taken prior to the start of a new batched insert.</p>
<ul>
<li>
<p>If yes, a savepoint is taken prior to the start of a new batch of rows. If an error occurs on the insert, an implicit &#34;rollback to savepoint&#34; is executed.</p>
</li>
<li>
<p>If no, there is no implicit savepoint taken. If an error occurs on the buffered insert, then it is reported back to the application, but no rollback is executed. Errors are reported asynchronously for buffer inserts. Errors for inserted rows are not reported when the INSERT statement is executed in the application.</p>
<ul>
<li>
<p>Some errors for inserted rows are reported later, when the first statement other than the INSERT is executed. This may include DELETE, UPDATE, INSERT (into different tables), COMMIT, and ROLLBACK. Any statement that closes the buffered insert statement can report an error. In such cases, the statement that reports the error is not executed. You need to first handle the error and also reexecute the statement on which the buffered insert error is reported. Otherwise, you may rollback the transaction and reexecute it.</p>
<p>For example, consider using a COMMIT statement to close a buffered insert loop. COMMIT can report an error because of a duplicate key from an earlier insert. In this scenario, the commit is not executed. You should first handle the error and then reexecute COMMIT. Otherwise, you can rollback the transaction and reexecute it.</p>
</li>
<li>
<p>Some errors are reported on the insert itself, and may reflect an error of a previously inserted row. In such cases, no further inserts are executed. You need to handle the errors of the previously inserted row and continue inserting the current insert, which is a long process. Instead, you may rollback and reexecute the transaction.</p>
<p>For example, consider that the limit of internal buffer is 10 rows and the application is inserting 15 rows in a loop. Suppose there is an error on the 8th row. The error is reported when the 11th row insert happens and the insert is no more executed further.</p>
</li>
</ul>
</li>
</ul>
<p>The following are some of the possible errors that you might face during buffered insert:</p>
<ul>
<li>
<p>ORA-00001: duplicate key in index</p>
</li>
<li>
<p>ORA-01400: mandatory (not null) column is missing or Null during insert</p>
</li>
<li>
<p>ORA-01401: inserted value too large for column</p>
</li>
<li>
<p>ORA-01438: value larger than specified precision allows for this column</p>
</li>
</ul>
<div id="LNPCB492" class="example">
<p class="titleinexample"><a id="sthref1009"></a>Example 7-2 inserting Buffered Rows into a Table</p>
<p>This program inserts LOOPCNT number of rows into the EMP table. At loop counter=5, this program attempts to insert an invalid empno. Without the max_row_insert option, the program inserts all rows except the invalid row. When the max_row_insert option is set to LOOPCNT, only the first four rows are inserted.</p>
<p>Using the max_row_insert option, when the erroneous statement is removed, the program performs the same way an array insert program would.</p>
<pre> *****************************************************************
      * bufinsdemo:                                                   *
      *                                                               *
      * This program inserts LOOPCNT number of rows into EMP table.   *
      * At loop counter=5, this program attempts to insert an invalid *
      * empno. Without max_row_insert option, this program inserts    *
      * all rows except this invalid row. When max_row_insert option  *
      * is set to LOOPCNT, only the first 4 rows are inserted.        *
      *                                                               *
      * With max_row_insert option, when this errorneous statement    *
      * is removed, the performance of this program is similar to     *
      * having an array insert in this program.                       *
      *****************************************************************
 
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  bufinsdemo.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
 
      * EMBEDDED COBOL (file &#34;BUFINSDEMO.PCO&#34;)  
 
           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
 
       01  EMPIN.
           02  EMPNO PIC  9(6) COMP.
           02  ENAME PIC  X(10).
           02 JOB PIC  X(9).
           02  MGR PIC 9(4).
           02  HIREDATE PIC  X(9).
           02  SAL PIC  X(6).
           02  COMM PIC  X(6).
           02  DEPTNO PIC  9(2).
 
       01  EMPOUT.
           02  EMPNO1 PIC  9(4) COMP.
           02  ENAME1 PIC  X(10).
           02  JOB1 PIC  X(9).
           02  MGR1 PIC 9(4).
           02  HIREDATE1 PIC  X(9).
           02  SAL1 PIC  X(6).
           02  COMM1 PIC  X(6).
           02  DEPTNO1 PIC  9(2).
 
           EXEC SQL END DECLARE SECTION END-EXEC.
 
       01  LOOPCNT PIC  9(4) COMP VALUE 100.
       01  CNT PIC  9(4).
       01  CNT2 PIC  9(2).
 
       01  STRINGFIELDS.
           02 STR PIC X(18) VARYING.
 
           EXEC SQL INCLUDE SQLCA END-EXEC.
 
       PROCEDURE DIVISION.
       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR END-EXEC.
 
           PERFORM LOGON.
 
      * When max_row_insert option is set to LOOPCNT and when the errorneous
      * statement is removed, all the rows will be inserted into the database
      * in one stretch and hence maximum performance gain will be achieved.
   DISPLAY &#34;Inserting &#34;, LOOPCNT, &#34; rows into EMP table&#34;.
   PERFORM INS-TAB VARYING CNT FROM 1 BY 1 
           UNTIL CNT &gt; LOOPCNT.
 
   EXEc SQL COMMIT END-EXEC.
 
   EXEC SQL SELECT COUNT(*) INTO :CNT FROM EMP
            WHERE ENAME LIKE &#39;EMP_%&#39;
   END-EXEC.
   DISPLAY &#34;Number of rows successfully inserted into EMP &#34;
           &#34;table:&#34;, CNT.
 
   DISPLAY &#34; &#34;.
           EXEC SQL DECLARE C1 CURSOR FOR
                    SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL,
    COMM, DEPTNO 
    FROM EMP
            WHERE ENAME LIKE &#39;EMP_%&#39;
    ORDER BY EMPNO
   END-EXEC.
 
           EXEC SQL OPEN C1 END-EXEC.
 
   DISPLAY &#34;Fetching inserted rows from EMP table&#34;. 
           PERFORM FETCH-TAB.
       ENDFETCH-TAB.
 
   EXEC SQL CLOSE C1 END-EXEC.
 
   EXEC SQL DELETE FROM EMP WHERE EMPNO &lt; 1000 END-EXEC.
 
           EXEC SQL COMMIT WORK RELEASE END-EXEC.
           STOP RUN.
 
       LOGON.
           MOVE &#34;scott&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;tiger&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
 
      * INSERTS DATA INTO EMP TABLE
       INS-TAB.
   IF CNT = 5 THEN
     MOVE 10000 TO EMPNO
   ELSE
             MOVE CNT TO EMPNO
   END-IF
 
   MOVE &#34; &#34; TO STR.
   STRING &#34;EMP_&#34;, CNT INTO STR
   END-STRING.
   MOVE STR TO ENAME.
 
   MOVE &#34; &#34; TO STR.
   STRING &#34;JOB_&#34;, CNT INTO STR
   END-STRING.
   MOVE STR TO JOB.
 
   MOVE 100 TO MGR.
 
   IF CNT &gt; 30 THEN
       COMPUTE CNT2 = 30
   ELSE 
       MOVE CNT TO CNT2
   END-IF
 
   MOVE &#34; &#34; TO STR.
   STRING CNT2, &#34;-JAN-06&#34; INTO STR
   END-STRING.
   MOVE STR TO HIREDATE.
 
   MOVE &#34; &#34; TO STR.
   STRING CNT2, &#34;000&#34; INTO STR
   END-STRING.
   MOVE STR TO SAL.
 
   MOVE 1000 TO COMM.
 
   MOVE 10 TO DEPTNO.
 
   EXEC SQL INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE,
            SAL, COMM, DEPTNO) VALUES (:EMPIN)
   END-EXEC.
 
      * FETCHES DATA FROM EMP TABLE
       FETCH-TAB.
           EXEC SQL WHENEVER NOT FOUND GOTO ENDFETCH-TAB END-EXEC.
           EXEC SQL FETCH C1 INTO :EMPOUT END-EXEC.
           DISPLAY &#34;Empno=&#34;, EMPNO1, &#34;, Ename=&#34;, ENAME1,
 &#34;, Job=&#34;, JOB1, &#34;, Mgr=&#34;, MGR1,
                   &#34;, Hiredate=&#34;, HIREDATE1.
           DISPLAY &#34;Sal=&#34;, SAL1, &#34;, Comm=&#34;, COMM1, &#34;, Deptno=&#34;, DEPTNO1.
 GO TO FETCH-TAB.
 
      * HANDLES SQL ERROR CONDITIONS
       SQL-ERROR.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY SQLERRMC.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pco06pls.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pco08err.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>