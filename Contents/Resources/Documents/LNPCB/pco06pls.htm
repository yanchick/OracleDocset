<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77857"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Embedded%20PL%2FSQL"></a><title>Embedded PL/SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:15Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pco05sql.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pco07tab.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/27</span> <!-- End Header -->
<div id="LNPCB006" class="chapter"><a id="g33607"></a> <a id="i9981"></a>
<h1 class="chapter"><span class="secnum">6</span> Embedded PL/SQL</h1>
<p>This chapter shows you how to improve performance by embedding PL/SQL transaction processing blocks in your program. This chapter has the following sections:</p>
<ul>
<li>
<p><a href="#i8174">Embedding PL/SQL</a></p>
</li>
<li>
<p><a href="#i4996">Advantages of PL/SQL</a></p>
</li>
<li>
<p><a href="#i5004">Embedding PL/SQL Blocks</a></p>
</li>
<li>
<p><a href="#i5009">Host Variables and PL/SQL</a></p>
</li>
<li>
<p><a href="#i5014">Indicator Variables and PL/SQL</a></p>
</li>
<li>
<p><a href="#i8407">Host Tables and PL/SQL</a></p>
</li>
<li>
<p><a href="#i8377">Cursor Usage in Embedded PL/SQL</a></p>
</li>
<li>
<p><a href="#i24558">Stored PL/SQL and Java Subprograms</a></p>
</li>
<li>
<p><a href="#i9641">Sample Program 9: Calling a Stored Procedure</a></p>
</li>
<li>
<p><a href="#i5051">Cursor Variables</a></p>
</li>
</ul>
<a id="i8174"></a>
<div id="LNPCB398" class="sect1">
<h2 class="sect1">Embedding PL/SQL</h2>
<p>Pro*COBOL treats a PL/SQL block like a single embedded SQL statement. You can place a PL/SQL block anywhere in a host program that you can place a SQL statement.<a id="sthref775"></a><a id="sthref776"></a></p>
<p>To embed a PL/SQL block in your host program, declare the variables to be shared with PL/SQL and bracket the PL/SQL block with the EXEC SQL EXECUTE and END-EXEC keywords.<a id="sthref777"></a></p>
<div id="LNPCB399" class="sect2"><a id="sthref778"></a>
<h3 class="sect2">Host Variables</h3>
<p>Inside a PL/SQL block, host variables are global to the entire block and can be used anywhere a PL/SQL variable is allowed. Like host variables in a SQL statement, host variables in a PL/SQL block must be prefixed with a colon. The colon sets host variables apart from PL/SQL variables and database objects.<a id="sthref779"></a><a id="sthref780"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB400" class="sect2"><a id="sthref781"></a>
<h3 class="sect2">VARCHAR Variables</h3>
<p>When entering a PL/SQL block, Oracle automatically checks the length fields of VARCHAR host variables. Therefore, you must set the length fields <span class="italic">before</span> the block is entered. For input variables, set the length field to the length of the value stored in the string field. For output variables, set the length field to the maximum length allowed by the string field.<a id="sthref782"></a><a id="sthref783"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB401" class="sect2"><a id="sthref784"></a>
<h3 class="sect2">Indicator Variables</h3>
<p>In a PL/SQL block, you cannot refer to an indicator variable by itself; it must be appended to its associated host variable. Further, if you refer to a host variable with its indicator variable, you must always refer to it that way in the same block.<a id="sthref785"></a><a id="sthref786"></a></p>
<div id="LNPCB402" class="sect3"><a id="sthref787"></a>
<h4 class="sect3">Handling NULLs</h4>
<p>When entering a block, if an indicator variable has a value of -1, PL/SQL automatically assigns a NULL to the host variable. When exiting the block, if a host variable is NULL, PL/SQL automatically assigns a value of -1 to the indicator variable.<a id="sthref788"></a><a id="sthref789"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB403" class="sect3"><a id="sthref790"></a>
<h4 class="sect3">Handling Truncated Values</h4>
<p>PL/SQL does not raise an exception when a truncated string value is assigned to a host variable. However, if you use an indicator variable, PL/SQL sets it to the original length of the string.<a id="sthref791"></a><a id="sthref792"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB404" class="sect2"><a id="sthref793"></a>
<h3 class="sect2">SQLCHECK</h3>
<p>You must specify SQLCHECK=SEMANTICS when precompiling a program with an embedded PL/SQL block. You must also use the USERID option. For more information, see <a href="pco14opt.htm#g27880">Chapter 14, &#34;Precompiler Options&#34;</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i4996"></a>
<div id="LNPCB405" class="sect1">
<h2 class="sect1">Advantages of PL/SQL</h2>
<p>This section looks at some of the features and benefits offered by PL/SQL, such as:</p>
<ul>
<li>
<p>Better performance</p>
</li>
<li>
<p>Integration with Oracle</p>
</li>
<li>
<p>Cursor FOR loops</p>
</li>
<li>
<p>Procedures and functions</p>
</li>
<li>
<p>Packages</p>
</li>
<li>
<p>PL/SQL tables</p>
</li>
<li>
<p>User-defined records</p>
</li>
</ul>
<p>For more information about PL/SQL, see <a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<div id="LNPCB406" class="sect2"><a id="sthref794"></a>
<h3 class="sect2">Better Performance</h3>
<p>PL/SQL can help you reduce overhead, improve performance, and increase productivity. For example, without PL/SQL, Oracle must process SQL statements one at a time. Each SQL statement results in another call to the Server and higher overhead. However, with PL/SQL, you can send an entire block of SQL statements to the server. This minimizes communication between your application and the server.<a id="sthref795"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB407" class="sect2"><a id="sthref796"></a>
<h3 class="sect2">Integration with Oracle</h3>
<p>PL/SQL is tightly integrated with the server. For example, most PL/SQL datatypes are native to the data dictionary. Furthermore, you can use the %TYPE attribute to base variable declarations on column definitions stored in the data dictionary, as the following example shows:<a id="sthref797"></a><a id="sthref798"></a></p>
<pre>job_title  emp.job%TYPE; 
</pre>
<p>That way, you need not know the exact datatype of the column. Furthermore, if a column definition changes, the variable declaration changes accordingly and automatically. This provides data independence, reduces maintenance costs, and allows programs to adapt as the database changes.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB408" class="sect2"><a id="sthref799"></a>
<h3 class="sect2">Cursor FOR Loops</h3>
<p>With PL/SQL, you need not use the DECLARE, OPEN, FETCH, and CLOSE statements to define and manipulate a cursor. Instead, you can use a cursor FOR loop, which implicitly declares its loop index as a record, opens the cursor associated with a given query, repeatedly fetches data from the cursor into the record and then closes the cursor. An example follows:<a id="sthref800"></a><a id="sthref801"></a></p>
<pre>DECLARE 
    ... 
BEGIN 
    FOR emprec IN (SELECT empno, sal, comm FROM emp) LOOP 
        IF emprec.comm / emprec.sal &gt; 0.25 THEN ... 
        ... 
    END LOOP; 
END; 
</pre>
<p>Notice that you use dot notation to reference fields in the record.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB409" class="sect2"><a id="sthref802"></a>
<h3 class="sect2">Subprograms</h3>
<p>PL/SQL has two types of subprograms called <span class="italic">procedures</span> and <span class="italic">functions</span>, which aid application development by letting you isolate operations. Generally, you use a procedure to perform an action and a function to compute a value. <a id="sthref803"></a><a id="sthref804"></a><a id="sthref805"></a></p>
<p>Procedures and functions provide <span class="italic">extensibility</span>. That is, they let you tailor the PL/SQL language to suit your needs. For example, if you need a procedure that creates a new department, you can write your own, such as follows:</p>
<pre>PROCEDURE create_dept 
    (new_dname  IN CHAR(14), 
     new_loc    IN CHAR(13), 
     new_deptno OUT NUMBER(2)) IS 
BEGIN 
    SELECT deptno_seq.NEXTVAL INTO new_deptno FROM dual; 
    INSERT INTO dept VALUES (new_deptno, new_dname, new_loc); 
END create_dept; 
</pre>
<p>When called, this procedure accepts a new department name and location, selects the next value in a department-number database sequence, inserts the new number, name, and location into the <span class="italic">dept</span> table and then returns the new number to the caller.</p>
<p>You can store subprograms in the database (using CREATE FUNCTION and CREATE PROCEDURE) that can be called from multiple applications without needing to be re-compiled each time.</p>
<div id="LNPCB410" class="sect3"><a id="sthref806"></a>
<h4 class="sect3">Parameter Modes</h4>
<p>You use <span class="italic">parameter modes</span> to define the behavior of formal parameters. There are three parameter modes: IN (the default), OUT, and IN OUT. An IN parameter lets you pass values to the subprogram being called. An OUT parameter lets you return values to the caller of a subprogram. An IN OUT parameter lets you pass initial values to the subprogram being called and return updated values to the caller.<a id="sthref807"></a><a id="sthref808"></a><a id="sthref809"></a><a id="sthref810"></a><a id="sthref811"></a></p>
<p>The datatype of each actual parameter must be convertible to the datatype of its corresponding formal parameter. <a href="#BEIDDGEA">Table 6-1</a> shows the legal conversions between datatypes.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB411" class="sect2"><a id="sthref812"></a>
<h3 class="sect2">Packages</h3>
<p>PL/SQL lets you bundle logically related types, program objects, and subprograms into a <span class="italic">package</span>. Packages can be compiled and stored in a database, where their contents can be shared by multiple applications.<a id="sthref813"></a><a id="sthref814"></a></p>
<p>Packages usually have two parts: a specification and a body. The <span class="italic">specification</span> is the interface to your applications; it declares the types, constants, variables, exceptions, cursors, and subprograms available for use. The <span class="italic">body</span> defines cursors and subprograms and so implements the specification. The following example &#34;packages&#34; two employment procedures:</p>
<pre>PACKAGE emp_actions IS  -- package specification 
    PROCEDURE hire_employee (empno NUMBER, ename CHAR, ...); 
    PROCEDURE fire_employee (emp_id NUMBER); 
END emp_actions; 

PACKAGE BODY emp_actions IS  -- package body 
    PROCEDURE hire_employee (empno NUMBER, ename CHAR, ...) IS 
    BEGIN 
        INSERT INTO emp VALUES (empno, ename, ...); 
    END hire_employee; 
    PROCEDURE fire_employee (emp_id NUMBER) IS 
    BEGIN 
        DELETE FROM emp WHERE empno = emp_id; 
    END fire_employee; 
END emp_actions; 
</pre>
<p>Only the declarations in the package specification are visible and accessible to applications. Implementation details in the package body are hidden and inaccessible.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB412" class="sect2"><a id="sthref815"></a>
<h3 class="sect2">PL/SQL Tables</h3>
<p>PL/SQL provides a composite datatype named TABLE. Objects of type TABLE are called <span class="italic">PL/SQL tables</span>, which are modeled as (but not the same as) database tables. PL/SQL tables have only one column and use a primary key to give you array-like access to rows. The column can belong to any scalar type (such as CHAR, DATE, or NUMBER), but the primary key must belong to type BINARY_INTEGER, PLS_INTEGER or VARCHAR2.<a id="sthref816"></a><a id="sthref817"></a></p>
<p>You can declare PL/SQL table types in the declarative part of any block, procedure, function, or package. The following example declares a TABLE type called <span class="italic">NumTabTyp</span>:</p>
<pre>DECLARE 
    TYPE NumTabTyp IS TABLE OF NUMBER 
        INDEX BY BINARY_INTEGER; 
    ... 
BEGIN 
    ... 
END; 
</pre>
<p>Once you define type <span class="italic">NumTabTyp</span>, you can declare PL/SQL tables of that type, as the next example shows:</p>
<pre>num_tab  NumTabTyp; 
</pre>
<p>The identifier <span class="italic">num_tab</span> represents an entire PL/SQL table.</p>
<p>You reference rows in a PL/SQL table using array-like syntax to specify the primary key value. For example, you reference the ninth row in the PL/SQL table named <span class="italic">num_tab</span> as follows:</p>
<pre>num_tab(9) ... 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB413" class="sect2"><a id="sthref818"></a>
<h3 class="sect2">User-Defined Records</h3>
<p>You can use the %ROWTYPE attribute to declare a record that represents a row in a database table or a row fetched by a cursor. However, you cannot specify the datatypes of fields in the record or define fields of your own. The composite datatype RECORD lifts those restrictions.<a id="sthref819"></a><a id="sthref820"></a><a id="sthref821"></a><a id="sthref822"></a></p>
<p>Objects of type RECORD are called <span class="italic">records</span>. Unlike PL/SQL tables, records have uniquely named fields, which can belong to different datatypes. For example, suppose you have different kinds of data about an employee such as name, salary, hire date, and so on. This data is dissimilar in type but logically related. A record that contains such fields as the name, salary, and hire date of an employee would let you treat the data as a logical unit.</p>
<p>You can declare record types and objects in the declarative part of any block, procedure, function, or package. The following example declares a RECORD type called <span class="italic">DeptRecTyp</span>:</p>
<pre>DECLARE 
    TYPE DeptRecTyp IS RECORD 
        (deptno  NUMBER(4) NOT NULL := 10,  -- must initialize
         dname   CHAR(9), 
         loc     CHAR(14)); 
</pre>
<p>Notice that the field declarations are like variable declarations. Each field has a unique name and specific datatype. You can add the NOT NULL option to any field declaration and so prevent the assigning of NULLs to that field. However, you must initialize NOT NULL fields.</p>
<p>Once you define type <span class="italic">DeptRecTyp</span>, you can declare records of that type, as the next example shows:</p>
<pre>dept_rec  DeptRecTyp; 
</pre>
<p>The identifier <span class="italic">dept_rec</span> represents an entire record.</p>
<p>You use dot notation to reference individual fields in a record. For example, you reference the <span class="italic">dname</span> field in the <span class="italic">dept_rec</span> record as follows:</p>
<pre>dept_rec.dname ... 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5004"></a>
<div id="LNPCB414" class="sect1">
<h2 class="sect1">Embedding PL/SQL Blocks</h2>
<p>Pro*COBOL treats a PL/SQL block like a single embedded SQL statement. Thus, you can place a PL/SQL block anywhere in a host program that you can place a SQL statement.<a id="sthref823"></a><a id="sthref824"></a></p>
<p>To embed a PL/SQL block in your host program, simply bracket the PL/SQL block with the keywords EXEC SQL EXECUTE and END-EXEC as follows:</p>
<pre>     EXEC SQL EXECUTE 
         DECLARE 
         ... 
         BEGIN 
         ... 
         END;
     END-EXEC. 
</pre>
<p>When your program embeds PL/SQL blocks, you must specify the precompiler option SQLCHECK=SEMANTICS because PL/SQL must be parsed by Pro*COBOL. To connect to the server, you must also specify the option USERID. For more information, see <a href="pco14opt.htm#i12295">&#34;Using Pro*COBOL Precompiler Options&#34;</a>. <a id="sthref825"></a><a id="sthref826"></a></p>
</div>
<!-- class="sect1" -->
<a id="i5009"></a>
<div id="LNPCB415" class="sect1">
<h2 class="sect1">Host Variables and PL/SQL</h2>
<p>Host variables are the key to communication between a host language and a PL/SQL block. Host variables can be shared with PL/SQL, meaning that PL/SQL can set and reference host variables.</p>
<p>For example, you can prompt a user for information and use host variables to pass that information to a PL/SQL block. Then, PL/SQL can access the database and use host variables to pass the results back to your host program.<a id="sthref827"></a></p>
<p>Inside a PL/SQL block, host variables are treated as global to the entire block and can be used anywhere a PL/SQL variable is allowed. Like host variables in a SQL statement, host variables in a PL/SQL block must be prefixed with a colon. The colon sets host variables apart from PL/SQL variables and database objects.</p>
<div id="LNPCB416" class="sect2"><a id="sthref828"></a>
<h3 class="sect2">PL/SQL Examples<a id="sthref829"></a></h3>
<p>The following example illustrates the use of host variables with PL/SQL. The program prompts the user for an employee number and then displays the job title, hire date, and salary of that employee.<a id="sthref830"></a></p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01 USERNAME   PIC X(20) VARYING.
 01 PASSWORD   PIC X(20) VARYING.
 01 EMP-NUMBER PIC S9(4) COMP.
 01 JOB-TITLE  PIC X(20) VARYING.
 01 HIRE-DATE  PIC X(9) VARYING.
 01 SALARY     PIC S9(6)V99
                          DISPLAY SIGN LEADING SEPARATE.
     EXEC SQL END DECLARE SECTION END-EXEC. 
     EXEC SQL INCLUDE SQLCA END-EXEC. 
     ...
     DISPLAY &#39;Connected to Oracle&#39;. 
 PERFORM
     DISPLAY &#39;Employee Number (0 to end)? &#39;WITH NO ADVANCING 
     ACCEPT EMP-NUMBER 
     IF EMP-NUMBER = 0  
         EXEC SQL COMMIT WORK RELEASE END-EXEC 
         DISPLAY &#39;Exiting program&#39; 
         STOP RUN
     END-IF. 
*   ---------------- begin PL/SQL block ----------------- 
     EXEC SQL EXECUTE 
        BEGIN 
            SELECT job, hiredate, sal 
                INTO :JOB-TITLE, :HIRE-DATE, :SALARY 
                FROM EMP 
                WHERE EMPNO = :EMP-NUMBER; 
        END; 
     END-EXEC. 
*    ---------------- end PL/SQL block ----------------- 
     DISPLAY &#39;Number  Job Title  Hire Date  Salary&#39;. 
     DISPLAY &#39;------------------------------------&#39;. 
     DISPLAY EMP-NUMBER, JOB-TITLE, HIRE-DATE, SALARY. 
 END-PERFORM. 
     ...
 SQL-ERROR.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC. 
     EXEC SQL ROLLBACK WORK RELEASE END-EXEC. 
     DISPLAY &#39;Processing error&#39;. 
     STOP RUN.
</pre>
<p>Notice that the host variable <span class="italic">EMP-NUMBER</span> is set before the PL/SQL block is entered, and the host variables <span class="italic">JOB-TITLE, HIRE-DATE</span>, and <span class="italic">SALARY</span> are set inside the block.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB417" class="sect2"><a id="sthref831"></a>
<h3 class="sect2">A More Complex PL/SQL Example</h3>
<p>In the following example the user is prompted for a bank account number, transaction type, and transaction amount. The account is then debited or credited. If the account does not exist, an exception is raised. When the transaction is complete its status is displayed.<a id="sthref832"></a></p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01 USERNAME   PIC X(20) VARYING.
 01 ACCT-NUM   PIC S9(4) COMP.
 01 TRANS-TYPE PIC X(1).
 01 TRANS-AMT  PIC PIC S9(6)V99
                       DISPLAY SIGN LEADING SEPARATE.
 01 STATUS     PIC X(80) VARYING.
    EXEC SQL END DECLARE SECTION END-EXEC.
     EXEC SQL INCLUDE SQLCA END-EXEC. 
     DISPLAY &#39;Username? &#39;WITH NO ADVANCING. 
     ACCEPT USERNAME. 
     DISPLAY &#39;Password? &#39;. 
     ACCEPT PASSWORD. 
     EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR. 
     EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWORD. 
     PERFORM 
     DISPLAY &#39;Account Number (0 to end)? &#39;
         WITH NO ADVANCING 
     ACCEPT ACCT_NUM 
     IF ACCT-NUM = 0
         EXEC SQL COMMIT WORK RELEASE END-EXEC 
         DISPLAY &#39;Exiting program&#39; WITH NO ADVANCING 
         STOP RUN 
     END-IF.
     DISPLAY &#39;Transaction Type - D)ebit or C)redit? &#39; 
         WITH NO ADVANCING
     ACCEPT TRANS-TYPE 
     DISPLAY &#39;Transaction Amount? &#39; 
     ACCEPT trans_amt 
*   --------------------- begin PL/SQL block ------------------- 
     EXEC SQL EXECUTE 
        DECLARE 
            old_bal      NUMBER(9,2); 
            err_msg      CHAR(70); 
            nonexistent  EXCEPTION; 
        BEGIN 
           IF :TRANS-TYP-TYPE = &#39;C&#39; THEN       -- credit the account 
                UPDATE accts SET bal = bal + :TRANS-AMT 
                    WHERE acctid = :acct-num; 
                IF SQL%ROWCOUNT = 0 THEN    -- no rows affected 
                    RAISE nonexistent; 
                ELSE 
                   :STATUs := &#39;Credit applied&#39;; 
                END IF; 
            ELSIF :TRANS-TYPe = &#39;D&#39; THEN    -- debit the account 
                SELECT bal INTO old_bal FROM accts 
                    WHERE acctid = :ACCT-NUM; 
                IF old_bal &gt;= :TRANS-AMT THEN   -- enough funds 
                    UPDATE accts SET bal = bal - :TRANS-AMT 
                        WHERE acctid = :ACCT-NUM; 
                    :STATUS := &#39;Debit applied&#39;; 
                ELSE 
                    :STATUS := &#39;Insufficient funds&#39;; 
                END IF; 
            ELSE 
              :STATUS := &#39;Invalid type: &#39; || :TRANS-TYPE; 
            END IF; 
            COMMIT; 
        EXCEPTION 
            WHEN NO_DATA_FOUND OR nonexistent THEN 
                :STATUS := &#39;Nonexistent account&#39;; 
            WHEN OTHERS THEN 
                err_msg := SUBSTR(SQLERRM, 1, 70); 
               :STATUS := &#39;Error: &#39; || err_msg; 
        END; 
     END-EXEC. 
*     ------------------- end PL/SQL block ----------------------- 
     DISPLAY &#39;Status: &#39;, STATUS 
 END-PERFORM.
     ...
 SQL-ERROR.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC. 
     EXEC SQL ROLLBACK WORK RELEASE END-EXEC. 
     DISPLAY &#39;Processing error&#39;. 
     STOP RUN. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB418" class="sect2"><a id="sthref833"></a>
<h3 class="sect2">VARCHAR Pseudotype</h3>
<p>Recall that you can use the VARCHAR pseudotype to declare variable-length character strings. If the VARCHAR is an input host variable, you must tell Pro*COBOL what length to expect. Therefore, set the length field to the actual length of the value stored in the string field.</p>
<p>If the VARCHAR is an output host variable, Pro*COBOL automatically sets the length field. However, to use a VARCHAR output host variable in your PL/SQL block, you must initialize the length field <span class="italic">before</span> entering the block. Therefore, set the length field to the declared (maximum) length of the VARCHAR, as shown in the following example:<a id="sthref834"></a><a id="sthref835"></a></p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
        01 EMP-NUM   PIC S9(4) COMP.
        01 EMP-NAME  PIC X(10) VARYING.
        01 SALARY    PIC S9(6)V99
                     DISPLAY SIGN LEADING SEPARATE.
     ... 
     EXEC SQL END DECLARE SECTION END-EXEC.
 PROCEDURE DIVISION.
     ...
* -- initialize length field 
     MOVE 10 TO EMP-NAME-LEN.
     EXEC SQL EXECUTE 
     BEGIN 
        SELECT ename, sal INTO :EMP-NAME, :SALARY 
            FROM emp 
            WHERE empno = :EMP-NUM; 
        ... 
     END; 
     END-EXEC. 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5014"></a>
<div id="LNPCB419" class="sect1">
<h2 class="sect1">Indicator Variables and PL/SQL</h2>
<p>PL/SQL does not need indicator variables because it can manipulate NULLs. For example, within PL/SQL, you can use the IS NULL operator to test for NULLs, as follows:<a id="sthref836"></a></p>
<pre>IF variable IS NULL THEN ... 
</pre>
<p>You can use the assignment operator (:=) to assign NULLs, as follows:</p>
<pre>variable := NULL; 
</pre>
<p>However, host languages need indicator variables because they cannot manipulate NULLs. Embedded PL/SQL meets this need by letting you use indicator variables to:</p>
<ul>
<li>
<p>Accept NULLs input from a host program</p>
</li>
<li>
<p>Output NULLs or truncated values to a host program</p>
</li>
</ul>
<p>When used in a PL/SQL block, indicator variables are subject to the following rule:</p>
<ul>
<li>
<p>If you refer to a host variable with an indicator variable, you must always refer to it that way in the same block.</p>
</li>
</ul>
<p>In the following example, the indicator variable <span class="italic">IND-COMM</span> appears with its host variable <span class="italic">COMMISSION</span> in the SELECT statement, so it must appear that way in the IF statement:</p>
<pre>     EXEC SQL EXECUTE 
     BEGIN 
        SELECT ename, comm 
            INTO :EMP-NAME, :COMMISSION:IND-COMM FROM emp 
            WHERE empno = :EMP-NUM; 
        IF :COMMISSION:IND-COMM IS NULL THEN ... 
        ... 
     END; 
     END-EXEC. 
</pre>
<p>Notice that PL/SQL treats <span class="italic">:COMMISSION:IND-COMM</span> like any other simple variable. Though you cannot refer directly to an indicator variable inside a PL/SQL block, PL/SQL checks the value of the indicator variable when entering the block and sets the value correctly when exiting the block.</p>
<div id="LNPCB420" class="sect2"><a id="sthref837"></a>
<h3 class="sect2">Handling NULLs</h3>
<p>When entering a block, if an indicator variable has a value of -1, PL/SQL automatically assigns a NULL to the host variable. When exiting the block, if a host variable is NULL, PL/SQL automatically assigns a value of -1 to the indicator variable. In the next example, if <span class="italic">IND-SAL</span> had a value of -1 before the PL/SQL block was entered, the <span class="italic">salary_missing</span> exception is raised. An <span class="italic">exception</span> is a named error condition. <a id="sthref838"></a><a id="sthref839"></a></p>
<pre>    EXEC SQL EXECUTE 
    BEGIN 
        IF :SALARY:IND-SAL IS NULL THEN 
            RAISE salary_missing; 
        END IF; 
        ... 
    END; 
    END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB421" class="sect2"><a id="sthref840"></a>
<h3 class="sect2">Handling Truncated Values</h3>
<p>PL/SQL does not raise an exception when a truncated string value is assigned to a host variable. However, if you use an indicator variable, PL/SQL sets it to the original length of the string. The following example the host program will be able to tell, by checking the value of <span class="italic">IND-NAME</span>, if a truncated value was assigned to <span class="italic">EMP-NAME</span>: <a id="sthref841"></a></p>
<pre>     EXEC SQL EXECUTE 
     DECLARE 
        ... 
        new_name  CHAR(10); 
     BEGIN 
        ... 
        :EMP_NAME:IND-NAME := new_name; 
        ... 
     END; 
     END-EXEC. 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i8407"></a>
<div id="LNPCB422" class="sect1">
<h2 class="sect1">Host Tables and PL/SQL</h2>
<p>You can pass input host tables and indicator tables to a PL/SQL block. They can be indexed by a PL/SQL variable of type BINARY_INTEGER or PLS_INTEGER; VARCHAR2 key types are not permitted. Normally, the entire host table is passed to PL/SQL, but you can use the ARRAYLEN statement (discussed later) to specify a smaller table dimension.</p>
<p>Furthermore, you can use a subprogram call to assign all the values in a host table to rows in a PL/SQL table. Given that the table subscript range is <span class="italic">m</span> .. <span class="italic">n</span>, the corresponding PL/SQL table index range is always 1 .. <span class="italic">(n</span> - <span class="italic">m</span> + 1). For example, if the table subscript range is 5 .. 10, the corresponding PL/SQL table index range is 1 .. (10 - 5 + 1) or 1 .. 6.</p>
<p><span class="bold">Note:</span> Pro*COBOL does not check your usage of host tables. For instance, no index range checking is done.</p>
<p>In the following example, you pass a host table named <span class="italic">salary</span> to a PL/SQL block, which uses the host table in a function call. The function is named <span class="italic">median</span> because it finds the middle value in a series of numbers. Its formal parameters include a PL/SQL table named <span class="italic">num_tab</span>. The function call assigns all the values in the actual parameter <span class="italic">salary</span> to rows in the formal parameter <span class="italic">num_tab</span>.</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
     ... 
 01  SALARY OCCURS 100 TIMES PIC S9(6)V99 COMP-3.
 01  MEDIAN-SALARY  PIC S9(6)V99 COMP-3.
     EXEC SQL END DECLARE SECTION END-EXEC. 
* -- populate the host table 
     EXEC SQL EXECUTE 
     DECLARE 
        TYPE NumTabTyp IS TABLE OF REAL 
            INDEX BY BINARY_INTEGER; 
        n  BINARY_INTEGER; 
        ... 
        FUNCTION median (num_tab NumTabTyp, n INTEGER) 
            RETURN REAL IS 
        BEGIN 
* -- compute median 
        END; 
     BEGIN 
        n := 100; 
        :MEDIAN-SALARY := median(:SALARY    END; 
     END-EXEC. 
</pre>
<p>You can also use a subprogram call to assign all row values in a PL/SQL table to corresponding elements in a host table. For an example, see <a href="#i24558">&#34;Stored PL/SQL and Java Subprograms&#34;</a>.</p>
<p>The interface between Host Tables and PL/SQL strictly controls datatypes. The default external type for PIC X is CHARF (fixed length character string) and this can only be mapped to PL/SQL tables of type CHAR.</p>
<p><a href="#BEIDDGEA">Table 6-1</a> shows the legal conversions between row values in a PL/SQL table and elements in a host table. The most notable fact is that you cannot pass a PIC X variable to a table of type VARCHAR2 without using datatype equivalencing to equivalence the variable to VARCHAR2, or using PICX=VARCHAR2 on the command line.</p>
<div id="LNPCB423" class="tblformalwide">
<p class="titleintable"><a id="sthref842"></a><a id="BEIDDGEA"></a>Table 6-1 Legal Datatype Conversions</p>
<table class="cellalignment4974" title="Legal Datatype Conversions " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t2">PL/SQL Table</th>
<th class="cellalignment4972" id="r1c2-t2">-</th>
<th class="cellalignment4972" id="r1c3-t2">-</th>
<th class="cellalignment4972" id="r1c4-t2">-</th>
<th class="cellalignment4972" id="r1c5-t2">-</th>
<th class="cellalignment4972" id="r1c6-t2">-</th>
<th class="cellalignment4972" id="r1c7-t2">-</th>
<th class="cellalignment4972" id="r1c8-t2">-</th>
<th class="cellalignment4972" id="r1c9-t2">-</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t2" headers="r1c1-t2">
<p>Host Table</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c2-t2">
<p>CHAR</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c3-t2">
<p>DATE</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c4-t2">
<p>LONG</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c5-t2">
<p>LONG RAW</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c6-t2">
<p>NUMBER</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c7-t2">
<p>RAW</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c8-t2">
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c9-t2">
<p>VARCHAR2</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t2" headers="r1c1-t2">
<p>CHARF</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c2-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t2" headers="r1c1-t2">
<p>CHARZ</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c2-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t2" headers="r1c1-t2">
<p>DATE</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c3-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t2" headers="r1c1-t2">
<p>DECIMAL</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c6-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t2" headers="r1c1-t2">
<p>DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c6-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t2" headers="r1c1-t2">
<p>FLOAT</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c6-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t2" headers="r1c1-t2">
<p>INTEGER</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t2" headers="r1c1-t2">
<p>LONG</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c2-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c4-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t2" headers="r1c1-t2">
<p>LONG VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c4-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c5-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c7-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c9-t2">
<p>X</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t2" headers="r1c1-t2">
<p>LONG VARRAW</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c5-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c7-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t2" headers="r1c1-t2">
<p>NUMBER</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c6-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c7-t2">&nbsp;</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t2" headers="r1c1-t2">
<p>RAW</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c5-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c7-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t2" headers="r1c1-t2">
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c8-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r16c1-t2" headers="r1c1-t2">
<p>STRING</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c4-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c5-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c7-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c9-t2">
<p>X</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r17c1-t2" headers="r1c1-t2">
<p>UNSIGNED</p>
</td>
<td class="cellalignment4973" headers="r17c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r17c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r17c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r17c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r17c1-t2 r1c6-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r17c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r17c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r17c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r18c1-t2" headers="r1c1-t2">
<p>VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r18c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r18c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r18c1-t2 r1c4-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r18c1-t2 r1c5-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r18c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r18c1-t2 r1c7-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r18c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r18c1-t2 r1c9-t2">
<p>X</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r19c1-t2" headers="r1c1-t2">
<p>VARCHAR2</p>
</td>
<td class="cellalignment4973" headers="r19c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r19c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r19c1-t2 r1c4-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r19c1-t2 r1c5-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r19c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r19c1-t2 r1c7-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r19c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r19c1-t2 r1c9-t2">
<p>X</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r20c1-t2" headers="r1c1-t2">
<p>VARNUM</p>
</td>
<td class="cellalignment4973" headers="r20c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r20c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r20c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r20c1-t2 r1c5-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r20c1-t2 r1c6-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r20c1-t2 r1c7-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r20c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r20c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r21c1-t2" headers="r1c1-t2">
<p>VARRAW</p>
</td>
<td class="cellalignment4973" headers="r21c1-t2 r1c2-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r21c1-t2 r1c3-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r21c1-t2 r1c4-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r21c1-t2 r1c5-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r21c1-t2 r1c6-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r21c1-t2 r1c7-t2">
<p>X</p>
</td>
<td class="cellalignment4973" headers="r21c1-t2 r1c8-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r21c1-t2 r1c9-t2">
<p>-</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" -->
<div id="LNPCB424" class="sect2"><a id="sthref843"></a>
<h3 class="sect2">ARRAYLEN Statement</h3>
<p>Suppose you must pass an input host table to a PL/SQL block for processing. By default, when binding such a host table, Pro*COBOL use its declared dimension. However, you might not want to process the entire table. In that case, you can use the ARRAYLEN statement to specify a smaller table dimension. ARRAYLEN associates the host table with a host variable, which stores the smaller dimension. The statement syntax is:<a id="sthref844"></a></p>
<pre>     EXEC SQL ARRAYLEN host_array (dimension) EXECUTE END-EXEC. 
</pre>
<p>where <span class="italic">dimension</span> is a 4-byte, integer host variable, <span class="italic">not</span> a literal or an expression.</p>
<p>The ARRAYLEN statement must appear somewhere after the declarations of <span class="italic">host_array</span> and <span class="italic">dimension</span>. You cannot specify an offset into the host table. However, you might be able to use COBOL features for that purpose.</p>
<p>The following example uses ARRAYLEN to override the default dimension of a host table named <span class="italic">BONUS</span>:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01 BONUS OCCURS 100 TIMES PIC S9(6)V99
         DISPLAY SIGN LEADING SEPARATE.
 01 MY-DIM  PIC S9(9) COMP. 
     ...
     EXEC SQL ARRAYLEN BONUS (MY-DIM) END-EXEC. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
* -- populate the host table 
     ... 
* -- set smaller table dimension 
     MOVE 25 TO MY-DIM.
     EXEC SQL EXECUTE 
     DECLARE 
        TYPE NumTabTyp IS TABLE OF REAL 
            INDEX BY BINARY_INTEGER; 
        median_bonus  REAL; 
        FUNCTION median (num_tab NumTabTyp, n INTEGER) 
            RETURN REAL IS 
        BEGIN 
* -- compute median 
        END; 
     BEGIN 
        median_bonus := median(:BONUS, :MY-DIM); 
        ... 
     END; 
     END-EXEC. 
</pre>
<p>Only 25 table elements are passed to the PL/SQL block because ARRAYLEN reduces the host table from 100 to 25 elements. As a result, when the PL/SQL block is sent to the server for execution, a much smaller host table is sent along. This saves time and, in a networked environment, reduces network traffic.</p>
<div id="LNPCB425" class="sect3"><a id="sthref845"></a>
<h4 class="sect3"><a id="sthref846"></a>Optional Keyword EXECUTE to ARRAYLEN Statement</h4>
<p>The use of host tables used in a dynamic SQL Method 2 statement (see <a href="pco09dyn.htm#i3892">&#34;Using Method 2&#34;</a>) may have two different interpretations based on the presence or absence of the keyword to EXECUTE the ARRAYLEN statement. .</p>
<p>If the EXECUTE keyword is absent:</p>
<ul>
<li>
<p>The PL/SQL block will be executed multiple times, with the actual number determined by the minimum dimension of ARRAYLEN used.</p>
</li>
<li>
<p>The host array cannot be bound to a PL/SQL table.</p>
</li>
</ul>
<p>If EXECUTE is present:</p>
<ul>
<li>
<p>The host table must be bound to an index table.</p>
</li>
<li>
<p>The PL/SQL block will be executed once.</p>
</li>
<li>
<p>All host variables specified in the EXEC SQL EXECUTE statement must:</p>
<ul>
<li>
<p>Be specified in an ARRAYLEN ... EXECUTE statement, or</p>
</li>
<li>
<p>Be a scalar.</p>
</li>
</ul>
</li>
</ul>
<p>The following Pro*COBOL example demonstrates how host tables can be used to determine how many times a given PL/SQL block is executed. In this case, the PL/SQL block will be execute 3 times resulting in 3 new rows in the <span class="italic">emp</span> table.</p>
<pre>       ... 
 01  DYNSTMT   PIC X(80) VARYING. 
 01  EMPNOTAB  PIC S9(4) COMPUTATIONAL OCCURS 5 TIMES. 
 01  ENAMETAB  PIC X(10) OCCURS 3 TIMES. 
       ... 
           MOVE 1111 TO EMPNOTAB(1). 
           MOVE 2222 TO EMPNOTAB(2). 
           MOVE 3333 TO EMPNOTAB(3). 
           MOVE 4444 TO EMPNOTAB(4). 
           MOVE 5555 TO EMPNOTAB(5). 
  
           MOVE &#34;MICKEY&#34; TO ENAMETAB(1). 
           MOVE &#34;MINNIE&#34; TO ENAMETAB(2). 
           MOVE &#34;GOOFY&#34; TO ENAMETAB(3). 
  
           MOVE &#34;BEGIN INSERT INTO emp(empno, ename) VALUES :b1, :b2; END;&#34; 
             TO DYNSTMT-ARR. 
           MOVE 57 TO DYNSTMT-LEN. 
   
           EXEC SQL PREPARE s1 FROM :DYNSTMT END-EXEC. 
           EXEC SQL EXECUTE s1 USING :EMPNOTAB, :ENAMETAB END-EXEC. 
       ... 
  
</pre>
<p>Given the following PL/SQL procedure:</p>
<pre>  CREATE OR REPLACE PACKAGE pkg AS  
     TYPE tab IS TABLE OF NUMBER(5) INDEX BY BINARY_INTEGER;  
     PROCEDURE proc1 (parm1 tab, parm2 NUMBER, parm3 tab);  
  END;  
  
</pre>
<p>The following Pro*COBOL example demonstrates how to bind a host table to a PL/SQL index table through dynamic method 2. Note the presence of the ARRAYLEN...EXECUTE statement for all host arrays specified in the EXEC SQL EXECUTE statement.</p>
<pre>       ... 
 01  DYNSTMT   PIC X(80) VARYING. 
 01  II        PIC S9(4) COMP VALUE 2. 
 01  INTTAB    PIC S9(9) COMP OCCURS 3 TIMES. 
 01  DIM       PIC S9(9) COMP VALUE 3. 
  
           EXEC SQL ARRAYLEN INTTAB (DIM) EXECUTE END-EXEC. 
       ... 
           MOVE 1 TO INTTAB(1). 
           MOVE 2 TO INTTAB(2). 
           MOVE 3 TO INTTAB(3). 
  
           MOVE &#34;BEGIN pkg.proc1 (:v1, :v2, :v3); end;&#34;; 
             TO DYNSTMT-ARR. 
           MOVE 37 TO DYNSTMT-LEN. 
   
           EXEC SQL PREPARE s1 FROM :DYNSTMT END-EXEC. 
           EXEC SQL EXECUTE s1 USING :INTTAB, :II, :INTTAB END-EXEC. 
       ... 
  
</pre>
<p>However, the following Pro*COBOL example will result in a precompile-time error because there is no ARRAYLEN...EXECUTE statement for INTTAB2.</p>
<pre>       ... 
 01  DYNSTMT   PIC X(80) VARYING. 
 01  INTTAB    PIC S9(9) COMP OCCURS 3 TIMES. 
 01  INTTAB2   PIC S9(9) COMP OCCURS 3 TIMES. 
 01  DIM       PIC S9(9) COMP VALUE 3. 
  
           EXEC SQL ARRAYLEN INTTAB (DIM) EXECUTE END-EXEC. 
       ... 
           MOVE 1 TO INTTAB(1). 
           MOVE 2 TO INTTAB(2). 
           MOVE 3 TO INTTAB(3). 
  
           MOVE &#34;BEGIN pkg.proc1 (:v1, :v2, :v3); end;&#34;; 
             TO DYNSTMT-ARR. 
           MOVE 37 TO DYNSTMT-LEN. 
   
           EXEC SQL PREPARE s1 FROM :DYNSTMT END-EXEC. 
           EXEC SQL EXECUTE s1 USING :INTTAB, :INTTAB2, :INTTAB END-EXEC. 
       ... 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i8377"></a>
<div id="LNPCB426" class="sect1">
<h2 class="sect1">Cursor Usage in Embedded PL/SQL</h2>
<p>The maximum number of cursors your program can simultaneously use is determined by the database initialization parameter OPEN_CURSORS. Normally, to prevent OPEN_CURSORS being exceeded, the precompiler allows management of statement cursors. The precompiler options HOLD_CURSOR, RELEASE_CURSOR and MAXOPENCURSORS are used. (For more details on this subject, see <a href="pcoadtun.htm#i24640">&#34;Embedded PL/SQL Considerations&#34;</a>.) While executing an embedded PL/SQL block there will be one cursor, the parent cursor, associated with the entire PL/SQL block and a separate child cursor for each statement executed during the execution of the PL/SQL block. Because the PL/SQL block is passed to the server for execution, only the parent cursor can be tracked by the precompiler runtime library. Thus, it is possible for applications that use a lot of cursors in this way to exceed OPEN_CURSORS. <a href="#i24512">Figure 6-1</a> shows how to calculate the maximum number of cursors used.</p>
<div id="LNPCB427" class="figure">
<p class="titleinfigure"><a id="i24512"></a>Figure 6-1 Maximum Cursors in Use</p>
<img width="600" height="163" src="img/pco81054.gif" alt="Maximum Cursors in Use"/><br/>
<a id="sthref847" href="img_text/pco81054.htm">Description of &#34;Figure 6-1 Maximum Cursors in Use&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Developers should be aware of this situation and plan for this in the setting of OPEN_CURSORS and MAXOPENCURSORS.</p>
<p>If there are problems with this, you may wish to free all child cursors after a SQL statement is executed.</p>
<p>This can be achieved by setting RELEASE_CURSOR=YES and HOLD_CURSOR=NO. Because the use of the first setting for the entire program is likely to have an impact on performance, you can set these options in line as follows:</p>
<pre>     EXEC ORACLE OPTION (RELEASE_CURSOR=YES) END-EXEC. 
* --  first embedded PL/SQL block 
     EXEC ORACLE OPTION (RELEASE_CURSOR=NO)END-EXEC. 
* --  embedded SQL statements
     EXEC ORACLE OPTION (RELEASE_CURSOR=YES)END-EXEC. 
* --  second embedded PL/SQL block 
     EXEC ORACLE OPTION (RELEASE_CURSOR=NO)END-EXEC. 
* --  embedded SQL statements 
</pre></div>
<!-- class="sect1" -->
<a id="i24558"></a>
<div id="LNPCB428" class="sect1">
<h2 class="sect1">Stored PL/SQL and Java Subprograms</h2>
<p>Unlike anonymous blocks, PL/SQL subprograms (procedures and functions) and <a id="sthref848"></a><a id="sthref849"></a>Java methods can be compiled separately, stored in the database, and invoked.</p>
<p>A subprogram explicitly created using an Oracle tool such as SQL*Plus is called a <span class="italic">stored</span> subprogram. Once compiled and stored in the data dictionary, it is a database object can be re-executed without being re-compiled. <a id="sthref850"></a><a id="sthref851"></a></p>
<p>When a subprogram within a PL/SQL block or stored subprogram is sent to the database by your application, it is called an <span class="bold">inline</span> subprogram and is compiled by the database. Pro*COBOL sends the statement to the server for execution.<a id="sthref852"></a></p>
<p>Subprograms defined within a package are considered part of the package, and so are called <span class="bold">packaged</span> subprograms. Stored subprograms not defined within a package are called <span class="bold">standalone</span> subprograms.<a id="sthref853"></a></p>
<div id="LNPCB429" class="sect2"><a id="sthref854"></a>
<h3 class="sect2">Creating Stored Subprograms</h3>
<p>You can embed the SQL statements CREATE FUNCTION, CREATE PROCEDURE, and CREATE PACKAGE in a COBOL program, as the following example shows:<a id="sthref855"></a><a id="sthref856"></a></p>
<pre>     EXEC SQL CREATE 
     FUNCTION sal_ok (salary REAL, title CHAR) 
      RETURN BOOLEAN AS 
        min_sal  REAL; 
        max_sal  REAL; 
     BEGIN 
        SELECT losal, hisal INTO min_sal, max_sal 
            FROM sals 
            WHERE job = title; 
        RETURN (salary &gt;= min_sal) AND 
               (salary &lt;= max_sal); 
     END sal_ok; 
     END-EXEC. 
</pre>
<p>Notice that the embedded CREATE {FUNCTION | PROCEDURE | PACKAGE} statement is a hybrid. Like all other embedded CREATE statements, it begins with the keywords EXEC SQL (not EXEC SQL EXECUTE).</p>
<p>If an embedded CREATE {FUNCTION | PROCEDURE | PACKAGE} statement fails, Oracle generates a warning, not an error. For the full syntax of the CREATE statement see the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference.</span></a></p>
</div>
<!-- class="sect2" -->
<a id="i8978"></a>
<div id="LNPCB430" class="sect2">
<h3 class="sect2">Calling a Stored PL/SQL or Java Subprogram</h3>
<p>To call a stored subprogram from your host program, you can use either an anonymous PL/SQL block or the CALL embedded SQL statement.</p>
<div id="LNPCB431" class="sect3"><a id="sthref857"></a>
<h4 class="sect3">Anonymous PL/SQL Block</h4>
<p>The following example calls a standalone procedure named <span class="italic">raise_salary</span>:<a id="sthref858"></a></p>
<pre>     EXEC SQL EXECUTE 
     BEGIN 
        raise_salary(:emp_id, :increase); 
     END; 
     END-EXEC. 
</pre>
<p>Notice that stored subprograms can take parameters. In this example, the actual parameters <span class="italic">emp_id</span> and <span class="italic">increase</span> are host variables.</p>
<p>In the next example, the procedure <span class="italic">raise_salary</span> is stored in a package named <span class="italic">emp_actions</span>, so you must use dot notation to fully qualify the procedure call:</p>
<pre>     EXEC SQL EXECUTE 
     BEGIN 
        emp_actions.raise_salary(:emp_id, :increase); 
     END; 
     END-EXEC. 
</pre>
<p>An actual IN parameter can be a literal, host variable, host table, PL/SQL constant or variable, PL/SQL table, PL/SQL user-defined record, subprogram call, or expression. However, an actual OUT parameter cannot be a literal, subprogram call, or expression.</p>
<p>You must use precompiler option SQLCHECK=SEMANTICS with an embedded PL/SQL block.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB432" class="sect3"><a id="sthref859"></a>
<h4 class="sect3"><a id="sthref860"></a><a id="sthref861"></a>CALL Statement</h4>
<p>The concepts presented earlier for the embedded PL/SQL block holds true for the CALL statement. The CALL embedded SQL statement has the form:</p>
<pre>      EXEC SQL 
        CALL [schema.][package.]stored_proc[@db_link](arg1, ...) 
        [INTO :ret_var[[INDICATOR]:ret_ind]] 
     END-EXEC.
</pre>
<p>where:</p>
<pre>schema
</pre>
<p>the schema containing the procedure</p>
<pre>package
</pre>
<p>the package containing the procedure</p>
<pre>stored_proc
</pre>
<p>is the Java or PL/SQL stored procedure to be called</p>
<pre>db_link
</pre>
<p>is the optional remote database link</p>
<pre>arg1...
</pre>
<p>is the list of arguments (variables, literals, or expressions) passed,</p>
<pre>ret_var
</pre>
<p>is the optional host variable which receives the result</p>
<pre>ind_var
</pre>
<p>the optional indicator variable for ret_var.</p>
<p>You can use either SQLCHECK=SYNTAX, or SQLCHECK=SEMANTICS with the CALL statement.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB433" class="sect3"><a id="sthref862"></a>
<h4 class="sect3">CALL Example<a id="sthref863"></a></h4>
<p>If you have created a PL/SQL function <code>fact</code> (stored in the package <code>mathpkg</code>) that takes an integer as input and returns its factorial in an integer:</p>
<pre>     EXEC SQL CREATE OR REPLACE PACKAGE BODY mathpkg as 
       function fact(n IN INTEGER) RETURN INTEGER AS
         BEGIN
           IF (n &lt;= 0) then return 1;
           ELSE return n * fact(n - 1);
           END IF;
         END fact;
       END mathpkge;
     END-EXEC.
</pre>
<p>then to use <code>fact</code> in a Pro*COBOL application:</p>
<p>...</p>
<pre>          01 N      PIC S9(4) COMP.
          01 FACT   PIC S9(9) COMP.
...
     EXEC SQL CALL mathpkge.fact(:N) INTO :FACT END-EXEC.
...
</pre>
<p>For more information about this statement, see <a href="pcoafemb.htm#i24775">&#34;CALL (Executable Embedded SQL)&#34;</a>. For a complete explanation of passing arguments and other issues, see <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a>, &#34;External Routines&#34; chapter.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i5042"></a>
<div id="LNPCB434" class="sect2">
<h3 class="sect2">Using Dynamic PL/SQL</h3>
<p>Recall that Pro*COBOL treats an entire PL/SQL block like a single SQL statement. Therefore, you can store a PL/SQL block in a string host variable. Then, if the block contains no host variables, you can use dynamic SQL Method 1 to execute the PL/SQL string. Or, if the block contains a known number of host variables, you can use dynamic SQL Method 2 to prepare and execute the PL/SQL string. If the block contains an unknown number of host variables, you must use dynamic SQL Method 4. For more information, refer to <a href="pco09dyn.htm#g19788">Chapter 9, &#34;Oracle Dynamic SQL&#34;</a>, <a href="pco10ady.htm#g1024116">Chapter 10, &#34;ANSI Dynamic SQL&#34;</a>and <a href="pco11ody.htm#i9695">Chapter 11, &#34;Oracle Dynamic SQL: Method 4&#34;</a>.<a id="sthref864"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB435" class="sect2"><a id="sthref865"></a>
<h3 class="sect2">Subprograms Restriction</h3>
<p>In dynamic SQL Method 4, a host table cannot be bound to a PL/SQL procedure with a parameter of type TABLE.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i9641"></a>
<div id="LNPCB436" class="sect1">
<h2 class="sect1">Sample Program 9: Calling a Stored Procedure<a id="sthref866"></a><a id="sthref867"></a></h2>
<p>Before trying the sample program, you must create a PL/SQL package named <span class="italic">calldemo</span>, by running the following script, titled CALLDEMO.SQL, which is supplied with Pro*COBOL. The script can be found in the Pro*COBOL demo library. Check your system-specific Oracle documentation for exact spelling of the the name of the script.<a id="sthref868"></a><a id="sthref869"></a></p>
<pre>CREATE OR REPLACE PACKAGE calldemo AS

   TYPE name_array IS TABLE OF emp.ename%type
       INDEX BY BINARY_INTEGER;
   TYPE job_array IS TABLE OF emp.job%type
       INDEX BY BINARY_INTEGER;
   TYPE sal_array IS TABLE OF emp.sal%type
       INDEX BY BINARY_INTEGER;

   PROCEDURE get_employees(
     dept_number IN     number,    -- department to query
     batch_size  IN     INTEGER,   -- rows at a time
     found       IN OUT INTEGER,   -- rows actually returned
     done_fetch  OUT    INTEGER,   -- all done flag
     emp_name    OUT    name_array,
     job         OUT    job_array,
     sal         OUT    sal_array);

END calldemo;
/

CREATE OR REPLACE PACKAGE BODY calldemo AS

   CURSOR get_emp (dept_number IN number) IS
       SELECT ename, job, sal FROM emp
           WHERE deptno = dept_number;


   -- Procedure &#34;get_employees&#34; fetches a batch of employee
   -- rows (batch size is determined by the client/caller
   -- of the procedure).  It can be called from other
   -- stored procedures or client application programs.
   -- The procedure opens the cursor if it is not
   -- already open, fetches a batch of rows, and
   -- returns the number of rows actually retrieved. At
   -- end of fetch, the procedure closes the cursor.

   PROCEDURE get_employees(
     dept_number IN     number,
     batch_size  IN     INTEGER,
     found       IN OUT INTEGER,
     done_fetch  OUT    INTEGER,
     emp_name    OUT    name_array,
     job         OUT    job_array,
     sal         OUT    sal_array) IS

   BEGIN
       IF NOT get_emp%ISOPEN THEN      -- open the cursor if
           OPEN get_emp(dept_number);  -- not already open
       END IF;

       -- Fetch up to &#34;batch_size&#34; rows into PL/SQL table,
       -- tallying rows found as they are retrieved. When all
       -- rows have been fetched, close the cursor and exit
       -- the loop, returning only the last set of rows found.

       done_fetch := 0;  -- set the done flag FALSE
       found := 0;

       FOR i IN 1..batch_size LOOP
           FETCH get_emp INTO emp_name(i), job(i), sal(i);
           IF get_emp%NOTFOUND THEN    -- if no row was found
               CLOSE get_emp;
               done_fetch := 1;   -- indicate all done
               EXIT;
           ELSE
               found := found + 1;  -- count row
           END IF;
       END LOOP;
   END;
END;
/
</pre>
<p>The following sample program connects to the database, prompts the user for a department number and then calls a PL/SQL procedure named <span class="italic">get_employees</span>, which is stored in package <span class="italic">calldemo</span>. The procedure declares three PL/SQL tables as OUT formal parameters and then fetches a batch of employee data into the PL/SQL tables. The matching actual parameters are host tables. When the procedure finishes, row values in the PL/SQL tables are automatically assigned to the corresponding elements in the host tables. The program calls the procedure repeatedly, displaying each batch of employee data, until no more data is found.</p>
<pre>      *****************************************************************
      * Sample Program 9: Calling a Stored Procedure
      * 
      * This program connects to ORACLE, prompts the user for a
      * department number, then calls a PL/SQL stored procedure named
      * GET_EMPLOYEES, which is stored in package CALLDEMO.  The 
      * procedure declares three PL/SQL tables ast OUT formal
      * parameters, then fetches a batch of employee data into the 
      * PL/SQL tables.  The matching actual parameters are host tables.
      * When the procedure finishes, it automatically assigns all row
      * values in the PL/SQL tables to corresponding elements in the
      * host tables.  The program calls the procedure repeatedly,
      * displaying each batch of employee data, until no more data
      * is found.
      * Use option picx=varchar2 when precompiling this sample program.
      *****************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID. CALL-STORED-PROC.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME         PIC X(15) VARYING.
       01  PASSWD           PIC X(15) VARYING.
       01  DEPT-NUM         PIC S9(9) COMP.
       01  EMP-TABLES.
           05  EMP-NAME     OCCURS 10 TIMES PIC X(10).
           05  JOB-TITLE    OCCURS 10 TIMES PIC X(10).

           05  SALARY       OCCURS 10 TIMES COMP-2.

       01  DONE-FLAG        PIC S9(9) COMP.
       01  TABLE-SIZE       PIC S9(9) COMP VALUE 10.
       01  NUM-RET          PIC S9(9) COMP.
       01  SQLCODE          PIC S9(9) COMP.
           EXEC SQL END DECLARE SECTION END-EXEC.

       01  COUNTER          PIC S9(9) COMP.
       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME   PIC X(10).
           05  D-JOB-TITLE  PIC X(10).

           05  D-SALARY     PIC Z(5)9.

           05  D-DEPT-NUM   PIC 9(2).

           EXEC SQL INCLUDE SQLCA END-EXEC.

       PROCEDURE DIVISION.

       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR DO
               PERFORM SQL-ERROR END-EXEC.

           PERFORM LOGON.
           PERFORM INIT-TABLES VARYING COUNTER FROM 1 BY 1
               UNTIL COUNTER &gt; 10.
           PERFORM GET-DEPT-NUM.
           PERFORM DISPLAY-HEADER.
           MOVE ZERO TO DONE-FLAG.
           MOVE ZERO TO NUM-RET.
           PERFORM FETCH-BATCH UNTIL DONE-FLAG = 1.
           PERFORM LOGOFF.

       INIT-TABLES.
           MOVE SPACE TO EMP-NAME(COUNTER).
           MOVE SPACE TO JOB-TITLE(COUNTER).
           MOVE ZERO TO SALARY(COUNTER).

       GET-DEPT-NUM.
           MOVE ZERO TO DEPT-NUM.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ENTER DEPARTMENT NUMBER: &#34;
               WITH NO ADVANCING.

           ACCEPT D-DEPT-NUM.

           MOVE D-DEPT-NUM TO DEPT-NUM.

       DISPLAY-HEADER.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;EMPLOYEE    JOB TITLE    SALARY&#34;.
           DISPLAY &#34;--------    ---------    ------&#34;.

       FETCH-BATCH.
           EXEC SQL EXECUTE
               BEGIN
                   CALLDEMO.GET_EMPLOYEES
                       (:DEPT-NUM, :TABLE-SIZE,
                        :NUM-RET,  :DONE-FLAG,
                        :EMP-NAME, :JOB-TITLE, :SALARY);
               END;
           END-EXEC.
           PERFORM PRINT-ROWS VARYING COUNTER FROM 1 BY 1
               UNTIL COUNTER &gt; NUM-RET.

       PRINT-ROWS.
           MOVE EMP-NAME(COUNTER) TO D-EMP-NAME.
           MOVE JOB-TITLE(COUNTER) TO D-JOB-TITLE.
           MOVE SALARY(COUNTER) TO D-SALARY.
           DISPLAY D-EMP-NAME, &#34;  &#34;,
                   D-JOB-TITLE, &#34;   &#34;,
                   D-SALARY.

       LOGON.
           MOVE &#34;SCOTT&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;TIGER&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER: &#34;, USERNAME-ARR.

       LOGOFF.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY.&#34;.
           DISPLAY &#34; &#34;.
           EXEC SQL COMMIT WORK RELEASE END-EXEC.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
</pre>
<p>Remember that the datatype of each actual parameter must be convertible to the datatype of its corresponding formal parameter. Further, before a stored subprogram exits, all OUT formal parameters must be assigned values. Otherwise, the values of corresponding actual parameters are indeterminate.</p>
<div id="LNPCB437" class="sect2"><a id="sthref870"></a>
<h3 class="sect2">Remote Access</h3>
<p>PL/SQL lets you access remote databases through <span class="italic">database links</span>. Typically, database links are established by your DBA and stored in the data dictionary. A database link tells your program where the remote database is located, the path to it, and what username and password to use. The following example uses the database link <span class="italic">dallas</span> to call the <span class="italic">raise_salary</span> procedure:</p>
<pre>     EXEC SQL EXECUTE 
        BEGIN 
        raise_salary@dallas(:emp_id, :increase); 
        END; 
     END-EXEC. 
</pre>
<p>You can create synonyms to provide location transparency for remote subprograms, as the following example shows:</p>
<pre> CREATE PUBLIC SYNONYM raise_salary FOR raise_salary@dallas;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5051"></a>
<div id="LNPCB438" class="sect1">
<h2 class="sect1">Cursor Variables</h2>
<p>You can use <span class="italic">cursor variables</span> in your Pro*COBOL programs to process multi-row queries using static embedded SQL. A cursor variable identifies a <span class="italic">cursor reference</span> that is defined and opened on the database server, using PL/SQL. See <a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for complete information about cursor variables.<a id="sthref871"></a><a id="sthref872"></a></p>
<p>Like a cursor, a cursor variable points to the current row in the active set of a multi-row query. Cursors differ from cursor variables the way constants differ from variables. While a cursor is static, a cursor variable is dynamic, because it is not tied to a specific query. You can open a cursor variable for any type-compatible query.<a id="sthref873"></a></p>
<p>You can assign new values to a cursor variable and pass it as a parameter to subprograms, including subprograms stored in a database. This gives you a convenient way to centralize data retrieval.</p>
<p>First, you declare the cursor variable. After declaring the variable, you use these statements to control a cursor variable:</p>
<ul>
<li>
<p>ALLOCATE</p>
</li>
<li>
<p>OPEN ... FOR</p>
</li>
<li>
<p>FETCH</p>
</li>
<li>
<p>CLOSE</p>
</li>
<li>
<p>FREE</p>
</li>
</ul>
<p>After you declare the cursor variable and allocate memory for it, you must pass it as an input host variable (bind variable) to PL/SQL, OPEN it FOR a multi-row query on the server side, FETCH from it on the client side and then CLOSE it on either side.</p>
<p>The advantages of cursor variables are</p>
<ul>
<li>
<p>Ease of maintenance. Queries are centralized, in the stored procedure that opens the cursor variable. If you need to change the cursor, you only need to make the change in one place: the stored procedure. There is no need to change each application.</p>
</li>
<li>
<p>Increased Security. The user of the application (the username when the Pro*COBOL application connected to the database) must have execute permission on the stored procedure that opens the cursor. This user, however, does not need to have read permission on the tables used in the query. This capability can be used to limit access to the columns in the table.</p>
</li>
</ul>
<div id="LNPCB439" class="sect2"><a id="sthref874"></a>
<h3 class="sect2">Declaring a Cursor Variable</h3>
<p>You declare a Pro*COBOL cursor variable using the SQL-CURSOR pseudotype. For example:<a id="sthref875"></a><a id="sthref876"></a></p>
<pre> WORKING-STORAGE SECTION.
     ...
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
         ...
         01  CUR-VAR  SQL-CURSOR.
         ...
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre>
<p>A SQL-CURSOR variable is implemented as a COBOL group item in the code that Pro*COBOL generates. A cursor variable is just like any other Pro*COBOL host variable.<a id="sthref877"></a><a id="sthref878"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB440" class="sect2"><a id="sthref879"></a>
<h3 class="sect2">Allocating a Cursor Variable</h3>
<p>Before you can OPEN or FETCH from a cursor variable, you must initialize it using the Pro*COBOL ALLOCATE command. For example, to initialize the cursor variable CUR-VAR that was declared in the previous section, write the following statement:<span class="bold"><a id="sthref880"></a><a id="sthref881"></a><a id="sthref882"></a></span></p>
<pre>     EXEC SQL ALLOCATE :CUR-VAR END-EXEC.
</pre>
<p>Allocating a cursor variable does <span class="italic">not</span> require a call to the server, either at precompile time or at runtime.</p>
<p>The AT clause cannot be used in an ALLOCATE statement.</p>
<p><span class="bold">Caution:</span> Allocating a cursor variable <span class="italic">does</span> cause heap memory to be used. For this reason, avoid allocating a cursor variable in a program loop.<a id="sthref883"></a><a id="sthref884"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB441" class="sect2"><a id="sthref885"></a>
<h3 class="sect2">Opening a Cursor Variable</h3>
<p>You must use an embedded anonymous PL/SQL block to open a cursor variable on the database server. The anonymous PL/SQL block may open the cursor either indirectly by calling a PL/SQL stored procedure that opens the cursor (and defines it in the same statement) or directly from the Pro*COBOL program.<a id="sthref886"></a></p>
<div id="LNPCB442" class="sect3"><a id="sthref887"></a>
<h4 class="sect3">Opening Indirectly through a Stored PL/SQL Procedure</h4>
<p>Consider the following PL/SQL package stored in the database:<a id="sthref888"></a><a id="sthref889"></a><a id="sthref890"></a></p>
<pre>CREATE PACKAGE demo_cur_pkg AS
    TYPE EmpName IS RECORD (name VARCHAR2(10));
    TYPE cur_type IS REF CURSOR RETURN EmpName;
    PROCEDURE open_emp_cur (
               curs     IN OUT curtype,
               dept_num IN     number);
END;

CREATE PACKAGE BODY demo_cur_pkg AS
    CREATE PROCEDURE open_emp_cur (
               curs     IN OUT curtype,
               dept_num IN     number) IS
    BEGIN
        OPEN curs FOR
            SELECT ename FROM emp
                WHERE deptno = dept_num
                ORDER BY ename ASC;
    END;
END;
</pre>
<p>After this package has been stored, you can open the cursor <span class="italic">curs</span> by first calling the <span class="italic">open_emp_cur</span> stored procedure from your Pro*COBOL program and then issuing a FETCH from the cursor variable emp_cursor in the program. For example:</p>
<pre> WORKING-STORAGE SECTION.
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01  emp_cursor     sql-cursor.
 01  DEPT-NUM      PIC S9(4).
 01  EMP-NAME      PIC X(10) VARYING.
     EXEC SQL END DECLARE SECTION END-EXEC.
     ...

 PROCEDURE DIVISION.
     ...
*    Allocate the cursor variable.
     EXEC SQL 
         ALLOCATE :emp-cursor 
     END-EXEC.
     ...
     MOVE 30 TO dept_num.
*    Open the cursor on the Oracle Server.
     EXEC SQL EXECUTE
         begin
             demo_cur_pkg.open_emp_cur(:emp-cursor, :dept-num);
         END;
     END-EXEC.
     EXEC SQL 
         WHENEVER NOT FOUND DO PERFORM SIGN-OFF
     END-EXEC.
 FETCH-LOOP.
     EXEC SQL 
         FETCH :emp_cursor INTO :EMP-NAME 
     END-EXEC.
     DISPLAY &#34;Employee Name: &#34;,:EMP-NAME.
     GO TO FETCH-LOOP.
     ...
 SIGN-OFF.
     ...
</pre></div>
<!-- class="sect3" -->
<div id="LNPCB443" class="sect3"><a id="sthref891"></a>
<h4 class="sect3">Opening Directly from Your Pro*COBOL Application</h4>
<p>To open a cursor using a PL/SQL anonymous block in a Pro*COBOL program, define the cursor in the anonymous block. Consider the following example:<a id="sthref892"></a><a id="sthref893"></a></p>
<pre> PROCEDURE DIVISION.
     ...
     EXEC SQL EXECUTE
         begin
             OPEN :emp_cursor FOR SELECT ename FROM emp
                 WHERE deptno = :DEPT-NUM;
         end;
     END-EXEC.
     ...
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB444" class="sect2"><a id="sthref894"></a>
<h3 class="sect2">Fetching from a Cursor Variable</h3>
<p>After opening a cursor variable for a multi-row query, you use the FETCH statement to retrieve rows as you would from a static cursor. The syntax follows:<a id="sthref895"></a><a id="sthref896"></a></p>
<pre>     EXEC SQL FETCH cursor_variable_name 
         INTO {record_name | variable_name[, variable_name, ...]} 
     END-EXEC.
</pre>
<p>Each column value returned by the cursor variable is assigned to a corresponding field or variable in the INTO clause, providing that their datatypes are compatible. <a id="sthref897"></a></p>
<p>The FETCH statement must be executed on the client side. The following example fetches rows into a host record named <span class="italic">EMP-REC</span>:</p>
<pre>* -- exit loop when done fetching
     EXEC SQL
         WHENEVER NOT FOUND DO PERFORM NO-MORE
     END-EXEC.
     PERFORM
* -- fetch row into record
     EXEC SQL FETCH :EMP-CUR INTO :EMP-REC END-EXEC 
* -- test for transfer out of loop
     ...
* -- process the data
     ...
     END-PERFORM.
     ...
 NO-MORE.
     ...
</pre>
<p>Use the embedded SQL FETCH .... INTO command to retrieve the rows selected when you opened the cursor variable. For example:<a id="sthref898"></a></p>
<pre> EXEC SQL
     FETCH :emp_cursor INTO :EMP-INFO:EMP-INFO-IND
 END-EXEC.
</pre>
<p>Before you can FETCH from a cursor variable, the variable must be initialized and opened. You cannot FETCH from an unopened cursor variable.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB445" class="sect2"><a id="sthref899"></a>
<h3 class="sect2">Closing a Cursor Variable</h3>
<p>Use the embedded SQL CLOSE statement to close a cursor variable. At this point its active set becomes undefined. The syntax follows: <a id="sthref900"></a><a id="sthref901"></a></p>
<pre>     EXEC SQL CLOSE cursor_variable_name END-EXEC.
</pre>
<p>The CLOSE statement can be executed on the client side or the server side. The following example closes the cursor variable <span class="italic">CUR-VAR</span> when the last row is processed:</p>
<pre> WORKING-STORAGE SECTION.
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
*    Declare the cursor variable.
         01  CUR-VAR       SQL-CURSOR.
         ...
     EXEC SQL END DECLARE SECTION END-EXEC.

 PROCEDURE DIVISION.
*    Allocate and open the cursor variable, then
*    Fetch one or more rows.
     ...
*    Close the cursor variable.
     EXEC SQL
         CLOSE :CUR-VAR
     END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB446" class="sect2"><a id="sthref902"></a>
<h3 class="sect2">Freeing a Cursor Variable<a id="sthref903"></a></h3>
<p>To free memory allocated for the cursor variable, <span class="italic">CUR-VAR,</span> use the FREE statement after the CLOSE:</p>
<pre>*    Free the cursor variable memory.
     EXEC SQL 
         FREE :CUR-VAR
     END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB447" class="sect2"><a id="sthref904"></a>
<h3 class="sect2">Restrictions on Cursor<a id="sthref905"></a> Variables</h3>
<p>The following restrictions apply to the use of cursor variables:<span class="bold"><a id="sthref906"></a></span></p>
<ul>
<li>
<p>Cursor variables are not supported in dynamic SQL.</p>
</li>
<li>
<p>You can only use cursor variables with the ALLOCATE, FETCH, FREE, and CLOSE commands. The DECLARE CURSOR command does <span class="italic">not</span> apply to cursor variables.</p>
</li>
<li>
<p>You cannot use the AT clause with the ALLOCATE command.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCB448" class="sect2"><a id="sthref907"></a>
<h3 class="sect2">Sample Program 11: Cursor Variables<a id="sthref908"></a><a id="sthref909"></a></h3>
<p>The following sample programs&mdash;a SQL script (SAMPLE11.sql) and a Pro*COBOL program (SAMPLE11.pco)&mdash;demonstrate how you can use cursor variables in Pro*COBOL.<a id="sthref910"></a><a id="sthref911"></a></p>
<div id="LNPCB449" class="sect3"><a id="sthref912"></a>
<h4 class="sect3">SAMPLE11.SQL</h4>
<p>Following is the PL/SQL source code for a creating a package that declares and opens a cursor variable:<a id="sthref913"></a></p>
<pre>CONNECT SCOTT/TIGER
CREATE OR REPLACE PACKAGE emp_demo_pkg AS
    TYPE emp_cur_type IS REF CURSOR RETURN emp%ROWTYPE;
    PROCEDURE open_cur (
        cursor   IN OUT emp_cur_type,
        dept_num IN     number);
END emp_demo_pkg;
/  
CREATE OR REPLACE PACKAGE BODY emp_demo_pkg AS

    PROCEDURE open_cur (
        cursor   IN OUT emp_cur_type, 
        dept_num IN     number) IS
    BEGIN 
        OPEN cursor FOR SELECT * FROM emp
        WHERE deptno = dept_num
        ORDER BY ename ASC;
    END;
END emp_demo_pkg;
/
</pre></div>
<!-- class="sect3" -->
<div id="LNPCB450" class="sect3"><a id="sthref914"></a>
<h4 class="sect3">SAMPLE11.PCO</h4>
<p>Following is a Pro*COBOL sample program, SAMPLE11.PCO, that uses the cursor variable declared in the SAMPLE11.sql example to fetch employee names, salaries, and commissions from the EMP table:</p>
<pre>      *****************************************************************
      * Sample Program 11:  Cursor Variable Operations                *
      *                                                               *
      * This program logs on to ORACLE, allocates and opens a cursor  *
      * variable fetches the names, salaries, and commissions of all  *
      * salespeople, displays the results, then closes the cursor.    *
      *****************************************************************
                                          
       IDENTIFICATION DIVISION.
       PROGRAM-ID. CURSOR-VARIABLES.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(15) VARYING.
       01  PASSWD            PIC X(15) VARYING.
       01  HOST              PIC X(15) VARYING.
       01  EMP-CUR           SQL-CURSOR.
       01  EMP-INFO.
           05  EMP-NUM       PIC S9(4) COMP.
           05  EMP-NAM       PIC X(10) VARYING.
           05  EMP-JOB       PIC X(10) VARYING.
           05  EMP-MGR       PIC S9(4) COMP.
           05  EMP-DAT       PIC X(10) VARYING.
           05  EMP-SAL       PIC S9(6)V99 
                               DISPLAY SIGN LEADING SEPARATE.
           05  EMP-COM       PIC S9(6)V99 
                               DISPLAY SIGN LEADING SEPARATE.
           05  EMP-DEP       PIC S9(4) COMP.
       01  EMP-INFO-IND.
           05  EMP-NUM-IND   PIC S9(4) COMP.
           05  EMP-NAM-IND   PIC S9(4) COMP.
           05  EMP-JOB-IND   PIC S9(4) COMP.
           05  EMP-MGR-IND   PIC S9(4) COMP.
           05  EMP-DAT-IND   PIC S9(4) COMP.
           05  EMP-SAL-IND   PIC S9(4) COMP.
           05  EMP-COM-IND   PIC S9(4) COMP.
           05  EMP-DEP-IND   PIC S9(4) COMP.
           EXEC SQL END DECLARE SECTION END-EXEC.
      
           EXEC SQL INCLUDE SQLCA END-EXEC.   

       01  DISPLAY-VARIABLES.
           05  D-DEP-NUM     PIC Z(3)9.
           05  D-EMP-NAM     PIC X(10).
           05  D-EMP-SAL     PIC Z(4)9.99.
           05  D-EMP-COM     PIC Z(4)9.99.
           05  D-EMP-DEP     PIC 9(2).


       PROCEDURE DIVISION.
      
       BEGIN-PGM.
           EXEC SQL
               WHENEVER SQLERROR DO PERFORM SQL-ERROR
           END-EXEC.
           PERFORM LOGON.
           EXEC SQL
               ALLOCATE :EMP-CUR
           END-EXEC.
           DISPLAY &#34;Enter department number (0 to exit):  &#34; 
               WITH NO ADVANCING.
           ACCEPT D-EMP-DEP.
           MOVE D-EMP-DEP TO EMP-DEP.
           IF EMP-DEP &lt;= 0
               GO TO SIGN-OFF
           END-IF.
           MOVE EMP-DEP TO D-DEP-NUM.
           EXEC SQL EXECUTE
               BEGIN
                   emp_demo_pkg.open_cur(:EMP-CUR, :EMP-DEP);
               END;
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;For department &#34;, D-DEP-NUM, &#34;:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;EMPLOYEE   SALARY     COMMISSION&#34;.
           DISPLAY &#34;---------- ---------- ----------&#34;.
                 
       FETCH-LOOP.
           EXEC SQL
               WHENEVER NOT FOUND GOTO CLOSE-UP
           END-EXEC.
           MOVE SPACES TO EMP-NAM-ARR.
           EXEC SQL FETCH :EMP-CUR
               INTO :EMP-NUM:EMP-NUM-IND,
                    :EMP-NAM:EMP-NAM-IND,
                    :EMP-JOB:EMP-JOB-IND,
                    :EMP-MGR:EMP-MGR-IND,
                    :EMP-DAT:EMP-DAT-IND,
                    :EMP-SAL:EMP-SAL-IND,
                    :EMP-COM:EMP-COM-IND,
                    :EMP-DEP:EMP-DEP-IND
           END-EXEC.
           MOVE EMP-SAL TO D-EMP-SAL.
           IF EMP-COM-IND = 0
               MOVE EMP-COM TO D-EMP-COM
               DISPLAY EMP-NAM-ARR, &#34;   &#34;, D-EMP-SAL, 
                       &#34;   &#34;, D-EMP-COM
           ELSE
               DISPLAY EMP-NAM-ARR, &#34;   &#34;, D-EMP-SAL, 
                       &#34;        N/A&#34;
           END-IF.
           GO TO FETCH-LOOP. 
      
       LOGON.
           MOVE &#34;SCOTT&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;TIGER&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           MOVE &#34;INST1_ALIAS&#34; TO HOST-ARR.
           MOVE 11 TO HOST-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER: &#34;, USERNAME-ARR.

       CLOSE-UP.
           EXEC SQL
               CLOSE :EMP-CUR
           END-EXEC.
           EXEC SQL
               FREE :EMP-CUR
           END-EXEC.
       SIGN-OFF.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY.&#34;.
           DISPLAY &#34; &#34;.
           EXEC SQL
               COMMIT WORK RELEASE
           END-EXEC.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL
               WHENEVER SQLERROR CONTINUE
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL
               ROLLBACK WORK RELEASE
           END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pco05sql.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pco07tab.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>