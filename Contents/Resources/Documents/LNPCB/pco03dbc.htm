<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77854"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Database%20Concepts"></a><title>Database Concepts</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:13Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pco02prc.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pco04dat.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/27</span> <!-- End Header -->
<div id="LNPCB003" class="chapter"><a id="g16449"></a> <a id="i3879"></a>
<h1 class="chapter"><span class="secnum">3</span> Database Concepts</h1>
<p>This chapter explains the CONNECT statement and its options, Oracle Net Services, and related network connection statements. Transaction processing is presented. You learn the basic techniques that safeguard the consistency of your database, including how to control whether changes to Oracle data are made permanent or undone.</p>
<ul>
<li>
<p><a href="#i5876">Connecting to Oracle</a></p>
</li>
<li>
<p><a href="#i5948">Default Databases and Connections</a></p>
</li>
<li>
<p><a href="#i3930">Key Terms</a></p>
</li>
<li>
<p><a href="#i3948">How Transactions Guard a Database</a></p>
</li>
<li>
<p><a href="#i3969">Beginning and Ending Transactions</a></p>
</li>
<li>
<p><a href="#i3985">Using the COMMIT Statement</a></p>
</li>
<li>
<p><a href="#i4042">Using the ROLLBACK Statement</a></p>
</li>
<li>
<p><a href="#i4100">Using the SAVEPOINT Statement</a></p>
</li>
<li>
<p><a href="#i4181">Using the RELEASE Option</a></p>
</li>
<li>
<p><a href="#i4194">Using the SET TRANSACTION Statement</a></p>
</li>
<li>
<p><a href="#i4224">Overriding Default Locking</a></p>
</li>
<li>
<p><a href="#i7126">Fetching Across Commits</a></p>
</li>
<li>
<p><a href="#i4309">Handling Distributed Transactions</a></p>
</li>
<li>
<p><a href="#i4331">Guidelines for Transaction Processing</a></p>
</li>
</ul>
<a id="i5876"></a>
<div id="LNPCB203" class="sect1">
<h2 class="sect1">Connecting to Oracle</h2>
<p>Your Pro*COBOL program must log on to Oracle before querying or manipulating data. To log on, you use the CONNECT statement, as in<a id="sthref216"></a><a id="sthref217"></a><a id="sthref218"></a></p>
<pre>     EXEC SQL 
         CONNECT :USERNAME IDENTIFIED BY :PASSWD
     END-EXEC. 
</pre>
<p>where USERNAME and PASSWD are PIC X(<span class="italic">n</span>) or PIC X(<span class="italic">n</span>) VARYING host variables. Alternatively, you can use the statement:</p>
<pre>     EXEC SQL 
         CONNECT :USR-PWD 
     END-EXEC. 
</pre>
<p>where the host variable USR-PWD contains your username and password separated by a slash (/) followed by an optional tnsnames.ora alias (@TNSALIAS).</p>
<p>The syntax for the CONNECT statement has an optional ALTER AUTHORIZATION clause. The complete syntax for CONNECT is shown here:</p>
<pre>     EXEC SQL 
        CONNECT { :user IDENTIFIED BY :oldpswd | :usr_psw }
        [[AT { dbname | :host_variable }] USING :connect_string ]
        [ {ALTER AUTHORIZATION :newpswd  | IN {SYSDBA | SYSOPER} MODE} ]
     END-EXEC.
</pre>
<p>The ALTER AUTHORIZATION clause is explained in <a href="#i6209">&#34;Changing Passwords at Runtime&#34;</a>. The SYSDBA and SYSOPER options are explained in <a href="#i6233">&#34;SYSDBA or SYSOPER Privileges&#34;</a> .</p>
<p>The CONNECT statement must be the first SQL statement executed by the program. That is, other executable SQL statements can positionally, but not logically, precede the CONNECT statement. If the precompiler option AUTO_CONNECT=YES, a CONNECT statement is not needed.)<a id="sthref219"></a><a id="sthref220"></a></p>
<p>To supply the username and password separately, you define two host variables as character strings or VARCHAR variables. If you supply a userid containing both username and password, only one host variable is needed.<a id="sthref221"></a><a id="sthref222"></a><a id="sthref223"></a></p>
<p>Make sure to set the username and password variables before the CONNECT is executed or it will fail. Your program can prompt for the values or you can hard-code them, as follows:<a id="sthref224"></a><a id="sthref225"></a><a id="sthref226"></a></p>
<pre> WORKING STORAGE SECTION. 
     ... 
 01  USERNAME  PIC X(10). 
 01  PASSWD    PIC X(10). 
         ... 
     ... 
 PROCEDURE DIVISION. 
 LOGON. 
     EXEC SQL WHENEVER SQLERROR GOTO LOGON-ERROR END-EXEC. 
     MOVE &#34;SCOTT&#34; TO USERNAME. 
     MOVE &#34;TIGER&#34; TO PASSWD. 
     EXEC SQL 
         CONNECT :USERNAME IDENTIFIED BY :PASSWD 
     END-EXEC. 
</pre>
<p>However, you cannot hard-code a username and password into the CONNECT statement or use quoted literals. For example, the following statements are <span class="italic">invalid</span>:</p>
<pre>     EXEC SQL 
         CONNECT SCOTT IDENTIFIED BY TIGER 
     END-EXEC. 

     EXEC SQL 
         CONNECT &#34;SCOTT&#34; IDENTIFIED BY &#34;TIGER&#34; 
     END-EXEC.
</pre></div>
<!-- class="sect1" -->
<a id="i5948"></a>
<div id="LNPCB204" class="sect1">
<h2 class="sect1">Default Databases and Connections</h2>
<p>It is possible within a Pro*COBOL program to maintain more than one database connection at the same time.</p>
<a id="i7213"></a>
<div id="LNPCB205" class="sect2">
<h3 class="sect2">Concurrent Logons</h3>
<p><a id="sthref227"></a>Pro*COBOL supports distributed processing through Oracle Net Services. Your application can concurrently access any combination of local and remote databases or make multiple connections to the same database. In <a href="#BHCBICDF">Figure 3-1</a>, an application program communicates with one local and three remote Oracle databases. ORA2, ORA3, and ORA4 are logical names used in CONNECT statements. <a id="sthref228"></a><a id="sthref229"></a><a id="sthref230"></a><a id="sthref231"></a></p>
<div id="LNPCB206" class="figure">
<p class="titleinfigure"><a id="BHCBICDF"></a>Figure 3-1 Connecting Through Oracle</p>
<img width="605" height="300" src="img/pco81045.gif" alt="Connecting Through Oracle"/><br/>
<a id="sthref232" href="img_text/pco81045.htm">Description of &#34;Figure 3-1 Connecting Through Oracle&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>By eliminating the boundaries in a network between different machines and operating systems, Oracle Net Services provides a distributed processing environment for Oracle tools. This section shows you how the Pro*COBOL supports distributed processing through Oracle Net Services. You learn how your application can<a id="sthref233"></a><a id="sthref234"></a></p>
<ul>
<li>
<p>Access other databases directly or indirectly</p>
</li>
<li>
<p>Concurrently access any combination of local and remote databases</p>
</li>
<li>
<p>Make multiple connections to the same database</p>
</li>
</ul>
<p>Normally you would need only a single connection, achieved by <code>EXEC SQL CONNECT :USR-PWD END-EXEC</code>. The database that is connected to is determined by what USR-PWD contains. If it contains the username and password for the default database, it will connect to the database defined as the default for the session. If it contains <span class="italic">username</span>/<span class="italic">password</span>@REMDB&#34; it will connect through Oracle Net Services to the REMDB database as defined by your Oracle Net Services configuration. (An alternative is to use the USING clause to specify the Oracle Net Services connection string.) This is the default connection.</p>
<p>To make further concurrent connections to either the same or different databases you make use of the AT clause, that is, <code>EXEC SQL AT DB1 CONNECT :USR-PWD END-EXEC</code>. The name after the AT clause uniquely identifies a &#34;nondefault&#34; connection, and any SQL statements with the same name after the AT clause are executed against that connection. If the AT clause is omitted in an SQL statement then the statement is executed against the default connection.<a id="sthref235"></a><a id="sthref236"></a></p>
<p>All database names must be unique, but two or more database names can specify the same connection. That is, you can have multiple connections to any database on any node.<a id="sthref237"></a></p>
</div>
<!-- class="sect2" -->
<a id="i5956"></a>
<div id="LNPCB207" class="sect2">
<h3 class="sect2">Using Username/Password</h3>
<p>Usually, you establish a connection to Oracle as follows:<a id="sthref238"></a><a id="sthref239"></a></p>
<pre>     EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWORD END-EXEC.
</pre>
<p>Or you can use:</p>
<pre>     EXEC SQL CONNECT :USR-PWD END-EXEC.<span class="bold"> </span>
</pre>
<p>where <span class="italic">USR-PWD</span> contains any valid Oracle connect string.</p>
<p>You can also log on automatically, as shown in <a href="#i6175">&#34;Automatic Logons&#34;</a>.<a id="sthref240"></a></p>
<p>These are simplified subsets of the CONNECT statement. For all details, read the next sections in this chapter and also see <a href="pcoafemb.htm#i12848">&#34;CONNECT (Executable Embedded SQL Extension)&#34;</a><a id="sthref241"></a>.</p>
<a id="i5985"></a>
<div id="LNPCB208" class="sect3">
<h4 class="sect3">Named Database Connections</h4>
<p>In the following example, you connect to a named database. Normally you use a named database connection only for multiple concurrent connections. The following example shows the syntax for a single connection:<a id="sthref242"></a></p>
<pre>* --  Declare necessary host variables
 WORKING-STORAGE SECTION.
     ...
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01  USERNAME  PIC X(10) .
 01  PASSWORD  PIC X(10) .
 01  DB-STRING PIC X(20) .
        ...
     EXEC SQL END DECLARE SECTION END-EXEC.
     ...
 PROCEDURE DIVISION.
     MOVE &#34;scott&#34; TO USERNAME.
     MOVE &#34;tiger&#34; TO PASSSWORD.
     MOVE &#34;nyremote&#34; TO DB-STRING.
      ... 
* --  Assign a unique name to the database connection.
     EXEC SQL DECLARE DBNAME DATABASE<span class="bold"> </span>END-EXEC.
* --  Connect to the nondefault database
     EXEC SQL
     CONNECT :USERNAME IDENTIFIED BY :PASSWORD 
     AT DBNAME USING :DB-STRING
     END-EXEC.
</pre>
<p>The identifiers in this example serve the following purposes:</p>
<ul>
<li>
<p>The host variables <span class="italic">USERNAME</span> and <span class="italic">PASSWORD</span> identify a valid user.</p>
</li>
<li>
<p>The host variable <span class="italic">DB-STRING</span> contains the Oracle Net Services syntax for logging on to a nondefault database at a remote node.</p>
</li>
<li>
<p>The undeclared identifier <span class="italic">DBNAME</span> names a nondefault connection; it is an identifier used by Oracle, <span class="italic">not</span> a host or program variable.</p>
</li>
</ul>
<p>The USING clause specifies the network, machine, and database to be associated with <span class="italic">DBNAME</span>. Later, SQL statements using the AT clause (with <span class="italic">DBNAME</span>) are executed at the database specified by <span class="italic">DB-STRING</span>.<a id="sthref243"></a><a id="sthref244"></a><a id="sthref245"></a><a id="sthref246"></a></p>
<p>Alternatively, you can use a character host variable in the AT clause, as the following example shows:</p>
<pre>* --  Declare necessary host variables
 WORKING-STORAGE SECTION.
     ...
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01  USERNAME  PIC X(10).
 01  PASSWORD  PIC X(10).
 01  DB-NAME   PIC X(10).
 01  DB-STRING PIC X(20).
        ...
     EXEC SQL END DECLARE SECTION END-EXEC.
     ...
 PROCEDURE DIVISION.
     MOVE &#34;scott&#34; TO USERNAME.
     MOVE &#34;tiger&#34; TO PASSSWORD.
     MOVE &#34;oracle1&#34; TO DB-NAME.
     MOVE &#34;nyremote&#34; TO DB-STRING.
     ... 
* --  Connect to the nondefault database
     EXEC SQL
     CONNECT :USERNAME IDENTIFIED BY :PASSWORD 
     AT :DB-NAME USING :DB-STRING
     END-EXEC.
</pre>
<p>If <span class="italic">DB-NAME</span> is a host variable, the DECLARE DATABASE statement is not needed. Only if <span class="italic">DBNAME</span> is an undeclared identifier must you execute a DECLARE <span class="italic">DBNAME</span> DATABASE statement before executing a CONNECT ... AT <span class="italic">DBNAME</span> statement.</p>
<p><span class="bold">SQL Operations.</span> If granted the privilege, you can execute any SQL data manipulation statement at the nondefault connection. For example, you might execute the following sequence of statements:</p>
<pre>     EXEC SQL AT DBNAME SELECT ... 
     EXEC SQL AT DBNAME INSERT ... 
     EXEC SQL AT DBNAME UPDATE ... 
</pre>
<p>In the next example, <span class="italic">DB-NAME</span> is a host variable:</p>
<pre>     EXEC SQL AT :DB-NAME DELETE ... 
</pre>
<p><span class="bold">Cursor Control.</span> Cursor control statements such as OPEN, FETCH, and CLOSE are exceptions&mdash;they never use an AT clause. If you want to associate a cursor with an explicitly identified database, use the AT clause in the DECLARE CURSOR statement, as follows:<a id="sthref247"></a><a id="sthref248"></a></p>
<pre>     EXEC SQL AT :DB-NAME DECLARE emp_cursor CURSOR FOR ... 
     EXEC SQL OPEN emp_cursor ... 
     EXEC SQL FETCH emp_cursor ... 
     EXEC SQL CLOSE emp_cursor END-EXEC.
</pre>
<p>If <span class="italic">DB-NAME</span> is a host variable, its declaration must be within the scope of all SQL statements that refer to the declared cursor. For example, if you open the cursor in one subprogram, then fetch from it in another, you must declare <span class="italic">DB-NAME</span> globally or pass it to each subprogram.</p>
<p>When opening, closing, or fetching from the cursor, you do not use the AT clause. The SQL statements are executed at the database named in the AT clause of the DECLARE CURSOR statement or at the default database if no AT clause is used in the cursor declaration.</p>
<p>The AT <span class="italic">:host-variable</span> clause enables you to change the connection associated with a cursor. However, you cannot change the association while the cursor is open. Consider the following example:<a id="sthref249"></a><a id="sthref250"></a></p>
<pre>     EXEC SQL AT :DB-NAME DECLARE emp_cursor CURSOR FOR ... 
     MOVE &#34;oracle1&#34; TO DB-NAME.
     EXEC SQL OPEN emp_cursor END-EXEC. 
     EXEC SQL FETCH emp_cursor INTO ... 
     MOVE &#34;oracle2&#34; TO DB-NAME.
* -- illegal, cursor still open 
     EXEC SQL OPEN emp_cursor END-EXEC.
     EXEC SQL FETCH emp_cursor INTO ... 
</pre>
<p>This is illegal because <span class="italic">emp_cursor</span> is still open when you try to execute the second OPEN statement. Separate cursors are not maintained for different connections; there is only one <span class="italic">emp_cursor</span>, which must be closed before it can be reopened for another connection. To debug the last example, simply close the cursor before reopening it, as follows:</p>
<pre>* -- close cursor first 
     EXEC SQL CLOSE emp_cursor END-EXEC.
     MOVE &#34;oracle2&#34; TO DB-NAME.
     EXEC SQL OPEN EMP-CUROR END-EXEC. 
     EXEC SQL FETCH emp_cursor INTO ... 
</pre>
<p><span class="bold">Dynamic SQL</span>. Dynamic SQL statements are similar to cursor control statements in that some never use the AT clause. For dynamic SQL Method 1, you must use the AT clause if you want to execute the statement at a nondefault connection. An example follows:<a id="sthref251"></a><a id="sthref252"></a><a id="sthref253"></a></p>
<pre>     EXEC SQL AT :DB-NAME EXECUTE IMMEDIATE :SQL-STMT END-EXEC.
 
</pre>
<p>For Methods 2, 3, and 4, you use the AT clause only in the DECLARE STATEMENT statement if you want to execute the statement at a nondefault connection. All other dynamic SQL statements such as PREPARE, DESCRIBE, OPEN, FETCH, and CLOSE never use the AT clause. The next example shows Method 2:<a id="sthref254"></a><a id="sthref255"></a></p>
<pre>     EXEC SQL AT :DB-NAME DECLARE SQL-STMT STATEMENT END-EXEC. 
     EXEC SQL PREPARE SQL-STMT FROM :SQL-STRING END-EXEC. 
     EXEC SQL EXECUTE SQL-STMT END-EXEC. 
</pre>
<p>The following example shows Method 3:</p>
<pre>     EXEC SQL AT :DB-NAME DECLARE SQL-STMT STATEMENT END-EXEC. 
     EXEC SQL PREPARE SQL-STMT FROM :SQL-STRING END-EXEC. 
     EXEC SQL DECLARE emp_cursor CURSOR FOR SQL-STMT END-EXEC. 
     EXEC SQL OPEN emp_cursor ... 
     EXEC SQL FETCH emp_cursor INTO ... 
     EXEC SQL CLOSE emp_cursor END-EXEC. 
</pre>
<p>You need not use the AT clause when connecting to a remote database unless you open two or more connections simultaneously (in which case the AT clause is needed to identify the active connection). To make the default connection to a remote database, use the following syntax:</p>
<pre>     EXEC SQL 
        CONNECT :USERNAME IDENTIFIED BY :PASSWORD USING :DB-STRING
     END-EXEC.
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i6175"></a>
<div id="LNPCB209" class="sect2">
<h3 class="sect2">Automatic Logons</h3>
<p>You can log on to Oracle automatically with the userid:<a id="sthref256"></a><a id="sthref257"></a><a id="sthref258"></a></p>
<pre>&lt;prefix&gt;&lt;username&gt; 
</pre>
<p>where <span class="italic">prefix</span> is the value of the Oracle initialization parameter OS_AUTHENT_PREFIX (the default value is OPS$) and <span class="italic">username</span> is your operating system user or task name. For example, if the prefix is OPS$, your user name is TBARNES, and OPS$TBARNES is a valid Oracle userid, then you log on to Oracle as user OPS$TBARNES.</p>
<p>To take advantage of the automatic logon feature, you simply pass a slash (/) character to Pro*COBOL, as follows:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01 ORACLEID   PIC X.
     ...
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
     MOVE &#39;/&#39; TO ORACLEID.
     EXEC SQL CONNECT :ORACLEID END-EXEC. 
</pre>
<p>This automatically connects you as user OPS$<span class="italic">username</span>. For example, if your operating system username is RHILL, and OPS$RHILL is a valid Oracle username, connecting with a slash (/) automatically logs you on to Oracle as user OPS$RHILL.</p>
<p>You can also pass a character string to Pro*COBOL. However, the string cannot contain trailing blanks. For example, the following CONNECT statement will fail:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
           01 ORACLEID   PIC X(5).
     ...
     EXEC SQL END DECLARE SECTION END-EXEC. 
     ... 
     MOVE &#39;/    &#39; TO ORACLEID.
     EXEC SQL CONNECT :ORACLEID END-EXEC.
</pre>
<div id="LNPCB210" class="sect3"><a id="sthref259"></a>
<h4 class="sect3">The AUTO_CONNECT Precompiler Option</h4>
<p>Pro*COBOL lets your program log on to the default database without using the CONNECT statement. Simply specify the precompiler option AUTO_CONNECT on the command line.<a id="sthref260"></a><a id="sthref261"></a><a id="sthref262"></a></p>
<p>Assume that the default value of OS_AUTHENT_PREFIX is OPS$, your username is TBARNES, and OPS$TBARNES is a valid Oracle userid. When AUTO_CONNECT=YES, as soon as Pro*COBOL encounters an executable SQL statement, your program logs on to Oracle automatically with the userid OPS$TBARNES.</p>
<p>When AUTO_CONNECT=NO (the default), you must use the CONNECT statement to log on to Oracle.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i6209"></a>
<div id="LNPCB211" class="sect2">
<h3 class="sect2">Changing Passwords at Runtime<a id="sthref263"></a><a id="sthref264"></a></h3>
<p>Pro*COBOL provides client applications with a convenient way to change a user password at runtime through the optional ALTER AUTHORIZATION clause.</p>
<p>The syntax for the ALTER AUTHORIZATION clause is shown here:</p>
<pre>     EXEC SQL CONNECT .. ALTER AUTHORIZATION :<span class="italic">NEWPSWD</span> END-EXEC.
</pre>
<p>Using this clause indicates that you want to change the account password to the value indicated by NEWPSWD. After the change is made, an attempt is made to connect as <code>USER</code>/<code>NEWPSWD</code>. This can have the following results:</p>
<ul>
<li>
<p>The application will connect without issue.</p>
</li>
<li>
<p>The application will fail to connect. This could be due to either of the following:</p>
<ul>
<li>
<p>Password verification failed for some reason. In this case the password remains unchanged.</p>
</li>
<li>
<p>The account is locked. Changes to the password are not permitted.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCB212" class="sect2"><a id="sthref265"></a>
<h3 class="sect2">Connect Without Alter Authorization</h3>
<p>This section describes the possible outcomes of different variations of the CONNECT statement.</p>
<div id="LNPCB213" class="sect3"><a id="sthref266"></a>
<h4 class="sect3">Standard CONNECT</h4>
<p>If an application issues the following statement:</p>
<pre>      EXEC SQL CONNECT ...   /* No ALTER AUTHORIZATION clause */
</pre>
<p>it performs a normal connection attempt. The possible results include the following:</p>
<ul>
<li>
<p>The application will connect without issue.</p>
</li>
<li>
<p>The application will connect, but will receive a password warning. The warning indicates that the password has expired but is in a grace period which will allow logons. At this point, the user is encouraged to change the password before the account becomes locked.</p>
</li>
<li>
<p>The application will fail to connect. Possible causes include the following:</p>
<ul>
<li>
<p>The password is incorrect.</p>
</li>
<li>
<p>The account has expired, and is possibly in a locked state.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i6233"></a>
<div id="LNPCB214" class="sect3">
<h4 class="sect3">SYSDBA or SYSOPER Privileges<a id="sthref267"></a><a id="sthref268"></a></h4>
<p>Before Oracle release 8.1 you did not have to use this clause to have the SYSOPER or SYSDBA system privilege, but now you must.</p>
<p>Append the following optional string to the CONNECT statement after all other clauses if you want to log on with either SYSDBA or SYSOPER system privileges:</p>
<pre>IN { SYSDBA | SYSOPER } MODE
</pre>
<p>For example:</p>
<pre>EXEC SQL CONNECT ... IN SYSDBA MODE END-EXEC.
</pre>
<p>Here are the restrictions that apply to this option:</p>
<ul>
<li>
<p>This option is not supported when using the AUTO_CONNECT=YES precompiler option setting.</p>
</li>
<li>
<p>The option is not permitted when using the ALTER AUTHORIZATION keywords in the CONNECT statement.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB215" class="sect2"><a id="sthref269"></a>
<h3 class="sect2">Using Links</h3>
<p>Database links are supported through the Oracle distributed database option. For example, a distributed query allows a single SELECT statement to access data on one or more nondefault databases. <a id="sthref270"></a><a id="sthref271"></a></p>
<p>The distributed query facility depends on database links, which assign a name to a CONNECT statement rather than to the connection itself. At runtime, the embedded SELECT statement is executed by the specified database server, which connects implicitly to the nondefault database(s) to get the required data.</p>
<p>For more information, see <a class="olink NETAG" href="../NETAG/toc.htm"><span class="italic">Oracle Database Net Services Administrator&#39;s Guide.</span></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3930"></a>
<div id="LNPCB216" class="sect1">
<h2 class="sect1">Key Terms</h2>
<p>Before delving into the subject of transactions, you should know the terms defined in this section.</p>
<p>The jobs or tasks that the database manages are called <span class="bolditalic">sessions</span>. A <span class="bolditalic">user session</span> is started when you run an application program or a tool such as Oracle Forms and connect to the database. Oracle enables user sessions to work simultaneously and share computer resources. To do this, Oracle must control <span class="bolditalic">concurrence</span>, the accessing of the same data by many users. Without adequate concurrence controls, there might be a loss of <span class="bolditalic">data integrity</span>. That is, changes to data or structures might be made in the wrong order.<a id="sthref272"></a><a id="sthref273"></a><a id="sthref274"></a><a id="sthref275"></a></p>
<p>Oracle uses <span class="bolditalic">locks</span> to control concurrent access to data. A lock gives you temporary ownership of a database resource such as a table or row of data. Thus, data cannot be changed by other users until you finish with it. You need never explicitly lock a resource, because default locking mechanisms protect table data and structures. However, you can request <span class="bolditalic">data locks</span> on tables or rows when it is to your advantage to override default locking. You can choose from several <span class="bolditalic">modes</span> of locking such as <span class="bolditalic">row share</span> and <span class="bolditalic">exclusive</span>.<a id="sthref276"></a><a id="sthref277"></a><a id="sthref278"></a></p>
<p>A <span class="bolditalic">deadlock</span> can occur when two or more users try to access the same database object. For example, two users updating the same table might wait if each tries to update a row currently locked by the other. Because each user is waiting for resources held by another user, neither can continue until the server breaks the deadlock. The server signals an error to the participating transaction that had completed the least amount of work, and the &#34;deadlock detected while waiting for resource&#34; error code is returned to SQLCODE in the SQLCA.<a id="sthref279"></a></p>
<p>When a table is queried by one user and updated by another at the same time, the database generates a <span class="bolditalic">read consistent</span> view of the table&#39;s data for the query. That is, once a query begins (and proceeds), the data read by the query does not change. As update activity continues, the database takes <span class="bolditalic">snapshots</span> of the table&#39;s data and records changes in a <span class="bolditalic">rollback segment</span>. The database uses information in the rollback segment to build read consistent query results and to undo changes if necessary.<a id="sthref280"></a><a id="sthref281"></a><a id="sthref282"></a></p>
</div>
<!-- class="sect1" -->
<a id="i3948"></a>
<div id="LNPCB217" class="sect1">
<h2 class="sect1">How Transactions Guard a Database</h2>
<p>The database is transaction oriented; it uses transactions to ensure data integrity. A transaction is a series of one or more logically related SQL statements you define to accomplish some task. The database treats the series of SQL statements as a unit so that all the changes brought about by the statements are either <span class="italic">committed</span> (made permanent) or <span class="italic">rolled back</span> (undone) at the same time. If your application program fails in the middle of a transaction, the database is automatically restored to its former (pre-transaction) state.<a id="sthref283"></a><a id="sthref284"></a><a id="sthref285"></a></p>
<p>The coming sections show you how to define and control transactions. Specifically, it shows how to<a id="sthref286"></a>:</p>
<ul>
<li>
<p>Begin and end transactions</p>
</li>
<li>
<p>Use the COMMIT statement to make transactions permanent</p>
</li>
<li>
<p>Use the SAVEPOINT statement with the ROLLBACK TO statement to undo parts of transactions</p>
</li>
<li>
<p>Use the ROLLBACK statement to undo whole transactions</p>
</li>
<li>
<p>Specify the RELEASE option to free resources and log off the database</p>
</li>
<li>
<p>Use the SET TRANSACTION statement to set read-only transactions</p>
</li>
<li>
<p>Use the FOR UPDATE clause or LOCK TABLE statement to override default locking</p>
</li>
</ul>
<p>For details about the SQL statements discussed in this chapter, see the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="i3969"></a>
<div id="LNPCB218" class="sect1">
<h2 class="sect1">Beginning and Ending Transactions</h2>
<p>You begin a transaction with the first executable SQL statement (other than CONNECT) in your program. When one transaction ends, the next executable SQL statement automatically begins another transaction. Thus, every executable statement is part of a transaction. Because they cannot be rolled back and need not be committed, declarative SQL statements are not considered part of a transaction.<a id="sthref287"></a><a id="sthref288"></a><a id="sthref289"></a></p>
<p>You end a transaction in one of the following ways:<a id="sthref290"></a></p>
<ul>
<li>
<p>Code a COMMIT or ROLLBACK statement, with or without the RELEASE option. This <span class="italic">explicitly</span> makes permanent or undoes changes to the database.</p>
</li>
<li>
<p>Code a data definition statement (ALTER, CREATE, or GRANT, for example) that issues an automatic commit before <span class="italic">and</span> after executing. This <span class="italic">implicitly</span> makes permanent changes to the database.<a id="sthref291"></a><a id="sthref292"></a></p>
</li>
</ul>
<p>A transaction also ends when there is a system failure or your user session stops unexpectedly because of software problems, hardware problems, or a forced interrupt.<a id="sthref293"></a></p>
<p>If your program fails in the middle of a transaction, Oracle detects the error and rolls back the transaction. If your operating system fails, Oracle restores the database to its former (pre-transaction) state.<a id="sthref294"></a></p>
</div>
<!-- class="sect1" -->
<a id="i3985"></a>
<div id="LNPCB219" class="sect1">
<h2 class="sect1">Using the COMMIT Statement</h2>
<p>The COMMIT statement is used to make changes to the database permanent. Until changes are committed, other users cannot access the changed data; they see it as it was before your transaction began. The COMMIT statement has no effect on the values of host variables or on the flow of control in your program. Specifically, the COMMIT statement:<a id="sthref295"></a><a id="sthref296"></a><a id="sthref297"></a></p>
<ul>
<li>
<p>Makes permanent all changes made to the database during the current transaction.</p>
</li>
<li>
<p>Makes these changes visible to other users.</p>
</li>
<li>
<p>Erases all savepoints (see the next section).</p>
</li>
<li>
<p>Releases all row and table locks, but not parse locks.</p>
</li>
<li>
<p>Closes cursors declared using the FOR UPDATE clause or referenced elsewhere in the code with the CURRENT OF clause. If MODE=ANSI | ANSI14 or CLOSE_ON_COMMIT=YES is used, then all explicit cursors are closed.</p>
</li>
<li>
<p>Ends the transaction.</p>
</li>
</ul>
<p>When MODE={ANSI13 | ORACLE}, explicit cursors not referenced in a CURRENT OF clause remain open across commits. This can boost performance. For an example, see <a href="#i7126">&#34;Fetching Across Commits&#34;</a>.</p>
<p>Because they are part of normal processing, COMMIT statements should be placed inline, on the main path through your program. Before your program terminates, it must explicitly commit pending changes. Otherwise, Oracle rolls them back. In the following example, you commit your transaction and disconnect:<a id="sthref298"></a><a id="sthref299"></a></p>
<pre>    EXEC SQL COMMIT WORK RELEASE END-EXEC.
</pre>
<p>The optional keyword WORK provides ANSI compatibility. The RELEASE option frees all resources (locks and cursors) held by your program and logs off the database.<a id="sthref300"></a><a id="sthref301"></a><a id="sthref302"></a></p>
<p>You need not follow a data definition statement with a COMMIT statement because data definition statements issue an automatic commit before <span class="italic">and</span> after executing. So, whether they succeed or fail, the prior transaction is committed.</p>
<a id="i4014"></a>
<div id="LNPCB220" class="sect2">
<h3 class="sect2">WITH HOLD Clause in DECLARE CURSOR Statements</h3>
<p>Any cursor that has been declared with the clause WITH HOLD after the word CURSOR remains open after a COMMIT. The following example shows how to use this clause:</p>
<pre>     EXEC SQL 
         DECLARE C1 CURSOR WITH HOLD
         FOR SELECT ENAME FROM EMP
         WHERE EMPNO BETWEEN 7600 AND 7700
     END-EXEC.
</pre>
<p>The cursor must not be declared for UPDATE. The WITH HOLD clause is used in DB2 to override the default, which is to close all cursors on commit. Pro*COBOL provides this clause in order to ease migrations of applications from DB2 to Oracle. When MODE=ANSI, Oracle uses the DB2 default, but all host variables must be declared in a Declare Section. To avoid having a Declare Section, use the precompiler option <span class="italic">CLOSE_ON_COMMIT</span> described next. See <a href="pcoafemb.htm#i12806">&#34;DECLARE CURSOR (Embedded SQL Directive)&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i4365"></a>
<div id="LNPCB221" class="sect2">
<h3 class="sect2"><a id="sthref303"></a>CLOSE_ON_COMMIT Precompiler Option</h3>
<p>The precompiler option CLOSE_ON_COMMIT is available to override the default behavior of MODE=ANSI (if you specify MODE=ANSI on the command line, any cursors not declared with the WITH HOLD clause are closed on commit):</p>
<pre>CLOSE_ON_COMMIT = {YES | NO} 
</pre>
<p>The default is NO. This option must be entered only on the command line or in a configuration file.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Use this option carefully; applications may be slowed if cursors are opened and closed many times because of the need to re-parse for each OPEN statement. See <a href="pco14opt.htm#i8871">&#34;CLOSE_ON_COMMIT&#34;</a>.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i4042"></a>
<div id="LNPCB222" class="sect1">
<h2 class="sect1">Using the ROLLBACK Statement</h2>
<p>You use the ROLLBACK statement to undo pending changes made to the database. For example, if you make a mistake, such as deleting the wrong row from a table, you can use ROLLBACK to restore the original data. The ROLLBACK statement has no effect on the values of host variables or on the flow of control in your program. Specifically, the ROLLBACK statement<a id="sthref304"></a><a id="sthref305"></a><a id="sthref306"></a><a id="sthref307"></a><a id="sthref308"></a></p>
<ul>
<li>
<p>Undoes all changes made to the database during the current transaction</p>
</li>
<li>
<p>Erases all savepoints</p>
</li>
<li>
<p>Ends the transaction</p>
</li>
<li>
<p>Releases all row and table locks, but not parse locks</p>
</li>
<li>
<p>Closes cursors declared using the FOR UPDATE clause or referenced elsewhere in the code with the CURRENT OF clause. If MODE={ANSI | ANSI14}, then <span class="italic">all</span> explicit cursors are closed.</p>
</li>
</ul>
<p>When MODE={ANSI13 | ORACLE}, explicit cursors not referenced in a CURRENT OF clause remain open across rollbacks.</p>
<p>Because they are part of exception processing, ROLLBACK statements should be placed in error handling routines, off the main path through your program. In the following example, you roll back your transaction and disconnect:<a id="sthref309"></a><a id="sthref310"></a></p>
<pre>    EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
</pre>
<p>The optional keyword WORK provides ANSI compatibility. The RELEASE option frees all resources held by your program and logs off the database.<a id="sthref311"></a><a id="sthref312"></a></p>
<p>If a WHENEVER SQLERROR GOTO statement branches to an error handling routine that includes a ROLLBACK statement, your program might enter an infinite loop if the rollback fails with an error. You can avoid this by coding WHENEVER SQLERROR CONTINUE before the ROLLBACK statement.</p>
<p>For example, consider the following:<a id="sthref313"></a><a id="sthref314"></a></p>
<pre>     EXEC SQL
         WHENEVER SQLERROR GOTO SQL-ERROR
     END-EXEC.
     ...
     DISPLAY &#39;Employee number? &#39;.
     ACCEPT EMP-NUMBER.
     DISPLAY &#39;Employee name? &#39;.
     ACCEPT EMP-NAME.
     EXEC SQL INSERT INTO EMP (EMPNO, ENAME)
        VALUES (:EMP-NUMBER, :EMP-NAME)
     END-EXEC.
     ...
 SQL-ERROR.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
     DISPLAY &#39;PROCESSING ERROR.&#39;.
     DISPLAY &#39;ERROR CODE : &#39;, SQLCODE.
     DISPLAY &#39;MESSAGE :&#39;, SQLERRMC.
     EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
     STOP RUN.
</pre>
<p>Oracle rolls back transactions if your program terminates abnormally.<a id="sthref315"></a><a id="sthref316"></a></p>
<div id="LNPCB223" class="sect2"><a id="sthref317"></a>
<h3 class="sect2">Statement-Level Rollbacks</h3>
<p>Before executing any SQL statement, Oracle marks an implicit savepoint (not available to you). Then, if the statement fails, Oracle rolls it back automatically and returns the applicable error code to SQLCODE in the SQLCA. For example, if an INSERT statement causes an error by trying to insert a duplicate value in a unique index, the statement is rolled back.<a id="sthref318"></a><a id="sthref319"></a></p>
<p>Only work started by the failed SQL statement is lost; work done before that statement in the current transaction is kept. Thus, if a data definition statement fails, the automatic commit that precedes it is not undone.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Before executing a SQL statement, Oracle must parse it, that is, examine it to make sure it follows syntax rules and refers to valid database objects. Errors detected while executing a SQL statement cause a rollback, but errors detected while parsing the statement do not.</div>
<p>Oracle can also roll back single SQL statements to break deadlocks. Oracle signals an error to one of the participating transactions and rolls back the current statement in that transaction.<a id="sthref320"></a><a id="sthref321"></a><a id="sthref322"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i4100"></a>
<div id="LNPCB224" class="sect1">
<h2 class="sect1">Using the SAVEPOINT Statement<a id="sthref323"></a></h2>
<p>The SAVEPOINT embedded SQL statement marks and names the current point in processing a transaction. Each marked point is called a <span class="italic">savepoint</span>. For example, the following statement marks a savepoint named <span class="italic">start_delete</span>:<a id="sthref324"></a><a id="sthref325"></a><a id="sthref326"></a></p>
<pre>    EXEC SQL SAVEPOINT start_delete END-EXEC.
</pre>
<p>Savepoints let you divide long transactions, giving you more control over complex procedures. For example, if a transaction performs several functions, you can mark a savepoint before each function. Then, if a function fails, you can easily restore the data to its former state, recover, and then reexecute the function.<a id="sthref327"></a></p>
<p>To undo part of a transaction, you can use savepoints with the ROLLBACK statement and its TO SAVEPOINT clause. The TO SAVEPOINT clause lets you roll back to an intermediate statement in the current transaction. With it, you do not have to undo all your changes. Specifically, the ROLLBACK TO SAVEPOINT statement:<a id="sthref328"></a><a id="sthref329"></a></p>
<ul>
<li>
<p>Undoes changes made to the database since the specified savepoint was marked</p>
</li>
<li>
<p>Erases all savepoints marked after the specified savepoint</p>
</li>
<li>
<p>Releases all row and table locks acquired since the specified savepoint was marked</p>
</li>
</ul>
<p>In the following example, you access the table MAIL_LIST to insert new listings, update old listings, and delete (a few) inactive listings. After the delete, you check SQLERRD(3) in the SQLCA for the number of rows deleted. If the number is unexpectedly large, you roll back to the savepoint <span class="italic">start_delete</span>, undoing just the delete.<a id="sthref330"></a></p>
<pre>* -- For each new customer
     DISPLAY &#39;New customer number? &#39;.
     ACCEPT CUST-NUMBER.
     IF CUST-NUMBER = 0
          GO TO REV-STATUS
     END-IF.
     DISPLAY &#39;New customer name? &#39;.
          ACCEPT  CUST-NAME.
     EXEC SQL INSERT INTO MAIL-LIST (CUSTNO, CNAME, STAT)
         VALUES (:CUST-NUMBER, :CUST-NAME, &#39;ACTIVE&#39;).
     END-EXEC.
     ...
* -- For each revised status
 REV-STATUS.
     DISPLAY &#39;Customer number to revise status? &#39;.
     ACCEPT CUST-NUMBER.
     IF CUST-NUMBER = 0
         GO TO SAVE-POINT
     END-IF.
     DISPLAY &#39;New status? &#39;.
     ACCEPT NEW-STATUS.
     EXEC SQL UPDATE MAIL-LIST
        SET STAT = :NEW-STATUS WHERE CUSTNO = :CUST-NUMBER
     END-EXEC.
     ...
* -- mark savepoint
 SAVE-POINT.
     EXEC SQL SAVEPOINT START-DELETE END-EXEC.
     EXEC SQL DELETE FROM MAIL-LIST WHERE STAT = &#39;INACTIVE&#39;
     END-EXEC.
     IF SQLERRD(3) &lt; 25 
* -- check number of rows deleted
         DISPLAY &#39;Number of rows deleted is &#39;, SQLERRD(3)
     ELSE
         DISPLAY &#39;Undoing deletion of &#39;, SQLERRD(3), &#39; rows&#39;
         EXEC SQL
             WHENEVER SQLERROR GOTO SQL-ERROR
         END-EXEC
         EXEC SQL
             ROLLBACK TO SAVEPOINT START-DELETE
         END-EXEC
     END-IF.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
     EXEC SQL COMMIT WORK RELEASE END-EXEC.
     STOP RUN.
* -- exit program.
     ...
 SQL-ERROR.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
     EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
     DISPLAY &#39;Processing error&#39;.
* -- exit program with an error.
     STOP RUN.
</pre>
<p>Note that you cannot specify the RELEASE option in a ROLLBACK TO SAVEPOINT statement.<a id="sthref331"></a><a id="sthref332"></a><a id="sthref333"></a><a id="sthref334"></a></p>
<p>Rolling back to a savepoint erases any savepoints marked after that savepoint. The savepoint to which you roll back, however, is not erased. For example, if you mark five savepoints, then roll back to the third, only the fourth and fifth are erased. A COMMIT or ROLLBACK statement erases all savepoints.<a id="sthref335"></a></p>
</div>
<!-- class="sect1" -->
<a id="i4181"></a>
<div id="LNPCB225" class="sect1">
<h2 class="sect1">Using the RELEASE Option</h2>
<p>Oracle rolls back changes automatically if your program terminates abnormally. Abnormal termination occurs when your program does not explicitly commit or roll back work and disconnect using the RELEASE embedded SQL statement.</p>
<p>Normal termination occurs when your program runs its course, closes open cursors, explicitly commits or rolls back work, disconnects, and returns control to the user. Your program will exit gracefully if the last SQL statement it executes is either<a id="sthref336"></a><a id="sthref337"></a></p>
<pre>     EXEC SQL COMMIT WORK RELEASE END-EXEC. 
</pre>
<p>or</p>
<pre>     EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
 
</pre>
<p>where the token WORK is optional. Otherwise, locks and cursors acquired by your user session are held after program termination until Oracle recognizes that the user session is no longer active. This might cause other users in a multiuser environment to wait longer than necessary for the locked resources.<a id="sthref338"></a></p>
</div>
<!-- class="sect1" -->
<a id="i4194"></a>
<div id="LNPCB226" class="sect1">
<h2 class="sect1">Using the SET TRANSACTION Statement</h2>
<p>You can use the SET TRANSACTION statement to begin a read-only or read/write transaction, or to assign your current transaction to a specified rollback segment. A COMMIT, ROLLBACK, or data definition statement ends a read-only transaction.</p>
<p>Because they allow &#34;repeatable reads,&#34; read-only transactions are useful for running multiple queries against one or more tables while other users update the same tables. During a read-only transaction, all queries refer to the same snapshot of the database, providing a multitable, multiquery, read-consistent view. Other users can continue to query or update data as usual. An example of the SET TRANSACTION statement follows: <a id="sthref339"></a><a id="sthref340"></a><a id="sthref341"></a><a id="sthref342"></a></p>
<pre>     EXEC SQL SET TRANSACTION READ ONLY END-EXEC.
 
</pre>
<p>The SET TRANSACTION statement must be the first SQL statement in a read-only transaction and can appear only once in a transaction. The READ ONLY parameter is required. Its use does not affect other transactions. Only the SELECT (without FOR UPDATE), LOCK TABLE, SET ROLE, ALTER SESSION, ALTER SYSTEM, COMMIT, and ROLLBACK statements are allowed in a read-only transaction.<a id="sthref343"></a><a id="sthref344"></a><a id="sthref345"></a><a id="sthref346"></a><a id="sthref347"></a></p>
<p>In the following example, a store manager checks sales activity for the day, the past week, and the past month by using a read-only transaction to generate a summary report. The report is unaffected by other users updating the database during the transaction.<a id="sthref348"></a></p>
<pre>     EXEC SQL SET TRANSACTION READ ONLY END-EXEC. 
     EXEC SQL SELECT SUM(SALEAMT) INTO :DAILY FROM SALES 
         WHERE SALEDATE = SYSDATE END-EXEC.
     EXEC SQL SELECT SUM(SALEAMT) INTO :WEEKLY FROM SALES
         WHERE SALEDATE &gt; SYSDATE - 7 END-EXEC.
     EXEC SQL SELECT SUM(SALEAMT) INTO :MONTHLY FROM SALES 
         WHERE SALEDATE &gt; SYSDATE - 30 END-EXEC. 
     EXEC SQL COMMIT WORK END-EXEC. 
* --  simply ends the transaction since there are no changes 
* --  to make permanent 
* --  format and print report 
</pre></div>
<!-- class="sect1" -->
<a id="i4224"></a>
<div id="LNPCB227" class="sect1">
<h2 class="sect1">Overriding Default Locking</h2>
<p>By default, Oracle implicitly (automatically) locks many data structures for you. However, you can request specific data locks on rows or tables when it is to your advantage to override default locking. Explicit locking lets you share or deny access to a table for the duration of a transaction or ensure multitable and multiquery read consistency.<a id="sthref349"></a><a id="sthref350"></a><a id="sthref351"></a></p>
<p>With the SELECT FOR UPDATE OF statement, you can explicitly lock specific rows of a table to make sure they do not change before an update or delete is executed. However, Oracle automatically obtains row-level locks at update or delete time. So, use the FOR UPDATE OF clause only if you want to lock the rows <span class="italic">before</span> the update or delete.<a id="sthref352"></a></p>
<p>You can explicitly lock entire tables using the LOCK TABLE statement.</p>
<a id="i4233"></a>
<div id="LNPCB228" class="sect2">
<h3 class="sect2">Using the FOR UPDATE OF Clause</h3>
<p>When you DECLARE a cursor, you can meanwhile optionally specify the FOR UPDATE clause, which has the effect of acquiring an exclusive lock on all rows defined by the cursor. This is useful, for example, when you want to base an update on existing rows in a table and want to ensure that they are not meanwhile changed by anyone else.</p>
<p>Note that if you refer to a cursor with the CURRENT OF clause, that the precompiler will automatically add the FOR UPDATE clause to the cursor definition and the word OF is optional.<a id="sthref353"></a><a id="sthref354"></a> For instance, instead of:</p>
<pre>     EXEC SQL DECLARE emp_cursor CURSOR FOR 
         SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 20 
            FOR UPDATE OF SAL
     END-EXEC.
 
</pre>
<p>you can drop the OF part of the clause and simply code:</p>
<pre>    EXEC SQL DECLARE emp_cursor CURSOR FOR 
        SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 20 
           FOR UPDATE
    END-EXEC.
</pre>
<p>For an example, see <a href="pco05sql.htm#i2016">&#34;Using the CURRENT OF Clause&#34;</a>.</p>
<div id="LNPCB229" class="sect3"><a id="sthref355"></a>
<h4 class="sect3">Restrictions</h4>
<p>You cannot use FOR UPDATE with multiple tables, but you must use FOR UPDATE OF to identify a column in the table that you want locked. Row locks obtained by a FOR UPDATE statement are cleared by a COMMIT, which explains why the cursor is closed for you. If you try to fetch from a FOR UPDATE cursor after a commit, Oracle generates a Fetch out of Sequence error.<a id="sthref356"></a><a id="sthref357"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7126"></a>
<div id="LNPCB230" class="sect1">
<h2 class="sect1">Fetching Across Commits</h2>
<p>If you want to mix commits and fetches, do not use the CURRENT OF clause. Instead, select the ROWID of each row, and then use that value to identify the current row during the update or delete. Consider the following example:<a id="sthref358"></a><a id="sthref359"></a></p>
<pre>     EXEC SQL DECLARE emp_cursor CURSOR FOR
         SELECT ENAME, SAL, ROWID FROM EMP WHERE JOB = &#39;CLERK&#39;
     END-EXEC.
     ...
     EXEC SQL OPEN emp_cursor END-EXEC.
     EXEC SQL WHENEVER NOT FOUND GOTO ...
     PERFORM
     EXEC SQL
         FETCH emp_cursor INTO :EMP_NAME, :SALARY, :ROW-ID
     END-EXEC
     ... 
         EXEC SQL UPDATE EMP SET SAL = :NEW-SALARY
             WHERE ROWID = :ROW-ID
         END-EXEC
         EXEC SQL COMMIT END-EXEC
     END-PERFORM.
</pre>
<p>Note, however, that the fetched rows are <span class="italic">not</span> locked. So, you can receive inconsistent results if another user modifies a row after you read it but before you update or delete it.</p>
<a id="i4261"></a>
<div id="LNPCB231" class="sect2">
<h3 class="sect2">Using the LOCK TABLE Statement</h3>
<p>Use the LOCK TABLE statement locks one or more tables in a specified lock mode. For example, the following statement locks the EMP table in <span class="italic">row share</span> mode. Row share locks allow concurrent access to a table. They prevent other users from locking the entire table for exclusive use.<a id="sthref360"></a><a id="sthref361"></a><a id="sthref362"></a><a id="sthref363"></a><a id="sthref364"></a></p>
<pre>     EXEC SQL
         LOCK TABLE EMP IN ROW SHARE MODE NOWAIT
     END-EXEC.
</pre>
<p>The lock mode determines what other locks can be placed on the table. For example, many users can acquire row share locks on a table at the same time, but only one user at a time can acquire an <span class="italic">exclusive</span> lock. While one user has an exclusive lock on a table, no other users can insert, update, or delete rows in that table. For more information about lock modes, see the <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a></p>
<p>The optional keyword NOWAIT tells Oracle not to wait for a table if it has been locked by another user. Control is immediately returned to your program so that it can do other work before trying again to acquire the lock. (You can check SQLCODE in the SQLCA to see if the table lock failed.) If you omit NOWAIT, Oracle waits until the table is available; the wait has no set limit.<a id="sthref365"></a><a id="sthref366"></a><a id="sthref367"></a></p>
<p>A table lock never keeps other users from querying a table, and a query never acquires a table lock. Consequently, a query never blocks another query or an update, and an update never blocks a query. Only if two different transactions try to update the same row will one transaction wait for the other to complete. Table locks are released when your transaction issues a COMMIT or ROLLBACK.<a id="sthref368"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i4309"></a>
<div id="LNPCB232" class="sect1">
<h2 class="sect1">Handling Distributed Transactions</h2>
<p>A <span class="italic">distributed database</span> is a single logical database comprising multiple physical databases at different nodes. A <span class="italic">distributed statement</span> is any SQL statement that accesses a remote node using a database link. A <span class="italic">distributed transaction</span> includes at least one distributed statement that updates data at multiple nodes of a distributed database. If the update affects only one node, the transaction is non-distributed.</p>
<p>When you issue a commit, changes to each database affected by the distributed transaction are made permanent. If instead you issue a rollback, all the changes are undone. However, if a network or machine fails during the commit or rollback, the state of the distributed transaction might be unknown or <span class="italic">in doubt</span>. In such cases, if you have FORCE TRANSACTION system privileges, you can manually commit or roll back the transaction at your local database by using the FORCE clause. The transaction must be identified by a quoted literal containing the transaction ID, which can be found in the data dictionary view DBA_2PC_PENDING. Some examples follow:<a id="sthref369"></a><a id="sthref370"></a></p>
<pre>     EXEC SQL COMMIT FORCE &#39;22.31.83&#39; END-EXEC.
     ...
     EXEC SQL ROLLBACK FORCE &#39;25.33.86&#39;END-EXEC.
</pre>
<p>FORCE commits or rolls back only the specified transaction and does not affect your current transaction. Note that you cannot manually roll back in-doubt transactions to a savepoint.</p>
<p>The COMMENT clause in the COMMIT statement lets you specify a Comment to be associated with a distributed transaction. If ever the transaction is in doubt, the server stores the text specified by COMMENT in the data dictionary view DBA_2PC_PENDING along with the transaction ID. The text must be a quoted literal of no more than &thinsp;50 characters in length. An example follows:</p>
<pre>     EXEC SQL
         COMMIT COMMENT &#39;In-doubt trans; notify Order Entry&#39;
     END-EXEC.
</pre>
<p>For more information about distributed transactions, see <a class="olink CNCPT1125" href="../CNCPT/transact.htm#CNCPT1125"><span class="italic">Oracle Database Concepts.</span></a></p>
</div>
<!-- class="sect1" -->
<a id="i4331"></a>
<div id="LNPCB233" class="sect1">
<h2 class="sect1">Guidelines for Transaction Processing</h2>
<p>The following guidelines will help you avoid some common problems.</p>
<div id="LNPCB234" class="sect2"><a id="sthref371"></a>
<h3 class="sect2">Designing Applications</h3>
<p>When designing your application, group logically related actions together in one transaction. A well-designed transaction includes all the steps necessary to accomplish a given task&mdash;no more and no less.</p>
<p>Data in the tables you reference must be left in a consistent state. Thus, the SQL statements in a transaction should change the data in a consistent way. For example, a transfer of funds between two bank accounts should include a debit to one account and a credit to another. Both updates should either succeed or fail together. An unrelated update, such as a new deposit to one account, should not be included in the transaction.<a id="sthref372"></a><a id="sthref373"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB235" class="sect2"><a id="sthref374"></a>
<h3 class="sect2">Obtaining Locks</h3>
<p>If your application programs include SQL locking statements, make sure the users requesting locks have the privileges needed to obtain the locks. Your DBA can lock any table. Other users can lock tables they own or tables for which they have a privilege, such as ALTER, SELECT, INSERT, UPDATE, or DELETE.<a id="sthref375"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB236" class="sect2"><a id="sthref376"></a>
<h3 class="sect2">Using PL/SQL</h3>
<p>If a PL/SQL block is part of a transaction, commits and rollback operations inside the block affect the whole transaction. In the following example, the rollback operation undoes changes made by the update <span class="italic">and</span> the insert:<a id="sthref377"></a><a id="sthref378"></a></p>
<pre>     EXEC SQL INSERT INTO EMP ...
     EXEC SQL EXECUTE
     BEGIN        UPDATE emp 
     ...
         ...
     EXCEPTION
         WHEN DUP_VAL_ON_INDEX THEN
             ROLLBACK;
     END;
     END-EXEC.
     ...
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB237" class="sect2"><a id="sthref379"></a>
<h3 class="sect2">X/Open Applications</h3>
<p>For instructions on using the XA interface in X/Open applications, see your Transaction Processing (TP) Monitor user&#39;s guide and <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide.</span></a></p>
<pre></pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pco02prc.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pco04dat.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>