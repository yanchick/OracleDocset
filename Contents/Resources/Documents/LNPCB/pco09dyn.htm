<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77860"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Oracle%20Dynamic%20SQL"></a><title>Oracle Dynamic SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:20Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pco08err.htm" title="Previous" type="text/html"/>
<link rel="Next" href="partpage2.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/27</span> <!-- End Header -->
<div id="LNPCB009" class="chapter"><a id="g19788"></a> <a id="i7933"></a>
<h1 class="chapter"><span class="secnum">9</span> Oracle Dynamic SQL</h1>
<p>This chapter shows you how to use dynamic SQL, an advanced programming technique that adds flexibility and functionality to your applications. After weighing the advantages and disadvantages of dynamic SQL, you learn four methods&mdash;from simple to complex&mdash;for writing programs that accept and process SQL statements &#34;on the fly&#34; at run time. You learn the requirements and limitations of each method and how to choose the right method for a given job.</p>
<p>Topics are:</p>
<ul>
<li>
<p><a href="#i3846">Dynamic SQL</a></p>
</li>
<li>
<p><a href="#i3851">Advantages and Disadvantages of Dynamic SQL</a></p>
</li>
<li>
<p><a href="#i3856">When to Use Dynamic SQL</a></p>
</li>
<li>
<p><a href="#i3861">Requirements for Dynamic SQL Statements</a></p>
</li>
<li>
<p><a href="#i3866">How Dynamic SQL Statements Are Processed</a></p>
</li>
<li>
<p><a href="#i3877">Methods for Using Dynamic SQL</a></p>
</li>
<li>
<p><a href="#i7445">Using Method 1</a></p>
</li>
<li>
<p><a href="#i3887">Sample Program 6: Dynamic SQL Method 1</a></p>
</li>
<li>
<p><a href="#i3892">Using Method 2</a></p>
</li>
<li>
<p><a href="#i3897">Sample Program 7: Dynamic SQL Method 2</a></p>
</li>
<li>
<p><a href="#i6266">Using Method 3</a></p>
</li>
<li>
<p><a href="#i3911">Sample Program 8: Dynamic SQL Method 3</a></p>
</li>
<li>
<p><a href="#i3705">Using Oracle Method 4</a></p>
</li>
<li>
<p><a href="#i3919">Using the DECLARE STATEMENT Statement</a></p>
</li>
<li>
<p><a href="#i3929">Using Host Tables</a></p>
</li>
<li>
<p><a href="#i3934">Using PL/SQL</a></p>
</li>
<li>
<p><a href="#BABHGCIA">Dynamic SQL Statement Caching</a></p>
</li>
</ul>
<a id="i3846"></a>
<div id="LNPCB573" class="sect1">
<h2 class="sect1">Dynamic SQL</h2>
<p>Most database applications do a specific job. For example, a simple program might prompt the user for an employee number, then update rows in the EMP and DEPT tables. In this case, you know the makeup of the UPDATE statement at precompile time. That is, you know which tables might be changed, the constraints defined for each table and column, which columns might be updated, and the datatype of each column.<a id="sthref1248"></a></p>
<p>However, some applications must accept (or build) and process a variety of SQL statements at run time. For example, a general-purpose report writer must build different SELECT statements for the various reports it generates. In this case, the statement&#39;s makeup is unknown until run time. Such statements can, and probably will, change from execution to execution. They are aptly called <span class="italic">dynamic</span> SQL statements.<a id="sthref1249"></a></p>
<p>Unlike static SQL statements, dynamic SQL statements are not embedded in your source program. Instead, they are stored in character strings input to or built by the program at run time. They can be entered interactively or read from a file.<a id="sthref1250"></a></p>
</div>
<!-- class="sect1" -->
<a id="i3851"></a>
<div id="LNPCB574" class="sect1">
<h2 class="sect1">Advantages and Disadvantages of Dynamic SQL</h2>
<p>Host programs that accept and process dynamically defined SQL statements are more versatile than plain embedded SQL programs. Dynamic SQL statements can be built interactively with input from users having little or no knowledge of SQL.<a id="sthref1251"></a></p>
<p>For example, your program might simply prompt users for a search condition to be used in the WHERE clause of a SELECT, UPDATE, or DELETE statement. A more complex program might allow users to choose from menus listing SQL operations, table and view names, column names, and so on. Thus, dynamic SQL lets you write highly flexible applications.</p>
<p>However, some dynamic queries require complex coding, the use of special data structures, and more runtime processing. While you might not notice the added processing time, you might find the coding difficult unless you fully understand dynamic SQL concepts and methods.</p>
</div>
<!-- class="sect1" -->
<a id="i3856"></a>
<div id="LNPCB575" class="sect1">
<h2 class="sect1">When to Use Dynamic SQL</h2>
<p>In practice, static SQL will meet nearly all your programming needs. Use dynamic SQL only if you need its open-ended flexibility. Its use is suggested when one or more of the following items is unknown at precompile time:<a id="sthref1252"></a></p>
<ul>
<li>
<p>Text of the SQL statement (commands, clauses, and so on)</p>
</li>
<li>
<p>The number of host variables</p>
</li>
<li>
<p>The datatypes of host variables</p>
</li>
<li>
<p>References to database objects such as columns, indexes, sequences, tables, usernames, and views</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i3861"></a>
<div id="LNPCB576" class="sect1">
<h2 class="sect1">Requirements for Dynamic SQL Statements</h2>
<p>To represent a dynamic SQL statement, a character string must contain the text of a valid DML or DDL SQL statement, but <span class="italic">not</span> contain the EXEC SQL clause, host-language delimiter or statement terminator.<a id="sthref1253"></a></p>
<p>In most cases, the character string can contain <span class="italic">dummy</span> host variables. They hold places in the SQL statement for actual host variables. Because dummy host variables are just place-holders, you do not declare them and can name them anything you like (hyphens are not allowed). For example, Oracle makes no distinction between the following two strings</p>
<pre>&#39;DELETE FROM EMP WHERE MGR = :MGRNUMBER AND JOB = :JOBTITLE&#39;
&#39;DELETE FROM EMP WHERE MGR = :M AND JOB = :J&#39;
</pre></div>
<!-- class="sect1" -->
<a id="i3866"></a>
<div id="LNPCB577" class="sect1">
<h2 class="sect1">How Dynamic SQL Statements Are Processed</h2>
<p>Typically, an application program prompts the user for the text of a SQL statement and the values of host variables used in the statement. Then Oracle <span class="italic">parses</span> the SQL statement. That is, Oracle examines the SQL statement to make sure it follows syntax rules and refers to valid database objects. Parsing also involves checking database access rights, reserving needed resources, and finding the optimal access path.<a id="sthref1254"></a></p>
<p>Next, Oracle <span class="italic">binds</span> the host variables to the SQL statement. That is, Oracle gets the addresses of the host variables so that it can read or write their values.<a id="sthref1255"></a><a id="sthref1256"></a></p>
<p>If the statement is a query, you define the SELECT variables and then Oracle FETCHes them until all rows are retrieved. The cursor is then closed.</p>
<p>Then Oracle <span class="italic">executes</span> the SQL statement. That is, Oracle does what the SQL statement requested, such as deleting rows from a table.</p>
<p>The SQL statement can be executed repeatedly using new values for the host variables.</p>
</div>
<!-- class="sect1" -->
<a id="i3877"></a>
<div id="LNPCB578" class="sect1">
<h2 class="sect1">Methods for Using Dynamic SQL</h2>
<p>This section introduces the four methods you can use to define dynamic SQL statements. It briefly describes the capabilities and limitations of each method, then offers guidelines for choosing the right method. Later sections show you how to use the methods.</p>
<p>The four methods are increasingly general. That is, Method 2 encompasses Method 1, Method 3 encompasses Methods 1 and 2, and so on. However, each method is most useful for handling a certain kind of SQL statement, as <a href="#i5308">Table 9-1</a> shows:</p>
<div id="LNPCB579" class="tblformal">
<p class="titleintable"><a id="sthref1257"></a><a id="sthref1258"></a>Table 9-1 <a id="i5308"></a><span class="bolditalic">Appropriate Method to Use</span></p>
<table class="cellalignment4971" title="Appropriate Method to Use" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t2">Method</th>
<th class="cellalignment4972" id="r1c2-t2">Kind of SQL Statement</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t2" headers="r1c1-t2">
<p>1</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c2-t2">
<p>Non-query without input host variables.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t2" headers="r1c1-t2">
<p>2</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c2-t2">
<p>Non-query with known number of input host variables.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t2" headers="r1c1-t2">
<p>3</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c2-t2">
<p>Query with known number of select-list items and input host variables.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t2" headers="r1c1-t2">
<p>4</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c2-t2">
<p>Query with unknown number of select-list items or input host variables.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The term <span class="italic">select-list item</span> includes column names and expressions.</p>
<div id="LNPCB580" class="sect2"><a id="sthref1259"></a>
<h3 class="sect2">Method 1</h3>
<p>This method lets your program accept or build a dynamic SQL statement, then immediately execute it using the EXECUTE IMMEDIATE command. The SQL statement must not be a query (SELECT statement) and must not contain any place-holders for input host variables. For example, the following host strings qualify:<a id="sthref1260"></a><a id="sthref1261"></a></p>
<pre>&#39;DELETE FROM EMP WHERE DEPTNO = 20&#39;

&#39;GRANT SELECT ON EMP TO SCOTT&#39;
</pre>
<p>With Method 1, the SQL statement is parsed every time it is executed (regardless of whether you have set HOLD_CURSOR=YES).</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB581" class="sect2"><a id="sthref1262"></a>
<h3 class="sect2">Method 2</h3>
<p>This method lets your program accept or build a dynamic SQL statement, then process it using the PREPARE and EXECUTE commands. The SQL statement must not be a query. The number of place-holders for input host variables and the datatypes of the input host variables must be known at precompile time. For example, the following host strings fall into this category:<a id="sthref1263"></a><a id="sthref1264"></a></p>
<pre>&#39;INSERT INTO EMP (ENAME, JOB) VALUES (:EMPNAME, :JOBTITLE)&#39;
&#39;DELETE FROM EMP WHERE EMPNO = :EMPNUMBER&#39;
</pre>
<p>With Method 2, the SQL statement can be parsed just once by calling PREPARE once, and executed many times with different values for the host variables. This is not true when RELEASE_CURSOR=YES is also specified, because the statement has to be prepared again before each execution.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL data definition statements such as CREATE are executed once the PREPARE is completed.<a id="sthref1265"></a></div>
</div>
<!-- class="sect2" -->
<div id="LNPCB582" class="sect2"><a id="sthref1266"></a>
<h3 class="sect2">Method 3</h3>
<p>This method lets your program accept or build a dynamic query then process it using the PREPARE command with the DECLARE, OPEN, FETCH, and CLOSE cursor commands. The number of select-list items, the number of place-holders for input host variables, and the datatypes of the input host variables must be known at precompile time. For example, the following host strings qualify:<a id="sthref1267"></a><a id="sthref1268"></a></p>
<pre>&#39;SELECT DEPTNO, MIN(SAL), MAX(SAL) FROM EMP GROUP BY DEPTNO&#39;
&#39;SELECT ENAME, EMPNO FROM EMP WHERE DEPTNO = :DEPTNUMBER&#39;
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB583" class="sect2"><a id="sthref1269"></a>
<h3 class="sect2">Method 4</h3>
<p>This method lets your program accept or build a dynamic SQL statement, then process it using descriptors (discussed in <a href="#i3705">&#34;Using Oracle Method 4&#34;</a>). The number of select-list items, the number of place-holders for input host variables, and the datatypes of the input host variables can be unknown until run time. For example, the following host strings fall into this category:<a id="sthref1270"></a></p>
<pre>&#39;INSERT INTO EMP (<span class="italic">unknown</span>) VALUES (<span class="italic">unknown</span>)&#39;

&#39;SELECT <span class="italic">unknown</span> FROM EMP WHERE DEPTNO = 20&#39;
</pre>
<p>Method 4 is required for dynamic SQL statements that contain an unknown number of select-list items or input host variables.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB584" class="sect2"><a id="sthref1271"></a>
<h3 class="sect2">Guidelines</h3>
<p>With all four methods, you must store the dynamic SQL statement in a character string, which must be a host variable or quoted literal. When you store the SQL statement in the string, omit the keywords EXEC SQL and the statement terminator.<a id="sthref1272"></a><a id="sthref1273"></a></p>
<p>With Methods 2 and 3, the number of place-holders for input host variables and the datatypes of the input host variables must be known at precompile time.</p>
<p>Each succeeding method imposes fewer constraints on your application, but is more difficult to code. As a rule, use the simplest method you can. However, if a dynamic SQL statement will be executed repeatedly by Method 1, use Method 2 instead to avoid re-parsing for each execution.</p>
<p>Method 4 provides maximum flexibility, but requires complex coding and a full understanding of dynamic SQL concepts. In general, use Method 4 only if you cannot use Methods 1, 2, or 3.</p>
<p>The decision logic in <a href="#i3709">Figure 9-1, &#34;Choosing the Right Method&#34;</a>, will help you choose the correct method.<a id="sthref1274"></a></p>
<div id="LNPCB585" class="sect3"><a id="sthref1275"></a>
<h4 class="sect3">Avoiding Common Errors</h4>
<p>If you use a character array to store the dynamic SQL statement, blank-pad the array before storing the SQL statement. That way, you clear extraneous characters. This is especially important when you reuse the array for different SQL statements. As a rule, always initialize (or re-initialize) the host string before storing the SQL statement.</p>
<p>Do not null-terminate the host string. Oracle does not recognize the null terminator as an end-of-string marker. Instead, Oracle treats it as part of the SQL statement.</p>
<p>If you use a VARCHAR variable to store the dynamic SQL statement, make sure the length of the VARCHAR is set (or reset) correctly before you execute the PREPARE or EXECUTE IMMEDIATE statement.</p>
<p>EXECUTE resets the SQLWARN warning flags in the SQLCA. So, to catch mistakes such as an unconditional update (caused by omitting a WHERE clause), check the SQLWARN flags after executing the PREPARE statement but before executing the EXECUTE statement.</p>
<p><a href="#i3709">Figure 9-1</a> shows how to choose the right method.</p>
<div id="LNPCB586" class="figure">
<p class="titleinfigure"><a id="i3709"></a>Figure 9-1 Choosing the Right Method</p>
<img width="605" height="572" src="img/pco81058.gif" alt="Choosing the Right Method"/><br/>
<a id="sthref1276" href="img_text/pco81058.htm">Description of &#34;Figure 9-1 Choosing the Right Method&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7445"></a>
<div id="LNPCB587" class="sect1">
<h2 class="sect1">Using Method 1</h2>
<p>The simplest kind of dynamic SQL statement results only in &#34;success&#34; or &#34;failure&#34; and uses no host variables. Some examples follow:</p>
<pre>&#39;DELETE FROM table_name WHERE column_name = constant&#39;
&#39;CREATE TABLE table_name ...&#39;
&#39;DROP INDEX index_name&#39;
&#39;UPDATE table_name SET column_name = constant&#39;
&#39;GRANT SELECT ON table_name TO username&#39;
</pre>
<a id="i3411"></a>
<div id="LNPCB588" class="sect2">
<h3 class="sect2">The EXECUTE IMMEDIATE Statement</h3>
<p>Method 1 parses, then immediately executes the SQL statement using the EXECUTE IMMEDIATE command. The command is followed by a character string (host variable or literal) containing the SQL statement to be executed, which cannot be a query.</p>
<p>The syntax of the EXECUTE IMMEDIATE statement follows:<a id="sthref1277"></a><a id="sthref1278"></a><a id="sthref1279"></a></p>
<pre>EXEC SQL EXECUTE IMMEDIATE { :HOST-STRING | STRING-LITERAL }END-EXEC.
</pre>
<p>In the following example, you use the host variable <span class="italic">SQL-STMT</span> to store SQL statements input by the user:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ... 
 01   SQL-STMT  PIC X(120);
      EXEC SQL END DECLARE SECTION END-EXEC.
     ...
 LOOP.
     DISPLAY &#39;Enter SQL statement: &#39; WITH NO ADVANCING.
     ACCEPT SQL-STMT END-EXEC.
* --  sql_stmt now contains the text of a SQL statement
   <span class="bold"> </span> EXEC SQL EXECUTE IMMEDIATE :SQL-STMT END-EXEC.
 NEXT.
     ...
</pre>
<p>Because EXECUTE IMMEDIATE parses the input SQL statement before every execution, Method 1 is best for statements that are executed only once. Data definition statements usually fall into this category.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB589" class="sect2"><a id="sthref1280"></a>
<h3 class="sect2">An Example</h3>
<p>The following fragment of a program prompts the user for a search condition to be used in the WHERE clause of an UPDATE statement, then executes the statement using Method 1:<a id="sthref1281"></a></p>
<pre>     ...
*    THE RELEASE_CURSOR=YES OPTION INSTRUCTS PRO*COBOL TO
*    RELEASE IMPLICIT CURSORS ASSOCIATED WITH EMBEDDED SQL
*    STATEMENTS.  THIS ENSURES THAT Oracle DOES NOT KEEP PARSE
*    LOCKS ON TABLES, SO THAT SUBSEQUENT DATA MANIPULATION
*    OPERATIONS ON THOSE TABLES DO NOT RESULT IN PARSE-LOCK
*    ERRORS.
 
     EXEC ORACLE OPTION (RELEASE_CURSOR=YES) END-EXEC.
 
*   
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01  USERNAME  PIC X(10) VALUE &#34;SCOTT&#34;.
 01  PASSWD    PIC X(10) VALUE &#34;TIGER&#34;.
 01  DYNSTMT   PIC X(80).
     EXEC SQL END DECLARE SECTION END-EXEC.
 01  UPDATESTMT PIC X(40).
 01  SEARCH-COND PIC X(40).
     ...
     DISPLAY &#34;ENTER A SEARCH CONDITION FOR STATEMENT:&#34;.
     MOVE &#34;UPDATE EMP SET COMM = 500 WHERE &#34; TO UPDATESTMT.
     DISPLAY UPDATESTMT.
     ACCEPT SEARCH-COND.
*    Concatenate SEARCH-COND to UPDATESTMT and store result 
*    in DYNSTMT.
     STRING UPDATESTMT DELIMITED BY SIZE 
         SEARCH-COND DELIMITED BY SIZE INTO DYNSTMT.
     EXEC SQL EXECUTE IMMEDIATE :DYNSTMT END-EXEC.
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3887"></a>
<div id="LNPCB590" class="sect1">
<h2 class="sect1">Sample Program 6: Dynamic SQL Method 1<a id="sthref1282"></a></h2>
<p>This program uses dynamic SQL Method 1 to create a table, insert a row, commit the insert, then drop the table.<a id="sthref1283"></a></p>
<pre>      *****************************************************************
      * Sample Program 6:  Dynamic SQL Method 1                       *
      *                                                               *
      * This program uses dynamic SQL Method 1 to create a table,     *
      * insert a row, commit the insert, then drop the table.         *
      *****************************************************************
      
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  DYNSQL1.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

      *    INCLUDE THE ORACLE COMMUNICATIONS AREA, A STRUCTURE
      *    THROUGH WHICH ORACLE MAKES ADDITIONAL RUNTIME STATUS
      *    INFORMATION AVAILABLE TO THE PROGRAM.

           EXEC SQL INCLUDE SQLCA END-EXEC.

      *    INCLUDE THE ORACLE COMMUNICATIONS AREA, A STRUCTURE
      *    THROUGH WHICH ORACLE MAKES ADDITIONAL RUNTIME STATUS
      *    INFORMATION AVAILABLE TO THE PROGRAM.

           EXEC SQL INCLUDE ORACA END-EXEC.

      *    THE OPTION ORACA=YES MUST BE SPECIFIED TO ENABLE USE OF
      *    THE ORACA.

           EXEC ORACLE OPTION (ORACA=YES) END-EXEC.

      *    THE RELEASE_CURSOR=YES OPTION INSTRUCTS PRO*COBOL TO
      *    RELEASE IMPLICIT CURSORS ASSOCIATED WITH EMBEDDED SQL
      *    STATEMENTS.  THIS ENSURES THAT ORACLE DOES NOT KEEP PARSE
      *    LOCKS ON TABLES, SO THAT SUBSEQUENT DATA MANIPULATION
      *    OPERATIONS ON THOSE TABLES DO NOT RESULT IN PARSE-LOCK
      *    ERRORS.

           EXEC ORACLE OPTION (RELEASE_CURSOR=YES) END-EXEC.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME  PIC X(10) VALUE &#34;SCOTT&#34;.
       01  PASSWD    PIC X(10) VALUE &#34;TIGER&#34;.
       01  DYNSTMT   PIC X(80) VARYING.
           EXEC SQL END DECLARE SECTION END-EXEC.

      *    DECLARE VARIABLES NEEDED TO DISPLAY COMPUTATIONALS.
       01  ORASLNRD  PIC 9(9).

       PROCEDURE DIVISION.

       MAIN.

      *    BRANCH TO PARAGRAPH SQLERROR IF AN ORACLE ERROR OCCURS.
           EXEC SQL WHENEVER SQLERROR GOTO SQLERROR END-EXEC.

      *    SAVE TEXT OF CURRENT SQL STATEMENT IN THE ORACA IF AN ERROR
      *    OCCURS.
           MOVE 1 TO ORASTXTF.

      *    CONNECT TO ORACLE.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER:  &#34; WITH NO ADVANCING.
           DISPLAY USERNAME.
           DISPLAY &#34; &#34;.

      *    EXECUTE A STRING LITERAL TO CREATE THE TABLE.  HERE, YOU
      *    GENERALLY USE A STRING VARIABLE INSTEAD OF A LITERAL, AS IS
      *    DONE LATER IN THIS PROGRAM.  BUT, YOU CAN USE A LITERAL IF
      *    YOU WISH.
           DISPLAY &#34;CREATE TABLE DYN1 (COL1 CHAR(4))&#34;.
           DISPLAY &#34; &#34;.
           EXEC SQL EXECUTE IMMEDIATE
               &#34;CREATE TABLE DYN1 (COL1 CHAR(4))&#34;
           END-EXEC.

      *    ASSIGN A SQL STATEMENT TO THE VARYING STRING DYNSTMT.
      *    SET THE -LEN PART TO THE LENGTH OF THE -ARR PART.
           MOVE &#34;INSERT INTO DYN1 VALUES (&#39;TEST&#39;)&#34; TO DYNSTMT-ARR. 
           MOVE 36 TO DYNSTMT-LEN.
           DISPLAY DYNSTMT-ARR.
           DISPLAY &#34; &#34;.

      *    EXECUTE DYNSTMT TO INSERT A ROW.  THE SQL STATEMENT IS A
      *    STRING VARIABLE WHOSE CONTENTS THE PROGRAM MAY DETERMINE
      *    AT RUN TIME.
           EXEC SQL EXECUTE IMMEDIATE :DYNSTMT END-EXEC.

      *    COMMIT THE INSERT.
           EXEC SQL COMMIT WORK END-EXEC.

      *    CHANGE DYNSTMT AND EXECUTE IT TO DROP THE TABLE.
           MOVE &#34;DROP TABLE DYN1&#34; TO DYNSTMT-ARR.
           MOVE 19 TO DYNSTMT-LEN.
           DISPLAY DYNSTMT-ARR.
           DISPLAY &#34; &#34;.
           EXEC SQL EXECUTE IMMEDIATE :DYNSTMT END-EXEC.

      *    COMMIT ANY PENDING CHANGES AND DISCONNECT FROM ORACLE.
           EXEC SQL COMMIT RELEASE END-EXEC.
           DISPLAY &#34;HAVE A GOOD DAY!&#34;.
           DISPLAY &#34; &#34;.
           STOP RUN.

       SQLERROR.

      *    ORACLE ERROR HANDLER.  PRINT DIAGNOSTIC TEXT CONTAINING
      *    ERROR MESSAGE, CURRENT SQL STATEMENT, AND LOCATION OF ERROR.
           DISPLAY SQLERRMC.
           DISPLAY &#34;IN &#34;, ORASTXTC.
           MOVE ORASLNR TO ORASLNRD.
           DISPLAY &#34;ON LINE &#34;, ORASLNRD, &#34; OF &#34;, ORASFNMC.

      *    DISABLE ORACLE ERROR CHECKING TO AVOID AN INFINITE LOOP
      *    SHOULD ANOTHER ERROR OCCUR WITHIN THIS PARAGRAPH.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.

      *    ROLL BACK ANY PENDING CHANGES AND DISCONNECT FROM ORACLE.
           EXEC SQL ROLLBACK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="sect1" -->
<a id="i3892"></a>
<div id="LNPCB591" class="sect1">
<h2 class="sect1">Using Method 2</h2>
<p>What Method 1 does in one step, Method 2 does in two. The dynamic SQL statement, which cannot be a query, is first prepared (named and parsed), then executed.</p>
<p>With Method 2, the SQL statement can contain place-holders for input host variables and indicator variables. You can PREPARE the SQL statement once, then EXECUTE it repeatedly using different values of the host variables. Also, if you have not specified MODE=ANSI, you need <span class="italic">not</span> re-prepare the SQL statement after a COMMIT or ROLLBACK (unless you log off and reconnect).<a id="sthref1284"></a><a id="sthref1285"></a><a id="sthref1286"></a><a id="sthref1287"></a><a id="sthref1288"></a></p>
<p>The syntax of the PREPARE statement follows:</p>
<pre>     EXEC SQL PREPARE S<span class="italic">TATEMENT-NAME</span>
         FROM { :<span class="italic">HOST-STRING</span> | <span class="italic">STRING-LITERAL</span> }
     END-EXEC.
</pre>
<p>PREPARE parses the SQL statement and gives it a name.</p>
<p><span class="italic">STATEMENT-NAME</span> is an identifier used by the precompiler, <span class="italic">not</span> a host or program variable, and should not be declared in a COBOL statement. It simply designates the prepared statement you want to EXECUTE.</p>
<p>The syntax of the EXECUTE statement is</p>
<pre>     EXEC SQL
         EXECUTE <span class="italic">STATEMENT-NAME</span> [USING H<span class="italic">OST-VARIABLE-LIST</span>]
     END-EXEC.
</pre>
<p>where <span class="italic">HOST-VARIABLE-LIST</span> stands for the following syntax:</p>
<pre>:<span class="italic">HOST-VAR1</span>[:<span class="italic">INDICATOR1</span>] [, <span class="italic">HOST-VAR2</span>[:<span class="italic">INDICATOR2</span>], ...]
</pre>
<p>EXECUTE executes the parsed SQL statement, using the values supplied for each input host variable. In the following example, the input SQL statement contains the place-holder <span class="italic">n</span>:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
     ... 
 01  EMP-NUMBER   PIC S9(4) COMP VALUE ZERO.
     ...
 01  DELETE-STMT   PIC X(120) VALUE SPACES.
     ...
     EXEC SQL END DECLARE SECTION END-EXEC. 
 01  WHERE-STMT    PIC X(40).
 01  SEARCH-COND   PIC X(40). 
     ... 
     MOVE &#39;DELETE FROM EMP WHERE EMPNO = :N AND &#39; TO WHERE-STMT.
     DISPLAY &#39;Complete this statement&#39;s search condition:&#39;.
     DISPLAY WHERE-STMT.
     ACCEPT SEARCH-COND.
*    Concatenate SEARCH-COND to WHERE-STMT and store in DELETE-STMT
     STRING WHERE-STMT DELIMITED BY SIZE
         SEARCH-COND DELIMITED BY SIZE INTO
         DELETE-STMT. 
     EXEC SQL PREPARE SQLSTMT FROM :DELETE-STMT END-EXEC.
 LOOP.
     DISPLAY &#39;Enter employee number: &#39; WITH NO ADVANCING.
     ACCEPT EMP-NUMBER.
     IF EMP-NUMBER = 0
        GO TO NEXT.
     EXEC SQL EXECUTE SQLSTMT USING :EMP-NUMBER END-EXEC.
 NEXT.
</pre>
<p>With Method 2, you must know the datatypes of input host variables at precompile time. In the last example, <span class="italic">EMP-NUMBER</span> was declared as type PIC S9(4) COMP. It could also have been declared as type PIC X(4) or COMP-1, because Oracle supports all these datatype conversions to the NUMBER internal datatype.</p>
<div id="LNPCB592" class="sect2"><a id="sthref1289"></a>
<h3 class="sect2">The USING Clause</h3>
<p>When the SQL statement EXECUTE is completed, input host variables in the USING clause replace corresponding place-holders in the prepared dynamic SQL statement.<a id="sthref1290"></a></p>
<p>Every place-holder in the dynamic SQL statement after PREPARE must correspond to a host variable in the USING clause. So, if the same place-holder appears two or more times in the statement after PREPARE, each appearance must correspond to a host variable in the USING clause. If one of the host variables in the USING clause is an array, all must be arrays. Otherwise, only one record is then processed.</p>
<p>The names of the place-holders need not match the names of the host variables. However, the order of the place-holders in the dynamic SQL statement after PREPARE must match the order of corresponding host variables in the USING clause.</p>
<p>To specify NULLs, you can associate indicator variables with host variables in the USING clause. For more information, see <a href="pco05sql.htm#i3617">&#34;Using Indicator Variables&#34;</a>.<a id="sthref1291"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3897"></a>
<div id="LNPCB593" class="sect1">
<h2 class="sect1">Sample Program 7: Dynamic SQL Method 2<a id="sthref1292"></a></h2>
<p>This program uses dynamic SQL Method 2 to insert two rows into the EMP table and then delete them.<a id="sthref1293"></a></p>
<pre>      *****************************************************************
      * Sample Program 7:  Dynamic SQL Method 2                       *
      *                                                               *
      * This program uses dynamic SQL Method 2 to insert two rows     *
      * into the EMP table, then delete them.                         *
      *****************************************************************
      
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  DYNSQL2.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

      *    INCLUDE THE SQL COMMUNICATIONS AREA, A STRUCTURE THROUGH
      *    WHICH ORACLE MAKES RUNTIME STATUS INFORMATION (SUCH AS ERROR
      *    CODES, WARNING FLAGS, AND DIAGNOSTIC TEXT) AVAILABLE TO THE
      *    PROGRAM.
           EXEC SQL INCLUDE SQLCA END-EXEC.

      *    INCLUDE THE ORACLE COMMUNICATIONS AREA, A STRUCTURE THROUGH
      *    WHICH ORACLE MAKES ADDITIONAL RUNTIME STATUS INFORMATION
      *    AVAILABLE TO THE PROGRAM.
           EXEC SQL INCLUDE ORACA END-EXEC.

      *    THE OPTION ORACA=YES MUST BE SPECIFIED TO ENABLE USE OF
      *    THE ORACA.
           EXEC ORACLE OPTION (ORACA=YES) END-EXEC.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME  PIC X(10) VALUE &#34;SCOTT&#34;.
       01  PASSWD    PIC X(10) VALUE &#34;TIGER&#34;.
       01  DYNSTMT   PIC X(80) VARYING.
       01  EMPNO     PIC S9(4) COMPUTATIONAL VALUE 1234.
       01  DEPTNO1   PIC S9(4) COMPUTATIONAL VALUE 10.
       01  DEPTNO2   PIC S9(4) COMPUTATIONAL VALUE 20.
           EXEC SQL END DECLARE SECTION END-EXEC.

      *    DECLARE VARIABLES NEEDED TO DISPLAY COMPUTATIONALS.
       01  EMPNOD    PIC 9(4).
       01  DEPTNO1D  PIC 9(2).
       01  DEPTNO2D  PIC 9(2).
       01  ORASLNRD  PIC 9(9).

       PROCEDURE DIVISION.
       MAIN.

      *    BRANCH TO PARAGRAPH SQLERROR IF AN ORACLE ERROR OCCURS.
           EXEC SQL WHENEVER SQLERROR GOTO SQLERROR END-EXEC.

      *    SAVE TEXT OF CURRENT SQL STATEMENT IN THE ORACA IF AN ERROR
      *    OCCURS.
           MOVE 1 TO ORASTXTF.

      *    CONNECT TO ORACLE.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE.&#34;.
           DISPLAY &#34; &#34;.

      *    ASSIGN A SQL STATEMENT TO THE VARYING STRING DYNSTMT.  BOTH
      *    THE ARRAY AND THE LENGTH PARTS MUST BE SET PROPERLY.  NOTE
      *    THAT THE STATEMENT CONTAINS TWO HOST VARIABLE PLACEHOLDERS,
      *    V1 AND V2, FOR WHICH ACTUAL INPUT HOST VARIABLES MUST BE
      *    SUPPLIED AT EXECUTE TIME.
           MOVE &#34;INSERT INTO EMP (EMPNO, DEPTNO) VALUES (:V1, :V2)&#34;
               TO DYNSTMT-ARR.
           MOVE 49 TO DYNSTMT-LEN.

      *    DISPLAY THE SQL STATEMENT AND ITS CURRENT INPUT HOST
      *    VARIABLES.
           DISPLAY DYNSTMT-ARR.
           MOVE EMPNO TO EMPNOD.
           MOVE DEPTNO1 TO DEPTNO1D.
           DISPLAY &#34;    V1 = &#34;, EMPNOD, &#34;    V2 = &#34;, DEPTNO1D.

      *    THE PREPARE STATEMENT ASSOCIATES A STATEMENT NAME WITH A
      *    STRING CONTAINING A SQL STATEMENT.  THE STATEMENT NAME IS
      *    A SQL IDENTIFIER, NOT A HOST VARIABLE, AND THEREFORE DOES
      *    NOT APPEAR IN THE DECLARE SECTION.

      *    A SINGLE STATEMENT NAME MAY BE PREPARED MORE THAN ONCE,
      *    OPTIONALLY FROM A DIFFERENT STRING VARIABLE.
           EXEC SQL PREPARE S FROM :DYNSTMT END-EXEC.

      *    THE EXECUTE STATEMENT EXECUTES A PREPARED SQL STATEMENT
      *    USING THE SPECIFIED INPUT HOST VARIABLES, WHICH ARE
      *    SUBSTITUTED POSITIONALLY FOR PLACEHOLDERS IN THE PREPARED
      *    STATEMENT.  FOR EACH OCCURRENCE OF A PLACEHOLDER IN THE
      *    STATEMENT THERE MUST BE A VARIABLE IN THE USING CLAUSE.
      *    THAT IS, IF A PLACEHOLDER OCCURS MULTIPLE TIMES IN THE
      *    STATEMENT, THE CORRESPONDING VARIABLE MUST APPEAR
      *    MULTIPLE TIMES IN THE USING CLAUSE.  THE USING CLAUSE MAY 
      *    BE OMITTED ONLY IF THE STATEMENT CONTAINS NO PLACEHOLDERS.
      *    A SINGLE PREPARED STATEMENT MAY BE EXECUTED MORE THAN ONCE,
      *    OPTIONALLY USING DIFFERENT INPUT HOST VARIABLES.
           EXEC SQL EXECUTE S USING :EMPNO, :DEPTNO1 END-EXEC.

      *    INCREMENT EMPNO AND DISPLAY NEW INPUT HOST VARIABLES.
           ADD 1 TO EMPNO.
           MOVE EMPNO TO EMPNOD.
           MOVE DEPTNO2 TO DEPTNO2D.
           DISPLAY &#34;    V1 = &#34;, EMPNOD, &#34;    V2 = &#34;, DEPTNO2D.

      *    REEXECUTE S TO INSERT THE NEW VALUE OF EMPNO AND A
      *    DIFFERENT INPUT HOST VARIABLE, DEPTNO2.  A REPREPARE IS NOT
      *    NECESSARY.
           EXEC SQL EXECUTE S USING :EMPNO, :DEPTNO2 END-EXEC.

      *    ASSIGN A NEW VALUE TO DYNSTMT.
           MOVE &#34;DELETE FROM EMP WHERE DEPTNO = :V1 OR DEPTNO = :V2&#34;
               TO DYNSTMT-ARR.
           MOVE 50 TO DYNSTMT-LEN.

      *    DISPLAY THE NEW SQL STATEMENT AND ITS CURRENT INPUT HOST
      *    VARIABLES.
           DISPLAY DYNSTMT-ARR.
           DISPLAY &#34;    V1 = &#34;, DEPTNO1D, &#34;      V2 = &#34;, DEPTNO2D.

      *    REPREPARE S FROM THE NEW DYNSTMT. 
           EXEC SQL PREPARE S FROM :DYNSTMT END-EXEC.

      *    EXECUTE THE NEW S TO DELETE THE TWO ROWS PREVIOUSLY
      *    INSERTED.
           EXEC SQL EXECUTE S USING :DEPTNO1, :DEPTNO2 END-EXEC.

      *    ROLLBACK ANY PENDING CHANGES AND DISCONNECT FROM ORACLE.
           EXEC SQL ROLLBACK RELEASE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY!&#34;.
           DISPLAY &#34; &#34;.
           STOP RUN.

        SQLERROR.
      *    ORACLE ERROR HANDLER.  PRINT DIAGNOSTIC TEXT CONTAINING
      *    ERROR MESSAGE, CURRENT SQL STATEMENT, AND LOCATION OF ERROR.
           DISPLAY SQLERRMC.
           DISPLAY &#34;IN &#34;, ORASTXTC.
           MOVE ORASLNR TO ORASLNRD.
           DISPLAY &#34;ON LINE &#34;, ORASLNRD, &#34; OF &#34;, ORASFNMC.

      *    DISABLE ORACLE ERROR CHECKING TO AVOID AN INFINITE LOOP
      *    SHOULD ANOTHER ERROR OCCUR WITHIN THIS PARAGRAPH.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.

      *    ROLL BACK ANY PENDING CHANGES AND DISCONNECT FROM ORACLE.
           EXEC SQL ROLLBACK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="sect1" -->
<a id="i6266"></a>
<div id="LNPCB594" class="sect1">
<h2 class="sect1">Using Method 3</h2>
<p>Method 3 is similar to Method 2 but combines the PREPARE statement with the statements needed to define and manipulate a cursor. This allows your program to accept and process queries. In fact, if the dynamic SQL statement is a query, you <span class="italic">must</span> use Method 3 or 4.<a id="sthref1294"></a></p>
<p>For Method 3, the number of columns in the query select list and the number of place-holders for input host variables must be known at precompile time. However, the names of database objects such as tables and columns need not be specified until run time (they cannot duplicate the names of host variables). Clauses that limit, group, and sort query results (such as WHERE, GROUP BY, and ORDER BY) can also be specified at run time.</p>
<p>With Method 3, you use the following sequence of embedded SQL statements:</p>
<pre>     EXEC SQL 
         PREPARE <span class="italic">STATEMENTNAME</span> FROM { :<span class="italic">HOST-STRING</span> | <span class="italic">STRING-LITERAL </span>}
     END-EXEC. 
     EXEC SQL DECLARE <span class="italic">CURSORNAME</span> CURSOR FOR <span class="italic">STATEMENTNAME</span> END-EXEC.
     EXEC SQL OPEN <span class="italic">CURSORNAME</span> [USING <span class="italic">HOST-VARIABLE-LIST</span>] END-EXEC.
     EXEC SQL FETCH <span class="italic">CURSORNAME</span> INTO <span class="italic">HOST-VARIABLE-LIST</span> END-EXEC.
     EXEC SQL CLOSE <span class="italic">CURSORNAME</span> END-EXEC.
</pre>
<p>Now let us look at what each statement does.</p>
<div id="LNPCB595" class="sect2"><a id="sthref1295"></a>
<h3 class="sect2">PREPARE</h3>
<p>The PREPARE statement parses the dynamic SQL statement and gives it a name. In the following example, PREPARE parses the query stored in the character string <span class="italic">SELECT-STMT</span> and gives it the name <span class="italic">SQLSTMT</span>:<a id="sthref1296"></a><a id="sthref1297"></a></p>
<pre>     MOVE &#39;SELECT MGR, JOB FROM EMP WHERE SAL &lt; :SALARY&#39;
         TO SELECT-STMT.
     EXEC SQL PREPARE SQLSTMT FROM :SELECT-STMT END-EXEC.
</pre>
<p>Commonly, the query WHERE clause is input from a terminal at run time or is generated by the application.</p>
<p>The identifier <span class="italic">SQLSTMT</span> is <span class="italic">not</span> a host or program variable, but must be unique. It designates a particular dynamic SQL statement.</p>
<p>The following statement is correct also:</p>
<pre>     EXEC SQL 
         PREPARE SQLSTMT FROM &#39;SELECT MGR, JOB FROM EMP WHERE SAL &lt; :SALARY&#39; 
     END-EXEC.
</pre>
<p>The following PREPARE statement, which uses the &#39;%&#39; wildcard, is also correct:</p>
<pre>     MOVE &#34;SELECT ENAME FROM TEST WHERE ENAME LIKE &#39;SMIT%&#39;&#34; TO MY-STMT.
     EXEC SQL 
         PREPARE S FROM MY-STMT
     END-EXEC.
</pre></div>
<!-- class="sect2" -->
<a id="i3409"></a>
<div id="LNPCB596" class="sect2">
<h3 class="sect2">DECLARE</h3>
<p>The DECLARE statement defines a cursor by giving it a name and associating it with a specific query. The cursor declaration is local to its precompilation unit. Continuing our example, DECLARE defines a cursor named <span class="italic">EMPCURSOR</span> and associates it with <span class="italic">SQLSTMT</span>, as follows:<a id="sthref1298"></a><a id="sthref1299"></a></p>
<pre>     EXEC SQL DECLARE EMPCURSOR CURSOR FOR SQLSTMT END-EXEC.
</pre>
<p>The identifiers <span class="italic">SQLSTMT</span> and <span class="italic">EMPCURSOR</span> are <span class="italic">not</span> host or program variables, but must be unique. If you declare two cursors using the same statement name, Pro*COBOL considers the two cursor names synonymous. For example, if you execute the statements</p>
<pre>     EXEC SQL PREPARE SQLSTMT FROM :SELECT-STMT END-EXEC.
     EXEC SQL DECLARE EMPCURSOR FOR SQLSTMT END-EXEC.
     EXEC SQL PREPARE SQLSTMT FROM :DELETE-STMT END-EXEC.
     EXEC SQL DECLARE DEPCURSOR FOR SQLSTMT END-EXEC.
</pre>
<p>when you OPEN <span class="italic">EMPCURSOR</span>, you will process the dynamic SQL statement stored in <span class="italic">DELETE-STMT</span>, not the one stored in <span class="italic">SELECT-STMT.</span></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB597" class="sect2"><a id="sthref1300"></a>
<h3 class="sect2">OPEN</h3>
<p>The OPEN statement allocates a cursor, binds input host variables, and executes the query, identifying its active set. OPEN also positions the cursor on the first row in the active set and zeroes the rows-processed count kept by the third element of SQLERRD in the SQLCA. Input host variables in the USING clause replace corresponding place-holders in the PREPAREd dynamic SQL statement.<a id="sthref1301"></a><a id="sthref1302"></a></p>
<p>In our example, OPEN allocates <span class="italic">EMPCURSOR</span> and assigns the host variable <span class="italic">SALARY</span> to the WHERE clause, as follows:</p>
<pre>     EXEC SQL OPEN EMPCURSOR USING :SALARY END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB598" class="sect2"><a id="sthref1303"></a>
<h3 class="sect2">FETCH</h3>
<p>The FETCH statement returns a row from the active set, assigns column values in the select list to corresponding host variables in the INTO clause, and advances the cursor to the next row. When no more rows are found, FETCH returns the &#34;no data found&#34; error code to SQLCODE in the SQLCA.<a id="sthref1304"></a><a id="sthref1305"></a></p>
<p>In our example, FETCH returns a row from the active set and assigns the values of columns MGR and JOB to host variables <span class="italic">MGR-NUMBER</span> and <span class="italic">JOB-TITLE</span>, as follows:</p>
<pre>     EXEC SQL FETCH EMPCURSOR INTO :MGR-NUMBER,:JOB-TITLE END-EXEC.
</pre>
<p>Host tables can be used with Method 3.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB599" class="sect2"><a id="sthref1306"></a>
<h3 class="sect2">CLOSE</h3>
<p>The CLOSE statement disables the cursor. Once you CLOSE a cursor, you can no longer FETCH from it. In our example, the CLOSE statement disables <span class="italic">EMPCURSOR</span>, as follows:</p>
<pre>     EXEC SQL CLOSE EMPCURSOR END-EXEC.
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3911"></a>
<div id="LNPCB600" class="sect1">
<h2 class="sect1">Sample Program 8: Dynamic SQL Method 3<a id="sthref1307"></a></h2>
<p>This program uses dynamic SQL Method 3 to retrieve the names of all employees in a given department from the EMP table.<a id="sthref1308"></a></p>
<pre>      *****************************************************************
      * Sample Program 8:  Dynamic SQL Method 3                       *
      *                                                               *
      * This program uses dynamic SQL Method 3 to retrieve the names  *
      * of all employees in a given department from the EMP table.    *
      *****************************************************************
      
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  DYNSQL3.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

      *    INCLUDE THE SQL COMMUNICATIONS AREA, A STRUCTURE THROUGH
      *    WHICH ORACLE MAKES RUNTIME STATUS INFORMATION (SUCH AS ERROR
      *    CODES, WARNING FLAGS, AND DIAGNOSTIC TEXT) AVAILABLE TO THE
      *    PROGRAM.
           EXEC SQL INCLUDE SQLCA END-EXEC.

      *    INCLUDE THE ORACLE COMMUNICATIONS AREA, A STRUCTURE THROUGH
      *    WHICH ORACLE MAKES ADDITIONAL RUNTIME STATUS INFORMATION
      *    AVAILABLE TO THE PROGRAM.
           EXEC SQL INCLUDE ORACA END-EXEC.

      *    THE ORACA=YES OPTION MUST BE SPECIFIED TO ENABLE USE OF
      *    THE ORACA.
           EXEC ORACLE OPTION (ORACA=YES) END-EXEC.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME  PIC X(10) VALUE &#34;SCOTT&#34;.
       01  PASSWD    PIC X(10) VALUE &#34;TIGER&#34;.
       01  DYNSTMT   PIC X(80) VARYING.
       01  ENAME     PIC X(10).
       01  DEPTNO    PIC S9999 COMPUTATIONAL VALUE 10.
           EXEC SQL END DECLARE SECTION END-EXEC.

      *    DECLARE VARIABLES NEEDED TO DISPLAY COMPUTATIONALS.
       01  DEPTNOD   PIC 9(2).
       01  ENAMED    PIC X(10).
       01  SQLERRD3  PIC 9(2).
       01  ORASLNRD  PIC 9(4).

       PROCEDURE DIVISION.
       MAIN.

      *    BRANCH TO PARAGRAPH SQLERROR IF AN ORACLE ERROR OCCURS.
           EXEC SQL WHENEVER SQLERROR GO TO SQLERROR END-EXEC.

      *    SAVE TEXT OF CURRENT SQL STATEMENT IN THE ORACA IF AN ERROR
      *    OCCURS.
           MOVE 1 TO ORASTXTF.

      *    CONNECT TO ORACLE.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE.&#34;.
           DISPLAY &#34; &#34;.

      *    ASSIGN A SQL QUERY TO THE VARYING STRING DYNSTMT.  BOTH THE
      *    ARRAY AND THE LENGTH PARTS MUST BE SET PROPERLY.  NOTE THAT
      *    THE STATEMENT CONTAINS ONE HOST VARIABLE PLACEHOLDER, V1,
      *    FOR WHICH AN ACTUAL INPUT HOST VARIABLE MUST BE SUPPLIED
      *    AT OPEN TIME.
           MOVE &#34;SELECT ENAME FROM EMP WHERE DEPTNO = :V1&#34;
               TO DYNSTMT-ARR.
           MOVE 40 TO DYNSTMT-LEN.

      *    DISPLAY THE SQL STATEMENT AND ITS CURRENT INPUT HOST
      *    VARIABLE.
           DISPLAY DYNSTMT-ARR.
           MOVE DEPTNO TO DEPTNOD.
           DISPLAY &#34;    V1 = &#34;, DEPTNOD.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;EMPLOYEE&#34;.
           DISPLAY &#34;--------&#34;.

      *    THE PREPARE STATEMENT ASSOCIATES A STATEMENT NAME WITH A
      *    STRING CONTAINING A SELECT STATEMENT.  THE STATEMENT NAME,
      *    WHICH MUST BE UNIQUE, IS A SQL IDENTIFIER, NOT A HOST
      *    VARIABLE, AND SO DOES NOT APPEAR IN THE DECLARE SECTION.
           EXEC SQL PREPARE S FROM :DYNSTMT END-EXEC.

      *    THE DECLARE STATEMENT ASSOCIATES A CURSOR WITH A PREPARED
      *    STATEMENT.  THE CURSOR NAME, LIKE THE STATEMENT NAME, DOES
      *    NOT APPEAR IN THE DECLARE SECTION.
           EXEC SQL DECLARE C CURSOR FOR S END-EXEC.

      *    THE OPEN STATEMENT EVALUATES THE ACTIVE SET OF THE PREPARED
      *    QUERY USING THE SPECIFIED INPUT HOST VARIABLES, WHICH ARE
      *    SUBSTITUTED POSITIONALLY FOR PLACEHOLDERS IN THE PREPARED
      *    QUERY.  FOR EACH OCCURRENCE OF A PLACEHOLDER IN THE
      *    STATEMENT THERE MUST BE A VARIABLE IN THE USING CLAUSE.
      *    THAT IS, IF A PLACEHOLDER OCCURS MULTIPLE TIMES IN THE
      *    STATEMENT, THE CORRESPONDING VARIABLE MUST APPEAR MULTIPLE
      *    TIMES IN THE USING CLAUSE.  THE USING CLAUSE MAY BE
      *    OMITTED ONLY IF THE STATEMENT CONTAINS NO PLACEHOLDERS.
      *    OPEN PLACES THE CURSOR AT THE FIRST ROW OF THE ACTIVE SET
      *    IN PREPARATION FOR A FETCH.

      *    A SINGLE DECLARED CURSOR MAY BE OPENED MORE THAN ONCE,
      *    OPTIONALLY USING DIFFERENT INPUT HOST VARIABLES.
           EXEC SQL OPEN C USING :DEPTNO END-EXEC.

      *    BRANCH TO PARAGRAPH NOTFOUND WHEN ALL ROWS HAVE BEEN
      *    RETRIEVED.
           EXEC SQL WHENEVER NOT FOUND GO TO NOTFOUND END-EXEC.

       GETROWS.

      *    THE FETCH STATEMENT PLACES THE SELECT LIST OF THE CURRENT
      *    ROW INTO THE VARIABLES SPECIFIED BY THE INTO CLAUSE, THEN
      *    ADVANCES THE CURSOR TO THE NEXT ROW.  IF THERE ARE MORE
      *    SELECT-LIST FIELDS THAN OUTPUT HOST VARIABLES, THE EXTRA
      *    FIELDS ARE NOT RETURNED.  SPECIFYING MORE OUTPUT HOST
      *    VARIABLES THAN SELECT-LIST FIELDS RESULTS IN AN ORACLE ERROR.
           EXEC SQL FETCH C INTO :ENAME END-EXEC.
           MOVE ENAME TO ENAMED.
           DISPLAY ENAMED.

      *    LOOP UNTIL NOT FOUND CONDITION IS DETECTED.
           GO TO GETROWS.

       NOTFOUND.
           MOVE SQLERRD(3) TO SQLERRD3.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;QUERY RETURNED &#34;, SQLERRD3, &#34; ROW(S).&#34;.

      *    THE CLOSE STATEMENT RELEASES RESOURCES ASSOCIATED WITH THE
      *    CURSOR.
           EXEC SQL CLOSE C END-EXEC.

      *    COMMIT ANY PENDING CHANGES AND DISCONNECT FROM ORACLE.
           EXEC SQL COMMIT RELEASE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY!&#34;.
           DISPLAY &#34; &#34;.
           STOP RUN.

       SQLERROR.

      *    ORACLE ERROR HANDLER.  PRINT DIAGNOSTIC TEXT CONTAINING
      *    ERROR MESSAGE, CURRENT SQL STATEMENT, AND LOCATION OF ERROR.
           DISPLAY SQLERRMC.
           DISPLAY &#34;IN &#34;, ORASTXTC.
           MOVE ORASLNR TO ORASLNRD.
           DISPLAY &#34;ON LINE &#34;, ORASLNRD, &#34; OF &#34;, ORASFNMC.

      *    DISABLE ORACLE ERROR CHECKING TO AVOID AN INFINITE LOOP
      *    SHOULD ANOTHER ERROR OCCUR WITHIN THIS PARAGRAPH.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.

      *    RELEASE RESOURCES ASSOCIATED WITH THE CURSOR.
           EXEC SQL CLOSE C END-EXEC.

      *    ROLL BACK ANY PENDING CHANGES AND DISCONNECT FROM ORACLE.
           EXEC SQL ROLLBACK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="sect1" -->
<a id="i3705"></a>
<div id="LNPCB601" class="sect1">
<h2 class="sect1">Using Oracle Method 4</h2>
<p>This section gives only an overview. For details, see <a href="pco11ody.htm#i9695">Chapter 11, &#34;Oracle Dynamic SQL: Method 4&#34;</a>.</p>
<p>LOBs are not supported in Oracle Method 4. Use ANSI dynamic SQL for LOB applications and all other new applications.</p>
<p>There is a kind of dynamic SQL statement that your program cannot process using Method 3. When the number of select-list items or place-holders for input host variables is unknown until run time, your program must use a descriptor. A <span class="italic">descriptor</span> is an area of memory used by your program and Oracle to hold a complete description of the variables in a dynamic SQL statement.<a id="sthref1309"></a><a id="sthref1310"></a></p>
<p>Recall that for a multi-row query, you FETCH selected column values INTO a list of declared output host variables. If the select list is unknown, the host-variable list cannot be established at precompile time by the INTO clause. For example, you know the following query returns two column values:</p>
<pre>     EXEC SQL
         SELECT ENAME, EMPNO FROM EMP WHERE DEPTNO = :DEPT-NUMBER
     END-EXEC.
</pre>
<p>However, if you let the user define the select list, you might not know how many column values the query will return.</p>
<div id="LNPCB602" class="sect2"><a id="sthref1311"></a>
<h3 class="sect2">Need for the SQLDA</h3>
<p>To process this kind of dynamic query, your program must issue the DESCRIBE SELECT LIST command and declare a data structure called the SQL Descriptor Area (SQLDA). Because it holds descriptions of columns in the query select list, this structure is also called a <span class="italic">select descriptor</span>.<a id="sthref1312"></a><a id="sthref1313"></a><a id="sthref1314"></a><a id="sthref1315"></a><a id="sthref1316"></a></p>
<p>Likewise, if a dynamic SQL statement contains an unknown number of place-holders for input host variables, the host-variable list cannot be established at precompile time by the USING clause.</p>
<p>To process the dynamic SQL statement, your program must issue the DESCRIBE BIND VARIABLES command and declare another kind of SQLDA called a <span class="italic">bind descriptor</span> to hold descriptions of the place-holders for the input host variables. (Input host variables are also called <span class="italic">bind variables</span>.)<a id="sthref1317"></a></p>
<p>If your program has more than one active SQL statement (it might have used OPEN for two or more cursors, for example), each statement must have its own SQLDAs statement. However, non-concurrent cursors can reuse SQLDAs. There is no set limit on the number of SQLDAs in a program.</p>
</div>
<!-- class="sect2" -->
<a id="i3410"></a>
<div id="LNPCB603" class="sect2">
<h3 class="sect2">The DESCRIBE Statement</h3>
<p>DESCRIBE initializes a descriptor to hold descriptions of select-list items or input host variables.</p>
<p>If you supply a select descriptor, the DESCRIBE SELECT LIST statement examines each select-list item in a prepared dynamic query to determine its name, datatype, constraints, length, scale, and precision. It then stores this information in the select descriptor.<a id="sthref1318"></a></p>
<p>If you supply a bind descriptor, the DESCRIBE BIND VARIABLES statement examines each place-holder in a prepared dynamic SQL statement to determine its name, length, and the datatype of its associated input host variable. It then stores this information in the bind descriptor for your use. For example, you might use place-holder names to prompt the user for the values of input host variables.<a id="sthref1319"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB604" class="sect2"><a id="sthref1320"></a>
<h3 class="sect2">SQLDA Contents</h3>
<p>A SQLDA is a host-program data structure that holds descriptions of select-list items or input host variables.<a id="sthref1321"></a></p>
<p>Though SQLDAs differ among host languages, a generic select SQLDA contains the following information about a query select list:<a id="sthref1322"></a><a id="sthref1323"></a></p>
<ul>
<li>
<p>Maximum number of columns that can be DESCRIBEd</p>
</li>
<li>
<p>Actual number of columns found by DESCRIBE</p>
</li>
<li>
<p>Addresses of buffers to store column values</p>
</li>
<li>
<p>Lengths of column values</p>
</li>
<li>
<p>Datatypes of column values</p>
</li>
<li>
<p>Addresses of indicator-variable values</p>
</li>
<li>
<p>Addresses of buffers to store column names</p>
</li>
<li>
<p>Sizes of buffers to store column names</p>
</li>
<li>
<p>Current lengths of column names</p>
</li>
</ul>
<p>A generic bind SQLDA contains the following information about the input host variables in a SQL statement:</p>
<ul>
<li>
<p>Maximum number of place-holders that can be DESCRIBEd</p>
</li>
<li>
<p>Actual number of place-holders found by DESCRIBE</p>
</li>
<li>
<p>Addresses of input host variables</p>
</li>
<li>
<p>Lengths of input host variables</p>
</li>
<li>
<p>Datatypes of input host variables</p>
</li>
<li>
<p>Addresses of indicator variables</p>
</li>
<li>
<p>Addresses of buffers to store place-holder names</p>
</li>
<li>
<p>Sizes of buffers to store place-holder names</p>
</li>
<li>
<p>Current lengths of place-holder names</p>
</li>
<li>
<p>Addresses of buffers to store indicator-variable names</p>
</li>
<li>
<p>Sizes of buffers to store indicator-variable names</p>
</li>
<li>
<p>Current lengths of indicator-variable names</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCB605" class="sect2"><a id="sthref1324"></a>
<h3 class="sect2">Implementing Method 4</h3>
<p>With Method 4, you generally use the following sequence of embedded SQL statements:</p>
<pre>     EXEC SQL
         PREPARE <span class="italic">STATEMENT-NAME</span>
         FROM { :<span class="italic">HOST-STRING</span> | <span class="italic">STRING-LITERAL</span> }
     END-EXE
     EXEC SQL
         DECLARE <span class="italic">CURSOR-NAME</span> CURSOR FOR <span class="italic">STATEMENT-NAME</span>
     END-EXEC.
     EXEC SQL
         DESCRIBE BIND VARIABLES FOR <span class="italic">STATEMENT-NAME</span>
         INTO <span class="italic">BIND-DESCRIPTOR-NAME</span>
     END-EXEC.
     EXEC SQL 
         OPEN <span class="italic">CURSOR-NAME</span>
         [USING DESCRIPTOR <span class="italic">BIND-DESCRIPTOR-NAME</span>]
     END-EXEC.
     EXEC SQL
         DESCRIBE [SELECT LIST FOR] <span class="italic">STATEMENT-NAME</span>
         INTO <span class="italic">SELECT-DESCRIPTOR-NAME</span>
     END-EXEC.
     EXEC SQL 
         FETCH <span class="italic">CURSOR-NAME</span>
         USING DESCRIPTOR <span class="italic">SELECT-DESCRIPTOR-NAME</span>
     END-EXEC.
     EXEC SQL CLOSE <span class="italic">CURSOR-NAME</span> END-EXEC.
</pre>
<p>Select and bind descriptors need not work in tandem. If the number of columns in a query select list is known, but the number of place-holders for input host variables is unknown, you can use the Method 4 OPEN statement with the following Method 3 FETCH statement:</p>
<pre>     EXEC SQL FETCH <span class="italic">EMPCURSOR</span> INTO :<span class="italic">HOST-VARIABLE-LIST</span> END-EXEC.
</pre>
<p>Conversely, if the number of place-holders for input host variables is known, but the number of columns in the select list is unknown, you can use the following Method 3 OPEN statement with the Method 4 FETCH statement:</p>
<pre>     EXEC SQL OPEN <span class="italic">CURSORNAME</span> [USING <span class="italic">HOST-VARIABLE-LIST</span>] END-EXEC.
</pre>
<p>Note that EXECUTE can be used for non-queries with Method 4.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3919"></a>
<div id="LNPCB606" class="sect1">
<h2 class="sect1">Using the DECLARE STATEMENT Statement</h2>
<p>With Methods 2, 3, and 4, you might need to use the statement<a id="sthref1325"></a><a id="sthref1326"></a><a id="sthref1327"></a><a id="sthref1328"></a></p>
<pre>      EXEC SQL [AT <span class="italic">dbname</span>] DECLARE <span class="italic">statementname</span> STATEMENT END-EXEC.
</pre>
<p>where <span class="italic">dbname</span> and <span class="italic">statementname</span> are identifiers used by Pro*COBOL, <span class="italic">not</span> host or program variables.</p>
<p>DECLARE STATEMENT declares the name of a dynamic SQL statement so that the statement can be referenced by PREPARE, EXECUTE, DECLARE CURSOR, and DESCRIBE. It is required if you want to execute the dynamic SQL statement at a nondefault database. An example using Method 2 follows:<a id="sthref1329"></a><a id="sthref1330"></a></p>
<pre>     EXEC SQL AT <span class="italic">remotedb</span> DECLARE <span class="italic">sqlstmt</span> STATEMENT END-EXEC.
     EXEC SQL PREPARE <span class="italic">sqltmt</span> FROM :<span class="italic">sqlstring</span> END-EXEC.
     EXEC SQL EXECUTE <span class="italic">sqlstm</span>t END-EXEC.
</pre>
<p>In the example, <span class="italic">remotedb</span> tells Oracle where to EXECUTE the SQL statement.</p>
<p>With Methods 3 and 4, DECLARE STATEMENT is also required if the DECLARE CURSOR statement precedes the PREPARE statement, as shown in the following example:</p>
<pre>     EXEC SQL DECLARE <span class="italic">sqlstmt</span> STATEMENT END-EXEC.
     EXEC SQL DECLARE <span class="italic">empcursor</span> CURSOR FOR <span class="italic">sqlstmt</span> END-EXEC.
     EXEC SQL PREPARE <span class="italic">sqlstmt</span> FROM :<span class="italic">sqlstring</span> END-EXEC.
</pre>
<p>The usual sequence of statements is</p>
<pre>     EXEC SQL PREPARE <span class="italic">sqlstmt</span> FROM :<span class="italic">sqlstring</span> END-EXEC.
     EXEC SQL DECLARE <span class="italic">empcursor</span> CURSOR FOR <span class="italic">sqlstmt</span> END-EXEC.
</pre></div>
<!-- class="sect1" -->
<a id="i3929"></a>
<div id="LNPCB607" class="sect1">
<h2 class="sect1">Using Host Tables</h2>
<p>Usage of host tables in static and dynamic SQL is similar. For example, to use input host tables with dynamic SQL Method 2, use the syntax<a id="sthref1331"></a><a id="sthref1332"></a></p>
<pre>     EXEC SQL EXECUTE <span class="italic">statementname</span> USING :<span class="italic">HOST-TABLE-LIST</span> END-EXEC.
</pre>
<p>where <span class="italic">HOST-TABLE-LIST</span> contains one or more host tables. With Method 3, use the following syntax:</p>
<pre>     OPEN <span class="italic">cursorname</span> USING :<span class="italic">HOST-TABLE-LIST</span> END-EXEC.
</pre>
<p>To use output host tables with Method 3, use the following syntax:</p>
<pre>     FETCH <span class="italic">cursorname</span> INTO :<span class="italic">HOST-TABLE-LIST</span> END-EXEC.
</pre>
<p>With Method 4, you must use the optional FOR clause to tell Oracle the size of your input or output host table. To learn how this is done, see your host-language supplement.<a id="sthref1333"></a></p>
</div>
<!-- class="sect1" -->
<a id="i3934"></a>
<div id="LNPCB608" class="sect1">
<h2 class="sect1">Using PL/SQL</h2>
<p>Pro*COBOL treats a PL/SQL block like a single SQL statement. So, like a SQL statement, a PL/SQL block can be stored in a string host variable or literal. When you store the PL/SQL block in the string, omit the keywords EXEC SQL EXECUTE, the keyword END-EXEC, and the statement terminator.<a id="sthref1334"></a></p>
<p>However, there are two differences in the way Pro*COBOL handles SQL and PL/SQL:</p>
<ul>
<li>
<p>All PL/SQL host variables should be treated in the same way as input host variables regardless of whether they are input or output host variables (or both).</p>
</li>
<li>
<p>You cannot FETCH from a PL/SQL block because it might contain any number of SQL statements. However, you can implement similar functionality by using cursor variables.</p>
</li>
</ul>
<div id="LNPCB609" class="sect2"><a id="sthref1335"></a>
<h3 class="sect2">With Method 1</h3>
<p>If the PL/SQL block contains no host variables, you can use Method 1 to EXECUTE the PL/SQL string in the usual way.<a id="sthref1336"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB610" class="sect2"><a id="sthref1337"></a>
<h3 class="sect2">With Method 2</h3>
<p>If the PL/SQL block contains a known number of input and output host variables, you can use Method 2 to PREPARE and EXECUTE the PL/SQL string in the usual way.<a id="sthref1338"></a></p>
<p>You must put <span class="italic">all</span> host variables in the USING clause. Once the PL/SQL string EXECUTE is completed, host variables in the USING clause replace corresponding place-holders in the string after PREPARE. Though Pro*COBOL treats all PL/SQL host variables as input host variables, values are assigned correctly. Input (program) values are assigned to input host variables, and output (column) values are assigned to output host variables.</p>
<p>Every place-holder in the PL/SQL string after PREPARE must correspond to a host variable in the USING clause. So, if the same place-holder appears two or more times in the PREPAREd string, each appearance must correspond to a host variable in the USING clause.<a id="sthref1339"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB611" class="sect2"><a id="sthref1340"></a>
<h3 class="sect2">With Method 3</h3>
<p>Methods 2 and 3 are the same except that Method 3 allows completion of a FETCH. Since you cannot FETCH from a PL/SQL block, use Method 2 instead.<a id="sthref1341"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB612" class="sect2"><a id="sthref1342"></a>
<h3 class="sect2">With Method 4</h3>
<p>If the PL/SQL block contains an unknown number of input or output host variables, you must use Method 4.<a id="sthref1343"></a></p>
<p>To use Method 4, you set up one bind descriptor for all the input and output host variables. Executing DESCRIBE BIND VARIABLES stores information about input <span class="italic">and</span> output host variables in the bind descriptor. Because you refer to all PL/SQL host variables with the methods associated with input host variables, executing DESCRIBE SELECT LIST has no effect.</p>
<p>The use of bind descriptors with Method 4 is detailed in your host-language supplement.</p>
<p>Note that in dynamic SQL Method 4, a host array cannot be bound to a PL/SQL procedure with a parameter of type &#34;table.&#34;</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB613" class="sect2"><a id="sthref1344"></a>
<h3 class="sect2">Caution</h3>
<p>Do not use ANSI-style Comments (-&thinsp;- ...) in a PL/SQL block that will be processed dynamically because end-of-line characters are ignored. As a result, ANSI-style Comments extend to the end of the block, not just to the end of a line. Instead, use C-style Comments (/* ... */).<a id="sthref1345"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABHGCIA"></a>
<div id="LNPCB614" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Dynamic SQL Statement Caching</h2>
<p>Statement caching refers to the feature that provides and manages a cache of statements for each session. In the server, it means that cursors are ready to be used without the need to parse the statement again. Statement caching can be enabled in the precompiler applications, which will help in the performance improvement of all applications that rely on the dynamic SQL statements. The performance improvement is achieved by removing the overhead of parsing the dynamic statements on reuse. The precompiler application user can obtain this performance improvement using a new command line option, stmt_cache (for the statement cache size), which will enable the statement caching of the dynamic statements. By enabling the new option, the statement cache will be created at session creation time. The caching is only applicable for the dynamic statements and the cursor cache for the static statements co-exists with the new feature.</p>
<p>The command line option <code>stmt_cache</code> can be given any value in the range of 0 to 65535. Statement caching is disabled by default (value 0). The <code>stmt_cache</code> option can be set to hold the anticipated number of distinct dynamic SQL statements in the application.</p>
<div id="LNPCB615" class="example">
<p class="titleinexample"><a id="sthref1346"></a>Example 9-1 Using the stmt_cache Option</p>
<p>This example demonstrates the use of the <code>stmt_cache</code> option. In this program, you insert rows into a table and select the inserted rows by using the cursor in the loop. When the stmt_cache option is used to precompile this program, the performance increases compared to a normal precompilation.</p>
<pre> *****************************************************************
      * stmtcache:                                                    *
      *                                                               *
      * NOTE:                                                         *
      * When this program is used to measure the performance with and *
      * without stmt_cache option, do the following changes in the    *
      * program,                                                      *
      * 1. Increase ROWSCNT to high value, say 10000.                 *
      * 2. Remove all the DISPLAY statements, usually which comsumes  *
      * significant portion of the total program execution time.      *
      *****************************************************************
 
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  stmtcache.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
 
      * EMBEDDED COBOL (file &#34;STMTCACHE.PCO&#34;)  
 
           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
       01  DYNSTMT   PIC X(100) VARYING.
       01  DYNSTMT2   PIC X(100) VARYING.
 
       01  ENAME PIC X(10).
       01  COMM PIC X(9).
 
           EXEC SQL END DECLARE SECTION END-EXEC.
 
       01  ROWSCNT  PIC 9(4) COMP VALUE 10. 
       01  LOOPNO PIC  9(4).
 
       01  STRINGFIELDS.
           02 STR PIC X(18) VARYING.
 
           EXEC SQL INCLUDE SQLCA END-EXEC.
 
       PROCEDURE DIVISION.
       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR END-EXEC.
 
           PERFORM LOGON.
 
           MOVE &#34;INSERT INTO BONUS (ENAME, COMM) VALUES (:A,:B)&#34;
                TO DYNSTMT-ARR.
           MOVE 53 TO DYNSTMT-LEN.
 
           DISPLAY &#34;Inserts &#34;, ROWSCNT, &#34; rows into BONUS table.&#34;.
           PERFORM INSDATA VARYING LOOPNO FROM 1 BY 1 
                   UNTIL LOOPNO &gt; ROWSCNT.
           
           DISPLAY &#34; &#34;.
 
           DISPLAY &#34;Fetches the inserted rows from BONUS.&#34;.
           DISPLAY &#34;  ENAME COMM&#34;.
 
           MOVE &#34;SELECT ENAME, COMM FROM BONUS WHERE COMM=:A&#34;
                TO DYNSTMT2-ARR.
           MOVE 43 TO DYNSTMT2-LEN.
 
           MOVE 1 TO LOOPNO.
 
      * Loops for preparing and fetching ROWSCNT number of times
       FETCHDATA.
      * Do the prepare in the loop so that the advantage of
      * stmt_caching is visible
           EXEC SQL PREPARE S2 FROM :DYNSTMT2 END-EXEC.
 
           EXEC SQL DECLARE C1 CURSOR FOR S2
           END-EXEC.
 
           EXEC SQL OPEN C1 USING :LOOPNO END-EXEC.
 
           EXEC SQL WHENEVER NOT FOUND GO TO NOTFOUND END-EXEC.
 
       GETROWS.
      * Close the cursor so that the reparsing is not required for
      * stmt_cache
           EXEC SQL FETCH C1 INTO :ENAME, :COMM
           END-EXEC.
           DISPLAY ENAME, COMM.
           GO TO GETROWS.
 
       NOTFOUND.
           EXEC SQL CLOSE C1 END-EXEC.
           COMPUTE LOOPNO = LOOPNO + 1.
 
           IF LOOPNO &lt;= ROWSCNT THEN
             GO TO FETCHDATA
           END-IF.
 
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
 
       LOGON.
           MOVE &#34;scott&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;tiger&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
 
      * Populates the host variable and insert into the table
       INSDATA.
           EXEC SQL PREPARE S1 FROM :DYNSTMT END-EXEC.
           MOVE &#34; &#34; TO STR.
           STRING &#34;EMP_&#34;, LOOPNO INTO STR
           END-STRING.
           MOVE STR TO ENAME.
           MOVE LOOPNO TO COMM.
 
           EXEC SQL EXECUTE S1 USING :ENAME, :COMM END-EXEC.
 
      * HANDLES SQL ERROR CONDITIONS
       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pco08err.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="partpage2.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>