<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77861"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/ANSI%20Dynamic%20SQL"></a><title>ANSI Dynamic SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:21Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="partpage2.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pco11ody.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">16/27</span> <!-- End Header -->
<div id="LNPCB010" class="chapter"><a id="g1024116"></a> <a id="i1009100"></a>
<h1 class="chapter"><span class="secnum">10</span> ANSI Dynamic SQL</h1>
<p><a id="sthref1348"></a><a id="sthref1349"></a><a id="sthref1350"></a>This chapter describes Oracle&#39;s implementation of <a id="sthref1351"></a>ANSI dynamic SQL (that is, dynamic SQL as specified by the SQL standard) which should be used for new Method 4 applications. It has enhancements over the older Oracle dynamic SQL Method 4, which is described in <a href="pco11ody.htm#i9695">Chapter 11, &#34;Oracle Dynamic SQL: Method 4&#34;</a>. The ANSI Method 4 supports all Oracle types, while the older Oracle Method 4 does <span class="italic">not</span> support cursor variables, tables of group items, the DML returning clause, and LOBs.</p>
<p>In ANSI dynamic SQL, descriptors are internally maintained by Oracle, while in the older Oracle dynamic SQL Method 4, descriptors are defined in the user&#39;s Pro*COBOL program. In both cases, with Method 4 your Pro*COBOL program accepts or builds SQL statements that contain a varying number of host variables.</p>
<p>The main sections in this chapter are:</p>
<ul>
<li>
<p><a href="#i1000792">Basics of ANSI Dynamic SQL</a></p>
</li>
<li>
<p><a href="#i1000922">Overview of ANSI SQL Statements</a></p>
</li>
<li>
<p><a href="#i1001031">Oracle Extensions</a></p>
</li>
<li>
<p><a href="#i1001093">ANSI Dynamic SQL Precompiler Options</a></p>
</li>
<li>
<p><a href="#i1001175">Full Syntax of the Dynamic SQL Statements</a></p>
</li>
<li>
<p><a href="#i1005696">Sample Programs: SAMPLE12.PCO</a></p>
</li>
</ul>
<a id="i1000792"></a>
<div id="LNPCB617" class="sect1">
<h2 class="sect1"><a id="sthref1352"></a>Basics of ANSI Dynamic SQL</h2>
<p>Consider the SQL statement:</p>
<pre>SELECT ename, empno FROM emp WHERE deptno = :deptno_data 
</pre>
<p>The steps you follow to use ANSI dynamic SQL are:</p>
<ul>
<li>
<p>Declare variables, including a string to hold the statement to be executed.</p>
</li>
<li>
<p>Allocate descriptors for input and output variables.</p>
</li>
<li>
<p>Prepare the statement.</p>
</li>
<li>
<p>Describe input for the input descriptor.</p>
</li>
<li>
<p>Set the input descriptor (in our example the one input host bind variable, <code>deptno_data)</code>.</p>
</li>
<li>
<p>Declare and open a dynamic cursor.</p>
</li>
<li>
<p>Set the output descriptors (in our example, the output host variables <code>ename</code> and <code>empno)</code>.</p>
</li>
<li>
<p>Repeatedly fetch data, using GET DESCRIPTOR to retrieve the <code>ename</code> and <code>empno</code> data fields from each row.</p>
</li>
<li>
<p>Do something with the data retrieved (output it, for instance).</p>
</li>
<li>
<p>Close the dynamic cursor and deallocate the input and output descriptors.</p>
</li>
</ul>
<div id="LNPCB618" class="sect2"><a id="sthref1353"></a>
<h3 class="sect2"><a id="sthref1354"></a>Precompiler Options</h3>
<p>Normally, if you are using ANSI dynamic SQL you will be writing to the ANSI standard for precompilers and will therefore be using the macro command line option MODE=ANSI. If you wish to use this method and do not wish to use MODE=ANSI, then the functionality is controlled by the micro command line option: DYNAMIC=ANSI.</p>
<p>You can either set the micro precompiler option DYNAMIC to ANSI, or set the macro option MODE to ANSI. This causes the default value of DYNAMIC to be ANSI. The other setting of DYNAMIC is ORACLE. For more about micro options, see <a href="pco14opt.htm#i8395">&#34;Macro and Micro Options&#34;</a> and <a href="pco14opt.htm#i12604">&#34;DYNAMIC&#34;</a>.</p>
<p>In order to use ANSI type codes, set the precompiler micro option TYPE_CODE to ANSI, or set the macro option MODE to ANSI. This changes the default setting of TYPE_CODE to ANSI. To set TYPE_CODE to ANSI, DYNAMIC must also be ANSI.</p>
<p>For a list of the ANSI SQL types see <a href="#CDDBDDFB">Table 10-1</a>. Use the ANSI types with precompiler option TYPE_CODE set to ANSI if you want your application to be portable across database platforms and be as compliant to ANSI as possible.</p>
<p>For more details, see <a href="pco14opt.htm#i5831">&#34;MODE&#34;</a> and <a href="pco14opt.htm#i12603">&#34;TYPE_CODE&#34;</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1000922"></a>
<div id="LNPCB619" class="sect1">
<h2 class="sect1"><a id="sthref1355"></a>Overview of ANSI SQL Statements</h2>
<p>Allocate a descriptor area before using it in a dynamic SQL statement.</p>
<p>The ALLOCATE DESCRIPTOR statement syntax is:</p>
<pre>     EXEC SQL ALLOCATE DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam | string_literal</span>}
        [WITH MAX <span class="italic">{:occurrences </span>|<span class="italic"> numeric_literal}</span>]
     END-EXEC.
</pre>
<p>A global descriptor can be used in any module in the program. A local descriptor can be accessed only in the file in which it is allocated. Local is the default.</p>
<p>The descriptor name, <code>desc_nam</code>, is a host variable. A string literal can be used instead.</p>
<p><code>occurrences</code> is the maximum number of bind variables or columns that the descriptor can hold, with a default of 100.</p>
<p>When a descriptor is no longer needed, deallocate it to conserve memory.</p>
<p>The deallocate statement is:</p>
<pre>     EXEC SQL DEALLOCATE DESCRIPTOR [GLOBAL | LOCAL]
        {:<span class="italic">desc_nam </span>|<span class="italic"> string_literal</span>}
<span class="italic">     </span>END-EXEC.
</pre>
<p>Use the DESCRIBE statement to obtain information on a prepared SQL statement. DESCRIBE INPUT describes bind variables for the dynamic statement that has been prepared. DESCRIBE OUTPUT (the default) can give the number, type, and length of the output columns. The simplified syntax is:</p>
<pre>     EXEC SQL DESCRIBE [INPUT | OUTPUT] <span class="italic">sql_statement</span> 
        USING [SQL] DESCRIPTOR [GLOBAL | LOCAL] {:<span class="italic">desc_nam </span>|<span class="italic"> string_literal</span>}
     END-EXEC.
</pre>
<p>If your SQL statement has input and output values, you must allocate two descriptors: one for input and one for output values. If there are no input values, for example:</p>
<pre>SELECT ename, empno FROM emp 
</pre>
<p>then the input descriptor is not needed.</p>
<p>Use the SET DESCRIPTOR statement to specify input values for INSERTS, UPDATES, DELETES and the WHERE clauses of SELECT statements. Use SET DESCRIPTOR to set the number of input bind variables (stored in <span class="italic">COUNT</span>) when you have not done a DESCRIBE into your input descriptor:</p>
<pre>     EXEC SQL SET DESCRIPTOR [GLOBAL | LOCAL] {:<span class="italic">desc_nam </span>|<span class="italic"> string_literal</span>}<span class="italic"> </span>
        COUNT = {:<span class="italic">kount </span>|<span class="italic"> numeric_literal</span>} 
     END-EXEC.
</pre>
<p><code>kount</code> can be a host variable or a numeric literal, such as 5. Use a SET DESCRIPTOR statement for each host variable, giving at least the data value of the variable:</p>
<pre>     EXEC SQL SET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
        VALUE <span class="italic">item_number</span> DATA = :<span class="italic">hv3</span>
<span class="italic">     </span>END-EXEC.
</pre>
<p>You can also set the type and length of the input host variable:</p>
<p><span class="bold">Note:</span> If you do not set the type and length, either explicitly, through the SET DESCRIPTOR statement, or implicitly by doing a DESCRIBE OUTPUT, when TYPE_CODE=ORACLE, the precompiler will use values for these derived from the host variable itself. When TYPE_CODE=ANSI, you must set the type using the values in <a href="#CDDBDDFB">Table 10-1, &#34;ANSI SQL Datatypes&#34;</a>. You should also set the length because the ANSI default lengths may not match those of your host variable.</p>
<pre>     EXEC SQL SET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
        VALUE <span class="italic">item_number</span> TYPE = :<span class="italic">hv1</span>, LENGTH = :<span class="italic">hv2</span>, DATA = :<span class="italic">hv3</span>
<span class="italic">     </span>END-EXEC.
</pre>
<p>We use the identifiers <code>hv1</code>, <code>hv2</code>, and <code>hv3</code> to remind us that the values must be supplied by host variables. <span class="italic">item_number</span> is the position of the input variable in the SQL statement. It can be a host variable or an integer number.</p>
<p>TYPE is the Type Code selected from the following table, if TYPE_CODE is set to ANSI:</p>
<div id="LNPCB620" class="tblformal">
<p class="titleintable"><a id="sthref1356"></a><a id="CDDBDDFB"></a>Table 10-1 ANSI SQL Datatypes</p>
<table class="cellalignment4971" title="ANSI SQL Datatypes" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t2">Datatype</th>
<th class="cellalignment4972" id="r1c2-t2">Type Code</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t2" headers="r1c1-t2">
<p>CHARACTER</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c2-t2">
<p>1</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t2" headers="r1c1-t2">
<p>CHARACTER VARYING</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c2-t2">
<p>12</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t2" headers="r1c1-t2">
<p>DATE</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c2-t2">
<p>9</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t2" headers="r1c1-t2">
<p>DECIMAL</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c2-t2">
<p>3</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t2" headers="r1c1-t2">
<p>DOUBLE PRECISION</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c2-t2">
<p>8</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t2" headers="r1c1-t2">
<p>FLOAT</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c2-t2">
<p>6</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t2" headers="r1c1-t2">
<p>INTEGER</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c2-t2">
<p>4</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t2" headers="r1c1-t2">
<p>NUMERIC</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c2-t2">
<p>2</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t2" headers="r1c1-t2">
<p>REAL</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c2-t2">
<p>7</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t2" headers="r1c1-t2">
<p>SMALLINT</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c2-t2">
<p>5</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>See <a href="pco11ody.htm#g26226">Table 11-2, &#34;Oracle External and Related COBOL Datatypes&#34;</a> for the Oracle type codes. Use the negative value of the Oracle code if the ANSI datatype is not in the table, and TYPE_CODE = ANSI.</p>
<p>DATA is the host variable value which is input.</p>
<p>You can also set other input values such as indicator, precision and scale. See the more complete discussion of <a href="#i1001420">&#34;SET DESCRIPTOR&#34;</a>for a list of all the possible descriptor item names.</p>
<p>The numeric values in the SET DESCRIPTOR statement must be declared as either <code>PIC S9(9) COMP</code> or <code>PIC S9(4) COMP</code> except for indicator and returned length values which you must declare as <code>PIC S9(4)COMP</code>.</p>
<p>In the following example, when you want to retrieve empno, set these values: VALUE=2, because <code>empno</code> is the second output host variable in the dynamic SQL statement. The host variable <code>EMPNO-TYP</code> is set to 3 (Oracle Type for integer). The length of a host integer, <code>EMPNO-LEN</code>, is set to 4, which is the size of the host variable. The DATA is equated to the host variable EMPNO-DATA which will receive the value from the database table. The code fragment is as follows:</p>
<pre> ... 
 01  DYN-STATEMENT PIC X(58)
     VALUE &#34;SELECT ename, empno FROM emp WHERE deptno =:deptno_number&#34;.
 01  EMPNO-DATA PIC S9(9) COMP.
 01  EMPNO-TYP  PIC S9(9) COMP   VALUE 3.
 01  EMPNO-LEN  PIC S9(9) COMP   VALUE 4.
 ...
     EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 2  TYPE=:EMPNO-TYP, LENGTH=:EMPNO-LEN,
        DATA=:EMPNO-DATA END-EXEC.
 
</pre>
<p>After setting the input values, execute or open your statement using the input descriptor. If there are output values in your statement, set them before doing a FETCH. If you have done a DESCRIBE OUTPUT, you may have to reset the actual types and lengths of your host variables because the DESCRIBE execution will produce internal types and lengths which differ from your host variable external types and length.</p>
<p>After the FETCH of the output descriptor, use GET DESCRIPTOR to access the returned data. Again we show a simplified syntax with details later in this chapter:</p>
<pre>     EXEC SQL GET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam | string_literal</span>}
        VALUE <span class="italic">item_number </span>
<span class="italic">        </span>:<span class="italic">hv1 </span>= DATA, :<span class="italic">hv2 </span>= INDICATOR, :<span class="italic">hv3 </span>= RETURNED_LENGTH
     END-EXEC.
</pre>
<p><code>desc_nam</code> and <code>item_number</code> can be literals or host variables. A descriptor name can be a literal such as &#39;out&#39;. An item number can be a numeric literal such as 2.</p>
<p><code>hv1, hv2, and hv3</code> are host variables. They must be host variables, not literals. Only three are shown in the example. See <a href="#g1028984">Table 10-4, &#34;Definitions of Descriptor Item Names&#34;</a> for a list of all possible items of returned data that you can get.</p>
<p>Use either <code>PIC S9(n) COMP</code> where n is the platform-dependent upper limit, <code>PIC S9(9)COMP</code> or <code>PIC S9(4)COMP</code>for all numeric values, except for indicator and returned length variables, which must be <code>PIC S9(4) COMP</code>.</p>
</div>
<!-- class="sect1" -->
<a id="i1000986"></a>
<div id="LNPCB621" class="sect1">
<h2 class="sect1">Sample Code</h2>
<p>The following example demonstrates the use of ANSI Dynamic SQL. It allocates an input descriptor <code>in</code> and an output descriptor <code>out</code> to execute a SELECT statement. Input values are set through the SET DESCRIPTOR statement. The cursor is opened and fetched from and the resulting output values are retrieved through a GET DESCRIPTOR statement.</p>
<pre> ... 
 01  DYN-STATEMENT PIC X(58)
     VALUE &#34;SELECT ENAME, EMPNO FROM EMP WHERE DEPTNO =:DEPTNO-DAT&#34;.
 01  EMPNO-DAT  PIC S9(9) COMP.
 01  EMPNO-TYP  PIC S9(9) COMP   VALUE 3.
 01  EMPNO-LEN  PIC S9(9) COMP   VALUE 4.
 01  DEPTNO-TYP PIC S9(9) COMP   VALUE 3.
 01  DEPTNO-LEN PIC S9(9) COMP   VALUE 4.
 01  DEPTNO-DAT PIC S9(9) COMP   VALUE 10.
 01  ENAME-TYP  PIC S9(9) COMP   VALUE 3.
 01  ENAME-LEN  PIC S9(9) COMP   VALUE 30.
 01  ENAME-DAT  PIC X(30).
 01  SQLCODE PIC S9(9)    COMP   VALUE 0.
 ...
* Place preliminary code, including connection, here
...
     EXEC SQL ALLOCATE DESCRIPTOR &#39;in&#39; END-EXEC.
     EXEC SQL ALLOCATE DESCRIPTOR &#39;out&#39; END-EXEC.
     EXEC SQL PREPARE s FROM :DYN-STATEMENT END-EXEC.
     EXEC SQL DESCRIBE INPUT s USING DESCRIPTOR &#39;in&#39; END-EXEC.
     EXEC SQL SET DESCRIPTOR &#39;in&#39; VALUE 1 TYPE=:DEPTNO-TYP,
        LENGTH=:DEPTNO-LEN, DATA=:DEPTNO-DAT END-EXEC.
     EXEC SQL DECLARE c CURSOR FOR s END-EXEC.
     EXEC SQL OPEN c USING DESCRIPTOR &#39;in&#39; END-EXEC.
     EXEC SQL DESCRIBE OUTPUT s USING DESCRIPTOR &#39;out&#39; END-EXEC.
     EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 1 TYPE=:ENAME-TYP, 
        LENGTH=:ENAME-LEN, DATA=:ENAME-DAT END-EXEC.
     EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 2 TYPE=:EMPNO-TYP, 
        LENGTH=:EMPNO-LEN, DATA=:EMPNO-DAT END-EXEC.

     EXEC SQL WHENEVER NOT FOUND GOTO BREAK END-EXEC.
 LOOP.
     IF SQLCODE NOT = 0
        GOTO BREAK.
     EXEC SQL FETCH c INTO DESCRIPTOR &#39;out&#39; END-EXEC.
     EXEC SQL GET DESCRIPTOR &#39;OUT&#39; VALUE 1 :ENAME-DAT = DATA END-EXEC.
     EXEC SQL GET DESCRIPTOR &#39;OUT&#39; VALUE 2 :EMPNO-DAT = DATA END-EXEC.
     DISPLAY &#34;ENAME = &#34; WITH NO ADVANCING
     DISPLAY ENAME-DAT  WITH NO ADVANCING
     DISPLAY &#34;EMPNO = &#34; WITH NO ADVANCING
     DISPLAY EMPNO-DAT.
     GOTO LOOP.
 BREAK:
     EXEC SQL CLOSE c END-EXEC.
     EXEC SQL DEALLOCATE DESCRIPTOR &#39;in&#39; END-EXEC.
     EXEC SQL DEALLOCATE DESCRIPTOR &#39;out&#39; END-EXEC.
</pre></div>
<!-- class="sect1" -->
<a id="i1001031"></a>
<div id="LNPCB622" class="sect1">
<h2 class="sect1"><a id="sthref1357"></a>Oracle Extensions</h2>
<p>These extensions are described next:</p>
<ul>
<li>
<p>Reference semantics for data items in SET statements.</p>
</li>
<li>
<p>Arrays for bulk operations.</p>
</li>
<li>
<p>Support for object types, NCHAR columns, and LOBs.</p>
</li>
</ul>
<a id="i1001037"></a>
<div id="LNPCB623" class="sect2">
<h3 class="sect2"><a id="sthref1358"></a>Reference Semantics</h3>
<p>The ANSI standard specifies <span class="italic">value</span> semantics. To improve performance, Oracle has extended this standard to include <span class="italic">reference</span> semantics.</p>
<p>Value semantics makes a copy of your host variables data. Reference semantics uses the addresses of your host variables, avoiding a copy. Thus, reference semantics can provide performance improvements for large amounts of data.</p>
<p>To help speed up fetches, use the REF keyword before the data clauses:</p>
<pre>     EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 1 TYPE=:ENAME-TYP,
        LENGTH=:ENAME-LEN, REF DATA=:ENAME-DAT END-EXEC.
     EXEC SQL DESCRIPTOR &#39;out&#39; VALUE 2 TYPE=:EMPNO-TYP,
        LENGTH=:EMPNO-LEN, REF DATA=:EMPNO-DAT END-EXEC.
</pre>
<p>Then the host variables receive the results of the retrieves. The GET statement is not needed. The retrieved data is written directly into <code>ename_data</code> and <code>empno_data</code> after each FETCH.</p>
<p>Use of the REF keyword is allowed <span class="italic">only</span> before DATA, INDICATOR and RETURNED_LENGTH items (which can vary with each row fetched) as in this fragment of code:</p>
<pre> 01   INDI       PIC S9(4) COMP.
 01   RETRN-LEN  PIC S9(9) COMP.
 ...
      EXEC SQL SET DESCRIPTOR &#39;out&#39; VALUE 1 TYPE=:ENAME-TYP,
         LENGTH=:ENAME-LEN, REF DATA=:ENAME-DAT,
         REF INDICATOR=:INDI, REF RETURNED_LENGTH =:RETRN-LEN END-EXEC.
</pre>
<p>After each fetch, <code>RETRN-LEN</code> holds the actual retrieved length of the <code>ename</code> field, which is useful for <code>CHAR</code> or <code>VARCHAR2</code> data.</p>
<p><code>ENAME-LEN</code> will not receive the returned length. It will not be changed by the FETCH statement. Use a DESCRIBE statement, followed by a GET statement to find out the maximum column width before fetching rows of data.</p>
<p>REF keyword is also used for other types of SQL statements than SELECT, to speed them up. Note that with reference semantics, the host variable is used rather than a value copied into the descriptor area. The host variable data at the time of execution of the SQL statement is used, not its data at the time of the SET. Here is an example:</p>
<pre> ...
     MOVE 1 to VAL.
 ...
     EXEC SQL SET DESCRIPTOR &#39;value&#39; VALUE 1 DATA = :VAL END-EXEC.
     EXEC SQL SET DESCRIPTOR &#39;reference&#39; VALUE 1 REF DATA = :VAL END-EXEC.
     MOVE 2 to VAL.
* Will use  VAL = 1
     EXEC SQL EXECUTE s USING  DESCRIPTOR &#39;value&#39; END-EXEC.
*Will use VAL = 2
     EXEC SQL EXECUTE s USING DESCRIPTOR &#39;reference&#39; END-EXEC.
</pre>
<p>See <a href="#i1001420">&#34;SET DESCRIPTOR&#34;</a> for many more details on the differences.</p>
</div>
<!-- class="sect2" -->
<a id="i1003925"></a>
<div id="LNPCB624" class="sect2">
<h3 class="sect2"><a id="sthref1359"></a>Using Tables for Bulk Operations</h3>
<p>Oracle&#39;s implementation of ANSI dynamic SQL extends the SQL standard&#39;s dynamic SQL by providing bulk operations. To use bulk operations, use the <code>FOR</code> clause with an array size to specify the amount of input data or the number of rows you want to process.</p>
<p>The <code>FOR</code> clause is used in the ALLOCATE statement to give the maximum amount of data or number of rows. For example, to use a maximum array size of 100:</p>
<pre>     EXEC SQL FOR 100 ALLOCATE DESCRIPTOR &#39;out&#39; END-EXEC.
</pre>
<p>or:</p>
<pre>     MOVE 100 TO INT-ARR-SIZE.
     EXEC SQL FOR :INT-ARR-SIZE ALLOCATE DESCRIPTOR &#39;out&#39; END-EXEC.
</pre>
<p>The <code>FOR</code> clause is then used in subsequent statements that access the descriptor. In an output descriptor the FETCH statement must have an array size equal to or less than the array size already used in the ALLOCATE statement:</p>
<pre>     EXEC SQL FOR 20 FETCH c1 USING DESCRIPTOR &#39;out&#39; END-EXEC.
</pre>
<p>Subsequent GET statements for the same descriptor, that get DATA, INDICATOR, or RETURNED_LENGTH values, must use the same array size as the FETCH statement.</p>
<pre> 01  VAL-DATA   OCCURS 20 TIMES  PIC S9(9) COMP.
 01  VAL-INDI   OCCURS 20 TIMES  PIC S9(4) COMP.
...
     EXEC SQL FOR 20 GET DESCRIPTOR &#39;out&#39; VALUE 1 :VAL-DATA = DATA,
       :VAL-INDI = INDICATOR 
     END-EXEC.
</pre>
<p>However, GET statements that reference other items which do not vary from row to row, such as LENGTH, TYPE and COUNT, must <span class="italic">not</span> use the <code>FOR</code> clause:</p>
<pre> 01  CNT  PIC S9(9) COMP.
 01  LEN  PIC S9(9) COMP.
...
     EXEC SQL GET DESCRIPTOR &#39;out&#39;   :CNT = COUNT END-EXEC.
     EXEC SQL GET DESCRIPTOR &#39;out&#39; VALUE 1 :LEN = LENGTH END-EXEC.
</pre>
<p>The same holds true for SET statements with reference semantics. SET statements which precede the FETCH and employ reference semantics for DATA, INDICATOR, or RETURNED_LENGTH must have the same array size as the FETCH:</p>
<pre> ... 
 01  REF-DATA   OCCURS 20 TIMES  PIC S9(9) COMP.
 01  REF-INDI   OCCURS 20 TIMES  PIC S9(4) COMP.
...
     EXEC SQL FOR 20 SET DESCRIPTOR &#39;out&#39; VALUE 1 REF DATA = :REF-DATA,
        REF INDICATOR = :REF-INDI END-EXEC.
</pre>
<p>Similarly, for a descriptor that is used for input, to insert a batch of rows, for instance, the EXECUTE or OPEN statement must use an array size equal to or less than the size used in the ALLOCATE statement. The SET statement, for both value and reference semantics, that accesses DATA, INDICATOR, or RETURNED_LENGTH must use the same array size as in the EXECUTE statement.</p>
<p>The FOR clause is never used on the DEALLOCATE or PREPARE statements.</p>
<p>The following code sample illustrates a bulk operation with no output descriptor (there is no output, only input to be inserted into the table <code>emp</code>). The value of <code>CNT</code> is 2 (there are two host variables, <code>ENAME and EMPNO</code>, in the INSERT statement). The data table <code>ENAME-TABLE</code> holds three character strings: <code>Tom</code>, <code>Dick</code> and <code>Harry</code>, in that order. Their employee numbers are in the table <code>EMPNO-TABLE</code>. The indicator table <code>ENAME-IND</code> has a value of -1 for the second element; so a <code>NULL</code> will be inserted instead of <code>Dick</code>.</p>
<pre> 01  DYN-STATEMENT  PIC X(240) value 
         &#34;INSERT INTO EMP(ENAME, EMPNO) VALUES (:ENAME,:EMPNO)&#34;. 
 01  ARRAY-SIZE PIC S9(9) COMP   VALUE 3. 
 01  ENAME-VALUES. 
      05 FILLER PIC X(6)   VALUE &#34;Tom   &#34;. 
      05 FILLER PIC X(6)   VALUE &#34;Dick  &#34;. 
      05 FILLER PIC X(6)   VALUE &#34;Harry &#34;. 
 01  ENAME-TABLE REDEFINES ENAME-VALUES. 
      05 ENAME  PIC X(6)OCCURS 3 TIMES. 
 01  ENAME-IND  PIC S9(4) COMPOCCURS 3 TIMES. 
 01  ENAME-LEN  PIC S9(9) COMP   VALUE   6. 
 01  ENAME-TYP  PIC S9(9) COMP   VALUE  96. 
 01  EMPNO-VALUES. 
      05 FILLER PIC S9(9) COMP   VALUE 8001. 
      05 FILLER PIC S9(9) COMP   VALUE 8002. 
      05 FILLER PIC S9(9) COMP   VALUE 8003. 
 01  EMPNO-TABLE REDEFINES EMPNO-VALUES. 
      05 EMPNO  PIC S9(9) DISPLAY SIGN LEADING  OCCURS 3 TIMES. 
 01  EMPNO-LEN  PIC S9(9) COMP   VALUE   4. 
 01  EMPNO-TYP  PIC S9(9) COMP   VALUE   3. 
 01  CNT        PIC S9(9) COMP   VALUE   2. 
........ 
     EXEC SQL FOR :ARRAY-SIZE ALLOCATE DESCRIPTOR &#39;in&#39; END-EXEC.  
     EXEC SQL PREPARE S FROM :DYN-STATEMENT  END-EXEC. 
     MOVE 0 TO ENAME-IND(1). 
     MOVE -1 TO ENAME-IND(2). 
     MOVE 0 TO ENAME-IND(3). 
     EXEC SQL SET DESCRIPTOR &#39;in&#39; COUNT = :CNT END-EXEC. 
     EXEC SQL SET DESCRIPTOR &#39;in&#39; VALUE 1  
        TYPE = :ENAME-TYP, LENGTH =:ENAME-LEN 
     END-EXEC. 
     EXEC SQL FOR :ARRAY-SIZE  SET DESCRIPTOR &#39;in&#39; VALUE 1 
        DATA = :ENAME, INDICATOR = :ENAME-IND  
     END-EXEC. 
     EXEC SQL SET DESCRIPTOR &#39;in&#39; VALUE 2  
        TYPE = :EMPNO-TYP, LENGTH =:EMPNO-LEN 
     END-EXEC. 
     EXEC SQL FOR :ARRAY-SIZE  SET DESCRIPTOR &#39;in&#39; VALUE 2 
        DATA = :EMPNO  
     END-EXEC. 
     EXEC SQL FOR :ARRAY-SIZE EXECUTE S  
        USING DESCRIPTOR &#39;in&#39; END-EXEC. 
  ...
</pre>
<p>The preceding code inserts these values into the table:</p>
<pre>      EMPNO   ENAME 
      8001    Tom        
      8002            
      8003    Harry      
</pre>
<p>See the discussion in <a href="pco07tab.htm#i3048">&#34;The FOR Clause&#34;</a> for restrictions and cautions.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1001093"></a>
<div id="LNPCB625" class="sect1">
<h2 class="sect1"><a id="sthref1360"></a>ANSI Dynamic SQL Precompiler Options<a id="sthref1361"></a></h2>
<p><a id="sthref1362"></a>The macro option MODE (See <a href="pco14opt.htm#i5831">&#34;MODE&#34;</a>) sets ANSI compatibility characteristics and controls a number of functions. It can have the values ANSI or ORACLE. For individual functions there are micro options that override the MODE setting.</p>
<p><a id="sthref1363"></a><a id="sthref1364"></a>The precompiler micro option <span class="italic">DYNAMIC</span> specifies the descriptor behavior in dynamic SQL. The precompiler micro option <span class="italic">TYPE_CODE</span> specifies whether ANSI or Oracle datatype codes are to be used.</p>
<p>When the macro option MODE is set to ANSI, the micro option DYNAMIC becomes ANSI automatically. When MODE is set to ORACLE, DYNAMIC becomes ORACLE.</p>
<p>DYNAMIC and TYPE_CODE cannot be used inline.</p>
<p>The following table describes how the <a id="sthref1365"></a>DYNAMIC setting affects various functionality:</p>
<div id="LNPCB626" class="tblformal">
<p class="titleintable"><a id="sthref1366"></a><a id="sthref1367"></a>Table 10-2 DYNAMIC Option Settings</p>
<table class="cellalignment4971" title="DYNAMIC Option Settings" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t3">Function</th>
<th class="cellalignment4972" id="r1c2-t3">DYNAMIC=ANSI</th>
<th class="cellalignment4972" id="r1c3-t3">DYNAMIC=ORACLE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t3" headers="r1c1-t3">
<p>Descriptor creation.</p>
</td>
<td class="cellalignment4973" headers="r2c1-t3 r1c2-t3">
<p>Must use ALLOCATE statement.</p>
</td>
<td class="cellalignment4973" headers="r2c1-t3 r1c3-t3">
<p>Must use an Oracle format descriptor.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t3" headers="r1c1-t3">
<p>Descriptor destruction.</p>
</td>
<td class="cellalignment4973" headers="r3c1-t3 r1c2-t3">
<p>May use DEALLOCATE statement.</p>
</td>
<td class="cellalignment4973" headers="r3c1-t3 r1c3-t3">
<p>N/A</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t3" headers="r1c1-t3">
<p>Retrieving data.</p>
</td>
<td class="cellalignment4973" headers="r4c1-t3 r1c2-t3">
<p>May use both FETCH and GET statements.</p>
</td>
<td class="cellalignment4973" headers="r4c1-t3 r1c3-t3">
<p>Must use only FETCH statement.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t3" headers="r1c1-t3">
<p>Setting input data.</p>
</td>
<td class="cellalignment4973" headers="r5c1-t3 r1c2-t3">
<p>May use DESCRIBE INPUT statement. Must use SET statement.</p>
</td>
<td class="cellalignment4973" headers="r5c1-t3 r1c3-t3">
<p>Must set descriptor values in code. Must use DESCRIBE BIND VARIABLES statement.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t3" headers="r1c1-t3">
<p>Descriptor representation.</p>
</td>
<td class="cellalignment4973" headers="r6c1-t3 r1c2-t3">
<p>Single quoted literal or host identifier which contains the descriptor name.</p>
</td>
<td class="cellalignment4973" headers="r6c1-t3 r1c3-t3">
<p>Host variable, a pointer to SQLDA.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t3" headers="r1c1-t3">
<p>Data types available.</p>
</td>
<td class="cellalignment4973" headers="r7c1-t3 r1c2-t3">
<p>All ANSI types except BIT and all Oracle types.</p>
</td>
<td class="cellalignment4973" headers="r7c1-t3 r1c3-t3">
<p>Oracle types except objects, LOBs, and cursor variables.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The micro option TYPE_CODE is set by the precompiler to the same setting as the macro option MODE. TYPE_CODE can only equal ANSI if DYNAMIC equals ANSI.</p>
<p><a id="sthref1368"></a>The following table shows the functionality corresponding to the TYPE_CODE settings.</p>
<div id="LNPCB627" class="tblformal">
<p class="titleintable"><a id="sthref1369"></a><a id="g1016234"></a>Table 10-3 TYPE_CODE Option Settings</p>
<table class="cellalignment4971" title="TYPE_CODE Option Settings" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t4">Function</th>
<th class="cellalignment4972" id="r1c2-t4">TYPE_CODE=ANSI</th>
<th class="cellalignment4972" id="r1c3-t4">TYPE_CODE=ORACLE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t4" headers="r1c1-t4">
<p>Data type code numbers input and returned in dynamic SQL.</p>
</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c2-t4">
<p>Use ANSI code numbers when ANSI type exists. Otherwise, use the negative of the Oracle code number.</p>
<p>Only valid when DYNAMIC=ANSI.</p>
</td>
<td class="cellalignment4973" headers="r2c1-t4 r1c3-t4">
<p>Use Oracle code numbers.</p>
<p>May be used regardless of the setting of DYNAMIC.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect1" -->
<a id="i1001175"></a>
<div id="LNPCB628" class="sect1">
<h2 class="sect1">Full Syntax of the Dynamic SQL Statements</h2>
<p>For more details on all these statements, see the alphabetical listing in the appendix <a href="pcoafemb.htm#g65199">Appendix E, &#34;Embedded SQL Statements and Precompiler Directives&#34;</a>.</p>
<a id="i1005236"></a>
<div id="LNPCB629" class="sect2">
<h3 class="sect2"><a id="sthref1370"></a>ALLOCATE DESCRIPTOR</h3>
<p>This statement is used only for ANSI dynamic SQL.</p>
<p class="subhead2"><a id="LNPCB630"></a>Purpose</p>
<p>Use this statement to allocate a SQL descriptor area. Supply a descriptor, the maximum number of occurrences of host bind items, and an array size.</p>
<p class="subhead2"><a id="LNPCB631"></a>Syntax</p>
<pre>     EXEC SQL [FOR [:]array_size] ALLOCATE DESCRIPTOR [GLOBAL | LOCAL]
        {:desc_nam | string_literal} [WITH MAX occurrences]
     END-EXEC.
</pre>
<div id="LNPCB632" class="sect3"><a id="sthref1371"></a>
<h4 class="sect3">Variables</h4>
<p>A number of variables can be used with the ALLOCATE descriptor. These include: array_size, desc_nam, and occurrences.</p>
<dl>
<dt>array_size</dt>
<dd>
<p>The optional array_size clause (an Oracle extension) supports table processing. It tells the precompiler that the descriptor is usable for table processing.</p>
<pre> GLOBAL | LOCAL
</pre>
<p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
</dd>
<dt>desc_nam</dt>
<dd>
<p>The desc_nam variable defines the local descriptors that must be unique in the module. A runtime error is generated if the descriptor has been previously allocated, but not deallocated. A global descriptor must be unique for the application or a runtime error results.</p>
</dd>
<dt>occurrences</dt>
<dd>
<p>The optional occurrences clause is the maximum number of host variables possible in the descriptor. The occurrences variable must be an integer constant between 0 and 64K, or an error is returned. The default is 100. A precompiler error results if it does not conform to these rules.</p>
</dd>
</dl>
</div>
<!-- class="sect3" -->
<div id="LNPCB633" class="sect3"><a id="sthref1372"></a>
<h4 class="sect3">Examples</h4>
<pre>     EXEC SQL ALLOCATE DESCRIPTOR &#39;SELDES&#39; WITH MAX 50 END-EXEC.

     EXEC SQL FOR :BATCH ALLOCATE DESCRIPTOR GLOBAL :BINDDES WITH MAX 25
        END-EXEC.
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1005237"></a>
<div id="LNPCB634" class="sect2">
<h3 class="sect2"><a id="sthref1373"></a>DEALLOCATE DESCRIPTOR</h3>
<p class="subhead2"><a id="LNPCB635"></a>Purpose</p>
<p>To free memory, use the deallocate statement. This statement deallocates a previously allocated SQL descriptor area.</p>
<p class="subhead2"><a id="LNPCB636"></a>Syntax</p>
<pre>     EXEC SQL DEALLOCATE DESCRIPTOR [GLOBAL | LOCAL] 
        {<span class="italic">:desc_nam </span>| <span class="italic">string_literal</span>}
     END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB637"></a>Variables</p>
<dl>
<dt>desc_nam</dt>
<dd>
<p>The only variable available with the deallocate descriptor is desc_nam (for descriptor name.) A runtime error results when a descriptor with the same name and scope has not been allocated, or has already been allocated and deallocated.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB638"></a>Examples</p>
<pre>     EXEC SQL DEALLOCATE DESCRIPTOR GLOBAL &#39;SELDES&#39; END-EXEC.

     EXEC SQL DEALLOCATE DESCRIPTOR :BINDDES END-EXEC.
</pre></div>
<!-- class="sect2" -->
<a id="i1004022"></a>
<div id="LNPCB639" class="sect2">
<h3 class="sect2"><a id="sthref1374"></a>GET DESCRIPTOR</h3>
<p class="subhead2"><a id="LNPCB640"></a>Purpose</p>
<p>Use to obtain information from a SQL descriptor area.</p>
<p class="subhead2"><a id="LNPCB641"></a>Syntax</p>
<pre>     EXEC SQL [FOR [:]<span class="italic">array_size</span>] GET DESCRIPTOR [GLOBAL | LOCAL]
     <span class="italic">   </span>{<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
        {:<span class="italic">hv0</span>  = COUNT | VALUE <span class="italic">item_number</span> :<span class="italic">hv1</span> = <span class="italic">item_name1</span> 
        [{, :<span class="italic">hvN</span> = <span class="italic">item_nameN </span>}]}
     END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB642"></a>Variables</p>
<dl>
<dt>array_size</dt>
<dd>
<p>The <code>FOR array_size</code> variable is an optional Oracle extension. <code>FOR array_size</code> has to be equal to the <code>array_size</code> field in the FETCH statement.</p>
</dd>
<dt>desc_nam</dt>
<dd>
<p>The descriptor name.</p>
</dd>
<dt>GLOBAL | LOCAL</dt>
<dd>
<p>GLOBAL means that the descriptor name is known to all program files. LOCAL means that it is known only in the file in which it is allocated. LOCAL is the default.</p>
</dd>
<dt>COUNT</dt>
<dd>
<p>The total number of bind variables.</p>
</dd>
<dt>VALUE item_number</dt>
<dd>
<p>The position of the item in the SQL statement. <code>item_number</code> can be a variable or a constant. If <code>item_number</code> is greater than <code>COUNT</code>, the &#34;no data found&#34; condition is returned. <code>item_number</code> must be greater than 0.</p>
</dd>
<dt>hv1 .. hvN</dt>
<dd>
<p>These are host variables to which values are transferred.</p>
</dd>
<dt>item_name1 .. item_nameN</dt>
<dd>
<p>The descriptor item names corresponding to the host variables. The possible ANSI descriptor item names are listed in the following table.</p>
</dd>
</dl>
<div id="LNPCB643" class="tblformal">
<p class="titleintable"><a id="sthref1375"></a><a id="g1028984"></a>Table 10-4 Definitions of Descriptor Item Names</p>
<table class="cellalignment4971" title="Definitions of Descriptor Item Names" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t5"><span class="bold">Descriptor Item Name</span></th>
<th class="cellalignment4972" id="r1c2-t5"><span class="bold">Meaning</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t5" headers="r1c1-t5">
<p><code>TYPE</code></p>
</td>
<td class="cellalignment4973" headers="r2c1-t5 r1c2-t5">
<p>See <a href="#CDDBDDFB">Table 10-1</a> for the ANSI type codes. See <a href="pco11ody.htm#g26226">Table 11-2</a> for the Oracle type codes. Use the negative value of the Oracle code if the ANSI datatype is not in the table, and TYPE_CODE = ANSI.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t5" headers="r1c1-t5">
<p><code>LENGTH</code></p>
</td>
<td class="cellalignment4973" headers="r3c1-t5 r1c2-t5">
<p>Length of data in the column. In characters for NCHAR, and otherwise in bytes. Set by the DESCRIBE OUTPUT.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t5" headers="r1c1-t5">
<p><code>OCTET_LENGTH</code></p>
</td>
<td class="cellalignment4973" headers="r4c1-t5 r1c2-t5">
<p>Length of data in bytes.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t5" headers="r1c1-t5">
<p><code>RETURNED_LENGTH</code></p>
</td>
<td class="cellalignment4973" headers="r5c1-t5 r1c2-t5">
<p>The actual data length after a FETCH. It is undefined for fixed-length character types.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t5" headers="r1c1-t5">
<p><code>RETURNED_OCTET_LENGTH</code></p>
</td>
<td class="cellalignment4973" headers="r6c1-t5 r1c2-t5">
<p>Length of the returned data in bytes.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t5" headers="r1c1-t5">
<p><code>PRECISION</code></p>
</td>
<td class="cellalignment4973" headers="r7c1-t5 r1c2-t5">
<p>The number of digits.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t5" headers="r1c1-t5">
<p><code>SCALE</code></p>
</td>
<td class="cellalignment4973" headers="r8c1-t5 r1c2-t5">
<p>For exact numeric types, the number of digits to the right of the decimal point.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t5" headers="r1c1-t5">
<p><code>NULLABLE</code></p>
</td>
<td class="cellalignment4973" headers="r9c1-t5 r1c2-t5">
<p>If 1, the column can have NULL values. If 0, the column cannot have NULL values.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t5" headers="r1c1-t5">
<p><code>INDICATOR</code></p>
</td>
<td class="cellalignment4973" headers="r10c1-t5 r1c2-t5">
<p>The associated indicator value.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t5" headers="r1c1-t5">
<p><code>DATA</code></p>
</td>
<td class="cellalignment4973" headers="r11c1-t5 r1c2-t5">
<p>The data value.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t5" headers="r1c1-t5">
<p><code>NAME</code></p>
</td>
<td class="cellalignment4973" headers="r12c1-t5 r1c2-t5">
<p>Column name.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t5" headers="r1c1-t5">
<p><code>CHARACTER_SET_NAME</code></p>
</td>
<td class="cellalignment4973" headers="r13c1-t5 r1c2-t5">
<p>Column&#39;s character set.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The following table lists the Oracle extensions to the descriptor item names.</p>
<div id="LNPCB644" class="tblformal">
<p class="titleintable"><a id="sthref1376"></a><a id="g1030681"></a>Table 10-5 Oracle Extensions to Definitions of Descriptor Item Names</p>
<table class="cellalignment4971" title="Oracle Extensions to Definitions of Descriptor Item Names" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t6"><span class="bold">Descriptor Item Name</span></th>
<th class="cellalignment4972" id="r1c2-t6"><span class="bold">Meaning</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t6" headers="r1c1-t6">
<p><code>NATIONAL_CHARACTER</code></p>
</td>
<td class="cellalignment4973" headers="r2c1-t6 r1c2-t6">
<p>If 2, NCHAR or NVARCHAR2. If 1, character. If 0, non-character.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t6" headers="r1c1-t6">
<p><code>INTERNAL_LENGTH</code></p>
</td>
<td class="cellalignment4973" headers="r3c1-t6 r1c2-t6">
<p>The internal length, in bytes.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="LNPCB645"></a>Usage Notes</p>
<p>Use the FOR clause in GET DESCRIPTOR statements which contain DATA, INDICATOR, and RETURNED_LENGTH items only.</p>
<p>The internal type is provided by the DESCRIBE OUTPUT statement. For both input and output, you must set the type to be the external type of your host variable. TYPE is the Oracle or ANSI code in <a href="#CDDBDDFB">Table 10-1</a> . You will receive the negative value of the Oracle type code if the ANSI type is not in the table.</p>
<p>LENGTH contains the column length in characters for fields that have fixed-width National Language character sets. It is in bytes for other character columns. It is set in DESCRIBE OUTPUT.</p>
<p>RETURNED_LENGTH is the actual data length set by the FETCH statement. It is in bytes or characters as described for LENGTH. The fields OCTET_LENGTH and RETURNED_OCTET_LENGTH are the lengths in bytes.</p>
<p>NULLABLE = 1 means that the column can have NULLS; NULLABLE = 0 means it cannot.</p>
<p>CHARACTER_SET_NAME only has meaning for character columns. For other types, it is undefined. The DESCRIBE OUTPUT statement obtains the value.</p>
<p>DATA and INDICATOR are the data value and the indicator status for that column. If data = NULL, but the indicator was not requested, an error is generated at runtime (&#34;DATA EXCEPTION, NULL VALUE, NO INDICATOR PARAMETER&#34;).</p>
<p class="subhead2"><a id="LNPCB646"></a>Oracle-specific Descriptor Item Names</p>
<p>NATIONAL_CHARACTER = 2 if the column is an NCHAR or NVARCHAR2 column. If the column is a character (but not National Character) column, this item is set to 1. If a non-character column, this item becomes 0 after DESCRIBE OUTPUT is executed.</p>
<p>INTERNAL_LENGTH is for compatibility with Oracle dynamic Method 4. It has the same value as the length member of the Oracle descriptor area. See <a href="pco11ody.htm#i9695">&#34;Oracle Dynamic SQL: Method 4&#34;</a> .</p>
<p class="subhead2"><a id="LNPCB647"></a>Examples</p>
<pre>     EXEC SQL GET DESCRIPTOR :BINDDES :COUNT = COUNT END-EXEC.

     EXEC SQL GET DESCRIPTOR &#39;SELDES&#39; VALUE 1 :TYP = TYPE, :LEN = LENGTH
        END-EXEC.

     EXEC SQL FOR :BATCH GET DESCRIPTOR LOCAL &#39;SELDES&#39;
        VALUE :SEL-ITEM-NO :IND = INDICATOR, :DAT = DATA END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<a id="i1001420"></a>
<div id="LNPCB648" class="sect2">
<h3 class="sect2"><a id="sthref1377"></a>SET DESCRIPTOR</h3>
<p class="subhead2"><a id="LNPCB649"></a>Purpose</p>
<p>Use this statement to set information in the descriptor area from host variables. The SET DESCRIPTOR statement supports <span class="italic">only</span> host variables for the item names.</p>
<p class="subhead2"><a id="LNPCB650"></a>Syntax</p>
<pre>     EXEC SQL [FOR [:]<span class="italic">array_size</span>] SET DESCRIPTOR [GLOBAL | LOCAL] 
        {<span class="italic">:desc_nam | string_literal</span>} 
        {COUNT = :<span class="italic">hv0</span> | VALUE <span class="italic">item_number</span>
        [REF] <span class="italic">item_name1</span> = :<span class="italic">hv1</span> 
        [{, [REF] <span class="italic">item_nameN</span> = :<span class="italic">hvN</span>}]}
     END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB651"></a>Variables</p>
<dl>
<dt>array_size</dt>
<dd>
<p>This optional Oracle clause permits using arrays when setting the descriptor items DATA, INDICATOR, and RETURNED_LENGTH only. You cannot use other items in a SET DESCRIPTOR that contains the FOR clause. All host variable table sizes must match. Use the same array size for the SET statement that you use for the FETCH statement.</p>
</dd>
<dt>desc_nam</dt>
<dd>
<p>The descriptor name. It follows the rules in ALLOCATE DESCRIPTOR.</p>
</dd>
<dt>COUNT</dt>
<dd>
<p>The number of bind (input) or define (output) variables.</p>
</dd>
<dt>VALUE item_number</dt>
<dd>
<p>Position in the dynamic SQL statement of a host variable.</p>
</dd>
<dt>hv1 .. hvN</dt>
<dd>
<p>The host variables (not constants) that you set.</p>
</dd>
<dt>item_name1 .. item_nameN</dt>
<dd>
<p>In a similar way to the GET DESCRIPTOR syntax (see <a href="#i1004022">&#34;GET DESCRIPTOR&#34;</a>), <code>item_name</code> can take on these values:</p>
</dd>
</dl>
<div id="LNPCB652" class="tblformal">
<p class="titleintable"><a id="sthref1378"></a><a id="g1029727"></a>Table 10-6 Descriptor Item Names for SET DESCRIPTOR</p>
<table class="cellalignment4971" title="Descriptor Item Names for SET DESCRIPTOR" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t7"><span class="bold">Descriptor Item Name</span></th>
<th class="cellalignment4972" id="r1c2-t7"><span class="bold">Meaning</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t7" headers="r1c1-t7">
<p>TYPE</p>
</td>
<td class="cellalignment4973" headers="r2c1-t7 r1c2-t7">
<p>See <a href="#CDDBDDFB">Table 10-1</a> for the ANSI type codes. See <a href="pco11ody.htm#g26226">Table 11-2</a> for the Oracle type codes. Use the negative value of the Oracle type code if the Oracle type is not in the table, and TYPE_CODE = ANSI.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t7" headers="r1c1-t7">
<p>LENGTH</p>
</td>
<td class="cellalignment4973" headers="r3c1-t7 r1c2-t7">
<p>Maximum length of data in the column.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t7" headers="r1c1-t7">
<p>PRECISION</p>
</td>
<td class="cellalignment4973" headers="r4c1-t7 r1c2-t7">
<p>The number of digits.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t7" headers="r1c1-t7">
<p>SCALE</p>
</td>
<td class="cellalignment4973" headers="r5c1-t7 r1c2-t7">
<p>For exact numeric types, the number of bytes to the right of the decimal point.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t7" headers="r1c1-t7">
<p>INDICATOR</p>
</td>
<td class="cellalignment4973" headers="r6c1-t7 r1c2-t7">
<p>The associated indicator value. Set for reference semantics.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t7" headers="r1c1-t7">
<p>DATA</p>
</td>
<td class="cellalignment4973" headers="r7c1-t7 r1c2-t7">
<p>Value of the data to be set. Set for reference semantics.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t7" headers="r1c1-t7">
<p>CHARACTER_SET_NAME</p>
</td>
<td class="cellalignment4973" headers="r8c1-t7 r1c2-t7">
<p>Column&#39;s character set.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>The Oracle extensions to the descriptor item names are listed in the following table.</p>
<div id="LNPCB653" class="tblformal">
<p class="titleintable"><a id="sthref1379"></a><a id="g1029923"></a>Table 10-7 Extensions to Descriptor Item Names for SET DESCRIPTOR</p>
<table class="cellalignment4971" title="Extensions to Descriptor Item Names for SET DESCRIPTOR " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t8"><span class="bold">Descriptor Item Name</span></th>
<th class="cellalignment4972" id="r1c2-t8"><span class="bold">Meaning</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t8" headers="r1c1-t8">
<p>RETURNED_LENGTH</p>
</td>
<td class="cellalignment4973" headers="r2c1-t8 r1c2-t8">
<p>Length returned after a FETCH. Set if reference semantics is being used.</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t8" headers="r1c1-t8">
<p>NATIONAL_CHARACTER</p>
</td>
<td class="cellalignment4973" headers="r3c1-t8 r1c2-t8">
<p>Set to 2 when the input host variable is an NCHAR or NVARCHAR2 type.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="LNPCB654"></a>Usage Notes</p>
<p>Reference semantics is another optional Oracle extension that speeds performance. Use the keyword REF before these descriptor items names only: DATA, INDICATOR, RETURNED_LENGTH. When you use the REF keyword you do not need to use a GET statement. Complex data types and DML returning clauses require the REF form of SET DESCRIPTOR. See <a href="pco05sql.htm#i6276">&#34;DML Returning Clause&#34;</a>.</p>
<p>When REF is used the associated host variable itself is used in the SET. The GET is not needed in this case. The RETURNED_LENGTH can only be set when you use the REF semantics, not the value semantics.</p>
<p>Use the same array size for the SET or GET statements that you use in the FETCH.</p>
<p>Set the NATIONAL_CHAR field to 2 for NCHAR host input values.</p>
<p>When setting an object type&#39;s characteristics, you must set USER_DEFINED_TYPE_NAME and USER_DEFINED_TYPE_NAME_LENGTH.</p>
<p>If omitted, USER_DEFINED_TYPE_SCHEMA and USER_DEFINED_TYPE_SCHEMA_LENGTH default to the current connection.</p>
<div id="LNPCB655" class="sect3"><a id="sthref1380"></a>
<h4 class="sect3">Example</h4>
<p>Bulk table examples are found in <a href="#i1003925">&#34;Using Tables for Bulk Operations&#34;</a>.</p>
<pre> ...
 O1  BINDNO  PIC S9(9) COMP  VALUE 2.
 01  INDI    PIC S9(4) COMP  VALUE -1.
 01  DATA    PIC X(6)  COMP  VALUE &#34;ignore&#34;.
 01  BATCH   PIC S9(9) COMP  VALUE 1.
 ...
     EXEC SQL FOR :batch ALLOCATE DESCRIPTOR :BINDDES END-EXEC.
     EXEC SQL SET DESCRIPTOR GLOBAL :BINDDES COUNT = 3 END-EXEC.
     EXEC SQL FOR :batch SET DESCRIPTOR :BINDDES
        VALUE :BINDNO INDICATOR = :INDI, DATA = :DATA END-EXEC.
...
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB656" class="sect2"><a id="sthref1381"></a>
<h3 class="sect2"><a id="sthref1382"></a>Use of PREPARE</h3>
<p class="subhead2"><a id="LNPCB657"></a>Purpose</p>
<p>The PREPARE statement used in this method is the same as the PREPARE statement used in the Oracle dynamic SQL methods. An Oracle extension allows a quoted string for the SQL statement, as well as a variable.</p>
<p class="subhead2"><a id="LNPCB658"></a>Syntax</p>
<pre>     EXEC SQL PREPARE <span class="italic">statement_id</span> FROM :<span class="italic">sql_statement</span> END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB659"></a>Variables</p>
<dl>
<dt>statement_id</dt>
<dd>
<p>This must not be declared; it is an undeclared SQL identifier associated with the prepared SQL statement.</p>
</dd>
<dt>sql_statement</dt>
<dd>
<p>A character string (a constant or a variable) holding the embedded SQL statement.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB660"></a>Examples</p>
<pre> ...
 01  STATEMENT    PIC X(255)
        VALUE &#34;SELECT ENAME FROM emp WHERE deptno = :d&#34;.
 ...
     EXEC SQL PREPARE S1 FROM :STATEMENT END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB661" class="sect2"><a id="sthref1383"></a>
<h3 class="sect2"><a id="sthref1384"></a>DESCRIBE INPUT</h3>
<p class="subhead2"><a id="LNPCB662"></a>Purpose</p>
<p>This statement returns information about the input bind variables.</p>
<p class="subhead2"><a id="LNPCB663"></a>Syntax</p>
<pre>     EXEC SQL DESCRIBE INPUT <span class="italic">statement_id</span> USING [SQL] DESCRIPTOR 
        [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
<span class="italic">     </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB664"></a>Variables</p>
<dl>
<dt>statement_id</dt>
<dd>
<p>The same as used in PREPARE and DESCRIBE OUTPUT. This must not be declared; it is a SQL identifier.</p>
</dd>
<dt>GLOBAL | LOCAL</dt>
<dd>
<p>GLOBAL means that the descriptor name is known to all program files. LOCAL means that it is known only in the file in which it is allocated. LOCAL is the default.</p>
</dd>
<dt>desc_nam</dt>
<dd>
<p>The descriptor name.</p>
</dd>
<dt>Usage Notes</dt>
<dd>
<p>Only COUNT and NAME are implemented for bind variables in this version.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB665"></a>Examples</p>
<pre>     EXEC SQL DESCRIBE INPUT S1 USING SQL DESCRIPTOR GLOBAL :BINDDES END-EXEC.
     EXEC SQL DESCRIBE INPUT S2 USING DESCRIPTOR &#39;input&#39; END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB666" class="sect2"><a id="sthref1385"></a>
<h3 class="sect2">DESCRIBE OUTPUT</h3>
<p class="subhead2"><a id="LNPCB667"></a>Purpose</p>
<p>The DESCRIBE INPUT statement is used to obtain information about the columns in a PREPARE statement. The ANSI syntax differs from the older syntax. The information which is stored in the SQL descriptor area is the number of values returned and associated information such as type, length, and name.</p>
<p class="subhead2"><a id="LNPCB668"></a>Syntax</p>
<pre>     EXEC SQL DESCRIBE [OUTPUT] <span class="italic">statement_id</span> USING [SQL] DESCRIPTOR
        [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
<span class="italic">     </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB669"></a>Variables</p>
<dl>
<dt>statement_id</dt>
<dd>
<p>The statement_id is a SQL identifier. It must not be declared.</p>
</dd>
<dt>GLOBAL | LOCAL</dt>
<dd>
<p>GLOBAL means that the descriptor name is known to all program files. LOCAL means that it is known only in the file in which it is allocated. LOCAL is the default.</p>
</dd>
<dt>desc_nam</dt>
<dd>
<p>The descriptor name. Either a host variable preceded by a &#39;:&#39;, or a single-quoted string. OUTPUT is the default and can be omitted.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB670"></a>Examples</p>
<pre> ...
 01  DESNAME   PIC X(10) VALUE &#34;SELDES&#34;.
 ...
     EXEC SQL DESCRIBE S1 USING SQL DESCRIPTOR &#39;SELDES&#39; END-EXEC. 
* Or:
     EXEC SQL DESCRIBE OUTPUT S1 USING DESCRIPTOR :DESNAME END-EXEC.
</pre></div>
<!-- class="sect2" -->
<a id="i1007416"></a>
<div id="LNPCB671" class="sect2">
<h3 class="sect2"><a id="sthref1386"></a>EXECUTE</h3>
<p class="subhead2"><a id="LNPCB672"></a>Purpose</p>
<p>EXECUTE matches input and output variables in a prepared SQL statement and then executes the statement. This ANSI version of EXECUTE differs from the older EXECUTE statement by allowing two descriptors in one statement to support DML RETURNING.</p>
<p class="subhead2"><a id="LNPCB673"></a>Syntax</p>
<pre>     EXEC SQL [FOR [:]<span class="italic">array_size</span>] EXECUTE <span class="italic">statement_id</span> 
        [USING [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}] 
        [INTO [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}]
     END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB674"></a>Variables</p>
<dl>
<dt>array_size</dt>
<dd>
<p>The number of rows the statement will process.</p>
</dd>
<dt>statement_id</dt>
<dd>
<p>The same as used in PREPARE. This must not be declared; it is a SQL identifier. It can be a literal.</p>
</dd>
<dt>GLOBAL | LOCAL</dt>
<dd>
<p>GLOBAL means that the descriptor name is known to all program files. LOCAL means that it is known only in the file in which it is allocated. LOCAL is the default.</p>
</dd>
<dt>desc_nam</dt>
<dd>
<p>The descriptor name. Either a host variable preceded by a &#39;:&#39;, or a single-quoted string.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB675"></a>Usage Notes</p>
<p>The INTO clause implements the RETURNING clause for INSERT, UPDATE and DELETE (See <a href="pco05sql.htm#i5615">&#34;Inserting Rows&#34;</a> and succeeding pages).</p>
<p class="subhead2"><a id="LNPCB676"></a>Examples</p>
<pre>     EXEC SQL EXECUTE S1 USING SQL DESCRIPTOR GLOBAL :BINDDES END-EXEC.

     EXEC SQL EXECUTE S2 USING DESCRIPTOR :bv1 INTO DESCRIPTOR &#39;SELDES&#39;
        END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB677" class="sect2"><a id="sthref1387"></a>
<h3 class="sect2"><a id="sthref1388"></a>Use of EXECUTE IMMEDIATE</h3>
<p class="subhead2"><a id="LNPCB678"></a>Purpose</p>
<p>The EXECUTE IMMEDIATE statement executes a literal or host variable character string containing the SQL statement.The ANSI SQL form of this statement is the same as in the older dynamic SQL:</p>
<p class="subhead2"><a id="LNPCB679"></a>Syntax</p>
<pre>     EXEC SQL EXECUTE IMMEDIATE [:]<span class="italic">sql_statement END-EXEC.</span>
</pre>
<p class="subhead2"><a id="LNPCB680"></a>Variables</p>
<dl>
<dd>
<p>Only one variable is available with the EXECUTE IMMEDIATE statement.</p>
</dd>
<dt>sql_statement</dt>
<dd>
<p>The sql_statement variable is the SQL statement or PL/SQL block in a character string. It can be a host variable or a literal.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB681"></a>Examples</p>
<pre>     EXEC SQL EXECUTE IMMEDIATE :<span class="italic">statement</span> END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB682" class="sect2"><a id="sthref1389"></a>
<h3 class="sect2"><a id="sthref1390"></a>Use of DYNAMIC DECLARE CURSOR</h3>
<p class="subhead2"><a id="LNPCB683"></a>Purpose</p>
<p>The DYNAMIC DECLARE CURSOR statement declares a cursor that is associated with a statement which is a query. This is a form of the generic Declare Cursor statement.</p>
<p class="subhead2"><a id="LNPCB684"></a>Syntax</p>
<pre>     EXEC SQL DECLARE <span class="italic">cursor_name</span> CURSOR FOR <span class="italic">statement_id END-EXEC.</span>
</pre>
<p class="subhead2"><a id="LNPCB685"></a>Variables</p>
<dl>
<dt>cursor_name</dt>
<dd>
<p>A cursor variable (a SQL identifier, not a host variable).</p>
</dd>
<dt>statement_id</dt>
<dd>
<p>An undeclared SQL identifier (the same as the one used in the PREPARE statement).</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB686"></a>Examples</p>
<pre>     EXEC SQL DECLARE C1 CURSOR FOR S1 END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB687" class="sect2"><a id="sthref1391"></a>
<h3 class="sect2"><a id="sthref1392"></a>OPEN Cursor</h3>
<p class="subhead2"><a id="LNPCB688"></a>Purpose</p>
<p>The OPEN statement associates input parameters with a cursor and then opens the cursor.</p>
<p class="subhead2"><a id="LNPCB689"></a>Syntax</p>
<pre>     EXEC SQL [FOR [:]<span class="italic">array_size</span>] OPEN <span class="italic">dyn_cursor</span> 
        [[USING [SQL] DESCRIPTOR [GLOBAL | LOCAL] <span class="italic">desc_nam1</span>]
        [INTO [SQL] DESCRIPTOR [GLOBAL | LOCAL] <span class="italic">desc_nam2</span>] ]
     END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB690"></a>Variables</p>
<dl>
<dt>array_size</dt>
<dd>
<p>This limit is less than or equal to number specified when the descriptor was allocated.</p>
</dd>
<dt>GLOBAL | LOCAL</dt>
<dd>
<p>GLOBAL means that the descriptor name is known to all program files. LOCAL means that it is known only in the file in which it is allocated. LOCAL is the default.</p>
</dd>
<dt>dyn_cursor</dt>
<dd>
<p>The cursor variable.</p>
</dd>
<dt>desc_nam1, desc_nam2</dt>
<dd>
<p>The optional descriptor names.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB691"></a>Usage Notes</p>
<p>If the prepared statement associated with the cursor contains colons or question marks, a USING clause must be specified, or an error results at runtime. The INTO clause supports DML RETURNING (See <a href="pco05sql.htm#i5615">&#34;Inserting Rows&#34;</a> and succeeding sections on DELETE and UPDATE).</p>
<p class="subhead2"><a id="LNPCB692"></a>Examples</p>
<pre>     EXEC SQL OPEN C1 USING SQL DESCRIPTOR :BINDDES END-EXEC.

     EXEC SQL FOR :LIMIT OPEN C2 USING DESCRIPTOR :B1, :B2 
       INTO SQL DESCRIPTOR :SELDES
     END-EXEC.
</pre></div>
<!-- class="sect2" -->
<a id="i1007925"></a>
<div id="LNPCB693" class="sect2">
<h3 class="sect2"><a id="sthref1393"></a>FETCH</h3>
<p class="subhead2"><a id="LNPCB694"></a>Purpose</p>
<p>The FETCH statement fetches a row for a cursor declared with a dynamic DECLARE statement.</p>
<p class="subhead2"><a id="LNPCB695"></a>Syntax</p>
<pre>     EXEC SQL [FOR [:]<span class="italic">array_size</span>] FETCH cursor INTO [SQL] DESCRIPTOR 
       [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
     END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB696"></a>Variables</p>
<dl>
<dt>array_size</dt>
<dd>
<p>The number of rows the statement will process.</p>
</dd>
<dt>cursor</dt>
<dd>
<p>The dynamic cursor that was previously declared.</p>
</dd>
<dt>GLOBAL | LOCAL</dt>
<dd>
<p>GLOBAL means that the descriptor name is known to all program files. LOCAL means that it is known only in the file in which it is allocated. LOCAL is the default.</p>
</dd>
<dt>desc_nam</dt>
<dd>
<p>Descriptor name.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB697"></a>Usage Notes</p>
<p>The optional <code>array_size</code> in the FOR clause must be less than or equal to the number specified in the ALLOCATE DESCRIPTOR statement.</p>
<p>RETURNED_LENGTH is undefined for fixed-length character types.</p>
<p class="subhead2"><a id="LNPCB698"></a>Examples</p>
<pre>     EXEC SQL FETCH FROM C1 INTO DESCRIPTOR &#39;SELDES&#39; END-EXEC.

     EXEC SQL FOR :ARSZ FETCH C2 INTO DESCRIPTOR :DESC END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB699" class="sect2"><a id="sthref1394"></a>
<h3 class="sect2"><a id="sthref1395"></a>CLOSE a Dynamic Cursor</h3>
<p class="subhead2"><a id="LNPCB700"></a>Purpose</p>
<p>The CLOSE statement closes a dynamic cursor. Its syntax is identical to the Oracle Method 4.</p>
<p class="subhead2"><a id="LNPCB701"></a>Syntax</p>
<pre>     EXEC SQL CLOSE <span class="italic">cursor</span> END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB702"></a>Variables</p>
<p>Only one variable is available with the CLOSE statement.</p>
<dl>
<dt>cursor</dt>
<dd>
<p>The cursor variable describes the previously declared dynamic cursor.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB703"></a>Examples</p>
<pre>     EXEC SQL CLOSE C1 END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB704" class="sect2"><a id="sthref1396"></a>
<h3 class="sect2"><a id="sthref1397"></a>Differences From Oracle Dynamic Method 4</h3>
<p>The ANSI dynamic SQL interface supports all the features supported by the Oracle dynamic Method 4, with these additions:</p>
<ul>
<li>
<p>All datatypes, including cursor variables, and LOB types are supported by ANSI Dynamic SQL.</p>
</li>
<li>
<p>The ANSI mode uses an internal <span class="italic">SQL descriptor area</span> which is an expansion of the external SQLDA used in Oracle older dynamic Method 4 to store its input and output information.</p>
</li>
<li>
<p>New embedded SQL statements are introduced: ALLOCATE DESCRIPTOR, DEALLOCATE DESCRIPTOR, DESCRIBE, GET DESCRIPTOR, and SET DESCRIPTOR.</p>
</li>
<li>
<p>The DESCRIBE statement does not return the names of indicator variables in ANSI Dynamic SQL.</p>
</li>
<li>
<p>ANSI Dynamic SQL does not allow you to specify the maximum size of the returned column name or expression. The default size is set at 128.</p>
</li>
<li>
<p>The descriptor name must be either an identifier in single-quotes or a host variable preceded by a colon.</p>
</li>
<li>
<p>For output, the optional SELECT LIST FOR clause in the DESCRIBE is replaced by the optional keyword OUTPUT. The INTO clause is replaced by the USING DESCRIPTOR clause, which can contain the optional keyword SQL.</p>
</li>
<li>
<p>For input, the optional BIND VARIABLES FOR clause of the DESCRIBE can be replaced by the keyword INPUT. The INTO clause is replaced by the USING DESCRIPTOR clause, which can contain the optional keyword SQL.</p>
</li>
<li>
<p>The optional keyword SQL can come before the keyword DESCRIPTOR in the USING clause of the EXECUTE, FETCH and OPEN statements.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCB705" class="sect2"><a id="sthref1398"></a>
<h3 class="sect2"><a id="sthref1399"></a>Restrictions</h3>
<p>Restrictions in effect on ANSI dynamic SQL are:</p>
<ul>
<li>
<p>You cannot mix the two dynamic methods in the same module.</p>
</li>
<li>
<p>The precompiler option DYNAMIC must be set to ANSI. The precompiler option TYPE_CODE can be set to ANSI only if DYNAMIC is set to ANSI.</p>
</li>
<li>
<p>The SET statement supports only host variables as item names.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005696"></a>
<div id="LNPCB706" class="sect1">
<h2 class="sect1"><a id="sthref1400"></a>Sample Programs: SAMPLE12<a id="sthref1401"></a><a id="sthref1402"></a>.PCO</h2>
<p>The following ANSI SQL dynamic Method 4 program, SAMPLE12.PCO, is found in the demo directory. SAMPLE12 mimics SQL*Plus by prompting for SQL statements to be input by the user. Read the comments at the beginning for details of the program flow.</p>
<pre>      ******************************************************************
      * Sample Program 12: Dynamic SQL Method 4 using ANSI Dynamic SQL *
      *                                                                *
      * This program shows the basic steps required to use dynamic     *
      * SQL Method 4 with ANSI Dynamic SQL.  After logging on to       *
      * ORACLE, the program prompts the user for a SQL statement,      *
      * PREPAREs the statement, DECLAREs a cursor, checks for any      *
      * bind variables using DESCRIBE INPUT, OPENs the cursor, and     *
      * DESCRIBEs any select-list variables.  If the input SQL         *
      * statement is a query, the program FETCHes each row of data,    *
      * then CLOSEs the cursor.                                        *
      * use option dynamic=ansi when precompiling this sample.         *
      ******************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID.  ANSIDYNSQL4.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       01  USERNAME       PIC X(20).
       01  PASSWD         PIC X(20).
       01  BDSC           PIC X(6) VALUE &#34;BNDDSC&#34;.
       01  SDSC           PIC X(6) VALUE &#34;SELDSC&#34;.
       01  BNDCNT         PIC S9(9) COMP.
       01  SELCNT         PIC S9(9) COMP.
       01  BNDNAME        PIC X(80).
       01  BNDVAL         PIC X(80).
       01  SELNAME        PIC X(80) VARYING.
       01  SELDATA        PIC X(80).
       01  SELTYP         PIC S9(4) COMP.
       01  SELPREC        PIC S9(4) COMP.
       01  SELLEN         PIC S9(4) COMP.
       01  SELIND         PIC S9(4) COMP.
       01  DYN-STATEMENT  PIC X(80).
       01  BND-INDEX      PIC S9(9) COMP.
       01  SEL-INDEX      PIC S9(9) COMP.
       01  VARCHAR2-TYP   PIC S9(4) COMP VALUE 1.
       01  VAR-COUNT      PIC 9(2).
       01  ROW-COUNT      PIC 9(4).
       01  NO-MORE-DATA   PIC X(1) VALUE &#34;N&#34;.
       01  TMPLEN         PIC S9(9) COMP.
       01  MAX-LENGTH     PIC S9(9) COMP VALUE 80.

           EXEC SQL INCLUDE SQLCA         END-EXEC.

       PROCEDURE DIVISION.
       START-MAIN.

           EXEC SQL WHENEVER SQLERROR GOTO SQL-ERROR END-EXEC.

           DISPLAY &#34;USERNAME: &#34; WITH NO ADVANCING.
           ACCEPT USERNAME.
           DISPLAY &#34;PASSWORD: &#34; WITH NO ADVANCING.
           ACCEPT PASSWD.
           EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWD END-EXEC.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER: &#34;, USERNAME.

      *    ALLOCATE THE BIND AND SELECT DESCRIPTORS.

           EXEC SQL ALLOCATE DESCRIPTOR :BDSC WITH MAX 20 END-EXEC.
           EXEC SQL ALLOCATE DESCRIPTOR :SDSC WITH MAX 20 END-EXEC.

      *    GET A SQL STATEMENT FROM THE OPERATOR.

           DISPLAY &#34;ENTER SQL STATEMENT WITHOUT TERMINATOR:&#34;.
           DISPLAY &#34;&gt;&#34; WITH NO ADVANCING.
           ACCEPT DYN-STATEMENT.
           DISPLAY &#34; &#34;.

      *    PREPARE THE SQL STATEMENT AND DECLARE A CURSOR.

           EXEC SQL  PREPARE S1 FROM :DYN-STATEMENT  END-EXEC.
           EXEC SQL  DECLARE C1 CURSOR FOR S1        END-EXEC.

      *    DESCRIBE BIND VARIABLES.

           EXEC SQL DESCRIBE INPUT S1 USING DESCRIPTOR :BDSC END-EXEC.

           EXEC SQL GET DESCRIPTOR :BDSC :BNDCNT = COUNT END-EXEC.

           IF BNDCNT &lt; 0
               DISPLAY &#34;TOO MANY BIND VARIABLES.&#34;
               GO TO END-SQL
           ELSE
               DISPLAY &#34;NUMBER OF BIND VARIABLES: &#34; WITH NO ADVANCING
               MOVE BNDCNT TO VAR-COUNT
               DISPLAY VAR-COUNT
      *        EXEC SQL SET DESCRIPTOR :BDSC COUNT = :BNDCNT END-EXEC
           END-IF.

           IF BNDCNT = 0
               GO TO DESCRIBE-ITEMS.
           PERFORM SET-BND-DSC
                   VARYING BND-INDEX FROM 1 BY 1
                   UNTIL BND-INDEX &gt; BNDCNT.

      *    OPEN THE CURSOR AND DESCRIBE THE SELECT-LIST ITEMS.

       DESCRIBE-ITEMS.
           EXEC SQL  OPEN C1 USING DESCRIPTOR :BDSC END-EXEC.

           EXEC SQL  DESCRIBE OUTPUT S1 USING DESCRIPTOR :SDSC  END-EXEC.

           EXEC SQL GET DESCRIPTOR :SDSC :SELCNT = COUNT END-EXEC.

           IF SELCNT &lt; 0
               DISPLAY &#34;TOO MANY SELECT-LIST ITEMS.&#34;
               GO TO END-SQL
           ELSE
               DISPLAY &#34;NUMBER OF SELECT-LIST ITEMS: &#34;
                   WITH NO ADVANCING
               MOVE SELCNT TO VAR-COUNT
               DISPLAY VAR-COUNT
               DISPLAY &#34; &#34;
      *        EXEC SQL SET DESCRIPTOR :SDSC COUNT = :SELCNT END-EXEC
           END-IF.

      *    SET THE INPUT DESCRIPTOR

           IF SELCNT &gt; 0
               PERFORM SET-SEL-DSC
                   VARYING SEL-INDEX FROM 1 BY 1
                   UNTIL SEL-INDEX &gt; SELCNT
               DISPLAY &#34; &#34;.

      *    FETCH EACH ROW AND PRINT EACH SELECT-LIST VALUE.

           IF SELCNT &gt; 0
               PERFORM FETCH-ROWS UNTIL NO-MORE-DATA = &#34;Y&#34;.

           DISPLAY &#34; &#34;
           DISPLAY &#34;NUMBER OF ROWS PROCESSED: &#34; WITH NO ADVANCING.
           MOVE SQLERRD(3) TO ROW-COUNT.
           DISPLAY ROW-COUNT.

      *    CLEAN UP AND TERMINATE.

           EXEC SQL CLOSE C1 END-EXEC.
           EXEC SQL DEALLOCATE DESCRIPTOR :BDSC END-EXEC.
           EXEC SQL DEALLOCATE DESCRIPTOR :SDSC END-EXEC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY!&#34;.
           DISPLAY &#34; &#34;.
           STOP RUN.

      *    DISPLAY ORACLE ERROR MESSAGE AND CODE.

       SQL-ERROR.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
       END-SQL.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.

      *    PERFORMED SUBROUTINES BEGIN HERE:

      *    SET A BIND-LIST ELEMENT&#39;S ATTRIBUTE
      *    LET THE USER FILL IN THE BIND VARIABLES AND
      *    REPLACE THE 0S DESCRIBED INTO THE DATATYPE FIELDS OF THE
      *    BIND DESCRIPTOR WITH 1S TO AVOID AN &#34;INVALID DATATYPE&#34;
      *    ORACLE ERROR
       SET-BND-DSC.
               EXEC SQL GET DESCRIPTOR :BDSC VALUE
                      :BND-INDEX :BNDNAME = NAME END-EXEC.
               DISPLAY &#34;ENTER VALUE FOR &#34;, BNDNAME.
               ACCEPT BNDVAL.
               EXEC SQL SET DESCRIPTOR :BDSC VALUE :BND-INDEX
                 TYPE = :VARCHAR2-TYP, LENGTH = :MAX-LENGTH, 
                 DATA = :BNDVAL END-EXEC.

      * SET A SELECT-LIST ELEMENT&#39;S ATTRIBUTES
       SET-SEL-DSC.
           MOVE SPACES TO SELNAME-ARR.
           EXEC SQL GET DESCRIPTOR :SDSC VALUE :SEL-INDEX
                 :SELNAME = NAME, :SELTYP = TYPE,
                 :SELPREC = PRECISION, :SELLEN = LENGTH END-EXEC.

      *    IF DATATYPE IS DATE, LENGTHEN TO 9 CHARACTERS.
           IF SELTYP = 12
               MOVE 9 TO SELLEN.

      *    IF DATATYPE IS NUMBER, SET LENGTH TO PRECISION.
           MOVE 0 TO TMPLEN. 
           IF SELTYP = 2 AND SELPREC = 0
               MOVE 40 TO TMPLEN.
           IF SELTYP = 2 AND SELPREC &gt; 0
               ADD 2 TO SELPREC
               MOVE SELPREC TO TMPLEN.

           IF SELTYP = 2
               IF TMPLEN &gt; MAX-LENGTH
                   DISPLAY &#34;COLUMN VALUE TOO LARGE FOR DATA BUFFER.&#34;
                   GO TO END-SQL
               ELSE
                   MOVE TMPLEN TO SELLEN.


      * COERCE DATATYPES TO VARCHAR2.
           MOVE 1 TO SELTYP.

      *    DISPLAY COLUMN HEADING.
           DISPLAY &#34;  &#34;, SELNAME-ARR(1:SELLEN) WITH NO ADVANCING.

           EXEC SQL SET DESCRIPTOR :SDSC VALUE :SEL-INDEX
              TYPE = :SELTYP, LENGTH = :SELLEN END-EXEC.

      * FETCH A ROW AND PRINT THE SELECT-LIST VALUE.

       FETCH-ROWS.
           EXEC SQL  FETCH C1 INTO DESCRIPTOR :SDSC END-EXEC.
           IF SQLCODE NOT = 0
               MOVE &#34;Y&#34; TO NO-MORE-DATA.
           IF SQLCODE = 0
               PERFORM PRINT-COLUMN-VALUES
                   VARYING SEL-INDEX FROM 1 BY 1
                   UNTIL SEL-INDEX &gt; SELCNT
               DISPLAY &#34; &#34;.

      * PRINT A SELECT-LIST VALUE.

       PRINT-COLUMN-VALUES.
           MOVE SPACES TO SELDATA.
      *    returned length is not set for blank padded types
           IF SELTYP EQUALS 1
              EXEC SQL GET DESCRIPTOR :SDSC VALUE :SEL-INDEX
                :SELDATA = DATA, :SELIND = INDICATOR, 
                :SELLEN = LENGTH END-EXEC
           ELSE    
              EXEC SQL GET DESCRIPTOR :SDSC VALUE :SEL-INDEX
                 :SELDATA = DATA, :SELIND = INDICATOR, 
                 :SELLEN = RETURNED_LENGTH END-EXEC.
           IF (SELIND = -1)
              move &#34;  NULL&#34; to SELDATA.

           DISPLAY SELDATA(1:SELLEN), &#34;  &#34; 
                 WITH NO ADVANCING.
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="partpage2.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pco11ody.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>