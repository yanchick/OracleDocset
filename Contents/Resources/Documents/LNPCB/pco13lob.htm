<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77864"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Large%20Objects%20%28LOBs%29"></a><title>Large Objects (LOBs)</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:28Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pco12thr.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pco14opt.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">19/27</span> <!-- End Header -->
<script>
<!-- // <![CDATA[
window.name='pco13lob'
// ]]> -->
</script> <script>
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="LNPCB013" class="chapter"><a id="g1025153"></a> <a id="i1017004"></a>
<h1 class="chapter"><span class="secnum">13</span> Large Objects (LOBs)</h1>
<p>This chapter describes the support provided by embedded SQL statements for the <span class="italic">LOB</span> (Large Object) datatypes. The four types of LOBs are introduced and compared to the older LONG and LONG RAW datatypes.</p>
<p>The embedded SQL interface in Pro*COBOL is shown to provide similar functionality to that of the PL/SQL language.</p>
<p>The LOB statements and their options and host variables are presented.</p>
<p>Last, an example of Pro*COBOL programming using the LOB interface.</p>
<p>The main sections are:</p>
<ul>
<li>
<p><a href="#i1003528">Using LOBs</a></p>
</li>
<li>
<p><a href="#i1000154">How to Use LOBs</a></p>
</li>
<li>
<p><a href="#i1000162">Rules for LOB Statements</a></p>
</li>
<li>
<p><a href="#i1017087">LOB Statements</a></p>
</li>
<li>
<p><a href="#i1006967">LOB Sample Program: LOBDEMO1.PCO</a></p>
</li>
</ul>
<a id="i1003528"></a>
<div id="LNPCB812" class="sect1">
<h2 class="sect1">Using LOBs<a id="sthref1612"></a></h2>
<p>LOBs (large objects) are database types that are used to store large amounts of data (maximum size is 4 Gigabytes) such as ASCII text, text in National Characters, files in various graphics formats, and sound wave forms.</p>
<div id="LNPCB813" class="sect2"><a id="sthref1613"></a>
<h3 class="sect2">Internal LOBs<a id="sthref1614"></a></h3>
<p>Internal LOBs (BLOBs, CLOBs, NCLOBs) are stored in database table spaces and have transactional support of the database server. (COMMITT, ROLLBACK, and so forth work with them.)</p>
<p><span class="italic">BLOBs</span> (Binary LOBs) store unstructured binary (also called &#34;raw&#34;) data, such as video clips.</p>
<p><span class="italic">CLOBs</span> (Character LOBs) store large blocks of character data from the database character set.</p>
<p><span class="italic">NCLOBs</span> (National Character LOBs) store large blocks of character data from the national character set.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB814" class="sect2"><a id="sthref1615"></a>
<h3 class="sect2">External LOBs<a id="sthref1616"></a></h3>
<p>External LOBs are operating system files outside the database tablespaces, that have no transactional support from the database server.</p>
<p><span class="italic">BFILEs</span> (Binary Files) store data in external binary files. A BFILE can be in GIF, JPEG, MPEG, MPEG2, text, or other formats.<a id="sthref1617"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB815" class="sect2"><a id="sthref1618"></a>
<h3 class="sect2">Security for BFILEs</h3>
<p>The <span class="italic">DIRECTORY</span> object is used to access and use BFILEs. The DIRECTORY is a logical alias name (stored in the server) for the actual physical directory in the server file system containing the file. Users are permitted to access the file only if granted access privilege on the DIRECTORY object.</p>
<p>Two kinds of SQL statements can be used with BFILEs:</p>
<ul>
<li>
<p>The DDL (data definition language) SQL statements CREATE, REPLACE, ALTER, and DROP.</p>
</li>
<li>
<p>The DML (Data Management Language) SQL statements are used to GRANT and REVOKE the READ system and object privileges on DIRECTORY objects.</p>
</li>
</ul>
<p>A sample CREATE DIRECTORY directive is:</p>
<pre>     EXEC SQL CREATE OR REPLACE DIRECTORY &#34;Mydir&#34; AS &#39;/usr/home/mydir&#39; END-EXEC.
</pre>
<p>Other users or roles can read the directory only if you grant them permission with a DML (Data Manipulation Language) statement, such as GRANT. For example, to allow user <code>scott</code> to read BFILES in directory <code>/usr/home/mydir</code>:</p>
<pre>     EXEC SQL GRANT READ ON DIRECTORY &#34;Mydir&#34; TO scott END-EXEC.
</pre>
<p>Up to 10 BFILES can be opened simultaneously in one session. This default value can be changed by setting the SESSION_MAX_OPEN_FILES parameter.</p>
<p>See <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a> for more details on DIRECTORY objects and BFILE security, and the the GRANT command.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB816" class="sect2"><a id="sthref1619"></a>
<h3 class="sect2">LOBs Compared with LONG and LONG RAW<a id="sthref1620"></a></h3>
<p>LOBs are different from the older LONG and LONG RAW datatypes in many ways.</p>
<ul>
<li>
<p>The maximum size of a LOB is 4 Gigabytes versus 2 Gigabytes for LONG and LONG RAW.</p>
</li>
<li>
<p>You can use random as well as sequential access methods on LOBs; you can only use sequential access methods on LONG and LONG RAW.</p>
</li>
<li>
<p>LOBs (except NCLOBs) can be attributes of an object type that you define.</p>
</li>
<li>
<p>Tables can have multiple LOB columns, but can have only one LONG or LONG RAW column.</p>
</li>
</ul>
<p>Migration of existing LONG and LONG Raw attributes to LOBs is recommended by Oracle. Oracle plans to end support of LONG and LONG RAW in future releases. See Also: <a class="olink UPGRD" href="../UPGRD/toc.htm"><span class="italic">Oracle Database Upgrade Guide</span></a> for more information on migration, and <a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a> for more information on LOBs.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB817" class="sect2"><a id="sthref1621"></a>
<h3 class="sect2">LOB Locators<a id="sthref1622"></a></h3>
<p>A <span class="italic">LOB locator</span> points to the actual LOB contents. The locator is returned when you retrieve the LOB, not the LOB&#39;s contents. LOB locators cannot be saved in one transaction or session and used again in a later transaction or session.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB818" class="sect2"><a id="sthref1623"></a>
<h3 class="sect2">Temporary LOBs<a id="sthref1624"></a></h3>
<p>You can create <span class="italic">temporary</span> LOBs to assist your use of database LOBs. Temporary LOBs are like local variables and are not associated with any table. They are only accessible by their creator using their locators and are deleted when a session ends.</p>
<p>There is no support for temporary BFILES. Temporary LOBs are only permitted to be input variables (IN values) in the WHERE clause of an INSERT statement, in the SET clause of an UPDATE, or in the WHERE clause of a DELETE statement. Temporary LOBs have no transactional support from the database server, which means that you cannot do a COMMIT or ROLLBACK on them.</p>
<p>Temporary LOB locators can span transactions. They are deleted when the server abnormally terminates, and when an error is returned from a database SQL operation.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB819" class="sect2"><a id="sthref1625"></a>
<h3 class="sect2">LOB Buffering Subsystem<a id="sthref1626"></a></h3>
<p>The <span class="italic">LBS</span> (LOB Buffering Subsystem) is an area of user memory provided for use as a buffer for one or more LOBs in the client&#39;s address space.</p>
<p>Buffering has these advantages, especially for applications on a client that does many small reads and writes to specific regions of the LOB:</p>
<ul>
<li>
<p>The LBS reduces round-trips to the server because you fill the buffer with multiple reads/writes to the LOBs, and then write to the server when a FLUSH directive is executed.</p>
</li>
<li>
<p>Buffering also reduces the total number of LOB updates on the server. This creates better LOB performance and saves disk space.</p>
</li>
</ul>
<p>Oracle provides a simple buffer subsystem, not a cache. Oracle does not guarantee that the contents of a buffer are always synchronized with the server LOB value. Use the FLUSH statement to actually write updates in the server LOB.</p>
<p>Buffered reads/writes of a LOB are performed through its locator. A locator enabled for buffering provides a consistent read version of the LOB until you perform a write through that locator.</p>
<p>After being used for a buffered WRITE, a locator becomes an updated locator and provides access to the latest LOB version <span class="italic">as seen through the buffering subsystem</span>. All further buffered WRITEs to the LOB can be done only through this updated locator. Transactions involving buffered LOB operations cannot migrate across user sessions.</p>
<p>The LBS is managed by the user, who is responsible for updating server LOB values by using FLUSH statements to update them. The LBS is single-user and single-threaded. Use ROLLBACK and SAVEPOINT actions to guarantee correctness in the server LOBs. Transactional support for buffered LOB operations is not guaranteed by Oracle. To ensure transactional semantics for buffered LOB updates, you must maintain logical savepoints to perform a rollback in the event of an error.</p>
<p>For more information on the LBS, see <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1000154"></a>
<div id="LNPCB820" class="sect1">
<h2 class="sect1">How to Use LOBs</h2>
<p>There are two methods available to access LOBs in Pro*COBOL:</p>
<ul>
<li>
<p>The DBMS_LOB package inside PL/SQL blocks.</p>
</li>
<li>
<p>Embedded SQL statements.</p>
</li>
</ul>
<p>The imbedded SQL statements are designed to give users a functional equivalent to the PL/SQL interface.</p>
<p>The following table compares LOB access in PL/SQL and embedded SQL statements in Pro*COBOL. Dashes indicate missing functionality.</p>
<div id="LNPCB821" class="tblformal">
<p class="titleintable"><a id="sthref1627"></a><a id="sthref1628"></a>Table 13-1 LOB Access Methods</p>
<table class="cellalignment4971" title="LOB Access Methods " summary="q">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t2">PL/SQL<a id="sthref1629" href="#sthref1629" onclick="footdisplay(1,&#34;\u003cspan class=\&#34;bold\&#34;\u003eFrom dbmslob.sql. All routines are prefixed with \x27DBMS_LOB.\x27 except BFILENAME.\u003c/span\u003e&#34;)"><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></th>
<th class="cellalignment4972" id="r1c2-t2">Pro*COBOL Embedded SQL</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t2" headers="r1c1-t2">
<p>COMPARE()</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c2-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t2" headers="r1c1-t2">
<p>INSTR()</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c2-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t2" headers="r1c1-t2">
<p>SUBSTR()</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c2-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t2" headers="r1c1-t2">
<p>APPEND()</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c2-t2">
<p>APPEND</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t2" headers="r1c1-t2">
<p>:=</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c2-t2">
<p>ASSIGN</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t2" headers="r1c1-t2">
<p>CLOSE()</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c2-t2">
<p>CLOSE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t2" headers="r1c1-t2">
<p>COPY()</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c2-t2">
<p>COPY</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t2" headers="r1c1-t2">
<p>CREATETEMPORARY()</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c2-t2">
<p>CREATE TEMPORARY</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t2" headers="r1c1-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c2-t2">
<p>DISABLE BUFFERING</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t2" headers="r1c1-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c2-t2">
<p>ENABLE BUFFERING</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t2" headers="r1c1-t2">
<p>ERASE()</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c2-t2">
<p>ERASE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t2" headers="r1c1-t2">
<p>GETCHUNKSIZE()</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c2-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t2" headers="r1c1-t2">
<p>ISOPEN()</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c2-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t2" headers="r1c1-t2">
<p>FILECLOSE()</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c2-t2">
<p>CLOSE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r16c1-t2" headers="r1c1-t2">
<p>FILECLOSEALL()</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c2-t2">
<p>FILE CLOSE ALL</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r17c1-t2" headers="r1c1-t2">
<p>FILEEXISTS()</p>
</td>
<td class="cellalignment4973" headers="r17c1-t2 r1c2-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r18c1-t2" headers="r1c1-t2">
<p>FILEGETNAME()</p>
</td>
<td class="cellalignment4973" headers="r18c1-t2 r1c2-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r19c1-t2" headers="r1c1-t2">
<p>FILEISOPEN()</p>
</td>
<td class="cellalignment4973" headers="r19c1-t2 r1c2-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r20c1-t2" headers="r1c1-t2">
<p>FILEOPEN()</p>
</td>
<td class="cellalignment4973" headers="r20c1-t2 r1c2-t2">
<p>OPEN</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r21c1-t2" headers="r1c1-t2">
<p>BFILENAME()</p>
</td>
<td class="cellalignment4973" headers="r21c1-t2 r1c2-t2">
<p>FILE SET<a id="sthref1630" href="#sthref1630" onclick="footdisplay(2,&#34;\u003cspan class=\&#34;bold\&#34;\u003eThe BFILENAME() built in SQL function may also be used.\u003c/span\u003e&#34;)"><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a></p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r22c1-t2" headers="r1c1-t2">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r22c1-t2 r1c2-t2">
<p>FLUSH BUFFER</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r23c1-t2" headers="r1c1-t2">
<p>FREETEMPORARY()</p>
</td>
<td class="cellalignment4973" headers="r23c1-t2 r1c2-t2">
<p>FREE TEMPORARY</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r24c1-t2" headers="r1c1-t2">
<p>GETLENGTH()</p>
</td>
<td class="cellalignment4973" headers="r24c1-t2 r1c2-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r25c1-t2" headers="r1c1-t2">
<p>=</p>
</td>
<td class="cellalignment4973" headers="r25c1-t2 r1c2-t2">
<p>-</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r26c1-t2" headers="r1c1-t2">
<p>ISTEMPORARY()</p>
</td>
<td class="cellalignment4973" headers="r26c1-t2 r1c2-t2">
<p>DESCRIBE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r27c1-t2" headers="r1c1-t2">
<p>LOADFROMFILE()</p>
</td>
<td class="cellalignment4973" headers="r27c1-t2 r1c2-t2">
<p>LOAD FROM FILE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r28c1-t2" headers="r1c1-t2">
<p>OPEN()</p>
</td>
<td class="cellalignment4973" headers="r28c1-t2 r1c2-t2">
<p>OPEN</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r29c1-t2" headers="r1c1-t2">
<p>READ()</p>
</td>
<td class="cellalignment4973" headers="r29c1-t2 r1c2-t2">
<p>READ</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r30c1-t2" headers="r1c1-t2">
<p>TRIM()</p>
</td>
<td class="cellalignment4973" headers="r30c1-t2 r1c2-t2">
<p>TRIM</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r31c1-t2" headers="r1c1-t2">
<p>WRITE()</p>
</td>
<td class="cellalignment4973" headers="r31c1-t2 r1c2-t2">
<p>WRITE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r32c1-t2" headers="r1c1-t2">
<p>WRITEAPPEND()</p>
</td>
<td class="cellalignment4973" headers="r32c1-t2 r1c2-t2">
<p>WRITE</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup><span class="bold">From dbmslob.sql. All routines are prefixed with &#39;DBMS_LOB.&#39; except BFILENAME.</span></p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2&nbsp;</sup><span class="bold">The BFILENAME() built in SQL function may also be used.</span></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must explicitly lock the row before using any of the new statements that modify or change a LOB in any way. Operations that can modify a LOB value are APPEND, COPY, ERASE, LOAD FROM FILE, TRIM, and WRITE.</div>
<div id="LNPCB822" class="sect2"><a id="sthref1631"></a>
<h3 class="sect2">LOB Locators in Your Application</h3>
<p>To use LOB locators in your Pro*COBOL application use these pseudo-types:</p>
<ul>
<li>
<p>SQL-BLOB</p>
</li>
<li>
<p>SQL-CLOB</p>
</li>
<li>
<p>SQL-NCLOB</p>
</li>
<li>
<p>SQL-BFILE</p>
</li>
</ul>
<p>For example, to declare an NCLOB variable called MY-NCLOB:</p>
<pre> 01  MY-NCLOB    SQL-NCLOB.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB823" class="sect2"><a id="sthref1632"></a>
<h3 class="sect2">Initializing a LOB</h3>
<p>This section discusses how to initialize different varieties of LOBs.</p>
<div id="LNPCB824" class="sect3"><a id="sthref1633"></a>
<h4 class="sect3">Internal LOBs<a id="sthref1634"></a></h4>
<p>To initialize a BLOB to empty, use the <span class="italic">EMPTY_BLOB()</span> function or use the ALLOCATE SQL statement. For CLOBs and NCLOBs, use the <span class="italic">EMPTY_CLOB()</span> function<span class="italic">.</span> See <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more about EMPTY_BLOB() and EMPTY_CLOB(). These functions are permitted only in the VALUES clause of an INSERT statement or as the source of the SET clause in an UPDATE statement.</p>
<p>For example:</p>
<pre>     EXEC SQL INSERT INTO lob_table (a_blob, a_clob)
        VALUES (EMPTY_BLOB(), EMPTY_CLOB()) END-EXEC.
</pre>
<p>The ALLOCATE statement allocates a LOB locator and initializes it to empty, so, the following code is equivalent to the previous example:</p>
<pre>...
 01  A-BLOB      SQL-BLOB.
 01  A-CLOB      SQL-CLOB.
...
     EXEC SQL ALLOCATE :A-BLOB END-EXEC.
     EXEC SQL ALLOCATE :A-CLOB END-EXEC.
     EXEC SQL INSERT INTO lob_table (a_blob, a_clob)
        VALUES (:A-BLOB, :A-CLOB) END-EXEC.
</pre></div>
<!-- class="sect3" -->
<div id="LNPCB825" class="sect3"><a id="sthref1635"></a>
<h4 class="sect3">External LOBs<a id="sthref1636"></a></h4>
<p>Use the LOB FILE SET statement to initialize the DIRECTORY alias of the BFILE and FILENAME this way:</p>
<pre>...
 01  ALIAS        PIC X(14) VARYING.
 01  FILENAME     PIC X(14) VARYING.
 01  A-BFILE      SQL-BFILE.
 ...
     MOVE &#34;lob_dir&#34; TO ALIAS-ARR.
     MOVE 7 TO ALIAS-LEN.
     MOVE &#34;image.gif&#34; TO FILENAME-ARR
     MOVE 9 TO FILENAME-LEN..     
     EXEC SQL ALLOCATE :A-BFILE END-EXEC.
     EXEC SQL LOB FILE SET :A-BFILE
        DIRECTORY = :ALIAS, FILENAME = :FILENAME END-EXEC.
     EXEC SQL INSERT INTO file_table (a_bfile) VALUES (:A-BFILE) END-EXEC.
</pre>
<p>Refer to <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a> for a complete description of DIRECTORY object naming conventions and DIRECTORY object privileges.</p>
<p>Alternatively, you can use the BFILENAME(&#39;directory&#39;, &#39;filename&#39;) function in an INSERT or UPDATE statement to initialize a BFILE column or attribute for a particular row, and give the name of the actual physical directory and filename:</p>
<pre>     EXEC SQL INSERT INTO file_table (a_bfile)
        VALUES (BFILENAME(&#39;lob_dir&#39;, &#39;image.gif&#39;))
           RETURNING a_bfile INTO :A-BFILE END-EXEC.
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
BFILENAME() does not check permissions on the directory or filename, or whether the physical directory actually exists. Subsequent file accesses that use the BFILE locator will do those checks and return an error if the file is inaccessible.</div>
</div>
<!-- class="sect3" -->
<div id="LNPCB826" class="sect3"><a id="sthref1637"></a>
<h4 class="sect3">Temporary LOBs<a id="sthref1638"></a></h4>
<p>A temporary LOB is initialized to empty when it is first created using the embedded SQL LOB CREATE TEMPORARY statement. The EMPTY_BLOB() and EMPTY_CLOB() functions cannot be used with temporary LOBs.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB827" class="sect3"><a id="sthref1639"></a>
<h4 class="sect3">Freeing LOBs</h4>
<p>The FREE statement is used to free the memory used by an ALLOCATE statement:</p>
<pre>EXEC SQL FREE :A-BLOB END-EXEC.
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1000162"></a>
<div id="LNPCB828" class="sect1">
<h2 class="sect1">Rules for LOB Statements</h2>
<p>Here are the rules for using LOB statements:</p>
<div id="LNPCB829" class="sect2"><a id="sthref1640"></a>
<h3 class="sect2">For All LOB Statements<a id="sthref1641"></a></h3>
<p>These general restrictions and limitations apply when manipulating LOBs with the SQL LOB statements:</p>
<ul>
<li>
<p>The FOR clause is not allowed in embedded SQL LOB statements. Only one LOB locator can be used in those statement. However, the ALLOCATE and FREE statements do allow FOR clauses.</p>
</li>
<li>
<p>Distributed LOBs are not supported. Although you may use the AT database clause in any of the new embedded SQL LOB statements, you cannot mix LOB locators that were created or allocated using different database connections in the same SQL LOB statement.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNPCB830" class="sect2"><a id="sthref1642"></a>
<h3 class="sect2">For the LOB Buffering Subsystem<a id="sthref1643"></a></h3>
<p>For the LBS, these rules must be followed:</p>
<ul>
<li>
<p>Errors in read or write accesses are reported at the next access to the server. Therefore, error recovery has to be coded by you, the user.</p>
</li>
<li>
<p>When updating a LOB with buffered writes, do not update the same LOB with a method that bypasses the LOB Buffering Subsystem.</p>
</li>
<li>
<p>An updated LOB locator enabled for buffering can be passed as an IN parameter to a PL/SQL procedure, but not as an IN OUT or OUT parameter. An error is returned. An error is also returned when there is an attempt to return an updated locator.</p>
</li>
<li>
<p>An ASSIGN of an <span class="italic">updated</span> locator enabled for buffering to another locator is not allowed.</p>
</li>
<li>
<p>You can append to the LOB value with buffered writes, but the starting offset must be one character after the end of the LOB. The LBS does not allow APPEND statements resulting in zero-byte fillers or spaces in LOBs in the database server.</p>
</li>
<li>
<p>The character sets of the host locator bind variable and the database server CLOB must be the same.</p>
</li>
<li>
<p>Only ASSIGN, READ and WRITE statements work with a locator enabled for buffering.</p>
</li>
<li>
<p>The following statements result in errors when used with a locator enabled for buffering: APPEND, COPY, ERASE, DESCRIBE (LENGTH only), SELECT, and TRIM. Errors are also returned when you use these statements with a locator that is not enabled for buffering, if the LOB pointed to by the locator is being accessed in buffered mode by another locator.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The FLUSH statement must be used on a LOB enabled by the LOB Buffering Subsystem before</div>
<ul>
<li>
<p>Committing the transaction.</p>
</li>
<li>
<p>Migrating from the current transaction to another.</p>
</li>
<li>
<p>Disabling buffer operations on a LOB.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1000167"></a>
<div id="LNPCB831" class="sect2">
<h3 class="sect2">For Host Variables</h3>
<p>Use the following rules and notes for the LOB statements:<a id="sthref1644"></a></p>
<ul>
<li>
<p><span class="italic">src</span> and <span class="italic">dst</span> can refer to either internal or external LOB locators, but <span class="italic">file</span> refers only to external locators.</p>
</li>
<li>
<p>Numeric host values (<code>amt, src_offset, dst_offset</code><span class="italic">,</span> and so forth.) are declared <code>as</code> a 4-byte integer variable, PIC S9(9) COMP. The values are restricted between 0 and 4 Gigabytes.</p>
</li>
<li>
<p>The concept of NULL is part of a LOB locator. There is no need for indicator variables in the LOB statements. NULL cannot be used with numeric value variables such as <code>amt, src_offset</code>, and so forth and result in an error.</p>
</li>
<li>
<p>The offset values <code>src_offset</code> and <code>dst_offset</code> have default values 1.</p>
<div class="infoboxnotealso">
<p class="notep1">Note:</p>
BLOB, CLOB, and NCLOB variables need to respect the alignment requirements of your platform. Refer to you platform documentation on alignment restrictions of your particular platform.</div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1017087"></a>
<div id="LNPCB832" class="sect1">
<h2 class="sect1">LOB Statements</h2>
<p>The statements are presented alphabetically. In all the statements where it appears, <span class="italic">database</span> refers to a database connection</p>
<a id="i1008465"></a>
<div id="LNPCB833" class="sect2">
<h3 class="sect2">APPEND<a id="sthref1645"></a></h3>
<p class="subhead2"><a id="LNPCB834"></a>Purpose</p>
<p>The APPEND statement appends a LOB value at the end of another LOB.</p>
<p class="subhead2"><a id="LNPCB835"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB APPEND :<span class="italic">src</span> TO :<span class="italic">dst </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB836"></a>Host Variables</p>
<dl>
<dt>src (IN)</dt>
<dd>
<p>An internal LOB locator uniquely referencing the source LOB.</p>
</dd>
<dt>dsc (IN OUT)</dt>
<dd>
<p>An internal LOB locator uniquely referencing the destination LOB.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB837"></a>Usage Notes</p>
<p>The data is copied from the source LOB to the end of the destination LOB, extending the destination LOB up to a maximum of 4 Gigabytes. If the LOB is extended beyond 4 Gigabytes, an error will occur.</p>
<p>The source and destination LOBs must already exist and the destination LOB must be initialized.</p>
<p>Both the source and destination LOBs must be of the same internal LOB type. It is an error to have enabled LOB buffering for either type of locator.</p>
</div>
<!-- class="sect2" -->
<a id="i1008466"></a>
<div id="LNPCB838" class="sect2">
<h3 class="sect2">ASSIGN<a id="sthref1646"></a></h3>
<p class="subhead2"><a id="LNPCB839"></a>Purpose</p>
<p>Assigns a LOB or BFILE locator to another.</p>
<p class="subhead2"><a id="LNPCB840"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB ASSIGN :<span class="italic">src</span> to :<span class="italic">dst </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB841"></a>Host Variables</p>
<dl>
<dt>src (IN)</dt>
<dd>
<p>LOB or BFILE locator source copied from.</p>
</dd>
<dt>dsc (IN OUT)</dt>
<dd>
<p>LOB or BFILE locator copied to.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB842"></a>Usage Notes</p>
<p>After the assignment, both locators refer to the same LOB value. The destination LOB locator must be a valid initialized (allocated) locator.</p>
<p>For internal LOBs, the source locator&#39;s LOB value is copied to the destination locator&#39;s LOB value only when the destination locator is stored in the table. For Pro*COBOL, issuing a FLUSH of an object containing the destination locator will copy the LOB value.</p>
<p>An error is returned when a BFILE locator is assigned to an internal LOB locator and vice-versa. It is also an error if the <span class="italic">src</span> and <span class="italic">dst</span> LOBs are not of the same type.</p>
<p>If the source locator is for an internal LOB that was enabled for buffering, and the source locator has been used to modify the LOB value through the LOB Buffering Subsystem, and the buffers have not been flushed since the WRITE, then the source locator cannot be assigned to the destination locator. This is because only one locator for each LOB can modify the LOB value through the LOB Buffering Subsystem.</p>
</div>
<!-- class="sect2" -->
<a id="i1008467"></a>
<div id="LNPCB843" class="sect2">
<h3 class="sect2">CLOSE<a id="sthref1647"></a></h3>
<p class="subhead2"><a id="LNPCB844"></a>Purpose</p>
<p>Close an open LOB or BFILE.</p>
<p class="subhead2"><a id="LNPCB845"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB CLOSE :<span class="italic">src </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB846"></a>Host Variables</p>
<dl>
<dt>src (IN OUT)</dt>
<dd>
<p>The locator of the LOB or BFILE to be closed.</p>
</dd>
</dl>
<p class="subhead2"><a id="LNPCB847"></a>Usage Notes</p>
<p>It is an error to close the same LOB twice either with different locators or with the same locator. For external LOBs, no error is produced if the BFILE exists but has not been opened.</p>
<p>It is an error to COMMIT a transaction before closing all previously opened LOBs. At transaction ROLLBACK time, all LOBs that are still open will be discarded without first being closed.</p>
</div>
<!-- class="sect2" -->
<a id="i1008468"></a>
<div id="LNPCB848" class="sect2">
<h3 class="sect2">COPY<a id="sthref1648"></a></h3>
<p class="subhead2"><a id="LNPCB849"></a>Purpose</p>
<p>Copy all or part of a LOB value into a second LOB.</p>
<p class="subhead2"><a id="LNPCB850"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB COPY :<span class="italic">amt </span>FROM :<span class="italic">src</span> [AT :<span class="italic">src_offset</span>]
        TO :<span class="italic">dst</span> [AT :<span class="italic">dst_offset</span>] END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB851"></a>Host Variables</p>
<p><a id="LNPCB852"></a><a id="sthref1649"></a><span class="subhead3">amt (IN)&nbsp;</span>The maximum number of bytes for BLOBs, or characters for CLOBs and NCLOBs, to copy.</p>
<p><a id="LNPCB853"></a><a id="sthref1650"></a><span class="subhead3">src (IN)&nbsp;</span>The locator of the source LOB.</p>
<p><a id="LNPCB854"></a><a id="sthref1651"></a><span class="subhead3">src_offset (IN)&nbsp;</span>This is the number of characters for CLOB or NCLOB, and the number of bytes for a BLOB, starting from 1 at the beginning of the LOB.</p>
<p><a id="LNPCB855"></a><a id="sthref1652"></a><span class="subhead3">dst (IN)&nbsp;</span>The locator of the destination LOB.</p>
<p><a id="LNPCB856"></a><a id="sthref1653"></a><span class="subhead3">dst_offset (IN)&nbsp;</span>The destination offset. Same rules as for src_offset.</p>
<p class="subhead2"><a id="LNPCB857"></a>Usage Notes</p>
<p>If the data already exists at the destination&#39;s offset and beyond, it is overwritten with the source data. If the destination&#39;s offset is beyond the end of the current data, zero-byte fillers (BLOBs) or spaces (CLOBs) are written into the destination LOB from the end of the current data to the beginning of the newly written data from the source.</p>
<p>The destination LOB is extended to accommodate the newly written data if it extends beyond the current length of the destination LOB. It is a runtime error to extend this LOB beyond 4 Gigabytes.</p>
<p>It is also an error to try to copy from a LOB that is not initialized.</p>
<p>Both the source and destination LOBs must be of the same type. LOB buffering must not be enabled for either locator.</p>
<p>To make a temporary LOB permanent, the COPY statement must be used to explicitly COPY the temporary LOB into a permanent one.The <code>amt</code> variable indicates the maximum amount to copy. If the end of the source LOB is reached before the specified amount is copied, the operation terminates without an error.</p>
</div>
<!-- class="sect2" -->
<a id="i1008469"></a>
<div id="LNPCB858" class="sect2">
<h3 class="sect2">CREATE TEMPORARY<a id="sthref1654"></a></h3>
<p class="subhead2"><a id="LNPCB859"></a>Purpose</p>
<p>Creates a temporary LOB.</p>
<p class="subhead2"><a id="LNPCB860"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB CREATE TEMPORARY :<span class="italic">src </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB861"></a>Host Variables</p>
<p><a id="LNPCB862"></a><a id="sthref1655"></a><span class="subhead3">src (IN OUT)&nbsp;</span>Before execution, when IN, <code>src</code> is a LOB locator previously allocated.</p>
<p>After execution, when OUT, <code>src</code> is a LOB locator that will point to a new empty temporary LOB.</p>
<p class="subhead2"><a id="LNPCB863"></a>Usage Notes</p>
<p>After successful execution, the locator points to a newly created temporary LOB that resides on the database server independent of a table. The temporary LOB is empty and has zero length.</p>
<p>At the end of a session, all temporary LOBs are freed. Reads and Writes to temporary LOBs never go through the buffer cache.</p>
</div>
<!-- class="sect2" -->
<a id="i1008470"></a>
<div id="LNPCB864" class="sect2">
<h3 class="sect2">DISABLE BUFFERING<a id="sthref1656"></a></h3>
<p class="subhead2"><a id="LNPCB865"></a>Purpose</p>
<p>Disables LOB buffering for the LOB locator.</p>
<p class="subhead2"><a id="LNPCB866"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB DISABLE BUFFERING :<span class="italic">src </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB867"></a>Host Variables</p>
<p><a id="LNPCB868"></a><a id="sthref1657"></a><span class="subhead3">src (IN OUT)&nbsp;</span>An internal LOB locator.</p>
<p class="subhead2"><a id="LNPCB869"></a>Usage Notes</p>
<p>This statement does not support BFILEs. Subsequent reads or writes will not be done through the LBS.</p>
<p><span class="bold">Note:</span> Use a FLUSH BUFFER command to make changes permanent, since the DISABLE BUFFERING statement does not implicitly flush the changes made in the LOB Buffering Subsystem.</p>
</div>
<!-- class="sect2" -->
<a id="i1007018"></a>
<div id="LNPCB870" class="sect2">
<h3 class="sect2">ENABLE BUFFERING<a id="sthref1658"></a></h3>
<p class="subhead2"><a id="LNPCB871"></a>Purpose</p>
<p>Enables LOB buffering for the LOB locator.</p>
<p class="subhead2"><a id="LNPCB872"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB ENABLE BUFFERING :<span class="italic">src </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB873"></a>Host Variables</p>
<p><a id="LNPCB874"></a><a id="sthref1659"></a><span class="subhead3">src (IN OUT)&nbsp;</span>An internal LOB locator.</p>
<p class="subhead2"><a id="LNPCB875"></a>Usage Notes</p>
<p>This statement does not support BFILEs. Subsequent reads and writes are done through the LBS.</p>
</div>
<!-- class="sect2" -->
<a id="i1008471"></a>
<div id="LNPCB876" class="sect2">
<h3 class="sect2">ERASE<a id="sthref1660"></a></h3>
<p class="subhead2"><a id="LNPCB877"></a>Purpose</p>
<p>Erases a given amount of LOB data starting from a given offset.</p>
<p class="subhead2"><a id="LNPCB878"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB ERASE :amt 
        FROM :src [AT :src_offset] END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB879"></a>Host Variables</p>
<p><a id="LNPCB880"></a><a id="sthref1661"></a><span class="subhead3">amt (IN OUT)&nbsp;</span>The input is the number of bytes or characters to erase. The returned output is the actual number erased.</p>
<p><a id="LNPCB881"></a><a id="sthref1662"></a><span class="subhead3">src (IN OUT)&nbsp;</span>An internal LOB locator.</p>
<p><a id="LNPCB882"></a><a id="sthref1663"></a><span class="subhead3">src_offset (IN)&nbsp;</span>The offset from the beginning of the LOB, starting from 1.</p>
<p class="subhead2"><a id="LNPCB883"></a>Usage Notes</p>
<p>This statement does not support BFILEs.</p>
<p>After execution, <span class="italic">amt</span> returns the actual number of characters/bytes that were erased. The actual number and requested number will differ if the end of the LOB value is reached before erasing the requested number of characters/bytes. If the LOB is empty, <span class="italic">amt</span> will indicate that 0 characters/bytes were erased.</p>
<p>For BLOBs, erasing means zero-byte fillers overwrite the existing LOB value. For CLOBs, erasing means that spaces overwrite the existing LOB value.</p>
</div>
<!-- class="sect2" -->
<a id="i1008472"></a>
<div id="LNPCB884" class="sect2">
<h3 class="sect2">FILE CLOSE ALL<a id="sthref1664"></a></h3>
<p class="subhead2"><a id="LNPCB885"></a>Purpose</p>
<p>Closes all BFILES opened in the current session.</p>
<p class="subhead2"><a id="LNPCB886"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB FILE CLOSE ALL END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB887"></a>Usage Notes</p>
<p>If there are any open files in the session whose closure has not been handled properly, you can use the FILE CLOSE ALL statement to close all files opened in the session and resume file operations from the beginning.</p>
</div>
<!-- class="sect2" -->
<a id="i1008473"></a>
<div id="LNPCB888" class="sect2">
<h3 class="sect2">FILE SET<a id="sthref1665"></a></h3>
<p class="subhead2"><a id="LNPCB889"></a>Purpose</p>
<p>Sets DIRECTORY alias and FILENAME in a BFILE locator.</p>
<p class="subhead2"><a id="LNPCB890"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB FILE SET :<span class="italic">file</span>
        DIRECTORY = :<span class="italic">alias</span>, FILENAME = :<span class="italic">filename </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB891"></a>Host Variables</p>
<p><a id="LNPCB892"></a><a id="sthref1666"></a><span class="subhead3">file (IN OUT)&nbsp;</span>BFILE locator where the DIRECTORY alias and FILENAME is set.</p>
<p><a id="LNPCB893"></a><a id="sthref1667"></a><span class="subhead3">alias (IN)&nbsp;</span>DIRECTORY alias name to set.</p>
<p><a id="LNPCB894"></a><a id="sthref1668"></a><span class="subhead3">filename (IN)&nbsp;</span>The FILENAME to set.</p>
<p class="subhead2"><a id="LNPCB895"></a>Usage Notes</p>
<p>The given BFILE locator must be first ALLOCATEd prior to its use in this statement.</p>
<p>Both the DIRECTORY alias name and FILENAME must be provided.</p>
<p>The maximum length of the DIRECTORY alias is 30 bytes. The maximum length of the FILENAME is 255 bytes.</p>
<p>The only external datatypes supported for use with the DIRECTORY alias name and FILENAME attributes are VARCHAR, VARCHAR2 and CHARF.</p>
<p>It is an error to use this statement with anything but an external LOB locator.</p>
</div>
<!-- class="sect2" -->
<a id="i1008474"></a>
<div id="LNPCB896" class="sect2">
<h3 class="sect2">FLUSH BUFFER<a id="sthref1669"></a></h3>
<p class="subhead2"><a id="LNPCB897"></a>Purpose</p>
<p>Writes this LOB&#39;s buffers to the database server.</p>
<p class="subhead2"><a id="LNPCB898"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB FLUSH BUFFER :src [FREE] END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB899"></a>Host Variables</p>
<p><a id="LNPCB900"></a><a id="sthref1670"></a><span class="subhead3">src (IN OUT)&nbsp;</span>Internal LOB locator.</p>
<p class="subhead2"><a id="LNPCB901"></a>Usage Notes</p>
<p>Writes the buffer data to the database LOB in the server from the LOB referenced by the input locator.</p>
<p>LOB buffering must have already been enabled for the input LOB locator.</p>
<p>The FLUSH operation, by default, does not free the buffer resources for reallocation to another buffered LOB operation. However, if you want to free the buffer explicitly, you can include the optional FREE keyword to so indicate.</p>
</div>
<!-- class="sect2" -->
<a id="i1008475"></a>
<div id="LNPCB902" class="sect2">
<h3 class="sect2">FREE TEMPORARY<a id="sthref1671"></a></h3>
<p class="subhead2"><a id="LNPCB903"></a>Purpose</p>
<p>Free the temporary space for the LOB locator.</p>
<p class="subhead2"><a id="LNPCB904"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB FREE TEMPORARY :<span class="italic">src </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB905"></a>Host Variables</p>
<p><a id="LNPCB906"></a><a id="sthref1672"></a><span class="subhead3">src (IN OUT)&nbsp;</span>The LOB locator pointing to the temporary LOB.</p>
<p class="subhead2"><a id="LNPCB907"></a>Usage Notes</p>
<p>The input locator must point to a temporary LOB. The output locator is marked not initialized and can be used in subsequent LOB statements.</p>
</div>
<!-- class="sect2" -->
<a id="i1008476"></a>
<div id="LNPCB908" class="sect2">
<h3 class="sect2">LOAD FROM FILE<a id="sthref1673"></a></h3>
<p class="subhead2"><a id="LNPCB909"></a>Purpose</p>
<p>Copy all or a part of a BFILE into an internal LOB.</p>
<p class="subhead2"><a id="LNPCB910"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB LOAD :<span class="italic">amt</span> 
        FROM FILE :<span class="italic">file</span> [AT :<span class="italic">src_offset</span>] INTO :<span class="italic">dst</span> [AT :<span class="italic">dst_offset</span>] END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB911"></a>Host Variables</p>
<p><a id="LNPCB912"></a><a id="sthref1674"></a><span class="subhead3">amt (IN)&nbsp;</span>Maximum number of bytes to be loaded.</p>
<p><a id="LNPCB913"></a><a id="sthref1675"></a><span class="subhead3">file (IN OUT)&nbsp;</span>The source BFILE locator.</p>
<p><a id="LNPCB914"></a><a id="sthref1676"></a><span class="subhead3">src_offset (IN)&nbsp;</span>The number of bytes offset from the beginning of the file, starting from 1.</p>
<p><a id="LNPCB915"></a><a id="sthref1677"></a><span class="subhead3">dst (IN OUT)&nbsp;</span>The destination LOB locator which can be BLOB, CLOB, be NCLOB.</p>
<p><a id="LNPCB916"></a><a id="sthref1678"></a><span class="subhead3">dst_offset (IN)&nbsp;</span>The number of bytes (for BLOBs) or characters (CLOBs and NCLOBs) from the beginning of the destination LOB where writing will begin. It starts at 1.</p>
<p class="subhead2"><a id="LNPCB917"></a>Usage Notes</p>
<p>The data is copied from the source BFILE to the destination internal LOB. No character set conversions are performed when copying the BFILE data to a CLOB or NCLOB. Therefore, the BFILE data must already be in the same character set as the CLOB or NCLOB in the database.</p>
<p>The source and destination LOBs must already exist. If the data already exists at the destination&#39;s start position, it is overwritten with the source data. If the destination&#39;s start position is beyond the end of the current data, zero-byte fillers (BLOBs) or spaces (CLOBs and NCLOBs) are written into the destination LOB from the end of the data to the beginning of the newly written data from the source.</p>
<p>The destination LOB is extended to accommodate the newly written data if it extends beyond the current length of the destination LOB. It is an error to extend this LOB beyond 4 Gigabytes.</p>
<p>It is also an error to copy from a BFILE that is not initialized.</p>
<p>The amount parameter indicates the maximum amount to load. If the end of the source BFILE is reached before the specified amount is loaded, the operation terminates without error.</p>
</div>
<!-- class="sect2" -->
<a id="i1008477"></a>
<div id="LNPCB918" class="sect2">
<h3 class="sect2">OPEN<a id="sthref1679"></a></h3>
<p class="subhead2"><a id="LNPCB919"></a>Purpose</p>
<p>Open a LOB or BFILE for read or read/write access.</p>
<p class="subhead2"><a id="LNPCB920"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB OPEN :<span class="italic">src</span> 
        [ READ ONLY | READ WRITE ] END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB921"></a>Host Variables</p>
<p><a id="LNPCB922"></a><a id="sthref1680"></a><span class="subhead3">src (IN OUT)&nbsp;</span>LOB locator of the LOB or BFILE.</p>
<p class="subhead2"><a id="LNPCB923"></a>Usage Notes</p>
<p>The default mode in which a LOB or BFILE can be Opened is for READ ONLY access.</p>
<p>For internal LOBs, being OPEN is associated with the LOB, not with the locator. Assigning an already Opened locator to another locator does not count as OPENing a new LOB. Instead, both locators refer to the same LOB. For BFILEs, being OPEN is associated with the locator.</p>
<p>Only 32 LOBs can be OPEN at any one time. An error will be returned when the 33rd LOB is Opened.</p>
<p>There is no support for writable BFILEs. Therefore, when you OPEN a BFILE in READ WRITE mode, an error is returned.</p>
<p>It is also an error to open a LOB in READ ONLY mode and then attempt to WRITE to the LOB.</p>
</div>
<!-- class="sect2" -->
<a id="i1000009"></a>
<div id="LNPCB924" class="sect2">
<h3 class="sect2">READ<a id="sthref1681"></a></h3>
<p class="subhead2"><a id="LNPCB925"></a>Purpose</p>
<p>Reads all or part of a LOB or BFILE into a buffer.</p>
<p class="subhead2"><a id="LNPCB926"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB READ :amt FROM :<span class="italic">src </span>[AT :<span class="italic">src_offset</span>]
        INTO :<span class="italic">buffer</span> [WITH LENGTH :<span class="italic">buflen</span>] END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB927"></a>Host Variables</p>
<p><a id="LNPCB928"></a><a id="sthref1682"></a><span class="subhead3">amt (IN OUT)&nbsp;</span>The input is the number of characters or bytes to be read. The output is the actual number of characters or bytes that were read.</p>
<p>If the amount of bytes to be read is larger than the buffer length it is assumed that the LOB is being READ in a polling mode. On input if this value is 0, then the data will be read in a polling mode from the input offset until the end of the LOB.</p>
<p>The number of bytes or characters actually read is returned in <code>amt.</code> If the data is read in pieces, <code>amt</code> will always contain the length of the last piece read.</p>
<p>When the end of a LOB is reached an <span class="italic">ORA-1403: no data found</span> error will be issued.</p>
<p>When reading in a polling mode, the application must invoke the LOB READ repeatedly to read more pieces of the LOB until no more data is left. Control the use of the polling mode with the NOT FOUND condition in a WHENEVER directive to catch the ORA-1403 error.</p>
<p><a id="LNPCB929"></a><a id="sthref1683"></a><span class="subhead3">src (IN)&nbsp;</span>The LOB or BFILE locator.</p>
<p><a id="LNPCB930"></a><a id="sthref1684"></a><span class="subhead3">src_offset (IN)&nbsp;</span>This is the absolute offset from the beginning of the LOB value from which to start reading. For character LOBs it is the number of characters from the beginning of the LOB. For binary LOBs or BFILEs it is the number of bytes. The first position is 1.</p>
<p><a id="LNPCB931"></a><a id="sthref1685"></a><span class="subhead3">buffer (IN OUT)&nbsp;</span>A buffer into which the LOB data will be read. The external datatype of the buffer is restricted to only a few types depending on the type of the source LOB. The maximum length of the buffer depends on the external datatype being used to store the LOB value. <a id="sthref1686"></a>The following table summarizes the legal external datatypes and their corresponding maximum lengths categorized by source LOB type:</p>
<div id="LNPCB932" class="tblformal">
<p class="titleintable"><a id="sthref1687"></a><a id="sthref1688"></a>Table 13-2 Source LOB and Precompiler Datatypes</p>
<table class="cellalignment4971" title="Source LOB and Precompiler Datatypes" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t7">External LOB<a id="sthref1689" href="#sthref1689" onclick="footdisplay(1,&#34;\u003cspan class=\&#34;bold\&#34;\u003e Any of the external datatypes shown can be used with BFILES.\u003c/span\u003e&#34;)"><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></th>
<th class="cellalignment4972" id="r1c2-t7">Internal LOB</th>
<th class="cellalignment4972" id="r1c3-t7">Precompiler External Datatype</th>
<th class="cellalignment4972" id="r1c4-t7">Precompiler Maximum Length <a id="sthref1690" href="#sthref1690" onclick="footdisplay(2,&#34;\u003cspan class=\&#34;bold\&#34;\u003e Lengths are measured in bytes, not characters.\u003c/span\u003e&#34;)"><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a></th>
<th class="cellalignment4972" id="r1c5-t7">PL/SQL Datatype</th>
<th class="cellalignment4972" id="r1c6-t7">PL/SQL Maximum Length</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t7" headers="r1c1-t7">
<p>BFILE</p>
</td>
<td class="cellalignment4973" headers="r2c1-t7 r1c2-t7">
<p>BLOB</p>
</td>
<td class="cellalignment4973" headers="r2c1-t7 r1c3-t7">
<p>RAW</p>
<p>VARRAW</p>
<p>LONG RAW</p>
<p>LONG VARRAW</p>
</td>
<td class="cellalignment4973" headers="r2c1-t7 r1c4-t7">
<p>65535</p>
<p>65533</p>
<p>2147483647</p>
<p>2147483643</p>
</td>
<td class="cellalignment4973" headers="r2c1-t7 r1c5-t7">
<p>RAW</p>
</td>
<td class="cellalignment4973" headers="r2c1-t7 r1c6-t7">
<p>32767</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t7" headers="r1c1-t7">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r3c1-t7 r1c2-t7">
<p>CLOB</p>
</td>
<td class="cellalignment4973" headers="r3c1-t7 r1c3-t7">
<p>VARCHAR2</p>
<p>VARCHAR</p>
<p>LONG VARCHAR</p>
</td>
<td class="cellalignment4973" headers="r3c1-t7 r1c4-t7">
<p>65535</p>
<p>65533</p>
<p>2147483643</p>
</td>
<td class="cellalignment4973" headers="r3c1-t7 r1c5-t7">
<p>VARCHAR2</p>
</td>
<td class="cellalignment4973" headers="r3c1-t7 r1c6-t7">
<p>32767</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t7" headers="r1c1-t7">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r4c1-t7 r1c2-t7">
<p>NCLOB</p>
</td>
<td class="cellalignment4973" headers="r4c1-t7 r1c3-t7">
<p>NVARCHAR2</p>
</td>
<td class="cellalignment4973" headers="r4c1-t7 r1c4-t7">
<p>4000</p>
</td>
<td class="cellalignment4973" headers="r4c1-t7 r1c5-t7">
<p>NVARCHAR2</p>
</td>
<td class="cellalignment4973" headers="r4c1-t7 r1c6-t7">
<p>4000</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup> <span class="bold">Any of the external datatypes shown can be used with BFILES.</span></p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2&nbsp;</sup> <span class="bold">Lengths are measured in bytes, not characters.</span></p>
<p><a id="LNPCB933"></a><a id="sthref1691"></a><span class="subhead3">buflen (IN)&nbsp;</span>Specifies the length of the given buffer when it cannot be determined otherwise.</p>
<p class="subhead2"><a id="LNPCB934"></a>Usage Notes</p>
<p>A BFILE must already exist on the database server and must have been opened using the input locator. The database must have permission to read the file and the user must have read permission on the directory.</p>
<p>It is an error to try to read from an un-initialized LOB or BFILE.</p>
<p>The length of the buffer is determined this way:</p>
<ul>
<li>
<p>From <code>buflen</code>, when the WITH LENGTH clause is present.</p>
</li>
<li>
<p>In the absence of the WITH LENGTH clause, the length is determined by treating the buffer host variable in OUT mode according to the rules in <a href="pco04dat.htm#i13105">&#34;Handling Character Data&#34;</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1008478"></a>
<div id="LNPCB935" class="sect2">
<h3 class="sect2">TRIM<a id="sthref1692"></a></h3>
<p class="subhead2"><a id="LNPCB936"></a>Purpose</p>
<p>Truncates the LOB value.</p>
<p class="subhead2"><a id="LNPCB937"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB TRIM :<span class="italic">src</span> TO :<span class="italic">newlen </span>END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB938"></a>Host Variables</p>
<p><a id="LNPCB939"></a><a id="sthref1693"></a><span class="subhead3">src (IN OUT)&nbsp;</span>LOB locator for internal LOB.</p>
<p><a id="LNPCB940"></a><a id="sthref1694"></a><span class="subhead3">newlen (IN)&nbsp;</span>The new length of the LOB value.</p>
<p class="subhead2"><a id="LNPCB941"></a>Usage Notes</p>
<p>This statement is not for BFILES. The new length cannot be greater than the current length, or an error is returned.</p>
</div>
<!-- class="sect2" -->
<a id="i1008479"></a>
<div id="LNPCB942" class="sect2">
<h3 class="sect2">WRITE<a id="sthref1695"></a></h3>
<p class="subhead2"><a id="LNPCB943"></a>Purpose</p>
<p>Writes the contents of a buffer to a LOB.</p>
<p class="subhead2"><a id="LNPCB944"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB WRITE [APPEND] [ FIRST | NEXT | LAST | ONE ]
        :<span class="italic">amt </span>FROM :<span class="italic">buffer</span> [WITH LENGTH :<span class="italic">buflen</span>] 
           INTO :<span class="italic">dst</span> [AT :<span class="italic">dst_offset</span>] END-EXEC.
</pre>
<p class="subhead2"><a id="LNPCB945"></a>Host Variables</p>
<p><a id="LNPCB946"></a><a id="sthref1696"></a><span class="subhead3">amt (IN OUT)&nbsp;</span>The input is the number of characters or bytes to be written.</p>
<p>The output is the actual number of characters or bytes that is written.</p>
<p>When writing using a polling method, <code>amt</code> will return the cumulative total length written for the execution of the WRITE statement after a WRITE LAST is executed. If the WRITE statement is interrupted, <code>amt</code> will be undefined.</p>
<p><a id="LNPCB947"></a><a id="sthref1697"></a><span class="subhead3">buffer (IN)&nbsp;</span>A buffer from which the LOB data is written. See <a href="#i1000009">&#34;READ&#34;</a> for the lengths of datatypes.</p>
<p><a id="LNPCB948"></a><a id="sthref1698"></a><span class="subhead3">dst (IN OUT)&nbsp;</span>The LOB locator.</p>
<p><a id="LNPCB949"></a><a id="sthref1699"></a><span class="subhead3">dst_offset (IN)&nbsp;</span>The offset from the beginning of the LOB (counting from 1), in characters for CLOBs and NCLOBs, in bytes for BLOBs.</p>
<p><a id="LNPCB950"></a><a id="sthref1700"></a><span class="subhead3">buflen (IN)&nbsp;</span>The buffer length when it cannot be calculated in any other way.</p>
<p class="subhead2"><a id="LNPCB951"></a>Usage Notes</p>
<p>If LOB data already exists, it is overwritten with the data stored in the buffer. If the offset specified is beyond the end of the data currently in the LOB, zero-byte fillers or spaces are inserted into the LOB.</p>
<p>Specifying the keyword APPEND in the WRITE statement causes the data to automatically be written to the end of the LOB. When APPEND is specified, the destination offset is assumed to be the end of the LOB. It is an error to specify the destination offset when using the APPEND option in the WRITE statement.</p>
<p>The buffer can be written to the LOB in one piece (using the ONE orientation which is the default) or it can be provided piece-wise using a standard polling method.</p>
<p>Polling is begun by using FIRST, then NEXT to write subsequent pieces. The LAST keyword is used to write the final piece that terminates the write.</p>
<p>Using this piece-wise write mode, the buffer and the length can be different in each call if the pieces are of different sizes and from different locations.</p>
<p>If the total amount of data passed to Oracle is less than the amount specified by the <code>amt</code> parameter after doing all the writes, an error results.</p>
<p>The same rules apply for determining the buffer length as in the READ statement. See <a href="#i1000009">&#34;READ&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i1008862"></a>
<div id="LNPCB952" class="sect2">
<h3 class="sect2">DESCRIBE</h3>
<p class="subhead2"><a id="LNPCB953"></a>Purpose</p>
<p>This is a statement that is equivalent to several OCI and PL/SQL statements. Use the LOB DESCRIBE SQL statement to retrieve attributes from a LOB. The LOB DESCRIBE statement has this format:</p>
<p class="subhead2"><a id="LNPCB954"></a>Syntax</p>
<pre>     EXEC SQL [AT [:]<span class="italic">database</span>] LOB DESCRIBE :<span class="italic">src</span> GET <span class="italic">attribute1</span> [{, <span class="italic">attributeN</span>}]
        INTO :<span class="italic">hv1</span> [[INDICATOR] :<span class="italic">hv_ind1</span>] [{, :<span class="italic">hvN</span> [[INDICATOR] :<span class="italic">hv_indN</span>] }] 
           END-EXEC.
</pre>
<p>where an attribute can be any of these choices:</p>
<pre>CHUNKSIZE | DIRECTORY | FILEEXISTS | FILENAME | ISOPEN | ISTEMPORARY | LENGTH
</pre>
<p class="subhead2"><a id="LNPCB955"></a>Host Variables</p>
<p><a id="LNPCB956"></a><a id="sthref1701"></a><span class="subhead3">src (IN)&nbsp;</span>The LOB locator of an internal or external LOB.</p>
<p><a id="LNPCB957"></a><a id="sthref1702"></a><span class="subhead3">hv1 ... hvN (OUT)&nbsp;</span>The host variables that receive the attribute values, in the order specified in the attribute name list.</p>
<p><a id="LNPCB958"></a><a id="sthref1703"></a><span class="subhead3">hv_ind1 ... hv_indN (OUT)&nbsp;</span>Optional host variables that receive the indicator NULL status in the order of the attribute name list.</p>
<p>The following table describes the attributes, which LOB it is associated with, and the COBOL types into which they should be read:</p>
<div id="LNPCB959" class="tblformalwide">
<p class="titleintable"><a id="sthref1704"></a><a id="sthref1705"></a>Table 13-3 LOB Attributes</p>
<table class="cellalignment4974" title="LOB Attributes" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t8">LOB Attribute</th>
<th class="cellalignment4972" id="r1c2-t8">Attribute Description</th>
<th class="cellalignment4972" id="r1c3-t8">Restrictions</th>
<th class="cellalignment4972" id="r1c4-t8">COBOL Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t8" headers="r1c1-t8">
<p>CHUNKSIZE<a id="sthref1706"></a></p>
</td>
<td class="cellalignment4973" headers="r2c1-t8 r1c2-t8">
<p>The optimum amount (in bytes for BLOBs and characters for CLOBs/NCLOBs) of space of a given tablespace block, which is used to store the LOB value. Chunk sizes are not fixed and the maximum possible value based on the available chunk sizes is used for storage. If you make multiple WRITE requests on the same page or set of pages, data is written to the disk only when committed and is treated as a single modification. This allows for data being written in larger chunk sizes.</p>
</td>
<td class="cellalignment4973" headers="r2c1-t8 r1c3-t8">
<p>BLOBs, CLOBs and NCLOBs only</p>
</td>
<td class="cellalignment4973" headers="r2c1-t8 r1c4-t8">
<p>PIC S9(9) COMP</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t8" headers="r1c1-t8">
<p>DIRECTORY<a id="sthref1707"></a></p>
</td>
<td class="cellalignment4973" headers="r3c1-t8 r1c2-t8">
<p>The name of the DIRECTORY alias for the BFILE. The length, n, is between 1 and 30 bytes. Use that length in the picture.</p>
</td>
<td class="cellalignment4973" headers="r3c1-t8 r1c3-t8">
<p>FILE LOBs only</p>
</td>
<td class="cellalignment4973" headers="r3c1-t8 r1c4-t8">
<p>PIC X(n) [VARYING]</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t8" headers="r1c1-t8">
<p>FILEEXISTS<a id="sthref1708"></a></p>
</td>
<td class="cellalignment4973" headers="r4c1-t8 r1c2-t8">
<p>Determines whether or not the BFILE exists on the server&#39;s operating system file system. FILEEXISTS is true when it is nonzero; false when it equals 0.</p>
</td>
<td class="cellalignment4973" headers="r4c1-t8 r1c3-t8">
<p>FILE LOBs only</p>
</td>
<td class="cellalignment4973" headers="r4c1-t8 r1c4-t8">
<p>PIC S9(9) COMP</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t8" headers="r1c1-t8">
<p>FILENAME<a id="sthref1709"></a></p>
</td>
<td class="cellalignment4973" headers="r5c1-t8 r1c2-t8">
<p>The name of the BFILE. The length, n, is between 1 and 255 bytes. Use that length in the picture.</p>
</td>
<td class="cellalignment4973" headers="r5c1-t8 r1c3-t8">
<p>FILE LOBs only</p>
</td>
<td class="cellalignment4973" headers="r5c1-t8 r1c4-t8">
<p>PIC X(n) [VARYING]</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t8" headers="r1c1-t8">
<p>ISOPEN<a id="sthref1710"></a></p>
</td>
<td class="cellalignment4973" headers="r6c1-t8 r1c2-t8">
<p>For BFILEs, if the input BFILE locator was never used in an OPEN statement, the BFILE is considered not to be OPENed by this locator. However, a different BFILE locator may have OPENed the BFILE. More than one OPEN can be performed on the same BFILE using different locators. For LOBs, if a different locator opened the LOB, the LOB is still considered to be OPEN by the input locator. ISOPEN is true when it is nonzero; false when it equals 0.</p>
</td>
<td class="cellalignment4973" headers="r6c1-t8 r1c3-t8">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r6c1-t8 r1c4-t8">
<p>PIC S9(9) COMP</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t8" headers="r1c1-t8">
<p>ISTEMPORARY<a id="sthref1711"></a></p>
</td>
<td class="cellalignment4973" headers="r7c1-t8 r1c2-t8">
<p>Determines whether or not the input LOB locator refers to a temporary LOB or not. ISTEMPORARY is true when it is nonzero; false when it equals 0.</p>
</td>
<td class="cellalignment4973" headers="r7c1-t8 r1c3-t8">
<p>BLOBs, CLOBs and NCLOBs only</p>
</td>
<td class="cellalignment4973" headers="r7c1-t8 r1c4-t8">
<p>PIC S9(9) COMP</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t8" headers="r1c1-t8">
<p>LENGTH<a id="sthref1712"></a></p>
</td>
<td class="cellalignment4973" headers="r8c1-t8 r1c2-t8">
<p>Length of BLOBs and BFILEs in bytes, CLOBs and NCLOBs in characters. For BFILEs, the length includes EOF if it exists. Empty internal LOBs have zero length. LOBs/BFILEs that are not initialized have undefined length.</p>
</td>
<td class="cellalignment4973" headers="r8c1-t8 r1c3-t8">
<p>-</p>
</td>
<td class="cellalignment4973" headers="r8c1-t8 r1c4-t8">
<p>PIC 9(9) COMP</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformalwide" -->
<p class="subhead2"><a id="LNPCB960"></a>Usage Notes</p>
<p>Indicator variables should be declared as PIC S9(4) COMP. After execution has completed, SQLERRD(3) contains the number of attributes retrieved without error. If there was an execution error, the attribute at which it occurred is one more than the contents of SQLERRD(3).</p>
<p class="subhead2"><a id="LNPCB961"></a>DESCRIBE Example</p>
<p>Here is a simple Pro*COBOL example that extracts the DIRECTORY and FILENAME attributes of a given BFILE:</p>
<pre>...
 01  A-BFILE      SQL-BFILE.
 01  DIRECTORY    PIC X(30) VARYING.
 01  FILENAME     PIC X(30) VARYING.
 01  D-IND        PIC S9(4) COMP.
 01  F-IND        PIC S9(4) COMP.
 01  FEXISTS      PIC S9(9) COMP.
 01  ISOPN        PIC S9(9) COMP.  
...
</pre>
<p>Finally, select a BFILE locator from some LOB table and do the DESCRIBE:</p>
<pre>     EXEC SQL ALLOCATE :A-BFILE END-EXEC.
     EXEC SQL INSERT INTO lob_table (a_bfile) VALUES (BFILENAME (&#39;lob.dir&#39;,
        &#39;image.gif&#39;)) END-EXEC.
     EXEC SQL SELECT a_bfile INTO :A-BFILE FROM lob_table WHERE ... END-EXEC.
     EXEC SQL DESCRIBE :A-BFILE GET DIRECTORY, FILENAME, FILEEXISTS, ISOPEN
        INTO :DIRECTORY:D-IND, :FILENAME:F-IND, FEXISTS, ISOPN ND-EXEC.
</pre>
<p>Indicator variables are valid for use only with the DIRECTORY and FILENAME attributes. These attributes are character strings whose values may be truncated if the host variable buffers used to hold their values are not large enough. When truncation occurs, the value of the indicator will be set to the original length of the attribute.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB962" class="sect2"><a id="sthref1713"></a>
<h3 class="sect2">READ and WRITE Using the Polling Method<a id="sthref1714"></a></h3>
<p>Here is an outline of using READ with the polling method:</p>
<p>Start the read polling by setting the amount to zero in the first LOB READ (or set the amount to the size of the total data to be read). The amount is first set to zero in this case outline which omits details:</p>
<pre>      EXEC SQL ALLOCATE :CLOB1 END-EXEC.

      EXEC SQL WHENEVER NOT FOUND GOTO END-OF-CLOB END-EXEC.

      EXEC SQL SELECT A_CLOB INTO :CLOB1 FROM LOB_TABLE WHERE ... END-EXEC.

      MOVE 0 TO AMT.
      EXEC SQL LOB READ :AMT FROM :VLOB1 AT :OFFSET INTO :BUFFER END-EXEC.

 READ-LOOP.
      EXEC SQL LOB READ :AMT FROM :CLOB1 INTO BUFFER $END-EXEC.
      GO TO READ-LOOP.

 END-OF-CLOB.     
      EXEC SQL WHENEVER NOT FOUND CONTINUE END-EXEC.

      EXEC SQL FREE :CLOB1 END-EXEC.
</pre>
<p>The following code outline writes data from a buffer into an internal CLOB. The value of AMT (16 characters) in the initial write statement should be the length of the entire data you will write. The buffer is 5 characters long.</p>
<p>If EOF is read in the initial read, then do the LOB WRITE ONE. If not, start polling with a LOB WRITE FIRST of the buffer. Read the data, and do a LOB WRITE NEXT of the output. No offset is needed in the LOB WRITE NEXT because data is written at the end of the last write. After EOF is read, break out of the read loop and do a LOB WRITE LAST. The amount returned must equal the initial amount value (16).</p>
<pre>     MOVE 16 TO AMT.
     PERFORM READ-NEXT-RECORD.
     MOVE INREC TO BUFFER-ARR.
     MOVE 5 TO BUFFER-LEN.
     IF (END-OF-FILE = &#34;Y&#34;)
         EXEC SQL LOB WRITE ONE :AMT FROM :BUFFER INTO CLOB1 
            AT :OFFSET END-EXEC.
         PERFORM DISPLAY-CLOB
     ELSE
         EXEC SQL LOB WRITE FIRST :AMT FROM :BUFFER INTO :CLOB1
            AT :OFFSET END-EXEC.
     PERFORM READ-NEXT-RECORD.
     PERFORM WRITE-TO-CLOB 
        UNTIL END-OF-FILE = &#34;Y&#34;.
     MOVE INREC TO BUFFER-ARR.
     MOVE 1 TO BUFFER-LEN.
     EXEC SQL LOB WRITE LAST :AMT FROM :BUFFER INTO :CLOB1 END-EXEC.
     PERFORM DISPLAY-CLOB.
     ...
 WRITE-TO-CLOB.
     MOVE INREC TO BUFFER-ARR.
     MOVE 5 TO BUFFER-LEN.
     EXEC SQL LOB WRITE NEXT :AMT FROM :BUFFER INTO :CLOB1 END-EXEC.
     PERFORM READ-NEXT RECORD.

 READ-NEXT-RECORD.
     MOVE SPACES TO INREC.
     READ INFILE NEXT RECORD
        AT END
        MOVE &#34;Y&#34; TO END-OF-FILE.
 ...
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006967"></a>
<div id="LNPCB963" class="sect1">
<h2 class="sect1">LOB Sample Program: LOBDEMO1.PCO<a id="sthref1715"></a><a id="sthref1716"></a></h2>
<p>The LOBDEMO1.PCO program illustrates several LOB embedded SQL statements. The source code is in your <code>demo</code> directory. The application uses a table named <code>license_table</code> whose columns are social security number, name, and a CLOB containing text summarizing driving offenses. Several simplified SQL operations of a typical motor vehicle department are modeled.</p>
<p>The possible actions are:</p>
<ul>
<li>
<p>Add new records.</p>
</li>
<li>
<p>List records by social security number.</p>
</li>
<li>
<p>List information in a record, given a social security number.</p>
</li>
<li>
<p>Append a new traffic violation to an existing CLOB&#39;s contents.</p>
</li>
</ul>
<p>Here is the listing of LOBDEMO1.PCO:</p>
<pre>      *********************************************************************
      * LOB Demo 1: DMV Database                                          *
      *                                                                   *
      * SCENARIO:                                                         *
      *                                                                   *
      * We consider the example of a database used to store driver&#39;s      *
      * licenses. The licenses are stored as rows of a table containing   *
      * three columns: the sss number of a person, his/her name and the   *
      * text summary of the info found in his license.                    *
      *                                                                   *
      * The sss number and the name are the unique social security number *
      * and name of an individual.  The text summary is a summary of the  *
      * information on the individual, including his driving record,      *
      * which can be arbitrarily long and may contain comments and data   *
      * regarding the person&#39;s driving ability.                           *
      *                                                                   *
      * APPLICATION OVERVIEW:                                             *
      *                                                                   *
      * This example demonstrate how a Pro*COBOL client can handle the    *
      * new LOB datatypes.  Demonstrated are the mechanisms for accessing *
      * and storing lobs to/from tables.                                  *
      *                                                                   *
      *  To run the demo:                                                 *
      *                                                                   *
      *  1. Execute the script, lobdemo1.sql in Server Manager            *
      *  2. Precompile using Pro*COBOL                                    *
      *       procob lobdemo1                                             *
      *  3. Compile/Link (This step is platform specific)                 *
      *                                                                   *
      * lobdemo1.sql contains the following SQL statements:               *
      *                                                                   *
      * connect scott/tiger;                                              *
      *                                                                   *
      * drop table license_table;                                         *
      *                                                                   *
      * create table license_table(                                       *
      * sss char(9),                                                      *
      * name varchar2(50),                                                *
      * txt_summary clob);                                                *
      *                                                                   *
      * insert into license_table                                         *
      *  values(&#39;971517006&#39;, &#39;Dennis Kernighan&#39;,                          *
      *  &#39;Wearing a Bright Orange Shirt&#39;);                                *
      *                                                                   *
      * insert into license_table                                         *
      *  values(&#39;555001212&#39;, &#39;Eight H. Number&#39;,                           *
      *  &#39;Driving Under the Influence&#39;);                                  *
      *                                                                   *
      * insert into license_table                                         *
      *  values(&#39;010101010&#39;, &#39;P. Doughboy&#39;,                               *
      *  &#39;Impersonating An Oracle Employee&#39;);                             *
      *                                                                   *
      * insert into license_table                                         *
      *  values(&#39;555377012&#39;, &#39;Calvin N. Hobbes&#39;,                          *
      *  &#39;Driving Under the Influence&#39;);                                  *
      *                                                                   *
      * The main program provides the menu of actions that can be         *
      * performed.  The program stops when the number 5 (Quit) option     *
      * is entered.  Depending on the input, this main program calls      *
      * the appropriate nested program to execute the chosen action.      *
      *                                                                   *
      *********************************************************************
       IDENTIFICATION DIVISION.
       PROGRAM-ID.  LOBDEMO1.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  USERNAME       PIC X(5).
       01  PASSWD         PIC X(5).
       01  CHOICE         PIC 9 VALUE 0.
       01  SSS            PIC X(9).
       01  SSSEXISTS      PIC 9 VALUE ZERO.
       01  LICENSE-TXT    SQL-CLOB .
       01  NEWCRIME       PIC X(35) VARYING.
       01  SSSCOUNT       PIC S9(4) COMP.
       01  THE-STRING    PIC X(200) VARYING.
       01  TXT-LENGTH    PIC S9(9) COMP.
       01  CRIMES.
           05 FILLER PIC X(35) VALUE &#34;Driving Under the Influence&#34;.
           05 FILLER PIC X(35) VALUE &#34;Grand Theft Auto&#34;.
           05 FILLER PIC X(35) VALUE &#34;Driving Without a License&#34;.
           05 FILLER PIC X(35) VALUE 
                  &#34;Impersonating an Oracle Employee&#34;.
           05 FILLER PIC X(35) VALUE &#34;Wearing a Bright Orange Shirt&#34;.
       01  CRIMELIST REDEFINES CRIMES.
           05 CRIME  PIC X(35) OCCURS 5 TIMES.
       01  CRIME-INDEX   PIC 9.
       01  TXT-LEN       PIC S9(9) COMP.
       01  CRIME-LEN     PIC S9(9) COMP.
       01  NAME1         PIC X(50) VARYING.
       01  NEWNAME         PIC X(50).
      *********************************************************************

           EXEC SQL INCLUDE SQLCA END-EXEC.

       PROCEDURE DIVISION.
       A000-CONTROL SECTION.
      *********************************************************************
      *  A000-CONTROL
      *     Overall control section 
      *********************************************************************
       A000-CNTRL.
              EXEC SQL 
                WHENEVER SQLERROR DO PERFORM Z900-SQLERROR 
              END-EXEC.
              PERFORM B000-LOGON.
              PERFORM C000-MAIN UNTIL CHOICE = 5.
              PERFORM D000-LOGOFF.
       A000-EXIT.
              STOP RUN.

       B000-LOGON SECTION.
      *********************************************************************
      *  B000-LOGON
      *    Log on to database.
      *********************************************************************
       B000-LGN.
           DISPLAY &#39;**************************************************&#39;.
           DISPLAY &#39;*            Welcome to the DMV Database         *&#39;.
           DISPLAY &#39;**************************************************&#39;.
           MOVE &#34;scott&#34; TO USERNAME.
           MOVE &#34;tiger&#34; TO PASSWD.
           EXEC SQL
              CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;Connecting to license database account:  &#34;, 
              USERNAME, &#34;/&#34;, PASSWD.
           DISPLAY &#34; &#34;.
       B000-EXIT.
           EXIT.
       C000-MAIN SECTION.
      *********************************************************************
      *  C000-MAIN
      *    Display the main menu and action requests   
      *********************************************************************
       C000-MN.

           DISPLAY &#34; &#34;.
           DISPLAY &#34;License Options:&#34;.
           DISPLAY &#34;1. List available records by SSS number&#34;.
           DISPLAY &#34;2. Get information on a particular record&#34;.
           DISPLAY &#34;3. Add crime to a record&#34;.
           DISPLAY &#34;4. Insert new record to database&#34;.
           DISPLAY &#34;5. Quit&#34;.
           DISPLAY &#34; &#34;.
 
           MOVE ZERO TO CHOICE.
           PERFORM Z300-ACCEPT-CHOICE UNTIL CHOICE &lt; 6 
                                   AND CHOICE &gt; 0.
           IF (CHOICE = 1)
              PERFORM C100-LIST-RECORDS.
           IF (CHOICE = 2)
               PERFORM C200-GET-RECORD.
           IF (CHOICE = 3)
               PERFORM C300-ADD-CRIME.
           IF (CHOICE = 4)
               PERFORM C400-NEW-RECORD.
        C000-EXIT.
           EXIT.
       
        C100-LIST-RECORDS SECTION.
      *********************************************************************
      *  C100-LIST-RECORDS
      *   Select  Social Security Numbers from LICENCSE_TABLE
      *   and display the list
      *********************************************************************
        C100-LST.

           EXEC SQL DECLARE SSS_CURSOR CURSOR FOR 
                        SELECT SSS FROM LICENSE_TABLE
           END-EXEC.
 
           EXEC SQL OPEN SSS_CURSOR END-EXEC.
 
           DISPLAY &#34;Available records:&#34;.

           PERFORM C110-DISPLAY-RECORDS UNTIL SQLCODE = 1403.
           EXEC SQL CLOSE SSS_CURSOR END-EXEC.
       C100-EXIT.
           EXIT. 
       C110-DISPLAY-RECORDS SECTION.
      *********************************************************************
      *  C110-DISPLAY-RECORDS
      *    Fetch the next record from the cursor and display it.
      *********************************************************************
       C110-DSPLY.
            EXEC SQL FETCH SSS_CURSOR INTO :SSS END-EXEC.
            IF SQLCODE = 0 THEN
                DISPLAY SSS.
       C110-EXIT.
            EXIT. 

       C200-GET-RECORD SECTION.
      *******************************************************************
      *  C200-GET-RECORD
      *    Allocates the global clob LICENSE-TXT then selects 
      *    the name and text which corresponds to the client-supplied
      *    sss.  It then calls Z200-PRINTCRIME to print the information and
      *    frees the clob.
      *******************************************************************
       C200-GTRECRD.
           PERFORM Z100-GET-SSS.
           IF (SSSEXISTS = 1)
             EXEC SQL ALLOCATE :LICENSE-TXT END-EXEC
             EXEC SQL SELECT NAME, TXT_SUMMARY 
                  INTO :NAME1, :LICENSE-TXT FROM LICENSE_TABLE 
                  WHERE SSS = :SSS END-EXEC
             DISPLAY &#34;==================================================
      -         &#34;========================&#34;
             DISPLAY &#34; &#34;
             DISPLAY &#34;NAME:  &#34;, NAME1-ARR, &#34;SSS:  &#34;, SSS
             DISPLAY &#34; &#34;
             PERFORM Z200-PRINTCRIME       
             DISPLAY &#34; &#34;
             DISPLAY &#34;==================================================
      -         &#34;========================&#34;
             EXEC SQL FREE :LICENSE-TXT END-EXEC
           ELSE
              DISPLAY &#34;SSS Number Not Found&#34;.
       C200-EXIT.
           EXIT.
       C310-GETNEWCRIME SECTION.
      *******************************************************************
      *  C310-GETNEWCRIME
      *    Provides a list of the possible crimes to the user and
      *    stores the user&#39;s correct response in the variable
      *    NEWCRIME.
      *******************************************************************
       C310-GTNWCRM.

            EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           
            DISPLAY &#34; &#34;.
            DISPLAY &#34;Select from the following:&#34;.
            PERFORM C311-DISPLAY-CRIME
              VARYING CRIME-INDEX FROM 1 BY 1
              UNTIL CRIME-INDEX &gt; 5.
            MOVE ZERO TO CHOICE.
            PERFORM Z300-ACCEPT-CHOICE UNTIL CHOICE &lt; 6
                                  AND CHOICE &gt; 0.
            MOVE CRIME(CHOICE) TO NEWCRIME-ARR.
            MOVE 35 TO NEWCRIME-LEN.
            MOVE ZERO TO CHOICE.
       C310-EXIT.
            EXIT.
       C311-DISPLAY-CRIME SECTION.
      *******************************************************************
      *   C311-DISPLAY-CRIME
      *      Display an element of the crime table
      *******************************************************************
       C311-DSPLYCRM.
           DISPLAY &#34;(&#34;, CRIME-INDEX, &#34;) &#34;, CRIME(CRIME-INDEX).
       C311-EXIT.
            EXIT.
       C320-APPENDTOCLOB SECTION.
      *******************************************************************
      * C320-APPENDTOCLOB
      *    Obtains the length of the global clob LICENSE-TXT and
      *    uses that in the LOB WRITE statement to append the NEWCRIME
      *    character buffer to the global clob LICENSE-TXT.
      *    The name corresponding the global SSS is then selected
      *    and displayed to the screen along with value of LICENSE-TXT.
      *    The caller to this function must allocate, select and later
      *    free the global clob LICENSE-TXT.
      *******************************************************************
       C320-PPNDTCLB.

           EXEC SQL 
                WHENEVER SQLERROR DO PERFORM Z900-SQLERROR 
           END-EXEC.

           EXEC SQL LOB DESCRIBE :LICENSE-TXT GET LENGTH
               INTO :TXT-LEN END-EXEC.

           MOVE NEWCRIME-LEN TO CRIME-LEN.
           IF (TXT-LEN NOT = 0)
             ADD 3 TO TXT-LEN
           ELSE
             ADD 1 TO TXT-LEN.
           EXEC SQL LOB WRITE :CRIME-LEN FROM :NEWCRIME
                 INTO :LICENSE-TXT AT :TXT-LEN END-EXEC.

           EXEC SQL SELECT NAME INTO :NAME1 FROM LICENSE_TABLE 
               WHERE SSS = :SSS END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;NAME:  &#34;, NAME1-ARR, &#34;SSS:  &#34;, SSS.
           DISPLAY &#34; &#34;.
           PERFORM Z200-PRINTCRIME.       
           DISPLAY &#34; &#34;.          

       C320-EXIT.
          EXIT.
 
       C300-ADD-CRIME SECTION.
      *******************************************************************
      * ADD-CRIME
      *    Obtains a sss and crime from the user and appends
      *    the crime to the list of crimes of the corresponding sss.
      *******************************************************************
       C300-DDCRM.

           EXEC SQL 
              WHENEVER SQLERROR DO PERFORM Z900-SQLERROR 
           END-EXEC.

           PERFORM Z100-GET-SSS.
           IF (SSSEXISTS = 1)
             EXEC SQL ALLOCATE :LICENSE-TXT END-EXEC
             PERFORM C310-GETNEWCRIME       
             EXEC SQL SELECT TXT_SUMMARY INTO :LICENSE-TXT
                  FROM LICENSE_TABLE WHERE SSS = :SSS 
                  FOR UPDATE END-EXEC
             PERFORM C320-APPENDTOCLOB
             EXEC SQL FREE :LICENSE-TXT END-EXEC
           ELSE
              DISPLAY &#34;SSS Number Not Found&#34;.
       C300-EXIT.
           EXIT.

       C400-NEW-RECORD SECTION.
      *******************************************************************
      * C400-NEW-RECORD
      *    Obtains the sss and name of a new record and inserts them
      *    along with an empty_clob() for the clob in the table.
      *******************************************************************
       C400-NWRCRD.

           PERFORM Z100-GET-SSS.
           IF (SSSEXISTS = 1)
             DISPLAY &#34;Record with that sss number already exists&#34;
           ELSE
             DISPLAY &#34;Name? &#34; WITH NO ADVANCING
             ACCEPT NEWNAME
             DISPLAY &#34; &#34;.
             EXEC SQL ALLOCATE :LICENSE-TXT END-EXEC
             EXEC SQL INSERT INTO LICENSE_TABLE
                  VALUES (:SSS, :NEWNAME, EMPTY_CLOB()) END-EXEC
             EXEC SQL SELECT TXT_SUMMARY INTO :LICENSE-TXT
                  FROM LICENSE_TABLE WHERE SSS = :SSS END-EXEC
             DISPLAY &#34;==================================================
      -         &#34;========================&#34;
             DISPLAY &#34;NAME: &#34;, NEWNAME,&#34;SSS: &#34;, SSS
             PERFORM Z200-PRINTCRIME
             DISPLAY &#34;==================================================
      -         &#34;========================&#34;
             EXEC SQL FREE :LICENSE-TXT END-EXEC.
       C400-EXIT.
          EXIT.
       D000-LOGOFF SECTION.
      *******************************************************************
      *  D000-LOGOFF
      *    Commit the work done to the database and log off
      *******************************************************************
       D000-LGFF.
           EXEC SQL COMMIT WORK RELEASE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY!&#34;.
           DISPLAY &#34; &#34;.
       D000-EXIT.
           STOP RUN.
       Z100-GET-SSS SECTION.
      *******************************************************************
      *  Z100-GET-SSS
      *    Fills the global variable SSS with the client-supplied sss.
      *    Sets the global variable SSSEXISTS to 0 if the sss does not 
      *    correspond to any entry in the database, else sets it to 1.
      *******************************************************************
       Z100-GTSSS.
           DISPLAY &#34;Social Security Number? &#34; WITH NO ADVANCING.
           ACCEPT SSS.
           DISPLAY &#34; &#34;.
          
           EXEC SQL SELECT COUNT(*) INTO :SSSCOUNT FROM LICENSE_TABLE
               WHERE SSS = :SSS END-EXEC.
           
           IF (SSSCOUNT = 0)
              MOVE 0 TO SSSEXISTS
           ELSE 
              MOVE 1 TO SSSEXISTS.
       Z100-EXIT.
          EXIT.
       Z200-PRINTCRIME SECTION.
      *******************************************************************
      *  Z200-PRINTCRIME
      *    Obtains the length of the global clob LICENSE-TXT and
      *    uses that in the LOB READ statement to read the clob
      *    into a character buffer to display the contents of the clob.
      *    The caller to this function must allocate, select and later
      *    free the global clob LICENSE-TXT.
      *******************************************************************
       Z200-PRNTCRM.
           DISPLAY &#34;=====================&#34;.
           DISPLAY &#34; CRIME SHEET SUMMARY &#34;.
           DISPLAY &#34;=====================&#34;.

           MOVE SPACE TO THE-STRING-ARR.
           EXEC SQL LOB DESCRIBE :LICENSE-TXT GET LENGTH
               INTO :TXT-LENGTH END-EXEC.

           IF (TXT-LENGTH = 0)
              DISPLAY &#34;Record is clean&#34;
            ELSE
              EXEC SQL LOB READ :TXT-LENGTH FROM :LICENSE-TXT
                 INTO :THE-STRING END-EXEC
              DISPLAY THE-STRING-ARR.

       Z200-EXIT.
           EXIT.
       Z300-ACCEPT-CHOICE SECTION.
      *******************************************************************
      *   Z300-ACCEPT-CHOICE
      *      Accept a choice between 1 and 5
      *******************************************************************
       Z300-CCPT.
           DISPLAY &#34;Your Selection (1-5)? &#34; WITH NO ADVANCING.
           ACCEPT CHOICE.
           DISPLAY &#34; &#34;.
           IF CHOICE &gt;5 OR CHOICE &lt; 1 THEN
              DISPLAY &#34;Invalid Selection&#34;
              DISPLAY &#34;Please Choose from the indicated list&#34;.
       Z300-EXIT.
          EXIT.
       
       Z900-SQLERROR SECTION.
      *******************************************************************
      * Z900-SQLERROR
      *    Called whenever a SQLERROR occurs.
      *    Display the Error, Roll Back any work done and Log Off
      *******************************************************************
       Z900-SQLRRR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
       Z900-EXIT.
           STOP RUN.
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pco12thr.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pco14opt.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>


</body></html>