<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77853"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Precompiler%20Concepts"></a><title>Precompiler Concepts</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:12Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pco01int.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pco03dbc.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/27</span> <!-- End Header -->
<div id="LNPCB002" class="chapter"><a id="g19644"></a> <a id="i2443"></a>
<h1 class="chapter"><span class="secnum">2</span> Precompiler Concepts</h1>
<p>This chapter explains how embedded SQL programs do their work. It presents definitions of important words, explanations of basic concepts, and key rules.</p>
<p>Topics covered are:</p>
<ul>
<li>
<p><a href="#i7199">Key Concepts of Embedded SQL Programming</a></p>
</li>
<li>
<p><a href="#i5683">Programming Guidelines</a></p>
</li>
<li>
<p><a href="#i6521">The Declare Section</a></p>
</li>
<li>
<p><a href="#i5979">Nested Programs</a></p>
</li>
<li>
<p><a href="#i6391">Conditional Precompilations</a></p>
</li>
<li>
<p><a href="#i6313">Separate Precompilations</a></p>
</li>
<li>
<p><a href="#CHDBIHHF">Compiling and Linking</a></p>
</li>
<li>
<p><a href="#i2226">Sample DEPT and EMP Tables</a></p>
</li>
<li>
<p><a href="#i3228">Sample EMP Program: SAMPLE1.PCO</a></p>
</li>
</ul>
<a id="i7199"></a>
<div id="LNPCB126" class="sect1">
<h2 class="sect1">Key Concepts of Embedded SQL Programming</h2>
<p>This section lays the conceptual foundation on which later chapters build. <a id="sthref32"></a></p>
<a id="i6760"></a>
<div id="LNPCB127" class="sect2">
<h3 class="sect2">Steps in Developing an Embedded SQL Application<a id="sthref33"></a></h3>
<p>Precompiling results in a source file that can be compiled normally. Although precompiling adds a step to the traditional development process, that step is well worth taking because it lets you write very flexible applications.</p>
<p><a href="#i6767">Figure 2-1</a> walks you through the embedded SQL application development process:</p>
<div id="LNPCB128" class="figure">
<p class="titleinfigure"><a id="i6767"></a>Figure 2-1 Application Development Process</p>
<img width="605" height="502" src="img/pco81050.gif" alt="Development Process"/><br/>
<a id="sthref34" href="img_text/pco81050.htm">Description of &#34;Figure 2-1 Application Development Process&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCB129" class="sect2"><a id="sthref35"></a>
<h3 class="sect2">Embedded SQL Statements</h3>
<p>The term <span class="italic">embedded SQL</span> refers to SQL statements placed within an application program. Because the application program houses the SQL statements, it is called a <span class="italic">host program</span>, and the language in which it is written is called the <span class="italic">host language</span>. For example, with Pro*COBOL you can embed SQL statements in a COBOL host program.<a id="sthref36"></a><a id="sthref37"></a></p>
<p>To manipulate and query Oracle data, you use the INSERT, UPDATE, DELETE, and SELECT statements. INSERT adds rows of data to database tables, UPDATE modifies rows, DELETE removes unwanted rows, and SELECT retrieves rows that meet your search criteria.</p>
<p>Only SQL statements&mdash;not SQL*Plus statements&mdash;are valid in an application program. (SQL*Plus has additional statements for setting environment parameters, editing, and report formatting.)</p>
<div id="LNPCB130" class="sect3"><a id="sthref38"></a>
<h4 class="sect3">Executable versus Declarative Statements</h4>
<p>Embedded SQL includes all the interactive SQL statements plus others that allow you to transfer data between Oracle and a host program. There are two types of embedded SQL statements: <span class="italic">executable statements</span> and <span class="italic">directives</span>.</p>
<p>Executable SQL statements generate calls to the database. They include almost all queries, Data Manipulation Language (DML), data definition language (DDL), and Data Control Language (DCL) statements.</p>
<p><span class="italic">Directives</span>, on the other hand, do not result in calls to SQLLIB and do not operate on Oracle data.</p>
<p><a id="sthref39"></a><a id="sthref40"></a>You use directives to declare Oracle objects, communications areas, and SQL variables. They can be placed wherever COBOL declarations can be placed.<a id="sthref41"></a></p>
<p><a href="pcoafemb.htm#g65199">Appendix E, &#34;Embedded SQL Statements and Precompiler Directives&#34;</a> contains a presentation of the most important statements and directives. <a href="#g14502">Table 2-1</a> groups some examples of embedded SQL statements (not a complete list.)</p>
<div id="LNPCB131" class="tblformal">
<p class="titleintable"><a id="sthref42"></a><a id="g14502"></a>Table 2-1 Embedded SQL Statements</p>
<table class="cellalignment4971" title="Embedded SQL Statements " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t2"><span class="bold">Directives</span></th>
<th class="cellalignment4972" id="r1c2-t2"><br/></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t2" headers="r1c1-t2">
<p><span class="bold">STATEMENT</span></p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c2-t2">
<p><span class="bold">PURPOSE</span></p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t2" headers="r1c1-t2">
<p>ARRAYLEN*</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c2-t2">
<p>To use host tables with PL/SQL</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t2" headers="r1c1-t2">
<p>BEGIN DECLARE SECTION*</p>
<p>END DECLARE SECTION*</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c2-t2">
<p>To declare host variables</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t2" headers="r1c1-t2">
<p>DECLARE*</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c2-t2">
<p>To name Oracle objects</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t2" headers="r1c1-t2">
<p>INCLUDE*</p>
</td>
<td class="cellalignment4973" headers="r6c1-t2 r1c2-t2">
<p>To copy in files</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t2" headers="r1c1-t2">
<p>VAR*</p>
</td>
<td class="cellalignment4973" headers="r7c1-t2 r1c2-t2">
<p>To equivalence variables</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t2" headers="r1c1-t2">
<p>WHENEVER*</p>
</td>
<td class="cellalignment4973" headers="r8c1-t2 r1c2-t2">
<p>To handle runtime errors</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t2" headers="r1c1-t2">
<p>Executable SQL</p>
</td>
<td class="cellalignment4973" headers="r9c1-t2 r1c2-t2">&nbsp;</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t2" headers="r1c1-t2">
<p>STATEMENT</p>
</td>
<td class="cellalignment4973" headers="r10c1-t2 r1c2-t2">
<p>PURPOSE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t2" headers="r1c1-t2">
<p>ALLOCATE*</p>
<p>ALTER</p>
<p>CONNECT*</p>
<p>CREATE</p>
<p>DROP</p>
<p>GRANT</p>
<p>NOAUDIT</p>
<p>RENAME</p>
<p>REVOKE</p>
<p>TRUNCATE</p>
</td>
<td class="cellalignment4973" headers="r11c1-t2 r1c2-t2">
<p>To define and control Oracle data</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t2" headers="r1c1-t2">
<p>CLOSE*</p>
<p>DELETE</p>
<p>EXPLAIN PLAN</p>
<p>FETCH*</p>
<p>INSERT</p>
<p>LOCK TABLE</p>
<p>OPEN*</p>
<p>SELECT</p>
<p>UPDATE</p>
</td>
<td class="cellalignment4973" headers="r12c1-t2 r1c2-t2">
<p>To query and manipulate Oracle data</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t2" headers="r1c1-t2">
<p>COMMIT</p>
<p>ROLLBACK</p>
<p>SAVEPOINT</p>
<p>SET TRANSACTION</p>
</td>
<td class="cellalignment4973" headers="r13c1-t2 r1c2-t2">
<p>To process transactions</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t2" headers="r1c1-t2">
<p>DESCRIBE*</p>
<p>EXECUTE*</p>
<p>PREPARE*</p>
</td>
<td class="cellalignment4973" headers="r14c1-t2 r1c2-t2">
<p>To use dynamic SQL</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t2" headers="r1c1-t2">
<p>ALTER SESSION</p>
<p>SET ROLE</p>
</td>
<td class="cellalignment4973" headers="r15c1-t2 r1c2-t2">
<p>To control sessions</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r16c1-t2" headers="r1c1-t2">
<p>*Has no interactive counterpart</p>
</td>
<td class="cellalignment4973" headers="r16c1-t2 r1c2-t2">&nbsp;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB135" class="sect2"><a id="sthref43"></a>
<h3 class="sect2">Embedded SQL Syntax</h3>
<p>In your application program, you can freely intermix SQL statements with host-language statements and use host-language variables in SQL statements. The only special requirement for building SQL statements into your host program is that you begin them with the words EXEC SQL and end them with the token END-EXEC. Pro*COBOL translates all executable EXEC SQL statements into calls to the runtime library SQLLIB.<a id="sthref44"></a><a id="sthref45"></a><a id="sthref46"></a><a id="sthref47"></a></p>
<p>Most embedded SQL statements differ from their interactive counterparts only through the addition of a new clause or the use of program variables. Compare the following interactive and embedded ROLLBACK statements:<a id="sthref48"></a></p>
<pre>ROLLBACK WORK;           -- interactive

* embedded
     EXEC SQL
         ROLLBACK WORK
     END-EXEC.
</pre>
<p>A period or any other terminator can follow a SQL statement. Either of the following is allowed:</p>
<pre>     EXEC SQL ... END-EXEC,
     EXEC SQL ... END-EXEC.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB136" class="sect2"><a id="sthref49"></a>
<h3 class="sect2">Static Versus Dynamic SQL Statements</h3>
<p>Most application programs are designed to process <span class="italic">static</span> SQL statements and fixed transactions. In this case, you know the makeup of each SQL statement and transaction before run time. That is, you know which SQL commands will be issued, which database tables might be changed, which columns will be updated, and so on.<a id="sthref50"></a><a id="sthref51"></a> See <a href="pco05sql.htm#g16518">Chapter 5, &#34;Embedded SQL&#34;</a>.</p>
<p>However, some applications are required to accept and process any valid SQL statement at run time. In this case you might not know until run time all the SQL commands, database tables, and columns involved.</p>
<p><span class="italic">Dynamic</span> SQL is an advanced programming technique that lets your program accept or build SQL statements at run time and take explicit control over datatype conversion. See <a href="pco09dyn.htm#g19788">Chapter 9, &#34;Oracle Dynamic SQL&#34;</a>, <a href="pco10ady.htm#g1024116">Chapter 10, &#34;ANSI Dynamic SQL&#34;</a>, and <a href="pco11ody.htm#i9695">Chapter 11, &#34;Oracle Dynamic SQL: Method 4&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB137" class="sect2"><a id="sthref52"></a>
<h3 class="sect2">Embedded PL/SQL Blocks</h3>
<p>Pro*COBOL treats a PL/SQL block like a single embedded SQL statement, so you can place a PL/SQL block anywhere in an application program that you can place a SQL statement. To embed PL/SQL in your host program, you simply declare the variables to be shared with PL/SQL and bracket the PL/SQL block with the keywords EXEC SQL EXECUTE and END-EXEC.<a id="sthref53"></a></p>
<p>From embedded PL/SQL blocks, you can manipulate Oracle data flexibly and safely because PL/SQL supports all SQL data manipulation and transaction processing commands. For more information about PL/SQL, see <a href="pco06pls.htm#g33607">Chapter 6, &#34;Embedded PL/SQL&#34;</a>.<a id="sthref54"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB138" class="sect2"><a id="sthref55"></a>
<h3 class="sect2">Host Variables and Indicator Variables</h3>
<p>A <span class="italic">host variable</span> is a scalar or table variable or group item declared in the COBOL language and shared with Oracle, meaning that both your program and Oracle can reference its value. Host variables are the key to communication between Oracle and your program. <a id="sthref56"></a></p>
<p>You use <span class="italic">input</span> host variables to pass data to the database. You use <span class="italic">output</span> host variables to pass data and status information from the database to your program.<a id="sthref57"></a></p>
<p>Host variables can be used anywhere an expression can be used. In SQL statements, host variables must be prefixed with a colon &#39;:&#39; to set them apart from database schema names.<a id="sthref58"></a><a id="sthref59"></a></p>
<p>You can associate any host variable with an optional indicator variable. An <span class="italic">indicator variable</span> is an integer variable that indicates the value or condition of its host variable. A <span class="italic">NULL</span> is a missing, an unknown, or an inapplicable value. You use indicator variables to assign NULLs to input host variables and to detect NULLs in output variables or truncated values in output character host variables. <a id="sthref60"></a></p>
<p>A host variable must <span class="italic">not</span> be:</p>
<ul>
<li>
<p>prefixed with a colon in COBOL statements</p>
</li>
<li>
<p>used in data definition (DDL) statements such as ALTER and CREATE</p>
</li>
</ul>
<p>In SQL statements, an indicator variable must be prefixed with a colon and appended to its associated host variable (to improve readability, you can precede the indicator variable with the optional keyword INDICATOR).</p>
<p>Every program variable used in a SQL statement must be declared according to the rules of the COBOL language. Normal rules of scope apply. COBOL variable names can be any length, but only the first 30 characters are significant for Pro*COBOL<a id="sthref61"></a><a id="sthref62"></a><a id="sthref63"></a><a id="sthref64"></a><a id="sthref65"></a><a id="sthref66"></a>. Any valid COBOL identifier can be used as a host variable identifier, including those beginning with digits.</p>
<p>The external datatype of a host variable and the internal datatype of its source or target database column need not be the same, but they must be compatible. <a href="pco04dat.htm#g46570">Table 4-9, &#34;Conversions Between Internal and External Datatypes&#34;</a> shows the compatible datatypes between which Oracle converts automatically when necessary.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB139" class="sect2"><a id="sthref67"></a>
<h3 class="sect2">Oracle Datatypes</h3>
<p>Typically, a host program inputs data to the database, and the database outputs data to the program. Oracle inserts input data into database tables and selects output data into program host variables. To store a data item, Oracle must know its <span class="italic">datatype</span>, which specifies a storage format and valid range of values.</p>
<p>Oracle recognizes two kinds of datatypes: <span class="italic">internal</span> and <span class="italic">external</span>. Internal datatypes specify how Oracle stores data in database columns. Oracle also uses internal datatypes to represent database pseudo-columns, which return specific data items but are not actual columns in a table.<a id="sthref68"></a><a id="sthref69"></a></p>
<p>External datatypes specify how data is stored in host variables. When your host program inputs data to Oracle, it does any conversion between the external datatype of the input host variable and the internal datatype of the database column. When Oracle outputs data to your host program, if necessary, Oracle converts between the internal datatype of the database column and the external datatype of the output host variable.<a id="sthref70"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can override default datatype conversions by using dynamic SQL Method 4 or datatype equivalencing. For information about datatype equivalencing, see <a href="pco04dat.htm#i21911">&#34;Explicit Control Over DATE String Format&#34;</a>.</div>
</div>
<!-- class="sect2" -->
<div id="LNPCB140" class="sect2"><a id="sthref71"></a>
<h3 class="sect2">Tables</h3>
<p>Pro*COBOL lets you define table host variables (called <span class="italic">host tables</span>) and operate on them with a single SQL statement. Using the SELECT, FETCH, DELETE, INSERT, and UPDATE statements, you can query and manipulate large volumes of data with ease.<a id="sthref72"></a></p>
<p>For a complete discussion of host tables, see <a href="pco07tab.htm#g12783">Chapter 7, &#34;Host Tables&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i2019"></a>
<div id="LNPCB141" class="sect2">
<h3 class="sect2">Errors and Warnings</h3>
<p>When you execute an embedded SQL statement, it either succeeds or fails, and might result in an error or warning. You need a way to handle these results. Pro*COBOL provides the following error handling mechanisms:<a id="sthref73"></a></p>
<ul>
<li>
<p>SQLCODE status variable</p>
</li>
<li>
<p>SQLSTATE status variable</p>
</li>
<li>
<p>SQL Communications Area (SQLCA)</p>
</li>
<li>
<p>WHENEVER statement</p>
</li>
<li>
<p>Oracle Communications Area (ORACA)</p>
</li>
</ul>
<div id="LNPCB142" class="sect3"><a id="sthref74"></a>
<h4 class="sect3">SQLCODE/SQLSTATE Status Variables</h4>
<p>After executing a SQL statement, the Oracle Server returns a status code to a variable named SQLCODE or SQLSTATE. The status code indicates whether the SQL statement executed successfully or caused an error or warning condition.</p>
</div>
<!-- class="sect3" -->
<a id="i6891"></a>
<div id="LNPCB143" class="sect3">
<h4 class="sect3">SQLCA Status Variable</h4>
<p>The SQLCA is a data structure that defines program variables used by Oracle to pass runtime status information to the program. With the SQLCA, you can take different actions based on feedback from Oracle about work just attempted. For example, you can check to see if a DELETE statement succeeded and, if so, how many rows were deleted.<a id="sthref75"></a></p>
<p>The SQLCA provides for diagnostic checking and event handling. At runtime, the SQLCA holds status information passed to your program by Oracle. After executing a SQL statement, Oracle sets SQLCA variables to indicate the outcome, as illustrated in <a href="#i6729">Figure 2-2</a>.</p>
<div id="LNPCB144" class="figure">
<p class="titleinfigure"><a id="i6729"></a>Figure 2-2 Updating the SQLCA</p>
<img width="605" height="447" src="img/pco81051.gif" alt="Updating the SQLCA"/><br/>
<a id="sthref76" href="img_text/pco81051.htm">Description of &#34;Figure 2-2 Updating the SQLCA&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>You can check to see if an INSERT, UPDATE, or DELETE statement succeeded and if it did, how many rows were affected. Or, if the statement failed, you can get more information about what happened.<a id="sthref77"></a><a id="sthref78"></a></p>
<p>When MODE={ANSI13 | ORACLE}, you must declare the SQLCA by hard-coding it or by copying it into your program with the INCLUDE statement. The section <a href="pco08err.htm#i16095">&#34;Using the SQL Communications Area&#34;</a> shows you how to declare and use the SQLCA.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB145" class="sect3"><a id="sthref79"></a>
<h4 class="sect3">WHENEVER Statement</h4>
<p>With the WHENEVER statement, you can specify actions to be taken automatically when Oracle detects an error or warning condition. These actions include continuing with the next statement, calling a subprogram, branching to a labeled statement, performing a paragraph, or stopping.<a id="sthref80"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB146" class="sect3"><a id="sthref81"></a>
<h4 class="sect3">ORACA</h4>
<p>When more information is needed about runtime errors than the SQLCA provides, you can use the ORACA. The ORACA is a data structure that handles Oracle communication. It contains cursor statistics, information about the current SQL statement, option settings, and system statistics.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB147" class="sect3"><a id="sthref82"></a>
<h4 class="sect3">Precompiler Options and Error Handling</h4>
<p>Oracle returns the success or failure of SQL statements in status variables, SQLSTATE and SQLCODE. With precompiler option MODE=ORACLE, you use SQLCODE, declared by including SQLCA. With MODE=ANSI, either SQLSTATE or SQLCODE must be declared, but SQLCA is not necessary.</p>
<p>For more information, see <a href="pco08err.htm#i5309">Chapter 8, &#34;Error Handling and Diagnostics&#34;</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABCJDBD"></a>
<div id="LNPCB148" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQL99 Syntax Support</h3>
<p>The SQL standard enables the portability of SQL applications across all conforming software products. Oracle features are compliant with the ANSI/ISO SQL99 standard, including ANSI compliant joins. Pro*Cobol supports all SQL99 features that are supported by Oracle database, which means that the SQL99 syntax for the SELECT, INSERT, DELETE, and UPDATE statements and the body of the cursor in a DECLARE CURSOR statement are supported.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5683"></a>
<div id="LNPCB149" class="sect1">
<h2 class="sect1">Programming Guidelines</h2>
<p>This section deals with embedded SQL syntax, coding conventions, and Pro*COBOL-specific features and restrictions. Topics are arranged alphabetically for quick reference.<a id="sthref83"></a><a id="sthref84"></a></p>
<div id="LNPCB150" class="sect2"><a id="sthref85"></a>
<h3 class="sect2">Abbreviations</h3>
<p>You can use the standard COBOL abbreviations, such as PIC for PICTURE IS and COMP for USAGE IS COMPUTATIONAL.<a id="sthref86"></a><a id="sthref87"></a><a id="sthref88"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB151" class="sect2"><a id="sthref89"></a>
<h3 class="sect2">Case-Insensitivity</h3>
<p>Pro*COBOL precompiler options and values as well as all EXEC SQL statements, inline commands, and COBOL statements are case-insensitive. The precompiler accepts both upper- and lower-case tokens.<a id="sthref90"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB152" class="sect2"><a id="sthref91"></a>
<h3 class="sect2">COBOL Versions Supported<a id="sthref92"></a></h3>
<p>&shy;&shy;<a id="sthref93"></a>Pro*COBOL supports the standard implementation of COBOL for your operating system (usually COBOL-85 or COBOL-74). Some platforms may support both COBOL implementations. For more information, see your Oracle system-specific documentation.</p>
</div>
<!-- class="sect2" -->
<a id="i5700"></a>
<div id="LNPCB153" class="sect2">
<h3 class="sect2">Coding Areas</h3>
<p><a id="sthref94"></a><a id="sthref95"></a><a id="sthref96"></a><a id="sthref97"></a>The precompiler option FORMAT, specifies the format of your source code. If you specify FORMAT=ANSI (the default), you are conforming as much as possible to the ANSI standard. In this format, columns 1 through 6 can contain an optional sequence number, and column 7 (indicator area) can indicate comments or continuation lines.</p>
<p>Division headers, section headers, paragraph names, FD and 01 statements begin in columns 8 through 11 (area A). Other statements, including EXEC SQL and EXEC ORACLE statements, must be placed in area B (columns 12 through 72). These guidelines for source code format can be overridden by your compiler&#39;s rules.</p>
<p>If you specify FORMAT=TERMINAL, COBOL statements can begin in column 1 (the left-most column), or column 1 can be the indicator area. This format is also subject to the rules of your compiler.</p>
<p>You can specify FORMAT=VARIABLE to allow Flexible B Area Length.</p>
<p>Consult your COBOL compiler documentation for your own platform to determine the actual acceptable formats for COBOL statements.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In this manual, COBOL code examples use the FORMAT=TERMINAL setting. The online sample programs in the demo directory use FORMAT=ANSI.<a id="sthref98"></a></div>
</div>
<!-- class="sect2" -->
<div id="LNPCB154" class="sect2"><a id="sthref99"></a>
<h3 class="sect2">Commas</h3>
<p>In SQL, you must use commas to separate list items, as the following example shows:</p>
<pre>     EXEC SQL SELECT ENAME, JOB, SAL
         INTO :EMP-NAME, :JOB-TITLE, :SALARY
         FROM EMP
         WHERE EMPNO = :EMP-NUMBER
     END-EXEC.
</pre>
<p>In COBOL, you can use commas or blanks to separate list items. For example, the following two statements are equivalent:</p>
<pre>     ADD AMT1, AMT2, AMT3 TO TOTAL-AMT. 
     ADD AMT1 AMT2 AMT3 TO TOTAL-AMT.  
</pre></div>
<!-- class="sect2" -->
<a id="i13421"></a>
<div id="LNPCB155" class="sect2">
<h3 class="sect2">Comments<a id="sthref100"></a></h3>
<p>You can place COBOL comment lines within SQL statements. COBOL comment lines start with an asterisk (*) in the indicator area.</p>
<p>You can also place ANSI SQL-style comments starting with &#34;-&thinsp;- &#34; within SQL statements at the end of a line (but not after the last line of the SQL statement).</p>
<p>COBOL comments continue for the rest of the line after these two characters: &#34;*&gt;&#34;.</p>
<p>You can place C-style comments (/* ... */) in SQL statements.</p>
<p>The following example shows all four styles of comments:<a id="sthref101"></a><a id="sthref102"></a><a id="sthref103"></a><a id="sthref104"></a></p>
<pre>     MOVE 12 TO DEPT-NUMBER. *&gt; This is the software development group.
     EXEC SQL SELECT ENAME, SAL 
*    assign column values to output host variables 
         INTO :EMP-NAME, :SALARY    -- output host variables 
     /*  column values assigned to output host variables */ 
         FROM EMP 
         WHERE DEPTNO = :DEPT-NUMBER 
     END-EXEC.    -- illegal Comment
</pre>
<p>You cannot nest comments or place them on the last line of a SQL statement after the terminator END-EXEC.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB156" class="sect2"><a id="sthref105"></a>
<h3 class="sect2">Continuation Lines<a id="sthref106"></a></h3>
<p>You can continue SQL statements from one line to the next, according to the rules of COBOL, as this example shows:<a id="sthref107"></a></p>
<pre>     EXEC SQL SELECT ENAME, SAL INTO :EMP-NAME, :SALARY FROM EMP 
         WHERE DEPTNO = :DEPT-NUMBER 
     END-EXEC. 
</pre>
<p>No continuation indicator is needed.</p>
<p>To continue a string literal from one line to the next, code the literal through column 72. On the next line, code a hyphen (-) in column 7, a quote in column 12 or beyond, and then the rest of the literal. An example follows:<a id="sthref108"></a><a id="sthref109"></a><a id="sthref110"></a></p>
<pre> WORKING STORAGE SECTION. 
     ... 
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
         ... 
 01  UPDATE-STATEMENT  PIC X(80) VALUE &#34;UPDATE EMP SET BON 
-               &#34;US = 500 WHERE DEPTNO = 20&#34;. 
     EXEC SQL END DECLARE SECTION END-EXEC.  
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB157" class="sect2"><a id="sthref111"></a>
<h3 class="sect2">Copy Statements</h3>
<p>Copy statements are not parsed by Pro*COBOL. Therefore, files included with the COPY command should not contain definitions of Host variables or contain embedded SQL statements. Instead, use the INCLUDE precompiler statement which is documented in <a href="#i7498">&#34;Using the INCLUDE Statement&#34;</a>. Be careful when using INCLUDE and also using DECLARE_SECTION=YES. Group items should be either placed all inside or all outside of a Declare Section.</p>
</div>
<!-- class="sect2" -->
<a id="i7510"></a>
<div id="LNPCB158" class="sect2">
<h3 class="sect2">Decimal-Point is Comma</h3>
<p>Pro*COBOL supports the DECIMAL-POINT IS COMMA clause in the ENVIRONMENT DIVISION. If the DECIMAL-POINT IS COMMA clause appears in the source file, then the comma will be allowed as the symbol beginning the decimal part of any numeric literals in the VALUE clauses.</p>
<p>For example, the following is allowed:</p>
<pre>            IDENTIFICATION DIVISION.
            PROGRAM-ID.  FOO
            ENVIRONMENT DIVISION.
            CONFIGURATION   SECTION.
            SPECIAL-NAMES.
                DECIMAL-POINT IS COMMA.                *&gt;  &lt;-- **
            DATA DIVISION.
            WORKING-STORAGE SECTION.
        ...
            01  WDATA1          PIC      S9V999 VALUE  +,567. *&gt;  &lt;--- **
            01  WDATA2          PIC      S9V999 VALUE  -,234. *&gt;  &lt;--- **
        ...
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB159" class="sect2"><a id="sthref112"></a>
<h3 class="sect2">Delimiters</h3>
<p>The LITDELIM option specifies the delimiters for COBOL string constants and literals. If you specify LITDELIM=APOST, Pro*COBOL uses apostrophes when generating COBOL code. If you specify LITDELIM=QUOTE (default), quotation marks are used, as in <a id="sthref113"></a><a id="sthref114"></a><a id="sthref115"></a></p>
<pre>     CALL &#34;SQLROL&#34; USING SQL-TMP0. 
</pre>
<p>In SQL statements, you must use quotation marks to delimit identifiers containing special or lowercase characters, as in</p>
<pre>     EXEC SQL CREATE TABLE &#34;Emp2&#34; END-EXEC.
 
</pre>
<p>However, you must use apostrophes to delimit string constants, as in</p>
<pre>     EXEC SQL SELECT ENAME FROM EMP WHERE JOB = &#39;CLERK&#39; END-EXEC.
 
</pre>
<p>Regardless of which delimiter is used in the Pro*COBOL source file, Pro*COBOL generates the delimiter specified by the LITDELIM value.</p>
</div>
<!-- class="sect2" -->
<a id="i7511"></a>
<div id="LNPCB160" class="sect2">
<h3 class="sect2">Division Headers that are Optional<a id="sthref116"></a></h3>
<p>The following division headers are optional:</p>
<ul>
<li>
<p>IDENTIFICATION DIVISION</p>
</li>
<li>
<p>ENVIRONMENT DIVISION</p>
</li>
<li>
<p>DATA DIVISION</p>
</li>
</ul>
<p>Note that the PROCEDURE DIVISION header is not optional. The following source can be precompiled:</p>
<pre>*IDENTIFICATION DIVISION header is optional
 PROGRAM-ID.     HELLO.
*ENVIRONMENT DIVISION header is optional
 CONFIGURATION SECTION.
*DATA DIVISION header is optional
 WORKING-STORAGE SECTION.
 PROCEDURE       DIVISION.
     DISPLAY &#34;Hello World!&#34;.
     STOP RUN.
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB161" class="sect2"><a id="sthref117"></a>
<h3 class="sect2">Embedded SQL Syntax</h3>
<p>To use a SQL statement in your Pro*COBOL program, precede the SQL statement with the EXEC SQL clause, and end the statement with the END-EXEC keyword. Embedded SQL syntax is described in the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span>.</a><a id="sthref118"></a><a id="sthref119"></a><a id="sthref120"></a><a id="sthref121"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB162" class="sect2"><a id="sthref122"></a>
<h3 class="sect2">Figurative Constants</h3>
<p>Figurative constants, such as HIGH-VALUE, ZERO, and SPACE, cannot be used in SQL statements. For example, the following is <span class="italic">invalid</span>:<a id="sthref123"></a><a id="sthref124"></a></p>
<pre>     EXEC SQL DELETE FROM EMP WHERE COMM = ZERO END-EXEC.
 
</pre>
<p>Instead, use the following:</p>
<pre>     EXEC SQL DELETE FROM EMP WHERE COMM = 0 END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB163" class="sect2"><a id="sthref125"></a>
<h3 class="sect2">File Length<a id="sthref126"></a></h3>
<p>Pro*COBOL cannot process arbitrarily long source files. Some of the variables used internally limit the size of the generated file. There is no absolute limit to the number of lines allowed, but the following aspects of the source file are contributing factors to the file-size constraint:</p>
<ul>
<li>
<p>Complexity of the embedded SQL statements (for example, the number of bind and define variables)</p>
</li>
<li>
<p>Whether a database name is used (for example, connecting to a database with an AT clause)</p>
</li>
<li>
<p>Number of embedded SQL statements</p>
</li>
</ul>
<p>To prevent problems related to this limitation, use multiple program units to sufficiently reduce the size of the source files.</p>
</div>
<!-- class="sect2" -->
<a id="i13419"></a>
<div id="LNPCB164" class="sect2">
<h3 class="sect2">FILLER is Allowed</h3>
<p>The word FILLER is allowed in host variable declarations. The word FILLER is used to specify an elementary item of a group that cannot be referred to explicitly. The following declaration is valid:</p>
<pre> 01  STOCK. 
     05  DIVIDEND     PIC X(5).
     05  FILLER       PIC X.
     05  PRICE        PIC X(6).
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB165" class="sect2"><a id="sthref127"></a>
<h3 class="sect2">Host Variable Names</h3>
<p>Any valid standard COBOL identifier can be used as a host variable. Variable names can be any length, but only the first 30 characters are significant. The maximum number of significant characters recognized by COBOL compilers is 30. <a id="sthref128"></a><a id="sthref129"></a><a id="sthref130"></a></p>
<p>For portability, you may wish to restrict the length of host variable names to 18 or fewer characters (the length mandated by the SQL standard).</p>
<p>For a list of words that have restrictions on their use in applications, see <a href="pcoacres.htm#g26115">Appendix B, &#34;Reserved Words, Keywords, and Namespaces&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB166" class="sect2"><a id="sthref131"></a>
<h3 class="sect2">Hyphenated Names</h3>
<p>You can use hyphenated host-variable names in static SQL statements but <span class="italic">not</span> in dynamic SQL. For example, the following usage is <span class="italic">invalid</span>:<a id="sthref132"></a><a id="sthref133"></a></p>
<pre>     MOVE &#34;DELETE FROM EMP WHERE EMPNO = :EMP-NUMBER&#34; TO SQLSTMT. 
     EXEC SQL PREPARE STMT1 FROM SQLSTMT END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB167" class="sect2"><a id="sthref134"></a>
<h3 class="sect2">Level Numbers</h3>
<p>When declaring host variables, you can use level numbers 01 through 49, and 77. Pro*COBOL does not allow variables containing the VARYING clause or pseudo-type variables (these datatypes are prefixed with &#34;SQL- &#34;) to be declared level 49 or 77.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB168" class="sect2"><a id="sthref135"></a>
<h3 class="sect2">MAXLITERAL Default</h3>
<p>With the MAXLITERAL option, you can specify the maximum length of string literals generated by Pro*COBOL, so that compiler limits are not exceeded. For Pro*COBOL, the default value is 256, but you might have to specify a lower value. On IBM-proprietary S370 operating systems it is 120.</p>
</div>
<!-- class="sect2" -->
<a id="i13420"></a>
<div id="LNPCB169" class="sect2">
<h3 class="sect2">Multibyte Datatypes</h3>
<p>ANSI standard National Character Set datatypes are supported for handling multibyte character data. The PIC N or PIC G clause, if supported by your compiler, defines variables that store fixed-length NCHAR strings. You can store variable-length, multibyte National Character Set strings using COBOL group items consisting of a length field and a string field.<a id="sthref136"></a> See <a href="pco04dat.htm#i7848">&#34;VARCHAR Variables&#34;</a>.</p>
<p>The environmental variable NLS_NCHAR is available to specify a client-side Globalization Support National Character Set.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB170" class="sect2"><a id="sthref137"></a>
<h3 class="sect2">NULLs in SQL<a id="sthref138"></a></h3>
<p>In SQL, a NULL represents a missing, unknown, or inapplicable column value; it equates neither to zero nor to a blank. Use the NVL function to convert NULLs to non-NULL values, use the IS [NOT] NULL comparison operator to search for NULLs, and use indicator variables to insert and test for NULLs.<a id="sthref139"></a><a id="sthref140"></a><a id="sthref141"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB171" class="sect2"><a id="sthref142"></a>
<h3 class="sect2">Paragraph and Section Names</h3>
<p>You can associate standard COBOL paragraph and section names with SQL statements, as shown in the following example: <a id="sthref143"></a><a id="sthref144"></a></p>
<pre> LOAD-DATA. 
     EXEC SQL 
         INSERT INTO EMP (EMPNO, ENAME, DEPTNO) 
             VALUES (:EMP-NUMBER, :EMP-NAME, :DEPT-NUMBER) 
     END-EXEC. 
</pre>
<p>Also, you can reference paragraph and section names in a WHENEVER ... DO or WHENEVER ... GOTO statement, as the next example shows:</p>
<pre> PROCEDURE DIVISION. 
 MAIN. 
     EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR END-EXEC. 
     ... 
 SQL-ERROR SECTION. 
     ... 
</pre>
<p>You must begin all paragraph names in area A.<a id="sthref145"></a><a id="sthref146"></a></p>
</div>
<!-- class="sect2" -->
<a id="i5847"></a>
<div id="LNPCB172" class="sect2">
<h3 class="sect2">REDEFINES Clause</h3>
<p>You can use the COBOL REDEFINES clause to redefine group or elementary items. For example, the following declarations are valid:<a id="sthref147"></a></p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01  REC-ID   PIC X(4). 
 01  REC-NUM  REDEFINES  REC-ID  PIC S9(4) COMP. 
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre>
<p>And:<a id="sthref148"></a><a id="sthref149"></a></p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
  01  STOCK. 
       05  DIVIDEND     PIC X(5). 
       05  PRICE        PIC X(6). 
   01  BOND  REDEFINES  STOCK. 
       05  COUPON-RATE  PIC X(4). 
       05  PRICE        PIC X(7). 
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre>
<p>Pro*COBOL issues no warning or error if a single INTO clause uses items from both a group item host variable and from its re-definition.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB173" class="sect2"><a id="sthref150"></a>
<h3 class="sect2">Relational Operators</h3>
<p>COBOL relational operators differ from their SQL equivalents, as shown in <a href="#i13966">Table 2-2</a>. Furthermore, COBOL enables the use of words instead of symbols, whereas SQL does not.</p>
<div id="LNPCB174" class="tblformal">
<p class="titleintable"><a id="sthref151"></a><a id="sthref152"></a>Table 2-2 <a id="i13966"></a><span class="bolditalic">Relational Operators</span></p>
<table class="cellalignment4971" title="Relational Operators" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t5">SQL Operators</th>
<th class="cellalignment4972" id="r1c2-t5">COBOL Operators</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t5" headers="r1c1-t5">
<p>=</p>
</td>
<td class="cellalignment4973" headers="r2c1-t5 r1c2-t5">
<p>=, EQUAL TO</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t5" headers="r1c1-t5">
<p>&lt; &gt;, !=, ^=</p>
</td>
<td class="cellalignment4973" headers="r3c1-t5 r1c2-t5">
<p>NOT=, NOT EQUAL TO</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t5" headers="r1c1-t5">
<p>&gt;</p>
</td>
<td class="cellalignment4973" headers="r4c1-t5 r1c2-t5">
<p>&gt;, GREATER THAN</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t5" headers="r1c1-t5">
<p>&lt;</p>
</td>
<td class="cellalignment4973" headers="r5c1-t5 r1c2-t5">
<p>&lt;, LESS THAN</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t5" headers="r1c1-t5">
<p>&gt;=</p>
</td>
<td class="cellalignment4973" headers="r6c1-t5 r1c2-t5">
<p>&gt;=, GREATER THAN OR EQUAL TO</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t5" headers="r1c1-t5">
<p>&lt;=</p>
</td>
<td class="cellalignment4973" headers="r7c1-t5 r1c2-t5">
<p>&lt;=, LESS THAN OR EQUAL TO</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t5" headers="r1c1-t5">&nbsp;</td>
<td class="cellalignment4973" headers="r8c1-t5 r1c2-t5">&nbsp;</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="i14005"></a>
<div id="LNPCB175" class="sect2">
<h3 class="sect2"><a id="sthref153"></a><a id="sthref154"></a>Sentence Terminator</h3>
<p>A COBOL <span class="italic">sentence</span> includes one or more COBOL or SQL statements, or both of them, and ends with a period. In conditional sentences, only the last statement must end with a period, as the following example shows.<a id="sthref155"></a><a id="sthref156"></a></p>
<pre>     IF EMP-NUMBER = ZERO 
         MOVE FALSE TO VALID-DATA 
         PERFORM GET-EMP-NUM UNTIL VALID-DATA = TRUE 
     ELSE 
         EXEC SQL DELETE FROM EMP 
             WHERE EMPNO = :EMP-NUMBER 
         END-EXEC
         ADD 1 TO DELETE-TOTAL.
     END-IF. 
</pre>
<p>SQL statements may be ended by a comma, a period, or another COBOL statement.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i6521"></a>
<div id="LNPCB176" class="sect1">
<h2 class="sect1">The Declare Section</h2>
<p>Passing data between the database server and your application program requires host variables and error handling. This section shows you how to meet these requirements.</p>
<div id="LNPCB177" class="sect2"><a id="sthref157"></a>
<h3 class="sect2">Contents of a Declare Section</h3>
<p>A Declare Section begins with the statement<a id="sthref158"></a><a id="sthref159"></a><a id="sthref160"></a>:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
</pre>
<p>and ends with the statement:</p>
<pre>     EXEC SQL END DECLARE SECTION END-EXEC.
</pre>
<p>Between these two statements only the following are allowed:<a id="sthref161"></a><a id="sthref162"></a></p>
<ul>
<li>
<p>Host-variable and indicator-variable declarations</p>
</li>
<li>
<p>Non-host COBOL variables</p>
</li>
<li>
<p>EXEC SQL DECLARE statements</p>
</li>
<li>
<p>EXEC SQL INCLUDE statements</p>
</li>
<li>
<p>EXEC SQL VAR statements</p>
</li>
<li>
<p>EXEC ORACLE statements</p>
</li>
<li>
<p>COBOL comments</p>
</li>
</ul>
<div id="LNPCB178" class="sect3"><a id="sthref163"></a>
<h4 class="sect3">An Example</h4>
<p>In the following example, you declare four host variables for use later in your program. <a id="sthref164"></a></p>
<pre> WORKING-STORAGE SECTION.
   ...
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
         ...
 01  EMP-NUMBER     PIC 9(4)  COMP VALUE ZERO.
 01  EMP-NAME       PIC X(10) VARYING.
 01  SALARY         PIC S9(5)V99 COMP-3 VALUE ZERO.
 01  COMMISSION     PIC S9(5)V99 COMP-3 VALUE ZERO.
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB179" class="sect2"><a id="sthref165"></a>
<h3 class="sect2">Precompiler Option DECLARE_SECTION<a id="sthref166"></a></h3>
<p>The Declare Section is optional. For backward compatibility with releases prior to 8.0, for which it was required, Pro*COBOL provides a command-line precompiler option for explicit control over whether only declarations in the Declare Section are allowed as host variables. This option is:</p>
<p>DECLARE_SECTION={YES | NO} (default is NO)</p>
<p>You must use the DECLARE_SECTION option on the command line or in a configuration file.</p>
<p>When MODE=ORACLE and DECLARE_SECTION=YES, only variables declared inside the Declare Section are allowed as host variables. When MODE=ANSI then DECLARE_SECTION is implicitly set to YES. See the discussion of macro and micro options in <a href="pco14opt.htm#i8395">&#34;Macro and Micro Options&#34;</a>.</p>
<p>If DECLARE_SECTION is set to YES, then you must declare all program variables used in SQL statements inside the Declare Section. If DECLARE_SECTION is set to NO, then it is optional to use a Declare Section. In this case, declarations of host variables and indicator variables can be made either inside or outside a Declare Section. This optional behavior is a change from Release 8.0 and earlier releases. See <a href="pco14opt.htm#i7346">&#34;DECLARE_SECTION&#34;</a> for details of the option.</p>
<p>Multiple Declare Sections are allowed for each precompiled unit. Furthermore, a host program can contain several independently precompiled units.<a id="sthref167"></a></p>
</div>
<!-- class="sect2" -->
<a id="i7498"></a>
<div id="LNPCB180" class="sect2">
<h3 class="sect2">Using the INCLUDE Statement</h3>
<p>The INCLUDE statement lets you copy files into your host program, as the following example shows:</p>
<pre>*    Copy in the SQL Communications Area (SQLCA) 
     EXEC SQL INCLUDE SQLCA END-EXEC. 
*    Copy in the Oracle Communications Area (ORACA) 
     EXEC SQL INCLUDE ORACA END-EXEC. 
</pre>
<p>You can INCLUDE any file. When you precompile your Pro*COBOL program, each EXEC SQL INCLUDE statement is replaced by a copy of the file named in the statement.<a id="sthref168"></a></p>
<div id="LNPCB181" class="sect3"><a id="sthref169"></a>
<h4 class="sect3">Filename Extensions</h4>
<p>If your system uses file extensions but you do not specify one, Pro*COBOL assumes the default extension for source files (usually COB). For more information, see your Oracle system-specific documentation.<a id="sthref170"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB182" class="sect3"><a id="sthref171"></a>
<h4 class="sect3">Search Paths</h4>
<p>If your system uses directories, you can set a search path for included files using the INCLUDE option, as follows:</p>
<pre>INCLUDE=<span class="italic">path</span> 
</pre>
<p>where <span class="italic">path</span> defaults to the current directory.</p>
<p>Pro*COBOL first searches the current directory, then the directory specified by the INCLUDE option, and finally the directory for standard INCLUDE files. You need not specify a path for standard files such as the SQLCA and ORACA. However, a path is required for nonstandard files unless they are stored in the current directory.<a id="sthref172"></a></p>
<p>You can also specify multiple paths on the command line, as follows:</p>
<pre>... INCLUDE=&lt;path1&gt; INCLUDE=&lt;path2&gt; ... 
</pre>
<p>When multiple paths are specified, Pro*COBOL searches the current directory first, then the <span class="italic">path1</span> directory, then the <span class="italic">path2</span> directory, and so on. The directory containing standard INCLUDE files is searched last. The path syntax is system specific. For more information, see your Oracle system-specific documentation.</p>
<p>Remember that Pro*COBOL searches for a file in the current directory first even if you specify a search path. If the file you want to INCLUDE is in another directory, make sure no file with the same name is in the current directory or any other directory that precedes it in the search path. If your operating system is case sensitive, be sure to specify the same upper/lowercase filename under which the file is stored.<a id="sthref173"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i5979"></a>
<div id="LNPCB183" class="sect1">
<h2 class="sect1">Nested Programs</h2>
<p>Nesting programs in COBOL means that you place one program inside another. The contained programs may reference some of the resources of the programs that contain them. The names within the higher-level program and the nested program can be the same, and describe different data items without conflict, because the names are known only within the programs. However, names described in the Configuration Section of the higher-level program can be referenced in the nested program.</p>
<p>Some compilers do not support the GLOBAL clause. Pro*COBOL supports nested programs by generating code that contains GLOBAL clauses. To avoid generating GLOBAL clauses unconditionally, specify the precompiler option NESTED=NO. NESTED (=YES or NO) defaults to YES and can be used in configuration files, or on the command line, but not inline (EXEC ORACLE statement).</p>
<p>See Also: <a href="pco14opt.htm#i11881">&#34;NESTED&#34;</a>.</p>
<p>The higher-level program can contain several nested programs. Likewise, nested programs can have programs nested within them. You must place the nested program directly before the END PROGRAM header of the program in which it is nested.</p>
<p>You can call a nested program only by a program in which it is either directly or indirectly nested. If you want a nested program to be called by any program, even one on a different branch of the nested tree structure, you code the COMMON clause in the PROGRAM-ID paragraph of the nested program. You can code COMMON only for nested programs:</p>
<pre> PROGRAM-ID.  &lt;nested-program-name&gt; COMMON.
</pre>
<p>You can code the GLOBAL phrase for File Definitions and level 01 data items (any subordinate items automatically become global). This enables them to be referenced in all subprograms directly or indirectly contained within them. You code GLOBAL on the higher-level program. If the nested program defines the same name as one declared GLOBAL in a higher-level program, COBOL uses the declaration within the nested program. If the data item contains a REDEFINES clause, GLOBAL must follow it.</p>
<pre> FD file-name GLOBAL ...
 01 data-name1 GLOBAL ...
 01 data-name2 REDEFINES data-name3 GLOBAL ...
</pre>
<a id="i13375"></a>
<div id="LNPCB184" class="sect2">
<h3 class="sect2"><a id="sthref174"></a>Support for Nested Programs</h3>
<p>Pro*COBOL enables you to store nested programs with embedded SQL within a single source file. All 01 level items, which are marked as global in a containing program and are valid host variables at the containing program level, are usable as valid host variables in any programs directly or indirectly contained by the containing program. Consider the following example:</p>
<pre> IDENTIFICATION DIVISION.
 PROGRAM-ID. MAINPROG.
 ENVIRONMENT DIVISION.
 DATA DIVISION.
 WORKING-STORAGE SECTION.

     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01 REC1  GLOBAL.
           05    VAR1   PIC X(10).
           05    VAR2   PIC X(10).
 01 VAR1  PIC X(10) GLOBAL.
     EXEC SQL END DECLARE SECTION END-EXEC.

 PROCEDURE DIVISION.
     ...
     &lt;main program statements&gt;
     ...
 IDENTIFICATION DIVISION.
    PROGRAM-ID. NESTEDPROG.
 ENVIRONMENT DIVISION.
 DATA DIVISION.
 WORKING-STORAGE SECTION.

 01 VAR1   PIC S9(4).

 PROCEDURE DIVISION.
     ...
     EXEC SQL SELECT X, Y INTO :REC1 FROM ... END-EXEC.

     EXEC SQL SELECT X INTO :VAR1 FROM ... END-EXEC.

     EXEC SQL SELECT X INTO :REC1.VAR1 FROM ... END-EXEC.
     ...
 END PROGRAM NESTEDPROG.
 END PROGRAM MAINPROG.
</pre>
<p>The main program declares the host variable REC1 as global, and thus the nested program can use REC1 in the first select statement without having to declare it. Since VAR1 is declared as a global variable and also as a local variable in the nested program, the second select statement will use the VAR1 declared as S9(4), overriding the global declaration. In the third select statement, the global VAR1 of REC1 declared as PIC X(10) is used.</p>
<p>The previous paragraph describes the results when DECLARE_SECTION=NO is used. When DECLARE_SECTION=YES, Pro*COBOL will not recognize host variables <span class="italic">unless</span> they are declared inside a Declare Section. If the preceding program is precompiled with DECLARE_SECTION=YES, then the second select statement would result in an ambiguous host variable error. The first and third select statements would function the same.</p>
<p>Note: Recursive nested programs are not supported</p>
<div id="LNPCB185" class="sect3"><a id="sthref175"></a>
<h4 class="sect3">Declaring the SQLCA</h4>
<p>For information on declaring the SQLCA for nested programs, (see <a href="#i6891">&#34;SQLCA Status Variable&#34;</a>), the included SQLCA definition provided will be declared as global, so the declaration of SQLCA is only required in the higher-level program. The SQLCA can change each time a new SQL statement is executed. The SQLCA provided can always be modified to remove the global specification if you want to declare additional SQLCA areas in the nested programs. This also applies to SQLDA and ORACA.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB186" class="sect3"><a id="sthref176"></a>
<h4 class="sect3">Nested Program Example</h4>
<p>See SAMPLE13.PCO in the demo directory<a id="sthref177"></a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i6391"></a>
<div id="LNPCB187" class="sect1">
<h2 class="sect1">Conditional Precompilations</h2>
<p>Conditional precompilation includes (or excludes) sections of code in your host program based on certain conditions. For example, you might want to include one section of code when precompiling under UNIX and another section when precompiling under VMS. Conditional precompilation lets you write programs that can run in different environments.<a id="sthref178"></a><a id="sthref179"></a></p>
<p>Conditional sections of code are marked by statements that define the environment and actions to take. You can code host-language statements as well as EXEC SQL statements in these sections. The following statements let you exercise conditional control over precompilation:<a id="sthref180"></a><a id="sthref181"></a><a id="sthref182"></a><a id="sthref183"></a><a id="sthref184"></a></p>
<pre>*   -- define a symbol
     EXEC ORACLE DEFINE symbol END-EXEC.
*    -- if symbol is defined
     EXEC ORACLE IFDEF symbol  END-EXEC.
*   -- if symbol is not defined
     EXEC ORACLE IFNDEF symbol END-EXEC.
*            -- otherwise  
     EXEC ORACLE ELSE END-EXEC.
*           -- end this control block 
     EXEC ORACLE ENDIF END-EXEC.
</pre>
<p>A conditional statement must be terminated with <code>END-EXEC</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The conditional compilation feature of your compiler may not be supported by Pro*COBOL.</div>
<div id="LNPCB188" class="sect2"><a id="sthref185"></a>
<h3 class="sect2">An Example</h3>
<p>In the following example, the SELECT statement is precompiled only when the symbol <span class="italic">SITE2</span> is defined:<a id="sthref186"></a></p>
<pre>     EXEC ORACLE IFDEF SITE2 END-EXEC.
     EXEC SQL SELECT DNAME 
        INTO :DEPT-NAME 
        FROM DEPT 
        WHERE DEPTNO = :DEPT-NUMBER
     EXEC ORACLE ENDIF END-EXEC.
</pre>
<p>Blocks of conditions can be nested as shown in the following example:</p>
<pre>     EXEC ORACLE IFDEF OUTER END-EXEC. 
     EXEC ORACLE IFDEF INNER END-EXEC. 
     ... 
     EXEC ORACLE ENDIF END-EXEC. 
     EXEC ORACLE ENDIF END-EXEC. 
</pre>
<p>You can &#34;Comment out&#34; host-language or embedded SQL code by placing it between IFDEF and ENDIF and <span class="italic">not</span> defining the symbol.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB189" class="sect2"><a id="sthref187"></a>
<h3 class="sect2">Defining Symbols</h3>
<p>You can define a symbol in two ways. Either include the statement<a id="sthref188"></a></p>
<pre>     EXEC ORACLE DEFINE symbol END-EXEC.
</pre>
<p>in your host program or define the symbol on the command line using the syntax</p>
<pre>... INAME=filename ... DEFINE=symbol 
</pre>
<p>where <span class="italic">symbol</span> is not case-sensitive.</p>
<p>Some port-specific symbols are predefined for you when Pro*COBOL is installed on your system. For example, predefined operating system symbols include CMS, MVS, UNIX, and VMS.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A DEFINE SYMBOL name beginning with a number, or that includes a dash, causes an unrecoverable error during precompilation. You can use underscores, and you can use numbers other than at the beginning of a DEFINE SYMBOL name.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i6313"></a>
<div id="LNPCB190" class="sect1">
<h2 class="sect1">Separate Precompilations</h2>
<p>You can precompile several COBOL program modules separately and then link them into one executable program. This supports modular programming, which is required when the functional components of a program are written and debugged by different programmers. The individual program modules need not be written in the same language.<a id="sthref189"></a></p>
<div id="LNPCB191" class="sect2"><a id="sthref190"></a>
<h3 class="sect2">Guidelines</h3>
<p>The following guidelines will help you avoid some common problems.<a id="sthref191"></a><a id="sthref192"></a></p>
<div id="LNPCB192" class="sect3"><a id="sthref193"></a>
<h4 class="sect3">Referencing Cursors</h4>
<p>Cursor names are SQL identifiers, whose scope is the precompilation unit. Hence, cursor operations cannot span precompilation units (files). That is, you cannot declare a cursor in one file and open or fetch from it in another file, so when doing a separate precompilation, make sure all definitions and references to a given cursor are in one file.<a id="sthref194"></a><a id="sthref195"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB193" class="sect3"><a id="sthref196"></a>
<h4 class="sect3">Specifying MAXOPENCURSORS</h4>
<p>When you precompile the program module that connects to Oracle, specify a value for MAXOPENCURSORS that is high enough for any of the program modules. If you use it for another program module, MAXOPENCURSORS is ignored. Only the value in effect for the connect is used at run time.<a id="sthref197"></a><a id="sthref198"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB194" class="sect3"><a id="sthref199"></a>
<h4 class="sect3">Using a Single SQLCA</h4>
<p><a id="sthref200"></a><a id="sthref201"></a>If you want to use just one memory area for the SQLCA, the process for doing so depends on which version of Pro*COBOL you are using.</p>
<div id="LNPCB195" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref202"></a>
<h5 class="sect4">Version 1.8 and Lower</h5>
<p>You must declare the SQLCA globally. You can do this by modifying the SQLCA.COB file, changing the line</p>
<pre> 01  SQLCA.
</pre>
<p>to</p>
<pre> 01  SQLCA EXTERNAL.
</pre>
<p>Alternatively, you can include a hard-coded definition for SQLCA, copied from SQLCA.cob and make the aforementioned change. Note that you still have to include a definition of SQLCA in each precompiled unit.</p>
</div>
<!-- class="sect4" -->
<div id="LNPCB196" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref203"></a>
<h5 class="sect4">Version 2 and Later</h5>
<p>In later versions of Pro*COBOL, the SQLCA is not copied from the file system. It is generated by the precompiler. If you need to share the SQLCA structure in these versions, instead of this statement:</p>
<pre>EXEC SQL INCLUDE SQLCA END-EXEC
</pre>
<p>you should use the following code:</p>
<pre>EXEC SQL INCLUDE SQLCA.ANX END-EXEC
</pre>
<p>This causes the precompiler to generate the SQLCA structure with the EXTERNAL keyword added automatically.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNPCB197" class="sect3"><a id="sthref204"></a>
<h4 class="sect3">Using a Single DATE_FORMAT</h4>
<p>You must use the same format string for DATE in each program module.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB198" class="sect2"><a id="sthref205"></a>
<h3 class="sect2">Restrictions</h3>
<p>All references to an explicit cursor must be in the same program file. You cannot perform operations on a cursor that was declared in a different module. See Chapter 4 for more information about cursors.<a id="sthref206"></a></p>
<p>Also, any program file that contains SQL statements must have a SQLCA that is in the scope of the local SQL statements.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDBIHHF"></a>
<div id="LNPCB199" class="sect1">
<h2 class="sect1">Compiling and Linking</h2>
<p>To get an executable program, you must compile the source file(s) produced by Pro*COBOL, then link the resulting object module with any modules needed from SQLLIB and system-specific Oracle libraries.<a id="sthref207"></a><a id="sthref208"></a></p>
<p>The linker resolves symbolic references in the object modules. If these references conflict, the link fails. Such conflicts can happen when you try to link third party software into a precompiled program. Not all third-party software is compatible with Oracle, so you might have problems. Check with Oracle Support Services to see if the software is supported.</p>
<p>Compiling and linking are system-dependent. For example, on some systems, you must turn off compiler optimization when compiling a host language program. For instructions, see your system-specific Oracle manual.</p>
</div>
<!-- class="sect1" -->
<a id="i2226"></a>
<div id="LNPCB200" class="sect1">
<h2 class="sect1">Sample DEPT and EMP Tables</h2>
<p>Most of the complete program examples in this guide use two sample database tables: DEPT and EMP. If they do not exist in your demo directory, create them before running the sample programs. Their definitions follow: <a id="sthref209"></a><a id="sthref210"></a><a id="sthref211"></a><a id="sthref212"></a></p>
<pre>CREATE TABLE DEPT (DEPTNO NUMBER(2), DNAME VARCHAR2(14), LOC VARCHAR2(13));

CREATE TABLE EMP (EMPNO NUMBER(4) primary key, ENAME VARCHAR2(10), JOB VARCHAR2(9), MGR NUMBER(4), HIREDATE DATE, SAL NUMBER(7,2), COMM NUMBER(7,2), DEPTNO NUMBER(2));
</pre>
<div id="LNPCB201" class="sect2"><a id="sthref213"></a>
<h3 class="sect2">Sample DEPT and EMP Data</h3>
<p>Respectively, the DEPT and EMP tables contain the following rows of data:</p>
<pre>DEPTNO  DNAME      LOC
------- ---------- ---------
10      ACCOUNTING NEW YORK
20      RESEARCH   DALLAS
30      SALES      CHICAGO
40      OPERATIONS BOSTON

EMPNO ENAME   JOB          MGR  HIREDATE    SAL   COMM  DEPTNO
----- ------- --------- ------ --------- ------ ------ -------
 7369 SMITH   CLERK       7902 17-DEC-80    800             20
 7499 ALLEN   SALESMAN    7698 20-FEB-81   1600    300      30
 7521 WARD    SALESMAN    7698 22-FEB-81   1250    500      30
 7566 JONES   MANAGER     7839 02-APR-81   2975             20
 7654 MARTIN  SALESMAN    7698 28-SEP-81   1250   1400      30
 7698 BLAKE   MANAGER     7839 01-MAY-81   2850             30
 7782 CLARK   MANAGER     7839 09-JUN-81   2450             10
 7788 SCOTT   ANALYST     7566 19-APR-87   3000             20
 7839 KING    PRESIDENT        17-NOV-81   5000             10
 7844 TURNER  SALESMAN    7698 08-SEP-81   1500             30
 7876 ADAMS   CLERK       7788 23-MAY-87   1100             20
 7900 JAMES   CLERK       7698 03-DEC-81    950             30
 7902 FORD    ANALYST     7566 03-DEC-81   3000             20
 7934 MILLER  CLERK       7782 23-JAN-82   1300             10
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3228"></a>
<div id="LNPCB202" class="sect1">
<h2 class="sect1">Sample EMP Program: SAMPLE1.PCO<a id="sthref214"></a></h2>
<p>A good way to get acquainted with embedded SQL is to look at a program example. This program is SAMPLE1.PCO in the <code>demo</code> directory.</p>
<p>The program logs on to the database, prompts the user for an employee number, queries the database table EMP for the employee&#39;s name, salary, and commission. The selected results are stored in host variables EMP-NAME, SALARY, and COMMISSION. The program uses the host indicator variable, COMM-IND to detect NULL values in column COMMISSION. See <a href="pco04dat.htm#i18673">&#34;Indicator Variables&#34;</a>.</p>
<p>The paragraph DISPLAY-INFO then displays the result.</p>
<p>The COBOL variables USERNAME, PASSWD, and EMP-NAME are declared using the VARYING clause, which enables you to use a variable-length string external Oracle datatype called VARCHAR. This datatype is explained in <a href="pco04dat.htm#i7848">&#34;VARCHAR Variables&#34;</a>.</p>
<p>The SQLCA Communications Area is included to handle errors. If an error occurs, paragraph SQL-ERROR is performed. See <a href="pco08err.htm#i16095">&#34;Using the SQL Communications Area&#34;</a>.</p>
<p>The BEGIN DECLARE SECTION and END DECLARE SECTION statements used are optional, unless you set the precompiler option DECLARE_SECTION to YES, or option MODE to ANSI. See <a href="pco14opt.htm#i5831">&#34;MODE&#34;</a>.</p>
<p>The WHENEVER statement is used to handle errors. For more details, see <a href="pco08err.htm#i13728">&#34;WHENEVER Directive&#34;</a>.</p>
<p>The program ends when the user enters a zero employee number<a id="sthref215"></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For simplicity in demonstrating this feature, this example does not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <a class="olink DBSEG50053" href="../DBSEG/app_devs.htm#DBSEG50053"><span class="italic">Oracle Database Security Guide</span></a> for password management guidelines and other security recommendations.</div>
<pre>* This program logs on to ORACLE, prompts the user for an employee number, 
* queries the database for the employee&#39;s name, salary, and commission, then
* displays the result. The program terminates when the user enters a 0.              *
       ID DIVISION.

       PROGRAM-ID. QUERY.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(10) VARYING.
       01  PASSWD            PIC X(10) VARYING.
       01  EMP-REC-VARS.
           05  EMP-NAME      PIC X(10) VARYING.
           05  EMP-NUMBER    PIC S9(4) COMP VALUE ZERO.
           05  SALARY        PIC S9(5)V99 COMP-3 VALUE ZERO.
           05  COMMISSION    PIC S9(5)V99 COMP-3 VALUE ZERO.
           05  COMM-IND      PIC S9(4) COMP VALUE ZERO.
           EXEC SQL END DECLARE SECTION END-EXEC.

           EXEC SQL INCLUDE SQLCA END-EXEC.

       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME    PIC X(10).
           05  D-SALARY      PIC Z(4)9.99.
           05  D-COMMISSION  PIC Z(4)9.99.
           05  D-EMP-NUMBER  PIC 9(4).

       01 D-TOTAL-QUERIED   PIC 9(4) VALUE ZERO.
        
       PROCEDURE DIVISION.
       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR
              DO PERFORM SQL-ERROR END-EXEC.

           PERFORM LOGON.

       QUERY-LOOP.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ENTER EMP NUMBER (0 TO QUIT): &#34;
               WITH NO ADVANCING.

           ACCEPT D-EMP-NUMBER.

           MOVE D-EMP-NUMBER TO EMP-NUMBER.
           IF (EMP-NUMBER = 0)
               PERFORM SIGN-OFF.
           MOVE SPACES TO EMP-NAME-ARR.
           EXEC SQL WHENEVER NOT FOUND GOTO NO-EMP END-EXEC.
           EXEC SQL SELECT ENAME, SAL, NVL(COMM, 0)
               INTO :EMP-NAME, :SALARY, :COMMISSION:COMM-IND
               FROM EMP
               WHERE EMPNO = :EMP-NUMBER
           END-EXEC.
           PERFORM DISPLAY-INFO.
           ADD 1 TO D-TOTAL-QUERIED.
           GO TO QUERY-LOOP.

       NO-EMP.
           DISPLAY &#34;NOT A VALID EMPLOYEE NUMBER - TRY AGAIN.&#34;.
           GO TO QUERY-LOOP.

       LOGON.
           MOVE &#34;SCOTT&#34; TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE &#34;TIGER&#34; TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER: &#34;, USERNAME-ARR.
        
       DISPLAY-INFO.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;EMPLOYEE    SALARY    COMMISSION&#34;.
           DISPLAY &#34;--------    ------    ----------&#34;. 
           MOVE EMP-NAME-ARR TO D-EMP-NAME.
           MOVE SALARY TO D-SALARY.
           IF COMM-IND = -1
               DISPLAY D-EMP-NAME, D-SALARY, &#34;          NULL&#34;
           ELSE
               MOVE COMMISSION TO D-COMMISSION
               DISPLAY D-EMP-NAME, D-SALARY, &#34;      &#34;, D-COMMISSION
           END-IF.

       SIGN-OFF.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;TOTAL NUMBER QUERIED WAS &#34;,
               D-TOTAL-QUERIED, &#34;.&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY.&#34;.
           DISPLAY &#34; &#34;.
           EXEC SQL COMMIT WORK RELEASE END-EXEC.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;ORACLE ERROR DETECTED:&#34;.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pco01int.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pco03dbc.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>