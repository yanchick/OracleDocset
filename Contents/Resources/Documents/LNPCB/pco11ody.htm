<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77862"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Oracle%20Dynamic%20SQL%3A%20Method%204"></a><title>Oracle Dynamic SQL: Method 4</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:21Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pco10ady.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pco12thr.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">17/27</span> <!-- End Header -->
<div id="LNPCB011" class="chapter"><a id="i9695"></a>
<h1 class="chapter"><span class="secnum">11</span> Oracle Dynamic SQL: Method 4</h1>
<p>This chapter shows you how to implement Oracle dynamic SQL Method 4, which lets your program accept or build dynamic SQL statements that contain a varying number of host variables.</p>
<p>New applications should be developed using the newer ANSI SQL Method 4 described in <a href="pco10ady.htm#g1024116">Chapter 10, &#34;ANSI Dynamic SQL&#34;</a>.The ANSI Method 4 supports all Oracle types, while the older Oracle Method 4 does <span class="italic">not</span> support cursor variables, tables of group items, the DML returning clause, and LOBs.</p>
<p>Subjects discussed include the following:</p>
<ul>
<li>
<p><a href="#i10838">Meeting the Special Requirements of Method 4</a></p>
</li>
<li>
<p><a href="#i10843">Understanding the SQL Descriptor Area (SQLDA)</a></p>
</li>
<li>
<p><a href="#i25366">The SQLDA Variables</a></p>
</li>
<li>
<p><a href="#i10853">Prerequisite Knowledge</a></p>
</li>
<li>
<p><a href="#i10858">The Basic Steps</a></p>
</li>
<li>
<p><a href="#i10863">A Closer Look at Each Step</a></p>
</li>
<li>
<p><a href="#i25561">Using Host Tables with Method 4</a></p>
</li>
<li>
<p><a href="#i10873">Sample Program 10: Dynamic SQL Method 4</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For a discussion of dynamic SQL Methods 1, 2, and 3, and an overview of Oracle Method 4, see <a href="pco09dyn.htm#g19788">Chapter 9, &#34;Oracle Dynamic SQL&#34;</a></div>
<a id="i10838"></a>
<div id="LNPCB707" class="sect1">
<h2 class="sect1">Meeting the Special Requirements of Method 4</h2>
<p>Before looking into the requirements of Method 4, you should be familiar with the terms <span class="italic">select-list item</span> and <span class="italic">place-holder</span>. Select-list items are the columns or expressions following the keyword SELECT in a query. For example, the following dynamic query contains three select-list items:</p>
<pre>SELECT ENAME, JOB, SAL + COMM FROM EMP WHERE DEPTNO = 20
</pre>
<p>Place-holders are dummy bind (input) variables that hold places in a SQL statement for actual bind variables. You do not declare place-holders and can name them anything you like. Place-holders for bind variables are most often used in the SET, VALUES, and WHERE clauses. For example, the following dynamic SQL statements each contain two place-holders.</p>
<pre>INSERT INTO EMP (EMPNO, DEPTNO) VALUES (:E, :D)
DELETE FROM DEPT WHERE DEPTNO = :DNUM AND LOC = :DLOC
</pre>
<p>Place-holders cannot reference table or column names.</p>
<div id="LNPCB708" class="sect2"><a id="sthref1403"></a>
<h3 class="sect2">Advantages of Method 4</h3>
<p>Unlike Methods 1, 2, and 3, dynamic SQL Method 4 lets your program:</p>
<ul>
<li>
<p>Accept or build dynamic SQL statements that contain an unknown number of select-list items or place-holders</p>
</li>
<li>
<p>Take explicit control over datatype conversion between Oracle and COBOL types</p>
</li>
</ul>
<p>To add this flexibility to your program, you must give the runtime library additional information.<a id="sthref1404"></a></p>
</div>
<!-- class="sect2" -->
<div id="LNPCB709" class="sect2"><a id="sthref1405"></a>
<h3 class="sect2">Information the Database Needs</h3>
<p>Pro*COBOL generates calls to Oracle for all executable dynamic SQL statements. If a dynamic SQL statement contains no select-list items or place-holders, the database needs no additional information to execute the statement. The following DELETE statement falls into this category:</p>
<pre>*    Dynamic SQL statement...
     MOVE &#39;DELETE FROM EMP WHERE DEPTNO = 30&#39; TO STMT.
</pre>
<p>However, most dynamic SQL statements contain select-list items or place-holders for bind variables, as shown in the following UPDATE statement:</p>
<pre>*    Dynamic SQL statement with place-holders...
     MOVE &#39;UPDATE EMP SET COMM = :C WHERE EMPNO = :E&#39; TO STMT.
</pre>
<p>To execute a dynamic SQL statement that contains select-list items or place-holders for bind variables, or both, the database needs information about the program variables that will hold output or input values. Specifically, the database needs the following information:</p>
<ul>
<li>
<p>The number of select-list items and the number of bind variables</p>
</li>
<li>
<p>The length of each select-list item and bind variable</p>
</li>
<li>
<p>The datatype of each select-list item and bind variable</p>
</li>
<li>
<p>The memory address of each output variable that will store the value of a select-list item, and the address of each bind variable</p>
</li>
</ul>
<p>For example, to write the value of a select-list item, the database needs the address of the corresponding output variable.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB710" class="sect2"><a id="sthref1406"></a>
<h3 class="sect2">Where the Information is Stored</h3>
<p>All the information the database needs about select-list items or place-holders for bind variables, except their values, is stored in a program data structure called the SQL Descriptor Area (SQLDA).</p>
<p>Descriptions of select-list items are stored in a <span class="italic">select SQLDA</span>, and descriptions of place-holders for bind variables are stored in a <span class="italic">bind SQLDA</span>.<a id="sthref1407"></a><a id="sthref1408"></a></p>
<p>The values of select-list items are stored in output buffers; the values of bind variables are stored in input buffers. You use the library routine SQLADR to store the addresses of these data buffers in a select or bind SQLDA, so that the database knows where to write output values and read input values.<a id="sthref1409"></a><a id="sthref1410"></a></p>
<p>How do values get stored in these data variables? A FETCH generates output values using a cursor, and input values are filled in by your program, typically from information entered interactively by the user.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB711" class="sect2"><a id="sthref1411"></a>
<h3 class="sect2">How Information is Obtained</h3>
<p>You use the DESCRIBE statement to help get the information the database needs. The DESCRIBE SELECT LIST statement examines each select-list item to determine its name, datatype, constraints, length, scale, and precision, then stores this information in the select SQLDA for your use. For example, you might use select-list names as column headings in a printout. DESCRIBE also stores the total number of select-list items in the SQLDA.</p>
<p>The DESCRIBE BIND VARIABLES statement examines each place-holder to determine its name and length, then stores this information in an input buffer and bind SQLDA for your use. For example, you might use place-holder names to prompt the user for the values of bind variables.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i10843"></a>
<div id="LNPCB712" class="sect1">
<h2 class="sect1">Understanding the SQL Descriptor Area (SQLDA)</h2>
<p>This section describes the SQLDA data structure in detail. You learn how to declare it, what variables it contains, how to initialize them, and how to use them in your program.<a id="sthref1412"></a><a id="sthref1413"></a></p>
<div id="LNPCB713" class="sect2"><a id="sthref1414"></a>
<h3 class="sect2">Purpose of the SQLDA</h3>
<p>Method 4 is required for dynamic SQL statements that contain an unknown number of select-list items or place-holders for bind variables. To process this kind of dynamic SQL statement, your program must explicitly declare SQLDAs, also called <span class="italic">descriptors</span>. Each descriptor corresponds to a group item in your program.<a id="sthref1415"></a></p>
<p>A <span class="italic">select descriptor</span> stores descriptions of select-list items and the addresses of output buffers that hold the names and values of select-list items.<a id="sthref1416"></a><a id="sthref1417"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The name of a select-list item can be a column name, a column alias, or the text of an expression such as SAL + COMM.<a id="sthref1418"></a><a id="sthref1419"></a></div>
<p>A <span class="italic">bind descriptor</span> stores descriptions of bind variables and indicator variables and the addresses of input buffers where the names and values of bind variables and indicator variables are stored.<a id="sthref1420"></a><a id="sthref1421"></a><a id="sthref1422"></a><a id="sthref1423"></a></p>
<p>Remember, some descriptor variables contain addresses, not values. Therefore, you must declare data buffers to hold the values. You decide the sizes of the required input and output buffers. Because COBOL does not support pointers, you must use the library subroutine SQLADR to get the addresses of input and output buffers. You learn how to call SQLADR in the section <a href="#i9020">&#34;Using SQLADR&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB714" class="sect2"><a id="sthref1424"></a>
<h3 class="sect2">Multiple SQLDAs</h3>
<p>If your program has more than one active dynamic SQL statement, each statement must have its own SQLDA. You can declare any number of SQLDAs with different names. For example, you might declare three select SQLDAs named SELDSC1, SELDSC2, and SELDSC3, so that you can FETCH from three concurrently open cursors. However, non-concurrent cursors can reuse SQLDAs.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB715" class="sect2"><a id="sthref1425"></a>
<h3 class="sect2">Declaring a SQLDA</h3>
<p>To declare select and bind SQLDAs, you can code them into your program using the sample select and bind SQLDAs shown in <a href="#CDDHABCF">Figure 11-1</a>. You can modify the table dimensions to suit your needs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For byte-swapped platforms, use COMP5 instead of COMP when declaring a SQLDA.</div>
<div id="LNPCB716" class="figure">
<p class="titleinfigure"><a id="CDDHABCF"></a>Figure 11-1 Sample Pro*COBOL SQLDA Descriptors and Data Buffers (32 bit)</p>
<img width="367" height="610" src="img/pco81005.gif" alt="Sample Descriptors and Buffers"/><br/>
<a id="sthref1426" href="img_text/pco81005.htm">Description of &#34;Figure 11-1 Sample Pro*COBOL SQLDA Descriptors and Data Buffers (32 bit)&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
For 64-bit platforms, use PIC S9(18) declarations instead of PIC S9(9) when declaring a SQLDA.</div>
<p>You can store the SQLDAs in files (named SELDSC and BNDDSC, for example), and then copy the files into your program with the INCLUDE statement as follows:<a id="sthref1427"></a><a id="sthref1428"></a><a id="sthref1429"></a><a id="sthref1430"></a></p>
<pre>     EXEC SQL INCLUDE SELDSC END-EXEC.
     EXEC SQL INCLUDE BNDDSC END-EXEC.
</pre>
<p><a href="#i25351">Figure 11-2</a> shows whether variables are set by SQLADR calls, DESCRIBE commands, FETCH commands, or program assignments.</p>
<div id="LNPCB717" class="figure">
<p class="titleinfigure"><a id="i25351"></a>Figure 11-2 How Variables Are Set</p>
<img width="402" height="450" src="img/pco81006.gif" alt="Setting Variables"/><br/>
<a id="sthref1431" href="img_text/pco81006.htm">Description of &#34;Figure 11-2 How Variables Are Set&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i25366"></a>
<div id="LNPCB718" class="sect1">
<h2 class="sect1">The SQLDA Variables</h2>
<p>This section explains the purpose and use of each variable in the SQLDA.<a id="sthref1432"></a></p>
<p class="subhead1"><a id="LNPCB719"></a>SQLDNUM</p>
<p>This variable specifies the maximum number of select-list items or place-holders that can be included in DESCRIBE. Thus, SQLDNUM determines the number of elements in the descriptor tables.<a id="sthref1433"></a><a id="sthref1434"></a></p>
<p>Before issuing a DESCRIBE command, you must set this variable to the dimension of the descriptor tables. After the DESCRIBE, you must reset it to the actual number of variables in the DESCRIBE, which is stored in SQLDFND.</p>
<p class="subhead1"><a id="LNPCB720"></a>SQLDFND</p>
<p>The SQLDFND variable is the actual number of select-list items or place-holders found by the DESCRIBE command.<a id="sthref1435"></a><a id="sthref1436"></a></p>
<p>SQLDFND is set by DESCRIBE. If SQLDFND is negative, the DESCRIBE command found too many select-list items or place-holders for the size of the descriptor. For example, if you set SQLDNUM to 10 but DESCRIBE finds 11 select-list items or place-holders, SQLDFND is set to -11. If this happens, you cannot process the SQL statement without reallocating the descriptor.</p>
<p>After the DESCRIBE, you must set SQLDNUM equal to SQLDFND.</p>
<p class="subhead1"><a id="LNPCB721"></a>SELDV | BNDDV</p>
<p>The <span class="bold">SELDV | BNDDV</span> table contains the addresses of data buffers that store select-list or bind-variable values.<a id="sthref1437"></a><a id="sthref1438"></a><a id="sthref1439"></a><a id="sthref1440"></a></p>
<p>You must set the elements of SELDV or BNDDV using SQLADR.</p>
<p class="subhead1"><a id="LNPCB722"></a>Select Descriptors</p>
<p>The following statement</p>
<pre>     EXEC SQL FETCH ... USING DESCRIPTOR ...
</pre>
<p>directs the database to store FETCHed select-list values in the data buffers addressed by SELDV(1) through SELDV(SQLDNUM). Thus, the database stores the Jth select-list value in SEL-DV(J).</p>
<p class="subhead1"><a id="LNPCB723"></a>Bind Descriptors</p>
<p>You must set the bind descriptors before issuing the OPEN command. The following statement</p>
<pre>     EXEC SQL OPEN ... USING DESCRIPTOR ...
</pre>
<p>directs Oracle to execute the dynamic SQL statement using the bind-variable values addressed by BNDDV(1) through BNDDV(SQLDNUM). (Typically, the values are entered by the user.) The database finds the Jth bind-variable value in BND-DV(J).</p>
<p class="subhead1"><a id="LNPCB724"></a>SELDFMT | BNDDFMT</p>
<p>The <span class="bold">SELDFMT | BNDDFMT</span> table contains the addresses of data buffers that store select-list or bind-variable conversion format strings. You can currently use it only for COBOL packed decimals. The format for the conversion string is PP.+SS or PP.-SS where PP is the precision and SS is the scale. For definitions of precision and scale, see the section <a href="#i9038">&#34;Extracting Precision and Scale&#34;</a>.<a id="sthref1441"></a><a id="sthref1442"></a><a id="sthref1443"></a><a id="sthref1444"></a></p>
<p>The use of format strings is optional. If you want a conversion format for the Jth select-list item or bind variable, set SELDFMT(J) or BNDDFMT(J) using SQLADR, then store the packed-decimal format (<code>07.+02</code> for example) in SEL-DFMT or BND-DFMT. Otherwise, set SELDFMT(J) or BNDDFMT(J) to zero.</p>
<p class="subhead1"><a id="LNPCB725"></a>SELDVLN | BNDDVLN</p>
<p>The <span class="bold">SELDVLN | BNDDVLN</span> table contains the lengths of select-list variables or bind-variable values stored in the data buffers.<a id="sthref1445"></a><a id="sthref1446"></a><a id="sthref1447"></a><a id="sthref1448"></a></p>
<p class="subhead1"><a id="LNPCB726"></a>Select Descriptors</p>
<p>DESCRIBE SELECT LIST sets the table of lengths to the maximum expected for each select-list item. However, you might want to reset some lengths before issuing a FETCH command. FETCH returns at most <span class="italic">n</span> characters, where <span class="italic">n</span> is the value of SELDVLN(J) before the FETCH command.</p>
<p>The format of the length differs among datatypes. For CHAR select-list items, DESCRIBE SELECT LIST sets SELDVLN(J) to the maximum length in bytes of the select-list item. For NUMBER select-list items, scale and precision are returned respectively in the low and next-higher bytes of the variable. You can use the library routine SQLPRC to extract precision and scale values from SELDVLN. See the section <a href="#i9038">&#34;Extracting Precision and Scale&#34;</a>.</p>
<p>You must reset SELDVLN(J) to the required length of the data buffer before the FETCH. For example, when coercing a NUMBER to a COBOL character string, set SELDVLN(J) to the precision of the number plus two for the sign and decimal point. When coercing a NUMBER to a COBOL floating point number, set SELDVLN(J) to the length of the appropriate floating point type on your system.</p>
<p>For more information about the lengths of coerced datatypes, see the section <a href="#i9051">&#34;Converting Data&#34;</a>.</p>
<p class="subhead1"><a id="LNPCB727"></a>Bind Descriptors</p>
<p>You must set the Bind Descriptor lengths before issuing the OPEN command. For example, you can use the following statements to set the lengths of bind-variable character strings entered by the user:</p>
<pre> PROCEDURE DIVISION. 
     ... 
     PERFORM GET-INPUT-VAR 
         VARYING J FROM 1 BY 1 UNTIL J &gt; SQLDNUM IN BNDDSC. 
     ... 
 GET-INPUT-VAR. 
     DISPLAY &#34;Enter value of &#34;, BND-DH-VNAME(J). 
     ACCEPT INPUT-STRING. 
     UNSTRING INPUT-STRING DELIMITED BY &#34;  &#34; 
         INTO BND-DV(J) COUNT IN BNDDVLN(J). 
</pre>
<p>Because Oracle accesses a data buffer indirectly, using the address in SELDV(J) or BNDDV(J), it does not know the length of the value in that buffer. If you want to change the length Oracle uses for the Jth select-list or bind-variable value, reset SELDVLN(J) or BNDDVLN(J) to the length you need. Each input or output buffer can have a different length.</p>
<p class="subhead1"><a id="LNPCB728"></a>SELDFMTL | BNDDFMTL</p>
<p>This is a table containing the lengths of select-list or bind-variable conversion format strings. Currently, you can use it only for COBOL packed decimal.</p>
<p>The use of format strings is optional. If you want a conversion format for the Jth select-list item or bind variable, set SELDFMTL(J) before the FETCH or BNDDFMTL(J) before the OPEN to the length of the packed-decimal format stored in SEL-DFMT or BND-DFMT. Otherwise, set SELDFMTL(J) or BNDDFMTL(J) to zero.</p>
<p>If the value of SELDFMTL(J) or BNDDFMTL(J) is zero, SELDFMT(J) or BNDDFMT(J) are not used.</p>
<p class="subhead1"><a id="LNPCB729"></a>SELDVTYP | BNDDVTYP</p>
<p>The <span class="bold">SELDVTYP | BNDDVTYP</span> table contains the datatype codes of select-list or bind-variable values. These codes determine how Oracle data is converted when stored in the data buffers addressed by elements of SELDV. The datatype descriptor table is further described in <a href="#i9051">&#34;Converting Data&#34;</a>.<a id="sthref1449"></a><a id="sthref1450"></a><a id="sthref1451"></a><a id="sthref1452"></a></p>
<p class="subhead1"><a id="LNPCB730"></a>Select Descriptors</p>
<p>DESCRIBE SELECT LIST sets the table of datatype codes to the <span class="italic">internal</span> datatype (for example, VARCHAR2, CHAR, NUMBER, or DATE) of the items in the select list.</p>
<p>Before a FETCH is executed, you might want to reset some datatypes because the internal format of datatypes can be difficult to handle. For display purposes, it is usually a good idea to coerce the datatype of select-list values to VARCHAR2. For calculations, you might want to coerce numbers from Oracle to COBOL format. See <a href="#i25065">&#34;Coercing Datatypes&#34;</a>.</p>
<p>The high bit of SELDVTYP(J) is set to indicate the NULL/not NULL status of the Jth select-list column. You must always clear this bit before issuing an OPEN or FETCH command. Use the library routine SQLNUL to retrieve the datatype code and clear the NULL/not NULL bit. For more information, see: <a href="#i25272">&#34;Handling NULL/Not NULL Datatypes&#34;</a>.</p>
<p>It is best to change the NUMBER internal datatype to an external datatype compatible with that of the COBOL data buffer addressed by SELDV(J).</p>
<p class="subhead1"><a id="LNPCB731"></a>Bind Descriptors</p>
<p>DESCRIBE BIND VARIABLES sets the table of datatype codes to zeros. You must reset the table of datatypes before issuing the OPEN command. The code represents the external (COBOL) datatype of the buffer addressed by BNDDV(J). Often, bind-variable values are stored in character strings, so the datatype table elements are set to 1 (the VARCHAR2 datatype code).</p>
<p>To change the datatype of the Jth select-list or bind-variable value, reset SELDVTYP(J) or BNDDVTYP(J) to the datatype you want.</p>
<p class="subhead1"><a id="LNPCB732"></a>SELDI | BNDDI</p>
<p>The <span class="bold">SELDI | BNDDI</span> table contains the addresses of data buffers that store indicator-variable values. You must set the elements of SELDI or BNDDI using SQLADR. <a id="sthref1453"></a><a id="sthref1454"></a><a id="sthref1455"></a><a id="sthref1456"></a></p>
<p class="subhead1"><a id="LNPCB733"></a>Select Descriptors</p>
<p>You must set this table before issuing the FETCH command. When Oracle executes the statement</p>
<pre>     EXEC SQL FETCH ... USING DESCRIPTOR ... 
</pre>
<p>if the Jth returned select-list value is NULL, the buffer addressed by SELDI(J) is set to -1. Otherwise, it is set to zero (the value is not NULL) or a positive integer (the value was truncated).</p>
<p class="subhead1"><a id="LNPCB734"></a>Bind Descriptors</p>
<p>You must initialize this table and set the associated indicator variables before issuing the OPEN command. When Oracle executes the statement</p>
<pre>     EXEC SQL OPEN ... USING DESCRIPTOR ...
</pre>
<p>the buffer addressed by BNDDI(J) determines whether the Jth bind variable is NULL. If the value of an indicator variable is -1, its associated bind variable is NULL.</p>
<p class="subhead1"><a id="LNPCB735"></a>SELDH-VNAME | BNDDH-VNAME</p>
<p>The <span class="bold">SELDH-VNAME | BNDDH-VNAME</span> table contains the addresses of data buffers that store select-list or place-holder names as they appear in dynamic SQL statements. You must set the elements of SELDH-VNAME or BNDDH-VNAME using SQLADR before issuing the DESCRIBE command.<a id="sthref1457"></a><a id="sthref1458"></a><a id="sthref1459"></a><a id="sthref1460"></a></p>
<p>DESCRIBE directs Oracle to store the name of the Jth select-list item or place-holder in the data buffer addressed by SELDH-VNAME(J) or BNDDH-VNAME(J). Thus, Oracle stores the Jth select-list or place-holder name in SEL-DH-VNAME(J) or BND-DH-VNAME(J).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <span class="bold">SELDH-VNAME | BNDDH-VNAME</span> table contains only the name of the column, and <span class="italic">not</span> the table-qualifier.column name, even if you provide it in your SQL statement. If, for example, you were to do a describe of select-list in the SQL statement <code>select a.owner from all_tables</code> the software will return <code>not a.owner</code>, but instead, <code>owner</code>. If necessary, you should use column aliases to correctly identify a column in the select list.</div>
<p class="subhead1"><a id="LNPCB736"></a>SELDH-MAX-VNAMEL | BNDDH-MAX-VNAMEL</p>
<p>The <span class="bold">SELDH-MAX-VNAMEL | BNDDH-MAX-VNAMEL</span> table contains the maximum lengths of the data buffers that store select-list or place-holder names. The buffers are addressed by the elements of SELDH-VNAME or BNDDH-VNAME.<a id="sthref1461"></a><a id="sthref1462"></a><a id="sthref1463"></a><a id="sthref1464"></a></p>
<p>You must set the elements of SELDH-MAX-VNAMEL or BNDDH-MAX-VNAMEL before issuing the DESCRIBE command. Each select-list or place-holder name buffer can have a different length.</p>
<p class="subhead1"><a id="LNPCB737"></a>SELDH-CUR-VNAMEL | BNDDH-CUR-VNAMEL</p>
<p>The <span class="bold">SELDH-CUR-VNAMEL | BNDDH-CUR-VNAMEL</span> table contains the actual lengths of the names of the select-list or place-holder. DESCRIBE sets the table of actual lengths to the number of characters in each select-list or place-holder name.<a id="sthref1465"></a><a id="sthref1466"></a><a id="sthref1467"></a><a id="sthref1468"></a></p>
<p class="subhead1"><a id="LNPCB738"></a>SELDI-VNAME | BNDDI-VNAME</p>
<p>The <span class="bold">SELDI-VNAME | BNDDI-VNAME</span> table contains the addresses of data buffers that store indicator-variable names.</p>
<p>You can associate indicator-variable values with select-list items and bind variables. However, you can associate indicator-variable names only with bind variables. You can use this table only with bind descriptors.<a id="sthref1469"></a><a id="sthref1470"></a><a id="sthref1471"></a><a id="sthref1472"></a> You must set the elements of BNDDI-VNAME using SQLADR before issuing the DESCRIBE command.</p>
<p>DESCRIBE BIND VARIABLES directs Oracle to store any indicator-variable names in the data buffers addressed by BNDDI-VNAME(1) through BNDDI-VNAME(SQLDNUM). Thus, Oracle stores the Jth indicator-variable name in BND-DI-VNAME(J).</p>
<p class="subhead1"><a id="LNPCB739"></a>SELDI-MAX-VNAMEL | BNDDI-MAX-VNAMEL</p>
<p>The <span class="bold">SELDI-MAX-VNAMEL | BNDDI-MAX-VNAMEL</span> table contains the maximum lengths of the data buffers that store indicator-variable names. The buffers are addressed by the elements of SELDI-VNAME or BNDDI-VNAME.</p>
<p>You can associate indicator-variable names only with bind variables. You can use this table only with bind descriptors.<a id="sthref1473"></a><a id="sthref1474"></a><a id="sthref1475"></a><a id="sthref1476"></a></p>
<p>You must set the elements BNDDI-MAX-VNAMEL(1) through BNDDI-MAX-VNAMEL(SQLDNUM) before issuing the DESCRIBE command. Each indicator-variable name buffer can have a different length.</p>
<p class="subhead1"><a id="LNPCB740"></a>SELDI-CUR-VNAMEL | BNDDI-CUR-VNAMEL</p>
<p>The <span class="bold">SELDI-CUR-VNAMEL | BNDDI-CUR-VNAMEL</span> table contains the actual lengths of the names of the indicator variables. You can associate indicator-variable names only with bind variables. You can use this table only with bind descriptors.<a id="sthref1477"></a><a id="sthref1478"></a><a id="sthref1479"></a><a id="sthref1480"></a></p>
<p>DESCRIBE BIND VARIABLES sets the table of actual lengths to the number of characters in each indicator-variable name.</p>
<p class="subhead1"><a id="LNPCB741"></a>SELDFCLP | BNDDFCLP</p>
<p>The <span class="bold">SELDFCLP | BNDDFCLP</span> table is reserved for future use. It must be present because Oracle expects the group item SELDSC or BNDDSC to be a certain size.<a id="sthref1481"></a><a id="sthref1482"></a><a id="sthref1483"></a><a id="sthref1484"></a> You must currently set the elements of SELDFCLP and BNDDFCLP to zero.</p>
<p class="subhead1"><a id="LNPCB742"></a>SELDFCRCP | BNDDFCRCP</p>
<p>The <span class="bold">SELDFCRCP | BNDDFCRCP</span> table is reserved for future use. It must be present because Oracle expects the group item SELDSC or BNDDSC to be a certain size.<a id="sthref1485"></a><a id="sthref1486"></a><a id="sthref1487"></a><a id="sthref1488"></a> You must set the elements of SELDFCRCP and BNDDFCRCP to zero.</p>
</div>
<!-- class="sect1" -->
<a id="i10853"></a>
<div id="LNPCB743" class="sect1">
<h2 class="sect1">Prerequisite Knowledge</h2>
<p>You need a working knowledge of the following subjects to implement dynamic SQL Method 4:<a id="sthref1489"></a></p>
<ul>
<li>
<p>Using the library routine SQLADR</p>
</li>
<li>
<p>converting data</p>
</li>
<li>
<p>coercing datatypes</p>
</li>
<li>
<p>handling NULL/not NULL datatypes</p>
</li>
</ul>
<a id="i9020"></a>
<div id="LNPCB744" class="sect2">
<h3 class="sect2">Using SQLADR</h3>
<p>You must call the library subroutine SQLADR to get the addresses of data buffers that store input and output values. You store the addresses in a bind or select SQLDA so that Oracle knows where to read bind-variable values or write select-list values.</p>
<p>Call SQLADR using the syntax<a id="sthref1490"></a><a id="sthref1491"></a><a id="sthref1492"></a><a id="sthref1493"></a></p>
<pre>     CALL &#34;SQLADR&#34; USING BUFFER, ADDRESS.
</pre>
<p>where:</p>
<dl>
<dt>BUFFER</dt>
<dd>
<p>Is a data buffer that stores the value or name of a select-list item, bind variable, or indicator variable.</p>
</dd>
<dt>ADDRESS</dt>
<dd>
<p>Is an integer variable that returns the address of the data buffer.</p>
<p>A call to SQLADR stores the address of BUFFER in ADDRESS. The next example uses SQLADR to initialize the select descriptor tables SELDV, SELDH-VNAME, and SELDI. Their elements address data buffers for select-list values, select-list names, and indicator values.</p>
<pre> PROCEDURE DIVISION.
     ... 
     PERFORM INIT-SELDSC 
         VARYING J FROM 1 BY 1 UNTIL J &gt; SQLDNUM IN SELDSC.
     ... 
 INIT-SELDSC.
     CALL &#34;SQLADR&#34; USING SEL-DV(J), SELDV(J).
     CALL &#34;SQLADR&#34; USING SEL-DH-VNAME(J), SELDH-VNAME(J).
     CALL &#34;SQLADR&#34; USING SEL-DI(J), SELDI(J).
</pre></dd>
</dl>
</div>
<!-- class="sect2" -->
<a id="i9051"></a>
<div id="LNPCB745" class="sect2">
<h3 class="sect2">Converting Data</h3>
<p>This section provides more detail about the datatype descriptor table. In host programs that use neither datatype equivalencing nor dynamic SQL Method 4, the conversion between internal and external datatypes is determined at precompile time. By default, Pro*COBOL assigns a specific external datatype to each host variable. For example, Pro*COBOL assigns the INTEGER external datatype to host variables of type PIC S9(n) COMP.</p>
<p>However, Method 4 lets you control data conversion and formatting. You specify conversions by setting datatype codes in the datatype descriptor table.</p>
<p class="subhead1"><a id="LNPCB746"></a>Internal Datatypes</p>
<p>Internal datatypes specify the formats used by Oracle to store column values in database tables to represent pseudocolumn values.<a id="sthref1494"></a><a id="sthref1495"></a></p>
<p>When you issue a DESCRIBE SELECT LIST command, Oracle returns the internal datatype code for each select-list item to the SELDVTYP (datatype) descriptor table. For example, the datatype code for the Jth select-list item is returned to SELDVTYP(J).</p>
<p><a href="#g26357">Table 11-1</a> shows the internal datatypes and their codes:</p>
<div id="LNPCB747" class="tblformal">
<p class="titleintable"><a id="sthref1496"></a><a id="g26357"></a>Table 11-1 Internal Datatypes and Related Codes</p>
<table class="cellalignment4971" title="Internal Datatypes and Related Codes" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t7">Internal Datatype</th>
<th class="cellalignment4972" id="r1c2-t7">Code</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t7" headers="r1c1-t7">
<p>VARCHAR2</p>
<p>NUMBER</p>
<p>LONG</p>
<p>ROWID</p>
<p>DATE</p>
<p>RAW</p>
<p>LONG RAW</p>
<p>CHAR</p>
</td>
<td class="cellalignment4973" headers="r2c1-t7 r1c2-t7">
<p>1</p>
<p>2</p>
<p>8</p>
<p>11</p>
<p>12</p>
<p>23</p>
<p>24</p>
<p>96</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p class="subhead1"><a id="LNPCB748"></a><a id="sthref1497"></a>External Datatypes</p>
<p>External datatypes specify the formats used to store values in input and output host variables.<a id="sthref1498"></a><a id="sthref1499"></a></p>
<p>The DESCRIBE BIND VARIABLES command sets the BNDDVTYP table of datatype codes to zeros. Therefore, you must reset the codes <span class="italic">before</span> issuing the OPEN command. The codes tell Oracle which external datatypes to expect for the various bind variables. For the Jth bind variable, reset BNDDVTYP(J) to the external datatype you want.</p>
<p>The following table shows the external datatypes and their codes, as well as the corresponding COBOL datatypes:</p>
<div id="LNPCB749" class="tblformal">
<p class="titleintable"><a id="sthref1500"></a><a id="g26226"></a>Table 11-2 Oracle External and Related COBOL Datatypes</p>
<table class="cellalignment4971" title="Oracle External and Related COBOL Datatypes " summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t8">Name</th>
<th class="cellalignment4972" id="r1c2-t8">Code</th>
<th class="cellalignment4972" id="r1c3-t8">COBOL Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t8" headers="r1c1-t8">
<p>VARCHAR2</p>
</td>
<td class="cellalignment4973" headers="r2c1-t8 r1c2-t8">
<p>1</p>
</td>
<td class="cellalignment4973" headers="r2c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>) when MODE=ANSI</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t8" headers="r1c1-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment4973" headers="r3c1-t8 r1c2-t8">
<p>2</p>
</td>
<td class="cellalignment4973" headers="r3c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t8" headers="r1c1-t8">
<p>INTEGER</p>
</td>
<td class="cellalignment4973" headers="r4c1-t8 r1c2-t8">
<p>3</p>
</td>
<td class="cellalignment4973" headers="r4c1-t8 r1c3-t8">
<p>PIC S9(<span class="italic">n</span>) COMP</p>
<p>(Use COMP, not COMP5, on SPARC Solaris 64 bit platforms)</p>
<p>PIC S9(<span class="italic">n</span>) COMP5</p>
<p>(COMP5 for byte-swapped platforms)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t8" headers="r1c1-t8">
<p>FLOAT</p>
</td>
<td class="cellalignment4973" headers="r5c1-t8 r1c2-t8">
<p>4</p>
</td>
<td class="cellalignment4973" headers="r5c1-t8 r1c3-t8">
<p>COMP-1</p>
<p>COMP-2</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t8" headers="r1c1-t8">
<p>STRING (<a href="#CDDHDHEH">1</a>)</p>
</td>
<td class="cellalignment4973" headers="r6c1-t8 r1c2-t8">
<p>5</p>
</td>
<td class="cellalignment4973" headers="r6c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t8" headers="r1c1-t8">
<p>VARNUM</p>
</td>
<td class="cellalignment4973" headers="r7c1-t8 r1c2-t8">
<p>6</p>
</td>
<td class="cellalignment4973" headers="r7c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t8" headers="r1c1-t8">
<p>DECIMAL</p>
</td>
<td class="cellalignment4973" headers="r8c1-t8 r1c2-t8">
<p>7</p>
</td>
<td class="cellalignment4973" headers="r8c1-t8 r1c3-t8">
<p>PIC S9(n)V9(n) COMP-3</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t8" headers="r1c1-t8">
<p>LONG</p>
</td>
<td class="cellalignment4973" headers="r9c1-t8 r1c2-t8">
<p>8</p>
</td>
<td class="cellalignment4973" headers="r9c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r10c1-t8" headers="r1c1-t8">
<p>VARCHAR (<a href="#i10728">2</a>)</p>
</td>
<td class="cellalignment4973" headers="r10c1-t8 r1c2-t8">
<p>9</p>
</td>
<td class="cellalignment4973" headers="r10c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>) VARYING</p>
<p>PIC N(<span class="italic">n</span>) VARYING</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r11c1-t8" headers="r1c1-t8">
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r11c1-t8 r1c2-t8">
<p>11</p>
</td>
<td class="cellalignment4973" headers="r11c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r12c1-t8" headers="r1c1-t8">
<p>DATE</p>
</td>
<td class="cellalignment4973" headers="r12c1-t8 r1c2-t8">
<p>12</p>
</td>
<td class="cellalignment4973" headers="r12c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r13c1-t8" headers="r1c1-t8">
<p>VARRAW (<a href="#i10728">2</a>)</p>
</td>
<td class="cellalignment4973" headers="r13c1-t8 r1c2-t8">
<p>15</p>
</td>
<td class="cellalignment4973" headers="r13c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r14c1-t8" headers="r1c1-t8">
<p>RAW</p>
</td>
<td class="cellalignment4973" headers="r14c1-t8 r1c2-t8">
<p>23</p>
</td>
<td class="cellalignment4973" headers="r14c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r15c1-t8" headers="r1c1-t8">
<p>LONG RAW</p>
</td>
<td class="cellalignment4973" headers="r15c1-t8 r1c2-t8">
<p>24</p>
</td>
<td class="cellalignment4973" headers="r15c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r16c1-t8" headers="r1c1-t8">
<p>UNSIGNED</p>
</td>
<td class="cellalignment4973" headers="r16c1-t8 r1c2-t8">
<p>68</p>
</td>
<td class="cellalignment4973" headers="r16c1-t8 r1c3-t8">
<p>(not supported)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r17c1-t8" headers="r1c1-t8">
<p>DISPLAY</p>
</td>
<td class="cellalignment4973" headers="r17c1-t8 r1c2-t8">
<p>91</p>
</td>
<td class="cellalignment4973" headers="r17c1-t8 r1c3-t8">
<p>PIC S9...9V9...9 DISPLAY SIGN LEADING SEPARATE</p>
<p>PIC S9(<span class="italic">n</span>)V9(<span class="italic">n</span>) DISPLAY SIGN LEADING SEPARATE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r18c1-t8" headers="r1c1-t8">
<p>LONG VARCHAR (<a href="#i10728">2</a>)</p>
</td>
<td class="cellalignment4973" headers="r18c1-t8 r1c2-t8">
<p>94</p>
</td>
<td class="cellalignment4973" headers="r18c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r19c1-t8" headers="r1c1-t8">
<p>LONG VARRAW (<a href="#i10728">2</a>)</p>
</td>
<td class="cellalignment4973" headers="r19c1-t8 r1c2-t8">
<p>95</p>
</td>
<td class="cellalignment4973" headers="r19c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r20c1-t8" headers="r1c1-t8">
<p>CHARF</p>
</td>
<td class="cellalignment4973" headers="r20c1-t8 r1c2-t8">
<p>96</p>
</td>
<td class="cellalignment4973" headers="r20c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>) when MODE = ANSI</p>
<p>PIC N(<span class="italic">n</span>) when MODE = ANSI</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r21c1-t8" headers="r1c1-t8">
<p>CHARZ (<a href="#CDDHDHEH">1</a>)</p>
</td>
<td class="cellalignment4973" headers="r21c1-t8 r1c2-t8">
<p>97</p>
</td>
<td class="cellalignment4973" headers="r21c1-t8 r1c3-t8">
<p>PIC X(<span class="italic">n</span>)</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r22c1-t8" headers="r1c1-t8">
<p>CURSOR</p>
</td>
<td class="cellalignment4973" headers="r22c1-t8 r1c2-t8">
<p>102</p>
</td>
<td class="cellalignment4973" headers="r22c1-t8 r1c3-t8">
<p>SQL-CURSOR</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p><span class="bold">Notes</span>:</p>
<a id="i10726"></a>
<ol>
<li id="CDDHDHEH">
<p>For use in an EXEC SQL VAR statement only.</p>
</li>
<li id="i10728">
<p>Include the <span class="italic">n</span>-byte length field.</p>
</li>
</ol>
<p>For more information about the datatypes and their formats, see <a href="pco04dat.htm#i22898">&#34;The Oracle Database Datatypes&#34;</a>.</p>
<p class="subhead1"><a id="LNPCB750"></a>PL/SQL Datatypes</p>
<p>PL/SQL provides a variety of predefined scalar and composite datatypes. A <span class="italic">scalar</span> type has no internal components. A <span class="italic">composite</span> type has internal components that can be manipulated individually. <a href="#i10618">Table 11-4</a> shows the predefined PL/SQL scalar datatypes and their internal datatype equivalence</p>
<div id="LNPCB751" class="tblformal">
<p class="titleintable"><a id="sthref1501"></a><a id="sthref1502"></a>Table 11-3 <span class="bolditalic">PL/SQL Datatype Equivalences with Internal Datatypes</span></p>
<table class="cellalignment4971" title="PL/SQL Datatype Equivalences with Internal Datatypes" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t9">PL/SQL Datatype</th>
<th class="cellalignment4972" id="r1c2-t9">Oracle Internal Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t9" headers="r1c1-t9">
<p>VARCHAR</p>
<p>VARCHAR2</p>
</td>
<td class="cellalignment4973" headers="r2c1-t9 r1c2-t9">
<p>VARCHAR2</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t9" headers="r1c1-t9">
<p>BINARY_INTEGER</p>
<p>DEC</p>
<p>DECIMAL</p>
<p>DOUBLE PRECISION</p>
<p>FLOAT</p>
<p>INT</p>
<p>INTEGER</p>
<p>NATURAL</p>
<p>NUMBER</p>
<p>NUMERIC</p>
<p>POSITIVE</p>
<p>REAL</p>
<p>SMALLINT</p>
</td>
<td class="cellalignment4973" headers="r3c1-t9 r1c2-t9">
<p>NUMBER</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t9" headers="r1c1-t9">
<p>LONG</p>
</td>
<td class="cellalignment4973" headers="r4c1-t9 r1c2-t9">
<p>LONG</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t9" headers="r1c1-t9">
<p>ROWID</p>
</td>
<td class="cellalignment4973" headers="r5c1-t9 r1c2-t9">
<p>ROWID</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r6c1-t9" headers="r1c1-t9">
<p>DATE</p>
</td>
<td class="cellalignment4973" headers="r6c1-t9 r1c2-t9">
<p>DATE</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r7c1-t9" headers="r1c1-t9">
<p>RAW</p>
</td>
<td class="cellalignment4973" headers="r7c1-t9 r1c2-t9">
<p>RAW</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r8c1-t9" headers="r1c1-t9">
<p>LONG RAW</p>
</td>
<td class="cellalignment4973" headers="r8c1-t9 r1c2-t9">
<p>LONG RAW</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r9c1-t9" headers="r1c1-t9">
<p>CHAR</p>
<p>CHARACTER</p>
<p>STRING</p>
</td>
<td class="cellalignment4973" headers="r9c1-t9 r1c2-t9">
<p>CHAR</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="i25065"></a>
<div id="LNPCB752" class="sect2">
<h3 class="sect2"><a id="sthref1503"></a><a id="sthref1504"></a><a id="sthref1505"></a><a id="sthref1506"></a>Coercing Datatypes</h3>
<p>For a select descriptor, DESCRIBE SELECT LIST can return any of the internal datatypes. Often, as in the case of character data, the internal datatype corresponds exactly to the external datatype you want to use. However, a few internal datatypes map to external datatypes that can be difficult to handle. Thus, you might want to reset some elements in the SELDVTYP descriptor table.</p>
<p>For example, you might want to reset NUMBER values to FLOAT values, which correspond to PIC S9(<span class="italic">n</span>)V9(<span class="italic">n</span>) COMP-1 values in COBOL. Oracle does any necessary conversion between internal and external datatypes at FETCH time. Be sure to reset the datatypes <span class="italic">after</span> the DESCRIBE SELECT LIST but <span class="italic">before</span> the FETCH.<a id="sthref1507"></a><a id="sthref1508"></a><a id="sthref1509"></a></p>
<p>For a bind descriptor, DESCRIBE BIND VARIABLES does <span class="italic">not</span> return the datatypes of bind variables, only their number and names. Therefore, you must explicitly set the BNDDVTYP table of datatype codes to tell Oracle the external datatype of each bind variable. Oracle does any necessary conversion between external and internal datatypes at OPEN time.</p>
<p>When you reset datatype codes in the SELDVTYP or BNDDVTYP descriptor table, you are &#34;coercing datatypes.&#34; For example, to coerce the Jth select-list value to VARCHAR2, use the following statement:</p>
<pre>*    Coerce select-list value to VARCHAR2. 
     MOVE 1 TO SELDVTYP(J). 
</pre>
<p>When coercing a NUMBER select-list value to VARCHAR2 for display purposes, you must also extract the precision and scale bytes of the value and use them to compute a maximum display length. Then, before the FETCH, you must reset the appropriate element of the SELDVLN (length) descriptor table to tell Oracle the buffer length to use. To specify the length of the Jth select-list value, set SELDVLN(J) to the length you need.<a id="sthref1510"></a></p>
<p>For example, if DESCRIBE SELECT LIST finds that the Jth select-list item is of type NUMBER, and you want to store the returned value in a COBOL variable declared as PIC S9(<span class="italic">n</span>)V9(<span class="italic">n</span>) COMP-1, simply set SELDVTYP(J) to 4 and SELDVLN(J) to the length of COMP-1 numbers on your system.<a id="sthref1511"></a></p>
<p class="subhead1"><a id="LNPCB753"></a>Exceptions</p>
<p>In some cases, the internal datatypes that DESCRIBE SELECT LIST returns might not suit your purposes. Two examples of this are DATE and NUMBER. When you DESCRIBE a DATE select-list item, Oracle returns the datatype code 12 to the SELDVTYP table. Unless you reset the code before the FETCH, the date value is returned in its 7-byte internal format. To get the date in its default character format, you must change the datatype code from 12 to 1 (VARCHAR2) and increase the SELDVLN value from 7 to 9.</p>
<p>Similarly, when you DESCRIBE a NUMBER select-list item, Oracle returns the datatype code 2 to the SELDVTYP table. Unless you reset the code before the FETCH, the numeric value is returned in its internal format, which is probably not desired. Therefore, change the code from 2 to 1 (VARCHAR2), 3 (INTEGER), 4 (FLOAT), or some other appropriate datatype.</p>
<p class="subhead1"><a id="i9038"></a><a id="LNPCB754"></a>Extracting Precision and Scale</p>
<p>The library subroutine SQLPRC extracts precision and scale. Normally, it is used after the DESCRIBE SELECT LIST, and its first parameter is SELDVLN(J). To call SQLPRC, use the following syntax<a id="sthref1512"></a><a id="sthref1513"></a><a id="sthref1514"></a><a id="sthref1515"></a><a id="sthref1516"></a></p>
<pre>     CALL &#34;SQLPRC&#34; USING LENGTH, PRECISION, SCALE.
</pre>
<p>where:</p>
<div class="inftblinformal">
<table class="cellalignment4974" title="descriptions of length, precision, and scale" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t10">Syntax</th>
<th class="cellalignment4972" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t10" headers="r1c1-t10">LENGTH</td>
<td class="cellalignment4973" headers="r2c1-t10 r1c2-t10">Is an integer variable that stores the length of a NUMBER value. The scale and precision of the value are stored in the low and next-higher bytes, respectively.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t10" headers="r1c1-t10">PRECISION</td>
<td class="cellalignment4973" headers="r3c1-t10 r1c2-t10">Is an integer variable that returns the <span class="italic">precision</span> of the NUMBER value. Precision is the number of significant digits. It is set to zero if the select-list item refers to a NUMBER of unspecified size. In this case, because the size is unspecified, assume the maximum precision, 38.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t10" headers="r1c1-t10">SCALE</td>
<td class="cellalignment4973" headers="r4c1-t10 r1c2-t10">Is an integer variable that returns the <span class="italic">scale</span> of the NUMBER value. Scale specifies where rounding will occur. For example, a scale of 2 means the value is rounded to the nearest hundredth (3.456 becomes 3.46); a scale of -3 means that the number is rounded to the nearest thousand (3.456 becomes 3000).</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>The following example shows how SQLPRC is used to compute maximum display lengths for NUMBER values that will be coerced to VARCHAR2:<a id="sthref1517"></a></p>
<pre> WORKING-STORAGE SECTION. 
 01  PRECISION       PIC S9(9) COMP. 
 01  SCALE           PIC S9(9) COMP. 
 01  DISPLAY-LENGTH  PIC S9(9) COMP. 
 01  MAX-LENGTH      PIC S9(9) COMP VALUE 80. 
     ... 
 PROCEDURE DIVISION. 
     ... 
     PERFORM ADJUST-LENGTH 
         VARYING J FROM 1 BY 1 UNTIL J &gt; SQLDNUM IN SELDSC. 
 ADJUST-LENGTH. 
*    If datatype is NUMBER, extract precision and scale. 
     IF SELDVTYP(J) = 2 
         CALL &#34;SQLPRC&#34; USING SELDVLN(J), PRECISION, SCALE. 
     MOVE 0 TO DISPLAY-LENGTH. 
*    Precision is set to zero if the select-list item 
*    refers to a NUMBER of unspecified size.  We allow for 
*    a maximum precision of 10. 
     IF SELDVTYP(J) = 2 AND PRECISION = 0 
         MOVE 10 TO DISPLAY-LENGTH. 
*    Allow for possible decimal point and sign. 
     IF SELDVTYP(J) = 2 AND PRECISION &gt; 0 
         ADD 2 TO PRECISION 
         MOVE PRECISION TO DISPLAY-LENGTH. 
     ... 
</pre>
<p>Notice that the first parameter in the subroutine call is the Jth element in the table of select-list lengths.</p>
<p>The SQLPRC procedure, defined in the SQLLIB runtime library, returns zero as the precision and scale values for certain SQL datatypes. The SQLPR2 procedure is similar to SQLPRC in that it has the same syntax and returns the same binary values, except for the datatypes shown in this table:</p>
<div id="LNPCB755" class="tblformal">
<p class="titleintable"><a id="sthref1518"></a><a id="sthref1519"></a>Table 11-4 Datatype Exceptions to the SQLPR2 Procedure</p>
<table class="cellalignment4971" title="Datatype Exceptions to the SQLPR2 Procedure" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t11">SQL Datatype</th>
<th class="cellalignment4972" id="r1c2-t11">Binary Precision</th>
<th class="cellalignment4972" id="r1c3-t11">Binary Scale</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t11" headers="r1c1-t11">
<p>FLOAT</p>
</td>
<td class="cellalignment4973" headers="r2c1-t11 r1c2-t11">
<p>126</p>
</td>
<td class="cellalignment4973" headers="r2c1-t11 r1c3-t11">
<p>-127</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t11" headers="r1c1-t11">
<p>FLOAT(<span class="italic">n</span>)</p>
</td>
<td class="cellalignment4973" headers="r3c1-t11 r1c2-t11">
<p><span class="italic">n</span> (range is 1 .. 126)</p>
</td>
<td class="cellalignment4973" headers="r3c1-t11 r1c3-t11">
<p>-127</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t11" headers="r1c1-t11">
<p>REAL</p>
</td>
<td class="cellalignment4973" headers="r4c1-t11 r1c2-t11">
<p>63</p>
</td>
<td class="cellalignment4973" headers="r4c1-t11 r1c3-t11">
<p>-127</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t11" headers="r1c1-t11">
<p>DOUBLE PRECISION</p>
</td>
<td class="cellalignment4973" headers="r5c1-t11 r1c2-t11">
<p>126</p>
</td>
<td class="cellalignment4973" headers="r5c1-t11 r1c3-t11">
<p>-127</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="i25272"></a>
<div id="LNPCB756" class="sect2">
<h3 class="sect2">Handling NULL/Not NULL Datatypes</h3>
<p>For every select-list column (not expression), DESCRIBE SELECT LIST returns a NULL/not NULL indication in the datatype table of the select descriptor. If the Jth select-list column is constrained to be not NULL, the high-order bit of SELDVTYP(J) datatype variable is clear; otherwise, it is set.<a id="sthref1520"></a></p>
<p>Before using the datatype in an OPEN or FETCH statement, if the NULL status bit is set, you must clear it. Never set the bit.</p>
<p>You can use the library routine SQLNUL to find out if a column allows NULL datatypes and to clear the datatype&#39;s NULL status bit. You call SQLNUL using the syntax<a id="sthref1521"></a><a id="sthref1522"></a><a id="sthref1523"></a><a id="sthref1524"></a><a id="sthref1525"></a></p>
<pre>     CALL &#34;SQLNUL&#34; USING VALUE-TYPE, TYPE-CODE, NULL-STATUS.
</pre>
<p>where:</p>
<div class="inftblinformal">
<table class="cellalignment4974" title="descriptions of value-type, type-code, and null-status" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t12">Syntax</th>
<th class="cellalignment4972" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t12" headers="r1c1-t12">VALUE-TYPE</td>
<td class="cellalignment4973" headers="r2c1-t12 r1c2-t12">Is a 2-byte integer variable that stores the datatype code of a select-list column.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t12" headers="r1c1-t12">TYPE-CODE</td>
<td class="cellalignment4973" headers="r3c1-t12 r1c2-t12">Is a 2-byte integer variable that returns the datatype code of the select-list column with the high-order bit cleared.</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t12" headers="r1c1-t12">NULL-STATUS</td>
<td class="cellalignment4973" headers="r4c1-t12 r1c2-t12">Is an integer variable that returns the NULL status of the select-list column. 1 means that the column allows NULLs; 0 means that it does not.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>The following example shows how to use SQLNUL:<a id="sthref1526"></a></p>
<pre> WORKING-STORAGE SECTION.
     ... 
*    Declare variable for subroutine call.
     01  NULL-STATUS  PIC S9(9) COMP.
     ... 
 PROCEDURE DIVISION.
 MAIN.
     EXEC SQL WHENEVER SQLERROR GOTO SQL-ERROR END-EXEC.
     ...
     PERFORM HANDLE-NULLS
         VARYING J FROM 1 BY 1 UNTIL J &gt; SQLDNUM IN SELDSC.
     ...
 HANDLE-NULLS.
*    Find out if column is NOT NULL, and clear high-order bit.
     CALL &#34;SQLNUL&#34; USING SELDVTYP(J), SELDVTYP(J), NULL-STATUS.
*    If NULL-STATUS = 1, NULLs are allowed.
</pre>
<p>Notice that the first and second parameters in the subroutine call are the same. Respectively, they are the datatype variable before and after its NULL status bit is cleared.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i10858"></a>
<div id="LNPCB757" class="sect1">
<h2 class="sect1">The Basic Steps</h2>
<p>Method 4 can be used to process <span class="italic">any</span> dynamic SQL statement. In the example in <a href="#i25561">&#34;Using Host Tables with Method 4&#34;</a>, a query is processed so that you can see how both input and output host variables are handled.<a id="sthref1527"></a></p>
<p>To process the dynamic query, our example program takes the following steps:</p>
<ol>
<li>
<p>Declare a host string to hold the query text.</p>
</li>
<li>
<p>Declare select and bind descriptors.</p>
</li>
<li>
<p>Set the maximum number of select-list items and place-holders that can be DESCRIBEd.</p>
</li>
<li>
<p>Initialize the select and bind descriptors.</p>
</li>
<li>
<p>Store the query text in the host string.</p>
</li>
<li>
<p>PREPARE the query from the host string.</p>
</li>
<li>
<p>DECLARE a cursor FOR the query.</p>
</li>
<li>
<p>DESCRIBE the bind variables INTO the bind descriptor.</p>
</li>
<li>
<p>Reset the number of place-holders to the number actually found by DESCRIBE.</p>
</li>
<li>
<p>Get values for the bind variables found by DESCRIBE.</p>
</li>
<li>
<p>OPEN the cursor USING the bind descriptor.</p>
</li>
<li>
<p>DESCRIBE the select list INTO the select descriptor.</p>
</li>
<li>
<p>Reset the number of select-list items to the number actually found by DESCRIBE.</p>
</li>
<li>
<p>Reset the length and datatype of each select-list item for display purposes.</p>
</li>
<li>
<p>FETCH a row from the database INTO data buffers using the select descriptor.</p>
</li>
<li>
<p>Process the select-list values returned by FETCH.</p>
</li>
<li>
<p>CLOSE the cursor when there are no more rows to FETCH.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the dynamic SQL statement is <span class="italic">not</span> a query or contains a known number of select-list items or place-holders, then some of the preceding steps are unnecessary.</div>
</div>
<!-- class="sect1" -->
<a id="i10863"></a>
<div id="LNPCB758" class="sect1">
<h2 class="sect1">A Closer Look at Each Step</h2>
<p>This section discusses each step in more detail. A full-length example program illustrating Method 4 is seen at the end of this chapter. With Method 4, you use the following sequence of embedded SQL statements:<a id="sthref1528"></a></p>
<pre>     EXEC SQL
         PREPARE &lt;statement_name&gt;
         FROM {:&lt;host_string&gt; | &lt;string_literal&gt;}
     END-EXEC.
     EXEC SQL 
         DECLARE &lt;cursor_name&gt; CURSOR FOR &lt;statement_name&gt;
     END-EXEC.
     EXEC SQL
         DESCRIBE BIND VARIABLES FOR &lt;statement_name&gt;
         INTO &lt;bind_descriptor_name&gt;
     END-EXEC.
     EXEC SQL
         OPEN &lt;cursor_name&gt; 
         [USING DESCRIPTOR &lt;bind_descriptor_name&gt;]
     END-EXEC.
     EXEC SQL
         DESCRIBE [SELECT LIST FOR] &lt;statement_name&gt;
         INTO &lt;select_descriptor_name&gt;
     END-EXEC.
     EXEC SQL
         FETCH &lt;cursor_name&gt; USING DESCRIPTOR &lt;select_descriptor_name&gt;
     END-EXEC.
     EXEC SQL
         CLOSE &lt;cursor_name&gt;
     END-EXEC.
</pre>
<p>If the number of select-list items in a dynamic query is known, you can omit DESCRIBE SELECT LIST and use the following Method 3 FETCH statement:</p>
<pre>EXEC SQL FETCH &lt;cursor_name&gt; INTO &lt;host_variable_list&gt; END-EXEC.
</pre>
<p>Alternatively, if the number of place-holders for bind variables in a dynamic SQL statement is known, you can omit DESCRIBE BIND VARIABLES and use the following Method 3 OPEN statement:</p>
<pre>     EXEC SQL OPEN &lt;cursor_name&gt; [USING &lt;host_variable_list&gt;] END-EXEC.
</pre>
<p>The next section illustrates how these statements allow your host program to accept and process a dynamic SQL statement using descriptors.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Several figures accompany the following discussion. To avoid cluttering the figures, it was necessary to confine descriptor tables to 3 elements and to limit the maximum length of names and values to 5 and 10 characters, respectively.</div>
<div id="LNPCB759" class="sect2"><a id="sthref1529"></a>
<h3 class="sect2">Declare a Host String</h3>
<p>Your program needs a host variable to store the text of the dynamic SQL statement. The host variable (SELECTSTMT in our example) must be declared as a character string:</p>
<pre>     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
     ... 
 01  SELECTSTMT  PIC X(120). 
     EXEC SQL END DECLARE SECTION END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB760" class="sect2"><a id="sthref1530"></a>
<h3 class="sect2">Declare the SQLDAs</h3>
<p>Because the query in our example might contain an unknown number of select-list items or place-holders, you must declare select and bind descriptors. Instead of hard-coding the SQLDAs, you use INCLUDE to copy them into your program, as follows:</p>
<pre>     EXEC SQL INCLUDE SELDSC END-EXEC. 
     EXEC SQL INCLUDE BNDDSC END-EXEC. 
</pre>
<p>For reference, the INCLUDEd declaration of SELDSC follows:</p>
<pre> WORKING-STORAGE SECTION. 
     ... 
 01  SELDSC. 
         05  SQLDNUM              PIC S9(9) COMP. 
         05  SQLDFND              PIC S9(9) COMP. 
         05  SELDVAR              OCCURS 3 TIMES. 
             10 SELDV             PIC S9(9) COMP. 
             10 SELDFMT           PIC S9(9) COMP. 
             10 SELDVLN           PIC S9(9) COMP. 
             10 SELDFMTL          PIC S9(4) COMP. 
             10 SELDVTYP          PIC S9(4) COMP. 
             10 SELDI             PIC S9(9) COMP. 
             10 SELDH-VNAME       PIC S9(9) COMP. 
             10 SELDH-MAX-VNAMEL  PIC S9(4) COMP. 
             10 SELDH-CUR-VNAMEL  PIC S9(4) COMP. 
             10 SELDI-VNAME       PIC S9(9) COMP. 
             10 SELDI-MAX-VNAMEL  PIC S9(4) COMP. 
             10 SELDI-CUR-VNAMEL  PIC S9(4) COMP. 
             10 SELDFCLP          PIC S9(9) COMP. 
             10 SELDFCRCP         PIC S9(9) COMP. 

 01  XSELDI. 
     05  SEL-DI        OCCURS 3 TIMES PIC S9(9) COMP. 
 01  XSELDIVNAME. 
         05  SEL-DI-VNAME  OCCURS 3 TIMES PIC X(5). 
 01  XSELDV. 
         05  SEL-DV        OCCURS 3 TIMES PIC X(10). 
 01  XSELDHVNAME. 
         05  SEL-DH-VNAME  OCCURS 3 TIMES PIC X(5).  
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB761" class="sect2"><a id="sthref1531"></a>
<h3 class="sect2">Set the Maximum Number to DESCRIBE</h3>
<p>You next set the maximum number of select-list items or place-holders that can be described, as follows:</p>
<pre>     MOVE 3 TO SQLDNUM IN SELDSC. 
     MOVE 3 TO SQLDNUM IN BNDDSC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB762" class="sect2"><a id="sthref1532"></a>
<h3 class="sect2">Initialize the Descriptors</h3>
<p>You must initialize several descriptor variables. Some require the library subroutine SQLADR.</p>
<p>In our example, you store the maximum lengths of name buffers in the SELDH-MAX-VNAMEL, BNDDH-MAX-VNAMEL, and BNDDI-MAX-VNAMEL tables, and use SQLADR to store the addresses of value and name buffers in the SELDV, SELDI, BNDDV, BNDDI, SELDH-VNAME, BNDDH-VNAME, and BNDDI-VNAME tables.<a id="sthref1533"></a></p>
<pre> PROCEDURE DIVISION. 
     ... 
     PERFORM INIT-SELDSC 
         VARYING J FROM 1 BY 1 UNTIL J &gt; SQLDNUM IN SELDSC. 
     PERFORM INIT-BNDDSC 
         VARYING J FROM 1 BY 1 UNTIL J &gt; SQLDNUM IN BNDDSC. 
     ... 
 INIT-SELDSC. 
     MOVE SPACES TO SEL-DV(J). 
     MOVE SPACES TO SEL-DH-VNAME(J). 
     MOVE 5 TO SELDH-MAX-VNAMEL(J). 
     CALL &#34;SQLADR&#34; USING SEL-DV(J), SELDV(J). 
     CALL &#34;SQLADR&#34; USING SEL-DH-VNAME(J), SELDH-VNAME(J). 
     CALL &#34;SQLADR&#34; USING SEL-DI(J), SELDI(J). 
     ... 
 INIT-BNDDSC. 
     MOVE SPACES TO BND-DV(J). 
     MOVE SPACES TO BND-DH-VNAME(J). 
     MOVE SPACES TO BND-DI-VNAME(J). 
     MOVE 5 TO BNDDH-MAX-VNAMEL(J). 
     MOVE 5 TO BNDDI-MAX-VNAMEL(J). 
     CALL &#34;SQLADR&#34; USING BND-DV(J), BNDDV(J). 
     CALL &#34;SQLADR&#34; USING BND-DH-VNAME(J), BNDDH-VNAME(J). 
     CALL &#34;SQLADR&#34; USING BND-DI(J), BNDDI(J). 
     CALL &#34;SQLADR&#34; USING BND-DI-VNAME(J), BNDDI-VNAME(J).
     ...
</pre>
<p><a href="#i10618">Figure 11-3</a> and <a href="#i10659">Figure 11-4</a> represent the resulting descriptors.</p>
<div id="LNPCB763" class="figure">
<p class="titleinfigure"><a id="i10618"></a>Figure 11-3 Initialized Select Descriptor</p>
<img width="598" height="360" src="img/pco81007.gif" alt="Initialized Select Descriptor"/><br/>
<a id="sthref1534" href="img_text/pco81007.htm">Description of &#34;Figure 11-3 Initialized Select Descriptor&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="LNPCB764" class="figure">
<p class="titleinfigure"><a id="i10659"></a>Figure 11-4 Initialized Bind Descriptor</p>
<img width="496" height="502" src="img/pco81008.gif" alt="Initialized Bind Descriptor"/><br/>
<a id="sthref1535" href="img_text/pco81008.htm">Description of &#34;Figure 11-4 Initialized Bind Descriptor&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCB765" class="sect2"><a id="sthref1536"></a>
<h3 class="sect2">Store the Query Text in the Host String</h3>
<p>Next, you prompt the user for a SQL statement, then store the input string in SELECTSTMT as follows:</p>
<pre>     DISPLAY &#34;Enter a SELECT statement: &#34; WITH NO ADVANCING. 
     ACCEPT SELECTSTMT. 
</pre>
<p>We assume the user entered the following string:</p>
<pre>     SELECT ENAME, EMPNO, COMM FROM EMP WHERE COMM &lt; :BONUS
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB766" class="sect2"><a id="sthref1537"></a>
<h3 class="sect2">PREPARE the Query from the Host String</h3>
<p>PREPARE parses the SQL statement and gives it a name. In our example, PREPARE parses the host string SELECTSTMT and gives it the name SQLSTMT, as follows:<a id="sthref1538"></a><a id="sthref1539"></a></p>
<pre>     EXEC SQL PREPARE SQLSTMT FROM :SELECTSTMT END-EXEC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB767" class="sect2"><a id="sthref1540"></a>
<h3 class="sect2">DECLARE a Cursor</h3>
<p>DECLARE CURSOR defines a cursor by giving it a name and associating it with a specific SELECT statement.</p>
<p>To declare a cursor for static queries, use the following syntax:<a id="sthref1541"></a><a id="sthref1542"></a></p>
<pre>     EXEC SQL DECLARE cursor_name CURSOR FOR SELECT ... 
</pre>
<p>To declare a cursor for dynamic queries, the statement name given to the dynamic query by PREPARE replaces the static query. In our example, DECLARE CURSOR defines a cursor named EMPCURSOR and associates it with SQLSTMT, as follows:</p>
<pre>     EXEC SQL DECLARE EMPCURSOR CURSOR FOR SQLSTMT END-EXEC.
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must declare a cursor for all dynamic SQL statements, not just queries. With non-queries, OPENing the cursor executes the dynamic SQL statement.</div>
</div>
<!-- class="sect2" -->
<div id="LNPCB768" class="sect2"><a id="sthref1543"></a>
<h3 class="sect2">DESCRIBE the Bind Variables</h3>
<p>DESCRIBE BIND VARIABLES puts descriptions of bind variables into a bind descriptor. In our example, DESCRIBE readies BNDDSC as follows:<a id="sthref1544"></a><a id="sthref1545"></a></p>
<pre>     EXEC SQL 
         DESCRIBE BIND VARIABLES FOR SQLSTMT 
         INTO BNDDSC 
     END-EXEC. 
</pre>
<p>Note that BNDDSC must <span class="italic">not</span> be prefixed with a colon.</p>
<p>The DESCRIBE BIND VARIABLES statement must follow the PREPARE statement but precede the OPEN statement.</p>
<p><a href="#i14773">Figure 11-5</a> shows the bind descriptor in our example after the DESCRIBE. Notice that DESCRIBE has set SQLDFND to the actual number of place-holders found in the processed SQL statement.</p>
<div id="LNPCB769" class="figure">
<p class="titleinfigure"><a id="i14773"></a>Figure 11-5 Bind Descriptor after the DESCRIBE</p>
<img width="600" height="624" src="img/pco81009.gif" alt="Bind after DESCRIBE"/><br/>
<a id="sthref1546" href="img_text/pco81009.htm">Description of &#34;Figure 11-5 Bind Descriptor after the DESCRIBE&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCB770" class="sect2"><a id="sthref1547"></a>
<h3 class="sect2">Reset Number of Place-Holders</h3>
<p>Next, you must reset the maximum number of place-holders to the number actually found by DESCRIBE, as follows:</p>
<pre>     IF SQLDFND IN BNDDSC &lt; 0 
         DISPLAY &#34;Too many bind variables&#34; 
         GOTO ROLL-BACK 
     ELSE 
         MOVE SQLDFND IN BNDDSC TO SQLDNUM IN BNDDSC
     END-IF. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB771" class="sect2"><a id="sthref1548"></a>
<h3 class="sect2">Get Values for Bind Variables</h3>
<p>Your program must get values for the bind variables in the SQL statement. How the program gets the values is up to you. For example, they can be hard-coded, read from a file, or entered interactively.</p>
<p>In our example, a value must be assigned to the bind variable that replaces the place-holder BONUS in the query WHERE clause. Prompt the user for the value, then process it, as follows:</p>
<pre> PROCEDURE DIVISION. 
     ... 
     PERFORM GET-INPUT-VAR 
         VARYING J FROM 1 BY 1 UNTIL J &gt; SQLDNUM IN BNDDSC. 
     ... 
 GET-INPUT-VAR. 
     ... 
*    Replace the 0 DESCRIBEd into the datatype table 
*    with a 1 to avoid an &#34;invalid datatype&#34; Oracle error. 
     MOVE 1 TO BNDDVTYP(J). 
*    Get value of bind variable. 
     DISPLAY &#34;Enter value of &#34;, BND-DH-VNAME(J). 
     ACCEPT INPUT-STRING. 
     UNSTRING INPUT-STRING DELIMITED BY &#34;  &#34; 
         INTO BND-DV(J) COUNT IN BNDDVLN(J). 
</pre>
<p>Assuming that the user supplied a value of 625 for BONUS, the next table shows the resulting bind descriptor.</p>
<div id="LNPCB772" class="figure">
<p class="titleinfigure"><a id="sthref1549"></a>Figure 11-6 Bind Descriptor after Assigning Values</p>
<img width="576" height="614" src="img/pco81010.gif" alt="After Assigning"/><br/>
<a id="sthref1550" href="img_text/pco81010.htm">Description of &#34;Figure 11-6 Bind Descriptor after Assigning Values&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCB773" class="sect2"><a id="sthref1551"></a>
<h3 class="sect2">OPEN the Cursor</h3>
<p>The OPEN statement for dynamic queries is similar to the one for static queries, except the cursor is associated with a bind descriptor. Values determined at run time and stored in buffers addressed by elements of the bind descriptor tables are used to evaluate the SQL statement. With queries, the values are also used to identify the active set.<a id="sthref1552"></a><a id="sthref1553"></a></p>
<p>In our example, OPEN associates EMPCURSOR with BNDDSC as follows:</p>
<pre>     EXEC SQL 
         OPEN EMPCUR USING DESCRIPTOR BNDDSC 
     END-EXEC. 
</pre>
<p>Remember, BNDDSC must <span class="italic">not</span> be prefixed with a colon.</p>
<p>Then, OPEN executes the SQL statement. With queries, OPEN also identifies the active set and positions the cursor at the first row.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB774" class="sect2"><a id="sthref1554"></a>
<h3 class="sect2">DESCRIBE the Select List</h3>
<p>If the dynamic SQL statement is a query, the DESCRIBE SELECT LIST statement must follow the OPEN statement but precede the FETCH statement.<a id="sthref1555"></a><a id="sthref1556"></a></p>
<p>DESCRIBE SELECT LIST puts descriptions of select-list items into a select descriptor. In our example, DESCRIBE readies SELDSC as follows:</p>
<pre>     EXEC SQL 
         DESCRIBE SELECT LIST FOR SQLSTMT INTO SELDSC 
     END-EXEC. 
</pre>
<p>Accessing the data dictionary, DESCRIBE sets the length and datatype of each select-list value.</p>
<p><a href="#i10665">Figure 11-7</a> shows the select descriptor in our example after the DESCRIBE. Notice that DESCRIBE has set SQLDFND to the actual number of items found in the query select list. If the SQL statement is not a query, SQLDFND is set to zero. Also notice that the NUMBER lengths are not usable yet. For columns defined as NUMBER, you must use the library subroutine SQLPRC to extract precision and scale. See the section <a href="#i25065">&#34;Coercing Datatypes&#34;</a>.</p>
<div id="LNPCB775" class="figure">
<p class="titleinfigure"><a id="i10665"></a>Figure 11-7 Select Descriptor after the DESCR</p>
<img width="568" height="471" src="img/pco81011.gif" alt="Select after DESCR"/><br/>
<a id="sthref1557" href="img_text/pco81011.htm">Description of &#34;Figure 11-7 Select Descriptor after the DESCR&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCB776" class="sect2"><a id="sthref1558"></a>
<h3 class="sect2">Reset Number of Select-List Items</h3>
<p>Next, you must reset the maximum number of select-list items to the number actually found by DESCRIBE, as follows:</p>
<pre>     MOVE SQLDFND IN SELDSC TO SQLDNUM IN SELDSC. 
</pre></div>
<!-- class="sect2" -->
<div id="LNPCB777" class="sect2"><a id="sthref1559"></a>
<h3 class="sect2">Reset Length/Datatype of Each Select-List Item</h3>
<p>Before fetching the select-list values, the example resets some elements in the length and datatype tables for display purposes.</p>
<pre> PROCEDURE DIVISION. 
     ... 
     PERFORM COERCE-COLUMN-TYPE 
         VARYING J FROM 1 BY 1 UNTIL J &gt; SQLDNUM IN SELDSC. 
     ... 
 COERCE-COLUMN-TYPE. 
*    Clear NULL bit. 
     CALL &#34;SQLNUL&#34; USING SELDVTYP(J), SELDVTYP(J), NULL-STATUS. 

*    If datatype is DATE, lengthen to 9 characters. 
     IF SELDVTYP(J) = 12 
         MOVE 9 TO SELDVLN(J). 

*    If datatype is NUMBER, extract precision and scale. 
     MOVE 0 TO DISPLAY-LENGTH. 
     IF SELDVTYP(J) = 2 AND PRECISION = 0 
         MOVE 10 TO DISPLAY-LENGTH. 
     IF SELDVTYP(J) = 2 AND PRECISION &gt; 0 
         ADD 2 TO PRECISION 
         MOVE PRECISION TO DISPLAY-LENGTH. 
     IF SELDVTYP(J) = 2 
         IF DISPLAY-LENGTH &gt; MAX-LENGTH 
             DISPLAY &#34;Column value too large for data buffer.&#34; 
             GO TO END-PROGRAM 
         ELSE 
             MOVE DISPLAY-LENGTH TO SELDVLN(J). 

*    Coerce datatypes to VARCHAR2. 
     MOVE 1 TO SELDVTYP(J). 
</pre>
<p><a href="#i10667">Figure 11-8</a> shows the resulting select descriptor. Notice that the NUMBER lengths are now usable and that all the datatypes are VARCHAR2. The lengths in SELDVLN(2) and SELDVLN(3) are 6 and 9 because we increased the DESCRIBEd lengths of 4 and 7 by 2 to allow for a possible sign and decimal point.</p>
<div id="LNPCB778" class="figure">
<p class="titleinfigure"><a id="i10667"></a>Figure 11-8 Select Descriptor before the FETCH</p>
<img width="568" height="471" src="img/pco81011.gif" alt="Select after DESCR"/><br/>
<a id="sthref1560" href="img_text/pco81011.htm">Description of &#34;Figure 11-8 Select Descriptor before the FETCH&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="LNPCB779" class="sect2"><a id="sthref1561"></a>
<h3 class="sect2">FETCH Rows from the Active Set</h3>
<p>FETCH returns a row from the active set, stores select-list values in the data buffers, and advances the cursor to the next row in the active set. If there are no more rows, FETCH sets SQLCODE in the SQLCA, the SQLCODE variable, or the SQLSTATE variable to the &#34;no data found&#34; error code. In the following example, FETCH returns the values of columns ENAME, EMPNO, and COMM to SELDSC:<a id="sthref1562"></a><a id="sthref1563"></a></p>
<pre>     EXEC SQL 
         FETCH EMPCURSOR USING DESCRIPTOR SELDSC 
     END-EXEC. 
</pre>
<p><a href="#CDDDHFIG">Figure 11-9</a> shows the select descriptor in our example after the FETCH. Notice that Oracle has stored the select-list and indicator values in the data buffers addressed by the elements of SELDV and SELDI.</p>
<p>For output buffers of datatype 1, Oracle, using the lengths stored in SELDVLN, left-justifies CHAR or VARCHAR2 data, and right-justifies NUMBER data.</p>
<p>The value <code>MARTIN</code> was retrieved from a VARCHAR2(10) column in the EMP table. Using the length in SELDVLN(1), Oracle left-justifies the value in a 10-byte field, filling the buffer.</p>
<p>The value 7654 was retrieved from a NUMBER(4) column and coerced to <code>7654</code>. However, the length in SELDVLN(2) was increased by two to allow for a possible sign and decimal point, so Oracle right-justifies the value in a 6-byte field.</p>
<p>The value 482.50 was retrieved from a NUMBER(7,2) column and coerced to 482.50. Again, the length in SELDVLN(3) was increased by two, so Oracle right-justifies the value in a 9-byte field.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB780" class="sect2"><a id="sthref1564"></a>
<h3 class="sect2">Get and Process Select-List Values</h3>
<p>After the FETCH, your program can process the select-list values returned by FETCH. In our example, values for columns ENAME, EMPNO, and COMM are processed.</p>
</div>
<!-- class="sect2" -->
<div id="LNPCB781" class="sect2"><a id="sthref1565"></a>
<h3 class="sect2">CLOSE the Cursor</h3>
<p><a id="sthref1566"></a><a id="sthref1567"></a>CLOSE disables the cursor. In our example, CLOSE disables EMPCURSOR as follows:</p>
<pre>     EXEC SQL CLOSE EMPCURSOR END-EXEC
</pre>
<div id="LNPCB782" class="figure">
<p class="titleinfigure"><a id="CDDDHFIG"></a>Figure 11-9 Select Descriptor after the FETCH</p>
<img width="586" height="386" src="img/pco81013.gif" alt="Select r after FETCH"/><br/>
<a id="sthref1568" href="img_text/pco81013.htm">Description of &#34;Figure 11-9 Select Descriptor after the FETCH&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i25561"></a>
<div id="LNPCB783" class="sect1">
<h2 class="sect1">Using Host Tables with Method 4</h2>
<p>To use input or output host tables with Method 4, you must use the optional FOR clause to tell Oracle the size of your host table. For more information about the FOR clause, see <a href="pco07tab.htm#g12783">Chapter 7, &#34;Host Tables&#34;</a>.</p>
<p>Set descriptor entries for the Jth select-list item or bind variable, but instead of addressing a single data buffer, SELDVLN(J) or BNDDVLN(J) addresses a table of data buffers. Then use a FOR clause in the EXECUTE or FETCH statement, as appropriate, to tell Oracle the number of table elements you want to process.</p>
<p>This procedure is necessary because Oracle has no other way of knowing the size of your host table.</p>
<p><a id="i9326"></a>In the following example (32 bit only), two input host tables are used to insert 8 pairs of values of EMPNO and DEPTNO into the table EMP. Note that EXECUTE can be used for non-queries with Method 4.</p>
<pre> IDENTIFICATION DIVISION. 
 PROGRAM-ID. DYN4INS. 
 ENVIRONMENT DIVISION. 
 DATA DIVISION. 
 WORKING-STORAGE SECTION. 
 01  BNDDSC. 
     02  SQLDNUM              PIC S9(9) COMP VALUE 2. 
     02  SQLDFND              PIC S9(9) COMP. 
     02  BNDDVAR              OCCURS 2 TIMES. 
         03 BNDDV             PIC S9(9) COMP. 
         03 BNDDFMT           PIC S9(9) COMP. 
         03 BNDDVLN           PIC S9(9) COMP. 
         03 BNDDFMTL          PIC S9(4) COMP. 
         03 BNDDVTYP          PIC S9(4) COMP. 
         03 BNDDI             PIC S9(9) COMP. 
         03 BNDDH-VNAME       PIC S9(9) COMP. 
         03 BNDDH-MAX-VNAMEL  PIC S9(4) COMP. 
         03 BNDDH-CUR-VNAMEL  PIC S9(4) COMP. 
         03 BNDDI-VNAME       PIC S9(9) COMP. 
         03 BNDDI-MAX-VNAMEL  PIC S9(4) COMP. 
         03 BNDDI-CUR-VNAMEL  PIC S9(4) COMP. 
         03 BNDDFCLP          PIC S9(9) COMP. 
         03 BNDDFCRCP         PIC S9(9) COMP. 
 01  XBNDDI. 
     03  BND-DI               OCCURS 2 TIMES PIC S9(4) COMP. 
 01  XBNDDIVNAME. 
     03  BND-DI-VNAME         OCCURS 2 TIMES PIC X(80). 
 01  XBNDDV. 
*    Since you know what the SQL statement will be, you can set 
*    up a two-dimensional table with a maximum of 2 columns and 
*    8 rows.  Each element can be up to 10 characters long.  (You 
*    can alter these values according to your needs.) 
     03  BND-COLUMN           OCCURS 2 TIMES. 
         05  BND-ELEMENT      OCCURS 8 TIMES PIC X(10). 
 01  XBNDDHVNAME. 
     03  BND-DH-VNAME         OCCURS 2 TIMES PIC X(80).  
 01  COLUMN-INDEX             PIC 999. 
 01  ROW-INDEX                PIC 999. 
 01  DUMMY-INTEGER            PIC 9999.
     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
         01  USERNAME         PIC X(20). 
         01  PASSWD           PIC X(20). 
         01  DYN-STATEMENT    PIC X(80). 
         01  NUMBER-OF-ROWS   PIC S9(4) COMP. 
     EXEC SQL END DECLARE SECTION END-EXEC. 

     EXEC SQL INCLUDE SQLCA END-EXEC. 

 PROCEDURE DIVISION. 
 START-MAIN. 

     EXEC SQL WHENEVER SQLERROR GOTO SQL-ERROR END-EXEC. 

     MOVE &#34;SCOTT&#34; TO USERNAME. 
     MOVE &#34;TIGER&#34; TO PASSWD. 
     EXEC SQL 
         CONNECT :USERNAME IDENTIFIED BY :PASSWD 
     END-EXEC. 
     DISPLAY &#34;Connected to Oracle&#34;. 

*    Initialize bind and select descriptors. 
     PERFORM INIT-BNDDSC THRU INIT-BNDDSC-EXIT 
         VARYING COLUMN-INDEX FROM 1 BY 1 
         UNTIL COLUMN-INDEX &gt; 2. 

*    Set up the SQL statement. 
     MOVE SPACES TO DYN-STATEMENT. 
     MOVE &#34;INSERT INTO EMP(EMPNO, DEPTNO) VALUES(:EMPNO,:DEPTNO)&#34; 
         TO DYN-STATEMENT.
     DISPLAY DYN-STATEMENT.

*    Prepare the SQL statement. 
     EXEC SQL 
         PREPARE S1 FROM :DYN-STATEMENT 
     END-EXEC. 

*    Describe the bind variables. 
     EXEC SQL 
         DESCRIBE BIND VARIABLES FOR S1 INTO BNDDSC 
     END-EXEC. 

     PERFORM Z-BIND-TYPE THRU Z-BIND-TYPE-EXIT 
         VARYING COLUMN-INDEX FROM 1 BY 1 
         UNTIL COLUMN-INDEX &gt; 2. 

     IF SQLDFND IN BNDDSC &lt; 0 
         DISPLAY &#34;TOO MANY BIND VARIABLES.&#34; 
         GO TO SQL-ERROR 
     ELSE 
         DISPLAY &#34;BIND VARS = &#34; WITH NO ADVANCING 
         MOVE SQLDFND IN BNDDSC TO DUMMY-INTEGER 
         DISPLAY DUMMY-INTEGER 
         MOVE SQLDFND IN BNDDSC TO SQLDNUM IN BNDDSC. 

         MOVE 8 TO NUMBER-OF-ROWS. 
         PERFORM GET-ALL-VALUES THRU GET-ALL-VALUES-EXIT 
             VARYING ROW-INDEX FROM 1 BY 1 
             UNTIL ROW-INDEX &gt; NUMBER-OF-ROWS. 

*    Execute the SQL statement. 
     EXEC SQL FOR :NUMBER-OF-ROWS 
         EXECUTE S1 USING DESCRIPTOR BNDDSC 
     END-EXEC. 

     DISPLAY &#34;INSERTED &#34; WITH NO ADVANCING. 
     MOVE SQLERRD(3) TO DUMMY-INTEGER. 
     DISPLAY DUMMY-INTEGER WITH NO ADVANCING. 
     DISPLAY &#34; ROWS.&#34;. 
     GO TO END-SQL. 

 SQL-ERROR. 
*    Display any SQL error message and code. 
     DISPLAY SQLERRMC. 
     EXEC SQL ROLLBACK WORK RELEASE END-EXEC. 
     STOP RUN. 

 END-SQL. 
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC. 
     EXEC SQL COMMIT WORK RELEASE END-EXEC. 
     STOP RUN. 

 INIT-BNDDSC. 
*    Start of COBOL PERFORM procedures, initialize the bind 
*    descriptor. 
     MOVE 80 TO BNDDH-MAX-VNAMEL(COLUMN-INDEX). 
     CALL &#34;SQLADR&#34; USING 
         BND-DH-VNAME(COLUMN-INDEX) 
         BNDDH-VNAME(COLUMN-INDEX). 
     MOVE 80 TO BNDDI-MAX-VNAMEL(COLUMN-INDEX). 
     CALL &#34;SQLADR&#34; USING 
         BND-DI-VNAME(COLUMN-INDEX) 
         BNDDI-VNAME (COLUMN-INDEX). 
     MOVE 10 TO BNDDVLN(COLUMN-INDEX). 
     CALL &#34;SQLADR&#34; USING 
         BND-ELEMENT(COLUMN-INDEX,1) 
         BNDDV(COLUMN-INDEX). 
     MOVE ZERO TO BNDDI(COLUMN-INDEX). 
     CALL &#34;SQLADR&#34; USING 
         BND-DI(COLUMN-INDEX) 
         BNDDI(COLUMN-INDEX). 
     MOVE ZERO TO BNDDFMT(COLUMN-INDEX). 
     MOVE ZERO TO BNDDFMTL(COLUMN-INDEX). 
     MOVE ZERO TO BNDDFCLP(COLUMN-INDEX). 
     MOVE ZERO TO BNDDFCRCP(COLUMN-INDEX). 
 INIT-BNDDSC-EXIT. 
     EXIT.

 Z-BIND-TYPE. 
*    Replace the 0s DESCRIBEd into the datatype table with 1s to 
*    avoid an &#34;invalid datatype&#34; Oracle error. 
     MOVE 1 TO BNDDVTYP(COLUMN-INDEX). 

 Z-BIND-TYPE-EXIT. 
     EXIT. 

 GET-ALL-VALUES. 
*    Get the bind variables for each row. 
     DISPLAY &#34;ENTER VALUES FOR ROW NUMBER &#34;,ROW-INDEX. 
     PERFORM GET-BIND-VARS 
         VARYING COLUMN-INDEX FROM 1 BY 1 
         UNTIL COLUMN-INDEX &gt; SQLDFND IN BNDDSC. 
 GET-ALL-VALUES-EXIT. 
     EXIT. 

 GET-BIND-VARS. 
*    Get the value of each bind variable. 
     DISPLAY &#34;    ENTER VALUE FOR &#34;,BND-DH-VNAME(COLUMN-INDEX) 
         WITH NO ADVANCING. 
     ACCEPT BND-ELEMENT(COLUMN-INDEX,ROW-INDEX). 
 GET-BIND-VARS-EXIT. 
     EXIT.  
</pre></div>
<!-- class="sect1" -->
<a id="i10873"></a>
<div id="LNPCB784" class="sect1">
<h2 class="sect1">Sample Program 10: Dynamic SQL Method 4<a id="sthref1569"></a></h2>
<p>This program shows the basic steps required to use dynamic SQL Method 4.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following example is 32 bit only. To avoid problems, please use the example from <code>$ORACLE_HOME/precomp/demo/procob2/sample10.pco</code> and include the correct version of the variable declaration file.
<p><code>bndsel.cob</code> 64 bit version in <code>precomp/public</code> (64 bit computer)</p>
<p><code>bndsel.cob_32</code> 32 bit version in <code>precomp/public32</code> (64 bit computer)</p>
</div>
<p>After logging on, the program prompts the user for a SQL statement, prepares statement, declares a cursor, checks for any bind variables using DESCRIBE BIND, opens the cursor, and describes any select-list variables. If the input SQL statement is a query, the program fetches each row of data, then closes the cursor.<a id="sthref1570"></a></p>
<pre>      ***************************************************************
      * Sample Program 10: Dynamic SQL Method 4                     *
      *                                                             *
      * This program shows the basic steps required to use dynamic  *
      * SQL Method 4.  After logging on to ORACLE, the program      *
      * prompts the user for a SQL statement, PREPAREs the          *
      * statement, DECLAREs a cursor, checks for any bind variables *
      * using DESCRIBE BIND, OPENs the cursor, and DESCRIBEs any    *
      * select-list variables.  If the input SQL statement is a     *
      * query, the program FETCHes each row of data, then CLOSEs    *
      * the cursor.                                                 *
      ***************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID.  DYNSQL4.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       01  BNDDSC.

           02  SQLDNUM               PIC S9(9) COMP VALUE 20.
           02  SQLDFND               PIC S9(9) COMP.
           02  BNDDVAR               OCCURS 20 TIMES.
               03  BNDDV             PIC S9(9) COMP.
               03  BNDDFMT           PIC S9(9) COMP.
               03  BNDDVLN           PIC S9(9) COMP.
               03  BNDDFMTL          PIC S9(4) COMP.
               03  BNDDVTYP          PIC S9(4) COMP.
               03  BNDDI             PIC S9(9) COMP.
               03  BNDDH-VNAME       PIC S9(9) COMP.
               03  BNDDH-MAX-VNAMEL  PIC S9(4) COMP.
               03  BNDDH-CUR-VNAMEL  PIC S9(4) COMP.
               03  BNDDI-VNAME       PIC S9(9) COMP.
               03  BNDDI-MAX-VNAMEL  PIC S9(4) COMP.
               03  BNDDI-CUR-VNAMEL  PIC S9(4) COMP.
               03  BNDDFCLP          PIC S9(9) COMP.
               03  BNDDFCRCP         PIC S9(9) COMP.

       01  XBNDDI.

           03  BND-DI                OCCURS 20 TIMES PIC S9(4) COMP.

       01  XBNDDIVNAME.
           03  BND-DI-VNAME          OCCURS 20 TIMES PIC X(80).
       01  XBNDDV.
           03  BND-DV                OCCURS 20 TIMES PIC X(80).
       01  XBNDDHVNAME.
           03  BND-DH-VNAME          OCCURS 20 TIMES PIC X(80).

       01  SELDSC.

           02  SQLDNUM               PIC S9(9) COMP VALUE 20.
           02  SQLDFND               PIC S9(9) COMP.
           02  SELDVAR               OCCURS 20 TIMES.
               03  SELDV             PIC S9(9) COMP.
               03  SELDFMT           PIC S9(9) COMP.
               03  SELDVLN           PIC S9(9) COMP.
               03  SELDFMTL          PIC S9(4) COMP.
               03  SELDVTYP          PIC S9(4) COMP.
               03  SELDI             PIC S9(9) COMP.
               03  SELDH-VNAME       PIC S9(9) COMP.
               03  SELDH-MAX-VNAMEL  PIC S9(4) COMP.
               03  SELDH-CUR-VNAMEL  PIC S9(4) COMP.
               03  SELDI-VNAME       PIC S9(9) COMP.
               03  SELDI-MAX-VNAMEL  PIC S9(4) COMP.
               03  SELDI-CUR-VNAMEL  PIC S9(4) COMP.
               03  SELDFCLP          PIC S9(9) COMP.
               03  SELDFCRCP         PIC S9(9) COMP.

       01  XSELDI.

           03  SEL-DI                OCCURS 20 TIMES PIC S9(4) COMP.

       01  XSELDIVNAME.
           03  SEL-DI-VNAME          OCCURS 20 TIMES PIC X(80).
       01  XSELDV.
           03  SEL-DV                OCCURS 20 TIMES PIC X(80).
       01  XSELDHVNAME.
           03  SEL-DH-VNAME          OCCURS 20 TIMES PIC X(80).

       01  TABLE-INDEX               PIC 9(3).
       01  VAR-COUNT                 PIC 9(2).
       01  ROW-COUNT                 PIC 9(4).
       01  NO-MORE-DATA              PIC X(1) VALUE &#34;N&#34;.
       01  NULLS-ALLOWED             PIC S9(9) COMP.

       01  PRECISION                 PIC S9(9) COMP.
       01  SCALE                     PIC S9(9) COMP.

       01  DISPLAY-LENGTH            PIC S9(9) COMP.
       01  MAX-LENGTH                PIC S9(9) COMP VALUE 80.
       01  COLUMN-NAME               PIC X(30).
       01  NULL-VAL                  PIC X(80) VALUE SPACES.
           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME       PIC X(20).
       01  PASSWD         PIC X(20).
       01  DYN-STATEMENT  PIC X(80).
           EXEC SQL END DECLARE SECTION   END-EXEC.
           EXEC SQL INCLUDE SQLCA         END-EXEC.

       PROCEDURE DIVISION.
       START-MAIN.

           EXEC SQL WHENEVER SQLERROR GOTO SQL-ERROR END-EXEC.

           DISPLAY &#34;USERNAME: &#34; WITH NO ADVANCING.

           ACCEPT USERNAME.

           DISPLAY &#34;PASSWORD: &#34; WITH NO ADVANCING.

           ACCEPT PASSWD.

           EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWD END-EXEC.
           DISPLAY &#34;CONNECTED TO ORACLE AS USER: &#34;, USERNAME.

      *    INITIALIZE THE BIND AND SELECT DESCRIPTORS.

           PERFORM INIT-BNDDSC
               VARYING TABLE-INDEX FROM 1 BY 1 
               UNTIL TABLE-INDEX &gt; 20.

           PERFORM INIT-SELDSC
               VARYING TABLE-INDEX FROM 1 BY 1 
               UNTIL TABLE-INDEX &gt; 20.

      *    GET A SQL STATEMENT FROM THE OPERATOR.

           DISPLAY &#34;ENTER SQL STATEMENT WITHOUT TERMINATOR:&#34;.
           DISPLAY &#34;&gt;&#34; WITH NO ADVANCING.

           ACCEPT DYN-STATEMENT.

           DISPLAY &#34; &#34;.

      *    PREPARE THE SQL STATEMENT AND DECLARE A CURSOR.

           EXEC SQL  PREPARE S1 FROM :DYN-STATEMENT  END-EXEC.
           EXEC SQL  DECLARE C1 CURSOR FOR S1        END-EXEC.

      *    DESCRIBE ANY BIND VARIABLES.

           EXEC SQL  DESCRIBE BIND VARIABLES FOR S1 INTO BNDDSC
           END-EXEC.

           IF SQLDFND IN BNDDSC &lt; 0
               DISPLAY &#34;TOO MANY BIND VARIABLES.&#34;
               GO TO END-SQL
           ELSE
               DISPLAY &#34;NUMBER OF BIND VARIABLES: &#34; WITH NO ADVANCING
               MOVE SQLDFND IN BNDDSC TO VAR-COUNT
               DISPLAY VAR-COUNT
               MOVE SQLDFND IN BNDDSC TO SQLDNUM IN BNDDSC
           END-IF.

      *    REPLACE THE 0S DESCRIBED INTO THE DATATYPE FIELDS OF THE
      *    BIND DESCRIPTOR WITH 1S TO AVOID AN &#34;INVALID DATATYPE&#34;
      *    ORACLE ERROR

           MOVE 1 TO TABLE-INDEX.
       FIX-BIND-TYPE.
               MOVE 1 TO BNDDVTYP(TABLE-INDEX)
               ADD 1 TO TABLE-INDEX
               IF TABLE-INDEX &lt;= 20
                   GO TO FIX-BIND-TYPE.

      *    LET THE USER FILL IN THE BIND VARIABLES.

           IF SQLDFND IN BNDDSC = 0
               GO TO DESCRIBE-ITEMS.
           MOVE 1 TO TABLE-INDEX.
       GET-BIND-VAR.
               DISPLAY &#34;ENTER VALUE FOR &#34;, BND-DH-VNAME(TABLE-INDEX).

               ACCEPT BND-DV(TABLE-INDEX).

               ADD 1 TO TABLE-INDEX
               IF TABLE-INDEX &lt;= SQLDFND IN BNDDSC
                   GO TO GET-BIND-VAR.

      *    OPEN THE CURSOR AND DESCRIBE THE SELECT-LIST ITEMS.

       DESCRIBE-ITEMS.

           EXEC SQL  OPEN C1 USING DESCRIPTOR BNDDSC          END-EXEC.
           EXEC SQL  DESCRIBE SELECT LIST FOR S1 INTO SELDSC  END-EXEC.

           IF SQLDFND IN SELDSC &lt; 0
               DISPLAY &#34;TOO MANY SELECT-LIST ITEMS.&#34;
               GO TO END-SQL
           ELSE
               DISPLAY &#34;NUMBER OF SELECT-LIST ITEMS: &#34;
                   WITH NO ADVANCING
               MOVE SQLDFND IN SELDSC TO VAR-COUNT
               DISPLAY VAR-COUNT
               DISPLAY &#34; &#34;
               MOVE SQLDFND IN SELDSC TO SQLDNUM IN SELDSC
           END-IF.

      *    COERCE THE DATATYPE OF ALL SELECT-LIST ITEMS TO VARCHAR2.

           IF SQLDNUM IN SELDSC &gt; 0
               PERFORM COERCE-COLUMN-TYPE
                   VARYING TABLE-INDEX FROM 1 BY 1
                   UNTIL TABLE-INDEX &gt; SQLDNUM IN SELDSC
               DISPLAY &#34; &#34;.

      *    FETCH EACH ROW AND PRINT EACH SELECT-LIST VALUE.

           IF SQLDNUM IN SELDSC &gt; 0
               PERFORM FETCH-ROWS UNTIL NO-MORE-DATA = &#34;Y&#34;.

           DISPLAY &#34; &#34;
           DISPLAY &#34;NUMBER OF ROWS PROCESSED: &#34; WITH NO ADVANCING.
           MOVE SQLERRD(3) TO ROW-COUNT.
           DISPLAY ROW-COUNT.

      *    CLEAN UP AND TERMINATE.

           EXEC SQL  CLOSE C1             END-EXEC.
           EXEC SQL  COMMIT WORK RELEASE  END-EXEC.
           DISPLAY &#34; &#34;.
           DISPLAY &#34;HAVE A GOOD DAY!&#34;.
           DISPLAY &#34; &#34;.
           STOP RUN.

      *    DISPLAY ORACLE ERROR MESSAGE AND CODE.

       SQL-ERROR.
           DISPLAY &#34; &#34;.
           DISPLAY SQLERRMC.
       END-SQL.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.

      *    PERFORMED SUBROUTINES BEGIN HERE:

      *    INIT-BNDDSC: INITIALIZE THE BIND DESCRIPTOR.

       INIT-BNDDSC.

           MOVE SPACES TO BND-DH-VNAME(TABLE-INDEX).
           MOVE 80 TO BNDDH-MAX-VNAMEL(TABLE-INDEX).
           CALL &#34;SQLADR&#34; USING 
               BND-DH-VNAME(TABLE-INDEX) 
               BNDDH-VNAME(TABLE-INDEX). 
        
           MOVE SPACES TO BND-DI-VNAME(TABLE-INDEX).
           MOVE 80 TO BNDDI-MAX-VNAMEL(TABLE-INDEX).
           CALL &#34;SQLADR&#34; USING 
               BND-DI-VNAME(TABLE-INDEX) 
               BNDDI-VNAME (TABLE-INDEX).
        
           MOVE SPACES TO BND-DV(TABLE-INDEX).
           MOVE 80 TO BNDDVLN(TABLE-INDEX).
           CALL &#34;SQLADR&#34; USING 
               BND-DV(TABLE-INDEX) 
               BNDDV(TABLE-INDEX).
           MOVE ZERO TO BND-DI(TABLE-INDEX).
           CALL &#34;SQLADR&#34; USING 
               BND-DI(TABLE-INDEX) 
               BNDDI(TABLE-INDEX).

           MOVE ZERO TO BNDDFMT(TABLE-INDEX).
           MOVE ZERO TO BNDDFMTL(TABLE-INDEX).
           MOVE ZERO TO BNDDFCLP(TABLE-INDEX).
           MOVE ZERO TO BNDDFCRCP(TABLE-INDEX).

      *    INIT-SELDSC: INITIALIZE THE SELECT DESCRIPTOR.

       INIT-SELDSC.

           MOVE SPACES TO SEL-DH-VNAME(TABLE-INDEX).
           MOVE 80 TO SELDH-MAX-VNAMEL(TABLE-INDEX).
           CALL &#34;SQLADR&#34; USING 
               SEL-DH-VNAME(TABLE-INDEX) 
               SELDH-VNAME(TABLE-INDEX). 
        
           MOVE SPACES TO SEL-DI-VNAME(TABLE-INDEX).
           MOVE 80 TO SELDI-MAX-VNAMEL(TABLE-INDEX).
           CALL &#34;SQLADR&#34; USING 
               SEL-DI-VNAME(TABLE-INDEX) 
               SELDI-VNAME (TABLE-INDEX).

           MOVE SPACES TO SEL-DV(TABLE-INDEX).
           MOVE 80 TO SELDVLN(TABLE-INDEX).
           CALL &#34;SQLADR&#34; USING 
               SEL-DV(TABLE-INDEX) 
               SELDV(TABLE-INDEX).

           MOVE ZERO TO SEL-DI(TABLE-INDEX).
           CALL &#34;SQLADR&#34; USING 
               SEL-DI(TABLE-INDEX) 
               SELDI(TABLE-INDEX).

           MOVE ZERO TO SELDFMT(TABLE-INDEX).
           MOVE ZERO TO SELDFMTL(TABLE-INDEX).
           MOVE ZERO TO SELDFCLP(TABLE-INDEX).
           MOVE ZERO TO SELDFCRCP(TABLE-INDEX).

      *    COERCE SELECT-LIST DATATYPES TO VARCHAR2.

       COERCE-COLUMN-TYPE.
           CALL &#34;SQLNUL&#34; USING
               SELDVTYP(TABLE-INDEX)
               SELDVTYP(TABLE-INDEX)
               NULLS-ALLOWED.

      *    IF DATATYPE IS DATE, LENGTHEN TO 9 CHARACTERS.
           IF SELDVTYP(TABLE-INDEX) = 12
               MOVE 9 TO SELDVLN(TABLE-INDEX).

      *    IF DATATYPE IS NUMBER, SET LENGTH TO PRECISION.
           IF SELDVTYP(TABLE-INDEX) = 2
               CALL &#34;SQLPRC&#34; USING
                   SELDVLN(TABLE-INDEX)
                   PRECISION
                   SCALE.
           MOVE 0 TO DISPLAY-LENGTH.
           IF SELDVTYP(TABLE-INDEX) = 2 AND PRECISION = 0
               MOVE 40 TO DISPLAY-LENGTH.
           IF SELDVTYP(TABLE-INDEX) = 2 AND PRECISION &gt; 0
               ADD 2 TO PRECISION
               MOVE PRECISION TO DISPLAY-LENGTH.

           IF SELDVTYP(TABLE-INDEX) = 2
               IF DISPLAY-LENGTH &gt; MAX-LENGTH
                   DISPLAY &#34;COLUMN VALUE TOO LARGE FOR DATA BUFFER.&#34;
                   GO TO END-SQL
               ELSE
                   MOVE DISPLAY-LENGTH TO SELDVLN(TABLE-INDEX).

      *    COERCE DATATYPES TO VARCHAR2.
           MOVE 1 TO SELDVTYP(TABLE-INDEX).

      *    DISPLAY COLUMN HEADING.
           MOVE SEL-DH-VNAME(TABLE-INDEX) TO COLUMN-NAME.
           DISPLAY COLUMN-NAME(1:SELDVLN(TABLE-INDEX)), &#34; &#34;
               WITH NO ADVANCING.

      *FETCH A ROW AND PRINT THE SELECT-LIST VALUE.

       FETCH-ROWS.
           EXEC SQL  FETCH C1 USING DESCRIPTOR SELDSC  END-EXEC.
           IF SQLCODE NOT = 0
               MOVE &#34;Y&#34; TO NO-MORE-DATA.
           IF SQLCODE = 0
               PERFORM PRINT-COLUMN-VALUES
                   VARYING TABLE-INDEX FROM 1 BY 1
                   UNTIL TABLE-INDEX &gt; SQLDNUM IN SELDSC
               DISPLAY &#34; &#34;.

      *PRINT A SELECT-LIST VALUE.

       PRINT-COLUMN-VALUES.
           IF SEL-DI(TABLE-INDEX) = -1
             DISPLAY NULL-VAL(1:SELDVLN(TABLE-INDEX)), &#34; &#34;
                 WITH NO ADVANCING
           ELSE
             DISPLAY SEL-DV(TABLE-INDEX)(1:SELDVLN(TABLE-INDEX)), &#34; &#34;
                 WITH NO ADVANCING
           END-IF.
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pco10ady.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pco12thr.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>