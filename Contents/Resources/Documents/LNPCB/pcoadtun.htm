<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-77868"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Performance%20Tuning"></a><title>Performance Tuning</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-06T20:23:29Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Pro*COBOL&reg; Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53282-01"/>
<meta name="dcterms.isVersionOf" content="LNPCB"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="pcoacres.htm" title="Previous" type="text/html"/>
<link rel="Next" href="pcoaechk.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53282-01.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">23/27</span> <!-- End Header -->
<div id="LNPCB018" class="appendix"><a id="g26568"></a>
<h1 class="appendix"><span class="secnum">C</span> Performance Tuning</h1>
<p>This appendix shows you some simple, easy-to-apply methods for improving the performance of your applications. Using these methods, you can often reduce processing time by 25 percent or more. Topics are:</p>
<ul>
<li>
<p><a href="#i24402">Causes of Poor Performance</a></p>
</li>
<li>
<p><a href="#i24423">Improving Performance</a></p>
</li>
<li>
<p><a href="#i24437">Using Host Tables</a></p>
</li>
<li>
<p><a href="#i24449">Using PL/SQL and Java</a></p>
</li>
<li>
<p><a href="#i24462">Optimizing SQL Statements</a></p>
</li>
<li>
<p><a href="#i24508">Using Indexes</a></p>
</li>
<li>
<p><a href="#i24524">Taking Advantage of Row-Level Locking</a></p>
</li>
<li>
<p><a href="#i24533">Eliminating Unnecessary Parsing</a></p>
</li>
</ul>
<a id="i24402"></a>
<div id="LNPCB1310" class="sect1">
<h2 class="sect1">Causes of Poor Performance</h2>
<p>One cause of poor performance is high Oracle communication overhead. Oracle must process SQL statements one at a time. Thus, each statement results in another call to Oracle and higher overhead. In a networked environment, SQL statements must be sent over the network, adding to network traffic. Heavy network traffic can slow down your application significantly.<a id="sthref1953"></a><a id="sthref1954"></a></p>
<p>Another cause of poor performance is inefficient SQL statements. Because SQL is so flexible, you can get the same result using two different statements. Using one statement might be less efficient. For example, the following two SELECT statements return the same rows (the name and number of every department having at least one employee):</p>
<pre>     EXEC SQL SELECT DNAME, DEPTNO 
         FROM DEPT 
         WHERE DEPTNO IN (SELECT DEPTNO FROM EMP)
     END-EXEC. 
</pre>
<p>Contrasted with:</p>
<pre>     EXEC SQL SELECT DNAME, DEPTNO 
         FROM DEPT 
         WHERE EXISTS 
         (SELECT DEPTNO FROM EMP WHERE DEPT.DEPTNO = EMP.DEPTNO)
     END-EXEC. 
</pre>
<p>The first statement is slower because it does a time-consuming full scan of the EMP table for every department number in the DEPT table. Even if the DEPTNO column in EMP is indexed, the index is not used because the subquery lacks a WHERE clause naming DEPTNO.</p>
<p>Another cause of poor performance is unnecessary parsing and binding. Recall that before executing a SQL statement, Oracle must parse and bind it. Parsing means examining the SQL statement to make sure it follows syntax rules and refers to valid database objects. Binding means associating host variables in the SQL statement with their addresses so that Oracle can read or write their values.</p>
<p>Many applications manage cursors poorly. This results in unnecessary parsing and binding, which adds noticeably to processing overhead.</p>
</div>
<!-- class="sect1" -->
<a id="i24423"></a>
<div id="LNPCB1311" class="sect1">
<h2 class="sect1">Improving Performance</h2>
<p>If you are unhappy with the performance of your precompiled programs, there are several ways you can reduce overhead.</p>
<p>You can greatly reduce Oracle communication overhead, especially in networked environments, by<a id="sthref1955"></a></p>
<ul>
<li>
<p>Using host tables</p>
</li>
<li>
<p>Using embedded PL/SQL</p>
</li>
</ul>
<p>You can reduce processing overhead&mdash;sometimes dramatically&mdash;by</p>
<ul>
<li>
<p>Optimizing SQL statements</p>
</li>
<li>
<p>SQL Statement Caching</p>
</li>
<li>
<p>Using indexes</p>
</li>
<li>
<p>Taking advantage of row-level locking</p>
</li>
<li>
<p>Eliminating unnecessary parsing</p>
</li>
<li>
<p>Avoiding unnecessary reparsing</p>
</li>
</ul>
<p>The following sections look at each of these ways to cut overhead.</p>
</div>
<!-- class="sect1" -->
<a id="i24437"></a>
<div id="LNPCB1312" class="sect1">
<h2 class="sect1">Using Host Tables</h2>
<p>Host tables can boost performance because they let you manipulate an entire collection of data with a single SQL statement. For example, suppose you want to insert salaries for 300 employees into the EMP table. Without tables your program must do 300 individual inserts&mdash;one for each employee. With arrays, only one INSERT is necessary. Consider the following statement:<a id="sthref1956"></a></p>
<pre>     EXEC SQL INSERT INTO EMP (SAL) VALUES (:SALARY) END-EXEC.
</pre>
<p>If <span class="italic">SALARY</span> is a simple host variable, Oracle executes the INSERT statement once, inserting a single row into the EMP table. In that row, the SAL column has the value of <span class="italic">SALARY</span>. To insert 300 rows this way, you must execute the INSERT statement 300 times.</p>
<p>However, if <span class="italic">SALARY</span> is a host table of size 300, Oracle inserts all 300 rows into the EMP table at once. In each row, the SAL column has the value of an element in the <span class="italic">SALARY</span> table.</p>
<p>For more information, see <a href="pco07tab.htm#g12783">Chapter 7, &#34;Host Tables&#34;</a></p>
</div>
<!-- class="sect1" -->
<a id="i24449"></a>
<div id="LNPCB1313" class="sect1">
<h2 class="sect1">Using PL/SQL and Java</h2>
<p>As <a href="#CHEIIGJI">Figure C-1</a> shows, if your application is database-intensive, you can use control structures to group SQL statements in a PL/SQL block, then send the entire block to Oracle. This can drastically reduce communication between your application and the database.<a id="sthref1957"></a></p>
<p>Also, you can use PL/SQL and Java subprograms to reduce calls from your application to the database. For example, to execute ten individual SQL statements, ten calls are required, but to execute a subprogram containing ten SQL statements, only one call is required. <a id="sthref1958"></a></p>
<p>Unlike anonymous blocks, PL/SQL and Java subprograms can be compiled separately and stored in a database. When called, they are passed to the PL/SQL engine immediately. Moreover, only one copy of a subprogram need be loaded into memory for execution by multiple users.<a id="sthref1959"></a></p>
<div id="LNPCB1314" class="figure">
<p class="titleinfigure"><a id="CHEIIGJI"></a>Figure C-1 PL/SQL Boosts Performance</p>
<img width="605" height="283" src="img/pco81060.gif" alt="PL/SQL Boosts Performance"/><br/>
<a id="sthref1960" href="img_text/pco81060.htm">Description of &#34;Figure C-1 PL/SQL Boosts Performance&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect1" -->
<a id="i24462"></a>
<div id="LNPCB1315" class="sect1">
<h2 class="sect1">Optimizing SQL Statements</h2>
<p>For every SQL statement, the optimizer generates an <span class="italic">execution plan</span>, which is a series of steps that Oracle takes to execute the statement. These steps are determined by rules given in the <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a>. Following these rules will help you write optimal SQL statements.<a id="sthref1961"></a><a id="sthref1962"></a><a id="sthref1963"></a></p>
<div id="LNPCB1316" class="sect2"><a id="sthref1964"></a>
<h3 class="sect2">Optimizer Hints</h3>
<p>For every SQL statement, the optimizer generates an <span class="italic">execution plan</span>, which is a series of steps that Oracle takes to execute the statement. In some cases, you can suggest the way to optimize a SQL statement. These suggestions, called <span class="italic">hints</span>, let you influence decisions made by the optimizer.<a id="sthref1965"></a><a id="sthref1966"></a></p>
<p>Hints are not directives; they merely help the optimizer do its job. Some hints limit the scope of information used to optimize a SQL statement, while others suggest overall strategies. You can use hints to specify the:</p>
<ul>
<li>
<p>Optimization approach for a SQL statement</p>
</li>
<li>
<p>Access path for each referenced table</p>
</li>
<li>
<p>Join order for a join</p>
</li>
<li>
<p>Method used to join tables</p>
</li>
</ul>
<div id="LNPCB1317" class="sect3"><a id="sthref1967"></a>
<h4 class="sect3">Giving Hints</h4>
<p>You give hints to the optimizer by placing them in a C-style Comment immediately after the verb in a SELECT, UPDATE, or DELETE statement. You can choose rule-based or cost-based optimization. With cost-based optimization, hints help maximize throughput or response time. In the following example, the ALL_ROWS hint helps maximize query throughput:</p>
<pre>     EXEC SQL SELECT /*+ ALL_ROWS (cost-based) */ EMPNO, ENAME, SAL
         INTO :EMP-NUMBER, :EMP-NAME, :SALARY  
         FROM EMP 
         WHERE DEPTNO = :DEPT-NUMBER
     END-EXEC. 
</pre>
<p>The plus sign (+), which must immediately follow the Comment opener, indicates that the Comment contains one or more hints. Notice that the Comment can contain remarks as well as hints.</p>
<p>For more information about optimizer hints, see the <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a></p>
<p>Trace Facility</p>
<p>You can use the SQL trace facility and the EXPLAIN PLAN statement to identify SQL statements that might be slowing down your application. The trace facility generates statistics for every SQL statement executed by Oracle. From these statistics, you can determine which statements take the most time to process. You can then concentrate your tuning efforts on those statements.<a id="sthref1968"></a><a id="sthref1969"></a></p>
<p>The EXPLAIN PLAN statement shows the execution plan for each SQL statement in your application. You can use the execution plan to identify inefficient SQL statements.</p>
<p>See Also: <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide f</span></a>or instructions on using trace tools and analyzing their output.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<div id="LNPCB1318" class="sect1"><!-- infolevel="all" infotype="General" --><a id="sthref1970"></a>
<h2 class="sect1">SQL Statement Caching</h2>
<p>Performance improvement is achieved in precompiler applications using statement caching. Any program using dynamic SQL statements, where the cursors have to be used with reparsing of the statements will have performance gain with statement caching. With this new feature, the overall execution time will be decreased.</p>
<p>The stmt_cache option can be set to hold the anticipated number of distinct dynamic SQL statements in the application. The customer can set the stmt_cache size with the new precompiler command line option. An optimal value of stmt_cache can not be set, as it depends on the input program behavior.</p>
<p>The performance can be measured with the change in the execution time (with and without statement caching).</p>
</div>
<!-- class="sect1" -->
<a id="i24508"></a>
<div id="LNPCB1319" class="sect1">
<h2 class="sect1">Using Indexes</h2>
<p>Using rowids, an <span class="italic">index</span> associates each distinct value in a table column with the rows containing that value. An index is created with the CREATE INDEX statement. For details, see the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.<a id="sthref1971"></a></p>
<p>You can use indexes to boost the performance of queries that return less than 15% of the rows in a table. A query that returns 15% or more of the rows in a table is executed faster by a <span class="italic">full scan</span>, that is, by reading all rows sequentially. Any query that names an indexed column in its WHERE clause can use the index. For guidelines that help you choose which columns to index, see the <a class="olink ADFNS" href="../ADFNS/toc.htm"><span class="italic">Oracle Database Advanced Application Developer&#39;s Guide</span></a>.<a id="sthref1972"></a></p>
</div>
<!-- class="sect1" -->
<a id="i24524"></a>
<div id="LNPCB1320" class="sect1">
<h2 class="sect1">Taking Advantage of Row-Level Locking</h2>
<p>By default, Oracle locks data at the row level rather than the table level. Row-level locking allows multiple users to access different rows in the same table concurrently. The resulting performance gain is significant.</p>
<p>You can specify table-level locking, but it lessens the effectiveness of the transaction processing option. For more information about table locking, see &#34;Using the LOCK TABLE Statement&#34; on <a href="pco03dbc.htm#i4261">&#34;Using the LOCK TABLE Statement&#34;</a>.<a id="sthref1973"></a></p>
<p>Applications that do online transaction processing benefit most from row-level locking. If your application relies on table-level locking, modify it to take advantage of row-level locking. In general, avoid explicit table-level locking.</p>
</div>
<!-- class="sect1" -->
<a id="i24533"></a>
<div id="LNPCB1321" class="sect1">
<h2 class="sect1">Eliminating Unnecessary Parsing</h2>
<p>Eliminating unnecessary parsing requires correct handling of cursors and selective use of the following cursor management options:</p>
<ul>
<li>
<p>MAXOPENCURSORS</p>
</li>
<li>
<p>HOLD_CURSOR</p>
</li>
<li>
<p>RELEASE_CURSOR</p>
</li>
</ul>
<p>These options affect implicit and explicit cursors, the cursor cache, and private SQL areas.<a id="sthref1974"></a><a id="sthref1975"></a><a id="sthref1976"></a><a id="sthref1977"></a><a id="sthref1978"></a><a id="sthref1979"></a></p>
<p><span class="bold">Note:</span> You can use the ORACA to get cursor cache statistics. See <a href="pco08err.htm#i14161">&#34;Using the Oracle Communications Area&#34;</a>.</p>
<div id="LNPCB1322" class="sect2"><a id="sthref1980"></a>
<h3 class="sect2">Handling Explicit Cursors</h3>
<p>Recall that there are two types of cursors: implicit and explicit (see <a href="pco02prc.htm#i2019">&#34;Errors and Warnings&#34;</a>). Oracle implicitly declares a cursor for all data definition and data manipulation statements. However, for queries that return more than one row, you should explicitly declare a cursor and fetch in batches rather than select into a host table. You use the DECLARE CURSOR statement to declare an explicit cursor. How you handle the opening and closing of explicit cursors affects performance.<a id="sthref1981"></a></p>
<p>If you need to reevaluate the active set, simply reopen the cursor. The OPEN statement will use any new host-variable values. You can save processing time if you do not close the cursor first.</p>
<p>Only CLOSE a cursor when you want to free the resources (memory and locks) acquired by OPENing the cursor. For example, your program should close all cursors before exiting.</p>
<p><span class="bold">Note:</span> To make performance tuning easier, the precompiler lets you reopen an already open cursor. However, this is an Oracle extension to the ANSI/ISO embedded SQL standard. So, when MODE=ANSI, you must close a cursor before reopening it.</p>
<div id="LNPCB1323" class="sect3"><a id="sthref1982"></a>
<h4 class="sect3">Cursor Control</h4>
<p>In general, there are three factors that affect the control of an explicitly declared cursor:</p>
<ul>
<li>
<p>Using the DECLARE, OPEN, FETCH, and CLOSE statements.</p>
</li>
<li>
<p>Using the PREPARE, DECLARE, OPEN, FETCH, and CLOSE statements</p>
</li>
<li>
<p>COMMIT closes the cursor when MODE=ANSI</p>
</li>
</ul>
<p>With the first way, beware of unnecessary parsing. The OPEN statement does the parsing, but only if the parsed statement is unavailable because the cursor was closed or never opened. Your program should declare the cursor, re-open it every time the value of a host variable changes, and close it only when the SQL statement is no longer needed.</p>
<p>With the second way, which is used in dynamic SQL Methods 3 and 4, the PREPARE statement does the parsing, and the parsed statement is available until a CLOSE statement is executed. Your program should prepare the SQL statement and declare the cursor, re-open the cursor every time the value of a host variable changes, re-prepare the SQL statement and re-open the cursor if the SQL statement changes, and close the cursor only when the SQL statement is no longer needed.</p>
<p>When possible, avoid placing OPEN and CLOSE statements in a loop; this is a potential cause of unnecessary re-parsing of the SQL statement. In the next example, both the OPEN and CLOSE statements are inside the outer loop. When MODE=ANSI, the CLOSE statement must be positioned as shown, because ANSI requires a cursor to be closed before being re-opened.</p>
<pre>     EXEC SQL DECLARE emp_cursor CURSOR FOR 
         SELECT ENAME, SAL FROM EMP
         WHERE SAL &gt;  :SALARY
         AND SAL &lt;= :SALARY + 1000
     END-EXEC. 
     MOVE 0 TO SALARY. 
 TOP. 
     EXEC SQL OPEN emp_cursor END-EXEC.
 LOOP.
     EXEC SQL FETCH emp_cursor INTO ....
     ... 
         IF SQLCODE = 0
              GO TO LOOP
          ELSE
              ADD 1000 TO SALARY
          END-IF.
     EXEC SQL CLOSE emp_cursor END-EXEC.
     IF SALARY &lt; 5000
         GO TO TOP. 
</pre>
<p>With MODE=ORACLE, however, by placing the CLOSE statement outside the outer loop, you can avoid possible re-parsing at each iteration of the OPEN statement.</p>
<pre> TOP. 
     EXEC SQL OPEN emp_cursor END-EXEC.
 LOOP.
     EXEC SQL FETCH emp_cursor INTO ....
     ... 
         IF SQLCODE = 0
              GO TO LOOP
          ELSE
              ADD 1000 TO SALARY
          END-IF. 
     IF SALARY &lt; 5000
         GO TO TOP. 
     EXEC SQL CLOSE emp_cursor END-EXEC.
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNPCB1324" class="sect2"><a id="sthref1983"></a>
<h3 class="sect2">Using the Cursor Management Options</h3>
<p>A SQL statement need be parsed only once unless you change its makeup. For example, you change the makeup of a query by adding a column to its select list or WHERE clause. The HOLD_CURSOR, RELEASE_CURSOR, and MAXOPENCURSORS options give you some control over how Oracle manages the parsing and re-parsing of SQL statements. Declaring an explicit cursor gives you maximum control over parsing.</p>
<div id="LNPCB1325" class="sect3"><a id="sthref1984"></a>
<h4 class="sect3">Private SQL Areas and Cursor Cache</h4>
<p>When any statement is executed, its associated cursor is linked to an entry in the cursor cache. The cursor cache is a continuously updated area of memory used for cursor management. The cursor cache entry is in turn linked to a private SQL area.<a id="sthref1985"></a></p>
<p>The private SQL area, a work area created dynamically at run time by Oracle, contains the parsed SQL statement, the addresses of host variables, and other information needed to process the statement. Dynamic Method 3 lets you name a SQL statement, access the information in its private SQL area, and, to some extent, control its processing.<a id="sthref1986"></a></p>
<p><a href="#i24609">Figure C-2</a> represents the cursor cache after your program has done an insert and a delete.</p>
<div id="LNPCB1326" class="figure">
<p class="titleinfigure"><a id="i24609"></a>Figure C-2 Cursors Linked through the Cursor Cache</p>
<img width="605" height="200" src="img/pco81062.gif" alt="Cursor Cache"/><br/>
<a id="sthref1987" href="img_text/pco81062.htm">Description of &#34;Figure C-2 Cursors Linked through the Cursor Cache&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<div id="LNPCB1327" class="sect3"><a id="sthref1988"></a>
<h4 class="sect3">Resource Use</h4>
<p>The maximum number of open cursors for each user session is set by the initialization parameter OPEN_CURSORS.</p>
<p>MAXOPENCURSORS specifies the <span class="italic">initial</span> size of the cursor cache. If a new cursor is needed and there are no free cache entries, Oracle tries to reuse an entry. Its success depends on the values of HOLD_CURSOR and RELEASE_CURSOR and, for explicit cursors, on the status of the cursor itself.</p>
<p>If the value of MAXOPENCURSORS is less than the number of statements that need to be cached during the execution of the program, Oracle will search for cursor cache entries to reuse once MAXOPENCURSORS cache entries have been exhausted. For example, suppose the cache entry <span class="italic">E</span>(1) for an INSERT statement is marked as reusable, and the number of cache entries already equals MAXOPENCURSORS. If the program executes a new statement, cache entry <span class="italic">E</span>(1) and its private SQL area might be reassigned to the new statement. To reexecute the INSERT statement, Oracle would have to re-parse it and reassign another cache entry.</p>
<p>Oracle allocates an additional cache entry if it cannot find one to reuse. For example, if MAXOPENCURSORS=8 and all eight entries are active, a ninth is created. If necessary, Oracle keeps allocating additional cache entries until it runs out of memory or reaches the limit set by OPEN_CURSORS. This dynamic allocation adds to processing overhead.</p>
<p>Thus, specifying a low value for MAXOPENCURSORS with HOLD_CURSOR=NO (the default) saves memory but causes potentially expensive dynamic allocations and de-allocations of new cache entries. Specifying a high value for MAXOPENCURSORS assures speedy execution but uses more memory.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB1328" class="sect3"><a id="sthref1989"></a>
<h4 class="sect3">Infrequent Execution</h4>
<p>Sometimes, the link between an <span class="italic">infrequently</span> executed SQL statement and its private SQL area should be temporary.</p>
<p>When HOLD_CURSOR=NO (the default), after Oracle executes the SQL statement and the cursor is closed, the precompiler marks the link between the cursor and cursor cache as reusable. The link is reused as soon as the cursor cache entry to which it points is needed for another SQL statement. This frees memory allocated to the private SQL area and releases parse locks. However, because a prepared cursor must remain active, its link is maintained even when HOLD_CURSOR=NO.</p>
<p>When RELEASE_CURSOR=YES, after Oracle executes the SQL statement and the cursor is closed, the private SQL area is automatically freed and the parsed statement lost. This might be necessary if, for example, you wish to conserve memory.</p>
<p>When RELEASE_CURSOR=YES, the link between the private SQL area and the cache entry is immediately removed and the private SQL area freed. Even if you tried to specify HOLD_CURSOR=YES, Oracle must still reallocate memory for a private SQL area and re-parse the SQL statement before executing it. Therefore, specifying RELEASE_CURSOR=YES overrides HOLD_CURSOR=YES.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB1329" class="sect3"><a id="sthref1990"></a>
<h4 class="sect3">Frequent Execution</h4>
<p>The links between a <span class="italic">frequently</span> executed SQL statement and its private SQL area should be maintained, because the private SQL area contains all the information needed to execute the statement. Maintaining access to this information makes subsequent execution of the statement much faster.</p>
<p>When HOLD_CURSOR=YES, the link between the cursor and cursor cache is maintained after Oracle executes the SQL statement. Thus, the parsed statement and allocated memory remain available. This is useful for SQL statements that you want to keep active because it avoids unnecessary re-parsing.<a id="sthref1991"></a></p>
</div>
<!-- class="sect3" -->
<div id="LNPCB1330" class="sect3"><a id="sthref1992"></a>
<h4 class="sect3">Effect on the Shared SQL Area</h4>
<p>Oracle caches the parsed representations of SQL statements and PL/SQL in its Shared SQL Cache. These representations are maintained until aged out by the need for the space to be used for other statements. For more information, see the <a class="olink CNCPT1228" href="../CNCPT/memory.htm#CNCPT1228"><span class="italic">Oracle Database Concepts</span></a> manual. The behavior of the Oracle server in this respect is unaffected by the Precompiler&#39;s cursor management settings and so can have the following effects:</p>
<ul>
<li>
<p>When RELEASE_CURSOR=YES and a statement is re executed, a request will be sent to the server to parse the statement but a full parse may not be necessary since the statement may still be cached.</p>
</li>
<li>
<p>When using HOLD_CURSOR=YES no locks are held on any objects referred to in the statement and so a redefinition of one of the objects in the statement will force the cached statement to become invalid and for the server to automatically reparse the statement. This may cause unexpected results.</p>
</li>
<li>
<p>Nonetheless, when RELEASE_CURSOR=YES, the re-parse might not require extra processing because Oracle caches the parsed representations of SQL statements and PL/SQL blocks in its <span class="italic">Shared SQL Cache</span>. Even if its cursor is closed, the parsed representation remains available until it is aged out of the cache.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i24640"></a>
<div id="LNPCB1331" class="sect3">
<h4 class="sect3">Embedded PL/SQL Considerations</h4>
<p>For the purposes of cursor management, an embedded PL/SQL block is treated just like a SQL statement. When an embedded PL/SQL block is executed, a parent cursor is associated with the entire block and a link is created between the cache entry and the private SQL area in the PGA for the embedded PL/SQL block. Be aware that each SQL statement inside the embedded block also requires a private SQL area in the PGA. These SQL statements use child cursors that PL/SQL manages itself. The disposition of the child cursors is determined through its associated parent cursor. That is, the private SQL areas used by the child cursors are freed after the private SQL area for its parent cursor is freed.</p>
<p>Note:</p>
<p>Using the defaults, HOLD_CURSOR=YES and RELEASE_CURSOR=NO, after executing a SQL statement with an earlier Oracle version, its parsed representation remains available. With Oracle, under similar conditions, the parsed representation remains available only until it is aged out of the Shared SQL Cache. Normally, this is not a problem, but you might get unexpected results if the definition of a referenced object changes before the SQL statement is re-parsed.</p>
</div>
<!-- class="sect3" -->
<div id="LNPCB1332" class="sect3"><a id="sthref1993"></a>
<h4 class="sect3">Parameter Interactions</h4>
<p><a href="#i24652">Table C-1</a> shows how HOLD_CURSOR and RELEASE_CURSOR interact. Notice that HOLD_CURSOR=NO overrides RELEASE_CURSOR=NO and that RELEASE_CURSOR=YES overrides HOLD_CURSOR=YES.</p>
<div id="LNPCB1333" class="tblformal">
<p class="titleintable"><a id="sthref1994"></a><a id="CHEHJFCA"></a>Table C-1 <a id="i24652"></a><span class="bolditalic">HOLD_CURSOR and RELEASE _CURSOR Interactions</span></p>
<table class="cellalignment4971" title="HOLD_CURSOR and RELEASE _CURSOR Interactions" summary="q" dir="ltr">
<thead>
<tr class="cellalignment4965">
<th class="cellalignment4972" id="r1c1-t2">HOLD_CURSOR</th>
<th class="cellalignment4972" id="r1c2-t2">RELEASE_CURSOR</th>
<th class="cellalignment4972" id="r1c3-t2">Links are...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r2c1-t2" headers="r1c1-t2">
<p>NO</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c2-t2">
<p>NO</p>
</td>
<td class="cellalignment4973" headers="r2c1-t2 r1c3-t2">
<p>marked as reusable</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r3c1-t2" headers="r1c1-t2">
<p>YES</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c2-t2">
<p>NO</p>
</td>
<td class="cellalignment4973" headers="r3c1-t2 r1c3-t2">
<p>maintained</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r4c1-t2" headers="r1c1-t2">
<p>NO</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c2-t2">
<p>YES</p>
</td>
<td class="cellalignment4973" headers="r4c1-t2 r1c3-t2">
<p>removed immediately</p>
</td>
</tr>
<tr class="cellalignment4965">
<td class="cellalignment4973" id="r5c1-t2" headers="r1c1-t2">
<p>YES</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c2-t2">
<p>YES</p>
</td>
<td class="cellalignment4973" headers="r5c1-t2 r1c3-t2">
<p>removed immediately</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<div id="LNPCB1334" class="sect1"><a id="sthref1995"></a>
<h2 class="sect1"><a id="sthref1996"></a>Avoiding Unnecessary Reparsing</h2>
<p>When an embedded SQL statement is executed in a loop, it gets parsed only once. However, the execute phase of the SQL statement can result in errors, and statements are reparsed, with the following exceptions:</p>
<ul>
<li>
<p>ORA-1403 (not found)</p>
</li>
<li>
<p>ORA-1405 (truncation)</p>
</li>
<li>
<p>ORA-1406 (null value)</p>
</li>
</ul>
<p>By correcting the errors, you can eliminate this unnecessary reparsing.</p>
</div>
<!-- class="sect1" --></div>
<!-- class="appendix" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4964">
<tr>
<td class="cellalignment4973">
<table class="cellalignment4969">
<tr>
<td class="cellalignment4968"><a href="pcoacres.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4968"><a href="pcoaechk.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4976">
<table class="cellalignment4967">
<tr>
<td class="cellalignment4968"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4968"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4968"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4968"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4968"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4968"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>