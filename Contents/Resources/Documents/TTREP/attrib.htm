<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-114014"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Defining%20Attributes%20and%20Options%20for%20a%20Replication%20Scheme"></a><title>Defining Attributes and Options for a Replication Scheme</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 726"/>
<meta name="dcterms.created" content="2014-09-29T11:11:55Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen In-Memory Database Replication Guide"/>
<meta name="dcterms.identifier" content="E21635-11"/>
<meta name="dcterms.isVersionOf" content="TTREP"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2012, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="definepair.htm" title="Previous" type="text/html"/>
<link rel="Next" href="standby.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21635-11.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/21</span> <!-- End Header -->
<div id="TTREP817" class="chapter"><a id="CHDFCJEE"></a>
<h1 class="chapter"><span class="secnum">4</span> Defining Attributes and Options for a Replication Scheme</h1>
<p>The following sections describe the return service options, <code>STORE</code> atttributes, and network operations that can be configured for both active standby pairs and classic replication (involving master and subscribers). Any differences for one replication scheme over the other are detailed within each section.</p>
<ul>
<li>
<p><a href="#CHDHCDCB">Using a return service</a></p>
</li>
<li>
<p><a href="#CHDFAGAB">Setting STORE attributes</a></p>
</li>
<li>
<p><a href="#CEGDGAAD">Configuring the network</a></p>
</li>
</ul>
<a id="CHDHCDCB"></a>
<div id="TTREP183" class="sect1">
<h2 class="sect1">Using a return servic<a id="sthref139"></a><a id="sthref140"></a>e<a id="sthref141"></a><a id="sthref142"></a></h2>
<p>You can configure your replication scheme with a return service to ensure a higher level of confidence that your replicated data is consistent on the databases in your replication scheme.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This section assumes you understand return services. For an overview on return services, see <a href="overview.htm#CJAFADFC">&#34;Copying updates between databases&#34;</a>.</div>
<p>This section describes how to configure and manage the return receipt and return twosafe services. You can specify a return service for table elements and database elements for any standby or subscriber defined in replication scheme with the <code>CREATE ACTIVE STANDBY PAIR</code>, <code>ALTER ACTIVE STANDBY PAIR</code>, <code>CREATE REPLICATION</code>, or <code>ALTER REPLICATION</code> statements. The default is the <code>NO RETURN</code> service, which is asynchronous replication and the best performance option.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can use the <a id="sthref143"></a><code>ttRepXactStatus</code> procedure to check on the status of a return receipt or return twosafe transaction. See <a href="monitor.htm#CFAJDGFG">&#34;Check the status of return service transactions&#34;</a> for details.</div>
<p>The following sections describe the return services that can be used for your replication scheme:</p>
<ul>
<li>
<p><a href="#BGBEIIBF">Specifying a different return service for each subscriber in a classic replication scheme</a></p>
</li>
<li>
<p><a href="#CHDFFDBE">RETURN RECEIPT</a></p>
</li>
<li>
<p><a href="#CHDFFEBC">RETURN RECEIPT BY REQUEST</a></p>
</li>
<li>
<p><a href="#CHDHIGDF">RETURN TWOSAFE</a></p>
</li>
<li>
<p><a href="#CHDGAFAE">RETURN TWOSAFE BY REQUEST</a></p>
</li>
<li>
<p><a href="#CHDBJEGA">NO RETURN</a></p>
</li>
</ul>
<a id="BGBEIIBF"></a>
<div id="TTREP781" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Specifying a different return service for each subscriber in a classic replication scheme</h3>
<p>In a classic replication scheme, you can specify a different return service for table elements and database elements for the subscribers listed in each <code>SUBSCRIBER</code> clause in a <code>CREATE REPLICATION</code> or <code>ALTER REPLICATION</code> statement.</p>
<p><a href="#BGBEGJJD">Example 4-1</a> shows separate <code>SUBSCRIBER</code> clauses that can define different return service attributes for <code><span class="codeinlineitalic">SubDatabase1</span></code> and <code><span class="codeinlineitalic">SubDatabase2</span></code>.</p>
<div id="TTREP782" class="example">
<p class="titleinexample"><a id="BGBEGJJD"></a>Example 4-1 Different return services for each subscriber</p>
<pre>CREATE REPLICATION <span class="italic">Owner.SchemeName</span>
  ELEMENT <span class="italic">ElementNameElementType</span>
    MASTER <span class="italic">DatabaseName</span> ON &#34;<span class="italic">HostName</span>&#34;
    SUBSCRIBER <span class="italic">SubDatabase1</span> ON &#34;<span class="italic">HostName</span>&#34; <span class="italic">ReturnServiceAttribute1</span>
    SUBSCRIBER <span class="italic">SubDatabase2</span> ON &#34;<span class="italic">HostName</span>&#34; <span class="italic">ReturnServiceAttribute2</span>;
</pre></div>
<!-- class="example" -->
<p>Alternatively, you can specify the same return service attribute for all of the subscribers defined in an element. <a href="#BGBJIAHC">Example 4-2</a> shows the use of a single <code>SUBSCRIBER</code> clause that defines the same return service attributes for both <code><span class="codeinlineitalic">SubDatabase1</span></code> and <code><span class="codeinlineitalic">SubDatabase2</span></code>.</p>
<div id="TTREP783" class="example">
<p class="titleinexample"><a id="BGBJIAHC"></a>Example 4-2 Same return service for all subscribers</p>
<pre>CREATE REPLICATION <span class="italic">Owner.SchemeName</span>
  ELEMENT <span class="italic">ElementNameElementType</span>
    MASTER <span class="italic">DatabaseName</span> ON &#34;<span class="italic">HostName</span>&#34;
    SUBSCRIBER <span class="italic">SubDatabase1</span> ON &#34;<span class="italic">HostName</span>&#34;,
               <span class="italic">SubDatabase2</span> ON &#34;<span class="italic">HostName</span>&#34;
               <span class="italic">ReturnServiceAttribute</span>;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDFFDBE"></a>
<div id="TTREP184" class="sect2">
<h3 class="sect2"><a id="sthref144"></a>RETURN RECEIPT<a id="sthref145"></a></h3>
<p>TimesTen provides an optional return receipt service to loosely couple or synchronize your application with the replication mechanism.</p>
<ul>
<li>
<p>In an active standby pair, you can specify the <code>RETURN RECEIPT</code> clause to enable the return receipt service for the standby database. With return receipt enabled, when your application commits a transaction for an element on the active database, the application remains blocked until the standby acknowledges receipt of the transaction update.</p>
</li>
<li>
<p>In a classic replication scheme, you can specify the <code>RETURN RECEIPT</code> clause to enable the return receipt service for the subscriber database. With return receipt enabled, when your application commits a transaction for an element on the master database, the application remains blocked until the subscriber acknowledges receipt of the transaction update. If the master is replicating the element to multiple subscribers, the application remains blocked until all of the subscribers have acknowledged receipt of the transaction update.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can also configure the replication agent to disable the return receipt service after a specific number of timeouts. See <a href="#CHDHHAGE">&#34;Setting the return service timeout period&#34;</a> for details on timeouts.</div>
<p>If the standby or subscriber is unable to acknowledge receipt of the transaction within a configurable timeout period, your application receives a <code>tt_ErrRepReturnFailed</code> (8170) warning on its commit request.</p>
<div id="TTREP784" class="example">
<p class="titleinexample"><a id="sthref146"></a>Example 4-3 Defining RETURN RECEIPT for an active standby pair</p>
<p>The following example creates an active standby pair where <code>master1</code> is the active database, <code>master2</code> is the standby database. The standby database is enabled with the return receipt service.</p>
<pre>Command&gt; CREATE ACTIVE STANDBY PAIR 
 &gt; master1, 
 &gt; master2 
 &gt; RETURN RECEIPT;
</pre></div>
<!-- class="example" -->
<div id="TTREP785" class="example">
<p class="titleinexample"><a id="sthref147"></a>Example 4-4 Defining RETURN RECEIPT for a classic replication scheme</p>
<p>To confirm that all transactions committed on the <code>tab</code> table in the master database (<code>masterds</code>) are received by the subscriber (<code>subscriberds</code>), the element description (<code>e</code>) might look like the following:</p>
<p><span class="bold">NOTE:</span> For more examples of classic replication schemes that use return receipt services, see <a href="design.htm#CHDDHFIC">Example 9-5</a> and <a href="design.htm#CACHEHJC">Example 9-6</a>.</p>
<pre>ELEMENT e TABLE tab
    MASTER masterds ON &#34;system1&#34;
    SUBSCRIBER subscriberds ON &#34;system2&#34;
      RETURN RECEIPT
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDFFEBC"></a>
<div id="TTREP185" class="sect2">
<h3 class="sect2"><a id="sthref148"></a>RETURN RECEIPT BY REQUEST<a id="sthref149"></a></h3>
<p><code>RETURN RECEIPT</code> enables notification of receipt for all transactions. You can use the <code>RETURN RECEIPT</code> <code>BY REQUEST</code> clause to enable an acknowledgement receipt notification only for specific transactions identified by your application.</p>
<p>If you specify <code>RETURN RECEIPT BY REQUEST</code>, you must use the <a id="sthref150"></a><code>ttRepSyncSet<a id="sthref151"></a></code> built-in procedure on the active or master database to enable the return receipt service for a transaction. The call to enable the return receipt service must be part of the transaction <a id="sthref152"></a>(<code>autocommit</code> must be off).</p>
<p>If the standby or subscriber database is unable to acknowledge receipt of the transaction update within a configurable timeout period, the application receives a <code>tt_ErrRepReturnFailed</code> (8170) warning on its commit request. See <a href="#CHDHHAGE">&#34;Setting the return service timeout period&#34;</a> for more information on the return service timeout period.</p>
<div id="TTREP786" class="example">
<p class="titleinexample"><a id="sthref153"></a>Example 4-5 RETURN RECEIPT BY REQUEST for an active standby pair</p>
<p>The following example creates an active standby pair where <code>master1</code> is the active database and <code>master2</code> is the standby database. The standby database is enabled with the return receipt service.</p>
<pre>Command&gt; CREATE ACTIVE STANDBY PAIR 
 &gt; master1, 
 &gt; master2 
 &gt; RETURN RECEIPT BY REQUEST;
</pre></div>
<!-- class="example" -->
<div id="TTREP787" class="example">
<p class="titleinexample"><a id="sthref154"></a>Example 4-6 RETURN RECEIPT BY REQUEST for a classic replication scheme</p>
<p>To enable confirmation that specific transactions committed on the <code>tab</code> table in the master database (<code>masterds</code>) are received by the subscriber (<code>subscriberds</code>), the element description (<code>e</code>) might look like:</p>
<pre>ELEMENT e TABLE tab
    MASTER masterds ON &#34;system1&#34;
    SUBSCRIBER subscriberds ON &#34;system2&#34;
      RETURN RECEIPT BY REQUEST
</pre></div>
<!-- class="example" -->
<div id="TTREP788" class="example">
<p class="titleinexample"><a id="sthref155"></a>Example 4-7 Using ttRepSyncSet to request the return services</p>
<p>Before committing a transaction that requires an acknowledgement return receipt, call <a id="sthref156"></a><code>ttRepSyncSet</code>. The following example sets the request for a return receipt with the first column set to <code>0x01</code> with a timeout value of 45 seconds in column two.</p>
<pre>Command&gt; autocommit off;
Command&gt; CALL ttRepSyncSet(0x01, 45, 1);
</pre>
<p>You can use <a id="sthref157"></a><code>ttRepSyncGet</code> to check if a return service is enabled and obtain the timeout value. The following demonstrates that the values that were previously set with the <code>ttRepSyncSet</code> built-in procedure.</p>
<pre>Command&gt; CALL ttRepSyncGet;
&lt; 01, 45, 1 &gt;
1 row found.
</pre>
<p>For more information, see <a class="olink TTREF297" href="../TTREF/proced.htm#TTREF297">&#34;ttRepSyncSet&#34;</a> and <a class="olink TTREF296" href="../TTREF/proced.htm#TTREF296">&#34;ttRepSyncGet&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDHIGDF"></a>
<div id="TTREP186" class="sect2">
<h3 class="sect2">RETURN <a id="sthref158"></a>TWOSAFE<a id="sthref159"></a></h3>
<p>TimesTen provides a return twosafe service to fully synchronize your application with the replication mechanism. The return twosafe service ensures that each replicated transaction is committed on the standby database before it is committed on the active database. If replication is unable to verify the transaction has been committed on the standby or subscriber, it returns notification of the error. Upon receiving an error, the application can either take a unique action or fall back on preconfigured actions, depending on the type of failure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When replication is configured with <code>RETURN TWOSAFE</code>, you must disable <a id="sthref160"></a>autocommit mode.</div>
<p>To enable the return twosafe service for the subscriber, specify the <code>RETURN TWOSAFE</code> attribute in the <code>CREATE ACTIVE STANDBY PAIR</code>, <code>ALTER ACTIVE STANDBY PAIR</code>, <code>CREATE REPLICATION</code>, or <code>ALTER REPLICATION</code> statements.</p>
<ul>
<li>
<p>When using an active standby pair, a <a id="sthref161"></a>transaction that contains operations that are replicated with <code>RETURN TWOSAFE</code> cannot have a <code>PassThrough</code> setting greater than 0. If <code>PassThrough</code> is greater than 0, an error is returned and the transaction must be rolled back.</p>
</li>
<li>
<p>W<a id="sthref162"></a>hen using a classic replication scheme, the return twosafe service is intended to be used in replication schemes where two databases must stay synchronized. One database has an active role, while the other database has a standby role but must be ready to assume an active role at any moment. <a id="sthref163"></a><a id="sthref164"></a>Use return twosafe with a bidirectional replication scheme with exactly two databases.</p>
<p>When the application commits a transaction on the master database, the application remains blocked until the subscriber acknowledges it has successfully committed the transaction. Initiating identical updates or deletes on both databases can lead to deadlocks in commits that can be resolved only by stopping the processes.</p>
</li>
</ul>
<p>If the standby or subscriber is unable to acknowledge commit of the transaction update within a configurable timeout period, the application receives a <code>tt_ErrRepReturnFailed</code> (8170) warning on its commit request. See <a href="#CHDHHAGE">&#34;Setting the return service timeout period&#34;</a> for more information on the return service timeout period.</p>
<div id="TTREP789" class="example">
<p class="titleinexample"><a id="sthref165"></a>Example 4-8 RETURN TWOSAFE with an active standby pair</p>
<p>The following example creates an active standby pair where <code>master1</code> is the active database, <code>master2</code> is the standby database. The standby database is enabled with the return twosafe service.</p>
<pre>Command&gt; CREATE ACTIVE STANDBY PAIR 
 &gt; master1, 
 &gt; master2 
 &gt; RETURN TWOSAFE;
</pre></div>
<!-- class="example" -->
<div id="TTREP790" class="example">
<p class="titleinexample"><a id="sthref166"></a>Example 4-9 RETURN TWOSAFE with a classic replication scheme</p>
<p>To confirm all transactions committed on the master database (<code>databaseA</code>) are also committed by the subscriber (<code>databaseB</code>), the element description (<code>a</code>) might look like the following:</p>
<pre>ELEMENT a DATASTORE
    MASTER databaseA ON &#34;system1&#34;
    SUBSCRIBER databaseB ON &#34;system2&#34;
      RETURN TWOSAFE
</pre>
<p>The entire <code>CREATE REPLICATION</code> statement that specifies both <code>databaseA</code> and <code>databaseB</code> in a bidirectional configuration with <code>RETURN TWOSAFE</code> might look like the following:</p>
<pre>CREATE REPLICATION bidirect
ELEMENT a DATASTORE
    MASTER databaseA ON &#34;system1&#34;
    SUBSCRIBER databaseB ON &#34;system2&#34;
      RETURN TWOSAFE
ELEMENT b DATASTORE
    MASTER databaseB ON &#34;system2&#34;
    SUBSCRIBER databaseA ON &#34;system1&#34;
      RETURN TWOSAFE;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDGAFAE"></a>
<div id="TTREP187" class="sect2">
<h3 class="sect2">RETURN TWOSAFE BY <a id="sthref167"></a>REQUEST<a id="sthref168"></a></h3>
<p><code>RETURN TWOSAFE</code> enables notification of commit on the standby database for all transactions. You can use the <code>RETURN TWOSAFE</code> <code>BY REQUEST</code> clause to enable notification of a commit on the standby only for specific transactions identified by your application.</p>
<p>If you specify <code>RETURN TWOSAFE BY REQUEST</code> for a standby or subscriber database, you must use the <a id="sthref169"></a><code>ttRepSyncSet</code> built-in procedure on the active or master database to enable the return twosafe service for a transaction. The call to enable the return twosafe service must be part of the transaction <a id="sthref170"></a>(<code>autocommit</code> must be off).</p>
<p>The <code>ALTER TABLE</code> statement cannot be used to alter a replicated table that is part of a <code>RETURN TWOSAFE BY REQUEST</code> transaction. If <code>DDLCommitBehavior</code>=0 (the default), the <code>ALTER TABLE</code> operation succeeds because a commit is performed before the <code>ALTER TABLE</code> operation, resulting in the <code>ALTER TABLE</code> operation executing in a new transaction which is not part of the <code>RETURN TWOSAFE BY REQUEST</code> transaction. If <code>DDLCommitBehavior</code>=1, the <code>ALTER TABLE</code> operation results in error 8051.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
See <a href="#CHDHHAGE">&#34;Setting the return service timeout period&#34;</a> for more information on setting the return service timeout period.</div>
<p>If the standby or subscriber is unable to acknowledge commit of the transaction within the timeout period, the application receives a <code>tt_ErrRepReturnFailed</code> (8170) warning on its commit request. The application can then chose how to handle the timeout. See <a href="#CHDHHAGE">&#34;Setting the return service timeout period&#34;</a>.</p>
<p>When using an active standby pair, a <a id="sthref171"></a>transaction that contains operations that are replicated with <code>RETURN TWOSAFE</code> cannot have a <code>PassThrough</code> setting greater than 0. If <code>PassThrough</code> is greater than 0, an error is returned and the transaction must be rolled back.</p>
<div id="TTREP791" class="example">
<p class="titleinexample"><a id="sthref172"></a>Example 4-10 RETURN TWOSAFE BY REQUST for an active standby pair</p>
<p>The following example creates an active standby pair where <code>master1</code> is the active database, <code>master2</code> is the standby database. The standby database is enabled with the return twosafe by request service.</p>
<pre>Command&gt; CREATE ACTIVE STANDBY PAIR 
 &gt; master1, 
 &gt; master2 
 &gt; RETURN TWOSAFE BY REQUEST;
</pre>
<p>Before calling commit for a transaction that requires confirmation of commit on the subscriber, call the <code>ttRepSyncSet</code> built-in procedure to request the return service, set the timeout period to 45 seconds, and specify no action (1) in the event of a timeout error:</p>
<pre>Command&gt; CALL ttRepSyncSet(0x01, 45, 1);
</pre>
<p>You can use the <a id="sthref173"></a><code>ttRepSyncGet</code> built-in procedure to check if a return service is enabled and obtain the timeout value.</p>
<pre>Command&gt; CALL ttRepSyncGet();
&lt; 01, 45, 1&gt;
1 row found.
</pre></div>
<!-- class="example" -->
<div id="TTREP792" class="example">
<p class="titleinexample"><a id="sthref174"></a>Example 4-11 RETURN TWOSAFE BY REQUEST for a classic replication scheme</p>
<p>To enable confirmation that specific transactions committed on the master database (<code>databaseA</code>) are also committed by the subscriber (<code>databaseB</code>), the element description (<code>a</code>) might look like:</p>
<pre>ELEMENT a DATASTORE
    MASTER databaseA ON &#34;system1&#34;
    SUBSCRIBER databaseB ON &#34;system2&#34;
      RETURN TWOSAFE BY REQUEST;
</pre>
<p>Before calling commit for a transaction that requires confirmation of commit on the subscriber, call the <code>ttRepSyncSet</code> built-in procedure to request the return service, set the timeout period to 45 seconds, and specify no action (1) in the event of a timeout error:</p>
<pre>Command&gt; CALL ttRepSyncSet(0x01, 45, 1);
</pre>
<p>You can use the <a id="sthref175"></a><code>ttRepSyncGet</code> built-in procedure to check if a return service is enabled and obtain the timeout value.</p>
<pre>Command&gt; CALL ttRepSyncGet();
&lt; 01, 45, 1&gt;
1 row found.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDBJEGA"></a>
<div id="TTREP188" class="sect2">
<h3 class="sect2"><a id="sthref176"></a><a id="sthref177"></a>NO RETURN</h3>
<p>You can use the <code>NO RETURN</code> clause to explicitly disable either the return receipt or return twosafe services, depending on which one you have enabled. <code>NO RETURN</code> is the default condition. This attribute is typically used only when altering a replication scheme to remove a previously defined return service in the <code>ALTER ACTIVE STANDBY PAIR</code> or <code>ALTER REPLICATION</code> statements. See <a href="alter.htm#BABHIBIH">Example 10-13</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDFAGAB"></a>
<div id="TTREP189" class="sect1">
<h2 class="sect1">Setting STORE <a id="sthref178"></a>attribute<a id="sthref179"></a>s</h2>
<p>The <code>STORE</code> attributes clause in the <code>CREATE ACTIVE STANDBY PAIR</code>, <code>ALTER ACTIVE STANDBY PAIR</code>, <code>CREATE REPLICATION</code>, and <code>ALTER REPLICATION</code> statements are used to set optional behavior for return services, compression, timeouts, durable commit behavior, and table definition checking. For a classic replication scheme, you can also define conflict reporting at the table level.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
See <a class="olink TTSQL289" href="../TTSQL/state.htm#TTSQL289">&#34;CREATE ACTIVE STANDBY PAIR&#34;</a> and <a class="olink TTSQL298" href="../TTSQL/state.htm#TTSQL298">&#34;CREATE REPLICATION&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for the full description and syntax for the <code>STORE</code> attributes.</div>
<p>When using classic replication schemes, the <code>FAILTHRESHOLD</code> and <code>TIMEOUT</code> attributes can be unique to a specific classic replication scheme definition. This means these attribute settings can vary if you have applied different classic replication scheme definitions to your replicated databases. This is not true for any of the other attributes, which must be the same across all classic replication scheme definitions. For example, setting the <code>PORT</code> attribute for one classic replication scheme sets it for all classic replication schemes. For an example classic replication scheme that uses a <code>STORE</code> clause to set the <code>FAILTHRESHOLD</code> attribute, see <a href="design.htm#CHDDHFIC">Example 9-5</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are using <code>ALTER ACTIVE STANDBY PAIR</code> to change any of the <code>STORE</code> attributes, you must follow the steps described in <a href="alterpair.htm#BABJAICG">&#34;Making other changes to an active standby pair&#34;</a>.</div>
<p>The following sections describe some of the <code>STORE</code> attributes:</p>
<ul>
<li>
<p><a href="#CHDHHAGE">Setting the return service timeout period</a></p>
</li>
<li>
<p><a href="#CHDFABDJ">Column definition options for replicated tables</a></p>
</li>
<li>
<p><a href="#CHDBEDCC">Compressing replicated traffic</a></p>
</li>
<li>
<p><a href="#CHDFGAEC">Port assignments</a></p>
</li>
<li>
<p><a href="#BGBJIIAD">Setting wait timeout for response from remote replication agents</a></p>
</li>
<li>
<p><a href="#CHDBACFH">Setting the transaction log failure threshold</a></p>
</li>
<li>
<p><a href="#CACHCIII">Suspending or resuming classic replication in response to conflicts</a></p>
</li>
</ul>
<a id="CHDHHAGE"></a>
<div id="TTREP191" class="sect2">
<h3 class="sect2">Setting the return service timeout period<a id="sthref180"></a></h3>
<p>The following describes how a timeout can occur in a replication scheme configured with one of the return services described in <a href="#CHDHCDCB">&#34;Using a return service&#34;</a>.</p>
<ul>
<li>
<p>In an active standby pair replication scheme, a timeout occurs if the standby database is unable to send an acknowledgement back to the active database within the time period specified by <code>RETURN WAIT TIME</code>.</p>
<p>If the standby database is unable to acknowledge the transaction update from the active database within the timeout period, the application receives an <code>errRepReturnFailed</code> warning on its commit request.</p>
</li>
<li>
<p>In a classic replication scheme, a timeout occurs if any of the subscribers are unable to send an acknowledgement back to the master within the time period specified by <code>RETURN WAIT TIME</code>.</p>
<p>The replication state could be set to <code>stop</code> by a user or by the master replication agent in the event of a subscriber failure. A subscriber may be unable to acknowledge a transaction that makes use of a return service and may time out with respect to the master.</p>
<p>If any of the subscribers are unable to acknowledge the transaction update within the timeout period, the application receives an <code>errRepReturnFailed</code> warning on its commit request.</p>
</li>
</ul>
<p>A return service may time out because of a replication failure or because replication is so far behind that the return service transaction times out before it is replicated. However, unless there is a simultaneous replication failure, failure to obtain a return service confirmation from the standby or subscriber does not necessarily mean the transaction has not been or will not be replicated.</p>
<p>The default return service timeout period is 10 seconds. You can specify a different return service timeout period by either:</p>
<ul>
<li>
<p>Specifying the <code>RETURN WAIT TIME</code> in the <code>CREATE ACTIVE STANDBY PAIR</code>, <code>ALTER ACTIVE STANDBY PAIR</code>, <code>CREATE REPLICATION</code>, or <code>ALTER REPLICATION</code> statements.</p>
<p>The <code>RETURN WAIT TIME</code> attribute specifies the number of seconds to wait for a return service acknowledgement. A value of 0 means that there is no waiting.</p>
<p>The following example alters an active database (<code>master1</code>) of an active standby pair to set a return service wait time of 25 seconds:</p>
<pre>Command&gt; ALTER ACTIVE STANDBY PAIR
 &gt; ALTER STORE master1 SET RETURN WAIT TIME 25;
</pre></li>
<li>
<p>Specifying a <a id="sthref181"></a>different return service timeout period programmatically by calling the <a id="sthref182"></a><code>ttRepSyncSet</code> built-in procedure on either the active database (in an active standby pair) or the master database (in a classic replication scheme) with a new timeout value for the <code>returnWait</code> parameter.</p>
<p>The following example demonstrates how to set the return service wait time to 25 seconds using <code>ttRepSyncSet</code>:</p>
<pre>Command&gt; CALL ttRepSyncSet (0x01, 25, 1);
</pre></li>
</ul>
<p>Once the timeout is set, the timeout period applies to all subsequent return service transactions until you either reset the timeout period or terminate the application session. For a classic replication scheme, the timeout setting applies to all return services for all subscribers.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can set other <code>STORE</code> attributes to establish policies that automatically disable return service blocking in the event of excessive timeouts and re-enable return service blocking when conditions improve. See <a href="#BGBHEHFB">&#34;Managing return service timeout errors and replication state changes&#34;</a>.</div>
<div id="TTREP793" class="example">
<p class="titleinexample"><a id="sthref183"></a>Example 4-12 Setting the timeout period for both databases in bidirectional (classic) replication scheme</p>
<p>To set the timeout period to 30 seconds for both bidirectionally replicated databases, <code>databaseA</code> and <code>databaseB</code>, in the <code>bidirect</code> replication scheme, the <code>CREATE REPLICATION</code> statement might look like the following:</p>
<pre>CREATE REPLICATION bidirect
ELEMENT a DATASTORE
    MASTER databaseA ON &#34;system1&#34;
    SUBSCRIBER databaseB ON &#34;system2&#34;
      RETURN TWOSAFE
ELEMENT b DATASTORE
    MASTER databaseB ON &#34;system2&#34;
    SUBSCRIBER databaseA ON &#34;system1&#34;
      RETURN TWOSAFE
STORE databaseA RETURN WAIT TIME 30
STORE databaseB RETURN WAIT TIME 30;
</pre></div>
<!-- class="example" -->
<div id="TTREP794" class="example">
<p class="titleinexample"><a id="sthref184"></a>Example 4-13 Resetting the timeout period</p>
<p>Use the <a id="sthref185"></a><code>ttRepSyncSet</code> built-in procedure to reset the timeout period to 45 seconds. To avoid resetting the <code>requestReturn</code> and <code>localAction</code> values, specify <code>NULL</code>:</p>
<pre>Command&gt; CALL ttRepSyncSet(NULL, 45, NULL);
</pre></div>
<!-- class="example" -->
<a id="BGBHEHFB"></a>
<div id="TTREP795" class="sect3">
<h4 class="sect3">Managing return service <a id="sthref186"></a>timeout <a id="sthref187"></a>errors and replication state changes</h4>
<p>The following sections describe how to detect and respond to timeouts on return service transactions:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
One response to a timeout is to disable the return service. You can determine if the return service is enabled or disabled with either the <a id="sthref188"></a><code>ttRepSyncSubscriberStatus</code> built-in procedure or the <code>ttRepReturnTransitionTrap</code> SNMP trap. For more information, see <a href="monitor.htm#CFAGGCFH">&#34;Determine if return service is disabled&#34;</a>.</div>
<ul>
<li>
<p><a href="#CHDEIBCB">Disabling return service blocking manually</a></p>
</li>
<li>
<p><a href="#CHDEFJJA">Establishing return service failure/recovery policies</a></p>
</li>
</ul>
<a id="CHDEIBCB"></a>
<div id="TTREP193" class="sect4">
<h5 class="sect4">Disabling return service blocking manually</h5>
<p>You may want to react if replication is stopped or return service timeout failures begin to adversely impact the performance of your replicated system. Your &#34;tolerance threshold&#34; for return service timeouts may depend on the historical frequency of timeouts and the performance/availability equation for your particular application, both of which should be factored into your response to the problem.</p>
<p>When using the return receipt service, you can manually respond by:</p>
<ul>
<li>
<p>Using the <code>ALTER ACTIVE STANDBY PAIR</code> or <code>ALTER REPLICATION</code> statements to disable return receipt blocking. If you decide to disable return receipt blocking, your decision to re-enable it depends on your confidence level that the return receipt transaction is no longer likely to time out.</p>
<p>The following example uses the <code>ALTER ACTIVE STANDBY PAIR</code> statement to disable return receipt after 10 failures:</p>
<pre>Command&gt; ALTER ACTIVE STANDBY PAIR
 &gt; ALTER STORE master1 SET DISABLE RETURN ALL 10;
</pre></li>
<li>
<p>Calling the <a id="sthref189"></a><code>ttDurableCommit</code> built-in procedure to durably commit transactions on the active or master database that you can no longer verify as being received by the standby or subscriber database.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="CHDEFJJA"></a>
<div id="TTREP194" class="sect4">
<h5 class="sect4">Establishing return service failure/recovery policies<a id="sthref190"></a><a id="sthref191"></a><a id="sthref192"></a><a id="sthref193"></a></h5>
<p>An <a id="sthref194"></a>alternative to manually responding to return service timeout failures is to establish return service failure and recovery policies in the replication scheme. These policies direct the replication agents to detect changes to the replication state and to keep track of return service timeouts and then automatically respond in a predefined manner.</p>
<p>The following attributes in the <code>CREATE ACTIVE STANDBY PAIR</code>, <code>ALTER ACTIVE STANDBY PAIR</code>, <code>CREATE REPLICATION</code>, or <code>ALTER REPLICATION</code> statements set the failure and recovery policies when using a <code>RETURN RECEIPT</code> or <code>RETURN TWOSAFE</code> service:</p>
<ul>
<li>
<p><code><a href="#CHDEJCHD">RETURN SERVICES {ON | OFF} WHEN [REPLICATION] STOPPED</a></code></p>
</li>
<li>
<p><code><a href="#CHDFGJBG">DISABLE RETURN</a></code></p>
</li>
<li>
<p><code><a href="#CHDIHAAG">RESUME RETURN</a></code></p>
</li>
<li>
<p><code><a href="#CHDIDJBE">DURABLE COMMIT</a></code></p>
</li>
<li>
<p><code><a href="#CHDEDGGB">LOCAL COMMIT ACTION</a></code></p>
</li>
</ul>
<p>The policies set by these attributes are applicable until changed. Except for <code><a href="#CHDIDJBE">DURABLE COMMIT</a></code>, the replication agent must be running to enforce these policies.</p>
<a id="CHDEJCHD"></a>
<div id="TTREP195" class="sect4">
<h5 class="sect4"><a id="sthref195"></a>RETURN SERVICES {ON | OFF} WHEN [REPLICATION] STOPPED</h5>
<p>The<a id="sthref196"></a><a id="sthref197"></a> <code>RETURN SERVICES {ON | OFF} WHEN [REPLICATION] STOPPED</code> attribute determines whether a return receipt or return twosafe service continues to be enabled or is disabled when replication is stopped.</p>
<ul>
<li>
<p>In an active standby pair, &#34;stopped&#34; means either the active replication agent is stopped (for example, by <code>ttAdmin</code> <code>-repStop</code> <code><span class="codeinlineitalic">active</span></code>) or the replication state of the standby database is set to <code>stop</code> or <code>pause</code> with respect to the active database (for example, by <code>ttRepAdmin</code> <code>-state stop</code> <code><span class="codeinlineitalic">standby</span></code>). A failed standby database that has exceeded the specified <a id="sthref198"></a><a id="sthref199"></a><code>FAILTHRESHOLD</code> v<a id="sthref200"></a>alue is set to the <code>failed</code> state, but is eventually set to the <code>stop</code> state by the replication agent on the active database.</p>
</li>
<li>
<p>In a classic replication scheme, &#34;stopped&#34; means either the master replication agent is stopped (for example, by <code>ttAdmin</code> <code>-repStop</code> <code><span class="codeinlineitalic">master</span></code>) or the replication state of the subscriber database is set to <code>stop</code> or <code>pause</code> with respect to the master database (for example, by <code>ttRepAdmin</code> <code>-state stop</code> <code><span class="codeinlineitalic">subscriber</span></code>). A failed subscriber that has exceeded the specified <a id="sthref201"></a><a id="sthref202"></a><code>FAILTHRESHOLD</code> value is set to the <code>failed</code> state, but is eventually set to the <code>stop</code> state by the master replication agent.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
A standby or subscriber database may become unavailable for a period of time that exceeds the timeout period specified by <code>RETURN WAIT TIME</code>, yet still be considered by the master replication agent to be in the <code>start</code> state. Failure policies related to timeouts are set by the <code><a href="#CHDFGJBG">DISABLE RETURN</a></code> attribute.</div>
<ul>
<li>
<p><code>RETURN SERVICES OFF WHEN REPLICATION STOPPED</code> disables the return service when replication is stopped and is the default when using the <code>RETURN RECEIPT</code> service.</p>
</li>
<li>
<p><code>RETURN SERVICES ON WHEN REPLICATION STOPPED</code> enables the return service to continue to be enabled when replication is stopped and is the default when using the <code>RETURN TWOSAFE</code> service.</p>
</li>
</ul>
<div id="TTREP766" class="example">
<p class="titleinexample"><a id="sthref203"></a>Example 4-14 RETURN SERVICES ON WHEN REPLICATION STOPPED for an active standby pair</p>
<p>The following example creates an active standby pair with <code>RETURN TWOSAFE</code> return service and defines that the return service is to be disabled when replication is stopped (which is opposite of the default).</p>
<pre>Command&gt; CREATE ACTIVE STANDBY PAIR 
 &gt; master1, 
 &gt; master2 
 &gt; RETURN TWOSAFE 
 &gt; STORE master2 RETURN SERVICES OFF WHEN REPLICATION STOPPED;
</pre>
<p>While the application is committing updates to the active database <code>master1</code>, <code>ttRepAdmin</code> is used to set the standby database <code>master2</code> to the <code>stop</code> state:</p>
<pre>ttRepAdmin -receiver -name master2 -state stop master1
</pre>
<p>The application continues to wait for return receipt acknowledgements from <code>master2</code> until the replication state is reset to <code>start</code> and it receives the acknowledgment:</p>
<pre>ttRepAdmin -receiver -name master2 -state start master1
</pre></div>
<!-- class="example" -->
<div id="TTREP796" class="example">
<p class="titleinexample"><a id="sthref204"></a>Example 4-15 RETURN SERVICES ON WHEN REPLICATION STOPPED for a classic replication scheme</p>
<p>Configure the <code>CREATE REPLICATION</code> statement to replicate updates from the <code>masterds</code> database to the <code>subscriber1</code> database. The <code>CREATE REPLICATION</code> statement specifies the use of <code><a href="#CHDFFDBE">RETURN RECEIPT</a></code> and <code>RETURN SERVICES ON WHEN REPLICATION STOPPED</code>.</p>
<pre>CREATE REPLICATION myscheme
 ELEMENT e TABLE tab
  MASTER masterds ON &#34;server1&#34;
  SUBSCRIBER subscriber1 ON &#34;server2&#34;
  RETURN RECEIPT
  STORE masterds ON &#34;server1&#34;
    RETURN SERVICES ON WHEN REPLICATION STOPPED;
</pre>
<p>While the application is committing updates to the master, <code>ttRepAdmin</code> is used to set <code>subscriber1</code> to the <code>stop</code> state:</p>
<pre>ttRepAdmin -receiver -name subscriber1 -state stop masterds
</pre>
<p>The application continues to wait for return receipt acknowledgements from <code>subscriber1</code> until the replication state is reset to <code>start</code> and it receives the acknowledgment:</p>
<pre>ttRepAdmin -receiver -name subscriber1 -state start masterds
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CHDFGJBG"></a>
<div id="TTREP196" class="sect4">
<h5 class="sect4"><a id="sthref205"></a>DISABLE <a id="sthref206"></a>RETURN</h5>
<p>When a <a id="sthref207"></a><code>DISABLE RETURN</code> value is set, the database keeps track of the number of return receipt or return twosafe transactions that have exceeded the timeout period set by <code>RETURN WAIT TIME</code>. If the number of timeouts exceeds the maximum value set by <code>DISABLE RETURN</code>, the application reverts to a default replication cycle in which it no longer waits for the standby or subscriber to acknowledge the replicated updates.</p>
<p>When return service blocking is disabled, the applications on the active or master database no longer block execution while waiting to receive acknowledgements from the standby or subscribers that they received or committed the replicated updates. Transactions are still replicated to the standby or subscriber, whether the return service is enabled or disabled. When the return service is disabled, the transactions are sent in asynchronous mode; the active or master database continues to listen for an acknowledgement of each batch of replicated updates from standby or subscriber databases.</p>
<p>Configure <code>DISABLE RETURN</code> as follows:</p>
<ul>
<li>
<p>For an active standby pair, specifying <code>SUBSCRIBER</code> is the same as specifying <code>ALL</code>. Both settings refer to the standby database.</p>
</li>
<li>
<p>For a classic replication scheme, you can set <code>DISABLE RETURN SUBSCRIBER</code> to establish a failure policy to disable return service blocking for only those subscribers that have timed out, or <code>DISABLE RETURN ALL</code> to establish a policy to disable return service blocking for all subscribers.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can use the <a id="sthref208"></a><code>ttRepSyncSubscriberStatus</code> built-in procedure or the <a id="sthref209"></a><code>ttRepReturnTransitionTrap</code> SNMP trap to determine whether the standby database or a particular subscriber has been disabled by the <code>DISABLE RETURN</code> failure policy.</div>
<p>The <code>DISABLE RETURN</code> failure policy is only enabled when the replication agent is running. If <code>DISABLE RETURN</code> is specified without <code>RESUME RETURN</code>, the return services remain off until the replication agent for the database has been restarted.</p>
<ul>
<li>
<p>For an active standby pair, you can cancel this failure policy by stopping the replication agent and specifying <code>DISABLE RETURN</code> with a zero value for <code><span class="codeinlineitalic">NumFailures</span></code>.</p>
</li>
<li>
<p>For a classic replication scheme, you can cancel this failure policy by stopping the replication agent and specifying either <code>DISABLE RETURN SUBSCRIBER</code> or <code>DISABLE RETURN ALL</code> with a zero value for <code><span class="codeinlineitalic">NumFailures</span></code>.</p>
<p><code>DISABLE RETURN</code> maintains a cumulative timeout count for each subscriber. If there are multiple subscribers and you set <code>DISABLE RETURN SUBSCRIBER</code>, the replication agent disables return service blocking for the first subscriber that reaches the timeout threshold. If one of the other subscribers later reaches the timeout threshold, the replication agent disables return service blocking for that subscriber also.</p>
</li>
</ul>
<p>The count of timeouts to trigger the failure policy is reset either when you restart the replication agent, when you set the <code>DISABLE RETURN</code> value to 0, or when return service blocking is re-enabled by <code><a href="#CHDIHAAG">RESUME RETURN</a></code>.</p>
<div id="TTREP767" class="example">
<p class="titleinexample"><a id="sthref210"></a>Example 4-16 DISABLE RETURN for an active standby pair</p>
<p>Configure the <code>CREATE ACTIVE STANDBY PAIR</code> statement to replicate updates from the active database <code>master1</code> to the standby database <code>master2</code>. The <code>CREATE ACTIVE STANDBY PAIR</code> statement specifies the use of <code><a href="#CHDFFDBE">RETURN RECEIPT</a></code> and <code>DISABLE RETURN ALL</code> with a <code><span class="codeinlineitalic">NumFailures</span></code> value of 5. The <code>RETURN WAIT TIME</code> is set to 30 seconds.</p>
<pre>CREATE ACTIVE STANDBY PAIR 
   master1, 
   master2 
   RETURN RECEIPT 
   STORE master1 
   DISABLE RETURN ALL 5
   RETURN WAIT TIME 30;
</pre>
<p>While the application is committing updates to the active database, the standby database (<code>master2</code>) experiences problems and fails to acknowledge a replicated transaction update. The application is blocked for 30 seconds after which it commits its next update to the active database <code>master1</code>. Over the course of the application session, this commit/timeout cycle repeats 4 more times until <code>DISABLE RETURN</code> disables return receipt blocking for <code>master2</code>.</p>
<p>For another example that sets the <code>DISABLE RETURN</code> attribute for an active standby pair, see <a href="#CHDIHCAF">Example 4-18</a>.</p>
</div>
<!-- class="example" -->
<div id="TTREP797" class="example">
<p class="titleinexample"><a id="sthref211"></a>Example 4-17 DISABLE RETURN SUBSCRIBER for a classic replication scheme</p>
<p>Configure the <code>CREATE REPLICATION</code> statement to replicate updates from the <code>masterds</code> master database to the subscriber databases: <code>subscriber1</code> and <code>subscriber2</code>. The <code>CREATE REPLICATION</code> statement specifies the use of <code><a href="#CHDFFDBE">RETURN RECEIPT</a></code> and <code>DISABLE RETURN SUBSCRIBER</code> with a <code><span class="codeinlineitalic">NumFailures</span></code> value of 5. The <code>RETURN WAIT TIME</code> is set to 30 seconds.</p>
<pre>CREATE REPLICATION myscheme
 ELEMENT e TABLE tab
   MASTER masterds ON &#34;server1&#34;
   SUBSCRIBER subscriber1 ON &#34;server2&#34;,
             subscriber2 ON &#34;server3&#34;
 RETURN RECEIPT
 STORE masterds ON &#34;server1&#34;
   DISABLE RETURN SUBSCRIBER 5
   RETURN WAIT TIME 30;
</pre>
<p>While the application is committing updates to the master, <code>subscriber1</code> experiences problems and fails to acknowledge a replicated transaction update. The application is blocked for 30 seconds after which it commits its next update to the master database <code>masterds</code>. Over the course of the application session, this commit/timeout cycle repeats 4 more times until <code>DISABLE RETURN</code> disables return receipt blocking for <code>subscriber1</code>. The application continues to wait for return-receipt acknowledgements from <code>subscriber2</code>, but not from <code>subscriber1</code>.</p>
<p>For another example that sets the <code>DISABLE RETURN</code> attribute for a classic replication scheme, see <a href="#BGBJAFJE">Example 4-19</a>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CHDIHAAG"></a>
<div id="TTREP197" class="sect4">
<h5 class="sect4"><a id="sthref212"></a>RESUME<a id="sthref213"></a> RETURN</h5>
<p>If <code>DISABLE RETURN</code> has disabled return service blocking, the <a id="sthref214"></a><code>RESUME RETURN</code> attribute sets the policy for re-enabling the return service. You can establish a return service recovery policy by setting the <a id="sthref215"></a><code>RESUME RETURN</code> attribute and specifying a resume latency value.</p>
<p>If return service blocking has been disabled for the standby or subscriber database and a latency time has been defined for <code>RESUME RETURN</code>, the following occurs:</p>
<ul>
<li>
<p>The applications on the active or master database no longer block execution while waiting to receive acknowledgements from the standby or subscribers. Transactions continue to be replicated to the standby or subscriber in asynchronous mode. The active or master databases continue to listen for an acknowledgement of each batch of replicated updates from standby or subscriber databases.</p>
</li>
<li>
<p>If the return service blocking is disabled, <code>RESUME RETURN</code> evaluates the commit-to-acknowledge time for the last transaction to see if the latency is less than the latency limit configured by the <code>RESUME RETURN</code>. If the commit-to-acknowledge time latency is less than the latency limit set by <code>RESUME RETURN</code>, TimesTen re-enables the return receipt or return twosafe services.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The commit-to-acknowledge time latency is the time elapsed between when the application issues a commit and when the active or master database receives acknowledgement from the standby or subscriber.
<p>TimesTen evaluates the latency of the last acknowledged transaction before the current transaction is replicated to the standby or subscriber. The return service is re-enabled before the sending of the current transaction after evaluating the latency from the last transaction.</p>
</div>
</li>
</ul>
<p>The <code>RESUME RETURN</code> policy is enabled only when the replication agent is running. You can cancel a return receipt resume policy by stopping the replication agent and then using <code>ALTER ACTIVE STANDBY PAIR</code> or <code>ALTER REPLICATION</code> statements to set <code>RESUME RETURN</code> to zero.</p>
<div id="TTREP768" class="example">
<p class="titleinexample"><a id="CHDIHCAF"></a>Example 4-18 RESUME RETURN for an active standby pair</p>
<p>If return receipt blocking has been disabled for <code>master2</code> and if <code>RESUME RETURN</code> is set to 8 milliseconds, then return receipt blocking is re-enabled for <code>master2</code> the instant the active receives an acknowledgement of the update from the standby, as long as the acknowledgement is received within the specified latency 8 milliseconds from when it was committed by the application on the active database.</p>
<pre>Command&gt; CREATE ACTIVE STANDBY PAIR 
 &gt; master1, 
 &gt; master2 
 &gt; RETURN RECEIPT
 &gt; STORE master1
 &gt; DISABLE RETURN ALL 5
 &gt; RESUME RETURN 8;
</pre></div>
<!-- class="example" -->
<div id="TTREP798" class="example">
<p class="titleinexample"><a id="BGBJAFJE"></a>Example 4-19 RESUME RETURN for a classic replication scheme</p>
<p>If return receipt blocking has been disabled for <code>subscriber1</code> and if <code>RESUME RETURN</code> is set to 8 milliseconds, then return receipt blocking is re-enabled for <code>subscriber1</code> the instant the master receives an acknowledgement of the update from the subscriber, as long as the acknowledgement is received within the specified latency 8 milliseconds from when it was committed by the application on the master database.</p>
<pre>CREATE REPLICATION myscheme
 ELEMENT e TABLE ttuser.tab
   MASTER masterds ON &#34;server1&#34;
   SUBSCRIBER subscriber1 ON &#34;server2&#34;,
             subscriber2 ON &#34;server3&#34;
 RETURN RECEIPT
 STORE masterds ON &#34;server1&#34;
   DISABLE RETURN SUBSCRIBER 5
   RESUME RETURN 8;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CHDIDJBE"></a>
<div id="TTREP198" class="sect4">
<h5 class="sect4">DURABLE <a id="sthref216"></a>COMMIT<a id="sthref217"></a><a id="sthref218"></a></h5>
<p>You can set the <code>DURABLE COMMIT</code> attribute to specify the durable commit policy for applications that have return service blocking disabled by <a id="sthref219"></a><code><a href="#CHDFGJBG">DISABLE RETURN</a></code>. When <code>DURABLE COMMIT</code> is set to <code>ON</code>, it overrides the <code>DurableCommits</code> general connection attribute on the active or master database and forces durable commits for those transactions that have had return service blocking disabled.</p>
<p>In addition, when <code>DURABLE COMMIT</code> is set to <code>ON</code>, durable commits are issued when return service blocking is disabled regardless of whether the replication agent is running or stopped. They are also issued when the <code>ttRepStateSave</code> built-in procedure has marked the standby or subscriber database as failed.</p>
<p>For a classic replication scheme, <code>DURABLE COMMIT</code> is useful if you have only one subscriber. However, if you are replicating the same data to two subscribers and you disable return service blocking to one subscriber, then you achieve better performance if you rely on the other subscriber than you would if you enable durable commits.</p>
<div id="TTREP769" class="example">
<p class="titleinexample"><a id="sthref220"></a>Example 4-20 DURABLE COMMIT ON with an active standby pair</p>
<p>Set <code>DURABLE COMMIT ON</code> when establishing a <code>DISABLE RETURN ALL</code> policy to disable return-receipt blocking for all subscribers. If return-receipt blocking is disabled, commits are durably committed to disk to provide redundancy.</p>
<pre>Command&gt; CREATE ACTIVE STANDBY PAIR 
 &gt; master1, 
 &gt; master2 
 &gt; RETURN RECEIPT
 &gt; STORE master1
 &gt; DISABLE RETURN ALL 5
 &gt; DURABLE COMMIT ON
 &gt; RESUME RETURN 8;
</pre></div>
<!-- class="example" -->
<div id="TTREP799" class="example">
<p class="titleinexample"><a id="sthref221"></a>Example 4-21 DURABLE COMMIT ON with a classic replication scheme</p>
<p>Set <code>DURABLE COMMIT ON</code> when establishing a <code>DISABLE RETURN ALL</code> policy to disable return-receipt blocking for all subscribers. If return-receipt blocking is disabled, commits are durably committed to disk to provide redundancy.</p>
<pre>CREATE REPLICATION myscheme
 ELEMENT e TABLE tab
   MASTER masterds ON &#34;server1&#34;
   SUBSCRIBER subscriber ON &#34;server2&#34;,
             subscriber2 ON &#34;server3&#34;
 RETURN RECEIPT
STORE masterds ON &#34;server1&#34;
   DISABLE RETURN ALL 5
   DURABLE COMMIT ON
   RESUME RETURN 8;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CHDEDGGB"></a>
<div id="TTREP199" class="sect4">
<h5 class="sect4"><a id="sthref222"></a>LOCAL COMMIT <a id="sthref223"></a>ACTION</h5>
<p>When you are using the return twosafe service, you can specify how the active or master replication agent responds to timeouts by setting <code>LOCAL COMMIT ACTION</code>. You can override this setting for specific transactions with the <code>localAction</code> parameter of the <a id="sthref224"></a><code>ttRepSyncSet</code> <a id="sthref225"></a>built-in procedure.</p>
<p>The possible actions upon receiving a timeout during replication of a twosafe transaction are:</p>
<ul>
<li>
<p><code>COMMIT</code> - On timeout, the commit function attempts to perform a commit to end the transaction locally. No more operations are possible on the same transaction.</p>
</li>
<li>
<p><code>NO ACTION</code> - On timeout, the commit function returns to the application, leaving the transaction in the same state it was in when it entered the commit call, with the exception that the application is not able to update any replicated tables. The application can reissue the commit. This is the default.</p>
</li>
</ul>
<p>If the call returns with an error, you can use the <a id="sthref226"></a><code>ttRepXactStatus</code><a id="sthref227"></a> procedure described in <a href="monitor.htm#CFAJDGFG">&#34;Check the status of return service transactions&#34;</a> to check the status of the transaction. Depending on the error, your application can choose to:</p>
<ul>
<li>
<p>Reissue the commit call - This repeats the entire return twosafe replication cycle, so that the commit call returns when the success or failure of the replicated commit on the subscriber is known or if the timeout period expires.</p>
</li>
<li>
<p>Roll back the transaction - If the call returns with an error related to applying the transaction on the standby or subscriber, such as primary key lookup failure, you can roll back the transaction on the active or master database.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDFABDJ"></a>
<div id="TTREP770" class="sect2">
<h3 class="sect2">Column definition options for replicated tables<a id="sthref228"></a><a id="sthref229"></a><a id="sthref230"></a><a id="sthref231"></a><a id="sthref232"></a><a id="sthref233"></a><a id="sthref234"></a><a id="sthref235"></a></h3>
<p>The definition for the columns of replicated tables participating in the replication scheme do not necessarily need to be identical.</p>
<ul>
<li>
<p>If the <code>TABLE DEFINITION CHECKING</code> value is set to <code>EXACT</code>, the column definitions must be identical on the active and standby databases. This attribute enables replication of tables that are identical in their physical structure.</p>
</li>
<li>
<p>If the <code>TABLE DEFINITION CHECKING</code> value is set to <code><a id="sthref236"></a><a id="sthref237"></a><a id="sthref238"></a>RELAXED</code> (the default), the column definitions of the replicated tables do not need to be identical. When using <code>RELAXED</code>, the replicated tables must have the same key definition, number of columns, column names, and column data types.</p>
<p>Table definition checking occurs on the standby database. Setting this attribute to <code>RELAXED</code> for both active and standby databases has the same effect as setting it for only the standby database.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more details on <code>TABLE DEFINITION CHECKING</code>, see <a class="olink TTSQL289" href="../TTSQL/state.htm#TTSQL289">&#34;CREATE ACTIVE STANDBY PAIR&#34;</a> or <a class="olink TTSQL298" href="../TTSQL/state.htm#TTSQL298">&#34;CREATE REPLICATION&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</div>
<p>The <code>TABLE DEFINITION CHECKING RELAXED</code> attribute does not require that the physical structure of the table be identical on both master databases. For example, if tables have columns in a different order or have a different number of partitions, the data can still be replicated when using the <code>RELAXED</code> attribute. Thus, if you are altering your table by adding or dropping columns, you should use the <code>RELAXED</code> attribute. As noted in <a class="olink TTSQL286" href="../TTSQL/state.htm#TTSQL286">&#34;ALTER TABLE&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>, adding columns when altering a table creates additional partitions. Dropping columns does not automatically free up the space. We recommend that any DML statement that alters the table should be executed on the master and then replicated to any standby database and subscribers.</p>
<p>The <code>RELAXED</code> setting can result in slightly slower performance if it is compensating for a different physical structure. If the tables are identical in physical structure, then there is no performance impact. You can eliminate any performance issues (caused by a different physical structure, additional partitions, or extraneous space) by using the <code>ttMigrate -r -relaxedUpgrade</code> (only valid on databases where the table definition checking is set to <code>RELAXED</code>) to coalesce all additional partitions of a table into a single partition and eliminate extraneous space caused by dropped columns. If you perform this on all databases involved in the replication scheme, the resulting physical structure is identical resulting in the best performance potential.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
See <a href="#CHDIHCAF">Example 4-18</a> and <a class="olink TTTRB196" href="../TTTRB/datastore_trouble.htm#TTTRB196">&#34;Check partition counts for the tables&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Troubleshooting Guide</span> for information on how to check the partitions in use for each table.
<p>For performance considerations of both the <code>EXACT</code> and <code>RELAXED</code> attributes for <code>TABLE DEFINITION CHECKING</code>, see <a href="perform.htm#CFHFIGDA">&#34;Performance considerations when altering tables that are replicated&#34;</a>.</p>
</div>
<p>To ensure that table definition checking is set to <code>RELAXED</code>, stop the replication agent on the active or master database and then execute an <code>ALTER ACTIVE STANDBY PAIR</code> or <code>ALTER REPLICATION</code> statement to set the table definition checking to <code>RELAXED</code>. Finally, use the <code>ttRepAdmin -duplicate</code> command to roll out these changes to the standby database and any subscribers. For more information, see <a class="olink TTSQL279" href="../TTSQL/state.htm#TTSQL279">&#34;ALTER ACTIVE STANDBY PAIR&#34;</a> and <a class="olink TTSQL284" href="../TTSQL/state.htm#TTSQL284">&#34;ALTER REPLICATION&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>The following sections provide examples for setting the table definition checking to relaxed:</p>
<ul>
<li>
<p><a href="#BGBGCFHD">Examples for an active standby pair replicating tables with table definition checking set to relaxed</a></p>
</li>
<li>
<p><a href="#BGBGCDJG">Examples for classic replication scheme with table definition checking set to relaxed</a></p>
</li>
</ul>
<a id="BGBGCFHD"></a>
<div id="TTREP800" class="sect3">
<h4 class="sect3">Examples for an active standby pair replicating tables with table definition checking set to relaxed</h4>
<p>The following examples demonstrate the effect of setting the <code>TABLE DEFINITION CHECKING</code> attribute to either <code>EXACT</code> or <code>RELAXED</code> in an active standby pair replication scheme.</p>
<div id="TTREP771" class="example">
<p class="titleinexample"><a id="BGBEBDFB"></a>Example 4-22 Replicating tables that are identical in an active standby pair</p>
<p>Create table <code>t1</code> in <code>master1</code> database:</p>
<pre>CREATE TABLE t1 (a INT PRIMARY KEY, b INT, c INT);
</pre>
<p>Create an active standby pair replication scheme. Set <code>TABLE DEFINITION CHECKING</code> to <code>EXACT</code> for the <code>master2</code> standby database.</p>
<pre>Command&gt; CREATE ACTIVE STANDBY PAIR master1, master2
       &gt; STORE master2 TABLE DEFINITION CHECKING EXACT;
</pre>
<p>Perform the rest of the steps to duplicate the active database to the standby database, start the replication agents on both databases, and set the state of the active database (as described in <a href="gettingstarted.htm#CHDCBIHE">Chapter 2, &#34;Getting Started&#34;</a>.</p>
<p>Insert a row into <code>t1</code> on <code>master1</code>.</p>
<pre>Command&gt; INSERT INTO t1 VALUES (4,5,6);
1 row inserted.
</pre>
<p>Verify the results on <code>t1</code> on <code>master2</code>.</p>
<pre>Command&gt; SELECT * FROM t1;
&lt; 4, 5, 6&gt;
1 row found.
</pre></div>
<!-- class="example" -->
<div id="TTREP773" class="example">
<p class="titleinexample"><a id="sthref239"></a>Example 4-23 Altering the table definition checking to relaxed in an active standby pair</p>
<p>You can alter the table definition checking for the active standby pair replication scheme to be relaxed. First, stop the replication agent on the active database before altering the active database. The following alters the <code>dsn1</code> active database so the table definition checking is set to relaxed:</p>
<pre>ALTER ACTIVE STANDBY PAIR
  ALTER STORE master1 SET TABLE DEFINITION CHECKING RELAXED;
</pre>
<p>After execution completes, use duplicate to roll out the changes to the standby database. Lastly, use duplicate to roll out the changes to any subscribers.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BGBGCDJG"></a>
<div id="TTREP801" class="sect3">
<h4 class="sect3">Examples for classic replication scheme with table definition checking set to relaxed</h4>
<p>The following examples demonstrate the effect of setting the <code>TABLE DEFINITION CHECKING</code> attribute to either <code>EXACT</code> or <code>RELAXED</code> in a classic replication scheme.</p>
<div id="TTREP802" class="example">
<p class="titleinexample"><a id="sthref240"></a>Example 4-24 Replicating tables that are identical in a classic replication scheme</p>
<p>Create table <code>t1</code> in <code>dsn1</code> database:</p>
<pre>CREATE TABLE ttuser.t1 (a INT PRIMARY KEY, b INT, c INT);
</pre>
<p>Create <code>ttuser.t1</code> table in the <code>dsn2</code> database exactly the same as in the <code>dsn1</code> database.</p>
<p>Create replication scheme <code>ttuser.rep1</code>. Set <code>TABLE DEFINITION CHECKING</code> to <code>EXACT</code> for the subscriber, <code>dsn2</code>.</p>
<pre>CREATE REPLICATION ttuser.rep1
       ELEMENT e1 TABLE ttuser.t1
       MASTER dsn1
       SUBSCRIBER dsn2
       STORE dsn2 TABLE DEFINITION CHECKING EXACT;
</pre>
<p>Start the replication agent for both databases. Insert a row into <code>ttuser.t1</code> on <code>dsn1</code>.</p>
<pre>Command&gt; INSERT INTO ttuser.t1 VALUES (4,5,6);
1 row inserted.
</pre>
<p>Verify the results on <code>ttuser.t1</code> on <code>dsn2</code>.</p>
<pre>Command&gt; SELECT * FROM ttuser.t1;
&lt; 4, 5, 6&gt;
1 row found.
</pre></div>
<!-- class="example" -->
<div id="TTREP803" class="example">
<p class="titleinexample"><a id="sthref241"></a>Example 4-25 Replicating tables with columns in different positions in a classic replication scheme</p>
<p>Create table <code>t1</code> in <code>dsn1</code> database:</p>
<pre>CREATE TABLE ttuser.t1 (a INT PRIMARY KEY, b INT, c INT);
</pre>
<p>Create table <code>ttuser.t1</code> in <code>dsn2</code> database with the columns in a different order than the columns in <code>ttuser.t1</code> in <code>dsn1</code> database. Note that the column names and data types are the same in both tables and <code>a</code> is the primary key in both tables.</p>
<pre>CREATE TABLE ttuser.t1 (c INT, a INT PRIMARY KEY, b INT);
</pre>
<p>Create replication scheme <code>ttuser.rep1</code>. Set <code>TABLE DEFINITION CHECKING</code> to <code>RELAXED</code> for the subscriber, <code>dsn2</code>.</p>
<pre>CREATE REPLICATION ttuser.rep1
       ELEMENT e1 TABLE ttuser.t1
       MASTER dsn1
       SUBSCRIBER dsn2
       STORE dsn2 TABLE DEFINITION CHECKING RELAXED;
</pre>
<p>Start the replication agent for both databases. Insert a row into <code>ttuser.t1</code> on <code>dsn1</code>.</p>
<pre>Command&gt; INSERT INTO ttuser.t1 VALUES (4,5,6);
1 row inserted.
</pre>
<p>Verify the results on <code>ttuser.t1</code> on <code>dsn2</code>.</p>
<pre>Command&gt; SELECT * FROM ttuser.t1;
&lt; 5, 6, 4 &gt;
1 row found.
</pre></div>
<!-- class="example" -->
<div id="TTREP804" class="example">
<p class="titleinexample"><a id="sthref242"></a>Example 4-26 Replicating tables with a different number of partitions in a classic replication scheme</p>
<p>When you alter a table to add columns, it increases the number of partitions in the table, even if you subsequently drop the new columns. You can use the <code>RELAXED</code> setting for <code>TABLE DEFINITION CHECKING</code> to replicate tables that have different number of partitions.</p>
<p>Create table <code>ttuser.t3</code> on <code>dsn1</code> with two columns.</p>
<pre>CREATE TABLE ttuser.t3 (a INT PRIMARY KEY, b INT);
</pre>
<p>Create table <code>ttuser.t3</code> on <code>dsn2</code> with one column that is the primary key.</p>
<pre>CREATE TABLE ttuser.t3 (a INT PRIMARY KEY);
</pre>
<p>Add a column to the table on <code>dsn2</code>. This increases the number of partitions to two, while the table on <code>dsn1</code> has one partition.</p>
<pre>ALTER TABLE ttuser.t3 ADD COLUMN b INT;
</pre>
<p>Create the replication scheme on both databases.</p>
<pre>CREATE REPLICATION reppart
       ELEMENT e2 TABLE ttuser.t3
       MASTER dsn1
       SUBSCRIBER dsn2
       STORE dsn2 TABLE DEFINITION CHECKING RELAXED;
</pre>
<p>Start the replication agent for both databases. Insert a row into <code>ttuser.t3</code> on <code>dsn1</code>.</p>
<pre>Command&gt; INSERT INTO ttuser.t3 VALUES (1,2);
1 row inserted.
</pre>
<p>Verify the results in <code>ttuser.t3</code> on <code>dsn2</code>.</p>
<pre>Command&gt; SELECT * FROM ttuser.t3;
&lt; 1, 2 &gt;
1 row found.
</pre></div>
<!-- class="example" -->
<div id="TTREP805" class="example">
<p class="titleinexample"><a id="sthref243"></a>Example 4-27 Altering the table definition checking to relaxed in a classic replication scheme</p>
<p>You can alter the table definition checking for a classic replication scheme to be relaxed. First, stop the replication agent on the master database before altering the replication scheme on it. The following alters the <code>dsn1</code> master database so the table definition checking is set to relaxed:</p>
<pre>ALTER REPLICATION reppart
  ALTER STORE dsn1 SET TABLE DEFINITION CHECKING RELAXED;
</pre>
<p>After execution completes, use duplicate to roll out the changes to the standby master. Lastly, use duplicate to roll out the changes to any subscribers.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBEDCC"></a>
<div id="TTREP200" class="sect2">
<h3 class="sect2">Compressing replicated <a id="sthref244"></a>traffic<a id="sthref245"></a></h3>
<p>If you are replicating over a low-bandwidth network, or if you are replicating massive amounts of data, you can set the <code>COMPRESS TRAFFIC</code> attribute to reduce the amount of bandwidth required for replication. The <code>COMPRESS TRAFFIC</code> attribute compresses the replicated data from the database specified by the <code>STORE</code> parameter in the <code>CREATE ACTIVE STANDBY PAIR</code>, <code>ALTER ACTIVE STANDBY PAIR</code>, <code>CREATE REPLICATION</code> or <code>ALTER REPLICATION</code> statements. TimesTen does not compress traffic from other databases.</p>
<p>Though the compression algorithm is optimized for speed, enabling the <code>COMPRESS TRAFFIC</code> attribute affects replication throughput and latency.</p>
<div id="TTREP201" class="example">
<p class="titleinexample"><a id="sthref246"></a>Example 4-28 Compressing traffic from an active database in an active standby pair</p>
<p>For example, to compress replicated traffic from active database <code>dsn1</code> and leave the replicated traffic from standby database <code>dsn2</code> uncompressed, the <code>CREATE ACTIVE STANDBY PAIR</code> statement looks like:</p>
<pre>CREATE ACTIVE STANDBY PAIR dsn1 ON &#34;host1&#34;, dsn2 ON &#34;host2&#34;
  SUBSCRIBER dsn3 ON &#34;host3&#34;
  STORE dsn1 ON &#34;host1&#34; COMPRESS TRAFFIC ON;
</pre></div>
<!-- class="example" -->
<div id="TTREP202" class="example">
<p class="titleinexample"><a id="sthref247"></a>Example 4-29 Compressing traffic from both active and standby databases</p>
<p>To compress the replicated traffic from the <code>dsn1</code> and <code>dsn2</code> databases, use:</p>
<pre>CREATE ACTIVE STANDBY PAIR dsn1 ON &#34;host1&#34;, dsn2 ON &#34;host2&#34;
   SUBSCRIBER dsn3 ON &#34;host3&#34;
 STORE dsn1 ON &#34;host1&#34; COMPRESS TRAFFIC ON
 STORE dsn2 ON &#34;host2&#34; COMPRESS TRAFFIC ON;
</pre></div>
<!-- class="example" -->
<div id="TTREP806" class="example">
<p class="titleinexample"><a id="sthref248"></a>Example 4-30 Compressing traffic from one database in a classic replication scheme</p>
<p>To compress replicated traffic from database <code>dsn1</code> and leave the replicated traffic from <code>dsn2</code> uncompressed, the <code>CREATE REPLICATION</code> statement looks like:</p>
<pre>CREATE REPLICATION repscheme
 ELEMENT d1 DATASTORE
    MASTER dsn1 ON host1
    SUBSCRIBER dsn2 ON host2
 ELEMENT d2 DATASTORE
    MASTER dsn2 ON host2
    SUBSCRIBER dsn1 ON host1
 STORE dsn1 ON host1 COMPRESS TRAFFIC ON;
</pre></div>
<!-- class="example" -->
<div id="TTREP807" class="example">
<p class="titleinexample"><a id="sthref249"></a>Example 4-31 Compressing traffic between both databases in a classic replication scheme</p>
<p>To compress the replicated traffic between both the <code>dsn1</code> and <code>dsn2</code> databases, use:</p>
<pre>CREATE REPLICATION scheme
 ELEMENT d1 DATASTORE
    MASTER dsn1 ON host1
    SUBSCRIBER dsn2 ON host2
 ELEMENT d2 DATASTORE
    MASTER dsn2 ON host2
    SUBSCRIBER dsn1 ON host1
 STORE dsn1 ON host1 COMPRESS TRAFFIC ON
 STORE dsn2 ON host2 COMPRESS TRAFFIC ON;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDFGAEC"></a>
<div id="TTREP203" class="sect2">
<h3 class="sect2">Port assignmen<a id="sthref250"></a><a id="sthref251"></a><a id="sthref252"></a><a id="sthref253"></a>ts</h3>
<p>The <code>PORT</code> parameter for the <code>STORE</code> attribute of the <code>CREATE ACTIVE STANDBY PAIR</code> and <code>CREATE REPLICATION</code> statements set the port number used by a database to listen for updates from another database.</p>
<ul>
<li>
<p>In an active standby pair, the standby database listens for updates from the active database. Read-only subscribers listen for updates from the standby database.</p>
</li>
<li>
<p>In a classic replication scheme, the subscribers listen for updates from the master database. Setting the <code>PORT</code> attribute for one classic replication scheme sets it for all classic replication schemes.</p>
</li>
</ul>
<p>Static port assignments are recommended. If no <a id="sthref254"></a><code>PORT</code> attribute is specified, the TimesTen daemon dynamically selects the port. When ports are assigned dynamically for the replication agents, then the ports of the TimesTen daemons have to match as well.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must assign static ports if you want to do online upgrades.</div>
<p>When statically assigning ports, it is important to specify the full host name, DSN and port in the <code>STORE</code> attribute.</p>
<div id="TTREP204" class="example">
<p class="titleinexample"><a id="sthref255"></a>Example 4-32 Assigning static ports for an active standby pair</p>
<pre>CREATE ACTIVE STANDBY PAIR dsn1 ON &#34;host1&#34;, dsn2 ON &#34;host2&#34;
   SUBSCRIBER dsn3 ON &#34;host3&#34;
 STORE dsn1 ON &#34;host1&#34; PORT 16080
 STORE dsn2 ON &#34;host2&#34; PORT 16083
 STORE dsn3 ON &#34;host3&#34; PORT 16084;
</pre></div>
<!-- class="example" -->
<div id="TTREP808" class="example">
<p class="titleinexample"><a id="sthref256"></a>Example 4-33 Assigning static ports for a classic replication scheme</p>
<pre>CREATE REPLICATION repscheme
 ELEMENT el1 TABLE ttuser.tab
    MASTER dsn1 ON host1
    SUBSCRIBER dsn2 ON host2
 ELEMENT el2 TABLE ttuser.tab
    MASTER dsn2 ON host2
    SUBSCRIBER dsn1 ON host1
 STORE dsn1 ON host1 PORT 16080
 STORE dsn2 ON host2 PORT 16083;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BGBJIIAD"></a>
<div id="TTREP820" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Setting wait timeout for response from remote replication agents</h3>
<p>The <code>TIMEOUT</code> store attribute sets the maximum number of seconds that the replication agent waits for a response from any remote replication agents.</p>
<p>We recommend that the default timeout (120 seconds) is used if you have any large transactions. The replication agent scales the timeout based on the size of the transaction in order to accommodate any large transactions that could potentially cause a delayed response from the remote replication agent. Automatic scaling by the replication agent is disabled if the user sets the <code>TIMEOUT</code> to less than or equal to 60 seconds.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you experience repeated timeouts and the error log shows that multiple transmitter and receiver threads restart, then the transaction may be larger than can be scaled by the replication agent with the current timeout value. Continue to increase the timeout value until replication can progress for the transaction.</div>
<p>The following example creates an active standby pair whose master databases are <code>rep1</code> and <code>rep2</code>. There is one subscriber, <code>rep3</code>. The type of replication is <code>RETURN RECEIPT</code>. The statement also sets <code>PORT</code> and <code>TIMEOUT</code> attributes for the master databases. The <code>TIMEOUT</code> attribute is set to 80 seconds for both the active and standby masters.</p>
<pre>CREATE ACTIVE STANDBY PAIR rep1, rep2 RETURN RECEIPT 
   SUBSCRIBER rep3
 STORE rep1 PORT 21000 TIMEOUT 80
 STORE rep2 PORT 22000 TIMEOUT 80;
</pre></div>
<!-- class="sect2" -->
<a id="CHDBACFH"></a>
<div id="TTREP205" class="sect2">
<h3 class="sect2">Setting the transaction l<a id="sthref257"></a>og failure <a id="sthref258"></a>threshold<a id="sthref259"></a><a id="sthref260"></a></h3>
<p>You <a id="sthref261"></a>can establish a threshold value that, when exceeded, sets an unavailable database to the <code>failed</code> state before the available transaction log space is exhausted, as follows:</p>
<ul>
<li>
<p>In an active standby pair, if the transaction log threshold is exceeded, sets an unavailable standby database or a read-only subscriber to the <code>failed</code> state before the available transaction log space is exhausted. Set the transaction log threshold by specifying the <code>STORE</code> clause with a <a id="sthref262"></a><code>FAILTHRESHOLD</code> value in the <code>CREATE ACTIVE STANDBY PAIR</code> or <code>ALTER ACTIVE STANDBY PAIR</code> statements.</p>
<p>If an active database sets the standby or read-only subscriber database to the <code>failed</code> state, it drops all of the data for the failed database from its transaction log and transmits a message to the failed database. If the active replication agent can communicate with the replication agent of the failed database, then the message is transmitted immediately. Otherwise, the message is transmitted when the connection is reestablished.</p>
</li>
<li>
<p>In a classic replication scheme, if the transaction log threshold is exceeded, sets an unavailable subscriber to the <code>failed</code> state before the available transaction log space is exhausted. Set the transaction log threshold by specifying the <code>STORE</code> clause with a <a id="sthref263"></a><code>FAILTHRESHOLD</code> value in the <code>CREATE REPLICATION</code> or <code>ALTER REPLICATION</code> statements. For an example, see <a href="design.htm#CHDDHFIC">Example 9-5</a>.</p>
<p>If a master database sets the subscriber database to the <code>failed</code> state, it drops all of the data for the failed subscriber from its transaction log and transmits a message to the failed subscriber database. If the master replication agent can communicate with the subscriber replication agent, then the message is transmitted immediately. Otherwise, the message is transmitted when the connection is reestablished.</p>
<p>However, after receiving the message from the master, if the subscriber is configured for bidirectional replication or to propagate updates to other subscribers, it does not transmit any further updates, because its replication state has been compromised.</p>
</li>
</ul>
<p>The default threshold value is 0, which means &#34;no limit.&#34; See <a href="setup.htm#CEGGAFHB">&#34;Setting connection attributes for logging&#34;</a> for details about transaction log failure threshold values.</p>
<p><a id="sthref264"></a><a id="sthref265"></a>Any application that connects to the failed database receives a <code>tt_ErrReplicationInvalid</code> (8025) warning indicating that the database has been marked <code>failed</code> by a replication peer. Once the database has been informed of its failed status, its state on the active or master database is changed from <code>failed</code> to <code>stop</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information about database states, see <a href="setup.htm#BABIDAHI">Table 11-1, &#34;Database states&#34;</a> .</div>
<p>An application can use the ODBC <a id="sthref266"></a><code>SQLGetInfo</code> function to check if the database the application is connected to has been set to the <code>failed</code> state, as described in <a href="failure.htm#CACHAEAJ">&#34;Subscriber failures&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CACHCIII"></a>
<div id="TTREP775" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Suspending or resuming classic replication in response to conflicts</h3>
<p>With classic replication, you can specify the number of replication conflicts per second at the table level at which conflict reporting is suspended and the number of conflicts per second at which conflict reporting resumes with the <a id="sthref267"></a><code>CONFLICT REPORTING SUSPEND</code> and <a id="sthref268"></a><code>CONFLICT REPORTING RESUME</code> attributes. For a full description, see <a href="conflict.htm#BABGABJH">Chapter 13, &#34;Resolving Replication Conflicts&#34;</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGDGAAD"></a>
<div id="TTREP401" class="sect1">
<h2 class="sect1">Configuring the network<a id="sthref269"></a><a id="sthref270"></a><a id="sthref271"></a><a id="sthref272"></a><a id="sthref273"></a><a id="sthref274"></a><a id="sthref275"></a><a id="sthref276"></a></h2>
<p>The following sections describe some of the issues to consider when replicating TimesTen data over a network.</p>
<ul>
<li>
<p><a href="#CEGCJHEF">Network bandwidth requirements</a></p>
</li>
<li>
<p><a href="#CEGDEFGJ">Replication in a WAN environment</a></p>
</li>
<li>
<p><a href="#CHDBICJF">Configuring network interfaces with the ROUTE clause</a></p>
</li>
<li>
<p><a href="#CEGIDDGE">Configuring network interfaces when not using the ROUTE clause</a></p>
</li>
<li>
<p><a href="#CEGDEGBI">Identifying the local host of a replicated database</a></p>
</li>
</ul>
<a id="CEGCJHEF"></a>
<div id="TTREP402" class="sect2">
<h3 class="sect2">Network bandwidth requirements</h3>
<p>The network bandwidth required for TimesTen replication depends on the bulk and frequency of the data being replicated. This discussion explores the types of transactions that characterize the high and low ends of the data range and the network bandwidth required to replicate the data between TimesTen databases.</p>
<p><a href="#BABBCAIC">Table 4-1</a> provides guidelines for calculating the size of replicated records.</p>
<div id="TTREP736" class="tblhruleformal">
<p class="titleintable"><a id="sthref277"></a><a id="BABBCAIC"></a>Table 4-1 Replicated record sizes</p>
<table class="cellalignment5810" title="Replicated record sizes" summary="This table provides guidelines for calculating the size of replicated records." dir="ltr">
<thead>
<tr class="cellalignment5804">
<th class="cellalignment5811" id="r1c1-t19">Record Type</th>
<th class="cellalignment5811" id="r1c2-t19">Size</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5804">
<td class="cellalignment5812" id="r2c1-t19" headers="r1c1-t19">
<p>Begin transaction</p>
</td>
<td class="cellalignment5812" headers="r2c1-t19 r1c2-t19">
<p>48 bytes</p>
</td>
</tr>
<tr class="cellalignment5804">
<td class="cellalignment5812" id="r3c1-t19" headers="r1c1-t19">
<p>Update</p>
</td>
<td class="cellalignment5812" headers="r3c1-t19 r1c2-t19">
<p>116 bytes</p>
<p>+ 18 bytes per column updated</p>
<p>+ size of old column values</p>
<p>+ size of new column values</p>
<p>+ size of the primary key or unique key</p>
</td>
</tr>
<tr class="cellalignment5804">
<td class="cellalignment5812" id="r4c1-t19" headers="r1c1-t19">
<p>Delete</p>
</td>
<td class="cellalignment5812" headers="r4c1-t19 r1c2-t19">
<p>104 bytes</p>
<p>+ size of the primary key or unique key</p>
</td>
</tr>
<tr class="cellalignment5804">
<td class="cellalignment5812" id="r5c1-t19" headers="r1c1-t19">
<p>Insert</p>
</td>
<td class="cellalignment5812" headers="r5c1-t19 r1c2-t19">
<p>104 bytes</p>
<p>+ size of the primary key or unique key</p>
<p>+ size of inserted row</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p>Transactions are sent between replicated databases in batches. A batch is created whenever there is no more data in the transaction log buffer in the master database, or when the current batch is roughly 256 KB. See <a href="overview.htm#CJAFADFC">&#34;Copying updates between databases&#34;</a> for more information.</p>
</div>
<!-- class="sect2" -->
<a id="CEGDEFGJ"></a>
<div id="TTREP403" class="sect2">
<h3 class="sect2">Replication in a <a id="sthref278"></a><a id="sthref279"></a><a id="sthref280"></a>WAN environment</h3>
<p>TimesTen replication uses the TCP/IP protocol, which is not optimized for a WAN environment. You can improve replication performance over a WAN by installing a third-party &#34;TCP stack&#34; product. If replacing the TCP stack is not a feasible solution, you can reduce the amount of network traffic that the TCP/IP protocol has to deal with by setting the <code>COMPRESS TRAFFIC</code> attribute in the <code>CREATE ACTIVE STANDBY PAIR</code> or <code>CREATE REPLICATION</code> statement. See <a href="#CHDBEDCC">&#34;Compressing replicated traffic&#34;</a> for details.</p>
<p>See installation information for either the AIX or Linux platforms in <a class="olink TTINS133" href="../TTINS/install.htm#TTINS133">&#34;AIX prerequisites&#34;</a> or <a class="olink TTINS139" href="../TTINS/install.htm#TTINS139">&#34;Linux prerequisites&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Installation Guide</span> for information about changing TCP/IP kernel parameters for better performance.</p>
</div>
<!-- class="sect2" -->
<a id="CHDBICJF"></a>
<div id="TTREP206" class="sect2">
<h3 class="sect2">Configuring network <a id="sthref281"></a>interfaces with the ROUTE clause<a id="sthref282"></a><a id="sthref283"></a><a id="sthref284"></a></h3>
<p>In a replication scheme, you need to identify the name of the host on which your database resides. The operating system translates this host name to one or more IP addresses.</p>
<p>When specifying the host for a database in a replication element, you should always use the name returned by the <code>hostname</code> command, as replication uses the same host name to verify that the current host is involved in the replication scheme. Replication schemes may not be created that do not include the current host.</p>
<p>While you must specify the host name returned by the operating system&#39;s <code>hostname</code> command when you specify the database name, you can configure replication to send or receive traffic over a different interface (other than the default) using the <code>ROUTE</code> clause.</p>
<p>If a host contains multiple network interfaces (with different IP addresses), you should specify which interfaces are to be used by replication using the <code>ROUTE</code> clause, unless you want replication to use the default interface. You must specify a priority for each interface. Replication tries to first connect using the address with the highest priority, and if a connection cannot be established, it tries the remaining addresses in order of priority until a connection is established. If a connection to a host fails while using one IP address, replication attempts to re-connect (or fall back) to another IP address, if more than one address has been specified in the <code>ROUTE</code> clause.</p>
<p>The syntax of the <code>ROUTE</code> clause is:</p>
<pre>ROUTE MASTER <span class="italic">FullDatabaseName</span> SUBSCRIBER <span class="italic">FullDatabaseName</span>
  {{MASTERIP <span class="italic">MasterHost</span> | SUBSCRIBERIP <span class="italic">SubscriberHost</span>}
    PRIORITY <span class="italic">Priority</span>} [...]
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Addresses for the <code>ROUTE</code> clause may be specified as either host names or IP addresses. However, if your host has more than one IP address configured for a given host name, you should only configure the <code>ROUTE</code> clause using the IP addresses, in order to ensure that replication uses only the IP addresses that you intend.</div>
<ul>
<li>
<p>When using the <code>ROUTE</code> clause in an active standby pair, each master database is a subscriber of the other master database and each read-only subscriber is a subscriber of both master databases. This means that the <code>CREATE ACTIVE STANDBY PAIR</code> statement should include <code>ROUTE</code> clauses in multiples of two to specify a route in both directions.</p>
</li>
<li>
<p>When using the <code>ROUTE</code> clause in a classic replication scheme that defines dual masters, each master database is a subscriber of the other master database. This means that the <code>CREATE REPLICATION</code> statement should include <code>ROUTE</code> clauses in multiples of two to specify a route in both directions.</p>
</li>
</ul>
<div id="TTREP207" class="example">
<p class="titleinexample"><a id="BABCDHBC"></a>Example 4-34 Configuring multiple network interfaces for an active standby pair</p>
<p>If <code>host1</code> host is configured with a second interface accessible by the <code>host1fast</code> host name, and <code>host2</code> is configured with a second interface at IP address <code>192.168.1.100</code>, you may specify that the secondary interfaces are used with the replication scheme.</p>
<pre>CREATE ACTIVE STANDBY PAIR dns1, dsn2
 ROUTE MASTER dsn1 ON &#34;host1&#34; SUBSCRIBER dsn2 ON &#34;host2&#34;
    MASTERIP &#34;host1fast&#34; PRIORITY 1
    SUBSCRIBERIP &#34;192.168.1.100&#34; PRIORITY 1
 ROUTE MASTER dsn2 ON &#34;host2&#34; SUBSCRIBER dsn1 ON &#34;host1&#34;
    MASTERIP &#34;192.168.1.100&#34; PRIORITY 1
    SUBSCRIBERIP &#34;host1fast&#34; PRIORITY 1;
</pre></div>
<!-- class="example" -->
<div id="TTREP809" class="example">
<p class="titleinexample"><a id="sthref285"></a>Example 4-35 Configuring multiple network interfaces for a classic replication scheme</p>
<p>If <code>host1</code> host is configured with a second interface accessible by the <code>host1fast</code> host name, and <code>host2</code> is configured with a second interface at IP address <code>192.168.1.100</code>, you may specify that the secondary interfaces are used with the replication scheme.</p>
<pre>CREATE REPLICATION repscheme
 ELEMENT e1 TABLE ttuser.tab
    MASTER dsn1 ON host1
    SUBSCRIBER dsn2 ON host2
 ELEMENT e2 TABLE ttuser.tab
    MASTER dsn2 ON host2
    SUBSCRIBER dsn1 ON host1
 ROUTE MASTER dsn1 ON host1 SUBSCRIBER dsn2 ON host2
    MASTERIP host1fast PRIORITY 1
    SUBSCRIBERIP &#34;192.168.1.100&#34; PRIORITY 1
 ROUTE MASTER dsn2 ON host2 SUBSCRIBER dsn1 ON host1
    MASTERIP &#34;192.168.1.100&#34; PRIORITY 1
    SUBSCRIBERIP host1fast PRIORITY 1;
</pre></div>
<!-- class="example" -->
<p>Alternately, on a replication host with more than one interface, you may want to configure replication to use one or more interfaces as backups, in case the primary interface fails or the connection from it to the receiving host is broken. You can use the <code>ROUTE</code> clause to specify two or more interfaces for each master or subscriber that are used by replication in order of priority.</p>
<p>If replication on the master host is unable to bind to the <code>MASTERIP</code> with the highest priority, it tries to connect using subsequent <code>MASTERIP</code> addresses in order of priority immediately. However, if the connection to the subscriber fails for any other reason, replication tries to connect using each of the <code>SUBSCRIBERIP</code> addresses in order of priority before it tries the <code>MASTERIP</code> address with the next highest priority.</p>
<div id="TTREP208" class="example">
<p class="titleinexample"><a id="sthref286"></a>Example 4-36 Configuring network priority on an active standby pair</p>
<p>If the <code>host1</code> host is configured with two network interfaces at IP addresses <code>192.168.1.100</code> and <code>192.168.1.101</code>, and the <code>host2</code> host is configured with two interfaces at IP addresses <code>192.168.1.200</code> and <code>192.168.1.201</code>, you may specify that replication use IP addresses <code>192.168.1.100</code> and <code>192.168.200</code> to transmit and receive traffic first, and to try IP addresses <code>192.168.1.101</code> or <code>192.168.1.201</code> if the first connection fails.</p>
<pre>CREATE ACTIVE STANDBY PAIR dns1, dns2
 ROUTE MASTER dsn1 ON &#34;host1&#34; SUBSCRIBER dsn2 ON &#34;host2&#34;
   MASTERIP &#34;192.168.1.100&#34; PRIORITY 1
   MASTERIP &#34;192.168.1.101&#34; PRIORITY 2
   SUBSCRIBERIP &#34;192.168.1.200&#34; PRIORITY 1
   SUBSCRIBERIP &#34;192.168.1.201&#34; PRIORITY 2;
</pre></div>
<!-- class="example" -->
<div id="TTREP810" class="example">
<p class="titleinexample"><a id="sthref287"></a>Example 4-37 Configuring network priority for a classic replication scheme</p>
<p>If the <code>host1</code> host is configured with two network interfaces at IP addresses <code>192.168.1.100</code> and <code>192.168.1.101</code>, and the <code>host2</code> host is configured with two interfaces at IP addresses <code>192.168.1.200</code> and <code>192.168.1.201</code>, you may specify that replication use IP addresses <code>192.168.1.100</code> and <code>192.168.200</code> to transmit and receive traffic first, and to try IP addresses <code>192.168.1.101</code> or <code>192.168.1.201</code> if the first connection fails.</p>
<pre>CREATE REPLICATION repscheme
 ELEMENT e TABLE ttuser.tab
   MASTER dsn1 ON host1
   SUBSCRIBER dsn2 ON host2
 ROUTE MASTER dsn1 ON host1 SUBSCRIBER dsn2 ON host2
   MASTERIP &#34;192.168.1.100&#34; PRIORITY 1
   MASTERIP &#34;192.168.1.101&#34; PRIORITY 2
   SUBSCRIBERIP &#34;192.168.1.200&#34; PRIORITY 1
   SUBSCRIBERIP &#34;192.168.1.201&#34; PRIORITY 2;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CEGIDDGE"></a>
<div id="TTREP404" class="sect2">
<h3 class="sect2">Configuring network interfaces when not using the ROUTE clause<a id="sthref288"></a><a id="sthref289"></a><a id="sthref290"></a><a id="sthref291"></a></h3>
<p>The following sections describe how to configure replication so that it uses the correct host names and IP addresses for each host when not using the <code>ROUTE</code> clause.</p>
<ul>
<li>
<p><a href="#CHDDCHIH">Identifying database hosts on UNIX without using the ROUTE clause</a></p>
</li>
<li>
<p><a href="#CHDHBGHC">Host name resolution on Windows</a></p>
</li>
<li>
<p><a href="#CHDCCDHH">User-specified addresses for TimesTen daemons and subdaemons</a></p>
</li>
</ul>
<a id="CHDDCHIH"></a>
<div id="TTREP406" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Identifying database hosts on UNIX without using the ROUTE clause</h4>
<p>When possible, you should use the <code>ROUTE</code> clause of a replication scheme to identify database hosts and the network interfaces to use for replication. However, if you have a replication scheme configuration that does not use the <code>ROUTE</code> clause, this section explains how to configure operating system and DNS files for a replication host with multiple network interfaces.</p>
<p>If a host contains multiple network interfaces (with different IP addresses) and replication is not configured with a <code>ROUTE</code> clause, TimesTen replication tries to connect to the IP addresses in the same order as returned by the <code>gethostbyname</code> call. It tries to connect using the first address; if a connection cannot be established, it tries the remaining addresses in order until a connection is established. TimesTen replication uses this same sequence each time it establishes a new connection to a host. If a connection to a host fails on one IP address, TimesTen replication attempts to re-connect (or fall back) to another IP address for the host in the same manner described above.</p>
<p>There are two basic ways you can configure a host to use multiple IP addresses on UNIX platforms: DNS or the <code>/etc/hosts</code> file.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you have multiple network interface cards (NICs), be sure that &#34;<code>multi on</code>&#34; is specified in the <code>/etc/host.conf</code> file. Otherwise, <code>gethostbyname</code> cannot return multiple addresses.</div>
<p>For example, if your machine has two NICs, use the following syntax for your <code>/etc/hosts</code> file:</p>
<pre>127.0.0.1  localhost
<span class="italic">IP_address_for_NIC_1</span>  <span class="italic">official_hostname</span> <span class="italic">optional_alias</span>
<span class="italic">IP_address_for_NIC_2</span>  <span class="italic">official_hostname</span> <span class="italic">optional_alias</span>
</pre>
<p>The host name <code><span class="codeinlineitalic">official_hostname</span></code> is the name returned by the <code>hostname</code> command.</p>
<p>When editing the <code>/etc/hosts</code> file, keep in mind that:</p>
<ul>
<li>
<p>You must log in as <code>root</code> to change the <code>/etc/hosts</code> file.</p>
</li>
<li>
<p>There should only be one line per IP address.</p>
</li>
<li>
<p>There can be multiple alias names on each line.</p>
</li>
<li>
<p>When there are multiple IP addresses for the same host name, they must be on consecutive lines.</p>
</li>
<li>
<p>The host name can be up to 30 characters long.</p>
</li>
</ul>
<p>For example, the following entry in the <code>/etc/hosts</code> file on a UNIX platform describes a server named <code>Host1</code> with two IP addresses:</p>
<pre>127.0.0.1        localhost
10.10.98.102     Host1
192.168.1.102    Host1
</pre>
<p>To specify the same configuration for DNS, your entry in the domain zone file would look like:</p>
<pre>Host1     IN     A     10.10.98.102
          IN     A     192.168.1.102
</pre>
<p>In either case, you only need to specify <code>Host1</code> as the host name in your replication scheme and replication uses the first available IP address when establishing a connection.</p>
<p>In an environment in which multiple IP addresses are used, you can also assign multiple host names to a single IP address in order to restrict a replication connection to a specific IP address. For example, you might have an entry in your <code>/etc/hosts</code> file that looks like:</p>
<pre>127.0.0.1        localhost
10.10.98.102     Host1
192.168.1.102    Host1 RepHost1
</pre>
<p>or a DNS zone file that looks like:</p>
<pre>Host1     IN     A     10.10.98.102
          IN     A     192.168.1.102
RepHost1  IN     A     192.168.1.102
</pre>
<p>If you want to restrict replication connections to IP address <code>192.168.1.102</code> for this host, you can specify <code>RepHost1</code> as the host name in your replication scheme. Another option is to simply specify the IP address as the host name in either the <code>CREATE ACTIVE STANDBY PAIR</code> or <code>CREATE REPLICATION</code> statements used to configure your replication scheme.</p>
</div>
<!-- class="sect3" -->
<a id="CHDHBGHC"></a>
<div id="TTREP407" class="sect3">
<h4 class="sect3">Host name resolution on Windows</h4>
<p>If a replication configuration is specified using host names rather than IP addresses, replication must be able to translate host names of peers into IP addresses. For this to happen efficiently on Windows, make sure each Windows machine is set up to query either a valid <a id="sthref292"></a>WINS server or a valid <a id="sthref293"></a>DNS server that has correct information about the hosts on the network. In the absence of such servers, static host-to-IP entries can be entered in either:</p>
<pre>%windir%\system32\drivers\etc\hosts
</pre>
<p>or</p>
<pre>%windir%\system32\drivers\etc\lmhosts
</pre>
<p>Without any of these options, a Windows machine resorts to broadcasting to detect peer nodes, which is extremely slow.</p>
<p>You may also encounter extremely slow host name resolution if the Windows machine cannot communicate with the defined WINS servers or DNS servers, or if the host name resolution set up is incorrect on those servers. Use the <code>ping</code> command to test whether a host can be efficiently located. The <code>ping</code> command responds immediately if host name resolution is set up properly.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must be consistent in identifying a database host in a replication scheme. Do not identify a host using its IP address for one database and then use its host name for the same or another database.</div>
</div>
<!-- class="sect3" -->
<a id="CHDCCDHH"></a>
<div id="TTREP408" class="sect3">
<h4 class="sect3">User-specified addresses for TimesTen daemons and subdaemons</h4>
<p>By default, the TimesTen main daemon, all subdaemons, and all agents use any available address to listen on a socket for requests. You can modify the <code>ttendaemon.options</code> file to specify an address for communication among the agents and daemons by including a <code>-listenaddr</code> option. See <a class="olink TTOPR215" href="../TTOPR/daemon.htm#TTOPR215">&#34;Managing TimesTen daemon options&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span> for details.</p>
<p>Suppose that your machine has two NICs whose addresses are <code>10.10.10.100</code> and <code>10.10.11.200</code>. The loopback address is <code>127.0.0.1</code>. Then keep in mind the following as it applies to the replication agent:</p>
<ul>
<li>
<p>If you do not set the <code>-listenaddr</code> option in the <code>ttendaemon.options</code> file, then any process can talk to the daemons and agents.</p>
</li>
<li>
<p>If you set <code>-listenaddr</code> to <code>10.10.10.100</code>, then any process on the local host or the <code>10.10.10</code> net can talk to daemons and agents on <code>10.10.10.100</code>. No processes on the <code>10.10.11</code> net can talk to the daemons and agents on <code>10.10.10.100</code>.</p>
</li>
<li>
<p>If you set <code>-listenaddr</code> to <code>127.0.0.1</code>, then only processes on the local host can talk to the daemons and agents. No processes on other hosts can talk the daemons and agents.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CEGDEGBI"></a>
<div id="TTREP409" class="sect2">
<h3 class="sect2">Identifying the local host of a replicated database</h3>
<p>Ordinarily, TimesTen replication is able to identify the hosts involved in a replication configuration using normal operating system host name resolution methods. However, in some rare instances, if the host has an unusual host name configuration, TimesTen is unable to determine that the local host matches the host name as specified in the replication scheme. When this occurs, you receive error 8191, &#34;This store is not involved in a replication scheme,&#34; when attempting to start replication using <code>ttRepStart</code> or <code>ttAdmin</code> <code>-repStart</code>. The <code>ttHostNameSet</code> built-in procedure may be used in this instance to explicitly indicate to TimesTen that the current database is in fact the database specified in the replication scheme. See <a class="olink TTREF258" href="../TTREF/proced.htm#TTREF258">&#34;ttHostNameSet&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for more information.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5803">
<tr>
<td class="cellalignment5812">
<table class="cellalignment5808">
<tr>
<td class="cellalignment5807"><a href="definepair.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5807"><a href="standby.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2012, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5814">
<table class="cellalignment5806">
<tr>
<td class="cellalignment5807"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5807"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5807"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5807"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5807"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5807"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>