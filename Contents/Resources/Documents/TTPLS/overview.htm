<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-113973"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Programming%20Features%20in%20PL%2FSQL%20in%20TimesTen"></a><title>Programming Features in PL/SQL in TimesTen</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 704"/>
<meta name="dcterms.created" content="2014-10-01T13:43:51Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen In-Memory Database PL/SQL Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E21639-07"/>
<meta name="dcterms.isVersionOf" content="TTPLS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="intro.htm" title="Previous" type="text/html"/>
<link rel="Next" href="dtypesfunc.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21639-07.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">6/14</span> <!-- End Header --><a id="CEGFFDGE"></a><a id="TTPLS118"></a>
<h1 class="chapter"><span class="secnum">2</span> Programming Features in PL/SQL in TimesTen</h1>
<p>One of the advantages of PL/SQL in TimesTen is the ability to integrate PL/SQL procedural constructs with the flexible and powerful TimesTen SQL language.</p>
<p>This chapter surveys the main PL/SQL programming features described in <a class="olink LNPLS001" href="../LNPLS/overview.htm#LNPLS001">&#34;Overview of PL/SQL&#34;</a> in <span class="italic">Oracle Database PL/SQL Language Reference</span>. Working from simple examples, you will learn how to use PL/SQL in TimesTen. Unless otherwise noted, the examples have the same results in TimesTen as in Oracle Database.</p>
<p>See the end of the chapter for TimesTen-specific considerations. See <a href="intro.htm#BHCGJJDF">&#34;TimesTen PL/SQL components and operations&#34;</a> for an overview of how applications interact with TimesTen in general and PL/SQL in particular.</p>
<p>The following are the main topics of this chapter:</p>
<ul>
<li>
<p><a href="#CEGICJJI">PL/SQL blocks</a></p>
</li>
<li>
<p><a href="#CEGEGAEI">PL/SQL variables and constants</a></p>
</li>
<li>
<p><a href="#CJAFFGDG">SQL function calls from PL/SQL</a></p>
</li>
<li>
<p><a href="#CEGJCJHA">PL/SQL control structures</a></p>
</li>
<li>
<p><a href="#CEGJHBFA">How to execute PL/SQL procedures and functions</a></p>
</li>
<li>
<p><a href="#CEGHBFIG">How to pass data between an application and PL/SQL</a></p>
</li>
<li>
<p><a href="#CJAJDFIJ">Use of SQL in PL/SQL programs</a></p>
</li>
<li>
<p><a href="#CEGBAJBJ">Use of cursors in PL/SQL programs</a></p>
</li>
<li>
<p><a href="#CEGFFEGG">PL/SQL procedures and functions</a></p>
</li>
<li>
<p><a href="#CEGFFDBF">PL/SQL packages</a></p>
</li>
<li>
<p><a href="#CJAFJHGG">Wrapping PL/SQL source code</a></p>
</li>
<li>
<p><a href="#CEGFEIHJ">Differences in TimesTen: transaction behavior</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Except where stated otherwise, the examples in this guide use the TimesTen <code>ttIsql</code> utility. In order to display output in the examples, the setting <code>SET SERVEROUTPUT ON</code> is used. For more information on <code>ttIsql</code>, see <a class="olink TTREF342" href="../TTREF/util.htm#TTREF342">&#34;ttIsql&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
<a id="CEGICJJI"></a><a id="TTPLS119"></a>
<div class="sect1">
<h2 class="sect1">P<a id="sthref19"></a><a id="sthref20"></a>L/SQL blocks</h2>
<p>The basic unit of a PL/SQL source program is the <span class="italic">block</span>, or <span class="italic">anonymous block</span>, which groups related declarations and statements. TimesTen supports PL/SQL blocks.</p>
<p>A PL/SQL block is defined by the keywords <code>DECLARE</code>, <code>BEGIN</code>, <code>EXCEPTION</code>, and <code>END</code>. <a href="#CEGGJACG">Example 2-1</a> shows the basic structure of a PL/SQL block.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you use TimesTen Application-Tier Database Cache (TimesTen Cache): A PL/SQL block cannot be passed through to Oracle Database. (Also see <a href="#CEGHJDFD">&#34;TimesTen PL/SQL with TimesTen Cache&#34;</a>.)</div>
<div class="example">
<p class="titleinexample"><a id="CEGGJACG"></a><a id="TTPLS120"></a>Example 2-1 PL/SQL block structure</p>
<pre>DECLARE   -- (optional)
          -- Variables, cursors, user-defined exceptions
BEGIN     -- (mandatory)
          -- PL/SQL statements
EXCEPTION -- (optional)
          -- Actions to perform when errors occur
END       -- (mandatory)
</pre></div>
<!-- class="example" -->
<p>You can define either anonymous or named blocks in your PL/SQL programs. This example creates an anonymous block that queries the <code>employees</code> table and returns the data in a PL/SQL variable:</p>
<pre>Command&gt; SET SERVEROUTPUT ON;
Command&gt;  DECLARE
       &gt;    v_fname VARCHAR2 (20);
       &gt;  BEGIN
       &gt;    SELECT first_name
       &gt;    INTO v_fname
       &gt;    FROM employees
       &gt;    WHERE employee_id = 100;
       &gt;  DBMS_OUTPUT.PUT_LINE (v_fname);
       &gt;  END;
       &gt;  /
Steven
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="sect1" -->
<a id="CEGEGAEI"></a><a id="TTPLS121"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">PL/S<a id="sthref21"></a><a id="sthref22"></a>QL variables and constants</h2>
<p>You can define variables and constants in PL/SQL and then use them in procedural statements and in SQL anywhere an expression can be used.</p>
<p>For example:</p>
<pre>Command&gt; DECLARE
       &gt;   v_hiredate DATE;
       &gt;   v_deptno   NUMBER (2) NOT NULL := 10;
       &gt;   v_location VARCHAR2 (13) := &#39;San Francisco&#39;;
       &gt;   c_comm     CONSTANT NUMBER := 1400;
</pre>
<p>You can use the <code>%T<a id="sthref23"></a>YPE</code> attribute to declare a variable according to either a TimesTen column definition or another declared variable. For example, use <code>%TYPE</code> to create variables <code>emp_lname</code> and <code>min_balance</code>:</p>
<pre>Command&gt; DECLARE
       &gt;   emp_lname  employees.last_name%TYPE;
       &gt;   balance    NUMBER (7,2);
       &gt;   min_balance  balance%TYPE:= 1000;
       &gt; BEGIN
       &gt;   SELECT last_name INTO emp_lname FROM employees WHERE employee_id = 100;
       &gt;   DBMS_OUTPUT.PUT_LINE (emp_lname);
       &gt;   DBMS_OUTPUT.PUT_LINE (min_balance);
       &gt; END;
       &gt; /
King
1000
 
PL/SQL procedure successfully completed.
</pre>
<p>You can assign a value to a variable in the following ways.</p>
<ul>
<li>
<p>With the assignment operator (<code>:=</code>), as shown in <a href="#CEGIDCAF">Example 2-2</a></p>
</li>
<li>
<p>By selecting or fetching values into it, as shown in <a href="#CEGIABAF">Example 2-3</a></p>
</li>
<li>
<p>By passing the variable as an <code>OUT</code> or <code>IN OUT</code> parameter to a subprogram (procedure or function) and then assigning the value inside the subprogram, as shown in <a href="#CEGFCBHB">Example 2-4</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>DBMS_OUTPUT</code> package used in these examples is supplied with TimesTen. For information on this and other supplied packages, refer to <a href="package.htm#CDECFEID">Chapter 8, &#34;TimesTen Supplied PL/SQL Packages&#34;</a>.</div>
<div class="example">
<p class="titleinexample"><a id="CEGIDCAF"></a><a id="TTPLS122"></a>Example 2-2 Assigning values to variables with the assignment operator</p>
<pre>Command&gt; DECLARE -- Assign values in the declarative section 
       &gt;   wages NUMBER;
       &gt;   hours_worked NUMBER := 40;
       &gt;   hourly_salary NUMBER := 22.50;
       &gt;   bonus NUMBER := 150;
       &gt;   country VARCHAR2(128);
       &gt;   counter NUMBER := 0;
       &gt;   done BOOLEAN;
       &gt;   valid_id BOOLEAN;
       &gt;   emp_rec1 employees%ROWTYPE;
       &gt;   emp_rec2 employees%ROWTYPE;
       &gt;   TYPE commissions IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
       &gt;   comm_tab commissions;
       &gt; BEGIN -- Assign values in the executable section
       &gt;   wages := (hours_worked * hourly_salary) + bonus;
       &gt;   country := &#39;France&#39;;
       &gt;   country := UPPER(&#39;Canada&#39;);
       &gt;   done := (counter &gt; 100);
       &gt;   valid_id := TRUE;
       &gt;   emp_rec1.first_name := &#39;Amy&#39;;
       &gt;   emp_rec1.last_name := &#39;Feiner&#39;;
       &gt;   emp_rec1 := emp_rec2;
       &gt;   comm_tab(5) := 20000 * 0.15;
       &gt; END;
       &gt; /
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
This exa<a id="sthref24"></a>mple uses records, which are composite data structures that have fields with different data types. You can use the <code>%ROWTYPE</code> attribute, as shown, to declare a record that represents a row in a table or a row from a query result set. Records are further discussed under <a href="dtypesfunc.htm#CIHEGAHD">&#34;PL/SQL composite data types&#34;</a>.</div>
<div class="example">
<p class="titleinexample"><a id="CEGIABAF"></a><a id="TTPLS123"></a>Example 2-3 Using SELECT INTO to assign values to variables</p>
<p>Select 10% of an employee&#39;s salary into the <code>bonus</code> variable:</p>
<pre>Command&gt;  DECLARE
       &gt;    bonus NUMBER(8,2);
       &gt;    emp_id NUMBER(6) := 100;
       &gt;  BEGIN
       &gt;    SELECT salary * 0.10 INTO bonus FROM employees
       &gt;      WHERE employee_id = emp_id;
       &gt;    DBMS_OUTPUT.PUT_LINE (bonus);
       &gt;  END;
       &gt;  /
2400
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="CEGFCBHB"></a><a id="TTPLS124"></a>Example 2-4 Assigning values to variables as parameters of a subprogram</p>
<p>Declare the variable <code>new_sal</code> and then pass the variable as a parameter (<code>sal</code>) to procedure <code>adjust_salary</code>. Procedure <code>adjust_salary</code> computes the average salary for employees with <code>job_id=&#39;ST_CLERK&#39;</code> and then updates <code>sal</code>. After the procedure is executed, the value of the variable is displayed to verify that the variable was correctly updated.</p>
<pre>Command&gt; DECLARE
       &gt;   new_sal NUMBER(8,2);
       &gt;   emp_id NUMBER(6) := 126;
       &gt; PROCEDURE adjust_salary (emp_id NUMBER, sal IN OUT NUMBER) IS
       &gt;   emp_job VARCHAR2(10);
       &gt;   avg_sal NUMBER(8,2);
       &gt; BEGIN
       &gt;   SELECT job_id INTO emp_job FROM employees
       &gt;     WHERE employee_id = emp_id;
       &gt;   SELECT AVG(salary) INTO avg_sal FROM employees
       &gt;     WHERE job_id = emp_job;
       &gt;   DBMS_OUTPUT.PUT_LINE (&#39;The average salary for &#39; || emp_job
       &gt;     || &#39; employees: &#39; || TO_CHAR(avg_sal));
       &gt;   sal := (sal + avg_sal)/2;
       &gt;   DBMS_OUTPUT.PUT_LINE (&#39;New salary is &#39; || sal);
       &gt; END;
       &gt; BEGIN
       &gt;   SELECT AVG(salary) INTO new_sal FROM employees;
       &gt;   DBMS_OUTPUT.PUT_LINE (&#39;The average salary for all employees: &#39;
       &gt;     || TO_CHAR(new_sal));
       &gt;   adjust_salary(emp_id, new_sal);
       &gt;   DBMS_OUTPUT.PUT_LINE (&#39;Salary should be same as new salary &#39; ||
       &gt;     new_sal);
       &gt; END;
       &gt; /
The average salary for all employees: 6461.68
The average salary for ST_CLERK employees: 2785
New salary is 4623.34
Salary should be same as new salary 4623.34
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
This example illustrates the ability to nest PL/SQL blocks within blocks. The outer anonymous block contains an enclosed procedure. This <code>PROCEDURE</code> statement is distinct from the <code>CREATE PROCEDURE</code> statement documented in <a href="#CEGFFEGG">&#34;PL/SQL procedures and functions&#34;</a>, which creates a subprogram that remains stored in the user&#39;s schema.</div>
</div>
<!-- class="sect1" -->
<a id="CJAFFGDG"></a><a id="TTPLS125"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">SQL function calls from PL/<a id="sthref25"></a><a id="sthref26"></a>SQL</h2>
<p>Most SQL functions are supported for calls directly from PL/SQL. In the first example that follows, the function <code>RTRIM</code> is used as a PL/SQL function in a PL/SQL assignment statement. In the second example, it is used as a SQL function in a static SQL statement.</p>
<div class="example">
<p class="titleinexample"><a id="TTPLS126"></a><a id="sthref27"></a>Example 2-5 Using the RTRIM function from PL/SQL</p>
<p>Use the TimesTen PL/SQL <code>RTRIM</code> built-in function to remove the right-most &#34;x&#34; and &#34;y&#34; characters from the string. Note that <code>RTRIM</code> is used in a PL/SQL assignment statement.</p>
<pre>Command&gt; DECLARE p_var VARCHAR2(30);
       &gt; BEGIN
       &gt;   p_var := RTRIM (&#39;RTRIM Examplexxxyyyxyxy&#39;, &#39;xy&#39;);
       &gt;   DBMS_OUTPUT.PUT_LINE (p_var);
       &gt; END;
       &gt; /
RTRIM Example
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="TTPLS127"></a><a id="sthref28"></a>Example 2-6 Using the RTRIM function from SQL</p>
<p>Use the TimesTen SQL function <code>RTRIM</code> to remove the right-most &#34;x&#34; and &#34;y&#34; characters from the string. Note that <code>RTRIM</code> is used in a static SQL statement.</p>
<pre>Command&gt;  DECLARE tt_var VARCHAR2 (30);
       &gt;  BEGIN
       &gt;    SELECT RTRIM (&#39;RTRIM Examplexxxyyyxyxy&#39;, &#39;xy&#39;)
       &gt;      INTO tt_var FROM DUAL;
       &gt;    DBMS_OUTPUT.PUT_LINE (tt_var);
       &gt; END;
       &gt; /
RTRIM Example
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<p>You can refer to information about SQL functions in TimesTen under <a class="olink TTSQL194" href="../TTSQL/express.htm#TTSQL194">&#34;Expressions&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>. See <a class="olink LNPLS00212" href="../LNPLS/fundamentals.htm#LNPLS00212">&#34;SQL Functions in PL/SQL Expressions&#34;</a> in <span class="italic">Oracle Database PL/SQL Language Reference</span> for information about support for SQL functions in PL/SQL.</p>
</div>
<!-- class="sect1" -->
<a id="CEGJCJHA"></a><a id="TTPLS129"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">PL/SQL control structures</h2>
<p>Control structures are among the PL/SQL extensions to SQL. TimesTen supports the same control structures as Oracle Database.</p>
<p>The following control structures are discussed in this section.</p>
<ul>
<li>
<p><a href="#CEGDAFIJ">Conditional control</a></p>
</li>
<li>
<p><a href="#CEGBACJA">Iterative control</a></p>
</li>
<li>
<p><a href="#CEGDIJHD">CONTINUE statement</a></p>
</li>
</ul>
<a id="CEGDAFIJ"></a><a id="TTPLS130"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Con<a id="sthref29"></a><a id="sthref30"></a><a id="sthref31"></a><a id="sthref32"></a>ditional control</h3>
<p>The <code>IF-THEN-ELSE</code> and <code>CASE</code> constructs are examples of conditional control. In <a href="#CEGIEADA">Example 2-7</a>, the <code>IF-THEN-ELSE</code> construct is used to determine the salary raise of an employee based on the current salary. The <code>CASE</code> construct is also used to choose the course of action to take based on the <code>job_id</code> of the employee.</p>
<div class="example">
<p class="titleinexample"><a id="CEGIEADA"></a><a id="TTPLS131"></a>Example 2-7 Using the IF-THEN-ELSE and CASE constructs</p>
<pre>Command&gt; DECLARE
       &gt;   jobid employees.job_id%TYPE;
       &gt;   empid employees.employee_id%TYPE := 115;
       &gt;   sal employees.salary%TYPE;
       &gt;   sal_raise NUMBER(3,2);
       &gt; BEGIN
       &gt;   SELECT job_id, salary INTO jobid, sal from employees
       &gt;     WHERE employee_id = empid;
       &gt;   CASE
       &gt;     WHEN jobid = &#39;PU_CLERK&#39; THEN
       &gt;       IF sal &lt; 3000 THEN sal_raise := .12;
       &gt;       ELSE sal_raise := .09;
       &gt;       END IF;
       &gt;     WHEN jobid = &#39;SH_CLERK&#39; THEN
       &gt;       IF sal &lt; 4000 THEN sal_raise := .11;
       &gt;       ELSE sal_raise := .08;
       &gt;       END IF;
       &gt;     WHEN jobid = &#39;ST_CLERK&#39; THEN
       &gt;       IF sal &lt; 3500 THEN sal_raise := .10;
       &gt;       ELSE sal_raise := .07;
       &gt;       END IF;
       &gt;     ELSE
       &gt;       BEGIN
       &gt;         DBMS_OUTPUT.PUT_LINE(&#39;No raise for this job: &#39; || jobid);
       &gt;       END;
       &gt;   END CASE;
       &gt; DBMS_OUTPUT.PUT_LINE (&#39;Original salary &#39; || sal);
       &gt; -- Update
       &gt; UPDATE employees SET salary = salary + salary * sal_raise
       &gt; WHERE employee_id = empid;
       &gt; END;
       &gt; /
Original salary 3100
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CEGBACJA"></a><a id="TTPLS132"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Ite<a id="sthref33"></a><a id="sthref34"></a><a id="sthref35"></a><a id="sthref36"></a>rative control</h3>
<p>An iterative control construct executes a sequence of statements repeatedly, as long as a specified condition is true. Loop constructs are used to perform iterative operations.</p>
<p>There are three loop types:</p>
<ul>
<li>
<p>Basic loop</p>
</li>
<li>
<p><code>FOR</code> loop</p>
</li>
<li>
<p><code>WHILE</code> loop</p>
</li>
</ul>
<p>The basic loop performs repetitive actions without overall conditions. The <code>FOR</code> loop performs iterative actions based on a count. The <code>WHILE</code> loops perform iterative actions based on a condition.</p>
<div class="example">
<p class="titleinexample"><a id="CEGGABFB"></a><a id="TTPLS133"></a>Example 2-8 Using a WHILE loop</p>
<pre>Command&gt; CREATE TABLE temp (tempid NUMBER(6),
       &gt; tempsal NUMBER(8,2),
       &gt; tempname VARCHAR2(25));
Command&gt; DECLARE
       &gt;   sal employees.salary%TYPE := 0;
       &gt;   mgr_id employees.manager_id%TYPE;
       &gt;   lname employees.last_name%TYPE;
       &gt;   starting_empid employees.employee_id%TYPE := 120;
       &gt; BEGIN
       &gt;   SELECT manager_id INTO mgr_id
       &gt;     FROM employees
       &gt;     WHERE employee_id = starting_empid;
       &gt;   WHILE sal &lt;= 15000 LOOP -- loop until sal &gt; 15000
       &gt;     SELECT salary, manager_id, last_name INTO sal, mgr_id, lname
       &gt;       FROM employees WHERE employee_id = mgr_id;
       &gt;   END LOOP;
       &gt;   INSERT INTO temp VALUES (NULL, sal, lname);  -- insert NULL for tempid
       &gt;   COMMIT;
       &gt; EXCEPTION
       &gt;   WHEN NO_DATA_FOUND THEN
       &gt;     INSERT INTO temp VALUES (NULL, NULL, &#39;Not found&#39;);  -- insert NULLs
       &gt;     COMMIT;
       &gt; END;
       &gt; /
 
PL/SQL procedure successfully completed.
 
Command&gt; SELECT * FROM temp;
&lt; &lt;NULL&gt;, 24000, King &gt;
1 row found.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CEGDIJHD"></a><a id="TTPLS134"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">CON<a id="sthref37"></a><a id="sthref38"></a>TINUE statement</h3>
<p>The <code>CONTINUE</code> statement enables you to transfer control within a loop back to a new iteration.</p>
<div class="example">
<p class="titleinexample"><a id="TTPLS135"></a><a id="sthref39"></a>Example 2-9 Using the CONTINUE statement</p>
<p>In this example, the first <code>v_total</code> assignment is executed for each of the 10 iterations of the loop. The second <code>v_total</code> assignment is executed for the first five iterations of the loop. The <code>CONTINUE</code> statement transfers control within a loop back to a new iteration, so for the last five iterations of the loop, the second <code>v_total</code> assignment is not executed. The end <code>v_total</code> value is 70.</p>
<pre>Command&gt; DECLARE
       &gt;   v_total  SIMPLE_INTEGER := 0;
       &gt; BEGIN
       &gt;   FOR i IN 1..10 LOOP
       &gt;     v_total := v_total + i;
       &gt;     DBMS_OUTPUT.PUT_LINE (&#39;Total is : &#39; || v_total);
       &gt;     CONTINUE WHEN i &gt; 5;
       &gt;     v_total := v_total + i;
       &gt;     DBMS_OUTPUT.PUT_LINE (&#39;Out of loop  Total is: &#39; || v_total);
       &gt;   END LOOP;
       &gt; END;
       &gt; /
Total is : 1
Out of loop  Total is: 2
Total is : 4
Out of loop  Total is: 6
Total is : 9
Out of loop  Total is: 12
Total is : 16
Out of loop  Total is: 20
Total is : 25
Out of loop  Total is: 30
Total is : 36
Total is : 43
Total is : 51
Total is : 60
Total is : 70

PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGJHBFA"></a><a id="TTPLS136"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Ho<a id="sthref40"></a><a id="sthref41"></a><a id="sthref42"></a><a id="sthref43"></a><a id="sthref44"></a>w to execute PL/SQL procedures and functions</h2>
<p>TimesTen supports execution of PL/SQL from client applications using ODBC, OCI, Pro*C/C++, ODP.NET, JDBC, or TimesTen TTClasses (for C++).</p>
<p>As noted earlier, a block is the basic unit of a PL/SQL source program. Anonymous blocks were also discussed earlier. By contrast, procedures and functions are PL/SQL blocks that have been defined with a specified name. See <a href="#CEGFFEGG">&#34;PL/SQL procedures and functions&#34;</a> for how to define and create them.</p>
<p>In Tim<a id="sthref45"></a>esTen, a PL/SQL procedure or function that is standalone (created with <code>CREATE PROCEDURE</code> or <code>CREATE FUNCTION</code>) or part of a package can be executed using an anonymous block or a <code>CALL</code> statement. (See <a class="olink TTSQL443" href="../TTSQL/state.htm#TTSQL443">&#34;CALL&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for details about <code>CALL</code> syntax.)</p>
<p>Consider the following function:</p>
<pre>create or replace function mytest return number is
begin
  return 1;
end;
</pre>
<p>In TimesTen, you can execute <code>mytest</code> in either of the following ways.</p>
<ul>
<li>
<p>In an anonymous block:</p>
<pre>Command&gt; variable n number;
Command&gt; begin
       &gt; :n := mytest();
       &gt; end;
       &gt; /
 
PL/SQL procedure successfully completed.
 
Command&gt; print n;
N                    : 1
</pre></li>
<li>
<p>In a <code>CALL</code> statement:</p>
<pre>Command&gt; variable n number;
Command&gt; call mytest() into :n;
Command&gt; print n;
N                    : 1
</pre></li>
</ul>
<p>In Oracle Database, you could also execute <code>mytest</code> through a SQL statement, as follows. This execution mechanism is <span class="italic">not</span> supported in TimesTen.</p>
<ul>
<li>
<p>In a <code>SELECT</code> statement:</p>
<pre>SQL&gt; select mytest from dual;
 
    MYTEST
----------
         1
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
A user&#39;s own procedure takes precedence over a TimesTen built-in procedure with the same name, but it is best to avoid such naming conflicts.</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CEGHBFIG"></a><a id="TTPLS137"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">How to pass data between an application and PL/SQL</h2>
<p>This section covers the following topics for passing data between an application and PL/SQL:</p>
<ul>
<li>
<p><a href="#CEGGJGJA">Using bind variables from an application</a></p>
</li>
<li>
<p><a href="#CEGDIEIE">IN, OUT, and IN OUT parameter modes</a></p>
</li>
</ul>
<p>Refer to <a class="olink LNPLS646" href="../LNPLS/dynamic.htm#LNPLS646">&#34;Bind Variables&#34;</a> in <span class="italic">Oracle Database PL/SQL Language Reference</span> for additional information.</p>
<a id="CEGGJGJA"></a><a id="TTPLS138"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using bind variables from an ap<a id="sthref46"></a>plication</h3>
<p>You can use &#34;<code>:</code><code><span class="codeinlineitalic">var</span></code>&#34; notation for bind variables to be passed between your application (such as a C or Java application) and PL/SQL. The term <span class="italic">bind variable</span> (or sometimes <span class="italic">host variable</span>) is used equivalently to how the term <span class="italic">parameter</span> has historically been used in TimesTen, and bind variables from an application would correspond to the parameters declared in a PL/SQL procedure or function specification.</p>
<p>Here is a simple example using <code>ttIsql</code> to call a PL/SQL procedure that retrieves the name and salary of the employee corresponding to a specified employee ID. In this example, <code>ttIsql</code> essentially acts as the calling application, and the name and salary are output from PL/SQL:</p>
<pre>Command&gt; VARIABLE b_name VARCHAR2 (25)
Command&gt; VARIABLE b_sal  NUMBER

Command&gt; BEGIN
       &gt;  query_emp (171, :b_name, :b_sal);
       &gt; END;
       &gt; /
 
PL/SQL procedure successfully completed.
 
Command&gt; PRINT b_name
B_NAME               : Smith
Command&gt; PRINT b_sal
B_SAL                : 7400
</pre>
<p>See <a href="sqlexamples.htm#CHDIFAHG">&#34;Examples using input and output parameters and bind variables&#34;</a> for the complete example.</p>
<p>See <a href="#CEGFFEGG">&#34;PL/SQL procedures and functions&#34;</a> for how to create and define procedures and functions.</p>
<p>See <a class="olink TTCDV130" href="../TTCDV/writing_app.htm#TTCDV130">&#34;Binding parameters and executing statements&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span> and <a class="olink TTJDV141" href="../TTJDV/writing_app.htm#TTJDV141">&#34;Preparing SQL statements and setting input parameters&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Java Developer&#39;s Guide</span> for additional information and examples for those languages.</p>
<div class="infobox-note">
<p class="notep1">No<a id="sthref47"></a><a id="sthref48"></a>tes:</p>
<ul>
<li>
<p>The TimesTen binding mechanism (early binding) differs from that of Oracle Database (late binding). TimesTen requires the data types before preparing queries. As a result, there will be an error if the data type of each bind parameter is not specified or cannot be inferred from the SQL statement. This would apply, for example, to the following statement:</p>
<pre>SELECT &#39;x&#39; FROM DUAL WHERE :a = :b;
</pre>
<p>You could address the issue as follows, for example:</p>
<pre>SELECT &#39;x&#39; from DUAL WHERE CAST(:a as VARCHAR2(10)) = 
                           CAST(:b as VARCHAR2(10));
</pre></li>
<li>
<p>For duplicate parameters, the implementation in PL/SQL in TimesTen is no different than the implementation in PL/SQL in Oracle Database.</p>
</li>
<li>
<p>The term &#34;bind parameter&#34; as used in TimesTen developer guides (in keeping with ODBC terminology) is equivalent to the term &#34;bind variable&#34; as used in TimesTen PL/SQL documents (in keeping with Oracle Database PL/SQL terminology).</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CEGDIEIE"></a><a id="TTPLS139"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">IN, OUT, and IN OUT parameter m<a id="sthref49"></a><a id="sthref50"></a><a id="sthref51"></a><a id="sthref52"></a><a id="sthref53"></a><a id="sthref54"></a>odes</h3>
<p>Parameter modes define whether parameters declared in a PL/SQL subprogram (procedure or function) specification are used for input, output, or both. The three parameter modes are <code>IN</code> (the default), <code>OUT</code>, and <code>IN OUT</code>.</p>
<p>An <code>IN</code> parameter lets you pass a value to the subprogram being invoked. Inside the subprogram, an <code>IN</code> parameter acts like a constant and cannot be assigned a value. You can pass a constant, literal, initialized variable, or expression as an <code>IN</code> parameter.</p>
<p>An <code>OUT</code> parameter returns a value to the caller of a subprogram. Inside the subprogram, an <code>OUT</code> parameter acts like a variable. You can change its value and reference the value after assigning it.</p>
<p>An <code>IN OUT</code> parameter passes an initial value to a subprogram and returns an updated value to the caller. It can be assigned a value and its value can be read. Typically, an <code>IN OUT</code> parameter is a string buffer or numeric accumulator that is read inside the subprogram and then updated. The actual parameter that corresponds to an <code>IN OUT</code> formal parameter must be a variable, not a constant or an expression.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
TimesTen supports the binding of associative arrays (but not varrays or nested tables) as <code>IN</code>, <code>OUT</code>, or <code>IN OUT</code> parameters. See <a href="dtypesfunc.htm#CIJBEIIF">&#34;Using associative arrays from applications&#34;</a>.</div>
<p>See <a href="sqlexamples.htm#CHDIFAHG">&#34;Examples using input and output parameters and bind variables&#34;</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJAJDFIJ"></a><a id="TTPLS140"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Use of SQL in PL/SQL programs</h2>
<p>PL/SQL is tightly integrated with the TimesTen database through the SQL language. This section covers use of the following SQL features in PL/SQL.</p>
<ul>
<li>
<p><a href="#CEGGFHJF">Static SQL in PL/SQL for queries and DML statements</a></p>
</li>
<li>
<p><a href="#CEGEIGCA">Dynamic SQL in PL/SQL (EXECUTE IMMEDIATE statement)</a></p>
</li>
<li>
<p><a href="#CEGGIEEG">FORALL and BULK COLLECT operations</a></p>
</li>
<li>
<p><a href="#CEGEIHAB">RETURNING INTO clause</a></p>
</li>
<li>
<p><a href="#CEGHJDFD">TimesTen PL/SQL with TimesTen Cache</a></p>
</li>
<li>
<p><a href="#CEGFAEDJ">Large objects (LOBs)</a></p>
</li>
</ul>
<a id="CEGGFHJF"></a><a id="TTPLS141"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Static SQL in PL/SQL for q<a id="sthref55"></a><a id="sthref56"></a><a id="sthref57"></a><a id="sthref58"></a><a id="sthref59"></a>ueries and DML statements</h3>
<p>From within PL/SQL, you can execute the following as static SQL:</p>
<ul>
<li>
<p>DML statements: <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>MERGE</code></p>
</li>
<li>
<p>Queries: <code>SELECT</code></p>
</li>
<li>
<p>Transaction control: <code>COMMIT</code> and <code>ROLLBACK</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>You must use dynamic SQL to execute DDL statements in PL/SQL. See the next section, <a href="#CEGEIGCA">&#34;Dynamic SQL in PL/SQL (EXECUTE IMMEDIATE statement)&#34;</a>.</p>
</li>
<li>
<p>See <a href="#CEGFEIHJ">&#34;Differences in TimesTen: transaction behavior&#34;</a> for details about how TimesTen transaction behavior differs from Oracle Database behavior.</p>
</li>
</ul>
</div>
<p>For information on these SQL statements, refer to <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p><a href="#CEGDGDGH">Example 2-10</a> shows how to execute a query. For additional examples using TimesTen SQL in PL/SQL, see <a href="sqlexamples.htm#CIHGFECI">Chapter 5, &#34;Examples Using TimesTen SQL in PL/SQL&#34;</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CEGDGDGH"></a><a id="TTPLS142"></a>Example 2-10 Retrieving data with SELECT...INTO</p>
<p>Use the <code>SELECT... INTO</code> statement to retrieve exactly one row of data. TimesTen returns an error for any query that returns no rows or multiple rows.</p>
<p>This example retrieves <code>hire_date</code> and <code>salary</code> for the employee with <code>employee_id=100</code> from the <code>employees</code> table of the <code>HR</code> schema.</p>
<pre>Command&gt; run selectinto.sql
 
DECLARE
   v_emp_hiredate employees.hire_date%TYPE;
   v_emp_salary   employees.salary%TYPE;

BEGIN
   SELECT hire_date, salary
   INTO   v_emp_hiredate, v_emp_salary
   FROM   employees
   WHERE  employee_id = 100;
   DBMS_OUTPUT.PUT_LINE(v_emp_hiredate || &#39; &#39; || v_emp_salary);
END;
/
 
1987-06-17 24000
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CEGEIGCA"></a><a id="TTPLS143"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Dynamic SQL in PL/SQL (EX<a id="sthref60"></a><a id="sthref61"></a><a id="sthref62"></a><a id="sthref63"></a><a id="sthref64"></a>ECUTE IMMEDIATE statement)</h3>
<p>You can use native dynamic SQL, through the <code>EXECUTE IMMEDIATE</code> statement, to accomplish any of the following:</p>
<ul>
<li>
<p>Execute a DML statement such as <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>.</p>
</li>
<li>
<p>Execute a DDL statement such as <code>CREATE</code> or <code>ALTER</code>. For example, you can use <code>ALTER SESSION</code> to change a PL/SQL first connection attribute.</p>
</li>
<li>
<p>Execute a PL/SQL anonymous block.</p>
</li>
<li>
<p>Call a PL/SQL stored procedure or function.</p>
</li>
<li>
<p>Call a TimesTen built-in procedure. (See <a class="olink TTREF213" href="../TTREF/proced.htm#TTREF213">&#34;Built-In Procedures&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.)</p>
</li>
</ul>
<p>One use case is if you do not know the full text of your SQL statement until execution time. For example, during compilation you may not know the name of the column to use in the <code>WHERE</code> clause of your <code>SELECT</code> statement. In such a situation, you can use the <code>EXECUTE IMMEDIATE</code> statement.</p>
<p>A<a id="sthref65"></a><a id="sthref66"></a>nother use case is for DDL, which cannot be executed in static SQL from within PL/SQL.</p>
<p>To call a TimesTen built-in procedure that returns a result set, create a record type and use <code>EXECUTE IMMEDIATE</code> with <code>BULK COLLECT</code> to fetch the results into an array.</p>
<p><a href="#CEGGBHJH">Example 2-11</a> provides a set of brief examples of <code>EXECUTE IMMEDIATE</code>. For additional examples, see <a href="sqlexamples.htm#CHDBHJCA">&#34;Examples using EXECUTE IMMEDIATE&#34;</a>.</p>
<p>For more information, see <a class="olink LNPLS01115" href="../LNPLS/dynamic.htm#LNPLS01115">&#34;EXECUTE IMMEDIATE Statement&#34;</a> in <span class="italic">Oracle Database PL/SQL Language Reference</span>.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>See <a href="#CEGFEIHJ">&#34;Differences in TimesTen: transaction behavior&#34;</a> for important information.</p>
</li>
<li>
<p>As a DDL statement is being parsed to drop a procedure or a package, a timeout occurs if the procedure, or a procedure in the package, is still in use. After a call to a procedure, that procedure is considered to be in use until execution has returned to the user side. Any such deadlock times out after a short time.</p>
</li>
<li>
<p>You can also use the <code>DBMS_SQL</code> package for dynamic SQL. See <a href="package.htm#CHDCDJAA">&#34;DBMS_SQL&#34;</a>.</p>
</li>
</ul>
</div>
<div class="example">
<p class="titleinexample"><a id="CEGGBHJH"></a><a id="TTPLS368"></a>Example 2-11 Using EXECUTE IMMEDIATE to execute PL/SQL</p>
<p>This provides a set of examples using PL/SQL in <code>EXECUTE IMMEDIATE</code> statements. (The examples are independent of each other.)</p>
<p>Create a table and execute a DML statement on it within a PL/SQL block, specifying the input parameter through a <code>USING</code> clause. Then select the table to see the result.</p>
<pre>Command&gt; create table t(i int);
Command&gt; declare
       &gt;    i number := 1;
       &gt; begin
       &gt;    execute immediate &#39;begin insert into t values(:j);end;&#39; using i;
       &gt; end;
       &gt; /
 
PL/SQL procedure successfully completed.
 
Command&gt; select * from t;
&lt; 1 &gt;
1 row found.
</pre>
<p>Create a PL/SQL procedure <code>foo</code> then execute it in a PL/SQL block, specifying the input parameter through a <code>USING</code> clause:</p>
<pre>Command&gt; create or replace procedure foo(message varchar2) is
       &gt; begin
       &gt;    dbms_output.put_line(message);
       &gt; end;
       &gt; /
 
Procedure created.
 
Command&gt; begin
       &gt;    execute immediate &#39;begin foo(:b);end;&#39; using &#39;hello&#39;;
       &gt; end;
       &gt; /
hello
 
PL/SQL procedure successfully completed.
</pre>
<p>Create a PL/SQL procedure <code>myprint</code> then execute it through a <code>CALL</code> statement, specifying the input parameter through a <code>USING</code> clause:</p>
<pre>Command&gt; declare
       &gt;    a number := 1;
       &gt; begin
       &gt;    execute immediate &#39;call myprint(:b)&#39; using a;
       &gt; end;
       &gt; /
myprint procedure got number 1
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="TTPLS369"></a>Usage notes for dynamic SQL</p>
<p>Code that is executed through <code>EXECUTE IMMEDIATE</code> generally shares the same environment as the outer PL/SQL block, as in Oracle Database. In particular, be aware of the following. (These points apply to using <code>DBMS_SQL</code> as well as <code>EXECUTE IMMEDIATE</code>.)</p>
<ul>
<li>
<p>SQL and PL/SQL executed through <code>EXECUTE IMMEDIATE</code> run in the same transaction as the outer block.</p>
</li>
<li>
<p>Any exception raised during execution of an <code>EXECUTE IMMEDIATE</code> statement is propagated to the outer block. Therefore, any errors on the error stack when the <code>EXECUTE IMMEDIATE</code> statement is executed are visible inside the outer block. This is useful for procedures such as <code>DBMS_UTILITY.FORMAT_ERROR_STACK</code>.</p>
</li>
<li>
<p>Errors on the error stack prior to execution of a PL/SQL block in an <code>EXECUTE IMMEDIATE</code> statement are visible inside the block, for example by using <code>DBMS_UTILITY.FORMAT_ERROR_STACK</code>.</p>
</li>
<li>
<p>The execution environment in which an <code>EXECUTE IMMEDIATE</code> statement executes is the same as for the outer block. PL/SQL and TimesTen parameters, REF CURSOR state, and package state from the <code>EXECUTE IMMEDIATE</code> statement are visible inside the outer block.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CEGGIEEG"></a><a id="TTPLS145"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">FORALL and BU<a id="sthref67"></a><a id="sthref68"></a><a id="sthref69"></a><a id="sthref70"></a><a id="sthref71"></a><a id="sthref72"></a><a id="sthref73"></a><a id="sthref74"></a>LK COLLECT operations</h3>
<p><span class="italic">Bulk binding</span> is a powerful feature used in the execution of SQL statements from PL/SQL to move large amounts of data between SQL and PL/SQL. (This is different from binding parameters from an application program to PL/SQL.) With bulk binding, you bind arrays of values in a single operation rather than using a loop to perform <code>FETCH</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations multiple times. TimesTen supports bulk binding, which can result in significant performance improvement.</p>
<p>Use the <code>FORALL</code> statement to bulk-bind input collections before sending them to the SQL engine. Use <code>BULK COLLECT</code> to bring back batches of results from SQL. You can bulk-collect into any type of PL/SQL collection, such as a varray, nested table, or associative array (index-by table). For additional information on collections, refer to <a href="dtypesfunc.htm#CIJEGABH">&#34;Using collections in PL/SQL&#34;</a>.</p>
<p>You can use the <code>%BULK_EXCEPTIONS</code> cursor attribute and the <code>SAVE EXCEPTIONS</code> clause with <code>FORALL</code> statements. <code>SAVE EXCEPTIONS</code> allows an <code>UPDATE</code>, <code>INSERT</code>, or <code>DELETE</code> statement to continue executing after it issues an exception (for example, a constraint error). Exceptions are collected into an array that you can examine using <code>%BULK_EXCEPTIONS</code> after the statement has executed. When you use <code>SAVE EXCEPTIONS</code>, if exceptions are encountered during the execution of the <code>FORALL</code> statement, then all rows in the collection are processed. When the statement finishes, an error is issued to indicate that at least one exception occurred. If you do not use <code>SAVE EXCEPTIONS</code>, then when an exception is issued during a <code>FORALL</code> statement, the statement returns the exception immediately and no other rows are processed.</p>
<p>Refer to <a class="olink LNPLS901" href="../LNPLS/tuning.htm#LNPLS901">&#34;Using FORALL Statement and BULK COLLECT Clause Together&#34;</a> in <span class="italic">Oracle Database PL/SQL Language Reference</span> for more information on these features.</p>
<p><a href="#CEGFGDGC">Example 2-12</a> shows basic use of bulk binding and the <code>FORALL</code> statement. For more information and examples on bulk binding, see <a href="sqlexamples.htm#CHDDIIJE">&#34;Examples using FORALL and BULK COLLECT&#34;</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CEGFGDGC"></a><a id="TTPLS146"></a>Example 2-12 Using the FORALL statement</p>
<p>In the following example, the PL/SQL program increases the salary for employees with IDs 100, 102, 104, or 110. The <code>FORALL</code> statement bulk-binds the collection.</p>
<pre>Command&gt; CREATE OR REPLACE PROCEDURE raise_salary (p_percent NUMBER) IS
       &gt;   TYPE numlist_type IS TABLE OF NUMBER
       &gt;    INDEX BY BINARY_INTEGER;
       &gt;   v_id  numlist_type;  -- collection
       &gt; BEGIN
       &gt;   v_id(1) := 100; v_id(2) := 102; v_id (3) := 104; v_id (4) := 110;
       &gt;   -- bulk-bind the associative array
       &gt;   FORALL i IN v_id.FIRST .. v_id.LAST
       &gt;    UPDATE employees
       &gt;     SET salary = (1 + p_percent/100) * salary
       &gt;     WHERE employee_id = v_id (i);
       &gt; END;
       &gt; /
 
Procedure created.
 
</pre>
<p>Find out salaries before executing the <code>raise_salary</code> procedure:</p>
<pre>Command&gt; SELECT salary FROM employees WHERE employee_id = 100 OR employee_id = 
102 OR employee_id = 104 OR employee_id = 100;
&lt; 24000 &gt;
&lt; 17000 &gt;
&lt; 6000 &gt;
3 rows found.
</pre>
<p>Execute the procedure and verify results as follows.</p>
<pre>Command&gt; EXECUTE raise_salary (10);
 
PL/SQL procedure successfully completed.
 
Command&gt; SELECT salary FROM employees WHERE employee_id = 100 or employee_id = 
102 OR employee_id = 104 OR employee_id = 100;
&lt; 26400 &gt;
&lt; 18700 &gt;
&lt; 6600 &gt;
3 rows found.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CEGEIHAB"></a><a id="TTPLS147"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">RE<a id="sthref75"></a><a id="sthref76"></a>TURNING INTO clause</h3>
<p>You can use a <code>RETURNING INTO</code> clause, sometimes referred to as <span class="italic">DML returning</span>, with an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement to return specified columns or expressions, optionally including rowids, from rows that were affected by the action. This eliminates the need for a subsequent <code>SELECT</code> statement and separate round trip, in case, for example, you want to confirm what was affected or want the rowid after an insert or update.</p>
<p>A <code>RETURNING INTO</code> clause can be used with dynamic SQL (with <code>EXECUTE IMMEDIATE</code>) or static SQL.</p>
<p>Through the PL/SQL <code>BULK COLLECT</code> feature, the clause can return items from a single row into either a set of parameters or a record, or can return columns from multiple rows into a PL/SQL collection such as a varray, nested table, or associative array (index-by table). Parameters in the <code>INTO</code> part of the clause must be output only, not input/output. For information on collections, refer to <a href="dtypesfunc.htm#CIJEGABH">&#34;Using collections in PL/SQL&#34;</a>. For <code>BULK COLLECT</code>, see <a href="#CEGGIEEG">&#34;FORALL and BULK COLLECT operations&#34;</a> and <a href="sqlexamples.htm#CHDDIIJE">&#34;Examples using FORALL and BULK COLLECT&#34;</a>.</p>
<p>SQL syntax and restrictions for the <code>RETURNING INTO</code> clause in TimesTen are documented as part of the <a class="olink TTSQL321" href="../TTSQL/state.htm#TTSQL321">&#34;INSERT&#34;</a>, <a class="olink TTSQL336" href="../TTSQL/state.htm#TTSQL336">&#34;UPDATE&#34;</a>, and <a class="olink TTSQL306" href="../TTSQL/state.htm#TTSQL306">&#34;DELETE&#34;</a> documentation in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>Also see <a href="sqlexamples.htm#CHDCIBCB">&#34;Examples using RETURNING INTO&#34;</a>.</p>
<p>Refer to <a class="olink LNPLS01354" href="../LNPLS/returninginto_clause.htm#LNPLS01354">&#34;RETURNING INTO Clause&#34;</a> in <span class="italic">Oracle Database PL/SQL Language Reference</span> for additional information about DML returning.</p>
</div>
<!-- class="sect2" -->
<a id="CEGHJDFD"></a><a id="TTPLS148"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Times<a id="sthref77"></a><a id="sthref78"></a>Ten PL/SQL with TimesTen Cache</h3>
<p>When PL/SQL programs execute SQL statements, the SQL statements are processed by TimesTen in the same manner as when SQL is executed from applications written in other programming languages. All standard behaviors of TimesTen SQL apply. In an TimesTen Cache environment, this includes the ability to use all cache features from PL/SQL. When PL/SQL accesses tables in cache groups, the normal rules for those tables apply. For example, issuing a <code>SELECT</code> statement against a cache instance in a dynamic cache group may cause the instance to be automatically loaded into TimesTen from Oracle Database.</p>
<p>In particular, be aware of the following points about this functionality.</p>
<ul>
<li>
<p>When you use static SQL in PL/SQL, any tables accessed must exist in TimesTen or the PL/SQL will not compile successfully. In the following example, <code>ABC</code> must exist in TimesTen.</p>
<pre>begin
  insert into abc values(1, &#39;Y&#39;);
end;
</pre></li>
<li>
<p>In an TimesTen Cache environment, there is the capability to use the TimesTen passthrough facility to automatically route SQL statements from TimesTen to Oracle Database. (See <a class="olink TTCAC291" href="../TTCAC/operations.htm#TTCAC291">&#34;Setting a passthrough level&#34;</a> in <span class="italic">Oracle TimesTen Application-Tier Database Cache User&#39;s Guide</span> for details of the passthrough facility.)</p>
<p>With <code>passthrough=1</code>, a statement can be passed through to Oracle Database if any accessed table does not exist in TimesTen. In PL/SQL, however, the statement would have to be executed using dynamic SQL.</p>
<p>Updating the preceding example, the following TimesTen PL/SQL block could be used to access <code>ABC</code> in Oracle Database with <code>passthrough=1</code>:</p>
<pre>begin
  execute immediate &#39;insert into abc values(1, &#39;Y&#39;)&#39;;
end;
</pre>
<p>In this case, TimesTen PL/SQL can compile the block because the SQL statement is not examined at compile time.</p>
</li>
<li>
<p>While PL/SQL can be executed in TimesTen, in the current release the TimesTen passthrough facility cannot be used to route PL/SQL blocks from TimesTen to Oracle Database. For example, when using TimesTen Cache with <code>passthrough=3</code>, statements executed on a TimesTen connection are routed to Oracle Database in most circumstances. In this scenario, you may not execute PL/SQL blocks from your application program, because TimesTen would attempt to forward them to Oracle Database, which is not supported. (In the <code>passthrough=1</code> example, it is just the SQL statement being routed to Oracle Database, not the block as a whole.)</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Important:</p>
PL/SQL procedures and functions can use any of the following cache operations with either definer&#39;s rights or invoker&#39;s rights:
<ul>
<li>
<p>Loading or refreshing a cache group with commit every <code><span class="codeinlineitalic">n</span></code> rows</p>
</li>
<li>
<p>DML on AWT cache groups</p>
</li>
<li>
<p>DML on non-propagated cache groups (user managed cache groups without <code>PROPAGATE</code> enabled)</p>
</li>
<li>
<p><code>SELECT</code> on cache group tables that do not invoke passthrough or dynamic load</p>
</li>
<li>
<p><code>UNLOAD CACHE GROUP</code></p>
</li>
</ul>
<p>PL/SQL procedures or functions that use any of the following cache operations must use invoker&#39;s rights (<code>AUTHID CURRENT_USER</code>): passthrough, dynamic loading of a cache group, loading or refreshing a cache group using <code>WITH ID</code>, DDL on cache groups, DML on SWT cache groups, or <code>FLUSH CACHE GROUP</code>.</p>
<p>See <a href="accesscntl.htm#BABDDCHC">&#34;Definer&#39;s rights and invoker&#39;s rights&#34;</a>.</p>
</div>
</div>
<!-- class="sect2" -->
<a id="CEGFAEDJ"></a><a id="TTPLS370"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Lar<a id="sthref79"></a><a id="sthref80"></a>ge objects (LOBs)</h3>
<p>TimesTen supports LOBs (large objects). This includes CLOBs (character LOBs), NCLOBs (national character LOBs), and BLOBs (binary LOBs).</p>
<p>PL/SQL language features support LOBs in TimesTen as they do in Oracle Database, unless noted otherwise.</p>
<p>This section provides a brief overview of LOBs and discusses their use in PL/SQL, covering the following topics.</p>
<ul>
<li>
<p><a href="#CEGHHGGJ">About LOBs</a></p>
</li>
<li>
<p><a href="#CEGBDJGA">LOB locators</a></p>
</li>
<li>
<p><a href="#CEGEHJHJ">Temporary LOBs</a></p>
</li>
<li>
<p><a href="#CEGJJIBB">Differences between TimesTen LOBs and Oracle Database LOBs</a></p>
</li>
<li>
<p><a href="#CEGEAJGC">Using LOBs</a></p>
</li>
<li>
<p><a href="#CEGEAHIG">PL/SQL package support for LOBs</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
TimesTen does not support CLOBs if the database character set is <code>TIMESTEN8</code>.</div>
<p>You can also refer to the following:</p>
<ul>
<li>
<p><a class="olink TTSQL481" href="../TTSQL/types.htm#TTSQL481">&#34;LOB data types&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for additional information about LOBs in TimesTen</p>
</li>
<li>
<p><a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a> for general information about programming with LOBs (but not specific to TimesTen functionality)</p>
</li>
</ul>
<a id="CEGHHGGJ"></a><a id="TTPLS371"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">About LOBs</h4>
<p>A LOB is a large binary object (BLOB) or character object (CLOB or NCLOB). In TimesTen, a BLOB can be up to 16 MB in size and a CLOB or NCLOB up to 4 MB. LOBs in TimesTen have essentially the same functionality as in Oracle Database, except as noted otherwise. (See <a href="#CEGJJIBB">&#34;Differences between TimesTen LOBs and Oracle Database LOBs&#34;</a>.)</p>
<p>LOBs may be either persistent or temporary. A persistent LOB exists in a LOB column in the database. A temporary LOB exists only within an application.</p>
</div>
<!-- class="sect3" -->
<a id="CEGBDJGA"></a><a id="TTPLS400"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">LOB locators</h4>
<p>In PL/SQL, a LOB consists of a LOB locator and a LOB value. The locator is an opaque structure that acts as a handle to the value. When an application uses a LOB in an operation such as passing a LOB as a parameter, it is passing the locator, not the actual value.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
LOB manipulations through APIs that use LOB locators result in usage of TimesTen temporary space. Any significant number of such manipulations may necessitate a size increase for the TimesTen temporary data region. See <a class="olink TTREF154" href="../TTREF/attribute.htm#TTREF154">&#34;TempSize&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
<p>To update a LOB, your transaction must have an exclusive lock on the row containing the LOB. You can accomplish this by selecting the LOB with a <code>SELECT ... FOR UPDATE</code> statement. This results in a writable locator. With a simple <code>SELECT</code> statement, the locator is read-only. Read-only and writable locators behave as follows.</p>
<ul>
<li>
<p>A read-only locator is <span class="italic">read consistent</span>, meaning that throughout its lifetime, it sees only the contents of the LOB as of the time it was selected. Note that this would include any uncommitted updates made to the LOB within the same transaction prior to when the LOB was selected.</p>
</li>
<li>
<p>A writable locator is updated with the latest data from the database each time a write is made through the locator. So each write is made to the most current data of the LOB, including updates that have been made through other locators.</p>
</li>
</ul>
<p>The following example details behavior for two writable locators for the same LOB:</p>
<ol>
<li>
<p>The LOB column contains &#34;XY&#34;.</p>
</li>
<li>
<p>Select locator <code>L1</code> for update.</p>
</li>
<li>
<p>Select locator <code>L2</code> for update.</p>
</li>
<li>
<p>Write &#34;Z&#34; through <code>L1</code> at offset 1.</p>
</li>
<li>
<p>Read through locator <code>L1</code>. This would return &#34;ZY&#34;.</p>
</li>
<li>
<p>Read through locator <code>L2</code>. This would return &#34;XY&#34;, because <code>L2</code> remains read-consistent until it is used for a write.</p>
</li>
<li>
<p>Write &#34;W&#34; through <code>L2</code> at offset 2.</p>
</li>
<li>
<p>Read through locator <code>L2</code>. This would return &#34;ZW&#34;. Prior to the write in the preceding step, the locator was updated with the latest data (&#34;ZY&#34;).</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="CEGEHJHJ"></a><a id="TTPLS401"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Temporary LOBs</h4>
<p>A PL/SQL block can create a temporary LOB explicitly, for it own use. In TimesTen, the lifetime of such a LOB does not extend past the end of the transaction in which it is created (as is the case with the lifetime of any LOB locator in TimesTen).</p>
<p>A temporary LOB may also be created implicitly by TimesTen. For example, if a <code>SELECT</code> statement selects a LOB concatenated with an additional string of characters, TimesTen implicitly creates a temporary LOB to contain the concatenated data. Note that a temporary LOB is a server-side object. TimesTen has no concept of client-side LOBs.</p>
<p>Temporary LOBs are stored in the TimesTen temporary data region.</p>
<p>See <a class="olink TTPLP66665" href="../TTPLP/d_lob.htm#TTPLP66665">&#34;CREATETEMPORARY procedures&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database PL/SQL Packages Reference</span> for how to create temporary LOBs.</p>
</div>
<!-- class="sect3" -->
<a id="CEGJJIBB"></a><a id="TTPLS372"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Differences between TimesTen LOBs and Oracle Database LOBs</h4>
<p>Be aware of the following:</p>
<ul>
<li>
<p>A key difference between the TimesTen LOB implementation and the Oracle Database implementation is that in TimesTen, LOB locators do not remain valid past the end of the transaction. All LOB locators are invalidated after a commit or rollback, whether explicit or implicit. This includes after any DDL statement if TimesTen <code>DDLCommitBehavior</code> is set to 0 (the default), for Oracle Database behavior, which is always the case for PL/SQL users.</p>
</li>
<li>
<p>TimesTen does not support BFILEs, SecureFiles, array reads and writes for LOBs, or callback functions for LOBs.</p>
</li>
<li>
<p>In TimesTen, the <code>DBMS_LOB</code> <code>FRAGMENT</code> procedures are not supported, so you can write data into the middle of a LOB only by overwriting previous data. There is no functionality to insert data into the middle of a LOB and move previous data, beginning at that point, higher in the LOB correspondingly. Similarly, in TimesTen you can delete data from the middle of a LOB only by overwriting previous data with zeros or null data. There is no functionality to remove data from the middle of a LOB and move previous data, beginning at that point, lower in the LOB correspondingly. In either case in TimesTen, the size of the LOB does not change, except in the circumstance where from the specified offset there is less space available in the LOB than there is data to write. (In Oracle Database there is functionality for either mode, either overwriting and not changing the size of the LOB, or inserting or deleting and changing the size of the LOB.)</p>
</li>
<li>
<p>TimesTen does not support binding arrays of LOBs.</p>
</li>
<li>
<p>TimesTen does not support batch processing of LOBs.</p>
</li>
<li>
<p>Relevant to BLOBs, there are differences in the usage of hexadecimal literals in TimesTen. See the description of <code><span class="codeinlineitalic">HexadecimalLiteral</span></code> in <a class="olink TTSQL202" href="../TTSQL/express.htm#TTSQL202">&#34;Constants&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CEGEAJGC"></a><a id="TTPLS374"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using LOBs</h4>
<p>The following shows basic use of a CLOB. Assume a table defined and populated as follows, with a <code>BLOB</code> column (not used here) and a <code>CLOB</code> column:</p>
<pre>Command&gt; create table t1 (a int, b blob, c clob);
Command&gt; insert into t1(a,b,c) values(1, 0x123451234554321, &#39;abcde&#39;);
1 row inserted.
Command&gt; commit;
</pre>
<p>Select a CLOB from the table and display it:</p>
<pre>Command&gt; declare
       &gt;    myclob clob;
       &gt; begin
       &gt;    select c into myclob from t1 where a=1;
       &gt;    dbms_output.put_line(&#39;CLOB selected from table t1 is: &#39; || myclob);
       &gt; end;
       &gt; /
CLOB selected from table t1 is: abcde
 
PL/SQL procedure successfully completed.
</pre>
<p>The following tries to display the temporary CLOB again after a <code>commit</code> statement has ended the transaction, showing that the LOB locator becomes invalid from that point:</p>
<pre>Command&gt; declare
       &gt;    myclob clob;
       &gt; begin
       &gt;    select c into myclob from t1 where a=1;
       &gt;    dbms_output.put_line(&#39;CLOB selected from table t1 is: &#39; || myclob);
       &gt;    commit;
       &gt;    dbms_output.put_line(&#39;CLOB after end of transaction is: &#39; || myclob);
       &gt; end;
       &gt; /
 1806: invalid LOB locator specified
 8507: ORA-06512: at line 8
CLOB selected from table t1 is: abcde
The command failed.
</pre></div>
<!-- class="sect3" -->
<a id="CEGEAHIG"></a><a id="TTPLS375"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">PL/SQL package support for LOBs</h4>
<p>TimesTen supports subprograms of the <code>DBMS_LOB</code> package for manipulation of LOB data.</p>
<p>See <a href="package.htm#CHDHJHDA">&#34;DBMS_LOB&#34;</a> in this document for a list and descriptions of these subprograms. See <a class="olink TTPLP600" href="../TTPLP/d_lob.htm#TTPLP600">&#34;DBMS_LOB&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database PL/SQL Packages Reference</span> for further information.</p>
</div>
<!-- class="sect3" -->
<a id="CEGEHJBC"></a><a id="TTPLS376"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Passthrough LOBs</h4>
<p>Passthrough LOBs, which are LOBs in Oracle Database accessed through TimesTen, are exposed as TimesTen LOBs and are supported by TimesTen in much the same way that any TimesTen LOB is supported, but note the following:</p>
<ul>
<li>
<p>TimesTen LOB size limitations do not apply to storage of passthrough LOBs, but do apply to binding. Also, if a passthrough LOB is copied to a TimesTen LOB, such as through <code>DBMS_LOB.COPY</code>, the size limit applies to the copy.</p>
<p>An attempt to copy a passthrough LOB to a TimesTen LOB when the passthrough LOB is larger than the TimesTen LOB size limit results in an error.</p>
</li>
<li>
<p>As with TimesTen local LOBs, a locator for a passthrough LOB does not remain valid past the end of the transaction.</p>
</li>
</ul>
<p>See <a href="package.htm#CHDHJHDA">&#34;DBMS_LOB&#34;</a> in this document for information about <code>DBMS_LOB</code> support for passthrough LOBs.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGBAJBJ"></a><a id="TTPLS149"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Use of c<a id="sthref81"></a>ursors in PL/SQL programs</h2>
<p>A cursor, either explicit or implicit, is used to handle the result set of a <code>SELECT</code> statement. As a programmer, you can declare an explicit cursor to manage queries that return multiple rows of data. PL/SQL declares and opens an implicit cursor for any <code>SELECT</code> statement that is not associated with an explicit cursor.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
Be aware that in TimesTen, any operation that ends your transaction closes all cursors associated with the connection. This includes any <code>COMMIT</code> or <code>ROLLBACK</code> statement. This also includes any DDL statement executed when PL/SQL is enabled, because the <code>DDLCommitBehavior</code> connection must be set to 0 (Oracle Database behavior) if PL/SQL is enabled. This results in autocommits of DDL statements. See <a href="#CEGFEIHJ">&#34;Differences in TimesTen: transaction behavior&#34;</a> for additional information.</div>
<p><a href="#CEGEIHJC">Example 2-13</a> shows basic use of a cursor. See <a href="sqlexamples.htm#CHDJGBGD">&#34;Examples using cursors&#34;</a> for additional information and examples. Also see <a href="dtypesfunc.htm#CIJDIGEB">&#34;PL/SQL REF CURSORs&#34;</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CEGEIHJC"></a><a id="TTPLS150"></a>Example 2-13 Using a cursor to retrieve information about an employee</p>
<p>Declare a cursor <code>c1</code> to retrieve the last name, salary, hire date, and job class for the employee whose employee ID is 120.</p>
<pre>Command&gt; DECLARE
       &gt;   CURSOR c1 IS
       &gt;     SELECT last_name, salary, hire_date, job_id FROM employees
       &gt;     WHERE employee_id = 120;
       &gt; --declare record variable that represents a row
       &gt; --fetched from the employees table
       &gt;   employee_rec c1%ROWTYPE;
       &gt; BEGIN
       &gt; -- open the explicit cursor
       &gt; -- and use it to fetch data into employee_rec
       &gt;   OPEN c1;
       &gt;   FETCH c1 INTO employee_rec;
       &gt;   DBMS_OUTPUT.PUT_LINE(&#39;Employee name: &#39; || employee_rec.last_name);
       &gt;   CLOSE c1;
       &gt; END;
       &gt; /
Employee name: Weiss
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="CEGFFEGG"></a><a id="TTPLS151"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">PL<a id="sthref82"></a><a id="sthref83"></a><a id="sthref84"></a><a id="sthref85"></a><a id="sthref86"></a><a id="sthref87"></a>/SQL procedures and functions</h2>
<p>Procedures and functions are PL/SQL blocks that have been defined with a specified name.</p>
<a id="TTPLS345"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref88"></a>
<h3 class="sect2">Creating and using procedures and functions</h3>
<p>Standalone subprograms (stored procedures or functions) are created at the database level with the <code>CREATE PROCEDURE</code> or <code>CREATE FUNCTION</code> statement.</p>
<p>Optionally use <code>CREATE OR REPLACE PROCEDURE</code> or <code>CREATE OR REPLACE FUNCTION</code> if you want the subprogram to be replaced if it already exists.</p>
<p>Use <code>ALTER PROCEDURE</code> or <code>ALTER FUNCTION</code> to explicitly compile a procedure or function or modify the compilation options. (To recompile a procedure or function that is part of a package, recompile the package using the <code>ALTER PACKAGE</code> statement.)</p>
<p>In TimesTen, syntax for <code>CREATE PROCEDURE</code> and <code>CREATE FUNCTION</code> is a subset of what is supported in Oracle Database. For information on these statements and the <code>ALTER PROCEDURE</code> and <code>ALTER FUNCTION</code> statements in TimesTen, see <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>Also see <a href="#CEGJHBFA">&#34;How to execute PL/SQL procedures and functions&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>I<a id="sthref89"></a>f you use replication: PL/SQL DDL statements, such as <code>CREATE</code> statements for PL/SQL functions, procedures, and packages, are not replicated. See <a class="olink TTREP744" href="../TTREP/alterpair.htm#TTREP744">&#34;Creating a new PL/SQL object in an existing active standby pair&#34;</a> and <a class="olink TTREP745" href="../TTREP/alter.htm#TTREP745">&#34;Adding a PL/SQL object to an existing replication scheme&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Replication Guide</span> for steps to address this.</p>
</li>
<li>
<p>If you use TimesTen Cache: A PL/SQL procedure or function resident in Oracle Database cannot be called in TimesTen by passthrough. Procedures and functions must be defined in TimesTen to be executable in TimesTen. (Also see <a href="#CEGHJDFD">&#34;TimesTen PL/SQL with TimesTen Cache&#34;</a>.)</p>
</li>
<li>
<p>PL/SQL and database object names: TimesTen does not support non-ASCII or quoted non-uppercase names of PL/SQL objects (procedures, functions, and packages). Also, trailing spaces in the quoted names of PL/SQL objects are not supported. In addition, trailing spaces in the quoted names of objects such as tables and views that are passed to PL/SQL are silently removed.</p>
</li>
<li>
<p>Definer&#39;s rights or invoker&#39;s rights determines access to SQL objects used by a PL/SQL procedure or function. For information, refer to <a href="accesscntl.htm#BABDDCHC">&#34;Definer&#39;s rights and invoker&#39;s rights&#34;</a>.</p>
</li>
<li>
<p>See <a href="exceptions.htm#BABEFAHA">&#34;Showing errors in ttIsql&#34;</a> for how to get information when you encounter errors in compiling a procedure or function.</p>
</li>
</ul>
</div>
<div class="example">
<p class="titleinexample"><a id="TTPLS346"></a><a id="sthref90"></a>Example 2-14 Create and execute a procedure with OUT parameters</p>
<p>This example creates a procedure that uses <code>OUT</code> parameters, executes the procedure in an anonymous block, then displays the <code>OUT</code> values. The procedure takes an employee ID as input then outputs the salary and job ID for the employee.</p>
<pre>Command&gt;  CREATE OR REPLACE PROCEDURE get_employee
       &gt;    (p_empid in employees.employee_id%TYPE,
       &gt;     p_sal OUT employees.salary%TYPE,
       &gt;     p_job OUT employees.job_id%TYPE) IS
       &gt; BEGIN
       &gt;   SELECT salary,job_id
       &gt;   INTO p_sal, p_job
       &gt;   FROM employees
       &gt;   WHERE employee_id = p_empid;
       &gt; END;
       &gt; /
 
Procedure created.
 
Command&gt; VARIABLE v_salary NUMBER;
Command&gt; VARIABLE v_job VARCHAR2(15);
Command&gt; BEGIN
       &gt;   GET_EMPLOYEE (120, :v_salary, :v_job);
       &gt; END;
       &gt; /
 
PL/SQL procedure successfully completed.
 
Command&gt; PRINT
V_SALARY             : 8000
V_JOB                : ST_MAN

Command&gt; SELECT salary, job_id FROM employees WHERE employee_id = 120;
&lt; 8000, ST_MAN &gt;
1 row found.
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Instead of using the anonymous block shown in the preceding example, you could use a <code>CALL</code> statement:
<pre>Command&gt; CALL GET_EMPLOYEE(120, :v_salary, :v_job);
</pre></div>
<div class="example">
<p class="titleinexample"><a id="TTPLS344"></a><a id="sthref91"></a>Example 2-15 Create and call a function</p>
<p>This example creates a function that returns the salary of the employee whose employee ID is specified as input, then calls the function and displays the result that was returned.</p>
<pre>Command&gt; CREATE OR REPLACE FUNCTION get_sal
       &gt;   (p_id employees.employee_id%TYPE) RETURN NUMBER IS
       &gt;    v_sal employees.salary%TYPE := 0;
       &gt; BEGIN
       &gt;   SELECT salary INTO v_sal FROM employees
       &gt;     WHERE employee_id = p_id;
       &gt;   RETURN v_sal;
       &gt; END get_sal;
       &gt; /
 
Function created.
 
Command&gt; variable n number;
Command&gt; call get_sal(100) into :n;
Command&gt; print n;
N                    : 24000
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Instead of using the <code>CALL</code> statement shown in the preceding example, you could use an anonymous block:
<pre>Command&gt; begin
       &gt;   :n := get_sal(100);
       &gt; end;
       &gt; /
</pre></div>
</div>
<!-- class="sect2" -->
<a id="CEGBFIFD"></a><a id="TTPLS347"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using s<a id="sthref92"></a>ynonyms for procedures and functions</h3>
<p>TimesTen supports private and public synonyms (aliases) for database objects, including PL/SQL procedures, functions, and packages. Synonyms are often used to mask object names and object owners or to simplify SQL statements.</p>
<p>Create a private synonym for procedure <code>foo</code> in your schema as follows:</p>
<pre>CREATE SYNONYM synfoo FOR foo;
</pre>
<p>Create a public synonym as follows:</p>
<pre>CREATE PUBLIC SYNONYM pubfoo FOR foo;
</pre>
<p>A private synonym exists in the schema of a specific user and shares the same namespace as database objects such as tables, views, and sequences. A private synonym cannot have the same name as a table or other object in the same schema.</p>
<p>A public synonym does not belong to any particular schema, is accessible to all users, and can have the same name as any private object.</p>
<p>To use a synonym you must have appropriate privileges to access the underlying object. For required privileges to create or drop a synonym, see <a href="accesscntl.htm#BABJGFDE">&#34;Required privileges for PL/SQL statements and operations&#34;</a>.</p>
<p>For general information about synonyms, see <a class="olink TTOPR674" href="../TTOPR/comp.htm#TTOPR674">&#34;Understanding synonyms&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>. For information about the <code>CREATE SYNONYM</code> and <code>DROP SYNONYM</code> statements, see <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<div class="example">
<p class="titleinexample"><a id="CEGDGFAJ"></a><a id="TTPLS348"></a>Example 2-16 Use a synonym for a procedure</p>
<p>In the following example, <code>USER1</code> creates a procedure in his schema and creates a public synonym for it. Then <code>USER2</code> executes the procedure through the public synonym. Assume the following:</p>
<ul>
<li>
<p><code>USER1</code> has been granted <code>CREATE SESSION</code>, <code>CREATE PROCEDURE</code>, and <code>CREATE PUBLIC SYNONYM</code> privileges.</p>
</li>
<li>
<p><code>USER2</code> has been granted <code>CREATE SESSION</code> and <code>EXECUTE ANY PROCEDURE</code> privileges.</p>
</li>
<li>
<p>Both users have connected to the database.</p>
</li>
<li>
<p><code>USER2</code> employs the <code>SET SERVEROUTPUT ON</code> setting.</p>
</li>
</ul>
<p><span class="bold">USER1</span>:</p>
<pre>Command&gt; create or replace procedure test is
       &gt; begin
       &gt; dbms_output.put_line(&#39;Running the test&#39;);
       &gt; end;
       &gt; /
 
Procedure created.
 
Command&gt; create public synonym pubtest for test;
 
Synonym created.
</pre>
<p><span class="bold">USER2</span>:</p>
<pre>Command&gt; begin
       &gt; pubtest;
       &gt; end;
       &gt; /
Running the test
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGFFDBF"></a><a id="TTPLS153"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">PL/SQL packages</h2>
<p>This section discusses how to create and use PL/SQL packages.</p>
<p>For information about PL/SQL packages provided with TimesTen, refer to <a href="package.htm#CDECFEID">Chapter 8, &#34;TimesTen Supplied PL/SQL Packages.&#34;</a></p>
<a id="TTPLS154"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref93"></a>
<h3 class="sect2">Package concepts<a id="sthref94"></a></h3>
<p>A package is a database object that groups logically related PL/SQL types, variables, and subprograms. You specify the package and then define its body in separate steps.</p>
<p>The package specification is the interface to the package, declaring the public types, variables, constants, exceptions, cursors, and subprograms that are visible outside the immediate scope of the package. The body defines the objects declared in the specification, as well as queries for the cursors, code for the subprograms, and private objects that are not visible to applications outside the package.</p>
<p>TimesTen stores the package specification separately from the package body in the database. Other schema objects that call or reference public program objects depend only on the package specification, not on the package body.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The syntax for creating packages and package bodies is the same as in Oracle Database; however, while Oracle Database documentation mentions that you must run a script named <code>DBMSSTDX.SQL</code>, this does not apply to TimesTen.</div>
</div>
<!-- class="sect2" -->
<a id="TTPLS155"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref95"></a>
<h3 class="sect2">Creating and using packages<a id="sthref96"></a></h3>
<p>To create packages and store them permanently in the database, use the <code>CREATE PACKAGE</code> and <code>CREATE PACKAGE BODY</code> statements.</p>
<p>To create a new package, do the following:</p>
<ol>
<li>
<p>Create the package specification with the <code>CREATE PACKAGE</code> statement.</p>
<p>You can d<a id="sthref97"></a>eclare program objects in the package specification. Such objects are referred to as <span class="italic">public</span> objects and can be referenced outside the package, and by other objects in the package.</p>
<p>Optionally use <code>CREATE OR REPLACE PACKAGE</code> if you want the package specification to be replaced if it already exists.</p>
</li>
<li>
<p>Create the package body with the <code>CREATE PACKAGE BODY</code> (or <code>CREATE OR REPLACE PACKAGE BODY</code>) statement.</p>
<p>You can declare and define program objects in the package body.</p>
<ul>
<li>
<p>You must define public objects declared in the package specification.</p>
</li>
<li>
<p>You can declare and define additional package objects, referred to as <span class="italic">private</span> objects. Private objects are declared in the package body rather than in the package specification, so they can be referenced only by other objects in the package. They cannot be referenced outside the package.</p>
</li>
</ul>
</li>
</ol>
<p>Use <code>ALTER PACKAGE</code> to explicitly compile the member procedures and functions of a package or modify the compilation options.</p>
<p>For more information on the <code>CREATE PACKAGE</code>, <code>CREATE PACKAGE BODY</code>, and <code>ALTER PACKAGE</code> statements, see <a class="olink TTSQL277" href="../TTSQL/state.htm#TTSQL277">&#34;SQL Statements&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>If you use replication: PL/SQL DDL statements, such as <code>CREATE</code> statements for PL/SQL functions, procedures, and packages, are not replicated. See <a class="olink TTREP744" href="../TTREP/alterpair.htm#TTREP744">&#34;Creating a new PL/SQL object in an existing active standby pair&#34;</a> and <a class="olink TTREP745" href="../TTREP/alter.htm#TTREP745">&#34;Adding a PL/SQL object to an existing replication scheme&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Replication Guide</span> for steps to address this.</p>
</li>
<li>
<p>See <a href="exceptions.htm#BABEFAHA">&#34;Showing errors in ttIsql&#34;</a> for how to get information when you encounter errors in compiling a package.</p>
</li>
</ul>
</div>
<div class="example">
<p class="titleinexample"><a id="CEGGCJFC"></a><a id="TTPLS156"></a>Example 2-17 Create and use a package</p>
<p>Consider the case where you want to add a row to the employees tables when you hire a new employee and delete a row from the employees table when an employee leaves your company. The following example creates two procedures to accomplish these tasks and bundles the procedures in a package. The package also contains a function to return the count of employees with a salary greater than that of a specific employee. The example then executes the function and procedures and verifies the results.</p>
<pre>Command&gt; CREATE OR REPLACE PACKAGE emp_actions AS
       &gt;   PROCEDURE hire_employee (employee_id NUMBER,
       &gt;     last_name VARCHAR2,
       &gt;     first_name VARCHAR2,
       &gt;     email VARCHAR2,
       &gt;     phone_number VARCHAR2,
       &gt;     hire_date DATE,
       &gt;     job_id VARCHAR2,
       &gt;     salary NUMBER,
       &gt;     commission_pct NUMBER,
       &gt;     manager_id NUMBER,
       &gt;     department_id NUMBER);
       &gt;   PROCEDURE remove_employee (emp_id NUMBER);
       &gt;   FUNCTION num_above_salary (emp_id NUMBER) RETURN NUMBER;
       &gt; END emp_actions;
       &gt; /
 
Package created.
 
Command&gt; -- Package body:
       &gt; CREATE OR REPLACE PACKAGE BODY emp_actions AS
       &gt; -- Code for procedure hire_employee:
       &gt;   PROCEDURE hire_employee (employee_id NUMBER,
       &gt;     last_name VARCHAR2,
       &gt;     first_name VARCHAR2,
       &gt;     email VARCHAR2,
       &gt;     phone_number VARCHAR2,
       &gt;     hire_date DATE,
       &gt;     job_id VARCHAR2,
       &gt;     salary NUMBER,
       &gt;     commission_pct NUMBER,
       &gt;     manager_id NUMBER,
       &gt;     department_id NUMBER) IS
       &gt;   BEGIN
       &gt;     INSERT INTO employees VALUES (employee_id,
       &gt;       last_name,
       &gt;       first_name,
       &gt;       email,
       &gt;       phone_number,
       &gt;       hire_date,
       &gt;       job_id,
       &gt;       salary,
       &gt;       commission_pct,
       &gt;       manager_id,
       &gt;       department_id);
       &gt;   END hire_employee;
       &gt; -- Code for procedure remove_employee:
       &gt;   PROCEDURE remove_employee (emp_id NUMBER) IS
       &gt;   BEGIN
       &gt;     DELETE FROM employees WHERE employee_id = emp_id;
       &gt;   END remove_employee;
       &gt; -- Code for function num_above_salary:
       &gt;   FUNCTION num_above_salary (emp_id NUMBER) RETURN NUMBER IS
       &gt;     emp_sal NUMBER(8,2);
       &gt;     num_count NUMBER;
       &gt;   BEGIN
       &gt;     SELECT salary INTO emp_sal FROM employees
       &gt;     WHERE employee_id = emp_id;
       &gt;     SELECT COUNT(*) INTO num_count FROM employees
       &gt;     WHERE salary &gt; emp_sal;
       &gt;     RETURN num_count;
       &gt;   END num_above_salary;
       &gt; END emp_actions;
       &gt; /
 
Package body created.
 
Command&gt; BEGIN
       &gt; /* call function to return count of employees with salary
       &gt;    greater than salary of employee with employee_id = 120
       &gt; */
       &gt;   DBMS_OUTPUT.PUT_LINE
       &gt;     (&#39;Number of employees with higher salary: &#39; ||
       &gt;       TO_CHAR(emp_actions.num_above_salary(120)));
       &gt; END;
       &gt; /
Number of employees with higher salary: 33
 
PL/SQL procedure successfully completed.
</pre>
<p>Verify the count of 33.</p>
<pre>Command&gt; SELECT salary FROM employees WHERE employee_id = 120;
&lt; 8000 &gt;
1 row found.

Command&gt; SELECT COUNT (*) FROM employees WHERE salary &gt; 8000;
&lt; 33 &gt;
1 row found.
</pre>
<p>Now add an employee and verify results. Then, remove the employee and verify that the employee was deleted from the <code>employees</code> table.</p>
<pre>Command&gt; BEGIN 
       &gt;   emp_actions.hire_employee(300,
       &gt;     &#39;Belden&#39;,
       &gt;     &#39;Enrique&#39;,
       &gt;     &#39;EBELDEN&#39;,
       &gt;     &#39;555.111.2222&#39;,
       &gt;     &#39;31-AUG-04&#39;,
       &gt;     &#39;AC_MGR&#39;,
       &gt;     9000,
       &gt;     .1,
       &gt;     101,
       &gt;     110);
       &gt; END;
       &gt; /
 
PL/SQL procedure successfully completed.
 
Command&gt; SELECT * FROM employees WHERE employee_id = 300;
&lt; 300, Belden, Enrique, EBELDEN, 555.111.2222, 2004-08-31 00:00:00, AC_MGR, 9000, 
.1, 101, 110 &gt;
1 row found.
Command&gt; BEGIN
       &gt;   emp_actions.remove_employee (300);
       &gt; END;
       &gt; /
 
PL/SQL procedure successfully completed.
 
Command&gt; SELECT * FROM employees WHERE employee_id = 300;
0 rows found.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="TTPLS349"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref98"></a>
<h3 class="sect2">Using s<a id="sthref99"></a>ynonyms for packages</h3>
<p>TimesTen supports private and public synonyms (aliases) for database objects, including PL/SQL procedures, functions, and packages. Synonyms are often used to mask object names and object owners or to simplify SQL statements.</p>
<p>To create a private synonym for package <code>foopkg</code> in your schema:</p>
<pre>CREATE SYNONYM synfoopkg FOR foopkg;
</pre>
<p>To create a public synonym for <code>foopkg</code>:</p>
<pre>CREATE PUBLIC SYNONYM pubfoopkg FOR foopkg;
</pre>
<p>Also see <a href="#CEGBFIFD">&#34;Using synonyms for procedures and functions&#34;</a> and <a href="accesscntl.htm#BABJGFDE">&#34;Required privileges for PL/SQL statements and operations&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot create synonyms for individual member subprograms of a package.
<p>This is valid:</p>
<pre>create or replace public synonym pubtestpkg for testpkg;
</pre>
<p>This is not valid:</p>
<pre>create or replace public synonym pubtestproc for testpkg.testproc;
</pre></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJAFJHGG"></a><a id="TTPLS157"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Wrap<a id="sthref100"></a>ping PL/SQL source code</h2>
<p><span class="italic">Wrapping</span> is the process of hiding PL/SQL source code. You can wrap PL/SQL source code with the <code>wrap</code> utility, which processes an input SQL file and wraps only the PL/SQL units in the file, such as a package specifications, package bodies, functions, and procedures.</p>
<p>Consider the following example, which uses a file <code>wrap_test.sql</code> to define a procedure named <code>wraptest</code>. It then uses the <code>wrap</code> utility to process <code>wrap_test.sql</code>. The procedure is created with the source code hidden, and executes successfully. As a final step, the <code>ALL_OBJECTS</code> view is queried to see the wrapped source code.</p>
<p>Here are the contents of <code>wrap_test.sql</code>:</p>
<pre>CREATE OR REPLACE PROCEDURE wraptest IS
   TYPE emp_tab IS TABLE OF employees%ROWTYPE INDEX BY PLS_INTEGER;
   all_emps emp_tab;
BEGIN
   SELECT * BULK COLLECT INTO all_emps FROM employees;
   FOR i IN 1..10
      LOOP
         DBMS_OUTPUT.PUT_LINE(&#39;Emp Id: &#39; || all_emps(i).employee_id);
      END LOOP;
END;
/
</pre>
<p>In the example that follows, &#34;<code>$</code>&#34; is the UNIX prompt, &#34;<code>Command&gt;</code>&#34; is the <code>ttIsql</code> prompt, and user input is shown in bold.</p>
<pre>$ <span class="bold">wrap iname=wrap_test.sql</span>
 
PL/SQL Wrapper: Release 11.2.0.2.0- Production on Wed Sep 14 12:59:27 2011
 
Copyright (c) 1993, 2009, Oracle.  All rights reserved.
 
Processing wrap_test.sql to wrap_test.plb
 
$ <span class="bold">cat wrap_test.plb</span>
CREATE OR REPLACE PROCEDURE wraptest wrapped
a000000
1
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
7
124 12c
YZ6L0v2ntFaqttW8hSJD5IHIYccwg+nwNfZqfHQCv/9kMJyznwdLh8FepNXpWS1fzVBDkTke
LWlhFdFzCMfmmJ5GGrCwrqgngEhfRpq7ck5Dzsf7sDlnQeE3QGmb/yu9Dec1+JO2kOMlx3dq
BuC7fR2f5sjDtBeDXiGCC0kJ5QBVregtoBckZNO9MoiWS4w0jF6T1CPY0Aoi/KUwxC8S8I8n
amF5xGQDCYTDajs77orIGEqtX747k0YAO+r1e9adGUsVgZK1ONcTM/+Wit+LYKi7b03eJxdB
+aaKn/Lh
 
/
 
$ <span class="bold">ttisql sampledb_1122</span>
 
Copyright (c) 1996-2011, Oracle.  All rights reserved.
Type ? or &#34;help&#34; for help, type &#34;exit&#34; to quit ttIsql.
 
connect &#34;DSN=sampledb_1122&#34;;
Connection successful:
DSN=sampledb_1122;UID=myuserid;DataStore=.../install/info/DemoDataStore/
sampledb_1122;DatabaseCharacterSet=US7ASCII;ConnectionCharacterSet=US7ASCII;DRIVER
=.../install/lib/libtten.so;PermSize=40;TempSize=32;TypeMode=0;
(Default setting AutoCommit=1)
 
Command&gt; <span class="bold">@wrap_test.plb</span>
 
CREATE OR REPLACE PROCEDURE wraptest wrapped
a000000
1
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
7
124 12c
YZ6L0v2ntFaqttW8hSJD5IHIYccwg+nwNfZqfHQCv/9kMJyznwdLh8FepNXpWS1fzVBDkTke
LWlhFdFzCMfmmJ5GGrCwrqgngEhfRpq7ck5Dzsf7sDlnQeE3QGmb/yu9Dec1+JO2kOMlx3dq
BuC7fR2f5sjDtBeDXiGCC0kJ5QBVregtoBckZNO9MoiWS4w0jF6T1CPY0Aoi/KUwxC8S8I8n
amF5xGQDCYTDajs77orIGEqtX747k0YAO+r1e9adGUsVgZK1ONcTM/+Wit+LYKi7b03eJxdB
+aaKn/Lh
 
Procedure created.
 
Command&gt; <span class="bold">SET SERVEROUTPUT ON</span>
Command&gt; <span class="bold">BEGIN</span>
       &gt;    <span class="bold">wraptest();</span>
       &gt; <span class="bold">END;</span>
       &gt; <span class="bold">/</span>
Emp Id: 100
Emp Id: 101
Emp Id: 102
Emp Id: 103
Emp Id: 104
Emp Id: 105
Emp Id: 106
Emp Id: 107
Emp Id: 108
Emp Id: 109
 
PL/SQL procedure successfully completed.
 
Command&gt; <span class="bold">SELECT text FROM all_source WHERE name = &#39;WRAPTEST&#39;;</span>

&lt; PROCEDURE wraptest wrapped
a000000
1
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
7
124 12c
YZ6L0v2ntFaqttW8hSJD5IHIYccwg+nwNfZqfHQCv/9kMJyznwdLh8FepNXpWS1fzVBDkTke
LWlhFdFzCMfmmJ5GGrCwrqgngEhfRpq7ck5Dzsf7sDlnQeE3QGmb/yu9Dec1+JO2kOMlx3dq
BuC7fR2f5sjDtBeDXiGCC0kJ5QBVregtoBckZNO9MoiWS4w0jF6T1CPY0Aoi/KUwxC8S8I8n
amF5xGQDCYTDajs77orIGEqtX747k0YAO+r1e9adGUsVgZK1ONcTM/+Wit+LYKi7b03eJxdB
+aaKn/Lh
 
 &gt;
1 row found.
</pre></div>
<!-- class="sect1" -->
<a id="CEGFEIHJ"></a><a id="TTPLS158"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Differences in TimesTen: tr<a id="sthref101"></a><a id="sthref102"></a><a id="sthref103"></a>ansaction behavior</h2>
<p>In TimesTen, any operation that ends your transaction closes all cursors associated with the connection. This includes the following:</p>
<ul>
<li>
<p>Any <code>COMMIT</code> or <code>ROLLBACK</code> statement</p>
</li>
<li>
<p>For PL/SQL users, any DDL statement</p>
<p>This is because when PL/SQL is enabled (the <code>PLSQL</code> first connection attribute is set to 1), the TimesTen <code>DDLCommitBehavior</code> general connection attribute must be set to 0 for Oracle Database behavior (autocommit DDL).</p>
</li>
</ul>
<p>For example, consider the following scenario, where you want to recompile a set of procedures. This would not work, because the first time <code>ALTER PROCEDURE</code> is executed, the cursor (<code>pnamecurs</code>) would be closed:</p>
<pre>declare
   cursor pnamecurs is select * from all_objects where object_name like &#39;MYPROC%&#39;;
begin
   for rec in pnamecurs loop
     execute immediate &#39;alter procedure &#39; || rec.object_name || &#39; compile&#39;;
   end loop;
end;
</pre>
<p>Instead, you can do something like the following, which fetches all the procedure names into an internal table then executes <code>ALTER PROCEDURE</code> on them with no active cursor.</p>
<pre>declare
   cursor pnamecurs is select * from all_objects where object_name like &#39;MYPROC%&#39;;
   type tbl is table of c%rowtype index by binary_integer;
   myprocs tbl;

begin
   open pnamecurs;
   fetch pnamecurs bulk collect into myprocs;
   close pnamecurs;
   for i in 1..myprocs.count loop
     execute immediate &#39;alter procedure &#39; || myprocs(i).object_name || &#39; compile&#39;;
   end loop;
end;
</pre></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment6337">
<tr>
<td class="cellalignment6344">
<table class="cellalignment6348">
<tr>
<td class="cellalignment6341"><a href="intro.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment6341"><a href="dtypesfunc.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment6346">
<table class="cellalignment6347">
<tr>
<td class="cellalignment6341"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment6341"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment6341"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment6341"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment6341"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment6341"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>