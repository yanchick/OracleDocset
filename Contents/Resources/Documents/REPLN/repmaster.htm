<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-91723"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Master%20Replication%20Concepts%20and%20Architecture"></a><title>Master Replication Concepts and Architecture</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1042"/>
<meta name="dcterms.created" content="2015-02-06T8:21:52Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Advanced Replication"/>
<meta name="dcterms.identifier" content="E53117-02"/>
<meta name="dcterms.isVersionOf" content="REPLN"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="repoverview.htm" title="Previous" type="text/html"/>
<link rel="Next" href="repmview.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53117-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/15</span> <!-- End Header -->
<div id="REPLN002" class="chapter"><a id="g72661"></a> <a id="i43908"></a>
<h1 class="chapter"><span class="secnum">2</span> Master Replication Concepts and Architecture</h1>
<p><a id="sthref114"></a><a id="sthref115"></a>This chapter explains the concepts and architecture of Oracle&#39;s master replication sites in both single master and multimaster replication environments.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i33520">Master Replication Concepts</a></p>
</li>
<li>
<p><a href="#i32372">Master Replication Architecture</a></p>
</li>
</ul>
<a id="i33520"></a>
<div id="REPLN166" class="sect1">
<h2 class="sect1">Master Replication Concepts<a id="sthref116"></a></h2>
<p>To understand the architectural details of master replication, you must understand the concepts of master replication. Knowing how and why replication is used provides you with a greater understanding of how the individual architectural elements work together to create a multimaster replication environment.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#BGBHCCDJ">What is Master Replication?</a></p>
</li>
<li>
<p><a href="#BGBGBHFE">Why Use Multimaster Replication?</a></p>
</li>
<li>
<p><a href="#BGBCIEGH">Multimaster Replication Process</a></p>
</li>
<li>
<p><a href="#i33607">Conflict Resolution Concepts</a></p>
</li>
<li>
<p><a href="#i40503">How Replication Works with Object Types and Collections</a></p>
</li>
</ul>
<a id="BGBHCCDJ"></a>
<div id="REPLN167" class="sect2">
<h3 class="sect2">What is Master Replication?</h3>
<p>Oracle has two types of master replication: single master replication and multimaster replication. Multimaster replication includes multiple master sites, where each master site operates as an equal peer. In single master replication, a single master site supporting materialized view replication provides the mechanisms to support potentially hundreds or thousands of materialized view sites. A single master site that supports one or more materialized view sites can also participate in a multiple master site environment, creating a hybrid replication environment (combination of multimaster and materialized view replication).</p>
<p>Materialized views can be based on master tables at master sites or on materialized views at materialized view sites. When materialized views are based on materialized views, you have a multitier materialized view environment. In such an environment, materialized views that have other materialized views based on them are called master materialized views.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repmview.htm#i34980">Chapter 3, &#34;Materialized View Concepts and Architecture&#34;</a> for more information about multitier materialized views</div>
<div id="REPLN168" class="sect3"><a id="sthref117"></a>
<h4 class="sect3">Multimaster Replication</h4>
<p>Multimaster replication, also known as peer-to-peer or <span class="italic">n</span>-way replication, consists of multiple master sites equally participating in an update-anywhere model. Updates made to an individual master site are propagated (sent) to all other participating master sites. <a href="#i43116">Figure 2-1</a> illustrates a multimaster replication system.</p>
<p>Oracle database servers operating as master sites in a multimaster replication environment automatically work to converge the data of all table replicas, and ensure global transaction consistency and data integrity. Conflict resolution is independently handled at each of the master sites. Multimaster replication provides complete replicas of each replicated table at each of the master sites.</p>
<p>If the replication environment is a hybrid environment (it has multiple master sites supporting one or more materialized view sites), then the target master site propagates any of the materialized view updates to all other master sites in the multimaster replication environment. Then each master site propagates changes to their materialized views when the materialized views refresh.</p>
<div id="REPLN169" class="figure">
<p class="titleinfigure"><a id="i43116"></a>Figure 2-1 Multimaster Replication</p>
<img width="600" height="296" src="img/repln001.gif" alt="Description of Figure 2-1 follows"/><br/>
<a id="sthref118" href="img_text/repln001.htm">Description of &#34;Figure 2-1 Multimaster Replication&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<div id="REPLN170" class="sect3"><a id="sthref119"></a>
<h4 class="sect3">Single Master Replication<a id="sthref120"></a></h4>
<p>A single master site can also function as the target master site for one or more materialized view sites. Unlike multimaster replication, where updates to a single site are propagated to all other master sites, materialized views update only their target master site.</p>
<p>Conflict resolution is handled only at master sites or master materialized view sites. Materialized view replication can contain complete or partial replicas of the replicated table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repmview.htm#i34980">Chapter 3, &#34;Materialized View Concepts and Architecture&#34;</a> for more information about materialized view replication with a master site</div>
</div>
<!-- class="sect3" -->
<div id="REPLN171" class="sect3"><a id="sthref121"></a>
<h4 class="sect3">Master Sites</h4>
<p>A master site can be both a node in a multimaster replication environment and the master for one or more materialized view sites in a single master or multimaster replication environment. The replicated objects are stored at the master site and are available for user access.</p>
<div id="REPLN172" class="sect4"><a id="sthref122"></a>
<h5 class="sect4">Master Definition Site<a id="sthref123"></a></h5>
<p>In a multimaster replication environment, one master site operates as the master definition site for a master group. This particular site performs many of the administrative and maintenance tasks for the multimaster replication environment.</p>
<p>Each master group can have only one master definition site, though the master definition site can be any of the master sites in the multimaster environment. Additionally, the master definition site can be changed to a different master site if necessary.</p>
<p>A single master site supporting materialized view replication is by default the master definition site.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBGBHFE"></a>
<div id="REPLN173" class="sect2">
<h3 class="sect2">Why Use Multimaster Replication?<a id="sthref124"></a></h3>
<p>From a very basic point of view, replication is used to ensure that data is available when and where you need it. The following sections describe several different environments that have different information delivery requirements. Your replication environment might have one or more of the following requirements.</p>
<div id="REPLN174" class="sect3"><a id="sthref125"></a>
<h4 class="sect3">Failover<a id="sthref126"></a></h4>
<p>Multimaster replication can protect the availability of a mission critical database. For example, a multimaster replication environment can replicate data in your database to establish a failover site should the primary site become unavailable due to system or network outages. Such a failover site can also serve as a fully functional database to support application access when the primary site is concurrently operational.</p>
<p>You can use Oracle Net to configure automatic connect-time failover, which enables Oracle Net to fail over to a different master site if the first master site fails. You configure automatic connect-time failover in your <code dir="ltr">tnsnames.ora</code> file by setting the <code dir="ltr">FAILOVER_MODE</code> parameter to <code dir="ltr">on</code> and specifying multiple connect descriptors.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NETAG013" href="../NETAG/advcfg.htm#NETAG013"><span class="italic">Oracle Database Net Services Administrator&#39;s Guide</span></a> for more information about configuring connect-time failover</div>
</div>
<!-- class="sect3" -->
<div id="REPLN175" class="sect3"><a id="sthref127"></a>
<h4 class="sect3">Load Balancing<a id="sthref128"></a></h4>
<p>Multimaster replication is useful for transaction processing applications that require multiple points of access to database information for the following purposes:</p>
<ul>
<li>
<p>Distributing a heavy application load</p>
</li>
<li>
<p>Ensuring continuous availability</p>
</li>
<li>
<p>Providing more localized data access</p>
</li>
</ul>
<p>Applications that have application load distribution requirements commonly include customer service oriented applications.</p>
<div id="REPLN176" class="figure">
<p class="titleinfigure"><a id="sthref129"></a>Figure 2-2 Multimaster Replication Supporting Multiple Points of Update Access</p>
<img width="600" height="288" src="img/repln055.gif" alt="Description of Figure 2-2 follows"/><br/>
<a id="sthref130" href="img_text/repln055.htm">Description of &#34;Figure 2-2 Multimaster Replication Supporting Multiple Points of Update Access&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<div id="REPLN177" class="sect3"><a id="sthref131"></a>
<h4 class="sect3">Support for Disconnected Materialized View Environments<a id="sthref132"></a></h4>
<p>Materialized view replication enables users to remotely store all or a subset of replicated data from a master site in a disconnected environment. This scenario is typical of sales force automation systems where an individual&#39;s laptop (a disconnected device) stores a subset of data related to the individual salesperson.</p>
<p>Master sites operate as the target of the materialized view environment. Master site support can be:</p>
<ul>
<li>
<p>A single master site supporting all of the materialized views, which reduces the possibility of divergent data because conflict resolution is performed only at master sites or master materialized view sites (in a multitier materialized view environment).</p>
</li>
<li>
<p>A combination of multimaster and materialized view replication where groups of materialized views are targeted to different masters of the multimaster configuration. This configuration distributes the network load across multiple master nodes, providing improved scalability and availability should one of the master nodes become unavailable.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="REPLN178" class="sect3"><a id="sthref133"></a>
<h4 class="sect3">Oracle Real Application Clusters Compared with Replication<a id="sthref134"></a><a id="sthref135"></a></h4>
<p>The two major areas where you must consider whether Advanced Replication or Oracle Real Application Clusters (Oracle RAC) better serves your needs are load balancing and survivability.</p>
<ul>
<li>
<p><span class="bold">Load Balancing</span>: Advanced Replication provides read load balancing over multiple databases, while Oracle RAC provides read and write load balancing over multiple instances. Because each write must be performed at each replication site, replication does not offer write load balancing.</p>
</li>
<li>
<p><span class="bold">Survivability</span>: Replication provides greater survivability protection with regards to natural disasters, power outages, or sabotage, or both because the remaining replication sites can be positioned in a geographically different region. Oracle RAC operates on a cluster or other massively parallel system and is located in the same physical environment, and thus cannot protect against the physical problems that replication can protect against.</p>
</li>
<li>
<p><span class="bold">Interoperability</span>: Advanced Replication can replicate data between different platforms and operating systems that are running Oracle. The instances in an Oracle RAC environment must run on the same platform.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBCIEGH"></a>
<div id="REPLN179" class="sect2">
<h3 class="sect2">Multimaster Replication Process<a id="sthref136"></a><a id="sthref137"></a></h3>
<p>There are two types of multimaster replication: asynchronous and synchronous.</p>
<p><span class="bold">Asynchronous</span> replication, often referred to as store-and-forward replication, captures any local changes, stores them in a queue, and, at regular intervals, propagates and applies these changes at remote sites. With this form of replication, there is a period of time before all sites achieve data convergence.</p>
<p><span class="bold">Synchronous</span> replication, also known as real-time replication, applies any changes or executes any replicated procedures at all sites participating in the replication environment as part of a single transaction. If the data manipulation language (DML) statement or procedure fails at any site, then the entire transaction rolls back. Synchronous replication ensures data consistency at all sites in real-time.</p>
<p>You can change the propagation mode from asynchronous to synchronous or vice versa for a master site. If you change the propagation mode for a master site in a master group, then you must regenerate replication support for all master group objects. When you regenerate replication support, Oracle then activates the internal triggers and regenerates the internal packages to support replication of the objects at all master sites. Also, a multimaster replication environment can contain a mixture of both synchronous and asynchronous replication.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i35026">&#34;Understanding Mixed-Mode Multimaster Systems&#34;</a> for more information</div>
<div id="REPLN180" class="sect3"><a id="sthref138"></a>
<h4 class="sect3">Asynchronous Replication<a id="sthref139"></a></h4>
<p>Asynchronous replication independently propagates any DML or replicated procedure execution to all of the other master sites participating in the multimaster replication environment. Propagation occurs in a separate transaction after the DML or replication procedure has been executed locally.</p>
<p>Asynchronous replication is the default mode of replication. Asynchronous replication requires less networking and hardware resources than does synchronous replication, resulting in better availability and performance.</p>
<p>Asynchronous replication, however, means that the data sets at the different master sites in the replication environment can be different for a period of time before the changes have been propagated. Also, data conflicts can occur in an asynchronous replication environment.</p>
<p>The following describes the process of asynchronous replication:</p>
<ol>
<li>
<p>A user issues DML statement or executes a wrapper for a replicated procedure.</p>
<p>After a table has been set up for replication, any DML that a user commits on the table is captured for replication to all other master sites.</p>
<p>For each row that is inserted, updated, or deleted, an internal trigger creates a deferred <span class="glossaryterm">remote procedure call (RPC)</span> and places it in the deferred transaction queue. The deferred transaction queue contains all deferred RPCs.</p>
<p>If a procedure has been replicated and its wrapper is executed at a master site, then the procedure call is placed in the deferred transaction queue.</p>
</li>
<li>
<p>The deferred transaction queue stores deferred RPCs.</p>
<p>Each transaction in the deferred transaction queue has a list of destinations that define where the deferred transaction should be propagated; this list contains all master sites except for the originating site. There is one deferred transaction queue for each site, and this one queue can be used by multiple replication groups.</p>
</li>
<li>
<p>Propagation sends deferred transaction queue entry to destination.</p>
<p>At scheduled intervals or on-demand, the deferred transactions in the deferred transaction queue are propagated to the target destinations. Each destination can have a different interval.</p>
</li>
<li>
<p>The deferred transaction queue entry applied at a remote destination.</p>
<p>As a deferred transaction is being propagated to a target destination, each deferred RPC is applied at the destination site by calling an internal package. If the deferred transaction cannot be successfully applied at the destination site, then it is resent and placed into the error queue at the destination site, where the DBA can fix the error condition and re-apply the deferred transaction.</p>
<p>When a deferred transaction queue entry is applied at the remote destination, Oracle checks for data conflicts. If a conflict is detected, then it is logged at the remote location and, optionally, a conflict resolution method is invoked.</p>
</li>
<li>
<p>When a deferred transaction has been successfully pushed to all remote master sites, it is not purged from the deferred transaction queue at the originating site immediately. It can be purged later by a purge job, which runs at a user-defined interval.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repconflicts.htm#i26513">Chapter 5, &#34;Conflict Resolution Concepts and Architecture&#34;</a> for more information</div>
</div>
<!-- class="sect3" -->
<div id="REPLN181" class="sect3"><a id="sthref140"></a>
<h4 class="sect3">Synchronous Replication<a id="sthref141"></a></h4>
<p>Synchronous replication propagates any changes made at a local site to other synchronously linked masters in a replication environment during the same transaction as the initial change. If the propagation fails at any of the master sites, then the entire transaction, including the initial change at the local master site, rolls back. This strict enforcement ensures data consistency across the replication environment. Unlike asynchronous replication, there is never a period of time when the data at any of the master sites does not match.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i35026">&#34;Understanding Mixed-Mode Multimaster Systems&#34;</a> for a discussion on using both synchronous and asynchronous replication in a single environment</div>
<p>Synchronous replication also ensures that no data conflicts are introduced into the replication environment. These benefits have the cost of requiring many hardware and networking resources with no flexibility for downtime. For example, if a single master site of a six node multimaster environment is unavailable, then a transaction cannot be completed at any master site.</p>
<p>However, in asynchronous replication, the deferred transaction is held at the originating site until the downed site becomes available. Meanwhile, the transaction can be successfully propagated and applied at other replication sites.</p>
<p>Additionally, while query performance remains high because they are performed locally with synchronous replication, updates are slower because of the two-phase commit protocol that ensures that any updates are successfully propagated and applied to the remote destination sites.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN028" href="../ADMIN/ds_concepts.htm#ADMIN028"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information about two-phase commit</div>
<p>The following describes the process of synchronous replication:</p>
<ol>
<li>
<p>User issues DML statement or executes a wrapper for a replicated procedure.</p>
<p>After a table has been set up for replication, any DML that a user commits on the target table is captured for replication to all other master replication sites.</p>
<p>If a procedure has been replicated and its wrapper is executed at a master site, then the procedure call is captured for replication.</p>
</li>
<li>
<p>DML or wrapper execution is immediately propagated to destination sites.</p>
<p>The internal trigger captures any DML and immediately propagates these actions to all other master sites in the replication environment. The internal trigger applies these actions in the security context of the propagator&#39;s database link and uses an internal RPC to apply these actions at the destination site.</p>
<p>Like an internal trigger, a wrapper for a replicated procedure immediately propagates the procedure call to all other master sites in the replication environment.</p>
<p>If the transaction fails at any one of the master replication sites, then the transaction is rolled back at all master sites. This methodology ensures data consistency across all master replication sites. Because of the need to roll back a transaction if any site fails, synchronous replication is extremely dependent on highly-available networks, databases, and the associated hardware.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i33607"></a>
<div id="REPLN182" class="sect2">
<h3 class="sect2">Conflict Resolution Concepts<a id="sthref142"></a><a id="sthref143"></a></h3>
<p>When Oracle replicates a table, any DML applied to the replicated table at any replication site (either master or materialized view site) that causes a data conflict at a destination site is automatically detected by the Oracle server at the destination site. Any data conflicts introduced by a materialized view site are detected and resolved at the target master site or master materialized view site of the materialized view.</p>
<p>For example, if the following master group is scheduled to propagate changes once an hour, then consider what happens when:</p>
<div class="inftblinformal">
<table class="cellalignment5774" title="Conflict Detection Example" summary="This table shows updates to the same row in Master Site A and Master Site B at different times, and propagation of the changes between these two sites." dir="ltr">
<thead>
<tr class="cellalignment5765">
<th class="cellalignment5775" id="r1c1-t9">Time</th>
<th class="cellalignment5775" id="r1c2-t9">Master Site A</th>
<th class="cellalignment5775" id="r1c3-t9">Master Site B</th>
<th class="cellalignment5775" id="r1c4-t9">Status</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r2c1-t9" headers="r1c1-t9">8:00 AM</td>
<td class="cellalignment5771" headers="r2c1-t9 r1c2-t9">Propagate Changes to Master Site B</td>
<td class="cellalignment5771" headers="r2c1-t9 r1c3-t9">Propagate Changes to Master Site A</td>
<td class="cellalignment5771" headers="r2c1-t9 r1c4-t9">Data converges.</td>
</tr>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r3c1-t9" headers="r1c1-t9">8:15 AM</td>
<td class="cellalignment5771" headers="r3c1-t9 r1c2-t9">Updates Row 1</td>
<td class="cellalignment5771" headers="r3c1-t9 r1c3-t9">-</td>
<td class="cellalignment5771" headers="r3c1-t9 r1c4-t9">-</td>
</tr>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r4c1-t9" headers="r1c1-t9">8:30 AM</td>
<td class="cellalignment5771" headers="r4c1-t9 r1c2-t9">-</td>
<td class="cellalignment5771" headers="r4c1-t9 r1c3-t9">Updates Row 1</td>
<td class="cellalignment5771" headers="r4c1-t9 r1c4-t9">-</td>
</tr>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r5c1-t9" headers="r1c1-t9">9:00 AM</td>
<td class="cellalignment5771" headers="r5c1-t9 r1c2-t9">Propagate Changes to Master Site B</td>
<td class="cellalignment5771" headers="r5c1-t9 r1c3-t9">Propagate Changes to Master Site A</td>
<td class="cellalignment5771" headers="r5c1-t9 r1c4-t9">Conflict Detected on Row 1</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>If the time between propagations is considered an interval and two or more sites update the same row during a single interval, then a conflict occurs.</p>
<p>In addition to the update conflict described previously, there are insert and delete conflicts. Consider the following summaries of each type of conflict. Each conflict occurs when the conflicting actions occur within the same interval.</p>
<div class="inftblinformal">
<table class="cellalignment5774" title="Conflict Types" summary="This table lists the conflict types, update, uniqueness, and delete, and summarizes each one." dir="ltr">
<thead>
<tr class="cellalignment5765">
<th class="cellalignment5775" id="r1c1-t10">Conflict Type</th>
<th class="cellalignment5775" id="r1c2-t10">Summary</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r2c1-t10" headers="r1c1-t10">Update conflict</td>
<td class="cellalignment5771" headers="r2c1-t10 r1c2-t10">Two or more DML statements are applied to the same row at different replication sites before the DML statement can be propagated to the other sites.</td>
</tr>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r3c1-t10" headers="r1c1-t10">Uniqueness conflict</td>
<td class="cellalignment5771" headers="r3c1-t10 r1c2-t10">An insert is performed at two or more sites and the primary key (or other set of unique columns) for each insert contains the same value, or an update at one site modifies the primary key (or other set of unique columns), which contains the same value as an insert at another site.</td>
</tr>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r4c1-t10" headers="r1c1-t10">Delete conflict</td>
<td class="cellalignment5771" headers="r4c1-t10 r1c2-t10">A row is deleted at one site and an update occurs at another site, which can result in an attempt to update a row that does not exist, or the same row is deleted in the same interval at multiple sites.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repconflicts.htm#i26513">Chapter 5, &#34;Conflict Resolution Concepts and Architecture&#34;</a> for more information about the different types of data conflicts</div>
<p>After a data conflict is detected, the following actions occur:</p>
<ol>
<li>
<p>The conflict resolution methods try to resolve the data conflict.</p>
</li>
<li>
<p>If the conflict is not resolved, then the data conflict is logged in the error queue at the destination site.</p>
</li>
</ol>
<p>When a data conflict is logged in the error queue, then the database administrator is responsible for resolving the data conflict manually.</p>
<p>If you choose to use Oracle-supplied or user-defined conflict resolution methods, then the Oracle server automatically tries to resolve the data conflict. The conflict resolution methods that you implement should conform to the business rules defined for your replication environment and should work to guarantee data convergence. You might need to modify tables to meet the needs of the conflict resolution methods you implement. For example, the latest time stamp conflict resolution method requires a time stamp column in the table on which it is implemented.</p>
</div>
<!-- class="sect2" -->
<a id="i40503"></a>
<div id="REPLN183" class="sect2">
<h3 class="sect2">How Replication Works with Object Types and Collections<a id="sthref144"></a><a id="sthref145"></a><a id="sthref146"></a><a id="sthref147"></a><a id="sthref148"></a></h3>
<p>Oracle <span class="bold">object</span> <span class="bold">types</span> are user-defined data types that make it possible to model complex real-world entities such as customers and orders as single entities, called <span class="bold">objects</span>, in the database. You create object types using the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> <code dir="ltr">...</code> <code dir="ltr">AS</code> <code dir="ltr">OBJECT</code> statement. You can replicate object types and objects between master sites in a multimaster replication environment.</p>
<p>An Oracle object that occupies a single column in a table is called a <span class="bold">column object</span>. Typically, tables that contain column objects also contain other columns, which can be built-in data types, such as <code dir="ltr">VARCHAR2</code> and <code dir="ltr">NUMBER</code>. An <span class="bold">object table</span> is a special kind of table in which each row represents an object. Each row in an object table is a <span class="bold">row object</span>.</p>
<p>You can also replicate <span class="bold">collections</span>. Collections are user-defined data types that are based on <code dir="ltr">VARRAY</code> and nested table data types. You create varrays with the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> <code dir="ltr">...</code> <code dir="ltr">AS</code> <code dir="ltr">VARRAY</code> statement, and you create nested tables with the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> <code dir="ltr">...</code> <code dir="ltr">AS</code> <code dir="ltr">TABLE</code> statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Advanced Replication does not support type inheritance or type evolution, and Advanced Replication does not support types created with the <code dir="ltr">NOT</code> <code dir="ltr">FINAL</code> clause. If a column of a replicated table or a replicated object table is based on a user-defined type, then you cannot alter the user-defined type.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ" href="../ADOBJ/toc.htm"><span class="italic">Oracle Database Object-Relational Developer&#39;s Guide</span></a> for detailed information about user-defined types, column objects, object tables, and collections. This section assumes a basic understanding of the information in that book.</div>
<div id="REPLN117" class="sect3"><a id="sthref149"></a>
<h4 class="sect3">Type Agreement at Replication Sites<a id="sthref150"></a><a id="sthref151"></a></h4>
<p>User-defined types include all types created using the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> statement, including object, nested table, and <code dir="ltr">VARRAY</code>. To replicate schema objects based on user-defined types, the user-defined types themselves must exist, and must be the same, at all replication sites.</p>
<p>When replicating user-defined types and the schema objects on which they are based, the following conditions apply:</p>
<ul>
<li>
<p>All replication sites must have the same object identifier (OID), schema owner, and type name for a replicated user-defined type.</p>
</li>
<li>
<p>If the user-defined type is an object type, then all replication sites must agree on the order and data type of the attributes in the object type. You establish the order and data types of the attributes when you create the object type. For example, consider the following object type:</p>
<pre dir="ltr">CREATE TYPE cust_address_typ AS OBJECT
     (street_address     VARCHAR2(40), 
      postal_code        VARCHAR2(10), 
      city               VARCHAR2(30), 
      state_province     VARCHAR2(10), 
      country_id         CHAR(2));
/
</pre>
<p>At all replication sites, <code dir="ltr">street_address</code> must be the first attribute for this type and must be <code dir="ltr">VARCHAR2(40)</code>, <code dir="ltr">postal_code</code> must be the second attribute and must be <code dir="ltr">VARCHAR2(10)</code>, <code dir="ltr">city</code> must be the third attribute and must be <code dir="ltr">VARCHAR2(30)</code>, and so on.</p>
</li>
<li>
<p><a id="sthref152"></a>All replication sites must agree on the hashcode of the user-defined type. Oracle examines a user-defined type and assigns the hashcode. This examination includes the type attributes, order of attributes, and type name. When all of these items are the same for two or more types, the types have the same hashcode. You can view the hashcode for a type by querying the <code dir="ltr">DBA_TYPE_VERSIONS</code> data dictionary view.</p>
</li>
</ul>
<p>To ensure that a user-defined type is the same at all replication sites, you must create the user-defined type in one of the following ways:</p>
<ul>
<li>
<p><a href="#i44554">Use the Replication Management API</a></p>
</li>
<li>
<p><a href="#i44568">Use a CREATE TYPE Statement</a></p>
</li>
<li>
<p><a href="#i44852">Use Export/Import</a></p>
</li>
</ul>
<a id="i44554"></a>
<div id="REPLN184" class="sect4">
<h5 class="sect4">Use the Replication Management API</h5>
<p>Oracle recommends that you use the replication management API to create, modify, or drop any replicated object at a replication site, including user-defined types. If you do not use the replication management API for these actions, then replication errors can result. For example, to add a user-defined type that meets the conditions described previously to all replication sites in a master group, create the type at the master definition site and then use the <code dir="ltr">CREATE_MASTER_REPOBJECT</code> procedure in the <code dir="ltr">DBMS_REPCAT</code> package to add the type to a master group.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REPMA019" href="../REPMA/rarrcatpac.htm#REPMA019"><span class="italic">Oracle Database Advanced Replication Management API Reference</span></a></div>
</div>
<!-- class="sect4" -->
<a id="i44568"></a>
<div id="REPLN185" class="sect4">
<h5 class="sect4">Use a CREATE TYPE Statement<a id="sthref153"></a><a id="sthref154"></a></h5>
<p>You can use a <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> statement at a replication site to create the type. It might be necessary to do this if you want to precreate the type at all replication sites and then add it to a replication group.</p>
<p>If you choose this option, then you must ensure the following:</p>
<ul>
<li>
<p>The type is in the same schema at all replication sites.</p>
</li>
<li>
<p>The type has the same attributes in the same order at all replication sites.</p>
</li>
<li>
<p>The type has the same data type for each attribute at all replication sites.</p>
</li>
<li>
<p>The type has the same object identifier at all replication sites.</p>
</li>
</ul>
<p>You can find the object identifier for a type by querying the <code dir="ltr">DBA_TYPES</code> data dictionary view. For example, to find the object identifier (OID) for the <code dir="ltr">cust_address_typ</code>, enter the following query:</p>
<pre dir="ltr">SELECT TYPE_OID FROM DBA_TYPES WHERE TYPE_NAME = &#39;CUST_ADDRESS_TYP&#39;;

TYPE_OID
--------------------------------
6F9BC33653681B7CE03400400B40A607
</pre>
<p>Or, if you are creating a new type at several different replication sites, then you can specify the same OID at each site during type creation. In this case, you can identify a globally unique OID by running the following query:</p>
<pre dir="ltr">SELECT SYS_GUID() OID FROM DUAL;
</pre>
<p>When you know the OID for the type, complete the following steps to create the type at the replication sites where it does not exist:</p>
<ol>
<li>
<p>Log in to the replication site as the user who owns the type. If this user does not exist at the replication site, then create the user.</p>
</li>
<li>
<p>Issue the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> statement and specify the OID:</p>
<pre dir="ltr">CREATE TYPE oe.cust_address_typ OID &#39;6F9BC33653681B7CE03400400B40A607&#39; 
     AS OBJECT (
     street_address     VARCHAR2(40), 
     postal_code        VARCHAR2(10), 
     city               VARCHAR2(30), 
     state_province     VARCHAR2(10), 
     country_id         CHAR(2));
/
</pre></li>
</ol>
<p>The type is now ready for use at the replication site.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REPMA104" href="../REPMA/rarrcatpac.htm#REPMA104"><span class="italic">Oracle Database Advanced Replication Management API Reference</span></a></div>
</div>
<!-- class="sect4" -->
<a id="i44852"></a>
<div id="REPLN186" class="sect4">
<h5 class="sect4">Use Export/Import</h5>
<p>You can use the Export and Import utilities to maintain type agreement between replication sites. When you export object tables based on user-defined types, or tables containing column objects based on user-defined types, the user-defined types are also exported automatically, if the user performing the export has access to these types. When you import these tables at another replication site, the user-defined types are the same as the ones at the site where you performed the export.</p>
<p>Therefore, you can use export/import to precreate your replication tables at new replication sites, and then specify the &#34;use existing object&#34; option when you add these tables to a replication group. This practice ensures type agreement at your replication sites.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SUTIL" href="../SUTIL/toc.htm"><span class="italic">Oracle Database Utilities</span></a> for information about export/import</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN187" class="sect3"><a id="sthref155"></a>
<h4 class="sect3">Object Tables and Replication<a id="sthref156"></a><a id="sthref157"></a></h4>
<p>When you replicate object tables, the following conditions apply:</p>
<ul>
<li>
<p>The OID of an object table must be the same at all replication sites.</p>
</li>
<li>
<p>The OID of each row object in an object table must be the same at all replication sites.</p>
</li>
</ul>
<p>You can meet these conditions by using the replication management API to add object tables to a replication group, modify object tables, and drop object tables from a replication group. For example, if you use the <code dir="ltr">CREATE_MASTER_REPOBJECT</code> procedure in the <code dir="ltr">DBMS_REPCAT</code> package to add an object table to a master group, then Oracle ensures that these conditions are met. You can also use export/import to precreate object tables at replication sites to meet these conditions.</p>
<p>Another option is to specify the OID for an object table when you create the object table at multiple replication sites. Complete the following steps to use this option:</p>
<a id="i44954"></a>
<ol>
<li id="BGBFGFJA">
<p>Query the <code dir="ltr">DUAL</code> view for a globally unique OID:</p>
<pre dir="ltr">SELECT SYS_GUID() OID FROM DUAL;

OID
--------------------------------
81D98C325D4A45D0E03408002074B239
</pre></li>
<li>
<p>Create the <code dir="ltr">categories_tab</code> object table with the OID returned in Step <a href="#BGBFGFJA">1</a> at each replication site:</p>
<pre dir="ltr">CREATE TABLE oe.categories_tab5 OF oe.category_typ 
   OID &#39;81D98C325D4A45D0E03408002074B239&#39;
   (category_id PRIMARY KEY);
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<div id="REPLN188" class="sect3"><a id="sthref158"></a>
<h4 class="sect3">Tables with Collection Columns<a id="sthref159"></a><a id="sthref160"></a><a id="sthref161"></a><a id="sthref162"></a></h4>
<p>Collection columns are columns based on <code dir="ltr">VARRAY</code> and nested table data types. Oracle supports the replication of collection columns. When you add a table with a collection column to a replication group, the data in the collection column is replicated automatically. If the collection column is a varray, then a varray larger than four kilobytes is stored as a <code dir="ltr">BLOB</code>.</p>
<p>If the collection column is a nested table, then Oracle Database performs row-level replication for each row in the nested table&#39;s storage table. For example, changes in five rows of a storage table result in five distinct remote procedure calls (RPCs), and five distinct conflict detection and optional resolution phases. The storage table can be stored as an index-organized table.</p>
<p>In addition, DML on a row that contains a nested table results in separate RPCs for the parent table and for each affected row in the nested table&#39;s storage table. Oracle does not perform referential integrity checks between the rows in the parent table and the rows in the storage table unless you explicitly specified integrity constraints during the creation of the parent table. Oracle recommends that you specify such constraints for replicated tables to detect all conflicts.</p>
<p>To ensure conflict detection between a nested table and its storage table, Oracle recommends that you define a deferrable foreign key constraint between them. Without a deferrable foreign key constraint, a conflict can insert rows in the storage table that cannot be accessed. A deferrable foreign key constraint causes an error to be raised in these situations so that the conflict is detected. You use the <code dir="ltr">DEFERRED</code> clause of the <code dir="ltr">SET</code> <code dir="ltr">CONSTRAINTS</code> statement to defer a constraint.</p>
<p>The following actions are not allowed directly on the storage table of a nested table in a replicated table:</p>
<ul>
<li>
<p>Adding the storage table to a replication group</p>
</li>
<li>
<p>Altering the storage table</p>
</li>
<li>
<p>Dropping the storage table</p>
</li>
<li>
<p>Generating replication support on the storage table</p>
</li>
</ul>
<p>These actions can occur indirectly when they are performed on the parent table of the storage table. In addition, you cannot replicate a subset of the columns in a storage table.</p>
</div>
<!-- class="sect3" -->
<div id="REPLN189" class="sect3"><a id="sthref163"></a>
<h4 class="sect3">Tables with REF Columns<a id="sthref164"></a><a id="sthref165"></a></h4>
<p>A <code dir="ltr">REF</code> is an Oracle built-in data type that is a logical &#34;pointer&#34; to a row object in an object table. A scoped <code dir="ltr">REF</code> is a <code dir="ltr">REF</code> that can only contain references to a specified object table, while an unscoped <code dir="ltr">REF</code> can contain references to any object table in the database. A scoped <code dir="ltr">REF</code> requires less storage space and provides more efficient access than an unscoped <code dir="ltr">REF</code>. Oracle supports the replication of tables with <code dir="ltr">REF</code>s.</p>
<div id="REPLN190" class="sect4"><a id="sthref166"></a>
<h5 class="sect4">Scoped REFs</h5>
<p>If a table with a scoped <code dir="ltr">REF</code> is replicated and the object table referenced by a <code dir="ltr">REF</code> is not replicated, then you must create the referenced object table at the sites where it does not exist before you begin replicating the table containing the scoped <code dir="ltr">REF</code>. Otherwise, replicating this table results in an error when the scoped <code dir="ltr">REF</code> cannot find the referenced object table. Typically, in this situation, it is best to replicate the referenced object table as well because it can become out of sync at the various replication sites if it is not replicated.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN191" class="sect4"><a id="sthref167"></a>
<h5 class="sect4">Unscoped REFs</h5>
<p>If a table with an unscoped <code dir="ltr">REF</code> is replicated and the object table referenced by the <code dir="ltr">REF</code> is not replicated, then a dangling <code dir="ltr">REF</code> might result at replicated sites if the <code dir="ltr">REF</code> cannot find the referenced object. For a replicated <code dir="ltr">REF</code> to be valid, the referenced object table must exist at each replication site.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN192" class="sect4"><a id="sthref168"></a>
<h5 class="sect4">REFs Created Using the WITH ROWID Option</h5>
<p>If the <code dir="ltr">WITH</code> <code dir="ltr">ROWID</code> option is specified for a <code dir="ltr">REF</code> column, then Oracle maintains a hint for the rowid of the row object referenced in the <code dir="ltr">REF</code>. Oracle can find the object referenced directly using the rowid contained in the <code dir="ltr">REF</code>, without the need to fetch the rowid from the OID index. The <code dir="ltr">WITH</code> <code dir="ltr">ROWID</code> option is not supported for scoped <code dir="ltr">REF</code>s.</p>
<p>Replicating a <code dir="ltr">REF</code> created using the <code dir="ltr">WITH</code> <code dir="ltr">ROWID</code> option results in an incorrect rowid hint at each replication site, except the site where the <code dir="ltr">REF</code> was first created or modified. The <code dir="ltr">ROWID</code> information in the <code dir="ltr">REF</code> is meaningless at the other sites, and Oracle does not correct the rowid hint automatically. Invalid rowid hints can cause performance problems. In this case, you can use the <code dir="ltr">VALIDATE</code> <code dir="ltr">STRUCTURE</code> option of the <code dir="ltr">ANALYZE</code> <code dir="ltr">TABLE</code> statement to determine which rowid hints at each replication site are incorrect.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01105" href="../SQLRF/statements_4005.htm#SQLRF01105"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ANALYZE</code> <code dir="ltr">TABLE</code> statement</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i32372"></a>
<div id="REPLN193" class="sect1">
<h2 class="sect1">Master Replication Architecture<a id="sthref169"></a></h2>
<p>Although you can build a replication environment by following the procedures and examples described in the online Help for the Advanced Replication interface in Oracle Enterprise Manager Cloud Control and in the <a class="olink REPMA" href="../REPMA/toc.htm"><span class="variable">Oracle Database Advanced Replication Management API Reference</span></a>, understanding the architecture of replication gives you valuable information for setting up your database environment to support replication, tuning your replication environment, and troubleshooting your replication environment when necessary. This section describes the architecture of replication in terms of mechanisms and processes.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#BGBDDCFG">Master Site Mechanisms</a></p>
</li>
<li>
<p><a href="#BGBFGBAD">Administrative Mechanisms</a></p>
</li>
<li>
<p><a href="#BGBHACEF">Organizational Mechanisms</a></p>
</li>
<li>
<p><a href="#BGBIFHBG">Propagation Mechanism</a></p>
</li>
<li>
<p><a href="#i32840">Performance Mechanisms</a></p>
</li>
<li>
<p><a href="#i42236">Replication Protection Mechanisms</a></p>
</li>
<li>
<p><a href="#BGBDGEEA">Conflict Resolution Mechanisms</a></p>
</li>
</ul>
<a id="BGBDDCFG"></a>
<div id="REPLN194" class="sect2">
<h3 class="sect2">Master Site Mechanisms<a id="sthref170"></a><a id="sthref171"></a></h3>
<p>To support a replication environment, Oracle uses the following mechanisms at each master site that is participating in either a multimaster replication or single master replication environment. Some of the following master site mechanisms are required only in special circumstances.</p>
<div id="REPLN195" class="sect3"><a id="sthref172"></a>
<h4 class="sect3">Master Site Roles/Users<a id="sthref173"></a><a id="sthref174"></a></h4>
<p>Depending on your security requirements, the following three roles can be consolidated into a single replication administrator. In fact, most multimaster replication environments use a single user to perform the replication administration, propagation, and receiving roles. If you have more stringent security requirements, then you can assign the following roles to different users.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
The term &#34;roles&#34; in this context is not related to the SQL term &#34;roles.&#34; The referenced replication roles are granted using stored PL/SQL procedures or individual privileges or both.</div>
<div id="REPLN196" class="sect4"><a id="sthref175"></a>
<h5 class="sect4">Replication Administrator<a id="sthref176"></a></h5>
<p>The replication administrator performs all of the administrative functions relating to a master site in a replication environment. In general, it is preferable to have a single replication administrator for a replication environment. In addition to preparing a database to support replication, the replication administrator has the following responsibilities:</p>
<ul>
<li>
<p>Building and maintaining the individual master replication groups</p>
</li>
<li>
<p>Adding and removing participating master sites</p>
</li>
<li>
<p>Managing the queues</p>
</li>
<li>
<p>Controlling the state of the replication environment (normal and quiesced)</p>
</li>
</ul>
<p>The default user name for this administrator is <code dir="ltr">repadmin</code>, but you can use any user name you wish.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN197" class="sect4"><a id="sthref177"></a>
<h5 class="sect4">Propagator<a id="sthref178"></a><a id="sthref179"></a></h5>
<p>The propagator performs the task of propagating each transaction contained in the deferred transaction queue to the transaction&#39;s destinations. There is a single propagator for the database. In other words, it is possible for you to have multiple replication administrators to manage different schemas, but there can only be a single propagator for each database.</p>
</div>
<!-- class="sect4" -->
<a id="i43219"></a>
<div id="REPLN198" class="sect4">
<h5 class="sect4">Receiver<a id="sthref180"></a><a id="sthref181"></a></h5>
<p>The receiver is responsible for receiving and applying the deferred transactions from the propagator. If the receiver does not have the appropriate privileges to apply a call in the deferred transaction, then the entire deferred transaction is placed in the error queue at the destination. You can register the receiver by using the <code dir="ltr">REGISTER_USER_REPGROUP</code> procedure in the <code dir="ltr">DBMS_REPCAT_ADMIN</code> package.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN199" class="sect3"><a id="sthref182"></a>
<h4 class="sect3">Database Links and Replication<a id="sthref183"></a><a id="sthref184"></a></h4>
<p>Database links provide the conduit to replicate data between master sites and materialized view sites. In a multimaster environment, there is a database link from each individual master site to all other master sites. Another way to look at the configuration of database links is that there are N - 1 database links for each master site, where N is the total number of master sites.</p>
<div id="REPLN200" class="figure">
<p class="titleinfigure"><a id="i32497"></a>Figure 2-3 Each Arrow Represents a Database Link</p>
<img width="395" height="254" src="img/repln072.gif" alt="Description of Figure 2-3 follows"/><br/>
<a id="sthref185" href="img_text/repln072.htm">Description of &#34;Figure 2-3 Each Arrow Represents a Database Link&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>In <a href="#i32497">Figure 2-3</a>, each master site has two database links to the other master sites (N-1 or in this case 3 - 1 = 2). This configuration ensures the bi-directional communication channels between master sites needed for multimaster replication. Notice that for a materialized view site, only a link from the materialized view site to the master site is required. The master site does not need a database link to the materialized view site.</p>
<p>The most basic setup has a database link from the replication administrator at the individual master site to the replication administrators at the other participating master replication sites.</p>
<p><a id="sthref186"></a><a id="sthref187"></a>A common approach, however, adds an additional set of database links to your replication environment. Before creating any replication administrator database links, you create public database links between all of the participating master sites, without specifying a <code dir="ltr">CONNECT</code> <code dir="ltr">TO</code> clause. The public database links specify the target of each database link with the <code dir="ltr">USING</code> clause, which specifies the service name of a remote database.</p>
<p>After creating the public database links, you can create the private replication administrator database links. When creating private database links, you specify the <code dir="ltr">CONNECT</code> <code dir="ltr">TO</code> clause, but the associated public database link eliminates the need to specify a <code dir="ltr">USING</code> clause.</p>
<p>The approach of using both public and private database links reduces the amount of administration needed to manage database links. Consider the following advantages:</p>
<ul>
<li>
<p>Multiple sets of private database links can share the same public link, further simplifying the administration of database links.</p>
</li>
<li>
<p>If the target database of a database link changes but the service name for the target database remains the same, then you only need to change the <code dir="ltr">tnsnames.ora</code> file entry for the target database. Remember that the <code dir="ltr">USING</code> clause specifies the service name for the remote target database. All private database links for the same target point to the destination defined in the <code dir="ltr">USING</code> clause in the public database link.</p>
<p>For example, if a database is moved to a different server but keeps the same service name, then you can update the <code dir="ltr">tnsnames.ora</code> file entry for the remote database at each replication site, and you do not need to re-create the database link.</p>
</li>
</ul>
<p>As previously described, the replication administrator usually performs the tasks of administration and propagation in a multimaster environment. Because a single user performs these tasks, only one set of private database links must be created for the replication administrator.</p>
<p>However, in multimaster replication environments where propagation is performed by users other than the replication administrator, the appropriate set of private database links must be created for each of these alternate users.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN028" href="../ADMIN/ds_concepts.htm#ADMIN028"><span class="variable">Oracle Database Administrator&#39;s Guide</span></a> for detailed information about database links and for information about creating database links</p>
</li>
<li>
<p><a class="olink NETAG" href="../NETAG/toc.htm"><span class="variable">Oracle Database Net Services Administrator&#39;s Guide</span></a> for information about service names and the <code dir="ltr">tnsnames.ora</code> file</p>
</li>
</ul>
</div>
<div id="REPLN201" class="sect4"><a id="sthref188"></a>
<h5 class="sect4">Database Links Created by the Advanced Replication Interface<a id="sthref189"></a><a id="sthref190"></a><a id="sthref191"></a></h5>
<p>If you use a wizard in the Advanced Replication interface in the Oracle Enterprise Manager Cloud Control to set up your replication sites, then, by default, the wizard creates database links with a <code dir="ltr">USING</code> clause that contains the description of the service name in the <code dir="ltr">tnsnames.ora</code> file or the Oracle Management Server.</p>
<p>For example, suppose the <code dir="ltr">tnsnames.ora</code> file entry for a site is the following:</p>
<pre dir="ltr">HQ.MYCOMPANY.COM = 
(DESCRIPTION=
   (ADDRESS=(PROTOCOL=TCP)(HOST=server1)(PORT=1521))
   (CONNECT_DATA=(SID=hqdb)(SERVER=DEDICATED)))
</pre>
<p>Here, the service name is <code dir="ltr">HQ.MYCOMPANY.COM</code> and the description is the text after the first equal sign. The following statement shows an example of a database link to the <code dir="ltr">HQ.MYCOMPANY.COM</code> site created by the wizard:</p>
<pre dir="ltr">CREATE PUBLIC DATABASE LINK &#34;HQ.MYCOMPANY.COM&#34; USING 
&#39;(DESCRIPTION=
   (ADDRESS=(PROTOCOL=TCP)(HOST=server1)(PORT=1521))
   (CONNECT_DATA=(SID=hqdb)(SERVER=DEDICATED)))&#39;;
</pre>
<p>The wizard uses the description of the service name and not the service name itself because different sites can have different information in their <code dir="ltr">tnsnames.ora</code> files. For example, if the wizard only used the service name and not the service name description, then the user would be required to ensure that the same service name exists and has the same information in the <code dir="ltr">tnsnames.ora</code> file at all sites, because there is no way for the Advanced Replication interface to check for this requirement.</p>
<p>By using the description for the service name, the wizard ensures that the database link is valid for all replication sites. The drawback to this type of database link is that, in the rare cases when service name description of a database changes, you must drop and re-create the database link. If the database link is created only with the service name and not the description, then you could change the <code dir="ltr">tnsnames.ora</code> file at all sites and retain the same database link.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can override the default behavior of the wizard by editing the customization screens of the wizard.</div>
</div>
<!-- class="sect4" -->
<a id="i42930"></a>
<div id="REPLN111" class="sect4">
<h5 class="sect4">Connection Qualifiers<a id="sthref192"></a><a id="sthref193"></a><a id="sthref194"></a></h5>
<p>Connection qualifiers allow several database links pointing to the same remote database to establish connections using different paths. For example, a database named <code dir="ltr">ny</code> can have two public database links named <code dir="ltr">ny.example.com</code> that connect to the remote database using different paths.</p>
<ul>
<li>
<p><code dir="ltr">ny.example.com@ethernet</code>, a link that connects to <code dir="ltr">ny</code> using an Ethernet link</p>
</li>
<li>
<p><code dir="ltr">ny.example.com@modem</code>, another link that connects to <code dir="ltr">ny</code> using a modem link</p>
</li>
</ul>
<p>For the purposes of replication, connection qualifiers can also enable you to more closely control the propagation characteristics for multiple master groups. Consider, if each master site contains three separate master groups and you are not using connection qualifiers, then the scheduling characteristics for the propagation of the deferred transaction queue is the same for all master groups. This can be costly if one master group propagates deferred transactions once an hour while the other two master groups propagate deferred transactions once a day.</p>
<p>Associating a connection qualifier with a master group gives you the ability to define different scheduling characteristics for the propagation of the deferred transaction queue on a master group level versus on a database level as previously described.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN02901" href="../ADMIN/ds_admin.htm#ADMIN02901"><span class="variable">Oracle Database Administrator&#39;s Guide</span></a> to learn about defining connection qualifiers for a database link</div>
<p>When you create a master group, you can indicate that you want to use a connection qualifier for all scheduled links that correspond to the group. However, when you use connection qualifiers for a master group, Oracle propagates information only after you have created database links with connection qualifiers at every master site. After a master group is created, you cannot remove, add, or change the connection qualifier for the group.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Caution</span>:</p>
To preserve transaction integrity in a multimaster environment that uses connection qualified links and multiple master groups, a transaction cannot manipulate replication objects in groups with different connection qualifiers.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
<span class="bold"><a id="sthref195"></a><a id="sthref196"></a></span>If you plan to use connection qualifiers, then you probably need to increase the value of the <code dir="ltr">OPEN_LINKS</code> initialization parameter at all master sites. The default is four open links for each process. Estimate the required value based on your usage. See <a href="repplan.htm#i14922">&#34;Initialization Parameters&#34;</a>, and see the <a class="olink REFRN10138" href="../REFRN/GUID-0B426902-11AD-4063-AED3-A815328DD0C4.htm#REFRN10138"><span class="italic">Oracle Database Reference</span></a> for more information about <code dir="ltr">OPEN_LINKS</code>.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i33686"></a>
<div id="REPLN202" class="sect3">
<h4 class="sect3">Replication Objects<a id="sthref197"></a></h4>
<p>The most visible part of your replication environment is the replicated objects themselves. Of these replicated objects, replicated tables are the foundation of your replication environment. The following sections discuss replicating the related database objects. These discussions highlight the benefits and potential limitations of replicating the following types of database objects:</p>
<ul>
<li>
<p><a href="#i38775">Tables</a></p>
</li>
<li>
<p><a href="#i38780">Indexes</a></p>
</li>
<li>
<p><a href="#i38785">Packages and Package Bodies</a></p>
</li>
<li>
<p><a href="#i38790">Procedures and Functions</a></p>
</li>
<li>
<p><a href="#i40517">User-Defined Types and Type Bodies</a></p>
</li>
<li>
<p><a href="#i38795">Triggers</a></p>
</li>
<li>
<p><a href="#i38804">Views, Object Views, and Synonyms</a></p>
</li>
<li>
<p><a href="#i41646">Indextypes</a></p>
</li>
<li>
<p><a href="#i41650">User-Defined Operators</a></p>
</li>
</ul>
<a id="i38775"></a>
<div id="REPLN203" class="sect4">
<h5 class="sect4">Tables<a id="sthref198"></a><a id="sthref199"></a></h5>
<p>In most cases, replicated tables are the foundation of your replication environment. After a table is selected for replication and has had replication support generated, it is monitored by internal triggers to detect any DML applied to&nbsp;it.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i33387">&#34;Internal Triggers&#34;</a></div>
<p>When you replicate a table, you have the option of replicating the table structure and table data to the remote data sites or just the table structure. Additionally, if a table of the same name and structure already exists at the target replication site, then you have the option of using the existing object in your replication environment.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="sthref200"></a><a id="sthref201"></a>
<ul>
<li>
<p>On tables with self-referential integrity constraints, Advanced Replication cannot guarantee that the deletes will be performed in the correct order. To perform deletes on tables with self-referential integrity constraints, use procedural replication. See <a class="olink REPMA103" href="../REPMA/rarmanmaster.htm#REPMA103"><span class="italic">Oracle Database Advanced Replication Management API Reference</span></a> for information.</p>
</li>
<li>
<p><a id="sthref202"></a><a id="sthref203"></a>When adding a master site to a master group that contains tables with circular dependencies or a table that contains a self-referential constraint, you must precreate the table definitions and manually load the data at the new master site. The following is an example of a circular dependency: Table A has a foreign key constraint on table B, and table B has a foreign key constraint on table A.</p>
</li>
<li>
<p><a id="sthref204"></a><a id="sthref205"></a>When you drop a function-based index from a replicated table, or add a function-based index to a replicated table, you must regenerate replication support for the table.</p>
</li>
</ul>
</div>
<p><a id="i47715"></a>Though replicating a table is intended for replicating any table data changes to all sites participating in the replication environment, there are other uses for replicating a table.</p>
<ul>
<li>
<p><span class="bold">Object and Data Transport</span>: After an object has been replicated to a target destination site, replication support is not automatically generated. You can use this approach as an easy way to distribute objects and data to remote destinations. If you do not drop the replication objects and do not generate replication support, then the table (or other objects) and the data remain at the remote destination site, and any changes at the remote destination site are not replicated. This approach enables you to distribute a standard database environment and data set to a new database environment.</p>
</li>
<li>
<p><span class="bold">Object Transport</span>: Similarly, you can replicate a table to a target destination site without copying the data. This approach creates the object at the destination site, but does not populate it with data. Therefore, you can quickly distribute an empty database environment.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repplan.htm#i15320">&#34;Considerations for Replicated Tables&#34;</a></div>
</div>
<!-- class="sect4" -->
<a id="i38780"></a>
<div id="REPLN204" class="sect4">
<h5 class="sect4">Indexes<a id="sthref206"></a><a id="sthref207"></a><a id="sthref208"></a></h5>
<p>Any index that is used to enforce a constraint in a table is automatically created at the remote destination sites when a table is selected for replication and created at the remote site. Any index that is used for performance reasons, however, must be explicitly selected for replication to be created at the other master sites participating in the replication environment. When an index is replicated to other sites, it operates as if the index was created locally. You do not need to generate replication support for indexes.</p>
<p>Oracle supports the replication of domain indexes. You can replicate the definition of storage tables for domain indexes, but you cannot replicate the storage tables themselves because they typically contain <code dir="ltr">ROWID</code> information.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="repplan.htm#i21860">&#34;Foreign Keys and Replicated Tables&#34;</a> for information about replicating the index on a foreign key column</p>
</li>
<li>
<p><a class="olink ADDCI290" href="../ADDCI/dom_idx.htm#ADDCI290"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a> for more information about extensible indexes</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<a id="i38785"></a>
<div id="REPLN205" class="sect4">
<h5 class="sect4">Packages and Package Bodies<a id="sthref209"></a><a id="sthref210"></a></h5>
<p>Selecting packages and package bodies for replication and generating the needed replication support gives you the ability to do procedural replication. Procedural replication can offer performance advantages for large, batch-oriented operations on large numbers of rows that can be run serially within a replication environment.</p>
<p><a id="sthref211"></a><a id="sthref212"></a>All parameters for a procedure with replication support must be <code dir="ltr">IN</code> parameters and must meet the data type requirements described in <a href="repplan.htm#i13947">&#34;Data Type Considerations for Replicated Tables&#34;</a>. <code dir="ltr">OUT</code> and <code dir="ltr">IN/OUT</code> modes are not supported.</p>
<p>A replicated procedure must be declared in a package. Standalone procedures cannot have replication support.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REPMA103" href="../REPMA/rarmanmaster.htm#REPMA103"><span class="italic">Oracle Database Advanced Replication Management API Reference</span></a> for detailed information about using procedural replication</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Similar to the concepts presented in the <a href="#i38775">&#34;Tables&#34;</a>, you can select a package and package body for replication but not generate replication support to use replication as an easy way to distribute the object to a remote site, though any calls made to the package are not replicated.</div>
</div>
<!-- class="sect4" -->
<a id="i38790"></a>
<div id="REPLN206" class="sect4">
<h5 class="sect4">Procedures and Functions<a id="sthref213"></a><a id="sthref214"></a><a id="sthref215"></a><a id="sthref216"></a></h5>
<p>Procedures and functions not declared as part of a package cannot have replication support. Though you cannot create a procedural replication environment with standalone procedures and functions, you can still use replication to distribute these standalone procedures and functions to the sites in your replication environment. When the standalone procedure or function is created at the remote site using replication, the created object does not have replication support and operates as though the object was created locally.</p>
</div>
<!-- class="sect4" -->
<a id="i40517"></a>
<div id="REPLN207" class="sect4">
<h5 class="sect4">User-Defined Types and Type Bodies</h5>
<p>To replicate schema objects with user-defined types, the user-defined types must exist on all replication sites and be the same at all replication sites.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i40503">&#34;How Replication Works with Object Types and Collections&#34;</a></div>
</div>
<!-- class="sect4" -->
<a id="i38795"></a>
<div id="REPLN208" class="sect4">
<h5 class="sect4">Triggers<a id="sthref217"></a><a id="sthref218"></a></h5>
<p>To ensure that any application or database logic is present at each master site, you can select triggers for replication. An important example of replicating a trigger is replicating a trigger that automatically inserts a time stamp into a table when any DML is applied to the table.</p>
<p>To avoid refiring of the trigger, it is important to insert an API call into the trigger to detect if the trigger is being fired through a local or remote call. This is to avoid the situation where the trigger updates a row that causes the trigger to fire again.</p>
<p>Notice line 5 in the following code example:</p>
<pre dir="ltr">1) CREATE OR REPLACE TRIGGER hr.insert_time
2)    BEFORE
3)       INSERT OR UPDATE ON hr.employees FOR EACH ROW
4)    BEGIN
5)       IF DBMS_REPUTIL.FROM_REMOTE = FALSE THEN
6)          :NEW.TIMESTAMP := SYSDATE;
7)       END IF;
8)    END;
9) /
</pre>
<p>If the <code dir="ltr">DBMS_REPUTIL.FROM_REMOTE</code> function determines that the insert or update was locally initiated, then the defined action (that is, assign time stamp) occurs. If this function determines that the insert or update is from a remote site, then the time stamp value is not assigned. This example assumes that a <code dir="ltr">timestamp</code> column was added to the <code dir="ltr">hr.employees</code> table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REPMA112" href="../REPMA/rarconflictres.htm#REPMA112"><span class="italic">Oracle Database Advanced Replication Management API Reference</span></a> for more information about creating replicated triggers</div>
</div>
<!-- class="sect4" -->
<a id="i38804"></a>
<div id="REPLN209" class="sect4">
<h5 class="sect4">Views, Object Views, and Synonyms<a id="sthref219"></a><a id="sthref220"></a><a id="sthref221"></a><a id="sthref222"></a><a id="sthref223"></a><a id="sthref224"></a></h5>
<p>When you replicate a view, an object view or a synonym, you are simply using replication to distribute these objects to the other master sites that are involved in the replication environment. After the object is replicated to the other sites, it operates as if the object was created locally. No internal trigger or package monitors the object to capture any changes. Because it is a replicated object, though, you can still drop or modify it using either the Advanced Replication interface in Oracle Enterprise Manager Cloud Control or the replication management API.</p>
</div>
<!-- class="sect4" -->
<a id="i41646"></a>
<div id="REPLN210" class="sect4">
<h5 class="sect4">Indextypes<a id="sthref225"></a><a id="sthref226"></a></h5>
<p>Oracle supports the replication of indextypes. You must explicitly replicate the type and type body functions that you use to implement an indextype, either using the Advanced Replication interface in Oracle Enterprise Manager Cloud Control or the <code dir="ltr">CREATE_MASTER_REPOBJECT</code> procedure in the <code dir="ltr">DBMS_REPCAT</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADDCI290" href="../ADDCI/dom_idx.htm#ADDCI290"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a> for more information about extensible indexes</div>
</div>
<!-- class="sect4" -->
<a id="i41650"></a>
<div id="REPLN211" class="sect4">
<h5 class="sect4">User-Defined Operators</h5>
<p>Developers of object-oriented applications can extend the list of built-in relational operators (for example, <code dir="ltr">+</code>, <code dir="ltr">-</code>, <code dir="ltr">/</code>, <code dir="ltr">*</code>, <code dir="ltr">LIKE</code>) with domain specific operators (for example, <code dir="ltr">Contains</code>, <code dir="ltr">Within_Distance</code>, <code dir="ltr">Similar</code>) called user-defined operators. When you replicate a user-defined operator, you are simply using replication to distribute the operator to the other master sites that are involved in the replication environment. After the object is replicated to the other sites, it operates as if the operator was created locally. No internal trigger or package monitors the object to capture any changes. Because it is a replicated object, though, you can still drop or modify it using the replication management API.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADDCI290" href="../ADDCI/dom_idx.htm#ADDCI290"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i41180"></a>
<div id="REPLN212" class="sect3">
<h4 class="sect3">Alternatives to Replicating Sequences<a id="sthref227"></a><a id="sthref228"></a></h4>
<p>Because two sequences at different databases can generate the same value, replicating sequences is not supported.</p>
<p>Three alternatives to replicating sequences guarantee the generation of unique values and avoid any uniqueness data conflicts. You can retrieve a unique identifier by executing the following select statement:</p>
<pre dir="ltr">SELECT SYS_GUID() OID FROM DUAL;
</pre>
<p>This SQL statement returns a 16-byte globally unique identifier. This value is based on an algorithm that uses time and datestamp and machine identifier to generate a globally unique identifier. The globally unique identifier appears in a format similar to the following:</p>
<pre dir="ltr">4595EF13AB785E73E03400400B40F58B
</pre>
<p>An alternate solution to using the <code dir="ltr">SYS_GUID()</code> function is to create a sequence at each of the master sites and concatenate the site name (or other globally unique value) with the local sequence. This approach helps you to avoid any potential duplicate sequence values and helps in preventing insert conflicts as described in the <a href="#i33607">&#34;Conflict Resolution Concepts&#34;</a> section.</p>
<p>Additionally, you can create a sequence at each of the master sites so that each site generates a unique value in your replication environment. You can accomplish this by using a combination of starting, incrementing, and maximum values in the <code dir="ltr">CREATE</code> <code dir="ltr">SEQUENCE</code> statement. For example, you might configure the following:</p>
<div class="inftblinformal">
<table class="cellalignment5774" title="Unique Sequence Examples" summary="This table shows ways to use the START WITH and INCREMENT BY parameters in the CREATE SEQUENCE statement to create unique sequences at replication sites." dir="ltr">
<thead>
<tr class="cellalignment5765">
<th class="cellalignment5775" id="r1c1-t34">Parameter</th>
<th class="cellalignment5775" id="r1c2-t34">Master Site A</th>
<th class="cellalignment5775" id="r1c3-t34">Master Site B</th>
<th class="cellalignment5775" id="r1c4-t34">Master Site C</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r2c1-t34" headers="r1c1-t34"><code dir="ltr">START</code> <code dir="ltr">WITH</code></td>
<td class="cellalignment5771" headers="r2c1-t34 r1c2-t34"><code dir="ltr">1</code></td>
<td class="cellalignment5771" headers="r2c1-t34 r1c3-t34">3</td>
<td class="cellalignment5771" headers="r2c1-t34 r1c4-t34">5</td>
</tr>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r3c1-t34" headers="r1c1-t34"><code dir="ltr">INCREMENT</code> <code dir="ltr">BY</code></td>
<td class="cellalignment5771" headers="r3c1-t34 r1c2-t34">10</td>
<td class="cellalignment5771" headers="r3c1-t34 r1c3-t34">10</td>
<td class="cellalignment5771" headers="r3c1-t34 r1c4-t34">10</td>
</tr>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r4c1-t34" headers="r1c1-t34">Range Example</td>
<td class="cellalignment5771" headers="r4c1-t34 r1c2-t34">1, 11, 21, 31, 41,...</td>
<td class="cellalignment5771" headers="r4c1-t34 r1c3-t34">3, 13, 23, 33, 43,...</td>
<td class="cellalignment5771" headers="r4c1-t34 r1c4-t34">5, 15, 25, 35, 45,...</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblinformal" -->
<p>Using a similar approach, you can define different ranges for each master site by specifying a <code dir="ltr">START</code> <code dir="ltr">WITH</code> and <code dir="ltr">MAXVALUE</code> that would produce a unique range for each site.</p>
</div>
<!-- class="sect3" -->
<a id="i33387"></a>
<div id="REPLN213" class="sect3">
<h4 class="sect3">Internal Triggers<a id="sthref229"></a></h4>
<p>Oracle uses internal triggers to capture and store information about updates to replicated data. Internal triggers build remote procedure calls (RPCs) to reproduce data changes made to the local site at remote replication sites. These deferred RPCs are stored in the deferred transaction queue and are propagated to the other master sites participating in the replication environment. The internal triggers supporting data replication are essentially components within the Oracle server executable. Therefore, Oracle can capture and store updates to replicated data very quickly with minimal use of system resources.</p>
</div>
<!-- class="sect3" -->
<div id="REPLN214" class="sect3"><a id="sthref230"></a>
<h4 class="sect3">Deferred Transactions<a id="sthref231"></a><a id="sthref232"></a></h4>
<p>Oracle forwards data replication information by propagating (that is, sending and executing) the RPCs that are generated by the internal triggers described previously. These RPCs are stored in the deferred transaction queue. In addition to containing the execution command for the internal procedure at the destination site, each RPC also contains the data to be replicated to the target site. Oracle uses distributed transaction protocols to protect global database integrity automatically and ensure data survivability.</p>
</div>
<!-- class="sect3" -->
<div id="REPLN215" class="sect3"><a id="sthref233"></a>
<h4 class="sect3">Internal Procedure<a id="sthref234"></a></h4>
<p>When a deferred RPC created by an internal trigger is propagated to the other master sites participating in a replication environment, an internal procedure at the destination site is used to apply the deferred RPC at the remote site. These internal procedures are activated automatically when you generate replication support for a table. These internal procedures are executed based on the RPCs that are received from the deferred transaction queue of the originating site.</p>
</div>
<!-- class="sect3" -->
<div id="REPLN216" class="sect3"><a id="sthref235"></a>
<h4 class="sect3">Queues</h4>
<p>The following queues manage the transactions that are generated by Advanced Replication:</p>
<div id="REPLN217" class="sect4"><a id="sthref236"></a>
<h5 class="sect4">Deferred Transaction Queue<a id="sthref237"></a></h5>
<p>This queue stores the transactions (for example, DML) that are bound for another destination in the master group. Oracle stores RPCs produced by the internal triggers in the deferred transaction queue of a site for later propagation. Oracle also records information about initiating transactions so that all RPCs from a transaction can be propagated and applied remotely as a transaction. Oracle&#39;s replication facility implements the deferred transaction queue using Oracle&#39;s advanced queuing mechanism.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When the restricted session is enabled by the SQL statement <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code> with the <code dir="ltr">ENABLE</code> <code dir="ltr">RESTRICTED</code> <code dir="ltr">SESSION</code> clause, deferred transactions are not propagated. When the restricted session is disabled, they are propagated.</div>
</div>
<!-- class="sect4" -->
<a id="i34583"></a>
<div id="REPLN218" class="sect4">
<h5 class="sect4">Error Queue<a id="sthref238"></a><a id="sthref239"></a></h5>
<p>The error queue stores information about deferred transactions that could not be applied successfully at the local site. The error queue does not display information about errors at other master sites in the replication environment. When the error condition has been resolved, you can either reexecute the transaction or delete the transaction from the error queue.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN219" class="sect4"><a id="sthref240"></a>
<h5 class="sect4">Job Queue<a id="sthref241"></a><a id="sthref242"></a><a id="sthref243"></a></h5>
<p>Oracle manages the propagation process using Oracle&#39;s <span class="glossaryterm">job queue mechanism</span> and <span class="glossaryterm">deferred transactions</span>. Each server has a local job queue. A server&#39;s job queue is a database table storing information about local jobs such as the PL/SQL call to execute for a job, when to run a job, and so on. Typical jobs in a replication environment include jobs to push deferred transactions to remote master sites, jobs to purge applied transactions from the deferred transaction queue, and jobs to refresh materialized view refresh groups.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBFGBAD"></a>
<div id="REPLN220" class="sect2">
<h3 class="sect2">Administrative Mechanisms<a id="sthref244"></a></h3>
<p>Several mechanisms are required to handle the administrative tasks that are often performed to support a replication environment. These mechanisms enable you to turn on and off a replication environment, as well as monitor the administrative tasks that are generated when you build or modify a replication environment.</p>
<a id="i37780"></a>
<div id="REPLN221" class="sect3">
<h4 class="sect3">Replication Modes of Operation<a id="sthref245"></a><a id="sthref246"></a><a id="sthref247"></a></h4>
<p>There are three modes of operation for a replication environment.</p>
<div id="REPLN222" class="sect4"><a id="sthref248"></a>
<h5 class="sect4">Normal</h5>
<p>A replication environment in the normal mode allows replication to occur. The replication environment is &#34;running&#34; in this mode. Any transaction against a replicated object is allowed and is appropriately propagated.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN223" class="sect4"><a id="sthref249"></a>
<h5 class="sect4">Quiescing</h5>
<p>Quiescing is the mode that transfers a replication environment from the normal mode to the quiesced mode. While a replication environment is quiescing, the user is no longer able to execute a transaction against a replicated object, but any existing deferred transactions are propagated. Queries against a quiescing table are allowed. When all deferred transactions have been successfully propagated to their respective destinations, the replication environment proceeds to the quiesced mode.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN224" class="sect4"><a id="sthref250"></a>
<h5 class="sect4">Quiesced</h5>
<p>A quiesced replication environment can be considered disabled for normal replication use and is used primarily for administrative purposes (such as adding and removing replicated objects). Replication is &#34;stopped&#34; in this mode. A quiesced state prevents users from executing any transactions against a replicated object in the quiesced master group unless they turn off replication, which can result in divergent data after replication is resumed. Transactions include DML against a replicated table or the execution of a wrapper for a replicated procedure. If master tables are quiesced, then materialized views based on those master tables cannot propagate their changes to the target master tables, but local changes to the materialized view can continue.</p>
<p>A replication environment is quiesced on a master group level. All master sites participating in the master group are affected. When a master group reaches a quiesced state, you can be certain that any transactions in the deferred transaction queue have been successfully propagated to the other master sites or put into the error queue. Users can still query tables that belong to a quiesced master group.</p>
<p>Quiescing one master group does not affect other master groups. A master group in normal mode can continue to process updates while other master groups are quiesced.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN225" class="sect3"><a id="sthref251"></a>
<h4 class="sect3">Replication Mode Control</h4>
<p>Though there are three modes of replication operation, there are only two mechanisms to control these modes (recall that the quiescing mode is a transition from a normal to quiesced mode).</p>
<div id="REPLN226" class="sect4"><a id="sthref252"></a>
<h5 class="sect4">Suspend<a id="sthref253"></a></h5>
<p>Executing the suspend mechanism begins the quiescing mode that transfers the mode of replication operation for a master group from normal to quiesced. When the deferred transaction queue has no unpropagated deferred transactions for the master group, the replication environment proceeds to the quiesced mode.</p>
<p>The suspend mechanism can only be executed when the replication environment is in normal mode. Execute suspend when you must modify the replication environment.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN227" class="sect4"><a id="sthref254"></a>
<h5 class="sect4">Resume<a id="sthref255"></a></h5>
<p>The resume mechanism transfers a master group from the quiesced replication mode to the normal mode. If you have been performing administrative work on your replication environment (for example, adding replicated objects), then you should verify that the administrative request queue (<code dir="ltr">DBA_REPCATLOG</code>) is empty before executing the resume mechanism.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN228" class="sect3"><a id="sthref256"></a>
<h4 class="sect3">Administrative Requests<a id="sthref257"></a><a id="sthref258"></a></h4>
<p>To configure and manage a replication environment, each participating server uses Oracle&#39;s replication management API. A server&#39;s <a id="sthref259"></a>replication management API is a set of PL/SQL packages encapsulating procedures and functions administrators can use to configure Oracle&#39;s replication features. The Advanced Replication interface in Oracle Enterprise Manager Cloud Control also uses the procedures and functions of each site&#39;s replication management API to perform work.</p>
<p>An <span class="glossaryterm">administrative request</span> is a call to a procedure or function in Oracle&#39;s replication management API. For example, when you use the Advanced Replication interface in Oracle Enterprise Manager Cloud Control to create a master group, the interface completes the task by making a call to the <code dir="ltr">DBMS_REPCAT.CREATE_MASTER_REPGROUP</code> procedure. Some administrative requests generate additional replication management API calls to complete the request.</p>
<div id="REPLN229" class="sect4"><a id="sthref260"></a>
<h5 class="sect4">The Administrative Request Mechanisms<a id="sthref261"></a><a id="sthref262"></a><a id="sthref263"></a></h5>
<p>When you use the Advanced Replication interface in Oracle Enterprise Manager Cloud Control or make a call to a procedure in the <code dir="ltr">DBMS_REPCAT</code> package to administer a replication system, Oracle uses its internal mechanisms to broadcast the request synchronously. If a synchronous broadcast fails for any reason, then Oracle returns an error message and rolls back the encompassing transaction.</p>
<p>When an Oracle server receives an administrative request, it records the request in the<a id="sthref264"></a><a id="sthref265"></a> <code dir="ltr">DBA_REPCATLOG</code> view and the corresponding DDL statement in a child table of the <code dir="ltr">DBA_REPCATLOG</code> view. When you view administrative requests for a master group at a master site, you might observe requests that are waiting for a callback from another master site. These requests are called <code dir="ltr">AWAIT_CALLBACK</code> requests. Master replication activity cannot resume until all of the administrative requests in the <code dir="ltr">DBA_REPCATLOG</code> view have been applied and any errors resolved.</p>
<p>Whenever you use the Advanced Replication interface in Oracle Enterprise Manager Cloud Control to create an administrative request for a replication group, Oracle automatically inserts a job into the local job queue, if one does not already exist for the group. This job periodically executes the <code dir="ltr">DBMS_REPCAT.<a id="sthref266"></a><a id="sthref267"></a>DO_DEFERRED_REPCAT_ADMIN</code> procedure. Whenever you synchronously broadcast a request, Oracle attempts to start this job immediately to apply the replicated changes at each master site.</p>
<p>If Oracle does not encounter any errors, then <code dir="ltr">DO_DEFERRED_REPCAT_ADMIN</code> is run whenever a background process is available to execute the job. Oracle automatically determines how often the background process wakes up. You can experience a delay if you do not have enough background processes available to execute the outstanding jobs.</p>
<p><a id="sthref268"></a><a id="sthref269"></a>For each call of <code dir="ltr">DO_DEFERRED_REPCAT_ADMIN</code> at a master site, the site checks the <code dir="ltr">DBA_REPCATLOG</code> view to see if there are any requests that need to be performed. When one or more administrative requests are present, Oracle applies the request and updates any local views as appropriate. This event can occur asynchronously at each master site.</p>
<p><code dir="ltr">DO_DEFERRED_REPCAT_ADMIN</code> executes the local administrative requests in the proper order. When <code dir="ltr">DO_DEFERRED_REPCAT_ADMIN</code> is executed at a master that is not the master definition site, it does as much as possible. Some asynchronous activities, such as populating a replicated table, require communication with the master definition site. If this communication is not possible, then <code dir="ltr">DO_DEFERRED_REPCAT_ADMIN</code> stops executing administrative requests to avoid executing requests out of order. Some communication with the master definition site, such as the final step of updating or deleting an administrative request at the master definition site, can be deferred and does not prevent <code dir="ltr">DO_DEFERRED_REPCAT_ADMIN</code> from executing additional requests.</p>
<p>The success or failure of an administrative request at each master site is noted in the <code dir="ltr">DBA_REPCATLOG</code> view at each site. For each master group, the Advanced Replication interface in Oracle Enterprise Manager Cloud Control displays the corresponding status of each administrative request. Ultimately, each master site propagates the status of its administrative requests to the master definition site. If a request completes successfully at a master site, then Oracle removes the callback for the site from the <code dir="ltr">DBA_REPCATLOG</code> view at the master definition site.</p>
<p>If a request completes successfully at all sites, then all entries in the <code dir="ltr">DBA_REPCATLOG</code> view at all sites, including the master definition site, are removed. If a request at a non master definition site fails, then Oracle removes the request at the master site and updates the corresponding <code dir="ltr">AWAIT_CALLBACK</code> request at the master definition site with <code dir="ltr">ERROR</code> status and the reason for the failure.</p>
<p>By synchronously broadcasting the change, Oracle ensures that all sites are aware of the change, and thus are capable of remaining synchronized. By allowing the change to be applied at the site at a future point in time, Oracle provides you with the flexibility to choose the most appropriate time to apply changes at a site.</p>
<p>If an object requires replication support, then you must regenerate replication support after altering the object. Oracle then activates the internal triggers and regenerates the packages to support replication of the altered object at all master sites.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although the DDL must be successfully applied at the master definition site in order for these procedures to complete without error, this does not guarantee that the DDL is successfully applied at each master site. The Advanced Replication interface in Oracle Enterprise Manager Cloud Control displays the status of all administrative requests. Additionally, the <code dir="ltr">DBA_REPCATLOG</code> view contains interim status and any asynchronous error messages generated by the request.</div>
<p>Any materialized view sites that are affected by a DDL change are updated the next time you perform a refresh of the materialized view site. While all master sites can communicate with one another, materialized view sites can communicate only with their associated master site.</p>
<p>If you must alter the shape of a materialized view as the result of a change to its master, then you must drop and re-create the materialized view.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN230" class="sect3"><a id="sthref270"></a>
<h4 class="sect3">Administrative Request Queue<a id="sthref271"></a><a id="sthref272"></a><a id="sthref273"></a></h4>
<p>Often referred to as the administrative request queue, the <code dir="ltr">DBA_REPCATLOG</code> view stores administrative requests that manage and modify your replication environment. Some <code dir="ltr">DBMS_REPCAT</code> procedures that are executed are listed in the administrative request queue. For example, if you wanted to add a replicated table to an existing master group, then you would see a request naming the <code dir="ltr">DBMS_REPCAT.CREATE_MASTER_REPOBJECT</code> procedure.</p>
<p>You can view the administrative request queue by querying the <code dir="ltr">DBA_REPCATLOG</code> view or viewing the Administrative Requests page in the Advanced Replication interface in Oracle Enterprise Manager Cloud Control.</p>
<p><a id="sthref274"></a><a id="sthref275"></a>Each request has a status that displays the state of the request. Here are the possible states:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlinebold"><a id="sthref276"></a>READY</span></code>: The <code dir="ltr">READY</code> state indicates that the request is ready to be executed. If you monitor the administrative request queue and a request remains in the <code dir="ltr">READY</code> state for a long time, then a request in front of the ready request might be waiting for a callback. Typically, administrative requests in the <code dir="ltr">READY</code> state are waiting for a job to execute them. You can execute them manually by using the <code dir="ltr"><a id="sthref277"></a><a id="sthref278"></a>DO_DEFERRED_REPCAT_ADMIN</code> procedure in the <code dir="ltr">DBMS_REPCAT</code> package.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlinebold"><a id="sthref279"></a>AWAIT_CALLBACK</span></code>: The <code dir="ltr">AWAIT_CALLBACK</code> state indicates that the request is waiting for a request to be executed at another site and is waiting for confirmation of the request execution. After the request receives the callback, the request is either removed or has its status changed. The request is removed from the queue if it was applied successfully, or its status is changed to <code dir="ltr">ERROR</code> if it failed. This state is only possible at the master definition site.</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlinebold"><a id="sthref280"></a>ERROR</span></code>: If a request cannot be successfully executed, then it is placed in the <code dir="ltr">ERROR</code> state. The error number appears in the <code dir="ltr">ERRNUM</code> column and the error message appears in the <code dir="ltr">MESSAGE</code> column of the administrative request queue (or <code dir="ltr">ERROR</code> in the <span class="bold">Status</span> field on the Administrative Requests page when using the Advanced Replication interface in Oracle Enterprise Manager Cloud Control).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a request is in the <code dir="ltr">ERROR</code> state, then resolve the error condition as described by the error number and resubmit the request.</div>
</li>
</ul>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlinebold"><a id="sthref281"></a>DO_CALLBACK</span></code>: If a request at a master site is in the <code dir="ltr">DO_CALLBACK</code> state, then it means that the master site must inform the master definition site about the success or failure of the request. This state is only possible at a master site that is not the master definition site.</p>
</li>
</ul>
<p>The administrative request queue of each master site lists only the administrative requests to be performed at that master site. The master definition site for a master group, however, lists administrative requests to be performed at each of the master sites. The administrative request queue at the master definition site lets the DBA monitor administrative requests of all the master sites in the replication environment.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When the restricted session is enabled by the SQL statement <code dir="ltr">ALTER SYSTEM</code> with the <code dir="ltr">ENABLE RESTRICTED SESSION</code> clause, administrative requests are not executed. When the restricted session is disabled, they are executed.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBHACEF"></a>
<div id="REPLN231" class="sect2">
<h3 class="sect2">Organizational Mechanisms</h3>
<p>Oracle uses several organizational mechanisms to organize the previously described master site and administrative mechanisms to create discrete replication groups. Most notable of these organizational mechanisms is the master group. An additional organization mechanism helps to group columns that are used to resolve conflicts for a replicated table.</p>
<div id="REPLN232" class="sect3"><a id="sthref282"></a>
<h4 class="sect3">Master Group<a id="sthref283"></a><a id="sthref284"></a><a id="sthref285"></a></h4>
<p>In a replication environment, Oracle manages replication objects using <span class="glossaryterm">replication groups</span>. A replication group is a collection of replication objects that are always updated in a transactionally consistent manner.</p>
<p>By organizing related database objects within a replication group, it is easier to administer many objects together. Typically, you create and use a replication group to organize the schema objects necessary to support a particular database application. That is not to say that replication groups and schemas must correspond with one another. Objects in a replication group can originate from several database schemas, and a schema can contain objects that are members of different replication groups. The restriction is that a replication object can be a member of only one group.</p>
<p>In a multimaster replication environment, the replication groups are called <span class="glossaryterm">master groups</span>. Corresponding master groups at different sites must contain the same set of replication objects (see <a href="#i33686">&#34;Replication Objects&#34;</a>). <a href="#i46613">Figure 2-4</a> illustrates that master group <code dir="ltr">hr_mg</code> contains an exact replica of the replicated objects at each master site.</p>
<div id="REPLN233" class="figure">
<p class="titleinfigure"><a id="i46613"></a>Figure 2-4 Master Group hr_mg Contains Same Replication Objects at All Sites</p>
<img width="600" height="400" src="img/repln073.gif" alt="Description of Figure 2-4 follows"/><br/>
<a id="sthref286" href="img_text/repln073.htm">Description of &#34;Figure 2-4 Master Group hr_mg Contains Same Replication Objects at All Sites&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The master group organization at the master site plays an integral role in the organization of replication objects at a materialized view site.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repmview.htm#i32253">&#34;Organizational Mechanisms&#34;</a> for more information about the organizational mechanisms at a materialized view site</div>
<p>Additionally, <a href="#i33688">Figure 2-5</a> illustrates that each site can contain multiple replication groups, though each group must contain the same set of objects at each master site.</p>
<div id="REPLN234" class="figure">
<p class="titleinfigure"><a id="i33688"></a>Figure 2-5 Master Groups Are Identical at Each Master Site</p>
<img width="600" height="336" src="img/repln078.gif" alt="Description of Figure 2-5 follows"/><br/>
<a id="sthref287" href="img_text/repln078.htm">Description of &#34;Figure 2-5 Master Groups Are Identical at Each Master Site&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<div id="REPLN235" class="sect3"><a id="sthref288"></a>
<h4 class="sect3">Column Groups<a id="sthref289"></a><a id="sthref290"></a></h4>
<p>Column groups provide the organizational mechanism to group all columns that are involved in a conflict resolution routine. If a conflict occurs in one of the columns of the group, then the remainder of the group&#39;s columns can resolve the conflict. For example, if a column group for a table contains a <code dir="ltr">min_price</code>, <code dir="ltr">list_price</code>, <code dir="ltr">cost_price</code>, and <code dir="ltr">timestamp</code> field and a conflict arises for the <code dir="ltr">list_price</code> field, then the <code dir="ltr">timestamp</code> field can resolve the conflict, if a timestamp conflict resolution routine has been used.</p>
<p>Initially, you might think that you should put all columns in the table into a single column group. Although this makes setup and administration easier, it might decrease the performance of your replicated table and might increase the potential for data conflicts. As described in the <a href="#i32840">&#34;Performance Mechanisms&#34;</a>, if a conflict occurs in one column group of a table, then the minimum communication feature does not send data from other column groups in the table. Therefore, placing all columns into a single column group might negate the advantages of the minimum communication feature, unless you use the <code dir="ltr">SEND_OLD_VALUES</code> and <code dir="ltr">COMPARE_OLD_VALUES</code> procedures in the <code dir="ltr">DBMS_REPCAT</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repconflicts.htm#i26513">Chapter 5, &#34;Conflict Resolution Concepts and Architecture&#34;</a> for more information about column groups</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBIFHBG"></a>
<div id="REPLN236" class="sect2">
<h3 class="sect2">Propagation Mechanism<a id="sthref291"></a><a id="sthref292"></a></h3>
<p>Propagation is the essence of replication because it is the mechanism that sends or distributes any actions to all other master sites in the replication environment.</p>
<div id="REPLN237" class="sect3"><a id="sthref293"></a>
<h4 class="sect3">Propagation Types</h4>
<p>As the internal trigger captures any DML applied to a replicated table, the DML must be <span class="glossaryterm">propagated</span> (or sent) to the other master sites in the replication environment. Internal triggers are described in the section <a href="#i33387">&#34;Internal Triggers&#34;</a>.</p>
<p>Advanced Replication supports both asynchronous and synchronous replication.</p>
<div id="REPLN238" class="sect4"><a id="sthref294"></a>
<h5 class="sect4">Asynchronous<a id="sthref295"></a><a id="sthref296"></a><a id="sthref297"></a></h5>
<p>Typical replication configurations use <span class="glossaryterm">asynchronous data replication</span>. Asynchronous data replication occurs when an application updates a local replica of a table, stores replication information in a local queue, and then forwards the replication information to other replication sites at a later time. Consequently, asynchronous data replication is also called <span class="glossaryterm">store-and-forward data replication</span>.</p>
<p>As <a href="#i34151">Figure 2-6</a> shows, Oracle uses its internal triggers, deferred transactions, deferred transaction queues, and job queues to propagate data-level changes asynchronously among master sites in a replication environment, as well as from an updatable materialized view to its master table.</p>
<div id="REPLN239" class="figure">
<p class="titleinfigure"><a id="i34151"></a>Figure 2-6 Asynchronous Data Replication Mechanisms</p>
<img width="600" height="424" src="img/repln032.gif" alt="Description of Figure 2-6 follows"/><br/>
<a id="sthref298" href="img_text/repln032.htm">Description of &#34;Figure 2-6 Asynchronous Data Replication Mechanisms&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect4" -->
<div id="REPLN240" class="sect4"><a id="sthref299"></a>
<h5 class="sect4">Synchronous<a id="sthref300"></a><a id="sthref301"></a></h5>
<p><a id="sthref302"></a><a id="sthref303"></a>Oracle also supports synchronous data propagation for applications with special requirements. <span class="glossaryterm">Synchronous data propagation</span> occurs when an application updates a local replica of a table, and within the same transaction also updates at least one other replica of the same table. Consequently, synchronous data replication is also called <span class="glossaryterm">real-time data replication</span>. Use synchronous replication only when applications require that replicated sites remain continuously synchronized.</p>
<div id="REPLN241" class="figure">
<p class="titleinfigure"><a id="i46228"></a>Figure 2-7 Synchronous Data Replication Mechanisms</p>
<img width="600" height="352" src="img/repln039.gif" alt="Description of Figure 2-7 follows"/><br/>
<a id="sthref304" href="img_text/repln039.htm">Description of &#34;Figure 2-7 Synchronous Data Replication Mechanisms&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>As <a href="#i46228">Figure 2-7</a> shows, Oracle uses the same internal triggers to generate remote procedure calls (RPCs) that asynchronously replicate data-level changes to other replication sites to support synchronous, row-level data replication. However, Oracle does not defer the execution of such RPCs. Instead, data replication RPCs execute within the boundary of the same transaction that modifies the local replica. Consequently, a data-level change must be possible at all synchronously linked sites that manage a replicated table; otherwise, a transaction rollback occurs.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN242" class="sect3"><a id="sthref305"></a>
<h4 class="sect3">Synchronous Data Propagation</h4>
<p>As shown in <a href="#i34600">Figure 2-8</a>, whenever an application makes a DML change to a local replicated table and the replication group is using synchronous row-level replication, the change is synchronously propagated to the other master sites in the replication environment using internal triggers. <a id="sthref306"></a>When the application applies a local change, the internal triggers issue calls to generated procedures at the remote master sites <span class="italic">in the security context of the replication propagator</span>. Oracle ensures that all distributed transactions either commit or rollback in the event of a failure.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN031" href="../ADMIN/ds_txns.htm#ADMIN031"><span class="variable">Oracle Database Administrator&#39;s Guide</span></a> for more information about distributed transactions</div>
<div id="REPLN243" class="figure">
<p class="titleinfigure"><a id="i34600"></a>Figure 2-8 Propagating Changes Using Synchronous Row-Level Replication</p>
<img width="600" height="400" src="img/repln030.gif" alt="Description of Figure 2-8 follows"/><br/>
<a id="sthref307" href="img_text/repln030.htm">Description of &#34;Figure 2-8 Propagating Changes Using Synchronous Row-Level Replication&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="REPLN244" class="sect4"><a id="sthref308"></a>
<h5 class="sect4">Restrictions</h5>
<p>Because of the locking mechanism used by synchronous replication, <a id="sthref309"></a><a id="sthref310"></a>deadlocks can occur when the same row is updated at two different sites at the same time. When an application performs a synchronous update to a replicated table, Oracle first locks the local row and then uses an <code dir="ltr">AFTER</code> <code dir="ltr">ROW</code> trigger to lock the corresponding remote row. Oracle releases the locks when the transaction commits at each site.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A replication system that uses real-time propagation of replication data is highly dependent on system and network availability because it can function only when all sites in the system are concurrently available.</div>
</div>
<!-- class="sect4" -->
<div id="REPLN245" class="sect4"><a id="sthref311"></a>
<h5 class="sect4">Destination of Synchronously Replicated Transactions<a id="sthref312"></a></h5>
<p>The necessary remote procedure calls to support synchronous replication are included in the internal trigger for each object. When you generate replication support for a replicated object, Oracle activates the triggers at all master sites to add the necessary remote procedure calls for the new site. Conversely, when you remove a master site from a master group, Oracle removes the calls from the internal triggers.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN246" class="sect4"><a id="sthref313"></a>
<h5 class="sect4">Conflict Detection<a id="sthref314"></a></h5>
<p>If all sites of a master group communicate synchronously with one another, then applications should never experience replication conflicts. However, if even one site is sending changes asynchronously to another site, then applications can experience conflicts at any site in the replication environment.</p>
<p>If the change is being propagated synchronously, then an error is raised and a rollback is required. If the change is propagated asynchronously, then Oracle automatically detects the conflicts and either logs the conflict in the error queue or, if you designate an appropriate resolution method, resolves the conflict.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repconflicts.htm#i26513">Chapter 5, &#34;Conflict Resolution Concepts and Architecture&#34;</a></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i35026"></a>
<div id="REPLN247" class="sect3">
<h4 class="sect3">Understanding Mixed-Mode Multimaster Systems<a id="sthref315"></a></h4>
<p>In some situations, you might decide to have a mixed-mode environment in which some master sites propagate a master group&#39;s changes asynchronously and others propagate changes synchronously. The order in which you add new master sites to a group with different data propagation modes can be important.</p>
<p>For example, suppose that you have three master sites: A, B, and C. If you first create site A as the master definition site, and then add site B with a synchronous propagation mode, then site A sends changes to site B synchronously and site B sends changes to site A synchronously. There is no need to be concerned about the scheduling of links at either site, because neither site is creating deferred transactions.</p>
<p>Now suppose that you create master site C with an asynchronous propagation mode. The propagation modes are now as illustrated in <a href="#i46250">Figure 2-9</a>.</p>
<div id="REPLN248" class="figure">
<p class="titleinfigure"><a id="i46250"></a>Figure 2-9 Selecting a Propagation Mode</p>
<img width="600" height="240" src="img/repln040.gif" alt="Description of Figure 2-9 follows"/><br/>
<a id="sthref316" href="img_text/repln040.htm">Description of &#34;Figure 2-9 Selecting a Propagation Mode&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>You must now schedule propagation of the deferred transaction queue from site A to site C, from site B to site C, and from site C to sites A and B.</p>
<p>As another example, consider what would happen if you created site A as the master definition site, then added site C with an asynchronous propagation mode, then added site B with a synchronous propagation mode. Now the propagation modes would be as shown in <a href="#i46259">Figure 2-10</a>.</p>
<div id="REPLN249" class="figure">
<p class="titleinfigure"><a id="i46259"></a>Figure 2-10 Ordering Considerations</p>
<img width="600" height="240" src="img/repln041.gif" alt="Description of Figure 2-10 follows"/><br/>
<a id="sthref317" href="img_text/repln041.htm">Description of &#34;Figure 2-10 Ordering Considerations&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Each time that you add a new master site to a mixed-mode multimaster system, consider how the addition affects the data propagation modes to and from existing sites.</p>
</div>
<!-- class="sect3" -->
<div id="REPLN250" class="sect3"><a id="sthref318"></a>
<h4 class="sect3">Initiating Propagation<a id="sthref319"></a></h4>
<p>When synchronous propagation is used, the propagation of the DML is handled immediately and is automatically initiated. If asynchronous propagation is used, then you can use the following methods to propagate the deferred transactions:</p>
<ul>
<li>
<p><span class="bold">Scheduled job:</span> In most cases, use a scheduled job to automatically propagate the deferred transactions at a set interval.</p>
</li>
<li>
<p><span class="bold">Manual propagation:</span> You can also manually propagate the changes by executing a stored procedure or using the Advanced Replication interface in Oracle Enterprise Manager Cloud Control. You might occasionally need to manually propagate your deferred transactions if you do not want to wait for the job queue to automatically propagate the deferred transactions.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i32840"></a>
<div id="REPLN251" class="sect2">
<h3 class="sect2">Performance Mechanisms<a id="sthref320"></a><a id="sthref321"></a></h3>
<p>As with any enterprise database solution, performance is always an important issue for the database administrator. Advanced Replication provides several mechanisms to help increase the performance of your replication environment.</p>
<a id="i37218"></a>
<div id="REPLN252" class="sect3">
<h4 class="sect3">Parallel Propagation<a id="sthref322"></a><a id="sthref323"></a></h4>
<p>With <span class="glossaryterm">parallel propagation</span>, Oracle asynchronously propagates replicated transactions using multiple, parallel transit streams for higher throughput. When necessary, Oracle orders the execution of dependent transactions to ensure global database integrity.</p>
<p>Parallel propagation uses the pool of available parallel processes. This is the same facility Oracle uses for other parallel operations such as parallel query, parallel load, and parallel recovery. Each server process propagates transactions through a single stream. A parallel coordinator process controls these server processes. The coordinator tracks transaction dependencies, allocates work to the server processes, and tracks their progress.</p>
<p>Parallel processes remain associated with a parallel operation on the server throughout the execution of that operation. When the operation is complete, those server processes become available to process other parallel operations. For example, when Oracle Database performs a parallel push of the deferred transaction queue to its destination, all parallel processes used to push the queue remain dedicated to the push until it is complete.</p>
<p><a id="sthref324"></a>To configure a pool of parallel processes for a server properly, you must consider several issues related to the configuration of a replication system.</p>
<ul>
<li>
<p>When you configure all scheduled links to use serial propagation, the replication system does not use parallel processes. Therefore, you do not need to adjust the size of any server&#39;s pool of parallel processes to account for replication. Typically, serial propagation is used only for backward compatibility.</p>
</li>
<li>
<p>When you configure one or more scheduled links to use parallel propagation, you must consider the number of parallel processes that each link uses to push changes to its destination. Furthermore, you should also consider how long each push holds parallel servers from being used by other operations. For example, when you configure a scheduled link for continuous propagation with a large value for delay seconds, Oracle holds on to the parallel processes used to push transactions to its destination. Therefore, you should increase the number of parallel processes for the corresponding database server to ensure that there are enough processes for other parallel operations on the server.</p>
</li>
</ul>
<p>To configure a database server&#39;s pool of parallel query processes, use the following initialization parameters:</p>
<ul>
<li>
<p><code dir="ltr"><a id="sthref325"></a><a id="sthref326"></a>PARALLEL_MAX_SERVERS</code></p>
</li>
<li>
<p><code dir="ltr"><a id="sthref327"></a><a id="sthref328"></a>PARALLEL_MIN_SERVERS</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="repplan.htm#i14922">&#34;Initialization Parameters&#34;</a></p>
</li>
<li>
<p><a class="olink REFRN" href="../REFRN/toc.htm"><span class="variable">Oracle Database Reference</span></a></p>
</li>
</ul>
</div>
<div id="REPLN253" class="sect4"><a id="sthref329"></a>
<h5 class="sect4">Implementing Parallel Propagation<a id="sthref330"></a><a id="sthref331"></a></h5>
<p>For most users, setting the parallel propagation parameter to a value of 1 provides sufficient performance. A setting of 1 enables the optimized data transfer method discussed in the previous section instead of serial propagation. However, some users might want to further tune the parallel propagation value.</p>
<p>The following procedure is the recommended method to further tune the parallel propagation value:</p>
<ol>
<li>
<p>Set the parallel propagation value to 1.</p>
</li>
<li>
<p>Test your database environment and carefully measure the propagation throughput.</p>
<p>If you have achieved your performance goals with a parallel propagation value of 1, then you have implemented parallel propagation, and you do not need to complete the remaining steps in this procedure.</p>
<div class="infobox-note">
<p class="notep1">Note::</p>
As you increase the value of the parallel propagation parameter, be aware of the trade-offs between increased parallel propagation and the resources required to support the extra parallel processes.</div>
</li>
<li id="i35934">
<p>To try to achieve greater propagation throughput than with a value of 1, then set your parallel propagation value to 2.</p>
</li>
<li id="i35907">
<p>Test your database environment and carefully measure the propagation throughput.</p>
<p>In many cases, you might experience propagation throughput degradation with a value of 2. This reduction is due to round-trip delays associated with the coordinator assigning dependent transactions to available processes and waiting for the necessary commit acknowledgments before assigning additional transactions.</p>
<p>Repeat Steps <a href="#i35934">3</a> and <a href="#i35907">4</a> with the parallel propagation value set to 4 and again with&nbsp;8. If throughput still does not improve, then it suggests that the transactions in your environment are highly dependent on each other. Reduce the parallel propagation value to 1 and proceed to Step <a href="#i41619">5</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i35730">&#34;Tuning Parallel Propagation&#34;</a> to learn about techniques to reduce transaction dependencies</div>
<p>If your performance did improve with a value of 2, 4, or 8, then it suggests that your transactions have a low degree of interdependence. You can even set your parallel propagation parameter to any value greater than 8. Just be sure to thoroughly test your environment and remain aware of the trade-offs between increased parallelism and the necessary resources to support those extra parallel processes.</p>
</li>
<li id="i41619">
<p>Set parallel propagation to the value that offers the best performance in your environment based on your testing.</p>
</li>
</ol>
</div>
<!-- class="sect4" -->
<a id="i35730"></a>
<div id="REPLN254" class="sect4">
<h5 class="sect4">Tuning Parallel Propagation<a id="sthref332"></a><a id="sthref333"></a></h5>
<p>To gain the greatest amount of performance benefits from parallel propagation, reduce the amount of dependent transactions that are created. Remember that a transaction cannot start until all of its dependent transactions have been committed.</p>
<p>When trying to reduce the number of dependent transactions:</p>
<ul>
<li>
<p>Use smaller transactions if possible (that is, commit more often, without destroying autonomy).</p>
</li>
<li>
<p>Increase number of freelists for each table that receives inserts.</p>
</li>
<li>
<p>Try to avoid hotspots (a row that is frequently modified - if the same row is touched, then those transactions are serialized). For example, use an Oracle sequence instead of using a counter in a row and incrementing it &#34;manually.&#34;</p>
</li>
<li>
<p>Consider using row-level dependency tracking.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i42789">&#34;Use of Row-Level Dependency Tracking to Improve Parallelism&#34;</a></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN255" class="sect3"><a id="sthref334"></a>
<h4 class="sect3">Minimum Communication<a id="sthref335"></a><a id="sthref336"></a></h4>
<p>To detect and resolve an update conflict for a row, the propagating site must send a certain amount of data about the new and old versions of the row to the receiving site. By default, Oracle minimizes the amount of data that must be communicated to detect conflicts for each changed row in the table. Specifically, Oracle propagates:</p>
<ul>
<li>
<p>The primary key value and the old value of each column in each modified column group (the value before the modification)</p>
</li>
<li>
<p>The new value of each updated column</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>For an inserted row, the row has no old value. For a deleted row, the row has no new value.</p>
</li>
<li>
<p>Ensure that your replication environment uses minimum communication by ensuring that the <code dir="ltr">min_communication</code> parameter is set to the default value of <code dir="ltr">TRUE</code> when you run the procedures <code dir="ltr">CREATE_MVIEW_REPOBJECT</code> and <code dir="ltr">GENERATE_REPLICATION_SUPPORT</code> in the <code dir="ltr">DBMS_REPCAT</code> package.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i46930"></a>
<div id="REPLN256" class="sect3">
<h4 class="sect3">Delay Seconds<a id="sthref337"></a><a id="sthref338"></a></h4>
<p>Though not directly a performance mechanism, properly configuring the <code dir="ltr">delay_seconds</code> parameter can give you greater control over the timing of your propagation of deferred transactions.</p>
<p>When you are pushing deferred transactions, you set the <code dir="ltr">delay_seconds</code> parameter in the <code dir="ltr">SCHEDULE_PUSH</code> procedure or the <code dir="ltr">PUSH</code> function. When you are purging deferred transactions, you set the <code dir="ltr">delay_seconds</code> parameter in the <code dir="ltr">SCHEDULE_PURGE</code> procedure or the <code dir="ltr">PURGE</code> function. These procedures and functions are in the <code dir="ltr">DBMS_DEFER_SYS</code> package.</p>
<p>The <code dir="ltr">delay_seconds</code> parameter controls how long a job remains aware of the deferred transaction queue. The effects of the <code dir="ltr">delay_seconds</code> parameter can best be illustrated with the following two examples:</p>
<dl>
<dt><span class="bold">delay_seconds = 0 (default)</span></dt>
<dd>
<p>If a scheduled job with a 60 minute interval wakes up at 2:30 pm and checks the deferred transaction queue, then any existing deferred transactions are propagated. The propagation takes 2 minutes and therefore the job is complete at 2:32 pm.</p>
<p>If a deferred transaction enters the queue at 2:34 pm, then the deferred transaction is not propagated because the job is complete. In this scenario, the deferred transaction will be propagated at 3:30 pm.</p>
</dd>
<dt><span class="bold">delay_seconds = 300</span></dt>
<dd>
<p>If a scheduled job with a 60 minute interval wakes up at 2:30 pm and checks the deferred transaction queue, then any existing deferred transactions are propagated. The propagation takes 2 minutes and therefore the job is complete at 2:32 pm.</p>
<p>If a deferred transaction enters the queue at 2:34 pm, then the deferred transaction is propagated because the job remains aware of the deferred transaction queue for 300 seconds (5 minutes) after the job has completed propagating whatever was in the queue. In this scenario, the deferred transaction is propagated at 2:34 pm.</p>
<p>Why not just set the job to execute more often? Starting and stopping the job has a greater amount of overhead than starting the job and keeping it aware for a set period of time. In addition to decreasing the overhead associated with starting and stopping these jobs, using the <code dir="ltr">delay_seconds</code> parameter can reduce the amount of redo logging required to support scheduled jobs.</p>
<p>As with most performance features, there is a point of diminishing returns. Keep the length of the <code dir="ltr">delay_seconds</code> parameter in check for the following reasons:</p>
</dd>
</dl>
<ul>
<li>
<p><span class="bold">Parallel Propagation</span>: Each parallel process that is used when pushing the deferred transaction queue is not available for other parallel activities until the propagation job is complete. A long <code dir="ltr">delay_seconds</code> value might keep the parallel process unavailable for other operations. To use parallel propagation, you set the <code dir="ltr">parallelism</code> parameter to 1 or higher in the <code dir="ltr">SCHEDULE_PUSH</code> procedure or the <code dir="ltr">PUSH</code> function.</p>
</li>
<li>
<p><span class="bold">Serial Propagation</span>: If you are using serial propagation (not parallel propagation), then the <code dir="ltr">delay_seconds</code> value causes the open session to &#34;sleep&#34; for the entire length of the delay, providing none of the benefits earlier described. To use serial propagation, you set the <code dir="ltr">parallelism</code> parameter to 0 (zero) in the <code dir="ltr">SCHEDULE_PUSH</code> procedure or the <code dir="ltr">PUSH</code> function.</p>
</li>
<li>
<p><span class="bold">Precise Purge</span>: If you specify the <code dir="ltr">purge_method_precise</code> method when using the <code dir="ltr">DBMS_DEFER_SYS.PURGE</code> procedure and you have defined a large <code dir="ltr">delay_seconds</code> value, then you might experience performance degradation when performing the specified purge. Using <code dir="ltr">purge_method_precise</code> is more expensive than the alternative (<code dir="ltr">purge_method_quick</code>), but it ensures that the deferred transactions and procedure calls are purged after they have been successfully pushed.</p>
</li>
</ul>
<p>As a general rule of thumb, there are few viewable benefits of setting the <code dir="ltr">delay_seconds</code> parameter to a value greater than 20 minutes (which is 1200 seconds for the parameter setting).</p>
<p>Additionally, if you are using serial propagation by setting the <code dir="ltr">parallelism</code> parameter to 0, then you probably do not want to set a large <code dir="ltr">delay_seconds</code> value. Unlike parallel propagation, serial propagation only checks the queue after the duration of the <code dir="ltr">delay_seconds</code> value has elapsed. If you use serial propagation and set <code dir="ltr">delay_seconds</code> to 20 minutes, then the scheduled job sleeps for the entire 20 minutes, and any deferred transactions that enter the deferred transaction queue during that time are not pushed until 20 minutes have elapsed. Therefore, if you are using serial propagation, then consider setting <code dir="ltr">delay_seconds</code> to a value of 60 seconds or lower.</p>
<p>If you set a value of 20 minutes for parallel propagation, then the parallel push checks once a minute. If you can afford this resource lock, then the relatively high <code dir="ltr">delay_seconds</code> value of 20 minutes is probably most efficient in your environment. If, however, you cannot afford this resource lock, then consider setting the <code dir="ltr">delay_seconds</code> value to 10 or 20 seconds. Although you must execute the jobs more often than if the value was set to 1200 seconds, you still gain many of the benefits of the <code dir="ltr">delay_seconds</code> feature (versus the default value of 0 seconds).</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i42236"></a>
<div id="REPLN257" class="sect2">
<h3 class="sect2">Replication Protection Mechanisms<a id="sthref339"></a><a id="sthref340"></a><a id="sthref341"></a></h3>
<p>In a multimaster replication environment, Oracle ensures that transactions propagated to remote sites are never lost and never propagated more than once, even when failures occur. Oracle protects transactions in the following ways:</p>
<ul>
<li>
<p>Multiple procedure calls submitted within a single local transaction are executed within a transaction remotely.</p>
</li>
<li>
<p>If the network or remote database fails during propagation, then the transaction is rolled back at the remote site and the transaction remains in the local queue at the originating site until the remote database becomes accessible again and the transaction can be successfully propagated.</p>
</li>
<li>
<p>A transaction is not removed from the queue at the local site until it is successfully propagated and applied to all of its destination sites. Even after the transaction is successfully propagated to all destination sites, it remains in the queue until the purge job removes it.</p>
</li>
</ul>
<p>In the case of parallel propagation, replication uses a special-purpose distributed transaction protocol optimized for propagation. The remote site keeps track of the transactions that have been propagated successfully and sends this information back to the local site when it is requested. The local site records this information and purges the entries in its local queue that have been propagated to all destination sites. In case of failures, the local site asks the remote site for information about the transactions that have been propagated successfully so that propagation can continue at the appropriate point.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Successful propagation does not necessarily imply successful application of the transaction at the remote site. Errors such as unresolvable conflicts or running out of storage space can cause the transaction to result in an error, which is logged at the remote site as an error transaction.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i37218">&#34;Parallel Propagation&#34;</a></p>
</li>
<li>
<p>The Advanced Replication interface online Help for more information about viewing and managing error transactions with the Advanced Replication interface in Oracle Enterprise Manager Cloud Control</p>
</li>
</ul>
</div>
<a id="i42149"></a>
<div id="REPLN258" class="sect3">
<h4 class="sect3">Data Propagation Dependency Maintenance<a id="sthref342"></a><a id="sthref343"></a><a id="sthref344"></a></h4>
<p>Oracle maintains dependency ordering when propagating replicated transactions to remote sites. For example, consider the following transactions:</p>
<ol>
<li>
<p>Transaction A cancels an order.</p>
</li>
<li>
<p>Transaction B sees the cancellation and processes a refund.</p>
</li>
</ol>
<p>Transaction B depends on transaction A because transaction B sees the committed update canceling the order (transaction A) on the local system.</p>
<p>Oracle propagates transaction B (the refund) <span class="italic">after</span> it successfully propagates transaction A (the order cancellation). Oracle applies the updates that process the refund <span class="italic">after</span> it applies the cancellation.</p>
<div id="REPLN259" class="sect4"><a id="sthref345"></a>
<h5 class="sect4">Parallel Propagation Dependency Tracking<a id="sthref346"></a><a id="sthref347"></a></h5>
<p>When Oracle executes a new transaction on the local system, Oracle completes the following process:</p>
<ol>
<li>
<p>Oracle records the system change number (SCN) of the most recent transaction that updates data that is seen by the new transaction as the dependent SCN. You can record the SCN either at the data block level or at the row level, as discussed later in this chapter.</p>
</li>
<li>
<p>Oracle ensures that transactions with SCNs less than or equal to the dependent SCN propagate successfully to the remote system.</p>
</li>
<li>
<p>Oracle propagates the waiting, dependent transaction.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
When there are no possible dependencies between transactions, Oracle propagates transactions in parallel.</div>
<p>Parallel propagation maintains data integrity in a manner different from that of serial propagation. With serial propagation, <a id="sthref348"></a><a id="sthref349"></a>Oracle applies all transactions in the same order that they commit on the local system to maintain any dependencies. With parallel propagation, Oracle tracks dependencies and executes them in commit order when dependencies can exist and in parallel when dependencies cannot exist. With both serial and parallel propagation, Oracle preserves the order of execution within a transaction. The deferred transaction executes every remote procedure call at each site in the same order as it was executed within the local transaction.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A single coordinator process exists for each database link to a remote site. Each database link to the same remote site requires a different connection qualifier.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i42930">&#34;Connection Qualifiers&#34;</a></div>
</div>
<!-- class="sect4" -->
<a id="i42789"></a>
<div id="REPLN260" class="sect4">
<h5 class="sect4">Use of Row-Level Dependency Tracking to Improve Parallelism<a id="sthref350"></a><a id="sthref351"></a><a id="sthref352"></a><a id="sthref353"></a><a id="sthref354"></a><a id="sthref355"></a></h5>
<p>When you create a table, you can specify the following options for tracking system change numbers (SCN)s:</p>
<ul>
<li>
<p><code dir="ltr">NOROWDEPENDENCIES</code>, the default, specifies that the SCN is tracked at the data block level.</p>
</li>
<li>
<p><code dir="ltr">ROWDEPENDENCIES</code> specifies that the SCN is tracked for each row in the table.</p>
</li>
</ul>
<p>When you use the <code dir="ltr">NOROWDEPENDENCIES</code> clause for a table, the data block SCN tracks the most recent update of a row that is stored in the data block. Other rows that were updated earlier can be stored in the same data block, but information about when these rows were updated is lost when a new SCN is applied at the data block level.</p>
<p>When you use the <code dir="ltr">ROWDEPENDENCIES</code> clause for a table, multiple SCNs can be stored in a single data block. That is, a separate SCN tracks changes for each row that is stored in the data block. If two rows that are stored in the same data block are changed by different transactions, then each row has an SCN that tracks the change. To track the SCN at the row level, each row in the table uses an additional six bytes of storage space.</p>
<p>Using the <code dir="ltr">ROWDEPENDENCIES</code> clause for a table enables parallel propagation to track dependencies and order changes more efficiently when applying the deferred transaction queue. This increased efficiency improves performance and provides greater scalability in replication environments.</p>
<p>You can use the following query to list the tables that are using the <code dir="ltr">ROWDEPENDENCIES</code> clause currently:</p>
<pre dir="ltr">SELECT OWNER, TABLE_NAME FROM DBA_TABLES 
  WHERE DEPENDENCIES = &#39;ENABLED&#39;;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repplan.htm#i20201">&#34;Row-Level Dependency Tracking&#34;</a> for information about creating a table using the <code dir="ltr">ROWDEPENDENCIES</code> clause</div>
</div>
<!-- class="sect4" -->
<div id="REPLN261" class="sect4"><a id="sthref356"></a>
<h5 class="sect4">Minimize Transaction Dependencies to Improve Parallelism<a id="sthref357"></a><a id="sthref358"></a></h5>
<p>If you did not use the <code dir="ltr">ROWDEPENDENCIES</code> clause for some of your replicated tables, then you can improve the performance of parallel propagation for these tables by minimizing transaction dependencies.</p>
<p>In this case, certain application conditions can establish dependencies among transactions that force Oracle to serialize the propagation of deferred transactions. When several unrelated transactions modify the same data block in a replicated table, Oracle serializes the propagation of the corresponding transactions to remote destinations.</p>
<p>To minimize transaction dependencies created at the data block level, avoid situations that concentrate data block modifications into one or a small number of data blocks. For example, when a replicated table experiences a high degree of <code dir="ltr">INSERT</code> activity, you can distribute the storage of new rows into multiple data blocks by creating multiple free lists for the table.</p>
<p><a id="i41997"></a>If possible, avoid situations where many transactions all update the same small table. For example, a poorly designed application might employ a small table that transactions read and update to simulate sequence number generation for a primary key. This design forces all transactions to update the same data block. A better solution is to create a sequence and cache sequence numbers to optimize primary key generation and improve parallel propagation performance.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBDGEEA"></a>
<div id="REPLN262" class="sect2">
<h3 class="sect2">Conflict Resolution Mechanisms<a id="sthref359"></a><a id="sthref360"></a></h3>
<p>The receiving master site in a replication environment detects update, uniqueness, and delete conflicts as follows:</p>
<ul>
<li>
<p>The receiving site detects an update conflict if there is any difference between the old values of the replicated row, which are the values before the modification, and the current values of the same row at the receiving site in either the primary key columns or the columns in an updated column group.</p>
</li>
<li>
<p>The receiving site detects a uniqueness conflict if a uniqueness constraint violation occurs during an <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> of a replicated row.</p>
</li>
<li>
<p>The receiving site detects a delete conflict if it cannot find a row for an <code dir="ltr">UPDATE</code> or <code dir="ltr">DELETE</code> statement because the primary key of the row does not exist.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
To detect and resolve an update conflict for a row, the propagating site must send a certain amount of data about the new and old versions of the row to the receiving site. For maximum performance, tune the amount of data that Oracle uses to support update conflict detection and resolution. For more information, see <a href="repconflicts.htm#i24725">&#34;Send and Compare Old Values&#34;</a>.</div>
<div id="REPLN263" class="sect3"><a id="sthref361"></a>
<h4 class="sect3">Row Identification During Conflict Detection</h4>
<p><a id="sthref362"></a><a id="sthref363"></a>To detect replication conflicts accurately, Oracle must be able to uniquely identify and match corresponding rows at different sites during data replication. Typically, Oracle&#39;s replication facility uses the primary key of a table to uniquely identify rows in the table. When a table does not have a primary key, you must designate an alternate key&mdash;a column or set of columns that Oracle can use to uniquely identify rows in the table during data replication.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Do not permit applications to update the primary key or alternate key columns of a table. This ensures that Oracle can identify rows and preserve the integrity of replicated data.</div>
</div>
<!-- class="sect3" -->
<div id="REPLN264" class="sect3"><a id="sthref364"></a>
<h4 class="sect3">Resolution of Data Conflicts<a id="sthref365"></a><a id="sthref366"></a></h4>
<p>Oracle provides a mechanism that enables you to define a conflict resolution method that resolves a data conflict when detected. Oracle provides several prebuilt conflict resolution methods:</p>
<ul>
<li>
<p>Latest and Earliest Timestamp</p>
</li>
<li>
<p>Overwrite and Discard</p>
</li>
<li>
<p>Maximum and Minimum</p>
</li>
<li>
<p>Additive and Average</p>
</li>
<li>
<p>Timestamp</p>
</li>
<li>
<p>Priority Group</p>
</li>
<li>
<p>Site Priority</p>
</li>
</ul>
<p>If the prebuilt Oracle conflict resolution methods do not meet the needs of your replication environment, then you have the option of writing your own conflict resolution method using PL/SQL and implementing it as a user-defined conflict resolution method. See <a href="repconflicts.htm#i26513">Chapter 5, &#34;Conflict Resolution Concepts and Architecture&#34;</a> to learn how conflict resolution works.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The online Help for the Advanced Replication interface to learn how to implement conflict resolution with Oracle Enterprise Manager Cloud Control, and see the <a class="olink REPMA006" href="../REPMA/rarconflictres.htm#REPMA006"><span class="italic">Oracle Database Advanced Replication Management API Reference</span></a> to learn how to implement conflict resolution using the replication management API.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5764">
<tr>
<td class="cellalignment5771">
<table class="cellalignment5769">
<tr>
<td class="cellalignment5768"><a href="repoverview.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5768"><a href="repmview.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5773">
<table class="cellalignment5767">
<tr>
<td class="cellalignment5768"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5768"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5768"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5768"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5768"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5768"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>