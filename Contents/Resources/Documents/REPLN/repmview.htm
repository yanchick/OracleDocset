<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-91724"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Materialized%20View%20Concepts%20and%20Architecture"></a><title>Materialized View Concepts and Architecture</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1042"/>
<meta name="dcterms.created" content="2015-02-06T8:21:52Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Advanced Replication"/>
<meta name="dcterms.identifier" content="E53117-02"/>
<meta name="dcterms.isVersionOf" content="REPLN"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="repmaster.htm" title="Previous" type="text/html"/>
<link rel="Next" href="repdt.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53117-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/15</span> <!-- End Header -->
<div id="REPLN003" class="chapter"><a id="i34980"></a>
<h1 class="chapter"><span class="secnum">3</span> Materialized View Concepts and Architecture</h1>
<p><a id="sthref367"></a><a id="sthref368"></a>This chapter explains the concepts and architecture of Oracle materialized views.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i29867">Materialized View Concepts</a></p>
</li>
<li>
<p><a href="#i29896">Materialized View Architecture</a></p>
</li>
</ul>
<a id="i29867"></a>
<div id="REPLN265" class="sect1">
<h2 class="sect1">Materialized View Concepts<a id="sthref369"></a></h2>
<p>Oracle uses <span class="glossaryterm">materialized views</span> (also known as snapshots in prior releases) to replicate data to nonmaster sites in a replication environment and to cache expensive queries in a data warehouse environment. This chapter, and this <span class="italic">Oracle Database Advanced Replication</span> manual in general, discusses materialized views for use in a replication environment.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#BABIIDJC">What is a Materialized View?</a></p>
</li>
<li>
<p><a href="#i44564">Why Use Materialized Views?</a></p>
</li>
<li>
<p><a href="#BABCCHDA">Read-Only, Updatable, and Writeable Materialized Views</a></p>
</li>
<li>
<p><a href="#i52501">Available Materialized Views</a></p>
</li>
<li>
<p><a href="#i53514">Required Privileges for Materialized View Operations</a></p>
</li>
<li>
<p><a href="#i28635">Data Subsetting with Materialized Views</a></p>
</li>
<li>
<p><a href="#BABEDIAH">Determining the Fast Refresh Capabilities of a Materialized View</a></p>
</li>
<li>
<p><a href="#i52377">Multitier Materialized Views</a></p>
</li>
<li>
<p><a href="#i55740">How Materialized Views Work with Object Types and Collections</a></p>
</li>
<li>
<p><a href="#i51957">Materialized View Registration at a Master Site or Master Materialized View Site</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../DWHSG/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn more about materialized views for data warehousing</div>
<a id="BABIIDJC"></a>
<div id="REPLN266" class="sect2">
<h3 class="sect2">What is a Materialized View?</h3>
<p>A materialized view is a replica of a target master from a single point in time. The master can be either a master table at a master site or a master materialized view at a materialized view site. Whereas in multimaster replication tables are continuously updated by other master sites, materialized views are updated from one or more masters through individual batch updates, known as a <span class="glossaryterm">refreshes</span>, from a single master site or master materialized view site, as illustrated in <a href="#g109816">Figure 3-1</a>. The arrows in <a href="#g109816">Figure 3-1</a> represent database links.</p>
<div id="REPLN267" class="figure">
<p class="titleinfigure"><a id="g109816"></a>Figure 3-1 Materialized View Connected to a Single Master Site</p>
<img width="395" height="254" src="img/repln072.gif" alt="Description of Figure 3-1 follows"/><br/>
<a id="sthref370" href="img_text/repln072.htm">Description of &#34;Figure 3-1 Materialized View Connected to a Single Master Site&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>When a fast refresh is performed on a materialized view, Oracle must examine all of the changes to the master table or master materialized view since the last refresh to see if any apply to the materialized view. Therefore, if any changes were made to the master since the last refresh, then a materialized view refresh takes some time to apply the changes to the materialized view. If, however, no changes at all were made to the master since the last refresh of a materialized view, then the materialized view refresh should be very quick.</p>
</div>
<!-- class="sect2" -->
<a id="i44564"></a>
<div id="REPLN268" class="sect2">
<h3 class="sect2">Why Use Materialized Views?<a id="sthref371"></a></h3>
<p>You can use materialized views to achieve one or more of the following goals:</p>
<ul>
<li>
<p><a href="#i36016">Ease Network Loads</a></p>
</li>
<li>
<p><a href="#i36021">Create a Mass Deployment Environment</a></p>
</li>
<li>
<p><a href="#i36025">Enable Data Subsetting</a></p>
</li>
<li>
<p><a href="#i36029">Enable Disconnected Computing</a></p>
</li>
</ul>
<a id="i36016"></a>
<div id="REPLN269" class="sect3">
<h4 class="sect3">Ease Network Loads<a id="sthref372"></a></h4>
<p>If one of your goals is to reduce network loads, then you can use materialized views to distribute your corporate database to regional sites. Instead of the entire company accessing a single database server, user load is distributed across multiple database servers. With multitier materialized views, you can create materialized views based on other materialized views, which enables you to distribute user load to an even greater extent because clients can access materialized view sites instead of master sites. To decrease the amount of data that is replicated, a materialized view can be a subset of a master table or master materialized view.</p>
<p>While multimaster replication also distributes a corporate database among multiple sites, the networking requirements for multimaster replication are greater than those for replicating with materialized views because of the transaction by transaction nature of multimaster replication. Further, the ability of multimaster replication to provide real-time or near real-time replication can result in greater network traffic, and might require a dedicated network link.</p>
<p>Materialized views are updated through an efficient batch process from a single master site or master materialized view site. They have lower network requirements and dependencies than multimaster replication because of the point in time nature of materialized view replication. Whereas multimaster replication requires constant communication over the network, materialized view replication requires only periodic refreshes.</p>
<p>In addition to not requiring a dedicated network connection, replicating data with materialized views increases data availability by providing local access to the target data. These benefits, combined with mass deployment and data subsetting (both of which also reduce network loads), greatly enhance the performance and reliability of your replicated database.</p>
</div>
<!-- class="sect3" -->
<a id="i36021"></a>
<div id="REPLN270" class="sect3">
<h4 class="sect3">Create a Mass Deployment<a id="sthref373"></a><a id="sthref374"></a> Environment</h4>
<p>Deployment templates enable you to precreate a materialized view environment locally. You can then use deployment templates to quickly and easily deploy materialized view environments to support sales force automation and other mass deployment environments. Parameters enable you to create custom data sets for individual users without changing the deployment template. This technology enables you to roll out a database infrastructure to hundreds or thousands of users.</p>
</div>
<!-- class="sect3" -->
<a id="i36025"></a>
<div id="REPLN271" class="sect3">
<h4 class="sect3">Enable Data Subsetting<a id="sthref375"></a></h4>
<p>Materialized views enable you to replicate data based on column- and row-level subsetting, while multimaster replication requires replication of the entire table. Data subsetting enables you to replicate information that pertains only to a particular site. For example, if you have a regional sales office, then you might replicate only the data that is needed in that region, thereby cutting down on unnecessary network traffic.</p>
</div>
<!-- class="sect3" -->
<a id="i36029"></a>
<div id="REPLN272" class="sect3">
<h4 class="sect3">Enable Disconnected Computing<a id="sthref376"></a></h4>
<p>Materialized views do not require a dedicated network connection. Though you have the option of automating the refresh process by scheduling a job, you can manually refresh your materialized view on-demand, which is an ideal solution for sales applications running on a laptop. For example, a developer can integrate the replication management API for refresh on-demand into the sales application. When the salesperson has completed the day&#39;s orders, the salesperson simply dials up the network and uses the integrated mechanism to refresh the database, thus transferring the orders to the main office.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABCCHDA"></a>
<div id="REPLN273" class="sect2">
<h3 class="sect2">Read-Only, Updatable, and Writeable Materialized Views</h3>
<p>A materialized view can be either read-only, updatable, or writeable. Users cannot perform data manipulation language (DML) statements on read-only materialized views, but they can perform DML on updatable and writeable materialized views.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
For read-only, updatable, and writeable materialized views defined using the default primary key option, the defining query of the materialized view must reference all of the primary key columns in the master.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="repoverview.htm#i12887">&#34;Materialized View Replication&#34;</a> for an introduction to read-only and updatable materialized views</p>
</li>
<li>
<p><a href="repplan.htm#i15320">&#34;Considerations for Replicated Tables&#34;</a></p>
</li>
</ul>
</div>
<a id="i50978"></a>
<div id="REPLN274" class="sect3">
<h4 class="sect3">Read-Only Materialized Views<a id="sthref377"></a><a id="sthref378"></a></h4>
<p>You can make a materialized view read-only during creation by omitting the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause or disabling the equivalent option in the Advanced Replication interface in Oracle Enterprise Manager Cloud Control. Read-only materialized views use many of the same mechanisms as updatable materialized views, except that they do not need to belong to a materialized view group.</p>
<p>In addition, using read-only materialized views eliminates the possibility of a materialized view introducing data conflicts at the master site or master materialized view site, although this convenience means that updates cannot be made at the remote materialized view site. The following is an example of a read-only materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.employees AS
  SELECT * FROM hr.employees@orc1.example.com;
</pre></div>
<!-- class="sect3" -->
<div id="REPLN275" class="sect3"><a id="sthref379"></a>
<h4 class="sect3">Updatable Materialized Views<a id="sthref380"></a><a id="sthref381"></a></h4>
<p>You can make a materialized view updatable during creation by including the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause or enabling the equivalent option in the Advanced Replication interface in Oracle Enterprise Manager Cloud Control. For changes made to an updatable materialized view to be pushed back to the master during refresh, the updatable materialized view must belong to a materialized view group.</p>
<p>Updatable materialized views enable you to decrease the load on master sites because users can make changes to the data at the materialized view site. The following is an example of an updatable materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.departments FOR UPDATE AS
  SELECT * FROM hr.departments@orc1.example.com;
</pre>
<p>The following statement creates a materialized view group:</p>
<pre dir="ltr">BEGIN
   DBMS_REPCAT.CREATE_MVIEW_REPGROUP (<a id="sthref382"></a><a id="sthref383"></a>
      gname =&gt; &#39;hr_repg&#39;,
      master =&gt; &#39;orc1.example.com&#39;,
      propagation_mode =&gt; &#39;ASYNCHRONOUS&#39;);
END;
/
</pre>
<p>The following statement adds the <code dir="ltr">hr.departments</code> materialized view to the materialized view group, making the materialized view updatable:</p>
<pre dir="ltr">BEGIN
   DBMS_REPCAT.CREATE_MVIEW_REPOBJECT (<a id="sthref384"></a><a id="sthref385"></a>
      gname =&gt; &#39;hr_repg&#39;,
      sname =&gt; &#39;hr&#39;,
      oname =&gt; &#39;departments&#39;,
      type =&gt; &#39;SNAPSHOT&#39;,
      min_communication =&gt; TRUE);
END;
</pre>
<p>/</p>
<p>You can also use the Advanced Replication interface in Oracle Enterprise Manager Cloud Control to create a materialized view group and add a materialized view to it.</p>
<p><span class="bold"><a id="sthref386"></a></span>In a single master site environment that has updatable materialized views, quiesce is not required when you perform administration operations on the master site if you:</p>
<ul>
<li>
<p>Propagate all of the deferred transactions at the databases containing updatable materialized views before you perform the administration operations to the master group.</p>
</li>
<li>
<p>Do not allow any database manipulation language (DML) changes on the updatable materialized views until you have finished the administration operation on the master site and regenerated replication support for the materialized view.</p>
</li>
</ul>
<p>If you do not perform these actions, then quiesce the master group before you perform the administration operations on it.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="sthref387"></a><a id="sthref388"></a>
<ul>
<li>
<p>Do not use column aliases when you are creating an updatable materialized view. Column aliases cause an error when you attempt to add the materialized view to a materialized view group using the <code dir="ltr">CREATE_MVIEW_REPOBJECT</code> procedure.</p>
</li>
<li>
<p>An updatable materialized view based on a master table or master materialized view that has defined column default values does not automatically use the master&#39;s default values.</p>
</li>
<li>
<p><a id="sthref389"></a><a id="sthref390"></a>A <code dir="ltr">DELETE</code> <code dir="ltr">CASCADE</code> constraint used with an updatable materialized view must be deferrable.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i30731">&#34;Materialized View Groups&#34;</a> for more information</p>
</li>
<li>
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about column aliases</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="REPLN276" class="sect3"><a id="sthref391"></a>
<h4 class="sect3">Writeable Materialized Views<a id="sthref392"></a><a id="sthref393"></a></h4>
<p>A writeable materialized view is one that is created using the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause but is not part of a materialized view group. Users can perform DML operations on a writeable materialized view, but if you refresh the materialized view, then these changes are not pushed back to the master and the changes are lost in the materialized view itself. Writeable materialized views are typically allowed wherever fast-refreshable read-only materialized views are allowed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Most of the documentation about materialized views only refers to read-only and updatable materialized views because writeable materialized views are rarely used.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i52501"></a>
<div id="REPLN277" class="sect2">
<h3 class="sect2">Available Materialized Views<a id="sthref394"></a></h3>
<p>Oracle offers several types of materialized views to meet the needs of many different replication (and nonreplication) situations. The following sections describe each type of materialized view and also describe some environments for which they are best suited.</p>
<p>The following sections contain examples of creating different types of materialized views:</p>
<ul>
<li>
<p><a href="#i30768">Primary Key Materialized Views</a></p>
</li>
<li>
<p><a href="#i55634">Object Materialized Views</a></p>
</li>
<li>
<p><a href="#i44949">ROWID Materialized Views</a></p>
</li>
<li>
<p><a href="#BABEEHGJ">Complex Materialized Views</a></p>
</li>
</ul>
<p>Whenever you create a materialized view, regardless of its type, always specify the schema name of the table owner in the query for the materialized view. For example, consider the following <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.employees
  AS SELECT * FROM hr.employees@orc1.example.com;
</pre>
<p>Here, the schema <code dir="ltr">hr</code> is specified in the query.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot execute a distributed transaction that includes changes to the master table of a refresh-on-commit materialized view. Refresh-on-commit materialized views are those created using the <code dir="ltr">ON</code> <code dir="ltr">COMMIT</code> <code dir="ltr">REFRESH</code> clause in the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement. You can execute a distributed transaction that includes changes to the master table of a refresh-on-demand materialized view.</div>
<a id="i30768"></a>
<div id="REPLN278" class="sect3">
<h4 class="sect3">Primary Key Materialized Views<a id="sthref395"></a><a id="sthref396"></a></h4>
<p>Primary key materialized views are the default type of materialized view. They are updatable if the materialized view was created as part of a materialized view group and <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> was specified when defining the materialized view. An updatable materialized view must belong to a materialized view group that has the same name as the replication group at its master site or master materialized view site. In addition, an updatable materialized view must reside in a different database than the master replication group.</p>
<p>Changes are propagated according to the row-level changes that have occurred, as identified by the primary key value of the row (not the <code dir="ltr">ROWID</code>). The following is an example of a SQL statement for creating an updatable, primary key materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.customers FOR UPDATE AS
  SELECT * FROM oe.customers@orc1.example.com;
</pre>
<p>Primary key materialized views can contain a subquery so that you can create a subset of rows at the remote materialized view site. A subquery is a query imbedded within the primary query, so that you have multiple <code dir="ltr">SELECT</code> statements in the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement. This subquery can be as simple as a basic <code dir="ltr">WHERE</code> clause or as complex as a multilevel <code dir="ltr">WHERE</code> <code dir="ltr">EXISTS</code> clause. Primary key materialized views that contain a selected class of subqueries can still be incrementally (or fast) refreshed, if each master referenced has a materialized view log. A fast refresh uses materialized view logs to update only the rows that have changed since the last refresh.</p>
<p>The following materialized view is created with a <code dir="ltr">WHERE</code> clause containing a subquery:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.orders REFRESH FAST AS
 SELECT * FROM oe.orders@orc1.example.com o
 WHERE EXISTS
   (SELECT * FROM oe.customers@orc1.example.com c
    WHERE o.customer_id = c.customer_id AND c.credit_limit &gt; 10000);
</pre>
<p>This type of materialized view is called a subquery materialized view.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To create this <code dir="ltr">oe.orders</code> materialized view, <code dir="ltr">credit_limit</code> must be logged in the master&#39;s materialized view log. See <a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a> for more information.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i30731">&#34;Materialized View Groups&#34;</a> for more information about materialized view groups</p>
</li>
<li>
<p><a href="#i30893">&#34;Materialized Views with Subqueries&#34;</a> for more information about materialized views with subqueries</p>
</li>
<li>
<p><a href="#i29858">&#34;Refresh Types&#34;</a> for more information about fast refresh</p>
</li>
<li>
<p><a href="#i30732">&#34;Materialized View Log&#34;</a> for more information about materialized view logs</p>
</li>
<li>
<p><a class="olink SQLRF007" href="../SQLRF/queries.htm#SQLRF007"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about subqueries</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i55634"></a>
<div id="REPLN279" class="sect3">
<h4 class="sect3">Object Materialized Views</h4>
<p>If a materialized view is based on an object table and is created using the <code dir="ltr">OF</code> <span class="italic">type</span> clause, then the materialized view is called an <span class="bold">object materialized view</span>. An object materialized view is structured in the same way as an object table. That is, an object materialized view is composed of row objects, and each row object is identified by an object identifier (OID) column.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i55614">&#34;Materialized Views Based on Object Tables&#34;</a></div>
</div>
<!-- class="sect3" -->
<a id="i44949"></a>
<div id="REPLN280" class="sect3">
<h4 class="sect3">ROWID Materialized Views<a id="sthref397"></a><a id="sthref398"></a></h4>
<p>Oracle supports <code dir="ltr">ROWID</code> materialized views in addition to the default primary key materialized views. A <code dir="ltr">ROWID</code> materialized view is based on the physical row identifiers (rowids) of the rows in a master. <code dir="ltr">ROWID</code> materialized views can be used for materialized views based on master tables that do not have a primary key, or for materialized views that do not include all primary key columns of the master tables.</p>
<p>The following is an example of a <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement that creates a <code dir="ltr">ROWID</code> materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.orders REFRESH WITH ROWID AS
 SELECT * FROM oe.orders@orc1.example.com;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i30732">&#34;Materialized View Log&#34;</a> for more information about the differences between a <code dir="ltr">ROWID</code> and primary key materialized view</p>
</li>
<li>
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">WITH</code> <code dir="ltr">ROWID</code> clause in the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABEEHGJ"></a>
<div id="REPLN281" class="sect3">
<h4 class="sect3">Complex Materialized Views<a id="sthref399"></a><a id="sthref400"></a></h4>
<p>To be fast refreshed, the defining query for a materialized view must observe certain restrictions. If you require a materialized view whose defining query is more general and cannot observe the restrictions, then the materialized view is complex and cannot be fast refreshed.</p>
<p>Specifically, a materialized view is considered complex when the defining query of the materialized view contains:</p>
<ul>
<li>
<p>A <code dir="ltr">CONNECT</code> <code dir="ltr">BY</code> clause</p>
<p>For example, the following statement creates a complex materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.emp_hierarchy AS
  SELECT LPAD(&#39; &#39;, 4*(LEVEL-1))||email USERNAME 
    FROM hr.employees@orc1.example.com START WITH manager_id IS NULL 
    CONNECT BY PRIOR employee_id = manager_id;
</pre></li>
<li>
<p>An <code dir="ltr">INTERSECT</code>, <code dir="ltr">MINUS</code>, or <code dir="ltr">UNION</code> <code dir="ltr">ALL</code> set operation</p>
<p>For example, the following statement creates a complex materialized view because it has a <code dir="ltr">UNION</code> <code dir="ltr">ALL</code> set operation:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.mview_employees AS
  SELECT employees.employee_id, employees.email 
  FROM hr.employees@orc1.example.com
UNION ALL
  SELECT new_employees.employee_id, new_employees.email 
  FROM hr.new_employees@orc1.example.com;
</pre></li>
<li>
<p>The <code dir="ltr">DISTINCT</code> or <code dir="ltr">UNIQUE</code> keyword</p>
<p>For example, the following statement creates a complex materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.employee_depts AS
  SELECT DISTINCT department_id FROM hr.employees@orc1.example.com 
  ORDER BY department_id; 
</pre></li>
<li>
<p>In some cases, an aggregate function, although it is possible to have an aggregate function in the defining query and still have a simple materialized view</p>
<p>For example, the following statement creates a complex materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.average_sal AS
  SELECT AVG(salary) &#34;Average&#34; FROM hr.employees@orc1.example.com;
</pre></li>
<li>
<p>In some cases, joins other than those in a subquery, although it is possible to have joins in the defining query and still have a simple materialized view</p>
<p>For example, the following statement creates a complex materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.emp_join_dep AS
  SELECT last_name 
  FROM hr.employees@orc1.example.com e, hr.departments@orc1.example.com d
  WHERE e.department_id = d.department_id; 
</pre></li>
<li>
<p>In some cases, a <code dir="ltr">UNION</code> operation</p>
<p>Specifically, a materialized view with a <code dir="ltr">UNION</code> operation is complex if any one of these conditions is true:</p>
<ul>
<li>
<p>Any query within the <code dir="ltr">UNION</code> is complex. The previous bullet items specify when a query makes a materialized view complex.</p>
</li>
<li>
<p>The outermost <code dir="ltr">SELECT</code> list columns do not match for the queries in the <code dir="ltr">UNION</code>. In the following example, the first query only has <code dir="ltr">order_total</code> in the outermost <code dir="ltr">SELECT</code> list while the second query has <code dir="ltr">customer_id</code> in the outermost <code dir="ltr">SELECT</code> list. Therefore, the materialized view is complex.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.orders AS
  SELECT order_total 
  FROM oe.orders@orc1.example.com o
  WHERE EXISTS
    (SELECT cust_first_name, cust_last_name
       FROM oe.customers@orc1.example.com c
       WHERE o.customer_id = c.customer_id 
       AND c.credit_limit &gt; 50)
UNION    
  SELECT customer_id 
  FROM oe.orders@orc1.example.com o
  WHERE EXISTS
    (SELECT cust_first_name, cust_last_name 
       FROM oe.customers@orc1.example.com c
       WHERE o.customer_id = c.customer_id 
       AND c.account_mgr_id = 30);  
</pre>
<p>The innermost <code dir="ltr">SELECT</code> list has no bearing on whether a materialized view is complex. In the previous example, the innermost <code dir="ltr">SELECT</code> list is <code dir="ltr">cust_first_name</code> and <code dir="ltr">cust_last_name</code> for both queries in the <code dir="ltr">UNION</code>.</p>
</li>
</ul>
</li>
<li>
<p>Clauses that do not follow the requirements detailed in <a href="#i28701">&#34;Restrictions for Materialized Views with Subqueries&#34;</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If possible, you should avoid using complex materialized views because they cannot be fast refreshed, which might degrade network performance (see <a href="#i31171">&#34;Refresh Process&#34;</a> for information).</div>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink DWHSG" href="../DWHSG/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for information about materialized views with aggregate functions and joins</p>
</li>
<li>
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">CONNECT</code> <code dir="ltr">BY</code> clause, set operations, the <code dir="ltr">DISTINCT</code> keyword, and aggregate functions</p>
</li>
</ul>
</div>
<div id="REPLN282" class="sect4"><a id="sthref401"></a>
<h5 class="sect4">A Comparison of Simple and Complex Materialized Views<a id="sthref402"></a><a id="sthref403"></a><a id="sthref404"></a><a id="sthref405"></a></h5>
<p>For certain applications, you might want to consider using a complex materialized view. <a href="#i57556">Figure 3-2</a> and the following text discuss some issues that you should consider.</p>
<div id="REPLN283" class="figure">
<p class="titleinfigure"><a id="i57556"></a>Figure 3-2 Comparison of Simple and Complex Materialized Views</p>
<img width="600" height="392" src="img/repln023.gif" alt="Description of Figure 3-2 follows"/><br/>
<a id="sthref406" href="img_text/repln023.htm">Description of &#34;Figure 3-2 Comparison of Simple and Complex Materialized Views&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<ul>
<li>
<p><span class="bold">Complex Materialized View</span>: Method A in <a href="#i57556">Figure 3-2</a> shows a complex materialized view. The materialized view in Database II exhibits efficient query performance because the join operation was completed during the materialized view&#39;s refresh. However, complete refreshes must be performed because the materialized view is complex, and these refreshes will probably be slower than fast refreshes.</p>
</li>
<li>
<p><span class="bold">Simple Materialized Views with a Joined View</span>: Method B in <a href="#i57556">Figure 3-2</a> shows two simple materialized views in Database II, as well as a view that performs the join in the materialized view&#39;s database. Query performance against the view would not be as good as the query performance against the complex materialized view in Method A. However, the simple materialized views can be refreshed more efficiently using fast refresh and materialized view logs.</p>
</li>
</ul>
<p>In summary, to decide which method to use:</p>
<ul>
<li>
<p>If you refresh rarely and want faster query performance, then use Method A (complex materialized view).</p>
</li>
<li>
<p>If you refresh regularly and can sacrifice query performance, then use Method&nbsp;B (simple materialized view).</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i53514"></a>
<div id="REPLN284" class="sect2">
<h3 class="sect2">Required Privileges for Materialized View Operations<a id="sthref407"></a><a id="sthref408"></a><a id="sthref409"></a><a id="sthref410"></a><a id="sthref411"></a></h3>
<p>Three distinct types of users perform operations on materialized views:</p>
<ul>
<li>
<p><span class="bold">Creator:</span> the user who creates the materialized view.</p>
</li>
<li>
<p><span class="bold">Refresher:</span> the user who refreshes the materialized view.</p>
</li>
<li>
<p><span class="bold">Owner:</span> the user who owns the materialized view. The materialized view resides in this user&#39;s schema.</p>
</li>
</ul>
<p>One user can perform all of these operations on a particular materialized view. However, in some replication environments, different users perform these operations on a particular materialized view. The privileges required to perform these operations depend on whether the same user performs them or different users perform them. The following sections explain the privileges requirements in detail.</p>
<p>If the owner of a materialized view at the materialized view site has a private database link to the master site or master materialized view site, then the database link connects to the owner of the master at the master site or master materialized view site. Otherwise, the normal rules for connections through database links apply.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following sections do not cover the requirements necessary to create materialized views with query rewrite enabled. See the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for information.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The following sections discuss database links. See the <a class="olink ADMIN028" href="../ADMIN/ds_concepts.htm#ADMIN028"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information about using database links.</div>
<div id="REPLN285" class="sect3"><a id="sthref412"></a>
<h4 class="sect3">Creator Is Owner</h4>
<p>If the creator of a materialized view also owns the materialized view, then this user must have the following privileges to create a materialized view, granted explicitly rather than through a role:</p>
<ul>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> or <code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code>.</p>
</li>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> or <code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code>.</p>
</li>
<li>
<p><code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> object privilege on the master and the master&#39;s materialized view log or either <code dir="ltr">READ</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> or <code dir="ltr">SELECT</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> system privilege. If the master site or master materialized view site is remote, then the <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> object privilege must be granted to the user at the master site or master materialized view site to which the user at the materialized view site connects through a database link.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="REPLN286" class="sect3"><a id="sthref413"></a>
<h4 class="sect3">Creator Is Not Owner</h4>
<p>If the creator of a materialized view is not the owner, certain privileges must be granted to the creator and to the owner to create a materialized view. Both the creator&#39;s privileges and the owner&#39;s privileges must be granted explicitly rather than through a role.</p>
<p><a href="#g89736">Table 3-1</a> shows the required privileges when the creator of the materialized view is not the owner.</p>
<div id="REPLN287" class="tblhruleformal">
<p class="titleintable"><a id="sthref414"></a><a id="g89736"></a>Table 3-1 Required Privileges for Creating Materialized Views (Creator != Owner)</p>
<table class="cellalignment5774" title="Required Privileges for Creating Materialized Views (Creator != Owner)" summary="This table shows the required privileges for the creator and the owner when creating materialized views for the case where the creator is not the owner." dir="ltr">
<thead>
<tr class="cellalignment5765">
<th class="cellalignment5775" id="r1c1-t17">Creator</th>
<th class="cellalignment5775" id="r1c2-t17">Owner</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r2c1-t17" headers="r1c1-t17">
<p><code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code></p>
</td>
<td class="cellalignment5771" headers="r2c1-t17 r1c2-t17">
<p><code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> or <code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code></p>
<p><code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> object privilege on the master and the master&#39;s materialized view log or either <code dir="ltr">READ</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> or <code dir="ltr">SELECT</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> system privilege. If the master site or master materialized view site is remote, then the <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> object privilege must be granted to the user at the master site or master materialized view site to which the user at the materialized view site connects through a database link.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect3" -->
<div id="REPLN288" class="sect3"><a id="sthref415"></a>
<h4 class="sect3">Refresher Is Owner</h4>
<p>If the refresher of a materialized view also owns the materialized view, this user must have <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> object privilege on the master and the master&#39;s materialized view log or either <code dir="ltr">READ</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> or <code dir="ltr">SELECT</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> system privilege. If the master site or master materialized view site is remote, then the <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> object privilege must be granted to the user at the master site or master materialized view site to which the user at the materialized view site connects through a database link. This privilege can be granted either explicitly or through a role.</p>
</div>
<!-- class="sect3" -->
<div id="REPLN289" class="sect3"><a id="sthref416"></a>
<h4 class="sect3">Refresher Is Not Owner</h4>
<p>If the refresher of a materialized view is not the owner, certain privileges must be granted to the refresher and to the owner. These privileges can be granted either explicitly or through a role.</p>
<p><a href="#g89746">Table 3-2</a> shows the required privileges when the refresher of the materialized view is not the owner.</p>
<div id="REPLN290" class="tblhruleformal">
<p class="titleintable"><a id="sthref417"></a><a id="g89746"></a>Table 3-2 Required Privileges for Refreshing Materialized Views (Refresher != Owner)</p>
<table class="cellalignment5774" title="Required Privileges for Refreshing Materialized Views (Refresher != Owner)" summary="This table shows the required privileges for the refresher and the owner when refreshing materialized views for the case where the refresher is not the owner." dir="ltr">
<thead>
<tr class="cellalignment5765">
<th class="cellalignment5775" id="r1c1-t18">Refresher</th>
<th class="cellalignment5775" id="r1c2-t18">Owner</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r2c1-t18" headers="r1c1-t18">
<p><code dir="ltr">ALTER</code> <code dir="ltr">ANY</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code></p>
</td>
<td class="cellalignment5771" headers="r2c1-t18 r1c2-t18">
<p>If the master site or master materialized view site is local, then <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> object privilege on the master and master&#39;s materialized view log or either <code dir="ltr">READ</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> or <code dir="ltr">SELECT</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> system privilege.</p>
<p>If the master site or master materialized view site is remote, then the <code dir="ltr">READ</code> or <code dir="ltr">SELECT</code> object privilege must be granted to the user at the master site or master materialized view site to which the user at the materialized view site connects through a database link.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i28635"></a>
<div id="REPLN291" class="sect2">
<h3 class="sect2">Data Subsetting with Materialized Views<a id="sthref418"></a><a id="sthref419"></a><a id="sthref420"></a><a id="sthref421"></a></h3>
<p>In certain situations, you might want your materialized view to reflect a subset of the data in the master table or master materialized view. Row subsetting enables you to include only the rows that are needed from the master in the materialized views by using a <code dir="ltr">WHERE</code> clause. Column subsetting enables you to include only the columns that are needed from the master in the materialized views. You do this by specifying certain select columns in the <code dir="ltr">SELECT</code> statement during materialized view creation. If you use deployment templates to build your materialized views, then you can define column subsets on updatable materialized views.</p>
<p>Some reasons to use data subsetting are to:</p>
<ul>
<li>
<p><span class="bold">Reduce Network Traffic</span>: In a column-subsetted materialized view, only changes that satisfy the <code dir="ltr">WHERE</code> clause of the materialized view&#39;s defining query are propagated to the materialized view site, thereby reducing the amount of data transferred and reducing network traffic.</p>
</li>
<li>
<p><span class="bold">Secure Sensitive Data</span>: Users can only view data that satisfies the defining query for the materialized view.</p>
</li>
<li>
<p><span class="bold">Reduce Resource Requirements</span>: If the materialized view is located on a laptop, then hard disks are generally significantly smaller than the hard disks on a corporate server. Subsetted materialized views might require significantly less storage space.</p>
</li>
<li>
<p><span class="bold">Improve Refresh Times</span>: Because less data is propagated to the materialized view site, the refresh process is faster, which is essential for those who need to refresh materialized views using a dial up network connection from a laptop.</p>
</li>
</ul>
<p>For example, the following statement creates a materialized view based on the <code dir="ltr">oe.orders@orc1.example.com</code> master table and includes only the rows for the sales representative with a <code dir="ltr">sales_rep_id</code> number of <code dir="ltr">173</code>:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.orders REFRESH FAST AS
 SELECT * FROM oe.orders@orc1.example.com
 WHERE sales_rep_id = 173;
</pre>
<p>Rows of the orders table with a <code dir="ltr">sales_rep_id</code> number other than <code dir="ltr">173</code> are excluded from this materialized view.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following sections discuss row subsetting with subqueries. For more information about column subsetting, see <a href="repdt.htm#i29069">&#34;Column Subsetting with Deployment Templates&#34;</a>.</div>
<a id="i30893"></a>
<div id="REPLN292" class="sect3">
<h4 class="sect3">Materialized Views with Subqueries<a id="sthref422"></a><a id="sthref423"></a></h4>
<p>The previous example works well for individual materialized views that do not have any referential constraints to other materialized views. But, if you want to replicate data based on the information in multiple tables, then maintaining and defining these materialized views can be difficult. The following sections provide examples of situations where a subquery is useful.</p>
<div id="REPLN293" class="sect4"><a id="sthref424"></a>
<h5 class="sect4">Many to One Subqueries<a id="sthref425"></a><a id="sthref426"></a><a id="sthref427"></a></h5>
<p>Consider a scenario where you have the <code dir="ltr">customers</code> table and <code dir="ltr">orders</code> table in the <code dir="ltr">oe</code> schema, and you want to create a materialized view of the <code dir="ltr">orders</code> table based on data in both the <code dir="ltr">orders</code> table and the <code dir="ltr">customers</code> table. For example, suppose a salesperson wants to see all of the orders for the customers with a credit limit greater than $10,000. In this case, the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement that creates the <code dir="ltr">orders</code> materialized view has a subquery with a many to one relationship, because there can be many orders for each customer.</p>
<p>Look at the relationships in <a href="#i30029">Figure 3-3</a>, and notice that the <code dir="ltr">customers</code> and <code dir="ltr">orders</code> tables are related through the <code dir="ltr">customer_id</code> column. The following statement satisfies the original goal of the salesperson. That is, the following statement creates a materialized view that contains orders for customers whose credit limit is greater than $10,000:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.orders REFRESH FAST FOR UPDATE AS
  SELECT * FROM oe.orders@orc1.example.com o
  WHERE EXISTS
    (SELECT * FROM oe.customers@orc1.example.com c
     WHERE o.customer_id = c.customer_id AND c.credit_limit &gt; 10000);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To create this <code dir="ltr">oe.orders</code> materialized view, <code dir="ltr">credit_limit</code> must be logged in the master&#39;s materialized view log. See <a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a> for more information.</div>
<div id="REPLN294" class="figure">
<p class="titleinfigure"><a id="i30029"></a>Figure 3-3 Row Subsetting with Many to One Subqueries</p>
<img width="600" height="192" src="img/repln088.gif" alt="Description of Figure 3-3 follows"/><br/>
<a id="sthref428" href="img_text/repln088.htm">Description of &#34;Figure 3-3 Row Subsetting with Many to One Subqueries&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>As you can see, the materialized view created by this statement is fast refreshable and updatable. If new customers are identified that have a credit limit greater than $10,000, then the new data will be propagated to the materialized view site during the subsequent refresh process. Similarly, if a customer&#39;s credit limit drops to less than $10,000, then the customer&#39;s data will be removed from the materialized view during the subsequent refresh process.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN295" class="sect4"><a id="sthref429"></a>
<h5 class="sect4">One to Many Subqueries<a id="sthref430"></a><a id="sthref431"></a><a id="sthref432"></a></h5>
<p>Consider a scenario where you have the <code dir="ltr">customers</code> table and <code dir="ltr">orders</code> table in the <code dir="ltr">oe</code> schema, and you want to create a materialized view of the <code dir="ltr">customers</code> table based on data in both the <code dir="ltr">customers</code> table and the <code dir="ltr">orders</code> table. For example, suppose a salesperson wants to see all of the customers who have an order with an order total greater than $20,000, then the most efficient method is to create a materialized view with a one to many subquery in the defining query of a materialized view.</p>
<p>Here, the defining query in the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement on the <code dir="ltr">customers</code> table has a subquery with a one to many relationship. That is, one customer can have many orders.</p>
<p>Look at the relationships in <a href="#i57830">Figure 3-4</a>, and notice that the <code dir="ltr">orders</code> table and <code dir="ltr">customers</code> table are related through the <code dir="ltr">customer_id</code> column. The following statement satisfies the original goal of the salesperson. That is, this statement creates a materialized view that contains customers who have an order with an order total greater than $20,000:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.customers REFRESH FAST FOR UPDATE AS
  SELECT * FROM oe.customers@orc1.example.com c
  WHERE EXISTS
    (SELECT * FROM oe.orders@orc1.example.com o
     WHERE c.customer_id = o.customer_id AND o.order_total &gt; 20000);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To create this <code dir="ltr">oe.customers</code> materialized view, <code dir="ltr">customer_id</code> and <code dir="ltr">order_total</code> must be logged in the materialized view log for the <code dir="ltr">orders</code> table. See <a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a> for more information.</div>
<div id="REPLN296" class="figure">
<p class="titleinfigure"><a id="i57830"></a>Figure 3-4 Row Subsetting with One to Many Subqueries</p>
<img width="600" height="180" src="img/repln087.gif" alt="Description of Figure 3-4 follows"/><br/>
<a id="sthref433" href="img_text/repln087.htm">Description of &#34;Figure 3-4 Row Subsetting with One to Many Subqueries&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The materialized view created by this statement is fast refreshable and updatable. If new customers are identified that have an order total greater than $20,000, then the new data will be propagated to the materialized view site during the subsequent refresh process. Similarly, if a customer cancels an order with an order total greater than $20,000 and has no other order totals greater than $20,000, then the customer&#39;s data will be removed from the materialized view during the subsequent refresh process.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN297" class="sect4"><a id="sthref434"></a>
<h5 class="sect4">Many to Many Subqueries<a id="sthref435"></a><a id="sthref436"></a><a id="sthref437"></a></h5>
<p>Consider a scenario where you have the <code dir="ltr">order_items</code> table and <code dir="ltr">inventories</code> table in the <code dir="ltr">oe</code> schema, and you want to create a materialized view of the <code dir="ltr">inventories</code> table based on data in both the <code dir="ltr">inventories</code> table and the <code dir="ltr">order_items</code> table. For example, suppose a salesperson wants to see all of the inventories with a quantity on hand greater than 0 (zero) for each product whose <code dir="ltr">product_id</code> is in the <code dir="ltr">order_items</code> table. In other words, the salesperson wants to see the inventories that are greater than zero for all of the products that customers have ordered. Here, an inventory is a certain quantity of a product at a particular warehouse. So, a certain product can be in many order items and in many inventories.</p>
<p>To accomplish the salesperson&#39;s goal, you can create a materialized view with a subquery on the many to many relationship between the <code dir="ltr">order_items</code> table and the <code dir="ltr">inventories</code> table.</p>
<p>When you create the <code dir="ltr">inventories</code> materialized view, you want to retrieve the inventories with the quantity on hand greater than zero for the products that appear in the <code dir="ltr">order_items</code> table. Look at the relationships in <a href="#i47911">Figure 3-5</a>, and note that the <code dir="ltr">inventories</code> table and <code dir="ltr">order_items</code> table are related through the <code dir="ltr">product_id</code> column. The following statement creates the materialized view:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.inventories REFRESH FAST FOR UPDATE AS
  SELECT * FROM oe.inventories@orc1.example.com i
  WHERE i.quantity_on_hand &gt; 0 AND EXISTS
    (SELECT * FROM oe.order_items@orc1.example.com o
     WHERE i.product_id = o.product_id);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To create this <code dir="ltr">oe.inventories</code> materialized view, the <code dir="ltr">product_id</code> column in the <code dir="ltr">order_items</code> table must be logged in the master&#39;s materialized view log. See <a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a> for more information.</div>
<div id="REPLN298" class="figure">
<p class="titleinfigure"><a id="i47911"></a>Figure 3-5 Row Subsetting with Many to Many Subqueries</p>
<img width="600" height="216" src="img/repln089.gif" alt="Description of Figure 3-5 follows"/><br/>
<a id="sthref438" href="img_text/repln089.htm">Description of &#34;Figure 3-5 Row Subsetting with Many to Many Subqueries&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The materialized view created by this statement is fast refreshable and updatable. If new inventories that are greater than zero are identified for products in the <code dir="ltr">order_items</code> table, then the new data will be propagated to the materialized view site during the subsequent refresh process. Similarly, if a customer cancels an order for a product and there are no other orders for the product in the <code dir="ltr">order_items</code> table, then the inventories for the product will be removed from the materialized view during the subsequent refresh process.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN299" class="sect4"><a id="sthref439"></a>
<h5 class="sect4">Materialized Views with Subqueries and Unions<a id="sthref440"></a><a id="sthref441"></a><a id="sthref442"></a></h5>
<p>In situations where you want a single materialized view to contain data that matches the complete results of two or more different queries, you can use the <code dir="ltr">UNION</code> operator. When you use the <code dir="ltr">UNION</code> operator to create a materialized view, you have two <code dir="ltr">SELECT</code> statements around each <code dir="ltr">UNION</code> operator, one is above it and one is below it. The resulting materialized view contains rows selected by either query.</p>
<p>You can use the <code dir="ltr">UNION</code> operator as a way to create fast refreshable materialized views that satisfy &#34;or&#34; conditions without using the <code dir="ltr">OR</code> expression in the <code dir="ltr">WHERE</code> clause of a subquery. Under some conditions, using an <code dir="ltr">OR</code> expression in the <code dir="ltr">WHERE</code> clause of a subquery causes the resulting materialized view to be complex, and therefore not fast refreshable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i28701">&#34;Restrictions for Materialized Views with Subqueries&#34;</a> for more information about the <code dir="ltr">OR</code> expressions in subqueries</div>
<p>For example, suppose a salesperson wants the product information for the products in a particular <code dir="ltr">category_id</code> that are <span class="italic">either</span> in a warehouse in California <span class="italic">or</span> contain the word &#34;Rouge&#34; in their translated product descriptions (for the French translation). The following statement uses the <code dir="ltr">UNION</code> operator and subqueries to capture this data in a materialized view for products in <code dir="ltr">category_id</code> 29:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.product_information REFRESH FAST FOR UPDATE AS
 SELECT * FROM oe.product_information@orc1.example.com pi
 WHERE pi.category_id = 29 AND EXISTS
  (SELECT * FROM oe.product_descriptions@orc1.example.com pd
  WHERE pi.product_id = pd.product_id AND 
        pd.translated_description LIKE &#39;%Rouge%&#39;)  
UNION
 SELECT * FROM oe.product_information@orc1.example.com pi
 WHERE pi.category_id = 29 AND EXISTS
  (SELECT * FROM oe.inventories@orc1.example.com i
  WHERE pi.product_id = i.product_id AND EXISTS
    (SELECT * FROM oe.warehouses@orc1.example.com w
    WHERE i.warehouse_id = w.warehouse_id AND EXISTS
      (SELECT * FROM hr.locations@orc1.example.com l
       WHERE w.location_id = l.location_id 
       AND l.state_province = &#39;California&#39;)));   
  
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To create the <code dir="ltr">oe.product_information</code> materialized view, <code dir="ltr">translated_description</code> in the <code dir="ltr">oe.product_descriptions</code> table, the <code dir="ltr">state_province</code> in the <code dir="ltr">hr.locations</code> table, and the <code dir="ltr">location_id</code> column in the <code dir="ltr">oe.warehouses</code> table must be logged in each master&#39;s materialized view log. See <a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a> for more information.</div>
<p><a href="#i44854">Figure 3-6</a> shows the relationships of the master tables involved in this statement.</p>
<div id="REPLN300" class="figure">
<p class="titleinfigure"><a id="i44854"></a>Figure 3-6 Row Subsetting with Subqueries and Unions</p>
<img width="600" height="568" src="img/repln090.gif" alt="Description of Figure 3-6 follows"/><br/>
<a id="sthref443" href="img_text/repln090.htm">Description of &#34;Figure 3-6 Row Subsetting with Subqueries and Unions&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>In addition to the <code dir="ltr">UNION</code> operation, this statement contains the following subqueries:</p>
<ul>
<li>
<p>A subquery referencing the <code dir="ltr">product_information</code> table and the <code dir="ltr">product_descriptions</code> table. This subquery is one to many because one product can have multiple product descriptions (for different languages).</p>
</li>
<li>
<p>A subquery referencing the <code dir="ltr">product_information</code> table and the <code dir="ltr">inventories</code> table. This subquery is one to many because a product can be in many inventories.</p>
</li>
<li>
<p>A subquery referencing the <code dir="ltr">inventories</code> table and the <code dir="ltr">warehouses</code> table. This subquery is many to one because many inventories can be stored in one warehouse.</p>
</li>
<li>
<p>A subquery referencing the <code dir="ltr">warehouses</code> table and the <code dir="ltr">locations</code> table. This subquery is many to one because many warehouses can be in one location.</p>
</li>
</ul>
<p>The materialized view created by this statement is fast refreshable and updatable. If a new product is added that is stored in a warehouse in California or that has the string &#34;Rouge&#34; in the translated product description, then the new data will be propagated to the <code dir="ltr">product_information</code> materialized view during the subsequent refresh process.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i28701"></a>
<div id="REPLN301" class="sect3">
<h4 class="sect3">Restrictions for Materialized Views with Subqueries<a id="sthref444"></a><a id="sthref445"></a><a id="sthref446"></a></h4>
<p>The defining query of a materialized view with a subquery is subject to several restrictions to preserve the materialized view&#39;s fast refresh capability.</p>
<p>The following are restrictions for fast refresh materialized views with subqueries:</p>
<ul>
<li>
<p>Materialized views must be primary key materialized views.</p>
</li>
<li>
<p><a id="sthref447"></a><a id="sthref448"></a><a id="sthref449"></a>The master&#39;s materialized view log must include certain columns referenced in the subquery. For information about which columns must be included, see <a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a>.</p>
</li>
<li>
<p><a id="sthref450"></a><a id="sthref451"></a><a id="sthref452"></a>If the subquery is many to many or one to many, join columns that are not part of a primary key must be included in the materialized view log of the master. This restriction does not apply to many to one subqueries.</p>
</li>
<li>
<p><a id="sthref453"></a><a id="sthref454"></a><a id="sthref455"></a>The subquery must be a positive subquery. For example, you can use the <code dir="ltr">EXISTS</code> condition, but not the <code dir="ltr">NOT</code> <code dir="ltr">EXISTS</code> condition.</p>
</li>
<li>
<p>The subquery must use <code dir="ltr">EXISTS</code> to connect each nested level (<code dir="ltr">IN</code> is not allowed).</p>
</li>
<li>
<p>Each table can be in only one <code dir="ltr">EXISTS</code> expression.</p>
</li>
<li>
<p><a id="sthref456"></a><a id="sthref457"></a>The join expression must use exact match or equality comparisons (that is, equi-joins).</p>
</li>
<li>
<p>Each table can be joined only once within the subquery.</p>
</li>
<li>
<p>A primary key must exist for each table at each nested level.</p>
</li>
<li>
<p>Each nested level can only reference the table in the level above it.</p>
</li>
<li>
<p><a id="sthref458"></a><a id="sthref459"></a><a id="sthref460"></a><a id="sthref461"></a><a id="sthref462"></a><a id="sthref463"></a>Subqueries can include <code dir="ltr">AND</code> conditions, but each <code dir="ltr">OR</code> condition can only reference columns contained within one row. Multiple <code dir="ltr">OR</code> conditions within a subquery can be connected with an <code dir="ltr">AND</code> condition.</p>
</li>
<li>
<p>All tables referenced in a subquery must reside in the same master site or master materialized view site.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="sthref464"></a><a id="sthref465"></a>If the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement includes an <code dir="ltr">ON</code> <code dir="ltr">PREBUILT</code> <code dir="ltr">TABLE</code> clause and a subquery, then the subquery is treated as many to many. Therefore, in this case, the join columns must be recorded in the materialized view log. See the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ON</code> <code dir="ltr">PREBUILT</code> <code dir="ltr">TABLE</code> clause in the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i30768">&#34;Primary Key Materialized Views&#34;</a> for more information about primary key materialized views</div>
</div>
<!-- class="sect3" -->
<div id="REPLN302" class="sect3"><a id="sthref466"></a>
<h4 class="sect3">Restrictions for Materialized Views with Unions Containing Subqueries<a id="sthref467"></a><a id="sthref468"></a></h4>
<p>The following are restrictions for fast refresh materialized views with unions containing subqueries:</p>
<ul>
<li>
<p>All of the restrictions described in the previous section, <a href="#i28701">&#34;Restrictions for Materialized Views with Subqueries&#34;</a>, apply to the subqueries in each union block.</p>
</li>
<li>
<p>All join columns must be included in the materialized view log of the master, even if the subquery is many to one.</p>
</li>
<li>
<p>All of the restrictions described in the previous section, <a href="#BABEEHGJ">&#34;Complex Materialized Views&#34;</a>, for clauses with <code dir="ltr">UNIONS</code>.</p>
</li>
</ul>
<div id="REPLN303" class="sect4"><a id="sthref469"></a>
<h5 class="sect4">Examples of Materialized Views with Unions Containing Subqueries</h5>
<p>The following statement creates the <code dir="ltr">oe.orders</code> materialized view. This materialized view is fast refreshable because the subquery in each union block satisfies the restrictions for subqueries described in <a href="#i28701">&#34;Restrictions for Materialized Views with Subqueries&#34;</a>.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.orders REFRESH FAST AS
  SELECT * FROM oe.orders@orc1.example.com o
  WHERE EXISTS
    (SELECT * FROM oe.customers@orc1.example.com c
     WHERE o.customer_id = c.customer_id 
     AND c.credit_limit &gt; 50)
UNION    
  SELECT * 
  FROM oe.orders@orc1.example.com o
  WHERE EXISTS
    (SELECT * FROM oe.customers@orc1.example.com c
     WHERE o.customer_id = c.customer_id 
     AND c.account_mgr_id = 30);  
</pre>
<p>Notice that one of the restrictions for subqueries states that each table can be in only one <code dir="ltr">EXISTS</code> expression. Here, the <code dir="ltr">customers</code> table appears in two <code dir="ltr">EXISTS</code> expressions, but the <code dir="ltr">EXISTS</code> expressions are in separate <code dir="ltr">UNION</code> blocks. Because the restrictions described in <a href="#i28701">&#34;Restrictions for Materialized Views with Subqueries&#34;</a> only apply to each <code dir="ltr">UNION</code> block, not to the entire <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement, the materialized view is fast refreshable.</p>
<p>In contrast, the materialized view created with the following statement cannot be fast refreshed because the <code dir="ltr">orders</code> table is referenced in two different <code dir="ltr">EXISTS</code> expressions within the same <code dir="ltr">UNION</code> block:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.orders AS
  SELECT * FROM oe.orders@orc1.example.com o
  WHERE EXISTS
    (SELECT * FROM oe.customers@orc1.example.com c
     WHERE o.customer_id = c.customer_id  -- first reference to orders table
     AND c.credit_limit &gt; 50
     AND EXISTS
        (SELECT * FROM oe.orders@orc1.example.com o
         WHERE order_total &gt; 5000 
         AND o.customer_id = c.customer_id)) -- second reference to orders table
UNION    
  SELECT * 
  FROM oe.orders@orc1.example.com o
  WHERE EXISTS
    (SELECT * FROM oe.customers@orc1.example.com c
     WHERE o.customer_id = c.customer_id 
     AND c.account_mgr_id = 30);  
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABEDIAH"></a>
<div id="REPLN304" class="sect2">
<h3 class="sect2">Determining the Fast Refresh Capabilities of a Materialized View<a id="sthref470"></a><a id="sthref471"></a><a id="sthref472"></a><a id="sthref473"></a><a id="sthref474"></a><a id="sthref475"></a></h3>
<p>To determine whether a materialized view&#39;s subquery satisfies the restrictions detailed in the previous section, create the materialized view with fast refresh. Oracle returns errors if the materialized view violates any restrictions for subquery materialized views. If you specify force refresh, then you might not receive any errors because, when a force refresh is requested, Oracle automatically performs a complete refresh if it cannot perform a fast refresh.</p>
<p>You can also use the <code dir="ltr">EXPLAIN_MVIEW</code> procedure in the <code dir="ltr">DBMS_MVIEW</code> package to determine the following information about an existing materialized view or a proposed materialized view that does not yet exist:</p>
<ul>
<li>
<p>The capabilities of a materialized view</p>
</li>
<li>
<p>Whether each capability is possible</p>
</li>
<li>
<p>If a capability is not possible, then why it is not possible</p>
</li>
</ul>
<p>This information can be stored in a varray or in the <code dir="ltr">MV_CAPABILITIES_TABLE</code>. To store the information in the table, before you run the <code dir="ltr">EXPLAIN_MVIEW</code> procedure, you must build this table by running the <code dir="ltr">utlxmv.sql</code> script in the <span class="italic">Oracle_home</span><code dir="ltr">/rdbms/admin</code> directory.</p>
<p>For example, to determine the capabilities of the <code dir="ltr">oe.orders</code> materialized view, enter:</p>
<pre dir="ltr">EXECUTE DBMS_MVIEW.EXPLAIN_MVIEW (&#39;oe.orders&#39;);
</pre>
<p>Or, if the materialized view does not yet exist, then you can supply the query that you want to use to create it:</p>
<pre dir="ltr">BEGIN
  DBMS_MVIEW.EXPLAIN_MVIEW (&#39;SELECT * FROM oe.orders@orc1.example.com o
    WHERE EXISTS (SELECT * FROM oe.customers@orc1.example.com c
    WHERE o.customer_id = c.customer_id AND c.credit_limit &gt; 500)&#39;);
END;
/
</pre>
<p>Query the <code dir="ltr">MV_CAPABILITIES_TABLE</code> to see the results.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">MV_CAPABILITIES_TABLE</code> does not show materialized view refresh capabilities that depend on prebuilt container tables. For example, complete refresh is required after a partition maintenance operation on a prebuilt container table, but the <code dir="ltr">MV_CAPABILITIES_TABLE</code> does not show this limitation.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG" href="../DWHSG/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for more information about the <code dir="ltr">EXPLAIN_MVIEW</code> procedure</div>
</div>
<!-- class="sect2" -->
<a id="i52377"></a>
<div id="REPLN305" class="sect2">
<h3 class="sect2">Multitier Materialized Views<a id="sthref476"></a><a id="sthref477"></a></h3>
<p>The ability to create materialized views that are based on other materialized views enables you to create <span class="bold">multitier materialized views</span>. Materialized views that are based on other materialized views can be read-only or updatable. The arrows in <a href="#i51945">Figure 3-7</a> represent database links.</p>
<div id="REPLN306" class="figure">
<p class="titleinfigure"><a id="i51945"></a>Figure 3-7 Multitier Materialized Views</p>
<img width="525" height="254" src="img/repln085.gif" alt="Description of Figure 3-7 follows"/><br/>
<a id="sthref478" href="img_text/repln085.htm">Description of &#34;Figure 3-7 Multitier Materialized Views &#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p><a id="sthref479"></a><a id="sthref480"></a><a id="sthref481"></a>When you are using multitier materialized views, the materialized view based on a master table is called a level 1 materialized view. Then, a materialized view based on the level 1 materialized view is called a level 2 materialized view. Next is level 3 and so on. <a href="#i53545">Figure 3-8</a> shows these levels.</p>
<div id="REPLN307" class="figure">
<p class="titleinfigure"><a id="i53545"></a>Figure 3-8 Levels of Materialized Views</p>
<img width="600" height="472" src="img/repln095.gif" alt="Description of Figure 3-8 follows"/><br/>
<a id="sthref482" href="img_text/repln095.htm">Description of &#34;Figure 3-8 Levels of Materialized Views&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p><a id="sthref483"></a><a id="sthref484"></a><a id="sthref485"></a>A materialized view that is acting as the master for another materialized view is called a <span class="bold">master materialized view</span>. A materialized view at any level can be a master materialized view, and, as you can see in <a href="#i53545">Figure 3-8</a>, a master materialized view can have multiple materialized views based on it. In <a href="#i53545">Figure 3-8</a>, two level 2 materialized views are based on one level 1 materialized view.</p>
<p><a href="#i46867">Figure 3-9</a> illustrates an example that shows a master materialized view at level 1 (<code dir="ltr">orders_1</code>) and level&nbsp;2 (<code dir="ltr">orders_2</code>).</p>
<div id="REPLN308" class="figure">
<p class="titleinfigure"><a id="i46867"></a>Figure 3-9 Master Materialized Views</p>
<img width="600" height="568" src="img/repln097.gif" alt="Description of Figure 3-9 follows"/><br/>
<a id="sthref486" href="img_text/repln097.htm">Description of &#34;Figure 3-9 Master Materialized Views&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The master for the level 1 materialized view <code dir="ltr">orders_1</code> is the master table <code dir="ltr">orders</code> at the master site, but, starting with level 2, each materialized view has a master materialized view at the level above it. For example, the master for the level 2 materialized view <code dir="ltr">orders_2</code> is the level 1 materialized view <code dir="ltr">orders_1</code>.</p>
<p>A master materialized view functions the same way a master table does at a master site. That is, changes pushed from a level 2 materialized view to a level 1 materialized view are handled in the same way that changes pushed from a level 1 materialized view to a master table are handled.</p>
<p>A receiver must be registered at a master materialized view site. The receiver is responsible for receiving and applying the deferred transactions from the propagator at multitier materialized view sites that are based on the master materialized view.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repmaster.htm#i43219">&#34;Receiver&#34;</a></div>
<p>Multitier materialized views offer greater flexibility in the design of a replication environment. Some materialized view sites might not need to replicate all of the data in master tables, and, in fact, these sites might not have the storage capacity for all of the data. In addition, replicating less data means that there is less activity on the network.</p>
<p>Multitier materialized views are ideal for organizations that are structured on three or more levels or constrained by limited network resources. For example, consider a company with international, national, and local offices. This company has many computers at both the national and local level that replicate data. Here, the replication environment can be configured with the master site at the international headquarters and with materialized views at the national level. These materialized views at the national level only replicate the subset of data from the master tables that apply to their respective countries. Now, using multitier materialized views, another level of materialized views at the local level can be based on the materialized views at the national level. The materialized views at the local level contain the subset of data from the level 1 materialized views that apply to their local customers.</p>
<a id="i53354"></a>
<div id="REPLN309" class="sect3">
<h4 class="sect3">Scenario for Using Multitier Materialized Views</h4>
<p>Consider a multinational company that maintains all employee information at headquarters, which is in the in the United States. The company uses the tables in the <code dir="ltr">hr</code> schema to maintain the employee information. This company has one main office in 14 countries and many regional offices for cities in these countries.</p>
<p>For example, the company has one main office for all of the United Kingdom, but it also has an office in the city of London. The United Kingdom office maintains employee information for all of the employees in the United Kingdom, while the London office only maintains employee information for the employees at the London office. In this scenario, the <code dir="ltr">hr.employees</code> master table is at headquarters in the United States and each regional office has a an <code dir="ltr">hr.employees</code> materialized view that only contains the necessary employee information.</p>
<p>The following statement creates the <code dir="ltr">hr.employees</code> materialized view for the United Kingdom office. The statement queries the master table in the database at headquarters, which is <code dir="ltr">orc1.example.com</code>. Notice that the statement uses subqueries so that the materialized view only contains employees whose <code dir="ltr">country_id</code> is <code dir="ltr">UK</code>.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.employees REFRESH FAST FOR UPDATE AS
  SELECT * FROM hr.employees@orc1.example.com e
    WHERE EXISTS
      (SELECT * FROM hr.departments@orc1.example.com d
       WHERE e.department_id = d.department_id
       AND EXISTS
         (SELECT * FROM hr.locations@orc1.example.com l
          WHERE l.country_id = &#39;UK&#39;
          AND d.location_id = l.location_id));
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To create this <code dir="ltr">hr.employees</code> materialized view, the following columns must be logged:
<ul>
<li>
<p>The <code dir="ltr">department_id</code> column must be logged in the materialized view log for the <code dir="ltr">hr.employees</code> master table at <code dir="ltr">orc1.example.com</code>.</p>
</li>
<li>
<p>The <code dir="ltr">country_id</code> must be logged in the materialized view log for the <code dir="ltr">hr.locations</code> master table at <code dir="ltr">orc1.example.com</code>.</p>
</li>
</ul>
<p>See <a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a> for more information.</p>
</div>
<p>The following statement creates the <code dir="ltr">hr.employees</code> materialized view for the London office based on the level 1 materialized view at the United Kingdom office. The statement queries the materialized view in the database at the United Kingdom office, which is <code dir="ltr">reg_uk.example.com</code>. Notice that the statement uses subqueries so that the materialized view only contains employees whose <code dir="ltr">city</code> is <code dir="ltr">London</code>.</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW hr.employees REFRESH FAST FOR UPDATE AS
  SELECT * FROM hr.employees@reg_uk.example.com e
    WHERE EXISTS
      (SELECT * FROM hr.departments@reg_uk.example.com d
       WHERE e.department_id = d.department_id
       AND EXISTS
         (SELECT * FROM hr.locations@reg_uk.example.com l
          WHERE l.city = &#39;London&#39;
          AND d.location_id = l.location_id));
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To create this <code dir="ltr">hr.employees</code> materialized view, the following columns must be logged:
<ul>
<li>
<p>The <code dir="ltr">department_id</code> column must be logged in the materialized view log for the <code dir="ltr">hr.employees</code> master materialized view at <code dir="ltr">reg_uk.example.com</code>.</p>
</li>
<li>
<p>The <code dir="ltr">country_id</code> must be logged in the materialized view log for the <code dir="ltr">hr.locations</code> master materialized view at <code dir="ltr">reg_uk.example.com</code>.</p>
</li>
</ul>
<p>See <a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a> for more information.</p>
</div>
</div>
<!-- class="sect3" -->
<a id="i48147"></a>
<div id="REPLN310" class="sect3">
<h4 class="sect3">Restrictions for Using Multitier Materialized Views<a id="sthref487"></a><a id="sthref488"></a></h4>
<p>Both master materialized views and materialized views based on materialized views must be primary key materialized views.</p>
<div id="REPLN311" class="sect4"><a id="sthref489"></a>
<h5 class="sect4">Additional Restrictions for Master Materialized Views<a id="sthref490"></a></h5>
<p>The following types of materialized views cannot be masters for updatable materialized views:</p>
<ul>
<li>
<p><code dir="ltr">ROWID</code> materialized views</p>
</li>
<li>
<p>Complex materialized views</p>
</li>
<li>
<p>Read-only materialized views</p>
</li>
</ul>
<p>However, these types of materialized views can be masters for read-only materialized views.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN312" class="sect4"><a id="sthref491"></a>
<h5 class="sect4">Additional Restrictions for Updatable Materialized Views Based on Materialized Views</h5>
<p>Updatable materialized views based on materialized views must:</p>
<ul>
<li>
<p>Belong to a materialized view group that has the same name as the materialized view group at its master materialized view site.</p>
</li>
<li>
<p>Reside in a different database than the materialized view group at its master materialized view site.</p>
</li>
<li>
<p>Be based on another updatable materialized view or other updatable materialized views, not on a read-only materialized view.</p>
</li>
<li>
<p><a id="sthref492"></a><a id="sthref493"></a><a id="sthref494"></a><a id="sthref495"></a>Be based on a materialized view in a materialized view group that is owned by <code dir="ltr">PUBLIC</code> at the master materialized view site.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i55740"></a>
<div id="REPLN313" class="sect2">
<h3 class="sect2">How Materialized Views Work with Object Types and Collections<a id="sthref496"></a><a id="sthref497"></a><a id="sthref498"></a><a id="sthref499"></a><a id="sthref500"></a><a id="sthref501"></a><a id="sthref502"></a></h3>
<p>Oracle <span class="bold">object</span> <span class="bold">types</span> are user-defined data types that make it possible to model complex real-world entities such as customers and orders as single entities, called <span class="bold">objects</span>, in the database. You create object types using the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> <code dir="ltr">...</code> <code dir="ltr">AS</code> <code dir="ltr">OBJECT</code> statement. You can replicate object types and objects between master sites and materialized view sites in a replication environment.</p>
<p>An Oracle object that occupies a single column in a table is called a <span class="bold">column object</span>. Typically, tables that contain column objects also contain other columns, which can be built-in data types, such as <code dir="ltr">VARCHAR2</code> and <code dir="ltr">NUMBER</code>. An <span class="bold">object table</span> is a special kind of table in which each row represents an object. Each row in an object table is a <span class="bold">row object</span>.</p>
<p>You can also replicate <span class="bold">collections</span>. Collections are user-defined data types that are based on <code dir="ltr">VARRAY</code> and nested table data types. You create varrays with the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> <code dir="ltr">...</code> <code dir="ltr">AS</code> <code dir="ltr">VARRAY</code> statement, and you create nested tables with the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> <code dir="ltr">...</code> <code dir="ltr">AS</code> <code dir="ltr">TABLE</code> statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p><a id="sthref503"></a><a id="sthref504"></a><a id="sthref505"></a>You cannot create refresh-on-commit materialized views based on a master with user-defined types or Oracle-supplied types. Refresh-on-commit materialized views are those created using the <code dir="ltr">ON</code> <code dir="ltr">COMMIT</code> <code dir="ltr">REFRESH</code> clause in the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement.</p>
</li>
<li>
<p>Advanced Replication does not support type inheritance, and Advanced Replication does not support types created with the <code dir="ltr">NOT</code> <code dir="ltr">FINAL</code> clause.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADOBJ" href="../ADOBJ/toc.htm"><span class="italic">Oracle Database Object-Relational Developer&#39;s Guide</span></a> for detailed information about user-defined types, Oracle objects, and collections. This section assumes a basic understanding of the information in that book.</p>
</li>
<li>
<p><a class="olink SQLRF002" href="../SQLRF/sql_elements.htm#SQLRF002"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about user-defined types and Oracle-supplied types</p>
</li>
</ul>
</div>
<a id="i54878"></a>
<div id="REPLN314" class="sect3">
<h4 class="sect3">Type Agreement at Replication Sites<a id="sthref506"></a><a id="sthref507"></a><a id="sthref508"></a></h4>
<p>User-defined types include all types created using the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> statement, including object, nested table, <code dir="ltr">VARRAY</code>, and indextype. To replicate schema objects based on user-defined types, the user-defined types themselves must exist, and must be the same, at all replication sites. In addition, Oracle recommends that you add a user-defined type to the replication group in which it is used, but doing so is not required.</p>
<p>When replicating user-defined types and the schema objects on which they are based, the following conditions apply:</p>
<ul>
<li>
<p>The user-defined types replicated at the master site and materialized view site must be created at the materialized view site before you create any materialized views that depend on these types.</p>
</li>
<li>
<p>All of the masters on which a materialized view is based must be at the same master site to create a materialized view with user-defined types.</p>
</li>
<li>
<p>A user-defined type must be the same at all replication sites:</p>
<ul>
<li>
<p>All replication sites must have the same object identifier (OID), schema owner, and type name for each replicated user-defined type.</p>
</li>
<li>
<p>If the user-defined type is an object type, then all replication sites must agree on the order and data type of the attributes in the object type. You establish the order and data types of the attributes when you create the object type. For example, consider the following object type:</p>
<pre dir="ltr">CREATE TYPE cust_address_typ AS OBJECT
     (street_address     VARCHAR2(40), 
      postal_code        VARCHAR2(10), 
      city               VARCHAR2(30), 
      state_province     VARCHAR2(10), 
      country_id         CHAR(2));
/
</pre>
<p>At all replication sites, <code dir="ltr">street_address</code> must be the first attribute for this type and must be <code dir="ltr">VARCHAR2(40)</code>, <code dir="ltr">postal_code</code> must be the second attribute and must be <code dir="ltr">VARCHAR2(10)</code>, <code dir="ltr">city</code> must be the third attribute and must be <code dir="ltr">VARCHAR2(30)</code>, and so on.</p>
</li>
<li>
<p><a id="sthref509"></a>All replication sites must agree on the hashcode of the user-defined type. Oracle examines a user-defined type and assigns the hashcode. This examination includes the type attributes, order of attributes, and type name. When all of these items are the same for two or more types, the types have the same hashcode. You can view the hashcode for a type by querying the <code dir="ltr">DBA_TYPE_VERSIONS</code> data dictionary view.</p>
</li>
</ul>
</li>
</ul>
<p>To ensure that a user-defined type is the same at all replication sites, you must create the user-defined type at the materialized view site in one of the following ways:</p>
<ul>
<li>
<p><a href="#i50680">Use the Replication Management API</a></p>
</li>
<li>
<p><a href="#i49836">Use a CREATE TYPE Statement</a></p>
</li>
</ul>
<a id="i50680"></a>
<div id="REPLN315" class="sect4">
<h5 class="sect4">Use the Replication Management API</h5>
<p>Oracle recommends that you use the replication management API to create, modify, or drop any replicated object at a materialized view site, including user-defined types. If you do not use the replication management API for these actions, then replication errors might result.</p>
<p>Specifically, to create a user-defined type that is the same at the master site and the materialized view site, use the <code dir="ltr">CREATE_MVIEW_REPOBJECT</code> procedure in the <code dir="ltr">DBMS_REPCAT</code> package. This procedure creates the type and adds it to a materialized view group. To drop a user-defined type from the materialized view site, use the <code dir="ltr">DROP_MVIEW_REPOBJECT</code> procedure in the <code dir="ltr">DBMS_REPCAT</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REPMA019" href="../REPMA/rarrcatpac.htm#REPMA019"><span class="italic">Oracle Database Advanced Replication Management API Reference</span></a></div>
</div>
<!-- class="sect4" -->
<a id="i49836"></a>
<div id="REPLN316" class="sect4">
<h5 class="sect4">Use a CREATE TYPE Statement<a id="sthref510"></a><a id="sthref511"></a></h5>
<p>You can use a <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> statement at the materialized view site to create the type. It might be necessary to do this to create a read-only materialized view that uses the type, and you do not want to add the read-only materialized view to a materialized view group.</p>
<p>If you choose this option, then you must ensure the following:</p>
<ul>
<li>
<p>The type is in the same schema at both the materialized view site and the master site.</p>
</li>
<li>
<p>The type has the same attributes in the same order at both the materialized view site and the master site.</p>
</li>
<li>
<p>The type has the same data type for each attribute at both the materialized view site and the master site.</p>
</li>
<li>
<p>The type has the same object identifier at both the materialized view site and the master site.</p>
</li>
</ul>
<p>You can find the object identifier for a type by querying the <code dir="ltr">DBA_TYPES</code> data dictionary view. For example, to find the object identifier (OID) for the <code dir="ltr">cust_address_typ</code>, enter the following query:</p>
<pre dir="ltr">SELECT TYPE_OID FROM DBA_TYPES WHERE TYPE_NAME = &#39;CUST_ADDRESS_TYP&#39;;

TYPE_OID
--------------------------------
6F9BC33653681B7CE03400400B40A607
</pre>
<p>Now that you know the OID for the type at the master site, complete the following steps to create the type at the materialized view site:</p>
<ol>
<li>
<p>Log in to the materialized view site as the user who owns the type at the master site. If this user does not exist at the materialized view site, then create the user.</p>
</li>
<li>
<p>Issue the <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> statement and specify the OID:</p>
<pre dir="ltr">CREATE TYPE oe.cust_address_typ OID &#39;6F9BC33653681B7CE03400400B40A607&#39; 
     AS OBJECT (
     street_address     VARCHAR2(40), 
     postal_code        VARCHAR2(10), 
     city               VARCHAR2(30), 
     state_province     VARCHAR2(10), 
     country_id         CHAR(2));
/
</pre></li>
</ol>
<p>The type is now ready for use at the materialized view site.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN317" class="sect3"><a id="sthref512"></a>
<h4 class="sect3">Column Subsetting of Masters with Column Objects<a id="sthref513"></a><a id="sthref514"></a><a id="sthref515"></a><a id="sthref516"></a><a id="sthref517"></a><a id="sthref518"></a></h4>
<p>A read-only materialized view can replicate specific attributes of a column object without replicating other attributes. For example, using the <code dir="ltr">cust_address_typ</code> user-defined data type described in the previous section, suppose a <code dir="ltr">customers_sub</code> master table is created at master site <code dir="ltr">orc1.example.com</code>:</p>
<pre dir="ltr">CREATE TABLE oe.customers_sub (
      customer_id        NUMBER(6)  PRIMARY KEY, 
      cust_first_name    VARCHAR2(20), 
      cust_last_name     VARCHAR2(20),
      cust_address       oe.cust_address_typ);
</pre>
<p>You can create the following read-only materialized view at a remote materialized view site:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.customers_mv1 AS
   SELECT customer_id, cust_last_name, c.cust_address.postal_code
   FROM oe.customers_sub@orc1.example.com c;
</pre>
<p>Notice that the <code dir="ltr">postal_code</code> attribute is specified in the <code dir="ltr">cust_address</code> column object.</p>
<p>An updatable materialized view must replicate the entire column object. It cannot replicate some attributes of a column object but not others. The following statement is valid because it specifies the entire <code dir="ltr">cust_address</code> column object:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.customers_mv1 FOR UPDATE AS
   SELECT customer_id, cust_last_name, cust_address
   FROM oe.customers_sub@orc1.example.com;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repdt.htm#i29069">&#34;Column Subsetting with Deployment Templates&#34;</a> for more information about column subsetting with deployment templates. Column subsetting is supported only with deployment templates.</div>
</div>
<!-- class="sect3" -->
<a id="i55614"></a>
<div id="REPLN318" class="sect3">
<h4 class="sect3">Materialized Views Based on Object Tables<a id="sthref519"></a><a id="sthref520"></a><a id="sthref521"></a></h4>
<p>If a materialized view is based on an object table and is created using the <code dir="ltr">OF</code> <span class="italic">type</span> clause, then the materialized view is called an <span class="bold">object materialized view</span>. An object materialized view is structured in the same way as an object table. That is, an object materialized view is composed of row objects. If a materialized view that is based on an object table is created without using the <code dir="ltr">OF</code> <span class="italic">type</span> clause, then the materialized view is read-only and is not an object materialized view. That is, such a materialized view has regular rows, not row objects.</p>
<p>To create a materialized view based on an object table, the types on which the materialized view depends must exist at the materialized view site, and each type must have the same object identifier as it does at the master site.</p>
<div id="REPLN319" class="sect4"><a id="sthref522"></a>
<h5 class="sect4">Creation of Object Materialized Views Using the OF <span class="italic">type</span> Clause<a id="sthref523"></a><a id="sthref524"></a><a id="sthref525"></a></h5>
<p>After the required types are created at the materialized view site, you can create an object materialized view by specifying the <code dir="ltr">OF</code> <span class="italic">type</span> clause.</p>
<p>For example, suppose the following SQL statements create the <code dir="ltr">oe.categories_tab</code> object table at the <code dir="ltr">orc1.example.com</code> master site:</p>
<pre dir="ltr">CREATE TYPE oe.category_typ AS OBJECT
   (category_name           VARCHAR2(50), 
    category_description    VARCHAR2(1000), 
    category_id             NUMBER(2));
/

CREATE TABLE oe.categories_tab OF oe.category_typ
    (category_id    PRIMARY KEY);
</pre>
<p>To create materialized views that can be fast refreshed based on the <code dir="ltr">oe.categories_tab</code> master table, create a materialized view log for this table:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON oe.categories_tab WITH OBJECT ID;
</pre>
<p>The <code dir="ltr">WITH</code> <code dir="ltr">OBJECT</code> <code dir="ltr">ID</code> clause is required when you create a materialized view log on an object table.</p>
<p>After you create the <code dir="ltr">oe.category_typ</code> type at the materialized view site with the same object identifier as the same type at the master site, you can create an object materialized view based on the <code dir="ltr">oe.categories_tab</code> object table using the <code dir="ltr">OF</code> <span class="italic">type</span> clause, as in the following SQL statement:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.categories_objmv OF oe.category_typ 
   REFRESH FAST FOR UPDATE
   AS SELECT * FROM oe.categories_tab@orc1.example.com;
</pre>
<p>Here, <span class="italic">type</span> is <code dir="ltr">oe.category_typ</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The types must be the same at the materialized view site and master site. See <a href="#i54878">&#34;Type Agreement at Replication Sites&#34;</a> for more information.</div>
</div>
<!-- class="sect4" -->
<div id="REPLN320" class="sect4"><a id="sthref526"></a>
<h5 class="sect4">Materialized Views Based on Object Tables Created Without Using the OF <span class="italic">type</span> Clause</h5>
<p>If you create a materialized view based on an object table without using the <code dir="ltr">OF</code> <span class="italic">type</span> clause, then the materialized view is read-only, and it loses the object properties of the object table on which it is based. That is, the resulting read-only materialized view contains one or more of the columns of the master, but each row functions as a row in a relational table. The rows are not row objects.</p>
<p>For example, you can create a materialized view based on the <code dir="ltr">categories_tab</code> master by using the following SQL statement:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.categories_relmv
   AS SELECT * FROM oe.categories_tab@orc1.example.com;
</pre>
<p>In this case, the <code dir="ltr">categories_relmv</code> materialized view must be read-only, and the rows in this materialized view function in the same way as rows in a relational table.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN321" class="sect4"><a id="sthref527"></a>
<h5 class="sect4">OID Preservation in Object Materialized Views<a id="sthref528"></a><a id="sthref529"></a></h5>
<p>An object materialized view inherits the object identifier (OID) specifications of its master. If the master has a primary key-based OID, then the OIDs of row objects in the materialized view are primary key-based. If the master has a system generated OID, then the OIDs of row objects in the materialized view are system generated. Also, the OID of each row in the object materialized view matches the OID of the same row in the master, and the OIDs are preserved during refresh of the materialized view. Consequently, <code dir="ltr">REF</code>s to the rows in the object table remain valid at the materialized view site.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN322" class="sect3"><a id="sthref530"></a>
<h4 class="sect3">Materialized Views with Collection Columns<a id="sthref531"></a><a id="sthref532"></a><a id="sthref533"></a><a id="sthref534"></a><a id="sthref535"></a><a id="sthref536"></a><a id="sthref537"></a><a id="sthref538"></a></h4>
<p>Collection columns are columns based on varray and nested table data types. Oracle supports the creation of materialized views with collection columns.</p>
<p>If the collection column is a nested table, then you can optionally specify the <span class="italic">nested_table_storage_clause</span> during materialized view creation. The <span class="italic">nested_table_storage_clause</span> lets you specify the name of the storage table for the nested table in the materialized view. For example, suppose you create the master table <code dir="ltr">people_reltab</code> at the master site <code dir="ltr">orc1.example.com</code> that contains the nested table <code dir="ltr">phones_ntab</code>:</p>
<pre dir="ltr">CREATE TYPE oe.phone_typ AS OBJECT (
   location    VARCHAR2(15),
   num         VARCHAR2(14));
/

CREATE TYPE oe.phone_ntabtyp AS TABLE OF oe.phone_typ;
/

CREATE TABLE oe.people_reltab (
   id               NUMBER(4) CONSTRAINT pk_people_reltab PRIMARY KEY,
   first_name       VARCHAR2(20),
   last_name        VARCHAR2(20),
   phones_ntab      oe.phone_ntabtyp)
   NESTED TABLE phones_ntab STORE AS phone_store_ntab
   ((PRIMARY KEY (NESTED_TABLE_ID, location)));
</pre>
<p>Notice the <code dir="ltr">PRIMARY</code> <code dir="ltr">KEY</code> specification in the last line of the preceding SQL statement. You must specify a primary key for the storage table if you plan to create materialized views based on its parent table. In this case, the storage table is <code dir="ltr">phone_store_ntab</code> and the parent table is <code dir="ltr">people_reltab</code>.</p>
<p>To create materialized views that can be fast refreshed, create a materialized view log on both the parent table and the storage table, specifying the nested table column as a filter column for the parent table&#39;s materialized view log:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON oe.people_reltab;

ALTER MATERIALIZED VIEW LOG ON oe.people_reltab ADD(phones_ntab);

CREATE MATERIALIZED VIEW LOG ON oe.phone_store_ntab WITH PRIMARY KEY;
</pre>
<p>At the materialized view site, create the required types, ensuring that the object identifier for each type is the same as the object identifier at the master site. Then, you can create a materialized view based on <code dir="ltr">people_reltab</code> and specify its storage table using the following statement:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.people_reltab_mv
   NESTED TABLE phones_ntab STORE AS phone_store_ntab_mv 
   REFRESH FAST AS SELECT * FROM oe.people_reltab@orc1.example.com;
</pre>
<p>In this case, the <span class="italic">nested_table_storage_clause</span> is the line that begins with &#34;<code dir="ltr">NESTED</code> <code dir="ltr">TABLE</code>&#34; in the previous example, and it specifies that the storage table&#39;s name is <code dir="ltr">phone_store_ntab_mv</code>. The <span class="italic">nested_table_storage_clause</span> is optional. If you do not specify this clause, Oracle automatically names the storage table. To view the name of a storage table, query the <code dir="ltr">DBA_NESTED_TABLES</code> data dictionary table.</p>
<p>The storage table:</p>
<ul>
<li>
<p>Is a separate, secondary materialized view</p>
</li>
<li>
<p>Is refreshed automatically when you refresh the materialized view containing the nested table</p>
</li>
<li>
<p>Is dropped automatically when you drop the materialized view containing the nested table</p>
</li>
<li>
<p>Inherits the primary key constraint of the master&#39;s storage table</p>
</li>
</ul>
<p>Because the storage table inherits the primary key constraint of the master&#39;s storage table, do not specify <code dir="ltr">PRIMARY</code> <code dir="ltr">KEY</code> in the <code dir="ltr">STORE</code> <code dir="ltr">AS</code> clause.</p>
<p>The following actions are not allowed directly on the storage table of a nested table in a materialized view:</p>
<ul>
<li>
<p>Refreshing the storage table</p>
</li>
<li>
<p>Adding the storage table to a replication group</p>
</li>
<li>
<p>Altering the storage table</p>
</li>
<li>
<p>Dropping the storage table</p>
</li>
<li>
<p>Generating replication support on the storage table</p>
</li>
</ul>
<p>These actions can occur indirectly when they are performed on the materialized view that contains the nested table. In addition, you cannot replicate a subset of the columns in a storage table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF53214" href="../SQLRF/statements_3001.htm#SQLRF53214"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <span class="italic">nested_table_col_properties</span>, which is fully documented in the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement</div>
<div id="REPLN323" class="sect4"><a id="sthref539"></a>
<h5 class="sect4">Restrictions for Materialized Views with Collection Columns<a id="sthref540"></a><a id="sthref541"></a><a id="sthref542"></a><a id="sthref543"></a><a id="sthref544"></a><a id="sthref545"></a></h5>
<p>The following restrictions apply to materialized views with collection columns:</p>
<ul>
<li>
<p>Row subsetting of collection columns is not allowed. However, you can use row subsetting on the parent table of a nested table and doing so can result in a subset of the nested tables in the materialized view.</p>
</li>
<li>
<p>Column subsetting of collection columns is not allowed.</p>
</li>
<li>
<p>A nested table&#39;s storage table must have a primary key.</p>
</li>
<li>
<p>For the parent table of a nested table to be fast refreshed, both the parent table and the nested table&#39;s storage table must have a materialized view log.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN324" class="sect3"><a id="sthref546"></a>
<h4 class="sect3">Materialized Views with REF Columns<a id="sthref547"></a><a id="sthref548"></a><a id="sthref549"></a><a id="sthref550"></a><a id="sthref551"></a></h4>
<p>You can create materialized views with <code dir="ltr">REF</code> columns. A <code dir="ltr">REF</code> is an Oracle built-in data type that is a logical &#34;pointer&#34; to a row object in an object table. A scoped <code dir="ltr">REF</code> is a <code dir="ltr">REF</code> that can contain references only to a specified object table, while an unscoped <code dir="ltr">REF</code> can contain references to any object table in the database that is based on the corresponding object type. A scoped <code dir="ltr">REF</code> requires less storage space and provides more efficient access than an unscoped&nbsp;<code dir="ltr">REF</code>.</p>
<p>As described in the following section, you can rescope a <code dir="ltr">REF</code> column to a local materialized view or table at the materialized view site during creation of the materialized view. If you do not rescope the <code dir="ltr">REF</code> column, then they continue to point to the remote master. Unscoped <code dir="ltr">REF</code> columns always continue to point to the master. When a <code dir="ltr">REF</code> column at a materialized view site points to a remote master, the <code dir="ltr">REF</code>s are considered dangling. In SQL, dereferencing a dangling <code dir="ltr">REF</code> returns a <code dir="ltr">NULL</code>. Also, PL/SQL only supports dereferencing <code dir="ltr">REF</code>s by using the <code dir="ltr">UTL_OBJECT</code> package and raises an exception for dangling <code dir="ltr">REF</code>s.</p>
<div id="REPLN325" class="sect4"><a id="sthref552"></a>
<h5 class="sect4">Scoped REF Column<a id="sthref553"></a>s</h5>
<p>If you are creating a materialized view based on a master that has a scoped <code dir="ltr">REF</code> column, then you can rescope the <code dir="ltr">REF</code> to a different object table or object materialized view at the materialized view site. Typically, you would rescope the <code dir="ltr">REF</code> column to the local object materialized view instead of the original remote object table. To rescope a materialized view, you can either use the <code dir="ltr">SCOPE</code> <code dir="ltr">FOR</code> clause in the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement, or you can use the <code dir="ltr">ALTER</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement after creating the materialized view. If you do not rescope the <code dir="ltr">REF</code> column, then the materialized view retains the <code dir="ltr">REF</code> scope of the master.</p>
<p>For example, suppose you create the <code dir="ltr">customers_with_ref</code> master table at the <code dir="ltr">orc1.example.com</code> master site using the following statements:</p>
<pre dir="ltr">-- Create the user-defined data type cust_address_typ.
CREATE TYPE oe.cust_address_typ AS OBJECT
   (street_address     VARCHAR2(40),
    postal_code        VARCHAR2(10),
    city               VARCHAR2(30),
    state_province     VARCHAR2(10),
    country_id         CHAR(2));
/

-- Create the object table cust_address_objtab.
CREATE TABLE oe.cust_address_objtab OF oe.cust_address_typ;

-- Create table with REF to cust_address_typ.
CREATE TABLE oe.customers_with_ref (
         customer_id        NUMBER(6) PRIMARY KEY, 
     cust_first_name    VARCHAR2(20), 
     cust_last_name     VARCHAR2(20),
     cust_address       REF oe.cust_address_typ 
                          SCOPE IS oe.cust_address_objtab);
</pre>
<p>Assuming the <code dir="ltr">cust_address_typ</code> exists at the materialized view site with the same object identifier as the type at the master site, you can create a <code dir="ltr">cust_address_objtab_mv</code> object materialized view using the following statement:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.cust_address_objtab_mv OF oe.cust_address_typ AS 
   SELECT * FROM oe.cust_address_objtab@orc1.example.com;
</pre>
<p>Now, you can create a materialized view of the <code dir="ltr">customers_with_ref</code> master table and rescope the <code dir="ltr">REF</code> to the <code dir="ltr">cust_address_objtab_mv</code> materialized view using the following statement:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW oe.customers_with_ref_mv
   (SCOPE FOR (cust_address) IS oe.cust_address_objtab_mv)
   AS SELECT * FROM oe.customers_with_ref@orc1.example.com;
</pre>
<p>To use the <code dir="ltr">SCOPE</code> <code dir="ltr">FOR</code> clause when you create a materialized view, remember to create the materialized view or table specified in the <code dir="ltr">SCOPE</code> <code dir="ltr">FOR</code> clause first. Otherwise, you cannot specify the <code dir="ltr">SCOPE</code> <code dir="ltr">FOR</code> clause during materialized view creation. For example, if you had created the <code dir="ltr">customers_with_ref_mv</code> materialized view before you created the <code dir="ltr">cust_address_objtab_mv</code> materialized view, then you could not use the <code dir="ltr">SCOPE</code> <code dir="ltr">FOR</code> clause when you created the <code dir="ltr">customers_with_ref_mv</code> materialized view. In this case, the <code dir="ltr">REF</code>s are considered dangling because they point back to the object table at the remote master site.</p>
<p>However, even if you do not use the <code dir="ltr">SCOPE</code> <code dir="ltr">FOR</code> clause when you are creating a materialized view, you can alter the materialized view to specify a <code dir="ltr">SCOPE</code> <code dir="ltr">FOR</code> clause. For example, you can alter the <code dir="ltr">customers_with_ref_mv</code> materialized view with the following statement:</p>
<pre dir="ltr">ALTER MATERIALIZED VIEW oe.customers_with_ref_mv
   MODIFY SCOPE FOR (cust_address) IS oe.cust_address_objtab_mv;
</pre></div>
<!-- class="sect4" -->
<div id="REPLN326" class="sect4"><a id="sthref554"></a>
<h5 class="sect4">Unscoped REF Columns<a id="sthref555"></a></h5>
<p>If you create a materialized view based on a remote master with an unscoped <code dir="ltr">REF</code> column, then the <code dir="ltr">REF</code> column is created in the materialized view, but the <code dir="ltr">REF</code>s are considered dangling because they point to a remote database.</p>
</div>
<!-- class="sect4" -->
<div id="REPLN327" class="sect4"><a id="sthref556"></a>
<h5 class="sect4">Logging REF Columns in the Materialized View Log<a id="sthref557"></a><a id="sthref558"></a></h5>
<p>If necessary, you can log REF columns in the materialized view log.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a> for more information</div>
</div>
<!-- class="sect4" -->
<div id="REPLN328" class="sect4"><a id="sthref559"></a>
<h5 class="sect4">REFs Created Using the WITH ROWID Clause<a id="sthref560"></a><a id="sthref561"></a></h5>
<p>If the <code dir="ltr">WITH</code> <code dir="ltr">ROWID</code> clause is specified for a <code dir="ltr">REF</code> column, then Oracle maintains the rowid of the object referenced in the <code dir="ltr">REF</code>. Oracle can find the object referenced directly using the rowid contained in the <code dir="ltr">REF</code>, without the need to fetch the rowid from the OID index. Therefore, you use the <code dir="ltr">WITH</code> <code dir="ltr">ROWID</code> clause to specify a rowid hint. The <code dir="ltr">WITH</code> <code dir="ltr">ROWID</code> clause is not supported for scoped <code dir="ltr">REF</code>s.</p>
<p>Replicating a <code dir="ltr">REF</code> created using the <code dir="ltr">WITH</code> <code dir="ltr">ROWID</code> clause results in an incorrect rowid hint at each replication site except the site where the <code dir="ltr">REF</code> was first created or modified. The <code dir="ltr">ROWID</code> information in the <code dir="ltr">REF</code> is meaningless at the other sites, and Oracle does not correct the rowid hint automatically. Invalid rowid hints can cause performance problems. In this case, you can use the <code dir="ltr">VALIDATE</code> <code dir="ltr">STRUCTURE</code> option of the <code dir="ltr">ANALYZE</code> <code dir="ltr">TABLE</code> statement to determine which rowid hints at each replication site are incorrect.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01105" href="../SQLRF/statements_4005.htm#SQLRF01105"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ANALYZE</code> <code dir="ltr">TABLE</code> statement</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i51957"></a>
<div id="REPLN329" class="sect2">
<h3 class="sect2">Materialized View Registration at a Master Site<a id="sthref562"></a><a id="sthref563"></a> or Master Materialized View Site</h3>
<p>At the master site and master materialized view site, an Oracle database automatically registers information about a materialized view based on its master table(s) or master materialized view(s). The following sections explain more about Oracle&#39;s materialized view registration mechanism.</p>
<div id="REPLN330" class="sect3"><a id="sthref564"></a>
<h4 class="sect3">Viewing Information about Registered Materialized Views<a id="sthref565"></a><a id="sthref566"></a></h4>
<p>A level 1 materialized view or materialized view group is registered at its master site. A level 2 or higher multitier materialized view or materialized view group is registered at its master materialized view site, not at the master site. You can query the <code dir="ltr">DBA_REGISTERED_MVIEWS</code> data dictionary view at a master site or master materialized view site to list the following information about a remote materialized view:</p>
<ul>
<li>
<p>The owner, name, and database that contains the materialized view</p>
</li>
<li>
<p>The materialized view&#39;s defining query</p>
</li>
<li>
<p>Other materialized view characteristics, such as its refresh method</p>
</li>
</ul>
<p>You can also query the <code dir="ltr"><a id="sthref567"></a><a id="sthref568"></a><a id="sthref569"></a>DBA_MVIEW_REFRESH_TIMES</code> view at a master site or master materialized view site to obtain the last refresh times for each materialized view. Administrators can use this information to monitor materialized view activity and coordinate changes to materialized view sites if a master table or master materialized view must be dropped, altered, or relocated.</p>
</div>
<!-- class="sect3" -->
<div id="REPLN331" class="sect3"><a id="sthref570"></a>
<h4 class="sect3">Internal Mechanisms</h4>
<p>Oracle automatically registers a materialized view at its master site or master materialized view site when you create the materialized view, and unregisters the materialized view when you drop it. The same applies to materialized view groups.</p>
<p>When you drop a master materialized view, Oracle does not automatically drop the materialized views based on it. You must drop these materialized views manually. If you do not drop such a materialized view and the materialized view tries to refresh to a master materialized view that has been dropped, Oracle returns an error.</p>
<p>For example, suppose a materialized view named <code dir="ltr">orders_lev1</code> is based on the <code dir="ltr">oe.orders</code> master table, and a materialized view named <code dir="ltr">orders_lev2</code> is based on <code dir="ltr">orders_lev1</code>. If you drop <code dir="ltr">orders_lev1</code>, <code dir="ltr">orders_lev2</code> remains intact. However, if you try to refresh <code dir="ltr">orders_lev2</code>, Oracle returns an error because <code dir="ltr">orders_lev1</code> no longer exists.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Oracle cannot guarantee the registration or unregistration of a materialized view at its master site or master materialized view site during the creation or drop of the materialized view, respectively. If Oracle cannot successfully register a materialized view during creation, then you must complete the registration manually using the <code dir="ltr">REGISTER_MVIEW</code> procedure in the <code dir="ltr">DBMS_MVIEW</code> package. If Oracle cannot successfully unregister a materialized view when you drop the materialized view, then the registration information for the materialized view persists in the master site or master materialized view site until it is manually unregistered. It is possible that complex materialized views might not be registered.</div>
</div>
<!-- class="sect3" -->
<div id="REPLN332" class="sect3"><a id="sthref571"></a>
<h4 class="sect3">Manual Materialized View Registration<a id="sthref572"></a><a id="sthref573"></a><a id="sthref574"></a><a id="sthref575"></a><a id="sthref576"></a><a id="sthref577"></a><a id="sthref578"></a><a id="sthref579"></a></h4>
<p>If necessary, you can maintain registration manually. Use the <code dir="ltr">REGISTER_MVIEW</code> and <code dir="ltr">UNREGISTER_MVIEW</code> procedures of the <code dir="ltr">DBMS_MVIEW</code> package at the master site or master materialized view site to add, modify, or remove materialized view registration information.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The <code dir="ltr">REGISTER_MVIEW</code> and <code dir="ltr">UNREGISTER_MVIEW</code> procedures are described in the <a class="olink ARPLS027" href="../ARPLS/d_mview.htm#ARPLS027"><span class="variable">Oracle Database PL/SQL Packages and Types Reference</span></a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i29896"></a>
<div id="REPLN333" class="sect1">
<h2 class="sect1">Materialized View Architecture<a id="sthref580"></a></h2>
<p>The objects used in materialized view replication are depicted in <a href="#i57503">Figure 3-10</a>. Some of these objects are optional and are used only as needed to support the created materialized view environment. For example, if you have a read-only materialized view, then you do not have an updatable materialized view log nor an internal trigger at the materialized view site. Also, if you have a complex materialized view that cannot be fast refreshed, then you might not have a materialized view log at the master site.</p>
<div id="REPLN334" class="figure">
<p class="titleinfigure"><a id="i57503"></a>Figure 3-10 Materialized View Replication Objects</p>
<img width="600" height="592" src="img/repln096.gif" alt="Description of Figure 3-10 follows"/><br/>
<a id="sthref581" href="img_text/repln096.htm">Description of &#34;Figure 3-10 Materialized View Replication Objects&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Notice that a master materialized view can have both a materialized view log and an updatable materialized view log. Ensure that you account for the extra space required by these logs when you are planning for your master materialized view site.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i51462">Master Site and Master Materialized View Site Mechanisms</a></p>
</li>
<li>
<p><a href="#i51494">Materialized View Site Mechanisms</a></p>
</li>
<li>
<p><a href="#i32253">Organizational Mechanisms</a></p>
</li>
<li>
<p><a href="#i31171">Refresh Process</a></p>
</li>
</ul>
<a id="i51462"></a>
<div id="REPLN335" class="sect2">
<h3 class="sect2">Master Site and Master Materialized View Site Mechanisms<a id="sthref582"></a><a id="sthref583"></a><a id="sthref584"></a><a id="sthref585"></a></h3>
<p>The three mechanisms displayed in <a href="#i26176">Figure 3-11</a> are required at a master site and at a master materialized view site to support fast refreshing of materialized views.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Master materialized views contain the mechanisms described in <a href="#i51494">&#34;Materialized View Site Mechanisms&#34;</a> in addition to the mechanisms described in this section.</div>
<div id="REPLN336" class="figure">
<p class="titleinfigure"><a id="i26176"></a>Figure 3-11 Master Site and Master Materialized View Site Objects</p>
<img width="600" height="120" src="img/repln071.gif" alt="Description of Figure 3-11 follows"/><br/>
<a id="sthref586" href="img_text/repln071.htm">Description of &#34;Figure 3-11 Master Site and Master Materialized View Site Objects&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div id="REPLN337" class="sect3"><a id="sthref587"></a>
<h4 class="sect3">Master Table or Master Materialized View<a id="sthref588"></a><a id="sthref589"></a><a id="sthref590"></a><a id="sthref591"></a></h4>
<p>The master table or master materialized view is the basis for the materialized view. A master table is located at the target master site while a master materialized view is located at a master materialized view site. If the master is a master table, then this table can be involved in both materialized view replication and multimaster replication. Remember that a materialized view points to only one master site or master materialized view site. Changes made to the master table or master materialized view, as recorded by the materialized view log, are propagated to the materialized view during the refresh process.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Fast refreshable materialized views must be based on master tables, master materialized views, or synonyms of master tables or master materialized views. Complete refresh must be used for a materialized view based on a view.</div>
</div>
<!-- class="sect3" -->
<div id="REPLN338" class="sect3"><a id="sthref592"></a>
<h4 class="sect3">Internal Trigger for the Materialized View Log<a id="sthref593"></a><a id="sthref594"></a><a id="sthref595"></a></h4>
<p>When changes are made to the master table or master materialized view using DML, an internal trigger records information about the affected rows in the materialized view log. This information includes the values of the primary key, rowid, or object id, or both, as well as the values of the other columns logged in the materialized view log. This is an internal <code dir="ltr">AFTER</code> <code dir="ltr">ROW</code> trigger that is automatically activated when you create a materialized view log for the target master table or master materialized view. It inserts a row into the materialized view log whenever an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statement modifies the table&#39;s data. This trigger is always the last trigger to fire.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When the materialized view contains a subquery, you might need to log columns referenced in a subquery. See <a href="#i28635">&#34;Data Subsetting with Materialized Views&#34;</a> for information about subquery materialized views and <a href="repplan.htm#i16640">&#34;Logging Columns in the Materialized View Log&#34;</a> for more information about the columns that must be logged.</div>
</div>
<!-- class="sect3" -->
<a id="i30732"></a>
<div id="REPLN107" class="sect3">
<h4 class="sect3">Materialized View Log<a id="sthref596"></a><a id="sthref597"></a><a id="sthref598"></a><a id="sthref599"></a></h4>
<p>A materialized view log is required on a master to perform a fast refresh on materialized views based on the master. When you create a materialized view log for a master table or master materialized view, Oracle creates an <a id="sthref600"></a>underlying table as the materialized view log. A materialized view log can hold the primary keys, rowids, or object identifiers of rows, or both, that have been updated in the master table or master materialized view. A materialized view log can also contain other columns to support fast refreshes of materialized views with subqueries.</p>
<p>The name of a materialized view log&#39;s table is <code dir="ltr">MLOG$_</code><span class="italic">master_name</span>. The materialized view log is created in the same schema as the target master. One materialized view log can support multiple materialized views on its master table or master materialized view. As described in the previous section, the internal trigger adds change information to the materialized view log whenever a DML transaction has taken place on the target master.</p>
<p>Following are the types of materialized view logs:</p>
<ul>
<li>
<p><span class="bold"><a id="sthref601"></a>Primary Key</span>: The materialized view records changes to the master table or master materialized view based on the primary key of the affected rows.</p>
</li>
<li>
<p><span class="bold"><a id="sthref602"></a>Row ID</span>: The materialized view records changes to the master table or master materialized view based on the rowid of the affected rows.</p>
</li>
<li>
<p><span class="bold"><a id="sthref603"></a>Object ID</span>: The materialized view records changes to the master object table or master object materialized view based on the object identifier of the affected row objects.</p>
</li>
<li>
<p><span class="bold"><a id="sthref604"></a>Combination</span>: The materialized view records changes to the master table or master materialized view based any combination of the three options. It is possible to record changes based on the primary key, the <code dir="ltr">ROWID</code>, and the object identifier of the affected rows. Such a materialized view log supports primary key, <code dir="ltr">ROWID</code>, and object materialized views, which is helpful for environments that have all three types of materialized views based on a master.</p>
</li>
</ul>
<p>A combination materialized view log works in the same manner as a materialized view log that tracks only one type of value, except that more than one type of value is recorded. For example, a combination materialized view log can track both the primary key and the rowid of the affected row are recorded.</p>
<p><a id="sthref605"></a><a id="sthref606"></a>Though the difference between materialized view logs based on primary keys and rowids is small (one records affected rows using the primary key, while the other records affected rows using the physical rowid), the practical impact is large. Using rowid materialized views and materialized view logs makes reorganizing and truncating your master tables difficult because it prevents your <code dir="ltr">ROWID</code> materialized views from being fast refreshed. If you reorganize or truncate your master table, then your rowid materialized view must be <code dir="ltr">COMPLETE</code> refreshed because the rowids of the master table have changed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>You use the <code dir="ltr">BEGIN_TABLE_REORGANIZATION</code> and <code dir="ltr">END_TABLE_REORGANIZATION</code> procedures in the <code dir="ltr">DBMS_MVIEW</code> package to reorganize a master table. See the <a class="olink ARPLS027" href="../ARPLS/d_mview.htm#ARPLS027"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information.</p>
</li>
<li>
<p><a id="sthref607"></a><a id="sthref608"></a><a id="sthref609"></a><a id="sthref610"></a>Online redefinition of tables is another possible way to reorganize master tables, but online redefinition is not allowed on master tables with materialized view logs, master materialized views, and materialized views. Online redefinition is allowed on master tables that do not have materialized view logs. See the <a class="olink ADMIN01514" href="../ADMIN/tables.htm#ADMIN01514"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> for more information about online redefinition of tables.</p>
</li>
</ul>
</div>
<div id="REPLN339" class="sect4"><a id="sthref611"></a>
<h5 class="sect4">Materialized View Logs on Object Tables<a id="sthref612"></a><a id="sthref613"></a></h5>
<p>You can create materialized view logs on object tables. For example, the following SQL statement creates the <code dir="ltr">categories_typ</code> user-defined type:</p>
<pre dir="ltr">CREATE TYPE oe.category_typ AS OBJECT
   (category_name           VARCHAR2(50), 
    category_description    VARCHAR2(1000), 
    category_id             NUMBER(2));
/
</pre>
<p>When you create an object table based on this type, you can either specify that the object identifier should be system-generated or primary key-based:</p>
<pre dir="ltr">CREATE TABLE oe.categories_tab_sys OF oe.category_typ 
    (category_id    PRIMARY KEY)
    OBJECT ID SYSTEM GENERATED;

CREATE TABLE oe.categories_tab_pkbased OF oe.category_typ 
    (category_id    PRIMARY KEY)
    OBJECT ID PRIMARY KEY;
</pre>
<p>When you create a materialized view log on an object table, you must log the object identifier by specifying the <code dir="ltr">WITH</code> <code dir="ltr">OBJECT</code> <code dir="ltr">ID</code> clause, but you can also specify that the primary key is logged if the object identifier is primary key-based.</p>
<p>For example, the following statement creates a materialized view log for the <code dir="ltr">categories_tab_sys</code> object table and specifies that the object identifier column be logged:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON oe.categories_tab_sys
   WITH OBJECT ID;
</pre>
<p>The following statement creates a materialized view log for the <code dir="ltr">categories_tab_pkbased</code> object table and specifies that the primary key column be logged along with the object identifier column:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW LOG ON oe.categories_tab_pkbased
   WITH OBJECT ID, PRIMARY KEY;
</pre></div>
<!-- class="sect4" -->
<div id="REPLN340" class="sect4"><a id="sthref614"></a>
<h5 class="sect4">Restriction on Import of Materialized View Logs to a Different Schema<a id="sthref615"></a><a id="sthref616"></a></h5>
<p>Materialized view logs are exported with the schema name explicitly given in the DDL statements. Therefore, materialized view logs cannot be imported into a schema that is different than the schema from which they were exported. An error is written to the import log file and the items are not imported if you attempt an import using the Data Pump Import utility that specifies the <code dir="ltr">REMAP_SCHEMA</code> import parameter to import an export dump file that contains materialized view logs in the specified schema.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i51494"></a>
<div id="REPLN341" class="sect2">
<h3 class="sect2">Materialized View Site Mechanisms</h3>
<p>When a materialized view is created, additional mechanisms are created at the materialized view site to support the materialized view. Specifically, at least one index is created. If you create an updatable materialized view, then an internal trigger and a local log (the updatable materialized view log) are also created at the materialized view site.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>If the materialized view site is a master materialized view site, then it contains the mechanisms described in the previous section in addition to the mechanisms described in this section. See <a href="#i51462">&#34;Master Site and Master Materialized View Site Mechanisms&#34;</a>.</p>
</li>
<li>
<p>The size limit for a materialized view name is 30 bytes. If you try to create a materialized view with a name larger than 30 bytes, Oracle returns an error.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i57503">Figure 3-10, &#34;Materialized View Replication Objects&#34;</a></div>
<div id="REPLN342" class="sect3"><a id="sthref617"></a>
<h4 class="sect3">Index<a id="sthref618"></a><a id="sthref619"></a></h4>
<p>At least one index is created at the remote materialized view site for each primary key and <code dir="ltr">ROWID</code> materialized view. For a primary key materialized view, the index corresponds to the primary key of the target master table or master materialized view and includes <code dir="ltr">_PK</code> in its name. A number is appended if an index with the same name already exists at the materialized view site. For a <code dir="ltr">ROWID</code> materialized view, the index is on the <code dir="ltr">ROWID</code> column and includes <code dir="ltr">I_SNAP$_</code> in its name. Additional indexes can be created by Oracle at the remote materialized view site to support fast refreshing of materialized views with subqueries.</p>
</div>
<!-- class="sect3" -->
<div id="REPLN343" class="sect3"><a id="sthref620"></a>
<h4 class="sect3">Updatable Materialized View Log<a id="sthref621"></a><a id="sthref622"></a><a id="sthref623"></a></h4>
<p>An updatable materialized view log (<code dir="ltr">USLOG$_</code><span class="italic">materialized_view_name</span>) is used to determine which rows must be overwritten or removed from a materialized view during a fast refresh. A read-only materialized view does not create this log, and Oracle does not use this log during a complete refresh because, in this case, the entire materialized view is replaced.</p>
<p>If there is a conflict between an updatable materialized view and a master, then, during a refresh, the conflict might result in an entry in the updatable materialized view log that is not in the materialized view log at the master site or master materialized view site. In this case, Oracle uses the updatable materialized view log to remove or overwrite the row in the materialized view.</p>
<p>The updatable materialized view log is also used when you fast refresh a writeable materialized view, as illustrated in the following scenario:</p>
<ol>
<li>
<p>A user inserts a row into a writeable materialized view that has a remote master. Because the materialized view is writeable and not updatable, the transaction is not stored in the deferred transaction queue at the materialized view site.</p>
</li>
<li>
<p>Oracle logs information about this insert in the updatable materialized view log.</p>
</li>
<li>
<p>The user fast refreshes the materialized view.</p>
</li>
<li>
<p>Oracle uses the information in the updatable materialized view log and deletes the inserted row. A materialized view must be an exact copy of the master when the fast refresh is complete. Therefore, Oracle must delete the inserted row.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="REPLN344" class="sect3"><a id="sthref624"></a>
<h4 class="sect3">Internal Trigger for the Updatable Materialized View Log<a id="sthref625"></a><a id="sthref626"></a><a id="sthref627"></a></h4>
<p>Like the internal trigger at the master site or master materialized view site, the internal trigger at the materialized view site records DML changes applied to an updatable materialized view in the <code dir="ltr">USLOG$_</code><span class="italic">materialized_view_name</span> log. A read-only materialized view does not create this trigger.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i32253"></a>
<div id="REPLN345" class="sect2">
<h3 class="sect2">Organizational Mechanisms</h3>
<p>In addition to the materialized view mechanisms described in the previous section, several other mechanisms organize the materialized views at the materialized view site. These mechanisms maintain organizational consistency between the materialized view site and its master site or master materialized view site, as well as transactional (read) consistency with the target replication group. These mechanisms are materialized view groups and refresh groups.</p>
<a id="i30731"></a>
<div id="REPLN346" class="sect3">
<h4 class="sect3">Materialized View Groups<a id="sthref628"></a><a id="sthref629"></a></h4>
<p>A <span class="glossaryterm">materialized view group</span> in a replication system maintains a partial or complete copy of the objects at the target replication group at its master site or master materialized view site. Materialized view groups cannot span the boundaries of the replication group at the master site or master materialized view site. <a href="#i27492">Figure 3-12</a> displays the correlation between Groups A and B at the master site and Groups A and B at the materialized view site.</p>
<div id="REPLN347" class="figure">
<p class="titleinfigure"><a id="i27492"></a>Figure 3-12 Materialized View Groups Correspond with Master Groups</p>
<img width="600" height="336" src="img/repln074.gif" alt="Description of Figure 3-12 follows"/><br/>
<a id="sthref630" href="img_text/repln074.htm">Description of &#34;Figure 3-12 Materialized View Groups Correspond with Master Groups&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Group A at the materialized view site (see <a href="#i27492">Figure 3-12</a>) contains only some of the objects in the corresponding Group A at the master site. Group B at the materialized view site contains all objects in Group B at the master site. Under no circumstances, however, could Group B at the materialized view site contain objects from Group A at the master site. As illustrated in <a href="#i27492">Figure 3-12</a>, a materialized view group has the same name as the master group on which the materialized view group is based. For example, a materialized view group based on a <code dir="ltr">personnel</code> master group is also named <code dir="ltr">personnel</code>.</p>
<p><a id="sthref631"></a><a id="sthref632"></a><a id="sthref633"></a>In addition to maintaining organizational consistency between materialized view sites and their master sites or master materialized view sites, materialized view groups are required for supporting updatable materialized views. If a materialized view does not belong to a materialized view group, then it must be a read-only or writeable materialized view.</p>
<div id="REPLN105" class="sect4"><a id="sthref634"></a>
<h5 class="sect4">Materialized View Group Owners<a id="sthref635"></a><a id="sthref636"></a></h5>
<p>A materialized view group owner enables you to have multiple materialized view groups based on a single replication group at a master site or master materialized view site. For example, to support multiple users within the same database at a materialized view site, you might want to create multiple materialized view groups for a target master group. Doing so enables you to define different subqueries for your materialized view definitions in each materialized view group, and allows each user to access only his or her subset of the data.</p>
<p>Defining multiple materialized view groups gives you the ability to control data sets at a group level. For example, if you create different materialized view groups named <code dir="ltr">hr</code>, <code dir="ltr">personnel</code>, and <code dir="ltr">manufacturing</code> for these departments, then you can administer each department as a group, instead of as individual objects. For example, you can drop the objects as a group.</p>
<p>To accommodate multiple materialized view groups at the same materialized view site that are based on a single replication group at the master site or master materialized view site, you can specify a group owner as an additional identifier when defining your materialized view group.</p>
<p>After you have defined your materialized view group with the addition of a group owner, you add your materialized view objects to the target materialized view group by defining the same group owner. When using a group owner, remember that each materialized view object must have a unique name. If a single materialized view site has multiple materialized view groups based on the same replication group at the master site or master materialized view site, then a materialized view group&#39;s object names cannot have the same name as materialized view objects in another materialized view group. To avoid conflicting names, you can append the group owner name to the end of your object name. For example, if you have group owners <code dir="ltr">hr</code> and <code dir="ltr">ac</code>, then you might name the <code dir="ltr">employees</code> materialized view object as <code dir="ltr">employees_hr</code> and <code dir="ltr">employees_ac</code>, respectively.</p>
<p>Additionally, all materialized view groups that are based on the same replication group at a single materialized view site must &#34;point&#34; to the same master site or master materialized view site. For example, if the <code dir="ltr">hr_repg</code> materialized view group owned by <code dir="ltr">hr</code> is based on the associated master group at the <code dir="ltr">orc1.example.com</code> master site, then the <code dir="ltr">hr_repg</code> materialized view group owned by <code dir="ltr">personnel</code> must also be based on the associated master group at <code dir="ltr">orc1.example.com</code>, if the <code dir="ltr">hr</code> and <code dir="ltr">personnel</code> owned groups are at the same materialized view site.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REPMA105" href="../REPMA/rarmanmv.htm#REPMA105"><span class="variable">Oracle Database Advanced Replication Management API Reference</span></a> for more information about defining a group owner using the replication management API</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i30557"></a>
<div id="REPLN109" class="sect3">
<h4 class="sect3">Refresh Groups<a id="sthref637"></a><a id="sthref638"></a></h4>
<p>To preserve referential integrity and transactional (read) consistency among multiple materialized views, Oracle Database can refresh individual materialized views as part of a refresh group. After refreshing all of the materialized views in a refresh group, the data of all materialized views in the group correspond to the same transactionally consistent point in time.</p>
<p>As illustrated in <a href="#i27670">Figure 3-13</a>, a refresh group can contain materialized views from multiple materialized view groups to maintain transactional (read) consistency across replication group boundaries.</p>
<div id="REPLN348" class="figure">
<p class="titleinfigure"><a id="i27670"></a>Figure 3-13 Refresh Groups Can Contain Objects from Multiple Materialized View Groups</p>
<img width="600" height="320" src="img/repln075.gif" alt="Description of Figure 3-13 follows"/><br/>
<a id="sthref639" href="img_text/repln075.htm">Description of &#34;Figure 3-13 Refresh Groups Can Contain Objects from Multiple Materialized View Groups&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>While you might want to define a single refresh group for each materialized view group, it might be more efficient to use one large refresh group that contains objects from multiple materialized view groups. Such a configuration reduces the amount of &#34;overhead&#34; needed to refresh your materialized views. A refresh group can contain up to 400 materialized views.</p>
<p>One configuration that you want to avoid is using multiple refresh groups to refresh the contents of a single materialized view group. Using multiple refresh groups to refresh the contents of a single materialized view group might introduce inconsistencies in the materialized view data, which can cause referential integrity problems at the materialized view site. Only use this type of configuration when you have in-depth knowledge of the database environment and can prevent any referential integrity problems.</p>
</div>
<!-- class="sect3" -->
<div id="REPLN349" class="sect3"><a id="sthref640"></a>
<h4 class="sect3">Refresh Group Size<a id="sthref641"></a><a id="sthref642"></a></h4>
<p>There are a few trade-offs to consider when you are deciding on the size of your refresh groups. Oracle is optimized for large refresh groups. So, large refresh groups refresh faster than an equal number of materialized views in small refresh groups, if the materialized views in the groups are similar. For example, refreshing a refresh group with 100 materialized views is faster than refreshing five refresh groups with 20 materialized views each. Also, large refresh groups enable you to refresh a greater number of materialized views with only one call to the replication management API.</p>
<p>During the refresh of a refresh group, each materialized view in the group is locked at the materialized view site for the amount of time required to refresh all of the materialized views in the refresh group. This locking is required to prevent users from updating the materialized views during the refresh operation, because updates can make the data inconsistent. Therefore, having smaller refresh groups means that the materialized views are locked for less time when you perform a refresh.</p>
<p>Network connectivity must be maintained while performing a refresh. If the connectivity is lost or interrupted during the refresh, then all changes are rolled back so that the database remains consistent. Therefore, in cases where the network connectivity is difficult to maintain, consider using smaller refresh groups.</p>
<p>Advanced Replication includes an optimization for null refresh. That is, if there were no changes to the master tables or master materialized views since the last refresh for a particular materialized view, then almost no extra time is required for the materialized view during materialized view group refresh.</p>
<p><a href="#g89643">Table 3-3</a> summarizes the advantages of large and small refresh groups.</p>
<div id="REPLN350" class="tblformal">
<p class="titleintable"><a id="sthref643"></a><a id="g89643"></a>Table 3-3 Large and Small Refresh Groups</p>
<table class="cellalignment5776" title="Large and Small Refresh Groups" summary="This table shows the advantages of large and small refresh groups." dir="ltr">
<thead>
<tr class="cellalignment5765">
<th class="cellalignment5775" id="r1c1-t49">Advantages of Large Refresh Groups</th>
<th class="cellalignment5775" id="r1c2-t49">Advantages of Small Refresh Groups</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r2c1-t49" headers="r1c1-t49">
<ul>
<li>
<p>Refreshes faster than an equal number of materialized views in multiple refresh groups</p>
</li>
</ul>
</td>
<td class="cellalignment5771" headers="r2c1-t49 r1c2-t49">
<ul>
<li>
<p>Materialized views locked for shorter periods of time</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment5765">
<td class="cellalignment5771" id="r3c1-t49" headers="r1c1-t49">
<ul>
<li>
<p>Refreshes with single replication management API call</p>
</li>
</ul>
</td>
<td class="cellalignment5771" headers="r3c1-t49 r1c2-t49">
<ul>
<li>
<p>Rollback of refresh changes due to loss of connectivity is less likely</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i31171"></a>
<div id="REPLN351" class="sect2">
<h3 class="sect2">Refresh Process<a id="sthref644"></a><a id="sthref645"></a></h3>
<p>A materialized view&#39;s data does not necessarily match the current data of its master table or master materialized view at all times. A materialized view is a transactionally (read) consistent reflection of its master as the data existed at a specific point in time (that is, at creation or when a refresh occurs). To keep a materialized view&#39;s data relatively current with the data of its master, the materialized view must be refreshed periodically. A <span class="glossaryterm">materialized view refresh</span> is an efficient batch operation that makes a materialized view reflect a more current state of its master table or master materialized view.</p>
<p>A refresh of an updatable materialized view first pushes the deferred transactions at the materialized view site to its master site or master materialized view site. Then, the data at the master site or master materialized view site is pulled down and applied to the materialized view.</p>
<p>A row in a master table can be updated many times between refreshes of a materialized view, but the refresh updates the row in the materialized view only once with the current data. For example, a row in a master table might be updated 10 times since the last refresh of a materialized view, but the result is still only one update of the corresponding row in the materialized view during the next refresh.</p>
<p>Decide how and when to refresh each materialized view to make it more current. For example, materialized views based on masters that applications update often might require frequent refreshes. In contrast, materialized views based on relatively static masters usually require infrequent refreshes. In summary, analyze application characteristics and requirements to determine appropriate materialized view refresh intervals.</p>
<p>To refresh materialized views, Oracle supports several refresh types and methods of initiating a refresh.</p>
<a id="i29858"></a>
<div id="REPLN352" class="sect3">
<h4 class="sect3">Refresh Types</h4>
<p>Oracle can refresh a materialized view using either a fast, complete, or force refresh.</p>
<div id="REPLN353" class="sect4"><a id="sthref646"></a>
<h5 class="sect4">Complete Refresh<a id="sthref647"></a><a id="sthref648"></a><a id="sthref649"></a></h5>
<p>To perform a <span class="glossaryterm">complete refresh</span> of a materialized view, the server that manages the materialized view executes the materialized view&#39;s defining query, which essentially re-creates the materialized view. To refresh the materialized view, the result set of the query replaces the existing materialized view data. Oracle can perform a complete refresh for any materialized view. Depending on the amount of data that satisfies the defining query, a complete refresh can take a substantially longer amount of time to perform than a fast refresh.</p>
<p>If you perform a complete refresh of a master materialized view, then the next refresh performed on any materialized views based on this master materialized view must be a complete refresh. If a fast refresh is attempted for such a materialized view after its master materialized view has performed a complete refresh, then Oracle returns the following error:</p>
<pre dir="ltr">ORA-12034 mview log is younger than last refresh
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If complete refresh is used for a materialized view, then set its <code dir="ltr"><a id="sthref650"></a><a id="sthref651"></a><a id="sthref652"></a>PCTFREE</code> to <code dir="ltr">0</code> and <a id="sthref653"></a><a id="sthref654"></a><a id="sthref655"></a><code dir="ltr">PCTUSED</code> to <code dir="ltr">99</code> for maximum efficiency.</div>
</div>
<!-- class="sect4" -->
<div id="REPLN354" class="sect4"><a id="sthref656"></a>
<h5 class="sect4">Fast Refresh<a id="sthref657"></a><a id="sthref658"></a><a id="sthref659"></a></h5>
<p>To perform a <span class="glossaryterm">fast refresh</span>, the master that manages the materialized view first identifies the changes that occurred in the master since the most recent refresh of the materialized view and then applies these changes to the materialized view. Fast refreshes are more efficient than complete refreshes when there are few changes to the master because the participating server and network replicate a smaller amount of data.</p>
<p>You can perform fast refreshes of materialized views only when the master table or master materialized view has a materialized view log. Also, for fast refreshes to be faster than complete refreshes, each join column in the <code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code> statement must have an index on it.</p>
<p><a id="sthref660"></a><a id="sthref661"></a>After a direct path load on a master table or master materialized view using SQL*Loader, a fast refresh does not apply the changes that occurred during the direct path load. Also, fast refresh does not apply changes that result from other types of bulk load operations on masters. Examples of these operations include <code dir="ltr">INSERT</code> statements with an <code dir="ltr">APPEND</code> hint and <code dir="ltr">INSERT</code> <code dir="ltr">...</code> <code dir="ltr">SELECT</code> <code dir="ltr">*</code> <code dir="ltr">FROM</code> statements.</p>
<div id="REPLN355" class="figure">
<p class="titleinfigure"><a id="sthref662"></a>Figure 3-14 Fast Refresh of a Materialized View</p>
<img width="600" height="368" src="img/repln077.gif" alt="Description of Figure 3-14 follows"/><br/>
<a id="sthref663" href="img_text/repln077.htm">Description of &#34;Figure 3-14 Fast Refresh of a Materialized View&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p><a id="sthref664"></a>If you have materialized views based on partitioned master tables, then you might be able to use Partition Change Tracking (PCT) to identify which materialized view rows correspond to a particular partition. PCT is also used to support fast refresh after partition maintenance operations on a materialized view&#39;s master table. PCT-based refresh on a materialized view is possible only if several conditions are satisfied.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DWHSG009" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG009"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for information about PCT and about PCT-based refresh</div>
<p><a id="sthref665"></a><a id="sthref666"></a><a id="sthref667"></a>If you have updatable multitier materialized views, then DML changes made to the multitier materialized view can be pulled back to this materialized view multiple times to ensure data consistency after each refresh of a materialized view. This behavior is best illustrated through an example.</p>
<p>Consider a replication environment with the following characteristics:</p>
<ul>
<li>
<p>Master site <code dir="ltr">orc1.example.com</code> has the <code dir="ltr">oe.customers</code> table.</p>
</li>
<li>
<p>Level 1 materialized view site <code dir="ltr">ca.us</code> has the <code dir="ltr">oe.customers_region</code> updatable materialized view based on the <code dir="ltr">oe.customers</code> table at <code dir="ltr">orc1.example.com</code>.</p>
</li>
<li>
<p>Level 2 updatable materialized view site <code dir="ltr">sf.ca</code> has the <code dir="ltr">oe.customers_sf</code> updatable materialized view based on the <code dir="ltr">oe.customers_region</code> materialized view at <code dir="ltr">ca.us</code>.</p>
</li>
</ul>
<p>Given these characteristics, the following scenario might follow:</p>
<ol>
<li>
<p>The <code dir="ltr">credit_limit</code> for a customer is changed from <code dir="ltr">3000</code> to <code dir="ltr">5000</code> in the <code dir="ltr">oe.customers_sf</code> updatable materialized view at <code dir="ltr">sf.ca</code>.</p>
</li>
<li>
<p>Oracle enters the change in the deferred transaction queue at <code dir="ltr">sf.ca</code>.</p>
</li>
<li>
<p>A fast refresh of the level 2 materialized view <code dir="ltr">oe.customers_sf</code> pushes the new value for the <code dir="ltr">credit_limit</code> to <code dir="ltr">oe.customers_region</code> materialized view at <code dir="ltr">ca.us</code>.</p>
</li>
<li>
<p>The change is applied to the <code dir="ltr">oe.customers_region</code> materialized view at <code dir="ltr">ca.us</code>.</p>
</li>
<li>
<p>The update for the <code dir="ltr">credit_limit</code> at the <code dir="ltr">ca.us</code> site is recorded in both the deferred transaction queue and the materialized view log a this level 1 materialized view site.</p>
</li>
<li>
<p>A fast refresh of the level 2 materialized view <code dir="ltr">oe.customers_sf</code> pulls the <code dir="ltr">credit_limit</code> value of <code dir="ltr">5000</code> back down to this materialized view at <code dir="ltr">sf.ca</code>.</p>
</li>
<li>
<p>A fast refresh of the level 1 materialized view <code dir="ltr">oe.customers_region</code> pushes the new value for the <code dir="ltr">credit_limit</code> to <code dir="ltr">oe.customers</code> master table at <code dir="ltr">orc1.example.com</code>.</p>
</li>
<li>
<p>The change is applied to the <code dir="ltr">oe.customers</code> master table at <code dir="ltr">orc1.example.com</code>.</p>
</li>
<li>
<p>The update for the <code dir="ltr">credit_limit</code> at the <code dir="ltr">orc1.example.com</code> site is recorded in both the deferred transaction queue and the materialized view log a this master site.</p>
</li>
<li>
<p>A new fast refresh of the level 1 materialized view <code dir="ltr">oe.customers_region</code> pulls the <code dir="ltr">credit_limit</code> value of <code dir="ltr">5000</code> back down to this materialized view at <code dir="ltr">ca.us</code>.</p>
</li>
<li>
<p>The update for the <code dir="ltr">credit_limit</code> at the <code dir="ltr">ca.us</code> site is recorded in the materialized view log a this level 1 materialized view site.</p>
</li>
<li>
<p>A fast refresh of the level 2 materialized view <code dir="ltr">oe.customers_sf</code> pulls the <code dir="ltr">credit_limit</code> value of <code dir="ltr">5000</code> back down to this materialized view at <code dir="ltr">sf.ca</code> for a second time.</p>
</li>
</ol>
</div>
<!-- class="sect4" -->
<div id="REPLN356" class="sect4"><a id="sthref668"></a>
<h5 class="sect4">Force Refresh<a id="sthref669"></a><a id="sthref670"></a><a id="sthref671"></a></h5>
<p>To perform a <span class="glossaryterm">force refresh</span> of a materialized view, the server that manages the materialized view attempts to perform a fast refresh. If a fast refresh is not possible, then Oracle Database performs a complete refresh. Use the force setting when you want a materialized view to refresh if a fast refresh is not possible.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN357" class="sect3"><a id="sthref672"></a>
<h4 class="sect3">Initiating a Refresh<a id="sthref673"></a><a id="sthref674"></a></h4>
<p>When creating a refresh group, you can configure the group so that Oracle automatically refreshes the group&#39;s materialized views at scheduled intervals. Conversely, you can omit scheduling information so that the refresh group must be refreshed manually or &#34;on-demand.&#34; Manual refresh is an ideal solution when the refresh is performed with a dial-up network connection.</p>
<div id="REPLN358" class="sect4"><a id="sthref675"></a>
<h5 class="sect4">Scheduled Refresh<a id="sthref676"></a><a id="sthref677"></a><a id="sthref678"></a><a id="sthref679"></a><a id="sthref680"></a><a id="sthref681"></a></h5>
<p>When you create a refresh group for automatic refreshing, you must specify a scheduled refresh interval for the group during the creation process. When setting a group&#39;s refresh interval, consider the following characteristics:</p>
<ul>
<li>
<p>The dates or date expressions specifying the refresh interval must evaluate to a future point in time.</p>
</li>
<li>
<p>The refresh interval must be greater than the length of time necessary to perform a refresh.</p>
</li>
<li>
<p>Relative date expressions evaluate to a point in time relative to the most recent refresh date. If a network or system failure interferes with a scheduled group refresh, then the evaluation of a relative date expression could change accordingly.</p>
</li>
<li>
<p>Explicit date expressions evaluate to specific points in time, regardless of the most recent refresh date.</p>
</li>
<li>
<p>Consider your environment&#39;s tolerance for stale data: if there is a low tolerance, then refresh often; whereas if there is a high tolerance, then refresh less often.</p>
</li>
</ul>
<p>The following are examples of simple date expressions that you can use to specify an interval:</p>
<ul>
<li>
<p>An interval of one hour is specifies as:</p>
<pre dir="ltr">SYSDATE + 1/24
</pre></li>
<li>
<p>An interval of seven days is specifies as:</p>
<pre dir="ltr">SYSDATE + 7
</pre></li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN" href="../ADMIN/toc.htm"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> and <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about date arithmetic</div>
</div>
<!-- class="sect4" -->
<div id="REPLN359" class="sect4"><a id="sthref682"></a>
<h5 class="sect4">On-Demand Refresh<a id="sthref683"></a><a id="sthref684"></a><a id="sthref685"></a><a id="sthref686"></a></h5>
<p>Scheduled materialized view refreshes might not always be the appropriate solution for your environment. For example, immediately following a bulk data load into a master table, dependent materialized views no longer represent the master table&#39;s data. Rather than wait for the next scheduled automatic group refreshes, you can manually refresh dependent materialized view groups to immediately propagate the new rows of the master table to associated materialized views.</p>
<p>You might also want to refresh your materialized views on-demand when your materialized views are integrated with a sales force automation system located on a disconnected laptop. Developers designing the sales force automation software can create an application control, such as a button, that a salesperson can use to refresh the materialized views when they are ready to transfer the day&#39;s orders to the server after establishing a dial-up network connection.</p>
<p>The following example illustrates an on-demand refresh of the <code dir="ltr">hr_refg</code> refresh group:</p>
<pre dir="ltr">EXECUTE DBMS_REFRESH.REFRESH(&#39;hr_refg&#39;);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="sthref687"></a><a id="sthref688"></a>Do not use the <code dir="ltr">DBMS_MVIEW.REFRESH_ALL_MVIEWS</code> or the <code dir="ltr">DBMS_MVIEW.REFRESH_DEPENDENT</code> procedure to refresh materialized views used in a replication environment. Instead, use the <code dir="ltr">DBMS_REFRESH.REFRESH</code> or the <code dir="ltr">DBMS_MVIEW.REFRESH</code> procedure to refresh materialized views in a replication environment.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="REPLN360" class="sect3"><a id="sthref689"></a>
<h4 class="sect3">Constraints and Refresh<a id="sthref690"></a><a id="sthref691"></a></h4>
<p>To avoid any integrity constraint violations during refresh of materialized views, make non primary key integrity constraints on each materialized view deferrable. This requirement includes LOB columns with <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraints. In addition, all materialized views that are related by foreign key constraints should be refreshed together or in the same refresh group.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Primary key constraints on materialized views might or might not be deferrable.</p>
</li>
<li>
<p><a id="sthref692"></a><a id="sthref693"></a>A <code dir="ltr">DELETE</code> <code dir="ltr">CASCADE</code> constraint used with an updatable materialized view must be deferrable.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF52180" href="../SQLRF/clauses002.htm#SQLRF52180"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about making constraints deferrable</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5764">
<tr>
<td class="cellalignment5771">
<table class="cellalignment5769">
<tr>
<td class="cellalignment5768"><a href="repmaster.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5768"><a href="repdt.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5773">
<table class="cellalignment5767">
<tr>
<td class="cellalignment5768"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5768"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5768"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5768"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5768"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5768"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>