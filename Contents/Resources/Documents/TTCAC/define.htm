<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-107394"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Defining%20Cache%20Groups"></a><title>Defining Cache Groups</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 726"/>
<meta name="dcterms.created" content="2014-09-23T15:6:30Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen Application-Tier Database Cache User&#39;s Guide"/>
<meta name="dcterms.identifier" content="E21634-12"/>
<meta name="dcterms.isVersionOf" content="TTCAC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2012, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="prereqs.htm" title="Previous" type="text/html"/>
<link rel="Next" href="operations.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21634-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/21</span> <!-- End Header -->
<div id="TTCAC203" class="chapter"><a id="CHDBFEEJ"></a>
<h1 class="chapter"><span class="secnum">4</span> Defining Cache Groups</h1>
<p>The following sections describe the different types of cache groups and how to define them:</p>
<ul>
<li>
<p><a href="#CHDIGJJB">Cache groups and cache tables</a></p>
</li>
<li>
<p><a href="#CHDCJCDH">Creating a cache group</a></p>
</li>
<li>
<p><a href="#CHDGCGFD">Caching Oracle Database synonyms</a></p>
</li>
<li>
<p><a href="#CBBCHAAJ">Caching Oracle Database LOB data</a></p>
</li>
<li>
<p><a href="#CHDGICCB">Implementing aging in a cache group</a></p>
</li>
<li>
<p><a href="#CHDBACDC">Dynamic cache groups</a></p>
</li>
<li>
<p><a href="#CHDCJADE">Global cache groups</a></p>
</li>
</ul>
<a id="CHDIGJJB"></a>
<div id="TTCAC204" class="sect1">
<h2 class="sect1">Cache groups and cache tables</h2>
<p>A <a id="sthref250"></a>cache group defines the Oracle Database data to cache in the TimesTen database. When you create a cache group, cache tables are created in the TimesTen database that correspond to the Oracle Database tables being cached.</p>
<p>A separate table definition must be specified in the cache group definition for each Oracle Database table that is being cached. The owner, table name, and cached column names of a TimesTen cache table must match the owner, table name, and column names of the corresponding cached Oracle Database table. The cache table can contain all or a subset of the columns and rows of the cached Oracle Database table. Each TimesTen cache table must have a primary key.</p>
<p>Before you define the cache group table, create the Oracle Database tables that are to be cached. Each table should be either:</p>
<ul>
<li>
<p>An Oracle Database table with a primary key on non-nullable columns. The TimesTen cache table primary key must be defined on the full Oracle Database table primary key. For example, if the cached Oracle Database table has a composite primary key on columns <code>c1</code>, <code>c2</code> and <code>c3</code>, the TimesTen cache table must also have a composite primary key on columns <code>c1</code>, <code>c2</code> and <code>c3</code>.</p>
<p>The following example shows how to create a cache group from an Oracle Database table with a composite primary key. Create the <code>job_history</code> table with a composite key on the Oracle database:</p>
<pre>SQL&gt; CREATE TABLE job_history
    (employee_id NUMBER(6) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    job_id VARCHAR2(10) NOT NULL,
    department_id NUMBER(4),
    PRIMARY KEY(employee_id, start_date)); 
Table created.
</pre>
<p>Create the cache group on TimesTen with all columns of the composite primary key:</p>
<pre>Command&gt; CREATE WRITETHROUGH CACHE GROUP job_hist_cg
       &gt; FROM oratt.job_history
       &gt; (employee_id NUMBER(6) NOT NULL,
       &gt; start_date DATE NOT NULL,
       &gt; end_date DATE NOT NULL,
       &gt; job_id VARCHAR2(10) NOT NULL,
       &gt; department_id NUMBER(4),
       &gt; PRIMARY KEY(employee_id, start_date));
</pre></li>
<li>
<p>An Oracle Database table with non-nullable columns upon which a unique index is defined on one or more of the non-nullable columns in the table. The TimesTen cache table primary key must be defined on all of the columns in the unique index. For example, if the unique index for the Oracle Database table is made up of multiple columns <code>c1</code>, <code>c2</code>, and <code>c3</code>, the TimesTen cache table must have a composite primary key on columns <code>c1</code>, <code>c2</code>, and <code>c3</code>.</p>
<p>The following examples create Oracle Database unique indexes defined on tables with non-nullable columns.</p>
<pre>SQL&gt; CREATE TABLE regions(
      region_id NUMBER NOT NULL, 
      region_name VARCHAR2(25));
Table created.
SQL&gt; CREATE UNIQUE INDEX region_idx 
      ON regions(region_id);
Index created.

SQL&gt; CREATE TABLE sales(
      prod_id INT NOT NULL, 
      cust_id INT NOT NULL,
      quantity_sold INT NOT NULL,
      time_id DATE NOT NULL);
Table created.
SQL&gt; CREATE UNIQUE INDEX sales_index ON sales(prod_id, cust_id);
Index created.
</pre>
<p>After creation of the Oracle Database table and unique index, you can create cache groups on TimesTen for these tables using the unique index columns as the primary key definition as shown below:</p>
<pre>Command&gt; CREATE WRITETHROUGH CACHE GROUP region_cg
 &gt; FROM oratt.regions
 &gt; (region_id NUMBER NOT NULL PRIMARY KEY, 
 &gt;  region_name VARCHAR2(25));

Command&gt; CREATE WRITETHROUGH CACHE GROUP sales_cg
 &gt; FROM oratt.sales 
 &gt; (prod_id INT NOT NULL, cust_id INT NOT NULL, 
 &gt;  quantity_sold INT NOT NULL, time_id DATE NOT NULL, 
 &gt;  PRIMARY KEY(prod_id, cust_id));
</pre></li>
</ul>
<p>A TimesTen database can contain multiple cache groups. A cache group can contain one or more cache tables. An Oracle Database table cannot be cached in more than one cache group within the same TimesTen database.</p>
<p>Creating indexes on a cache table in TimesTen can help speed up particular queries issued on the table in the same fashion as on a TimesTen regular table. You can create non-unique indexes on a TimesTen cache table. Do not create unique indexes on a cache table that do not match any unique index on the cached Oracle Database table. Otherwise, it can cause unique constraint failures in the cache table that do not occur in the cached Oracle Database table, and result in these tables in the two databases being no longer synchronized with each other when autorefresh operations are performed.</p>
<div id="TTCAC205" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref251"></a>
<h3 class="sect2"><a id="sthref252"></a>Single-table cache group</h3>
<p>The simplest cache group is one that caches a single Oracle Database table. In a single-table cache group, there is a root table but no child tables.</p>
<p><a href="#CHDCJFBJ">Figure 4-1</a> shows a single-table cache group <code>target_customers</code> that caches the <code>customer</code> table.</p>
<div id="TTCAC206" class="figure">
<p class="titleinfigure"><a id="CHDCJFBJ"></a>Figure 4-1 Cache group with a single table</p>
<img width="336" height="386" src="img/cachegroup1table.gif" alt="Description of Figure 4-1 follows"/><br/>
<a id="sthref253" href="img_text/cachegroup1table.htm">Description of &#34;Figure 4-1 Cache group with a single table&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="CHDIIEGA"></a>
<div id="TTCAC207" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref254"></a>Multiple-table cache group</h3>
<p>A multiple-table cache group is one that defines a root table and one or more child tables. A cache group can only contain one root table. Each <a id="sthref255"></a>child table must reference the primary key or a unique index of the root table or of another child table in the cache group using a foreign key constraint. Although tables in a multiple-table cache group must be related to each other in the TimesTen database through foreign key constraints, it is not required that the tables be related to each other in the Oracle database. The <a id="sthref256"></a>root table does not reference any table in the cache group with a foreign key constraint.</p>
<p><a href="#CHDIJFHG">Figure 4-2</a> shows a multiple-table cache group <code>customer_orders</code> that caches the <code>customer</code>, <code>orders</code> and <code>order_item</code> tables. Each parent table in the <code>customer_orders</code> cache group has a primary key that is referenced by a child table through a foreign key constraint. The <code>customer</code> table is the root table of the cache group because it does not reference any table in the cache group with a foreign key constraint. The primary key of the root table is considered the primary key of the cache group. The <code>orders</code> table is a child table of the customer root table. The <code>order_item</code> table is a child table of the <code>orders</code> child table.</p>
<div id="TTCAC208" class="figure">
<p class="titleinfigure"><a id="CHDIJFHG"></a>Figure 4-2 Cache group with multiple tables</p>
<img width="344" height="500" src="img/cachegroupover.gif" alt="Description of Figure 4-2 follows"/><br/>
<a id="sthref257" href="img_text/cachegroupover.htm">Description of &#34;Figure 4-2 Cache group with multiple tables&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The <a id="sthref258"></a>table hierarchy in a multiple-table cache group can designate child tables to be parents of other child tables. A child table cannot reference more than one parent table. However, a parent table can be referenced by more than one child table.</p>
<p><a href="#CHDCHFCJ">Figure 4-3</a> shows an improper cache table hierarchy. Neither the customer nor the product table references a table in the cache group with a foreign key constraint. This results in the cache group having two root tables which is invalid.</p>
<div id="TTCAC209" class="figure">
<p class="titleinfigure"><a id="CHDCHFCJ"></a>Figure 4-3 Problem: Cache group contains two root tables</p>
<img width="416" height="518" src="img/cachegroupover2.gif" alt="Description of Figure 4-3 follows"/><br/>
<a id="sthref259" href="img_text/cachegroupover2.htm">Description of &#34;Figure 4-3 Problem: Cache group contains two root tables&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>To resolve this problem and cache all the tables, create a cache group which contains the <code>customer</code>, <code>orders</code>, and <code>order_item</code> tables, and a second cache group which contains the <code>product</code> and the <code>inventory</code> tables as shown in <a href="#CHDFHFJG">Figure 4-4</a>.</p>
<div id="TTCAC210" class="figure">
<p class="titleinfigure"><a id="CHDFHFJG"></a>Figure 4-4 Solution: Create two cache groups</p>
<img width="469" height="454" src="img/cachegroupover3.gif" alt="Description of Figure 4-4 follows"/><br/>
<a id="sthref260" href="img_text/cachegroupover3.htm">Description of &#34;Figure 4-4 Solution: Create two cache groups&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCJCDH"></a>
<div id="TTCAC211" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Creating a cache group</h2>
<p>You create cache groups by using a <code>CREATE CACHE GROUP</code> SQL statement or by using Oracle SQL Developer, a graphical tool. For more information about SQL Developer, see <a class="olink TTSDV" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=TTSDV"><span class="italic">Oracle SQL Developer Oracle TimesTen In-Memory Database Support User&#39;s Guide</span></a>.</p>
<p>Cache groups are identified as either system managed or user managed. <a id="sthref261"></a>System managed cache groups enforce specific behaviors, while the behavior of a user managed cache group can be customized. System managed cache group types include:</p>
<ul>
<li>
<p><a href="#CHDGDEDA">Read-only cache group</a></p>
</li>
<li>
<p><a href="#CHDJAJAC">Asynchronous writethrough (AWT) cache group</a></p>
</li>
<li>
<p><a href="#CHDCGGGG">Synchronous writethrough (SWT) cache group</a></p>
</li>
</ul>
<p>See <a href="#CHDGBFBJ">&#34;User managed cache group&#34;</a> for information about user managed cache groups.</p>
<p>The following topics also apply to creating a cache group:</p>
<ul>
<li>
<p><a href="#CHDEBGEI">AUTOREFRESH cache group attribute</a></p>
</li>
<li>
<p><a href="#CHDBIFFG">Using a WHERE clause</a></p>
</li>
<li>
<p><a href="#CHDBEEFE">ON DELETE CASCADE cache table attribute</a></p>
</li>
<li>
<p><a href="#CHDCGJIC">UNIQUE HASH ON cache table attribute</a></p>
</li>
</ul>
<p>Cache groups must be created by and are owned by the cache manager user.</p>
<p>You cannot cache Oracle Database data in a temporary <a id="sthref262"></a>database.</p>
<a id="CHDGDEDA"></a>
<div id="TTCAC212" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Read-only cache group</h3>
<p>A <a id="sthref263"></a>read-only cache group enforces a caching behavior where the TimesTen cache tables cannot be updated directly, and committed updates on the cached Oracle Database tables are automatically refreshed to the cache tables as shown in <a href="#CHDCCGEJ">Figure 4-5</a>.</p>
<div id="TTCAC213" class="figure">
<p class="titleinfigure"><a id="CHDCCGEJ"></a>Figure 4-5 Read-only cache group</p>
<img width="227" height="373" src="img/readonlycg.gif" alt="Description of Figure 4-5 follows"/><br/>
<a id="sthref264" href="img_text/readonlycg.htm">Description of &#34;Figure 4-5 Read-only cache group&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>If the TimesTen database is unavailable for whatever reason, you can still update the Oracle Database tables that are cached in a read-only cache group. When the TimesTen database returns to operation, updates that were committed on the cached Oracle Database tables while the TimesTen database was unavailable are automatically refreshed to the TimesTen cache tables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When TimesTen manages operations for read only cache groups, it connects to the Oracle database using the cache administration user name and password set with the <code>ttCacheUidPwdSet</code> built-in procedure. For more details on <code>ttCacheUidPwdSet</code>, see <a href="prereqs.htm#BCFFCGHH">&#34;Set the cache administration user name and password&#34;</a>.</div>
<p>The following are the definitions of the Oracle Database tables that are to be cached in the read-only cache groups that are defined in <a href="#CHDJFGGA">Example 4-1</a>, <a href="#CHDDGBGF">Example 4-12</a>, <a href="#CHDGJAGF">Example 4-13</a>, <a href="#CHDCCAAI">Example 4-21</a> and <a href="#CHDHGJCF">Example 4-22</a>. The Oracle Database tables are owned by the schema user <code>oratt</code>. The <code>oratt</code> user must be granted the <code>CREATE SESSION</code> and <code>RESOURCE</code> privileges before it can create tables.</p>
<pre>CREATE TABLE customer
(cust_num NUMBER(6) NOT NULL PRIMARY KEY,
 region   VARCHAR2(10),
 name     VARCHAR2(50),
 address  VARCHAR2(100));

CREATE TABLE orders
(ord_num      NUMBER(10) NOT NULL PRIMARY KEY,
 cust_num     NUMBER(6) NOT NULL,
 when_placed  DATE NOT NULL,
 when_shipped DATE NOT NULL);
</pre>
<p>The companion Oracle Database user with the same name as the TimesTen cache manager user must be granted the <code>SELECT</code> privilege on the <code>oratt.customer</code> and <code>oratt.orders</code> tables in order for the cache manager user to create a read-only cache group that caches these tables, and for autorefresh operations to occur from the cached Oracle Database tables to the TimesTen cache tables.</p>
<p>Use the <code>CREATE READONLY CACHE GROUP</code> statement to create a read-only cache group.</p>
<div id="TTCAC214" class="example">
<p class="titleinexample"><a id="CHDJFGGA"></a>Example 4-1 <a id="sthref265"></a>Creating a read-only cache group</p>
<p>The following statement creates a read-only cache group <code>customer_orders</code> that caches the tables <code>oratt.customer</code> (root table) and <code>oratt.orders</code> (child table):</p>
<pre>CREATE READONLY CACHE GROUP customer_orders
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num)),
oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num),
  FOREIGN KEY(cust_num) REFERENCES oratt.customer(cust_num));
</pre></div>
<!-- class="example" -->
<p>The cache tables in a read-only cache group cannot be updated directly. However, you can set the passthrough level to 2 to allow committed update operations issued on a TimesTen cache table to be passed through and processed on the cached Oracle Database table, and then have the updates be automatically refreshed into the cache table. See <a href="operations.htm#CHDDEJAE">&#34;Setting a passthrough level&#34;</a>.</p>
<p>The effects of a passed through statement on cache tables in a read-only cache group do not occur in the transaction in which the update operation was issued. Instead, they are seen after the passed through update operation has been committed on the Oracle database and the next automatic refresh of the cache group has occurred. The companion Oracle Database user of the TimesTen cache manager user must be granted the <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> privileges on the Oracle Database tables that are cached in the read-only cache group in order for the passed through update operations to be processed on the cached Oracle Database tables.</p>
<p>If you manually created the Oracle Database objects used to enforce the predefined behaviors of an autorefresh cache group as described in <a href="prereqs.htm#BCFHCBJE">&#34;Manually create Oracle Database objects used to manage data caching&#34;</a>, you need to set the autorefresh state to <code>OFF</code> when creating the cache group.</p>
<p>Then you need to run the <code>ttIsql</code> utility&#39;s <code>cachesqlget</code> command to generate a SQL*Plus script used to create a log table and a trigger in the Oracle database for each Oracle Database table that is cached in the read-only cache group. See <a href="#CHDGGFAB">&#34;Manually creating Oracle Database objects for autorefresh cache groups&#34;</a> for information about how to create these objects.</p>
<div id="TTCAC215" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref266"></a>
<h4 class="sect3"><a id="sthref267"></a>Restrictions with read-only cache groups</h4>
<p>The following restrictions apply when using a read-only cache group:</p>
<ul>
<li>
<p>The cache tables on TimesTen cannot be updated directly.</p>
</li>
<li>
<p>Only the <code>ON DELETE CASCADE</code> and <code>UNIQUE HASH ON</code> cache table attributes can be used in the cache table definitions.</p>
<p>See <a href="#CHDBEEFE">&#34;ON DELETE CASCADE cache table attribute&#34;</a> for more information about the <code>ON DELETE CASCADE</code> cache table attribute.</p>
<p>See <a href="#CHDCGJIC">&#34;UNIQUE HASH ON cache table attribute&#34;</a> for more information about the <code>UNIQUE HASH ON</code> cache table attribute.</p>
</li>
<li>
<p>A <code>FLUSH CACHE GROUP</code> statement cannot be issued on the cache group.</p>
<p>See <a href="operations.htm#CHDBGBBG">&#34;Flushing a user managed cache group&#34;</a> for more information about the <code>FLUSH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>A <code>TRUNCATE TABLE</code> statement issued on a cached Oracle Database table is not automatically refreshed to the TimesTen cache table.</p>
</li>
<li>
<p>A <code>LOAD CACHE GROUP</code> statement can only be issued on the cache group if the cache tables are empty, unless the cache group is dynamic.</p>
<p>See <a href="operations.htm#CHDBGAAF">&#34;Loading and refreshing a cache group&#34;</a> for more information about the <code>LOAD CACHE GROUP</code> statement.</p>
<p>See <a href="#CHDBACDC">&#34;Dynamic cache groups&#34;</a> for more information about dynamic cache groups.</p>
</li>
<li>
<p>The autorefresh state must be <code>PAUSED</code> before you can issue a <code>LOAD CACHE GROUP</code> statement on the cache group, unless the cache group is dynamic, in which case the autorefresh state must be <code>PAUSED</code> or <code>ON</code>. The <code>LOAD CACHE GROUP</code> statement cannot contain a <code>WHERE</code> clause, unless the cache group is dynamic, in which case the <code>WHERE</code> clause must be followed by a <code>COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> clause.</p>
<p>See <a href="#CHDEBGEI">&#34;AUTOREFRESH cache group attribute&#34;</a> for more information about autorefresh states.</p>
<p>See <a href="#CHDBIFFG">&#34;Using a WHERE clause&#34;</a> for more information about <code>WHERE</code> clauses in cache group definitions and operations.</p>
</li>
<li>
<p>The autorefresh state must be <code>PAUSED</code> before you can issue a <code>REFRESH CACHE GROUP</code> statement on the cache group. The <code>REFRESH CACHE GROUP</code> statement cannot contain a <code>WHERE</code> clause.</p>
<p>See <a href="operations.htm#CHDBGAAF">&#34;Loading and refreshing a cache group&#34;</a> for more information about the <code>REFRESH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>All tables and columns referenced in <code>WHERE</code> clauses when creating, loading or unloading the cache group must be fully qualified. For example:</p>
<p><code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code> and <code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code><code>.</code><code><span class="codeinlineitalic">column_name</span></code></p>
</li>
<li>
<p>Least recently used (LRU) aging cannot be specified on the cache group, unless the cache group is dynamic where LRU aging is defined by default.</p>
<p>See <a href="#CHDCAJDA">&#34;LRU aging&#34;</a> for more information about LRU aging.</p>
</li>
<li>
<p>Read-only cache groups cannot cache Oracle Database views or materialized views.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDJAJAC"></a>
<div id="TTCAC216" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Asynchronous writethrough (AWT) cache group</h3>
<p>An <a id="sthref268"></a>asynchronous writethrough (AWT) cache group enforces a caching behavior where committed updates on the TimesTen cache tables are automatically and asynchronously propagated to the cached Oracle Database tables as shown in <a href="#CHDGGHFJ">Figure 4-6</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You should avoid executing DML statements on Oracle Database tables cached in an AWT cache group. This can result in an error condition. For more information, see <a href="#CBBGBCIG">&#34;Restrictions with AWT cache groups&#34;</a>.</div>
<div id="TTCAC217" class="figure">
<p class="titleinfigure"><a id="CHDGGHFJ"></a>Figure 4-6 Asynchronous writethrough cache group</p>
<img width="201" height="403" src="img/asyncwritethroughcg.gif" alt="Description of Figure 4-6 follows"/><br/>
<a id="sthref269" href="img_text/asyncwritethroughcg.htm">Description of &#34;Figure 4-6 Asynchronous writethrough cache group&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Since an AWT cache group propagates data from the TimesTen database to the Oracle database, any data modified by the user in the cached tables on the Oracle database is not automatically uploaded from the Oracle database to the TimesTen database. In this case, you must explicitly unload and then reload the AWT cache groups on TimesTen.</p>
<p>The transaction commit on the TimesTen database occurs asynchronously from the commit on the Oracle database. This enables an application to continue issuing transactions on the TimesTen database without waiting for the Oracle Database transaction to complete. However, your application cannot ensure when the transactions are completed on the Oracle database.</p>
<p>Execution of the <code>UNLOAD CACHE GROUP</code> statement for an AWT cache group waits until updates on the rows have been propagated to the Oracle database.</p>
<p>You can update cache tables in an AWT cache group even if the Oracle database is unavailable. When the Oracle database returns to operation, updates that were committed on the cache tables while the Oracle database was unavailable are automatically propagated to the cached Oracle Database tables.</p>
<p>If there are updates from DML statements that you do not want propagated to the Oracle database, then you can disable propagation of committed updates (as a result of executing DML statements) within the current transaction to the Oracle database by setting the flag in the <code>ttCachePropagateFlagSet</code> built-in procedure to zero. After the flag is set to zero, the effects of executing any DML statements are never propagated to the back-end Oracle database. Thus, these updates exist only on the TimesTen database. You can then re-enable propagation by resetting the flag to one with the <code>ttCachePropagateFlagSet</code> built-in procedure. After the flag is set back to one, propagation of all committed updates to the Oracle database resumes. The propagation flag automatically resets to one after the transaction is committed or rolled back. See <a class="olink TTREF232" href="../TTREF/proced.htm#TTREF232">&#34;ttCachePropagateFlagSet&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for more details.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When TimesTen manages operations for AWT cache groups, it connects to the Oracle database using the cache administration user name and password set with the <code>ttCacheUidPwdSet</code> built-in procedure. For more details on <code>ttCacheUidPwdSet</code>, see <a href="prereqs.htm#BCFFCGHH">&#34;Set the cache administration user name and password&#34;</a>.</div>
<p>The following is the definition of the Oracle Database table that is to be cached in the AWT cache groups that are defined in <a href="#CHDBIJAJ">Example 4-2</a>, <a href="#CHDBHHBD">Example 4-14</a> and <a href="#CHDJAAAI">Example 4-16</a>. The Oracle Database table is owned by the schema user <code>oratt</code>. The <code>oratt</code> user must be granted the <code>CREATE SESSION</code> and <code>RESOURCE</code> privileges before it can create tables.</p>
<pre>CREATE TABLE customer
(cust_num NUMBER(6) NOT NULL PRIMARY KEY,
 region   VARCHAR2(10),
 name     VARCHAR2(50),
 address  VARCHAR2(100));
</pre>
<p>The companion Oracle Database user of the TimesTen cache manager user must be granted the <code>SELECT</code> privilege on the <code>oratt.customer</code> table in order for the cache manager user to create an AWT cache group that caches this table. The cache administration user must be granted the <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> Oracle Database privileges on the <code>oratt.customer</code> table for asynchronous writethrough operations to be applied to the Oracle Database.</p>
<p>Use the <code>CREATE ASYNCHRONOUS WRITETHROUGH CACHE GROUP</code> statement to create an AWT cache group.</p>
<div id="TTCAC218" class="example">
<p class="titleinexample"><a id="CHDBIJAJ"></a>Example 4-2 <a id="sthref270"></a>Creating an AWT cache group</p>
<p>The following statement creates an asynchronous writethrough cache group <code>new_customers</code> that caches the <code>oratt.customer</code> table:</p>
<pre>CREATE ASYNCHRONOUS WRITETHROUGH CACHE GROUP new_customers
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num));
</pre></div>
<!-- class="example" -->
<p>The following sections describe configuration, behavior, and management for AWT cache groups:</p>
<ul>
<li>
<p><a href="#CHDFGHFF">Managing the replication agent</a></p>
</li>
<li>
<p><a href="#CHDEIHHI">Configuring parallel propagation to Oracle Database tables</a></p>
</li>
<li>
<p><a href="#CBBHDIGF">What an AWT cache group does and does not guarantee</a></p>
</li>
<li>
<p><a href="#CBBGBCIG">Restrictions with AWT cache groups</a></p>
</li>
<li>
<p><a href="#CBBDGDCB">Reporting Oracle Database permanent errors for AWT cache groups</a></p>
</li>
</ul>
<a id="CHDFGHFF"></a>
<div id="TTCAC219" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Managing the replication agent</h4>
<p>Performing asynchronous writethrough operations requires that the replication agent be running on the TimesTen database that contains AWT cache groups. Executing a <code>CREATE ASYNCHRONOUS WRITETHROUGH CACHE GROUP</code> statement creates a replication scheme that enables committed updates on the TimesTen cache tables to be asynchronously propagated to the cached Oracle Database tables.</p>
<p>After you have created AWT cache groups, start the replication agent on the TimesTen database.</p>
<div id="TTCAC220" class="example">
<p class="titleinexample"><a id="CHDICFEF"></a>Example 4-3 Starting the replication agent<a id="sthref271"></a><a id="sthref272"></a><a id="sthref273"></a></p>
<p>The replication agent can be manually started programmatically by calling the <code>ttRepStart</code> built-in procedure as the cache manager user:</p>
<pre>% ttIsql &#34;DSN=cachealone1;UID=cacheuser;PWD=timesten;OraclePWD=oracle&#34;
Command&gt; call ttRepStart;
</pre></div>
<!-- class="example" -->
<p>It can also be started from a command line by running a <a id="sthref274"></a><code>ttAdmin -repStart</code> utility command as a TimesTen external user with the <code>CACHE_MANAGER</code> privilege:</p>
<pre>% ttAdmin -repStart cachealone1
</pre>
<p>The replication agent does not start unless there is at least one AWT cache group or replication scheme in the TimesTen database.</p>
<p>If the replication agent is running, it must be stopped before you can issue another <code>CREATE ASYNCHRONOUS WRITETHROUGH CACHE GROUP</code> statement or a <code>DROP CACHE GROUP</code> statement on an AWT cache group.</p>
<div id="TTCAC221" class="example">
<p class="titleinexample"><a id="sthref275"></a>Example 4-4 Stopping the replication agent<a id="sthref276"></a><a id="sthref277"></a><a id="sthref278"></a></p>
<p>The replication agent can be manually stopped programmatically by calling the <code>ttRepStop</code> built-in procedure as the cache manager user:</p>
<pre>Command&gt; call ttRepStop;
</pre>
<p>It can also be stopped from a command line by running a <code><a id="sthref279"></a>ttAdmin -repStop</code> utility command as a TimesTen external user with the <code>CACHE_MANAGER</code> privilege:</p>
<pre>% ttAdmin -repStop cachealone1
</pre></div>
<!-- class="example" -->
<p>You can set a <a id="sthref280"></a>replication agent start policy to determine how and when the replication agent process starts on a TimesTen database.</p>
<p>The default start policy is <code>manual</code> which means the replication agent must be started manually by calling the <code>ttRepStart</code> built-in procedure or running a <code>ttAdmin -repStart</code> utility command. To manually stop a running replication agent process, call the <code>ttRepStop</code> built-in procedure or run a <code>ttAdmin -repStop</code> utility command.</p>
<p>The start policy can be set to <code>always</code> so that the replication agent starts automatically when the TimesTen main daemon process starts. With the <code>always</code> start policy, the replication agent cannot be stopped when the main daemon is running unless the start policy is changed to either <code>manual</code> or <code>norestart</code> and then a manual stop is issued by calling the <code>ttRepStop</code> built-in procedure or running a <code>ttAdmin -repStop</code> utility command.</p>
<p>With the <code>manual</code> and <code>always</code> start policies, the replication agent automatically restarts after a failure such as a database invalidation.</p>
<p>The start policy can be set to <code>norestart</code> which means the replication agent must be started manually by calling the <code>ttRepStart</code> built-in procedure or running a <code>ttAdmin -repStart</code> utility command, and stopped manually by calling the <code>ttRepStop</code> built-in procedure or running a <code>ttAdmin -repStop</code> utility command.</p>
<p>With the <code>norestart</code> start policy, the replication agent does not automatically restart after a failure such as a database invalidation. You must restart the replication agent manually by calling the <code>ttRepStart</code> built-in procedure or running a <code>ttAdmin -repStart</code> utility command.</p>
<div id="TTCAC222" class="example">
<p class="titleinexample"><a id="sthref281"></a>Example 4-5 Setting a replication agent start policy<a id="sthref282"></a><a id="sthref283"></a><a id="sthref284"></a></p>
<p>As the instance administrator, grant the <code>ADMIN</code> privilege to the cache manager user:</p>
<pre>% ttIsql cachealone1
Command&gt; GRANT ADMIN TO cacheuser;
Command&gt; exit
</pre>
<p>The replication agent start policy can be set programmatically by calling the <code>ttRepPolicySet</code> built-in procedure as the cache manager user:</p>
<pre>% ttIsql &#34;DSN=cachealone1;UID=cacheuser;PWD=timesten;OraclePWD=oracle&#34;
Command&gt; call ttRepPolicySet(&#39;manual&#39;);
Command&gt; exit
</pre>
<p>It can also be set from a command line by running a <a id="sthref285"></a><code>ttAdmin -repPolicy</code> utility command as a TimesTen external user with the <code>ADMIN</code> privilege:</p>
<pre>% ttAdmin -repPolicy always cachealone1
</pre>
<p>Since the AWT cache group uses the replication agent to asynchronously propagate transactions to the Oracle database, these transactions remain in the transaction log buffer and transaction log files until the replication agent confirms they have been fully processed by the Oracle database. You can monitor the propagation for these transactions with the <code>ttLogholds</code> built-in procedure. When you call the <code>ttLogHolds</code> built-in procedure, the description field contains &#34;<code>_ORACLE</code>&#34; to identify the transaction log hold for the AWT cache group propagation.</p>
<pre>Command&gt; call ttLogHolds();
&lt; 0, 18958336, Checkpoint                    , cachealone1.ds0 &gt;
&lt; 0, 19048448, Checkpoint                    , cachealone1.ds1 &gt;
&lt; 0, 19050904, Replication                   , ADC6160529:_ORACLE &gt;
3 rows found.
</pre>
<p>For more details on the <code>ttLogHolds</code> built-in procedure and how to monitor replication through bookmarks and log sequence numbers, see the <a class="olink TTREP468" href="../TTREP/monitor.htm#TTREP468">&#34;Show replicated log holds&#34;</a> section in the <span class="italic">Oracle TimesTen In-Memory Database Replication Guide</span>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDEIHHI"></a>
<div id="TTCAC448" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Configuring <a id="sthref286"></a><a id="sthref287"></a><a id="sthref288"></a>parallel propagation to Oracle Database tables</h4>
<p>To improve throughput for an AWT cache group, you can configure multiple threads that act in parallel to propagate and apply transactional changes to the Oracle database. Parallel propagation enforces transactional dependencies and applies changes in AWT cache tables to Oracle Database tables in commit order.</p>
<p>Parallel propagation is supported for AWT cache groups with the following configurations:</p>
<ul>
<li>
<p>AWT cache groups in a cache grid</p>
</li>
<li>
<p>AWT cache groups involved in an active standby pair replication scheme</p>
</li>
<li>
<p>AWT cache groups in a single TimesTen database (without a replication scheme configuration)</p>
</li>
<li>
<p>AWT cache groups configured with any aging policy</p>
</li>
</ul>
<p>The following data store attributes enable parallel propagation and control the number of threads that operate in parallel to propagate changes from AWT cache tables to the corresponding Oracle Database tables:</p>
<ul>
<li>
<p><code>ReplicationApplyOrdering</code><a id="sthref289"></a> enables parallel propagation by default.</p>
</li>
<li>
<p><code>ReplicationParallelism</code><a id="sthref290"></a> defines the number of transmitter threads on the source database and the number of receiver threads on the target database for parallel replication in a replication scheme. This value can be between 2 and 32 when used solely for parallel replication. The default is 1. In addition, the value of <code>ReplicationParellelism</code> cannot exceed half the value of <code>LogBufParallelism</code>.</p>
</li>
<li>
<p><code>CacheAWTParallelism</code><a id="sthref291"></a>, when set, determines the number of threads used in parallel propagation of changes from AWT cache tables to the Oracle Database tables. Set this attribute to a number from 2 to 31. The default is 1.</p>
</li>
</ul>
<p>Parallel propagation for an AWT cache group is configured with one of the following scenarios:</p>
<ul>
<li>
<p><code>ReplicationApplyOrdering</code> is set to 0 and <code>ReplicationParallelism</code> is greater than 1.</p>
<p>If you do not set <code>CacheAWTParallelism</code>, the number of threads that apply changes to Oracle Database is 2 times the setting for <code>ReplicationParallelism</code>. For example, if <code>ReplicationParallelism=3</code>, the number of threads that apply changes to Oracle Database tables is 6. In this case, <code>ReplicationParallelism</code> can only be set from 2 to 16; otherwise, twice the value would exceed the maximum number of 31 threads for parallel propagation. If the value is set to 16, the maximum number of threads defaults to 31.</p>
</li>
<li>
<p><code>ReplicationApplyOrdering</code> is set to 0, <code>ReplicationParallelism</code> is equal to or greater than 1, and <code>CacheAWTParallelism</code> is greater than 1. The value for <code>CacheAWTParallelism</code> must be greater than or equal to the value set for <code>ReplicationParallelism</code> and less than or equal to 31.</p>
<p>If <code>CacheAWTParallelism</code> is not specified, then <code>ReplicationParallelism</code> is used to determine the number of threads that are used for parallel propagation to Oracle Database. However, since this value is doubled for parallel propagation threads, you can only set <code>ReplicationParallelism</code> to a number from 2 to 16. If the value is set to 16, the maximum number of threads defaults to 31.</p>
<p>If both <code>ReplicationParallelism</code> and <code>CacheAWTParallelism</code> attributes are set, the value set in <code>CacheAWTParallelism</code> configures the number of threads used for parallel propagation. The setting for <code>CacheAWTParallelism</code> determines the number of apply threads for parallel propagation and the setting for <code>ReplicationParallelism</code> determines the number of threads for parallel replication. Thus, if <code>ReplicationParallelism</code> is set to 4 and <code>CacheAWTParallelism</code> is set to 6, then the number of threads that apply changes to Oracle Database tables is 6. This enables the number of threads used to be different for parallel replication and parallel propagation to Oracle Database tables.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information about parallel replication, see <a class="olink TTREP423" href="../TTREP/setup.htm#TTREP423">&#34;Configuring parallel replication&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Replication Guide</span>.
<p>For more details on these data store attributes, see <a class="olink TTREF750" href="../TTREF/attribute.htm#TTREF750">&#34;ReplicationApplyOrdering,&#34;</a> <a class="olink TTREF133" href="../TTREF/attribute.htm#TTREF133">&#34;ReplicationParallelism,&#34;</a> and <a class="olink TTREF760" href="../TTREF/attribute.htm#TTREF760">&#34;CacheAWTParallelism&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</div>
<p>These data store attributes are interrelated. <a href="#CBBHFJFF">Table 4-1</a> shows the result with the combination of the various possible attribute values.</p>
<div id="TTCAC462" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref292"></a><a id="CBBHFJFF"></a>Table 4-1 Results of Parallel Propagation Data Store Attribute Relationships</p>
<table class="cellalignment5353" title="Results of Parallel Propagation Data Store Attribute Relationships" summary="Parallel propagation attribute relationships" dir="ltr">
<thead>
<tr class="cellalignment5344">
<th class="cellalignment5354" id="r1c1-t6">ReplicationApply Ordering</th>
<th class="cellalignment5354" id="r1c2-t6">ReplicationParallelism</th>
<th class="cellalignment5354" id="r1c3-t6">CacheAWTParallelism</th>
<th class="cellalignment5354" id="r1c4-t6">Number of parallel propagation threads</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5344">
<td class="cellalignment5350" id="r2c1-t6" headers="r1c1-t6">
<p>Set to 0, which enables parallel propagation</p>
</td>
<td class="cellalignment5350" headers="r2c1-t6 r1c2-t6">
<p>Set to &gt; 1 for multiple tracks and &lt;= 16.</p>
</td>
<td class="cellalignment5350" headers="r2c1-t6 r1c3-t6">
<p>Not specified.</p>
</td>
<td class="cellalignment5350" headers="r2c1-t6 r1c4-t6">
<p>Set to twice the value of <code>ReplicationParallelism</code>.</p>
</td>
</tr>
<tr class="cellalignment5344">
<td class="cellalignment5350" id="r3c1-t6" headers="r1c1-t6">
<p>Set to 0, which enables parallel propagation</p>
</td>
<td class="cellalignment5350" headers="r3c1-t6 r1c2-t6">
<p>Set to &gt; 16 and &lt;= 32 for multiple tracks.</p>
</td>
<td class="cellalignment5350" headers="r3c1-t6 r1c3-t6">
<p>Not specified.</p>
</td>
<td class="cellalignment5350" headers="r3c1-t6 r1c4-t6">
<p>Error is thrown. If <code>CacheAWTParallelism</code> is not set, then 2 times the value set in <code>ReplicationParallelism</code> specifies the number of threads. Thus, in this case, <code>ReplicationParallelism</code> cannot be greater than 16.</p>
</td>
</tr>
<tr class="cellalignment5344">
<td class="cellalignment5350" id="r4c1-t6" headers="r1c1-t6">
<p>Set to 0, which enables parallel propagation</p>
</td>
<td class="cellalignment5350" headers="r4c1-t6 r1c2-t6">
<p>Set to &gt; 1 and &lt;= 32 for multiple tracks.</p>
</td>
<td class="cellalignment5350" headers="r4c1-t6 r1c3-t6">
<p>Set to &gt;= to <code>ReplicationParallelism</code>.</p>
</td>
<td class="cellalignment5350" headers="r4c1-t6 r1c4-t6">
<p>Set to number specified by <code>CacheAWTParallelism</code>.</p>
</td>
</tr>
<tr class="cellalignment5344">
<td class="cellalignment5350" id="r5c1-t6" headers="r1c1-t6">
<p>Set to 0, which enables parallel propagation</p>
</td>
<td class="cellalignment5350" headers="r5c1-t6 r1c2-t6">
<p>Set to &gt; 1 and &lt;= 32 for multiple tracks.</p>
</td>
<td class="cellalignment5350" headers="r5c1-t6 r1c3-t6">
<p>Set to &lt; <code>ReplicationParallelism</code>.</p>
</td>
<td class="cellalignment5350" headers="r5c1-t6 r1c4-t6">
<p>Error is thrown at database creation. The <code>CacheAWTParallelism</code> must be set to a value greater than or equal to <code>ReplicationParallelism</code>.</p>
</td>
</tr>
<tr class="cellalignment5344">
<td class="cellalignment5350" id="r6c1-t6" headers="r1c1-t6">
<p>Set to 0, which enables parallel propagation</p>
</td>
<td class="cellalignment5350" headers="r6c1-t6 r1c2-t6">
<p>Set to 1 or not specified. Single track.</p>
</td>
<td class="cellalignment5350" headers="r6c1-t6 r1c3-t6">
<p>Set to &gt; 1</p>
</td>
<td class="cellalignment5350" headers="r6c1-t6 r1c4-t6">
<p>Set to number specified by <code>CacheAWTParallelism</code>.</p>
</td>
</tr>
<tr class="cellalignment5344">
<td class="cellalignment5350" id="r7c1-t6" headers="r1c1-t6">
<p>Set to 1, which disables parallel propagation.</p>
</td>
<td class="cellalignment5350" headers="r7c1-t6 r1c2-t6">
<p>N/A</p>
</td>
<td class="cellalignment5350" headers="r7c1-t6 r1c3-t6">
<p>Set to &gt; 1</p>
</td>
<td class="cellalignment5350" headers="r7c1-t6 r1c4-t6">
<p>Error is thrown at database creation, since parallelism is turned off, but <code>CacheAWTParallelism</code> is set to a value, expecting parallel propagation to be enabled.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformalwide" -->
<p><a id="sthref293"></a><a id="sthref294"></a><a id="sthref295"></a><a id="sthref296"></a>Foreign keys in Oracle Database tables that are to be cached must have indexes created on the foreign keys. Consider these Oracle Database tables:</p>
<pre>CREATE TABLE parent (c1 NUMBER PRIMARY KEY NOT NULL);
CREATE TABLE child (c1 NUMBER PRIMARY KEY NOT NULL, 
                    c2 NUMBER REFERENCES parent(c1));
CREATE TABLE grchild (c1 NUMBER PRIMARY KEY NOT NULL, 
                      c2 NUMBER REFERENCES parent(c1), 
                      c3 NUMBER REFERENCES parent(c1));
</pre>
<p>These indexes must be created:</p>
<pre>CREATE INDEX idx_1 ON child(c2);
CREATE INDEX idx_2 ON grchild(c2);
CREATE INDEX idx_3 ON grchild(c3);
</pre>
<a id="CBBBBFFA"></a>
<div id="TTCAC464" class="sect4">
<h5 class="sect4">Table constraint restrictions when using parallel propagation for AWT cache groups</h5>
<p>When you use parallel propagation for AWT cache groups, you must manually enforce data consistency. A<a id="sthref297"></a>ny unique index, unique constraint, or foreign key constraint that exists on columns in the Oracle Database tables that are to be cached should also be created on the AWT cache tables within TimesTen. If you cannot create these constraints on the AWT cache tables and you have configured for parallel propagation, then TimesTen serializes any transactions with DML operations to any table with missing constraints. For example, if a unique index created on a table in the Oracle database cannot be created on the corresponding cached table in TimesTen, all transactions for this table are serialized.</p>
<p>TimesTen automatically checks for missing constraints on the Oracle database that are not cached on TimesTen when you issue any of the following SQL statements:</p>
<ul>
<li>
<p>When you create an AWT cache group with the <code>CREATE ASYNCHRONOUS CACHE GROUP</code> statement</p>
</li>
<li>
<p>When you create a unique index on an AWT cache table with the <code>CREATE UNIQUE INDEX</code> statement</p>
</li>
<li>
<p>When you drop a unique index on an AWT cache table with the <code>DROP INDEX</code> statement</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can manually initiate a check for missing constraints with the <code>ttCacheCheck</code> built-in procedure. For example, TimesTen does not automatically check for missing constraints after a schema change on cached Oracle Database tables. After any schema change on the Oracle database, you should perform an manual check for missing constraints by executing <code>ttCacheCheck</code> on the TimesTen database.
<p>See <a href="#CBBHBCFF">&#34;Manually initiate check for missing constraints&#34;</a> for other conditions where you should manually check for missing constraints.</p>
</div>
<p>If the check notes missing constraints on the cached tables, TimesTen issues warnings about each missing constraint.</p>
<p>For the following scenarios, the cached table is marked so that transactions that include DML operations are serialized when propagated to the Oracle database.</p>
<ul>
<li>
<p>Transactions that apply DML operations to AWT cache tables that are missing unique indexes or unique constraints.</p>
</li>
<li>
<p>Missing foreign key constraints for tables within a single AWT cache group.</p>
<ul>
<li>
<p>If both the referencing table and the referenced table for the foreign key relationship are in the same AWT cache group and the foreign key relationship is not defined, both tables are marked for transaction serialization.</p>
</li>
<li>
<p>If the referencing table is in an AWT cache group and the referenced table is not in an AWT cache group, the table inside the cache group is not marked for transaction serialization. Only a warning is issued to notify the user of the missing constraint.</p>
</li>
<li>
<p>If the referenced table is in an AWT cache group and the referencing table is not in an AWT cache group, the table inside the cache group is not marked for transaction serialization. Only a warning is issued to notify the user of the missing constraint.</p>
</li>
</ul>
</li>
<li>
<p>Missing foreign key constraints between cache groups. When you have tables defined in separate AWT cache groups that are missing a foreign key constraint, both tables are marked for serialized transactions.</p>
</li>
<li>
<p>If a missing foreign key constraint causes a chain of foreign key constraints to be broken between two AWT cache groups, transactions for all tables within both AWT cache groups are serialized.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
An Oracle Database trigger may introduce an operational dependency of which TimesTen may not be aware. In this case, you should either disable parallel propagation for the AWT cache group or do not cache the table in an AWT cache group on which the trigger is created.</div>
<div id="TTCAC465" class="example">
<p class="titleinexample"><a id="sthref298"></a>Example 4-6 Examples of missing constraints when creating an AWT cache group</p>
<p>The following example creates two tables in the <code>oratt</code> schema in the Oracle database. There is a foreign key relationship between <code>active_customer</code> and the <code>ordertab</code> tables. Because the examples use these tables for parallel propagation, an index is created on the foreign key in the <code>ordertab</code> table.</p>
<pre>SQL&gt; CREATE TABLE active_customer
       (custid NUMBER(6) NOT NULL PRIMARY KEY,
        name VARCHAR2(50),
        addr VARCHAR2(100),
        zip VARCHAR2(12),
        region VARCHAR2(12) DEFAULT &#39;Unknown&#39;);
Table created.
 
SQL&gt; CREATE TABLE ordertab
       (orderid NUMBER(10) NOT NULL PRIMARY KEY,
        custid NUMBER(6) NOT NULL);
Table created.
 
SQL&gt; ALTER TABLE ordertab 
      ADD CONSTRAINT cust_fk 
       FOREIGN KEY (custid) REFERENCES active_customer(custid);
Table altered.

SQL&gt; CREATE INDEX order_idx on ordertab (custid);
</pre></div>
<!-- class="example" -->
<p>TimesTen automatically checks for missing constraints when each <code>CREATE CACHE GROUP</code> is issued. In the following example, a single cache group is created that includes the <code>active_customer</code> table. Only a warning is issued since the <code>active_customer</code> is the referenced table and the referencing table, <code>ordertab</code>, is not in any AWT cache group. The <code>active_customer</code> table is not marked for serialized transactions.</p>
<pre>CREATE WRITETHROUGH CACHE GROUP update_cust
 FROM oratt.active_customer
 (custid NUMBER(6) NOT NULL PRIMARY KEY,
 name VARCHAR2(50),
 addr VARCHAR2(100),
 zip VARCHAR2(12));
Warning  5297: The following Oracle foreign key constraints on AWT cache table 
ORATT.ACTIVE_CUSTOMER contain cached columns that do not have corresponding 
foreign key constraints on TimesTen: ORATT.CUST_FK [Outside of CG].
</pre>
<p>The following example creates two AWT cache groups on TimeTen, one that includes the <code>active_customer</code> table and the other includes the <code>ordertab</code> table. There is a missing foreign key constraint between the cache groups. Thus, a warning is issued for both tables, but only the <code>ordertab</code> table is marked for serial transactions since it is the referencing table that should contain the foreign key.</p>
<pre>CREATE WRITETHROUGH CACHE GROUP update_cust
 FROM oratt.active_customer
 (custid NUMBER(6) NOT NULL PRIMARY KEY,
 name VARCHAR2(50),
 addr VARCHAR2(100),
 zip VARCHAR2(12);
Warning  5297: The following Oracle foreign key constraints on AWT cache table 
oratt.update_customer contain cached columns that do not have corresponding 
foreign key constraints on TimesTen: ordertab.cust_fk [Outside of CG].

CREATE WRITETHROUGH CACHE GROUP update_orders
 FROM oratt.ordertab
 (orderid NUMBER(10) NOT NULL PRIMARY KEY,
  custid NUMBER(6) NOT NULL);
Warning  5295: Propagation will be serialized on AWT cache table 
ORATT.ORDERTAB because the following Oracle foreign key constraints on this 
table contain cached columns that do not have corresponding foreign key 
constraints on TimesTen: ORDERTAB.CUST_FK [Across AWT cache groups].
</pre>
<a id="CBBHBCFF"></a>
<div id="TTCAC519" class="sect4">
<h5 class="sect4">Manually initiate check for missing constraints</h5>
<p>The <code>ttCacheCheck</code> built-in procedure performs the same check for missing constraints for cached tables on the Oracle database as performed automatically by TimesTen. The <code>ttCacheCheck</code> provides appropriate messages about missing constraints and the tables marked for serialized propagation. With the <code>ttCacheCheck</code> built-in procedure, you can check for missing constraints for a given cache group or for all cache groups in TimesTen to ensure that all cache groups are not missing constraints.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Since <code>ttCacheCheck</code> updates system tables to indicate if DML executed against a table should or should not be serialized, you must commit or roll back after the <code>ttCacheCheck</code> built-in completes.
<p>For more details of the <code>ttCacheCheck</code> built-in procedure, see <a class="olink TTREF792" href="../TTREF/proced.htm#TTREF792">&#34;ttCacheCheck&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</div>
<p>You may need to manually call the <code>ttCacheCheck</code> built-in procedure to update the known dependencies after any of the following scenarios:</p>
<ul>
<li>
<p>After dropping a series of AWT cache groups on TimesTen with the <code>DROP CACHE GROUP</code> statement.</p>
</li>
<li>
<p>After adding or dropping a unique index, unique constraint, or foreign key on an Oracle Database table that is cached in an AWT cache group. If you do not call the <code>ttCacheCheck</code> built-in procedure after adding a constraint, you may receive a run time error on the AWT cache group. After dropping a constraint, TimesTen may serialize transactions even if it is not necessary. Calling the <code>ttCacheCheck</code> built-in procedure verifies whether serialization is necessary.</p>
</li>
<li>
<p>You can use this built-in procedure to determine why some transactions are being serialized.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>ttCacheCheck</code> built-in procedure cannot be called while the replication agent is running.
<p>If a DDL statement is being executed on an AWT cache group when <code>ttCacheCheck</code> is called, then <code>ttCacheCheck</code> waits for the statement to complete or until the timeout period is reached.</p>
<p>If you have not defined the <code>CacheAwtParallelism</code> data store attribute to greater than one or the specified cache group is not an AWT cache group, then the <code>ttCacheCheck</code> built-in procedure returns an empty result set.</p>
</div>
<div id="TTCAC466" class="example">
<p class="titleinexample"><a id="sthref299"></a>Example 4-7 Manually executing ttCacheCheck update missing dependencies</p>
<p>The following example shows the user manually executing the <code>ttCacheCheck</code> built-in procedure to determine if there are any missing constraints for an AWT cache group <code>update_orders</code> that is owned by <code>cacheuser</code>. A result set is returned that includes the error message. The <code>ordertab</code> table in the <code>update_orders</code> cache group is marked for serially propagated transactions.</p>
<pre>Command&gt; call ttCacheCheck(NULL, &#39;cacheuser&#39;, &#39;update_orders&#39;);

&lt; CACHEUSER, UPDATE_ORDERS, CACHEUSER, ORDERTAB, Foreign Key, CACHEUSER, 
CUST_FK, 1, Transactions updating this table will be serialized to Oracle
because: The missing foreign key connects two AWT cache groups., 
table CACHEUSER.ORDERTAB constraint CACHEUSER.CUST_FK foreign key(CUSTID) 
references CACHEUSER.ACTIVE_CUSTOMER(CUSTID) &gt;
1 row found.
</pre></div>
<!-- class="example" -->
<p>Whenever the cache group schema changes in either the TimesTen or Oracle databases, you can call <code>ttCacheCheck</code> against all AWT cache groups to verify all constraints. The following example shows the user manually executing the <code>ttCacheCheck</code> built-in procedure to determine if there are any missing constraints for any AWT cache group in the entire TimesTen database by providing a <code>NULL</code> value for all input parameters. A result set is returned that includes any error messages.</p>
<pre>Command&gt; call ttCacheCheck(NULL, NULL, NULL);

&lt; CACHEUSER, UPDATE_ORDERS, CACHEUSER, ORDERTAB, Foreign Key, CACHEUSER, 
CUST_FK, 1, Transactions updating this table will be serialized to Oracle
because: The missing foreign key connects two AWT cache groups., 
table CACHEUSER.ORDERTAB constraint CACHEUSER.CUST_FK foreign key(CUSTID) 
references CACHEUSER.ACTIVE_CUSTOMER(CUSTID) &gt;
1 row found.
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect4" -->
<a id="CBBFJJHD"></a>
<div id="TTCAC509" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Configuring batch size for parallel propagation for AWT cache groups<a id="sthref300"></a><a id="sthref301"></a><a id="sthref302"></a></h5>
<p>When using AWT cache groups, TimesTen batches together one or more transactions that are to be applied in parallel to the back-end Oracle database. The <code>CacheParAwtBatchSize</code> parameter configures a threshold value for the number of rows included in a single batch. Once the maximum number of rows is reached, TimesTen includes the rest of the rows in the transaction (TimesTen does not break up any transactions), but does not add any more transactions to the batch.</p>
<p>For example, a user sets the <code>CacheParAwtBatchSize</code> to 200. For the next AWT propagation, there are three transactions, each with 120 rows, that need to be propagated and applied to the Oracle database. TimesTen includes the first two transactions in the first batch for a total of 240 rows. The third transaction is included in a second batch.</p>
<p>The default value for the <code>CacheParAwtBatchSize</code> parameter is 125 rows. The minimum value is 1. For more details on the <code>CacheParAwtBatchSize</code> parameter in the <code>ttDBConfig</code> built-in procedure, see <a class="olink TTREF795" href="../TTREF/proced.htm#TTREF795">&#34;ttDBConfig&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
<p>You can retrieve the current value of <code>CacheParAwtBatchSize</code> as follows:</p>
<pre>call ttDBConfig(&#39;CacheParAwtBatchSize&#39;);
&lt; CACHEPARAWTBATCHSIZE, 125 &gt;
1 row found.
 
</pre>
<p>You can set the <code>CacheParAwtBatchSize</code> parameter to 200 as follows:</p>
<pre>call ttDBConfig(&#39;CacheParAwtBatchSize&#39;,&#39;200&#39;);
&lt; CACHEPARAWTBATCHSIZE, 200 &gt;
1 row found
 
</pre>
<p>Set the <code>CacheParAwtBatchSize</code> parameter only when advised by Oracle Support, who analyzes the workload and any dependencies in the workload to determine if a different value for <code>CacheParAwtBatchSize</code> could improve performance. Dependencies exist when transactions concurrently change the same data. Oracle Support may advise you to reduce this value if there are too many dependencies in the workload.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CBBHDIGF"></a>
<div id="TTCAC223" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">What an AWT cache group does and does not guarantee</h4>
<p>An AWT cache group <span class="italic">can</span> guarantee that:</p>
<ul>
<li>
<p>No transactions are lost because of communication failures between the TimesTen and Oracle databases.</p>
</li>
<li>
<p>If the replication agent is not running or loses its connection to the Oracle database, automatic propagation of committed updates on the TimesTen cache tables to the cached Oracle Database tables resumes after the agent restarts or reconnects to the Oracle database.</p>
</li>
<li>
<p>Transactions are committed in the Oracle database in the same order they were committed in the TimesTen database.</p>
</li>
</ul>
<p>An AWT cache group <span class="italic">cannot</span> guarantee that:</p>
<ul>
<li>
<p><a id="sthref303"></a><a id="sthref304"></a>All transactions committed successfully in the TimesTen database are successfully propagated to and committed in the Oracle database. Execution errors on the Oracle database cause the transaction in the Oracle database to be rolled back. For example, an update on the Oracle database may fail because of a unique constraint violation. Transactions that contain execution errors are not retried.</p>
<p>Execution errors are considered permanent errors and are reported to the <code><span class="codeinlineitalic">TimesTenDatabaseFileName</span></code><code>.awterrs</code> file that resides in the same directory as the TimesTen database&#39;s checkpoint files. See <a href="#CBBDGDCB">&#34;Reporting Oracle Database permanent errors for AWT cache groups&#34;</a> for more information.</p>
</li>
<li>
<p>The absolute order of Oracle Database updates is preserved because TimesTen does not resolve update conflicts. The following are some examples:</p>
<ul>
<li>
<p>In two separate TimesTen databases (<code>DB1</code> and <code>DB2</code>), different AWT cache groups cache the same Oracle Database table. An update is committed on the cache table in <code>DB1</code>. An update is then committed on the cache table in <code>DB2</code>. The two cache tables reside in different TimesTen databases and cache the same Oracle Database table. Because the writethrough operations are asynchronous, the update from <code>DB2</code> may get propagated to the Oracle database before the update from <code>DB1</code>, resulting in the update from <code>DB1</code> overwriting the update from <code>DB2</code>.</p>
<p>Using a dynamic AWT global cache group resolves this write inconsistency. See <a href="#CHDCJADE">&#34;Global cache groups&#34;</a> for more information about global cache groups.</p>
</li>
<li>
<p>An update is committed on a cache table in an AWT cache group. The same update is committed on the cached Oracle Database table using a passthrough operation. The cache table update, which is automatically and asynchronously propagated to the Oracle database, may overwrite the passed through update that was processed directly on the cached Oracle Database table depending on when the propagated update and the passed through update is processed on the Oracle database. For this and other potential error conditions, TimesTen recommends that you do not execute DML statements directly against Oracle Database tables cached in an AWT cache group. For more information, see <a href="#CBBGBCIG">&#34;Restrictions with AWT cache groups&#34;</a>.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CBBGBCIG"></a>
<div id="TTCAC224" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><a id="sthref305"></a>Restrictions with AWT cache groups</h4>
<p>The following restrictions apply when using an AWT cache group:</p>
<ul>
<li>
<p>Only the <code>ON DELETE CASCADE</code> and <code>UNIQUE HASH ON</code> cache table attributes can be used in the cache table definitions.</p>
<p>See <a href="#CHDBEEFE">&#34;ON DELETE CASCADE cache table attribute&#34;</a> for more information about the <code>ON DELETE CASCADE</code> cache table attribute.</p>
<p>See <a href="#CHDCGJIC">&#34;UNIQUE HASH ON cache table attribute&#34;</a> for more information about the <code>UNIQUE HASH ON</code> cache table attribute.</p>
</li>
<li>
<p>A <code>FLUSH CACHE GROUP</code> statement cannot be issued on the cache group.</p>
<p>See <a href="operations.htm#CHDBGBBG">&#34;Flushing a user managed cache group&#34;</a> for more information about the <code>FLUSH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>The cache table definitions cannot contain a <code>WHERE</code> clause.</p>
<p>See <a href="#CHDBIFFG">&#34;Using a WHERE clause&#34;</a> for more information about <code>WHERE</code> clauses in cache group definitions and operations.</p>
</li>
<li>
<p>A <code>TRUNCATE TABLE</code> statement cannot be issued on the cache tables.</p>
</li>
<li>
<p>AWT cache groups cannot cache Oracle Database views or materialized views.</p>
</li>
</ul>
<ul>
<li>
<p>The replication agent must be stopped before creating or dropping an AWT cache group.</p>
<p>See <a href="#CHDFGHFF">&#34;Managing the replication agent&#34;</a> for information about how to stop and start the replication agent.</p>
</li>
<li>
<p>Committed updates on the TimesTen cache tables are not propagated to the cached Oracle Database tables unless the replication agent is running.</p>
</li>
<li>
<p>To create an AWT cache group, the length of the absolute path name of the TimesTen database cannot exceed 248 characters.</p>
</li>
<li>
<p>You should avoid executing DML statements on Oracle Database tables cached in an AWT cache group. This could result in an error condition. Any insert, update, or delete operation on the cached Oracle Database table can negatively affect the operations performed on TimesTen for the affected rows. TimesTen does not detect or resolve update conflicts that occur on the Oracle database. Committed updates made directly on a cached Oracle Database table may be overwritten by a committed update made on the TimesTen cache table when the cache table update is propagated to the Oracle database. In addition, deleting rows on the cached Oracle Database table could cause an empty update if TimesTen tries to update a row that no longer exists.</p>
<p>To ensure that not all data is restricted from DML statements on Oracle Database, you can partition the data on Oracle Database to separate the data that is to be included in the AWT cache group from the data to be excluded from the AWT cache group.</p>
</li>
<li>
<p>TimesTen performs deferred checking when determining whether a single SQL statement causes a constraint violation with a unique index.</p>
<p>For example, suppose there is a unique index on a cached Oracle Database table&#39;s <code>NUMBER</code> column, and a unique index on the same <code>NUMBER</code> column on the TimesTen cache table. There are five rows in the cached Oracle Database table and the same five rows in the cache table. The values in the <code>NUMBER</code> column range from 1 to 5.</p>
<p>An <code>UPDATE</code> statement is issued on the cache table to increment the value in the <code>NUMBER</code> column by 1 for all rows. The operation succeeds on the cache table but fails when it is propagated to the cached Oracle Database table.</p>
<p>This occurs because TimesTen performs the unique index constraint check at the end of the statement&#39;s execution after all the rows have been updated. The Oracle database, however, performs the constraint check each time after a row has been updated.</p>
<p>Therefore, when the row in the cache table with value 1 in the <code>NUMBER</code> column is changed to 2 and the update is propagated to the Oracle database, it causes a unique constraint violation with the row that has the value 2 in the <code>NUMBER</code> column of the cached Oracle Database table.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CBBDGDCB"></a>
<div id="TTCAC467" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Reporting Oracle Database permanent errors for AWT cache groups<a id="sthref306"></a><a id="sthref307"></a><a id="sthref308"></a><a id="sthref309"></a><a id="sthref310"></a></h4>
<p>If transactions are not successfully propagated to and committed in the Oracle database, then the permanent errors cause the transaction in the Oracle database to be rolled back. For example, an update on the Oracle database may fail because of a unique constraint violation. Transactions that contain permanent errors are not retried.</p>
<p>Permanent errors are always reported to the <code><span class="codeinlineitalic">TimesTenDatabaseFileName</span></code><code>.awterrs</code> text file that resides in the same directory as the TimesTen database checkpoint files. See <a class="olink TTTRB358" href="../TTTRB/awt_trouble.htm#TTTRB358">&#34;Oracle Database errors reported by TimesTen for AWT&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Troubleshooting Guide</span> for information about the contents of this file.</p>
<p><a id="sthref311"></a><a id="sthref312"></a><a id="sthref313"></a>You can configure TimesTen to report these errors in both ASCII and XML formats with the <code>ttCacheConfig</code> built-in procedure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not pass in any values to the <code><span class="codeinlineitalic">tblOwner</span></code> and <code><span class="codeinlineitalic">tblName</span></code> parameters for <code>ttCacheConfig</code> as they are not applicable to setting the format for the errors file.</div>
<ul>
<li>
<p>To configure TimesTen to report permanent errors to only the <code><span class="codeinlineitalic">TimesTenDatabaseFileName</span></code><code>.awterrs</code> text file, call the <code>ttCacheConfig</code> built-in procedure with the <code>ASCII</code> parameter. This is the default.</p>
<pre>Command&gt; call ttCacheConfig(&#39;AwtErrorXmlOutput&#39;,,,&#39;ASCII&#39;);
</pre></li>
<li>
<p>To configure TimesTen to report permanent errors to both the <code><span class="codeinlineitalic">TimesTenDatabaseFileName</span></code><code>.awterrs</code> text file as well as to an XML file named <code><span class="codeinlineitalic">TimesTenDatabaseFileName</span></code><code>.awterrs.xml</code>, call the <code>ttCacheConfig</code> built-in procedure with the <code>XML</code> parameter.</p>
<pre>Command&gt; call ttCacheConfig(&#39;AwtErrorXmlOutput&#39;,,,&#39;XML&#39;);
</pre></li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Before calling <code>ttCacheConfig</code> to direct permanent errors to the XML file, you must first stop the replication agent. Then, restart the replication agent after the built-in procedure completes.
<p>For full details on this built-in procedure, see <a class="olink TTREF227" href="../TTREF/proced.htm#TTREF227">&#34;ttCacheConfig&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</div>
<p>When you configure error reporting to be reported in XML format, the following two files are generated when Oracle Database permanent errors occur:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">TimesTenDatabaseFileName</span></code><code>.awterrs.xml</code> contains the Oracle Database permanent error messages in XML format.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">TimesTenDatabaseFileName</span></code><code>.awterrs.dtd</code> is the file that contains the XML Document Type Definition (DTD), which is used when parsing the <code><span class="codeinlineitalic">TimesTenDatabaseFileName</span></code><code>.awterrs.xml</code> file.</p>
<p>The XML DTD, which is based on the XML 1.0 specification, is a set of markup declarations that describes the elements and structure of a valid XML file containing a log of errors. The XML file is encoded using UTF-8. The following are the elements for the XML format.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information on reading and understanding XML Document Type Definitions, see <code><a href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a></code>.</div>
<pre>&lt;!ELEMENT ttawterrorreport (awterrentry*) &gt;
&lt;!ELEMENT awterrentry(header, (failedop)?, failedtxn) &gt;
&lt;!ELEMENT header (time, datastore, oracleid, transmittingagent, errorstr,
 (ctn)?, (batchid)?, (depbatchid)?) &gt;
&lt;!ELEMENT failedop (sql) &gt;
&lt;!ELEMENT failedtxn ((sql)+) &gt;
&lt;!ELEMENT time (hour, min, sec, year, month, day) &gt;
&lt;!ELEMENT hour (#PCDATA) &gt;
&lt;!ELEMENT min (#PCDATA) &gt;
&lt;!ELEMENT sec (#PCDATA) &gt;
&lt;!ELEMENT year (#PCDATA) &gt;
&lt;!ELEMENT month (#PCDATA) &gt;
&lt;!ELEMENT day (#PCDATA) &gt;
&lt;!ELEMENT datastore (#PCDATA) &gt;
&lt;!ELEMENT oracleid (#PCDATA) &gt;
&lt;!ELEMENT transmittingagent (transmitingname, pid, threadid) &gt;
&lt;!ELEMENT pid (#PCDATA) &gt;
&lt;!ELEMENT threadid (#PCDATA) &gt;
&lt;!ELEMENT transmittingname (#PCDATA) &gt;
&lt;!ELEMENT errorstr (#PCDATA) &gt;
&lt;!ELEMENT ctn (timestamp, seqnum) &gt;
&lt;!ELEMENT timestamp(#PCDATA) &gt;
&lt;!ELEMENT seqnum(#PCDATA) &gt;
&lt;!ELEMENT batchid(#PCDATA) &gt;
&lt;!ELEMENT depbatchid(#PCDATA) &gt;
&lt;!ELEMENT sql(#PCDATA) &gt;
</pre></li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDCGGGG"></a>
<div id="TTCAC225" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Synchronous writethrough (SWT) cache group<a id="sthref314"></a></h3>
<p>A synchronous writethrough (SWT) cache group enforces a caching behavior where committed updates on the TimesTen cache tables are automatically and synchronously propagated to the cached Oracle Database tables as shown in <a href="#CHDIJDAG">Figure 4-7</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You should avoid executing DML statements on Oracle Database tables cached in an SWT cache group. This can result in an error condition. For more information, see <a href="#CBBBDIGF">&#34;Restrictions with SWT cache groups&#34;</a>.</div>
<div id="TTCAC226" class="figure">
<p class="titleinfigure"><a id="CHDIJDAG"></a>Figure 4-7 Synchronous writethrough cache group</p>
<img width="190" height="368" src="img/writethroughcg.gif" alt="Description of Figure 4-7 follows"/><br/>
<a id="sthref315" href="img_text/writethroughcg.htm">Description of &#34;Figure 4-7 Synchronous writethrough cache group&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The transaction commit on the TimesTen database occurs synchronously with the commit on the Oracle database. When an application commits a transaction in the TimesTen database, the transaction is processed in the Oracle database before it is processed in TimesTen. The application is blocked until the transaction has completed in both the Oracle and TimesTen databases.</p>
<p>If the transaction fails to commit in the Oracle database, the application must roll back the transaction in TimesTen. If the Oracle Database transaction commits successfully but the TimesTen transaction fails to commit, the cache tables in the SWT cache group are no longer synchronized with the cached Oracle Database tables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The behavior and error conditions for how commit occurs on both the TimesTen and Oracle databases when committing propagated updates is the same commit process on a user managed cache group with the <code>PROPAGATE</code> cache attribute that is described in <a href="#CHDGFDDB">&#34;PROPAGATE cache table attribute&#34;</a>.</div>
<p>To manually resynchronize the cache tables with the cached Oracle Database tables, call the <code>ttCachePropagateFlagSet</code> built-in procedure to disable update propagation, and then reissue the transaction in the TimesTen database after correcting the problem that caused the transaction commit to fail in TimesTen. Then, call the <code>ttCachePropagateFlagSet</code> built-in procedure to re-enable update propagation. You can also resynchronize the cache tables with the cached Oracle Database tables by reloading the accompanying cache groups.</p>
<p>The following is the definition of the Oracle Database table that is to be cached in the SWT cache group that is defined in <a href="#CHDGGHAI">Example 4-8</a>. The Oracle Database table is owned by the schema user <code>oratt</code>. The <code>oratt</code> user must be granted the <code>CREATE SESSION</code> and <code>RESOURCE</code> privileges before it can create tables.</p>
<pre>CREATE TABLE product
(prod_num    VARCHAR2(6) NOT NULL PRIMARY KEY,
 name        VARCHAR2(30),
 price       NUMBER(8,2),
 ship_weight NUMBER(4,1));
</pre>
<p>The companion Oracle Database user of the TimesTen cache manager user must be granted the <code>SELECT</code> privilege on the <code>oratt.product</code> table in order for the cache manager user to create an SWT cache group that caches this table. This Oracle Database user must also be granted the <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> privileges on the <code>oratt.product</code> table for synchronous writethrough operations to occur from the TimesTen cache table to the cached Oracle Database table.</p>
<p>Use the <code>CREATE SYNCHRONOUS WRITETHROUGH CACHE GROUP</code> statement to create an SWT cache group.</p>
<div id="TTCAC227" class="example">
<p class="titleinexample"><a id="CHDGGHAI"></a>Example 4-8 <a id="sthref316"></a>Creating a SWT cache group</p>
<p>The following statement creates a synchronous writethrough cache group <code>top_products</code> that caches the <code>oratt.product</code> table:</p>
<pre>CREATE SYNCHRONOUS WRITETHROUGH CACHE GROUP top_products
FROM oratt.product
 (prod_num    VARCHAR2(6) NOT NULL,
  name        VARCHAR2(30),
  price       NUMBER(8,2),
  ship_weight NUMBER(4,1),
  PRIMARY KEY(prod_num));
</pre></div>
<!-- class="example" -->
<p>When TimesTen manages operations for SWT cache groups, it connects to the Oracle database using the current user&#39;s credentials as the user name and the <code>OraclePwd</code> connection attribute as the Oracle password. TimesTen does not connect to the Oracle database with the cache administration user name and password set with the <code>ttCacheUidPwdSet</code> built-in procedure when managing SWT cache group operations. For more details, see <a href="prereqs.htm#BCFFCGHH">&#34;Set the cache administration user name and password&#34;</a>.</p>
<a id="CBBBDIGF"></a>
<div id="TTCAC228" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><a id="sthref317"></a>Restrictions with SWT cache groups</h4>
<p>The following restrictions apply when using an SWT cache group:</p>
<ul>
<li>
<p>Only the <code>ON DELETE CASCADE</code> and <code>UNIQUE HASH ON</code> cache table attributes can be used in the cache table definitions.</p>
<p>See <a href="#CHDBEEFE">&#34;ON DELETE CASCADE cache table attribute&#34;</a> for more information about the <code>ON DELETE CASCADE</code> cache table attribute.</p>
<p>See <a href="#CHDCGJIC">&#34;UNIQUE HASH ON cache table attribute&#34;</a> for more information about the <code>UNIQUE HASH ON</code> cache table attribute.</p>
</li>
<li>
<p>A <code>FLUSH CACHE GROUP</code> statement cannot be issued on the cache group.</p>
<p>See <a href="operations.htm#CHDBGBBG">&#34;Flushing a user managed cache group&#34;</a> for more information about the <code>FLUSH CACHE GROUP</code> statement</p>
</li>
<li>
<p>The cache table definitions cannot contain a <code>WHERE</code> clause.</p>
<p>See <a href="#CHDBIFFG">&#34;Using a WHERE clause&#34;</a> for more information about <code>WHERE</code> clauses in cache group definitions and operations.</p>
</li>
<li>
<p>A <code>TRUNCATE TABLE</code> statement cannot be issued on the cache tables.</p>
</li>
<li>
<p>SWT cache groups cannot cache Oracle Database views or materialized views.</p>
</li>
<li>
<p>You should avoid executing DML statements directly on Oracle Database tables cached in an SWT cache group. This could result in an error condition. Any insert, update, or delete operation on the cached Oracle Database table can negatively affect the operations performed on TimesTen for the affected rows. TimesTen does not detect or resolve update conflicts that occur on the Oracle database. Committed updates made directly on a cached Oracle Database table may be overwritten by a committed update made on the TimesTen cache table when the cache table update is propagated to the Oracle database. In addition, deleting rows on the cached Oracle Database table could cause an empty update if TimesTen tries to update a row that no longer exists.</p>
<p>To ensure that not all data is restricted from DML statements on Oracle Database, you can partition the data on Oracle Database to separate the data that is to be included in the SWT cache group from the data to be excluded from the SWT cache group.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDGBFBJ"></a>
<div id="TTCAC229" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">User managed cache group<a id="sthref318"></a></h3>
<p>If the system managed cache groups (read-only, AWT, SWT) do not satisfy your application&#39;s requirements, you can create a user managed cache group that defines customized caching behavior with one or more of the following cache table attributes:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When TimesTen manages operations for user managed cache groups, it connects to the Oracle database using the current user&#39;s credentials as the user name and the <code>OraclePwd</code> connection attribute as the Oracle password. TimesTen does not connect to the Oracle database with the cache administration user name and password set with the <code>ttCacheUidPwdSet</code> built-in procedure for user managed cache group operations. For more details, see <a href="prereqs.htm#BCFFCGHH">&#34;Set the cache administration user name and password&#34;</a>.</div>
<ul>
<li>
<p>You can specify the <a href="#CHDBHDHF">READONLY cache table attribute</a> on individual cache tables in a user managed cache group to define read-only behavior where the data is refreshed on TimesTen from the Oracle database at the table level.</p>
</li>
<li>
<p>You can specify the <code>PROPAGATE</code> cache table attribute on individual cache tables in a user managed cache group to define synchronous writethrough behavior at the table level. The <a href="#CHDGFDDB">PROPAGATE cache table attribute</a> specifies that committed updates on the cache table are automatically and synchronously propagated to the cached Oracle Database table.</p>
</li>
<li>
<p>You can define a user managed cache group to automatically refresh and propagate committed updates between the Oracle and TimesTen databases by using the <code>AUTOREFRESH</code> cache group attribute and the <code>PROPAGATE</code> cache table attribute. Using both attributes enables <a id="sthref319"></a>bidirectional transmit, so that committed updates on the TimesTen cache tables or the cached Oracle Database tables are propagated or refreshed to each other.</p>
<p>See <a href="#CHDEBGEI">&#34;AUTOREFRESH cache group attribute&#34;</a> for more information about defining an autorefresh mode, interval, and state.</p>
</li>
<li>
<p>You can use the <code>LOAD CACHE GROUP</code>, <code>REFRESH CACHE GROUP</code>, and <code>FLUSH CACHE GROUP</code> statements to manually control the transmit of committed updates between the Oracle and TimesTen databases.</p>
<p>See <a href="operations.htm#CHDBGAAF">&#34;Loading and refreshing a cache group&#34;</a> for more information about the <code>LOAD CACHE GROUP</code> and <code>REFRESH CACHE GROUP</code> statements. See <a href="operations.htm#CHDBGBBG">&#34;Flushing a user managed cache group&#34;</a> for more information about the <code>FLUSH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>You can cache <a id="sthref320"></a><a id="sthref321"></a>Oracle Database materialized views in a user managed cache group that does not use either the <code>PROPAGATE</code> or <code>AUTOREFRESH</code> cache group attributes. The cache group must be manually loaded and flushed. You cannot cache Oracle Database views.</p>
</li>
</ul>
<p>The following sections provide more information about user managed cache groups:</p>
<ul>
<li>
<p><a href="#CHDBHDHF">READONLY cache table attribute</a></p>
</li>
<li>
<p><a href="#CHDGFDDB">PROPAGATE cache table attribute</a></p>
</li>
<li>
<p><a href="#CBBBGHEI">Examples of user managed cache groups</a></p>
</li>
</ul>
<a id="CHDBHDHF"></a>
<div id="TTCAC235" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><a id="sthref322"></a><a id="sthref323"></a>READONLY cache table attribute</h4>
<p>The <code>READONLY</code> cache table attribute can be specified only for cache tables in a user managed cache group. <code>READONLY</code> specifies that the cache table cannot be updated directly. By default, a cache table in a user managed cache group is updatable.</p>
<p>Unlike a read-only cache group where all of its cache tables are read-only, in a user managed cache group individual cache tables can be specified as read-only using the <code>READONLY</code> cache table attribute.</p>
<p><a href="#CHDGCCED">Example 4-10</a> demonstrates the <code>READONLY</code> cache table attribute in the <code>oratt.cust_interests</code> cache table.</p>
<p>The following restrictions apply when using the <code>READONLY</code> cache table attribute:</p>
<ul>
<li>
<p>If the cache group uses the <code>AUTOREFRESH</code> cache group attribute, the <code>READONLY</code> cache table attribute must be specified on all or none of its cache tables.</p>
<p>See <a href="#CHDEBGEI">&#34;AUTOREFRESH cache group attribute&#34;</a> for more information about using the <code>AUTOREFRESH</code> cache group attribute.</p>
</li>
<li>
<p>You cannot use both the <code>READONLY</code> and <code>PROPAGATE</code> cache table attributes on the same cache table.</p>
<p>See <a href="#CHDGFDDB">&#34;PROPAGATE cache table attribute&#34;</a> for more information about using the <code>PROPAGATE</code> cache table attribute.</p>
</li>
<li>
<p>A <code>FLUSH CACHE GROUP</code> statement cannot be issued on the cache group unless one or more of its cache tables use neither the <code>READONLY</code> nor the <code>PROPAGATE</code> cache table attribute.</p>
<p>See <a href="operations.htm#CHDBGBBG">&#34;Flushing a user managed cache group&#34;</a> for more information about the <code>FLUSH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>After the <code>READONLY</code> cache table attribute has been specified on a cache table, you cannot change this attribute unless you drop the cache group and re-create it.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CHDGFDDB"></a>
<div id="TTCAC234" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><a id="sthref324"></a><a id="sthref325"></a>PROPAGATE cache table attribute</h4>
<p>The <code>PROPAGATE</code> cache table attribute can be specified only for cache tables in a user managed cache group. <code>PROPAGATE</code> specifies that committed updates on the TimesTen cache table as part of a TimesTen transaction are automatically and synchronously propagated to the cached Oracle Database table. If the <code>PROPAGATE</code> cache table attribute is not specified, then the default setting for a cache table in a user managed cache group is the <code>NOT PROPAGATE</code> cache table attribute (which does not propagate committed updates on the cache table to the cached Oracle table).</p>
<p>All SQL statements executed by an application on cached tables are applied to the cached tables immediately. All of these operations are buffered until the transaction commits or reaches a memory upper limit. At this time, all operations are propagated to the tables in the Oracle database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the TimesTen database or its daemon fails unexpectedly, the results of the transaction on either the TimesTen or Oracle databases are not guaranteed.</div>
<p>Since the operations in the transaction are applied to tables in both the TimesTen and Oracle databases, the process for committing is as follows:</p>
<ol>
<li>
<p>After the operations are propagated to the Oracle database, the commit is first attempted in the Oracle database.</p>
<ul>
<li>
<p>If an error occurs when applying the operations on the tables in the Oracle database, then all operations are rolled back on the tables on the Oracle database. If the commit fails in the Oracle database, the commit is not attempted in the TimesTen database and the application must roll back the TimesTen transaction. If the user tries to execute another statement, an error displays informing them of the need for a rollback. As a result, the Oracle database never misses updates committed in TimesTen.</p>
</li>
</ul>
</li>
<li>
<p>If the commit succeeds in the Oracle database, the commit is attempted in the TimesTen database.</p>
<ul>
<li>
<p>If the transaction successfully commits on the Oracle database, the user&#39;s transaction is committed on TimesTen (indicated by the commit log record in the transaction log) and notifies the application. If the application ends abruptly before TimesTen informs it of the success of the local commit, TimesTen is still able to finalize the transaction commit on TimesTen based on what is saved in the transaction log.</p>
</li>
<li>
<p>If the transaction successfully commits on the Oracle database and a failure occurs before returning the status of the commit on TimesTen, then no record of the successful commit is written into the transaction log and the transaction is rolled back.</p>
</li>
<li>
<p>If the commit fails in TimesTen, an error message is returned from TimesTen indicating the cause of the failure. You then need to manually resynchronize the cache tables with the Oracle Database tables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
See <a href="#CHDCGGGG">&#34;Synchronous writethrough (SWT) cache group&#34;</a> for information on how to resynchronize the cache tables with the Oracle Database tables.</div>
</li>
</ul>
</li>
</ol>
<p>You can disable propagation of committed updates on the TimesTen cached tables to the Oracle database with the <code>ttCachePropagateFlagSet</code> built-in procedure. This built-in procedure can enable or disable automatic propagation so that committed updates on a cache table on TimesTen for the current transaction are never propagated to the cached Oracle Database table. You can then re-enable propagation for DML statements by resetting the flag to one with the <code>ttCachePropagateFlagSet</code> built-in procedure. After the flag is set back to one, propagation of committed updates to the Oracle database resumes. The propagation flag automatically resets to one after the transaction is committed or rolled back. See <a class="olink TTREF232" href="../TTREF/proced.htm#TTREF232">&#34;ttCachePropagateFlagSet&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for more details.</p>
<p><a href="#CHDIAJEF">Example 4-9</a> demonstrates the use of the <code>PROPAGATE</code> cache table attribute in the <code>oratt.active_customer</code> cache table.</p>
<div id="TTCAC520" class="sect4"><a id="sthref326"></a>
<h5 class="sect4">Restrictions for the PROPAGATE cache attribute</h5>
<p>The following restrictions apply when using the <code>PROPAGATE</code> cache table attribute:</p>
<ul>
<li>
<p>If the cache group uses the <code>AUTOREFRESH</code> cache group attribute, the <code>PROPAGATE</code> cache table attribute must be specified on all or none of its cache tables.</p>
<p>See <a href="#CHDEBGEI">&#34;AUTOREFRESH cache group attribute&#34;</a> for more information about using the <code>AUTOREFRESH</code> cache group attribute.</p>
</li>
<li>
<p>If the cache group uses the <code>AUTOREFRESH</code> cache group attribute, the <code>NOT PROPAGATE</code> cache table attribute cannot be explicitly specified on any of its cache tables.</p>
</li>
<li>
<p>You cannot use both the <code>PROPAGATE</code> and <code>READONLY</code> cache table attributes on the same cache table.</p>
<p>See <a href="#CHDBHDHF">&#34;READONLY cache table attribute&#34;</a> for more information about using the <code>READONLY</code> cache table attribute.</p>
</li>
<li>
<p>A <code>FLUSH CACHE GROUP</code> statement cannot be issued on the cache group unless one or more of its cache tables use neither the <code>PROPAGATE</code> nor the <code>READONLY</code> cache table attribute.</p>
<p>See <a href="operations.htm#CHDBGBBG">&#34;Flushing a user managed cache group&#34;</a> for more information about the <code>FLUSH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>After the <code>PROPAGATE</code> cache table attribute has been specified on a cache table, you cannot change this attribute unless you drop the cache group and re-create it.</p>
</li>
<li>
<p>The <code>PROPAGATE</code> cache table attribute cannot be used when caching Oracle Database materialized views.</p>
</li>
<li>
<p>TimesTen does not perform a conflict check to prevent a propagate operation from overwriting data that was updated directly on a cached Oracle Database table. Therefore, updates should only be performed directly on the TimesTen cache tables or the cached Oracle Database tables, but not both.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CBBBGHEI"></a>
<div id="TTCAC521" class="sect3">
<h4 class="sect3">Examples of user managed cache groups</h4>
<p>The following are the definitions of the Oracle Database tables that are to be cached in the user managed cache groups that are defined in <a href="#CHDIAJEF">Example 4-9</a> and <a href="#CHDGCCED">Example 4-10</a>. The Oracle Database tables are owned by the schema user <code>oratt</code>. The <code>oratt</code> user must be granted the <code>CREATE SESSION</code> and <code>RESOURCE</code> privileges before it can create tables.</p>
<pre>CREATE TABLE active_customer
 (custid NUMBER(6) NOT NULL PRIMARY KEY,
  name   VARCHAR2(50),
  addr   VARCHAR2(100),
  zip    VARCHAR2(12),
  region VARCHAR2(12) DEFAULT &#39;Unknown&#39;);

CREATE TABLE ordertab
 (orderid NUMBER(10) NOT NULL PRIMARY KEY,
  custid  NUMBER(6) NOT NULL);

CREATE TABLE cust_interests
 (custid   NUMBER(6) NOT NULL,
  interest VARCHAR2(10) NOT NULL,
  PRIMARY KEY (custid, interest));

CREATE TABLE orderdetails
 (orderid  NUMBER(10) NOT NULL,
  itemid   NUMBER(8) NOT NULL,
  quantity NUMBER(4) NOT NULL,
  PRIMARY KEY (orderid, itemid));
</pre>
<p>Use the <code>CREATE USERMANAGED CACHE GROUP</code> statement to create a user managed cache group.</p>
<div id="TTCAC230" class="example">
<p class="titleinexample"><a id="CHDIAJEF"></a>Example 4-9 <a id="sthref327"></a>Creating a single-table user managed cache group</p>
<p>The following statement creates a user managed cache group <code>update_anywhere_customers</code> that caches the <code>oratt.active_customer</code> table as shown in <a href="#BABFAHGE">Figure 4-8</a>:</p>
<pre>CREATE USERMANAGED CACHE GROUP update_anywhere_customers
AUTOREFRESH MODE INCREMENTAL INTERVAL 30 SECONDS
FROM oratt.active_customer
 (custid NUMBER(6) NOT NULL,
  name   VARCHAR2(50),
  addr   VARCHAR2(100),
  zip    VARCHAR2(12),
  PRIMARY KEY(custid),
  PROPAGATE);
</pre></div>
<!-- class="example" -->
<div id="TTCAC231" class="figure">
<p class="titleinfigure"><a id="BABFAHGE"></a>Figure 4-8 Single-table user managed cache group</p>
<img width="323" height="337" src="img/example2.gif" alt="Description of Figure 4-8 follows"/><br/>
<a id="sthref328" href="img_text/example2.htm">Description of &#34;Figure 4-8 Single-table user managed cache group&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>In this example, all columns except <code>region</code> from the <code>oratt.active_customer</code> table are cached in TimesTen. Since this is defined with the <code>PROPAGATE</code> cache table attribute, updates committed on the <code>oratt.active_customer</code> cache table on TimesTen are transmitted to the <code>oratt.active_customer</code> cached Oracle Database table. Since the user managed cache table is also defined with the <code>AUTOREFRESH</code> cache attribute, any committed updates on the <code>oratt.active_customer</code> Oracle Database table are transmitted to the <code>update_anywhere_customers</code> cached table.</p>
<p>The companion Oracle Database user of the TimesTen cache manager user must be granted the <code>SELECT</code> privilege on the <code>oratt.active_customer</code> table in order for the cache manager user to create a user managed cache group that caches this table, and for autorefresh operations to occur from the cached Oracle Database table to the TimesTen cache table. The companion Oracle Database user must also be granted the <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> privileges on the <code>oratt.active_customer</code> table for synchronous writethrough operations to occur from the TimesTen cache table to the cached Oracle Database table.</p>
<p>In this example, the <code>AUTOREFRESH</code> cache group attribute specifies that committed updates on the <code>oratt.active_customer</code> cached Oracle Database table are automatically refreshed to the TimesTen <code>oratt.active_customer cache</code> table every 30 seconds.</p>
<p>If you manually created the Oracle Database objects used to enforce the predefined behaviors of a user managed cache group that uses the <code>AUTOREFRESH MODE INCREMENTAL</code> cache group attribute as described in <a href="prereqs.htm#BCFHCBJE">&#34;Manually create Oracle Database objects used to manage data caching&#34;</a>, you need to set the autorefresh state to <code>OFF</code> when creating the cache group.</p>
<p>Then you need to run the <code>ttIsql</code> utility&#39;s <code>cachesqlget</code> command to generate a SQL*Plus script used to create a log table and a trigger in the Oracle database for each Oracle Database table that is cached in the user managed cache group.</p>
<p>See <a href="#CHDGGFAB">&#34;Manually creating Oracle Database objects for autorefresh cache groups&#34;</a> for more information.</p>
<div id="TTCAC232" class="example">
<p class="titleinexample"><a id="CHDGCCED"></a>Example 4-10 <a id="sthref329"></a>Creating a multiple-table user managed cache group</p>
<p>The following statement creates a user managed cache group <code>western_customers</code> that caches the <code>oratt.active_customer</code>, <code>oratt.ordertab</code>, <code>oratt.cust_interests</code>, and <code>oratt.orderdetails</code> tables as shown in <a href="#BABGGEGD">Figure 4-9</a>:</p>
<pre>CREATE USERMANAGED CACHE GROUP western_customers
FROM oratt.active_customer
 (custid NUMBER(6) NOT NULL,
  name   VARCHAR2(50),
  addr   VARCHAR2(100),
  zip    VARCHAR2(12),
  region VARCHAR2(12),
  PRIMARY KEY(custid),
  PROPAGATE)
  WHERE (oratt.active_customer.region = &#39;West&#39;),
oratt.ordertab
 (orderid NUMBER(10) NOT NULL,
  custid  NUMBER(6) NOT NULL,
  PRIMARY KEY(orderid),
  FOREIGN KEY(custid) REFERENCES oratt.active_customer(custid),
  PROPAGATE),
oratt.cust_interests
 (custid   NUMBER(6) NOT NULL,
  interest VARCHAR2(10) NOT NULL,
  PRIMARY KEY(custid, interest),
  FOREIGN KEY(custid) REFERENCES oratt.active_customer(custid),
  READONLY),
oratt.orderdetails
 (orderid  NUMBER(10) NOT NULL,
  itemid   NUMBER(8) NOT NULL,
  quantity NUMBER(4) NOT NULL,
  PRIMARY KEY(orderid, itemid),
  FOREIGN KEY(orderid) REFERENCES oratt.ordertab(orderid))
  WHERE (oratt.orderdetails.quantity &gt;= 5);
</pre></div>
<!-- class="example" -->
<div id="TTCAC233" class="figure">
<p class="titleinfigure"><a id="BABGGEGD"></a>Figure 4-9 Multiple-table user managed cache group</p>
<img width="378" height="514" src="img/example1.gif" alt="Description of Figure 4-9 follows"/><br/>
<a id="sthref330" href="img_text/example1.htm">Description of &#34;Figure 4-9 Multiple-table user managed cache group&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Only customers in the West region who ordered at least 5 of the same item are cached.</p>
<p>The companion Oracle Database user of the TimesTen cache manager user must be granted the <code>SELECT</code> privilege on the <code>oratt.active_customer</code>, <code>oratt.ordertab</code>, <code>oratt.cust_interests</code>, and <code>oratt.orderdetails</code> tables in order for the cache manager user to create a user managed cache group that caches all of these tables. The companion Oracle Database user must also be granted the <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> privileges on the <code>oratt.active_customer</code> and <code>oratt.ordertab</code> tables for synchronous writethrough operations to occur from these TimesTen cache tables to the cached Oracle Database tables.</p>
<p>Each cache table in the <code>western_customers</code> cache group contains a primary key. Each child table references a parent table with a foreign key constraint. The <code>oratt.active_customer</code> root table and the <code>oratt.orderdetails</code> child table each contain a <code>WHERE</code> clause to restrict the rows to be cached. The <code>oratt.active_customer</code> root table and the <code>oratt.ordertab</code> child table both use the <a href="#CHDGFDDB">PROPAGATE cache table attribute</a> so that committed updates on these cache tables are automatically propagated to the cached Oracle Database tables. The <code>oratt.cust_interests</code> child table uses the <a href="#CHDBHDHF">READONLY cache table attribute</a> so that it cannot be updated directly.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEBGEI"></a>
<div id="TTCAC236" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref331"></a>AUTOREFRESH cache group attribute</h3>
<p>The <code>AUTOREFRESH</code> cache group attribute can be specified when creating a read-only cache group or a user managed cache group using a <code>CREATE CACHE GROUP</code> statement. <code>AUTOREFRESH</code> specifies that committed updates on cached Oracle Database tables are automatically refreshed to the TimesTen cache tables. Autorefresh is defined by default on read-only cache groups.</p>
<p>The following are the default settings of the autorefresh attributes:</p>
<ul>
<li>
<p>The autorefresh mode is incremental.</p>
</li>
<li>
<p>The autorefresh interval is 5 minutes.</p>
</li>
<li>
<p>The autorefresh state is <code>PAUSED</code>.</p>
</li>
</ul>
<p>TimesTen supports two <a id="sthref332"></a>autorefresh modes:</p>
<ul>
<li>
<p><code>INCREMENTAL</code>: Committed updates on cached Oracle Database tables are automatically refreshed to the TimesTen cache tables based on the cache group&#39;s autorefresh interval. Incremental autorefresh mode uses Oracle Database objects to track committed updates on cached Oracle Database tables. See <a href="manage.htm#BABFJHCA">&#34;Managing a caching environment with Oracle Database objects&#34;</a> for information on these objects.</p>
</li>
<li>
<p><code>FULL</code>: All cache tables are automatically refreshed, based on the cache group&#39;s autorefresh interval, by unloading all their rows and then reloading from the cached Oracle Database tables.</p>
</li>
</ul>
<p>Incremental autorefresh mode incurs some overhead to refresh the cache group for each committed update on the cached Oracle Database tables. There is no overhead when using full autorefresh mode.</p>
<p>When using incremental autorefresh mode, committed updates on cached Oracle Database tables are tracked in change log tables in the Oracle database. Under certain circumstances, it is possible for some change log records to be deleted from the change log table before they are automatically refreshed to the TimesTen cache tables. If this occurs, TimesTen initiates a full automatic refresh on the cache group. See <a href="manage.htm#CACBIHBH">&#34;Monitoring the cache administration user&#39;s tablespace&#34;</a> for information on how to configure an action to take when the tablespace that the change log tables reside in becomes full.</p>
<p>The change log table on the Oracle database does not have column-level resolution because of performance reasons. Thus the autorefresh operation updates all of the columns in a row. XLA reports that all of the columns in the row have changed even if the data did not actually change in each column.</p>
<p>The <a id="sthref333"></a>autorefresh interval determines how often autorefresh operations occur in minutes, seconds or milliseconds. Cache groups with the same autorefresh interval are refreshed within the same transaction. You can use the <a id="sthref334"></a><a id="sthref335"></a><a id="sthref336"></a><code>ttCacheAutorefresh</code> built-in procedure to initiate an immediate autorefresh operation. For more information, see <a class="olink TTREF736" href="../TTREF/proced.htm#TTREF736">&#34;ttCacheAutorefresh&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
<p>The <a id="sthref337"></a>autorefresh state can be set to <code>ON</code>, <code>PAUSED</code> or <code>OFF</code>. Autorefresh operations are scheduled by TimesTen when the cache group&#39;s autorefresh state is <code>ON</code>.</p>
<p>When the cache group&#39;s autorefresh state is <code>OFF</code>, committed updates on the cached Oracle Database tables are not tracked.</p>
<p>When the cache group&#39;s autorefresh state is <code>PAUSED</code>, committed updates on the cached Oracle Database tables are tracked in the Oracle database, but are not automatically refreshed to the TimesTen cache tables until the state is changed to <code>ON</code>.</p>
<p>The following restrictions apply when using the <code>AUTOREFRESH</code> cache group attribute:</p>
<ul>
<li>
<p>A <code>FLUSH CACHE GROUP</code> statement cannot be issued on the cache group.</p>
<p>See <a href="operations.htm#CHDBGBBG">&#34;Flushing a user managed cache group&#34;</a> for more information about the <code>FLUSH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>A <code>TRUNCATE TABLE</code> statement issued on a cached Oracle Database table is not automatically refreshed to the TimesTen cache table. Before issuing a <code>TRUNCATE TABLE</code> statement on a cached Oracle Database table, use an <code>ALTER CACHE GROUP</code> statement to change the autorefresh state of the cache group that contains the cache table to <code>PAUSED</code>.</p>
<p>See <a href="#CHDIJGDC">&#34;Altering a cache group to change the AUTOREFRESH mode, interval or state&#34;</a> for more information about the <code>ALTER CACHE GROUP</code> statement.</p>
<p>After issuing the <code>TRUNCATE TABLE</code> statement on the cached Oracle Database table, use a <code>REFRESH CACHE GROUP</code> statement to manually refresh the cache group.</p>
</li>
<li>
<p>A <code>LOAD CACHE GROUP</code> statement can only be issued if the cache tables are empty, unless the cache group is dynamic.</p>
<p>See <a href="operations.htm#CHDBGAAF">&#34;Loading and refreshing a cache group&#34;</a> for more information about the <code>LOAD CACHE GROUP</code> and <code>REFRESH CACHE GROUP</code> statements.</p>
<p>See <a href="#CHDBACDC">&#34;Dynamic cache groups&#34;</a> for more information about dynamic cache groups.</p>
</li>
<li>
<p>The autorefresh state must be <code>PAUSED</code> before you can issue a <code>LOAD CACHE GROUP</code> statement on the cache group, unless the cache group is dynamic, in which case the autorefresh state must be <code>PAUSED</code> or <code>ON</code>. The <code>LOAD CACHE GROUP</code> statement cannot contain a <code>WHERE</code> clause, unless the cache group is dynamic, in which case the <code>WHERE</code> clause must be followed by a <code>COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> clause.</p>
<p>See <a href="#CHDBIFFG">&#34;Using a WHERE clause&#34;</a> for more information about <code>WHERE</code> clauses in cache group definitions and operations.</p>
</li>
<li>
<p>The autorefresh state must be <code>PAUSED</code> before you can issue a <code>REFRESH CACHE GROUP</code> statement on the cache group. The <code>REFRESH CACHE GROUP</code> statement cannot contain a <code>WHERE</code> clause.</p>
</li>
<li>
<p>All tables and columns referenced in <code>WHERE</code> clauses when creating, loading or unloading the cache group must be fully qualified. For example:</p>
<p><code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code> and <code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code><code>.</code><code><span class="codeinlineitalic">column_name</span></code></p>
</li>
<li>
<p>To use the <code>AUTOREFRESH</code> cache group attribute in a user managed cache group, all of the cache tables must be specified with the <code>PROPAGATE</code> cache table attribute or all of the cache tables must be specified the <code>READONLY</code> cache table attribute.</p>
</li>
<li>
<p>You cannot specify the <code>AUTOREFRESH</code> cache group attribute in a user managed cache group that contains cache tables that explicitly use the <code>NOT PROPAGATE</code> cache table attribute.</p>
</li>
<li>
<p>The <code>AUTOREFRESH</code> cache table attribute cannot be used when caching Oracle Database materialized views in a user managed cache group.</p>
</li>
<li>
<p>LRU aging cannot be specified on the cache group, unless the cache group is dynamic where LRU aging is defined by default.</p>
<p>See <a href="#CHDCAJDA">&#34;LRU aging&#34;</a> for more information about LRU aging.</p>
</li>
</ul>
<p>If you create a unique index on a cache group with the <code>AUTOREFRESH</code> cache group attribute, the index is changed to a non-unique index to avoid a constraint violation. A constraint violation could occur with a unique index because conflicting updates could occur in the same statement execution on the Oracle Database table, while each row update is executed separately in TimesTen. If the unique index exists on the Oracle Database table that is being cached, then uniqueness is enforced on the Oracle Database table and does not need to be verified again in TimesTen.</p>
<p>In <a href="#CHDIAJEF">Example 4-9</a>, the <code>update_anywhere_customers</code> cache group uses the <code>AUTOREFRESH</code> cache group attribute.</p>
<a id="CHDIJGDC"></a>
<div id="TTCAC237" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Altering a cache group to change the AUTOREFRESH mode, interval or state</h4>
<p>After creating an autorefresh cache group, you can use an <code>ALTER CACHE GROUP</code> statement to change the cache group&#39;s autorefresh mode, interval or state. You cannot use <code>ALTER CACHE GROUP</code> to instantiate automatic refresh for a cache group that was originally created without autorefresh defined.</p>
<p>If you change a cache group&#39;s autorefresh state to <code>OFF</code> or drop a cache group that has an autorefresh operation in progress:</p>
<ul>
<li>
<p>The autorefresh operation stops if the setting of the <code>LockWait</code> connection attribute is greater than 0. The <code>ALTER CACHE GROUP</code> or <code>DROP CACHE GROUP</code> statement preempts the autorefresh operation.</p>
</li>
<li>
<p>The autorefresh operation continues if the <code>LockWait</code> connection attribute is set to 0. The <code>ALTER CACHE GROUP</code> or <code>DROP CACHE GROUP</code> statement is blocked until the autorefresh operation completes or the statement fails with a lock timeout error.</p>
</li>
</ul>
<div id="TTCAC238" class="example">
<p class="titleinexample"><a id="sthref338"></a>Example 4-11 Altering the autorefresh attributes of a cache group</p>
<p>The following statements change the autorefresh mode, interval and state of the <code>customer_orders</code> cache group:</p>
<pre>ALTER CACHE GROUP customer_orders SET AUTOREFRESH MODE FULL;
ALTER CACHE GROUP customer_orders SET AUTOREFRESH INTERVAL 30 SECONDS;
ALTER CACHE GROUP customer_orders SET AUTOREFRESH STATE ON;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDGGFAB"></a>
<div id="TTCAC239" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><a id="sthref339"></a>Manually creating Oracle Database objects for autorefresh cache groups</h4>
<p>If you manually created the Oracle Database objects used to enforce the predefined behaviors of an autorefresh cache group as described in <a href="prereqs.htm#BCFHCBJE">&#34;Manually create Oracle Database objects used to manage data caching&#34;</a>, you need to set the autorefresh state to <code>OFF</code> when creating the cache group.</p>
<p>Then you need to run the <code>ttIsql</code> utility&#39;s <code>cachesqlget</code> command with the <code>INCREMENTAL_AUTOREFRESH</code> option and the <code>INSTALL</code> flag as the cache manager user. This command generates a SQL*Plus script used to create a log table and a trigger in the Oracle database for each Oracle Database table that is cached in the autorefresh cache group. These Oracle Database objects track updates on the cached Oracle Database tables so that the updates can be automatically refreshed to the cache tables.</p>
<p>Next use SQL*Plus to run the script generated by the <code>ttIsql</code> utility&#39;s <code>cachesqlget</code> command as the <code>sys</code> user. Then use an <code>ALTER CACHE GROUP</code> statement to change the autorefresh state of the cache group to <code>PAUSED</code>.</p>
<div id="TTCAC240" class="example">
<p class="titleinexample"><a id="CHDDGBGF"></a>Example 4-12 Creating a read-only cache group when Oracle Database objects were manually created</p>
<p>The first statement creates a read-only cache group <code>customer_orders</code> with the autorefresh state set to <code>OFF</code>. The SQL*Plus script generated by the <a id="sthref340"></a><a id="sthref341"></a><code>ttIsql</code> utility&#39;s <code>cachesqlget</code> command is saved to the <code>/tmp/obj.sql</code> file. The last statement changes the autorefresh state of the cache group to <code>PAUSED</code>.</p>
<pre>CREATE READONLY CACHE GROUP customer_orders
AUTOREFRESH STATE OFF
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num)),
oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num),
  FOREIGN KEY(cust_num) REFERENCES oratt.customer(cust_num));

% ttIsql &#34;DSN=cachealone1;UID=cacheuser;PWD=timesten;OraclePWD=oracle&#34;
Command&gt; cachesqlget INCREMENTAL_AUTOREFRESH customer_orders INSTALL /tmp/obj.sql;
Command&gt; exit

% sqlplus sys as sysdba
Enter password: <span class="italic">password</span>
SQL&gt; @/tmp/obj
SQL&gt; exit

ALTER CACHE GROUP customer_orders SET AUTOREFRESH STATE PAUSED;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBIFFG"></a>
<div id="TTCAC241" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using a <a id="sthref342"></a>WHERE clause</h3>
<p>A cache table definition in a <code>CREATE CACHE GROUP</code> statement can contain a <code>WHERE</code> clause to restrict the rows to cache in the TimesTen database for particular cache group types.</p>
<p>You can also specify a <code>WHERE</code> clause in a <code>LOAD CACHE GROUP</code>, <code>UNLOAD CACHE GROUP</code>, <code>REFRESH CACHE GROUP</code> or <code>FLUSH CACHE GROUP</code> statement for particular cache group types. Some statements, such as <code>LOAD CACHE GROUP</code> and <code>REFRESH CACHE GROUP</code>, may result in concatenated <code>WHERE</code> clauses in which the <code>WHERE</code> clause for the cache table definition is evaluated before the <code>WHERE</code> clause in the <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement.</p>
<p>The following restrictions apply to <code>WHERE</code> clauses used in cache table definitions and cache group operations:</p>
<ul>
<li>
<p><code>WHERE</code> clauses can only be specified in the cache table definitions of a <code>CREATE CACHE GROUP</code> statement for read-only and user managed cache groups.</p>
</li>
<li>
<p>A <code>WHERE</code> clause can be specified in a <code>LOAD CACHE GROUP</code> statement except on an explicitly loaded autorefresh cache group.</p>
<p>See <a href="operations.htm#CHDBGAAF">&#34;Loading and refreshing a cache group&#34;</a> for more information about the <code>LOAD CACHE GROUP</code> statement.</p>
</li>
<li>
<p>A <code>WHERE</code> clause can be specified in a <code>REFRESH CACHE GROUP</code> statement except on an autorefresh cache group.</p>
<p>See <a href="operations.htm#CHDBGAAF">&#34;Loading and refreshing a cache group&#34;</a> for more information about the <code>REFRESH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>A <code>WHERE</code> clause can be specified in a <code>FLUSH CACHE GROUP</code> statement on a user managed cache group that allows committed updates on the TimesTen cache tables to be flushed to the cached Oracle Database tables.</p>
<p>See <a href="operations.htm#CHDBGBBG">&#34;Flushing a user managed cache group&#34;</a> for more information about the <code>FLUSH CACHE GROUP</code> statement.</p>
</li>
<li>
<p><code>WHERE</code> clauses in a <code>CREATE CACHE GROUP</code> statement cannot contain a subquery. Therefore, each <code>WHERE</code> clause cannot reference any table other than the one in its cache table definition. However, a <code>WHERE</code> clause in a <code>LOAD CACHE GROUP</code>, <code>UNLOAD CACHE GROUP</code>, <code>REFRESH CACHE GROUP</code> or <code>FLUSH CACHE GROUP</code> statement may contain a subquery.</p>
</li>
<li>
<p>A <code>WHERE</code> clause in a <code>LOAD CACHE GROUP</code>, <code>REFRESH CACHE GROUP</code> or <code>FLUSH CACHE GROUP</code> statement can reference only the root table of the cache group, unless the <code>WHERE</code> clause contains a subquery.</p>
</li>
<li>
<p><code>WHERE</code> clauses in the cache table definitions are only enforced when the cache group is manually loaded or refreshed, or the cache tables are dynamically loaded. If a cache table is updatable, you can insert or update a row such that the <code>WHERE</code> clause in the cache table definition for that row is not satisfied.</p>
</li>
<li>
<p>All tables and columns referenced in <code>WHERE</code> clauses when creating, loading, refreshing, unloading or flushing the cache group must be fully qualified. For example:</p>
<p><code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code> and <code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code><code>.</code><code><span class="codeinlineitalic">column_name</span></code></p>
</li>
</ul>
<p>In <a href="#CHDGCCED">Example 4-10</a>, both the <code>oratt.active_customer</code> and <code>oratt.orderdetails</code> tables contain a <code>WHERE</code> clause.</p>
<div id="TTCAC242" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref343"></a>
<h4 class="sect3">Proper placement of WHERE clause in a CREATE CACHE GROUP statement</h4>
<p>In a multiple-table cache group, a <code>WHERE</code> clause in a particular table definition should not reference any table in the cache group other than the table itself. For example, the following <code>CREATE CACHE GROUP</code> statements are valid:</p>
<pre>CREATE READONLY CACHE GROUP customer_orders
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num))
  WHERE (oratt.customer.cust_num &lt; 100),
oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num),
  FOREIGN KEY(cust_num) REFERENCES oratt.customer(cust_num));
</pre>
<pre>CREATE READONLY CACHE GROUP customer_orders
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num)),
oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num),
  FOREIGN KEY(cust_num) REFERENCES oratt.customer(cust_num));
  WHERE (oratt.orders.cust_num &lt; 100)
</pre>
<p>The following statement is not valid because the <code>WHERE</code> clause in the child table&#39;s definition references its parent table:</p>
<pre>CREATE READONLY CACHE GROUP customer_orders
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num)),
oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num),
  FOREIGN KEY(cust_num) REFERENCES oratt.customer(cust_num))
  WHERE (oratt.customer.cust_num &lt; 100);
</pre>
<p>Similarly, the following statement is not valid because the <code>WHERE</code> clause in the parent table&#39;s definition references its child table:</p>
<pre>CREATE READONLY CACHE GROUP customer_orders
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num))
  WHERE (oratt.orders.cust_num &lt; 100),
oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num),
  FOREIGN KEY(cust_num) REFERENCES oratt.customer(cust_num));
</pre></div>
<!-- class="sect3" -->
<div id="TTCAC243" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref344"></a>
<h4 class="sect3"><a id="sthref345"></a>Referencing Oracle Database PL/SQL functions in a WHERE clause</h4>
<p>A user-defined PL/SQL function in the Oracle database can be invoked indirectly in a <code>WHERE</code> clause within a <code>CREATE CACHE GROUP</code>, <code>LOAD CACHE GROUP</code>, or <code>REFRESH CACHE GROUP</code> (for dynamic cache groups only) statement. After creating the function, create a public synonym for the function. Then grant the <code>EXECUTE</code> privilege on the function to <code>PUBLIC</code>.</p>
<p>For example, in the Oracle database:</p>
<pre>CREATE OR REPLACE FUNCTION get_customer_name
(c_num oratt.customer.cust_num%TYPE) RETURN VARCHAR2 IS
c_name oratt.customer.name%TYPE;
BEGIN
  SELECT name INTO c_name FROM oratt.customer WHERE cust_num = c_num;
  RETURN c_name;
END get_customer_name;

CREATE PUBLIC SYNONYM retname FOR get_customer_name;
GRANT EXECUTE ON get_customer_name TO PUBLIC;
</pre>
<p>Then in the TimesTen database, for example, you can create a cache group with a <code>WHERE</code> clause that references the Oracle Database public synonym that was created for the function:</p>
<pre>CREATE READONLY CACHE GROUP top_customer
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num))
WHERE name = retname(100);
</pre>
<p>For cache group types that allow a <code>WHERE</code> clause on a <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement, you can invoke the function indirectly by referencing the public synonym that was created for the function. For example, you can use the following <code>LOAD CACHE GROUP</code> statement to load the AWT cache group <code>new_customers</code>:</p>
<pre>LOAD CACHE GROUP new_customers WHERE name = retname(101) COMMIT EVERY 0 ROWS;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBEEFE"></a>
<div id="TTCAC244" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref346"></a><a id="sthref347"></a>ON DELETE CASCADE cache table attribute</h3>
<p>The <code>ON DELETE CASCADE</code> cache table attribute can be specified for cache tables in any cache group type. <code>ON DELETE CASCADE</code> specifies that when rows containing referenced key values are deleted from a parent table, rows in child tables with dependent foreign keys are also deleted.</p>
<div id="TTCAC245" class="example">
<p class="titleinexample"><a id="CHDGJAGF"></a>Example 4-13 Using the ON DELETE CASCADE cache table attribute</p>
<p>The following statement uses the <code>ON DELETE CASCADE</code> cache table attribute on the child table&#39;s foreign key definition:</p>
<pre>CREATE READONLY CACHE GROUP customer_orders
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num)),
oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num),
  FOREIGN KEY(cust_num) REFERENCES oratt.customer(cust_num) ON DELETE CASCADE);
</pre></div>
<!-- class="example" -->
<p>All paths from a parent table to a child table must be either &#34;delete&#34; paths or &#34;do not delete&#34; paths. There cannot be some &#34;delete&#34; paths and some &#34;do not delete&#34; paths from a parent table to a child table. Specify the <code>ON DELETE CASCADE</code> cache table attribute for child tables on a &#34;delete&#34; path.</p>
<p>The following restrictions apply when using the <code>ON DELETE CASCADE</code> cache table attribute:</p>
<ul>
<li>
<p>For AWT and SWT cache groups, and for TimesTen cache tables in user managed cache groups that use the <code>PROPAGATE</code> cache table attribute, foreign keys in cache tables that use the <code>ON DELETE CASCADE</code> cache table attribute must be a proper subset of the foreign keys in the cached Oracle Database tables that use the <code>ON DELETE CASCADE</code> attribute. <code>ON DELETE CASCADE</code> actions on the cached Oracle Database tables are applied to the TimesTen cache tables as individual deletes. <code>ON DELETE CASCADE</code> actions on the cache tables are applied to the cached Oracle Database tables as a cascaded operation.</p>
</li>
<li>
<p>Matching of foreign keys between the TimesTen cache tables and the cached Oracle Database tables is enforced only when the cache group is being created. A cascade delete operation may not work if the foreign keys on the cached Oracle Database tables are altered after the cache group is created.</p>
</li>
</ul>
<p>See the <a class="olink TTSQL290" href="../TTSQL/state.htm#TTSQL290"><code>CREATE CACHE GROUP</code></a> statement in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for more information about the <code>ON DELETE CASCADE</code> cache table attribute.</p>
</div>
<!-- class="sect2" -->
<a id="CHDCGJIC"></a>
<div id="TTCAC246" class="sect2">
<h3 class="sect2"><a id="sthref348"></a><a id="sthref349"></a>UNIQUE HASH ON cache table attribute</h3>
<p>The <code>UNIQUE HASH ON</code> cache table attribute can be specified for cache tables in any cache group type. <code>UNIQUE HASH ON</code> specifies that a hash index rather than a range index is created on the primary key columns of the cache table. The columns specified in the hash index must be identical to the columns in the primary key. The <code>UNIQUE HASH ON</code> cache table attribute is also used to specify the size of the hash index.</p>
<div id="TTCAC247" class="example">
<p class="titleinexample"><a id="CHDBHHBD"></a>Example 4-14 Using the UNIQUE HASH ON cache table attribute</p>
<p>The following statement uses the <code>UNIQUE HASH ON</code> cache table attribute on the cache table&#39;s definition.</p>
<pre>CREATE ASYNCHRONOUS WRITETHROUGH CACHE GROUP new_customers
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num))
  UNIQUE HASH ON (cust_num) PAGES = 100;
</pre></div>
<!-- class="example" -->
<p>See the <a class="olink TTSQL290" href="../TTSQL/state.htm#TTSQL290"><code>CREATE CACHE GROUP</code></a> statement in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for more information about the <code>UNIQUE HASH ON</code> cache table attribute.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDGCGFD"></a>
<div id="TTCAC248" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Caching <a id="sthref350"></a>Oracle Database synonyms</h2>
<p>You can cache a private synonym in an AWT, SWT or user managed cache group that does not use the <code>AUTOREFRESH</code> cache group attribute. The private synonym can reference a public or private synonym, but it must eventually reference a table because it is the table that is actually being cached.</p>
<p>The table that is directly or indirectly referenced by the cached synonym can be owned by a user other than the Oracle Database user with the same name as the owner of the cache group that caches the synonym. The table must reside in the same Oracle database as the synonym. The cached synonym itself must be owned by the Oracle Database user with the same name as the owner of the cache group that caches the synonym.</p>
</div>
<!-- class="sect1" -->
<a id="CBBCHAAJ"></a>
<div id="TTCAC415" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Caching Oracle Database LOB data<a id="sthref351"></a><a id="sthref352"></a><a id="sthref353"></a><a id="sthref354"></a></h2>
<p>You can cache Oracle Database large object (LOB) data in TimesTen cache groups. TimesTen caches the data as follows:</p>
<ul>
<li>
<p>Oracle Database <code>CLOB</code> data is cached as TimesTen <code>CLOB</code> data.</p>
</li>
<li>
<p>Oracle Database <code>BLOB</code> data is cached as TimesTen <code>BLOB</code> data.</p>
</li>
<li>
<p>Oracle Database <code>NCLOB</code> data is cached as TimesTen <code>NCLOB</code> data.</p>
</li>
</ul>
<div id="TTCAC417" class="example">
<p class="titleinexample"><a id="sthref355"></a>Example 4-15 Caching Oracle Database LOB data</p>
<p>Create a table in the Oracle database that has LOB fields.</p>
<pre>CREATE TABLE t (
  i INT NOT NULL PRIMARY KEY
  , c CLOB
  , b BLOB
  , nc NCLOB);
</pre>
<p>Insert values into the Oracle Database table. The values are implicitly converted to LOB data types.</p>
<pre>INSERT INTO t VALUES (1
  , RPAD(&#39;abcdefg8&#39;, 2048, &#39;abcdefg8&#39;)
  , HEXTORAW(RPAD(&#39;123456789ABCDEF8&#39;, 4000, &#39;123456789ABCDEF8&#39;))
  , RPAD(&#39;abcdefg8&#39;, 2048, &#39;abcdefg8&#39;)
);

1 row inserted.
</pre>
<p>Create a dynamic AWT cache group and start the replication agent.</p>
<pre>CREATE DYNAMIC ASYNCHRONOUS WRITETHROUGH CACHE GROUP cg1 
  FROM t
 (i INT NOT NULL PRIMARY KEY
  , c CLOB
  , b BLOB
  , nc NCLOB);

CALL ttrepstart;
</pre>
<p>Load the data dynamically into the TimesTen cache group.</p>
<pre>SELECT * FROM t WHERE i = 1;

I:    1
C:    abcdefg8abcdefg8abcdefg8...
B:    123456789ABCDEF8123456789...
NC:   abcdefg8abcdefg8abcdefg8...

1 row found.
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="TTCAC416"></a>Restrictions <a id="sthref356"></a>on caching Oracle Database LOB data</p>
<p>These restrictions apply to caching Oracle Database LOB data in TimesTen cache groups:</p>
<ul>
<li>
<p>Column size is enforced when a cache group is created. <code>VARBINARY</code>, <code>VARCHAR2</code> and <code>NVARCHAR2</code> data types have a size limit of 4 megabytes. Values that exceed the user-defined column size are truncated at run time without notification.</p>
</li>
<li>
<p>Empty values in fields with <code>CLOB</code> and <code>BLOB</code> data types are initialized but not populated with data. Empty <code>CLOB</code> and <code>BLOB</code> fields are treated as follows:</p>
<ul>
<li>
<p>Empty <code>LOB</code> fields in the Oracle database are returned as <code>NULL</code> values.</p>
</li>
<li>
<p>Empty <code>BLOB</code> fields are loaded into the TimesTen cache as <code>NULL</code> values.</p>
</li>
<li>
<p>Empty <code>VARCHAR2</code> and <code>VARBINARY</code> fields in the TimesTen cache are propagated as <code>NULL</code> values.</p>
</li>
</ul>
</li>
</ul>
<p>In addition, cache groups that are configured for autorefresh operations have these restrictions on caching LOB data:</p>
<ul>
<li>
<p>When LOB data is updated in the Oracle database by OCI functions or the <code>DBMS_LOB</code> PL/SQL package, the data is not automatically refreshed in the TimesTen cache group. This occurs because TimesTen caching depends on Oracle Database triggers, and Oracle Database triggers are not executed when these types of updates occur. TimesTen does not notify the user that updates have occurred without being refreshed in TimesTen. When the LOB is updated through a SQL statement, a trigger is fired and autorefresh brings in the change.</p>
</li>
<li>
<p>Autorefresh operations update a complete row in the TimesTen cache. Thus, the cached LOB data may appear to be updated in TimesTen when no change has occurred in the LOB data in the Oracle database.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDGICCB"></a>
<div id="TTCAC249" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Implementing <a id="sthref357"></a>aging in a cache group</h2>
<p>You can define an aging policy for a cache group that specifies the aging type, the aging attributes, and the aging state. TimesTen supports two aging types, least recently used (LRU) aging and time-based aging.</p>
<p>LRU aging deletes the least recently used or referenced data based on a specified database usage range. Time-based aging deletes data based on a specified data lifetime and frequency of the aging process. You can use both LRU and time-based aging in the same TimesTen database, but you can define only one aging policy for a particular cache group.</p>
<p>An aging policy is specified in the cache table definition of the root table in a <code>CREATE CACHE GROUP</code> statement and applies to all cache tables in the cache group because aging is performed at the cache instance level. When rows are deleted from the cache tables by aging out, the rows in the cached Oracle Database table are not deleted.</p>
<p>You can add an aging policy to a cache group by using an <code>ALTER TABLE</code> statement on the root table. You can change the aging policy of a cache group by using <code>ALTER TABLE</code> statements on the root table to drop the existing aging policy and then add a new aging policy.</p>
<p>This section describes cache group definitions that contain an aging policy. The topics include:</p>
<ul>
<li>
<p><a href="#CHDCAJDA">LRU aging</a></p>
</li>
<li>
<p><a href="#CHDGBFGF">Time-based aging</a></p>
</li>
<li>
<p><a href="#CHDBJDDH">Manually scheduling an aging process</a></p>
</li>
<li>
<p><a href="#CHDDICEI">Configuring a sliding window</a></p>
</li>
</ul>
<a id="CHDCAJDA"></a>
<div id="TTCAC250" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref358"></a><a id="sthref359"></a>LRU aging</h3>
<p>LRU aging enables you to maintain the amount of memory used in a TimesTen database within a specified threshold by deleting the least recently used data. LRU aging can be defined for all cache group types except explicitly loaded autorefresh cache groups. LRU aging is defined by default on dynamic cache groups.</p>
<p>Define an LRU aging policy for a cache group by using the <code>AGING LRU</code> clause in the cache table definition of the <code>CREATE CACHE GROUP</code> statement. Aging occurs automatically if the aging state is set to its default of <code>ON</code>.</p>
<div id="TTCAC251" class="example">
<p class="titleinexample"><a id="CHDJAAAI"></a>Example 4-16 Defining an LRU aging policy on a cache group</p>
<p>The following statement defines an LRU aging policy on the AWT cache group <code>new_customers</code>:</p>
<pre>CREATE ASYNCHRONOUS WRITETHROUGH CACHE GROUP new_customers
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num))
AGING LRU ON;
</pre></div>
<!-- class="example" -->
<p>Use the <a id="sthref360"></a><a id="sthref361"></a><code>ttAgingLRUConfig</code> built-in procedure to set the LRU aging attributes as a user with the <code>ADMIN</code> privilege. The attribute settings apply to all tables in the TimesTen database that have an LRU aging policy defined and an aging state of <code>ON</code>.</p>
<p>The following are the LRU aging attributes:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">LowUsageThreshold</span></code>: The TimesTen database&#39;s space usage (the ratio of the permanent region&#39;s in-use size over the region&#39;s allocated size) at or below which LRU aging is deactivated. The default low usage threshold is .8 (80 percent).</p>
</li>
<li>
<p><code><span class="codeinlineitalic">HighUsageThreshold</span></code>: The TimesTen database&#39;s space usage above which LRU aging is activated. The default high usage threshold is .9 (90 percent).</p>
</li>
<li>
<p><code><span class="codeinlineitalic">AgingCycle</span></code>: The frequency in which aging occurs, in minutes. The default aging cycle is 1 minute.</p>
</li>
</ul>
<div id="TTCAC252" class="example">
<p class="titleinexample"><a id="sthref362"></a>Example 4-17 Setting the LRU aging attributes</p>
<p>The following built-in procedure call specifies that the aging process checks every 5 minutes to see if the TimesTen database&#39;s permanent region space usage is above 95 percent. If it is, the least recently used data is automatically aged out or deleted until the space usage is at or below 75 percent.</p>
<pre>Command&gt; CALL ttAgingLRUConfig(.75, .95, 5);
</pre></div>
<!-- class="example" -->
<p>If you set a new value for <code><span class="codeinlineitalic">AgingCycle</span></code> after an LRU aging policy has been defined on a cache group, the next time aging occurs is based on the current system time and the new aging cycle. For example, if the original aging cycle was 15 minutes and LRU aging occurred 10 minutes ago, aging is expected to occur again in 5 minutes. However, if you change the aging cycle to 30 minutes, aging next occurs 30 minutes from the time you call the <code>ttAgingLRUConfig</code> built-in procedure with the new aging cycle setting.</p>
<p>If a row has been accessed or referenced since the last aging cycle, it is not eligible for LRU aging in the current aging cycle. A row is considered to be accessed or referenced if at least one of the following is true:</p>
<ul>
<li>
<p>The row is used to build the result set of a <code>SELECT</code> or an <code>INSERT ... SELECT</code> statement.</p>
</li>
<li>
<p>The row has been marked to be updated or deleted in a pending transaction.</p>
</li>
</ul>
<p>In a multiple-table cache group, if a row in a child table has been accessed or referenced since the last aging cycle, then neither the related row in the parent table nor the row in the child table is eligible for LRU aging in the current aging cycle.</p>
<p>The <code>ALTER TABLE</code> statement can be used to perform the following tasks associated with changing or defining an LRU aging policy on a cache group:</p>
<ul>
<li>
<p>Change the aging state of a cache group by specifying the root table and using the <code>SET AGING</code> clause.</p>
</li>
<li>
<p>Add an LRU aging policy to a cache group that has no aging policy defined by specifying the root table and using the <code>ADD AGING LRU</code> clause.</p>
</li>
<li>
<p>Drop the LRU aging policy on a cache group by specifying the root table and using the <code>DROP AGING</code> clause.</p>
</li>
</ul>
<p>To change the aging policy of a cache group from LRU to time-based, use an <code>ALTER TABLE</code> statement on the root table with the <code>DROP AGING</code> clause to drop the LRU aging policy. Then use an <code>ALTER TABLE</code> statement on the root table with the <code>ADD AGING USE</code> clause to add a time-based aging policy.</p>
<p>You must stop the cache agent before you add, alter or drop an aging policy on an autorefresh cache group.</p>
</div>
<!-- class="sect2" -->
<a id="CHDGBFGF"></a>
<div id="TTCAC253" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref363"></a><a id="sthref364"></a>Time-based aging</h3>
<p>Time-based aging deletes data from a cache group based on the aging policy&#39;s specified data lifetime and frequency. Time-based aging can be defined for all cache group types.</p>
<p>Define a time-based aging policy for a cache group by using the <code>AGING USE</code> clause in the cache table definition of the <code>CREATE CACHE GROUP</code> statement. Aging occurs automatically if the aging state is set to its default of <code>ON</code>.</p>
<p>The definitions of the Oracle Database tables that are to be cached in the AWT cache group defined in <a href="#CHDBFJAA">Example 4-19</a> are defined in <a href="#CHDGAGEB">Example 4-18</a>. The Oracle Database tables are owned by the schema user <code>oratt</code>. The <code>oratt</code> user must be granted the <code>CREATE SESSION</code> and <code>RESOURCE</code> privileges before it can create tables.</p>
<div id="TTCAC427" class="example">
<p class="titleinexample"><a id="CHDGAGEB"></a>Example 4-18 Oracle Database table definitions</p>
<pre>CREATE TABLE orders
(ord_num      NUMBER(10) NOT NULL PRIMARY KEY,
 cust_num     NUMBER(6) NOT NULL,
 when_placed  DATE NOT NULL,
 when_shipped DATE NOT NULL);

CREATE TABLE order_item
(orditem_id NUMBER(12) NOT NULL PRIMARY KEY,
 ord_num    NUMBER(10),
 prod_num   VARCHAR2(6),
 quantity   NUMBER(3));
</pre></div>
<!-- class="example" -->
<p>The companion Oracle Database user of the TimesTen cache manager user must be granted the <code>SELECT</code> privilege on the <code>oratt.orders</code> and <code>oratt.order_item</code> tables in order for the cache manager user to create an AWT cache group that caches these tables. The cache administration user must be granted the <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> Oracle Database privileges for the <code>oratt.orders</code> and <code>oratt.order_item</code> tables for asynchronous writethrough operations to be applied on the Oracle Database.</p>
<div id="TTCAC254" class="example">
<p class="titleinexample"><a id="CHDBFJAA"></a>Example 4-19 Defining a time-based aging policy on a cache group</p>
<p>The following statement defines a time-based aging policy on the AWT cache group <code>ordered_items</code>:</p>
<pre>CREATE ASYNCHRONOUS WRITETHROUGH CACHE GROUP ordered_items
FROM oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num))
AGING USE when_placed LIFETIME 45 DAYS CYCLE 60 MINUTES ON,
oratt.order_item
 (orditem_id NUMBER(12) NOT NULL,
  ord_num    NUMBER(10),
  prod_num   VARCHAR2(6),
  quantity   NUMBER(3),
  PRIMARY KEY(orditem_id),
  FOREIGN KEY(ord_num) REFERENCES oratt.orders(ord_num));
</pre></div>
<!-- class="example" -->
<p>Cache instances that are greater than 45 days old based on the difference between the current system timestamp and the timestamp in the <code>when_placed</code> column of the <code>oratt.orders</code> table are candidates for aging. The aging process checks every 60 minutes to see if there are cache instances that can be automatically aged out or deleted from the cache tables.</p>
<p>The <code>AGING USE</code> clause requires the name of a non-nullable <code>TIMESTAMP</code> or <code>DATE</code> column used for time-based aging. We refer to this column as the timestamp column.</p>
<p>For each row, the value in the timestamp column stores the date and time when the row was most recently inserted or updated. The values in the timestamp column is maintained by your application. If the value of this column is unknown for particular rows and you do not want those rows to be aged out of the table, define the timestamp column with a large default value.</p>
<p>You can create an index on the timestamp column to optimize performance of the aging process.</p>
<p>You cannot add a column to an existing table and then use that column as the timestamp column because added columns cannot be defined as non-nullable. You cannot drop the timestamp column from a table that has a time-based aging policy defined.</p>
<p>Specify the lifetime in days, hours, minutes or seconds after the <code>LIFETIME</code> keyword in the <code>AGING USE</code> clause.</p>
<p>The value in the timestamp column is subtracted from the current system timestamp. The result is then truncated to the specified lifetime unit (day, hour, minute, second) and compared with the specified lifetime value. If the result is greater than the lifetime value, the row is a candidate for aging.</p>
<p>After the <code>CYCLE</code> keyword, specify the frequency in which aging occurs in days, hours, minutes or seconds. The default aging cycle is 5 minutes. If you specify an aging cycle of 0, aging is continuous.</p>
<p>The <code>ALTER TABLE</code> statement can be used to perform the following tasks associated with changing or defining a time-based aging policy on a cache group:</p>
<ul>
<li>
<p>Change the aging state of a cache group by specifying the root table and using the <code>SET AGING</code> clause.</p>
</li>
<li>
<p>Change the lifetime by specifying the root table and using the <code>SET AGING LIFETIME</code> clause.</p>
</li>
<li>
<p>Change the aging cycle by specifying the root table and using the <code>SET AGING CYCLE</code> clause.</p>
</li>
<li>
<p>Add a time-based aging policy to a cache group that has no aging policy defined by specifying the root table and using the <code>ADD AGING USE</code> clause.</p>
</li>
<li>
<p>Drop the time-based aging policy on a cache group by specifying the root table and using the <code>DROP AGING</code> clause.</p>
</li>
</ul>
<p>To change the aging policy of a cache group from time-based to LRU, use an <code>ALTER TABLE</code> statement on the root table with the <code>DROP AGING</code> clause to drop the time-based aging policy. Then use an <code>ALTER TABLE</code> statement on the root table with the <code>ADD AGING LRU</code> clause to add an LRU aging policy.</p>
<p>You must stop the cache agent before you add, alter or drop an aging policy on an autorefresh cache group.</p>
</div>
<!-- class="sect2" -->
<a id="CHDBJDDH"></a>
<div id="TTCAC255" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Manually scheduling an aging process</h3>
<p>Use the <a id="sthref365"></a><a id="sthref366"></a><code>ttAgingScheduleNow</code> built-in procedure to manually start a one-time aging process on a specified table or on all tables that have an aging policy defined. The aging process starts as soon as you call the built-in procedure unless there is already an aging process in progress. Otherwise the manually started aging process begins when the aging process that is in progress has completed. After the manually started aging process has completed, the start of the table&#39;s next aging cycle is set to the time when <code>ttAgingScheduleNow</code> was called if the table&#39;s aging state is <code>ON</code>.</p>
<div id="TTCAC256" class="example">
<p class="titleinexample"><a id="sthref367"></a>Example 4-20 Starting a one-time aging process</p>
<p>The following built-in procedure call starts a one-time aging process on the <code>oratt.orders</code> table based on the time <code>ttAgingScheduleNow</code> is called:</p>
<pre>Command&gt; CALL ttAgingScheduleNow(&#39;oratt.orders&#39;);
</pre></div>
<!-- class="example" -->
<p>Rows in the <code>oratt.orders</code> root table that are candidates for aging are deleted as well as related rows in the <code>oratt.order_item</code> child table.</p>
<p>When you call the <code>ttAgingScheduleNow</code> built-in procedure, the aging process starts regardless of whether the table&#39;s aging state is <code>ON</code> or <code>OFF</code>. If you want to start an aging process on a particular cache group, specify the name of the cache group&#39;s root table when you call the built-in procedure. If the <code>ttAgingScheduleNow</code> built-in procedure is called with no parameters, it starts an aging process and then resets the start of the next aging cycle on all tables in the TimesTen database that have an aging policy defined.</p>
<p>Calling the <code>ttAgingScheduleNow</code> built-in procedure does not change the aging state of any table. If a table&#39;s aging state is <code>OFF</code> when you call the built-in procedure, the aging process starts, but it is not scheduled to run again after the process has completed. To continue aging a table whose aging state is <code>OFF</code>, you must call <code>ttAgingScheduleNow</code> again or change the table&#39;s aging state to <code>ON</code>.</p>
<p>To manually control aging on a cache group, disable aging on the root table by using an <code>ALTER TABLE</code> statement with the <code>SET AGING OFF</code> clause. Then call <code>ttAgingScheduleNow</code> to start an aging process on the cache group.</p>
</div>
<!-- class="sect2" -->
<a id="CHDDICEI"></a>
<div id="TTCAC257" class="sect2">
<h3 class="sect2">Configuring a <a id="sthref368"></a>sliding window</h3>
<p>You can use time-based aging to implement a sliding window for a cache group. In a sliding window configuration, new rows are inserted into and old rows are deleted from the cache tables on a regular schedule so that the tables contain only the data that satisfies a specific time interval.</p>
<p>You can configure a sliding window for a cache group by using incremental autorefresh mode and defining a time-based aging policy. The autorefresh operation checks the timestamp of the rows in the cached Oracle Database tables to determine whether new data should be refreshed into the TimesTen cache tables. The system time and the time zone must be identical on the Oracle Database and TimesTen systems.</p>
<p>If the cache group does not use incremental autorefresh mode, you can configure a sliding window by using a <code>LOAD CACHE GROUP</code>, <code>REFRESH CACHE GROUP</code>, or <code>INSERT</code> statement, or a dynamic load operation to bring new data into the cache tables.</p>
<div id="TTCAC258" class="example">
<p class="titleinexample"><a id="CHDCCAAI"></a>Example 4-21 Defining a cache group with sliding window properties</p>
<p>The following statement configures a sliding window on the read-only cache group <code>recent_shipped_orders</code>:</p>
<pre>CREATE READONLY CACHE GROUP recent_shipped_orders
AUTOREFRESH MODE INCREMENTAL INTERVAL 1440 MINUTES STATE ON
FROM oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num))
AGING USE when_shipped LIFETIME 30 DAYS CYCLE 24 HOURS ON;
</pre></div>
<!-- class="example" -->
<p>New data in the <code>oratt.orders</code> cached Oracle Database table are automatically refreshed into the <code>oratt.orders</code> TimesTen cache table every 1440 minutes. Cache instances that are greater than 30 days old based on the difference between the current system timestamp and the timestamp in the <code>when_shipped</code> column are candidates for aging. The aging process checks every 24 hours to see if there are cache instances that can be aged out of the cache tables. Therefore, this cache group stores orders that have been shipped within the last 30 days.</p>
<p>The autorefresh interval and the lifetime used for aging determine the duration that particular rows remain in the cache tables. It is possible for data to be aged out of the cache tables before it has been in the cache tables for its lifetime. For example, for a read-only cache group if the autorefresh interval is 3 days and the lifetime is 30 days, data that is already 3 days old when it is refreshed into the cache tables is deleted after 27 days because aging is based on the timestamp stored in the rows of the cached Oracle Database tables that gets loaded into the TimesTen cache tables, not when the data is refreshed into the cache tables.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDBACDC"></a>
<div id="TTCAC259" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Dynamic cache groups<a id="sthref369"></a></h2>
<p>The data in a dynamic cache group is loaded on demand. For example, a call center application may not want to preload all of its customers&#39; information into TimesTen as it may be very large. Instead it can use a dynamic cache group so that a specific customer&#39;s information is loaded only when needed such as when the customer calls or logs onto the system.</p>
<p>Any system managed cache group type (read-only, AWT, SWT) can be defined as a dynamic cache group. A user managed cache group can be defined as a dynamic cache group unless it uses both the <code>AUTOREFRESH</code> cache group attribute and the <code>PROPAGATE</code> cache table attribute.</p>
<p>Use the <code>CREATE DYNAMIC CACHE GROUP</code> statement to create a dynamic cache group.</p>
<div id="TTCAC260" class="example">
<p class="titleinexample"><a id="CHDHGJCF"></a>Example 4-22 <a id="sthref370"></a>Dynamic read-only cache group</p>
<p>This following statement creates a dynamic read-only cache group <code>online_customers</code> that caches the <code>oratt.customer</code> table:</p>
<pre>CREATE DYNAMIC READONLY CACHE GROUP online_customers
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num));
</pre></div>
<!-- class="example" -->
<p>With an explicitly loaded cache group, data is initially loaded into the cache tables from the cached Oracle Database tables using a <code>LOAD CACHE GROUP</code> statement. With a dynamic cache group, data may also be loaded into the cache tables using a <code>LOAD CACHE GROUP</code> statement. However, with a dynamic cache group, data is typically loaded automatically when its cache tables are referenced by a <code>SELECT</code>, <code>INSERT</code>, or <code>UPDATE</code> statement and the data is not found in the tables resulting in a cache miss. See <a href="operations.htm#CJAGAAHE">&#34;Dynamically loading a cache instance&#34;</a> for more information.</p>
<p>With both explicitly loaded and dynamic cache groups, a <code>LOAD CACHE GROUP</code> statement loads into their cache tables qualified data that exists in the cached Oracle Database tables but not in the TimesTen cache tables. However, if a row exists in a cache table but a newer version exists in the cached Oracle Database table, a <code>LOAD CACHE GROUP</code> statement does not load that row into the cache table even if it satisfies the predicate of the statement.</p>
<p>By contrast, a <code>REFRESH CACHE GROUP</code> statement reloads qualifying rows that exists in the cache tables, effectively refreshing the content of the cache. For an explicitly loaded cache group, the rows that are refreshed are all the rows that satisfy the predicate of the <code>REFRESH CACHE GROUP</code> statement. However, for a dynamic cache group, the rows that are refreshed are the ones that satisfy the predicate and already exist in the cache tables. In other words, rows that end up being refreshed are the ones that have been updated or deleted in the cached Oracle Database table, but not the ones that have been inserted. Therefore, a refresh operation processes only the rows that are already in the cache tables. No new rows are loaded into the cache tables of a dynamic cache group as a result of a refresh.</p>
<p>The data in the cache instance of a dynamic read-only cache group is consistent with the data in the corresponding rows of the Oracle Database tables. At any instant in time, the data in a cache instance of an explicitly loaded cache group is consistent with the data in the corresponding rows of the Oracle Database tables, taking into consideration the state and the interval settings for autorefresh.</p>
<p>The data in a dynamic cache group is subject to aging as LRU aging is defined by default. You can use the <code>ttAgingLRUConfig</code> built-in procedure to override the default or current LRU aging attribute settings for the aging cycle and TimesTen database space usage thresholds. Alternatively, you can define time-based aging on a dynamic cache group to override LRU aging. Rows in a dynamic AWT cache group must be propagated to the Oracle database before they become candidates for aging.</p>
</div>
<!-- class="sect1" -->
<a id="CHDCJADE"></a>
<div id="TTCAC261" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Global cache groups<a id="sthref371"></a></h2>
<p>An Oracle Database table cannot be cached in more than one cache group within the same TimesTen database. However, the table can be cached in separate cache groups in different TimesTen databases. If the table is cached in separate AWT cache groups and the same cache instance is updated simultaneously on multiple TimesTen databases, there is no guarantee as to the order in which the updates are propagated to the cached Oracle Database table. Also, the contents of the updated cache table are inconsistent between the TimesTen databases.</p>
<p>A TimesTen cache grid prevents this problem by providing users with Oracle databases a means to horizontally scale out global cache groups across multiple systems with read/write data consistency across the TimesTen databases. A cache grid is a set of TimesTen databases that collectively manage the application data cached in global cache groups.</p>
<p><a id="sthref372"></a><a id="sthref373"></a>Tables that are cached in separate cache groups within different TimesTen databases must be cached in global cache groups in order for the cache grid to manage consistency of the cache instances across the grid members when updates are committed on the cache tables of the global cache group. In a cache grid, only one copy of a cache instance is allowed to be present in the entire grid at any moment in time. Each cache instance in a global cache group is owned by the grid member where it is currently located. Only the cache grid member that owns the cache instance has the right to update the data. The TimesTen cache grid tracks the ownership for each cache instance, so that it can quickly locate the grid member where each cache instance is currently located and ensure that the same cache instance is not concurrently present in multiple grid members. However, another grid member can obtain ownership of the cache instance from the current owner.</p>
<p>Global cache groups can be defined as dynamic AWT cache groups or as explicitly loaded AWT cache groups.</p>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDFDHDJ">Dynamic global cache groups</a></p>
</li>
<li>
<p><a href="#CHDJIBGC">Explicitly loaded global cache groups</a></p>
</li>
<li>
<p><a href="#CHDFEFGC">Start the replication agent</a></p>
</li>
<li>
<p><a href="#CHDDHGBA">Attach a TimesTen database to a cache grid</a></p>
</li>
</ul>
<a id="CHDFDHDJ"></a>
<div id="TTCAC429" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Dynamic global cache groups<a id="sthref374"></a></h3>
<p>The following statement is the definition of the Oracle Database table that are to be cached in the dynamic AWT global cache group that is created in <a href="#CHDDJGAC">Example 4-23</a>. The Oracle Database table is owned by the schema user <code>oratt</code>. The <code>oratt</code> user must be granted the <code>CREATE SESSION</code> and <code>RESOURCE</code> privileges before it can create tables.</p>
<pre>CREATE TABLE subscriber
(subscriberid       NUMBER(10) NOT NULL PRIMARY KEY,
 name               VARCHAR2(100) NOT NULL,
 minutes_balance    NUMBER(5) NOT NULL,
 last_call_duration NUMBER(4) NOT NULL);
</pre>
<p>The Oracle Database user with the same name as the TimesTen cache manager user must be granted the <code>SELECT</code> privilege on the <code>oratt.subscriber</code> table so that the cache manager user can create an AWT cache group that caches this table. The cache administration user must be granted the <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> Oracle Database privileges for the <code>oratt.subscriber</code> table for asynchronous writethrough operations to be applied to the Oracle Database.</p>
<p>Use the <code>CREATE DYNAMIC ASYNCHRONOUS WRITETHROUGH GLOBAL CACHE GROUP</code> statement to create a dynamic AWT global cache group.</p>
<div id="TTCAC262" class="example">
<p class="titleinexample"><a id="CHDDJGAC"></a>Example 4-23 <a id="sthref375"></a>Dynamic global cache group</p>
<p>The following statement creates a dynamic AWT global cache group <code>subscriber_accounts</code> that caches the <code>oratt.subscriber</code> table:</p>
<pre>CREATE DYNAMIC ASYNCHRONOUS WRITETHROUGH GLOBAL CACHE GROUP subscriber_accounts
FROM oratt.subscriber
 (subscriberid       NUMBER(10) NOT NULL PRIMARY KEY,
  name               VARCHAR2(100) NOT NULL,
  minutes_balance    NUMBER(5) NOT NULL,
  last_call_duration NUMBER(4) NOT NULL);
</pre></div>
<!-- class="example" -->
<p>When a subscriber to a prepaid telephone account makes a call, the cache instance that contains the subscriber&#39;s account balance is loaded into the <code>oratt.subscriber</code> cache table of the <code>subscriber_accounts</code> global cache group within one of the cache grid members. The query for the account balance information first searches the grid member on which the query is issued. If the cache tables on the local grid member do not contain data that satisfies a query, then the cache instance is transferred from other grid members to the local grid member in a <a id="sthref376"></a><span class="italic">grid data transfer</span> operation. If the grid does not contain the cache instance that satisfies the query, data is loaded from the Oracle Database tables. When data is loaded into the local grid member from the Oracle Database tables, this operation is called a <span class="italic"><a id="sthref377"></a><a id="sthref378"></a>dynamic load</span>. The grid member that the cache instance is loaded into becomes the owner of the cache instance. Other grid members cannot access the cache instance until the owner has updated the balance of minutes and the duration of the last call, and the committed update has been propagated to the cached Oracle Database table.</p>
<p>To ensure consistency among the grid members, an Oracle Database table that is cached in a global cache group in a TimesTen database should not also be cached in a local cache group in another TimesTen database within the same cache grid. In addition, the Oracle Database table should not be cached in a global cache group in another TimesTen database within a different cache grid.</p>
<p>For cache tables in a dynamic global cache group, a particular cache instance can be read or updated by only one grid member at a time. This grid member is referred to as the <a id="sthref379"></a><a id="sthref380"></a><a id="sthref381"></a><a id="sthref382"></a><a id="sthref383"></a>owner of the cache instance. When the owner no longer has a pending transaction on any row of the cache instance, another grid member can take ownership by reading or updating that instance. The owner relinquishes ownership of a cache instance when the instance has been deleted from that grid member as a result of:</p>
<ul>
<li>
<p>Aging</p>
</li>
<li>
<p>A <code>DELETE</code> statement issued on the cache table</p>
</li>
<li>
<p>An <code>UNLOAD CACHE GROUP</code> statement issued on the cache group</p>
</li>
<li>
<p>A request from another grid member to take ownership of that instance</p>
</li>
</ul>
<p>The owner relinquishes ownership of all its cache instances if that grid member detaches from its cache grid.</p>
<p>Read data consistency between nodes of a cache grid is guaranteed only when using serializable isolation level on the node where cache instances are being read. When using the default read committed isolation level, a connection on a grid node that is reading a cache instance may see a data value that has been subsequently updated to a new value by another connection in the same or a different node.</p>
<p>The cache tables in a dynamic global cache group can be populated using any of these operations:</p>
<ul>
<li>
<p>Dynamic load operation</p>
</li>
<li>
<p>Grid data transfer operation</p>
</li>
<li>
<p><code>INSERT</code> statement on the cache tables (but not an <code>INSERT INTO ... SELECT FROM</code> statement)</p>
</li>
<li>
<p><code>LOAD CACHE GROUP ... COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> statement (can only be used if all the other grid members do not own any of the cache instances to be loaded)</p>
</li>
</ul>
<p>See <a href="operations.htm#CJAGAAHE">&#34;Dynamically loading a cache instance&#34;</a> for information about a dynamic load operation.</p>
<p>A grid member can take ownership of a cache instance that is currently owned by another grid member by using any of the following operations:</p>
<ul>
<li>
<p>Grid data transfer operation</p>
</li>
<li>
<p>Dynamic load operation</p>
</li>
<li>
<p><code>LOAD CACHE GROUP ... WITH ID</code> statement</p>
</li>
</ul>
<p>A <code>REFRESH CACHE GROUP</code> statement can be issued on a dynamic global cache group only if it contains a <code>WITH ID</code> clause.</p>
<p>You can set the <a id="sthref384"></a><a id="sthref385"></a><code>CacheGridMsgWait</code> connection attribute to the maximum number of seconds that a grid member waits for the owner to relinquish the instance. The owner cannot relinquish ownership of a cache instance if it has a pending transaction on any row of the instance. The default maximum wait time is 60 seconds.</p>
<p>An <code>INSERT</code> statement issued on a cache table in a dynamic global cache group fails if the unique key value in the inserted row already exists in the cached Oracle Database table.</p>
<p>When using a <code>LOAD CACHE GROUP ... COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> statement, if any of the cache instances to be loaded within a transaction are owned by another grid member, an error is returned. The transaction is then rolled back and no cache instances are loaded within the failed transaction.</p>
<p>To prevent conflicts that can occur if you update the same row in a TimesTen cache table and the cached Oracle Database table concurrently, update only the cache table. The cached Oracle Database table should not be updated directly.</p>
<p>A TimesTen database that is a member of a cache grid can contain local and global cache groups. Only cache tables in global cache groups are guaranteed to be consistent among the grid members.</p>
</div>
<!-- class="sect2" -->
<a id="CHDJIBGC"></a>
<div id="TTCAC430" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Explicitly loaded global cache groups<a id="sthref386"></a></h3>
<p>Cache instances in an explicitly loaded global cache group are initially loaded from the Oracle database. You can reload the cache instances by issuing another <code>LOAD CACHE GROUP</code> statement or reload a single cache instance with the <code>REFRESH CACHE GROUP...WITH ID</code> statement.</p>
<p>If the cache tables on the local grid member do not contain data that satisfies a query, then the cache instance is transferred from other grid members to the local grid member in a <a id="sthref387"></a><span class="italic">grid data transfer</span> operation. If the grid does not contain the cache instance that satisfies the query, data is not loaded from the Oracle Database tables. The query returns no results.</p>
<p>Use the <code>CREATE ASYNCHRONOUS WRITETHROUGH GLOBAL CACHE GROUP</code> statement to create an explicitly loaded global cache group. Note that this SQL statement is the same as the SQL statement that creates a dynamic global cache group except that the <code>DYNAMIC</code> keyword is omitted.</p>
<div id="TTCAC431" class="example">
<p class="titleinexample"><a id="sthref388"></a>Example 4-24 Creating an explicitly loaded <a id="sthref389"></a>global cache group</p>
<p>The following statement creates an explicitly loaded AWT global cache group <code>subscriber_accounts</code> that caches the <code>oratt.subscriber</code> table:</p>
<pre>CREATE ASYNCHRONOUS WRITETHROUGH GLOBAL CACHE GROUP subscriber_accounts
FROM oratt.subscriber
 (subscriberid       NUMBER(10) NOT NULL PRIMARY KEY,
  name               VARCHAR2(100) NOT NULL,
  minutes_balance    NUMBER(5) NOT NULL,
  last_call_duration NUMBER(4) NOT NULL);
</pre>
<p>The cache tables in an explicitly loaded global cache group can be populated at any time using any of these operations:</p>
<ul>
<li>
<p>Grid data transfer operation</p>
</li>
<li>
<p><code>INSERT</code> statement on the cache tables (but not an <code>INSERT INTO ... SELECT FROM</code> statement)</p>
</li>
<li>
<p><code>LOAD CACHE GROUP</code> statement. The statement can be used only if other grid members do not own any of the cache instances to be loaded into the local grid member.</p>
</li>
<li>
<p><code>REFRESH CACHE GROUP ... WITH ID</code> statement</p>
</li>
</ul>
</div>
<!-- class="example" -->
<p>Aging is disabled by default on an explicitly loaded global cache group.</p>
<p>Set the <a id="sthref390"></a><a id="sthref391"></a><code>CacheGridMsgWait</code> connection attribute to the maximum number of seconds that a grid member waits for the owner to relinquish the instance. The owner cannot relinquish ownership of a cache instance if it has a pending transaction on any row of the instance. The default maximum wait time is 60 seconds.</p>
<p>If a query that specifies a primary key or foreign key is issued on a cache table where there is no row that satisfies the query, the cache instance is not transferred to the cache table.</p>
<p>If a row is inserted into a child table whose parent table exists in the cache grid, the cache instance is transferred to the member with the child table. An insert into a child table whose parent is not in the cache grid fails.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFEFGC"></a>
<div id="TTCAC263" class="sect2">
<h3 class="sect2">Start the replication agent</h3>
<p>After you have created a global cache group, start the replication agent on the TimesTen database as the cache manager user, if it is not already running:</p>
<pre>% ttIsql &#34;DSN=cachealone1;UID=cacheuser;PWD=timesten;OraclePWD=oracle&#34;
Command&gt; call ttRepStart;
Command&gt; exit
</pre></div>
<!-- class="sect2" -->
<a id="CHDDHGBA"></a>
<div id="TTCAC264" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Attach a TimesTen database to a cache grid<a id="sthref392"></a><a id="sthref393"></a><a id="sthref394"></a></h3>
<p>All standalone TimesTen databases, and the active and standby databases of an active standby pair that contain global cache groups must attach to the cache grid that they are associated with in order to update the cache tables of the global cache groups. Attaching the databases to the grid allow the databases to become members of the grid so that cache instances in the cache tables of the global cache groups can maintain consistency among the databases within the grid.</p>
<div id="TTCAC265" class="example">
<p class="titleinexample"><a id="sthref395"></a>Example 4-25 Attaching a TimesTen database to a cache grid</p>
<p>Attach the first standalone database to the <code>ttGrid</code> cache grid that it is associated with by calling the <code>ttGridAttach</code> built-in procedure as the cache manager user. The node number for a standalone TimesTen database is 1. Calling the <code>ttGridAttach</code> built-in procedure automatically starts the cache agent on the TimesTen database if it is not already running.</p>
<p>In this example, <code>alone1</code> is a name that uniquely identifies the grid member, <code>sys1</code> is the host name of the TimesTen system where the first standalone database resides, and <code>5001</code> is the TCP/IP port for the first standalone database&#39;s cache agent process:</p>
<pre>% ttIsql &#34;DSN=cachealone1;UID=cacheuser;PWD=timesten;OraclePWD=oracle&#34;
Command&gt; call ttGridAttach(1,&#39;alone1&#39;,&#39;sys1&#39;,5001);
Command&gt; exit
</pre>
<p>Specify a <a id="sthref396"></a><a id="sthref397"></a>port for the cache agent on each TimesTen database that attaches to the grid. There is no default port number. A typical grid uses the same port for each member of the grid, but different ports can be specified if desired. The port assignment is a grid member property. The only way to change the properties of a grid member after it has been attached to the grid is to destroy the grid and re-create it. Use the <code>ttGridNodeStatus</code> built-in procedure to determine the members of a grid and their ports.</p>
<p>See <a href="prereqs.htm#BCFCGCBJ">&#34;Configuring a cache grid&#34;</a> for more information about a cache grid.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5343">
<tr>
<td class="cellalignment5350">
<table class="cellalignment5348">
<tr>
<td class="cellalignment5347"><a href="prereqs.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5347"><a href="operations.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2012, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5352">
<table class="cellalignment5346">
<tr>
<td class="cellalignment5347"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5347"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5347"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5347"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5347"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5347"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>