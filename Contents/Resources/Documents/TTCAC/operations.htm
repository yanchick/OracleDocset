<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-107437"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Cache%20Group%20Operations"></a><title>Cache Group Operations</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 726"/>
<meta name="dcterms.created" content="2014-09-23T15:6:30Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen Application-Tier Database Cache User&#39;s Guide"/>
<meta name="dcterms.identifier" content="E21634-12"/>
<meta name="dcterms.isVersionOf" content="TTCAC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2012, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="define.htm" title="Previous" type="text/html"/>
<link rel="Next" href="gridmembers.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21634-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/21</span> <!-- End Header -->
<div id="TTCAC266" class="chapter"><a id="CIHFFECJ"></a>
<h1 class="chapter"><span class="secnum">5</span> Cache Group Operations</h1>
<p>The following sections describe operations that can be performed on cache groups:</p>
<ul>
<li>
<p><a href="#CHDIBEEE">Transmitting updates between the TimesTen and Oracle databases</a></p>
</li>
<li>
<p><a href="#CHDBGAAF">Loading and refreshing a cache group</a></p>
</li>
<li>
<p><a href="#CJAGAAHE">Dynamically loading a cache instance</a></p>
</li>
<li>
<p><a href="#CHDBGBBG">Flushing a user managed cache group</a></p>
</li>
<li>
<p><a href="#CHDCFAID">Unloading a cache group</a></p>
</li>
<li>
<p><a href="#CHDDEJAE">Setting a passthrough level</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can use SQL statements or SQL Developer to perform most of the operations in this chapter. For more information about SQL Developer, see <a class="olink TTSDV" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=TTSDV"><span class="italic">Oracle SQL Developer Oracle TimesTen In-Memory Database Support User&#39;s Guide</span></a>.</div>
<a id="CHDIBEEE"></a>
<div id="TTCAC267" class="sect1">
<h2 class="sect1">Transmitting updates between the TimesTen and Oracle databases</h2>
<p>You can use the following SQL statements to manually transmit committed updates between the TimesTen cache tables and the cached Oracle Database tables:</p>
<div class="inftblhruleinformal">
<table class="cellalignment5353" summary="This table contains descriptions of SQL statements that are used to copy data between Oracle tables and a cache group." dir="ltr">
<thead>
<tr class="cellalignment5344">
<th class="cellalignment5354" id="r1c1-t3">SQL statement</th>
<th class="cellalignment5354" id="r1c2-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment5344">
<td class="cellalignment5350" id="r2c1-t3" headers="r1c1-t3"><code>LOAD CACHE GROUP</code></td>
<td class="cellalignment5350" headers="r2c1-t3 r1c2-t3">Load cache instances that are not in the TimesTen cache tables from the cached Oracle Database tables.</td>
</tr>
<tr class="cellalignment5344">
<td class="cellalignment5350" id="r3c1-t3" headers="r1c1-t3"><code>REFRESH CACHE GROUP</code></td>
<td class="cellalignment5350" headers="r3c1-t3 r1c2-t3">Replace cache instances in the TimesTen cache tables with current data from the cached Oracle Database tables.</td>
</tr>
<tr class="cellalignment5344">
<td class="cellalignment5350" id="r4c1-t3" headers="r1c1-t3"><code>FLUSH CACHE GROUP</code></td>
<td class="cellalignment5350" headers="r4c1-t3 r1c2-t3">Propagate committed updates on the TimesTen cache tables to the cached Oracle Database tables. Only applicable for user managed cache groups.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<p>For AWT, SWT, and user managed cache groups that use the <code>PROPAGATE</code> cache table attribute, committed updates on the TimesTen cache tables are automatically propagated to the cached Oracle Database tables.</p>
<p>See <a href="define.htm#CHDJAJAC">&#34;Asynchronous writethrough (AWT) cache group&#34;</a> for more information about AWT cache groups.</p>
<p>See <a href="define.htm#CHDCGGGG">&#34;Synchronous writethrough (SWT) cache group&#34;</a> for more information about SWT cache groups.</p>
<p>See <a href="define.htm#CHDGFDDB">&#34;PROPAGATE cache table attribute&#34;</a> for more information about using the <code>PROPAGATE</code> cache table attribute on cache tables in a user managed cache group.</p>
<p>The <code>AUTOREFRESH</code> cache group attribute can be used in a read-only or a user managed cache group to automatically refresh committed updates on cached Oracle Database tables into the TimesTen cache tables. Automatic refresh can be defined on explicitly loaded or dynamic cache groups.</p>
<p>See <a href="define.htm#CHDEBGEI">&#34;AUTOREFRESH cache group attribute&#34;</a> for more information about automatically refreshing a cache group.</p>
<p>Data is manually preloaded into the cache tables of explicitly loaded cache groups. For dynamic cache groups, data is loaded on demand into the cache tables. A cache instance is automatically loaded from the cached Oracle Database tables when a particular statement does not find the data in the cache tables.</p>
<p>See <a href="#CJAGAAHE">&#34;Dynamically loading a cache instance&#34;</a> for more information about a dynamic load operation.</p>
<p>Dynamic cache groups are typically configured to automatically age out from the cache tables data that is no longer being used.</p>
</div>
<!-- class="sect1" -->
<a id="CHDBGAAF"></a>
<div id="TTCAC268" class="sect1">
<h2 class="sect1">Loading and refreshing a cache group</h2>
<p>You can manually insert or update cache instances in the TimesTen cache tables from the cached Oracle Database tables using either a <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement. The differences between loading and refreshing a cache group are:</p>
<ul>
<li>
<p><a id="sthref398"></a><code>LOAD CACHE GROUP</code> only loads committed inserts on the cached Oracle Database tables into the TimesTen cache tables. New cache instances are loaded into the cache tables, but cache instances that already exist in the cache tables are not updated or deleted even if the corresponding rows in the cached Oracle Database tables have been updated or deleted. A load operation is primarily used to initially populate a cache group.</p>
</li>
<li>
<p><a id="sthref399"></a><code>REFRESH CACHE GROUP</code> replaces cache instances in the TimesTen cache tables with the most current data from the cached Oracle Database tables including cache instances that are already exist in the cache tables. A refresh operation is primarily used to update the contents of a cache group with committed updates on the cached Oracle Database tables after the cache group has been initially populated.</p>
<p>For an explicitly loaded cache group, a refresh operation is equivalent to issuing an <code>UNLOAD CACHE GROUP</code> statement followed by a <code>LOAD CACHE GROUP</code> statement on the cache group. In effect, all committed inserts, updates and deletes on the cached Oracle Database tables are refreshed into the cache tables. New cache instances may be loaded into the cache tables. Cache instances that already exist in the cache tables are updated or deleted if the corresponding rows in the cached Oracle Database tables have been updated or deleted. See <a href="#CHDCFAID">&#34;Unloading a cache group&#34;</a> for more information about the <code>UNLOAD CACHE GROUP</code> statement.</p>
<p>For a dynamic cache group, a refresh operation only refreshes committed updates and deletes on the cached Oracle Database tables into the cache tables because only existing cache instances in the cache tables are refreshed. New cache instances are not loaded into the cache tables so after the refresh operation completes, the cache tables contain either the same or fewer number of cache instances. To load new cache instances into the cache tables of a dynamic cache group, use a <code>LOAD CACHE GROUP</code> statement or perform a dynamic load operation. See <a href="#CJAGAAHE">&#34;Dynamically loading a cache instance&#34;</a> for more information about a dynamic load operation.</p>
</li>
</ul>
<p>For most cache group types, you can use a <code>WHERE</code> clause in a <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement to restrict the rows to be loaded or refreshed into the cache tables.</p>
<p>If the cache table definitions use a <code>WHERE</code> clause, only rows that satisfy the <code>WHERE</code> clause are loaded or refreshed into the cache tables even if the <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement does not use a <code>WHERE</code> clause.</p>
<p>A <code>REFRESH CACHE GROUP</code> statement can be issued on a global cache group only if it contains a <code>WITH ID</code> clause.</p>
<p>If the cache group has a time-based aging policy defined, only cache instances where the timestamp in the root table&#39;s row is within the aging policy&#39;s lifetime are loaded or refreshed into the cache tables.</p>
<p>To prevent a load or refresh operation from processing a large number of cache instances within a single transaction, which can greatly reduce concurrency and throughput, use the <code>COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> clause to specify a commit frequency unless you are using the <code>WITH ID</code> clause. If you specify <code>COMMIT EVERY 0 ROWS</code>, the load or refresh operation is processed in a single transaction.</p>
<p>A <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement that uses the <code>COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> clause must be performed in its own transaction without any other operations within the same transaction.</p>
<div id="TTCAC269" class="example">
<p class="titleinexample"><a id="sthref400"></a>Example 5-1 <a id="sthref401"></a>Loading a cache group</p>
<p>The following statement loads new cache instances into the TimesTen cache tables in the <code>customer_orders</code> cache group from the cached Oracle Database tables:</p>
<pre>LOAD CACHE GROUP customer_orders COMMIT EVERY 256 ROWS;
</pre></div>
<!-- class="example" -->
<div id="TTCAC270" class="example">
<p class="titleinexample"><a id="sthref402"></a>Example 5-2 Loading a cache group using a WHERE clause</p>
<p>The following statement loads into the TimesTen cache tables in the <code>new_customers</code> cache group from the cached Oracle Database tables, new cache instances for customers whose customer number is greater than or equal to 5000:</p>
<pre>LOAD CACHE GROUP new_customers WHERE (oratt.customer.cust_num &gt;= 5000)
  COMMIT EVERY 256 ROWS;
</pre></div>
<!-- class="example" -->
<div id="TTCAC271" class="example">
<p class="titleinexample"><a id="sthref403"></a>Example 5-3 <a id="sthref404"></a>Refreshing a cache group</p>
<p>The following statement refreshes cache instances in the TimesTen cache tables within the <code>top_products</code> cache group from the cached Oracle Database tables:</p>
<pre>REFRESH CACHE GROUP top_products COMMIT EVERY 256 ROWS;
</pre></div>
<!-- class="example" -->
<div id="TTCAC272" class="example">
<p class="titleinexample"><a id="sthref405"></a>Example 5-4 Refreshing a cache group using a WHERE clause</p>
<p>The following statement refreshes in the TimesTen cache tables within the <code>update_anywhere_customers</code> cache group from the cached Oracle Database tables, cache instances of customers located in zip code 60610:</p>
<pre>REFRESH CACHE GROUP update_anywhere_customers
  WHERE (oratt.customer.zip = &#39;60610&#39;) COMMIT EVERY 256 ROWS;
</pre></div>
<!-- class="example" -->
<p>For more information, see the <a class="olink TTSQL323" href="../TTSQL/state.htm#TTSQL323">&#34;LOAD CACHE GROUP&#34;</a> and <a class="olink TTSQL325" href="../TTSQL/state.htm#TTSQL325">&#34;REFRESH CACHE GROUP&#34;</a> statements in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>The rest of this section includes these topics:</p>
<ul>
<li>
<p><a href="#CHDDAGAG">Loading and refreshing an explicitly loaded cache group with autorefresh</a></p>
</li>
<li>
<p><a href="#CJAEFBHD">Loading and refreshing a dynamic cache group with autorefresh</a></p>
</li>
<li>
<p><a href="#CHDCIFDI">Loading and refreshing a cache group using a WITH ID clause</a></p>
</li>
<li>
<p><a href="#CJACBCHC">Initiating an immediate autorefresh</a></p>
</li>
<li>
<p><a href="#CHDHEIJF">Loading and refreshing a multiple-table cache group</a></p>
</li>
<li>
<p><a href="#CHDBBEIB">Improving the performance of loading or refreshing a large number of cache instances</a></p>
</li>
<li>
<p><a href="#CJAFADFI">Example of manually loading and refreshing an explicitly loaded cache group</a></p>
</li>
<li>
<p><a href="#CJADBEHJ">Example of manually loading and refreshing a dynamic cache group</a></p>
</li>
</ul>
<a id="CHDDAGAG"></a>
<div id="TTCAC273" class="sect2">
<h3 class="sect2"><a id="sthref406"></a>Loading and refreshing an explicitly loaded cache group with autorefresh</h3>
<p>If the autorefresh state of an explicitly loaded cache group is <code>PAUSED</code>, the autorefresh state is changed to <code>ON</code> after a <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement issued on the cache group completes.</p>
<p>The following restrictions apply when manually loading or refreshing an explicitly loaded cache group with autorefresh:</p>
<ul>
<li>
<p>A <code>LOAD CACHE GROUP</code> statement can only be issued if the cache tables are empty.</p>
</li>
<li>
<p>The autorefresh state must be <code>PAUSED</code> before you can issue a <code>LOAD CACHE GROUP</code> statement.</p>
</li>
<li>
<p>The autorefresh state must be <code>PAUSED</code> before you can issue a <code>REFRESH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>A <code>LOAD CACHE GROUP</code> statement cannot contain a <code>WHERE</code> clause.</p>
</li>
<li>
<p>A <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement cannot contain a <code>WITH ID</code> clause.</p>
</li>
<li>
<p>A <code>REFRESH CACHE GROUP</code> statement cannot contain a <code>WHERE</code> clause.</p>
</li>
<li>
<p>All tables and columns referenced in a <code>WHERE</code> clause when loading the cache group must be fully qualified. For example:</p>
<p><code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code> and <code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code><code>.</code><code><span class="codeinlineitalic">column_name</span></code></p>
</li>
</ul>
<p>When an autorefresh operation occurs on an explicitly loaded cache group, all committed inserts, updates and deletes on the cached Oracle Database tables since the last autorefresh cycle are refreshed into the cache tables. New cache instances may be loaded into the cache tables. Cache instances that already exist in the cache tables are updated or deleted if the corresponding rows in the cached Oracle Database tables have been updated or deleted.</p>
</div>
<!-- class="sect2" -->
<a id="CJAEFBHD"></a>
<div id="TTCAC407" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Loading and refreshing a dynamic cache group with autorefresh</h3>
<p>If the autorefresh state of a dynamic cache group is <code>PAUSED</code>, the autorefresh state is changed to <code>ON</code> after any of the following events occur:</p>
<ul>
<li>
<p>Its cache tables are initially empty, and then a dynamic load, a <code>LOAD CACHE GROUP</code> or an unconditional <code>REFRESH CACHE GROUP</code> statement issued on the cache group completes.</p>
</li>
<li>
<p>Its cache tables are not empty, and then an unconditional <code>REFRESH CACHE GROUP</code> statement issued on the cache group completes.</p>
</li>
</ul>
<p>If the autorefresh state of a dynamic cache group is <code>PAUSED</code>, the autorefresh state remains at <code>PAUSED</code> after any of the following events occur:</p>
<ul>
<li>
<p>Its cache tables are initially empty, and then a <code>REFRESH CACHE GROUP ... WITH ID</code> statement issued on the cache group completes.</p>
</li>
<li>
<p>Its cache tables are not empty, and then a dynamic load, a <code>REFRESH CACHE GROUP ... WITH ID</code>, or a <code>LOAD CACHE GROUP</code> statement issued on the cache group completes.</p>
</li>
</ul>
<p>For a dynamic cache group, an autorefresh operation only refreshes committed updates and deletes on the cached Oracle Database tables since the last autorefresh cycle into the cache tables because only existing cache instances in the cache tables are refreshed. New cache instances are not loaded into the cache tables. To load new cache instances into the cache tables of a dynamic cache group, use a <code>LOAD CACHE GROUP</code> statement or perform a dynamic load operation. See <a href="#CJAGAAHE">&#34;Dynamically loading a cache instance&#34;</a> for more information about a dynamic load operation.</p>
<p>The following restrictions apply when manually loading or refreshing a dynamic cache group with automatic refresh:</p>
<ul>
<li>
<p>The autorefresh state must be <code>PAUSED</code> or <code>ON</code> before you can issue a <code>LOAD CACHE GROUP</code> statement.</p>
</li>
<li>
<p>The autorefresh state must be <code>PAUSED</code> before you can issue a <code>REFRESH CACHE GROUP</code> statement.</p>
</li>
<li>
<p>A <code>LOAD CACHE GROUP</code> statement that contains a <code>WHERE</code> clause must include a <code>COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> clause after the <code>WHERE</code> clause.</p>
</li>
<li>
<p>A <code>REFRESH CACHE GROUP</code> statement cannot contain a <code>WHERE</code> clause.</p>
</li>
<li>
<p>All tables and columns referenced in a <code>WHERE</code> clause when loading the cache group must be fully qualified. For example:</p>
<p><code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code> and <code><span class="codeinlineitalic">user_name</span></code><code>.</code><code><span class="codeinlineitalic">table_name</span></code><code>.</code><code><span class="codeinlineitalic">column_name</span></code></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDCIFDI"></a>
<div id="TTCAC274" class="sect2">
<h3 class="sect2">Loading and refreshing a cache group using a WITH ID clause</h3>
<p>The <code>WITH ID</code> clause of the <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement enables you to load or refresh a cache group based on values of the primary key columns without having to use a <code>WHERE</code> clause. The <code>WITH ID</code> clause is more convenient than the equivalent <code>WHERE</code> clause if the primary key contains more than one column. Using the <code>WITH ID</code> clause allows you to load one cache instance at a time. It also enables you to roll back the transaction containing the load or refresh operation, if necessary, unlike the equivalent statement that uses a <code>WHERE</code> clause because using a <code>WHERE</code> clause also requires specifying a <code>COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> clause.</p>
<div id="TTCAC275" class="example">
<p class="titleinexample"><a id="sthref407"></a>Example 5-5 <a id="sthref408"></a><a id="sthref409"></a>Loading a cache group using a WITH ID clause</p>
<p>A cache group recent_orders contains a single cache table <code>oratt.orderdetails</code> with a primary key of <code>(</code><code>orderid</code>, <code>itemid</code><code>)</code>. If a customer calls about an item within a particular order, the information can be obtained by loading the cache instance for the specified order number and item number.</p>
<p>Load the <code>oratt.orderdetails</code> cache table in the <code>recent_orders</code> cache group with the row whose value in the <code>orderid</code> column of the <code>oratt.orderdetails</code> cached Oracle Database table is 1756 and its value in the <code>itemid</code> column is 573:</p>
<pre>LOAD CACHE GROUP recent_orders WITH ID (1756,573);
</pre>
<p>The following is an equivalent <code>LOAD CACHE GROUP</code> statement that uses a <code>WHERE</code> clause:</p>
<pre>LOAD CACHE GROUP recent_orders WHERE orderid = 1756 and itemid = 573
  COMMIT EVERY 256 ROWS;
</pre></div>
<!-- class="example" -->
<p>A <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement issued on an autorefresh cache group cannot contain a <code>WITH ID</code> clause unless the cache group is dynamic.</p>
<p>You cannot use the <code>COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> clause with the <code>WITH ID</code> clause.</p>
</div>
<!-- class="sect2" -->
<a id="CJACBCHC"></a>
<div id="TTCAC408" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Initiating an immediate autorefresh<a id="sthref410"></a><a id="sthref411"></a><a id="sthref412"></a></h3>
<p>If the Oracle Database tables have been updated with data that needs to be applied to cache tables without waiting for the next autorefresh operation, you can call the <code>ttCacheAutorefresh</code> built-in procedure. The <code>ttCacheAutorefresh</code> built-in procedure initiates an immediate refresh operation and resets the autorefresh cycle to start at the moment you invoke <code>ttCacheAutorefresh</code>. The refresh operation is full or incremental depending on how the cache group is configured. The autorefresh state must be <code>ON</code> when <code>ttCacheAutorefresh</code> is called.</p>
<p>The autorefresh operation normally refreshes all cache groups sharing the same refresh interval in one transaction in order to preserve transactional consistency across these cache groups. Therefore, although you specify a specific cache group when you call <code>ttCacheAutorefresh</code>, the autorefresh operation occurs in one transaction for all cache groups that share the autorefresh interval with the specified cache group. If there is an existing transaction with table locks on objects that belong to the affected cache groups, <code>ttCacheAutofresh</code> returns an error without taking any action.</p>
<p>You can choose to run <code>ttCacheAutorefresh</code> asynchronously (the default) or synchronously. In synchronous mode, <code>ttCacheAutorefresh</code> returns an error if the refresh operation fails.</p>
<p>After calling <code>ttCacheAutorefresh</code>, you must commit or roll back the transaction before subsequent work can be performed.</p>
<div id="TTCAC409" class="example">
<p class="titleinexample"><a id="sthref413"></a>Example 5-6 Calling ttCacheAutorefresh</p>
<p>This example calls <code>ttCacheAutorefresh</code> for the <code>ttuser.western_customers</code> cache group, using asynchronous mode.</p>
<pre>Command&gt; call ttCacheAutorefresh(&#39;ttuser&#39;, &#39;western_customers&#39;);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDHEIJF"></a>
<div id="TTCAC276" class="sect2">
<h3 class="sect2">Loading and refreshing a multiple-table cache group</h3>
<p>If you are loading or refreshing a multiple-table cache group while the cached Oracle Database tables are concurrently being updated, set the isolation level in the TimesTen database to serializable before issuing the <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement. This causes TimesTen to query the cached Oracle Database tables in a serializable fashion during the load or refresh operation so that the loaded or refreshed cache instances in the cache tables are guaranteed to be transactionally consistent with the corresponding rows in the cached Oracle Database tables. After you have loaded or refreshed the cache group, set the isolation level back to read committed for better concurrency when accessing elements in the TimesTen database.</p>
</div>
<!-- class="sect2" -->
<a id="CHDBBEIB"></a>
<div id="TTCAC277" class="sect2">
<h3 class="sect2">Improving the performance of loading or refreshing a large number of cache instances</h3>
<p>You can improve the performance of loading or refreshing a large number of cache instances into a cache group by using the <code>PARALLEL</code> clause of the <code>LOAD CACHE GROUP</code> or <code>REFRESH CACHE GROUP</code> statement. Specify the number of threads to use when processing the load or refresh operation. You can specify 1 to 10 threads. One thread fetches rows from the cached Oracle Database tables, while the other threads insert the rows into the TimesTen cache tables. Do not specify more threads than the number of CPUs available on your system or you may encounter decreased performance than if you had not used the <code>PARALLEL</code> clause.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot use the <code>WITH ID</code> clause with the <code>PARALLEL</code> clause. You can use the <code>COMMIT EVERY n ROWS</code> clause with the <code>PARALLEL</code> clause as long as <code>n</code> is greater than 0. In addition, you cannot use the <code>PARALLEL</code> clause for read-only dynamic cache groups or when database level locking is enabled. For more details, see <a class="olink TTSQL325" href="../TTSQL/state.htm#TTSQL325">&#34;REFRESH CACHE GROUP&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</div>
<div id="TTCAC278" class="example">
<p class="titleinexample"><a id="sthref414"></a>Example 5-7 <a id="sthref415"></a><a id="sthref416"></a>Refreshing a cache group using a PARALLEL clause</p>
<p>The following statement refreshes cache instances in the TimesTen cache tables within the <code>western_customers</code> cache group from the cached Oracle Database tables using one thread to fetch rows from the cached Oracle Database tables and three threads to insert the rows into the cache tables:</p>
<pre>REFRESH CACHE GROUP western_customers COMMIT EVERY 256 ROWS PARALLEL 4;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CJAFADFI"></a>
<div id="TTCAC279" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Example of manually loading and refreshing an explicitly loaded cache group</h3>
<p>The following is the definition of the Oracle Database table that is to be cached in an explicitly loaded AWT cache group. The Oracle Database table is owned by the schema user <code>oratt</code>.</p>
<pre>CREATE TABLE customer
(cust_num NUMBER(6) NOT NULL PRIMARY KEY,
 region   VARCHAR2(10),
 name     VARCHAR2(50),
 address  VARCHAR2(100));
</pre>
<p>The following is the data in the <code>oratt.customer</code> cached Oracle Database table.</p>
<pre>CUST_NUM   REGION    NAME              ADDRESS
--------   -------   ---------------   ---------------------------    
       1   West      Frank Edwards     100 Pine St. Portland OR
       2   East      Angela Wilkins    356 Olive St. Boston MA
       3   Midwest   Stephen Johnson   7638 Walker Dr. Chicago IL
</pre>
<p>The following statement creates an explicitly loaded AWT cache group <code>new_customers</code> that caches the <code>oratt.customer</code> table:</p>
<pre>CREATE ASYNCHRONOUS WRITETHROUGH CACHE GROUP new_customers
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num));
</pre>
<p>The <code>oratt.customer</code> TimesTen cache table is initially empty.</p>
<pre>Command&gt; SELECT * FROM oratt.customer;
0 rows found.
</pre>
<p>The following <code>LOAD CACHE GROUP</code> statement loads the three cache instances from the cached Oracle Database table into the TimesTen cache table:</p>
<pre>Command&gt; LOAD CACHE GROUP new_customers COMMIT EVERY 256 ROWS;
3 cache instances affected.
Command&gt; SELECT * FROM oratt.customer;
&lt; 1, West, Frank Edwards, 100 Pine St. Portland OR &gt;
&lt; 2, East, Angela Wilkins, 356 Olive St. Boston MA &gt;
&lt; 3, Midwest, Stephen Johnson, 7638 Walker Dr. Chicago IL &gt;
</pre>
<p>Update the cached Oracle Database table by inserting a new row, updating an existing row, and deleting an existing row:</p>
<pre>SQL&gt; INSERT INTO customer
  2  VALUES (4, &#39;East&#39;, &#39;Roberta Simon&#39;, &#39;3667 Park Ave. New York NY&#39;);
SQL&gt; UPDATE customer SET name = &#39;Angela Peterson&#39; WHERE cust_num = 2;
SQL&gt; DELETE FROM customer WHERE cust_num = 3;
SQL&gt; COMMIT;
SQL&gt; SELECT * FROM customer;
CUST_NUM   REGION    NAME              ADDRESS
--------   -------   ---------------   ---------------------------    
       1   West      Frank Edwards     100 Pine St. Portland OR
       2   East      Angela Peterson   356 Olive St. Boston MA
       4   East      Roberta Simon     3667 Park Ave. New York NY
</pre>
<p>A <code>REFRESH CACHE GROUP</code> statement issued on an explicitly loaded cache group is processed by unloading and then reloading the cache group. As a result, the cache instances in the cache table matches the rows in the cached Oracle Database table.</p>
<pre>Command&gt; REFRESH CACHE GROUP new_customers COMMIT EVERY 256 ROWS;
3 cache instance affected.
Command&gt; SELECT * FROM oratt.customer;
&lt; 1, West, Frank Edwards, 100 Pine St. Portland OR &gt;
&lt; 2, East, Angela Peterson, 356 Olive St. Boston MA &gt;
&lt; 4, East, Roberta Simon, 3667 Park Ave. New York NY &gt;
</pre></div>
<!-- class="sect2" -->
<a id="CJADBEHJ"></a>
<div id="TTCAC280" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Example of manually loading and refreshing a dynamic cache group<a id="sthref417"></a><a id="sthref418"></a></h3>
<p>The following is the definition of the Oracle Database table that is to be cached in a dynamic AWT cache group. The Oracle Database table is owned by the schema user <code>oratt</code>.</p>
<pre>CREATE TABLE customer
(cust_num NUMBER(6) NOT NULL PRIMARY KEY,
 region   VARCHAR2(10),
 name     VARCHAR2(50),
 address  VARCHAR2(100));
</pre>
<p>The following is the data in the <code>oratt.customer</code> cached Oracle Database table.</p>
<pre>CUST_NUM   REGION    NAME              ADDRESS
--------   -------   ---------------   ---------------------------    
       1   West      Frank Edwards     100 Pine St. Portland OR
       2   East      Angela Wilkins    356 Olive St. Boston MA
       3   Midwest   Stephen Johnson   7638 Walker Dr. Chicago IL
</pre>
<p>The following statement creates a dynamic AWT cache group <code>new_customers</code> that caches the <code>oratt.customer</code> table:</p>
<pre>CREATE DYNAMIC ASYNCHRONOUS WRITETHROUGH CACHE GROUP new_customers
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num));
</pre>
<p>The <code>oratt.customer</code> TimesTen cache table is initially empty:</p>
<pre>Command&gt; SELECT * FROM oratt.customer;
0 rows found.
</pre>
<p>The following <code>LOAD CACHE GROUP</code> statement loads the three cache instances from the cached Oracle Database table into the TimesTen cache table:</p>
<pre>Command&gt; LOAD CACHE GROUP new_customers COMMIT EVERY 256 ROWS;
3 cache instances affected.
Command&gt; SELECT * FROM oratt.customer;
&lt; 1, West, Frank Edwards, 100 Pine St. Portland OR &gt;
&lt; 2, East, Angela Wilkins, 356 Olive St. Boston MA &gt;
&lt; 3, Midwest, Stephen Johnson, 7638 Walker Dr. Chicago IL &gt;
</pre>
<p>Update the cached Oracle Database table by inserting a new row, updating an existing row, and deleting an existing row:</p>
<pre>SQL&gt; INSERT INTO customer
  2  VALUES (4, &#39;East&#39;, &#39;Roberta Simon&#39;, &#39;3667 Park Ave. New York NY&#39;);
SQL&gt; UPDATE customer SET name = &#39;Angela Peterson&#39; WHERE cust_num = 2;
SQL&gt; DELETE FROM customer WHERE cust_num = 3;
SQL&gt; COMMIT;
SQL&gt; SELECT * FROM customer;
CUST_NUM   REGION    NAME              ADDRESS
--------   -------   ---------------   ---------------------------    
       1   West      Frank Edwards     100 Pine St. Portland OR
       2   East      Angela Peterson   356 Olive St. Boston MA
       4   East      Roberta Simon     3667 Park Ave. New York NY
</pre>
<p>A <code>REFRESH CACHE GROUP</code> statement issued on a dynamic cache group only refreshes committed updates and deletes on the cached Oracle Database tables into the cache tables. New cache instances are not loaded into the cache tables. Therefore, only existing cache instances are refreshed. As a result, the number of cache instances in the cache tables are either fewer than or the same as the number of rows in the cached Oracle Database tables.</p>
<pre>Command&gt; REFRESH CACHE GROUP new_customers COMMIT EVERY 256 ROWS;
2 cache instances affected.
Command&gt; SELECT * FROM oratt.customer;
&lt; 1, West, Frank Edwards, 100 Pine St. Portland OR &gt;
&lt; 2, East, Angela Peterson, 356 Olive St. Boston MA &gt;
</pre>
<p>A subsequent <code>LOAD CACHE GROUP</code> statement loads one cache instance from the cached Oracle Database table into the TimesTen cache table because only committed inserts are loaded into the cache table. Therefore, only new cache instances are loaded. Cache instances that already exist in the cache tables are not changed because of a <code>LOAD CACHE GROUP</code> statement, even if the corresponding rows in the cached Oracle Database tables were updated or deleted.</p>
<pre>Command&gt; LOAD CACHE GROUP new_customers COMMIT EVERY 256 ROWS;
1 cache instance affected.
Command&gt; SELECT * FROM oratt.customer;
&lt; 1, West, Frank Edwards, 100 Pine St. Portland OR &gt;
&lt; 2, East, Angela Peterson, 356 Olive St. Boston MA &gt;
&lt; 4, East, Roberta Simon, 3667 Park Ave. New York NY &gt;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJAGAAHE"></a>
<div id="TTCAC498" class="sect1">
<h2 class="sect1">Dynamically loading a cache instance<a id="sthref419"></a><a id="sthref420"></a></h2>
<p>In a dynamic cache group, data is automatically loaded into the TimesTen cache tables from the cached Oracle Database tables when a qualifying <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement is issued on one of the cache tables and the data does not exist in the cache table but does exist in the cached Oracle Database table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the Oracle database is down, the following error is returned:
<pre>5219: Temporary Oracle connection failure error in OCISessionBegin():
 ORA-01034: ORACLE not available
</pre></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Dynamic load can only be performed for dynamic cache groups if the <code>DynamicLoadEnable</code> connection attribute is enabled. See <a href="#CJAFADHD">&#34;Dynamic load configuration&#34;</a> for more details.</div>
<p>A dynamic load retrieves a single cache instance that is either automatically loaded from the Oracle database to the TimesTen database or, for dynamic global cache groups, transferred from the grid member that owns the instance to the requesting grid member. A <a id="sthref421"></a>cache instance consists of row from the root table of any cache group (that is uniquely identified by either a primary key or a unique index on the root table) and all related rows in the child tables associated by foreign key relationships.</p>
<p>If a row in the cached Oracle Database table satisfies the <code>WHERE</code> clause, the entire associated cache instance is loaded in order to maintain the defined relationships between primary keys and foreign keys of the parent and child tables. A dynamic load operation cannot load more than one row into the root table of any cache group. Only cache instances whose rows satisfy the <code>WHERE</code> clause of the cache table definitions are loaded.</p>
<p>The <code>WHERE</code> clause must specify one of the following for a dynamic load to occur:</p>
<ul>
<li>
<p>An equality condition with constants and/or parameters on all columns of a primary key or a foreign key of any table of the cache group. If more than one table of a cache group is referenced, each must be connected by an equality condition on the primary or foreign key relationship.</p>
</li>
<li>
<p>A mixture of equality or <code>IS NULL</code> conditions on all columns of a unique index, provided that you use at least one equality condition. That is, you can perform a dynamic load where some columns of the unique index are <code>NULL</code>. The unique index must be created on the root table of the cache group.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Dynamic loading based on a primary key search of the root table performs faster than primary key searches on a child table or foreign key searches on a child table.</div>
<p>The dynamic load is executed in a different transaction than the user transaction that triggers the dynamic load. The dynamic load transaction is committed before the SQL statement that triggers the dynamic load has finished execution. Thus, if the user transaction is rolled back, the dynamically loaded data remains in the cache group.</p>
<p><a id="sthref422"></a>With global cache groups, the TimesTen database must be attached to a cache grid before dynamic load is allowed with these cache groups. See <a href="define.htm#CHDCJADE">&#34;Global cache groups&#34;</a> for more information about global cache groups and attaching a TimesTen database to a cache grid.</p>
<p>The following sections describes dynamic load for cache groups:</p>
<ul>
<li>
<p><a href="#CJAFADHD">Dynamic load configuration</a></p>
</li>
<li>
<p><a href="#CJAEFIBA">Dynamic load guidelines</a></p>
</li>
<li>
<p><a href="#CJABAAJJ">Examples of dynamically loading a cache instance</a></p>
</li>
<li>
<p><a href="#CJABAECJ">Return dynamic load errors</a></p>
</li>
</ul>
<a id="CJAFADHD"></a>
<div id="TTCAC499" class="sect2">
<h3 class="sect2">Dynamic load configuration<a id="sthref423"></a></h3>
<p>Dynamic <a id="sthref424"></a><a id="sthref425"></a>load can be configured with the <code>DynamicLoadEnable</code> connection attribute as follows:</p>
<ul>
<li>
<p>0 - Disables dynamic load of Oracle Database data to TimesTen dynamic cache groups for the current connection.</p>
</li>
<li>
<p>1 (default) - Enables dynamic load of Oracle Database data to a single TimesTen dynamic cache group per statement for the current connection. The statement must reference tables of only one dynamic cache group and only in the main query. The statement can also reference non-cache tables. Only one cache instance can be loaded.</p>
</li>
<li>
<p>2 - Enables dynamic load of Oracle Database data to one or multiple TimesTen dynamic cache groups per statement for the current connection. The referenced tables can exist within multiple cache groups. All cache groups referenced in the main query are to be dynamically loaded; any cache groups referenced solely in a subquery are to be ignored for dynamic load. The statement can also reference non-cache tables. Only one cache instance can be loaded.</p>
</li>
</ul>
<p>Set the appropriate value in the <a id="sthref426"></a><a id="sthref427"></a><code>DynamicLoadEnable</code> connection attribute to configure the type of dynamic loading for all cache tables in dynamic cache groups that are accessed within a particular connection.</p>
<p>To enable or disable dynamic loading for a particular transaction, you can set the <code>DynamicLoadEnable</code> optimizer hint. However, the <code>DynamicLoadEnable</code> connection attribute is the only method for configuring what type of dynamic load is enabled.</p>
<p>You can set the <code>DynamicLoadEnable</code> optimizer hint with one of the following methods:</p>
<ul>
<li>
<p>Use the <code>ttIsql</code> utility <a id="sthref428"></a><code>set dynamicloadenable</code> command.</p>
</li>
<li>
<p>Call the <code>ttOptSetFlag</code> built-in procedure with the <a id="sthref429"></a><code>DynamicLoadEnable</code> flag set to the desired value. The following example sets dynamic loading to 1.</p>
<pre>call ttOptSetFlag(&#39;DynamicLoadEnable&#39;, 1)
</pre></li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more details, see <a class="olink TTREF207" href="../TTREF/attribute.htm#TTREF207">&#34;DynamicLoadEnable&#34;</a>, <a class="olink TTREF342" href="../TTREF/util.htm#TTREF342">&#34;ttIsql&#34;</a> or <a class="olink TTREF271" href="../TTREF/proced.htm#TTREF271">&#34;ttOptSetFlag&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.
<p>You can also set connection attributes with the <code>SQLSetConnectOption</code> ODBC function. See <a class="olink TTCDV477" href="../TTCDV/odbc_supported.htm#TTCDV477">&#34;Option support for SQLSetConnectOption and SQLGetConnectOption&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span> for more details.</p>
</div>
</div>
<!-- class="sect2" -->
<a id="CJAEFIBA"></a>
<div id="TTCAC452" class="sect2">
<h3 class="sect2">Dynamic load guidelines<a id="sthref430"></a><a id="sthref431"></a></h3>
<p>Dynamic load retrieves at most one cache instance for each cache group referenced in the main query. This section details the guidelines under which dynamic load occurs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Examples for these guidelines are provided in <a href="#CJABAAJJ">&#34;Examples of dynamically loading a cache instance&#34;</a>.</div>
<p>Dynamic load is available only for the following types of statements issued on a cache table in a dynamic cache group:</p>
<ul>
<li>
<p>When an <code>INSERT</code> statement inserts values into any of the child tables of a cache instance that does not currently exist in the TimesTen tables, the cache instance to which the new row belongs dynamically loads. The insert operation for the new child row is propagated to the cached Oracle Database table.</p>
</li>
<li>
<p><code>SELECT</code>, <code>UPDATE</code>, or <code>DELETE</code> statements require that the <code>WHERE</code> clause have the conditions as stated in <a href="#CJAGAAHE">&#34;Dynamically loading a cache instance&#34;</a>.</p>
</li>
</ul>
<p>The <code>SELECT</code>, <code>UPDATE</code>, or <code>DELETE</code> statements for which dynamic load is available must satisfy the following conditions:</p>
<ul>
<li>
<p>If the statement contains a subquery, only the cache group with tables referenced in the main query are considered for a dynamic load.</p>
</li>
<li>
<p>If the statement references multiple tables of the cache group, the statement must include an equality join condition between the primary keys and foreign keys for all parent and child relationships.</p>
</li>
<li>
<p>The statement cannot contain the <code>UNION</code>, <code>INTERSECT</code>, or <code>MINUS</code> set operators.</p>
</li>
<li>
<p>The statement can reference non-cache tables.</p>
</li>
<li>
<p>By default, the statement can reference cache tables from only one dynamic cache group. This behavior is enabled when <code>DynamicLoadEnable</code> is set to 1. However, if <code>DynamicLoadEnable</code> is set to 2, the statement can reference cache tables from multiple dynamic cache groups. See <a href="#CJAFADHD">&#34;Dynamic load configuration&#34;</a> for more information.</p>
</li>
</ul>
<p>Dynamic load behavior depends on the setting of <code>DynamicLoadEnable</code>. The following describes the rules that are evaluated to determine if a dynamic load occurs. These rules are followed when <code>DynamicLoadEnable</code> is set to either 1 or 2.</p>
<ul>
<li>
<p>Dynamic load does not occur for a cache group if any table of the cache group is specified more than once in any <code>FROM</code> clause.</p>
</li>
<li>
<p>Only the conditions explicitly specified in the query are considered for dynamic load, which excludes any derived conditions.</p>
</li>
<li>
<p>If any cache group is referenced only in a subquery, it is not considered for a dynamic load.</p>
</li>
<li>
<p>If the cache group has a time-based aging policy defined, the timestamp in the root table&#39;s row must be within the aging policy&#39;s lifetime in order for the cache instance to be loaded. See <a href="define.htm#CHDGICCB">&#34;Implementing aging in a cache group&#34;</a> for information about defining an aging policy on a cache group.</p>
</li>
<li>
<p>When using an active standby pair replication scheme, dynamic load cannot occur in any subscriber.</p>
</li>
</ul>
<p>When dynamic load is enabled with setting <code>DynamicLoadEnable</code> to 2, you can include multiple dynamic cache groups in the statement. The rules for this situation that determines if a dynamic load occurs are as follows:</p>
<ul>
<li>
<p>If multiple cache groups exist within in a query, dynamic load is considered for the cache groups that meet the required conditions for a dynamic load. Dynamic load is not considered for any cache groups that do not meet dynamic load conditions.</p>
</li>
<li>
<p>If tables of any dynamic cache group are referenced in the main query, they are considered for dynamic load, even if other tables in any cache group are referenced in the subquery.</p>
</li>
</ul>
<p>The following considerations can affect dynamic load:</p>
<ul>
<li>
<p>If tables within multiple cache groups or non-cache group tables are specified in the main query, the join order influences if the cache instance is loaded. If during the execution of the query, a dynamic load is possible and necessary to produce the query results, the dynamic load occurs. However, if no rows are returned, then some or all of the cache instances are not dynamically loaded.</p>
</li>
<li>
<p>If a statement specifies more than the dynamic load condition on tables of a cache group, the cache instance may be dynamically loaded even though the additional conditions are not qualified for the statement.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CJABAAJJ"></a>
<div id="TTCAC500" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Examples of dynamically loading a cache instance<a id="sthref432"></a></h3>
<p>The following is the definition of the Oracle Database tables that are to be cached in a dynamic AWT cache group. The Oracle Database table is owned by the schema user <code>oratt</code>.</p>
<pre>CREATE TABLE customer
(cust_num NUMBER(6) NOT NULL PRIMARY KEY,
 region   VARCHAR2(10),
 name     VARCHAR2(50),
 address  VARCHAR2(100));

CREATE TABLE orders
(ord_num      NUMBER(10) NOT NULL PRIMARY KEY,
 cust_num     NUMBER(6) NOT NULL,
 when_placed  DATE NOT NULL,
 when_shipped DATE NOT NULL);

CREATE TABLE orderdetails
 (orderid  NUMBER(10) NOT NULL,
  itemid   NUMBER(8) NOT NULL,
  quantity NUMBER(4) NOT NULL,
  PRIMARY KEY (orderid, itemid));
</pre>
<p>For example, the following data is in the <code>oratt.customer</code> cached Oracle Database table.</p>
<pre>CUST_NUM   REGION    NAME              ADDRESS
--------   -------   ---------------   ---------------------------    
       1   West      Frank Edwards     100 Pine St., Portland OR
       2   East      Angela Wilkins    356 Olive St., Boston MA
       3   Midwest   Stephen Johnson   7638 Walker Dr., Chicago IL
</pre>
<p>The following statement creates a dynamic AWT cache group <code>new_customers</code> that caches the <code>oratt.customer</code>, <code>oratt.orders</code>, and <code>oratt.orderdetails</code> tables:</p>
<pre>CREATE DYNAMIC ASYNCHRONOUS WRITETHROUGH CACHE GROUP new_customers
FROM oratt.customer
 (cust_num NUMBER(6) NOT NULL,
  region   VARCHAR2(10),
  name     VARCHAR2(50),
  address  VARCHAR2(100),
  PRIMARY KEY(cust_num)),
oratt.orders
 (ord_num      NUMBER(10) NOT NULL,
  cust_num     NUMBER(6) NOT NULL,
  when_placed  DATE NOT NULL,
  when_shipped DATE NOT NULL,
  PRIMARY KEY(ord_num),
  FOREIGN KEY(cust_num) REFERENCES oratt.customer(cust_num)),
oratt.orderdetails
 (orderid  NUMBER(10) NOT NULL,
  itemid   NUMBER(8) NOT NULL,
  quantity NUMBER(4) NOT NULL,
  PRIMARY KEY(orderid, itemid),
  FOREIGN KEY(orderid) REFERENCES oratt.orders(order_num));
</pre>
<p>The following examples can be used when <code>DynamicLoadEnable</code> is set to 1:</p>
<p>The <code>oratt.customer</code> TimesTen cache table is initially empty:</p>
<pre>Command&gt; SELECT * FROM oratt.customer;
0 rows found.
</pre>
<p>The following <code>SELECT</code> statement with an equality condition on the primary key for the <code>oratt.customer</code> table results in a dynamic load:</p>
<pre>Command&gt; SELECT * FROM oratt.customer WHERE cust_num = 1;
&lt; 1, West, Frank Edwards, 100 Pine St., Portland OR &gt;
</pre>
<p>However, if you do not use an equality condition on the primary key, no dynamic load occurs:</p>
<pre>Command&gt; SELECT * FROM oratt.customer WHERE cust_num IN (1,2);
</pre>
<p>The following example contains equality expressions on all of the primary key columns for a primary key composite. The <code>orderdetails</code> table has a composite primary key of <code>orderid</code> and <code>itemid</code>.</p>
<pre>UPDATE oratt.orderdetails SET quantity = 5 WHERE orderid=2280 AND itemid=663;
</pre>
<p>The following example shows an <code>INSERT</code> into the <code>orders</code> child table, which initiates a dynamic load. However, if you tried to insert into the <code>customer</code> table, which is the parent, no dynamic load occurs.</p>
<pre>INSERT INTO orders VALUES(1,1, DATE &#39;2012-01-25&#39;, DATE &#39;2012-01-30&#39;);
</pre>
<p>The following <code>UPDATE</code> statement dynamically loads one cache instance from the cached Oracle Database table into the TimesTen cache table, updates the instance in the cache table, and then automatically propagates the update to the cached Oracle Database table:</p>
<pre>Command&gt; UPDATE oratt.customer SET name = &#39;Angela Peterson&#39; WHERE cust_num = 2;
Command&gt; SELECT * FROM oratt.customer;
&lt; 1, West, Frank Edwards, 100 Pine St., Portland OR &gt;
&lt; 2, East, Angela Peterson, 356 Olive St., Boston MA &gt;
</pre>
<p>The following is the updated data in the <code>oratt.customer</code> cached Oracle Database table:</p>
<pre>CUST_NUM   REGION    NAME              ADDRESS
--------   -------   ---------------   ---------------------------    
       1   West      Frank Edwards     100 Pine St., Portland OR
       2   East      Angela Peterson   356 Olive St., Boston MA
       3   Midwest   Stephen Johnson   7638 Walker Dr., Chicago IL
</pre>
<p>The following <code>DELETE</code> statement dynamically loads one cache instance from the cached Oracle Database table into the TimesTen cache table, deletes the instance from the cache table, and then automatically propagates the delete to the cached Oracle Database table:</p>
<pre>Command&gt; DELETE FROM oratt.customer WHERE cust_num = 3;
Command&gt; SELECT * FROM oratt.customer;
&lt; 1, West, Frank Edwards, 100 Pine St., Portland OR &gt;
&lt; 2, East, Angela Peterson, 356 Olive St., Boston MA &gt;
</pre>
<p>The following is the updated data in the <code>oratt.customer</code> cached Oracle Database table.</p>
<pre>CUST_NUM   REGION    NAME              ADDRESS
--------   -------   ---------------   ---------------------------    
       1   West      Frank Edwards     100 Pine St., Portland OR
       2   East      Angela Peterson   356 Olive St., Boston MA
</pre>
<p>The following is an example of a dynamic load performed using all columns of a unique index on the root table. The <code>departments</code> table is defined in a dynamic AWT cache group. A unique index is created on this cache group consisting of the <code>manager_id</code> and <code>location_id</code>.</p>
<p>The following creates the departments table on the Oracle database.</p>
<pre>Command&gt; CREATE TABLE departments(
       &gt; department_id INT NOT NULL PRIMARY KEY,
       &gt; department_name VARCHAR(10) NOT NULL,
       &gt; technical_lead INT NOT NULL,
       &gt; manager_id INT,
       &gt; location_id INT NOT NULL);
</pre>
<p>The following creates the dynamic AWT cache group and a unique index on the <code>dept_cg</code> root table:</p>
<pre>Command&gt; CREATE DYNAMIC ASYNCHRONOUS WRITETHROUGH CACHE GROUP dept_cg
       &gt; FROM departments
       &gt; (department_id INT NOT NULL PRIMARY KEY, 
       &gt;  department_name VARCHAR(10) NOT NULL, 
       &gt;  technical_lead INT NOT NULL, 
       &gt;  manager_id INT, location_id INT NOT NULL);

Command&gt; CREATE UNIQUE INDEX dept_idx ON departments(manager_id, location_id);
</pre>
<p>The following inserts three records into the departments table on the Oracle database:</p>
<pre>Command&gt; insert into departments values (1, &#39;acct&#39;, 1, 1, 100);
1 row inserted.
Command&gt; insert into departments values (2, &#39;legal&#39;, 2, 2, 200);
1 row inserted.
Command&gt; insert into departments values (3, &#39;owner&#39;, 3, NULL, 300);
1 row inserted.
Command&gt; commit;
</pre>
<p>On TimesTen, dynamically load a cache instance based on the unique index:</p>
<pre>Command&gt; SELECT * FROM departments;
0 rows found.
Command&gt; SELECT * FROM departments WHERE manager_id IS NULL AND location_id=300;
&lt; 3, owner, 3, &lt;NULL&gt;, 300 &gt;
1 row found.
Command&gt; SELECT * FROM departments;
&lt; 3, owner, 3, &lt;NULL&gt;, 300 &gt;
1 row found.
Command&gt; SELECT * FROM departments WHERE manager_id=2 AND location_id=200;
&lt; 2, legal, 2, 2, 200 &gt;
1 row found.
Command&gt; SELECT * FROM departments;
&lt; 2, legal, 2, 2, 200 &gt;
&lt; 3, owner, 3, &lt;NULL&gt;, 300 &gt;
2 rows found.
</pre>
<p>The following examples demonstrate how to use dynamic load when referencing tables across multiple cache groups, which is enabled when <code>DynamicLoadEnable</code> is set to 2.</p>
<p>The following statements create multiple dynamic AWT cache groups, each with one or more tables that are cached from the Oracle database.</p>
<pre>CREATE DYNAMIC CACHE GROUP cachegrp 
 FROM table1(x1 INT PRIMARY KEY, y1 INT);

CREATE DYNAMIC CACHE GROUP cachegrp2 
 FROM table2(x2 INT PRIMARY KEY, y2 INT), 
 table3(x3 INT PRIMARY KEY, y3 INT, 
 FOREIGN KEY(y3) REFERENCES table2(x2);

CREATE DYNAMIC CACHE GROUP cachegrp3 
FROM table4(x4 INT PRIMARY KEY, y4 INT);

CREATE TABLE table5
 (x5 INT PRIMAY KEY,y5 INT);
</pre>
<p>The following example shows that no dynamic load occurs, even though the optimizer may derive that <code>x1</code> should be equated to 1:</p>
<pre>SELECT * FROM table1, table5 WHERE x5=1 AND x5=x1;
</pre>
<p>Dynamic load is considered for the cache instance from <code>table2</code> within <code>cachegrp2</code> since <code>table2</code> is referenced in the main query.</p>
<pre>SELECT * FROM table5, table2 
 WHERE x5 IN (SELECT y2 FROM table2, table3 where x2=1 and x2=y3);
</pre>
<p>The cache instance in the <code>cachegrp2</code> cache group is not considered for a dynamic load because all of its tables are referenced in the subquery.</p>
<pre>SELECT * FROM table5 
 WHERE x5 IN 
 (SELECT y3 FROM table2, table3 WHERE x2=1 AND x2=y3);
</pre>
<p>In the following example, if the row that would be retrieved from <code>table1</code> where <code>x1=1</code> is not already in the cache, whether the cache instance from <code>table1</code> is loaded depends on the join order. If the join order is &#39;<code>table5 table1</code>,&#39; the cache instance from <code>table1</code> is loaded if and only if there is a row in <code>table5</code> for which <code>x5=1</code>. If the join order is &#39;<code>table1 table5</code>&#39;, then the cache instance from <code>table1</code> is always loaded.</p>
<pre>SELECT * FROM table1, table5 WHERE x1=1 AND x5=1;  
</pre>
<p>A row (1,1) may be loaded for <code>table1</code>, but the <code>SELECT</code> does not return any rows.</p>
<pre>SELECT * FROM table1 WHERE x1=1 AND y1&gt;1;
</pre></div>
<!-- class="sect2" -->
<a id="CJABAECJ"></a>
<div id="TTCAC501" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Return dynamic load errors</h3>
<p>You can configure TimesTen to return an error if<a id="sthref433"></a> a <code>SELECT</code>, <code>UPDATE</code> or <code>DELETE</code> statement does not meet the requirements stated in <a href="#CJAEFIBA">&#34;Dynamic load guidelines&#34;</a>. The <a id="sthref434"></a><a id="sthref435"></a><code>DynamicLoadErrorMode</code> connection attribute controls what happens when an application executes a SQL operation against a dynamic cache group and the SQL operation cannot use dynamic load in a particular connection.</p>
<ul>
<li>
<p>When <code>DynamicLoadErrorMode</code> is set to a value of 0, dynamic load happens to any cache group referenced in the query that is qualified for dynamic load. Cache groups that do not qualify are not dynamically loaded and no errors are returned. When <code>DynamicLoadEnable=1</code>, no dynamic load occurs if the query references more than one cache group.</p>
</li>
<li>
<p>When <code>DynamicLoadErrorMode</code> is set to a value of 1, a query fails with an error if any dynamic cache group referenced in the query is not qualified for dynamic load. The error indicates the reason why the dynamic load cannot occur.</p>
</li>
</ul>
<p>To set the connection attribute solely for a particular transaction, use one of the following:</p>
<ul>
<li>
<p>Use the <code>ttIsql</code> utility <a id="sthref436"></a><code>set dynamicloaderrormode 1</code> command.</p>
</li>
<li>
<p>Call the <code>ttOptSetFlag</code> built-in procedure with the <a id="sthref437"></a><code>DynamicLoadErrorMode</code> flag and the optimizer value set to 1.</p>
<pre>call ttOptSetFlag(&#39;DynamicLoadErrorMode&#39;, 1)
</pre>
<p>Call the <code>ttOptSetFlag</code> built-in procedure with the <code>DynamicLoadErrorMode</code> flag and the optimizer value set to 0 to suppress error reporting when a statement does not comply with dynamic load requirements.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDBGBBG"></a>
<div id="TTCAC286" class="sect1">
<h2 class="sect1">Flushing a user managed cache group<a id="sthref438"></a></h2>
<p>The <code>FLUSH CACHE GROUP</code> statement manually propagates committed inserts and updates on TimesTen cache tables in a user managed cache group to the cached Oracle Database tables. Deletes are not flushed or manually propagated. Committed inserts and updates on cache tables that use the <code>PROPAGATE</code> cache table attribute cannot be flushed to the cached Oracle Database tables because these operations are already automatically propagated to the Oracle database.</p>
<p>With automatic propagation, committed inserts, updates and deletes are propagated to the Oracle database in the order they were committed in TimesTen. A flush operation can manually propagate multiple committed transactions on cache tables to the cached Oracle Database tables.</p>
<p>You cannot flush a user managed cache group that uses the <code>AUTOREFRESH</code> cache group attribute.</p>
<p>You can flush a user managed cache group if at least one of its cache tables uses neither the <code>PROPAGATE</code> nor the <code>READONLY</code> cache table attribute.</p>
<p>You can use a <code>WHERE</code> clause or <code>WITH ID</code> clause in a <code>FLUSH CACHE GROUP</code> statement to restrict the rows to be flushed to the cached Oracle Database tables. See the <a class="olink TTSQL319" href="../TTSQL/state.htm#TTSQL319">&#34;FLUSH CACHE GROUP&#34;</a> statement in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span> for more information.</p>
<div id="TTCAC287" class="example">
<p class="titleinexample"><a id="sthref439"></a>Example 5-8 <a id="sthref440"></a>Flushing a cache group</p>
<p>The following statement manually propagates committed insert and update operations on the TimesTen cache tables in the <code>western_customers</code> cache group to the cached Oracle Database tables:</p>
<pre>FLUSH CACHE GROUP western_customers;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="CHDCFAID"></a>
<div id="TTCAC288" class="sect1">
<h2 class="sect1">Unloading a cache group<a id="sthref441"></a></h2>
<p>You can delete some or all cache instances from the cache tables in a cache group with the <code>UNLOAD CACHE GROUP</code> statement. Unlike the <code>DROP CACHE GROUP</code> statement, the cache tables themselves are not dropped when a cache group is unloaded.</p>
<p>Use caution when using the <code>UNLOAD CACHE GROUP</code> statement with autorefresh cache groups. An unloaded row can reappear in the cache table as the result of an autorefresh operation if the row, or its related parent or child rows, are updated in the cached Oracle Database table.</p>
<p>Execution of the <code>UNLOAD CACHE GROUP</code> statement for an AWT cache group waits until updates on the rows have been propagated to the Oracle database.</p>
<p>To prevent an unload operation from processing a large number of cache instances within a single transaction, which could reduce concurrency and throughput, use the <code>COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> clause to specify a commit frequency.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information, see &#34;<a class="olink TTSQL335" href="../TTSQL/state.htm#TTSQL335">UNLOAD CACHE GROUP</a>&#34; in the <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</div>
<div id="TTCAC289" class="example">
<p class="titleinexample"><a id="sthref442"></a>Example 5-9 <a id="sthref443"></a>Unloading cache groups</p>
<p>The following statement unloads all cache instances from all cache tables in the <code>customer_orders</code> cache group. A commit frequency is specified, so the operations is performed over several transactions by committing every 256 rows:</p>
<pre>UNLOAD CACHE GROUP customer_orders COMMIT EVERY 256 ROWS;
</pre>
<p>The following statement unloads all cache instances from all cache tables in the <code>customer_orders</code> cache group in a single transaction. A single transaction should only be used if the data within <code>customer_orders</code> is small:</p>
<pre>UNLOAD CACHE GROUP customer_orders;
</pre>
<p>The following equivalent statements delete the cache instance for customer number 227 from the cache tables in the <code>new_customers</code> cache group:</p>
<pre>UNLOAD CACHE GROUP new_customers WITH ID (227);
UNLOAD CACHE GROUP new_customers WHERE (oratt.customer.cust_num = 227);
</pre></div>
<!-- class="example" -->
<a id="CIHGFBHC"></a>
<div id="TTCAC425" class="sect2">
<h3 class="sect2">Unloading a cache group across all grid members<a id="sthref444"></a><a id="sthref445"></a><a id="sthref446"></a></h3>
<p>You can unload a cache group in all members of a cache grid by setting an optimizer flag. Before executing the <code>UNLOAD CACHE GROUP</code> statement, call the <code>ttOptSetFlag</code> built-in procedure and set the <code>GlobalProcessing</code> optimizer flag to 1:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The unload operation does not execute across multiple grid nodes when using the <code>COMMIT EVERY</code> <code><span class="codeinlineitalic">n</span></code> <code>ROWS</code> clause, regardless of the state of the <code>GlobalProcessing</code> optimizer flag.</div>
<pre>CALL ttOptSetFlag(&#39;GlobalProcessing&#39;, 1);
</pre>
<p>Consider this statement:</p>
<pre>UNLOAD CACHE GROUP customer WHERE customer_id=54321;
</pre>
<p>A local unload operation removes the customer record only if the record exists on the node where the statement is executed. A global unload operation removes the customer record regardless of which node contains the record.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<div id="TTCAC290" class="sect1"><!-- infolevel="all" infotype="General" --><a id="sthref447"></a>
<h2 class="sect1">Determining the number of cache instances affected by an operation</h2>
<p>You can use the following mechanisms to determine how many cache instances were loaded by a <code>LOAD CACHE GROUP</code> statement, refreshed by a <code>REFRESH CACHE GROUP</code> statement, flushed by a <code>FLUSH CACHE GROUP</code> statement, or unloaded by an <code>UNLOAD CACHE GROUP</code> statement:</p>
<ul>
<li>
<p>Call the <a id="sthref448"></a><code>SQLRowCount()</code> ODBC function.</p>
</li>
<li>
<p>Invoke the <a id="sthref449"></a><code>Statement.getUpdateCount()</code> JDBC method.</p>
</li>
<li>
<p>Call the <a id="sthref450"></a><code>OCIAttrGet()</code> OCI function with the <code>OCI_ATTR_ROW_COUNT</code> option.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDDEJAE"></a>
<div id="TTCAC291" class="sect1">
<h2 class="sect1">Setting a passthrough level<a id="sthref451"></a><a id="sthref452"></a><a id="sthref453"></a></h2>
<p>When an application issues statements on a TimesTen connection, the statement can be executed in the TimesTen database or passed through to the Oracle database for execution. Whether the statement is executed in the TimesTen or Oracle database depends on the composition of the statement and the setting of the <code>PassThrough</code> connection attribute. You can set the <code>PassThrough</code> connection attribute to define which statements are to be executed locally in TimesTen and which are to be redirected to the Oracle database for execution.</p>
<p>When appropriate within passthrough levels 1 through 5, TimesTen connects to the Oracle database using the current user&#39;s credentials as the user name and the <code>OraclePwd</code> connection attribute as the Oracle password.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A <a id="sthref454"></a>transaction that contains operations that are replicated with <code>RETURN TWOSAFE</code> cannot have a <code>PassThrough</code> setting greater than 0. If <code>PassThrough</code> is greater than 0, an error is returned and the transaction must be rolled back.
<p>When <code>PassThrough</code> is set to 0, 1, or 2, the following behavior occurs when a dynamic load condition exists:</p>
<ul>
<li>
<p>A dynamic load can occur for a <code>SELECT</code> operation on cache tables in any dynamic cache group type.</p>
</li>
<li>
<p>A dynamic load for an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> operation can only occur on cached tables with dynamic AWT or SWT cache groups.</p>
</li>
</ul>
<p>See <a href="#CJAGAAHE">&#34;Dynamically loading a cache instance&#34;</a> for more details on dynamic load.</p>
</div>
<div id="TTCAC433" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref455"></a>
<h3 class="sect2">PassThrough=0</h3>
<p><code>PassThrough</code>=0 is the default setting and specifies that all statements are to be executed in the TimesTen database. <a href="#CIHDJEHA">Figure 5-1</a> shows that Table A is updated on the TimesTen database. Table F cannot be updated because it does not exist in TimesTen.</p>
<div id="TTCAC434" class="figure">
<p class="titleinfigure"><a id="CIHDJEHA"></a>Figure 5-1 PassThrough=0</p>
<img width="258" height="369" src="img/passthrough0.gif" alt="Description of Figure 5-1 follows"/><br/>
<a id="sthref456" href="img_text/passthrough0.htm">Description of &#34;Figure 5-1 PassThrough=0&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="TTCAC435" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref457"></a>
<h3 class="sect2">PassThrough=1</h3>
<p>Set <code>PassThrough</code>=1 to specify that a statement that references a table that does not exist in the TimesTen database is passed through to the Oracle database for execution. No DDL statements are passed through to the Oracle database.</p>
<p>If TimesTen cannot parse a <code>SELECT</code> statement because it includes keywords that do not exist in TimesTen SQL or because it includes syntax errors, it passes the statement to the Oracle database. If TimesTen cannot parse <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code> statements, TimesTen returns an error and the statement is not passed through to the Oracle database.</p>
<p><a href="#CIHGFHCI">Figure 5-2</a> shows that Table A is updated in the TimesTen database, while Table G is updated in the Oracle database because Table G does not exist in the TimesTen database.</p>
<div id="TTCAC436" class="figure">
<p class="titleinfigure"><a id="CIHGFHCI"></a>Figure 5-2 PassThrough=1</p>
<img width="238" height="374" src="img/passthrough1.gif" alt="Description of Figure 5-2 follows"/><br/>
<a id="sthref458" href="img_text/passthrough1.htm">Description of &#34;Figure 5-2 PassThrough=1&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="TTCAC437" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref459"></a>
<h3 class="sect2">PassThrough=2</h3>
<p><code>PassThrough</code>=2 specifies that <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> statements are passed through to the Oracle database for read-only cache groups and user managed cache groups that use the <code>READONLY</code> cache table attribute. Otherwise, <code>Passthrough</code>=1 behavior applies.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You are responsible in preventing conflicts that may occur if you update the same row in a TimesTen cache table as another user updates the cached Oracle Database table concurrently.</div>
<p><a href="#CIHJDAAJ">Figure 5-3</a> shows that updates to Table A and Table G in a read-only cache group are passed through to the Oracle database.</p>
<div id="TTCAC438" class="figure">
<p class="titleinfigure"><a id="CIHJDAAJ"></a>Figure 5-3 PassThrough=2</p>
<img width="249" height="460" src="img/passthrough2.gif" alt="Description of Figure 5-3 follows"/><br/>
<a id="sthref460" href="img_text/passthrough2.htm">Description of &#34;Figure 5-3 PassThrough=2&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="TTCAC439" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref461"></a>
<h3 class="sect2">PassThrough=3</h3>
<p><code>PassThrough</code>=3 specifies that all statements are passed through to the Oracle database for execution, except that <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> statements issued on cache tables in a dynamic AWT global cache group result in a TimesTen error.</p>
<p><a href="#CIHGEEDJ">Figure 5-4</a> shows that Table A is updated on the Oracle database for a read-only or updatable cache group. A <code>SELECT</code> statement that references Table G is also passed through to the Oracle database. A <code>SELECT</code> statement that references Table C in a dynamic AWT global cache group is passed through to the Oracle database.</p>
<div id="TTCAC440" class="figure">
<p class="titleinfigure"><a id="CIHGEEDJ"></a>Figure 5-4 PassThrough=3</p>
<img width="404" height="434" src="img/passthrough3.gif" alt="Description of Figure 5-4 follows"/><br/>
<a id="sthref462" href="img_text/passthrough3.htm">Description of &#34;Figure 5-4 PassThrough=3&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="TTCAC441" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref463"></a>
<h3 class="sect2">PassThrough=4</h3>
<p><code>PassThrough</code>=4 specifies that <code>SELECT</code> statements issued on cache tables in a dynamic AWT global cache group that do not satisfy the criteria for a dynamic load query are passed through to the Oracle database for execution. Otherwise, statements are executed in the TimesTen database. See <a href="#CJAEFIBA">&#34;Dynamic load guidelines&#34;</a> for the criteria for a dynamic load <code>SELECT</code> statement.</p>
<p><a href="#CIHIHGDH">Figure 5-5</a> shows that Table A in an updatable cache group is updated in the TimesTen database. The figure also shows a <code>SELECT</code> statement issued on a dynamic AWT global cache group that does not satisfy the criteria for a dynamic load <code>SELECT</code> statement and is passed through to the Oracle database for execution.</p>
<div id="TTCAC442" class="figure">
<p class="titleinfigure"><a id="CIHIHGDH"></a>Figure 5-5 PassThrough=4</p>
<img width="441" height="393" src="img/passthrough4.gif" alt="Description of Figure 5-5 follows"/><br/>
<a id="sthref464" href="img_text/passthrough4.htm">Description of &#34;Figure 5-5 PassThrough=4&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="TTCAC443" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref465"></a>
<h3 class="sect2">PassThrough=5</h3>
<p><code>PassThrough</code>=5 specifies that <code>SELECT</code> statements issued on cache tables in a dynamic AWT global cache group that do not satisfy the criteria for a dynamic load query are passed through to the Oracle database for execution when all committed updates on cache tables in dynamic AWT global cache groups by previous transactions within the connection have been propagated to the Oracle database. Otherwise statements are executed in the TimesTen database. See <a href="#CJAEFIBA">&#34;Dynamic load guidelines&#34;</a> for the criteria for a dynamic load <code>SELECT</code> statement.</p>
<p><a href="#CIHIBGBF">Figure 5-6</a> shows that Table A in an updatable cache group is updated in the TimesTen database. The figure also shows a <code>SELECT</code> statement issued on a dynamic AWT global cache group that does not satisfy the criteria for a dynamic load <code>SELECT</code> statement and is passed through to the Oracle database for execution after all committed updates on cache tables in dynamic AWT global cache groups by previous transactions within the connection have been propagated to the Oracle database.</p>
<div id="TTCAC444" class="figure">
<p class="titleinfigure"><a id="CIHIBGBF"></a>Figure 5-6 PassThrough=5</p>
<img width="441" height="445" src="img/passthrough5.gif" alt="Description of Figure 5-6 follows"/><br/>
<a id="sthref466" href="img_text/passthrough5.htm">Description of &#34;Figure 5-6 PassThrough=5&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="TTCAC445" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref467"></a>
<h3 class="sect2">Considerations for using passthrough</h3>
<p>Passing through update operations to the Oracle database for execution is not recommended when issued on cache tables in an AWT or SWT cache group.</p>
<ul>
<li>
<p>Committed updates on cache tables in an AWT cache group are automatically propagated to the cached Oracle Database tables in asynchronous fashion. However, passing through an update operation to the Oracle database for execution within the same transaction as the update on the cache table in the AWT cache group renders the propagate of the cache table update synchronous, which may have undesired results.</p>
</li>
<li>
<p>Committed updates on cache tables in an SWT cache group can result in self-deadlocks if, within the same transaction, updates on the same tables are passed through to the Oracle database for execution.</p>
</li>
</ul>
<p>A PL/SQL block cannot be passed through to the Oracle database for execution. Also, you cannot pass through to Oracle Database for execution a reference to a stored procedure or function that is defined in the Oracle database but not in the TimesTen database.</p>
<p>For more information about how the <code>PassThrough</code> connection attribute setting determines which statements are executed in the TimesTen database and which are passed through to the Oracle database for execution and under what circumstances, see <a class="olink TTREF211" href="../TTREF/attribute.htm#TTREF211">&#34;PassThrough&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The passthrough feature uses OCI to communicate with the Oracle database. The OCI diagnostic framework installs signal handlers that may impact signal handling that you use in your application. You can disable OCI signal handling by setting <code>DIAG_SIGHANDLER_ENABLED=FALSE</code> in the <code>sqlnet.ora</code> file. Refer to <a class="olink LNOCI1020" href="../LNOCI/oci10new.htm#LNOCI1020">&#34;Fault Diagnosability in OCI&#34;</a> in <span class="italic">Oracle Call Interface Programmer&#39;s Guide</span> for information.</div>
</div>
<!-- class="sect2" -->
<div id="TTCAC293" class="sect2"><a id="sthref468"></a>
<h3 class="sect2">Changing the passthrough level for a connection or transaction<a id="sthref469"></a></h3>
<p>You can override the current passthrough level using the <code>ttIsql</code> utility&#39;s <a id="sthref470"></a><code>set passthrough</code> command which applies to the current transaction.</p>
<p>You can also override the setting for a specific transaction by calling the <code>ttOptSetFlag</code> built-in procedure with the <a id="sthref471"></a><code>PassThrough</code> flag. The following procedure call sets the passthrough level to 3:</p>
<pre>CALL ttOptSetFlag(&#39;PassThrough&#39;, 3);
</pre>
<p>The <code>PassThrough</code> flag setting takes effect when a statement is prepared and it is the setting that is used when the statement is executed even if the setting has changed from the time the statement was prepared to when the statement is executed. After the transaction has been committed or rolled back, the original connection setting takes effect for all subsequently prepared statements.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5343">
<tr>
<td class="cellalignment5350">
<table class="cellalignment5348">
<tr>
<td class="cellalignment5347"><a href="define.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5347"><a href="gridmembers.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2012, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5352">
<table class="cellalignment5346">
<tr>
<td class="cellalignment5347"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5347"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5347"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5347"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5347"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5347"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>