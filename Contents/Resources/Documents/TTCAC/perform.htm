<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-107440"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Cache%20Performance"></a><title>Cache Performance</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 726"/>
<meta name="dcterms.created" content="2014-09-23T15:6:31Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen Application-Tier Database Cache User&#39;s Guide"/>
<meta name="dcterms.identifier" content="E21634-12"/>
<meta name="dcterms.isVersionOf" content="TTCAC"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2012, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="manage.htm" title="Previous" type="text/html"/>
<link rel="Next" href="cleanup.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21634-12.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/21</span> <!-- End Header -->
<div id="TTCAC410" class="chapter"><a id="sthref612"></a>
<h1 class="chapter"><span class="secnum">8</span> Cache Performance</h1>
<p>The following sections contain information about cache performance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<p>See <span class="italic">Oracle TimesTen In-Memory Database Troubleshooting Guide</span> for extensive information about monitoring autorefresh operations and improving autorefresh performance. See <a class="olink TTTRB247" href="../TTTRB/cache_trouble.htm#TTTRB247">&#34;Monitoring autorefresh cache groups&#34;</a> and <a class="olink TTTRB268" href="../TTTRB/cache_trouble.htm#TTTRB268">&#34;Poor autorefresh performance&#34;</a>.</p>
<p><span class="italic">Oracle TimesTen In-Memory Database Troubleshooting Guide</span> also has information about AWT cache group performance. See <a class="olink TTTRB277" href="../TTTRB/awt_trouble.htm#TTTRB277">&#34;Monitoring AWT performance&#34;</a> and <a class="olink TTTRB278" href="../TTTRB/awt_trouble.htm#TTTRB278">&#34;Possible causes of poor AWT performance&#34;</a>.</p>
</div>
<ul>
<li>
<p><a href="#BABGGDEC">Dynamic load performance</a></p>
</li>
<li>
<p><a href="#BABCFCFG">Improving AWT throughput</a></p>
</li>
<li>
<p><a href="#BABFDHHD">Improving performance when using incremental autorefresh for read-only cache groups</a></p>
</li>
<li>
<p><a href="#BABFFBCC">Improving performance when reclaiming memory during autorefresh operations</a></p>
</li>
<li>
<p><a href="#BABHBIIC">Retrieving statistics on autorefresh transactions</a></p>
</li>
<li>
<p><a href="#BABEIHEA">Caching the same Oracle table on two or more TimesTen databases</a></p>
</li>
</ul>
<a id="BABGGDEC"></a>
<div id="TTCAC411" class="sect1">
<h2 class="sect1">Dynamic load performance</h2>
<p>Dynamic loading based on a primary key search of the root table has faster performance than primary key searches on a child table or foreign key searches on a child table. For more details, see <a href="operations.htm#CJAGAAHE">&#34;Dynamically loading a cache instance&#34;</a>.</p>
</div>
<!-- class="sect1" -->
<a id="BABCFCFG"></a>
<div id="TTCAC412" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Improving AWT throughput<a id="sthref613"></a></h2>
<p>Use the following methods to improve through put for AWT cache groups:</p>
<ul>
<li>
<p><a href="#BABDHIEG">Improving AWT throughput with parallel propagation</a></p>
</li>
<li>
<p><a href="#BABIAFIJ">Improving AWT throughput with SQL array execution</a></p>
</li>
</ul>
<a id="BABDHIEG"></a>
<div id="TTCAC539" class="sect2">
<h3 class="sect2">Improving AWT throughput with <a id="sthref614"></a><a id="sthref615"></a><a id="sthref616"></a>parallel propagation</h3>
<p>To improve throughput for an AWT cache group, you can configure multiple threads that act in parallel to propagate and apply transactional changes to the Oracle database. Parallel propagation enforces transactional dependencies and applies changes in AWT cache tables to Oracle Database tables in commit order. For full details, see <a href="define.htm#CHDEIHHI">&#34;Configuring parallel propagation to Oracle Database tables&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABIAFIJ"></a>
<div id="TTCAC540" class="sect2">
<h3 class="sect2">Improving AWT throughput with SQL array execution</h3>
<p>By default, an AWT cache group uses the PL/SQL execution method to apply changes within TimesTen to the Oracle database. AWT bundles all pending operations into a single PL/SQL collection that is sent to the Oracle database server to be executed. This execution method is appropriate when there are mixed transactions and network latency between TimesTen and the Oracle database server.</p>
<p>Use the <code>CacheAWTMethod</code> first connection attribute to specify SQL array execution to apply changes within TimesTen to the Oracle database. This method is appropriate when the same type of operation is repeated. For example, SQL array execution is very efficient when a user does an update that affects several rows of the table. Updates are grouped together and sent to the Oracle database server in one batch.</p>
<p>The PL/SQL execution method transparently falls back to SQL array execution mode temporarily when it encounters one of the following:</p>
<ul>
<li>
<p>A statement that is over 32761 bytes in length.</p>
</li>
<li>
<p>A statement that references a column of type <code>BINARY FLOAT</code>, <code>BINARY DOUBLE</code> and <code>VARCHAR/VARBINARY</code> of length greater than 4000 bytes.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can also set this value with the <code>ttDBConfig</code> built-in procedure with the <code>CacheAwtMethod</code> parameter. For details, see <a class="olink TTREF795" href="../TTREF/proced.htm#TTREF795">&#34;ttDBConfig&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
<p>For more information, see <a class="olink TTREF722" href="../TTREF/attribute.htm#TTREF722">&#34;CacheAWTMethod&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFDHHD"></a>
<div id="TTCAC541" class="sect1">
<h2 class="sect1">Improving performance when using incremental autorefresh for read-only cache groups</h2>
<p>The following sections describe how to improve performance when you either have large transactions or join large tables when using incremental autorefresh for read-only cache groups:</p>
<ul>
<li>
<p><a href="#BABEGAIE">Improving execution of large transactions when using incremental autorefresh for read-only cache groups</a></p>
</li>
<li>
<p><a href="#BABJFCGG">Configuring a select limit when using incremental autorefresh for read-only cache groups</a></p>
</li>
</ul>
<a id="BABEGAIE"></a>
<div id="TTCAC510" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref617"></a><a id="sthref618"></a><a id="sthref619"></a><a id="sthref620"></a><a id="sthref621"></a>Improving<a id="sthref622"></a> execution of large <a id="sthref623"></a><a id="sthref624"></a><a id="sthref625"></a>transactions when using incremental autorefresh for read-only cache groups</h3>
<p>At certain times, you may execute large transactions, such as for the end of the month, the end of a quarter, or the end of the year transactions. You may also have situations where you modify or add a large amount of data in the Oracle database over a short period of time. For incremental autorefresh, read-only cache groups, TimesTen could potentially run out of permanent space when an autorefresh operation applies either one of these cases. Therefore, for these situations, you can configure an autorefresh transaction limit, where the large amount of data is broken up, applied, and committed over several smaller transactions.</p>
<p>The <code><a id="sthref626"></a>ttCacheAutorefreshXactLimit</code> built-in procedure enables you to direct autorefresh to commit after executing a specific number of operations. This option applies to all incremental autorefresh read-only cache groups that are configured with the same autorefresh interval.</p>
<p>Since the single transaction is broken up into several smaller transactions, transactional consistency cannot be maintained while autorefresh is in progress. Once the autorefresh cycle completes, the data is transactionally consistent. To protect instance consistency, we recommend that you set the autorefresh transaction limit only on cache groups with only a single table, since instance consistency between the parent and child tables is not guaranteed. When the autorefresh transaction limit is turned on, TimesTen does not enforce the foreign key relationship that protects instance consistency. Once you turn off the autorefresh transaction limit for incremental autorefresh read-only cache groups, both instance and transactional consistency are maintained again.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are using an active standby pair, you must call the <code>ttCacheAutorefreshXactLimit</code> built-in procedure for the same values on both the active and standby masters.</div>
<div id="TTCAC512" class="sect3"><a id="sthref627"></a>
<h4 class="sect3">Using ttCacheAutorefreshXactLimit</h4>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information, such as the syntax and the returned result set, see <a class="olink TTREF791" href="../TTREF/proced.htm#TTREF791">&#34;ttCacheAutorefreshXactLimit&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Replication Guide</span>.</div>
<p>For the month end processing, there can be a large number updates in a single transaction for the Oracle tables that are cached in autorefresh cache groups. In order to ensure that the large transaction does not fill up permanent memory, you can enable autorefresh to commit after every 256 (or any other user specified number) operations with the <code>ttCacheAutorefreshXactLimit</code> built-in procedure.</p>
<p>Turn on an autorefresh transaction limit for incremental autorefresh read-only cache groups before a large transaction with the <code>ttCacheAutorefreshXactLimit</code> built-in procedure where the <code><span class="codeinlineitalic">value</span></code> is set to <code>ON</code> or to a specific number of operations. Then, when autorefresh finishes updating the cached tables in TimesTen, turn off the autorefresh transaction limit for incremental autorefresh read-only cache groups with the <code>ttCacheAutorefreshXactLimit</code> built-in procedure.</p>
<p>The following example sets up the transaction limit to commit after every 256 operations for all incremental autorefresh read-only cache groups that are defined with an interval value of 10 seconds.</p>
<pre>call ttCacheAutorefreshXactLimit(&#39;10000&#39;, &#39;ON&#39;);
</pre>
<p>After the month end process has completed and the incremental autorefresh read-only cache groups are refreshed, disable the transaction limit for incremental autorefresh read-only cache groups that are defined with the interval value of 10 seconds.</p>
<pre>call ttCacheAutorefreshXactLimit(&#39;10000&#39;, &#39;OFF&#39;);
</pre>
<p>To enable the transaction limit for incremental autorefresh read-only cache groups to commit after every 1024 operations, provide 1024 as the value as follows:</p>
<pre>call ttCacheAutorefreshXactLimit(&#39;10000&#39;, &#39;1024&#39;);
</pre></div>
<!-- class="sect3" -->
<div id="TTCAC514" class="sect3"><a id="sthref628"></a>
<h4 class="sect3">Example of potential <a id="sthref629"></a>transactional inconsistency</h4>
<p>The following example uses the employee and departments table, where the department id of the department table is a foreign key that points to the department id of the employee table.</p>
<p>The following example creates two incremental autorefresh read-only cache groups, where each is in its own cache group. The autorefresh transaction limit is enabled with <code>ttCacheAutorefreshXactLimit</code> before a large transaction and is disabled after it completes.</p>
<ol>
<li>
<p>Before you initiate the large transaction, invoke <code>ttCacheAutorefreshXactLimit</code> to set the interval value and the number of operations after which to automatically commit. The following sets the number of operations to three (which is intentionally low to show a brief example) for all incremental autorefresh read-only cache groups with a two second interval.</p>
<pre>CALL ttCacheAutorefreshXactLimit(&#39;2000&#39;, &#39;3&#39;);
&lt; 2000, 3 &gt;
1 row found.
</pre></li>
<li>
<p>Create the incremental autorefresh read-only cache groups with interval of two seconds. This example creates two static (non-dynamic) read-only cache groups, where each contains a single table.</p>
<pre>CREATE READONLY CACHE GROUP cgDepts AUTOREFRESH MODE INCREMENTAL 
 INTERVAL 2 SECONDS 
FROM departments
    ( department_id    NUMBER(4) PRIMARY KEY
    , department_name  VARCHAR2(30) NOT NULL
    , manager_id       NUMBER(6)
    , location_id      NUMBER(4)
    );
 
CREATE READONLY CACHE GROUP cgEmpls AUTOREFRESH MODE INCREMENTAL 
 INTERVAL 2 SECONDS 
FROM employees
    ( employee_id    NUMBER(6) PRIMARY KEY
    , first_name     VARCHAR2(20)
    , last_name      VARCHAR2(25) NOT NULL
    , email          VARCHAR2(25) NOT NULL UNIQUE
    , phone_number   VARCHAR2(20)
    , hire_date      DATE NOT NULL
    , job_id         VARCHAR2(10) NOT NULL
    , salary         NUMBER(8,2)
    , commission_pct NUMBER(2,2)
    , manager_id     NUMBER(6)
    , department_id  NUMBER(4)
    );
</pre></li>
<li>
<p>Perform a manual <code>LOAD CACHE GROUP</code> for both autorefresh cache groups.</p>
<pre>LOAD CACHE GROUP cgDepts COMMIT EVERY 256 ROWS;
27 cache instances affected.
 
LOAD CACHE GROUP cgEmpls COMMIT EVERY 256 ROWS;
107 cache instances affected.
</pre></li>
</ol>
<p>You can have inconsistency within the table during an autorefresh as shown with the employees table.</p>
<ol>
<li>
<p>On TimesTen, select the minimum and maximum salary of all employees.</p>
<pre>SELECT MIN(salary), MAX(salary) FROM employees;
&lt; 2100, 24000 &gt;
1 row found.
</pre></li>
<li>
<p>On the Oracle database, add 100,000 to everyone&#39;s salary.</p>
<pre>UPDATE employees SET salary = salary + 100000;
107 rows updated.
</pre></li>
<li>
<p>On TimesTen, when you perform the <code>SELECT</code> again (while the autorefresh transactions are commmitted after every 3 records), it shows that while the maximum salary has updated, the minimum salary is still the old value.</p>
<pre>SELECT MIN(salary), MAX(salary) FROM employees;
&lt; 2100, 124000 &gt;
1 row found.
</pre></li>
<li>
<p>However, once the autorefresh completes, transactional consistency is maintained. For this example, once the autorefresh process completes, all salaries have increased by 100,000.</p>
<pre>SELECT MIN(salary), MAX(salary) FROM employees;
&lt; 102100, 124000 &gt;
1 row found.
</pre></li>
<li>
<p>The large transaction is complete, so disable the transaction limit for autorefresh cache groups with a 2 second interval.</p>
<pre>call ttCacheAutorefreshXactLimit(&#39;2000&#39;, &#39;OFF&#39;);
</pre></li>
</ol>
<p>You can have transactional inconsistency between cache groups if you perform a SQL statement while the autorefresh process is progressing. The following <code>SELECT</code> statement example executes against the employees and department table in the <code>cgDepts</code> autorefresh cache group. With this example, since the foreign key is not enforced on TimesTen and the autorefresh process applies several transactions, the employee table updates may be inserted before the department updates.</p>
<p>In addition, all of the updates for both tables in the cache group are not applied until the autorefresh cycle has completed. In the following example, the <code>SELECT</code> statement is executed before the autorefresh process is complete. Thus, the results do not show all of the expected data, such as the department name and several employees (some of the lawyers in the legal department 1000) are missing.</p>
<pre>SELECT e.department_id, d.DEPARTMENT_NAME, e.FIRST_NAME, e.LAST_NAME  
       FROM employees e, departments d         
       WHERE e.DEPARTMENT_ID  = d.DEPARTMENT_ID (+) 
       AND e.department_id &gt;= 1000 ORDER BY 1,2,3,4;
&lt; 1000, &lt;NULL&gt;, Alan, Dershowitz &gt;
&lt; 1000, &lt;NULL&gt;, F. Lee, Bailey &gt;
&lt; 1000, &lt;NULL&gt;, Johnnie, Cochran &gt;
3 rows found.
</pre>
<p>However, after the autorefresh process completes, transactional consistency is maintained. The following shows the same <code>SELECT</code> statement executed after the autorefresh is complete. All expected data, the department information and all of the new lawyers, are updated.</p>
<pre>SELECT e.department_id, d.DEPARTMENT_NAME, e.FIRST_NAME, e.LAST_NAME  
       FROM employees e, departments d         
       WHERE e.DEPARTMENT_ID  = d.DEPARTMENT_ID (+) 
       AND e.department_id &gt;= 1000 ORDER BY 1,2,3,4;
&lt; 1000, Legal, Alan, Dershowitz &gt;
&lt; 1000, Legal, Barry, Scheck &gt;
&lt; 1000, Legal, F. Lee, Bailey &gt;
&lt; 1000, Legal, Johnnie, Cochran &gt;
&lt; 1000, Legal, Robert, Kardashian &gt;
&lt; 1000, Legal, Robert, Shapiro &gt;
6 rows found.
</pre>
<p>For autorefresh cache groups that have more than one table, you can also experience transactional inconsistency if you execute SQL statements while the autorefresh process is in progress.</p>
<ol>
<li>
<p>Initiate the transaction limit for incremental autorefresh cache groups of 2 seconds with the <code>ttCacheAutorefreshXactLimit</code> built-in procedure and create a single autorefresh cache group with two tables: the employees and departments tables.</p>
<pre>CALL ttCacheAutorefreshXactLimit(&#39;2000&#39;, &#39;3&#39;);
&lt; 2000, 3 &gt;
1 row found.
 
CREATE READONLY CACHE GROUP cgDeptEmpls AUTOREFRESH MODE INCREMENTAL
 INTERVAL 2 SECONDS 
FROM departments
     ( department_id    NUMBER(4) PRIMARY KEY
     , department_name  VARCHAR2(30) NOT NULL
     , manager_id       NUMBER(6)
     , location_id      NUMBER(4)
     )
   , employees
     ( employee_id    NUMBER(6) PRIMARY KEY
     , first_name     VARCHAR2(20)
     , last_name      VARCHAR2(25) NOT NULL
     , email          VARCHAR2(25) NOT NULL UNIQUE
     , phone_number   VARCHAR2(20)
     , hire_date      DATE NOT NULL
     , job_id         VARCHAR2(10) NOT NULL
     , salary         NUMBER(8,2)
     , commission_pct NUMBER(2,2)
     , manager_id     NUMBER(6)
     , department_id  NUMBER(4)
     , foreign key(department_id) references departments(department_id)
     );
</pre></li>
<li>
<p>Manually load the cache group.</p>
<pre>LOAD CACHE GROUP cgDeptEmpls COMMIT EVERY 256 ROWS;
27 cache instances affected.
</pre></li>
<li>
<p>Perform a <code>SELECT</code> statement on TimesTen that uploads all of the legal department data.</p>
<pre>SELECT e.department_id, d.department_name, count(*)
       FROM employees e, departments d         
       WHERE e.department_id  = d.department_id (+) 
       GROUP BY e.department_id, d.department_name
       ORDER BY 1 desc;
&lt; 110, Accounting, 2 &gt;
&lt; 100, Finance, 6 &gt;
&lt; 90, Executive, 3 &gt;
&lt; 80, Sales, 34 &gt;
&lt; 70, Public Relations, 1 &gt;
&lt; 60, IT, 5 &gt;
&lt; 50, Shipping, 45 &gt;
&lt; 40, Human Resources, 1 &gt;
&lt; 30, Purchasing, 6 &gt;
&lt; 20, Marketing, 2 &gt;
&lt; 10, Administration, 1 &gt;
11 rows found.
</pre></li>
<li>
<p>On Oracle, insert a new legal department, numbered 1000, with 6 new lawyers in both the employee and department tables.</p>
</li>
<li>
<p>When performing a <code>SELECT</code> statement on TimesTen during the autorefresh process, only data on two of the lawyers in department 1000 have been uploaded into TimesTen.</p>
<pre>SELECT e.department_id, d.department_name, count(*)
       FROM employees e, departments d         
       WHERE e.department_id  = d.department_id (+) 
       GROUP BY e.department_id, d.department_name
       ORDER BY 1 desc;
&lt; 1000, Legal, 2 &gt;
&lt; 110, Accounting, 2 &gt;
&lt; 100, Finance, 6 &gt;
&lt; 90, Executive, 3 &gt;
&lt; 80, Sales, 34 &gt;
&lt; 70, Public Relations, 1 &gt;
&lt; 60, IT, 5 &gt;
&lt; 50, Shipping, 45 &gt;
&lt; 40, Human Resources, 1 &gt;
&lt; 30, Purchasing, 6 &gt;
&lt; 20, Marketing, 2 &gt;
&lt; 10, Administration, 1 &gt;
12 rows found.
</pre></li>
<li>
<p>However, after the autorefresh process completes, all 6 employees (lawyers) in the legal department have been uploaded to TimesTen. Now, it is transactionally consistent.</p>
<pre>SELECT e.department_id, d.department_name, COUNT(*)
       FROM employees e, departments d         
       WHERE e.department_id  = d.department_id (+) 
       GROUP BY e.department_id, d.department_name
       ORDER BY 1 desc;
&lt; 1000, Legal, 6 &gt;
&lt; 110, Accounting, 2 &gt;
&lt; 100, Finance, 6 &gt;
&lt; 90, Executive, 3 &gt;
&lt; 80, Sales, 34 &gt;
&lt; 70, Public Relations, 1 &gt;
&lt; 60, IT, 5 &gt;
&lt; 50, Shipping, 45 &gt;
&lt; 40, Human Resources, 1 &gt;
&lt; 30, Purchasing, 6 &gt;
&lt; 20, Marketing, 2 &gt;
&lt; 10, Administration, 1 &gt;
12 rows found.
</pre></li>
<li>
<p>The large transaction is complete, so disable the transaction limit for autorefresh cache groups with a 2 second interval.</p>
<pre>call ttCacheAutorefreshXactLimit(&#39;2000&#39;, &#39;OFF&#39;);
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<div id="TTCAC532" class="sect3"><a id="sthref630"></a>
<h4 class="sect3">Retrieving statistics to evaluate performance when a transaction limit is set</h4>
<p>To see how a autorefresh transaction limit for a particular autorefresh interval is performing, you can retrieve statistics for the last 10 incremental autorefresh transactions for this autorefresh interval with the <code>ttCacheAutorefIntervalStatsGet</code> built-in procedure. See <a href="#BABHBIIC">&#34;Retrieving statistics on autorefresh transactions&#34;</a> for more information.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABJFCGG"></a>
<div id="TTCAC527" class="sect2">
<h3 class="sect2"><a id="sthref631"></a>Configuring<a id="sthref632"></a><a id="sthref633"></a><a id="sthref634"></a> a select limit when using incremental autorefresh for read-only cache groups</h3>
<p>To facilitate incremental autorefresh for read-only cache groups, TimesTen executes a table join query on both the Oracle database base table and its corresponding change log table to retrieve the incremental changes. However, if both tables are very large, the join query can be slow. In addition, if the Oracle database base table is continuously updated while the join-query is executing, you may receive the <code>ORA-01555</code> &ldquo;Snapshot too old&rdquo; error from a long-running autorefresh query.</p>
<p>To avoid this situation, you can configure incremental <a id="sthref635"></a><a id="sthref636"></a>autorefresh with a select limit, which joins the Oracle database base table with a limited number of rows from the autorefresh change log table. You can configure a select limit with the <code><a id="sthref637"></a>ttCacheAutorefreshSelectLimit</code> built-in procedure.</p>
<p>Autorefresh continues to apply changes to the cached table incrementally until all the rows in the autorefresh change log table have been applied. When there are no rows left to apply, the autorefresh thread sleeps for the rest of the interval period.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For details on the syntax, parameters, result set, and restrictions, see <a class="olink TTREF847" href="../TTREF/proced.htm#TTREF847">&#34;ttCacheAutorefreshSelectLimit&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
<p>For example, before a large transaction, you can call the <code>ttCacheAutorefreshSelectLimit</code> built-in procedure to set a select limit to 1000 rows for incremental autorefresh cache groups with an interval value of 10 seconds. The following example sets the <code><span class="codeinlineitalic">value</span></code> to <code>ON</code>.</p>
<pre>Command&gt; call ttCacheAutorefreshSelectLimit(&#39;10000&#39;, &#39;ON&#39;);
&lt; 10000, ON &gt;
1 row found.
</pre>
<p>The following example set a select limit to 2000 rows for incremental autorefresh cache groups with an interval value of 7 seconds.</p>
<pre>Command&gt; call ttCacheAutorefreshSelectLimit(&#39;7000&#39;, &#39;2000&#39;);
&lt; 7000, 2000 &gt;
1 row found.
</pre>
<p>You can disable any select limit for incremental autorefresh cache groups with an interval value of 10 seconds by setting the <code><span class="codeinlineitalic">value</span></code> to <code>OFF</code>.</p>
<pre>Command&gt; call ttCacheAutorefreshSelectLimit(&#39;10000&#39;, &#39;OFF&#39;);
&lt; 10000, OFF &gt;
1 row found.
</pre>
<p>To see how a select limit for a particular autorefresh interval is performing, you can retrieve statistics for incremental autorefresh transactions for this autorefresh interval. See <a href="#BABHBIIC">&#34;Retrieving statistics on autorefresh transactions&#34;</a> for more information.</p>
<a id="BABGDACA"></a>
<div id="TTCAC529" class="sect3">
<h4 class="sect3">How to determine the cache group name for a particular select limit</h4>
<p>To determine the interval for a cache group, use <code>ttIsql</code> and run the <code>cachegroups</code> command:</p>
<pre>&gt; cachegroups <span class="codeinlineitalic">cgowner.cgname</span>;
</pre>
<p>This returns all attributes for the <code><span class="codeinlineitalic">cgowner.cgname</span></code> cache group including the interval.</p>
<p>To determine which intervals have a select limit, you can run the following query on the Oracle database where <code><span class="codeinlineitalic">&lt;cacheAdminUser&gt;</span></code> is the cache administrator, <code><span class="codeinlineitalic">&lt;hostName&gt;</span></code> is the host name of the machine where the TimesTen database is located, <code><span class="codeinlineitalic">&lt;databaseFileName&gt;</span></code> is the database path taken from the <code>DataStore</code> attribute, and substitute the version number (such as 06) for the <code><span class="codeinlineitalic">xx</span></code>.</p>
<pre>SELECT * FROM &lt;<span class="italic">cacheAdminUser</span>&gt;.tt_<span class="codeinlineitalic">xx</span>_arinterval_params
 WHERE param=&#39;AutorefreshSelectEveryN&#39;
   AND host=&#39;&lt;<span class="italic">hostName</span>&gt;&#39;
   AND database like &#39;%&lt;<span class="italic">databaseFileName</span>&gt;%&#39;
 ORDER BY arinterval;
 
</pre>
<p>For example, if the cache administrator user name is <code>pat</code>, the host name is <code>myhost</code>, the database file name is <code>myTtDb</code>, and 06 is substituted for <code><span class="codeinlineitalic">xx</span></code> that is the TimesTen minor release number then:</p>
<pre>SELECT * FROM pat.tt_06_arinterval_params
 WHERE param=&#39;AutorefreshSelectEveryN&#39;
   AND host=&#39;myhost&#39;
   AND database like &#39;%myTtDb%&#39;
 ORDER BY arinterval;
</pre>
<p>The interval is stored in milliseconds.</p>
</div>
<!-- class="sect3" -->
<div id="TTCAC533" class="sect3"><a id="sthref638"></a>
<h4 class="sect3">Retrieving statistics to evaluate performance when using a select limit</h4>
<p>To see how a select limit for a particular autorefresh interval is performing, you can retrieve statistics for incremental autorefresh transactions for this autorefresh interval with the <code>ttCacheAutorefIntervalStatsGet</code> built-in procedure. See <a href="#BABHBIIC">&#34;Retrieving statistics on autorefresh transactions&#34;</a> for more information.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFFBCC"></a>
<div id="TTCAC525" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref639"></a><a id="sthref640"></a><a id="sthref641"></a><a id="sthref642"></a><a id="sthref643"></a>Impro<a id="sthref644"></a>ving performance when reclaiming memory during autorefresh operations</h2>
<p>As described <a class="olink TTOPR762" href="../TTOPR/trans.htm#TTOPR762">&#34;Transaction reclaim operations&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>, TimesTen resource cleanup occurs during the reclaim phase of a transaction commit. To improve performance, a number of transaction log records are cached in memory to reduce the need to access the transaction log on disk in the the commit buffer. However, TimesTen must access the transaction log on disk if the transaction is larger than the reclaim buffer.</p>
<p>When you are using autorefresh for your cache groups, the cache agent has its own reclaim buffer to manage the transactions that are committed within autorefresh operations. If the cache agent reclaim buffer is too small, the commit operations during autorefresh can take longer than expected as it must access the transaction log on disk. To avoid any performance issues, you can configure a larger reclaim buffer for the cache agent so that the cache agent can handle larger transactions in memory at reclaim time.</p>
<p>When using an active standy pair replication scheme to replicate autorefresh operations, the replication agent applies the same autorefresh operations as part of the replication. Thus, the replication agents on both the active and standby nodes have their own reclaim buffers that should be configured to be the same size or greater than the cache agent reclaim buffer.</p>
<p>The <code>ttDbConfig</code> built-in procedure provides the following parameters for setting the maximum size for the reclaim buffers for both the cache agent and the replication agent. (The memory for the reclaim buffers are allocated out of temporary memory.)</p>
<ul>
<li>
<p><code>CacheAgentCommitBufSize</code> sets the maximum size for the reclaim buffer for the cache agent.</p>
</li>
<li>
<p><code>RepAgentCommitBufSize</code> sets the maximum size for the reclaim buffer for the replication agent. You should configure the maximum size for the reclaim buffer on both the active and standby nodes. It is recommended that you set the size for the reclaim buffers to the same value on both nodes, but not required.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more details, see <a class="olink TTREF795" href="../TTREF/proced.htm#TTREF795">&#34;ttDbConfig&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
<p>To determine if you should increment the size for the cache agent reclaim buffer, evaluate the <code>CommitBufMaxReached</code> and <code>CommitBufNumOverflows</code> statistics provided by the <code>ttCacheAutorefIntervalStatsGet</code> built-in procedure. For more details, see <a href="#BABHBIIC">&#34;Retrieving statistics on autorefresh transactions.&#34;</a></p>
</div>
<!-- class="sect1" -->
<a id="BABHBIIC"></a>
<div id="TTCAC531" class="sect1">
<h2 class="sect1"><a id="sthref645"></a><a id="sthref646"></a><a id="sthref647"></a>Retrieving statistics on autorefresh transactions</h2>
<p>Call the <code>ttCacheAutorefIntervalStatsGet</code> built-in procedure for statistical information about the last 10 autorefresh cycles for a particular autorefresh interval defined for an incremental autorefresh read-only cache group.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information on syntax and the returned result set for this built-in procedure, see <a class="olink TTREF789" href="../TTREF/proced.htm#TTREF789">&#34;ttCacheAutorefIntervalStatsGet&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.
<p>This built-in procedure is useful if you have set an transaction limit or a select limit for incremental, autorefresh read-only cache groups. See <a href="#BABEGAIE">&#34;Improving execution of large transactions when using incremental autorefresh for read-only cache groups&#34;</a> and <a href="#BABJFCGG">&#34;Configuring a select limit when using incremental autorefresh for read-only cache groups&#34;</a> for details.</p>
</div>
<p>The following example shows how to call the <code>ttCacheAutorefIntervalStatsGet</code> built-in procedure to retrieve statistics for incremental autorefresh read-only cache groups that have been defined as static and have the interval of 2 seconds:</p>
<pre>Command&gt; call ttCacheAutorefIntervalStatsGet(2000, 1);

&lt; 2000, 1, 21, 2013-04-30 06:05:38.000000, 100, 3761, 3761, 822, 1048576, 
1280, 0, 58825, 63825, 13590, 0, 0, 0, 0, 0 &gt;
&lt; 2000, 1, 20, 2013-04-30 06:05:37.000000, 100, 85, 85, 18, 1048576, 1280, 
0, 55064, 60064, 12768, 0, 0, 0, 0, 0 &gt;
&lt; 2000, 1, 19, 2013-04-30 06:05:32.000000, 100, 3043, 3043, 666, 1048576, 
1280, 0, 54979, 59979, 12750, 0, 0, 0, 0, 0 &gt;
&lt; 2000, 1, 18, 2013-04-30 06:05:30.000000, 100, 344, 344, 74, 1048576, 
1280, 0, 51936, 56936, 12084, 0, 0, 0, 0, 0 &gt;
&lt; 2000, 1, 17, 2013-04-30 06:05:28.000000, 100, 1826, 1826, 382, 1048576, 
1280, 0, 51592, 56592, 12010, 0, 0, 0, 0, 0 &gt;
&lt; 2000, 1, 16, 2013-04-30 06:05:26.000000, 100, 55, 55, 12, 1048576, 
1280, 0, 49766, 54766, 11628, 0, 0, 0, 0, 0 &gt;
&lt; 2000, 1, 15, 2013-04-30 06:05:22.000000, 100, 2901, 2901, 634, 1048576, 
1280, 0, 49711, 54711, 11616, 0, 0, 0, 0, 0 &gt;
&lt; 2000, 1, 14, 2013-04-30 06:05:21.000000, 100, 55, 55, 12, 1048576, 
1280, 0, 46810, 51810, 10982, 0, 0, 0, 0, 0 &gt;
&lt; 2000, 1, 13, 2013-04-30 06:05:10.000000, 100, 5844, 5844, 1263, 1048576, 
1280, 0, 46755, 51755, 10970, 0, 0, 0, 0, 0 &gt;
&lt; 2000, 1, 12, 2013-04-30 06:05:08.000000, 100, 607, 607, 132, 1048576, 
1280, 0, 40911, 45911, 9707, 0, 0, 0, 0, 0 &gt;

10 rows found. 
</pre></div>
<!-- class="sect1" -->
<a id="BABEIHEA"></a>
<div id="TTCAC522" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Caching the same Oracle table on two or more TimesTen databases<a id="sthref648"></a><a id="sthref649"></a><a id="sthref650"></a></h2>
<p>For each cache administration user, TimesTen creates a change log table and trigger (as part of what is created to manage caching) in the Oracle database for each cache table in the cache group. A trigger is fired for each committed insert, update, or delete operation on the cached Oracle Database table; the action is logged in the change log table.</p>
<p>If you cache the same Oracle database table in a cache group on two different TimesTen databases, we recommend that you use the same cache administration user name on both TimesTen databases as the owner of the cache table on each TimesTen database. When you use the same cache administration user, only one trigger and change log table are created to manage the changes to the base table. Thus, it is efficient and does not slow down the application.</p>
<p>If you create separate cache administration users on each TimesTen database to own the cache group that caches the same Oracle table, then separate triggers and change log tables exist on the Oracle database for the same table: one for each cache administration user. For example, if you have two separate TimesTen databases, each with their own cache administration user, two triggers fire for each DML operation on the base table, each of which are stored in a separate change log table. Firing two triggers and managing the separate change log tables can slow down the application.</p>
<p>The only reason to create separate cache administration users is if one of the TimesTen databases that caches the same table has a slow autorefresh rate or a slow connection to the Oracle database. In this case, having a single cache administration user on both TimesTen databases slows down the application on the faster connection, as it waits for the updates to be propagated to the slower database.</p>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment5343">
<tr>
<td class="cellalignment5350">
<table class="cellalignment5348">
<tr>
<td class="cellalignment5347"><a href="manage.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5347"><a href="cleanup.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2012, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment5352">
<table class="cellalignment5346">
<tr>
<td class="cellalignment5347"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5347"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5347"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5347"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5347"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5347"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>