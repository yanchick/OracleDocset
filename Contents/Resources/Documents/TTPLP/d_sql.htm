<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-113950"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/DBMS_SQL"></a><title>DBMS_SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 704"/>
<meta name="dcterms.created" content="2014-10-02T17:47:27Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen In-Memory Database PL/SQL Packages Reference"/>
<meta name="dcterms.identifier" content="E21645-06"/>
<meta name="dcterms.isVersionOf" content="TTPLP"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="d_random.htm" title="Previous" type="text/html"/>
<link rel="Next" href="d_util.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21645-06.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/19</span> <!-- End Header --><a id="BABEDAHF"></a><a id="TTPLP058"></a>
<h1 class="chapter"><span class="secnum">7</span> DBMS_SQL</h1>
<p>The <code>DBMS_SQL</code> package provides an interface for using dynamic SQL to execute data manipulation language (DML) and data definition language (DDL) statements, execute PL/SQL anonymous blocks, and call PL/SQL stored procedures and functions. For example, you can enter a <code>DROP TABLE</code> statement from within a stored procedure by using the <code>PARSE</code> procedure supplied with the <code>DBMS_SQL</code> package.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BABCIDIB">Using DBMS_SQL</a></p>
<ul>
<li>
<p>Overview</p>
</li>
<li>
<p>Security model</p>
</li>
<li>
<p>Constants</p>
</li>
<li>
<p>Operational notes</p>
</li>
<li>
<p>Exceptions</p>
</li>
<li>
<p>Examples</p>
</li>
</ul>
</li>
<li>
<p><a href="#CHDEEDCH">Data structures</a></p>
<ul>
<li>
<p>Record types</p>
</li>
<li>
<p>Table types</p>
</li>
</ul>
</li>
<li>
<p><a href="#i997453">Summary of DBMS_SQL subprograms</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For more information on native dynamic SQL, see <a class="olink TTPLS143" href="../TTPLS/overview.htm#TTPLS143">&#34;Dynamic SQL in PL/SQL (EXECUTE IMMEDIATE statement)&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database PL/SQL Developer&#39;s Guide</span>. You can also refer to <a class="olink LNPLS01115" href="../LNPLS/dynamic.htm#LNPLS01115">&#34;EXECUTE IMMEDIATE Statement&#34;</a> in <span class="italic">Oracle Database PL/SQL Language Reference</span>.</div>
<a id="BABCIDIB"></a><a id="TTPLP71250"></a>
<hr/>
<div class="refsect1">
<h2 class="refsect1">Using DB<a id="sthref317"></a><a id="sthref318"></a>MS_SQL</h2>
<ul>
<li>
<p><a href="#i1028953">Overview</a></p>
</li>
<li>
<p><a href="#i1027587">Security model</a></p>
</li>
<li>
<p><a href="#i1027592">Constants</a></p>
</li>
<li>
<p><a href="#i1027597">Exceptions</a></p>
</li>
<li>
<p><a href="#i1027602">Operational notes</a></p>
</li>
<li>
<p><a href="#i996963">Examples</a></p>
</li>
</ul>
<a id="i1028953"></a><a id="TTPLP71251"></a>
<hr/>
<h3 class="refsect2">Overview</h3>
<p>TimesTen lets you write stored procedures and anonymous PL/SQL blocks that use dynamic SQL. Dynamic SQL statements are not embedded in your source program; rather, they are stored in character strings that are input to, or built by, the program at runtime. This functionality enables you to create more general-purpose procedures. For example, dynamic SQL lets you create a procedure that operates on a table whose name is not known until runtime.</p>
<p>Native dynamic SQL (<code>EXECUTE IMMEDIATE</code>) is an alternative to <code>DBMS_SQL</code> that lets you place dynamic SQL statements, PL/SQL blocks, and PL/SQL procedure and function calls directly into PL/SQL blocks. In most situations, native dynamic SQL is easier to use and performs better than <code>DBMS_SQL</code>. However, native dynamic SQL itself has certain limitations, such as there being no support for so-called Method 4 (for dynamic SQL statements with an unknown number of inputs or outputs). Also, there are some tasks that can only be performed using <code>DBMS_SQL</code>.</p>
<p>The ability to use dynamic SQL from within stored procedures generally follows the model of the Oracle Call Interface (OCI). See <a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for information about OCI.</p>
<p>PL/SQL differs somewhat from other common programming languages, such as C. For example, addresses (also called <span class="italic">pointers</span>) are not user-visible in PL/SQL. As a result, there are some differences between OCI and the <code>DBMS_SQL</code> package, including the following:</p>
<ul>
<li>
<p>OCI binds by address, while the <code>DBMS_SQL</code> package binds by value.</p>
</li>
<li>
<p><a id="sthref319"></a><a id="sthref320"></a>With <code>DBMS_SQL</code> you must call <code>VARIABLE_VALUE</code> to retrieve the value of an <code>OUT</code> parameter for an anonymous block, and you must call <code>COLUMN_VALUE</code> after fetching rows to actually retrieve the values of the columns in the rows into your program.</p>
</li>
<li>
<p>The current release of the <code>DBMS_SQL</code> package does not provide <code>CANCEL</code> cursor procedures.</p>
</li>
<li>
<p>Indicator variables are not required, because <code>NULL</code> is fully supported as a value of a PL/SQL variable.</p>
</li>
</ul>
<a id="i1027587"></a><a id="TTPLP71252"></a>
<hr/>
<h3 class="refsect2">Security model</h3>
<p><code>DBMS_SQL</code> is owned by <code>SYS</code> and compiled with <code>AUTHID CURRENT_USER</code>. Any <code>DBMS_SQL</code> subprogram called from an anonymous PL/SQL block is run using the privileges of the current user.</p>
<p>See <a class="olink TTPLS274" href="../TTPLS/accesscntl.htm#TTPLS274">&#34;Definer&#39;s rights and invoker&#39;s rights&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database PL/SQL Developer&#39;s Guide</span> for information about the <code>AUTHID</code> clause.</p>
<a id="i1027592"></a><a id="TTPLP71255"></a>
<hr/>
<h3 class="refsect2">Constants</h3>
<p>The constants described in <a href="#CIHHIABA">Table 7-1</a> are used with the <code><span class="codeinlineitalic">language_flag</span></code> parameter of the <a href="#i997676">PARSE procedures</a>. For TimesTen, use <code>NATIVE</code>.</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71256"></a><a id="sthref321"></a><a id="CIHHIABA"></a>Table 7-1 DBMS_SQL constants</p>
<table class="cellalignment1016" title="DBMS_SQL constants" summary="This table describes constants used by DBMS_SQL subprograms." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t3">Name</th>
<th class="cellalignment1017" id="r1c2-t3">Type</th>
<th class="cellalignment1017" id="r1c3-t3">Value</th>
<th class="cellalignment1017" id="r1c4-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t3" headers="r1c1-t3">
<p><code>V6</code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t3 r1c2-t3">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t3 r1c3-t3">
<p><code>0</code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t3 r1c4-t3">
<p>Specifies Oracle Database version 6 behavior (not applicable for TimesTen).</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t3" headers="r1c1-t3">
<p><code>NATIVE</code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t3 r1c2-t3">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t3 r1c3-t3">
<p><code>1</code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t3 r1c4-t3">
<p>Specifies normal behavior for the database to which the program is connected.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t3" headers="r1c1-t3">
<p><code>V7</code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t3 r1c2-t3">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t3 r1c3-t3">
<p>2</p>
</td>
<td class="cellalignment1018" headers="r4c1-t3 r1c4-t3">
<p>Specifies Oracle Database version 7 behavior (not applicable for TimesTen).</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<a id="i1027602"></a><a id="TTPLP71258"></a>
<hr/>
<h3 class="refsect2">Operational notes</h3>
<ul>
<li>
<p><a href="#BABGFFAI">Execution flow</a></p>
</li>
</ul>
<ul>
<li>
<p><a href="#BABECIBG">Processing queries</a></p>
</li>
</ul>
<ul>
<li>
<p><a href="#BABFJHJF">Processing updates, inserts, and deletes</a></p>
</li>
</ul>
<ul>
<li>
<p><a href="#i1027496">Locating errors</a></p>
</li>
</ul>
<a id="BABGFFAI"></a><a id="TTPLP71259"></a>
<h4 class="refsect3">Exe<a id="sthref322"></a><a id="sthref323"></a>cution flow</h4>
<ol>
<li>
<p><a href="#i1027364">OPEN_CURSOR</a></p>
</li>
<li>
<p><a href="#i996870">PARSE</a></p>
</li>
<li>
<p><a href="#i996891">BIND_VARIABLE or BIND_ARRAY</a></p>
</li>
<li>
<p><a href="#i996897">DEFINE_COLUMN or DEFINE_ARRAY</a></p>
</li>
<li>
<p><a href="#BABBFFFJ">EXECUTE</a></p>
</li>
<li>
<p><a href="#i996905">FETCH_ROWS or EXECUTE_AND_FETCH</a></p>
</li>
<li>
<p><a href="#i996908">VARIABLE_VALUE or COLUMN_VALUE</a></p>
</li>
<li>
<p><a href="#i996912">CLOSE_CURSOR</a></p>
</li>
</ol>
<a id="i1027364"></a><a id="TTPLP71260"></a>
<h5 class="refsect4">OPEN_CURSOR</h5>
<p><a id="sthref324"></a>To process a SQL statement, you must have an open cursor. When you call the&nbsp;<a href="#i997665">OPEN_CURSOR function</a>, you receive a cursor ID number for the data structure representing a valid cursor maintained by TimesTen. These cursors are distinct from cursors defined at the precompiler, OCI, or PL/SQL level, and are used only by the <code>DBMS_SQL</code> package.</p>
<br/>
<a id="i996870"></a><a id="TTPLP71261"></a>
<h5 class="refsect4">PARSE</h5>
<p>Every SQL statement must be parsed by calling the <a href="#i997676">PARSE procedures</a>. Parsing the statement checks the statement syntax and associates it with the cursor in your program.</p>
<p>You can parse any DML or DDL statement. DDL statements are run on the parse, which performs the implied commit.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When parsing a DDL statement to drop a procedure or a package, a timeout can occur if you are still using the procedure in question or a procedure in the package in question. After a call to a procedure, that procedure is considered to be in use until execution has returned to the user side. Any such timeout occurs after a short time.</div>
<p>The execution flow of <code>DBMS_SQL</code> is shown in <a href="#BABDJEBE">Figure 7-1</a> that follows.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABDJEBE"></a><a id="TTPLP71262"></a>Figure 7-1 DBMS_SQL execution flow</p>
<img width="496" height="608" src="img/arpls008.gif" alt="Description of Figure 7-1 follows"/><br/>
<a id="sthref325" href="img_text/arpls008.htm">Description of &#34;Figure 7-1 DBMS_SQL execution flow&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<br/>
<a id="i996891"></a><a id="TTPLP71263"></a>
<h5 class="refsect4">BIND_VA<a id="sthref326"></a>RIABLE or BIND_ARRAY</h5>
<p>Many DML statements require that data in your program be input to TimesTen. When you define a SQL statement that contains input data to be supplied at runtime, you must use placeholders in the SQL statement to mark where data must be supplied.</p>
<p><a id="sthref327"></a>For each placeholder in the SQL statement, you must call a bind procedure, either the <a href="#i1025085">BIND_ARRAY procedure</a> or the <a href="#i1030093">BIND_VARIABLE procedure</a>, to supply the value of a variable in your program (or the values of an array) to the placeholder. When the SQL statement is subsequently run, TimesTen uses the data that your program has placed in the output and input, or bind, variables.</p>
<p><code>DBMS_SQL</code> can run a DML statement multiple times, each time with a different bind variable. The <code>BIND_ARRAY</code> procedure lets you bind a collection of scalars, each value of which is used as an input variable once for each <code>EXECUTE</code>. This is similar to the array interface supported by OCI.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The term &#34;bind parameter&#34; as used in TimesTen developer guides (in keeping with ODBC terminology) is equivalent to the term &#34;bind variable&#34; as used in TimesTen PL/SQL documents (in keeping with Oracle Database PL/SQL terminology).</div>
<br/>
<a id="i996897"></a><a id="TTPLP71264"></a>
<h5 class="refsect4">DEFINE_COLUMN or DEFINE_ARRAY</h5>
<p>The columns of the row being selected in a <code>SELECT</code> statement are identified by their relative positions as they appear in the select list, from left to right. For a query, you must call a define procedure (<code>DEFINE_COLUMN</code> or <code>DEFINE_ARRAY</code>) to specify the variables that are to receive the <code>SELECT</code> values, much the way an <code>INTO</code> clause does for a static query.</p>
<p>Use the <code>DEFINE_ARRAY</code> procedure to define a PL/SQL collection into which rows are fetched in a single <code>SELECT</code> statement. <code>DEFINE_ARRAY</code> provides an interface to fetch multiple rows at one fetch. You must call <code>DEFINE_ARRAY</code> before using the <code>COLUMN_VALUE</code> procedure to fetch the rows.</p>
<br/>
<a id="BABBFFFJ"></a><a id="TTPLP71265"></a>
<h5 class="refsect4">EXECUTE</h5>
<p>Call the <code>EXECUTE</code> function to run your SQL statement.</p>
<br/>
<a id="i996905"></a><a id="TTPLP71266"></a>
<h5 class="refsect4">FETCH_ROWS or EXECUTE_AND_FETCH</h5>
<p>The <code>FETCH_ROWS</code> function retrieves the rows that satisfy the query. Each successive fetch retrieves another set of rows, until the fetch cannot retrieve any more rows. Instead of calling <code>EXECUTE</code> and then <code>FETCH_ROWS</code>, you may find it more efficient to call <code>EXECUTE_AND_FETCH</code> if you are calling <code>EXECUTE</code> for a single execution.</p>
<br/>
<a id="i996908"></a><a id="TTPLP71267"></a>
<h5 class="refsect4">VARIABLE_VALUE or COLUMN_VALUE</h5>
<p>For queries, call <code>COLUMN_VALUE</code> to determine the value of a column retrieved by the <code>FETCH_ROWS</code> call. For anonymous blocks containing calls to PL/SQL procedures or DML statements with a <code>RETURNING</code> clause, call <code>VARIABLE_VALUE</code> to retrieve the values assigned to the output variables when statements were run.</p>
<br/>
<a id="i996912"></a><a id="TTPLP71268"></a>
<h5 class="refsect4">CLOSE_CURSOR</h5>
<p>When you no longer need a cursor for a session, close the cursor by calling <code>CLOSE_CURSOR</code>.</p>
<p>If you neglect to close a cursor, then the memory used by that cursor remains allocated even though it is no longer needed.</p>
<br/>
<a id="BABECIBG"></a><a id="TTPLP71269"></a>
<h4 class="refsect3">Processing queries</h4>
<p>If you are using dynamic SQL to process a query, then you must perform the following steps:</p>
<ol>
<li>
<p>Specify the variables that are to receive the values returned by the <code>SELECT</code> statement by calling the <a href="#i1025686">DEFINE_COLUMN procedure</a> or the <a href="#i1025685">DEFINE_ARRAY procedure</a>.</p>
</li>
<li>
<p>Run your <code>SELECT</code> statement by calling the <a href="#i1025983">EXECUTE function</a>.</p>
</li>
<li>
<p>Call the <a href="#i1026065">FETCH_ROWS function</a> (or <code>EXECUTE_AND_FETCH</code>) to retrieve the rows that satisfied your query.</p>
</li>
<li>
<p>Call <a href="#i1025449">COLUMN_VALUE procedure</a> to determine the&nbsp;value of a column retrieved by <code>FETCH_ROWS</code> for your query. If you used anonymous blocks containing calls to PL/SQL procedures, then you must call the <a href="#i998371">VARIABLE_VALUE procedure</a> to retrieve the values assigned to the output variables of these procedures.</p>
</li>
</ol>
<a id="BABFJHJF"></a><a id="TTPLP71270"></a>
<h4 class="refsect3">Processing updates, inserts, and deletes</h4>
<p>If you are using dynamic SQL to process an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, then you must perform the following steps.</p>
<ol>
<li>
<p>You must first run your <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement by calling the <a href="#i1025983">EXECUTE function</a>.</p>
</li>
<li>
<p>If statements have the <code>RETURNING</code> clause, then you must call the <a href="#i998371">VARIABLE_VALUE procedure</a> to retrieve the values assigned to the output variables.</p>
</li>
</ol>
<a id="i1027496"></a><a id="TTPLP71271"></a>
<h4 class="refsect3">Locating errors</h4>
<p>There are additional functions in the <code>DBMS_SQL</code> package for obtaining information about the last referenced cursor in the session. The values returned by these functions are only meaningful immediately after a SQL statement is run. In addition, some error-locating functions are only meaningful after certain <code>DBMS_SQL</code> calls. For example, call the <a href="#i1026408">LAST_ERROR_POSITION function</a> immediately after a <code>PARSE</code> call.</p>
<a id="i1027597"></a><a id="TTPLP71257"></a>
<hr/>
<h3 class="refsect2">Exceptions</h3>
<p>The following table lists the exceptions raised by <code>DBMS_SQL</code>.</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71650"></a><a id="sthref328"></a><a id="sthref329"></a>Table 7-2 Exceptions Raised by DBMS_SQL</p>
<table class="cellalignment1016" title="Exceptions Raised by DBMS_SQL" summary="This table describes exceptions raised by DBMS_SQL subprograms." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t6">Exception</th>
<th class="cellalignment1017" id="r1c2-t6">Error Code</th>
<th class="cellalignment1017" id="r1c3-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t6" headers="r1c1-t6">
<p><code>INCONSISTENT_TYPE</code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t6 r1c2-t6">
<p>-6562</p>
</td>
<td class="cellalignment1018" headers="r2c1-t6 r1c3-t6">
<p>Raised by the <a href="#i1025449">COLUMN_VALUE procedure</a> or <a href="#i998371">VARIABLE_VALUE procedure</a> when the type of the given <code>OUT</code> parameter (for where to output the requested value) is different from the type of the value.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<a id="i996963"></a><a id="TTPLP71272"></a>
<hr/>
<h3 class="refsect2">Ex<a id="sthref330"></a><a id="sthref331"></a>amples</h3>
<p>This section provides example procedures that make use of the <code>DBMS_SQL</code> package.</p>
<p><span class="bold">Example 1: Basic</span></p>
<p>This example does not require the use of dynamic SQL because the text of the statement is known at compile time, but it illustrates the basic concept underlying the package.</p>
<p>The <code>demo</code> procedure deletes all employees from a table <code>myemployees</code> (created from the <code>employees</code> table of the <code>HR</code> schema) whose salaries exceed a specified value.</p>
<pre>CREATE OR REPLACE PROCEDURE demo(p_salary IN NUMBER) AS 
   cursor_name INTEGER;
   rows_processed INTEGER;

BEGIN
   cursor_name := dbms_sql.open_cursor;
   DBMS_SQL.PARSE(cursor_name, &#39;DELETE FROM myemployees WHERE salary &gt; :x&#39;,
                  DBMS_SQL.NATIVE);
   DBMS_SQL.BIND_VARIABLE(cursor_name, &#39;:x&#39;, p_salary);
   rows_processed := DBMS_SQL.EXECUTE(cursor_name);
   DBMS_SQL.CLOSE_CURSOR(cursor_name);
EXCEPTION
WHEN OTHERS THEN
   DBMS_SQL.CLOSE_CURSOR(cursor_name);
END;
</pre>
<p>Create the <code>myemployees</code> table and see how many employees have salaries greater than or equal to $15,000:</p>
<pre>Command&gt; create table myemployees as select * from employees;
107 rows inserted.
 
Command&gt; select * from myemployees where salary&gt;=15000;
&lt; 100, Steven, King, SKING, 515.123.4567, 1987-06-17 00:00:00, AD_PRES, 24000, 
&lt;NULL&gt;, &lt;NULL&gt;, 90 &gt;
&lt; 101, Neena, Kochhar, NKOCHHAR, 515.123.4568, 1989-09-21 00:00:00, AD_VP, 17000,
&lt;NULL&gt;, 100, 90 &gt;
&lt; 102, Lex, De Haan, LDEHAAN, 515.123.4569, 1993-01-13 00:00:00, AD_VP, 17000, 
&lt;NULL&gt;, 100, 90 &gt;
3 rows found.
</pre>
<p>Run <code>demo</code> to delete everyone with a salary greater than $14,999 and confirm the results, as follows:</p>
<pre>Command&gt; begin
       &gt; demo(14999);
       &gt; end;
       &gt; /
 
PL/SQL procedure successfully completed.
 
Command&gt; select * from myemployees where salary&gt;=15000;
0 rows found.
</pre>
<p><span class="bold">Example 2: Copy between tables</span></p>
<p>The following sample procedure is passed the names of a source and a destination table, and copies the rows from the source table to the destination table. This sample procedure assumes that both the source and destination tables have the following columns.</p>
<pre>id        of type NUMBER
name      of type VARCHAR2(30)
birthdate of type DATE
</pre>
<p>This procedure does not specifically require the use of dynamic SQL; however, it illustrates the concepts of this package.</p>
<pre>CREATE OR REPLACE PROCEDURE copy ( 
     source      IN VARCHAR2, 
     destination IN VARCHAR2) IS 
     id_var             NUMBER; 
     name_var           VARCHAR2(30); 
     birthdate_var      DATE; 
     source_cursor      INTEGER; 
     destination_cursor INTEGER; 
     ignore             INTEGER; 
  BEGIN 
 
  -- Prepare a cursor to select from the source table: 
     source_cursor := dbms_sql.open_cursor; 
     DBMS_SQL.PARSE(source_cursor, 
         &#39;SELECT id, name, birthdate FROM &#39; || source, 
          DBMS_SQL.NATIVE); 
     DBMS_SQL.DEFINE_COLUMN(source_cursor, 1, id_var); 
     DBMS_SQL.DEFINE_COLUMN(source_cursor, 2, name_var, 30); 
     DBMS_SQL.DEFINE_COLUMN(source_cursor, 3, birthdate_var); 
     ignore := DBMS_SQL.EXECUTE(source_cursor); 
 
  -- Prepare a cursor to insert into the destination table: 
     destination_cursor := DBMS_SQL.OPEN_CURSOR; 
     DBMS_SQL.PARSE(destination_cursor, 
                  &#39;INSERT INTO &#39; || destination || 
                  &#39; VALUES (:id_bind, :name_bind, :birthdate_bind)&#39;, 
                   DBMS_SQL.NATIVE); 
 
  -- Fetch a row from the source table and insert it into the destination table: 
     LOOP 
       IF DBMS_SQL.FETCH_ROWS(source_cursor)&gt;0 THEN 
         -- get column values of the row 
         DBMS_SQL.COLUMN_VALUE(source_cursor, 1, id_var); 
         DBMS_SQL.COLUMN_VALUE(source_cursor, 2, name_var); 
         DBMS_SQL.COLUMN_VALUE(source_cursor, 3, birthdate_var); 
 
  -- Bind the row into the cursor that inserts into the destination table. You 
  -- could alter this example to require the use of dynamic SQL by inserting an 
  -- if condition before the bind. 
        DBMS_SQL.BIND_VARIABLE(destination_cursor, &#39;:id_bind&#39;, id_var); 
        DBMS_SQL.BIND_VARIABLE(destination_cursor, &#39;:name_bind&#39;, name_var); 
        DBMS_SQL.BIND_VARIABLE(destination_cursor, &#39;:birthdate_bind&#39;, 
                               birthdate_var); 
        ignore := DBMS_SQL.EXECUTE(destination_cursor); 
      ELSE 
 
  -- No more rows to copy: 
        EXIT; 
      END IF; 
    END LOOP; 
 
  -- Commit (in TimesTen commit closes cursors automatically): 
     COMMIT; 
 
   EXCEPTION 
     WHEN OTHERS THEN 
       IF DBMS_SQL.IS_OPEN(source_cursor) THEN 
         DBMS_SQL.CLOSE_CURSOR(source_cursor); 
       END IF; 
       IF DBMS_SQL.IS_OPEN(destination_cursor) THEN 
         DBMS_SQL.CLOSE_CURSOR(destination_cursor); 
       END IF; 
       RAISE; 
  END;
</pre>
<p><span class="bold">Examples 3, 4, and 5: Bulk DML</span></p>
<p>This series of examples shows how to use bulk array binds (table items) in the SQL DML statements <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>.</p>
<p>Here is an example of a bulk <code>INSERT</code> statement that adds three new departments to the <code>departments</code> table in the <code>HR</code> schema:</p>
<pre>DECLARE
  stmt VARCHAR2(200);
  departid_array     DBMS_SQL.NUMBER_TABLE;
  deptname_array     DBMS_SQL.VARCHAR2_TABLE;
  mgrid_array        DBMS_SQL.NUMBER_TABLE;
  locid_array        DBMS_SQL.NUMBER_TABLE;
  c                NUMBER;
  dummy            NUMBER;
BEGIN
  departid_array(1):= 280;
  departid_array(2):= 290;
  departid_array(3):= 300;
 
  deptname_array(1) := &#39;Community Outreach&#39;;
  deptname_array(2) := &#39;Product Management&#39;;
  deptname_array(3) := &#39;Acquisitions&#39;;
 
  mgrid_array(1) := 121;
  mgrid_array(2) := 120;
  mgrid_array(3) := 70;
 
  locid_array(1):= 1500;
  locid_array(2):= 1700;
  locid_array(3):= 2700;
 
  stmt := &#39;INSERT INTO departments VALUES(
     :departid_array, :deptname_array, :mgrid_array, :locid_array)&#39;;
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_ARRAY(c, &#39;:departid_array&#39;, departid_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:deptname_array&#39;, deptname_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:mgrid_array&#39;, mgrid_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:locid_array&#39;, locid_array);
  dummy := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c);
  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
</pre>
<p>Following is output from a <code>SELECT</code> statement, showing the new rows.</p>
<pre>Command&gt; select * from departments;
&lt; 10, Administration, 200, 1700 &gt;
...
&lt; 280, Community Outreach, 121, 1500 &gt;
&lt; 290, Product Management, 120, 1700 &gt;
&lt; 300, Acquisitions, 70, 2700 &gt;
30 rows found.
</pre>
<p>Here is an example of a bulk <code>UPDATE</code> statement that demonstrates updating salaries for four existing employees in the <code>employees</code> table in the <code>HR</code> schema:</p>
<pre>DECLARE
  stmt VARCHAR2(200);
  empno_array     DBMS_SQL.NUMBER_TABLE;
  salary_array    DBMS_SQL.NUMBER_TABLE;
  c               NUMBER;
  dummy           NUMBER;

BEGIN
  empno_array(1):= 203;
  empno_array(2):= 204;
  empno_array(3):= 205;
  empno_array(4):= 206;
 
  salary_array(1) := 7000;
  salary_array(2) := 11000;
  salary_array(3) := 13000;
  salary_array(4) := 9000;
 
  stmt := &#39;update employees set salary = :salary_array
    WHERE employee_id = :num_array&#39;;
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_ARRAY(c, &#39;:num_array&#39;, empno_array);
  DBMS_SQL.BIND_ARRAY(c, &#39;:salary_array&#39;, salary_array);
  dummy := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c);
 
  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
</pre>
<p>Assume the following entries for the specified employees before running the example, showing salaries of $6500, $10000, $12000, and $8300:</p>
<pre>Command&gt; select * from employees where employee_id&gt;=203 and employee_id&lt;=206;
&lt; 203, Susan, Mavris, SMAVRIS, 515.123.7777, 1994-06-07 00:00:00, HR_REP, 
6500, &lt;NULL&gt;, 101, 40 &gt;
&lt; 204, Hermann, Baer, HBAER, 515.123.8888, 1994-06-07 00:00:00, PR_REP, 
10000, &lt;NULL&gt;, 101, 70 &gt;
&lt; 205, Shelley, Higgins, SHIGGINS, 515.123.8080, 1994-06-07 00:00:00, AC_MGR,
12000, &lt;NULL&gt;, 101, 110 &gt;
&lt; 206, William, Gietz, WGIETZ, 515.123.8181, 1994-06-07 00:00:00, AC_ACCOUNT,
8300, &lt;NULL&gt;, 205, 110 &gt;
4 rows found.
</pre>
<p>The following shows the new salaries after running the example.</p>
<pre>Command&gt; select * from employees where employee_id&gt;=203 and employee_id&lt;=206;
&lt; 203, Susan, Mavris, SMAVRIS, 515.123.7777, 1994-06-07 00:00:00, HR_REP, 
7000, &lt;NULL&gt;, 101, 40 &gt;
&lt; 204, Hermann, Baer, HBAER, 515.123.8888, 1994-06-07 00:00:00, PR_REP, 
11000, &lt;NULL&gt;, 101, 70 &gt;
&lt; 205, Shelley, Higgins, SHIGGINS, 515.123.8080, 1994-06-07 00:00:00, AC_MGR,
13000, &lt;NULL&gt;, 101, 110 &gt;
&lt; 206, William, Gietz, WGIETZ, 515.123.8181, 1994-06-07 00:00:00, AC_ACCOUNT,
9000, &lt;NULL&gt;, 205, 110 &gt;
4 rows found.
</pre>
<p>In a <code>DELETE</code> statement, for example, you could bind in an array in the <code>WHERE</code> clause and have the statement be run for each element in the array, as follows:</p>
<pre>DECLARE
  stmt VARCHAR2(200);
  dept_no_array DBMS_SQL.NUMBER_TABLE;
  c NUMBER;
  dummy NUMBER;
BEGIN
  dept_no_array(1) := 60; 
  dept_no_array(2) := 70;
  stmt := &#39;delete from employees where department_id = :dept_array&#39;;
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_ARRAY(c, &#39;:dept_array&#39;, dept_no_array, 1, 1);
  dummy := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c);
 
  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
</pre>
<p>In this example, only the first element of the array is specified by the <code>BIND_ARRAY</code> call (lower and upper bounds of the array elements are both set to 1), so only employees in department 60 are deleted.</p>
<p>Before running the example, there are five employees in department 60 and one in department 70, where the department number is the last entry in each row:</p>
<pre>Command&gt; select * from employees where department_id&gt;=60 and department_id&lt;=70;
&lt; 103, Alexander, Hunold, AHUNOLD, 590.423.4567, 1990-01-03 00:00:00, IT_PROG, 
9000, &lt;NULL&gt;, 102, 60 &gt;
&lt; 104, Bruce, Ernst, BERNST, 590.423.4568, 1991-05-21 00:00:00, IT_PROG, 6000, 
&lt;NULL&gt;, 103, 60 &gt;
&lt; 105, David, Austin, DAUSTIN, 590.423.4569, 1997-06-25 00:00:00, IT_PROG, 4800,
 &lt;NULL&gt;, 103, 60 &gt;
&lt; 106, Valli, Pataballa, VPATABAL, 590.423.4560, 1998-02-05 00:00:00, IT_PROG, 
4800, &lt;NULL&gt;, 103, 60 &gt;
&lt; 107, Diana, Lorentz, DLORENTZ, 590.423.5567, 1999-02-07 00:00:00, IT_PROG, 
4200, &lt;NULL&gt;, 103, 60 &gt;
&lt; 204, Hermann, Baer, HBAER, 515.123.8888, 1994-06-07 00:00:00, PR_REP, 10000, 
&lt;NULL&gt;, 101, 70 &gt;
6 rows found.
</pre>
<p>After running the example, only the employee in department 70 remains.</p>
<pre>Command&gt; select * from employees where department_id&gt;=60 and department_id&lt;=70;
&lt; 204, Hermann, Baer, HBAER, 515.123.8888, 1994-06-07 00:00:00, PR_REP, 10000, 
&lt;NULL&gt;, 101, 70 &gt;
1 row found.
</pre>
<p><span class="bold">Example 6: Define an array</span></p>
<p>This example defines an array.</p>
<pre>CREATE OR REPLACE PROCEDURE BULK_PLSQL(deptid NUMBER) IS
    names    DBMS_SQL.VARCHAR2_TABLE;
    sals     DBMS_SQL.NUMBER_TABLE;
    c        NUMBER;
    r        NUMBER;
    sql_stmt VARCHAR2(32767) :=
        &#39;SELECT last_name, salary FROM employees WHERE department_id = :b1&#39;;
 
BEGIN
    c := DBMS_SQL.OPEN_CURSOR;
    DBMS_SQL.PARSE(c, sql_stmt, dbms_sql.native);
    DBMS_SQL.BIND_VARIABLE(c, &#39;b1&#39;, deptid);
    DBMS_SQL.DEFINE_ARRAY(c, 1, names, 5, 1);
    DBMS_SQL.DEFINE_ARRAY(c, 2, sals, 5, 1);
 
    r := DBMS_SQL.EXECUTE(c);
 
    LOOP
      r := DBMS_SQL.FETCH_ROWS(c);
      DBMS_SQL.COLUMN_VALUE(c, 1, names);
      DBMS_SQL.COLUMN_VALUE(c, 2, sals);
      EXIT WHEN r != 5;
    END LOOP;
 
    DBMS_SQL.CLOSE_CURSOR(c);
 
    -- loop through the names and sals collections
    FOR i IN names.FIRST .. names.LAST  LOOP
      DBMS_OUTPUT.PUT_LINE(&#39;Name = &#39; || names(i) || &#39;, salary = &#39; || sals(i));
    END LOOP;
END;
</pre>
<p>For example, for department 20 in the <code>employees</code> table, this produces the following output:</p>
<pre>Command&gt; begin
       &gt; bulk_plsql(20);
       &gt; end;
       &gt; /
Name = Hartstein, salary = 13000
Name = Fay, salary = 6000
 
PL/SQL procedure successfully completed.
</pre>
<p><span class="bold">Example 7: Describe columns</span></p>
<p>This can be used as a substitute for the <code>ttIsql</code> <code>DESCRIBE</code> command by using a <code>SELECT *</code> query on the table to describe. This example describes columns of the <code>employees</code> table.</p>
<pre>DECLARE
  c           NUMBER;
  d           NUMBER;
  col_cnt     INTEGER;
  f           BOOLEAN;
  rec_tab     DBMS_SQL.DESC_TAB;
  col_num    NUMBER;
  PROCEDURE print_rec(rec in DBMS_SQL.DESC_REC) IS
  BEGIN
    DBMS_OUTPUT.NEW_LINE;
    DBMS_OUTPUT.PUT_LINE(&#39;col_type            =    &#39;
                         || rec.col_type);
    DBMS_OUTPUT.PUT_LINE(&#39;col_maxlen          =    &#39;
                         || rec.col_max_len);
    DBMS_OUTPUT.PUT_LINE(&#39;col_name            =    &#39;
                         || rec.col_name);
    DBMS_OUTPUT.PUT_LINE(&#39;col_name_len        =    &#39;
                         || rec.col_name_len);
    DBMS_OUTPUT.PUT_LINE(&#39;col_schema_name     =    &#39;
                         || rec.col_schema_name);
    DBMS_OUTPUT.PUT_LINE(&#39;col_schema_name_len =    &#39;
                         || rec.col_schema_name_len);
    DBMS_OUTPUT.PUT_LINE(&#39;col_precision       =    &#39;
                         || rec.col_precision);
    DBMS_OUTPUT.PUT_LINE(&#39;col_scale           =    &#39;
                         || rec.col_scale);
    DBMS_OUTPUT.PUT(&#39;col_null_ok         =    &#39;);
    IF (rec.col_null_ok) THEN
      DBMS_OUTPUT.PUT_LINE(&#39;true&#39;);
    ELSE
      DBMS_OUTPUT.PUT_LINE(&#39;false&#39;);
    END IF;
  END;
BEGIN
  c := DBMS_SQL.OPEN_CURSOR;

  DBMS_SQL.PARSE(c, &#39;SELECT * FROM employees&#39;, DBMS_SQL.NATIVE);
 
  d := DBMS_SQL.EXECUTE(c);
 
  DBMS_SQL.DESCRIBE_COLUMNS(c, col_cnt, rec_tab);

/*
 * Following loop could simply be for j in 1..col_cnt loop.
 * Here we are simply illustrating some PL/SQL table
 * features.
 */
  col_num := rec_tab.first;
  IF (col_num IS NOT NULL) THEN
    LOOP
      print_rec(rec_tab(col_num));
      col_num := rec_tab.next(col_num);
      EXIT WHEN (col_num IS NULL);
    END LOOP;
  END IF;
 
  DBMS_SQL.CLOSE_CURSOR(c);
END;
</pre>
<p>Here is an abbreviated sample of the output, describing columns of the <code>employees</code> table, assuming it was run from the <code>HR</code> schema. Information from only the first two columns is shown here:</p>
<pre>col_type            =    2
col_maxlen          =    7
col_name            =    EMPLOYEE_ID
col_name_len        =    11
col_schema_name     =    HR
col_schema_name_len =    8
col_precision       =    6
col_scale           =    0
col_null_ok         =    false
col_type            =    1
col_maxlen          =    20
col_name            =    FIRST_NAME
col_name_len        =    10
col_schema_name     =    HR
col_schema_name_len =    8
col_precision       =    0
col_scale           =    0
col_null_ok         =    true
...
</pre>
<p><span class="bold">Example 8: RETURNING clause</span></p>
<p>With this clause, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements can return values of expressions. These values are returned in bind variables.</p>
<p><code>BIND_VARIABLE</code> is used to bind these outbinds if a single row is inserted, updated, or deleted. If multiple rows are inserted, updated, or deleted, then <code>BIND_ARRAY</code> is used. <code>VARIABLE_VALUE</code> must be called to get the values in these bind variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This is similar to <code>VARIABLE_VALUE</code>, which must be called after running a PL/SQL block with an out-bind inside <code>DBMS_SQL</code>.</div>
<p>The examples that follow assume a table <code>tab</code> has been created:</p>
<pre>Command&gt; create table tab (c1 number, c2 number);
</pre>
<p>i) This shows a single row insert.</p>
<pre>      CREATE OR REPLACE PROCEDURE single_Row_insert
           (c1 NUMBER, c2 NUMBER, r OUT NUMBER) is
      c NUMBER;
      n NUMBER;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;INSERT INTO tab VALUES (:bnd1, :bnd2) &#39; ||
                          &#39;RETURNING c1*c2 INTO :bnd3&#39;, DBMS_SQL.NATIVE);
     DBMS_SQL.BIND_VARIABLE(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd2&#39;, c2);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd3&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd3&#39;, r); -- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
</pre>
<p>The following runs this example and shows the results. The table was initially empty.</p>
<pre>Command&gt; declare r NUMBER;
       &gt; begin
       &gt; single_Row_insert(100,200,r);
       &gt; dbms_output.put_line(&#39;Product = &#39; || r);
       &gt; end;
       &gt; /
Product = 20000
 
PL/SQL procedure successfully completed.
 
Command&gt; select * from tab;
&lt; 100, 200 &gt;
1 row found.
</pre>
<p>ii) This shows a single row update. Note that <code>rownum</code> is an internal variable for row number.</p>
<pre>      CREATE OR REPLACE PROCEDURE single_Row_update
           (c1 NUMBER, c2 NUMBER, r out NUMBER) IS
      c NUMBER;
      n NUMBER;

      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;UPDATE tab SET c1 = :bnd1, c2 = :bnd2 &#39; ||
                          &#39;WHERE rownum = 1 &#39; || 
                          &#39;RETURNING c1*c2 INTO :bnd3&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd2&#39;, c2);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd3&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd3&#39;, r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
</pre>
<p>The following runs this example and shows the results, updating the row that was inserted in the previous example.</p>
<pre>Command&gt; declare r NUMBER;
       &gt; begin
       &gt; single_Row_update(200,300,r);
       &gt; dbms_output.put_line(&#39;Product = &#39; || r);
       &gt; end;
       &gt; /
Product = 60000
 
PL/SQL procedure successfully completed.
 
Command&gt; select * from tab;
&lt; 200, 300 &gt;
1 row found.
</pre>
<p>iii) This shows a multiple row insert.</p>
<pre>      CREATE OR REPLACE PROCEDURE multi_Row_insert
           (c1 DBMS_SQL.NUMBER_TABLE, c2 DBMS_SQL.NUMBER_TABLE, 
            r OUT DBMS_SQL.NUMBER_TABLE) is
      c NUMBER;
      n NUMBER;

      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;insert into tab VALUES (:bnd1, :bnd2) &#39; ||
                          &#39;RETURNING c1*c2 INTO :bnd3&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd2&#39;, c2);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd3&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd3&#39;, r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
</pre>
<p>The following script can be used to run this example in <code>ttIsql</code>:</p>
<pre>declare
   c1_array dbms_sql.number_table;
   c2_array dbms_sql.number_table;
   r_array dbms_sql.number_table;
begin
   c1_array(1) := 10;
   c1_array(2) := 20;
   c1_array(3) := 30;
   c2_array(1) := 15;
   c2_array(2) := 25;
   c2_array(3) := 35;
   multi_Row_insert(c1_array,c2_array,r_array);
   dbms_output.put_line(&#39;Product for row1 = &#39; || r_array(1));
   dbms_output.put_line(&#39;Product for row2 = &#39; || r_array(2));
   dbms_output.put_line(&#39;Product for row3 = &#39; || r_array(3));
end;
/
</pre>
<p>Following are the results. The table was initially empty.</p>
<pre>Product for row1 = 150
Product for row2 = 500
Product for row3 = 1050
 
PL/SQL procedure successfully completed.
 
Command&gt; select * from tab;
&lt; 10, 15 &gt;
&lt; 20, 25 &gt;
&lt; 30, 35 &gt;
3 rows found.
</pre>
<p>iv) This shows a multiple row update.</p>
<pre>      CREATE OR REPLACE PROCEDURE multi_Row_update
           (c1 NUMBER, c2 NUMBER, r OUT DBMS_SQL.NUMBER_TABLE) IS
        c NUMBER;
        n NUMBER;

     BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;UPDATE tab SET c1 = :bnd1 WHERE c2 &gt; :bnd2 &#39; ||
                          &#39;RETURNING c1*c2 INTO :bnd3&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd1&#39;, c1);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd2&#39;, c2);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd3&#39;, r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_OUTPUT.PUT_LINE(n || &#39; rows updated&#39;);
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd3&#39;, r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Note that <code>bnd1</code> and <code>bnd2</code> can be arrays as well. The value of the expression for all the rows updated is in <code>bnd3</code>. There is no way of differentiating which rows were updated of each value of <code>bnd1</code> and <code>bnd2</code>.</div>
<p>The following script can be used to run the example in <code>ttIsql</code>:</p>
<pre>declare
   c1 NUMBER;
   c2 NUMBER;
   r_array dbms_sql.number_table;
begin
   c1 := 100;
   c2 := 0;
   multi_Row_update(c1, c2, r_array);
   dbms_output.put_line(&#39;Product for row1 = &#39; || r_array(1));
   dbms_output.put_line(&#39;Product for row2 = &#39; || r_array(2));
   dbms_output.put_line(&#39;Product for row3 = &#39; || r_array(3));
end;
/
</pre>
<p>Here are the results, updating the rows that were inserted in the previous example. (The report of the number of rows updated is from the example itself. The products are reported by the test script.)</p>
<pre>3 rows updated
Product for row1 = 1500
Product for row2 = 2500
Product for row3 = 3500
 
PL/SQL procedure successfully completed.
 
Command&gt; select * from tab;
&lt; 100, 15 &gt;
&lt; 100, 25 &gt;
&lt; 100, 35 &gt;
3 rows found.
Command&gt;
</pre>
<p>v) This shows a multiple row delete.</p>
<pre>      CREATE OR REPLACE PROCEDURE multi_Row_delete
           (c1_test NUMBER,
            r OUT DBMS_SQL.NUMBER_TABLE) is
      c NUMBER;
      n NUMBER;

      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, &#39;DELETE FROM tab WHERE c1 = :bnd1 &#39; ||
                          &#39;RETURNING c1*c2 INTO :bnd2&#39;, DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_VARIABLE(c, &#39;bnd1&#39;, c1_test);
        DBMS_SQL.BIND_ARRAY(c, &#39;bnd2&#39;, r);
        n := DBMS_SQL.EXECUTE(c);
        DBMS_OUTPUT.PUT_LINE(n || &#39; rows deleted&#39;); 
        DBMS_SQL.VARIABLE_VALUE(c, &#39;bnd2&#39;, r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
</pre>
<p>The following script can be used to run the example in <code>ttIsql</code>.</p>
<pre>declare
   c1_test NUMBER;
   r_array dbms_sql.number_table;
begin
   c1_test := 100;
   multi_Row_delete(c1_test, r_array);
   dbms_output.put_line(&#39;Product for row1 = &#39; || r_array(1));
   dbms_output.put_line(&#39;Product for row2 = &#39; || r_array(2));
   dbms_output.put_line(&#39;Product for row3 = &#39; || r_array(3));
end;
/
</pre>
<p>Here are the results, deleting the rows that were updated in the previous example. (The report of the number of rows deleted is from the example itself. The products are reported by the test script.)</p>
<pre>3 rows deleted
Product for row1 = 1500
Product for row2 = 2500
Product for row3 = 3500
 
PL/SQL procedure successfully completed.
 
Command&gt; select * from tab;
0 rows found.
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>BIND_ARRAY</code> of <code>Number_Table</code> internally binds a number. The number of times statement is run depends on the number of elements in an inbind array.</div>
<p><span class="bold">Example 9: PL/SQL block in dynamic SQL</span></p>
<p>You can execute a PL/SQL block in dynamic SQL, using either <code>DBMS_SQL</code> or <code>EXECUTE IMMEDIATE</code>. This example executes a block using <code>DBMS_SQL</code>.</p>
<p>Assume the following procedure:</p>
<pre>Command&gt; create or replace procedure foo is
       &gt; begin
       &gt;    dbms_output.put_line(&#39;test&#39;);
       &gt; end;
       &gt; /
 
Procedure created.
</pre>
<p>Now execute the procedure in a PL/SQL block using <code>DBMS_SQL</code>:</p>
<pre>Command&gt; declare
       &gt;    c number;
       &gt;    r number;
       &gt; begin
       &gt;    c := dbms_sql.open_cursor;
       &gt;    dbms_sql.parse(c, &#39;begin foo; end;&#39;, dbms_sql.native);
       &gt;    r := dbms_sql.execute(c);
       &gt; end;
       &gt; /
test
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="refsect1" -->
<a id="CHDEEDCH"></a><a id="TTPLP71279"></a>
<hr/>
<div class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">Da<a id="sthref332"></a>ta structures</h2>
<p>The <code>DBMS_SQL</code> package defines the following record types and table types.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>The <code>PLS_INTEGER</code> and <code>BINARY_INTEGER</code> data types are identical. This document uses <code>BINARY_INTEGER</code> to indicate data types in reference information (such as for table types, record types, subprogram parameters, or subprogram return values), but may use either in discussion and examples.</p>
</li>
<li>
<p>The <code>INTEGER</code> and <code>NUMBER(38)</code> data types are also identical. This document uses <code>INTEGER</code> throughout.</p>
</li>
</ul>
</div>
<p class="titleinrefsubsect"><a id="sthref333"></a>Record types</p>
<ul>
<li>
<p><a href="#CHDCIIBF">DESC_REC record type</a></p>
</li>
<li>
<p><a href="#CHDGJIHF">DESC_REC2 record type</a></p>
</li>
<li>
<p><a href="#CHDDFEGC">DESC_REC3 record type</a></p>
</li>
</ul>
<p class="titleinrefsubsect"><a id="sthref334"></a>Table types</p>
<ul>
<li>
<p><a href="#CHDHGBCF">BINARY_DOUBLE_TABLE table type</a></p>
</li>
<li>
<p><a href="#CHDHIDEF">BINARY_FLOAT_TABLE table type</a></p>
</li>
<li>
<p><a href="#CIHIJBGI">BLOB_TABLE table type</a></p>
</li>
<li>
<p><a href="#CIHJHIHJ">CLOB_TABLE table type</a></p>
</li>
<li>
<p><a href="#CHDHGGFH">DATE_TABLE table type</a></p>
</li>
<li>
<p><a href="#CHDFBCDE">DESC_TAB table type</a></p>
</li>
<li>
<p><a href="#CHDIJCJA">DESC_TAB2 table type</a></p>
</li>
<li>
<p><a href="#CHDBGCBE">DESC_TAB3 table type</a></p>
</li>
<li>
<p><a href="#CHDIGEGH">INTERVAL_DAY_TO_SECOND_TABLE table type</a></p>
</li>
<li>
<p><a href="#CHDEHFCI">INTERVAL_YEAR_TO_MONTH_TABLE table type</a></p>
</li>
<li>
<p><a href="#CHDGFFAD">NUMBER_TABLE table type</a></p>
</li>
<li>
<p><a href="#CHDJHAEC">TIME_TABLE table type</a></p>
</li>
<li>
<p><a href="#CHDCEDDD">TIMESTAMP_TABLE table type</a></p>
</li>
<li>
<p><a href="#CHDHHECG">VARCHAR2_TABLE table type</a></p>
</li>
<li>
<p><a href="#CHDEGGIG">VARCHAR2A table type</a></p>
</li>
<li>
<p><a href="#CHDICCED">VARCHAR2S table type</a></p>
</li>
</ul>
<a id="CHDCIIBF"></a><a id="TTPLP71280"></a>
<hr/>
<h3 class="refsect2"><a id="sthref335"></a>DESC_REC record type</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
This type has been deprecated in favor of the <a href="#CHDGJIHF">DESC_REC2 record type</a>.</div>
<p>This record type holds the describe information for a single column in a dynamic query. It is the element type of the <code>DESC_TAB</code> table type and the <a href="#i1026120">DESCRIBE_COLUMNS procedure</a>.</p>
<p class="titleinrefsubsect"><a id="sthref336"></a>Syntax</p>
<pre>TYPE desc_rec IS RECORD (
      <span class="italic">col_type</span>            BINARY_INTEGER := 0,
      <span class="italic">col_max_len</span>         BINARY_INTEGER := 0,
      <span class="italic">col_name</span>            VARCHAR2(32)   := &#39;&#39;,
      <span class="italic">col_name_len</span>        BINARY_INTEGER := 0,
      <span class="italic">col_schema_name</span>     VARCHAR2(32)   := &#39;&#39;,
      <span class="italic">col_schema_name_len</span> BINARY_INTEGER := 0,
      <span class="italic">col_precision</span>       BINARY_INTEGER := 0,
      <span class="italic">col_scale</span>           BINARY_INTEGER := 0,
      <span class="italic">col_charsetid</span>       BINARY_INTEGER := 0,
      <span class="italic">col_charsetform</span>     BINARY_INTEGER := 0,
      <span class="italic">col_null_ok</span>         BOOLEAN        := TRUE);
TYPE desc_tab IS TABLE OF desc_rec INDEX BY BINARY_INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref337"></a>Fields</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71281"></a><a id="sthref338"></a><a id="sthref339"></a>Table 7-3 DESC_REC fields</p>
<table class="cellalignment1016" title="DESC_REC fields" summary="This table describes the parameters of the DBMS_DEBUG.BREAKPOINT_INFO subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t12">Field</th>
<th class="cellalignment1017" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_type</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t12 r1c2-t12">
<p>Type of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_max_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t12 r1c2-t12">
<p>Maximum column length</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_name</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t12 r1c2-t12">
<p>Name of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_name_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t12 r1c2-t12">
<p>Length of column name</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_schema_name</span></code></p>
</td>
<td class="cellalignment1018" headers="r6c1-t12 r1c2-t12">
<p>Column schema name</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r7c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_schema_name_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r7c1-t12 r1c2-t12">
<p>Length of column schema name</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r8c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_precision</span></code></p>
</td>
<td class="cellalignment1018" headers="r8c1-t12 r1c2-t12">
<p>Precision of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r9c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_scale</span></code></p>
</td>
<td class="cellalignment1018" headers="r9c1-t12 r1c2-t12">
<p>Scale of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r10c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_charsetid</span></code></p>
</td>
<td class="cellalignment1018" headers="r10c1-t12 r1c2-t12">
<p>Column character set ID</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r11c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_charsetform</span></code></p>
</td>
<td class="cellalignment1018" headers="r11c1-t12 r1c2-t12">
<p>Column character set form</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r12c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">col_null_ok</span></code></p>
</td>
<td class="cellalignment1018" headers="r12c1-t12 r1c2-t12">
<p>Null column flag, <code>TRUE</code> if <code>NULL</code> is allowable</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<a id="CHDGJIHF"></a><a id="TTPLP71282"></a>
<hr/>
<h3 class="refsect2"><a id="sthref340"></a>DESC_REC2 record type</h3>
<p><code>DESC_REC2</code> is the element type of the <code>DESC_TAB2</code> table type and the <a href="#i1029368">DESCRIBE_COLUMNS2 procedure</a>.</p>
<p>This record type is identical to <code>DESC_REC</code> except for the <code><span class="codeinlineitalic">col_name</span></code> field, which has been expanded to the maximum possible size for <code>VARCHAR2</code>. It is therefore preferred to <code>DESC_REC</code>, which is deprecated, because column name values can be greater than 32 characters.</p>
<p class="titleinrefsubsect"><a id="sthref341"></a>Syntax</p>
<pre>TYPE desc_rec2 IS RECORD (
   <span class="italic">col_type</span>            binary_integer := 0,
   <span class="italic">col_max_len</span>         binary_integer := 0,
   <span class="italic">col_name</span>            varchar2(32767) := &#39;&#39;,
   <span class="italic">col_name_len</span>        binary_integer := 0,
   <span class="italic">col_schema_name</span>     varchar2(32)   := &#39;&#39;,
   <span class="italic">col_schema_name_len</span> binary_integer := 0,
   <span class="italic">col_precision</span>       binary_integer := 0,
   <span class="italic">col_scale</span>           binary_integer := 0,
   <span class="italic">col_charsetid</span>       binary_integer := 0,
   <span class="italic">col_charsetform</span>     binary_integer := 0,
   <span class="italic">col_null_ok</span>         boolean        := TRUE);
</pre>
<p class="titleinrefsubsect"><a id="sthref342"></a>Fields</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71283"></a><a id="sthref343"></a><a id="sthref344"></a>Table 7-4 DESC_REC2 fields</p>
<table class="cellalignment1016" title="DESC_REC2 fields" summary="This table describes the parameters of the DBMS_DEBUG.BREAKPOINT_INFO subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t13">Field</th>
<th class="cellalignment1017" id="r1c2-t13">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_type</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t13 r1c2-t13">
<p>Type of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_max_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t13 r1c2-t13">
<p>Maximum column length</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_name</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t13 r1c2-t13">
<p>Name of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_name_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t13 r1c2-t13">
<p>Length of column name</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_schema_name</span></code></p>
</td>
<td class="cellalignment1018" headers="r6c1-t13 r1c2-t13">
<p>Column schema name</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r7c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_schema_name_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r7c1-t13 r1c2-t13">
<p>Length of column schema name</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r8c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_precision</span></code></p>
</td>
<td class="cellalignment1018" headers="r8c1-t13 r1c2-t13">
<p>Precision of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r9c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_scale</span></code></p>
</td>
<td class="cellalignment1018" headers="r9c1-t13 r1c2-t13">
<p>Scale of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r10c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_charsetid</span></code></p>
</td>
<td class="cellalignment1018" headers="r10c1-t13 r1c2-t13">
<p>Column character set ID</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r11c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_charsetform</span></code></p>
</td>
<td class="cellalignment1018" headers="r11c1-t13 r1c2-t13">
<p>Column character set form</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r12c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">col_null_ok</span></code></p>
</td>
<td class="cellalignment1018" headers="r12c1-t13 r1c2-t13">
<p>Null column flag, <code>TRUE</code> if <code>NULL</code> is allowable</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<a id="CHDDFEGC"></a><a id="TTPLP71284"></a>
<hr/>
<h3 class="refsect2"><a id="sthref345"></a>DESC_REC3 record type</h3>
<p><code>DESC_REC3</code> is the element type of the <code>DESC_TAB3</code> table type and the <a href="#CHDJBBFH">DESCRIBE_COLUMNS3 procedure</a>.</p>
<p><code>DESC_REC3</code> is identical to <code>DESC_REC2</code> except for two additional fields to hold the type name (<code><span class="codeinlineitalic">type_name</span></code>) and type name len (<code><span class="codeinlineitalic">type_name_len</span></code>) of a column in a dynamic query. The <code><span class="codeinlineitalic">col_type_name</span></code> and <code><span class="codeinlineitalic">col_type_name_len</span></code> fields are only populated when the <code><span class="codeinlineitalic">col_type</span></code> field value is 109 (the Oracle Database type number for user-defined types), which is not currently used.</p>
<p class="titleinrefsubsect"><a id="sthref346"></a>Syntax</p>
<pre>TYPE desc_rec3 IS RECORD (
   <span class="italic">col_type</span>               binary_integer := 0,
   <span class="italic">col_max_len</span>            binary_integer := 0,
   <span class="italic">col_name</span>               varchar2(32767) := &#39;&#39;,
   <span class="italic">col_name_len</span>           binary_integer := 0,
   <span class="italic">col_schema_name</span>        varchar2(32) := &#39;&#39;,
   <span class="italic">col_schema_name_len</span>    binary_integer := 0,
   <span class="italic">col_precision</span>          binary_integer := 0,
   <span class="italic">col_scale</span>              binary_integer := 0,
   <span class="italic">col_charsetid</span>          binary_integer := 0,
   <span class="italic">col_charsetform</span>        binary_integer := 0,
   <span class="italic">col_null_ok</span>            boolean := TRUE,
   <span class="italic">col_type_name</span>          varchar2(32767)   := &#39;&#39;,
   <span class="italic">col_type_name_len</span>      binary_integer := 0);
</pre>
<p class="titleinrefsubsect"><a id="sthref347"></a>Fields</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71285"></a><a id="sthref348"></a><a id="sthref349"></a>Table 7-5 DESC_REC3 fields</p>
<table class="cellalignment1016" title="DESC_REC3 fields" summary="This table describes the parameters of the DBMS_DEBUG.BREAKPOINT_INFO subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t14">Field</th>
<th class="cellalignment1017" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_type</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t14 r1c2-t14">
<p>Type of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_max_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t14 r1c2-t14">
<p>Maximum column length</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_name</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t14 r1c2-t14">
<p>Name of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_name_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t14 r1c2-t14">
<p>Length of column name</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_schema_name</span></code></p>
</td>
<td class="cellalignment1018" headers="r6c1-t14 r1c2-t14">
<p>Column schema name</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r7c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_schema_name_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r7c1-t14 r1c2-t14">
<p>Length of column schema name</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r8c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_precision</span></code></p>
</td>
<td class="cellalignment1018" headers="r8c1-t14 r1c2-t14">
<p>Precision of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r9c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_scale</span></code></p>
</td>
<td class="cellalignment1018" headers="r9c1-t14 r1c2-t14">
<p>Scale of column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r10c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_charsetid</span></code></p>
</td>
<td class="cellalignment1018" headers="r10c1-t14 r1c2-t14">
<p>Column character set ID</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r11c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_charsetform</span></code></p>
</td>
<td class="cellalignment1018" headers="r11c1-t14 r1c2-t14">
<p>Column character set form</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r12c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_null_ok</span></code></p>
</td>
<td class="cellalignment1018" headers="r12c1-t14 r1c2-t14">
<p>Null column flag, <code>TRUE</code> if <code>NULL</code> is allowable</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r13c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_type_name</span></code></p>
</td>
<td class="cellalignment1018" headers="r13c1-t14 r1c2-t14">
<p>Reserved for future use</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r14c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">col_type_name_len</span></code></p>
</td>
<td class="cellalignment1018" headers="r14c1-t14 r1c2-t14">
<p>Reserved for future use</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<a id="CHDHGBCF"></a><a id="TTPLP71286"></a>
<hr/>
<h3 class="refsect2"><a id="sthref350"></a>BINARY_DOUBLE_TABLE table type</h3>
<p>This is a table of <code>BINARY_DOUBLE</code>.</p>
<p class="titleinrefsubsect"><a id="sthref351"></a>Syntax</p>
<pre>TYPE binary_double_table IS TABLE OF BINARY_DOUBLE INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDHIDEF"></a><a id="TTPLP71287"></a>
<hr/>
<h3 class="refsect2"><a id="sthref352"></a>BINARY_FLOAT_TABLE table type</h3>
<p>This is a table of <code>BINARY_FLOAT</code>.</p>
<p class="titleinrefsubsect"><a id="sthref353"></a>Syntax</p>
<pre>TYPE binary_float_table IS TABLE OF BINARY_FLOAT INDEX BY BINARY_INTEGER;
</pre>
<a id="CIHIJBGI"></a><a id="TTPLP71652"></a>
<hr/>
<h3 class="refsect2"><a id="sthref354"></a>BLOB_TABLE table type</h3>
<p>This is a table of <code>BLOB</code>.</p>
<p class="titleinrefsubsect"><a id="sthref355"></a>Syntax</p>
<pre>TYPE blob_table IS TABLE OF BLOB INDEX BY BINARY_INTEGER;
</pre>
<a id="CIHJHIHJ"></a><a id="TTPLP71653"></a>
<hr/>
<h3 class="refsect2"><a id="sthref356"></a>CLOB_TABLE table type</h3>
<p>This is a table of <code>CLOB</code>.</p>
<p class="titleinrefsubsect"><a id="sthref357"></a>Syntax</p>
<pre>TYPE clob_table IS TABLE OF CLOB INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDHGGFH"></a><a id="TTPLP71288"></a>
<hr/>
<h3 class="refsect2"><a id="sthref358"></a>DATE_TABLE table type</h3>
<p>This is a table of <code>DATE</code>.</p>
<p class="titleinrefsubsect"><a id="sthref359"></a>Syntax</p>
<pre>type date_table IS TABLE OF DATE INDEX BY BINARY_INTEGER; 
</pre>
<a id="CHDFBCDE"></a><a id="TTPLP71289"></a>
<hr/>
<h3 class="refsect2"><a id="sthref360"></a>DESC_TAB table type</h3>
<p>This is a table of <a href="#CHDCIIBF">DESC_REC record type</a>.</p>
<p class="titleinrefsubsect"><a id="sthref361"></a>Syntax</p>
<pre>TYPE desc_tab IS TABLE OF desc_rec INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDIJCJA"></a><a id="TTPLP71290"></a>
<hr/>
<h3 class="refsect2"><a id="sthref362"></a>DESC_TAB2 table type</h3>
<p>This is a table of <a href="#CHDGJIHF">DESC_REC2 record type</a>.</p>
<p class="titleinrefsubsect"><a id="sthref363"></a>Syntax</p>
<pre>TYPE desc_tab2 IS TABLE OF desc_rec2 INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDBGCBE"></a><a id="TTPLP71291"></a>
<hr/>
<h3 class="refsect2"><a id="sthref364"></a>DESC_TAB3 table type</h3>
<p>This is a table of <a href="#CHDDFEGC">DESC_REC3 record type</a>.</p>
<p class="titleinrefsubsect"><a id="sthref365"></a>Syntax</p>
<pre>TYPE desc_tab3 IS TABLE OF desc_rec3 INDEX BY BINARY_INTEGER; 
</pre>
<a id="CHDIGEGH"></a><a id="TTPLP71292"></a>
<hr/>
<h3 class="refsect2"><a id="sthref366"></a>INTERVAL_DAY_TO_SECOND_TABLE table type</h3>
<p>This is a table of <code>DSINTERVAL_UNCONSTRAINED</code>.</p>
<p class="titleinrefsubsect"><a id="sthref367"></a>Syntax</p>
<pre> TYPE interval_day_to_second_Table IS TABLE OF
    DSINTERVAL_UNCONSTRAINED INDEX BY binary_integer;
</pre>
<a id="CHDEHFCI"></a><a id="TTPLP71293"></a>
<hr/>
<h3 class="refsect2"><a id="sthref368"></a>INTERVAL_YEAR_TO_MONTH_TABLE table type</h3>
<p>This is a table of <code>YMINTERVAL_UNCONSTRAINED</code>.</p>
<p class="titleinrefsubsect"><a id="sthref369"></a>Syntax</p>
<pre>TYPE interval_year_to_month_table IS TABLE OF YMINTERVAL_UNCONSTRAINED 
   INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDGFFAD"></a><a id="TTPLP71294"></a>
<hr/>
<h3 class="refsect2"><a id="sthref370"></a>NUMBER_TABLE table type</h3>
<p>This is a table of <code>NUMBER</code>.</p>
<p class="titleinrefsubsect"><a id="sthref371"></a>Syntax</p>
<pre>TYPE number_table IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDJHAEC"></a><a id="TTPLP71295"></a>
<hr/>
<h3 class="refsect2"><a id="sthref372"></a>TIME_TABLE table type</h3>
<p>This is a table of <code>TIME_UNCONSTRAINED</code>.</p>
<p class="titleinrefsubsect"><a id="sthref373"></a>Syntax</p>
<pre>TYPE time_table IS TABLE OF TIME_UNCONSTRAINED INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDCEDDD"></a><a id="TTPLP71296"></a>
<hr/>
<h3 class="refsect2"><a id="sthref374"></a>TIMESTAMP_TABLE table type</h3>
<p>This is a table of <code>TIMESTAMP_UNCONSTRAINED</code>.</p>
<p class="titleinrefsubsect"><a id="sthref375"></a>Syntax</p>
<pre>TYPE timestamp_table IS TABLE OF TIMESTAMP_UNCONSTRAINED INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDHHECG"></a><a id="TTPLP71297"></a>
<hr/>
<h3 class="refsect2"><a id="sthref376"></a>VARCHAR2_TABLE table type</h3>
<p>This is table of <code>VARCHAR2(2000)</code>.</p>
<p class="titleinrefsubsect"><a id="sthref377"></a>Syntax</p>
<pre>TYPE varchar2_table IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDEGGIG"></a><a id="TTPLP71298"></a>
<hr/>
<h3 class="refsect2"><a id="sthref378"></a>VARCHAR2A table type</h3>
<p>This is table of <code>VARCHAR2(32767)</code>.</p>
<p class="titleinrefsubsect"><a id="sthref379"></a>Syntax</p>
<pre>TYPE varchar2a IS TABLE OF VARCHAR2(32767) INDEX BY BINARY_INTEGER;
</pre>
<a id="CHDICCED"></a><a id="TTPLP71299"></a>
<hr/>
<h3 class="refsect2"><a id="sthref380"></a>VARCHAR2S table type</h3>
<p>This is table of <code>VARCHAR2(256)</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This type has been superseded by the <a href="#CHDEGGIG">VARCHAR2A table type</a>. It is supported only for backward compatibility.</div>
<p class="titleinrefsubsect"><a id="sthref381"></a>Syntax</p>
<pre>TYPE varchar2s IS TABLE OF VARCHAR2(256) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsect1" -->
<a id="i997453"></a><a id="TTPLP71300"></a>
<hr/>
<div class="refsect1">
<h2 class="refsect1">Sum<a id="sthref382"></a>mary of DBMS_SQL subprograms</h2>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71301"></a><a id="sthref383"></a><a id="sthref384"></a>Table 7-6 <span class="bold">DBMS_SQL</span> Package Subprograms</p>
<table class="cellalignment1016" title="DBMS_SQL Package Subprograms" summary="This table lists the DBMS_SQL subprograms in alphabetical order and briefly describes them." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t16">Subprogram</th>
<th class="cellalignment1017" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t16" headers="r1c1-t16">
<p><a href="#i1025085">BIND_ARRAY procedure</a></p>
</td>
<td class="cellalignment1018" headers="r2c1-t16 r1c2-t16">
<p>Binds a given value to a given collection.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t16" headers="r1c1-t16">
<p><a href="#i1030093">BIND_VARIABLE procedure</a></p>
</td>
<td class="cellalignment1018" headers="r3c1-t16 r1c2-t16">
<p>Binds a given value to a given variable.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t16" headers="r1c1-t16">
<p><a href="#i1026299">CLOSE_CURSOR procedure</a></p>
</td>
<td class="cellalignment1018" headers="r4c1-t16 r1c2-t16">
<p>Closes given cursor and frees memory.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t16" headers="r1c1-t16">
<p><a href="#i1025449">COLUMN_VALUE procedure</a></p>
</td>
<td class="cellalignment1018" headers="r5c1-t16 r1c2-t16">
<p>Returns value of the cursor element for a given position in a cursor.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t16" headers="r1c1-t16">
<p><a id="sthref385"></a>COLUMN_VALUE_LONG procedure</p>
</td>
<td class="cellalignment1018" headers="r6c1-t16 r1c2-t16">
<p>Returns a selected part of a <code>LONG</code> column that has been defined using <code>DEFINE_COLUMN_LONG</code>.</p>
<p><span class="bold">Important</span>: Because TimesTen does not support the <code>LONG</code> data type, attempting to use this procedure in TimesTen results in an <code>ORA-01018</code> error at runtime.</p>
<p>The <code>COLUMN_VALUE_LONG</code> and <code>DEFINE_COLUMN_LONG</code> procedures are therefore not documented in this manual.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r7c1-t16" headers="r1c1-t16">
<p><a href="#i1025685">DEFINE_ARRAY procedure</a></p>
</td>
<td class="cellalignment1018" headers="r7c1-t16 r1c2-t16">
<p>Defines a collection to be selected from the given cursor. Used only with <code>SELECT</code> statements.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r8c1-t16" headers="r1c1-t16">
<p><a href="#i1025686">DEFINE_COLUMN procedure</a></p>
</td>
<td class="cellalignment1018" headers="r8c1-t16 r1c2-t16">
<p>Defines a column to be selected from the given cursor. Used only with <code>SELECT</code> statements.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r9c1-t16" headers="r1c1-t16">
<p><a id="sthref386"></a>DEFINE_COLUMN_LONG procedure</p>
</td>
<td class="cellalignment1018" headers="r9c1-t16 r1c2-t16">
<p>Defines a <code>LONG</code> column to be selected from the given cursor. Used with <code>SELECT</code> statements.</p>
<p><span class="bold">Important</span>: Because TimesTen does not support the <code>LONG</code> data type, attempting to use the <code>COLUMN_VALUE_LONG</code> procedure in TimesTen results in an <code>ORA-01018</code> error at runtime.</p>
<p>The <code>COLUMN_VALUE_LONG</code> and <code>DEFINE_COLUMN_LONG</code> procedures are therefore not documented in this manual.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r10c1-t16" headers="r1c1-t16">
<p><a href="#i1026120">DESCRIBE_COLUMNS procedure</a></p>
</td>
<td class="cellalignment1018" headers="r10c1-t16 r1c2-t16">
<p>Describes the columns for a cursor opened and parsed through <code>DBMS_SQL</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r11c1-t16" headers="r1c1-t16">
<p><a href="#i1029368">DESCRIBE_COLUMNS2 procedure</a></p>
</td>
<td class="cellalignment1018" headers="r11c1-t16 r1c2-t16">
<p>Describes the specified column, as an alternative to <a href="#i1026120">DESCRIBE_COLUMNS procedure</a>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r12c1-t16" headers="r1c1-t16">
<p><a href="#CHDJBBFH">DESCRIBE_COLUMNS3 procedure</a></p>
</td>
<td class="cellalignment1018" headers="r12c1-t16 r1c2-t16">
<p>Describes the specified column, as an alternative to <a href="#i1026120">DESCRIBE_COLUMNS procedure</a>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r13c1-t16" headers="r1c1-t16">
<p><a href="#i1025983">EXECUTE function</a></p>
</td>
<td class="cellalignment1018" headers="r13c1-t16 r1c2-t16">
<p>Executes a given cursor.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r14c1-t16" headers="r1c1-t16">
<p><a href="#i1025711">EXECUTE_AND_FETCH function</a></p>
</td>
<td class="cellalignment1018" headers="r14c1-t16 r1c2-t16">
<p>Executes a given cursor and fetches rows.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r15c1-t16" headers="r1c1-t16">
<p><a href="#i1026065">FETCH_ROWS function</a></p>
</td>
<td class="cellalignment1018" headers="r15c1-t16 r1c2-t16">
<p>Fetches a row from a given cursor.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r16c1-t16" headers="r1c1-t16">
<p><a href="#i1026423">IS_OPEN function</a></p>
</td>
<td class="cellalignment1018" headers="r16c1-t16 r1c2-t16">
<p>Returns <code>TRUE</code> if the given cursor is open.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r17c1-t16" headers="r1c1-t16">
<p><a href="#i1026408">LAST_ERROR_POSITION function</a></p>
</td>
<td class="cellalignment1018" headers="r17c1-t16 r1c2-t16">
<p>Returns byte offset in the SQL statement text where the error occurred.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r18c1-t16" headers="r1c1-t16">
<p><a href="#i1026354">LAST_ROW_COUNT function</a></p>
</td>
<td class="cellalignment1018" headers="r18c1-t16 r1c2-t16">
<p>Returns cumulative count of the number of rows fetched.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r19c1-t16" headers="r1c1-t16">
<p><a href="#i1026364">LAST_ROW_ID function</a></p>
</td>
<td class="cellalignment1018" headers="r19c1-t16 r1c2-t16">
<p>Returns the rowid of last row processed, <code>NULL</code> for TimesTen.</p>
<p>TimesTen does not support rowid of the last row operated on by a DML statement.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r20c1-t16" headers="r1c1-t16">
<p><a href="#i1026374">LAST_SQL_FUNCTION_CODE function</a></p>
</td>
<td class="cellalignment1018" headers="r20c1-t16 r1c2-t16">
<p>Returns SQL function code for statement.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r21c1-t16" headers="r1c1-t16">
<p><a href="#i997665">OPEN_CURSOR function</a></p>
</td>
<td class="cellalignment1018" headers="r21c1-t16 r1c2-t16">
<p>Returns cursor ID number of new cursor.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r22c1-t16" headers="r1c1-t16">
<p><a href="#i997676">PARSE procedures</a></p>
</td>
<td class="cellalignment1018" headers="r22c1-t16 r1c2-t16">
<p>Parses given statement.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r23c1-t16" headers="r1c1-t16">
<p><a href="#CHDJDGDG">TO_CURSOR_NUMBER function</a></p>
</td>
<td class="cellalignment1018" headers="r23c1-t16 r1c2-t16">
<p>Takes an opened strongly or weakly typed REF CURSOR and transforms it into a <code>DBMS_SQL</code> cursor number.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r24c1-t16" headers="r1c1-t16">
<p><a href="#CHDFDCDE">TO_REFCURSOR function</a></p>
</td>
<td class="cellalignment1018" headers="r24c1-t16 r1c2-t16">
<p>Takes an opened, parsed, and executed cursor and transforms or migrates it into a PL/SQL-manageable REF CURSOR (a weakly typed cursor) that can be consumed by PL/SQL native dynamic SQL.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r25c1-t16" headers="r1c1-t16">
<p><a href="#i998371">VARIABLE_VALUE procedure</a></p>
</td>
<td class="cellalignment1018" headers="r25c1-t16 r1c2-t16">
<p>Returns value of named variable for given cursor.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<a id="i1025085"></a><a id="TTPLP71302"></a>
<hr/>
<h3 class="refsect2"><a id="sthref387"></a>BIND_ARRAY procedure</h3>
<p>This procedure binds a given value or set of values to a given variable in a cursor, based on the name of the variable in the statement.</p>
<p class="titleinrefsubsect"><a id="sthref388"></a>Syntax</p>
<pre>DBMS_SQL.BIND_ARRAY ( 
   <span class="italic">c</span>                   IN INTEGER, 
   <span class="italic">name</span>                IN VARCHAR2, 
   &lt;<span class="italic">table_variable</span>&gt;    IN &lt;<span class="italic">datatype</span>&gt; 
 [,<span class="italic">index1</span>              IN INTEGER, 
   <span class="italic">index2</span>              IN INTEGER)] ); 
</pre>
<p>Where the <code><span class="codeinlineitalic">table_variable</span></code> and its corresponding <code><span class="codeinlineitalic">datatype</span></code> can be any of the following matching pairs:</p>
<pre>&lt;bflt_tab&gt;     dbms_sql.Binary_Float_Table
&lt;bdbl_tab&gt;     dbms_sql.Binary_Double_Table
&lt;bl_tab&gt;       dbms_sql.Blob_Table
&lt;cl_tab&gt;       dbms_sql.Clob_Table
&lt;c_tab&gt;        dbms_sql.Varchar2_Table
&lt;d_tab&gt;        dbms_sql.Date_Table
&lt;ids_tab&gt;      dbms_sql.Interval_Day_to_Second_Table
&lt;iym_tab&gt;      dbms_sql.Interval_Year_to_Month_Table
&lt;n_tab&gt;        dbms_sql.Number_Table
&lt;tm_tab&gt;       dbms_sql.Time_Table
&lt;tms_tab&gt;      dbms_sql.Timestamp_Table
</pre>
<p>Notice that the <code>BIND_ARRAY</code> procedure is overloaded to accept different data types.</p>
<p class="titleinrefsubsect"><a id="sthref389"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71303"></a><a id="sthref390"></a><a id="sthref391"></a>Table 7-7 BIND_ARRAY procedure parameters</p>
<table class="cellalignment1016" title="BIND_ARRAY procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.BIND_ARRAY subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t17">Parameter</th>
<th class="cellalignment1017" id="r1c2-t17">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t17" headers="r1c1-t17">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t17 r1c2-t17">
<p>ID number of the cursor where the value is to be bound</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t17" headers="r1c1-t17">
<p><code><span class="codeinlineitalic">name</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t17 r1c2-t17">
<p>Name of the collection in the statement</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t17" headers="r1c1-t17">
<p><code><span class="codeinlineitalic">table_variable</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t17 r1c2-t17">
<p>Local variable that has been declared as <code><span class="codeinlineitalic">datatype</span></code></p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t17" headers="r1c1-t17">
<p><code><span class="codeinlineitalic">index1</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t17 r1c2-t17">
<p>Index for the table element that marks the lower bound of the range</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t17" headers="r1c1-t17">
<p><code><span class="codeinlineitalic">index2</span></code></p>
</td>
<td class="cellalignment1018" headers="r6c1-t17 r1c2-t17">
<p>Index for the table element that marks the upper bound of the range</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref392"></a>Usage notes</p>
<p>The length of the bind variable name should be less than or equal to 30 bytes.</p>
<p>For binding a range, the table must contain the elements that specify the range&mdash;<code>tab(</code><code><span class="codeinlineitalic">index1</span></code><code>)</code> and <code>tab(</code><code><span class="codeinlineitalic">index2</span></code><code>)</code>&mdash;but the range does not have to be dense. The <code><span class="codeinlineitalic">index1</span></code> value must be less than or equal to <code><span class="codeinlineitalic">index2</span></code>. All elements between <code>tab(</code><code><span class="codeinlineitalic">index1</span></code><code>)</code> and <code>tab(</code><code><span class="codeinlineitalic">index2</span></code><code>)</code> are used in the bind.</p>
<p>If you do not specify indexes in the bind call, and two different binds in a statement specify tables that contain a different number of elements, then the number of elements actually used is the minimum number between all tables. This is also the case if you specify indexes. The minimum range is selected between the two indexes for all tables.</p>
<p>Not all bind variables in a query have to be array binds. Some can be regular binds and the same value are used for each element of the collections in expression evaluations (and so forth).</p>
<p class="subhead2"><a id="TTPLP71304"></a>Bulk array binds</p>
<p><a id="sthref393"></a>Bulk selects, inserts, updates, and deletes can enhance the performance of applications by bundling many calls into one. The <code>DBMS_SQL</code> package lets you work on collections of data using the PL/SQL table type.</p>
<p><span class="italic"><a id="sthref394"></a><a id="sthref395"></a>Table items</span> are unbounded homogeneous collections. In persistent storage, they are like other relational tables and have no intrinsic ordering. But when a table item is brought into the workspace (either by querying or by navigational access of persistent data), or when it is created as the value of a PL/SQL variable or parameter, its elements are given subscripts that can be used with array-style syntax to get and set the values of elements.</p>
<p>The subscripts of these elements need not be dense, and can be any number including negative numbers. For example, a table item can contain elements at locations -10, 2, and 7 only.</p>
<p>When a table item is moved from transient work space to persistent storage, the subscripts are not stored. The table item is unordered in persistent storage.</p>
<p>At bind time the table is copied out from the PL/SQL buffers into local <code>DBMS_SQL</code> buffers (the same as for all scalar types), then the table is manipulated from the local <code>DBMS_SQL</code> buffers. Therefore, if you change the table after the bind call, then that change does not affect the way the execute acts.</p>
<p class="subhead2"><a id="TTPLP71305"></a>Ty<a id="sthref396"></a>pes for scalar collections</p>
<p>You can declare a local variable as one of the following table-item types, which are defined as public types in <code>DBMS_SQL</code>.</p>
<pre>TYPE binary_double_table 
                    IS TABLE OF BINARY_DOUBLE  INDEX BY BINARY_INTEGER;
TYPE binary_float_table 
                    IS TABLE OF BINARY_FLOAT   INDEX BY BINARY_INTEGER;
TYPE blob_table     IS TABLE OF BLOB           INDEX BY BINARY_INTEGER;
TYPE clob_table     IS TABLE OF CLOB           INDEX BY BINARY_INTEGER;
TYPE date_table     IS TABLE OF DATE           INDEX BY BINARY_INTEGER;
TYPE interval_day_to_second_table 
                    IS TABLE OF dsinterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE interval_year_to_month_table 
                    IS TABLE OF yminterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE number_table   IS TABLE OF NUMBER         INDEX BY BINARY_INTEGER;
TYPE time_table     IS TABLE OF time_unconstrained           
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_table 
                    IS TABLE OF timestamp_unconstrained   
                                               INDEX BY BINARY_INTEGER;
TYPE varchar2_table IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;

&lt;tm_tab&gt;   Time_Table
&lt;tms_tab&gt;  Timestamp_Table
&lt;ids_tab&gt;  Interval_Day_To_Second_Table
&lt;iym_tab&gt;  Interval_Year_To_Month_Table
</pre>
<p class="titleinrefsubsect"><a id="sthref397"></a>Examples</p>
<p>See <a href="#i996963">&#34;Examples&#34;</a>.</p>
<a id="i1030093"></a><a id="TTPLP71306"></a>
<hr/>
<h3 class="refsect2"><a id="sthref398"></a>BIND_VARIABLE procedure</h3>
<p>This procedures binds a given value or set of values to a given variable in a cursor, based on the name of the variable in the statement.</p>
<p class="titleinrefsubsect"><a id="sthref399"></a>Syntax</p>
<pre>DBMS_SQL.BIND_VARIABLE (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">name</span>           IN VARCHAR2,
   <span class="italic">value</span>          IN &lt;<span class="italic">datatype</span>&gt;);
</pre>
<p>Where <code><span class="codeinlineitalic">datatype</span></code> can be any of the following types:</p>
<pre>BINARY_DOUBLE
BINARY_FLOAT
BLOB
CLOB CHARACTER SET ANY_CS
DATE
INTERVAL DAY TO SECOND(9,9) (DSINTERVAL_UNCONSTRAINED)
NUMBER
TIME(9) (TIME_UNCONSTRAINED)
TIMESTAMP(9) (TIMESTAMP_UNCONSTRAINED)
VARCHAR2 CHARACTER SET ANY_CS
INTERVAL YEAR TO  MONTH(9) (YMINTERVAL_UNCONSTRAINED)
VARRAY
Nested table
</pre>
<p>Notice that <code>BIND_VARIABLE</code> is overloaded to accept different data types.</p>
<p>The following syntax is also supported for <code>BIND_VARIABLE</code>. The square brackets <code>[]</code> indicate an optional parameter for the <code>BIND_VARIABLE</code> function.</p>
<pre>DBMS_SQL.BIND_VARIABLE (
   <span class="italic">c</span>            IN INTEGER,
   <span class="italic">name</span>         IN VARCHAR2,
   <span class="italic">value</span>        IN VARCHAR2 CHARACTER SET ANY_CS [,out_value_size IN INTEGER]);
</pre>
<p>To bind <code>CHAR</code>, <code>RAW</code>, and <code>ROWID</code> data, you can use the following variations on the following syntax:</p>
<pre>DBMS_SQL.BIND_VARIABLE_CHAR (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">name</span>           IN VARCHAR2,
   <span class="italic">value</span>          IN CHAR CHARACTER SET ANY_CS [,out_value_size IN INTEGER]);

DBMS_SQL.BIND_VARIABLE_RAW (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">name</span>           IN VARCHAR2,
   <span class="italic">value</span>          IN RAW [,out_value_size IN INTEGER]);

DBMS_SQL.BIND_VARIABLE_ROWID (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">name</span>           IN VARCHAR2,
   <span class="italic">value</span>          IN ROWID);
</pre>
<p class="titleinrefsubsect"><a id="sthref400"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71307"></a><a id="sthref401"></a><a id="sthref402"></a>Table 7-8 BIND_VARIABLE procedure parameters</p>
<table class="cellalignment1016" title="BIND_VARIABLE procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.BIND_VARIABLE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t18">Parameter</th>
<th class="cellalignment1017" id="r1c2-t18">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t18" headers="r1c1-t18">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t18 r1c2-t18">
<p>ID number of the cursor where the value is to be bound</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t18" headers="r1c1-t18">
<p><code><span class="codeinlineitalic">name</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t18 r1c2-t18">
<p>Name of the variable in the statement</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t18" headers="r1c1-t18">
<p><code><span class="codeinlineitalic">value</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t18 r1c2-t18">
<p>Value to bind to the variable in the cursor</p>
<p>For <code>IN</code> and <code>IN OUT</code> variables, the value has the same type as the type of the value being passed in for this parameter.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t18" headers="r1c1-t18">
<p><code><span class="codeinlineitalic">out_value_size</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t18 r1c2-t18">
<p>Maximum expected <code>OUT</code> value size, in bytes, for the <code>VARCHAR2</code>, <code>RAW</code>, <code>CHAR OUT</code> or <code>IN OUT</code> variable</p>
<p>If no size is given, then the length of the current value is used. This parameter must be specified if the <code><span class="codeinlineitalic">value</span></code> parameter is not initialized.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref403"></a>Usage notes</p>
<p>If the variable is an <code>IN</code> or <code>IN OUT</code> variable or an <code>IN</code> collection, then the given bind value must be valid for the variable or array type. Bind values for <code>OUT</code> variables are ignored.</p>
<p>The bind variables or collections of a SQL statement are identified by their names. When binding a value to a bind variable or bind array, the string identifying it in the statement must contain a leading colon, as shown in the following example:</p>
<pre>SELECT last_name FROM employees WHERE salary &gt; :X;
</pre>
<p>For this example, the corresponding bind call would look similar to the following:</p>
<pre>BIND_VARIABLE(cursor_name, &#39;:X&#39;, 3500); 
</pre>
<p>Or:</p>
<pre>BIND_VARIABLE (cursor_name, &#39;X&#39;, 3500);
</pre>
<p>The length of the bind variable name should be less than or equal to 30 bytes.</p>
<p class="titleinrefsubsect"><a id="sthref404"></a>Examples</p>
<p>See <a href="#i996963">&#34;Examples&#34;</a>.</p>
<a id="i1026299"></a><a id="TTPLP71308"></a>
<hr/>
<h3 class="refsect2"><a id="sthref405"></a>CLOSE_CURSOR procedure</h3>
<p>This procedure closes a given cursor. The memory allocated to the cursor is released and you can no longer fetch from that cursor.</p>
<p class="titleinrefsubsect"><a id="sthref406"></a>Syntax</p>
<pre>DBMS_SQL.CLOSE_CURSOR (
   <span class="italic">c</span>    IN OUT INTEGER);
</pre>
<p class="titleinrefsubsect"><a id="sthref407"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71309"></a><a id="sthref408"></a><a id="sthref409"></a>Table 7-9 CLOSE_CURSOR procedure parameters</p>
<table class="cellalignment1016" title="CLOSE_CURSOR procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.CLOSE_CURSOR subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t19">Parameter</th>
<th class="cellalignment1017" id="r1c2-t19">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t19" headers="r1c1-t19">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t19 r1c2-t19">
<p><code>(IN)</code> ID number of the cursor to close</p>
<p><code>(OUT)</code> <code>NULL</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<a id="i1025449"></a><a id="TTPLP71310"></a>
<hr/>
<h3 class="refsect2"><a id="sthref410"></a>COLUMN_VALUE procedure</h3>
<p>This procedure is used to access the data fetched by calling the <a href="#i1026065">FETCH_ROWS function</a>. It returns the value of the cursor element for a given position in a given cursor.</p>
<p class="titleinrefsubsect"><a id="sthref411"></a>Syntax</p>
<pre>DBMS_SQL.COLUMN_VALUE (
   <span class="italic">c</span>                 IN  INTEGER,
   <span class="italic">position</span>          IN  INTEGER,
   <span class="italic">value</span>             OUT &lt;<span class="italic">datatype</span>&gt; 
 [,<span class="italic">column_error</span>      OUT NUMBER] 
 [,<span class="italic">actual_length</span>     OUT INTEGER]);
</pre>
<p>Where square brackets <code>[]</code> indicate optional parameters and <code><span class="codeinlineitalic">datatype</span></code> can be any of the following types:</p>
<pre>BINARY_DOUBLE
BINARY_FLOAT
BLOB
CLOB CHARACTER SET ANY_CS
DATE
INTERVAL DAY TO SECOND(9,9) (DSINTERVAL_UNCONSTRAINED)
NUMBER
TIME(9) (TIME_UNCONSTRAINED)
TIMESTAMP(9) (TIMESTAMP_UNCONSTRAINED)
VARCHAR2 CHARACTER SET ANY_CS
INTERVAL YEAR TO  MONTH(9) (YMINTERVAL_UNCONSTRAINED)
VARRAY
Nested table
</pre>
<p>For variables containing <code>CHAR</code>, <code>RAW</code>, and <code>ROWID</code> data, you can use the following variations on the syntax:</p>
<pre>DBMS_SQL.COLUMN_VALUE_CHAR (
   <span class="italic">c</span>               IN  INTEGER,
   <span class="italic">position</span>        IN  INTEGER,
   <span class="italic">value</span>           OUT CHAR CHARACTER SET ANY_CS
 [,<span class="italic">column_error</span>    OUT NUMBER]
 [,<span class="italic">actual_length</span>   OUT INTEGER]);
 
DBMS_SQL.COLUMN_VALUE_RAW (
   <span class="italic">c</span>               IN  INTEGER,
   <span class="italic">position</span>        IN  INTEGER,
   <span class="italic">value</span>           OUT RAW
 [,<span class="italic">column_error</span>    OUT NUMBER]
 [,<span class="italic">actual_length</span>   OUT INTEGER]);

DBMS_SQL.COLUMN_VALUE_ROWID (
   <span class="italic">c</span>               IN  INTEGER,
   <span class="italic">position</span>        IN  INTEGER,
   <span class="italic">value</span>           OUT ROWID
 [,<span class="italic">column_error</span>    OUT NUMBER]
 [,<span class="italic">actual_length</span>   OUT INTEGER]);
</pre>
<p>The following syntax enables the <code>COLUMN_VALUE</code> procedure to accommodate bulk operations:</p>
<pre>DBMS_SQL.COLUMN_VALUE( 
   <span class="italic">c</span>                 IN             INTEGER, 
   <span class="italic">position</span>          IN             INTEGER, 
   &lt;<span class="italic">param_name</span>&gt;      IN OUT NOCOPY  &lt;<span class="italic">table_type</span>&gt;);  
</pre>
<p>Where the <code><span class="codeinlineitalic">param_name</span></code> and its corresponding <code><span class="codeinlineitalic">table_type</span></code> can be any of these matching pairs:</p>
<pre>&lt;bdbl_tab&gt;     dbms_sql.Binary_Double_Table
&lt;bflt_tab&gt;     dbms_sql.Binary_Float_Table
&lt;bl_tab&gt;       dbms_sql.Blob_Table
&lt;cl_tab&gt;       dbms_sql.Clob_Table
&lt;c_tab&gt;        dbms_sql.Varchar2_Table
&lt;d_tab&gt;        dbms_sql.Date_Table
&lt;ids_tab&gt;      dbms_sql.Interval_Day_To_Second_Table
&lt;iym_tab&gt;      dbms_sql.Interval_Year_To_Month_Table
&lt;n_tab&gt;        dbms_sql.Number_Table
&lt;tm_tab&gt;       dbms_sql.Time_Table
&lt;tms_tab&gt;      dbms_sql.Timestamp_Table
</pre>
<p class="titleinrefsubsect"><a id="sthref412"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71311"></a><a id="sthref413"></a><a id="sthref414"></a>Table 7-10 COLUMN_VALUE procedure parameters (single row)</p>
<table class="cellalignment1016" title="COLUMN_VALUE procedure parameters (single row)" summary="This table describes Parameters used by the DBMS_SQL.COLUMN_VALUE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t20">Parameter</th>
<th class="cellalignment1017" id="r1c2-t20">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t20" headers="r1c1-t20">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t20 r1c2-t20">
<p>ID number of the cursor from which you are fetching the values</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t20" headers="r1c1-t20">
<p><code><span class="codeinlineitalic">position</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t20 r1c2-t20">
<p>Relative position of the column in the cursor, where the first column in a statement has position 1</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t20" headers="r1c1-t20">
<p><code><span class="codeinlineitalic">value</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t20 r1c2-t20">
<p>Value returned from the specified column</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t20" headers="r1c1-t20">
<p><code><span class="codeinlineitalic">column_error</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t20 r1c2-t20">
<p>Error code for the column value, if applicable</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t20" headers="r1c1-t20">
<p><code><span class="codeinlineitalic">actual_length</span></code></p>
</td>
<td class="cellalignment1018" headers="r6c1-t20 r1c2-t20">
<p>Actual length, before any truncation, of the value in the specified column</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71312"></a><a id="sthref415"></a><a id="sthref416"></a>Table 7-11 COLUMN_VALUE procedure parameters (bulk)</p>
<table class="cellalignment1016" title="COLUMN_VALUE procedure parameters (bulk)" summary="This table describes Parameters used by the DBMS_SQL.COLUMN_VALUE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t21">Parameter</th>
<th class="cellalignment1017" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t21" headers="r1c1-t21">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t21 r1c2-t21">
<p>ID number of the cursor from which you are fetching the values</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t21" headers="r1c1-t21">
<p><code><span class="codeinlineitalic">position</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t21 r1c2-t21">
<p>Relative position of the column in the cursor, where the first column in a statement has position 1</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t21" headers="r1c1-t21">
<p><code><span class="codeinlineitalic">param_name</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t21 r1c2-t21">
<p>Local variable that has been declared <code><span class="codeinlineitalic">table_type</span></code></p>
<p>The <code><span class="codeinlineitalic">param_name</span></code> is an <code>IN OUT NOCOPY</code> parameter for bulk operations.</p>
<p>For bulk operations, the subprogram appends the new elements at the appropriate (implicitly maintained) index. Consider an example where the <a href="#i1025685">DEFINE_ARRAY procedure</a> is used, a batch size (the <code><span class="codeinlineitalic">cnt</span></code> parameter) of 10 rows is specified, and a start index (<code><span class="codeinlineitalic">lower_bnd</span></code>) of 1 is specified. The first call to this subprogram, after calling the <a href="#i1026065">FETCH_ROWS function</a>, populates elements at index <code>1..10</code>; the next call populates elements <code>11..20</code>; and so on.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref417"></a>Exceptions</p>
<pre>ORA-06562: Type of out argument must match type of column or bind variable
</pre>
<p>This exception is raised if the type of the given <code>OUT</code> parameter <code>value</code> is different from the actual type of the value. This type was the given type when the column was defined by calling <code>DEFINE_COLUMN</code>.</p>
<p class="titleinrefsubsect"><a id="sthref418"></a>Examples</p>
<p>See <a href="#i996963">&#34;Examples&#34;</a>.</p>
<a id="i1025685"></a><a id="TTPLP71313"></a>
<hr/>
<h3 class="refsect2"><a id="sthref419"></a>DEFINE_ARRAY procedure</h3>
<p>This procedure defines the collection into which the row values are fetched, with a <a href="#i1026065">FETCH_ROWS function</a> call, for a given column. This procedure lets you do batch fetching of rows from a single <code>SELECT</code> statement. A single fetch brings several rows into the PL/SQL aggregate object.</p>
<p class="titleinrefsubsect"><a id="sthref420"></a>Scalar types for collections</p>
<p>You can declare a local variable as one of the following table-item types, and then fetch any number of rows into it using <code>DBMS_SQL</code>. These are the same types you can specify for the <code>BIND_ARRAY</code> procedure.</p>
<pre>TYPE binary_double_table 
                    IS TABLE OF BINARY_DOUBLE  INDEX BY BINARY_INTEGER;
TYPE binary_float_table 
                    IS TABLE OF BINARY_FLOAT   INDEX BY BINARY_INTEGER;
TYPE blob_table     IS TABLE OF BLOB           INDEX BY BINARY_INTEGER;
TYPE clob_table     IS TABLE OF CLOB           INDEX BY BINARY_INTEGER;
TYPE date_table     IS TABLE OF DATE           INDEX BY BINARY_INTEGER;
TYPE interval_day_to_second_table 
                    IS TABLE OF dsinterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE interval_year_to_month_table 
                    IS TABLE OF yminterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE number_table   IS TABLE OF NUMBER         INDEX BY BINARY_INTEGER;
TYPE time_table     IS TABLE OF time_unconstrained           
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_table 
                    IS TABLE OF timestamp_unconstrained   
                                               INDEX BY BINARY_INTEGER;
TYPE varchar2_table IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref421"></a>Syntax</p>
<pre>DBMS_SQL.DEFINE_ARRAY (
   <span class="italic">c</span>           IN INTEGER, 
   <span class="italic">position</span>    IN INTEGER,
   &lt;<span class="italic">table_variable</span>&gt;    IN &lt;<span class="italic">datatype</span>&gt; 
   <span class="italic">cnt</span>         IN INTEGER, 
   <span class="italic">lower_bnd</span>   IN INTEGER);
</pre>
<p>Where <code><span class="codeinlineitalic">table_variable</span></code> and its corresponding <code><span class="codeinlineitalic">datatype</span></code> can be any of the following matching pairs:</p>
<pre>&lt;bflt_tab&gt;     dbms_sql.Binary_Float_Table
&lt;bdbl_tab&gt;     dbms_sql.Binary_Double_Table
&lt;bl_tab&gt;       dbms_sql.Blob_Table
&lt;cl_tab&gt;       dbms_sql.Clob_Table
&lt;c_tab&gt;        dbms_sql.Varchar2_Table
&lt;d_tab&gt;        dbms_sql.Date_Table
&lt;n_tab&gt;        dbms_sql.Number_Table
&lt;tm_tab&gt;       dbms_sql.Time_Table
&lt;tms_tab&gt;      dbms_sql.Timestamp_Table
&lt;ids_tab&gt;      dbms_sql.Interval_Day_To_Second_Table
&lt;iym_tab&gt;      dbms_sql.Interval_Year_To_Month_Table
</pre>
<p>Note that <code>DEFINE_ARRAY</code> is overloaded to accept different data types.</p>
<p class="titleinrefsubsect"><a id="sthref422"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71314"></a><a id="sthref423"></a><a id="sthref424"></a>Table 7-12 DEFINE_ARRAY procedure parameters</p>
<table class="cellalignment1016" title="DEFINE_ARRAY procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_ARRAY subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t22">Parameter</th>
<th class="cellalignment1017" id="r1c2-t22">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t22" headers="r1c1-t22">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t22 r1c2-t22">
<p>ID number of the cursor where the array is to be bound</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t22" headers="r1c1-t22">
<p><code><span class="codeinlineitalic">position</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t22 r1c2-t22">
<p>Relative position of the column in the array being defined, where the first column in a statement has position 1</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t22" headers="r1c1-t22">
<p><code><span class="codeinlineitalic">table_variable</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t22 r1c2-t22">
<p>Local variable that has been declared as <code><span class="codeinlineitalic">datatype</span></code></p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t22" headers="r1c1-t22">
<p><code><span class="codeinlineitalic">cnt</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t22 r1c2-t22">
<p>Number of rows that must be fetched</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t22" headers="r1c1-t22">
<p><code><span class="codeinlineitalic">lower_bnd</span></code></p>
</td>
<td class="cellalignment1018" headers="r6c1-t22 r1c2-t22">
<p>Lower bound index, the starting point at which results are copied into the collection</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref425"></a>Usage notes</p>
<p>The count (<code><span class="codeinlineitalic">cnt</span></code>) must be an integer greater than zero. The <code><span class="codeinlineitalic">lower_bnd</span></code> can be positive, negative, or zero. A query on which a <code>DEFINE_ARRAY</code> call was issued cannot contain array binds.</p>
<p class="titleinrefsubsect"><a id="sthref426"></a>Exceptions</p>
<pre>ORA-29253: Invalid count argument passed to procedure dbms_sql.define_array
</pre>
<p>This exception is raised if the count (<code><span class="codeinlineitalic">cnt</span></code>) is less than or equal to zero.</p>
<p class="titleinrefsubsect"><a id="sthref427"></a>Examples</p>
<p>See <a href="#i996963">&#34;Examples&#34;</a>.</p>
<a id="i1025686"></a><a id="TTPLP71315"></a>
<hr/>
<h3 class="refsect2"><a id="sthref428"></a>DEFINE_COLUMN procedure</h3>
<p>This procedure defines a column to be selected from the given cursor. This procedure is only used with <code>SELECT</code> cursors.</p>
<p>The column being defined is identified by its relative position in the <code>SELECT</code> list of the statement in the given cursor. The type of the <code>COLUMN</code> value determines the type of the column being defined.</p>
<p class="titleinrefsubsect"><a id="sthref429"></a>Syntax</p>
<pre>DBMS_SQL.DEFINE_COLUMN (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">position</span>       IN INTEGER,
   <span class="italic">column</span>         IN &lt;<span class="italic">datatype</span>&gt;);
</pre>
<p>Where <code><span class="codeinlineitalic">datatype</span></code> can be any of the following types:</p>
<pre>BINARY_DOUBLE
BINARY_FLOAT
BLOB
CLOB CHARACTER SET ANY_CS
DATE
INTERVAL DAY TO SECOND(9,9) (DSINTERVAL_UNCONSTRAINED)
NUMBER
TIME(9) (TIME_UNCONSTRAINED)
TIMESTAMP(9) (TIMESTAMP_UNCONSTRAINED)
INTERVAL YEAR TO  MONTH(9) (YMINTERVAL_UNCONSTRAINED)
VARRAY
Nested table
</pre>
<p>Note that <code>DEFINE_COLUMN</code> is overloaded to accept different data types.</p>
<p>The following syntax is also supported for the <code>DEFINE_COLUMN</code> procedure:</p>
<pre>DBMS_SQL.DEFINE_COLUMN (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">position</span>       IN INTEGER,
   <span class="italic">column</span>         IN VARCHAR2 CHARACTER SET ANY_CS,
   <span class="italic">column_size</span>    IN INTEGER);
</pre>
<p>To define columns with <code>CHAR</code>, <code>RAW</code>, and <code>ROWID</code> data, you can use the following variations on the procedure syntax:</p>
<pre>DBMS_SQL.DEFINE_COLUMN_CHAR (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">position</span>       IN INTEGER,
   <span class="italic">column</span>         IN CHAR CHARACTER SET ANY_CS,
   <span class="italic">column_size</span>    IN INTEGER);

DBMS_SQL.DEFINE_COLUMN_RAW (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">position</span>       IN INTEGER,
   <span class="italic">column</span>         IN RAW,
   <span class="italic">column_size</span>    IN INTEGER);

DBMS_SQL.DEFINE_COLUMN_ROWID (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">position</span>       IN INTEGER,
   <span class="italic">column</span>         IN ROWID); 
</pre>
<p class="titleinrefsubsect"><a id="sthref430"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71316"></a><a id="sthref431"></a><a id="sthref432"></a>Table 7-13 DEFINE_COLUMN procedure parameters</p>
<table class="cellalignment1016" title="DEFINE_COLUMN procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t23">Parameter</th>
<th class="cellalignment1017" id="r1c2-t23">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t23" headers="r1c1-t23">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t23 r1c2-t23">
<p>ID number of the cursor for the row being defined to be selected</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t23" headers="r1c1-t23">
<p><code><span class="codeinlineitalic">position</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t23 r1c2-t23">
<p>Relative position of the column in the row being defined, where the first column in a statement has position 1</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t23" headers="r1c1-t23">
<p><code><span class="codeinlineitalic">column</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t23 r1c2-t23">
<p>Value of the column being defined</p>
<p>The type of this value determines the type for the column being defined.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t23" headers="r1c1-t23">
<p><code><span class="codeinlineitalic">column_size</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t23 r1c2-t23">
<p>Maximum expected size of the column value, in bytes, for columns of type <code>VARCHAR2</code>, <code>CHAR</code>, and <code>RAW</code></p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref433"></a>Examples</p>
<p>See <a href="#i996963">&#34;Examples&#34;</a>.</p>
<a id="i1026120"></a><a id="TTPLP71317"></a>
<hr/>
<h3 class="refsect2"><a id="sthref434"></a>DESCRIBE_COLUMNS procedure</h3>
<p>This procedure describes the columns for a cursor opened and parsed through <code>DBMS_SQL</code>.</p>
<p class="titleinrefsubsect"><a id="sthref435"></a>Syntax</p>
<pre>DBMS_SQL.DESCRIBE_COLUMNS ( 
   <span class="italic">c</span>              IN  INTEGER, 
   <span class="italic">col_cnt</span>        OUT INTEGER, 
   <span class="italic">desc_t</span>         OUT DBMS_SQL.DESC_TAB);
</pre>
<pre>DBMS_SQL.DESCRIBE_COLUMNS ( 
   <span class="italic">c</span>              IN  INTEGER, 
   <span class="italic">col_cnt</span>        OUT INTEGER, 
   <span class="italic">desc_t</span>         OUT DBMS_SQL.DESC_REC);
</pre>
<p class="titleinrefsubsect"><a id="sthref436"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71318"></a><a id="sthref437"></a><a id="sthref438"></a>Table 7-14 DESCRIBE_COLUMNS procedure parameters</p>
<table class="cellalignment1016" title=" DESCRIBE_COLUMNS procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.DESCRIBE_COLUMNS subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t24">Parameter</th>
<th class="cellalignment1017" id="r1c2-t24">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t24" headers="r1c1-t24">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t24 r1c2-t24">
<p>ID number of the cursor for the columns being described</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t24" headers="r1c1-t24">
<p><code><span class="codeinlineitalic">col_cnt</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t24 r1c2-t24">
<p>Number of columns in the select list of the query</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t24" headers="r1c1-t24">
<p><code><span class="codeinlineitalic">desc_t</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t24 r1c2-t24">
<p>Table to fill in with the description of each of the columns of the query</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref439"></a>Examples</p>
<p>See <a href="#i996963">&#34;Examples&#34;</a>.</p>
<a id="i1029368"></a><a id="TTPLP71319"></a>
<hr/>
<h3 class="refsect2"><a id="sthref440"></a>DESCRIBE_COLUMNS2 procedure</h3>
<p>This function describes the specified column. This is an alternative to <a href="#i1026120">DESCRIBE_COLUMNS procedure</a>.</p>
<p class="titleinrefsubsect"><a id="sthref441"></a>Syntax</p>
<pre>DBMS_SQL.DESCRIBE_COLUMNS2 ( 
   <span class="italic">c</span>              IN  INTEGER, 
   <span class="italic">col_cnt</span>        OUT INTEGER, 
   <span class="italic">desc_t</span>         OUT DBMS_SQL.DESC_TAB2);
</pre>
<pre>DBMS_SQL.DESCRIBE_COLUMNS2 ( 
   <span class="italic">c</span>              IN  INTEGER, 
   <span class="italic">col_cnt</span>        OUT INTEGER, 
   <span class="italic">desc_t</span>         OUT DBMS_SQL.DESC_REC2);
</pre>
<p class="titleinrefsubsect"><a id="sthref442"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71320"></a><a id="sthref443"></a><a id="sthref444"></a>Table 7-15 DESCRIBE_COLUMNS2 procedure parameters</p>
<table class="cellalignment1016" title="DESCRIBE_COLUMNS2 procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.DESCRIBE_COLUMNS2 subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t25">Parameter</th>
<th class="cellalignment1017" id="r1c2-t25">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t25" headers="r1c1-t25">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t25 r1c2-t25">
<p>ID number of the cursor for the columns being described</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t25" headers="r1c1-t25">
<p><code><span class="codeinlineitalic">col_cnt</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t25 r1c2-t25">
<p>Number of columns in the select list of the query</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t25" headers="r1c1-t25">
<p><code><span class="codeinlineitalic">desc_t</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t25 r1c2-t25">
<p>Table to fill in with the description of each of the columns of the query, indexed from 1 to the number of elements in the select list of the query</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<a id="CHDJBBFH"></a><a id="TTPLP71321"></a>
<hr/>
<h3 class="refsect2"><a id="sthref445"></a>DESCRIBE_COLUMNS3 procedure</h3>
<p>This function describes the specified column. This is an alternative to <a href="#i1026120">DESCRIBE_COLUMNS procedure</a>.</p>
<p class="titleinrefsubsect"><a id="sthref446"></a>Syntax</p>
<pre>DBMS_SQL.DESCRIBE_COLUMNS3 ( 
   <span class="italic">c</span>              IN  INTEGER, 
   <span class="italic">col_cnt</span>        OUT INTEGER, 
   <span class="italic">desc_t</span>         OUT DBMS_SQL.DESC_TAB3);
</pre>
<pre>DBMS_SQL.DESCRIBE_COLUMNS3 ( 
   <span class="italic">c</span>              IN  INTEGER, 
   <span class="italic">col_cnt</span>        OUT INTEGER, 
   <span class="italic">desc_t</span>         OUT DBMS_SQL.DESC_REC3);
</pre>
<p class="titleinrefsubsect"><a id="sthref447"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71322"></a><a id="sthref448"></a><a id="sthref449"></a>Table 7-16 DESCRIBE_COLUMNS3 procedure parameters</p>
<table class="cellalignment1016" title="DESCRIBE_COLUMNS3 procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.DESCRIBE_COLUMNS3 subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t26">Parameter</th>
<th class="cellalignment1017" id="r1c2-t26">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t26" headers="r1c1-t26">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t26 r1c2-t26">
<p>ID number of the cursor for the columns being described</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t26" headers="r1c1-t26">
<p><code><span class="codeinlineitalic">col_cnt</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t26 r1c2-t26">
<p>Number of columns in the select list of the query</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t26" headers="r1c1-t26">
<p><code><span class="codeinlineitalic">desc_t</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t26 r1c2-t26">
<p>Table to fill in with the description of each of the columns of the query, indexed from 1 to the number of elements in the select list of the query</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref450"></a>Usage notes</p>
<p>The cursor passed in by the cursor ID has to be opened and parsed, otherwise an error is raised for an invalid cursor ID.</p>
<a id="i1025983"></a><a id="TTPLP71323"></a>
<hr/>
<h3 class="refsect2"><a id="sthref451"></a>EXECUTE function</h3>
<p>This function executes a given cursor. This function accepts the ID number of the cursor and returns the number of rows processed. The return value is only valid for <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements. For other types of statements, including DDL, the return value is undefined and should be ignored.</p>
<p class="titleinrefsubsect"><a id="sthref452"></a>Syntax</p>
<pre>DBMS_SQL.EXECUTE (
   <span class="italic">c</span>   IN INTEGER)
  RETURN INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref453"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71324"></a><a id="sthref454"></a><a id="sthref455"></a>Table 7-17 EXECUTE function parameters</p>
<table class="cellalignment1016" title="EXECUTE function parameters" summary="This table describes Parameters used by the DBMS_SQL.EXECUTE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t27">Parameter</th>
<th class="cellalignment1017" id="r1c2-t27">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t27" headers="r1c1-t27">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t27 r1c2-t27">
<p>Cursor ID number of the cursor to execute</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref456"></a>Return value</p>
<p>An <code>INTEGER</code> value that indicates the number of rows processed</p>
<a id="i1025711"></a><a id="TTPLP71325"></a>
<hr/>
<h3 class="refsect2"><a id="sthref457"></a>EXECUTE_AND_FETCH function</h3>
<p>This function executes the given cursor and fetches rows. It provides the same functionality as calling <code>EXECUTE</code> and then calling <code>FETCH_ROWS</code>; however, calling <code>EXECUTE_AND_FETCH</code> may reduce the number of network round trips when used against a remote database.</p>
<p>The <code>EXECUTE_AND_FETCH</code> function returns the number of rows actually fetched.</p>
<p class="titleinrefsubsect"><a id="sthref458"></a>Syntax</p>
<pre>DBMS_SQL.EXECUTE_AND_FETCH (
   <span class="italic">c</span>              IN INTEGER,
   <span class="italic">exact</span>          IN BOOLEAN DEFAULT FALSE)
  RETURN INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref459"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71326"></a><a id="sthref460"></a><a id="sthref461"></a>Table 7-18 EXECUTE_AND_FETCH function parameters</p>
<table class="cellalignment1016" title="EXECUTE_AND_FETCH function parameters " summary="This table describes Parameters used by the DBMS_SQL.EXECUTE_AND_FETCH subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t28">Parameter</th>
<th class="cellalignment1017" id="r1c2-t28">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t28" headers="r1c1-t28">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t28 r1c2-t28">
<p>ID number of the cursor to execute and fetch</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t28" headers="r1c1-t28">
<p><code><span class="codeinlineitalic">exact</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t28 r1c2-t28">
<p><code>TRUE</code> to raise an exception if the number of rows actually matching the query differs from 1</p>
<p>Even if an exception is raised, the rows are still fetched and available.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref462"></a>Return value</p>
<p>An <code>INTEGER</code> value indicating the number of rows that were fetched</p>
<p class="titleinrefsubsect"><a id="sthref463"></a>Exceptions</p>
<pre>ORA-01422: Exact fetch returns more than requested number of rows
</pre>
<p>This exception is raised if the number of rows matching the query is not 1.</p>
<a id="i1026065"></a><a id="TTPLP71327"></a>
<hr/>
<h3 class="refsect2"><a id="sthref464"></a>FETCH_ROWS function</h3>
<p>This function fetches a row from a given cursor. A <a href="#i1025685">DEFINE_ARRAY procedure</a> call defines the collection into which the row values are fetched.</p>
<p>A <code>FETCH_ROWS</code> call fetches the specified number of rows, according to the <code><span class="codeinlineitalic">cnt</span></code> parameter of the <code>DEFINE_ARRAY</code> call. When you fetch the rows, they are copied into <code>DBMS_SQL</code> buffers until you execute a <a href="#i1025449">COLUMN_VALUE procedure</a> call, for each column, at which time the rows are copied into the table that was passed as an argument to <code>COLUMN_VALUE</code>. The rows are placed in positions <code><span class="codeinlineitalic">lower_bnd</span></code>, <code><span class="codeinlineitalic">lower_bnd</span></code>+1, <code><span class="codeinlineitalic">lower_bnd</span></code>+2, and so on, according to the <code><span class="codeinlineitalic">lower_bnd</span></code> setting in the <code>DEFINE_ARRAY</code> call. While there are still rows coming in, the user keeps issuing <code>FETCH_ROWS</code> and <code>COLUMN_VALUE</code> calls. You can call <code>FETCH_ROWS</code> repeatedly as long as there are rows remaining to be fetched.</p>
<p>The <code>FETCH_ROWS</code> function accepts the ID number of the cursor to fetch and returns the number of rows actually fetched.</p>
<p class="titleinrefsubsect"><a id="sthref465"></a>Syntax</p>
<pre>DBMS_SQL.FETCH_ROWS (
   <span class="italic">c</span>              IN INTEGER)
  RETURN INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref466"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71328"></a><a id="sthref467"></a><a id="sthref468"></a>Table 7-19 FETCH_ROWS function parameters</p>
<table class="cellalignment1016" title="FETCH_ROWS function parameters" summary="This table describes Parameters used by the DBMS_SQL.FETCH_ROWS subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t29">Parameter</th>
<th class="cellalignment1017" id="r1c2-t29">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t29" headers="r1c1-t29">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t29 r1c2-t29">
<p>ID number of the cursor to fetch</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref469"></a>Return value</p>
<p>An <code>INTEGER</code> value indicating the number of rows that were fetched</p>
<p class="titleinrefsubsect"><a id="sthref470"></a>Examples</p>
<p>See <a href="#i996963">&#34;Examples&#34;</a>.</p>
<a id="i1026423"></a><a id="TTPLP71329"></a>
<hr/>
<h3 class="refsect2"><a id="sthref471"></a>IS_OPEN function</h3>
<p>This function checks to see if the given cursor is currently open.</p>
<p class="titleinrefsubsect"><a id="sthref472"></a>Syntax</p>
<pre>DBMS_SQL.IS_OPEN (
   <span class="italic">c</span>              IN INTEGER)
  RETURN BOOLEAN;
</pre>
<p class="titleinrefsubsect"><a id="sthref473"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71330"></a><a id="sthref474"></a><a id="sthref475"></a>Table 7-20 IS_OPEN function parameters</p>
<table class="cellalignment1016" title="IS_OPEN function parameters" summary="This table describes Parameters used by the DBMS_SQL.IS_OPEN subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t30">Parameter</th>
<th class="cellalignment1017" id="r1c2-t30">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t30" headers="r1c1-t30">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t30 r1c2-t30">
<p>Cursor ID number of the cursor to check</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref476"></a>Return value</p>
<p><code>TRUE</code> for any cursor number that has been opened but not closed, or <code>FALSE</code> for a <code>NULL</code> cursor number</p>
<p>Note that the <a href="#i1026299">CLOSE_CURSOR procedure</a> nulls out the cursor variable passed to it.</p>
<p class="titleinrefsubsect"><a id="sthref477"></a>Exceptions</p>
<pre>ORA-29471 DBMS_SQL access denied
</pre>
<p>This is raised if an invalid cursor ID number is detected. Once a session has encountered and reported this error, every subsequent <code>DBMS_SQL</code> call in the same session raises this error, meaning that <code>DBMS_SQL</code> is non-operational for the session.</p>
<a id="i1026408"></a><a id="TTPLP71331"></a>
<hr/>
<h3 class="refsect2"><a id="sthref478"></a>LAST_ERROR_POSITION function</h3>
<p>This function returns the byte offset in the SQL statement text where the error occurred. The first character in the SQL statement is at position 0.</p>
<p class="titleinrefsubsect"><a id="sthref479"></a>Syntax</p>
<pre>DBMS_SQL.LAST_ERROR_POSITION 
   RETURN INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref480"></a>Return value</p>
<p>An <code>INTEGER</code> value indicating the byte offset in the SQL statement text where the error occurred</p>
<p class="titleinrefsubsect"><a id="sthref481"></a>Usage notes</p>
<p>Call this function after a <code>PARSE</code> call, before any other <code>DBMS_SQL</code> procedures or functions are called.</p>
<a id="i1026354"></a><a id="TTPLP71332"></a>
<hr/>
<h3 class="refsect2"><a id="sthref482"></a>LAST_ROW_COUNT function</h3>
<p>This function returns the cumulative count of the number of rows fetched.</p>
<p class="titleinrefsubsect"><a id="sthref483"></a>Syntax</p>
<pre>DBMS_SQL.LAST_ROW_COUNT 
   RETURN INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref484"></a>Return value</p>
<p>An <code>INTEGER</code> value indicating the cumulative count of the number of rows that were fetched</p>
<p class="titleinrefsubsect"><a id="sthref485"></a>Usage notes</p>
<p>Call this function after a <code>FETCH_ROWS</code> or an <code>EXECUTE_AND_FETCH</code> call. If called after an <code>EXECUTE</code> call, the value returned is zero.</p>
<a id="i1026364"></a><a id="TTPLP71333"></a>
<hr/>
<h3 class="refsect2"><a id="sthref486"></a>LAST_ROW_ID function</h3>
<p>This function returns the rowid of the last row processed, but <code>NULL</code> for TimesTen.</p>
<p>TimesTen does not support rowid of the last row operated on by a DML statement.</p>
<p class="titleinrefsubsect"><a id="sthref487"></a>Syntax</p>
<pre>DBMS_SQL.LAST_ROW_ID 
   RETURN ROWID;
</pre>
<p class="titleinrefsubsect"><a id="sthref488"></a>Return value</p>
<p><code>NULL</code> for TimesTen</p>
<a id="i1026374"></a><a id="TTPLP71334"></a>
<hr/>
<h3 class="refsect2"><a id="sthref489"></a>LAST_SQL_FUNCTION_CODE function</h3>
<p>This function returns the SQL function code for the statement. These codes are listed in the <a class="olink LNOCI17298" href="../LNOCI/oci17msc007.htm#LNOCI17298">&#34;OCI Function Codes&#34;</a> table in <span class="italic">Oracle Call Interface Programmer&#39;s Guide</span>.</p>
<p class="titleinrefsubsect"><a id="sthref490"></a>Syntax</p>
<pre>DBMS_SQL.LAST_SQL_FUNCTION_CODE 
   RETURN INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref491"></a>Return value</p>
<p>An <code>INTEGER</code> value indicating the SQL function code for the statement</p>
<p class="titleinrefsubsect"><a id="sthref492"></a>Usage notes</p>
<p>Call this function immediately after the SQL statement is run. Otherwise, the return value is undefined.</p>
<a id="i997665"></a><a id="TTPLP71335"></a>
<hr/>
<h3 class="refsect2"><a id="sthref493"></a>OPEN_CURSOR function</h3>
<p>This procedure opens a new cursor. The second overload takes a <code><span class="codeinlineitalic">security_level</span></code> parameter to apply fine-grained control to the security of the opened cursor. In TimesTen, however, there is no security enforcement: <code>security_level=0</code>.</p>
<p>When you no longer need this cursor, you must close it explicitly by calling the <a href="#i1026299">CLOSE_CURSOR procedure</a>.</p>
<p class="titleinrefsubsect"><a id="sthref494"></a>Syntax</p>
<pre>DBMS_SQL.OPEN_CURSOR 
  RETURN INTEGER;

DBMS_SQL.OPEN_CURSOR (
   <span class="italic">security_level</span>   IN   INTEGER) 
  RETURN INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref495"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71336"></a><a id="sthref496"></a><a id="sthref497"></a>Table 7-21 OPEN_CURSOR function parameters</p>
<table class="cellalignment1016" title="OPEN_CURSOR function parameters" summary="This table describes Parameters used by the DBMS_SQL.IS_OPEN subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t31">Parameter</th>
<th class="cellalignment1017" id="r1c2-t31">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t31" headers="r1c1-t31">
<p><code><span class="codeinlineitalic">security_level</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t31 r1c2-t31">
<p>Specifies the level of security protection to enforce on the opened cursor. Only the security level 0 is valid in TimesTen (levels 1 and 2 are not supported).</p>
<ul>
<li>
<p>Level 0 allows all <code>DBMS_SQL</code> operations on the cursor without any security checks. The cursor may be fetched from, and even re-bound and re-executed by, code running with a different effective user ID or roles than at the time the cursor was parsed. This level of security is disabled by default.</p>
</li>
<li>
<p>Level 1 is not applicable for TimesTen.</p>
</li>
<li>
<p>Level 2 is not applicable for TimesTen.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref498"></a>Return value</p>
<p>The cursor ID of the new cursor</p>
<p class="titleinrefsubsect"><a id="sthref499"></a>Usage notes</p>
<p>You can use cursors to run the same SQL statement repeatedly or to run a new SQL statement. When a cursor is reused, the contents of the corresponding cursor data area are reset when the new SQL statement is parsed. It is never necessary to close and reopen a cursor before reusing it.</p>
<a id="i997676"></a><a id="TTPLP71337"></a>
<hr/>
<h3 class="refsect2"><a id="sthref500"></a>PARSE procedures</h3>
<p>This procedure parses the given statement in the given cursor. All statements are parsed immediately. In addition, DDL statements are run immediately when parsed.</p>
<p>There are multiple versions of the <code>PARSE</code> procedure:</p>
<ul>
<li>
<p>Taking a <code>VARCHAR2</code> statement as an argument</p>
</li>
<li>
<p>Taking <code>VARCHAR2A</code>, table of <code>VARCHAR2(32767)</code>, as an argument</p>
</li>
<li>
<p>Taking <code>VARCHAR2S</code>, table of <code>VARCHAR2(32767)</code>, as an argument</p>
</li>
<li>
<p>Taking a <code>CLOB</code> statement as an argument</p>
<p>You can use the <code>CLOB</code> overload version of the parse procedure to parse a SQL statement larger than 32 KB.</p>
</li>
</ul>
<p>The <code>VARCHAR2A</code> overload version of the procedure concatenates elements of a PL/SQL table statement and parses the resulting string. You can use this procedure to parse a statement that is longer than the limit for a single <code>VARCHAR2</code> variable by splitting up the statement.</p>
<p class="titleinrefsubsect"><a id="sthref501"></a>Syntax</p>
<pre>DBMS_SQL.PARSE (
   <span class="italic">c</span>                  IN   INTEGER,
   <span class="italic">statement</span>          IN   VARCHAR2,
   <span class="italic">language_flag</span>      IN   INTEGER);
</pre>
<pre>DBMS_SQL.PARSE (
   <span class="italic">c</span>                  IN   INTEGER, 
   <span class="italic">statement</span>          IN   DBMS_SQL.VARCHAR2A,
   <span class="italic">lb</span>                 IN   INTEGER, 
   <span class="italic">ub</span>                 IN   INTEGER,
   <span class="italic">lfflg</span>              IN   BOOLEAN, 
   <span class="italic">language_flag</span>      IN   INTEGER);
</pre>
<pre>DBMS_SQL.PARSE (
   <span class="italic">c</span>                  IN   INTEGER, 
   <span class="italic">statement</span>          IN   DBMS_SQL.VARCHAR2S,
   <span class="italic">lb</span>                 IN   INTEGER, 
   <span class="italic">ub</span>                 IN   INTEGER,
   <span class="italic">lfflg</span>              IN   BOOLEAN, 
   <span class="italic">language_flag</span>      IN   INTEGER);

DBMS_SQL.PARSE (
   <span class="italic">c</span>                  IN   INTEGER,
   <span class="italic">statement</span>          IN   CLOB,
   <span class="italic">language_flag</span>      IN   INTEGER);
</pre>
<p class="titleinrefsubsect"><a id="sthref502"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71338"></a><a id="sthref503"></a><a id="sthref504"></a>Table 7-22 PARSE procedure parameters</p>
<table class="cellalignment1016" title="PARSE procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.PARSE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t32">Parameter</th>
<th class="cellalignment1017" id="r1c2-t32">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t32" headers="r1c1-t32">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t32 r1c2-t32">
<p>ID number of the cursor in which to parse the statement</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t32" headers="r1c1-t32">
<p><code><span class="codeinlineitalic">statement</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t32 r1c2-t32">
<p>SQL statement to be parsed</p>
<p>SQL statements larger than 32 KB can be stored in CLOBs.</p>
<p>Unlike PL/SQL statements, your SQL statement should not include a final semicolon. For example:</p>
<pre>DBMS_SQL.PARSE(cursor1, &#39;BEGIN proc; END;&#39;, 2);
DBMS_SQL.PARSE(cursor1, &#39;INSERT INTO tab VALUES(1)&#39;, 2);
</pre></td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t32" headers="r1c1-t32">
<p><code><span class="codeinlineitalic">lb</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t32 r1c2-t32">
<p>Lower bound for elements in the statement</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t32" headers="r1c1-t32">
<p><code><span class="codeinlineitalic">ub</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t32 r1c2-t32">
<p>Upper bound for elements in the statement</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t32" headers="r1c1-t32">
<p><code><span class="codeinlineitalic">lfflg</span></code></p>
</td>
<td class="cellalignment1018" headers="r6c1-t32 r1c2-t32">
<p><code>TRUE</code> to insert a line feed after each element on concatenation</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r7c1-t32" headers="r1c1-t32">
<p><code><span class="codeinlineitalic">language_flag</span></code></p>
</td>
<td class="cellalignment1018" headers="r7c1-t32 r1c2-t32">
<p>Flag to determine how the SQL statement is handled</p>
<p>For TimesTen, use the <code>NATIVE</code> (or 1) setting, which specifies normal behavior for the database to which the program is connected.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref505"></a>Usage notes</p>
<ul>
<li>
<p>Because client-side code cannot reference remote package variables or constants, you must explicitly use the values of the constants.</p>
<p>For example, the following code does <span class="italic">not</span> compile on the client:</p>
<pre>DBMS_SQL.PARSE(cur_hdl, stmt_str, DBMS_SQL.NATIVE); 
-- uses constant DBMS_SQL.NATIVE
</pre>
<p>The following code works on the client, because the argument is explicitly provided:</p>
<pre>DBMS_SQL.PARSE(cur_hdl, stmt_str, 1); -- compiles on the client
</pre></li>
<li>
<p>The <code>VARCHAR2S</code> type is supported only for backward compatibility. You are advised to use <code>VARCHAR2A</code> instead.</p>
</li>
</ul>
<p class="titleinrefsubsect"><a id="sthref506"></a>Exceptions</p>
<pre>ORA-24344: Success with compilation error
</pre>
<p>If you create a type, procedure, function, or package that has compilation warnings, this exception is raised but the object is still created.</p>
<p class="titleinrefsubsect"><a id="sthref507"></a>Examples</p>
<p>See <a href="#i996963">&#34;Examples&#34;</a>.</p>
<a id="CHDJDGDG"></a><a id="TTPLP71339"></a>
<hr/>
<h3 class="refsect2"><a id="sthref508"></a>TO_CURSOR_NUMBER function</h3>
<p>This function takes an opened strongly or weakly-typed REF CURSOR and transforms it into a <code>DBMS_SQL</code> cursor number.</p>
<p class="titleinrefsubsect"><a id="sthref509"></a>Syntax</p>
<pre>DBMS_SQL.TO_CURSOR_NUMBER(
   <span class="italic">rc</span> IN OUT SYS_REFCURSOR)
  RETURN INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref510"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71340"></a><a id="sthref511"></a><a id="sthref512"></a>Table 7-23 TO_CURSOR_NUMBER function parameters</p>
<table class="cellalignment1016" title="TO_CURSOR_NUMBER function parameters" summary="This table describes Parameters used by the DBMS_SQL.TO_CURSOR_NUMBER subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t33">Parameter</th>
<th class="cellalignment1017" id="r1c2-t33">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t33" headers="r1c1-t33">
<p><code><span class="codeinlineitalic">rc</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t33 r1c2-t33">
<p>REF CURSOR to be transformed into a cursor number</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref513"></a>Return value</p>
<p>A <code>DBMS_SQL</code> manageable cursor number transformed from a REF CURSOR</p>
<p class="titleinrefsubsect"><a id="sthref514"></a>Usage notes</p>
<ul>
<li>
<p>The REF CURSOR passed in has to be opened (<code>OPEN_CURSOR</code>).</p>
</li>
<li>
<p>Once the REF CURSOR is transformed into a <code>DBMS_SQL</code> cursor number, the REF CURSOR is no longer accessible by any native dynamic SQL operations.</p>
</li>
<li>
<p>Toggling between a REF CURSOR and <code>DBMS_SQL</code> cursor number after a fetch has started is not allowed.</p>
</li>
</ul>
<p class="titleinrefsubsect"><a id="sthref515"></a>Ex<a id="sthref516"></a><a id="sthref517"></a>amples</p>
<pre>CREATE OR REPLACE PROCEDURE DO_QUERY1(sql_stmt VARCHAR2) IS
  TYPE CurType IS REF CURSOR;
  src_cur         CurType;
  curid           NUMBER;
  desctab         DBMS_SQL.DESC_TAB;
  colcnt          NUMBER;
  namevar         VARCHAR2(50);
  numvar          NUMBER;
  datevar         DATE;
 
BEGIN
    -- sql_stmt := &#39;select * from employees&#39;;
    OPEN src_cur FOR sql_stmt;
 
    -- Switch from native dynamic SQL to DBMS_SQL
    curid := DBMS_SQL.TO_CURSOR_NUMBER(src_cur);
 
    DBMS_SQL.DESCRIBE_COLUMNS(curid, colcnt, desctab);
 
    -- Define columns
    FOR i IN 1 .. colcnt LOOP
         IF desctab(i).col_type = 2 THEN
           DBMS_SQL.DEFINE_COLUMN(curid, i, numvar);
         ELSIF desctab(i).col_type = 12 THEN
            DBMS_SQL.DEFINE_COLUMN(curid, i, datevar);
         ELSE
            DBMS_SQL.DEFINE_COLUMN(curid, i, namevar, 25);
         END IF;
    END LOOP;
 
  -- Fetch Rows
    WHILE DBMS_SQL.FETCH_ROWS(curid) &gt; 0 LOOP
        FOR i IN 1 .. colcnt LOOP
          IF (desctab(i).col_type = 1) THEN
            DBMS_SQL.COLUMN_VALUE(curid, i, namevar);
          ELSIF (desctab(i).col_type = 2) THEN
            DBMS_SQL.COLUMN_VALUE(curid, i, numvar);
          ELSIF (desctab(i).col_type = 12) THEN
            DBMS_SQL.COLUMN_VALUE(curid, i, datevar);
          END IF;
        END LOOP;
    END LOOP;
 
    DBMS_SQL.CLOSE_CURSOR(curid);
END;
</pre>
<p>You could execute this procedure as follows:</p>
<pre>Command&gt; begin
       &gt; do_query1(&#39;select * from employees&#39;);
       &gt; end;
       &gt; /
 
PL/SQL procedure successfully completed.
</pre>
<a id="CHDFDCDE"></a><a id="TTPLP71341"></a>
<hr/>
<h3 class="refsect2"><a id="sthref518"></a>TO_REFCURSOR function</h3>
<p>This function takes an opened (by <code>OPEN_CURSOR</code>), parsed (by <code>PARSE</code>), and executed (by <code>EXECUTE</code>) cursor and transforms or migrates it into a PL/SQL-manageable REF CURSOR (a weakly-typed cursor) that can be consumed by PL/SQL native dynamic SQL. This subprogram is only used with <code>SELECT</code> cursors.</p>
<p class="titleinrefsubsect"><a id="sthref519"></a>Syntax</p>
<pre>DBMS_SQL.TO_REFCURSOR(
   <span class="italic">cursor_number</span> IN OUT  INTEGER)
  RETURN SYS_REFCURSOR;
</pre>
<p class="titleinrefsubsect"><a id="sthref520"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71342"></a><a id="sthref521"></a><a id="sthref522"></a>Table 7-24 TO_REFCURSOR function parameters</p>
<table class="cellalignment1016" title="TO_REFCURSOR function parameters" summary="This table describes Parameters used by the DBMS_SQL.IS_OPEN subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t34">Parameter</th>
<th class="cellalignment1017" id="r1c2-t34">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t34" headers="r1c1-t34">
<p><code><span class="codeinlineitalic">cursor_number</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t34 r1c2-t34">
<p>Cursor number of the cursor to be transformed into a REF CURSOR</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref523"></a>Return value</p>
<p>A PL/SQL REF CURSOR transformed from a <code>DBMS_SQL</code> cursor number</p>
<p class="titleinrefsubsect"><a id="sthref524"></a>Usage notes</p>
<ul>
<li>
<p>The cursor passed in by the <code><span class="codeinlineitalic">cursor_number</span></code> has to be opened, parsed, and executed. Otherwise an error is raised.</p>
</li>
<li>
<p>Once the <code><span class="codeinlineitalic">cursor_number</span></code> is transformed into a REF CURSOR, it is no longer accessible by any <code>DBMS_SQL</code> operations.</p>
</li>
<li>
<p>After a <code><span class="codeinlineitalic">cursor_number</span></code> is transformed into a REF CURSOR, using <code>IS_OPEN</code> results in an error.</p>
</li>
<li>
<p>Toggling between REF CURSOR and <code>DBMS_SQL</code> cursor number after starting to fetch is not allowed. An error is raised.</p>
</li>
</ul>
<p class="titleinrefsubsect"><a id="sthref525"></a>Ex<a id="sthref526"></a><a id="sthref527"></a>amples</p>
<pre>CREATE OR REPLACE PROCEDURE DO_QUERY2(mgr_id NUMBER) IS
  TYPE CurType IS REF CURSOR;
  src_cur         CurType;
  curid           NUMBER;
  sql_stmt        VARCHAR2(200);
  ret             INTEGER;
  empnos          DBMS_SQL.Number_Table;
  depts           DBMS_SQL.Number_Table;
 
BEGIN
 
  -- DBMS_SQL.OPEN_CURSOR
  curid := DBMS_SQL.OPEN_CURSOR;
 
  sql_stmt :=
    &#39;SELECT EMPLOYEE_ID, DEPARTMENT_ID from employees where MANAGER_ID = :b1&#39;;
 
  DBMS_SQL.PARSE(curid, sql_stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_VARIABLE(curid, &#39;b1&#39;, mgr_id);
  ret := DBMS_SQL.EXECUTE(curid);
 
  -- Switch from DBMS_SQL to native dynamic SQL
  src_cur := DBMS_SQL.TO_REFCURSOR(curid);
 
  -- Fetch with native dynamic SQL
  FETCH src_cur BULK COLLECT INTO empnos, depts;
 
  IF empnos.COUNT &gt; 0 THEN
    DBMS_OUTPUT.PUT_LINE(&#39;EMPNO DEPTNO&#39;);
    DBMS_OUTPUT.PUT_LINE(&#39;----- ------&#39;);
    -- Loop through the empnos and depts collections
    FOR i IN 1 .. empnos.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE(empnos(i) || &#39;   &#39; || depts(i));
    END LOOP;
  END IF;
 
  -- Close cursor
  CLOSE src_cur;
END;
</pre>
<p>The following example executes this procedure for a manager ID of 103.</p>
<pre>Command&gt; begin
       &gt; do_query2(103);
       &gt; end;
       &gt; /
EMPNO DEPTNO
----- ------
104   60
105   60
106   60
107   60
 
PL/SQL procedure successfully completed.
</pre>
<a id="i998371"></a><a id="TTPLP71343"></a>
<hr/>
<h3 class="refsect2"><a id="sthref528"></a>VARIABLE_VALUE procedure</h3>
<p>This procedure returns the value of the named variable for a given cursor. It is used to return the values of bind variables inside PL/SQL blocks or of DML statements with a <code>RETURNING</code> clause.</p>
<p class="titleinrefsubsect"><a id="sthref529"></a>Syntax</p>
<pre>DBMS_SQL.VARIABLE_VALUE (
   <span class="italic">c</span>               IN  INTEGER,
   <span class="italic">name</span>            IN  VARCHAR2,
   <span class="italic">value</span>           OUT NOCOPY &lt;<span class="italic">datatype</span>&gt;);
 
</pre>
<p>Where <code><span class="codeinlineitalic">datatype</span></code> can be any of the following types:</p>
<pre>BINARY_DOUBLE
BINARY_FLOAT
BLOB
CLOB CHARACTER SET ANY_CS
DATE
INTERVAL DAY TO SECOND(9,9) (DSINTERVAL_UNCONSTRAINED)
NUMBER
TIME(9) (TIME_UNCONSTRAINED)
TIMESTAMP(9) (TIMESTAMP_UNCONSTRAINED)
VARCHAR2 CHARACTER SET ANY_CS
INTERVAL YEAR TO  MONTH(9) (YMINTERVAL_UNCONSTRAINED)
VARRAY
Nested table
</pre>
<p>For variables containing <code>CHAR</code>, <code>RAW</code>, and <code>ROWID</code> data, you can use the following variations on the syntax:</p>
<pre>DBMS_SQL.VARIABLE_VALUE_CHAR (
   <span class="italic">c</span>               IN  INTEGER,
   <span class="italic">name</span>            IN  VARCHAR2,
   <span class="italic">value</span>           OUT CHAR CHARACTER SET ANY_CS);

DBMS_SQL.VARIABLE_VALUE_RAW (
   <span class="italic">c</span>               IN  INTEGER,
   <span class="italic">name</span>            IN  VARCHAR2,
   <span class="italic">value</span>           OUT RAW);

DBMS_SQL.VARIABLE_VALUE_ROWID (
   <span class="italic">c</span>               IN  INTEGER,
   <span class="italic">name</span>            IN  VARCHAR2,
   <span class="italic">value</span>           OUT ROWID);
</pre>
<p>The following syntax enables the <code>VARIABLE_VALUE</code> procedure to accommodate bulk operations:</p>
<pre>DBMS_SQL.VARIABLE_VALUE ( 
   <span class="italic">c</span>                 IN   INTEGER, 
   <span class="italic">name</span>              IN   VARCHAR2,
   <span class="italic">value</span>             OUT NOCOPY &lt;<span class="italic">table_type</span>&gt;); 
</pre>
<p>For bulk operations, <code><span class="codeinlineitalic">table_type</span></code> can be any of the following:</p>
<pre>dbms_sql.Binary_Double_Table
dbms_sql.Binary_Float_Table
dbms_sql.Blob_Table
dbms_sql.Clob_Table
dbms_sql.Date_Table
dbms_sql.Interval_Day_To_Second_Table
dbms_sql.Interval_Year_To_Month_Table
dbms_sql.Number_Table
dbms_sql.Time_Table
dbms_sql.Timestamp_Table
dbms_sql.Varchar2_Table
</pre>
<p class="titleinrefsubsect"><a id="sthref530"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71344"></a><a id="sthref531"></a><a id="sthref532"></a>Table 7-25 VARIABLE_VALUE procedure parameters</p>
<table class="cellalignment1016" title="VARIABLE_VALUE procedure parameters " summary="This table describes Parameters used by the DBMS_SQL.VARIABLE_VALUE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t35">Parameter</th>
<th class="cellalignment1017" id="r1c2-t35">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t35" headers="r1c1-t35">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t35 r1c2-t35">
<p>ID number of the cursor from which to get the values</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t35" headers="r1c1-t35">
<p><code><span class="codeinlineitalic">name</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t35 r1c2-t35">
<p>Name of the variable for which you are retrieving the value</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t35" headers="r1c1-t35">
<p><code><span class="codeinlineitalic">value</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t35 r1c2-t35">
<p>For the single row option, value of the variable for the specified position</p>
<p>For the array option, local variable that has been declared <code><span class="codeinlineitalic">table_type</span></code></p>
<p><span class="bold">Note</span>: For bulk operations, <code><span class="codeinlineitalic">value</span></code> is an <code>OUT NOCOPY</code> parameter.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref533"></a>Exceptions</p>
<pre>ORA-06562: Type of out argument must match type of column or bind variable
</pre>
<p>This is raised if the type of the output parameter differs from the type of the value as defined by the <code>BIND_VARIABLE</code> call.</p>
<p class="titleinrefsubsect"><a id="sthref534"></a>Examples</p>
<p>See <a href="#i996963">&#34;Examples&#34;</a>.</p>
</div>
<!-- class="refsect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1009">
<tr>
<td class="cellalignment1018">
<table class="cellalignment1014">
<tr>
<td class="cellalignment1013"><a href="d_random.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1013"><a href="d_util.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1020">
<table class="cellalignment1012">
<tr>
<td class="cellalignment1013"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1013"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1013"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1013"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1013"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1013"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>