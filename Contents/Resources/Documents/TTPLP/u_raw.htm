<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-113963"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/UTL_RAW"></a><title>UTL_RAW</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 704"/>
<meta name="dcterms.created" content="2014-10-02T17:47:28Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen In-Memory Database PL/SQL Packages Reference"/>
<meta name="dcterms.identifier" content="E21645-06"/>
<meta name="dcterms.isVersionOf" content="TTPLP"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="u_ident.htm" title="Previous" type="text/html"/>
<link rel="Next" href="u_recomp.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21645-06.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">17/19</span> <!-- End Header --><a id="BABJHEGF"></a><a id="TTPLP072"></a>
<h1 class="chapter"><span class="secnum">13</span> UTL_RAW</h1>
<p>The <code>UTL_RAW</code> package provides SQL functions for manipulating <code>RAW</code> data types.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BABFGDDG">Using UTL_RAW</a></p>
<ul>
<li>
<p>Overview</p>
</li>
<li>
<p>Operational notes</p>
</li>
</ul>
</li>
<li>
<p><a href="#i996746">Summary of UTL_RAW subprograms</a></p>
</li>
</ul>
<a id="BABFGDDG"></a><a id="TTPLP71467"></a>
<hr/>
<div class="refsect1">
<h2 class="refsect1">Us<a id="sthref890"></a>ing UTL_RAW</h2>
<ul>
<li>
<p><a href="#i1005946">Overview</a></p>
</li>
<li>
<p><a href="#i1005951">Operational notes</a></p>
</li>
</ul>
<a id="i1005946"></a><a id="TTPLP71468"></a>
<hr/>
<h3 class="refsect2">Overview</h3>
<p>This package is necessary because normal SQL functions do not operate on <code>RAW</code> values and PL/SQL does not allow overloading between a <code>RAW</code> and a <code>CHAR</code> data type.</p>
<p><code>UTL_RAW</code> is not specific to the database environment and may be used in other environments. For this reason, the prefix <code>UTL</code> has been given to the package, instead of <code>DBMS</code>.</p>
<a id="i1005951"></a><a id="TTPLP71469"></a>
<hr/>
<h3 class="refsect2">Operational notes</h3>
<p><code>UTL_RAW</code> allows a <code>RAW</code> record to be composed of many elements. When the <code>RAW</code> data type is used, character set conversion is not performed, keeping the <code>RAW</code> value in its original format when being transferred through remote procedure calls.</p>
<p>With the <code>RAW</code> functions, you can manipulate binary data that was previously limited to the <code>hextoraw</code> and <code>rawtohex</code> SQL functions.</p>
<p>Functions returning <code>RAW</code> values do so in hexadecimal encoding.</p>
</div>
<!-- class="refsect1" -->
<a id="i996746"></a><a id="TTPLP71470"></a>
<hr/>
<div class="refsect1">
<h2 class="refsect1">Sum<a id="sthref891"></a>mary of UTL_RAW subprograms</h2>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71471"></a><a id="sthref892"></a><a id="sthref893"></a>Table 13-1 <span class="bolditalic">UTL_RAW Package Subprograms</span></p>
<table class="cellalignment1016" title="UTL_RAW Package Subprograms" summary="This table lists the UTL_RAW subprograms in alphabetical order and briefly describes them." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t2">Subprogram</th>
<th class="cellalignment1017" id="r1c2-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t2" headers="r1c1-t2">
<p><a href="#i1003896">BIT_AND function</a></p>
</td>
<td class="cellalignment1018" headers="r2c1-t2 r1c2-t2">
<p>Performs bitwise logical <code>AND</code> of two <code>RAW</code> values and returns the resulting <code>RAW</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t2" headers="r1c1-t2">
<p><a href="#BABGJABI">BIT_COMPLEMENT function</a></p>
</td>
<td class="cellalignment1018" headers="r3c1-t2 r1c2-t2">
<p>Performs bitwise logical <code>COMPLEMENT</code> of a <code>RAW</code> value and returns the resulting <code>RAW</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t2" headers="r1c1-t2">
<p><a href="#i1003945">BIT_OR function</a></p>
</td>
<td class="cellalignment1018" headers="r4c1-t2 r1c2-t2">
<p>Performs bitwise logical <code>OR</code> of two <code>RAW</code> values and returns the resulting <code>RAW</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t2" headers="r1c1-t2">
<p><a href="#i1003994">BIT_XOR function</a></p>
</td>
<td class="cellalignment1018" headers="r5c1-t2 r1c2-t2">
<p>Performs bitwise logical <code>XOR</code> (&#34;exclusive or&#34;) of two <code>RAW</code> values and returns the resulting <code>RAW</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t2" headers="r1c1-t2">
<p><a href="#i1004317">CAST_FROM_BINARY_DOUBLE function</a></p>
</td>
<td class="cellalignment1018" headers="r6c1-t2 r1c2-t2">
<p>Returns the <code>RAW</code> binary representation of a <code>BINARY_DOUBLE</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r7c1-t2" headers="r1c1-t2">
<p><a href="#i1004373">CAST_FROM_BINARY_FLOAT function</a></p>
</td>
<td class="cellalignment1018" headers="r7c1-t2 r1c2-t2">
<p>Returns the <code>RAW</code> binary representation of a <code>BINARY_FLOAT</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r8c1-t2" headers="r1c1-t2">
<p><a href="#i1004238">CAST_FROM_BINARY_INTEGER function</a></p>
</td>
<td class="cellalignment1018" headers="r8c1-t2 r1c2-t2">
<p>Returns the <code>RAW</code> binary representation of a <code>BINARY_INTEGER</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r9c1-t2" headers="r1c1-t2">
<p><a href="#BABBCAEG">CAST_FROM_NUMBER function</a></p>
</td>
<td class="cellalignment1018" headers="r9c1-t2 r1c2-t2">
<p>Returns the <code>RAW</code> binary representation of a <code>NUMBER</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r10c1-t2" headers="r1c1-t2">
<p><a href="#i1004636">CAST_TO_BINARY_DOUBLE function</a></p>
</td>
<td class="cellalignment1018" headers="r10c1-t2 r1c2-t2">
<p>Casts the <code>RAW</code> binary representation of a <code>BINARY_DOUBLE</code> value into a <code>BINARY_DOUBLE</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r11c1-t2" headers="r1c1-t2">
<p><a href="#i1004637">CAST_TO_BINARY_FLOAT function</a></p>
</td>
<td class="cellalignment1018" headers="r11c1-t2 r1c2-t2">
<p>Casts the <code>RAW</code> binary representation of a <code>BINARY_FLOAT</code> value into a <code>BINARY_FLOAT</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r12c1-t2" headers="r1c1-t2">
<p><a href="#BABGHJBD">CAST_TO_BINARY_INTEGER function</a></p>
</td>
<td class="cellalignment1018" headers="r12c1-t2 r1c2-t2">
<p>Casts the <code>RAW</code> binary representation of a <code>BINARY_INTEGER</code> value into a <code>BINARY_INTEGER</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r13c1-t2" headers="r1c1-t2">
<p><a href="#BABJJAFB">CAST_TO_NUMBER function</a></p>
</td>
<td class="cellalignment1018" headers="r13c1-t2 r1c2-t2">
<p>Casts the <code>RAW</code> binary representation of a <code>NUMBER</code> value into a <code>NUMBER</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r14c1-t2" headers="r1c1-t2">
<p><a href="#i1007280">CAST_TO_NVARCHAR2 function</a></p>
</td>
<td class="cellalignment1018" headers="r14c1-t2 r1c2-t2">
<p>Casts a <code>RAW</code> value into an <code>NVARCHAR2</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r15c1-t2" headers="r1c1-t2">
<p><a href="#i997085">CAST_TO_RAW function</a></p>
</td>
<td class="cellalignment1018" headers="r15c1-t2 r1c2-t2">
<p>Casts a <code>VARCHAR2</code> value into a <code>RAW</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r16c1-t2" headers="r1c1-t2">
<p><a href="#BABJFGBH">CAST_TO_VARCHAR2 function</a></p>
</td>
<td class="cellalignment1018" headers="r16c1-t2 r1c2-t2">
<p>Casts a <code>RAW</code> value into a <code>VARCHAR2</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r17c1-t2" headers="r1c1-t2">
<p><a href="#BABCIBGE">COMPARE function</a></p>
</td>
<td class="cellalignment1018" headers="r17c1-t2 r1c2-t2">
<p>Compares two <code>RAW</code> values.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r18c1-t2" headers="r1c1-t2">
<p><a href="#i997176">CONCAT function</a></p>
</td>
<td class="cellalignment1018" headers="r18c1-t2 r1c2-t2">
<p>Concatenates up to 12 <code>RAW</code> values into a single <code>RAW</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r19c1-t2" headers="r1c1-t2">
<p><a href="#i1003765">CONVERT function</a></p>
</td>
<td class="cellalignment1018" headers="r19c1-t2 r1c2-t2">
<p>Converts a <code>RAW</code> value from one character set to another and returns the resulting <code>RAW</code>.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r20c1-t2" headers="r1c1-t2">
<p><a href="#BABCGGCD">COPIES function</a></p>
</td>
<td class="cellalignment1018" headers="r20c1-t2 r1c2-t2">
<p>Copies a <code>RAW</code> value a specified number of times and returns the concatenated <code>RAW</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r21c1-t2" headers="r1c1-t2">
<p><a href="#BABCFHDJ">LENGTH function</a></p>
</td>
<td class="cellalignment1018" headers="r21c1-t2 r1c2-t2">
<p>Returns the length in bytes of a <code>RAW</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r22c1-t2" headers="r1c1-t2">
<p><a href="#i1003455">OVERLAY function</a></p>
</td>
<td class="cellalignment1018" headers="r22c1-t2 r1c2-t2">
<p>Overlays the specified portion of a target <code>RAW</code> value with an overlay <code>RAW</code> value, starting from a specified byte position and proceeding for a specified number of bytes.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r23c1-t2" headers="r1c1-t2">
<p><a href="#i1003598">REVERSE function</a></p>
</td>
<td class="cellalignment1018" headers="r23c1-t2 r1c2-t2">
<p>Reverses a byte-sequence in a <code>RAW</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r24c1-t2" headers="r1c1-t2">
<p><a href="#BABIFIJB">SUBSTR function</a></p>
</td>
<td class="cellalignment1018" headers="r24c1-t2 r1c2-t2">
<p>Returns a substring of a <code>RAW</code> value for a specified number of bytes from a specified starting position.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r25c1-t2" headers="r1c1-t2">
<p><a href="#i997340">TRANSLATE function</a></p>
</td>
<td class="cellalignment1018" headers="r25c1-t2 r1c2-t2">
<p>Translates the specified bytes from an input <code>RAW</code> value according to the bytes in a specified translation <code>RAW</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r26c1-t2" headers="r1c1-t2">
<p><a href="#i997416">TRANSLITERATE function</a></p>
</td>
<td class="cellalignment1018" headers="r26c1-t2 r1c2-t2">
<p>Converts the specified bytes from an input <code>RAW</code> value according to the bytes in a specified transliteration <code>RAW</code> value.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r27c1-t2" headers="r1c1-t2">
<p><a href="#BABGDIIJ">XRANGE function</a></p>
</td>
<td class="cellalignment1018" headers="r27c1-t2 r1c2-t2">
<p>Returns a <code>RAW</code> value containing the succession of one-byte encodings beginning and ending with the specified byte-codes.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>The <code>PLS_INTEGER</code> and <code>BINARY_INTEGER</code> data types are identical. This document uses <code>BINARY_INTEGER</code> to indicate data types in reference information (such as for table types, record types, subprogram parameters, or subprogram return values), but may use either in discussion and examples.</p>
</li>
<li>
<p>The <code>INTEGER</code> and <code>NUMBER(38)</code> data types are also identical. This document uses <code>INTEGER</code> throughout.</p>
</li>
</ul>
</div>
<a id="i1003896"></a><a id="TTPLP71472"></a>
<hr/>
<h3 class="refsect2"><a id="sthref894"></a>BIT_AND function</h3>
<p>This function performs bitwise logical <code>AND</code> of two supplied <code>RAW</code> values and returns the resulting <code>RAW</code>.</p>
<p class="titleinrefsubsect"><a id="sthref895"></a>Syntax</p>
<pre>UTL_RAW.BIT_AND (
   <span class="italic">r1</span> IN RAW,
   <span class="italic">r2</span> IN RAW) 
RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref896"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71473"></a><a id="sthref897"></a><a id="sthref898"></a>Table 13-2 BIT_AND function parameters</p>
<table class="cellalignment1016" title="BIT_AND function parameters " summary="This table describes the Parameters of the UTL_RAW.BIT_AND subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t4">Parameter</th>
<th class="cellalignment1017" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t4" headers="r1c1-t4">
<p><code><span class="codeinlineitalic">r1</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t4 r1c2-t4">
<p>First <code>RAW</code> value for <code>AND</code> operation</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t4" headers="r1c1-t4">
<p><code><span class="codeinlineitalic">r2</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t4 r1c2-t4">
<p>Second <code>RAW</code> value for <code>AND</code> operation</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref899"></a>Return value</p>
<p>Result of the <code>AND</code> operation, or <code>NULL</code> if either input value is <code>NULL</code></p>
<p class="titleinrefsubsect"><a id="sthref900"></a>Usage notes</p>
<p>If <code><span class="codeinlineitalic">r1</span></code> and <code><span class="codeinlineitalic">r2</span></code> differ in length, the operation is terminated after the last byte of the shorter of the two <code>RAW</code> values, and the unprocessed portion of the longer <code>RAW</code> value is appended to the partial result. The resulting length equals that of the longer of the two input values.</p>
<a id="BABGJABI"></a><a id="TTPLP71475"></a>
<hr/>
<h3 class="refsect2"><a id="sthref901"></a>BIT_COMPLEMENT function</h3>
<p>This function performs bitwise logical <code>COMPLEMENT</code> of the supplied <code>RAW</code> value and returns the resulting <code>RAW</code>. The result length equals the input <code>RAW</code> length.</p>
<p class="titleinrefsubsect"><a id="sthref902"></a>Syntax</p>
<pre>UTL_RAW.BIT_COMPLEMENT (
   <span class="italic">r</span> IN RAW) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref903"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71476"></a><a id="sthref904"></a><a id="sthref905"></a>Table 13-3 BIT_COMPLEMENT function parameters</p>
<table class="cellalignment1016" title="BIT_COMPLEMENT function parameters " summary="This table describes the Parameters of the UTL_RAW.BIT_COMPLEMENT subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t5">Parameter</th>
<th class="cellalignment1017" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t5" headers="r1c1-t5">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t5 r1c2-t5">
<p><code>RAW</code> value for <code>COMPLEMENT</code> operation</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref906"></a>Return value</p>
<p>Result of the <code>COMPLEMENT</code> operation, or <code>NULL</code> if the input value is <code>NULL</code></p>
<a id="i1003945"></a><a id="TTPLP71478"></a>
<hr/>
<h3 class="refsect2"><a id="sthref907"></a>BIT_OR function</h3>
<p>This function performs bitwise logical <code>OR</code> of two supplied <code>RAW</code> values and returns the resulting <code>RAW</code>.</p>
<p class="titleinrefsubsect"><a id="sthref908"></a>Syntax</p>
<pre>UTL_RAW.BIT_OR (
   <span class="italic">r1</span> IN RAW,
   <span class="italic">r2</span> IN RAW) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref909"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71479"></a><a id="sthref910"></a><a id="sthref911"></a>Table 13-4 BIT_OR function parameters</p>
<table class="cellalignment1016" title="BIT_OR function parameters " summary="This table describes the Parameters of the UTL_RAW.BIT_OR subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t6">Parameters</th>
<th class="cellalignment1017" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t6" headers="r1c1-t6">
<p><code><span class="codeinlineitalic">r1</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t6 r1c2-t6">
<p>First <code>RAW</code> value for <code>OR</code> operation</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t6" headers="r1c1-t6">
<p><code><span class="codeinlineitalic">r2</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t6 r1c2-t6">
<p>Second <code>RAW</code> value for <code>OR</code> operation</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref912"></a>Return value</p>
<p>Result of the <code>OR</code> operation, or <code>NULL</code> if either input value is <code>NULL</code></p>
<p class="titleinrefsubsect"><a id="sthref913"></a>Usage notes</p>
<p>If <code><span class="codeinlineitalic">r1</span></code> and <code><span class="codeinlineitalic">r2</span></code> differ in length, the operation is terminated after the last byte of the shorter of the two <code>RAW</code> values, and the unprocessed portion of the longer <code>RAW</code> value is appended to the partial result. The resulting length equals that of the longer of the two input values.</p>
<a id="i1003994"></a><a id="TTPLP71481"></a>
<hr/>
<h3 class="refsect2"><a id="sthref914"></a>BIT_XOR function</h3>
<p>This function performs bitwise logical <code>XOR</code> (&#34;exclusive or&#34;) of two supplied <code>RAW</code> values and returns the resulting <code>RAW</code>.</p>
<p class="titleinrefsubsect"><a id="sthref915"></a>Syntax</p>
<pre>UTL_RAW.BIT_XOR (
   <span class="italic">r1</span> IN RAW,
   <span class="italic">r2</span> IN RAW) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref916"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71482"></a><a id="sthref917"></a><a id="sthref918"></a>Table 13-5 BIT_XOR function parameters</p>
<table class="cellalignment1016" title="BIT_XOR function parameters " summary="This table describes the Parameters of the UTL_RAW.BIT_XOR subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t7">Parameter</th>
<th class="cellalignment1017" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t7" headers="r1c1-t7">
<p><code><span class="codeinlineitalic">r1</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t7 r1c2-t7">
<p>First <code>RAW</code> value for <code>XOR</code> operation</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t7" headers="r1c1-t7">
<p><code><span class="codeinlineitalic">r2</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t7 r1c2-t7">
<p>Second <code>RAW</code> value for <code>XOR</code> operation</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref919"></a>Return value</p>
<p>Result of the <code>XOR</code> operation, or <code>NULL</code> if either input value is <code>NULL</code></p>
<p class="titleinrefsubsect"><a id="sthref920"></a>Usage notes</p>
<p>If <code><span class="codeinlineitalic">r1</span></code> and <code><span class="codeinlineitalic">r2</span></code> differ in length, the operation is terminated after the last byte of the shorter of the two <code>RAW</code> values, and the unprocessed portion of the longer <code>RAW</code> value is appended to the partial result. The resulting length equals that of the longer of the two input values.</p>
<a id="i1004317"></a><a id="TTPLP71484"></a>
<hr/>
<h3 class="refsect2"><a id="sthref921"></a>CAST_FROM_BINARY_DOUBLE function</h3>
<p>This function returns the <code>RAW</code> binary representation of a <code>BINARY_DOUBLE</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref922"></a>Syntax</p>
<pre>UTL_RAW.CAST_FROM_BINARY_DOUBLE(
   <span class="italic">n</span>          IN BINARY_DOUBLE,
   <span class="italic">endianess</span>  IN BINARY_INTEGER DEFAULT 1) 
RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref923"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71485"></a><a id="sthref924"></a><a id="sthref925"></a>Table 13-6 CAST_FROM_BINARY_DOUBLE function parameters</p>
<table class="cellalignment1016" title="CAST_FROM_BINARY_DOUBLE function parameters" summary="This table describes the Parameters of the UTL_RAW.CAST_FROM_BINARARY_DOUBLE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t8">Parameter</th>
<th class="cellalignment1017" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t8" headers="r1c1-t8">
<p><code><span class="codeinlineitalic">n</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t8 r1c2-t8">
<p>The <code>BINARY_DOUBLE</code> value</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t8" headers="r1c1-t8">
<p><code><span class="codeinlineitalic">endianess</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t8 r1c2-t8">
<p><code>BINARY_INTEGER</code> value indicating the endianess</p>
<p>The function recognizes the defined constants <code>big_endian</code>, <code>little_endian</code>, and <code>machine_endian</code>. The default is <code>big_endian</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref926"></a>Return value</p>
<p><code>RAW</code> binary representation of the <code>BINARY_DOUBLE</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<p class="titleinrefsubsect"><a id="sthref927"></a>Usage notes</p>
<ul>
<li>
<p>An eight-byte <code>BINARY_DOUBLE</code> value maps to the IEEE 754 double-precision format as follows:</p>
<pre>byte 0: bit 63 ~ bit 56
byte 1: bit 55 ~ bit 48
byte 2: bit 47 ~ bit 40
byte 3: bit 39 ~ bit 32
byte 4: bit 31 ~ bit 24
byte 5: bit 23 ~ bit 16
byte 6: bit 15 ~ bit  8
byte 7: bit  7 ~ bit  0
</pre></li>
<li>
<p>Parameter <code><span class="codeinlineitalic">endianess</span></code> specifies how the bytes of the <code>BINARY_DOUBLE</code> value are mapped to the bytes of the <code>RAW</code> value. In the following matrix, <code>rb0</code> to <code>rb7</code> refer to the bytes of the <code>RAW</code> and <code>db0</code> to <code>db7</code> refer to the bytes of the <code>BINARY_DOUBLE</code>.</p>
<div class="inftblhruleinformalwide">
<table class="cellalignment1016" title="Parameter Endianess" summary="This table describes how the parameter Endianess describes how the bytes of BINARY_DOUBLE are mapped to the bytes of RAW." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t9">Endianess</th>
<th class="cellalignment1017" id="r1c2-t9">rb0</th>
<th class="cellalignment1017" id="r1c3-t9">rb1</th>
<th class="cellalignment1017" id="r1c4-t9">rb2</th>
<th class="cellalignment1017" id="r1c5-t9">rb3</th>
<th class="cellalignment1017" id="r1c6-t9">rb4</th>
<th class="cellalignment1017" id="r1c7-t9">rb5</th>
<th class="cellalignment1017" id="r1c8-t9">rb6</th>
<th class="cellalignment1017" id="r1c9-t9">rb7</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t9" headers="r1c1-t9"><span class="bold">big_endian</span></td>
<td class="cellalignment1018" headers="r2c1-t9 r1c2-t9"><code>db0</code></td>
<td class="cellalignment1018" headers="r2c1-t9 r1c3-t9"><code>db1</code></td>
<td class="cellalignment1018" headers="r2c1-t9 r1c4-t9"><code>db2</code></td>
<td class="cellalignment1018" headers="r2c1-t9 r1c5-t9"><code>db3</code></td>
<td class="cellalignment1018" headers="r2c1-t9 r1c6-t9"><code>db4</code></td>
<td class="cellalignment1018" headers="r2c1-t9 r1c7-t9"><code>db5</code></td>
<td class="cellalignment1018" headers="r2c1-t9 r1c8-t9"><code>db6</code></td>
<td class="cellalignment1018" headers="r2c1-t9 r1c9-t9"><code>db7</code></td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t9" headers="r1c1-t9"><span class="bold">little_endian</span></td>
<td class="cellalignment1018" headers="r3c1-t9 r1c2-t9"><code>db7</code></td>
<td class="cellalignment1018" headers="r3c1-t9 r1c3-t9"><code>db6</code></td>
<td class="cellalignment1018" headers="r3c1-t9 r1c4-t9"><code>db5</code></td>
<td class="cellalignment1018" headers="r3c1-t9 r1c5-t9"><code>db4</code></td>
<td class="cellalignment1018" headers="r3c1-t9 r1c6-t9"><code>db3</code></td>
<td class="cellalignment1018" headers="r3c1-t9 r1c7-t9"><code>db2</code></td>
<td class="cellalignment1018" headers="r3c1-t9 r1c8-t9"><code>db1</code></td>
<td class="cellalignment1018" headers="r3c1-t9 r1c9-t9"><code>db0</code></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformalwide" --></li>
<li>
<p>When <code>machine_endian</code> is specified, the eight bytes of the <code>BINARY_DOUBLE</code> argument are copied straight across into the <code>RAW</code> return value. The effect is the same as if the user specified <code>big_endian</code> on a big-endian system or <code>little_endian</code> on a little-endian system.</p>
</li>
</ul>
<a id="i1004373"></a><a id="TTPLP71486"></a>
<hr/>
<h3 class="refsect2"><a id="sthref928"></a>CAST_FROM_BINARY_FLOAT function</h3>
<p>This function returns the <code>RAW</code> binary representation of a <code>BINARY_FLOAT</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref929"></a>Syntax</p>
<pre>UTL_RAW.CAST_FROM_BINARY_FLOAT(
   <span class="italic">n</span>          IN BINARY_FLOAT,
   <span class="italic">endianess</span>  IN BINARY_INTEGER DEFAULT 1) 
RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref930"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71487"></a><a id="sthref931"></a><a id="sthref932"></a>Table 13-7 CAST_FROM_BINARY_FLOAT function parameters</p>
<table class="cellalignment1016" title="CAST_FROM_BINARY_FLOAT function parameters" summary="This table describes the Parameters of the UTL_RAW.CAST_FROM_BINARY_FLOAT subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t10">Parameter</th>
<th class="cellalignment1017" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t10" headers="r1c1-t10">
<p><code><span class="codeinlineitalic">n</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t10 r1c2-t10">
<p>The <code>BINARY_FLOAT</code> value</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t10" headers="r1c1-t10">
<p><code><span class="codeinlineitalic">endianess</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t10 r1c2-t10">
<p><code>BINARY_INTEGER</code> value indicating the endianess</p>
<p>The function recognizes the defined constants <code>big_endian</code>, <code>little_endian</code>, and <code>machine_endian</code>. The default is <code>big_endian</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref933"></a>Return value</p>
<p><code>RAW</code> binary representation of the <code>BINARY_FLOAT</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<p class="titleinrefsubsect"><a id="sthref934"></a>Usage notes</p>
<ul>
<li>
<p>A four-byte <code>BINARY_FLOAT</code> value maps to the IEEE 754 single-precision format as follows:</p>
<pre>byte 0: bit 31 ~ bit 24
byte 1: bit 23 ~ bit 16
byte 2: bit 15 ~ bit  8
byte 3: bit 7 ~  bit  0
</pre></li>
<li>
<p>The parameter <code><span class="codeinlineitalic">endianess</span></code> specifies how the bytes of the <code>BINARY_FLOAT</code> value are mapped to the bytes of the <code>RAW</code> value. In the following matrix, <code>rb0</code> to <code>rb3</code> refer to the bytes of the <code>RAW</code> and <code>fb0</code> to <code>fb3</code> refer to the bytes of the <code>BINARY_FLOAT</code>.</p>
<div class="inftblhruleinformal">
<table class="cellalignment1016" title="Parameter Endianess" summary="This table describes how the parameter Endianess describes how the bytes of BINARY_FLOAT are mapped to the bytes of RAW." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t11">Endianess</th>
<th class="cellalignment1017" id="r1c2-t11">rb0</th>
<th class="cellalignment1017" id="r1c3-t11">rb1</th>
<th class="cellalignment1017" id="r1c4-t11">rb2</th>
<th class="cellalignment1017" id="r1c5-t11">rb3</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t11" headers="r1c1-t11"><span class="bold">big_endian</span></td>
<td class="cellalignment1018" headers="r2c1-t11 r1c2-t11"><code>fbo</code></td>
<td class="cellalignment1018" headers="r2c1-t11 r1c3-t11"><code>fb1</code></td>
<td class="cellalignment1018" headers="r2c1-t11 r1c4-t11"><code>fb2</code></td>
<td class="cellalignment1018" headers="r2c1-t11 r1c5-t11"><code>fb3</code></td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t11" headers="r1c1-t11"><span class="bold">little_endian</span></td>
<td class="cellalignment1018" headers="r3c1-t11 r1c2-t11"><code>fb3</code></td>
<td class="cellalignment1018" headers="r3c1-t11 r1c3-t11"><code>fb2</code></td>
<td class="cellalignment1018" headers="r3c1-t11 r1c4-t11"><code>fb1</code></td>
<td class="cellalignment1018" headers="r3c1-t11 r1c5-t11"><code>fb0</code></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" --></li>
<li>
<p>When <code>machine_endian</code> is specified, the four bytes of the <code>BINARY_FLOAT</code> argument are copied straight across into the <code>RAW</code> return value. The effect is the same as if the user specified <code>big_endian</code> on a big-endian system or <code>little_endian</code> on a little-endian system.</p>
</li>
</ul>
<a id="i1004238"></a><a id="TTPLP71488"></a>
<hr/>
<h3 class="refsect2"><a id="sthref935"></a>CAST_FROM_BINARY_INTEGER function</h3>
<p>This function returns the <code>RAW</code> binary representation of a <code>BINARY_INTEGER</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref936"></a>Syntax</p>
<pre>UTL_RAW.CAST_FROM_BINARY_INTEGER (
   <span class="italic">n</span>          IN BINARY_INTEGER
   <span class="italic">endianess</span>  IN BINARY_INTEGER DEFAULT 1) 
RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref937"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71489"></a><a id="sthref938"></a><a id="sthref939"></a>Table 13-8 CAST_FROM_BINARY_INTEGER function parameters</p>
<table class="cellalignment1016" title="CAST_FROM_BINARY_INTEGER function parameters" summary="This table describes the Parameters of the UTL_RAW.CAST_FROM_BINARY_INTEGER subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t12">Parameter</th>
<th class="cellalignment1017" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">n</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t12 r1c2-t12">
<p>The <code>BINARY_INTEGER</code> value</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t12" headers="r1c1-t12">
<p><code><span class="codeinlineitalic">endianess</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t12 r1c2-t12">
<p><code>BINARY_INTEGER</code> value indicating the endianess</p>
<p>The function recognizes the defined constants <code>big_endian</code>, <code>little_endian</code>, and <code>machine_endian</code>. The default is <code>big_endian</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref940"></a>Return value</p>
<p><code>RAW</code> binary representation of the <code>BINARY_INTEGER</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<a id="BABBCAEG"></a><a id="TTPLP71490"></a>
<hr/>
<h3 class="refsect2"><a id="sthref941"></a>CAST_FROM_NUMBER function</h3>
<p>This function returns the <code>RAW</code> binary representation of a <code>NUMBER</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref942"></a>Syntax</p>
<pre>UTL_RAW.CAST_FROM_NUMBER (
   <span class="italic">n</span>  IN NUMBER)
 RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref943"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71491"></a><a id="sthref944"></a><a id="sthref945"></a>Table 13-9 CAST_FROM_NUMBER function parameters</p>
<table class="cellalignment1016" title="CAST_FROM_NUMBER function parameters" summary="This table describes the Parameters of the UTL_RAW.CAST_FROM_NUMBER subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t13">Parameter</th>
<th class="cellalignment1017" id="r1c2-t13">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t13" headers="r1c1-t13">
<p><code><span class="codeinlineitalic">n</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t13 r1c2-t13">
<p>The <code>NUMBER</code> value</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref946"></a>Return value</p>
<p><code>RAW</code> binary representation of the <code>NUMBER</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<a id="i1004636"></a><a id="TTPLP71492"></a>
<hr/>
<h3 class="refsect2"><a id="sthref947"></a>CAST_TO_BINARY_DOUBLE function</h3>
<p>This function casts the <code>RAW</code> binary representation of a <code>BINARY_DOUBLE</code> value into a <code>BINARY_DOUBLE</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref948"></a>Syntax</p>
<pre>UTL_RAW.CAST_TO_BINARY_DOUBLE (
   <span class="italic">r</span>          IN RAW
   <span class="italic">endianess</span>  IN BINARY_INTEGER DEFAULT 1) 
RETURN BINARY_DOUBLE;
</pre>
<p class="titleinrefsubsect"><a id="sthref949"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71622"></a><a id="sthref950"></a><a id="sthref951"></a>Table 13-10 CAST_TO_BINARY_DOUBLE function parameters</p>
<table class="cellalignment1016" title="CAST_TO_BINARY_DOUBLE function parameters" summary="This table describes the Parameters of the UTL_RAW.CAST_TO_BINARY_DOUBLE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t14">Parameter</th>
<th class="cellalignment1017" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t14 r1c2-t14">
<p><code>RAW</code> binary representation of a <code>BINARY_DOUBLE</code> value</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t14" headers="r1c1-t14">
<p><code><span class="codeinlineitalic">endianess</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t14 r1c2-t14">
<p><code>BINARY_INTEGER</code> value indicating the endianess</p>
<p>The function recognizes the defined constants <code>big_endian</code>, <code>little_endian</code>, and <code>machine_endian</code>. The default is <code>big_endian</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref952"></a>Return value</p>
<p>The <code>BINARY_DOUBLE</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<p class="titleinrefsubsect"><a id="sthref953"></a>Usage notes</p>
<ul>
<li>
<p>If the <code>RAW</code> argument is more than eight bytes, only the first eight bytes are used and the rest of the bytes are ignored. If the result is -0, +0 is returned. If the result is <code>NaN</code>, the value <code>BINARY_DOUBLE_NAN</code> is returned.</p>
</li>
<li>
<p>An eight-byte <code>BINARY_DOUBLE</code> value maps to the IEEE 754 double-precision format as follows:</p>
<pre>byte 0: bit 63 ~ bit 56
byte 1: bit 55 ~ bit 48
byte 2: bit 47 ~ bit 40
byte 3: bit 39 ~ bit 32
byte 4: bit 31 ~ bit 24
byte 5: bit 23 ~ bit 16
byte 6: bit 15 ~ bit  8
byte 7: bit  7 ~ bit  0
</pre></li>
<li>
<p>The parameter <code><span class="codeinlineitalic">endianess</span></code> specifies how the bytes of the <code>BINARY_DOUBLE</code> value are mapped to the bytes of the <code>RAW</code> value. In the following matrix, <code>rb0</code> to <code>rb7</code> refer to the bytes in <code>RAW</code> and <code>db0</code> to <code>db7</code> refer to the bytes in <code>BINARY_DOUBLE</code>.</p>
<div class="inftblhruleinformalwide">
<table class="cellalignment1016" title="Parameter Endianess" summary="This table describes how the parameter Endianess describes how the bytes of BINARY_DOUBLE are mapped to the bytes of RAW." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t15">Endianess</th>
<th class="cellalignment1017" id="r1c2-t15">rb0</th>
<th class="cellalignment1017" id="r1c3-t15">rb1</th>
<th class="cellalignment1017" id="r1c4-t15">rb2</th>
<th class="cellalignment1017" id="r1c5-t15">rb3</th>
<th class="cellalignment1017" id="r1c6-t15">rb4</th>
<th class="cellalignment1017" id="r1c7-t15">rb5</th>
<th class="cellalignment1017" id="r1c8-t15">rb6</th>
<th class="cellalignment1017" id="r1c9-t15">rb7</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t15" headers="r1c1-t15"><span class="bold">big_endian</span></td>
<td class="cellalignment1018" headers="r2c1-t15 r1c2-t15"><code>db0</code></td>
<td class="cellalignment1018" headers="r2c1-t15 r1c3-t15"><code>db1</code></td>
<td class="cellalignment1018" headers="r2c1-t15 r1c4-t15"><code>db2</code></td>
<td class="cellalignment1018" headers="r2c1-t15 r1c5-t15"><code>db3</code></td>
<td class="cellalignment1018" headers="r2c1-t15 r1c6-t15"><code>db4</code></td>
<td class="cellalignment1018" headers="r2c1-t15 r1c7-t15"><code>db5</code></td>
<td class="cellalignment1018" headers="r2c1-t15 r1c8-t15"><code>db6</code></td>
<td class="cellalignment1018" headers="r2c1-t15 r1c9-t15"><code>db7</code></td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t15" headers="r1c1-t15"><span class="bold">little_endian</span></td>
<td class="cellalignment1018" headers="r3c1-t15 r1c2-t15"><code>db7</code></td>
<td class="cellalignment1018" headers="r3c1-t15 r1c3-t15"><code>db6</code></td>
<td class="cellalignment1018" headers="r3c1-t15 r1c4-t15"><code>db5</code></td>
<td class="cellalignment1018" headers="r3c1-t15 r1c5-t15"><code>db4</code></td>
<td class="cellalignment1018" headers="r3c1-t15 r1c6-t15"><code>db3</code></td>
<td class="cellalignment1018" headers="r3c1-t15 r1c7-t15"><code>db2</code></td>
<td class="cellalignment1018" headers="r3c1-t15 r1c8-t15"><code>db1</code></td>
<td class="cellalignment1018" headers="r3c1-t15 r1c9-t15"><code>db0</code></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformalwide" --></li>
<li>
<p>When <code>machine_endian</code> is specified, the eight bytes of the <code>RAW</code> argument are copied straight across into the <code>BINARY_DOUBLE</code> return value. The effect is the same as if the user specified <code>big_endian</code> on a big-endian system or <code>little_endian</code> on a little-endian system.</p>
</li>
</ul>
<p class="titleinrefsubsect"><a id="sthref954"></a>Exceptions</p>
<p>If the <code>RAW</code> argument is less than eight bytes, a <code>VALUE_ERROR</code> exception is raised.</p>
<a id="i1004637"></a><a id="TTPLP71494"></a>
<hr/>
<h3 class="refsect2"><a id="sthref955"></a>CAST_TO_BINARY_FLOAT function</h3>
<p>This function casts the <code>RAW</code> binary representation of a <code>BINARY_FLOAT</code> value into a <code>BINARY_FLOAT</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref956"></a>Syntax</p>
<pre>UTL_RAW.CAST_TO_BINARY_FLOAT (
   <span class="italic">r</span>          IN RAW
   <span class="italic">endianess</span>  IN BINARY_INTEGER DEFAULT 1) 
RETURN BINARY_FLOAT;
</pre>
<p class="titleinrefsubsect"><a id="sthref957"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71495"></a><a id="sthref958"></a><a id="sthref959"></a>Table 13-11 CAST_TO_BINARY_FLOAT function parameters</p>
<table class="cellalignment1016" title="CAST_TO_BINARY_FLOAT function parameters" summary="This table describes the Parameters of the UTL_RAW.CAST_TO_BINARY_FLOAT subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t16">Parameter</th>
<th class="cellalignment1017" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t16" headers="r1c1-t16">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t16 r1c2-t16">
<p><code>RAW</code> binary representation of a <code>BINARY_FLOAT</code> value</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t16" headers="r1c1-t16">
<p><code><span class="codeinlineitalic">endianess</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t16 r1c2-t16">
<p><code>BINARY_INTEGER</code> value indicating the endianess</p>
<p>The function recognizes the defined constants <code>big_endian</code>, <code>little_endian</code>, and <code>machine_endian</code>. The default is <code>big_endian</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref960"></a>Return value</p>
<p>The <code>BINARY_FLOAT</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<p class="titleinrefsubsect"><a id="sthref961"></a>Usage notes</p>
<ul>
<li>
<p>If the <code>RAW</code> argument is more than four bytes, only the first four bytes are used and the rest of the bytes are ignored. If the result is -0, +0 is returned. If the result is <code>NaN</code>, the value <code>BINARY_FLOAT_NAN</code> is returned.</p>
</li>
<li>
<p>A four-byte <code>BINARY_FLOAT</code> value maps to the IEEE 754 single-precision format as follows:</p>
<pre>byte 0: bit 31 ~ bit 24
byte 1: bit 23 ~ bit 16
byte 2: bit 15 ~ bit  8
byte 3: bit 7 ~  bit  0
</pre></li>
<li>
<p>The parameter <code><span class="codeinlineitalic">endianess</span></code> specifies how the bytes of the <code>BINARY_FLOAT</code> value are mapped to the bytes of the <code>RAW</code> value. In the following matrix, <code>rb0</code> to <code>rb3</code> refer to the bytes in <code>RAW</code> and <code>fb0</code> to <code>fb3</code> refer to the bytes in <code>BINARY_FLOAT</code>.</p>
<div class="inftblhruleinformal">
<table class="cellalignment1016" title="Parameter Endianess" summary="This table describes how the parameter Endianess describes how the bytes of BINARY_FLOAT are mapped to the bytes of RAW." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t17">Endianess</th>
<th class="cellalignment1017" id="r1c2-t17">rb0</th>
<th class="cellalignment1017" id="r1c3-t17">rb1</th>
<th class="cellalignment1017" id="r1c4-t17">rb2</th>
<th class="cellalignment1017" id="r1c5-t17">rb3</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t17" headers="r1c1-t17"><span class="bold">big_endian</span></td>
<td class="cellalignment1018" headers="r2c1-t17 r1c2-t17"><code>fbo</code></td>
<td class="cellalignment1018" headers="r2c1-t17 r1c3-t17"><code>fb1</code></td>
<td class="cellalignment1018" headers="r2c1-t17 r1c4-t17"><code>fb2</code></td>
<td class="cellalignment1018" headers="r2c1-t17 r1c5-t17"><code>fb3</code></td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t17" headers="r1c1-t17"><span class="bold">little_endian</span></td>
<td class="cellalignment1018" headers="r3c1-t17 r1c2-t17"><code>fb3</code></td>
<td class="cellalignment1018" headers="r3c1-t17 r1c3-t17"><code>fb2</code></td>
<td class="cellalignment1018" headers="r3c1-t17 r1c4-t17"><code>fb1</code></td>
<td class="cellalignment1018" headers="r3c1-t17 r1c5-t17"><code>fb0</code></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" --></li>
<li>
<p>When <code>machine_endian</code> is specified, the four bytes of the <code>RAW</code> argument are copied straight across into the <code>BINARY_FLOAT</code> return value. The effect is the same as if the user specified <code>big_endian</code> on a big-endian system or <code>little_endian</code> on a little-endian system.</p>
</li>
</ul>
<p class="titleinrefsubsect"><a id="sthref962"></a>Exceptions</p>
<p>If the <code>RAW</code> argument is less than four bytes, a <code>VALUE_ERROR</code> exception is raised.</p>
<a id="BABGHJBD"></a><a id="TTPLP71496"></a>
<hr/>
<h3 class="refsect2"><a id="sthref963"></a>CAST_TO_BINARY_INTEGER function</h3>
<p>This function casts the <code>RAW</code> binary representation of a <code>BINARY_INTEGER</code> value into a <code>BINARY_INTEGER</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref964"></a>Syntax</p>
<pre>UTL_RAW.CAST_TO_BINARY_INTEGER (
   <span class="italic">r</span>          IN RAW
   <span class="italic">endianess</span>  IN BINARY_INTEGER DEFAULT 1) 
RETURN BINARY_INTEGER;
</pre>
<p class="titleinrefsubsect"><a id="sthref965"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71497"></a><a id="sthref966"></a><a id="sthref967"></a>Table 13-12 CAST_TO_BINARY_INTEGER function parameters</p>
<table class="cellalignment1016" title="CAST_TO_BINARY_INTEGER function parameters" summary="This table describes the Parameters of the UTL_RAW.CAST_TO_BINARY_INTEGER subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t18">Parameter</th>
<th class="cellalignment1017" id="r1c2-t18">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t18" headers="r1c1-t18">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t18 r1c2-t18">
<p><code>RAW</code> binary representation of a <code>BINARY_INTEGER</code> value</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t18" headers="r1c1-t18">
<p><code><span class="codeinlineitalic">endianess</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t18 r1c2-t18">
<p><code>BINARY_INTEGER</code> value indicating the endianess</p>
<p>The function recognizes the defined constants <code>big_endian</code>, <code>little_endian</code>, and <code>machine_endian</code>. The default is <code>big_endian</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref968"></a>Return value</p>
<p>The <code>BINARY_INTEGER</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<a id="BABJJAFB"></a><a id="TTPLP71498"></a>
<hr/>
<h3 class="refsect2"><a id="sthref969"></a>CAST_TO_NUMBER function</h3>
<p>This function casts the <code>RAW</code> binary representation of a <code>NUMBER</code> value into a <code>NUMBER</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref970"></a>Syntax</p>
<pre>UTL_RAW.CAST_TO_NUMBER (
   <span class="italic">r</span>  IN RAW) 
 RETURN NUMBER;
</pre>
<p class="titleinrefsubsect"><a id="sthref971"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71499"></a><a id="sthref972"></a><a id="sthref973"></a>Table 13-13 CAST_TO_NUMBER function parameters</p>
<table class="cellalignment1016" title="CAST_TO_NUMBER function parameters" summary="This table describes the Parameters of the UTL_RAW.CAST_TO_NUMBER subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t19">Parameter</th>
<th class="cellalignment1017" id="r1c2-t19">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t19" headers="r1c1-t19">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t19 r1c2-t19">
<p><code>RAW</code> binary representation of a <code>NUMBER</code> value</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref974"></a>Return value</p>
<p>The <code>NUMBER</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<a id="i1007280"></a><a id="TTPLP71500"></a>
<hr/>
<h3 class="refsect2"><a id="sthref975"></a>CAST_TO_NVARCHAR2 function</h3>
<p>This function casts a <code>RAW</code> value represented using some number of data bytes into an <code>NVARCHAR2</code> value with that number of data bytes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When casting to <code>NVARCHAR2</code>, the current Globalization Support character set is used for the characters within that <code>NVARCHAR2</code> value.</div>
<p class="titleinrefsubsect"><a id="sthref976"></a>Syntax</p>
<pre>UTL_RAW.CAST_TO_NVARCHAR2 (
   <span class="italic">r</span> IN RAW) 
RETURN NVARCHAR2;
</pre>
<p class="titleinrefsubsect"><a id="sthref977"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71501"></a><a id="sthref978"></a><a id="sthref979"></a>Table 13-14 CAST_TO_NVARCHAR2 function parameters</p>
<table class="cellalignment1016" title="CAST_TO_NVARCHAR2 function parameters " summary="This table describes the Parameters of the UTL_RAW.CAST_TO_NVARCHAR2 subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t21">Parameter</th>
<th class="cellalignment1017" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t21" headers="r1c1-t21">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t21 r1c2-t21">
<p><code>RAW</code> value, without leading length field, to be changed to an <code>NVARCHAR2</code> value</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref980"></a>Return value</p>
<p>Data converted from the input <code>RAW</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<a id="i997085"></a><a id="TTPLP71503"></a>
<hr/>
<h3 class="refsect2"><a id="sthref981"></a>CAST_TO_RAW function</h3>
<p>This function casts a <code>VARCHAR2</code> value represented using some number of data bytes into a <code>RAW</code> value with that number of data bytes. The data itself is not modified in any way, but its data type is recast to a <code>RAW</code> data type.</p>
<p class="titleinrefsubsect"><a id="sthref982"></a>Syntax</p>
<pre>UTL_RAW.CAST_TO_RAW (
   <span class="italic">c</span>  IN VARCHAR2) 
RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref983"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71504"></a><a id="sthref984"></a><a id="sthref985"></a>Table 13-15 CAST_TO_RAW function parameters</p>
<table class="cellalignment1016" title="CAST_TO_RAW function parameters " summary="This table describes the Parameters of the UTL_RAW.CAST_TO_RAW subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t22">Parameter</th>
<th class="cellalignment1017" id="r1c2-t22">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t22" headers="r1c1-t22">
<p><code><span class="codeinlineitalic">c</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t22 r1c2-t22">
<p><code>VARCHAR2</code> value to be changed to a <code>RAW</code> value</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref986"></a>Return values</p>
<p>Data converted from the input <code>VARCHAR2</code> value, with the same byte-length as the input value but without a leading length field, or <code>NULL</code> if the input is <code>NULL</code></p>
<a id="BABJFGBH"></a><a id="TTPLP71506"></a>
<hr/>
<h3 class="refsect2"><a id="sthref987"></a>CAST_TO_VARCHAR2 function</h3>
<p>This function casts a <code>RAW</code> value represented using some number of data bytes into a <code>VARCHAR2</code> value with that number of data bytes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When casting to <code>VARCHAR2</code>, the current Globalization Support character set is used for the characters within that <code>VARCHAR2</code> value.</div>
<p class="titleinrefsubsect"><a id="sthref988"></a>Syntax</p>
<pre>UTL_RAW.CAST_TO_VARCHAR2 (
   <span class="italic">r</span> IN RAW) 
RETURN VARCHAR2;
</pre>
<p class="titleinrefsubsect"><a id="sthref989"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71507"></a><a id="sthref990"></a><a id="sthref991"></a>Table 13-16 CAST_TO_VARCHAR2 function parameters</p>
<table class="cellalignment1016" title="CAST_TO_VARCHAR2 function parameters " summary="This table describes the Parameters of the UTL_RAW.CAST_TO_VARCHAR2 subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t24">Parameter</th>
<th class="cellalignment1017" id="r1c2-t24">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t24" headers="r1c1-t24">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t24 r1c2-t24">
<p><code>RAW</code> value, without leading length field, to be changed to a <code>VARCHAR2</code> value</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref992"></a>Return value</p>
<p>Data converted from the input <code>RAW</code> value, or <code>NULL</code> if the input is <code>NULL</code></p>
<a id="BABCIBGE"></a><a id="TTPLP71509"></a>
<hr/>
<h3 class="refsect2"><a id="sthref993"></a>COMPARE function</h3>
<p>This function compares two <code>RAW</code> values. If they differ in length, then the shorter is extended on the right according to the optional <code>pad</code> parameter.</p>
<p class="titleinrefsubsect"><a id="sthref994"></a>Syntax</p>
<pre>UTL_RAW.COMPARE (
   <span class="italic">r1</span>  IN RAW,
   <span class="italic">r2</span>  IN RAW
  [,<span class="italic">pad</span> IN RAW DEFAULT NULL]) 
  RETURN NUMBER;
</pre>
<p class="titleinrefsubsect"><a id="sthref995"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71510"></a><a id="sthref996"></a><a id="sthref997"></a>Table 13-17 COMPARE function parameters</p>
<table class="cellalignment1016" title="COMPARE function parameters " summary="This table describes the Parameters of the UTL_RAW.COMPARE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t25">Parameter</th>
<th class="cellalignment1017" id="r1c2-t25">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t25" headers="r1c1-t25">
<p><code><span class="codeinlineitalic">r1</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t25 r1c2-t25">
<p>First <code>RAW</code> value to be compared</p>
<p><span class="bold">Note</span>: The value can be <code>NULL</code> or zero-length.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t25" headers="r1c1-t25">
<p><code><span class="codeinlineitalic">r2</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t25 r1c2-t25">
<p>Second <code>RAW</code> value to be compared</p>
<p><span class="bold">Note</span>: The value can be <code>NULL</code> or zero-length.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t25" headers="r1c1-t25">
<p><code><span class="codeinlineitalic">pad</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t25 r1c2-t25">
<p>Byte to extend whichever of the input values is shorter (default <code>x&#39;00&#39;</code>)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref998"></a>Return value</p>
<p>A <code>NUMBER</code> value that equals the position number (numbered from 1) of the first mismatched byte when comparing the two input values, or 0 if the input values are identical or both <code>NULL</code></p>
<a id="i997176"></a><a id="TTPLP71512"></a>
<hr/>
<h3 class="refsect2"><a id="sthref999"></a>CONCAT function</h3>
<p>This function concatenates up to 12 <code>RAW</code> values into a single <code>RAW</code> value. If the concatenated size exceeds 32 KB, an error is returned.</p>
<p class="titleinrefsubsect"><a id="sthref1000"></a>Syntax</p>
<pre>UTL_RAW.CONCAT (  
   <span class="italic">r1</span>  IN RAW DEFAULT NULL,
   <span class="italic">r2</span>  IN RAW DEFAULT NULL,
   <span class="italic">r3</span>  IN RAW DEFAULT NULL,
   <span class="italic">r4</span>  IN RAW DEFAULT NULL,
   <span class="italic">r5</span>  IN RAW DEFAULT NULL,
   <span class="italic">r6</span>  IN RAW DEFAULT NULL,
   <span class="italic">r7</span>  IN RAW DEFAULT NULL,
   <span class="italic">r8</span>  IN RAW DEFAULT NULL,
   <span class="italic">r9</span>  IN RAW DEFAULT NULL,
   <span class="italic">r10</span> IN RAW DEFAULT NULL,
   <span class="italic">r11</span> IN RAW DEFAULT NULL,
   <span class="italic">r12</span> IN RAW DEFAULT NULL) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref1001"></a>Parameters</p>
<p>Items <code><span class="codeinlineitalic">r1...r12</span></code> are the <code>RAW</code> items to concatenate.</p>
<p class="titleinrefsubsect"><a id="sthref1002"></a>Return value</p>
<p><code>RAW</code> value consisting of the concatenated input values</p>
<p class="titleinrefsubsect"><a id="sthref1003"></a>Exceptions</p>
<p>There is an error if the sum of the lengths of the inputs exceeds the maximum allowable length for a <code>RAW</code> value, which is 32767 bytes.</p>
<a id="i1003765"></a><a id="TTPLP71514"></a>
<hr/>
<h3 class="refsect2"><a id="sthref1004"></a>CONVERT function</h3>
<p>This function converts a <code>RAW</code> value from one character set to another and returns the resulting <code>RAW</code> value.</p>
<p>Both character sets must be supported character sets defined to the database.</p>
<p class="titleinrefsubsect"><a id="sthref1005"></a>Syntax</p>
<pre>UTL_RAW.CONVERT (
   <span class="italic">r</span>            IN RAW,
   <span class="italic">to_charset</span>   IN VARCHAR2,
   <span class="italic">from_charset</span> IN VARCHAR2) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref1006"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71515"></a><a id="sthref1007"></a><a id="sthref1008"></a>Table 13-18 CONVERT function parameters</p>
<table class="cellalignment1016" title="CONVERT function parameters " summary="This table describes the Parameters of the UTL_RAW.CONVERT subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t26">Parameter</th>
<th class="cellalignment1017" id="r1c2-t26">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t26" headers="r1c1-t26">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t26 r1c2-t26">
<p><code>RAW</code> byte-string to be converted</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t26" headers="r1c1-t26">
<p><code><span class="codeinlineitalic">to_charset</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t26 r1c2-t26">
<p>Name of Globalization Support character set to which the input value is converted</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t26" headers="r1c1-t26">
<p><code><span class="codeinlineitalic">from_charset</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t26 r1c2-t26">
<p>Name of Globalization Support character set from which the input value is converted</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref1009"></a>Return value</p>
<p>Converted byte-string according to the specified character set</p>
<p class="titleinrefsubsect"><a id="sthref1010"></a>Exceptions</p>
<p><code>VALUE_ERROR</code> occurs under any of the following circumstances:</p>
<ul>
<li>
<p>The input byte-string is missing, <code>NULL</code>, or zero-length.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">from_charset</span></code> or <code><span class="codeinlineitalic">to_charset</span></code> parameter is missing, <code>NULL</code>, or zero-length.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">from_charset</span></code> or <code><span class="codeinlineitalic">to_charset</span></code> parameter is invalid or unsupported.</p>
</li>
</ul>
<a id="BABCGGCD"></a><a id="TTPLP71518"></a>
<hr/>
<h3 class="refsect2"><a id="sthref1011"></a>COPIES function</h3>
<p>This function returns a specified number of copies of a specified <code>RAW</code> value, concatenated.</p>
<p class="titleinrefsubsect"><a id="sthref1012"></a>Syntax</p>
<pre>UTL_RAW.COPIES (
   <span class="italic">r</span> IN RAW,
   <span class="italic">n</span> IN NUMBER) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref1013"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71519"></a><a id="sthref1014"></a><a id="sthref1015"></a>Table 13-19 COPIES function parameters</p>
<table class="cellalignment1016" title="COPIES function parameters " summary="This table describes the Parameters of the UTL_RAW.COPIES subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t27">Parameters</th>
<th class="cellalignment1017" id="r1c2-t27">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t27" headers="r1c1-t27">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t27 r1c2-t27">
<p><code>RAW</code> value to be copied</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t27" headers="r1c1-t27">
<p><code><span class="codeinlineitalic">n</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t27 r1c2-t27">
<p>Number of times to copy the <code>RAW</code> value</p>
<p><span class="bold">Note</span>: This must be a positive value.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref1016"></a>Return value</p>
<p><code>RAW</code> value copied the specified number of times and concatenated</p>
<p class="titleinrefsubsect"><a id="sthref1017"></a>Exceptions</p>
<p><code>VALUE_ERROR</code> occurs under any of the following circumstances:</p>
<ul>
<li>
<p>The value to be copied is missing, <code>NULL</code>, or zero-length.</p>
</li>
<li>
<p>The number of times to copy the value is less than or equal to 0.</p>
</li>
<li>
<p>The length of the result exceeds the maximum allowable length for a <code>RAW</code> value, which is 32767 bytes.</p>
</li>
</ul>
<a id="BABCFHDJ"></a><a id="TTPLP71521"></a>
<hr/>
<h3 class="refsect2"><a id="sthref1018"></a>LENGTH function</h3>
<p>This function returns the length in bytes of a <code>RAW</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref1019"></a>Syntax</p>
<pre>UTL_RAW.LENGTH (
   <span class="italic">r</span>  IN RAW) 
RETURN NUMBER;
</pre>
<p class="titleinrefsubsect"><a id="sthref1020"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71522"></a><a id="sthref1021"></a><a id="sthref1022"></a>Table 13-20 LENGTH function parameters</p>
<table class="cellalignment1016" title="LENGTH function parameters " summary="This table describes the Parameters of the UTL_RAW.LENGTH subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t28">Parameter</th>
<th class="cellalignment1017" id="r1c2-t28">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t28" headers="r1c1-t28">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t28 r1c2-t28">
<p><code>RAW</code> byte-stream to be measured</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref1023"></a>Return value</p>
<p><code>NUMBER</code> value indicating the length of the <code>RAW</code> value, in bytes</p>
<a id="i1003455"></a><a id="TTPLP71524"></a>
<hr/>
<h3 class="refsect2"><a id="sthref1024"></a>OVERLAY function</h3>
<p>This function overlays the specified portion of a target <code>RAW</code> value with an overlay <code>RAW</code>, starting from a specified byte position and proceeding for a specified number of bytes.</p>
<p class="titleinrefsubsect"><a id="sthref1025"></a>Syntax</p>
<pre>UTL_RAW.OVERLAY (
   <span class="italic">overlay_str</span> IN RAW,
   <span class="italic">target</span>      IN RAW
  [,<span class="italic">pos</span>         IN BINARY_INTEGER DEFAULT 1,
   <span class="italic">len</span>         IN BINARY_INTEGER DEFAULT NULL,
   <span class="italic">pad</span>         IN RAW            DEFAULT NULL]) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref1026"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71525"></a><a id="sthref1027"></a><a id="sthref1028"></a>Table 13-21 OVERLAY function parameters</p>
<table class="cellalignment1016" title="OVERLAY function parameters " summary="This table describes the Parameters of the UTL_RAW.OVERLAY subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t29">Parameters</th>
<th class="cellalignment1017" id="r1c2-t29">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t29" headers="r1c1-t29">
<p><code><span class="codeinlineitalic">overlay_str</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t29 r1c2-t29">
<p>Byte-string used to overlay target</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t29" headers="r1c1-t29">
<p><code><span class="codeinlineitalic">target</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t29 r1c2-t29">
<p>Target byte-string to be overlaid</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t29" headers="r1c1-t29">
<p><code><span class="codeinlineitalic">pos</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t29 r1c2-t29">
<p>Byte position in target at which to start overlay, numbered from 1 (default 1)</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t29" headers="r1c1-t29">
<p><code><span class="codeinlineitalic">len</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t29 r1c2-t29">
<p>Number of bytes to overlay (default: length of <code><span class="codeinlineitalic">overlay_str</span></code>)</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r6c1-t29" headers="r1c1-t29">
<p><code><span class="codeinlineitalic">pad</span></code></p>
</td>
<td class="cellalignment1018" headers="r6c1-t29 r1c2-t29">
<p>Pad byte used when <code>len</code> exceeds <code><span class="codeinlineitalic">overlay_str</span></code> length or <code><span class="codeinlineitalic">pos</span></code> exceeds <code><span class="codeinlineitalic">target</span></code> length (default <code>x&#39;00&#39;</code>)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref1029"></a>Return value</p>
<p><code>RAW</code> target byte value overlaid as specified</p>
<p class="titleinrefsubsect"><a id="sthref1030"></a>Usage notes</p>
<p>If <code><span class="codeinlineitalic">overlay_str</span></code> has less than <code><span class="codeinlineitalic">len</span></code> bytes, then it is extended to <code><span class="codeinlineitalic">len</span></code> bytes using the <code><span class="codeinlineitalic">pad</span></code> byte. If <code><span class="codeinlineitalic">overlay_str</span></code> exceeds <code><span class="codeinlineitalic">len</span></code> bytes, then the extra bytes in <code><span class="codeinlineitalic">overlay_str</span></code> are ignored. If <code><span class="codeinlineitalic">len</span></code> bytes beginning at position <code><span class="codeinlineitalic">pos</span></code> of <code>target</code> exceed the length of <code><span class="codeinlineitalic">target</span></code>, then <code><span class="codeinlineitalic">target</span></code> is extended to contain the entire length of <code><span class="codeinlineitalic">overlay_str</span></code>.</p>
<p><code>If</code> <code><span class="codeinlineitalic">len</span></code> is specified, it must be greater than or equal to 0. If <code><span class="codeinlineitalic">pos</span></code> is specified, it must be greater than or equal to 1. If <code><span class="codeinlineitalic">pos</span></code> exceeds the length of <code><span class="codeinlineitalic">target</span></code>, then <code><span class="codeinlineitalic">target</span></code> is padded with <code><span class="codeinlineitalic">pad</span></code> bytes to position <code><span class="codeinlineitalic">pos</span></code>, and <code><span class="codeinlineitalic">target</span></code> is further extended with <code><span class="codeinlineitalic">overlay_str</span></code> bytes.</p>
<p class="titleinrefsubsect"><a id="sthref1031"></a>Exceptions</p>
<p><code>VALUE_ERROR</code> occurs under any of the following circumstances:</p>
<ul>
<li>
<p>The <code><span class="codeinlineitalic">overlay_str</span></code> is <code>NULL</code> or zero-length.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">target</span></code> is missing or undefined.</p>
</li>
<li>
<p>The length of <code><span class="codeinlineitalic">target</span></code> exceeds the maximum length for a <code>RAW</code> value, 32767 bytes.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">len</span></code> is less than 0.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">pos</span></code> is less than or equal to 0.</p>
</li>
</ul>
<a id="i1003598"></a><a id="TTPLP71529"></a>
<hr/>
<h3 class="refsect2"><a id="sthref1032"></a>REVERSE function</h3>
<p>This function reverses a <code>RAW</code> byte-sequence from end to end. For example, <code>x&#39;0102F3&#39;</code> would be reversed to <code>x&#39;F30201&#39;</code>, and <code>&#39;xyz&#39;</code> would be reversed to <code>&#39;zyx&#39;</code>. The result length is the same as the input length.</p>
<p class="titleinrefsubsect"><a id="sthref1033"></a>Syntax</p>
<pre>UTL_RAW.REVERSE (
   <span class="italic">r</span> IN RAW) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref1034"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71530"></a><a id="sthref1035"></a><a id="sthref1036"></a>Table 13-22 REVERSE function parameters</p>
<table class="cellalignment1016" title="REVERSE function parameters " summary="This table describes the Parameters of the UTL_RAW.REVERSE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t30">Parameter</th>
<th class="cellalignment1017" id="r1c2-t30">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t30" headers="r1c1-t30">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t30 r1c2-t30">
<p><code>RAW</code> value to reverse</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref1037"></a>Return value</p>
<p><code>RAW</code> value that is the reverse of the input value</p>
<p class="titleinrefsubsect"><a id="sthref1038"></a>Exceptions</p>
<p><code>VALUE_ERROR</code> occurs if the input value is <code>NULL</code> or zero-length.</p>
<a id="BABIFIJB"></a><a id="TTPLP71533"></a>
<hr/>
<h3 class="refsect2"><a id="sthref1039"></a>SUBSTR function</h3>
<p>This function returns a substring of a <code>RAW</code> value for a specified number of bytes and starting position.</p>
<p class="titleinrefsubsect"><a id="sthref1040"></a>Syntax</p>
<pre>UTL_RAW.SUBSTR (
   <span class="italic">r</span>   IN RAW,
   <span class="italic">pos</span> IN BINARY_INTEGER
  [,<span class="italic">len</span> IN BINARY_INTEGER DEFAULT NULL]) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref1041"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71623"></a><a id="sthref1042"></a><a id="sthref1043"></a>Table 13-23 SUBSTR function parameters</p>
<table class="cellalignment1016" title="SUBSTR function parameters " summary="This table describes the Parameters of the UTL_RAW.SUBSTR subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t31">Parameter</th>
<th class="cellalignment1017" id="r1c2-t31">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t31" headers="r1c1-t31">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t31 r1c2-t31">
<p><code>RAW</code> byte-string from which the substring is extracted</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t31" headers="r1c1-t31">
<p><code><span class="codeinlineitalic">pos</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t31 r1c2-t31">
<p>Byte position at which to begin extraction, either counting forward from the beginning of the input byte-string (positive value) or backward from the end (negative value)</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t31" headers="r1c1-t31">
<p><code><span class="codeinlineitalic">len</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t31 r1c2-t31">
<p>Number of bytes, beginning at <code><span class="codeinlineitalic">pos</span></code> and proceeding toward the end of the byte string, to extract (default: to the end of the <code>RAW</code> byte-string)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref1044"></a>Return value</p>
<p><code>RAW</code> substring beginning at position <code><span class="codeinlineitalic">pos</span></code> for <code><span class="codeinlineitalic">len</span></code> bytes, or <code>NULL</code> if the input is <code>NULL</code></p>
<p class="titleinrefsubsect"><a id="sthref1045"></a>Usage notes</p>
<p>If <code><span class="codeinlineitalic">pos</span></code> is positive, <code>SUBSTR</code> counts from the beginning of the <code>RAW</code> byte-string to find the first byte. If <code><span class="codeinlineitalic">pos</span></code> is negative, <code>SUBSTR</code> counts backward from the end of the <code>RAW</code> byte-string. The value of <code><span class="codeinlineitalic">pos</span></code> cannot equal 0.</p>
<p>A specified value of <code><span class="codeinlineitalic">len</span></code> must be positive. If <code><span class="codeinlineitalic">len</span></code> is omitted, <code>SUBSTR</code> returns all bytes to the end of the <code>RAW</code> byte-string.</p>
<p class="titleinrefsubsect"><a id="sthref1046"></a>Exceptions</p>
<p><code>VALUE_ERROR</code> occurs under any of the following circumstances:</p>
<ul>
<li>
<p>The <code><span class="codeinlineitalic">pos</span></code> equals 0 or is greater than the length of <code>r</code>.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">len</span></code> is less than or equal to 0.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">len</span></code> is greater than (length of <code><span class="codeinlineitalic">r</span></code>) minus (<code><span class="codeinlineitalic">pos</span></code>-1).</p>
</li>
</ul>
<p class="titleinrefsubsect"><a id="sthref1047"></a>Examples</p>
<p><span class="bold">Example 1:</span> This example, run in <code>ttIsql</code>, counts backward 15 bytes from the end of the input <code>RAW</code> value for its starting position, then takes a substring of five bytes starting at that point.</p>
<pre>declare
  sr raw(32767); 
  r raw(32767);

begin
  sr       := hextoraw(&#39;1236567812125612344434341234567890ABAA1234&#39;);
  r := UTL_RAW.SUBSTR(sr, -15, 5);
  dbms_output.put_line(&#39;source raw: &#39; || sr);
  dbms_output.put_line(&#39;return raw: &#39; || r);
end;
/
</pre>
<p>The result is as follows:</p>
<pre>source raw: 1236567812125612344434341234567890ABAA1234
return raw: 5612344434
 
PL/SQL procedure successfully completed.
</pre>
<p>Here the input and output are presented, for purposes of this discussion, in a way that gives a clearer indication of the functionality:</p>
<pre>source raw: 12 36 56 78 12 12 <span class="bold">56 12 34 44 34</span> 34 12 34 56 78 90 AB AA 12 34
return raw: 56 12 34 44 34
</pre>
<p>The substring starts at the 15th byte from the end.</p>
<p><span class="bold">Example 2:</span> This example, run in <code>ttIsql</code>, has the same input <code>RAW</code> value and starting point as the preceding example, but because <code>len</code> is not specified the substring is taken from the starting point to the end of the input.</p>
<pre>declare
  sr raw(32767); 
  r raw(32767);
begin
  sr       := hextoraw(&#39;1236567812125612344434341234567890ABAA1234&#39;);
  r := UTL_RAW.SUBSTR(sr, -15);
  dbms_output.put_line(&#39;source raw: &#39; || sr);
  dbms_output.put_line(&#39;return raw: &#39; || r);
end;
/
</pre>
<p>Here is the result:</p>
<pre>source raw: 1236567812125612344434341234567890ABAA1234
return raw: 5612344434341234567890ABAA1234
</pre>
<p>Here the input and output are presented, for purposes of this discussion, in a way that gives a clearer indication of the functionality:</p>
<pre>source raw: 12 36 56 78 12 12 56 12 34 44 34 34 12 34 56 78 90 AB AA 12 34
return raw: 56 12 34 44 34 34 12 34 56 78 90 AB AA 12 34
</pre>
<a id="i997340"></a><a id="TTPLP71538"></a>
<hr/>
<h3 class="refsect2"><a id="sthref1048"></a>TRANSLATE function</h3>
<p>This function performs a byte-by-byte translation of a <code>RAW</code> value, given an input set of bytes, a set of bytes to search for and translate from in the input bytes, and a set of corresponding bytes to translate to. Whenever a byte in the specified <code><span class="codeinlineitalic">from_set</span></code> is found in the input <code>RAW</code> value, it is translated to the corresponding byte in the <code><span class="codeinlineitalic">to_set</span></code> for the output <code>RAW</code> value, or it is simply not included in the output <code>RAW</code> value if there is no corresponding byte in <code><span class="codeinlineitalic">to_set</span></code>. Any bytes in the input <code>RAW</code> value that do not appear in <code><span class="codeinlineitalic">from_set</span></code> are simply copied as-is to the output <code>RAW</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref1049"></a>Syntax</p>
<pre>UTL_RAW.TRANSLATE (
   <span class="italic">r</span>        IN RAW,
   <span class="italic">from_set</span> IN RAW,
   <span class="italic">to_set</span>   IN RAW) 
  RETURN RAW;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Be aware that <code><span class="codeinlineitalic">to_set</span></code> and <code><span class="codeinlineitalic">from_set</span></code> are reversed in the calling sequence compared to <code>TRANSLITERATE</code>.</div>
<p class="titleinrefsubsect"><a id="sthref1050"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71539"></a><a id="sthref1051"></a><a id="sthref1052"></a>Table 13-24 TRANSLATE function parameters</p>
<table class="cellalignment1016" title="TRANSLATE function parameters " summary="This table describes the Parameters of the UTL_RAW.TRANSLATE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t33">Parameter</th>
<th class="cellalignment1017" id="r1c2-t33">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t33" headers="r1c1-t33">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t33 r1c2-t33">
<p><code>RAW</code> source byte-string whose bytes are to be translated, as applicable</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t33" headers="r1c1-t33">
<p><code><span class="codeinlineitalic">from_set</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t33 r1c2-t33">
<p><code>RAW</code> byte-codes that are searched for in the source byte-string</p>
<p>Where found, they are translated in the result.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t33" headers="r1c1-t33">
<p><code><span class="codeinlineitalic">to_set</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t33 r1c2-t33">
<p><code>RAW</code> byte-codes to translate to</p>
<p>Where a <code><span class="codeinlineitalic">from_set</span></code> byte is found in the source byte-string, it is translated in the result to the corresponding <code><span class="codeinlineitalic">to_set</span></code> byte, as applicable.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref1053"></a>Return value</p>
<p><code>RAW</code> value with the translated byte-string</p>
<p class="titleinrefsubsect"><a id="sthref1054"></a>Usage notes</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">to_set</span></code> is shorter than <code><span class="codeinlineitalic">from_set</span></code>, the extra <code><span class="codeinlineitalic">from_set</span></code> bytes have no corresponding translation bytes. Bytes from the input <code>RAW</code> value that match any such <code><span class="codeinlineitalic">from_set</span></code> bytes are not translated or included in the result. They are effectively translated to <code>NULL</code>.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">to_set</span></code> is longer than <code><span class="codeinlineitalic">from_set</span></code>, the extra <code><span class="codeinlineitalic">to_set</span></code> bytes are ignored.</p>
</li>
<li>
<p>If a byte value is repeated in <code><span class="codeinlineitalic">from_set</span></code>, the repeated occurrence is ignored.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Differences from <code>TRANSLITERATE</code>:
<ul>
<li>
<p>The <code><span class="codeinlineitalic">from_set</span></code> parameter comes before the <code><span class="codeinlineitalic">to_set</span></code> parameter in the calling sequence.</p>
</li>
<li>
<p>Bytes from the source byte-string that appear in <code><span class="codeinlineitalic">from_set</span></code> but have no corresponding values in <code><span class="codeinlineitalic">to_set</span></code> are not translated or included in the result.</p>
</li>
<li>
<p>The resulting <code>RAW</code> value may be shorter than the input <code>RAW</code> value.</p>
</li>
</ul>
<p>Note that <code>TRANSLATE</code> and <code>TRANSLITERATE</code> only differ in functionality when <code><span class="codeinlineitalic">to_set</span></code> has fewer bytes than <code><span class="codeinlineitalic">from_set</span></code>.</p>
</div>
<p class="titleinrefsubsect"><a id="sthref1055"></a>Exceptions</p>
<p><code>VALUE_ERROR</code> occurs if the source byte string, <code><span class="codeinlineitalic">from_set</span></code>, or <code><span class="codeinlineitalic">to_set</span></code> is <code>NULL</code> or zero-length.</p>
<p class="titleinrefsubsect"><a id="CEGIGHCG"></a>Examples</p>
<p><span class="bold">Example 1:</span> In this example, run in <code>ttIsql</code>, <code>from_set</code> is <code>x&#39;12AA34&#39;</code> and <code>to_set</code> is <code>x&#39;CD&#39;</code>. Wherever <code>&#39;12&#39;</code> appears in the input <code>RAW</code> value it is replaced by <code>&#39;CD&#39;</code> in the result. Wherever <code>&#39;AA&#39;</code> or <code>&#39;34&#39;</code> appears in the input <code>RAW</code> value, because there are no corresponding bytes in <code><span class="codeinlineitalic">to_set</span></code>, those bytes are not included in the result (effectively translated to <code>NULL</code>).</p>
<p>You can compare this to <a href="#CEGEEHFE">&#34;Examples&#34;</a> in the <code>TRANSLITERATE</code> section to see how the functions differ.</p>
<pre>declare
  sr raw(32767);     
  from_set raw(32767);
  to_set raw(32767); 
  r raw(32767);
begin
  sr       := hextoraw(&#39;1236567812125612344434341234567890ABAA1234&#39;);
  from_set := hextoraw(&#39;12AA34&#39;);
  to_set   := hextoraw(&#39;CD&#39;);
  dbms_output.put_line(&#39;from_set:   &#39; || from_set);
  dbms_output.put_line(&#39;to_set:     &#39; || to_set);
  r := UTL_RAW.TRANSLATE(sr, from_set, to_set);
  dbms_output.put_line(&#39;source raw: &#39; || sr);
  dbms_output.put_line(&#39;return raw: &#39; || r);
end;
/
</pre>
<p>The result is as follows:</p>
<pre>from_set:   12AA34
to_set:     CD
source raw: 1236567812125612344434341234567890ABAA1234
return raw: CD365678CDCD56CD44CD567890ABCD

PL/SQL procedure successfully completed.
</pre>
<p>The inputs and output are presented in the following, for purposes of this discussion, in a way that gives a clearer indication of the functionality.</p>
<pre>from_set:   12  AA 34
to_set:     CD
source raw: 12 365678 12 12 56 12 34 44 34 34 12 34 567890AB AA 12 34
return raw: CD 365678 CD CD 56 CD    44       CD    567890AB    CD
</pre>
<p><span class="bold">Example 2:</span> In this example, run in <code>ttIsql</code>, the <code><span class="codeinlineitalic">from_set</span></code> is <code>x&#39;12AA12&#39;</code> and the <code><span class="codeinlineitalic">to_set</span></code> is <code>x&#39;CDABEF&#39;</code>. Wherever <code>&#39;12&#39;</code> appears in the input RAW it is replaced by <code>&#39;CD&#39;</code> in the result. Wherever <code>&#39;AA&#39;</code> appears in the input it is replaced by <code>&#39;AB&#39;</code> in the result. The second <code>&#39;12&#39;</code> in <code><span class="codeinlineitalic">from_set</span></code> is ignored, and therefore the corresponding byte in <code><span class="codeinlineitalic">to_set</span></code> is ignored as well.</p>
<pre>declare
  sr raw(32767);     
  from_set raw(32767);
  to_set raw(32767); 
  r raw(32767);
begin
  sr       := hextoraw(&#39;1236567812125612344434341234567890ABAA1234&#39;);
  from_set := hextoraw(&#39;12AA12&#39;);
  to_set   := hextoraw(&#39;CDABEF&#39;);
  dbms_output.put_line(&#39;from_set:   &#39; || from_set);
  dbms_output.put_line(&#39;to_set:     &#39; || to_set);
  r := UTL_RAW.TRANSLATE(sr, from_set, to_set);
  dbms_output.put_line(&#39;source raw: &#39; || sr);
  dbms_output.put_line(&#39;return raw: &#39; || r);
end;
/
</pre>
<p>The result is as follows. Note this is the same behavior as for <code>TRANSLITERATE</code> with the same input <code>RAW</code>, <code><span class="codeinlineitalic">from_set</span></code>, and <code><span class="codeinlineitalic">to_set</span></code>, as shown in <a href="#CEGEEHFE">&#34;Examples&#34;</a> in the <code>TRANSLITERATE</code> section.</p>
<pre>from_set:   12AA12
to_set:     CDABEF
source raw: 1236567812125612344434341234567890ABAA1234
return raw: CD365678CDCD56CD34443434CD34567890ABABCD34
 
PL/SQL procedure successfully completed.
</pre>
<a id="i997416"></a><a id="TTPLP71542"></a>
<hr/>
<h3 class="refsect2"><a id="sthref1056"></a>TRANSLITERATE function</h3>
<p>This function performs a byte-by-byte transliteration of a <code>RAW</code> value, given an input set of bytes, a set of bytes to search for and convert from in the input bytes, and a set of corresponding bytes to convert to. Whenever a byte in the specified <code><span class="codeinlineitalic">from_set</span></code> is found in the input <code>RAW</code> value, it is converted to the corresponding byte in the <code><span class="codeinlineitalic">to_set</span></code> for the output <code>RAW</code> value, or it is converted to the specified &#34;padding&#34; byte if there is no corresponding byte in <code><span class="codeinlineitalic">to_set</span></code>. Any bytes in the input <code>RAW</code> value that do not appear in <code><span class="codeinlineitalic">from_set</span></code> are copied as-is to the output <code>RAW</code> value.</p>
<p class="titleinrefsubsect"><a id="sthref1057"></a>Syntax</p>
<pre>UTL_RAW.TRANSLITERATE (
   <span class="italic">r</span>        IN RAW,
   <span class="italic">to_set</span>   IN RAW DEFAULT NULL,
   <span class="italic">from_set</span> IN RAW DEFAULT NULL,
   <span class="italic">pad</span>      IN RAW DEFAULT NULL)
  RETURN RAW;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Be aware that <code><span class="codeinlineitalic">to_set</span></code> and <code><span class="codeinlineitalic">from_set</span></code> are reversed in the calling sequence compared to <code>TRANSLATE</code>.</div>
<p class="titleinrefsubsect"><a id="sthref1058"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71543"></a><a id="sthref1059"></a><a id="sthref1060"></a>Table 13-25 TRANSLITERATE function parameters</p>
<table class="cellalignment1016" title="TRANSLITERATE function parameters " summary="This table describes the Parameters of the UTL_RAW.TRANSLITERATE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t36">Parameter</th>
<th class="cellalignment1017" id="r1c2-t36">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t36" headers="r1c1-t36">
<p><code><span class="codeinlineitalic">r</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t36 r1c2-t36">
<p><code>RAW</code> source byte-string whose bytes are to be converted, as applicable</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t36" headers="r1c1-t36">
<p><code><span class="codeinlineitalic">to_set</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t36 r1c2-t36">
<p><code>RAW</code> byte-codes to convert to</p>
<p>Where a <code><span class="codeinlineitalic">from_set</span></code> byte is found in the source byte-string, it is converted in the result to the corresponding <code><span class="codeinlineitalic">to_set</span></code> byte, as applicable. This defaults to a <code>NULL</code> string effectively extended with <code><span class="codeinlineitalic">pad</span></code> to the length of <code><span class="codeinlineitalic">from_set</span></code>, as necessary.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r4c1-t36" headers="r1c1-t36">
<p><code><span class="codeinlineitalic">from_set</span></code></p>
</td>
<td class="cellalignment1018" headers="r4c1-t36 r1c2-t36">
<p><code>RAW</code> byte-codes that are searched for in the source byte-string</p>
<p>Where found, they are converted in the result. The default is <code>x&#39;00&#39;</code> through <code>x&#39;FF&#39;</code>, which results in all bytes in the source byte string being converted in the result.</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r5c1-t36" headers="r1c1-t36">
<p><code><span class="codeinlineitalic">pad</span></code></p>
</td>
<td class="cellalignment1018" headers="r5c1-t36 r1c2-t36">
<p>A &#34;padding&#34; byte used as the conversion value for any byte in the source byte-string for which there is a matching byte in <code><span class="codeinlineitalic">from_set</span></code> that does not have a corresponding byte in <code><span class="codeinlineitalic">to_set</span></code> (default <code>x&#39;00&#39;</code>)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref1061"></a>Return value</p>
<p><code>RAW</code> value with the converted byte-string</p>
<p class="titleinrefsubsect"><a id="sthref1062"></a>Usage notes</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">to_set</span></code> is shorter than <code><span class="codeinlineitalic">from_set</span></code>, the extra <code><span class="codeinlineitalic">from_set</span></code> bytes have no corresponding conversion bytes. Bytes from the input <code>RAW</code> value that match any such <code><span class="codeinlineitalic">from_set</span></code> bytes are converted in the result to the <code><span class="codeinlineitalic">pad</span></code> byte instead.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">to_set</span></code> is longer than <code><span class="codeinlineitalic">from_set</span></code>, the extra <code><span class="codeinlineitalic">to_set</span></code> bytes are ignored.</p>
</li>
<li>
<p>If a byte value is repeated in <code><span class="codeinlineitalic">from_set</span></code>, the repeated occurrence is ignored.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Differences from <code>TRANSLATE</code>:
<ul>
<li>
<p>The <code><span class="codeinlineitalic">to_set</span></code> parameter comes before the <code><span class="codeinlineitalic">from_set</span></code> parameter in the calling sequence.</p>
</li>
<li>
<p>Bytes from the source byte-string that appear in <code><span class="codeinlineitalic">from_set</span></code> but have no corresponding values in <code><span class="codeinlineitalic">to_set</span></code> are replaced by <code><span class="codeinlineitalic">pad</span></code> in the result.</p>
</li>
<li>
<p>The resulting <code>RAW</code> value always has the same length as the input <code>RAW</code> value.</p>
</li>
</ul>
<p>Note that <code>TRANSLATE</code> and <code>TRANSLITERATE</code> only differ in functionality when <code><span class="codeinlineitalic">to_set</span></code> has fewer bytes than <code><span class="codeinlineitalic">from_set</span></code>.</p>
</div>
<p class="titleinrefsubsect"><a id="sthref1063"></a>Exceptions</p>
<p><code>VALUE_ERROR</code> occurs if the source byte-string is <code>NULL</code> or zero-length.</p>
<p class="titleinrefsubsect"><a id="CEGEEHFE"></a>Examples</p>
<p><span class="bold">Example 1:</span> In this example, run in <code>ttIsql</code>, the <code><span class="codeinlineitalic">from_set</span></code> is <code>x&#39;12AA34&#39;</code> and the <code><span class="codeinlineitalic">to_set</span></code> is <code>x&#39;CD&#39;</code>. Wherever <code>&#39;12&#39;</code> appears in the input <code>RAW</code> value it is replaced by <code>&#39;CD&#39;</code> in the result. Wherever <code>&#39;AA&#39;</code> or <code>&#39;34&#39;</code> appears in the input <code>RAW</code> value, because there are no corresponding bytes in <code><span class="codeinlineitalic">to_set</span></code>, those bytes are replaced by the <code><span class="codeinlineitalic">pad</span></code> byte, which is not specified and therefore defaults to <code>x&#39;00&#39;</code>.</p>
<p>You can compare this to <a href="#CEGIGHCG">&#34;Examples&#34;</a> in the <code>TRANSLATE</code> section to see how the functions differ.</p>
<pre>declare
  sr raw(32767);
  from_set raw(32767);
  to_set raw(32767); 
  r raw(32767);
begin
  sr       := hextoraw(&#39;1236567812125612344434341234567890ABAA1234&#39;);
  from_set := hextoraw(&#39;12AA34&#39;);
  to_set   := hextoraw(&#39;CD&#39;);
  dbms_output.put_line(&#39;from_set:   &#39; || from_set);
  dbms_output.put_line(&#39;to_set:     &#39; || to_set);
  r := UTL_RAW.TRANSLITERATE(sr, to_set, from_set);
  dbms_output.put_line(&#39;source raw: &#39; || sr);
  dbms_output.put_line(&#39;return raw: &#39; || r);
end;
/
</pre>
<p>The result is as follows.</p>
<pre>from_set:   12AA34
to_set:     CD
source raw: 1236567812125612344434341234567890ABAA1234
return raw: CD365678CDCD56CD00440000CD00567890AB00CD00
 
PL/SQL procedure successfully completed.
</pre>
<p>The inputs and output are presented in the following, for purposes of this discussion, in a way that gives a clearer indication of the functionality.</p>
<pre>from_set:   12  AA 34
to_set:     CD
source raw: 12 365678 12 12 56 12 34 44 34 34 12 34 567890AB AA 12 34
return raw: CD 365678 CD CD 56 CD 00 44 00 00 CD 00 567890AB 00 CD 00
</pre>
<p><span class="bold">Example 2:</span> This example, run in <code>ttIsql</code>, is the same as the preceding example, except <code><span class="codeinlineitalic">pad</span></code> is specified to be <code>x&#39;FF&#39;</code>.</p>
<pre>declare
  sr raw(32767);     
  from_set raw(32767);
  to_set raw(32767); 
  pad raw(32767);
  r raw(32767);
begin
  sr       := hextoraw(&#39;1236567812125612344434341234567890ABAA1234&#39;);
  from_set := hextoraw(&#39;12AA34&#39;);
  to_set   := hextoraw(&#39;CD&#39;);
  pad      := hextoraw(&#39;FF&#39;);
  dbms_output.put_line(&#39;from_set:   &#39; || from_set);
  dbms_output.put_line(&#39;to_set:     &#39; || to_set);
  r := UTL_RAW.TRANSLITERATE(sr, to_set, from_set, pad);
  dbms_output.put_line(&#39;source raw: &#39; || sr);
  dbms_output.put_line(&#39;return raw: &#39; || r);
end;
/
</pre>
<p>The result is as follows. <code>&#39;AA&#39;</code> and <code>&#39;34&#39;</code> are replaced by <code>&#39;FF&#39;</code> instead of <code>&#39;00&#39;</code>.</p>
<pre>from_set:   12AA34
to_set:     CD
source raw: 1236567812125612344434341234567890ABAA1234
return raw: CD365678CDCD56CDFF44FFFFCDFF567890ABFFCDFF
 
PL/SQL procedure successfully completed.
</pre>
<p><span class="bold">Example 3:</span> In this example, run in <code>ttIsql</code>, the <code><span class="codeinlineitalic">from_set</span></code> is <code>x&#39;12AA12&#39;</code> and the <code><span class="codeinlineitalic">to_set</span></code> is <code>x&#39;CDABEF&#39;</code>. Wherever <code>&#39;12&#39;</code> appears in the input <code>RAW</code> value it is replaced by <code>&#39;CD&#39;</code> in the result. Wherever <code>&#39;AA&#39;</code> appears in the input it is replaced by <code>&#39;AB&#39;</code> in the result. The second <code>&#39;12&#39;</code> in <code><span class="codeinlineitalic">from_set</span></code> is ignored, and therefore the corresponding byte in <code><span class="codeinlineitalic">to_set</span></code> is ignored as well.</p>
<pre>declare
  sr raw(32767);     
  from_set raw(32767);
  to_set raw(32767); 
  r raw(32767);
begin
  sr       := hextoraw(&#39;1236567812125612344434341234567890ABAA1234&#39;);
  from_set := hextoraw(&#39;12AA12&#39;);
  to_set   := hextoraw(&#39;CDABEF&#39;);
  dbms_output.put_line(&#39;from_set:   &#39; || from_set);
  dbms_output.put_line(&#39;to_set:     &#39; || to_set);
  r := UTL_RAW.TRANSLITERATE(sr, to_set, from_set);
  dbms_output.put_line(&#39;source raw: &#39; || sr);
  dbms_output.put_line(&#39;return raw: &#39; || r);
end;
/
</pre>
<p>The result is as follows. Note this is the same behavior as for <code>TRANSLATE</code> with the same input <code>RAW</code>, <code><span class="codeinlineitalic">from_set</span></code>, and <code><span class="codeinlineitalic">to_set</span></code>, as shown in <a href="#CEGIGHCG">&#34;Examples&#34;</a> in the <code>TRANSLATE</code> section.</p>
<pre>from_set:   12AA12
to_set:     CDABEF
source raw: 1236567812125612344434341234567890ABAA1234
return raw: CD365678CDCD56CD34443434CD34567890ABABCD34
 
PL/SQL procedure successfully completed.
</pre>
<p><span class="bold">Example 4:</span> In this example, run in <code>ttIsql</code>, <code><span class="codeinlineitalic">from_set</span></code> and <code><span class="codeinlineitalic">to_set</span></code> are not specified.</p>
<pre>declare
  sr raw(32767);
  r raw(32767);
begin
  sr       := hextoraw(&#39;1236567812125612344434341234567890ABAA1234&#39;);
  r := UTL_RAW.TRANSLITERATE(sr);
  dbms_output.put_line(&#39;source raw: &#39; || sr);
  dbms_output.put_line(&#39;return raw: &#39; || r);
end;
/
</pre>
<p>The result is as follows. According to the <code><span class="codeinlineitalic">from_set</span></code> and <code><span class="codeinlineitalic">to_set</span></code> defaults, all bytes are replaced by <code>x&#39;00&#39;</code>.</p>
<pre>source raw: 1236567812125612344434341234567890ABAA1234
return raw: 000000000000000000000000000000000000000000
 
PL/SQL procedure successfully completed.
</pre>
<a id="BABGDIIJ"></a><a id="TTPLP71547"></a>
<hr/>
<h3 class="refsect2"><a id="sthref1064"></a>XRANGE function</h3>
<p>This function returns a <code>RAW</code> value containing the succession of one-byte encodings beginning and ending with the specified byte-codes. The specified byte-codes must be single-byte <code>RAW</code> values. If the <code><span class="codeinlineitalic">start_byte</span></code> value is greater than the <code><span class="codeinlineitalic">end_byte</span></code> value, the succession of resulting bytes begins with <code><span class="codeinlineitalic">start_byte</span></code>, wraps through <code>x&#39;FF&#39;</code> back to <code>x&#39;00&#39;</code>, then ends at <code><span class="codeinlineitalic">end_byte</span></code>.</p>
<p class="titleinrefsubsect"><a id="sthref1065"></a>Syntax</p>
<pre>UTL_RAW.XRANGE (
   <span class="italic">start_byte</span> IN RAW DEFAULT NULL,
   <span class="italic">end_byte</span>   IN RAW DEFAULT NULL) 
  RETURN RAW;
</pre>
<p class="titleinrefsubsect"><a id="sthref1066"></a>Parameters</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="TTPLP71548"></a><a id="sthref1067"></a><a id="sthref1068"></a>Table 13-26 XRANGE function parameters</p>
<table class="cellalignment1016" title="XRANGE function parameters " summary="This table describes the Parameters of the UTL_RAW.XCHANGE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1010">
<th class="cellalignment1017" id="r1c1-t38">Parameters</th>
<th class="cellalignment1017" id="r1c2-t38">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r2c1-t38" headers="r1c1-t38">
<p><code><span class="codeinlineitalic">start_byte</span></code></p>
</td>
<td class="cellalignment1018" headers="r2c1-t38 r1c2-t38">
<p>Beginning byte-code value for resulting sequence (default <code>x&#39;00&#39;</code>)</p>
</td>
</tr>
<tr class="cellalignment1010">
<td class="cellalignment1018" id="r3c1-t38" headers="r1c1-t38">
<p><code><span class="codeinlineitalic">end_byte</span></code></p>
</td>
<td class="cellalignment1018" headers="r3c1-t38 r1c2-t38">
<p>Ending byte-code value for resulting sequence (default <code>x&#39;FF&#39;</code>)</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p class="titleinrefsubsect"><a id="sthref1069"></a>Return value</p>
<p><code>RAW</code> value containing the succession of one-byte encodings</p>
<p class="titleinrefsubsect"><a id="sthref1070"></a>Examples</p>
<p>The following three examples, run in <code>ttIsql</code>, show the results where <code><span class="codeinlineitalic">start_byte</span></code> is less than <code><span class="codeinlineitalic">end_byte</span></code>, <code><span class="codeinlineitalic">start_byte</span></code> is greater than <code><span class="codeinlineitalic">end_byte</span></code>, and default values are used.</p>
<pre>Command&gt; declare
       &gt;    r raw(32767);
       &gt;    s raw(32767);
       &gt;    e raw(32767);
       &gt; begin
       &gt;    s := hextoraw(&#39;1&#39;);
       &gt;    e := hextoraw(&#39;A&#39;);
       &gt;    r := utl_raw.xrange(s,e);
       &gt;    dbms_output.put_line(r);
       &gt; end;
       &gt; /
0102030405060708090A
 
PL/SQL procedure successfully completed.
 
Command&gt; declare
       &gt;    r raw(32767);
       &gt;    s raw(32767);
       &gt;    e raw(32767);
       &gt; begin
       &gt;    s := hextoraw(&#39;EE&#39;);
       &gt;    e := hextoraw(&#39;A&#39;);
       &gt;    r := utl_raw.xrange(s,e);
       &gt;    dbms_output.put_line(r);
       &gt; end;
       &gt; /
EEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF000102030405060708090A
 
PL/SQL procedure successfully completed.
 
Command&gt; declare
       &gt;    r raw(32767);
       &gt; begin
       &gt;    r := utl_raw.xrange();
       &gt;    dbms_output.put_line(r);
       &gt; end;
       &gt; /
000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F2021222324252627
28292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F
505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F7071727374757677
78797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9F
A0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7
C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF
F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="refsect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1009">
<tr>
<td class="cellalignment1018">
<table class="cellalignment1014">
<tr>
<td class="cellalignment1013"><a href="u_ident.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1013"><a href="u_recomp.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1020">
<table class="cellalignment1012">
<tr>
<td class="cellalignment1013"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1013"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1013"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1013"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1013"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1013"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>