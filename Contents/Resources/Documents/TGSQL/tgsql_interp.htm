<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-106783"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Reading%20Execution%20Plans"></a><title>Reading Execution Plans</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="automatic reoptimization, reoptimization, automatic, optimizer, adaptive, adaptive query plans, execution plans, adaptive query optimization, range, examples of partitions, hash partitions, examples of, partitioning, composite partitioning, examples of composite, joins, partition-wise, examples of partial, EXPLAIN PLAN statement, and partial partition-wise joins, partition-wise joins, partial, and EXPLAIN PLAN output, full, and EXPLAIN PLAN output, full, full partition-wise joins, and full partition-wise joins, examples of full, OTHER column, PLAN_TABLE table, DISTRIBUTION column, PARTITION_ID column, PARTITION_START column, OTHER_TAG column, BYTES column, PARTITION_STOP column, CARDINALITY column, COST column, POSITION column, PARENT_ID column, ID column, SEARCH_COLUMNS column, OPTIMIZER column, PLAN_TABLE, OBJECT_TYPE column, OBJECT_INSTANCE column, OBJECT_NAME column, OBJECT_OWNER column, OBJECT_NODE column, OPERATION column, STATEMENT_ID column, TIMESTAMP column, REMARKS column, OPTIONS column, V$ views, DBMS_XPLAN"/>
<meta name="dcterms.created" content="2017-07-24T09:35:46Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database SQL Tuning Guide"/>
<meta name="dcterms.identifier" content="E49106-14"/>
<meta name="dcterms.isVersionOf" content="TGSQL"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2013, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="tgsql_genplan.htm" title="Previous" type="text/html"/>
<link rel="Next" href="tgsql_pt_ops.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E49106-14.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-725CADF8-3803-416F-96EB-BF942F742663"></a> <span id="PAGE" style="display:none;">14/40</span> <!-- End Header -->
<a id="TGSQL94618"></a>
<h1 id="TGSQL-GUID-725CADF8-3803-416F-96EB-BF942F742663" class="sect1"><span class="enumeration_chapter">7</span> Reading Execution Plans</h1>
<div>
<p>This chapter contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="tgsql_interp.htm#GUID-1FA56307-047B-42BB-AF17-3B05F1814559">Reading Execution Plans: Basic</a></p>
</li>
<li>
<p><a href="tgsql_interp.htm#GUID-4B80D575-3DBC-49CD-932E-5DD95F80201B">Reading Execution Plans: Advanced</a></p>
</li>
<li>
<p><a href="tgsql_interp.htm#GUID-7957B335-D36A-42BF-96BB-FF47FFBA4DFD" title="The following dynamic performance and data dictionary views provide information on execution plans.The PLAN_TABLE is used by the EXPLAIN PLAN statement.The functions DISPLAY_PLAN and DISPLAY_CURSOR in DBMS_XPLAN are relevant for accessing adapted plans.">Execution Plan Reference</a></p>
</li>
</ul>
</div>
<a id="TGSQL94710"></a><a id="TGSQL94711"></a><a id="TGSQL94712"></a><a id="TGSQL277"></a>
<div class="props_rev_3"><a id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559"></a>
<h2 id="TGSQL-GUID-1FA56307-047B-42BB-AF17-3B05F1814559" class="sect2">Reading Execution Plans: Basic</h2>
<div>
<div class="section">
<p>This section uses <code class="codeph">EXPLAIN PLAN</code> examples to illustrate execution plans. The following query displays the execution plans:</p>
<pre dir="ltr">SELECT PLAN_TABLE_OUTPUT 
  FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, &#39;<span class="italic">statement_id</span>&#39;,&#39;BASIC&#39;));
</pre>
<p>Examples of the output from this statement are shown in <a href="tgsql_interp.htm#GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063__CEGFDIHJ">Example 7-4</a> and <a href="tgsql_interp.htm#GUID-1FA56307-047B-42BB-AF17-3B05F1814559__CEGCJACH">Example 7-1</a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__CEGCJACH">
<p class="titleinexample">Example 7-1 EXPLAIN PLAN for Statement ID ex_plan1</p>
<p>The following plan shows execution of a <code class="codeph">SELECT</code> statement. The table <code class="codeph">employees</code> is accessed using a full table scan. Every row in the table <code class="codeph">employees</code> is accessed, and the <code class="codeph">WHERE</code> clause criteria is evaluated for every row.</p>
<pre dir="ltr">EXPLAIN PLAN 
  SET statement_id = &#39;ex_plan1&#39; FOR
  SELECT phone_number 
  FROM   employees
  WHERE  phone_number LIKE &#39;650%&#39;;

---------------------------------------
| Id  | Operation         | Name      |
---------------------------------------
|   0 | SELECT STATEMENT  |           |
|   1 |  TABLE ACCESS FULL| EMPLOYEES |
---------------------------------------
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__GUID-2E0342FE-ABA2-48D0-9E12-20AD0A8A7CE4">
<p class="titleinexample">Example 7-2 EXPLAIN PLAN for Statement ID ex_plan2</p>
<p>This following plan shows the execution of a <code class="codeph">SELECT</code> statement. In this example, the database range scans the <code class="codeph">EMP_NAME_IX</code> index to evaluate the <code class="codeph">WHERE</code> clause criteria.</p>
<pre dir="ltr">EXPLAIN PLAN 
  SET statement_id = &#39;ex_plan2&#39; FOR
  SELECT last_name 
  FROM   employees
  WHERE  last_name LIKE &#39;Pe%&#39;;

SELECT PLAN_TABLE_OUTPUT 
  FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, &#39;ex_plan2&#39;,&#39;BASIC&#39;));

----------------------------------------
| Id  | Operation        | Name        |
----------------------------------------
|   0 | SELECT STATEMENT |             |
|   1 |  INDEX RANGE SCAN| EMP_NAME_IX |
----------------------------------------
</pre></div>
<!-- class="example" --></div>
</div>
<a id="TGSQL279"></a>
<div class="props_rev_3"><a id="GUID-4B80D575-3DBC-49CD-932E-5DD95F80201B"></a>
<h2 id="TGSQL-GUID-4B80D575-3DBC-49CD-932E-5DD95F80201B" class="sect2">Reading Execution Plans: Advanced</h2>
<div>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="tgsql_interp.htm#GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB" title="The adaptive optimizer is a feature of the optimizer that enables it to adapt plans based on run-time statistics. All adaptive mechanisms can execute a final plan for a statement that differs from the default plan.">Reading Adaptive Query Plans</a></p>
</li>
<li>
<p><a href="tgsql_interp.htm#GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" title="Plans for parallel queries differ in important ways from plans for serial queries.">Viewing Parallel Execution with EXPLAIN PLAN</a></p>
</li>
<li>
<p><a href="tgsql_interp.htm#GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063">Viewing Bitmap Indexes with EXPLAIN PLAN</a></p>
</li>
<li>
<p><a href="tgsql_interp.htm#GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F">Viewing Result Cache with EXPLAIN PLAN</a></p>
</li>
<li>
<p><a href="tgsql_interp.htm#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="To illustrate how Oracle Database displays pruning information for composite partitioned objects, consider the table emp_comp. It is range-partitioned on hiredate and subpartitioned by hash on deptno.">Viewing Partitioned Objects with EXPLAIN PLAN</a></p>
</li>
<li>
<p><a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C" title="The PLAN_TABLE used by the EXPLAIN PLAN statement contains the columns listed in this topic.">PLAN_TABLE Columns</a></p>
</li>
</ul>
</div>
<a id="TGSQL94855"></a><a id="TGSQL94856"></a><a id="TGSQL94857"></a><a id="TGSQL94854"></a>
<div class="props_rev_3"><a id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB"></a>
<h3 id="TGSQL-GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB" class="sect3">Reading Adaptive Query Plans</h3>
<div>
<p>The <span class="bold">adaptive optimizer</span> is a feature of the optimizer that enables it to adapt plans based on run-time statistics. All adaptive mechanisms can execute a final plan for a statement that differs from the default plan.</p>
<div class="section">
<p>An <a href="glossary.htm#GUID-5E4FD63A-4143-48FF-B8ED-9D953B8A6D40"><span class="xrefglossterm">adaptive query plan</span></a> chooses among subplans <span class="italic">during</span> the current statement execution. In contrast, <a href="glossary.htm#GUID-70FBCF66-F29E-4ADE-BEA8-F328917A2986"><span class="xrefglossterm">automatic reoptimization</span></a> changes a plan only on executions that occur <span class="italic">after</span> the current statement execution.</p>
<p>You can determine whether the database used adaptive query optimization for a SQL statement based on the comments in the <code class="codeph">Notes</code> section of plan. The comments indicate whether row sources are dynamic, or whether automatic reoptimization adapted a plan.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Assumptions</p>
</div>
<!-- class="section" -->
<div class="section">
<p>This tutorial assumes the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>The <code class="codeph">STATISTICS_LEVEL</code> initialization parameter is set to <code class="codeph">ALL</code>.</p>
</li>
<li>
<p>The database uses the default settings for adaptive execution.</p>
</li>
<li>
<p>As user <code class="codeph">oe</code>, you want to issue the following separate queries:</p>
<pre dir="ltr">SELECT o.order_id, v.product_name
FROM   orders o,
       (  SELECT order_id, product_name
          FROM   order_items o, product_information p
          WHERE  p.product_id = o.product_id
          AND    list_price &lt; 50
          AND    min_price &lt; 40  ) v
WHERE  o.order_id = v.order_id

SELECT product_name
FROM   order_items o, product_information p  
WHERE  o.unit_price = 15 
AND    quantity &gt; 1
AND    p.product_id = o.product_id
</pre></li>
<li>
<p>Before executing each query, you want to query <code class="codeph">DBMS_XPLAN.DISPLAY_PLAN</code> to see the default plan, that is, the plan that the optimizer chose before applying its adaptive mechanism.</p>
</li>
<li>
<p>After executing each query, you want to query <code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code> to see the final plan and adaptive query plan.</p>
</li>
<li>
<p><code class="codeph">SYS</code> has granted <code class="codeph">oe</code> the following privileges:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">GRANT SELECT ON V_$SESSION TO oe</code></p>
</li>
<li>
<p><code class="codeph">GRANT SELECT ON V_$SQL TO oe</code></p>
</li>
<li>
<p><code class="codeph">GRANT SELECT ON V_$SQL_PLAN TO oe</code></p>
</li>
<li>
<p><code class="codeph">GRANT SELECT ON V_$SQL_PLAN_STATISTICS_ALL TO oe</code></p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">To see the results of adaptive optimization:</p>
<ol>
<li>
<p>Start SQL*Plus, and then connect to the database as user <code class="codeph">oe</code>.</p>
</li>
<li id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__CEGEDCCC">
<p>Query <code class="codeph">orders</code>.</p>
<p>For example, use the following statement:</p>
<pre dir="ltr">SELECT o.order_id, v.product_name
FROM   orders o,
       (  SELECT order_id, product_name
          FROM   order_items o, product_information p
          WHERE  p.product_id = o.product_id
          AND    list_price &lt; 50
          AND    min_price &lt; 40  ) v
WHERE  o.order_id = v.order_id;
</pre></li>
<li id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__CEGCEJFA">
<p>View the plan in the cursor.</p>
<p>For example, run the following commands:</p>
<pre dir="ltr">SET LINESIZE 165
SET PAGESIZE 0
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(FORMAT=&gt;&#39;+ALLSTATS&#39;));
</pre>
<p>The following sample output has been reformatted to fit on the page. In this plan, the optimizer chooses a nested loops join. The original optimizer estimates are shown in the <code class="codeph">E-Rows</code> column, whereas the actual statistics gathered during execution are shown in the <code class="codeph">A-Rows</code> column. In the <code class="codeph">MERGE JOIN</code> operation, the difference between the estimated and actual number of rows is significant.</p>
<pre dir="ltr">--------------------------------------------------------------------------------------------
|Id| Operation             | Name          |Start<span class="bold">|E-Rows|A-Rows|</span>A-Time|Buff|OMem|1Mem|O/1/M|
--------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT      |                |   1|   | 269|00:00:00.09|1338|    |    |     |
| 1|  <span class="bold">NESTED LOOPS</span>         |                |   1|  1| 269|00:00:00.09|1338|    |    |     |
| 2|   MERGE JOIN CARTESIAN|                |   1|  4|9135|00:00:00.03|  33|    |    |     |
|*3|    TABLE ACCESS FULL  |PRODUCT_INFORMAT|   1|  1|  87|00:00:00.01|  32|    |    |     |
| 4|    BUFFER SORT        |                |  87|105|9135|00:00:00.01|   1|4096|4096|1/0/0|
| 5|     INDEX FULL SCAN   | ORDER_PK       |   1|105| 105|00:00:00.01|   1|    |    |     |
|*6|   INDEX UNIQUE SCAN   | ORDER_ITEMS_UK |9135|  1| 269|00:00:00.03|1305|    |    |     |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - filter((&#34;MIN_PRICE&#34;&lt;40 AND &#34;LIST_PRICE&#34;&lt;50))
   6 - access(&#34;O&#34;.&#34;ORDER_ID&#34;=&#34;ORDER_ID&#34; AND &#34;P&#34;.&#34;PRODUCT_ID&#34;=&#34;O&#34;.&#34;PRODUCT_ID&#34;)
</pre></li>
<li>
<p>Run the same query of <code class="codeph">orders</code> that you ran in Step 2.</p>
</li>
<li>
<p>View the execution plan in the cursor by using the same <code class="codeph">SELECT</code> statement that you ran in Step 3.</p>
<p>The following example shows that the optimizer has chosen a different plan, using a hash join. The Note section shows that the optimizer used statistics feedback to adjust its cost estimates for the second execution of the query, thus illustrating automatic reoptimization.</p>
<pre dir="ltr">--------------------------------------------------------------------------------------------
|Id| Operation              |Name    |Start|E-Rows|A-Rows|A-Time|Buff|Reads|OMem|1Mem|O/1/M|
--------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT       |               | 1 |   |269|00:00:00.02|60|1|     |     |     |
| 1|  NESTED LOOPS          |               | 1 |269|269|00:00:00.02|60|1|     |     |     |
|*2|   <span class="bold">HASH JOIN</span>            |               | 1 |313|269|00:00:00.02|39|1|1000K|1000K|1/0/0|
|*3|    TABLE ACCESS FULL   |PRODUCT_INFORMA| 1 | 87| 87|00:00:00.01|15|0|     |     |     |
| 4|    INDEX FAST FULL SCAN|ORDER_ITEMS_UK | 1 |665|665|00:00:00.01|24|1|     |     |     |
|*5|   INDEX UNIQUE SCAN    |ORDER_PK       |269|  1|269|00:00:00.01|21|0|     |     |     |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access(&#34;P&#34;.&#34;PRODUCT_ID&#34;=&#34;O&#34;.&#34;PRODUCT_ID&#34;)
   3 - filter((&#34;MIN_PRICE&#34;&lt;40 AND &#34;LIST_PRICE&#34;&lt;50))
   5 - access(&#34;O&#34;.&#34;ORDER_ID&#34;=&#34;ORDER_ID&#34;)
 
Note
-----
   - <span class="bold">statistics feedback used for this statement</span>
</pre></li>
<li>
<p>Query <code class="codeph">V$SQL</code> to verify the performance improvement.</p>
<p>The following query shows the performance of the two statements (sample output included).</p>
<pre dir="ltr">SELECT CHILD_NUMBER, CPU_TIME, ELAPSED_TIME, BUFFER_GETS
FROM   V$SQL
WHERE  SQL_ID = &#39;gm2npz344xqn8&#39;;
 
CHILD_NUMBER   CPU_TIME ELAPSED_TIME BUFFER_GETS
------------ ---------- ------------ -----------
           0      92006       131485        1831
           1      12000        24156          60
</pre>
<p>The second statement executed, which is child number <code class="codeph">1</code>, used statistics feedback. CPU time, elapsed time, and buffer gets are all significantly lower.</p>
</li>
<li>
<p>Explain the plan for the query of <code class="codeph">order_items</code>.</p>
<p>For example, use the following statement:</p>
<pre dir="ltr">EXPLAIN PLAN FOR
  SELECT product_name 
  FROM   order_items o, product_information p  
  WHERE  o.unit_price = 15
  AND    quantity &gt; 1  
  AND    p.product_id = o.product_id
</pre></li>
<li>
<p>View the plan in the plan table.</p>
<p>For example, run the following statement:</p>
<pre dir="ltr">SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
</pre>
<p>Sample output appears below:</p>
<pre dir="ltr">-------------------------------------------------------------------------------
|Id| Operation                 | Name             |Rows|Bytes|Cost (%CPU)|Time|
-------------------------------------------------------------------------------
| 0| SELECT STATEMENT             |                      |4|128|7 (0)|00:00:01|
| 1|  NESTED LOOPS                |                      | |   |     |        |
| 2|   NESTED LOOPS               |                      |4|128|7 (0)|00:00:01|
|*3|    TABLE ACCESS FULL         |ORDER_ITEMS           |4|48 |3 (0)|00:00:01|
|*4|    INDEX UNIQUE SCAN         |PRODUCT_INFORMATION_PK|1|   |0 (0)|00:00:01|
| 5|   TABLE ACCESS BY INDEX ROWID|PRODUCT_INFORMATION   |1|20 |1 (0)|00:00:01|
-------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - filter(&#34;O&#34;.&#34;UNIT_PRICE&#34;=15 AND &#34;QUANTITY&#34;&gt;1)
   4 - access(&#34;P&#34;.&#34;PRODUCT_ID&#34;=&#34;O&#34;.&#34;PRODUCT_ID&#34;)
</pre>
<p>In this plan, the optimizer chooses a nested loops join.</p>
</li>
<li>
<p>Run the query that you previously explained.</p>
<p>For example, use the following statement:</p>
<pre dir="ltr">SELECT product_name 
FROM   order_items o, product_information p  
WHERE  o.unit_price = 15
AND    quantity &gt; 1  
AND    p.product_id = o.product_id
</pre></li>
<li>
<p>View the plan in the cursor.</p>
<p>For example, run the following commands:</p>
<pre dir="ltr">SET LINESIZE 165
SET PAGESIZE 0
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(FORMAT=&gt;&#39;+ADAPTIVE&#39;));
</pre>
<p>Sample output appears below. Based on statistics collected at run time (Step 4), the optimizer chose a hash join rather than the nested loops join. The dashes (<code class="codeph">-</code>) indicate the steps in the nested loops plan that the optimizer considered but do not ultimately choose. The switch illustrates the adaptive query plan feature.</p>
<pre dir="ltr">-------------------------------------------------------------------------------
|Id | Operation                     | Name     |Rows|Bytes|Cost(%CPU)|Time    |
-------------------------------------------------------------------------------
|  0| SELECT STATEMENT              |                     |4|128|7(0)|00:00:01|
| *1|  HASH JOIN                    |                     |4|128|7(0)|00:00:01|
|- 2|   NESTED LOOPS                |                     | |   |    |        |
|- 3|    NESTED LOOPS               |                     | |128|7(0)|00:00:01|
|- 4|     <span class="bold">STATISTICS COLLECTOR</span>      |                     | |   |    |        |
| *5|      TABLE ACCESS FULL        | ORDER_ITEMS         |4| 48|3(0)|00:00:01|
|-*6|     INDEX UNIQUE SCAN         | PRODUCT_INFORMATI_PK|1|   |0(0)|00:00:01|
|- 7|    TABLE ACCESS BY INDEX ROWID| PRODUCT_INFORMATION |1| 20|1(0)|00:00:01|
|  8|   TABLE ACCESS FULL           | PRODUCT_INFORMATION |1| 20|1(0)|00:00:01|
-------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access(&#34;P&#34;.&#34;PRODUCT_ID&#34;=&#34;O&#34;.&#34;PRODUCT_ID&#34;)
   5 - filter(&#34;O&#34;.&#34;UNIT_PRICE&#34;=15 AND &#34;QUANTITY&#34;&gt;1)
   6 - access(&#34;P&#34;.&#34;PRODUCT_ID&#34;=&#34;O&#34;.&#34;PRODUCT_ID&#34;)

Note
-----
   - <span class="bold">this is an adaptive plan (rows marked &#39;-&#39; are inactive)</span>
</pre></li>
</ol>
</div>
<!-- class="section" -->
<div class="section">
<div class="infoboxnotealso" id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__GUID-83F902F5-DC23-45B7-B771-7207B505F555">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="tgsql_optcncpt.htm#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" title="An adaptive plan enables the optimizer to defer the final plan decision for a statement until execution time.">Adaptive Query Plans</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="tgsql_interp.htm#GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA__CEGCBHGJ" title="This 2 column table describes DBMS_XPLAN program units. Column 1 lists the functions. Column 2 provides more information about the functions.">Table 7-8</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="tgsql_influence.htm#GUID-DAFB7D07-E8B3-4219-A09D-214BD943AFF9" title="In Oracle Database, adaptive query optimization is the process by which the optimizer adapts an execution plan based on statistics collected at run time.">Controlling Adaptive Optimization</a>&#34;</span></p>
</li>
<li>
<p><a class="olink REFRN10214" target="_blank" href="../REFRN/GUID-16B23F95-8644-407A-A6C8-E85CADFA61FF.htm#REFRN10214"><span class="italic">Oracle Database Reference</span></a> to learn about the <code class="codeph">STATISTICS_LEVEL</code> initialization parameter</p>
</li>
<li>
<p><a class="olink ARPLS68408" target="_blank" href="../ARPLS/d_sqltun.htm#ARPLS68408"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to learn more about <code class="codeph">DBMS_XPLAN</code></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="TGSQL94713"></a>
<div class="props_rev_3"><a id="GUID-22F3C307-95C3-47EE-A3FD-545F614947CB"></a>
<h3 id="TGSQL-GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" class="sect3">Viewing Parallel Execution with EXPLAIN PLAN</h3>
<div>
<p>Plans for parallel queries differ in important ways from plans for serial queries.</p>
</div>
<a id="TGSQL94714"></a>
<div class="props_rev_3"><a id="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A"></a>
<h4 id="TGSQL-GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A" class="sect4">About EXPLAIN PLAN and Parallel Queries</h4>
<div>
<p>Tuning a parallel query begins much like a non-parallel query tuning exercise by choosing the driving table. However, the rules governing the choice are different.</p>
<p>In the serial case, the best driving table produces the fewest numbers of rows after applying limiting conditions. The database joins a small number of rows to larger tables using non-unique indexes.</p>
<p>For example, consider a table hierarchy consisting of <code class="codeph">customer</code>, <code class="codeph">account</code>, and <code class="codeph">transaction</code>.</p>
<div class="figure" id="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A__GUID-F83F6CF6-70FD-4DDB-98D5-72870DEF5E70">
<p class="titleinfigure">Figure 7-1 A Table Hierarchy</p>
<img width="496" height="112" src="img/GUID-78058F60-5952-46C3-A6F7-EC356AEDC3B6-default.gif" alt="Description of Figure 7-1 follows" title="Description of Figure 7-1 follows"/><br/>
<a href="img_text/GUID-78058F60-5952-46C3-A6F7-EC356AEDC3B6-print.htm">Description of &#34;Figure 7-1 A Table Hierarchy&#34;</a></div>
<!-- class="figure" -->
<p>In this example, <code class="codeph">customer</code> is the smallest table, whereas <code class="codeph">transaction</code> is the largest table. A typical OLTP query retrieves transaction information about a specific customer account. The query drives from the <code class="codeph">customer</code> table. The goal is to minimize logical I/O, which typically minimizes other critical resources including physical I/O and CPU time.</p>
<p>For parallel queries, the driving table is usually the <span class="italic">largest</span> table. It would not be efficient to use parallel query in this case because only a few rows from each table are accessed. However, what if it were necessary to identify all customers who had transactions of a certain type last month? It would be more efficient to drive from the <code class="codeph">transaction</code> table because no limiting conditions exist on the <code class="codeph">customer</code> table. The database would join rows from the <code class="codeph">transaction</code> table to the <code class="codeph">account</code> table, and then finally join the result set to the <code class="codeph">customer</code> table. In this case, the used on the <code class="codeph">account</code> and <code class="codeph">customer</code> table are probably highly selective primary key or unique indexes rather than the non-unique indexes used in the first query. Because the <code class="codeph">transaction</code> table is large and the column is not selective, it would be beneficial to use parallel query driving from the <code class="codeph">transaction</code> table.</p>
<p>Parallel operations include the following:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">PARALLEL_TO_PARALLEL</code></p>
</li>
<li>
<p><code class="codeph">PARALLEL_TO_SERIAL</code></p>
<p>A <code class="codeph">PARALLEL_TO_SERIAL</code> operation is always the step that occurs when the query coordinator consumes rows from a parallel operation. Another type of operation that does not occur in this query is a <code class="codeph">SERIAL</code> operation. If these types of operations occur, then consider making them parallel operations to improve performance because they too are potential bottlenecks.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_FROM_SERIAL</code></p>
</li>
<li>
<p><code class="codeph">PARALLEL_TO_PARALLEL</code></p>
<p>If the workloads in each step are relatively equivalent, then the <code class="codeph">PARALLEL_TO_PARALLEL</code> operations generally produce the best performance.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_COMBINED_WITH_CHILD</code></p>
</li>
<li>
<p><code class="codeph">PARALLEL_COMBINED_WITH_PARENT</code></p>
<p>A <code class="codeph">PARALLEL_COMBINED_WITH_PARENT</code> operation occurs when the database performs the step simultaneously with the parent step.</p>
</li>
</ul>
<p>If a parallel step produces many rows, then the QC may not be able to consume the rows as fast as they are produced. Little can be done to improve this situation.</p>
<div class="infoboxnotealso" id="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A__GUID-E0692402-F90F-4625-BD94-9841DBEE007F">
<p class="notep1">See Also:</p>
<p>The <code class="codeph">OTHER_TAG</code> column in <span class="q">&#34;<a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C" title="The PLAN_TABLE used by the EXPLAIN PLAN statement contains the columns listed in this topic.">PLAN_TABLE Columns</a>&#34;</span></p>
</div>
</div>
</div>
<a id="TGSQL94716"></a><a id="TGSQL94715"></a>
<div class="props_rev_3"><a id="GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE"></a>
<h4 id="TGSQL-GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE" class="sect4">Viewing Parallel Queries with EXPLAIN PLAN: Example</h4>
<div>
<p>When using <code class="codeph">EXPLAIN PLAN</code> with parallel queries, the database compiles and executes one parallel plan. This plan is derived from the serial plan by allocating row sources specific to the parallel support in the QC plan.</p>
<div class="section">
<p>The table queue row sources (<code class="codeph">PX</code> <code class="codeph">Send</code> and <code class="codeph">PX</code> <code class="codeph">Receive</code>), the granule iterator, and buffer sorts, required by the two parallel execution server set PQ model, are directly inserted into the parallel plan. This plan is the same plan for all parallel execution servers when executed in parallel or for the QC when executed serially.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE__CEGIFEAJ">
<p class="titleinexample">Example 7-3 Parallel Query Explain Plan</p>
<p>The following simple example illustrates an <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> for a parallel query:</p>
<pre dir="ltr">CREATE TABLE emp2 AS SELECT * FROM employees;

ALTER TABLE emp2 PARALLEL 2;

EXPLAIN PLAN FOR
  SELECT SUM(salary) 
  FROM   emp2 
  GROUP BY department_id;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());
</pre>
<pre dir="ltr">------------------------------------------------------------------------------------------------
| Id  | Operation              | Name     | Rows| Bytes |Cost %CPU|    TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------
| 0 | SELECT STATEMENT         |          | 107 |  2782 |  3 (34) |        |      |            |
| 1 |  PX COORDINATOR          |          |     |       |         |        |      |            |
| 2 |   PX SEND QC (RANDOM)    | :TQ10001 | 107 |  2782 |  3 (34) |  Q1,01 | P-&gt;S | QC (RAND)  |
| 3 |    HASH GROUP BY         |          | 107 |  2782 |  3 (34) |  Q1,01 | PCWP |            |
| 4 |     PX RECEIVE           |          | 107 |  2782 |  3 (34) |  Q1,01 | PCWP |            |
| 5 |      PX SEND HASH        | :TQ10000 | 107 |  2782 |  3 (34) |  Q1,00 | P-&gt;P | HASH       |
| 6 |       HASH GROUP BY      |          | 107 |  2782 |  3 (34) |  Q1,00 | PCWP |            |
| 7 |        PX BLOCK ITERATOR |          | 107 |  2782 |  2 (0)  |  Q1,00 | PCWP |            |
| 8 |         TABLE ACCESS FULL| EMP2     | 107 |  2782 |  2 (0)  |  Q1,00 | PCWP |            |
------------------------------------------------------------------------------------------------
</pre>
<p>One set of parallel execution servers scans <code class="codeph">EMP2</code> in parallel, while the second set performs the aggregation for the <code class="codeph">GROUP</code> <code class="codeph">BY</code> operation. The <code class="codeph">PX</code> <code class="codeph">BLOCK</code> <code class="codeph">ITERATOR</code> row source represents the splitting up of the table <code class="codeph">EMP2</code> into pieces to divide the scan workload between the parallel execution servers. The <code class="codeph">PX</code> <code class="codeph">SEND</code> and <code class="codeph">PX</code> <code class="codeph">RECEIVE</code> row sources represent the pipe that connects the two sets of parallel execution servers as rows flow up from the parallel scan, get repartitioned through the <code class="codeph">HASH</code> table queue, and then read by and aggregated on the top set. The <code class="codeph">PX</code> <code class="codeph">SEND</code> <code class="codeph">QC</code> row source represents the aggregated values being sent to the QC in random (RAND) order. The <code class="codeph">PX</code> <code class="codeph">COORDINATOR</code> row source represents the QC or Query Coordinator which controls and schedules the parallel plan appearing below it in the plan tree.</p>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="TGSQL94718"></a><a id="TGSQL94717"></a>
<div class="props_rev_3"><a id="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063"></a>
<h3 id="TGSQL-GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063" class="sect3">Viewing Bitmap Indexes with EXPLAIN PLAN</h3>
<div>
<div class="section">
<p>Index row sources using bitmap indexes appear in the <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> output with the word <code class="codeph">BITMAP</code> indicating the type of the index.</p>
<div class="infobox-note" id="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063__GUID-50D3D7DD-EAFA-44D6-8508-2CEA4C0874B8">
<p class="notep1">Note:</p>
<p>Queries using bitmap join index indicate the bitmap join index access path. The operation for bitmap join index is the same as bitmap index.</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063__CEGFDIHJ">
<p class="titleinexample">Example 7-4 EXPLAIN PLAN with Bitmap Indexes</p>
<p>In this example, the predicate <code class="codeph">c1</code>=<code class="codeph">2</code> yields a bitmap from which a subtraction can take place. From this bitmap, the bits in the bitmap for <code class="codeph">c2</code> = <code class="codeph">6</code> are subtracted. Also, the bits in the bitmap for <code class="codeph">c2</code> <code class="codeph">IS</code> <code class="codeph">NULL</code> are subtracted, explaining why there are two <code class="codeph">MINUS</code> row sources in the plan. The <code class="codeph">NULL</code> subtraction is necessary for semantic correctness unless the column has a <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint. The <code class="codeph">TO</code> <code class="codeph">ROWIDS</code> option generates the rowids necessary for the table access.</p>
<pre dir="ltr">EXPLAIN PLAN FOR  SELECT * 
  FROM   t
  WHERE  c1 = 2 
  AND    c2 &lt;&gt; 6 
  OR     c3 BETWEEN 10 AND 20;

SELECT STATEMENT
   TABLE ACCESS T BY INDEX ROWID
      BITMAP CONVERSION TO ROWID
         BITMAP OR
            BITMAP MINUS
               BITMAP MINUS
                  BITMAP INDEX C1_IND SINGLE VALUE
                  BITMAP INDEX C2_IND SINGLE VALUE
               BITMAP INDEX C2_IND SINGLE VALUE
            BITMAP MERGE
               BITMAP INDEX C3_IND RANGE SCAN
</pre></div>
<!-- class="example" --></div>
</div>
<a id="TGSQL94719"></a>
<div class="props_rev_3"><a id="GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F"></a>
<h3 id="TGSQL-GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F" class="sect3">Viewing Result Cache with EXPLAIN PLAN</h3>
<div>
<div class="section">
<p>When your query contains the <code class="codeph">result_cache</code> hint, the <code class="codeph">ResultCache</code> operator is inserted into the execution plan.</p>
<p>For example, consider the following query:</p>
<pre dir="ltr">SELECT /*+ result_cache */ deptno, avg(sal) 
FROM   emp 
GROUP BY deptno;
</pre>
<p>To view the <code class="codeph">EXPLAIN PLAN</code> for this query, use the following command:</p>
<pre dir="ltr">EXPLAIN PLAN FOR 
  SELECT /*+ result_cache */ deptno, avg(sal) 
  FROM emp 
  GROUP BY deptno;

SELECT PLAN_TABLE_OUTPUT FROM TABLE (DBMS_XPLAN.DISPLAY());
</pre>
<p>The <code class="codeph">EXPLAIN PLAN</code> output for this query should look similar to the following:</p>
<pre dir="ltr">--------------------------------------------------------------------------------
|Id| Operation          | Name                     |Rows|Bytes|Cost(%CPU)|Time |
--------------------------------------------------------------------------------
|0| SELECT STATEMENT    |                          | 11 | 77 | 4 (25)| 00:00:01|
|1|  RESULT CACHE       |b06ppfz9pxzstbttpbqyqnfbmy|    |    |       |         |
|2|   HASH GROUP BY     |                          | 11 | 77 | 4 (25)| 00:00:01|
|3|    TABLE ACCESS FULL| EMP                      |107 | 749| 3 (0) | 00:00:01|
--------------------------------------------------------------------------------
</pre>
<p>In this <code class="codeph">EXPLAIN PLAN</code>, the <code class="codeph">ResultCache</code> operator is identified by its <code class="codeph">CacheId</code>, which is <code class="codeph">b06ppfz9pxzstbttpbqyqnfbmy</code>. You can now run a query on the <code class="codeph">V$RESULT_CACHE_OBJECTS</code> view by using this <code class="codeph">CacheId</code>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="TGSQL94720"></a>
<div class="props_rev_3"><a id="GUID-37DF6780-3279-47CE-93E6-BE922F1451EF"></a>
<h3 id="TGSQL-GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" class="sect3">Viewing Partitioned Objects with EXPLAIN PLAN</h3>
<div>
<p><a id="d26296e1556" class="indexterm-anchor"></a><a id="d26296e1558" class="indexterm-anchor"></a><a id="d26296e1562" class="indexterm-anchor"></a><a id="d26296e1566" class="indexterm-anchor"></a><a id="d26296e1570" class="indexterm-anchor"></a><a id="d26296e1574" class="indexterm-anchor"></a>Use <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> to see how Oracle Database accesses partitioned objects for specific queries.</p>
<p>Partitions accessed after pruning are shown in the <code class="codeph">PARTITION</code> <code class="codeph">START</code> and <code class="codeph">PARTITION</code> <code class="codeph">STOP</code> columns. The row source name for the range partition is <code class="codeph">PARTITION</code> <code class="codeph">RANGE</code>. For hash partitions, the row source name is <code class="codeph">PARTITION</code> <code class="codeph">HASH</code>.</p>
<p>A join is implemented using partial partition-wise join if the <code class="codeph">DISTRIBUTION</code> column of the plan table of one of the joined tables contains <code class="codeph">PARTITION</code>(<code class="codeph">KEY</code>). Partial partition-wise join is possible if one of the joined tables is partitioned on its join column and the table is parallelized.</p>
<p>A join is implemented using full partition-wise join if the partition row source appears before the join row source in the <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> output. Full partition-wise joins are possible only if both joined tables are equi-partitioned on their respective join columns. Examples of execution plans for several types of partitioning follow.</p>
</div>
<a id="TGSQL94721"></a>
<div class="props_rev_3"><a id="GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01"></a>
<h4 id="TGSQL-GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01" class="sect4">Displaying Range and Hash Partitioning with EXPLAIN PLAN: Examples</h4>
<div>
<div class="section">
<p>Consider the following table, <code class="codeph">emp_range</code>, partitioned by range on <code class="codeph">hire_date</code> to illustrate how pruning is displayed. Assume that the tables <code class="codeph">employees</code> and <code class="codeph">departments</code> from the Oracle Database sample schema exist.</p>
<pre dir="ltr">CREATE TABLE emp_range 
PARTITION BY RANGE(hire_date) 
( 
  PARTITION emp_p1 VALUES LESS THAN (TO_DATE(&#39;1-JAN-1992&#39;,&#39;DD-MON-YYYY&#39;)),
  PARTITION emp_p2 VALUES LESS THAN (TO_DATE(&#39;1-JAN-1994&#39;,&#39;DD-MON-YYYY&#39;)),
  PARTITION emp_p3 VALUES LESS THAN (TO_DATE(&#39;1-JAN-1996&#39;,&#39;DD-MON-YYYY&#39;)),
  PARTITION emp_p4 VALUES LESS THAN (TO_DATE(&#39;1-JAN-1998&#39;,&#39;DD-MON-YYYY&#39;)),
  PARTITION emp_p5 VALUES LESS THAN (TO_DATE(&#39;1-JAN-2001&#39;,&#39;DD-MON-YYYY&#39;)) 
) 
AS SELECT * FROM employees; 
</pre>
<p>For the first example, consider the following statement:</p>
<pre dir="ltr">EXPLAIN PLAN FOR 
  SELECT * FROM emp_range; 
</pre>
<p>Oracle Database displays something similar to the following:</p>
<pre dir="ltr">--------------------------------------------------------------------
|Id| Operation           | Name      |Rows| Bytes|Cost|Pstart|Pstop|
--------------------------------------------------------------------
| 0| SELECT STATEMENT    |           |  105| 13965 | 2 |   |       |
| 1|  PARTITION RANGE ALL|           |  105| 13965 | 2 | 1 |     5 |
| 2|   TABLE ACCESS FULL | EMP_RANGE |  105| 13965 | 2 | 1 |     5 |
--------------------------------------------------------------------
</pre>
<p>The database creates a partition row source on top of the table access row source. It iterates over the set of partitions to be accessed. <a id="d26296e1748" class="indexterm-anchor"></a>In this example, the partition iterator covers all partitions (option <code class="codeph">ALL</code>), because a <a id="d26296e1756" class="indexterm-anchor"></a>predicate <a id="d26296e1761" class="indexterm-anchor"></a>was not used for pruning. The <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION</code>_<code class="codeph">STOP</code> columns of the <code class="codeph">PLAN_TABLE</code> show access to all partitions from 1 to 5.</p>
<p>For the next example, consider the following statement:</p>
<pre dir="ltr">EXPLAIN PLAN FOR 
  SELECT * 
  FROM   emp_range 
  WHERE  hire_date &gt;= TO_DATE(&#39;1-JAN-1996&#39;,&#39;DD-MON-YYYY&#39;);
</pre>
<pre dir="ltr">-----------------------------------------------------------------------
| Id | Operation                | Name   |Rows|Bytes|Cost|Pstart|Pstop|
-----------------------------------------------------------------------
|  0 | SELECT STATEMENT         |         | 3 | 399 |   2 |     |     |
|  1 |  PARTITION RANGE ITERATOR|         | 3 | 399 |   2 |   4 |   5 |
| *2 |   TABLE ACCESS FULL      |EMP_RANGE| 3 | 399 |   2 |   4 |   5 |
-----------------------------------------------------------------------
</pre>
<p>In the previous example, the partition row source iterates from partition 4 to 5 because the database prunes the other partitions using a predicate on <code class="codeph">hire_date</code>.</p>
<p>Finally, consider the following statement:</p>
<pre dir="ltr">EXPLAIN PLAN FOR 
  SELECT *
  FROM   emp_range
  WHERE  hire_date &lt; TO_DATE(&#39;1-JAN-1992&#39;,&#39;DD-MON-YYYY&#39;); 
</pre>
<pre dir="ltr">-----------------------------------------------------------------------
| Id  | Operation            | Name      |Rows|Bytes|Cost|Pstart|Pstop|
-----------------------------------------------------------------------
|   0 | SELECT STATEMENT       |           |    1 |   133 | 2 |   |   |
|   1 |  PARTITION RANGE SINGLE|           |    1 |   133 | 2 | 1 | 1 |
|*  2 |   TABLE ACCESS FULL    | EMP_RANGE |    1 |   133 | 2 | 1 | 1 |
-----------------------------------------------------------------------
</pre>
<p>In the previous example, only partition 1 is accessed and known at compile time; thus, there is no need for a partition row source.</p>
<div class="infobox-note" id="GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01__GUID-201DA968-4EF0-471D-85AC-28E3E1667F3C">
<p class="notep1">Note:</p>
<p>Oracle Database displays the same information for hash partitioned objects, except the partition row source name is <code class="codeph">PARTITION</code> <code class="codeph">HASH</code> instead of <code class="codeph">PARTITION</code> <code class="codeph">RANGE</code>. Also, with hash partitioning, pruning is only possible using equality or <code class="codeph">IN</code>-list predicates.</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="TGSQL94723"></a>
<div class="props_rev_3"><a id="GUID-60AB9A81-49C2-4033-A692-A9766A065A60"></a>
<h4 id="TGSQL-GUID-60AB9A81-49C2-4033-A692-A9766A065A60" class="sect4">Pruning Information with Composite Partitioned Objects: Examples</h4>
<div>
<p>To illustrate how Oracle Database displays pruning information for composite partitioned objects, consider the table <code class="codeph">emp_comp</code>. It is range-partitioned on <code class="codeph">hiredate</code> and subpartitioned by hash on <code class="codeph">deptno</code>.</p>
<div class="section">
<pre dir="ltr">CREATE TABLE emp_comp PARTITION BY RANGE(hire_date) 
      SUBPARTITION BY HASH(department_id) SUBPARTITIONS 3 
( 
PARTITION emp_p1 VALUES LESS THAN (TO_DATE(&#39;1-JAN-1992&#39;,&#39;DD-MON-YYYY&#39;)),
PARTITION emp_p2 VALUES LESS THAN (TO_DATE(&#39;1-JAN-1994&#39;,&#39;DD-MON-YYYY&#39;)),
PARTITION emp_p3 VALUES LESS THAN (TO_DATE(&#39;1-JAN-1996&#39;,&#39;DD-MON-YYYY&#39;)),
PARTITION emp_p4 VALUES LESS THAN (TO_DATE(&#39;1-JAN-1998&#39;,&#39;DD-MON-YYYY&#39;)),
PARTITION emp_p5 VALUES LESS THAN (TO_DATE(&#39;1-JAN-2001&#39;,&#39;DD-MON-YYYY&#39;)) 
) 
AS SELECT * FROM employees; 
</pre>
<p>For the first example, consider the following statement:</p>
<pre dir="ltr">EXPLAIN PLAN FOR 
  SELECT * FROM emp_comp; 

-----------------------------------------------------------------------
|Id| Operation           | Name     | Rows  | Bytes |Cost|Pstart|Pstop|
-----------------------------------------------------------------------
| 0| SELECT STATEMENT    |          | 10120 |  1314K| 78 |    |       |
| 1|  PARTITION RANGE ALL|          | 10120 |  1314K| 78 |  1 |     5 |
| 2|   PARTITION HASH ALL|          | 10120 |  1314K| 78 |  1 |     3 |
| 3|    TABLE ACCESS FULL| EMP_COMP | 10120 |  1314K| 78 |  1 |    15 |
-----------------------------------------------------------------------
</pre>
<p>This example shows the plan when Oracle Database accesses all subpartitions of all partitions of a composite object. The database uses two partition row sources for this purpose: a range partition row source to iterate over the partitions, and a hash partition row source to iterate over the subpartitions of each accessed partition.</p>
<p>In the following example, the range partition row source iterates from partition 1 to 5, because the database performs no pruning. Within each partition, the hash partition row source iterates over subpartitions 1 to 3 of the current partition. As a result, the table access row source accesses subpartitions 1 to 15. In other words, the database accesses all subpartitions of the composite object.</p>
<pre dir="ltr">EXPLAIN PLAN FOR 
  SELECT * 
  FROM   emp_comp 
  WHERE  hire_date = TO_DATE(&#39;15-FEB-1998&#39;, &#39;DD-MON-YYYY&#39;); 

-----------------------------------------------------------------------
| Id | Operation              | Name    |Rows|Bytes |Cost|Pstart|Pstop|
-----------------------------------------------------------------------
|  0 | SELECT STATEMENT       |          | 20 | 2660 | 17 |     |     |
|  1 |  PARTITION RANGE SINGLE|          | 20 | 2660 | 17 |   5 |   5 |
|  2 |   PARTITION HASH ALL   |          | 20 | 2660 | 17 |   1 |   3 |
|* 3 |    TABLE ACCESS FULL   | EMP_COMP | 20 | 2660 | 17 |  13 |  15 |
-----------------------------------------------------------------------
</pre>
<p>In the previous example, only the last partition, partition 5, is accessed. This partition is known at compile time, so the database does not need to show it in the plan. The hash partition row source shows accessing of all subpartitions within that partition; that is, subpartitions 1 to 3, which translates into subpartitions 13 to 15 of the <code class="codeph">emp_comp</code> table.</p>
<p>Now consider the following statement:</p>
<pre dir="ltr">EXPLAIN PLAN FOR 
  SELECT * 
  FROM   emp_comp 
  WHERE  department_id = 20; 

------------------------------------------------------------------------
| Id | Operation              |Name    |Rows | Bytes |Cost|Pstart|Pstop|
------------------------------------------------------------------------
|  0 | SELECT STATEMENT       |          | 101 | 13433 | 78 |    |     |
|  1 |  PARTITION RANGE ALL   |          | 101 | 13433 | 78 |  1 |   5 |
|  2 |   PARTITION HASH SINGLE|          | 101 | 13433 | 78 |  3 |   3 |
|* 3 |    TABLE ACCESS FULL   | EMP_COMP | 101 | 13433 | 78 |    |     |
------------------------------------------------------------------------
</pre>
<p>In the previous example, the predicate <code class="codeph">deptno=20</code> enables pruning on the hash dimension within each partition. Therefore, Oracle Database only needs to access a single subpartition. The number of this subpartition is known at compile time, so the hash partition row source is not needed.</p>
<p>Finally, consider the following statement:</p>
<pre dir="ltr">VARIABLE dno NUMBER; 
EXPLAIN PLAN FOR 
  SELECT * 
  FROM   emp_comp 
  WHERE  department_id = :dno; 

-----------------------------------------------------------------------
| Id| Operation              | Name    |Rows| Bytes |Cost|Pstart|Pstop|
-----------------------------------------------------------------------
| 0 | SELECT STATEMENT       |          | 101| 13433 | 78 |     |     |
| 1 |  PARTITION RANGE ALL   |          | 101| 13433 | 78 |   1 |   5 |
| 2 |   PARTITION HASH SINGLE|          | 101| 13433 | 78 | KEY | KEY |
|*3 |    TABLE ACCESS FULL   | EMP_COMP | 101| 13433 | 78 |     |     |
-----------------------------------------------------------------------
</pre>
<p>The last two examples are the same, except that <code class="codeph">department_id</code> = :<code class="codeph">dno</code> replaces <code class="codeph">deptno=20</code>. In this last case, the subpartition number is unknown at compile time, and a hash partition row source is allocated. The option is <code class="codeph">SINGLE</code> for this row source because Oracle Database accesses only one subpartition within each partition. In Step 2, both <code class="codeph">PARTITION</code>_<code class="codeph">START</code> and <code class="codeph">PARTITION</code>_<code class="codeph">STOP</code> are set to <code class="codeph">KEY</code>. This value means that Oracle Database determines the number of subpartitions at run time.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="TGSQL94725"></a><a id="TGSQL94726"></a><a id="TGSQL94724"></a>
<div class="props_rev_3"><a id="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A"></a>
<h4 id="TGSQL-GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A" class="sect4">Examples of Partial Partition-Wise Joins</h4>
<div>
<div class="section">
<p>In both <a href="tgsql_interp.htm#GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A__CEGBBAEA">Example 7-5</a> and <a href="tgsql_interp.htm#GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A__CEGFCDHA">Example 7-6</a>, the <code class="codeph">PQ_DISTRIBUTE</code> hint explicitly forces a partial partition-wise join because the query optimizer could have chosen a different plan based on cost in this query.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A__CEGBBAEA">
<p class="titleinexample">Example 7-5 Partial Partition-Wise Join with Range Partition</p>
In the following example, the database joins <code class="codeph">emp_range_did</code> on the partitioning column <code class="codeph">department_id</code> and parallelizes it. The database can use a partial partition-wise join because the <code class="codeph">dept2</code> table is not partitioned. Oracle Database dynamically partitions the <code class="codeph">dept2</code> table before the join.
<pre dir="ltr">CREATE TABLE dept2 AS SELECT * FROM departments;
ALTER TABLE dept2 PARALLEL 2;

CREATE TABLE emp_range_did PARTITION BY RANGE(department_id)
   (PARTITION emp_p1 VALUES LESS THAN (150),
    PARTITION emp_p5 VALUES LESS THAN (MAXVALUE) )
  AS SELECT * FROM employees;

ALTER TABLE emp_range_did PARALLEL 2;

EXPLAIN PLAN FOR 
  SELECT /*+ PQ_DISTRIBUTE(d NONE PARTITION) ORDERED */ e.last_name, 
         d.department_name 
  FROM   emp_range_did e, dept2 d 
  WHERE  e.department_id = d.department_id;

------------------------------------------------------------------------------------------------
|Id| Operation                    |Name        |Row|Byte|Cost|Pstart|Pstop|TQ|IN-OUT|PQ Distrib|
------------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT             |             |284 |16188|6 |   |   |       |     |          | 
| 1|  PX COORDINATOR              |             |    |     |  |   |   |       |     |          |
| 2|   PX SEND QC (RANDOM)        |:TQ10001     |284 |16188|6 |   |   | Q1,01 |P-&gt;S |QC (RAND) |
|*3|    HASH JOIN                 |             |284 |16188|6 |   |   | Q1,01 |PCWP |          |
| 4|     PX PARTITION RANGE ALL   |             |284 |7668 |2 | 1 | 2 | Q1,01 |PCWC |          |
| 5|      TABLE ACCESS FULL       |EMP_RANGE_DID|284 |7668 |2 | 1 | 2 | Q1,01 |PCWP |          |
| 6|     BUFFER SORT              |             |    |     |  |   |   | Q1,01 |PCWC |          |
| 7|      PX RECEIVE              |             | 21 | 630 |2 |   |   | Q1,01 |PCWP |          |
| 8|       PX SEND PARTITION (KEY)|:TQ10000     | 21 | 630 |2 |   |   |       |S-&gt;P |PART (KEY)|
| 9|        TABLE ACCESS FULL     |DEPT2        | 21 | 630 |2 |   |   |       |     |          |
------------------------------------------------------------------------------------------------
</pre>
<p>The execution plan shows that the table <code class="codeph">dept2</code> is scanned serially and all rows with the same partitioning column value of <code class="codeph">emp_range_did</code> (<code class="codeph">department_id</code>) are sent through a <code class="codeph">PART</code> (<code class="codeph">KEY</code>), or partition key, table queue to the same parallel execution server doing the partial partition-wise join.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A__CEGFCDHA">
<p class="titleinexample">Example 7-6 Partial Partition-Wise Join with Composite Partition</p>
<p>In the following example, <code class="codeph">emp_comp</code> is joined on the partitioning column and is parallelized, enabling use of a partial partition-wise join because <code class="codeph">dept2</code> is not partitioned. The database dynamically partitions <code class="codeph">dept2</code> before the join.</p>
<pre dir="ltr">ALTER TABLE emp_comp PARALLEL 2; 

EXPLAIN PLAN FOR 
  SELECT /*+ PQ_DISTRIBUTE(d NONE PARTITION) ORDERED */ e.last_name, 
         d.department_name 
  FROM   emp_comp e, dept2 d 
  WHERE  e.department_id = d.department_id;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

------------------------------------------------------------------------------------------------
| Id| Operation                   | Name  |Rows |Bytes |Cost|Pstart|Pstop|TQ |IN-OUT|PQ Distrib|
------------------------------------------------------------------------------------------------
| 0 | SELECT STATEMENT            |        | 445 | 17800 | 5 |   |   |       |      |          |
| 1 |  PX COORDINATOR             |        |     |       |   |   |   |       |      |          |
| 2 |   PX SEND QC (RANDOM)       |:TQ10001| 445 | 17800 | 5 |   |   | Q1,01 | P-&gt;S | QC (RAND)|
|*3 |    HASH JOIN                |        | 445 | 17800 | 5 |   |   | Q1,01 | PCWP |          |
| 4 |     PX PARTITION RANGE ALL  |        | 107 |  1070 | 3 | 1 | 5 | Q1,01 | PCWC |          |
| 5 |      PX PARTITION HASH ALL  |        | 107 |  1070 | 3 | 1 | 3 | Q1,01 | PCWC |          |
| 6 |       TABLE ACCESS FULL     |EMP_COMP| 107 |  1070 | 3 | 1 | 15| Q1,01 | PCWP |          |
| 7 |     PX RECEIVE              |        |  21 |   630 | 1 |   |   | Q1,01 | PCWP |          |
| 8 |      PX SEND PARTITION (KEY)|:TQ10000|  21 |   630 | 1 |   |   | Q1,00 | P-&gt;P |PART (KEY)|
| 9 |       PX BLOCK ITERATOR     |        |  21 |   630 | 1 |   |   | Q1,00 | PCWC |          |
|10 |        TABLE ACCESS FULL    |DEPT2   |  21 |   630 | 1 |   |   | Q1,00 | PCWP |          |
------------------------------------------------------------------------------------------------
</pre>
<p>The plan shows that the optimizer selects partial partition-wise join from one of two columns. The <code class="codeph">PX</code> <code class="codeph">SEND</code> node type is <code class="codeph">PARTITION</code>(<code class="codeph">KEY</code>) and the <code class="codeph">PQ Distrib</code> column contains the text <code class="codeph">PART</code> (<code class="codeph">KEY</code>), or partition key. This implies that the table <code class="codeph">dept2</code> is re-partitioned based on the join column <code class="codeph">department_id</code> to be sent to the parallel execution servers executing the scan of <code class="codeph">EMP_COMP</code> and the join.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="TGSQL94728"></a><a id="TGSQL94727"></a>
<div class="props_rev_3"><a id="GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A"></a>
<h4 id="TGSQL-GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A" class="sect4">Example of Full Partition-Wise Join</h4>
<div>
<div class="section">
<p>In the following example, <code class="codeph">emp_comp</code> and <code class="codeph">dept_hash</code> are joined on their hash partitioning columns, enabling use of a full partition-wise join. The <code class="codeph">PARTITION</code> <code class="codeph">HASH</code> row source appears on top of the join row source in the plan table output.</p>
<pre dir="ltr">CREATE TABLE dept_hash
   PARTITION BY HASH(department_id)
   PARTITIONS 3
   PARALLEL 2
   AS SELECT * FROM departments;

EXPLAIN PLAN FOR 
  SELECT /*+ PQ_DISTRIBUTE(e NONE NONE) ORDERED */ e.last_name,
         d.department_name
  FROM   emp_comp e, dept_hash d
  WHERE  e.department_id = d.department_id;

------------------------------------------------------------------------------------------------
|Id| Operation                  | Name      |Rows|Bytes|Cost|Pstart|Pstop|TQ |IN-OUT|PQ Distrib|
------------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT           |           | 106 | 2544 | 8 |   |    |       |      |         |
| 1|  PX COORDINATOR            |           |     |      |   |   |    |       |      |         |
| 2|   PX SEND QC (RANDOM)      | :TQ10000  | 106 | 2544 | 8 |   |    | Q1,00 | P-&gt;S |QC (RAND)|
| 3|    PX PARTITION HASH ALL   |           | 106 | 2544 | 8 | 1 |  3 | Q1,00 | PCWC |         |
|*4|     HASH JOIN              |           | 106 | 2544 | 8 |   |    | Q1,00 | PCWP |         |
| 5|      PX PARTITION RANGE ALL|           | 107 | 1070 | 3 | 1 |  5 | Q1,00 | PCWC |         |
| 6|       TABLE ACCESS FULL    | EMP_COMP  | 107 | 1070 | 3 | 1 | 15 | Q1,00 | PCWP |         |
| 7|      TABLE ACCESS FULL     | DEPT_HASH |  27 |  378 | 4 | 1 |  3 | Q1,00 | PCWP |         |
------------------------------------------------------------------------------------------------
</pre>
<p>The <code class="codeph">PX</code> <code class="codeph">PARTITION</code> <code class="codeph">HASH</code> row source appears on top of the join row source in the plan table output while the <code class="codeph">PX</code> <code class="codeph">PARTITION</code> <code class="codeph">RANGE</code> row source appears over the scan of <code class="codeph">emp_comp</code>. Each parallel execution server performs the join of an entire hash partition of <code class="codeph">emp_comp</code> with an entire partition of <code class="codeph">dept_hash</code>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="TGSQL94729"></a>
<div class="props_rev_3"><a id="GUID-B1401051-FDEF-483A-B769-0C28143FBD8F"></a>
<h4 id="TGSQL-GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" class="sect4">Examples of INLIST ITERATOR and EXPLAIN PLAN</h4>
<div>
<div class="section">
<p>An <code class="codeph">INLIST</code> <code class="codeph">ITERATOR</code> operation appears in the <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> output if an index implements an <code class="codeph">IN</code>-list predicate. For example:</p>
<pre dir="ltr">SELECT * FROM emp WHERE empno IN (7876, 7900, 7902);
</pre>
<p>The <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> output appears as follows:</p>
<pre dir="ltr">OPERATION          OPTIONS           OBJECT_NAME
----------------   ---------------   -------------- 
SELECT STATEMENT
INLIST ITERATOR
TABLE ACCESS       BY ROWID          EMP
INDEX              RANGE SCAN        EMP_EMPNO
</pre>
<p>The <code class="codeph">INLIST</code> <code class="codeph">ITERATOR</code> operation iterates over the next operation in the plan for each value in the <code class="codeph">IN</code>-list predicate. The following sections describe the three possible types of <code class="codeph">IN</code>-list columns for partitioned tables and indexes.</p>
</div>
<!-- class="section" --></div>
<a id="TGSQL94730"></a>
<div class="props_rev_3"><a id="GUID-4B04B5D8-9948-40A4-A769-632AB1770749"></a>
<h5 id="TGSQL-GUID-4B04B5D8-9948-40A4-A769-632AB1770749" class="sect5">When the IN-List Column is an Index Column: Example</h5>
<div>
<div class="section">
<p>If the <code class="codeph">IN</code>-list column <code class="codeph">empno</code> is an index column but not a partition column, then the plan is as follows (the <code class="codeph">IN</code>-list operator appears before the table operation but after the partition operation):</p>
<pre dir="ltr">OPERATION        OPTIONS              OBJECT_NAME PARTIT_START PARTITION_STOP
---------------- ------------         ----------- ------------ -------------- 
SELECT STATEMENT 
PARTITION RANGE  ALL                               KEY(INLIST)     KEY(INLIST)
INLIST ITERATOR
TABLE ACCESS     BY LOCAL INDEX ROWID EMP          KEY(INLIST)     KEY(INLIST)
INDEX            RANGE SCAN           EMP_EMPNO    KEY(INLIST)     KEY(INLIST)
</pre>
<p>The <code class="codeph">KEY</code>(<code class="codeph">INLIST</code>) designation for the partition start and stop keys specifies that an <code class="codeph">IN</code>-list predicate appears on the index start and stop keys.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="TGSQL94731"></a>
<div class="props_rev_3"><a id="GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C"></a>
<h5 id="TGSQL-GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C" class="sect5">When the IN-List Column is an Index and a Partition Column: Example</h5>
<div>
<div class="section">
<p>If <code class="codeph">empno</code> is an indexed and a partition column, then the plan contains an <code class="codeph">INLIST</code> <code class="codeph">ITERATOR</code> operation before the partition operation:</p>
<pre dir="ltr">OPERATION        OPTIONS              OBJECT_NAME PARTITION_START PARTITION_STOP
---------------- ------------         ----------- --------------- --------------
SELECT STATEMENT
INLIST ITERATOR
PARTITION RANGE  ITERATOR                         KEY(INLIST)     KEY(INLIST)
TABLE ACCESS     BY LOCAL INDEX ROWID EMP         KEY(INLIST)     KEY(INLIST)
INDEX            RANGE SCAN           EMP_EMPNO   KEY(INLIST)     KEY(INLIST)
</pre></div>
<!-- class="section" --></div>
</div>
<a id="TGSQL94732"></a>
<div class="props_rev_3"><a id="GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70"></a>
<h5 id="TGSQL-GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70" class="sect5">When the IN-List Column is a Partition Column: Example</h5>
<div>
<div class="section">
<p>If <code class="codeph">empno</code> is a partition column and no indexes exist, then no <code class="codeph">INLIST</code> <code class="codeph">ITERATOR</code> operation is allocated:</p>
<pre dir="ltr">OPERATION         OPTIONS        OBJECT_NAME   PARTITION_START   PARTITION_STOP
----------------  ------------   -----------   ---------------   --------------
SELECT STATEMENT
PARTITION RANGE   INLIST                       KEY(INLIST)       KEY(INLIST)
TABLE ACCESS      FULL           EMP           KEY(INLIST)       KEY(INLIST)
</pre>
<p>If <code class="codeph">emp_empno</code> is a <a id="d26296e2726" class="indexterm-anchor"></a>bitmap index, then the plan is as follows:</p>
<pre dir="ltr">OPERATION          OPTIONS           OBJECT_NAME
----------------   ---------------   -------------- 
SELECT STATEMENT
INLIST ITERATOR
TABLE ACCESS       BY INDEX ROWID    EMP
BITMAP CONVERSION  TO ROWIDS
BITMAP INDEX       SINGLE VALUE      EMP_EMPNO
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="TGSQL94733"></a>
<div class="props_rev_3"><a id="GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A"></a>
<h4 id="TGSQL-GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A" class="sect4">Example of Domain Indexes and EXPLAIN PLAN</h4>
<div>
<div class="section">
<p><a id="d26296e2812" class="indexterm-anchor"></a>You can also use <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> to derive user-defined CPU and I/O costs for domain indexes. <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> displays these statistics in the <code class="codeph">OTHER</code> column of <code class="codeph">PLAN_TABLE</code>.</p>
<p>For example, assume table <code class="codeph">emp</code> has user-defined operator <code class="codeph">CONTAINS</code> with a domain index <code class="codeph">emp_resume</code> on the <code class="codeph">resume</code> column, and the index type of <code class="codeph">emp_resume</code> supports the operator <code class="codeph">CONTAINS</code>. You explain the plan for the following query:</p>
<pre dir="ltr">SELECT * FROM emp WHERE CONTAINS(resume, &#39;Oracle&#39;) = 1 
</pre>
<p>The database could display the following plan:</p>
<pre dir="ltr">OPERATION            OPTIONS      OBJECT_NAME     OTHER 
-----------------    -----------  ------------    ----------------
SELECT STATEMENT 
TABLE ACCESS         BY ROWID     EMP
DOMAIN INDEX                      EMP_RESUME      CPU: 300, I/O: 4
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="TGSQL94735"></a><a id="TGSQL94736"></a><a id="TGSQL94737"></a><a id="TGSQL94734"></a>
<div class="props_rev_3"><a id="GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C"></a>
<h3 id="TGSQL-GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C" class="sect3">PLAN_TABLE Columns</h3>
<div>
<p>The <code class="codeph">PLAN_TABLE</code> used by the <code class="codeph">EXPLAIN PLAN</code> statement contains the columns listed in this topic.</p>
<div class="tblformal" id="GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDBCJG">
<p class="titleintable">Table 7-1 PLAN_TABLE Columns</p>
<table class="cellalignment4808" title="PLAN_TABLE Columns" summary="This table describes the columns in the PLAN_TABLE used by the EXPLAIN PLAN statement.">
<thead>
<tr class="cellalignment4802">
<th class="cellalignment4886" id="d26296e3160">Column</th>
<th class="cellalignment4824" id="d26296e3163">Type</th>
<th class="cellalignment4826" id="d26296e3166">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3171" headers="d26296e3160">
<p><code class="codeph">STATEMENT_ID</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3171 d26296e3163">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3171 d26296e3166">
<p>Value of the optional <code class="codeph">STATEMENT_ID</code> parameter specified in the <code class="codeph">EXPLAIN PLAN</code> statement.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3189" headers="d26296e3160">
<p><code class="codeph">PLAN_ID</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3189 d26296e3163">
<p><code class="codeph">NUMBER</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3189 d26296e3166">
<p>Unique identifier of a plan in the database.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3203" headers="d26296e3160">
<p><code class="codeph">TIMESTAMP</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3203 d26296e3163">
<p><code class="codeph">DATE</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3203 d26296e3166">
<p>Date and time when the <code class="codeph">EXPLAIN PLAN</code> statement was generated.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3218" headers="d26296e3160">
<p><code class="codeph">REMARKS</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3218 d26296e3163">
<p><code class="codeph">VARCHAR2(80)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3218 d26296e3166">
<p>Any comment (of up to 80 bytes) you want to associate with each step of the explained plan. This column indicates whether the database used an outline or SQL profile for the query.</p>
<p>If you need to add or change a remark on any row of the <code class="codeph">PLAN_TABLE</code>, then use the <code class="codeph">UPDATE</code> statement to modify the rows of the <code class="codeph">PLAN_TABLE</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3241" headers="d26296e3160">
<p><code class="codeph">OPERATION</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3241 d26296e3163">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3241 d26296e3166">
<p>Name of the internal operation performed in this step. In the first row generated for a statement, the column contains one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">DELETE STATEMENT</code></p>
</li>
<li>
<p><code class="codeph">INSERT STATEMENT</code></p>
</li>
<li>
<p><code class="codeph">SELECT STATEMENT</code></p>
</li>
<li>
<p><code class="codeph">UPDATE STATEMENT</code></p>
</li>
</ul>
<p>See <a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDHHFH" title="This table lists each combination of the OPERATION and OPTIONS columns of the PLAN_TABLE and their meaning within an execution plan.">Table 7-3</a> for more information about values for this column.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3277" headers="d26296e3160">
<p><code class="codeph">OPTIONS</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3277 d26296e3163">
<p><code class="codeph">VARCHAR2(225)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3277 d26296e3166">
<p>A variation on the operation described in the <code class="codeph">OPERATION</code> column.</p>
<p>See <a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDHHFH" title="This table lists each combination of the OPERATION and OPTIONS columns of the PLAN_TABLE and their meaning within an execution plan.">Table 7-3</a> for more information about values for this column.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3299" headers="d26296e3160">
<p><code class="codeph">OBJECT_NODE</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3299 d26296e3163">
<p><code class="codeph">VARCHAR2(128)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3299 d26296e3166">
<p>Name of the database link used to reference the object (a table name or view name). For local queries using parallel execution, this column describes the order in which the database consumes output from operations.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3311" headers="d26296e3160">
<p><code class="codeph">OBJECT_OWNER</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3311 d26296e3163">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3311 d26296e3166">
<p>Name of the user who owns the schema containing the table or index.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3323" headers="d26296e3160">
<p><code class="codeph">OBJECT_NAME</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3323 d26296e3163">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3323 d26296e3166">
<p>Name of the table or index.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3335" headers="d26296e3160">
<p><code class="codeph">OBJECT_ALIAS</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3335 d26296e3163">
<p><code class="codeph">VARCHAR2(65)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3335 d26296e3166">
<p>Unique alias of a table or view in a SQL statement. For indexes, it is the object alias of the underlying table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3348" headers="d26296e3160">
<p><code class="codeph">OBJECT_INSTANCE</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3348 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3348 d26296e3166">
<p>Number corresponding to the ordinal position of the object as it appears in the original statement. The numbering proceeds from left to right, outer to inner for the original statement text. View expansion results in unpredictable numbers.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3361" headers="d26296e3160">
<p><code class="codeph">OBJECT_TYPE</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3361 d26296e3163">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3361 d26296e3166">
<p>Modifier that provides descriptive information about the object; for example, <code class="codeph">NON</code>-<code class="codeph">UNIQUE</code> for indexes.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3379" headers="d26296e3160">
<p><code class="codeph">OPTIMIZER</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3379 d26296e3163">
<p><code class="codeph">VARCHAR2(255)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3379 d26296e3166">
<p>Current mode of the optimizer.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3391" headers="d26296e3160">
<p><code class="codeph">SEARCH_COLUMNS</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3391 d26296e3163">
<p><code class="codeph">NUMBERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3391 d26296e3166">
<p>Not currently used.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3403" headers="d26296e3160">
<p><code class="codeph">ID</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3403 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3403 d26296e3166">
<p>A number assigned to each step in the execution plan.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3415" headers="d26296e3160">
<p><code class="codeph">PARENT_ID</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3415 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3415 d26296e3166">
<p>The ID of the next execution step that operates on the output of the <code class="codeph">ID</code> step.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3430" headers="d26296e3160">
<p><code class="codeph">DEPTH</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3430 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3430 d26296e3166">
<p>Depth of the operation in the row source tree that the plan represents. You can use the value to indent the rows in a plan table report.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3444" headers="d26296e3160">
<p><code class="codeph">POSITION</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3444 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3444 d26296e3166">
<p>For the first row of output, this indicates the optimizer&#39;s estimated cost of executing the statement. For the other rows, it indicates the position relative to the other children of the same parent.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3456" headers="d26296e3160">
<p><code class="codeph">COST</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3456 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3456 d26296e3166">
<p>Cost of the operation as estimated by the optimizer&#39;s query approach. Cost is not determined for table access operations. The value of this column does not have any particular unit of measurement; it is a weighted value used to compare costs of execution plans. The value of this column is a function of the <code class="codeph">CPU_COST</code> and <code class="codeph">IO_COST</code> columns.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3474" headers="d26296e3160">
<p><code class="codeph">CARDINALITY</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3474 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3474 d26296e3166">
<p>Estimate by the query optimization approach of the number of rows that the operation accessed.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3486" headers="d26296e3160">
<p><code class="codeph">BYTES</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3486 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3486 d26296e3166">
<p>Estimate by the query optimization approach of the number of bytes that the operation accessed.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3498" headers="d26296e3160">
<p><code class="codeph">OTHER_TAG</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3498 d26296e3163">
<p><code class="codeph">VARCHAR2(255)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3498 d26296e3166">
<p>Describes the contents of the <code class="codeph">OTHER</code> column. Values are:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">SERIAL</code> (blank): Serial execution. Currently, SQL is not loaded in the <code class="codeph">OTHER</code> column for this case.</p>
</li>
<li>
<p><code class="codeph">SERIAL_FROM_REMOTE (S&nbsp;-&gt;&nbsp;R)</code>: Serial execution at a remote site.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_FROM_SERIAL (S&nbsp;-&gt;&nbsp;P)</code>: Serial execution. Output of step is partitioned or broadcast to parallel execution servers.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_TO_SERIAL (P&nbsp;-&gt;&nbsp;S)</code>: Parallel execution. Output of step is returned to serial QC process.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_TO_PARALLEL (P&nbsp;-&gt;&nbsp;P)</code>: Parallel execution. Output of step is repartitioned to second set of parallel execution servers.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_COMBINED_WITH_PARENT (PWP)</code>: Parallel execution; Output of step goes to next step in same parallel process. No interprocess communication to parent.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_COMBINED_WITH_CHILD (PWC)</code>: Parallel execution. Input of step comes from prior step in same parallel process. No interprocess communication from child.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3553" headers="d26296e3160">
<p><code class="codeph">PARTITION_START</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3553 d26296e3163">
<p><code class="codeph">VARCHAR2(255)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3553 d26296e3166">
<p>Start partition of a range of accessed partitions. It can take one of the following values:</p>
<p><span class="italic">n</span> indicates that the start partition has been identified by the SQL compiler, and its partition number is given by <span class="italic">n</span>.</p>
<p><code class="codeph">KEY</code> indicates that the start partition is identified at run time from partitioning key values.</p>
<p><code class="codeph">ROW REMOVE_LOCATION</code> indicates that the database computes the start partition (same as the stop partition) at run time from the location of each retrieved record. The record location is obtained by a user or from a global index.</p>
<p><code class="codeph">INVALID</code> indicates that the range of accessed partitions is empty.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3584" headers="d26296e3160">
<p><code class="codeph">PARTITION_STOP</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3584 d26296e3163">
<p><code class="codeph">VARCHAR2(255)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3584 d26296e3166">
<p>Stop partition of a range of accessed partitions. It can take one of the following values:</p>
<p><span class="italic">n</span> indicates that the stop partition has been identified by the SQL compiler, and its partition number is given by <span class="italic">n</span>.</p>
<p><code class="codeph">KEY</code> indicates that the stop partition is identified at run time from partitioning key values.</p>
<p><code class="codeph">ROW REMOVE_LOCATION</code> indicates that the database computes the stop partition (same as the start partition) at run time from the location of each retrieved record. The record location is obtained by a user or from a global index.</p>
<p><code class="codeph">INVALID</code> indicates that the range of accessed partitions is empty.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3615" headers="d26296e3160">
<p><code class="codeph">PARTITION_ID</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3615 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3615 d26296e3166">
<p>Step that has computed the pair of values of the <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> columns.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3633" headers="d26296e3160">
<p><code class="codeph">OTHER</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3633 d26296e3163">
<p><code class="codeph">LONG</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3633 d26296e3166">
<p>Other information that is specific to the execution step that a user might find useful. See the <code class="codeph">OTHER_TAG</code> column.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3648" headers="d26296e3160">
<p><code class="codeph">DISTRIBUTION</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3648 d26296e3163">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3648 d26296e3166">
<p>Method used to distribute rows from producer query servers to consumer query servers.</p>
<p>See <a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDDEDJ" title="This table describes the values that can appear in the DISTRIBUTION column of the PLAN_TABLE.">Table 7-2</a> for more information about the possible values for this column. For more information about consumer and producer query servers, see <a class="olink GUID-1C6BC851-DE4A-4651-9813-3E70023C8264" target="_blank" href="../VLDBG/GUID-1C6BC851-DE4A-4651-9813-3E70023C8264.htm#GUID-1C6BC851-DE4A-4651-9813-3E70023C8264"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3673" headers="d26296e3160">
<p><code class="codeph">CPU_COST</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3673 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3673 d26296e3166">
<p>CPU cost of the operation as estimated by the query optimizer&#39;s approach. The value of this column is proportional to the number of machine cycles required for the operation. For statements that use the rule-based approach, this column is null.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3685" headers="d26296e3160">
<p><code class="codeph">IO_COST</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3685 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3685 d26296e3166">
<p>I/O cost of the operation as estimated by the query optimizer&#39;s approach. The value of this column is proportional to the number of data blocks read by the operation. For statements that use the rule-based approach, this column is null.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3697" headers="d26296e3160">
<p><code class="codeph">TEMP_SPACE</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3697 d26296e3163">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3697 d26296e3166">
<p>Temporary space, in bytes, that the operation uses as estimated by the query optimizer&#39;s approach. For statements that use the rule-based approach, or for operations that do not use any temporary space, this column is null.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3709" headers="d26296e3160">
<p><code class="codeph">ACCESS_PREDICATES</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3709 d26296e3163">
<p><code class="codeph">VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3709 d26296e3166">
<p>Predicates used to locate rows in an access structure. For example, start or stop predicates for an index range scan.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3722" headers="d26296e3160">
<p><code class="codeph">FILTER_PREDICATES</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3722 d26296e3163">
<p><code class="codeph">VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3722 d26296e3166">
<p>Predicates used to filter rows before producing them.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3736" headers="d26296e3160">
<p><code class="codeph">PROJECTION</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3736 d26296e3163">
<p><code class="codeph">VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3736 d26296e3166">
<p>Expressions produced by the operation.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3751" headers="d26296e3160">
<p><code class="codeph">TIME</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3751 d26296e3163">
<p><code class="codeph">NUMBER(20,2)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3751 d26296e3166">
<p>Elapsed time in seconds of the operation as estimated by query optimization. For statements that use the rule-based approach, this column is null. The <code class="codeph">DBMS_XPLAN.DISPLAY_PLAN</code> out, the time is in the <code class="codeph">HH:MM:SS</code> format.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e3771" headers="d26296e3160">
<p><code class="codeph">QBLOCK_NAME</code></p>
</td>
<td class="cellalignment4827" headers="d26296e3771 d26296e3163">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4829" headers="d26296e3771 d26296e3166">
<p>Name of the query block, either system-generated or defined by the user with the <code class="codeph">QB_NAME</code> hint.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDDEDJ" title="This table describes the values that can appear in the DISTRIBUTION column of the PLAN_TABLE.">Table 7-2</a> describes the values that can appear in the <code class="codeph">DISTRIBUTION</code> column:</p>
</div>
<!-- class="section" -->
<div class="tblformalwide" id="GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDDEDJ">
<p class="titleintable">Table 7-2 Values of DISTRIBUTION Column of the PLAN_TABLE</p>
<table class="cellalignment4813" title="Values of DISTRIBUTION Column of the PLAN_TABLE" summary="This table describes the values that can appear in the DISTRIBUTION column of the PLAN_TABLE.">
<thead>
<tr class="cellalignment4802">
<th class="cellalignment4870" id="d26296e3807">DISTRIBUTION Text</th>
<th class="cellalignment4901" id="d26296e3810">Interpretation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e3815" headers="d26296e3807">
<p><code class="codeph">PARTITION (ROWID)</code></p>
</td>
<td class="cellalignment4902" headers="d26296e3815 d26296e3810">
<p>Maps rows to query servers based on the partitioning of a table or index using the rowid of the row to <code class="codeph">UPDATE</code> or <code class="codeph">DELETE</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e3829" headers="d26296e3807">
<p><code class="codeph">PARTITION (KEY)</code></p>
</td>
<td class="cellalignment4902" headers="d26296e3829 d26296e3810">
<p>Maps rows to query servers based on the partitioning of a table or index using a set of columns. Used for partial partition-wise join, <code class="codeph">PARALLEL INSERT</code>, <code class="codeph">CREATE TABLE AS SELECT</code> of a partitioned table, and <code class="codeph">CREATE PARTITIONED GLOBAL INDEX</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e3846" headers="d26296e3807">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4902" headers="d26296e3846 d26296e3810">
<p>Maps rows to query servers using a hash function on the join key. Used for <code class="codeph">PARALLEL JOIN</code> or <code class="codeph">PARALLEL GROUP BY</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e3860" headers="d26296e3807">
<p><code class="codeph">RANGE</code></p>
</td>
<td class="cellalignment4902" headers="d26296e3860 d26296e3810">
<p>Maps rows to query servers using ranges of the sort key. Used when the statement contains an <code class="codeph">ORDER BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e3871" headers="d26296e3807">
<p><code class="codeph">ROUND-ROBIN</code></p>
</td>
<td class="cellalignment4902" headers="d26296e3871 d26296e3810">
<p>Randomly maps rows to query servers.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e3879" headers="d26296e3807">
<p><code class="codeph">BROADCAST</code></p>
</td>
<td class="cellalignment4902" headers="d26296e3879 d26296e3810">
<p>Broadcasts the rows of the entire table to each query server. Used for a parallel join when one table is very small compared to the other.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e3887" headers="d26296e3807">
<p><code class="codeph">QC (ORDER)</code></p>
</td>
<td class="cellalignment4902" headers="d26296e3887 d26296e3810">
<p>The QC consumes the input in order, from the first to the last query server. Used when the statement contains an <code class="codeph">ORDER BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e3898" headers="d26296e3807">
<p><code class="codeph">QC (RANDOM)</code></p>
</td>
<td class="cellalignment4902" headers="d26296e3898 d26296e3810">
<p>The QC consumes the input randomly. Used when the statement does not have an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDHHFH" title="This table lists each combination of the OPERATION and OPTIONS columns of the PLAN_TABLE and their meaning within an execution plan.">Table 7-3</a> lists each combination of <code class="codeph">OPERATION</code> and <code class="codeph">OPTIONS</code> produced by the <code class="codeph">EXPLAIN PLAN</code> statement and its meaning within an execution plan.</p>
</div>
<!-- class="section" -->
<div class="tblformal" id="GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDHHFH">
<p class="titleintable">Table 7-3 <span class="italic"><span class="bold">OPERATION and OPTIONS Values Produced by EXPLAIN PLAN</span></span></p>
<table class="cellalignment4808" title="OPERATION and OPTIONS Values Produced by EXPLAIN PLAN" summary="This table lists each combination of the OPERATION and OPTIONS columns of the PLAN_TABLE and their meaning within an execution plan.">
<thead>
<tr class="cellalignment4802">
<th class="cellalignment4891" id="d26296e3940">Operation</th>
<th class="cellalignment4870" id="d26296e3943">Option</th>
<th class="cellalignment4913" id="d26296e3946">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e3951" headers="d26296e3940">
<p><code class="codeph">AND-EQUAL</code></p>
</td>
<td class="cellalignment4871" headers="d26296e3951 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e3951 d26296e3946">
<p>Operation accepting multiple sets of rowids, returning the intersection of the sets, eliminating duplicates. Used for the single-column indexes access path.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e3960" headers="d26296e3940">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e3960 d26296e3943">
<p><code class="codeph">CONVERSION</code></p>
</td>
<td class="cellalignment4914" headers="d26296e3960 d26296e3946">
<p><code class="codeph">TO ROWIDS</code> converts bitmap representations to actual rowids that you can use to access the table.</p>
<p><code class="codeph">FROM ROWIDS</code> converts the rowids to a bitmap representation.</p>
<p><code class="codeph">COUNT</code> returns the number of rowids if the actual values are not needed.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e3982" headers="d26296e3940">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e3982 d26296e3943">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4914" headers="d26296e3982 d26296e3946">
<p><code class="codeph">SINGLE VALUE</code> looks up the bitmap for a single key value in the index.</p>
<p><code class="codeph">RANGE SCAN</code> retrieves bitmaps for a key value range.</p>
<p><code class="codeph">FULL SCAN</code> performs a full scan of a bitmap index if there is no start or stop key.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4004" headers="d26296e3940">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4004 d26296e3943">
<p><code class="codeph">MERGE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4004 d26296e3946">
<p>Merges several bitmaps resulting from a range scan into one bitmap.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4016" headers="d26296e3940">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4016 d26296e3943">
<p><code class="codeph">MINUS</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4016 d26296e3946">
<p>Subtracts bits of one bitmap from another. Row source is used for negated predicates. Use this option only if there are nonnegated predicates yielding a bitmap from which the subtraction can take place. An example appears in <span class="q">&#34;<a href="tgsql_interp.htm#GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063">Viewing Bitmap Indexes with EXPLAIN PLAN</a>&#34;</span>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4032" headers="d26296e3940">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4032 d26296e3943">
<p><code class="codeph">OR</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4032 d26296e3946">
<p>Computes the bitwise <code class="codeph">OR</code> of two bitmaps.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4047" headers="d26296e3940">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4047 d26296e3943">
<p><code class="codeph">AND</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4047 d26296e3946">
<p>Computes the bitwise <code class="codeph">AND</code> of two bitmaps.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4062" headers="d26296e3940">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4062 d26296e3943">
<p><code class="codeph">KEY ITERATION</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4062 d26296e3946">
<p>Takes each row from a table row source and finds the corresponding bitmap from a bitmap index. This set of bitmaps are then merged into one bitmap in a following <code class="codeph">BITMAP MERGE</code> operation.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4077" headers="d26296e3940">
<p><code class="codeph">CONNECT BY</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4077 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4077 d26296e3946">
<p>Retrieves rows in hierarchical order for a query containing a <code class="codeph">CONNECT BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4091" headers="d26296e3940">
<p><code class="codeph">CONCATENATION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4091 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4091 d26296e3946">
<p>Operation accepting multiple sets of rows returning the union-all of the sets.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4102" headers="d26296e3940">
<p><code class="codeph">COUNT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4102 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4102 d26296e3946">
<p>Operation counting the number of rows selected from a table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4115" headers="d26296e3940">
<p><code class="codeph">COUNT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4115 d26296e3943">
<p><code class="codeph">STOPKEY</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4115 d26296e3946">
<p>Count operation where the number of rows returned is limited by the <code class="codeph">ROWNUM</code> expression in the <code class="codeph">WHERE</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4135" headers="d26296e3940">
<p><code class="codeph">CUBE SCAN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4135 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4135 d26296e3946">
<p>Uses inner joins for all cube access.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4146" headers="d26296e3940">
<p><code class="codeph">CUBE SCAN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4146 d26296e3943">
<p><code class="codeph">PARTIAL OUTER</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4146 d26296e3946">
<p>Uses an outer join for at least one dimension, and inner joins for the other dimensions.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4158" headers="d26296e3940">
<p><code class="codeph">CUBE SCAN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4158 d26296e3943">
<p><code class="codeph">OUTER</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4158 d26296e3946">
<p>Uses outer joins for all cube access.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4170" headers="d26296e3940">
<p><code class="codeph">DOMAIN INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4170 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4170 d26296e3946">
<p>Retrieval of one or more rowids from a domain index. The options column contain information supplied by a user-defined domain index cost function, if any.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4181" headers="d26296e3940">
<p><code class="codeph">FILTER</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4181 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4181 d26296e3946">
<p>Operation accepting a set of rows, eliminates some of them, and returns the rest.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4192" headers="d26296e3940">
<p><code class="codeph">FIRST ROW</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4192 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4192 d26296e3946">
<p>Retrieval of only the first row selected by a query.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4203" headers="d26296e3940">
<p><code class="codeph">FOR UPDATE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4203 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4203 d26296e3946">
<p>Operation retrieving and locking the rows selected by a query containing a <code class="codeph">FOR UPDATE</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4217" headers="d26296e3940">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4217 d26296e3943">
<p><code class="codeph">GROUP BY</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4217 d26296e3946">
<p>Operation hashing a set of rows into groups for a query with a <code class="codeph">GROUP BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4232" headers="d26296e3940">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4232 d26296e3943">
<p><code class="codeph">GROUP BY PIVOT</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4232 d26296e3946">
<p>Operation hashing a set of rows into groups for a query with a <code class="codeph">GROUP BY</code> clause. The <code class="codeph">PIVOT</code> option indicates a pivot-specific optimization for the <code class="codeph">HASH GROUP BY</code> operator.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4253" headers="d26296e3940">
<p><code class="codeph">HASH JOIN</code></p>
<p>(These are join operations.)</p>
</td>
<td class="cellalignment4871" headers="d26296e4253 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4253 d26296e3946">
<p>Operation joining two sets of rows and returning the result. This join method is useful for joining large data sets of data (DSS, Batch). The join condition is an efficient way of accessing the second table.</p>
<p>Query optimizer uses the smaller of the two tables/data sources to build a hash table on the join key in memory. Then it scans the larger table, probing the hash table to find the joined rows.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4269" headers="d26296e3940">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4269 d26296e3943">
<p><code class="codeph">ANTI</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4269 d26296e3946">
<p>Hash (left) antijoin</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4281" headers="d26296e3940">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4281 d26296e3943">
<p><code class="codeph">SEMI</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4281 d26296e3946">
<p>Hash (left) semijoin</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4293" headers="d26296e3940">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4293 d26296e3943">
<p><code class="codeph">RIGHT ANTI</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4293 d26296e3946">
<p>Hash right antijoin</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4305" headers="d26296e3940">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4305 d26296e3943">
<p><code class="codeph">RIGHT SEMI</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4305 d26296e3946">
<p>Hash right semijoin</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4317" headers="d26296e3940">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4317 d26296e3943">
<p><code class="codeph">OUTER</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4317 d26296e3946">
<p>Hash (left) outer join</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4329" headers="d26296e3940">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4329 d26296e3943">
<p><code class="codeph">RIGHT OUTER</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4329 d26296e3946">
<p>Hash right outer join</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4341" headers="d26296e3940">
<p><code class="codeph">INDEX</code></p>
<p>(These are access methods.)</p>
</td>
<td class="cellalignment4871" headers="d26296e4341 d26296e3943">
<p><code class="codeph">UNIQUE SCAN</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4341 d26296e3946">
<p>Retrieval of a single rowid from an index.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4355" headers="d26296e3940">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4355 d26296e3943">
<p><code class="codeph">RANGE SCAN</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4355 d26296e3946">
<p>Retrieval of one or more rowids from an index. Indexed values are scanned in ascending order.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4368" headers="d26296e3940">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4368 d26296e3943">
<p><code class="codeph">RANGE SCAN DESCENDING</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4368 d26296e3946">
<p>Retrieval of one or more rowids from an index. Indexed values are scanned in descending order.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4381" headers="d26296e3940">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4381 d26296e3943">
<p><code class="codeph">FULL SCAN</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4381 d26296e3946">
<p>Retrieval of all rowids from an index when there is no start or stop key. Indexed values are scanned in ascending order.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4394" headers="d26296e3940">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4394 d26296e3943">
<p><code class="codeph">FULL SCAN DESCENDING</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4394 d26296e3946">
<p>Retrieval of all rowids from an index when there is no start or stop key. Indexed values are scanned in descending order.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4408" headers="d26296e3940">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4408 d26296e3943">
<p><code class="codeph">FAST FULL SCAN</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4408 d26296e3946">
<p>Retrieval of all rowids (and column values) using multiblock reads. No sorting order can be defined. Compares to a full table scan on only the indexed columns. Only available with the cost based optimizer.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4420" headers="d26296e3940">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4420 d26296e3943">
<p><code class="codeph">SKIP SCAN</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4420 d26296e3946">
<p>Retrieval of rowids from a concatenated index without using the leading column(s) in the index. Only available with the cost based optimizer.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4432" headers="d26296e3940">
<p><code class="codeph">INLIST ITERATOR</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4432 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4432 d26296e3946">
<p>Iterates over the next operation in the plan for each value in the <code class="codeph">IN</code>-list predicate.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4446" headers="d26296e3940">
<p><code class="codeph">INTERSECTION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4446 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4446 d26296e3946">
<p>Operation accepting two sets of rows and returning the intersection of the sets, eliminating duplicates.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4457" headers="d26296e3940">
<p><code class="codeph">MERGE JOIN</code></p>
<p>(These are join operations.)</p>
</td>
<td class="cellalignment4871" headers="d26296e4457 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4457 d26296e3946">
<p>Operation accepting two sets of rows, each sorted by a value, combining each row from one set with the matching rows from the other, and returning the result.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4470" headers="d26296e3940">
<p><code class="codeph">MERGE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4470 d26296e3943">
<p><code class="codeph">OUTER</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4470 d26296e3946">
<p>Merge join operation to perform an outer join statement.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4482" headers="d26296e3940">
<p><code class="codeph">MERGE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4482 d26296e3943">
<p><code class="codeph">ANTI</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4482 d26296e3946">
<p>Merge antijoin.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4494" headers="d26296e3940">
<p><code class="codeph">MERGE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4494 d26296e3943">
<p><code class="codeph">SEMI</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4494 d26296e3946">
<p>Merge semijoin.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4506" headers="d26296e3940">
<p><code class="codeph">MERGE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4506 d26296e3943">
<p><code class="codeph">CARTESIAN</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4506 d26296e3946">
<p>Can result from 1 or more of the tables not having any join conditions to any other tables in the statement. Can occur even with a join and it may not be flagged as <code class="codeph">CARTESIAN</code> in the plan.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4521" headers="d26296e3940">
<p><code class="codeph">CONNECT BY</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4521 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4521 d26296e3946">
<p>Retrieval of rows in hierarchical order for a query containing a <code class="codeph">CONNECT BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4535" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
<p>(These are access methods.)</p>
</td>
<td class="cellalignment4871" headers="d26296e4535 d26296e3943">
<p><code class="codeph">FULL</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4535 d26296e3946">
<p>Retrieval of all rows from a materialized view.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4550" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4550 d26296e3943">
<p><code class="codeph">SAMPLE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4550 d26296e3946">
<p>Retrieval of sampled rows from a materialized view.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4562" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4562 d26296e3943">
<p><code class="codeph">CLUSTER</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4562 d26296e3946">
<p>Retrieval of rows from a materialized view based on a value of an indexed cluster key.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4574" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4574 d26296e3943">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4574 d26296e3946">
<p>Retrieval of rows from materialized view based on hash cluster key value.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4586" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4586 d26296e3943">
<p><code class="codeph">BY ROWID RANGE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4586 d26296e3946">
<p>Retrieval of rows from a materialized view based on a rowid range.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4598" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4598 d26296e3943">
<p><code class="codeph">SAMPLE BY ROWID RANGE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4598 d26296e3946">
<p>Retrieval of sampled rows from a materialized view based on a rowid range.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4610" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4610 d26296e3943">
<p><code class="codeph">BY USER ROWID</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4610 d26296e3946">
<p>If the materialized view rows are located using user-supplied rowids.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4622" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4622 d26296e3943">
<p><code class="codeph">BY INDEX ROWID</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4622 d26296e3946">
<p>If the materialized view is nonpartitioned and rows are located using index(es).</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4634" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4634 d26296e3943">
<p><code class="codeph">BY GLOBAL INDEX ROWID</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4634 d26296e3946">
<p>If the materialized view is partitioned and rows are located using only global indexes.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4646" headers="d26296e3940">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4646 d26296e3943">
<p><code class="codeph">BY LOCAL INDEX ROWID</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4646 d26296e3946">
<p>If the materialized view is partitioned and rows are located using one or more local indexes and possibly some global indexes.</p>
<p>Partition Boundaries:</p>
<p>The partition boundaries might have been computed by:</p>
<p>A previous <code class="codeph">PARTITION</code> step, in which case the <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> column values replicate the values present in the <code class="codeph">PARTITION</code> step, and the <code class="codeph">PARTITION_ID</code> contains the ID of the <code class="codeph">PARTITION</code> step. Possible values for <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> are <code class="codeph">NUMBER</code>(n), <code class="codeph">KEY</code>, <code class="codeph">INVALID</code>.</p>
<p>The <code class="codeph">MAT_VIEW REWRITE ACCESS</code> or <code class="codeph">INDEX</code> step itself, in which case the <code class="codeph">PARTITION_ID</code> contains the <code class="codeph">ID</code> of the step. Possible values for <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> are <code class="codeph">NUMBER</code>(n), <code class="codeph">KEY</code>, <code class="codeph">ROW</code> <code class="codeph">REMOVE_LOCATION</code> (<code class="codeph">MAT_VIEW REWRITE</code> <code class="codeph">ACCESS</code> only), and <code class="codeph">INVALID</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4741" headers="d26296e3940">
<p><code class="codeph">MINUS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4741 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4741 d26296e3946">
<p>Operation accepting two sets of rows and returning rows appearing in the first set but not in the second, eliminating duplicates.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4752" headers="d26296e3940">
<p><code class="codeph">NESTED LOOPS</code></p>
<p>(These are join operations.)</p>
</td>
<td class="cellalignment4871" headers="d26296e4752 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4752 d26296e3946">
<p>Operation accepting two sets of rows, an outer set and an inner set. Oracle Database compares each row of the outer set with each row of the inner set, returning rows that satisfy a condition. This join method is useful for joining small subsets of data (OLTP). The join condition is an efficient way of accessing the second table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4766" headers="d26296e3940">
<p><code class="codeph">NESTED LOOPS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4766 d26296e3943">
<p><code class="codeph">OUTER</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4766 d26296e3946">
<p>Nested loops operation to perform an outer join statement.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4778" headers="d26296e3940">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4778 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4778 d26296e3946">
<p>Iterates over the next operation in the plan for each partition in the range given by the <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> columns. <code class="codeph">PARTITION</code> describes partition boundaries applicable to a single partitioned object (table or index) or to a set of equipartitioned objects (a partitioned table and its local indexes). The partition boundaries are provided by the values of <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> of the <code class="codeph">PARTITION</code>. Refer to <a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDBCJG" title="This table describes the columns in the PLAN_TABLE used by the EXPLAIN PLAN statement.">Table 7-1</a> for valid values of partition start and stop.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4813" headers="d26296e3940">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4813 d26296e3943">
<p><code class="codeph">SINGLE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4813 d26296e3946">
<p>Access one partition.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4825" headers="d26296e3940">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4825 d26296e3943">
<p><code class="codeph">ITERATOR</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4825 d26296e3946">
<p>Access many partitions (a subset).</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4837" headers="d26296e3940">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4837 d26296e3943">
<p><code class="codeph">ALL</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4837 d26296e3946">
<p>Access all partitions.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4850" headers="d26296e3940">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4850 d26296e3943">
<p><code class="codeph">INLIST</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4850 d26296e3946">
<p>Similar to iterator, but based on an <code class="codeph">IN</code>-list predicate.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4866" headers="d26296e3940">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4866 d26296e3943">
<p><code class="codeph">INVALID</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4866 d26296e3946">
<p>Indicates that the partition set to be accessed is empty.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4879" headers="d26296e3940">
<p><code class="codeph">PX</code> <code class="codeph">ITERATOR</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4879 d26296e3943">
<p><code class="codeph">BLOCK</code>, <code class="codeph">CHUNK</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4879 d26296e3946">
<p>Implements the division of an object into block or chunk ranges among a set of parallel execution servers.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4897" headers="d26296e3940">
<p><code class="codeph">PX</code> <code class="codeph">COORDINATOR</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4897 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4897 d26296e3946">
<p>Implements the query coordinator that controls, schedules, and executes the parallel plan below it using parallel execution servers. It also represents a serialization point, as the end of the part of the plan executed in parallel and always has a <code class="codeph">PX SEND QC</code> operation below it.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4914" headers="d26296e3940">
<p><code class="codeph">PX</code> <code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4914 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4914 d26296e3946">
<p>Same semantics as the regular <code class="codeph">PARTITION</code> operation except that it appears in a parallel plan.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4932" headers="d26296e3940">
<p><code class="codeph">PX</code> <code class="codeph">RECEIVE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4932 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4932 d26296e3946">
<p>Shows the consumer/receiver parallel execution node reading repartitioned data from a send/producer (QC or parallel execution server) executing on a <code class="codeph">PX SEND</code> node. This information was formerly displayed into the <code class="codeph">DISTRIBUTION</code> column. See <a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDDEDJ" title="This table describes the values that can appear in the DISTRIBUTION column of the PLAN_TABLE.">Table 7-2</a>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4958" headers="d26296e3940">
<p><code class="codeph">PX</code> <code class="codeph">SEND</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4958 d26296e3943">
<p><code class="codeph">QC</code> <code class="codeph">(RANDOM), HASH</code>, <code class="codeph">RANGE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e4958 d26296e3946">
<p>Implements the distribution method taking place between two parallel execution servers. Shows the boundary between two sets and how data is repartitioned on the send/producer side. This information was formerly displayed into the <code class="codeph">DISTRIBUTION</code> column. See <a href="tgsql_interp.htm#GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__CEGDDEDJ" title="This table describes the values that can appear in the DISTRIBUTION column of the PLAN_TABLE.">Table 7-2</a>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4988" headers="d26296e3940">
<p><code class="codeph">REMOTE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4988 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4988 d26296e3946">
<p>Retrieval of data from a remote database.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e4999" headers="d26296e3940">
<p><code class="codeph">SEQUENCE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e4999 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e4999 d26296e3946">
<p>Operation involving accessing values of a sequence.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5010" headers="d26296e3940">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5010 d26296e3943">
<p><code class="codeph">AGGREGATE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5010 d26296e3946">
<p>Retrieval of a single row that is the result of applying a group function to a group of selected rows.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5023" headers="d26296e3940">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5023 d26296e3943">
<p><code class="codeph">UNIQUE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5023 d26296e3946">
<p>Operation sorting a set of rows to eliminate duplicates.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5036" headers="d26296e3940">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5036 d26296e3943">
<p><code class="codeph">GROUP</code> <code class="codeph">BY</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5036 d26296e3946">
<p>Operation sorting a set of rows into groups for a query with a <code class="codeph">GROUP BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5055" headers="d26296e3940">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5055 d26296e3943">
<p><code class="codeph">GROUP BY PIVOT</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5055 d26296e3946">
<p>Operation sorting a set of rows into groups for a query with a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. The <code class="codeph">PIVOT</code> option indicates a pivot-specific optimization for the <code class="codeph">SORT GROUP BY</code> operator.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5079" headers="d26296e3940">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5079 d26296e3943">
<p><code class="codeph">JOIN</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5079 d26296e3946">
<p>Operation sorting a set of rows before a merge-join.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5091" headers="d26296e3940">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5091 d26296e3943">
<p><code class="codeph">ORDER BY</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5091 d26296e3946">
<p>Operation sorting a set of rows for a query with an <code class="codeph">ORDER BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5106" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
<p>(These are access methods.)</p>
</td>
<td class="cellalignment4871" headers="d26296e5106 d26296e3943">
<p><code class="codeph">FULL</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5106 d26296e3946">
<p>Retrieval of all rows from a table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5120" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5120 d26296e3943">
<p><code class="codeph">SAMPLE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5120 d26296e3946">
<p>Retrieval of sampled rows from a table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5133" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5133 d26296e3943">
<p><code class="codeph">CLUSTER</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5133 d26296e3946">
<p>Retrieval of rows from a table based on a value of an indexed cluster key.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5145" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5145 d26296e3943">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5145 d26296e3946">
<p>Retrieval of rows from table based on hash cluster key value.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5157" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5157 d26296e3943">
<p><code class="codeph">BY ROWID RANGE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5157 d26296e3946">
<p>Retrieval of rows from a table based on a rowid range.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5169" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5169 d26296e3943">
<p><code class="codeph">SAMPLE BY ROWID RANGE</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5169 d26296e3946">
<p>Retrieval of sampled rows from a table based on a rowid range.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5181" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5181 d26296e3943">
<p><code class="codeph">BY USER ROWID</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5181 d26296e3946">
<p>If the table rows are located using user-supplied rowids.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5196" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5196 d26296e3943">
<p><code class="codeph">BY INDEX ROWID</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5196 d26296e3946">
<p>If the table is nonpartitioned and rows are located using indexes.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5208" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5208 d26296e3943">
<p><code class="codeph">BY GLOBAL INDEX ROWID</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5208 d26296e3946">
<p>If the table is partitioned and rows are located using only global indexes.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5220" headers="d26296e3940">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5220 d26296e3943">
<p><code class="codeph">BY LOCAL INDEX ROWID</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5220 d26296e3946">
<p>If the table is partitioned and rows are located using one or more local indexes and possibly some global indexes.</p>
<p>Partition Boundaries:</p>
<p>The partition boundaries might have been computed by:</p>
<p>A previous <code class="codeph">PARTITION</code> step, in which case the <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> column values replicate the values present in the <code class="codeph">PARTITION</code> step, and the <code class="codeph">PARTITION_ID</code> contains the ID of the <code class="codeph">PARTITION</code> step. Possible values for <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> are <code class="codeph">NUMBER</code>(n), <code class="codeph">KEY</code>, <code class="codeph">INVALID</code>.</p>
<p>The <code class="codeph">TABLE ACCESS</code> or <code class="codeph">INDEX</code> step itself, in which case the <code class="codeph">PARTITION_ID</code> contains the <code class="codeph">ID</code> of the step. Possible values for <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> are <code class="codeph">NUMBER</code>(n), <code class="codeph">KEY</code>, <code class="codeph">ROW REMOVE_LOCATION</code> (<code class="codeph">TABLE ACCESS</code> only), and <code class="codeph">INVALID</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5308" headers="d26296e3940">
<p><code class="codeph">TRANSPOSE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5308 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e5308 d26296e3946">
<p>Operation evaluating a <code class="codeph">PIVOT</code> operation by transposing the results of <code class="codeph">GROUP BY</code> to produce the final pivoted data.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5325" headers="d26296e3940">
<p><code class="codeph">UNION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5325 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e5325 d26296e3946">
<p>Operation accepting two sets of rows and returns the union of the sets, eliminating duplicates.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5336" headers="d26296e3940">
<p><code class="codeph">UNPIVOT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5336 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e5336 d26296e3946">
<p>Operation that rotates data from columns into rows.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4894" id="d26296e5348" headers="d26296e3940">
<p><code class="codeph">VIEW</code></p>
</td>
<td class="cellalignment4871" headers="d26296e5348 d26296e3943">&nbsp;</td>
<td class="cellalignment4914" headers="d26296e5348 d26296e3946">
<p>Operation performing a view&#39;s query and then returning the resulting rows to another operation.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<div class="infoboxnotealso" id="GUID-D7331098-AEF5-49A2-98A1-3039E2A5900C__GUID-9751A6D8-D411-4274-87FB-4AFE135BCD2A">
<p class="notep1">See Also:</p>
<p><a class="olink REFRN29510" target="_blank" href="../REFRN/GUID-0CAFEAD1-8C79-4200-8658-947D04BDFFE2.htm#REFRN29510"><span><cite>Oracle Database Reference</cite></span></a> for more information about <code class="codeph">PLAN_TABLE</code></p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="TGSQL283"></a>
<div class="props_rev_3"><a id="GUID-7957B335-D36A-42BF-96BB-FF47FFBA4DFD"></a>
<h2 id="TGSQL-GUID-7957B335-D36A-42BF-96BB-FF47FFBA4DFD" class="sect2">Execution Plan Reference</h2>
<div>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="tgsql_interp.htm#GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D" title="The following dynamic performance and data dictionary views provide information on execution plans.">Execution Plan Views</a></p>
</li>
<li>
<p><a href="tgsql_interp.htm#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2" title="The PLAN_TABLE is used by the EXPLAIN PLAN statement.">PLAN_TABLE Columns</a></p>
</li>
<li>
<p><a href="tgsql_interp.htm#GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA" title="The functions DISPLAY_PLAN and DISPLAY_CURSOR in DBMS_XPLAN are relevant for accessing adapted plans.">DBMS_XPLAN Program Units</a></p>
</li>
</ul>
</div>
<a id="TGSQL285"></a><a id="TGSQL284"></a>
<div class="props_rev_3"><a id="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D"></a>
<h3 id="TGSQL-GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D" class="sect3">Execution Plan Views</h3>
<div>
<p>The following dynamic performance and data dictionary views provide information on execution plans.</p>
<div class="section"></div>
<!-- class="section" -->
<div class="tblformal" id="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D__CEGJADJA">
<p class="titleintable">Table 7-4 Execution Plan Views</p>
<table class="cellalignment4808" title="Execution Plan Views" summary="This 2 column table describes execution plan views. Column 1 is the view. Column 2 describes that view.">
<thead>
<tr class="cellalignment4802">
<th class="cellalignment4831" id="d26296e5596">View</th>
<th class="cellalignment4913" id="d26296e5599">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4802">
<td class="cellalignment4833" id="d26296e5604" headers="d26296e5596">
<p><code class="codeph">V$SQL_SHARED_CURSOR</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5604 d26296e5599">
<p>Explains why a particular child cursor is not shared with existing child cursors. Each column identifies a specific reason why the cursor cannot be shared.</p>
<p>The <code class="codeph">USE_FEEDBACK_STATS</code> column shows whether a child cursor fails to match because of reoptimization.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4833" id="d26296e5617" headers="d26296e5596">
<p><code class="codeph">V$SQL_PLAN</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5617 d26296e5599">
<p>Includes a superset of all rows appearing in all final plans. <code class="codeph">PLAN_LINE_ID</code> is consecutively numbered, but for a single final plan, the IDs may not be consecutive.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4833" id="d26296e5628" headers="d26296e5596">
<p><code class="codeph">V$SQL_PLAN_STATISTICS_ALL</code></p>
</td>
<td class="cellalignment4914" headers="d26296e5628 d26296e5599">
<p>Contains memory usage statistics for row sources that use SQL memory (sort or hash join). This view concatenates information in <code class="codeph">V$SQL_PLAN</code> with execution statistics from <code class="codeph">V$SQL_PLAN_STATISTICS</code> and <code class="codeph">V$SQL_WORKAREA</code>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="TGSQL287"></a><a id="TGSQL288"></a><a id="TGSQL289"></a><a id="TGSQL286"></a>
<div class="props_rev_3"><a id="GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2"></a>
<h3 id="TGSQL-GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2" class="sect3">PLAN_TABLE Columns</h3>
<div>
<p>The <code class="codeph">PLAN_TABLE</code> is used by the <code class="codeph">EXPLAIN PLAN</code> statement.</p>
<div class="section">
<p><code class="codeph">PLAN_TABLE</code> contains the columns listed in <a href="tgsql_interp.htm#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGJACGD" title="This table describes the columns in the PLAN_TABLE used by the EXPLAIN PLAN statement.">Table 7-5</a>.</p>
<div class="tblformalwide" id="GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGJACGD">
<p class="titleintable">Table 7-5 PLAN_TABLE Columns</p>
<table class="cellalignment4813" title="PLAN_TABLE Columns" summary="This table describes the columns in the PLAN_TABLE used by the EXPLAIN PLAN statement.">
<thead>
<tr class="cellalignment4802">
<th class="cellalignment4886" id="d26296e5951">Column</th>
<th class="cellalignment4909" id="d26296e5954">Type</th>
<th class="cellalignment4904" id="d26296e5957">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e5962" headers="d26296e5951">
<p><code class="codeph">STATEMENT_ID</code></p>
</td>
<td class="cellalignment4911" headers="d26296e5962 d26296e5954">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e5962 d26296e5957">
<p>Value of the optional <code class="codeph">STATEMENT_ID</code> parameter specified in the <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> statement.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e5983" headers="d26296e5951">
<p><code class="codeph">PLAN_ID</code></p>
</td>
<td class="cellalignment4911" headers="d26296e5983 d26296e5954">
<p><code class="codeph">NUMBER</code></p>
</td>
<td class="cellalignment4906" headers="d26296e5983 d26296e5957">
<p>Unique identifier of a plan in the database.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e5997" headers="d26296e5951">
<p><code class="codeph">TIMESTAMP</code></p>
</td>
<td class="cellalignment4911" headers="d26296e5997 d26296e5954">
<p><code class="codeph">DATE</code></p>
</td>
<td class="cellalignment4906" headers="d26296e5997 d26296e5957">
<p>Date and time when the <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> statement was generated.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6015" headers="d26296e5951">
<p><code class="codeph">REMARKS</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6015 d26296e5954">
<p><code class="codeph">VARCHAR2(80)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6015 d26296e5957">
<p>Any comment (of up to 80 bytes) you want to associate with each step of the explained plan. This column indicates whether the database used an outline or SQL profile for the query.</p>
<p>If you need to add or change a remark on any row of the <code class="codeph">PLAN_TABLE</code>, then use the <code class="codeph">UPDATE</code> statement to modify the rows of the <code class="codeph">PLAN_TABLE</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6038" headers="d26296e5951">
<p><code class="codeph">OPERATION</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6038 d26296e5954">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6038 d26296e5957">
<p>Name of the internal operation performed in this step. In the first row generated for a statement, the column contains one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">DELETE STATEMENT</code></p>
</li>
<li>
<p><code class="codeph">INSERT STATEMENT</code></p>
</li>
<li>
<p><code class="codeph">SELECT STATEMENT</code></p>
</li>
<li>
<p><code class="codeph">UPDATE STATEMENT</code></p>
</li>
</ul>
<p>See <a href="tgsql_interp.htm#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGGGBCH" title="This table describes the values that can appear in the DISTRIBUTION column of the PLAN_TABLE.">Table 7-6</a> for more information about values for this column.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6074" headers="d26296e5951">
<p><code class="codeph">OPTIONS</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6074 d26296e5954">
<p><code class="codeph">VARCHAR2(225)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6074 d26296e5957">
<p>A variation on the operation that the <code class="codeph">OPERATION</code> column describes.</p>
<p>See <a href="tgsql_interp.htm#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGGGBCH" title="This table describes the values that can appear in the DISTRIBUTION column of the PLAN_TABLE.">Table 7-6</a> for more information about values for this column.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6096" headers="d26296e5951">
<p><code class="codeph">OBJECT_NODE</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6096 d26296e5954">
<p><code class="codeph">VARCHAR2(128)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6096 d26296e5957">
<p>Name of the database link used to reference the object (a table name or view name). For local queries using parallel execution, this column describes the order in which the database consumes output from operations.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6108" headers="d26296e5951">
<p><code class="codeph">OBJECT_OWNER</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6108 d26296e5954">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6108 d26296e5957">
<p>Name of the user who owns the schema containing the table or index.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6120" headers="d26296e5951">
<p><code class="codeph">OBJECT_NAME</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6120 d26296e5954">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6120 d26296e5957">
<p>Name of the table or index.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6132" headers="d26296e5951">
<p><code class="codeph">OBJECT_ALIAS</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6132 d26296e5954">
<p><code class="codeph">VARCHAR2(65)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6132 d26296e5957">
<p>Unique alias of a table or view in a SQL statement. For indexes, it is the object alias of the underlying table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6145" headers="d26296e5951">
<p><code class="codeph">OBJECT_INSTANCE</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6145 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6145 d26296e5957">
<p>Number corresponding to the ordinal position of the object as it appears in the original statement. The numbering proceeds from left to right, outer to inner for the original statement text. View expansion results in unpredictable numbers.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6158" headers="d26296e5951">
<p><code class="codeph">OBJECT_TYPE</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6158 d26296e5954">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6158 d26296e5957">
<p>Modifier that provides descriptive information about the object; for example, <code class="codeph">NONUNIQUE</code> for indexes.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6173" headers="d26296e5951">
<p><code class="codeph">OPTIMIZER</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6173 d26296e5954">
<p><code class="codeph">VARCHAR2(255)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6173 d26296e5957">
<p>Current mode of the optimizer.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6185" headers="d26296e5951">
<p><code class="codeph">SEARCH_COLUMNS</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6185 d26296e5954">
<p><code class="codeph">NUMBERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6185 d26296e5957">
<p>Not currently used.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6197" headers="d26296e5951">
<p><code class="codeph">ID</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6197 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6197 d26296e5957">
<p>A number assigned to each step in the execution plan.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6209" headers="d26296e5951">
<p><code class="codeph">PARENT_ID</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6209 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6209 d26296e5957">
<p>The ID of the next execution step that operates on the output of the <code class="codeph">ID</code> step.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6224" headers="d26296e5951">
<p><code class="codeph">DEPTH</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6224 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6224 d26296e5957">
<p>Depth of the operation in the row source tree that the plan represents. You can use this value to indent the rows in a plan table report.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6238" headers="d26296e5951">
<p><code class="codeph">POSITION</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6238 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6238 d26296e5957">
<p>For the first row of output, this indicates the optimizer&#39;s estimated cost of executing the statement. For the other rows, it indicates the position relative to the other children of the same parent.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6250" headers="d26296e5951">
<p><code class="codeph">COST</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6250 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6250 d26296e5957">
<p>Cost of the operation as estimated by the optimizer&#39;s query approach. Cost is not determined for table access operations. The value of this column does not have any particular unit of measurement; it is a weighted value used to compare costs of execution plans. The value of this column is a function of the <code class="codeph">CPU_COST</code> and <code class="codeph">IO_COST</code> columns.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6268" headers="d26296e5951">
<p><code class="codeph">CARDINALITY</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6268 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6268 d26296e5957">
<p>Estimate by the query optimization approach of the number of rows that the operation accessed.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6280" headers="d26296e5951">
<p><code class="codeph">BYTES</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6280 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6280 d26296e5957">
<p>Estimate by the query optimization approach of the number of bytes that the operation accessed.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6292" headers="d26296e5951">
<p><code class="codeph">OTHER_TAG</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6292 d26296e5954">
<p><code class="codeph">VARCHAR2(255)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6292 d26296e5957">
<p>Describes the contents of the <code class="codeph">OTHER</code> column. Values are:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">SERIAL</code> (blank): Serial execution. Currently, SQL is not loaded in the <code class="codeph">OTHER</code> column for this case.</p>
</li>
<li>
<p><code class="codeph">SERIAL_FROM_REMOTE</code> <code class="codeph">(S&nbsp;-&gt;&nbsp;R)</code>: Serial execution at a remote site.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_FROM_SERIAL (S&nbsp;-&gt;&nbsp;P)</code>: Serial execution. Output of step is partitioned or broadcast to parallel execution servers.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_TO_SERIAL (P&nbsp;-&gt;&nbsp;S)</code>: Parallel execution. Output of step is returned to serial QC process.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_TO_PARALLEL (P&nbsp;-&gt;&nbsp;P)</code>: Parallel execution. Output of step is repartitioned to second set of parallel execution servers.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_COMBINED_WITH_PARENT (PWP)</code>: Parallel execution; Output of step goes to next step in same parallel process. No interprocess communication to parent.</p>
</li>
<li>
<p><code class="codeph">PARALLEL_COMBINED_WITH_CHILD (PWC)</code>: Parallel execution. Input of step comes from prior step in same parallel process. No interprocess communication from child.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6349" headers="d26296e5951">
<p><code class="codeph">PARTITION_START</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6349 d26296e5954">
<p><code class="codeph">VARCHAR2(255)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6349 d26296e5957">
<p>Start partition of a range of accessed partitions. It can take one of the following values:</p>
<p><span class="italic">n</span> indicates that the start partition has been identified by the SQL compiler, and its partition number is given by <span class="italic">n</span>.</p>
<p><code class="codeph">KEY</code> indicates that the start partition is identified at run time from partitioning key values.</p>
<p><code class="codeph">ROW REMOVE_LOCATION</code> indicates that the database computes the start partition (same as the stop partition) at run time from the location of each retrieved record. The record location is obtained by a user or from a global index.</p>
<p><code class="codeph">INVALID</code> indicates that the range of accessed partitions is empty.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6380" headers="d26296e5951">
<p><code class="codeph">PARTITION_STOP</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6380 d26296e5954">
<p><code class="codeph">VARCHAR2(255)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6380 d26296e5957">
<p>Stop partition of a range of accessed partitions. It can take one of the following values:</p>
<p><span class="italic">n</span> indicates that the stop partition has been identified by the SQL compiler, and its partition number is given by <span class="italic">n</span>.</p>
<p><code class="codeph">KEY</code> indicates that the stop partition is identified at run time from partitioning key values.</p>
<p><code class="codeph">ROW</code> <code class="codeph">REMOVE_LOCATION</code> indicates that the database computes the stop partition (same as the start partition) at run time from the location of each retrieved record. The record location is obtained by a user or from a global index.</p>
<p><code class="codeph">INVALID</code> indicates that the range of accessed partitions is empty.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6414" headers="d26296e5951">
<p><code class="codeph">PARTITION_ID</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6414 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6414 d26296e5957">
<p>Step that has computed the pair of values of the <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> columns.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6432" headers="d26296e5951">
<p><code class="codeph">OTHER</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6432 d26296e5954">
<p><code class="codeph">LONG</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6432 d26296e5957">
<p>Other information that is specific to the execution step that a user might find useful. See the <code class="codeph">OTHER_TAG</code> column.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6447" headers="d26296e5951">
<p><code class="codeph">DISTRIBUTION</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6447 d26296e5954">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6447 d26296e5957">
<p>Method used to distribute rows from producer query servers to consumer query servers.</p>
<p>See <span class="q">&#34;<a href="tgsql_interp.htm#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGGGBCH" title="This table describes the values that can appear in the DISTRIBUTION column of the PLAN_TABLE.">Table 7-6</a>&#34;</span> for more information about the possible values for this column. For more information about consumer and producer query servers, see <a class="olink GUID-1C6BC851-DE4A-4651-9813-3E70023C8264" target="_blank" href="../VLDBG/GUID-1C6BC851-DE4A-4651-9813-3E70023C8264.htm#GUID-1C6BC851-DE4A-4651-9813-3E70023C8264"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6473" headers="d26296e5951">
<p><code class="codeph">CPU_COST</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6473 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6473 d26296e5957">
<p>CPU cost of the operation as estimated by the query optimizer&#39;s approach. The value of this column is proportional to the number of machine cycles required for the operation. For statements that use the rule-based approach, this column is null.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6485" headers="d26296e5951">
<p><code class="codeph">IO_COST</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6485 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6485 d26296e5957">
<p>I/O cost of the operation as estimated by the query optimizer&#39;s approach. The value of this column is proportional to the number of data blocks read by the operation. For statements that use the rule-based approach, this column is null.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6497" headers="d26296e5951">
<p><code class="codeph">TEMP_SPACE</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6497 d26296e5954">
<p><code class="codeph">NUMERIC</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6497 d26296e5957">
<p>Temporary space, in bytes, used by the operation as estimated by the query optimizer&#39;s approach. For statements that use the rule-based approach, or for operations that do not use any temporary space, this column is null.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6509" headers="d26296e5951">
<p><code class="codeph">ACCESS_PREDICATES</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6509 d26296e5954">
<p><code class="codeph">VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6509 d26296e5957">
<p>Predicates used to locate rows in an access structure. For example, start or stop predicates for an index range scan.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6523" headers="d26296e5951">
<p><code class="codeph">FILTER_PREDICATES</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6523 d26296e5954">
<p><code class="codeph">VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6523 d26296e5957">
<p>Predicates used to filter rows before producing them.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6537" headers="d26296e5951">
<p><code class="codeph">PROJECTION</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6537 d26296e5954">
<p><code class="codeph">VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6537 d26296e5957">
<p>Expressions produced by the operation.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6552" headers="d26296e5951">
<p><code class="codeph">TIME</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6552 d26296e5954">
<p><code class="codeph">NUMBER(20,2)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6552 d26296e5957">
<p>Elapsed time in seconds of the operation as estimated by query optimization. For statements that use the rule-based approach, this column is null.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4888" id="d26296e6566" headers="d26296e5951">
<p><code class="codeph">QBLOCK_NAME</code></p>
</td>
<td class="cellalignment4911" headers="d26296e6566 d26296e5954">
<p><code class="codeph">VARCHAR2(30)</code></p>
</td>
<td class="cellalignment4906" headers="d26296e6566 d26296e5957">
<p>Name of the query block, either system-generated or defined by the user with the <code class="codeph">QB_NAME</code> hint.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" -->
<div class="section"></div>
<!-- class="section" -->
<div class="tblformalwide" id="GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGGGBCH">
<p class="titleintable">Table 7-6 Values of DISTRIBUTION Column of the PLAN_TABLE</p>
<table class="cellalignment4813" title="Values of DISTRIBUTION Column of the PLAN_TABLE" summary="This table describes the values that can appear in the DISTRIBUTION column of the PLAN_TABLE.">
<thead>
<tr class="cellalignment4802">
<th class="cellalignment4809" id="d26296e6593">DISTRIBUTION Text</th>
<th class="cellalignment4880" id="d26296e6596">Interpretation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4802">
<td class="cellalignment4811" id="d26296e6601" headers="d26296e6593">
<p><code class="codeph">PARTITION (ROWID)</code></p>
</td>
<td class="cellalignment4881" headers="d26296e6601 d26296e6596">
<p>Maps rows to query servers based on the partitioning of a table or index using the rowid of the row to <code class="codeph">UPDATE</code>/<code class="codeph">DELETE</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4811" id="d26296e6615" headers="d26296e6593">
<p><code class="codeph">PARTITION (KEY)</code></p>
</td>
<td class="cellalignment4881" headers="d26296e6615 d26296e6596">
<p>Maps rows to query servers based on the partitioning of a table or index using a set of columns. Used for partial partition-wise join, <code class="codeph">PARALLEL INSERT</code>, <code class="codeph">CREATE TABLE AS SELECT</code> of a partitioned table, and <code class="codeph">CREATE PARTITIONED GLOBAL INDEX</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4811" id="d26296e6632" headers="d26296e6593">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4881" headers="d26296e6632 d26296e6596">
<p>Maps rows to query servers using a hash function on the join key. Used for <code class="codeph">PARALLEL JOIN</code> or <code class="codeph">PARALLEL GROUP BY</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4811" id="d26296e6646" headers="d26296e6593">
<p><code class="codeph">RANGE</code></p>
</td>
<td class="cellalignment4881" headers="d26296e6646 d26296e6596">
<p>Maps rows to query servers using ranges of the sort key. Used when the statement contains an <code class="codeph">ORDER BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4811" id="d26296e6657" headers="d26296e6593">
<p><code class="codeph">ROUND-ROBIN</code></p>
</td>
<td class="cellalignment4881" headers="d26296e6657 d26296e6596">
<p>Randomly maps rows to query servers.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4811" id="d26296e6665" headers="d26296e6593">
<p><code class="codeph">BROADCAST</code></p>
</td>
<td class="cellalignment4881" headers="d26296e6665 d26296e6596">
<p>Broadcasts the rows of the entire table to each query server. Used for a parallel join when one table is very small compared to the other.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4811" id="d26296e6673" headers="d26296e6593">
<p><code class="codeph">QC (ORDER)</code></p>
</td>
<td class="cellalignment4881" headers="d26296e6673 d26296e6596">
<p>The QC consumes the input in order, from the first to the last query server. Used when the statement contains an <code class="codeph">ORDER BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4811" id="d26296e6684" headers="d26296e6593">
<p><code class="codeph">QC (RANDOM)</code></p>
</td>
<td class="cellalignment4881" headers="d26296e6684 d26296e6596">
<p>The QC consumes the input randomly. Used when the statement does not have an <code class="codeph">ORDER BY</code> clause.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<p><a href="tgsql_interp.htm#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGHCIFE" title="This table lists each combination of the OPERATION and OPTIONS columns of the PLAN_TABLE and their meaning within an execution plan.">Table 7-7</a> lists each combination of <code class="codeph">OPERATION</code> and <code class="codeph">OPTIONS</code> produced by the <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> statement and its meaning within an execution plan.</p>
</div>
<!-- class="section" -->
<div class="tblformalwide" id="GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGHCIFE">
<p class="titleintable">Table 7-7 <span class="italic"><span class="bold">OPERATION and OPTIONS Values Produced by EXPLAIN PLAN</span></span></p>
<table class="cellalignment4813" title="OPERATION and OPTIONS Values Produced by EXPLAIN PLAN" summary="This table lists each combination of the OPERATION and OPTIONS columns of the PLAN_TABLE and their meaning within an execution plan.">
<thead>
<tr class="cellalignment4802">
<th class="cellalignment4870" id="d26296e6726">Operation</th>
<th class="cellalignment4870" id="d26296e6729">Option</th>
<th class="cellalignment4837" id="d26296e6732">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6737" headers="d26296e6726">
<p><code class="codeph">AND-EQUAL</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6737 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e6737 d26296e6732">
<p>Operation accepting multiple sets of rowids, returning the intersection of the sets, eliminating duplicates. Used for the single-column indexes access path.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6746" headers="d26296e6726">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6746 d26296e6729">
<p><code class="codeph">CONVERSION</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6746 d26296e6732">
<p><code class="codeph">TO ROWIDS</code> converts bitmap representations to actual rowids that you can use to access the table.</p>
<p><code class="codeph">FROM ROWIDS</code> converts the rowids to a bitmap representation.</p>
<p><code class="codeph">COUNT</code> returns the number of rowids if the actual values are not needed.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6768" headers="d26296e6726">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6768 d26296e6729">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6768 d26296e6732">
<p><code class="codeph">SINGLE VALUE</code> looks up the bitmap for a single key value in the index.</p>
<p><code class="codeph">RANGE SCAN</code> retrieves bitmaps for a key value range.</p>
<p><code class="codeph">FULL SCAN</code> performs a full scan of a bitmap index if there is no start or stop key.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6790" headers="d26296e6726">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6790 d26296e6729">
<p><code class="codeph">MERGE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6790 d26296e6732">
<p>Merges several bitmaps resulting from a range scan into one bitmap.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6802" headers="d26296e6726">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6802 d26296e6729">
<p><code class="codeph">MINUS</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6802 d26296e6732">
<p>Subtracts bits of one bitmap from another. Row source is used for negated predicates. This option is usable only if there are non-negated predicates yielding a bitmap from which the subtraction can take place.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6814" headers="d26296e6726">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6814 d26296e6729">
<p><code class="codeph">OR</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6814 d26296e6732">
<p>Computes the bitwise <code class="codeph">OR</code> of two bitmaps.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6829" headers="d26296e6726">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6829 d26296e6729">
<p><code class="codeph">AND</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6829 d26296e6732">
<p>Computes the bitwise <code class="codeph">AND</code> of two bitmaps.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6844" headers="d26296e6726">
<p><code class="codeph">BITMAP</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6844 d26296e6729">
<p><code class="codeph">KEY ITERATION</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6844 d26296e6732">
<p>Takes each row from a table row source and finds the corresponding bitmap from a bitmap index. This set of bitmaps are then merged into one bitmap in a following <code class="codeph">BITMAP</code> <code class="codeph">MERGE</code> operation.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6862" headers="d26296e6726">
<p><code class="codeph">CONNECT BY</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6862 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e6862 d26296e6732">
<p>Retrieves rows in hierarchical order for a query containing a <code class="codeph">CONNECT BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6876" headers="d26296e6726">
<p><code class="codeph">CONCATENATION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6876 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e6876 d26296e6732">
<p>Operation accepting multiple sets of rows returning the union-all of the sets.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6887" headers="d26296e6726">
<p><code class="codeph">COUNT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6887 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e6887 d26296e6732">
<p>Operation counting the number of rows selected from a table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6900" headers="d26296e6726">
<p><code class="codeph">COUNT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6900 d26296e6729">
<p><code class="codeph">STOPKEY</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6900 d26296e6732">
<p>Count operation where the number of rows returned is limited by the <code class="codeph">ROWNUM</code> expression in the <code class="codeph">WHERE</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6920" headers="d26296e6726">
<p><code class="codeph">CUBE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6920 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e6920 d26296e6732">
<p>Joins a table or view on the left and a cube on the right.</p>
<p>See <a class="olink SQLRF55589" target="_blank" href="../SQLRF/sql_elements006.htm#SQLRF55589"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">NO_USE_CUBE</code> and <code class="codeph">USE_CUBE</code> hints.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6945" headers="d26296e6726">
<p><code class="codeph">CUBE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6945 d26296e6729">
<p><code class="codeph">ANTI</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6945 d26296e6732">
<p>Uses an antijoin for a table or view on the left and a cube on the right.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6958" headers="d26296e6726">
<p><code class="codeph">CUBE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6958 d26296e6729">
<p><code class="codeph">ANTI SNA</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6958 d26296e6732">
<p>Uses an antijoin (single-sided null aware) for a table or view on the left and a cube on the right. The join column on the right (cube side) is <code class="codeph">NOT NULL</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6974" headers="d26296e6726">
<p><code class="codeph">CUBE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6974 d26296e6729">
<p><code class="codeph">OUTER</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6974 d26296e6732">
<p>Uses an outer join for a table or view on the left and a cube on the right.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e6987" headers="d26296e6726">
<p><code class="codeph">CUBE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e6987 d26296e6729">
<p><code class="codeph">RIGHT SEMI</code></p>
</td>
<td class="cellalignment4838" headers="d26296e6987 d26296e6732">
<p>Uses a right semijoin for a table or view on the left and a cube on the right.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7000" headers="d26296e6726">
<p><code class="codeph">CUBE SCAN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7000 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7000 d26296e6732">
<p>Uses inner joins for all cube access.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7011" headers="d26296e6726">
<p><code class="codeph">CUBE SCAN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7011 d26296e6729">
<p><code class="codeph">PARTIAL OUTER</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7011 d26296e6732">
<p>Uses an outer join for at least one dimension, and inner joins for the other dimensions.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7023" headers="d26296e6726">
<p><code class="codeph">CUBE SCAN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7023 d26296e6729">
<p><code class="codeph">OUTER</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7023 d26296e6732">
<p>Uses outer joins for all cube access.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7035" headers="d26296e6726">
<p><code class="codeph">DOMAIN INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7035 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7035 d26296e6732">
<p>Retrieval of one or more rowids from a domain index. The options column contain information supplied by a user-defined domain index cost function, if any.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7046" headers="d26296e6726">
<p><code class="codeph">FILTER</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7046 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7046 d26296e6732">
<p>Operation accepting a set of rows, eliminates some of them, and returns the rest.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7058" headers="d26296e6726">
<p><code class="codeph">FIRST ROW</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7058 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7058 d26296e6732">
<p>Retrieval of only the first row selected by a query.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7069" headers="d26296e6726">
<p><code class="codeph">FOR UPDATE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7069 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7069 d26296e6732">
<p>Operation retrieving and locking the rows selected by a query containing a <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7086" headers="d26296e6726">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7086 d26296e6729">
<p><code class="codeph">GROUP BY</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7086 d26296e6732">
<p>Operation hashing a set of rows into groups for a query with a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7104" headers="d26296e6726">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7104 d26296e6729">
<p><code class="codeph">GROUP BY PIVOT</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7104 d26296e6732">
<p>Operation hashing a set of rows into groups for a query with a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. The <code class="codeph">PIVOT</code> option indicates a pivot-specific optimization for the <code class="codeph">HASH GROUP BY</code> operator.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7128" headers="d26296e6726">
<p><code class="codeph">HASH JOIN</code></p>
<p>(These are join operations.)</p>
</td>
<td class="cellalignment4871" headers="d26296e7128 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7128 d26296e6732">
<p>Operation joining two sets of rows and returning the result. This join method is useful for joining large data sets of data (DSS, Batch). The join condition is an efficient way of accessing the second table.</p>
<p>Query optimizer uses the smaller of the two tables/data sources to build a hash table on the join key in memory. Then it scans the larger table, probing the hash table to find the joined rows.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7143" headers="d26296e6726">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7143 d26296e6729">
<p><code class="codeph">ANTI</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7143 d26296e6732">
<p>Hash (left) antijoin</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7155" headers="d26296e6726">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7155 d26296e6729">
<p><code class="codeph">SEMI</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7155 d26296e6732">
<p>Hash (left) semijoin</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7167" headers="d26296e6726">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7167 d26296e6729">
<p><code class="codeph">RIGHT ANTI</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7167 d26296e6732">
<p>Hash right antijoin</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7179" headers="d26296e6726">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7179 d26296e6729">
<p><code class="codeph">RIGHT SEMI</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7179 d26296e6732">
<p>Hash right semijoin</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7191" headers="d26296e6726">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7191 d26296e6729">
<p><code class="codeph">OUTER</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7191 d26296e6732">
<p>Hash (left) outer join</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7203" headers="d26296e6726">
<p><code class="codeph">HASH JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7203 d26296e6729">
<p><code class="codeph">RIGHT OUTER</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7203 d26296e6732">
<p>Hash right outer join</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7216" headers="d26296e6726">
<p><code class="codeph">INDEX</code></p>
<p>(These are access methods.)</p>
</td>
<td class="cellalignment4871" headers="d26296e7216 d26296e6729">
<p><code class="codeph">UNIQUE SCAN</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7216 d26296e6732">
<p>Retrieval of a single rowid from an index.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7230" headers="d26296e6726">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7230 d26296e6729">
<p><code class="codeph">RANGE SCAN</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7230 d26296e6732">
<p>Retrieval of one or more rowids from an index. Indexed values are scanned in ascending order.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7243" headers="d26296e6726">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7243 d26296e6729">
<p><code class="codeph">RANGE SCAN DESCENDING</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7243 d26296e6732">
<p>Retrieval of one or more rowids from an index. Indexed values are scanned in descending order.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7256" headers="d26296e6726">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7256 d26296e6729">
<p><code class="codeph">FULL SCAN</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7256 d26296e6732">
<p>Retrieval of all rowids from an index when there is no start or stop key. Indexed values are scanned in ascending order.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7269" headers="d26296e6726">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7269 d26296e6729">
<p><code class="codeph">FULL SCAN DESCENDING</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7269 d26296e6732">
<p>Retrieval of all rowids from an index when there is no start or stop key. Indexed values are scanned in descending order.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7282" headers="d26296e6726">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7282 d26296e6729">
<p><code class="codeph">FAST FULL SCAN</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7282 d26296e6732">
<p>Retrieval of all rowids (and column values) using multiblock reads. No sorting order can be defined. Compares to a full table scan on only the indexed columns. Only available with the cost based optimizer.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7294" headers="d26296e6726">
<p><code class="codeph">INDEX</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7294 d26296e6729">
<p><code class="codeph">SKIP SCAN</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7294 d26296e6732">
<p>Retrieval of rowids from a concatenated index without using the leading column(s) in the index. Only available with the cost based optimizer.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7306" headers="d26296e6726">
<p><code class="codeph">INLIST ITERATOR</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7306 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7306 d26296e6732">
<p>Iterates over the next operation in the plan for each value in the <code class="codeph">IN</code>-list predicate.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7320" headers="d26296e6726">
<p><code class="codeph">INTERSECTION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7320 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7320 d26296e6732">
<p>Operation accepting two sets of rows and returning the intersection of the sets, eliminating duplicates.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7331" headers="d26296e6726">
<p><code class="codeph">MERGE JOIN</code></p>
<p>(These are join operations.)</p>
</td>
<td class="cellalignment4871" headers="d26296e7331 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7331 d26296e6732">
<p>Operation accepting two sets of rows, each sorted by a value, combining each row from one set with the matching rows from the other, and returning the result.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7344" headers="d26296e6726">
<p><code class="codeph">MERGE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7344 d26296e6729">
<p><code class="codeph">OUTER</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7344 d26296e6732">
<p>Merge join operation to perform an outer join statement.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7357" headers="d26296e6726">
<p><code class="codeph">MERGE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7357 d26296e6729">
<p><code class="codeph">ANTI</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7357 d26296e6732">
<p>Merge antijoin.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7369" headers="d26296e6726">
<p><code class="codeph">MERGE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7369 d26296e6729">
<p><code class="codeph">SEMI</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7369 d26296e6732">
<p>Merge semijoin.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7381" headers="d26296e6726">
<p><code class="codeph">MERGE JOIN</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7381 d26296e6729">
<p><code class="codeph">CARTESIAN</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7381 d26296e6732">
<p>Can result from 1 or more of the tables not having any join conditions to any other tables in the statement. Can occur even with a join and it may not be flagged as <code class="codeph">CARTESIAN</code> in the plan.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7396" headers="d26296e6726">
<p><code class="codeph">CONNECT BY</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7396 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7396 d26296e6732">
<p>Retrieval of rows in hierarchical order for a query containing a <code class="codeph">CONNECT</code> <code class="codeph">BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7413" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
<p>(These are access methods.)</p>
</td>
<td class="cellalignment4871" headers="d26296e7413 d26296e6729">
<p><code class="codeph">FULL</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7413 d26296e6732">
<p>Retrieval of all rows from a materialized view.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7427" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7427 d26296e6729">
<p><code class="codeph">SAMPLE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7427 d26296e6732">
<p>Retrieval of sampled rows from a materialized view.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7439" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7439 d26296e6729">
<p><code class="codeph">CLUSTER</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7439 d26296e6732">
<p>Retrieval of rows from a materialized view based on a value of an indexed cluster key.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7451" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7451 d26296e6729">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7451 d26296e6732">
<p>Retrieval of rows from materialized view based on hash cluster key value.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7463" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7463 d26296e6729">
<p><code class="codeph">BY ROWID RANGE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7463 d26296e6732">
<p>Retrieval of rows from a materialized view based on a rowid range.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7475" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7475 d26296e6729">
<p><code class="codeph">SAMPLE BY ROWID RANGE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7475 d26296e6732">
<p>Retrieval of sampled rows from a materialized view based on a rowid range.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7487" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7487 d26296e6729">
<p><code class="codeph">BY USER ROWID</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7487 d26296e6732">
<p>If the materialized view rows are located using user-supplied rowids.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7500" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7500 d26296e6729">
<p><code class="codeph">BY INDEX ROWID</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7500 d26296e6732">
<p>If the materialized view is nonpartitioned and rows are located using indexes.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7512" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7512 d26296e6729">
<p><code class="codeph">BY GLOBAL INDEX ROWID</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7512 d26296e6732">
<p>If the materialized view is partitioned and rows are located using only global indexes.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7524" headers="d26296e6726">
<p><code class="codeph">MAT_VIEW REWITE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7524 d26296e6729">
<p><code class="codeph">BY LOCAL INDEX ROWID</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7524 d26296e6732">
<p>If the materialized view is partitioned and rows are located using one or more local indexes and possibly some global indexes.</p>
<p>Partition Boundaries:</p>
<p>The partition boundaries might have been computed by:</p>
<p>A previous <code class="codeph">PARTITION</code> step, in which case the <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> column values replicate the values present in the <code class="codeph">PARTITION</code> step, and the <code class="codeph">PARTITION_ID</code> contains the ID of the <code class="codeph">PARTITION</code> step. Possible values for <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> are <code class="codeph">NUMBER</code>(n), <code class="codeph">KEY</code>, and <code class="codeph">INVALID</code>.</p>
<p>The <code class="codeph">MAT_VIEW REWRITE ACCESS</code> or <code class="codeph">INDEX</code> step itself, in which case the <code class="codeph">PARTITION_ID</code> contains the <code class="codeph">ID</code> of the step. Possible values for <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> are <code class="codeph">NUMBER</code>(n), <code class="codeph">KEY</code>, <code class="codeph">ROW</code> <code class="codeph">REMOVE_LOCATION</code> (<code class="codeph">MAT_VIEW REWRITE</code> <code class="codeph">ACCESS</code> only), and <code class="codeph">INVALID</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7619" headers="d26296e6726">
<p><code class="codeph">MINUS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7619 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7619 d26296e6732">
<p>Operation accepting two sets of rows and returning rows appearing in the first set but not in the second, eliminating duplicates.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7630" headers="d26296e6726">
<p><code class="codeph">NESTED LOOPS</code></p>
<p>(These are join operations.)</p>
</td>
<td class="cellalignment4871" headers="d26296e7630 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7630 d26296e6732">
<p>Operation accepting two sets of rows, an outer set and an inner set. Oracle Database compares each row of the outer set with each row of the inner set, returning rows that satisfy a condition. This join method is useful for joining small subsets of data (OLTP). The join condition is an efficient way of accessing the second table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7643" headers="d26296e6726">
<p><code class="codeph">NESTED LOOPS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7643 d26296e6729">
<p><code class="codeph">OUTER</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7643 d26296e6732">
<p>Nested loops operation to perform an outer join statement.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7655" headers="d26296e6726">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7655 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7655 d26296e6732">
<p>Iterates over the next operation in the plan for each partition in the range given by the <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> columns. <code class="codeph">PARTITION</code> describes partition boundaries applicable to a single partitioned object (table or index) or to a set of equipartitioned objects (a partitioned table and its local indexes). The partition boundaries are provided by the values of <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> of the <code class="codeph">PARTITION</code>. Refer to <a href="tgsql_interp.htm#GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D__CEGJADJA" title="This 2 column table describes execution plan views. Column 1 is the view. Column 2 describes that view.">Table 7-4</a> for valid values of partition start and stop.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7690" headers="d26296e6726">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7690 d26296e6729">
<p><code class="codeph">SINGLE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7690 d26296e6732">
<p>Access one partition.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7702" headers="d26296e6726">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7702 d26296e6729">
<p><code class="codeph">ITERATOR</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7702 d26296e6732">
<p>Access many partitions (a subset).</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7714" headers="d26296e6726">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7714 d26296e6729">
<p><code class="codeph">ALL</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7714 d26296e6732">
<p>Access all partitions.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7727" headers="d26296e6726">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7727 d26296e6729">
<p><code class="codeph">INLIST</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7727 d26296e6732">
<p>Similar to iterator, but based on an <code class="codeph">IN</code>-list predicate.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7744" headers="d26296e6726">
<p><code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7744 d26296e6729">
<p><code class="codeph">INVALID</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7744 d26296e6732">
<p>Indicates that the partition set to be accessed is empty.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7757" headers="d26296e6726">
<p><code class="codeph">PX</code> <code class="codeph">ITERATOR</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7757 d26296e6729">
<p><code class="codeph">BLOCK</code>, <code class="codeph">CHUNK</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7757 d26296e6732">
<p>Implements the division of an object into block or chunk ranges among a set of parallel execution servers.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7775" headers="d26296e6726">
<p><code class="codeph">PX</code> <code class="codeph">COORDINATOR</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7775 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7775 d26296e6732">
<p>Implements the Query Coordinator which controls, schedules, and executes the parallel plan below it using parallel execution servers. It also represents a serialization point, as the end of the part of the plan executed in parallel and always has a <code class="codeph">PX SEND QC</code> operation below it.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7792" headers="d26296e6726">
<p><code class="codeph">PX</code> <code class="codeph">PARTITION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7792 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7792 d26296e6732">
<p>Same semantics as the regular <code class="codeph">PARTITION</code> operation except that it appears in a parallel plan.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7810" headers="d26296e6726">
<p><code class="codeph">PX</code> <code class="codeph">RECEIVE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7810 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7810 d26296e6732">
<p>Shows the consumer/receiver parallel execution node reading repartitioned data from a send/producer (QC or parallel execution server) executing on a PX SEND node. This information was formerly displayed into the <code class="codeph">DISTRIBUTION</code> column. See <a href="tgsql_interp.htm#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGJACGD" title="This table describes the columns in the PLAN_TABLE used by the EXPLAIN PLAN statement.">Table 7-5</a>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7832" headers="d26296e6726">
<p><code class="codeph">PX</code> <code class="codeph">SEND</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7832 d26296e6729">
<p><code class="codeph">QC</code> <code class="codeph">(RANDOM), HASH</code>, <code class="codeph">RANGE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7832 d26296e6732">
<p>Implements the distribution method taking place between two sets of parallel execution servers. Shows the boundary between two sets and how data is repartitioned on the send/producer side (QC or side. This information was formerly displayed into the <code class="codeph">DISTRIBUTION</code> column. See <a href="tgsql_interp.htm#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__CEGJACGD" title="This table describes the columns in the PLAN_TABLE used by the EXPLAIN PLAN statement.">Table 7-5</a>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7862" headers="d26296e6726">
<p><code class="codeph">REMOTE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7862 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7862 d26296e6732">
<p>Retrieval of data from a remote database.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7873" headers="d26296e6726">
<p><code class="codeph">SEQUENCE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7873 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e7873 d26296e6732">
<p>Operation involving accessing values of a sequence.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7884" headers="d26296e6726">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7884 d26296e6729">
<p><code class="codeph">AGGREGATE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7884 d26296e6732">
<p>Retrieval of a single row that is the result of applying a group function to a group of selected rows.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7897" headers="d26296e6726">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7897 d26296e6729">
<p><code class="codeph">UNIQUE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7897 d26296e6732">
<p>Operation sorting a set of rows to eliminate duplicates.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7910" headers="d26296e6726">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7910 d26296e6729">
<p><code class="codeph">GROUP</code> <code class="codeph">BY</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7910 d26296e6732">
<p>Operation sorting a set of rows into groups for a query with a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7933" headers="d26296e6726">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7933 d26296e6729">
<p><code class="codeph">GROUP BY PIVOT</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7933 d26296e6732">
<p>Operation sorting a set of rows into groups for a query with a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. The <code class="codeph">PIVOT</code> option indicates a pivot-specific optimization for the <code class="codeph">SORT GROUP BY</code> operator.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7957" headers="d26296e6726">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7957 d26296e6729">
<p><code class="codeph">JOIN</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7957 d26296e6732">
<p>Operation sorting a set of rows before a merge-join.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7969" headers="d26296e6726">
<p><code class="codeph">SORT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e7969 d26296e6729">
<p><code class="codeph">ORDER BY</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7969 d26296e6732">
<p>Operation sorting a set of rows for a query with an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e7987" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
<p>(These are access methods.)</p>
</td>
<td class="cellalignment4871" headers="d26296e7987 d26296e6729">
<p><code class="codeph">FULL</code></p>
</td>
<td class="cellalignment4838" headers="d26296e7987 d26296e6732">
<p>Retrieval of all rows from a table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8001" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8001 d26296e6729">
<p><code class="codeph">SAMPLE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e8001 d26296e6732">
<p>Retrieval of sampled rows from a table.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8013" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8013 d26296e6729">
<p><code class="codeph">CLUSTER</code></p>
</td>
<td class="cellalignment4838" headers="d26296e8013 d26296e6732">
<p>Retrieval of rows from a table based on a value of an indexed cluster key.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8025" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8025 d26296e6729">
<p><code class="codeph">HASH</code></p>
</td>
<td class="cellalignment4838" headers="d26296e8025 d26296e6732">
<p>Retrieval of rows from table based on hash cluster key value.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8037" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8037 d26296e6729">
<p><code class="codeph">BY ROWID RANGE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e8037 d26296e6732">
<p>Retrieval of rows from a table based on a rowid range.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8049" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8049 d26296e6729">
<p><code class="codeph">SAMPLE BY ROWID RANGE</code></p>
</td>
<td class="cellalignment4838" headers="d26296e8049 d26296e6732">
<p>Retrieval of sampled rows from a table based on a rowid range.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8061" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8061 d26296e6729">
<p><code class="codeph">BY USER ROWID</code></p>
</td>
<td class="cellalignment4838" headers="d26296e8061 d26296e6732">
<p>If the table rows are located using user-supplied rowids.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8076" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8076 d26296e6729">
<p><code class="codeph">BY INDEX ROWID</code></p>
</td>
<td class="cellalignment4838" headers="d26296e8076 d26296e6732">
<p>If the table is nonpartitioned and rows are located using index(es).</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8089" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8089 d26296e6729">
<p><code class="codeph">BY GLOBAL INDEX ROWID</code></p>
</td>
<td class="cellalignment4838" headers="d26296e8089 d26296e6732">
<p>If the table is partitioned and rows are located using only global indexes.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8101" headers="d26296e6726">
<p><code class="codeph">TABLE ACCESS</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8101 d26296e6729">
<p><code class="codeph">BY LOCAL INDEX ROWID</code></p>
</td>
<td class="cellalignment4838" headers="d26296e8101 d26296e6732">
<p>If the table is partitioned and rows are located using one or more local indexes and possibly some global indexes.</p>
<p>Partition Boundaries:</p>
<p>The partition boundaries might have been computed by:</p>
<p>A previous <code class="codeph">PARTITION</code> step, in which case the <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> column values replicate the values present in the <code class="codeph">PARTITION</code> step, and the <code class="codeph">PARTITION_ID</code> contains the ID of the <code class="codeph">PARTITION</code> step. Possible values for <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> are <code class="codeph">NUMBER</code>(n), <code class="codeph">KEY</code>, and <code class="codeph">INVALID</code>.</p>
<p>The <code class="codeph">TABLE</code> <code class="codeph">ACCESS</code> or <code class="codeph">INDEX</code> step itself, in which case the <code class="codeph">PARTITION_ID</code> contains the <code class="codeph">ID</code> of the step. Possible values for <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> are <code class="codeph">NUMBER</code>(n), <code class="codeph">KEY</code>, <code class="codeph">ROW</code> <code class="codeph">REMOVE_LOCATION</code> (<code class="codeph">TABLE</code> <code class="codeph">ACCESS</code> only), and <code class="codeph">INVALID</code>.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8199" headers="d26296e6726">
<p><code class="codeph">TRANSPOSE</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8199 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e8199 d26296e6732">
<p>Operation evaluating a <code class="codeph">PIVOT</code> operation by transposing the results of <code class="codeph">GROUP BY</code> to produce the final pivoted data.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8216" headers="d26296e6726">
<p><code class="codeph">UNION</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8216 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e8216 d26296e6732">
<p>Operation accepting two sets of rows and returns the union of the sets, eliminating duplicates.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8227" headers="d26296e6726">
<p><code class="codeph">UNPIVOT</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8227 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e8227 d26296e6732">
<p>Operation that rotates data from columns into rows.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4871" id="d26296e8238" headers="d26296e6726">
<p><code class="codeph">VIEW</code></p>
</td>
<td class="cellalignment4871" headers="d26296e8238 d26296e6729">&nbsp;</td>
<td class="cellalignment4838" headers="d26296e8238 d26296e6732">
<p>Operation performing a view&#39;s query and then returning the resulting rows to another operation.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<div class="infoboxnotealso" id="GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2__GUID-23B91028-0077-472A-A9CD-35A940152D88">
<p class="notep1">See Also:</p>
<p><a class="olink REFRN29510" target="_blank" href="../REFRN/GUID-0CAFEAD1-8C79-4200-8658-947D04BDFFE2.htm#REFRN29510"><span><cite>Oracle Database Reference</cite></span></a> for more information about <code class="codeph">PLAN_TABLE</code></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="TGSQL291"></a><a id="TGSQL290"></a>
<div class="props_rev_3"><a id="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA"></a>
<h3 id="TGSQL-GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA" class="sect3">DBMS_XPLAN Program Units</h3>
<div>
<p>The functions <code class="codeph">DISPLAY_PLAN</code> and <code class="codeph">DISPLAY_CURSOR</code> in <code class="codeph">DBMS_XPLAN</code> are relevant for accessing adapted plans.</p>
<div class="tblformal" id="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA__CEGCBHGJ">
<p class="titleintable">Table 7-8 DBMS_XPLAN Functions and Parameters Relevant for Adaptive Queries</p>
<table class="cellalignment4808" title="DBMS_XPLAN Functions and Parameters Relevant for Adaptive Queries" summary="This 2 column table describes DBMS_XPLAN program units. Column 1 lists the functions. Column 2 provides more information about the functions.">
<thead>
<tr class="cellalignment4802">
<th class="cellalignment4873" id="d26296e8363">Functions</th>
<th class="cellalignment4915" id="d26296e8366">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment4802">
<td class="cellalignment4877" id="d26296e8371" headers="d26296e8363">
<p><code class="codeph">DISPLAY_PLAN</code></p>
</td>
<td class="cellalignment4916" headers="d26296e8371 d26296e8366">
<p>The <code class="codeph">FORMAT</code> argument supports the modifier <code class="codeph">ADAPTIVE</code>.</p>
<p>When you specify <code class="codeph">ADAPTIVE</code>, the output includes the default plan. For each dynamic subplan, the plan shows a list of the row sources from the original that may be replaced, and the row sources that would replace them.</p>
<p>If the format argument specifies the outline display, then the function displays the hints for each option in the dynamic subplan. If the plan is not an adaptive query plan, then the function displays the default plan. When you do not specify <code class="codeph">ADAPTIVE</code>, the plan is shown as-is, but with additional comments in the Note section that show any row sources that are dynamic.</p>
</td>
</tr>
<tr class="cellalignment4802">
<td class="cellalignment4877" id="d26296e8395" headers="d26296e8363">
<p><code class="codeph">DISPLAY_CURSOR</code></p>
</td>
<td class="cellalignment4916" headers="d26296e8395 d26296e8366">
<p>The <code class="codeph">FORMAT</code> argument supports the modifier <code class="codeph">ADAPTIVE</code>.</p>
<p>When you specify <code class="codeph">ADAPTIVE</code>, the output includes:</p>
<ul style="list-style-type: disc;">
<li>
<p>The final plan. If the execution has not completed, then the output shows the current plan. This section also includes notes about run-time optimizations that affect the plan.</p>
</li>
<li>
<p>Recommended plan. In reporting mode, the output includes the plan that would be chosen based on execution statistics.</p>
</li>
<li>
<p>Dynamic plan. The output summarizes the portions of the plan that differ from the default plan chosen by the optimizer.</p>
</li>
<li>
<p>Reoptimization. The output displays the plan that would be chosen on a subsequent execution because of reoptimization.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section">
<div class="infoboxnotealso" id="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA__GUID-C6E97A92-5673-43E0-A386-FD30DB280405">
<p class="notep1">See Also:</p>
<p><a class="olink ARPLS68408" target="_blank" href="../ARPLS/d_sqltun.htm#ARPLS68408"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> to learn more about <code class="codeph">DBMS_XPLAN</code></p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment4801">
<tr>
<td class="cellalignment4834">
<table class="cellalignment4806">
<tr>
<td class="cellalignment4805"><a href="tgsql_genplan.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment4805"><a href="tgsql_pt_ops.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2013, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment4836">
<table class="cellalignment4804">
<tr>
<td class="cellalignment4805"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment4805"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment4805"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment4805"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment4805"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment4805"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>