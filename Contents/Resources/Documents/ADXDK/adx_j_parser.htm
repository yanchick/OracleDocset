<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-1659"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/XML%20Parsing%20for%20Java"></a><title>XML Parsing for Java</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="Parser for Java, Java components, parsing, creating a DOM, DOM, creating in Java, JCR 1.0 standard, JSR 170 standard, validation, DTD validating Mode, schema validation, schema validation mode, partial validation mode, auto validation mode, Parser for Java, overview, Oracle JVM, supported database, oraxml, command-line interface, XML parser, oraxml command-line interface, binary XML, saving text as, JAXP (Java API for XML Processing), XMLNode.selectNodes() method, data variables into XML, using DTDs, DTDs, external, JAR files, DTDs, Unicode in a system file, FileReader not for system files, UTF-8 output, XML output in UTF-8, UTF-16 Encoding, invalid characters, string data"/>
<meta name="dcterms.created" content="2016-12-08T13:58:19Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="XML Developer&#39;s Kit Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E54405-06"/>
<meta name="dcterms.isVersionOf" content="ADXDK"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="adx_j_gs.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adx_j_xmlbin.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E54405-06.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-33E0EA2B-A08A-462E-86B4-3F944409663D"></a> <span id="PAGE" style="display:none;">12/50</span> <!-- End Header -->
<a id="ADXDK975"></a><a id="ADXDK3000"></a>
<h1 id="ADXDK-GUID-33E0EA2B-A08A-462E-86B4-3F944409663D" class="sect1"><span class="enumeration_chapter">4</span> XML Parsing for Java</h1>
<div>
<p>This chapter explains Extensible Markup Language (XML) parsing for Java.</p>
<div class="section">
<p class="subhead1">Topics:</p>
</div>
<!-- class="section" -->
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-4BC9CC77-9343-421D-A5A0-9F073961DC75">Introduction to XML Parsing for Java</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-800D5A59-4AAC-458D-ACAC-1CF617B88CE2">Using XML Parsing for Java: Overview</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-B40FF06A-6390-4A8B-A0EB-0F8199977749">Parsing XML with DOM</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-2E469495-7D6C-4EB4-9123-6C3C0CDE1218">Parsing XML with SAX</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-FD056430-78F8-4507-8D6F-9BFB8D95EA8D">Parsing XML with JAXP</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-7C87A9E2-000B-4A33-8D86-11FDA13E1CCA">Compressing and Decompressing XML</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-BB57C7AC-2962-4617-B26F-FEE6B5114A7A">Tips and Techniques for Parsing XML</a></p>
</li>
</ul>
</div>
<a id="ADXDK976"></a><a id="ADXDK19083"></a>
<div class="props_rev_4"><a id="GUID-4BC9CC77-9343-421D-A5A0-9F073961DC75"></a>
<h2 id="ADXDK-GUID-4BC9CC77-9343-421D-A5A0-9F073961DC75" class="sect2"><span class="enumeration_section">4.1</span> Introduction to XML Parsing for Java</h2>
<div>
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-362910D4-3A78-4174-AE1E-6099AA852254">Prerequisites</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E">Standards and Specifications</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-5779A94D-7350-4678-A27E-49C710465744">XML Parsing in Java</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-972BAACB-5EC4-402B-98AA-680E2E783654">DOM in XML Parsing</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-E2FFE494-A2A8-455E-871E-0E287A956016">SDOM</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A">SAX in the XML Parser</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-706DD778-4C97-47CC-A7A5-DB9DBFD5C4C8">JAXP in the XML Parser</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E">Namespace Support in the XML Parser</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7">Validation in the XML Parser</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD">Compression in the XML Parser</a></p>
</li>
</ul>
</div>
<a id="ADXDK19084"></a>
<div class="props_rev_3"><a id="GUID-362910D4-3A78-4174-AE1E-6099AA852254"></a>
<h3 id="ADXDK-GUID-362910D4-3A78-4174-AE1E-6099AA852254" class="sect3"><span class="enumeration_section">4.1.1</span> Prerequisites</h3>
<div>
<p>An Oracle XML parser reads an XML document and uses either a Document Object Model (DOM) application programming interface (API) or Simple API for XML (SAX) to access to its content and structure. You can parse in either validating or nonvalidating mode.</p>
<p>This chapter assumes that you are familiar with these technologies:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="glossary.htm#GUID-0969F796-24C8-4A02-B671-B2EE8BD49F5B"><span class="xrefglossterm">Document Object Model (DOM)</span></a>: An in-memory tree representation of the structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-6B57591D-3889-4BCD-8598-58ED2DC9E9EE"><span class="xrefglossterm">Simple API for XML (SAX)</span></a>: A standard for event-based XML parsing.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-B2E5C8F8-E243-45AB-B95E-9FCECDE2D247"><span class="xrefglossterm">Java API for XML Processing (JAXP)</span></a>: A standard interface for processing XML with Java applications that supports the DOM and SAX standards.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-F2AC11F4-F0D2-4EFB-B28B-8114CC0D7C38"><span class="xrefglossterm">document type definition (DTD)</span></a>: A set of rules that defines the valid structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-25F8F1D2-58B2-4A3F-B38C-3C2652C9C19C"><span class="xrefglossterm">XML Schema</span></a>: A World Wide Web Consortium (W3C) recommendation that defines the valid structure of data types in an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-55AB1901-F16B-4FBD-9C2B-7164C71662B0"><span class="xrefglossterm">XML Namespaces</span></a>: A mechanism for differentiating element and attribute names within an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-B612EFFA-1150-448C-B2FC-9DC488F970A4"><span class="xrefglossterm">binary XML</span></a>: An XML representation that uses the compact schema-aware format, in which both scalable and nonscalable DOMs can save XML documents.</p>
</li>
</ul>
<p>For more information, see the list of XML resources in the <span class="q">&#34;<a href="preface.htm#GUID-2CD1F6B6-C8EC-42E3-97F2-589AABF9AFFB">Related Documents</a>.&#34;</span></p>
</div>
</div>
<a id="ADXDK19085"></a>
<div class="props_rev_3"><a id="GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E"></a>
<h3 id="ADXDK-GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E" class="sect3"><span class="enumeration_section">4.1.2</span> Standards and Specifications</h3>
<div>
<p>The DOM Level 1, Level 2, and Level 3 specifications are W3C Recommendations. For links to their specifications, see:</p>
<pre dir="ltr"><a href="http://www.w3.org/DOM/DOMTR" target="_blank">http://www.w3.org/DOM/DOMTR</a>
</pre>
<p>SAX is available in version 1.0 (deprecated) and 2.0. SAX is not a W3C specification. For SAX documentation, see:</p>
<pre dir="ltr"><a href="http://www.saxproject.org/" target="_blank">http://www.saxproject.org/</a>
</pre>
<p>XML Namespaces are a W3C Recommendation. For the specification, see:</p>
<pre dir="ltr"><a href="http://www.w3.org/TR/REC-xml-names" target="_blank">http://www.w3.org/TR/REC-xml-names</a>
</pre>
<p>JCR 1.0 (also known as JSR 170) defines a standard Java API for applications to interact with content repositories.</p>
<div class="infoboxnotealso" id="GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E__GUID-0B795078-287A-4F95-AE80-C868431A3116">
<p class="notep1">See Also:</p>
<p><a class="olink ADXDB2630" target="_blank" href="../ADXDB/xdb_jcr.htm#ADXDB2630"><span class="italic">Oracle XML DB Developer&#39;s Guide</span></a></p>
</div>
<p>JAXP is a standard API that enables use of DOM, SAX, XML Schema, and Extensible Stylesheet Language Transformation (XSLT), independent of processor implementation. For the JAXP specification and other information, see:</p>
<pre dir="ltr"><a href="http://www.oracle.com/technetwork/java/index.html" target="_blank">http://www.oracle.com/technetwork/java/index.html</a>
</pre>
<div class="infoboxnotealso" id="GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E__GUID-23ABA394-4C19-4FD5-8FB7-E8E322177423">
<p class="notep1">See Also:</p>
<p><a href="adx_ref_standards.htm#GUID-795A483B-12AC-4F6D-A606-6BE9DA963F0F">Oracle XML Developer&#39;s Kit Standards</a>, for information about standards supported by Oracle XML Developer&#39;s Kit (XDK)</p>
</div>
</div>
</div>
<a id="ADXDK19086"></a>
<div class="props_rev_3"><a id="GUID-695138D4-C21C-4467-98FC-7FE71F56116D"></a>
<h3 id="ADXDK-GUID-695138D4-C21C-4467-98FC-7FE71F56116D" class="sect3"><span class="enumeration_section">4.1.3</span> Large Node Handling</h3>
<div>
<p>DOM Stream access to XML nodes is done by Procedural Language/Structured Query Language (PL/SQL) and Java APIs. Nodes in an XML document can now far exceed 64 KB. Thus Joint Photographic Experts Group (JPEG), Word, PDF, rich text format (RTF), and HTML documents can be more readily stored.</p>
<div class="infoboxnotealso" id="GUID-695138D4-C21C-4467-98FC-7FE71F56116D__GUID-2E506D5D-0277-4D88-B2DE-C3559E99A68E">
<p class="notep1">See Also:</p>
<p><a class="olink ADXDB1150" target="_blank" href="../ADXDB/xdb11jav.htm#ADXDB1150"><span class="italic">Oracle XML DB Developer&#39;s Guide</span></a> for complete details on the Java large node capabilities</p>
</div>
</div>
</div>
<a id="ADXDK19088"></a><a id="ADXDK19089"></a><a id="ADXDK19087"></a>
<div class="props_rev_3"><a id="GUID-5779A94D-7350-4678-A27E-49C710465744"></a>
<h3 id="ADXDK-GUID-5779A94D-7350-4678-A27E-49C710465744" class="sect3"><span class="enumeration_section">4.1.4</span> XML Parsing in Java</h3>
<div>
<p><code>XMLParser</code> is the abstract base class for the XML parser for Java. An instantiated parser invokes the <code>parse()</code> method to read an XML document.</p>
<p><code>XMLDOMImplementation</code> factory methods provide another way to parse binary XML to create scalable DOM.</p>
<p><a href="adx_j_parser.htm#GUID-5779A94D-7350-4678-A27E-49C710465744__i1041301">Figure 4-1</a> shows the basic parsing process, using <code>XMLParser</code>. The figure does not apply to <code>XMLDOMImplementation()</code>.</p>
<div class="figure" id="GUID-5779A94D-7350-4678-A27E-49C710465744__i1041301">
<p class="titleinfigure">Figure 4-1 XML Parser Process</p>
<img width="363" height="326" src="img/GUID-69513AE4-AEC6-4694-BACF-5DE515A03E67-default.gif" alt="Description of Figure 4-1 follows" title="Description of Figure 4-1 follows"/><br/>
<a href="img_text/GUID-69513AE4-AEC6-4694-BACF-5DE515A03E67-print.htm">Description of &#34;Figure 4-1 XML Parser Process&#34;</a></div>
<!-- class="figure" -->
<p>These APIs provide a Java application with access to a parsed XML document:</p>
<ul style="list-style-type: disc;">
<li>
<p>DOM API</p>
<p>DOM API parses XML documents and builds a tree representation of the documents in memory. To parse with DOM API, use either a <code>DOMParser</code> object or the <code>XMLDOMImplementation</code> interface factory methods to create a pluggable, scalable DOM (SDOM).</p>
</li>
<li>
<p>SAX API</p>
<p>SAX API processes an XML document as a stream of events, which means that a program cannot access random locations in a document. To parse with SAX API, use a <code>SAXParser</code> object.</p>
</li>
<li>
<p>JAXP</p>
<p>JAXP is a Java-specific API that supports DOM, SAX, and Extensible Stylesheet Language (XSL). To parse with JAXP, use a <code>DocumentBuilder</code> or <code>SAXParser</code> object.</p>
</li>
</ul>
<p>Subsequent topics use the sample XML document in <a href="adx_j_parser.htm#GUID-5779A94D-7350-4678-A27E-49C710465744__CCHHDCHF">Example 4-1</a> to show the differences among DOM, SAX, and JAXP.</p>
<div class="example" id="GUID-5779A94D-7350-4678-A27E-49C710465744__CCHHDCHF">
<p class="titleinexample">Example 4-1 Sample XML Document</p>
<pre dir="ltr">&lt;?xml version=&#34;1.0&#34;?&gt;
  &lt;EMPLIST&gt;
    &lt;EMP&gt;
     &lt;ENAME&gt;MARY&lt;/ENAME&gt;
    &lt;/EMP&gt;
    &lt;EMP&gt;
     &lt;ENAME&gt;SCOTT&lt;/ENAME&gt;
    &lt;/EMP&gt;
  &lt;/EMPLIST&gt;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDK19090"></a>
<div class="props_rev_3"><a id="GUID-972BAACB-5EC4-402B-98AA-680E2E783654"></a>
<h3 id="ADXDK-GUID-972BAACB-5EC4-402B-98AA-680E2E783654" class="sect3"><span class="enumeration_section">4.1.5</span> DOM in XML Parsing</h3>
<div>
<p>DOM API builds an in-memory tree representation of the XML document. For example, given the document described in <a href="adx_j_parser.htm#GUID-5779A94D-7350-4678-A27E-49C710465744__CCHHDCHF">Example 4-1</a>, the DOM API creates the in-memory tree shown in <a href="adx_j_parser.htm#GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A__CCHDFAJF">Figure 4-2</a>. DOM API provides classes and methods to navigate and process the tree.</p>
<p>The important aspects of DOM API are:</p>
<ul style="list-style-type: disc;">
<li>
<p>DOM API provides a familiar tree structure of objects, making it easier to use than the SAX API.</p>
</li>
<li>
<p>The tree can be manipulated. For example, elements can be reordered and renamed, and both elements and attributes can be added and deleted.</p>
</li>
<li>
<p>Interactive applications can store the tree in memory, where users can access and manipulate it.</p>
</li>
<li>
<p>XKD includes DOM API extensions that support XPath. (Although the DOM standard does not support XPath, most XPath implementations use DOM.)</p>
</li>
<li>
<p>XDK supports SDOM. For details, see <span class="q">&#34;<a href="adx_j_parser.htm#GUID-E2FFE494-A2A8-455E-871E-0E287A956016">SDOM</a>.&#34;</span></p>
</li>
</ul>
</div>
<a id="ADXDK19091"></a>
<div class="props_rev_3"><a id="GUID-DF103B42-D957-4C1E-B433-7C81C0D1EC37"></a>
<h4 id="ADXDK-GUID-DF103B42-D957-4C1E-B433-7C81C0D1EC37" class="sect4"><span class="enumeration_section">4.1.5.1</span> DOM Creation</h4>
<div>
<p>In XDK for Java, there are three ways to create a DOM:</p>
<ul style="list-style-type: disc;">
<li>
<p>Parse a document using <code>DOMParser</code>.</p>
</li>
<li>
<p>Create a scalable DOM using <code>XMLDOMImplementation</code> factory methods.</p>
</li>
<li>
<p>Use an <code>XMLDocument</code> constructor. (This is not common.)</p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDK3400"></a>
<div class="props_rev_3"><a id="GUID-E2FFE494-A2A8-455E-871E-0E287A956016"></a>
<h3 id="ADXDK-GUID-E2FFE494-A2A8-455E-871E-0E287A956016" class="sect3"><span class="enumeration_section">4.1.6</span> SDOM</h3>
<div>
<p>XDK supports pluggable, scalable DOM (SDOM). This support relieves problems of memory inefficiency, limited scalability, and lack of control over the DOM configuration.</p>
<p>SDOM creation and configuration are mainly supported using the <code>XMLDOMImplementation</code> class.</p>
<p>Important aspects of SDOM are:</p>
<ul style="list-style-type: disc;">
<li>
<p>SDOM can use plug-in external XML in its existing forms.</p>
<p>Plug-in XML data can be in different forms&mdash;binary XML, <code>XMLType</code>, third-party DOM, and so on. SDOM need not replicate external XML in an internal representation. SDOM is created on top of plug-in XML data through the <code>Reader</code> and <code>InfosetWriter</code> abstract interfaces.</p>
</li>
<li>
<p>SDOM has transient nodes.</p>
<p>Nodes are created only if they are accessed and are freed if they are not used.</p>
</li>
<li>
<p>SDOM can use binary XML as both input and output.</p>
<p>SDOM can interact with data in two ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>Through the abstract <code>InfosetReader</code> and <code>InfosetWriter</code> interfaces.</p>
<p>To read and write <code>BinXML</code> data, users can use the <code>BinXML</code> implementation of <code>InfosetReader</code> and <code>InfosetWriter</code>. To read and write in other forms of XML infoset, users can use their own implementations.</p>
</li>
<li>
<p>Through an implementation of the <code>InfosetReader</code> and <code>InfosetWriter</code> adaptor for <code>BinXMLStream</code>.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-E2FFE494-A2A8-455E-871E-0E287A956016__GUID-FB5AC228-BDC4-43D8-90B2-60EB63F66704">
<p class="notep1">See Also:</p>
<p><a href="adx_j_xmlbin.htm#GUID-38D2C558-108C-449A-A9CD-BC2DAD163D5C">Using Binary XML with Java</a></p>
</div>
</li>
</ul>
<p>XDK SDOM support consists of:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-FDAE7477-75D4-439C-9116-45281C11406A">Pluggable DOM Support</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-3C68C8C0-D78B-4CBD-AC9D-CCC777CA03CA">Lazy Materialization</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-7088780C-4754-4732-B097-35CC02906FEC">Configurable DOM Settings</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-4A444B50-5AE6-4524-B2A6-89E60630BE0F">DOM Support for Fast Infoset</a></p>
</li>
</ul>
</div>
<a id="ADXDK19092"></a>
<div class="props_rev_3"><a id="GUID-FDAE7477-75D4-439C-9116-45281C11406A"></a>
<h4 id="ADXDK-GUID-FDAE7477-75D4-439C-9116-45281C11406A" class="sect4"><span class="enumeration_section">4.1.6.1</span> Pluggable DOM Support</h4>
<div>
<p>Pluggable DOM lets you split the DOM API from the data layer. The DOM API is separated from the data by the <code>InfosetReader</code> and <code>InfosetWriter</code> interfaces.</p>
<p>Using pluggable DOM, you can easily move XML data from one processor to another.</p>
<p>The DOM API includes unified standard APIs on top of the data to support node access, navigation, update processes, and searching capability.</p>
<div class="infoboxnotealso" id="GUID-FDAE7477-75D4-439C-9116-45281C11406A__GUID-7830DDBB-9FBD-46C0-BF77-194E62D6AB88">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="adx_j_parser.htm#GUID-0208270A-89F0-4174-9EB5-3C2960F1E8B3">Using SDOM</a>&#34;</span></p>
</div>
</div>
</div>
<a id="ADXDK19093"></a>
<div class="props_rev_3"><a id="GUID-3C68C8C0-D78B-4CBD-AC9D-CCC777CA03CA"></a>
<h4 id="ADXDK-GUID-3C68C8C0-D78B-4CBD-AC9D-CCC777CA03CA" class="sect4"><span class="enumeration_section">4.1.6.2</span> Lazy Materialization</h4>
<div>
<p>Using lazy materialization, XDK creates only nodes that are accessed and frees unused nodes from memory. Applications can process very large XML documents with improved scalability.</p>
<div class="infoboxnotealso" id="GUID-3C68C8C0-D78B-4CBD-AC9D-CCC777CA03CA__GUID-3C3BC557-4074-46DD-92ED-57887144B387">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="adx_j_parser.htm#GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D">Using Lazy Materialization</a>&#34;</span></p>
</div>
</div>
</div>
<a id="ADXDK19094"></a>
<div class="props_rev_3"><a id="GUID-7088780C-4754-4732-B097-35CC02906FEC"></a>
<h4 id="ADXDK-GUID-7088780C-4754-4732-B097-35CC02906FEC" class="sect4"><span class="enumeration_section">4.1.6.3</span> Configurable DOM Settings</h4>
<div>
<p>DOM configurations can be made to suit different applications. You can configure the DOM with different access patterns such as read-only, streaming, transient update, and shadow copy, achieving maximum memory use and performance in your applications.</p>
<div class="infoboxnotealso" id="GUID-7088780C-4754-4732-B097-35CC02906FEC__GUID-8909911C-7856-4832-8990-1BCF9E9A1B2D">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="adx_j_parser.htm#GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC">Using Configurable DOM Settings</a>&#34;</span></p>
</div>
</div>
</div>
<a id="ADXDK173"></a>
<div class="props_rev_3"><a id="GUID-4A444B50-5AE6-4524-B2A6-89E60630BE0F"></a>
<h4 id="ADXDK-GUID-4A444B50-5AE6-4524-B2A6-89E60630BE0F" class="sect4"><span class="enumeration_section">4.1.6.4</span> DOM Support for Fast Infoset</h4>
<div>
<p>Fast Infoset, developed by Oracle, is a compact binary XML format that represents the XML Infoset. This format has become the international standard ITU-T SG 17 and ISO/IEC JTC1 SC6. The Fast Infoset representation of XML Infoset is popular within the Java XML and Web Service communities.</p>
<p>Fast Infoset provides these benefits in comparison with other formats:</p>
<ul style="list-style-type: disc;">
<li>
<p>It is more compact, parses faster, and serializes better than XML text.</p>
</li>
<li>
<p>It encodes and decodes faster than parsing of XML text, and Fast Infoset documents are generally 20 to 60 percent smaller than the corresponding XML text.</p>
</li>
<li>
<p>It leads other binary XML formats in performance and compression ratio, and handles small to large documents in a more balanced manner.</p>
</li>
</ul>
<p>SDOM is the XDK DOM configuration that supports scalability. It is built on top of serialized binary data to provide a DOM API to applications like XPath and XSLT. SDOM has an open plug-in architecture that reads binary data through an abstract API InfosetReader. The InfosetReader API allows SDOM to decode the binary data going forward, remember the start location of the nodes, and search a location to decode from there. This support enables SDOM to free nodes that are not in use and re-create those nodes from binary data when they are needed. When binary data is stored externally, such as in a file or a BLOB, SDOM is highly scalable.</p>
<div class="infoboxnotealso" id="GUID-4A444B50-5AE6-4524-B2A6-89E60630BE0F__GUID-ACA4AA7E-760C-470E-9918-2EAD6C0F6E4F">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="adx_j_parser.htm#GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2">Using Fast Infoset with SDOM</a>&#34;</span></p>
</div>
</div>
</div>
</div>
<a id="ADXDK19096"></a><a id="ADXDK19095"></a>
<div class="props_rev_3"><a id="GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A"></a>
<h3 id="ADXDK-GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A" class="sect3"><span class="enumeration_section">4.1.7</span> SAX in the XML Parser</h3>
<div>
<p>Unlike DOM, SAX is event-based, so SAX API does not build in-memory tree representations of input documents. SAX API processes the input document element by element and can report events and significant data to callback methods in the application. For example, given the document described in <a href="adx_j_parser.htm#GUID-5779A94D-7350-4678-A27E-49C710465744__CCHHDCHF">Example 4-1</a>, the SAX API parses it as the series of linear events shown in <a href="adx_j_parser.htm#GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A__CCHDFAJF">Figure 4-2</a>.</p>
<p>The important aspects of SAX API are:</p>
<ul style="list-style-type: disc;">
<li>
<p>It is useful for search operations and other programs that need not manipulate an XML tree.</p>
</li>
<li>
<p>It does not consume significant memory resources.</p>
</li>
<li>
<p>It is faster than DOM when retrieving XML documents from a database.</p>
</li>
</ul>
<div class="figure" id="GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A__CCHDFAJF">
<p class="titleinfigure">Figure 4-2 Comparing DOM (Tree-Based) and SAX (Event-Based) APIs</p>
<img width="645" height="345" src="img/GUID-C98E53AF-D449-4FE5-92F3-A56B1B4FC4ED-default.gif" alt="Description of Figure 4-2 follows" title="Description of Figure 4-2 follows"/><br/>
<a href="img_text/GUID-C98E53AF-D449-4FE5-92F3-A56B1B4FC4ED-print.htm">Description of &#34;Figure 4-2 Comparing DOM (Tree-Based) and SAX (Event-Based) APIs&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="ADXDK19097"></a>
<div class="props_rev_3"><a id="GUID-706DD778-4C97-47CC-A7A5-DB9DBFD5C4C8"></a>
<h3 id="ADXDK-GUID-706DD778-4C97-47CC-A7A5-DB9DBFD5C4C8" class="sect3"><span class="enumeration_section">4.1.8</span> JAXP in the XML Parser</h3>
<div>
<p>JAXP enables you to plug in an implementation of the SAX or DOM parser. The SAX and DOM APIs provided by XDK are examples of vendor-specific implementations supported by JAXP.</p>
<p>The main advantage of JAXP is that it enables you to write interoperable applications. An application that uses features available through JAXP can very easily switch the implementation.</p>
<p>The main disadvantage of JAXP is that it runs more slowly than vendor-specific APIs. Also, JAXP lacks several features that Oracle-specific APIs provide. Some Oracle-specific features are available through the JAXP extension mechanism, but an application that uses these extensions loses the flexibility of switching implementation.</p>
</div>
</div>
<a id="ADXDK19099"></a><a id="ADXDK19100"></a><a id="ADXDK19098"></a>
<div class="props_rev_3"><a id="GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E"></a>
<h3 id="ADXDK-GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E" class="sect3"><span class="enumeration_section">4.1.9</span> Namespace Support in the XML Parser</h3>
<div>
<p>Namespaces are a mechanism to avoid name collisions between element types or attributes in XML documents.</p>
<p><a href="adx_j_parser.htm#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHBFJHA">Example 4-2</a> is an XML document that uses the <code>&lt;address&gt;</code> tag for both a company address and an employee address. An XML processor cannot distinguish between a company address and an employee address.</p>
<p><a href="adx_j_parser.htm#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">Example 4-3</a> is an XML document that uses these namespaces to distinguish between company and employee <code>&lt;address&gt;</code> tags:</p>
<pre dir="ltr">http://www.oracle.com/employee
http://www.oracle.com/company
</pre>
<p><a href="adx_j_parser.htm#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">Example 4-3</a> associates the <code>com</code> prefix with the first namespace and the <code>emp</code> prefix with the second namespace.</p>
<p>When parsing documents that use namespaces, it is helpful to remember these terms:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Namespace URI</span> is the URI assigned to <code>xmlns</code>. In <a href="adx_j_parser.htm#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">Example 4-3</a>, <code>http://www.oracle.com/employee</code> and <code>http://www.oracle.com/company</code> are namespace URIs.</p>
</li>
<li>
<p><span class="bold">Namespace prefix</span> is a namespace identifier declared with <code>xmlns</code>. In <a href="adx_j_parser.htm#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">Example 4-3</a>, <code>emp</code> and <code>com</code> are namespace prefixes.</p>
</li>
<li>
<p><span class="bold">Local name</span> is the name of an element or attribute without the namespace prefix. In <a href="adx_j_parser.htm#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">Example 4-3</a>, <code>employee</code> and <code>company</code> are local names.</p>
</li>
<li>
<p><span class="bold">Qualified name</span> is the local name plus the prefix. In <a href="adx_j_parser.htm#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">Example 4-3</a>, <code>emp:employee</code> and <code>com:company</code> are qualified names.</p>
</li>
<li>
<p><span class="bold">Expanded name</span> is the result of substituting the namespace URI for the namespace prefix. In <a href="adx_j_parser.htm#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">Example 4-3</a>, <code>http://www.oracle.com/employee:employee</code> and <code>http://www.oracle.com/company:company</code> are expanded element names.</p>
</li>
</ul>
<div class="example" id="GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHBFJHA">
<p class="titleinexample">Example 4-2 Sample XML Document Without Namespaces</p>
<pre dir="ltr">&lt;?xml version=&#39;1.0&#39;?&gt;
&lt;addresslist&gt;
  <span class="bold">&lt;company&gt;</span>
    <span class="bold">&lt;address&gt;</span>500 Oracle Parkway,
             Redwood Shores, CA 94065
    <span class="bold">&lt;/address&gt;</span>
  <span class="bold">&lt;/company&gt;</span>
  &lt;!-- ... --&gt;
  <span class="bold">&lt;employee&gt;</span>
    &lt;lastname&gt;King&lt;/lastname&gt;
    <span class="bold">&lt;address&gt;</span>3290 W Big Beaver
             Troy, MI 48084
    <span class="bold">&lt;/address&gt;</span>
  <span class="bold">&lt;/employee&gt;</span>
  &lt;!-- ... --&gt;
&lt;/addresslist&gt;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">
<p class="titleinexample">Example 4-3 Sample XML Document with Namespaces</p>
<pre dir="ltr">&lt;?xml version=&#39;1.0&#39;?&gt;
&lt;addresslist&gt;
&lt;!-- ... --&gt;
  &lt;com:company
    <span class="bold">xmlns:com=&#34;http://www.oracle.com/company/&#34;</span>&gt;
    <span class="bold">&lt;com:address&gt;</span>500 Oracle Parkway,
             Redwood Shores, CA 94065
    <span class="bold">&lt;/com:address&gt;</span>
  &lt;/com:company&gt;
  &lt;!-- ... --&gt;
  &lt;emp:employee
    <span class="bold">xmlns:emp=&#34;http://www.oracle.com/employee/&#34;</span>&gt;
    &lt;emp:lastname&gt;King&lt;/emp:lastname&gt;
    <span class="bold">&lt;emp:address&gt;</span>3290 W Big Beaver
             Troy, MI 48084
    <span class="bold">&lt;/emp:address&gt;</span>
&lt;/emp:employee&gt;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDK19102"></a><a id="ADXDK19101"></a>
<div class="props_rev_3"><a id="GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7"></a>
<h3 id="ADXDK-GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7" class="sect3"><span class="enumeration_section">4.1.10</span> Validation in the XML Parser</h3>
<div>
<p>To parse an XML document, invoke the <code>parse()</code> method. Typically, you invoke initialization and termination methods in association with the <code>parse()</code> method.</p>
<p>The parser mode can be either validating or nonvalidating. In validating mode, the parser determines whether the document conforms to the specified DTD or XML schema. In nonvalidating mode, the parser checks only for well-formedness. To set the parser mode, invoke the <code>setValidationMode()</code> method defined in <code>oracle.xml.parser.v2.XMLParser</code>.</p>
<p><a href="adx_j_parser.htm#GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__g1043218" title="Name of Mode, Mode Value in Java, and Description are the columns.">Table 4-1</a> shows the <code>setValidationMode()</code> flags that you can use in the XDK parser.</p>
<div class="tblformalwide" id="GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__g1043218">
<p class="titleintable">Table 4-1 XML Parser for Java Validation Modes</p>
<table class="cellalignment655" title="XML Parser for Java Validation Modes " summary="Name of Mode, Mode Value in Java, and Description are the columns.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment696" id="d18956e2043">Name</th>
<th class="cellalignment758" id="d18956e2046">Value</th>
<th class="cellalignment727" id="d18956e2049">The XML Parser . . .</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment699" id="d18956e2054" headers="d18956e2043">
<p>Nonvalidating mode</p>
</td>
<td class="cellalignment760" headers="d18956e2054 d18956e2046">
<p><code>NONVALIDATING</code></p>
</td>
<td class="cellalignment729" headers="d18956e2054 d18956e2049">
<p>Verifies that the XML is well-formed and parses the data.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment699" id="d18956e2065" headers="d18956e2043">
<p>DTD validating mode</p>
</td>
<td class="cellalignment760" headers="d18956e2065 d18956e2046">
<p><code>DTD_VALIDATION</code></p>
</td>
<td class="cellalignment729" headers="d18956e2065 d18956e2049">
<p>Verifies that the XML is well-formed and validates the XML data against the DTD. The DTD defined in the <code>&lt;!DOCTYPE&gt;</code> declaration must be relative to the location of the input XML document.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment699" id="d18956e2079" headers="d18956e2043">
<p>Schema validation mode</p>
</td>
<td class="cellalignment760" headers="d18956e2079 d18956e2046">
<p><code>SCHEMA_VALIDATION</code></p>
</td>
<td class="cellalignment729" headers="d18956e2079 d18956e2049">
<p>Validates the XML Document according to the XML schema specified for the document.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment699" id="d18956e2090" headers="d18956e2043">
<p>LAX validation mode</p>
</td>
<td class="cellalignment760" headers="d18956e2090 d18956e2046">
<p><code>SCHEMA_LAX_VALIDATION</code></p>
</td>
<td class="cellalignment729" headers="d18956e2090 d18956e2049">
<p>Tries to validate part or all of the instance document if it can find the schema definition. It does not raise an error if it cannot find the definition. See the sample program <code>XSDLax.java</code> in the <code>schema</code> directory.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment699" id="d18956e2107" headers="d18956e2043">
<p>Strict validation mode</p>
</td>
<td class="cellalignment760" headers="d18956e2107 d18956e2046">
<p><code>SCHEMA_STRICT_VALIDATION</code></p>
</td>
<td class="cellalignment729" headers="d18956e2107 d18956e2049">
<p>Tries to validate the whole instance document, raising errors if it cannot find the schema definition or if the instance does not conform to the definition.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment699" id="d18956e2118" headers="d18956e2043">
<p>Partial validation mode</p>
</td>
<td class="cellalignment760" headers="d18956e2118 d18956e2046">
<p><code>PARTIAL_VALIDATION</code></p>
</td>
<td class="cellalignment729" headers="d18956e2118 d18956e2049">
<p>Validates all or part of the input XML document according to the DTD, if present. If the DTD is not present, then the parser is set to nonvalidating mode.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment699" id="d18956e2129" headers="d18956e2043">
<p>Auto validation mode</p>
</td>
<td class="cellalignment760" headers="d18956e2129 d18956e2046">
<p><code>AUTO_VALIDATION</code></p>
</td>
<td class="cellalignment729" headers="d18956e2129 d18956e2049">
<p>Validates all or part of the input XML document according to the DTD or XML schema, if present. If neither is present, then the parser is set to nonvalidating mode.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>In addition to setting the validation mode with <code>setValidationMode()</code>, you can use the <code>oracle.xml.parser.schema.XSDBuilder</code> class to build an XML schema and then configure the parser to use it by invoking the <code>XMLParser.setXMLSchema()</code> method. In this case, the XML parser automatically sets the validation mode to <code>SCHEMA_STRICT_VALIDATION</code> and ignores the <code>schemaLocation</code> and <code>noNamespaceSchemaLocation</code> attributes. You can also change the validation mode to <code>SCHEMA_LAX_VALIDATION</code>. The <code>XMLParser.setDoctype()</code> method is a parallel method for DTDs, but unlike <code>setXMLSchema()</code> it does not alter the validation mode.</p>
<div class="infoboxnotealso" id="GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__GUID-EBD33428-9D47-49D4-99C1-4F3FDE7A16A0">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_sproc.htm#GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450">Using the XML Schema Processor for Java</a> to learn about validation</p>
</li>
<li>
<p><a class="olink JAXML" target="_blank" href="../JAXML/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a> to learn about the <code>XMLParser</code> and <code>XSDBuilder</code> classes</p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDK19104"></a><a id="ADXDK19103"></a>
<div class="props_rev_3"><a id="GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD"></a>
<h3 id="ADXDK-GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD" class="sect3"><span class="enumeration_section">4.1.11</span> Compression in the XML Parser</h3>
<div>
<p>You can use the XML compressor, which is implemented in the XML parser, to compress and decompress XML documents. The compression algorithm is based on tokenizing the XML tags. The assumption is that any XML document repeats some tags, so tokenizing these tags gives considerable compression. The degree of compression depends on the type of document: the larger the tags and the lesser the text content, the better the compression.</p>
<p>The Oracle XML parser generates a binary compressed output from either an in-memory DOM tree or SAX events generated from an XML document. <a href="adx_j_parser.htm#GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD__CCHHGEDF" title="This table describes differences between compression with the DOM and SAX APIs.">Table 4-2</a> describes the two types of compression.</p>
<div class="tblformalwide" id="GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD__CCHHGEDF">
<p class="titleintable">Table 4-2 XML Compression with DOM and SAX</p>
<table class="cellalignment655" title="XML Compression with DOM and SAX" summary="This table describes differences between compression with the DOM and SAX APIs.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment726" id="d18956e2287">Type</th>
<th class="cellalignment771" id="d18956e2290">Description</th>
<th class="cellalignment698" id="d18956e2293">Compression APIs</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment728" id="d18956e2298" headers="d18956e2287">
<p>DOM-based</p>
</td>
<td class="cellalignment773" headers="d18956e2298 d18956e2290">
<p>The goal is to reduce the size of the XML document without losing the structural and hierarchical information of the DOM tree. The parser serializes an in-memory DOM tree, corresponding to a parsed XML document, and generates a compressed XML output stream. The serialized stream regenerates the DOM tree when read back.</p>
</td>
<td class="cellalignment701" headers="d18956e2298 d18956e2293">
<p>Use the <code>writeExternal()</code> method to generate compressed XML and the <code>readExternal()</code> method to reconstruct it. The methods are in the <code>oracle.xml.parser.v2.XMLDocument</code> class.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment728" id="d18956e2317" headers="d18956e2287">
<p>SAX-based</p>
</td>
<td class="cellalignment773" headers="d18956e2317 d18956e2290">
<p>The SAX parser generates a compressed stream when it parses an XML file. SAX events generated by the SAX parser are handled by the SAX compression utility, which generates a compressed binary stream. When the binary stream is read back, the SAX events are generated.</p>
</td>
<td class="cellalignment701" headers="d18956e2317 d18956e2293">
<p>To generate compressed XML, instantiate <code>oracle.xml.comp.CXMLHandlerBase</code> by passing an output stream to the constructor. Pass the object to <code>SAXParser.setContentHandler()</code> and then execute the <code>parse()</code> method. Use the <code>oracle.xml.comp.CXMLParser</code> class to decompress the XML.</p>
<p><span class="bold">Note:</span> <code>CXMLHandlerBase</code> implements both SAX 1.0 and 2.0, but because 1.0 is deprecated, Oracle recommends that you use the 2.0 API.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The compressed streams generated from DOM and SAX are compatible; that is, you can use the compressed stream generated from SAX to generate the DOM tree and the reverse. As with XML documents in general, you can store the compressed XML data output in the database as a <code>BLOB</code> data item.</p>
<p>When a program parses a large XML document and creates a DOM tree in memory, it can affect performance. You can compress an XML document into a binary stream by serializing the DOM tree. You can regenerate the DOM tree without validating the XML data in the compressed stream. You can treat the compressed stream as a serialized stream, but the data in the stream is more controlled and managed than the compression implemented by Java default serialization.</p>
<div class="infobox-note" id="GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD__GUID-5883F728-AE8F-410F-9ECE-E727B29DBAB1">
<p class="notep1">Note:</p>
<p>Oracle Text cannot search a compressed XML document. Decompression reduces performance. If you are transferring files between client and server, then Hypertext Transfer Protocol (HTTP) compression can be easier.</p>
</div>
</div>
</div>
</div>
<a id="ADXDK977"></a><a id="ADXDK19105"></a>
<div class="props_rev_3"><a id="GUID-800D5A59-4AAC-458D-ACAC-1CF617B88CE2"></a>
<h2 id="ADXDK-GUID-800D5A59-4AAC-458D-ACAC-1CF617B88CE2" class="sect2"><span class="enumeration_section">4.2</span> Using XML Parsing for Java: Overview</h2>
<div>
<p>The fundamental component of any XML development is XML parsing. XML parsing for Java is a standalone XML component that parses an XML document (and possibly also a standalone DTD or XML schema) so that your program can process it.</p>
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-C9FB63BA-709F-49AD-922F-29F9E712974E">Using the XML Parser for Java: Basic Process</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-996EFA8E-2C09-46C4-839B-F607D44B815C">Running the XML Parser Demo Programs</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-204C527C-DED2-4FBA-861E-3378370529ED">Using the XML Parser Command-Line Utility (oraxml)</a></p>
</li>
</ul>
<div class="infobox-note" id="GUID-800D5A59-4AAC-458D-ACAC-1CF617B88CE2__GUID-07DFBA87-59AA-4B2F-A14D-6933592CE1F2">
<p class="notep1">Note:</p>
<p>You can use the parser with any supported Java Virtual Machine (JVM). With Oracle9<span class="italic">i</span> or later, you can load the parser into the database and use the internal Oracle JVM. For other database versions, run the parser in an external JVM and connect to a database through JDBC.</p>
</div>
</div>
<!-- class="section" --></div>
<a id="ADXDK19107"></a><a id="ADXDK19106"></a>
<div class="props_rev_3"><a id="GUID-C9FB63BA-709F-49AD-922F-29F9E712974E"></a>
<h3 id="ADXDK-GUID-C9FB63BA-709F-49AD-922F-29F9E712974E" class="sect3"><span class="enumeration_section">4.2.1</span> Using the XML Parser for Java: Basic Process</h3>
<div>
<p><a href="adx_j_parser.htm#GUID-C9FB63BA-709F-49AD-922F-29F9E712974E__i1038080">Figure 4-3</a> shows how to use the XML parser in a typical XML processing application.</p>
<div class="figure" id="GUID-C9FB63BA-709F-49AD-922F-29F9E712974E__i1038080">
<p class="titleinfigure">Figure 4-3 XML Parser for Java</p>
<img width="329" height="273" src="img/GUID-26161166-429F-4C04-9305-D3F085BC4FF7-default.gif" alt="Description of Figure 4-3 follows" title="Description of Figure 4-3 follows"/><br/>
<a href="img_text/GUID-26161166-429F-4C04-9305-D3F085BC4FF7-print.htm">Description of &#34;Figure 4-3 XML Parser for Java&#34;</a></div>
<!-- class="figure" -->
<p>The basic process of the application shown in <a href="adx_j_parser.htm#GUID-C9FB63BA-709F-49AD-922F-29F9E712974E__i1038080">Figure 4-3</a> is:</p>
<ol>
<li>
<p>The DOM or SAX parser parses input XML documents. For example, the program can parse XML data documents, DTDs, XML schemas, and XSL style sheets.</p>
</li>
<li>
<p>If you implement a validating parser, then the processor attempts to validate the XML data document against any supplied DTDs or XML schemas.</p>
</li>
</ol>
<div class="infoboxnotealso" id="GUID-C9FB63BA-709F-49AD-922F-29F9E712974E__GUID-4F46C7EC-9FF3-41B4-9002-5D4BC20DFA4C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_xslt.htm#GUID-E148A072-BDBE-40A4-A393-F4FC362382F5">Using the XSLT Processor for Java</a></p>
</li>
<li>
<p><a href="adx_j_sproc.htm#GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450">Using the XML Schema Processor for Java</a>to learn about validation</p>
</li>
<li>
<p><a class="olink JAXML" target="_blank" href="../JAXML/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a> for XML parser classes and methods</p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDK19109"></a><a id="ADXDK19108"></a>
<div class="props_rev_3"><a id="GUID-996EFA8E-2C09-46C4-839B-F607D44B815C"></a>
<h3 id="ADXDK-GUID-996EFA8E-2C09-46C4-839B-F607D44B815C" class="sect3"><span class="enumeration_section">4.2.2</span> Running the XML Parser Demo Programs</h3>
<div>
<div class="section">
<p>Demo programs for the XML parser for Java are included in <code>$ORACLE_HOME/xdk/demo/java/parser</code>. The demo programs are distributed among the subdirectories described in <a href="adx_j_parser.htm#GUID-996EFA8E-2C09-46C4-839B-F607D44B815C__CCHHGCFI" title="Describes the subdirectories of the /demo/java directory.">Table 4-3</a>.</p>
<div class="tblformalwide" id="GUID-996EFA8E-2C09-46C4-839B-F607D44B815C__CCHHGCFI">
<p class="titleintable">Table 4-3 Java Parser Demos</p>
<table class="cellalignment655" title="Java Parser Demos" summary="Describes the subdirectories of the /demo/java directory.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment757" id="d18956e2685">Directory</th>
<th class="cellalignment666" id="d18956e2688">Contents</th>
<th class="cellalignment730" id="d18956e2691">These programs ...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment759" id="d18956e2696" headers="d18956e2685">
<p><code>common</code></p>
</td>
<td class="cellalignment668" headers="d18956e2696 d18956e2688">
<pre dir="ltr">class.xml
DemoUtil.java
empl.xml
family.dtd
family.xml
iden.xsl
NSExample.xml
traversal.xml
</pre></td>
<td class="cellalignment731" headers="d18956e2696 d18956e2691">
<p>Provide XML files and Java programs for general use with the XML parser. For example, you can use the XSLT style sheet <code>iden.xsl</code> to achieve an identity transformation of the XML files. <code>DemoUtil.java</code> implements a helper method to create a URL from a file name, and is used by many other demo programs.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment759" id="d18956e2713" headers="d18956e2685">
<p><code>comp</code></p>
</td>
<td class="cellalignment668" headers="d18956e2713 d18956e2688">
<pre dir="ltr">DOMCompression.java
DOMDeCompression.java
SAXCompression.java
SAXDeCompression.java
SampleSAXHandler.java
sample.xml
xml.ser
</pre></td>
<td class="cellalignment731" headers="d18956e2713 d18956e2691">
<p>Show DOM and SAX compression:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>DOMCompression.java</code> compresses a DOM tree.</p>
</li>
<li>
<p><code>DOMDeCompression.java</code> reads back a DOM from a compressed stream.</p>
</li>
<li>
<p><code>SAXCompression.java</code> compresses the output from a SAX parser.</p>
</li>
<li>
<p><code>SAXDeCompression.java</code> regenerates SAX events from the compressed stream.</p>
</li>
<li>
<p><code>SampleSAXHandler.java</code> shows use of a handler to handle the events thrown by the SAX <code>DeCompressor</code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment759" id="d18956e2753" headers="d18956e2685">
<p><code>dom</code></p>
</td>
<td class="cellalignment668" headers="d18956e2753 d18956e2688">
<pre dir="ltr">AutoDetectEncoding.java
DOM2Namespace.java
DOMNamespace.java
DOMRangeSample.java
DOMSample.java
EventSample.java
I18nSafeXMLFileWritingSample.java
NodeIteratorSample.java
ParseXMLFromString.java
TreeWalkerSample.java
</pre></td>
<td class="cellalignment731" headers="d18956e2753 d18956e2691">
<p>Show uses of the DOM API:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>DOM2Namespace.java</code> shows how to use DOM Level 2.0 APIs.</p>
</li>
<li>
<p><code>DOMNamespace.java</code> shows how to use Namespace extensions to DOM APIs.</p>
</li>
<li>
<p><code>DOMRangeSample.java</code> shows how to use DOM Range APIs.</p>
</li>
<li>
<p><code>DOMSample.java</code> shows basic use of the DOM APIs.</p>
</li>
<li>
<p><code>EventSample.java</code> shows how to use DOM Event APIs.</p>
</li>
<li>
<p><code>NodeIteratorSample.java</code> shows how to use DOM Iterator APIs.</p>
</li>
<li>
<p><code>TreeWalkerSample.java</code> shows how to use DOM <code>TreeWalker</code> APIs.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment759" id="d18956e2803" headers="d18956e2685">
<p><code>jaxp</code></p>
</td>
<td class="cellalignment668" headers="d18956e2803 d18956e2688">
<pre dir="ltr">JAXPExamples.java
age.xsl
general.xml
jaxpone.xml
jaxpone.xsl
jaxpthree.xsl
jaxptwo.xsl
oraContentHandler.java
</pre></td>
<td class="cellalignment731" headers="d18956e2803 d18956e2691">
<p>Show various uses of the JAXP:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>JAXPExamples.java</code> provides a few examples of how to use the JAXP 1.1 API to run the Oracle engine.</p>
</li>
<li>
<p><code>oraContentHandler.java</code> implements a SAX content handler. The program invokes methods such as <code>startDocument()</code>, <code>endDocument()</code>, <code>startElement()</code>, and <code>endElement()</code> when it recognizes an XML tag.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment759" id="d18956e2837" headers="d18956e2685">
<p><code>sax</code></p>
</td>
<td class="cellalignment668" headers="d18956e2837 d18956e2688">
<pre dir="ltr">SAX2Namespace.java
SAXNamespace.java
SAXSample.java
Tokenizer.java
</pre></td>
<td class="cellalignment731" headers="d18956e2837 d18956e2691">
<p>Show various uses of the SAX APIs:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>SAX2Namespace.java</code> shows how to use SAX 2.0.</p>
</li>
<li>
<p><code>SAXNamespace.java</code> shows how to use namespace extensions to SAX APIs.</p>
</li>
<li>
<p><code>SAXSample.java</code> shows basic use of the SAX APIs.</p>
</li>
<li>
<p><code>Tokenizer.java</code> shows how to use the <code>XMLToken</code> interface APIs. The program implements the <code>XMLToken</code> interface, which must be registered with the <code>setTokenHandler()</code> method. A request for XML tokens is registered with the <code>setToken()</code> method. During tokenizing, the parser does not validate the document and does not include or read internal/external utilities.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment759" id="d18956e2881" headers="d18956e2685">
<p><code>xslt</code></p>
</td>
<td class="cellalignment668" headers="d18956e2881 d18956e2688">
<pre dir="ltr">XSLSample.java
XSLSample2.java
match.xml
match.xsl
math.xml
math.xsl
number.xml
number.xsl
position.xml
position.xsl
reverse.xml
reverse.xsl
string.xml
string.xsl
style.txt
variable.xml
variable.xsl
</pre></td>
<td class="cellalignment731" headers="d18956e2881 d18956e2691">
<p>Show the transformation of documents with XSLT:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>XSLSample.java</code> shows how to use the XSL processing capabilities of the Oracle XML parser. It transforms an input XML document with a given input style sheet. This demo builds the result of XSL transformations as a <code>DocumentFragment</code> and so does not support <code>xsl:output</code> features.</p>
</li>
<li>
<p><code>XSLSample2.java</code> transforms an input XML document with a given input style sheet. The demo streams the result of the XSL transformation and so supports <code>xsl:output</code> features.</p>
</li>
</ul>
<p><span class="bold">See Also:</span> <span class="q">&#34;<a href="adx_j_xslt.htm#GUID-A934BBC3-82AC-4620-A20F-F8AE7E6CA62E">Running the XSLT Processor Demo Programs</a>&#34;</span></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Documentation for how to compile and run the sample programs is located in the README file. The basic procedure is:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Change into the <code>$ORACLE_HOME/xdk/demo/java/parser</code> directory (UNIX) or <code>%ORACLE_HOME%\xdk\demo\java\parser</code> directory (Windows).</span></li>
<li class="stepexpand"><span>Set up your environment as described in <span class="q">&#34;<a href="adx_j_gs.htm#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720">Setting Up the XDK for Java Environment</a>&#34;</span>.</span></li>
<li class="stepexpand"><span>Change into each of these subdirectories and run <code>make</code> (UNIX) or <code>Make.bat</code> (Windows) at the command line. For example:</span>
<div>
<pre dir="ltr">cd comp;make;cd ..
cd jaxp;make;cd ..
cd sax;make;cd ..
cd dom;make;cd ..
cd xslt;make;cd ..
</pre>
<p>The make file compiles the source code in each directory, runs the programs, and writes the output for each program to a file with an <code>*.out</code> extension.</p>
</div>
</li>
<li class="stepexpand"><span>You can view the <code>*.out</code> files to view the output for the programs.</span></li>
</ol>
</div>
</div>
<a id="ADXDK19111"></a><a id="ADXDK19110"></a>
<div class="props_rev_3"><a id="GUID-204C527C-DED2-4FBA-861E-3378370529ED"></a>
<h3 id="ADXDK-GUID-204C527C-DED2-4FBA-861E-3378370529ED" class="sect3"><span class="enumeration_section">4.2.3</span> Using the XML Parser Command-Line Utility (oraxml)</h3>
<div>
<div class="section">
<p>The <code>oraxml</code> utility, which is located in <code>$ORACLE_HOME/bin</code> (UNIX) or <code>%ORACLE_HOME%\bin</code> (Windows), is a command-line interface that parses XML documents. It checks for both well-formedness and validity.</p>
<p>To use <code>oraxml</code>, ensure that:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Your <code>CLASSPATH</code> is set up as described in <span class="q">&#34;<a href="adx_j_gs.htm#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720">Setting Up the XDK for Java Environment</a>,&#34;</span> and your <code>CLASSPATH</code> environment variable references the <code>xmlparserv2.jar</code> file.</p>
</li>
<li>
<p>Your <code>PATH</code> environment variable can find the Java interpreter that comes with your version of the Java Development Kit (JDK).</p>
</li>
</ul>
<p><a href="adx_j_parser.htm#GUID-204C527C-DED2-4FBA-861E-3378370529ED__BGBCBAIE" title="Option and Purpose are the columns.">Table 4-4</a> lists the <code>oraxml</code> command-line options.</p>
<div class="tblformal" id="GUID-204C527C-DED2-4FBA-861E-3378370529ED__BGBCBAIE">
<p class="titleintable">Table 4-4 oraxml Command-Line Options</p>
<table class="cellalignment650" title="oraxml Command-Line Options " summary="Option and Purpose are the columns.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment681" id="d18956e3114">Option</th>
<th class="cellalignment682" id="d18956e3117">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3122" headers="d18956e3114">
<p>-<code>help</code></p>
</td>
<td class="cellalignment684" headers="d18956e3122 d18956e3117">
<p>Prints the help message</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3131" headers="d18956e3114">
<p>-<code>version</code></p>
</td>
<td class="cellalignment684" headers="d18956e3131 d18956e3117">
<p>Prints the release version</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3140" headers="d18956e3114">
<p>-<code>novalidate</code> <span class="italic"><code>fileName</code></span></p>
</td>
<td class="cellalignment684" headers="d18956e3140 d18956e3117">
<p>Checks whether the input file is well-formed</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3153" headers="d18956e3114">
<p>-<code>dtd</code> <span class="italic"><code>fileName</code></span></p>
</td>
<td class="cellalignment684" headers="d18956e3153 d18956e3117">
<p>Validates the input file with DTD Validation</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3166" headers="d18956e3114">
<p>-<code>schema</code> <span class="italic"><code>fileName</code></span></p>
</td>
<td class="cellalignment684" headers="d18956e3166 d18956e3117">
<p>Validates the input file with Schema Validation</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3179" headers="d18956e3114">
<p>-<code>log</code> <span class="italic"><code>logfile</code></span></p>
</td>
<td class="cellalignment684" headers="d18956e3179 d18956e3117">
<p>Writes the errors to the output log file</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3192" headers="d18956e3114">
<p>-<code>comp</code> <span class="italic"><code>fileName</code></span></p>
</td>
<td class="cellalignment684" headers="d18956e3192 d18956e3117">
<p>Compresses the input XML file</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3205" headers="d18956e3114">
<p>-<code>decomp</code> <span class="italic"><code>fileName</code></span></p>
</td>
<td class="cellalignment684" headers="d18956e3205 d18956e3117">
<p>Decompresses the input compressed file</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3218" headers="d18956e3114">
<p>-<code>enc</code> <span class="italic"><code>fileName</code></span></p>
</td>
<td class="cellalignment684" headers="d18956e3218 d18956e3117">
<p>Prints the encoding of the input file</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e3231" headers="d18956e3114">
<p>-<code>warning</code></p>
</td>
<td class="cellalignment684" headers="d18956e3231 d18956e3117">
<p>Shows warnings</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>For example, change into the <code>$ORACLE_HOME/xdk/demo/java/parser/common</code> directory. You can validate the document <code>family.xml</code> against <code>family.dtd</code> by executing this command on the command line:</p>
<pre dir="ltr">oraxml -dtd -enc family.xml
</pre>
<p>The output is:</p>
<pre dir="ltr">The encoding of the input file: UTF-8

The input XML file is parsed without errors using DTD validation mode.
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDK978"></a><a id="ADXDK19112"></a>
<div class="props_rev_3"><a id="GUID-B40FF06A-6390-4A8B-A0EB-0F8199977749"></a>
<h2 id="ADXDK-GUID-B40FF06A-6390-4A8B-A0EB-0F8199977749" class="sect2"><span class="enumeration_section">4.3</span> Parsing XML with DOM</h2>
<div>
<div class="section">
<p>The W3C standard library <code>org.w3c.dom</code> defines the <code>Document</code> class and classes for the components of a DOM. The Oracle XML parser includes the standard DOM APIs and complies with the W3C DOM recommendation. Along with <code>org.w3c.dom</code>, Oracle XML parsing includes classes that implement the DOM APIs and extend them to provide features such as printing document fragments and retrieving namespace information.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-A96D7D89-037D-4107-AAAB-8EAD0FAEBF53">Using the DOM API</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E">DOM Parser Architecture</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53">Performing Basic DOM Parsing</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-3F0DFF8C-DB04-4B9A-8C3A-AFD748258A6C">Creating SDOM</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-C198CA9B-369E-4352-AABC-3BC0A52BA642">Performing DOM Operations with Namespaces</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-736B0616-33E7-4DB2-93B8-BA6D7E441DF2">Performing DOM Operations with Events</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3">Performing DOM Operations with Ranges</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-7F97E630-D288-4D31-9880-D74B12B63FB0">Performing DOM Operations with TreeWalker</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19113"></a>
<div class="props_rev_3"><a id="GUID-A96D7D89-037D-4107-AAAB-8EAD0FAEBF53"></a>
<h3 id="ADXDK-GUID-A96D7D89-037D-4107-AAAB-8EAD0FAEBF53" class="sect3"><span class="enumeration_section">4.3.1</span> Using the DOM API</h3>
<div>
<div class="section">
<p>To implement DOM-based components in your XML application, use these classes:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code>oracle.xml.parser.v2.DOMParser</code></p>
<p>This class implements an XML 1.0 parser according to the W3C recommendation. Because <code>DOMParser</code> extends <code>XMLParser</code>, all methods of <code>XMLParser</code> are available to <code>DOMParser</code>.</p>
<div class="infoboxnotealso" id="GUID-A96D7D89-037D-4107-AAAB-8EAD0FAEBF53__GUID-82AA8D28-F0B1-44E5-BC4E-05303F2085BE">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="adx_j_parser.htm#GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E">DOM Parser Architecture</a>&#34;</span></p>
</div>
</li>
<li>
<p><code>oracle.xml.parser.v2.XMLDOMImplementation</code></p>
<p>This class contains factory methods used to create SDOM.</p>
<div class="infoboxnotealso" id="GUID-A96D7D89-037D-4107-AAAB-8EAD0FAEBF53__GUID-640DF3A0-7ADA-41F4-A452-8A30B2F07885">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="adx_j_parser.htm#GUID-3F0DFF8C-DB04-4B9A-8C3A-AFD748258A6C">Creating SDOM</a>&#34;</span></p>
</div>
</li>
</ul>
<p>You can also use the <code>DOMNamespace</code> and <code>DOM2Namespace</code> classes, which are sample programs included in <code>$ORACLE_HOME/xdk/demo/java/parser/dom</code>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19115"></a><a id="ADXDK19114"></a>
<div class="props_rev_3"><a id="GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E"></a>
<h3 id="ADXDK-GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E" class="sect3"><span class="enumeration_section">4.3.2</span> DOM Parser Architecture</h3>
<div>
<p><a href="adx_j_parser.htm#GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E__i1040902">Figure 4-4</a> shows the architecture of the DOM Parser.</p>
<div class="figure" id="GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E__i1040902">
<p class="titleinfigure">Figure 4-4 Basic Architecture of the DOM Parser</p>
<img width="666" height="566" src="img/GUID-46CF19D3-986C-493E-8BAF-09B576808C68-default.gif" alt="Description of Figure 4-4 follows" title="Description of Figure 4-4 follows"/><br/>
<a href="img_text/GUID-46CF19D3-986C-493E-8BAF-09B576808C68-print.htm">Description of &#34;Figure 4-4 Basic Architecture of the DOM Parser&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="ADXDK19118"></a><a id="ADXDK19119"></a><a id="ADXDK19120"></a><a id="ADXDK19116"></a>
<div class="props_rev_3"><a id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53"></a>
<h3 id="ADXDK-GUID-7C91F2D5-350D-4530-8988-295EF0B60D53" class="sect3"><span class="enumeration_section">4.3.3</span> Performing Basic DOM Parsing</h3>
<div>
<div class="section">
<p>The program <code>DOMSample.java</code> shows the basic steps for parsing an input XML document and accessing it through a DOM. <code>DOMSample.java</code> receives an XML file as input, parses it, and prints the elements and attributes in the DOM tree.</p>
<p>The steps, which provide possible methods and interfaces that you can use, are:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a <code>DOMParser</code> object (a parser) by invoking the <code>DOMParser()</code> constructor.</span>
<div>
<p>The code in <code>DOMSample.java</code> is:</p>
<pre dir="ltr">DOMParser parser = new DOMParser();
</pre></div>
</li>
<li class="stepexpand"><span>Configure the parser properties, using the methods in <a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHHJABF" title="This table describes methods that you can use to set various properties of the DOM parser.">Table 4-5</a>.</span>
<div>
<p>This code fragment from <code>DOMSample.java</code> specifies the error output stream, sets the validation mode to DTD validation, and enables warning messages:</p>
<pre dir="ltr">parser.setErrorStream(System.err);
parser.setValidationMode(DOMParser.DTD_VALIDATION);
parser.showWarnings(true);
</pre></div>
</li>
<li class="stepexpand"><span>Parse the input XML document by invoking the <code>parse()</code> method, which builds a tree of <code>Node</code> objects in memory.</span>
<div>
<p>This code fragment from <code>DOMSample.java</code> parses an instance of the <code>java.net.URL</code> class:</p>
<pre dir="ltr">parser.parse(url);
</pre>
<p>The XML input can be a file, a string buffer, or a URL. As the following code fragment shows, <code>DOMSample.java</code> accepts a file name as a parameter and invokes the <code>createURL</code> helper method to construct a URL object that can be passed to the parser:</p>
<pre dir="ltr">public class DOMSample
{
   static public void main(String[] argv)
   {
      try
      {
         if (argv.length != 1)
         {
            // Must pass in the name of the XML file.
            System.err.println(&#34;Usage: java DOMSample filename&#34;);
            System.exit(1);
         }
         ...
         // Generate a URL from the filename.
         URL url = DemoUtil.createURL(argv[0]);
         ...
</pre></div>
</li>
<li class="stepexpand"><span>Invoke <code>getDocument()</code> to get a handle to the root of the in-memory DOM tree, which is an <code>XMLDocument</code> object.</span>
<div>
<p>You can use this handle to access every part of the parsed XML document. The <code>XMLDocument</code> class implements the interfaces in <a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHIFIEF" title="Lists some of the interfaces implemented by XMLDocument.">Table 4-6</a>.</p>
<p>The code fragment from <code>DOMSample.java</code> is:</p>
<pre dir="ltr">XMLDocument doc = parser.getDocument();
</pre></div>
</li>
<li class="stepexpand" id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBFACH"><span>Get and manipulate DOM nodes of the retrieved document by invoking <code>XMLDocument</code> methods in <a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBDBGE" title="This table describes useful methods of the XMLDocument class.">Table 4-7</a>.</span>
<div>
<p>This code fragment from <code>DOMSample.java</code> uses the <code>DOMParser.print()</code> method to print the elements and attributes of the DOM tree:</p>
<pre dir="ltr">System.out.print(&#34;The elements are: &#34;);
printElements(doc);
 
System.out.println(&#34;The attributes of each element are: &#34;);
printElementAttributes(doc);
</pre>
<p>The following code fragment from <code>DOMSample.java</code> implements the <code>printElements()</code> method, which invokes <code>getElementsByTagName()</code> to get a list of all the elements in the DOM tree. Then the code loops through the list, invoking <code>getNodeName()</code> to print the name of each element:</p>
<pre dir="ltr">static void printElements(Document doc)
{
   NodeList nl = doc.getElementsByTagName(&#34;*&#34;);
   Node n;

   for (int i=0; i&lt;nl.getLength(); i++)
   {
      n = nl.item(i);
      System.out.print(n.getNodeName() + &#34; &#34;);
   }
 
   System.out.println();
}
</pre>
<p>The following code fragment from <code>DOMSample.java</code> implements the <code>printElementAttributes()</code> method, which invokes <code>Document.getElementsByTagName()</code> to get a list of all the elements in the DOM tree. Then the code loops through the list, invoking <code>Element.getAttributes()</code> to get the list of attributes for the element and invoking <code>Node.getNodeName()</code> to get the attribute name and <code>Node.getNodeValue()</code> to get the attribute value:</p>
<pre dir="ltr">static void printElementAttributes(Document doc)
{
   NodeList nl = doc.getElementsByTagName(&#34;*&#34;);
   Element e;
   Node n;
   NamedNodeMap nnm;
 
   String attrname;
   String attrval;
   int i, len;
 
   len = nl.getLength();

   for (int j=0; j &lt; len; j++)
   {
      e = (Element)nl.item(j);
      System.out.println(e.getTagName() + &#34;:&#34;);
      nnm = e.getAttributes();
 
      if (nnm != null)
      {
         for (i=0; i&lt;nnm.getLength(); i++)
         {
            n = nnm.item(i);
            attrname = n.getNodeName();
            attrval = n.getNodeValue();
            System.out.print(&#34; &#34; + attrname + &#34; = &#34; + attrval);
         }
      }
      System.out.println();
   }
}
</pre></div>
</li>
<li class="stepexpand"><span>Reset the parser state by invoking the <code>reset()</code> method. The parser is now ready to parse a new document.</span></li>
</ol>
<div class="section">
<p><a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHHJABF" title="This table describes methods that you can use to set various properties of the DOM parser.">Table 4-5</a> summarizes the <code>DOMParser</code> configuration methods.</p>
<div class="tblformal" id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHHJABF">
<p class="titleintable">Table 4-5 DOMParser Configuration Methods</p>
<table class="cellalignment650" title="DOMParser Configuration Methods" summary="This table describes methods that you can use to set various properties of the DOM parser.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment793" id="d18956e3874">Method</th>
<th class="cellalignment794" id="d18956e3877">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment795" id="d18956e3882" headers="d18956e3874">
<p><code>setBaseURL()</code></p>
</td>
<td class="cellalignment796" headers="d18956e3882 d18956e3877">
<p>Sets the base URL for loading external entities and DTDs. Invoke this method if the XML document is an <code>InputStream</code>.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment795" id="d18956e3893" headers="d18956e3874">
<p><code>setDoctype()</code></p>
</td>
<td class="cellalignment796" headers="d18956e3893 d18956e3877">
<p>Specifies the DTD to use when parsing.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment795" id="d18956e3901" headers="d18956e3874">
<p><code>setErrorStream()</code></p>
</td>
<td class="cellalignment796" headers="d18956e3901 d18956e3877">
<p>Creates an output stream for the output of errors and warnings.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment795" id="d18956e3909" headers="d18956e3874">
<p><code>setPreserveWhitespace()</code></p>
</td>
<td class="cellalignment796" headers="d18956e3909 d18956e3877">
<p>Instructs the parser to preserve the white space in the input XML document.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment795" id="d18956e3917" headers="d18956e3874">
<p><code>setValidationMode()</code></p>
</td>
<td class="cellalignment796" headers="d18956e3917 d18956e3877">
<p>Sets the validation mode of the parser. <a href="adx_j_parser.htm#GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__g1043218" title="Name of Mode, Mode Value in Java, and Description are the columns.">Table 4-1</a> describes the flags that you can use with this method.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment795" id="d18956e3930" headers="d18956e3874">
<p><code>showWarnings()</code></p>
</td>
<td class="cellalignment796" headers="d18956e3930 d18956e3877">
<p>Specifies whether the parser prints warnings.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHIFIEF" title="Lists some of the interfaces implemented by XMLDocument.">Table 4-6</a> summarizes the interfaces that the <code>XMLDocument</code> class implements.</p>
<div class="tblformal" id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHIFIEF">
<p class="titleintable">Table 4-6 Some Interfaces Implemented by XMLDocument</p>
<table class="cellalignment650" title="Some Interfaces Implemented by XMLDocument" summary="Lists some of the interfaces implemented by XMLDocument.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment678" id="d18956e3956">Interface</th>
<th class="cellalignment686" id="d18956e3959">What Interface Defines</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment680" id="d18956e3964" headers="d18956e3956">
<p><code>org.w3c.dom.Node</code></p>
</td>
<td class="cellalignment687" headers="d18956e3964 d18956e3959">
<p>A single node in the document tree and methods to access and process the node.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment680" id="d18956e3972" headers="d18956e3956">
<p><code>org.w3c.dom.Document</code></p>
</td>
<td class="cellalignment687" headers="d18956e3972 d18956e3959">
<p>A <code>Node</code> that represents the entire XML document.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment680" id="d18956e3983" headers="d18956e3956">
<p><code>org.w3c.dom.Element</code></p>
</td>
<td class="cellalignment687" headers="d18956e3983 d18956e3959">
<p>A <code>Node</code> that represents an XML element.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBDBGE" title="This table describes useful methods of the XMLDocument class.">Table 4-7</a> summarizes the methods for getting and manipulating DOM tree nodes.</p>
<div class="tblformal" id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBDBGE">
<p class="titleintable">Table 4-7 Methods for Getting and Manipulating DOM Tree Nodes</p>
<table class="cellalignment650" title="Methods for Getting and Manipulating DOM Tree Nodes" summary="This table describes useful methods of the XMLDocument class.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment697" id="d18956e4009">Method</th>
<th class="cellalignment777" id="d18956e4012">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4017" headers="d18956e4009">
<p><code>getAttributes()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4017 d18956e4012">
<p>Generates a <code>NamedNodeMap</code> containing the attributes of this node (if it is an element) or <code>null</code> otherwise.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4031" headers="d18956e4009">
<p><code>getElementsbyTagName()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4031 d18956e4012">
<p>Retrieves recursively all elements that match a given tag name under a certain level. This method supports the <code>*</code> tag, which matches any tag. Invoke <code>getElementsByTagName(&#34;*&#34;)</code> through the handle to the root of the document to generate a list of all elements in the document.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4045" headers="d18956e4009">
<p><code>getExpandedName()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4045 d18956e4012">
<p>Gets the expanded name of the element. This method is specified in the <code>NSName</code> interface.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4056" headers="d18956e4009">
<p><code>getLocalName()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4056 d18956e4012">
<p>Gets the local name for this element. If an element name is <code>&lt;E1:locn xmlns:E1=&#34;http://www.oracle.com/&#34;/&gt;</code>, then <code>locn</code> is the local name.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4070" headers="d18956e4009">
<p><code>getNamespaceURI()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4070 d18956e4012">
<p>Gets the namespace URI of this node, or <code>null</code> if it is unspecified. If an element name is <code>&lt;E1:locn xmlns:E1=&#34;http://www.oracle.com/&#34;/&gt;</code>, then <code>http://www.oracle.com</code> is the namespace URI.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4087" headers="d18956e4009">
<p><code>getNodeName()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4087 d18956e4012">
<p>Gets the name of a node in the DOM tree.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4095" headers="d18956e4009">
<p><code>getNodeValue()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4095 d18956e4012">
<p>Gets the value of this node, depending on its type. This node is in the <code>Node</code> interface.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4106" headers="d18956e4009">
<p><code>getPrefix()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4106 d18956e4012">
<p>Gets the namespace prefix for an element.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4114" headers="d18956e4009">
<p><code>getQualifiedName()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4114 d18956e4012">
<p>Gets the qualified name for an element. If an element name is <code>&lt;E1:locn xmlns:E1=&#34;http://www.oracle.com/&#34;/&gt;</code>, then <code>E1:locn</code> is the qualified name..</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment700" id="d18956e4128" headers="d18956e4009">
<p><code>getTagName()</code></p>
</td>
<td class="cellalignment778" headers="d18956e4128 d18956e4012">
<p>Gets the name of an element in the DOM tree.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" --></div>
</div>
<a id="ADXDK979"></a><a id="ADXDK19121"></a>
<div class="props_rev_3"><a id="GUID-3F0DFF8C-DB04-4B9A-8C3A-AFD748258A6C"></a>
<h3 id="ADXDK-GUID-3F0DFF8C-DB04-4B9A-8C3A-AFD748258A6C" class="sect3"><span class="enumeration_section">4.3.4</span> Creating SDOM</h3>
<div>
<div class="section">
<p>This section explains how to create and use a pluggable, scalable DOM (SDOM).</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-0208270A-89F0-4174-9EB5-3C2960F1E8B3">Using SDOM</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D">Using Lazy Materialization</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC">Using Configurable DOM Settings</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2">Using Fast Infoset with SDOM</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-1CF9E80D-7493-4574-B2DA-F1928F8AD552">SDOM Applications</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-D44D0697-F1FD-47B3-AE85-E101AA807FD5">XDK Java DOM Improvements</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19122"></a>
<div class="props_rev_3"><a id="GUID-0208270A-89F0-4174-9EB5-3C2960F1E8B3"></a>
<h4 id="ADXDK-GUID-0208270A-89F0-4174-9EB5-3C2960F1E8B3" class="sect4"><span class="enumeration_section">4.3.4.1</span> Using SDOM</h4>
<div>
<div class="section">
<p>SDOM has the DOM API split from the data. The underlying data can be either internal data or plug-in data, and both can be in binary XML.</p>
<p><span class="bold">Internal data</span> is XML text that has not been parsed. To be plugged in, internal data must be saved as binary XML and then parsed by the <code>DOMParser</code>. The parsed binary XML can be then be plugged into the <code>InfoSetReader</code> of the DOM API layer. The <code>InfosetReader</code> argument is the interface to the underlying XML data.</p>
<p><span class="bold">Plug-in data</span> is XML text that has been parsed, and can therefore be transferred from one processor to another.</p>
<p>To create an SDOM, you plug in XML data through the <code>InfosetReader</code> API on an <code>XMLDOMImplementation</code> object. For example:</p>
<pre dir="ltr">public Document createDocument(InfosetReader reader) throws DOMException
</pre>
<p>The <code>InfosetReader</code> API is implemented on top of <code>BinXMLStream</code>. Optional adaptors for other forms of XML data (such as dom4j, JDOM, or Java Database Connectivity (JDBC)) may also be supported. You can also plug in your own implementations.</p>
<p><code>InfosetReader</code> serves as the interface between the scalable DOM API layer and the underlying data. It is a generic, stream-based pull API that accesses XML data. The <code>InfosetReader</code> retrieves sequential events from the XML stream and queries the state and data from these events. The following code scans the XML data and retrieves the <code>QName</code>s and attributes of all elements:</p>
<pre dir="ltr">InfosetReader reader;
While (reader.hasNext())
{
   reader.next();
   if (reader.getEventType() == START_ELEMENT)
   {
        QName name = reader.getQName();
        TypedAttributeList attrList = reader.getAttributeList();
     }
}
</pre></div>
<!-- class="section" --></div>
<a id="ADXDK19123"></a>
<div class="props_rev_3"><a id="GUID-5DF8A264-91E3-4EA7-B058-BD71381A76AD"></a>
<h5 id="ADXDK-GUID-5DF8A264-91E3-4EA7-B058-BD71381A76AD" class="sect5"><span class="enumeration_section">4.3.4.1.1</span> InfosetReader Options</h5>
<div>
<p>The <code>InfosetReader</code> API supports these operations:</p>
<ul style="list-style-type: disc;">
<li>
<p>Copying (Optional, but <code>InfosetReader</code> from <code>BinXMLStream</code> always supports it)</p>
<p>To support shadow copying of DOM across documents, you can create a new copy of <code>InfosetReader</code> to ensure thread safety, using the <code>Clone</code> method. For more information, see <span class="q">&#34;<a href="adx_j_parser.htm#GUID-000BEA9C-8AAB-4C04-9BFB-A4BCBC18ACC9">Using Shadow Copy</a>&#34;</span>.</p>
</li>
<li>
<p>Moving Focus (Optional)</p>
<p>To support lazy materialization, the <code>InfosetReader</code> may have the ability to move focus to any location specified by <code>offset</code>:</p>
<pre dir="ltr">If (reader.hasSeekSupport())
   <span class="bold">reader.seek(offset</span>);
</pre>
<p>For more information, see <span class="q">&#34;<a href="adx_j_parser.htm#GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D">Using Lazy Materialization</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<a id="ADXDK19124"></a>
<div class="props_rev_3"><a id="GUID-D2842CD2-FA88-4F66-894F-2051675421AD"></a>
<h5 id="ADXDK-GUID-D2842CD2-FA88-4F66-894F-2051675421AD" class="sect5"><span class="enumeration_section">4.3.4.1.2</span> InfosetWriter</h5>
<div>
<p><code>InfosetWriter</code> is an extension of the <code>InfosetReader</code> API that supports data writing. XDK implements <code>InfosetWriter</code> on top of binary XML. You cannot modify this implementation.</p>
</div>
</div>
<a id="ADXDK19125"></a>
<div class="props_rev_3"><a id="GUID-DAF4040A-AC94-4D84-895E-2C3EC6642E2F"></a>
<h5 id="ADXDK-GUID-DAF4040A-AC94-4D84-895E-2C3EC6642E2F" class="sect5"><span class="enumeration_section">4.3.4.1.3</span> Saving XML Text as Binary XML</h5>
<div>
<div class="section">
<p>To create a scalable DOM from XML text, you must save the XML text as either binary XML or references to binary XML before you can run <code>DOMParser</code> on it.</p>
<p>To save the XML text as binary XML, set the <code>doc.save</code> argument to <code>false</code>, as in this example:</p>
<pre dir="ltr">XMLDocument doc;
InfosetWriter writer;
doc.save(writer, <span class="bold">false</span>);
writer.close();
</pre>
<p>If you know that the data source is available for deserialization, then you can save the section reference of binary XML instead of the actual data by setting the <code>doc.save</code> argument to <code>true</code>.</p>
<div class="infoboxnotealso" id="GUID-DAF4040A-AC94-4D84-895E-2C3EC6642E2F__GUID-77176928-0A9A-4A8A-A68F-34C3591FEEF7">
<p class="notep1">See Also:</p>
<p><a href="adx_j_xmlbin.htm#GUID-38D2C558-108C-449A-A9CD-BC2DAD163D5C">Using Binary XML with Java</a></p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDK1074"></a><a id="ADXDK19126"></a>
<div class="props_rev_3"><a id="GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D"></a>
<h4 id="ADXDK-GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D" class="sect4"><span class="enumeration_section">4.3.4.2</span> Using Lazy Materialization</h4>
<div>
<div class="section">
<p>Using lazy materialization, you can plug in an empty DOM, which can pull in data when needed and free (dereference) nodes when they are no longer needed. SDOM supports either manual or automatic node dereferencing.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-F0934CA5-F70E-4A1A-9001-CDCC3565FEC9">Pulling Data on Demand</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-58BABDA4-5BAE-4FD6-BE4C-E93F4D6E4294">Using Automatic Node Dereferencing</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-0EE1A341-D1A3-4418-B943-69D68A4A66BE">Using Manual Node Dereferencing</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-000BEA9C-8AAB-4C04-9BFB-A4BCBC18ACC9">Using Shadow Copy</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-EA7D0251-45FE-4E96-91F9-062BCBCDD7D3">Incorporating DOM Updates</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-4F4E67FB-711D-4E16-AB08-FC35BBEECCF1">Using the PageManager Interface to Support Internal Data</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19127"></a>
<div class="props_rev_3"><a id="GUID-F0934CA5-F70E-4A1A-9001-CDCC3565FEC9"></a>
<h5 id="ADXDK-GUID-F0934CA5-F70E-4A1A-9001-CDCC3565FEC9" class="sect5"><span class="enumeration_section">4.3.4.2.1</span> Pulling Data on Demand</h5>
<div>
<p>The plug-in DOM architecture creates an empty DOM, which contains a single <code>Document</code> node as the root of the tree. The rest of the DOM tree can be expanded later if it is accessed. A node may have unexpanded child and sibling nodes, but its parent and ancestors are always expanded. Each node maintains the <code>InfoSetReader.Offset</code> property of the next node so that the DOM can pull additional data to create the next node.</p>
<p>Depending on access method type, DOM nodes may expand more than the set of nodes returned:</p>
<div class="tblformal" id="GUID-F0934CA5-F70E-4A1A-9001-CDCC3565FEC9__GUID-9DD24819-2379-4F98-AA7B-51D9355F7FB0">
<table class="cellalignment650" summary="Lists and briefly describes the DOM node access modes.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment674" id="d18956e4912">Access Method</th>
<th class="cellalignment755" id="d18956e4915">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment676" id="d18956e4920" headers="d18956e4912">
<p>DOM Navigation</p>
</td>
<td class="cellalignment756" headers="d18956e4920 d18956e4915">
<p>Allows access to neighboring nodes such as first child, last child, parent, previous sibling, or next sibling. If node creation is needed, it is done in document order.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment676" id="d18956e4927" headers="d18956e4912">
<p>Identifier (ID) Indexing</p>
</td>
<td class="cellalignment756" headers="d18956e4927 d18956e4915">
<p>A DTD or XML schema can specify nodes with the type ID. If the DOM supports ID indexing, those nodes can be directly retrieved using the index. In scalable DOM, retrieval by index does not cause the expansion of all previous nodes, but their ancestor nodes are materialized.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment676" id="d18956e4934" headers="d18956e4912">
<p>XPath Expressions</p>
</td>
<td class="cellalignment756" headers="d18956e4934 d18956e4915">
<p>XPath evaluation can cause materialization of all intermediate nodes in memory. For example, the descendent axis &#39;//&#39; expands the whole subtree, although some nodes might be released after evaluation.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADXDK1075"></a>
<div class="props_rev_3"><a id="GUID-58BABDA4-5BAE-4FD6-BE4C-E93F4D6E4294"></a>
<h5 id="ADXDK-GUID-58BABDA4-5BAE-4FD6-BE4C-E93F4D6E4294" class="sect5"><span class="enumeration_section">4.3.4.2.2</span> Using Automatic Node Dereferencing</h5>
<div>
<div class="section">
<p>To use automatic node dereferencing, set the <code>PARTIAL_DOM</code> attribute to <code>Boolean.TRUE</code>.</p>
<p>DOM navigation support requires additional links between nodes. In automatic dereferencing mode, weak links can be automatically dereferenced during garbage collection.</p>
<p>Node release depends on link importance. Links to parent nodes cannot be dropped, because ancestors provide context for in-scope namespaces and it is difficult to retrieve dropped parent nodes using streaming APIs such as <code>InfosetReader</code>.</p>
<p>In an SDOM tree, links to parent and previous sibling nodes are strong and links to child and following sibling nodes are weak. When the JVM frees the nodes, references to them are still available in the underlying data so they can be re-created if needed.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK1076"></a>
<div class="props_rev_3"><a id="GUID-0EE1A341-D1A3-4418-B943-69D68A4A66BE"></a>
<h5 id="ADXDK-GUID-0EE1A341-D1A3-4418-B943-69D68A4A66BE" class="sect5"><span class="enumeration_section">4.3.4.2.3</span> Using Manual Node Dereferencing</h5>
<div>
<div class="section">
<p>To use manual node dereferencing, set the attribute <code>PARTIAL_DOM</code> to <code>Boolean.FALSE</code> and create the SDOM with plug-in XML data.</p>
<p>In manual dereferencing mode, there are no weak references. The application must explicitly dereference document fragments from the DOM tree. If an application processes the data in a deterministic order, then Oracle recommends avoiding the extra overhead of repeatedly releasing and re-creating nodes.</p>
<p>To manually dereference a node from all other nodes, invoke <code>freeNode()</code>. For example:</p>
<pre dir="ltr">Element root = doc.getDocumentElement();
 Node item = root.getFirstChild();
While (item != null)
{
     processItem(item);
     Node tmp = item;
     item = item.getNextSibling();
<span class="bold">     ((XMLNode)tmp).freeNode();</span>
}
</pre>
<p>Dereferencing a node does not remove it from the SDOM tree. The node can still be accessed and re-created from its parent, previous, and following siblings. However, after a node is dereferenced, a variable that holds the node throws an error when accessing the node.</p>
<div class="infobox-note" id="GUID-0EE1A341-D1A3-4418-B943-69D68A4A66BE__GUID-111AF5FD-2DD0-4B92-9184-F3715340CF91">
<p class="notep1">Note:</p>
<p>The <code>freeNode</code> invocation has no effect on a nonscalable DOM.</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19129"></a>
<div class="props_rev_3"><a id="GUID-000BEA9C-8AAB-4C04-9BFB-A4BCBC18ACC9"></a>
<h5 id="ADXDK-GUID-000BEA9C-8AAB-4C04-9BFB-A4BCBC18ACC9" class="sect5"><span class="enumeration_section">4.3.4.2.4</span> Using Shadow Copy</h5>
<div>
<p>Shadow copy avoids data replication by letting DOM nodes share their data.</p>
<p>Cloning, a common operation in XML processing, can be done lazily with SDOM.That is, the <code>copy</code> method creates only the root node of the fragment being copied, and the subtree is expanded only on demand.</p>
<p>DOM nodes themselves are not shared; their underlying data is shared. The DOM specification requires that the clone and its original have different node identities and different parent nodes.</p>
</div>
</div>
<a id="ADXDK19130"></a>
<div class="props_rev_3"><a id="GUID-EA7D0251-45FE-4E96-91F9-062BCBCDD7D3"></a>
<h5 id="ADXDK-GUID-EA7D0251-45FE-4E96-91F9-062BCBCDD7D3" class="sect5"><span class="enumeration_section">4.3.4.2.5</span> Incorporating DOM Updates</h5>
<div>
<div class="section">
<p>The DOM API supports update operations such as adding and deleting nodes and setting, deleting, changing, and inserting values. When a DOM is created by plugging in XML data, the underlying data is considered external to the DOM. DOM updates are visible from the DOM APIs but the data source remains the same. Normal update operations are available and do not interfere with each other.</p>
<p>To make a modified DOM persistent, you must explicitly save the DOM. Saving merges the changes with the original data and serializes the data in persistent storage. If you do not save a modified DOM explicitly, the changes are lost when the transaction ends.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19131"></a>
<div class="props_rev_3"><a id="GUID-4F4E67FB-711D-4E16-AB08-FC35BBEECCF1"></a>
<h5 id="ADXDK-GUID-4F4E67FB-711D-4E16-AB08-FC35BBEECCF1" class="sect5"><span class="enumeration_section">4.3.4.2.6</span> Using the PageManager Interface to Support Internal Data</h5>
<div>
<div class="section">
<p>When XML text is parsed with <code>DOMParser</code> and configured to create an SDOM, internal data is cached in the form of binary XML, and the DOM API layer is built on top of the internal data. This provides increased scalability, because the binary XML is more compact than DOM nodes.</p>
<p>For additional scalability, the SDOM can use back-end storage for binary data through the <code>PageManager</code> interface. Then, binary data can be swapped out of memory when not in use.</p>
<p>This code shows how to use the <code>PageManager</code> interface:</p>
<pre dir="ltr">DOMParser parser = new DOMParser();
parser.setAttribute(PARTIAL_DOM, Boolean.TRUE); //enable SDOM
parser.setAttribute(PAGE_MANAGER, new FilePageManager(&#34;pageFile&#34;));
...
// DOMParser other configuration
parser.parse(fileURL);
XMLDocument doc = parser.getDocument();
</pre>
<p>If you do not use the <code>PageManager</code> interface, then the parser caches the whole document as binary XML.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDK19132"></a>
<div class="props_rev_3"><a id="GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC"></a>
<h4 id="ADXDK-GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC" class="sect4"><span class="enumeration_section">4.3.4.3</span> Using Configurable DOM Settings</h4>
<div>
<div class="section">
<p>When you create a DOM with the <code>XMLDOMImplementation</code> class, you can configure the DOM for different applications and achieve maximum efficiency by using the <code>setAttribute</code> method in the <code>XMLDOMImplementation</code> class:</p>
<pre dir="ltr">public void setAttribute(String name, Object value) throws IllegalArgumentException
</pre>
<p>For SDOM, invoke <code>setAttribute</code> for the <code>PARTIAL_DOM</code> and <code>ACCESS_MODE</code> attributes.</p>
<div class="infobox-note" id="GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC__GUID-091E7B08-8F31-4BF1-BDBF-EE0C8AA81CA5">
<p class="notep1">Note:</p>
<p>New attribute values always affect the next DOM, not the current one. Therefore, you can use instances of <code>XMLDOMImplementation</code> to create DOMs with different configurations.</p>
</div>
</div>
<!-- class="section" --></div>
<a id="ADXDK1077"></a>
<div class="props_rev_3"><a id="GUID-21E3BF40-67ED-4742-A8A7-1C4687E4D187"></a>
<h5 id="ADXDK-GUID-21E3BF40-67ED-4742-A8A7-1C4687E4D187" class="sect5"><span class="enumeration_section">4.3.4.3.1</span> PARTIAL_DOM Attribute</h5>
<div>
<p>This attribute determines whether the created DOM is partial&mdash;that is, scalable. When this attribute has the value <code>TRUE</code>, the created DOM is scalable (that is, nodes that are not in use are freed and re-created when needed). When this attribute has the value <code>FALSE</code>, the created DOM is not scalable.</p>
</div>
</div>
<a id="ADXDK1078"></a>
<div class="props_rev_3"><a id="GUID-8E768BE9-0EE6-4BF5-8A20-5CAC499B40B0"></a>
<h5 id="ADXDK-GUID-8E768BE9-0EE6-4BF5-8A20-5CAC499B40B0" class="sect5"><span class="enumeration_section">4.3.4.3.2</span> ACCESS_MODE Attribute</h5>
<div>
<p>This attribute (which applies to both SDOM and nonscalable DOM) controls access to the created DOM. The <code>ACCESS_MODE</code> values, from least to most restrictive, are:</p>
<div class="tblformal" id="GUID-8E768BE9-0EE6-4BF5-8A20-5CAC499B40B0__GUID-6AAC2D0C-C6A3-4D2F-AAEB-F228DF56154A">
<table class="cellalignment650" summary="Lists ACCESS_MODE attribute values from least to most restrictive and explains their effect on DOM access and performance advantages.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment704" id="d18956e5690">Value</th>
<th class="cellalignment659" id="d18956e5693">DOM Access</th>
<th class="cellalignment681" id="d18956e5696">Performance Advantage</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment706" id="d18956e5701" headers="d18956e5690">
<p><code>UPDATEABLE</code></p>
</td>
<td class="cellalignment661" headers="d18956e5701 d18956e5693">
<p>All update operations allowed. This is the default value, for backward compatibility with the XDK DOM implementation.</p>
</td>
<td class="cellalignment683" headers="d18956e5701 d18956e5696">&nbsp;</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment706" id="d18956e5711" headers="d18956e5690">
<p><code>READ_ONLY</code></p>
</td>
<td class="cellalignment661" headers="d18956e5711 d18956e5693">
<p>No DOM update operations allowed. Node creation (for example, cloning) is allowed only if the new nodes are not added to the DOM tree.</p>
</td>
<td class="cellalignment683" headers="d18956e5711 d18956e5696">
<p>Write buffer is not created.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment706" id="d18956e5722" headers="d18956e5690">
<p><code>FORWARD_READ</code></p>
</td>
<td class="cellalignment661" headers="d18956e5722 d18956e5693">
<p>Forward navigation (for example, <code>getFirstChild().getNextSibling()</code> and <code>getLastChild()</code>) and access to parent and ancestor nodes is allowed; backward navigation (for example, <code>getPreviousSibling()</code>) is not allowed.</p>
</td>
<td class="cellalignment683" headers="d18956e5722 d18956e5696">
<p>Previous-sibling links are not created.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment706" id="d18956e5742" headers="d18956e5690">
<p><code>STREAM_READ</code></p>
</td>
<td class="cellalignment661" headers="d18956e5742 d18956e5693">
<p>Limited to the stream of nodes in document order, similar to SAX event access.</p>
<p>The current node is the last node that was accessed in document order. Applications can hold nodes in variables and revisit them, but using the DOM method to access any node before the current node (except a parent or ancestor) causes an error. For example:</p>
<ul style="list-style-type: disc;">
<li>
<p>This is allowed, although the parent is before the current node:</p>
<pre dir="ltr">Node parent = currentNode.getParentNode();
</pre></li>
<li>
<p>This causes an error unless the current node is the first child of the parent:</p>
<pre dir="ltr">Node child = parent.getFirstChild();
</pre></li>
<li>
<p>Accessing element attributes is always allowed:</p>
<pre dir="ltr">Attribute attr = parent.getFirstAttribute();
</pre></li>
</ul>
</td>
<td class="cellalignment683" headers="d18956e5742 d18956e5696">
<p>DOM maintains only parent links, not node locations; therefore, it need not re-create freed nodes.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
<a id="ADXDK174"></a>
<div class="props_rev_3"><a id="GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2"></a>
<h4 id="ADXDK-GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2" class="sect4"><span class="enumeration_section">4.3.4.4</span> Using Fast Infoset with SDOM</h4>
<div>
<div class="section">
<div class="infobox-note" id="GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2__GUID-9F2D519C-3294-44E5-AB13-C60B7E0BB823">
<p class="notep1">Note:</p>
<p>Use Fast Infoset only for input. For output, use CSX or XTI.</p>
</div>
<p>The Fast Infoset to XDK/J model enables you to use Fast Infoset techniques while working with XML content in Java. This example uses a serializer to encode XML data into a FastInfoset <code>BinaryStream</code>:</p>
<pre dir="ltr">public com.sun.xml.fastinfoset.sax.SAXDocumentSerializer getSAXDocumentSerializer();
public com.sun.xml.fastinfoset.stax.StAXDocumentSerializer getStAXDocumentSerializer();
</pre>
<p>The class <code>oracle.xml.scalable.BinaryStream</code> is the data management component that provides buffer management and an abstract paged I/O view to support decoding for different types of data storage.</p>
<p>The InfosetReader from <code>BinaryStream</code> is the implementation of <code>oracle.xml.scalable.InfosetReader</code> for the DOM to read data from binary. The implementation extends the basic decoder <code>sun.com.xml.fasterinfoset.Decoder</code> and adds support for seek and skip operations.</p>
<p>You can use Fast Infoset with Streaming API for XML (StAX) and SAX to create a DOM. To create an SDOM, you can use the routines from the preceding example and those in this example:</p>
<pre dir="ltr">String xmlFile, fiFile;
FileInputStream xin = new FileInputStream(new File(xmlFile));
XML_SAX_FI figen = new XML_SAX_FI();
FileOutputStream outfi = new FileOutputStream(new File(fiFile));
figen.parse(xin, outfi);
outfi.close();

import oracle.xml.scalable.BinaryStream;

BinaryStream stream = BinaryStream.newInstance(SUN_FI);
stream.setFile(new File(fiFile));
InfosetReader reader = stream.getInfosetReader();
XMLDOMImplementation dimp = new  XMLDOMImplementation();
dimp.setAttribute(XMLDocument.SCALABLE_DOM, Boolean.TRUE);
XMLDocument doc = (XMLDocument) dimp.createDocument(reader);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19134"></a>
<div class="props_rev_3"><a id="GUID-1CF9E80D-7493-4574-B2DA-F1928F8AD552"></a>
<h4 id="ADXDK-GUID-1CF9E80D-7493-4574-B2DA-F1928F8AD552" class="sect4"><span class="enumeration_section">4.3.4.5</span> SDOM Applications</h4>
<div>
<p>This application creates and uses an SDOM:</p>
<pre dir="ltr">XMLDOMImplementation domimpl = new XMLDOMImplementation();
domimpl.setAttribute(XMLDocument.SCALABLE_DOM, Boolean.TRUE);
domimpl.setAttribute(XMLDocument.ACCESS_MODE,XMLDocument.UPDATEABLE);
XMLDocument scalableDoc = (XMLDocument) domimpl.createDocument(reader);
</pre>
<p>The following application creates and uses an SDOM based on binary XML, which is described in <a href="adx_j_xmlbin.htm#GUID-38D2C558-108C-449A-A9CD-BC2DAD163D5C">Using Binary XML with Java</a>:</p>
<pre dir="ltr">BinXMLProcessor proc = BinXMLProcessorFactory.createProcessor();
BinXMLStream bstr = proc.createBinXMLStream();
BinXMLEncoder enc = bstr.getEncoder();
enc.setProperty(BinXMLEncoder.ENC_SCHEMA_AWARE, false);
 
SAXParser parser = new SAXParser();
parser.setContentHandler(enc.getContentHandler());
parser.setErrorHandler(enc.getErrorHandler());
parser.parse(BinXMLUtil.createURL(xmlfile));
 
BinXMLDecoder dec = bstr.getDecoder();
InfosetReader reader = dec.getReader();
XMLDOMImplementation domimpl = new XMLDOMImplementation();
domimpl.setAttribute(XMLDocument.SCALABLE_DOM, Boolean.TRUE);
XMLDocument currentDoc = (XMLDocument) domimpl.createDocument(reader);
</pre></div>
</div>
<a id="ADXDK181"></a>
<div class="props_rev_3"><a id="GUID-D44D0697-F1FD-47B3-AE85-E101AA807FD5"></a>
<h4 id="ADXDK-GUID-D44D0697-F1FD-47B3-AE85-E101AA807FD5" class="sect4"><span class="enumeration_section">4.3.4.6</span> XDK Java DOM Improvements</h4>
<div>
<p>XDK supports the DOM Level 3 Core specification, a recommendation of the W3C.</p>
<div class="infoboxnotealso" id="GUID-D44D0697-F1FD-47B3-AE85-E101AA807FD5__GUID-DAEDC723-554F-4AE0-8655-0B1ACC93C1BC">
<p class="notep1">See Also:</p>
<p><a href="http://www.w3.org/TR/DOM-Level-3-Core/" target="_blank"><code>http://www.w3.org/TR/DOM-Level-3-Core/</code></a> for more information about DOM Level 3</p>
</div>
</div>
</div>
</div>
<a id="ADXDK19135"></a>
<div class="props_rev_3"><a id="GUID-C198CA9B-369E-4352-AABC-3BC0A52BA642"></a>
<h3 id="ADXDK-GUID-C198CA9B-369E-4352-AABC-3BC0A52BA642" class="sect3"><span class="enumeration_section">4.3.5</span> Performing DOM Operations with Namespaces</h3>
<div>
<div class="section">
<p>The <code>DOM2Namespace.java</code> program shows a simple use of the parser and namespace extensions to the DOM APIs. The program receives an XML document, parses it, and prints the elements and attributes in the document.</p>
<p>This section includes some code from the <code>DOM2Namespace.java</code> program. For more detail, see the program itself.</p>
<p>The first four steps of <span class="q">&#34;<a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53">Performing Basic DOM Parsing</a>,&#34;</span> from parser creation to the <code>getDocument()</code> invocation, are basically the same for <code>DOM2Namespace.java</code>. The principal difference is in printing the DOM tree (Step <a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBFACH">5</a>). The <code>DOM2Namespace.java</code> program does this instead:</p>
<pre dir="ltr">// Print document elements
printElements(doc);
 
// Print document element attributes
System.out.println(&#34;The attributes of each element are: &#34;);
printElementAttributes(doc);
</pre>
<p>The <code>printElements()</code> method implemented by <code>DOM2Namespace.java</code> invokes <code>getElementsByTagName()</code> to get a list of all the elements in the DOM tree. It then loops through each item in the list and casts each <code>Element</code> to an <code>nsElement</code>. For each <code>nsElement</code> it invokes <code>nsElement.getPrefix()</code> to get the namespace prefix, <code>nsElement.getLocalName()</code> to get the local name, and <code>nsElement.getNamespaceURI()</code> to get the namespace URI:</p>
<pre dir="ltr">static void printElements(Document doc)
{
   NodeList nl = doc.getElementsByTagName(&#34;*&#34;);
   Element nsElement;
   String prefix;
   String localName;
   String nsName;

   System.out.println(&#34;The elements are: &#34;);
   for (int i=0; i &lt; nl.getLength(); i++)
   {
      nsElement = (Element)nl.item(i);
 
      prefix = nsElement.getPrefix();
      System.out.println(&#34;  ELEMENT Prefix Name :&#34; + prefix);
 
      localName = nsElement.getLocalName();
      System.out.println(&#34;  ELEMENT Local Name    :&#34; + localName);
 
      nsName = nsElement.getNamespaceURI();
      System.out.println(&#34;  ELEMENT Namespace     :&#34; + nsName);
   } 
   System.out.println();
}
</pre>
<p>The <code>printElementAttributes()</code> method invokes <code>Document.getElementsByTagName()</code> to get a <code>NodeList</code> of the elements in the DOM tree. It then loops through each element and invokes <code>Element.getAttributes()</code> to get the list of attributes for the element as special list called a <code>NamedNodeMap</code>. For each item in the attribute list it invokes <code>nsAttr.getPrefix()</code> to get the namespace prefix, <code>nsAttr.getLocalName()</code> to get the local name, and <code>nsAttr.getValue()</code> to get the value:</p>
<pre dir="ltr">static void printElementAttributes(Document doc)
{
   NodeList nl = doc.getElementsByTagName(&#34;*&#34;);
   Element e;
   Attr nsAttr; 
   String attrpfx;
   String attrname;
   String attrval; 
   NamedNodeMap nnm;
   int i, len;
 
   len = nl.getLength();
 
   for (int j=0; j &lt; len; j++)
   {
      e = (Element) nl.item(j);
      System.out.println(e.getTagName() + &#34;:&#34;);
 
      nnm = e.getAttributes();
 
      if (nnm != null)
      {
         for (i=0; i &lt; nnm.getLength(); i++)
         {
            nsAttr = (Attr) nnm.item(i);
 
            attrpfx = nsAttr.getPrefix();
            attrname = nsAttr.getLocalName();
            attrval = nsAttr.getNodeValue();
 
            System.out.println(&#34; &#34; + attrpfx + &#34;:&#34; + attrname + &#34; = &#34; 
                               + attrval);
         }
      }
      System.out.println();
   }
}
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19136"></a>
<div class="props_rev_3"><a id="GUID-736B0616-33E7-4DB2-93B8-BA6D7E441DF2"></a>
<h3 id="ADXDK-GUID-736B0616-33E7-4DB2-93B8-BA6D7E441DF2" class="sect3"><span class="enumeration_section">4.3.6</span> Performing DOM Operations with Events</h3>
<div>
<div class="section">
<p>The <code>EventSample.java</code> program shows how to register events with an event listener. For example, adding a node to a specified DOM element triggers an event, which causes the listener to print information about the event.</p>
<p>This section includes some code from the <code>EventSample.java</code> program. For more detail, see the program itself.</p>
<p>The <code>EventSample.java</code> program follows these steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Instantiate an event listener.</span>
<div>
<p>When a registered change triggers an event, the event is passed to the event listener, which handles it. This code fragment from <code>EventSample.java</code> shows the implementation of the listener:</p>
<pre dir="ltr">eventlistener evtlist = new eventlistener();
...
class eventlistener implements EventListener
{
   public eventlistener(){}
   public void handleEvent(Event e)
   {
      String s = &#34; Event &#34;+e.getType()+&#34; received &#34; + &#34;\n&#34;;
      s += &#34; Event is cancelable :&#34;+e.getCancelable()+&#34;\n&#34;;
      s += &#34; Event is bubbling event :&#34;+e.getBubbles()+&#34;\n&#34;;
      s += &#34; The Target is &#34; + ((Node)(e.getTarget())).getNodeName() + &#34;\n\n&#34;;
      System.out.println(s);
   }
}
</pre></div>
</li>
<li class="stepexpand"><span>Instantiate a new <code>XMLDocument</code> and then invoke <code>getImplementation()</code> to retrieve a <code>DOMImplementation</code> object.</span>
<div>
<p>Invoke the <code>hasFeature()</code> method to determine which features this implementation supports, as this code fragment from <code>EventSample.java</code> does:</p>
<pre dir="ltr">XMLDocument doc1 = new XMLDocument();
DOMImplementation impl = doc1.getImplementation();
 
System.out.println(&#34;The impl supports Events &#34;+
                   impl.hasFeature(&#34;Events&#34;, &#34;2.0&#34;));
System.out.println(&#34;The impl supports Mutation Events &#34;+
                   impl.hasFeature(&#34;MutationEvents&#34;, &#34;2.0&#34;));
</pre></div>
</li>
<li class="stepexpand"><span>Register desired events with the listener. This code fragment from <code>EventSample.java</code> registers three events on the document node:</span>
<div>
<pre dir="ltr">doc1.addEventListener(&#34;DOMNodeRemoved&#34;, evtlist, false);
doc1.addEventListener(&#34;DOMNodeInserted&#34;, evtlist, false);
doc1.addEventListener(&#34;DOMCharacterDataModified&#34;, evtlist, false);
</pre>
<p>This code fragment from <code>EventSample.java</code> creates a node of type <code>XMLElement</code> and then registers three events on the node:</p>
<pre dir="ltr">XMLElement el = (XMLElement)doc1.createElement(&#34;element&#34;);
...
el.addEventListener(&#34;DOMNodeRemoved&#34;, evtlist, false);
el.addEventListener(&#34;DOMNodeRemovedFromDocument&#34;, evtlist, false);
el.addEventListener(&#34;DOMCharacterDataModified&#34;, evtlist, false);
...
</pre></div>
</li>
<li class="stepexpand"><span>Perform actions that trigger events, which are then passed to the listener for handling, as this code fragment from <code>EventSample.java</code> does:</span>
<div>
<pre dir="ltr">att.setNodeValue(&#34;abc&#34;);
el.appendChild(el1);
el.appendChild(text);
text.setNodeValue(&#34;xyz&#34;);
doc1.removeChild(el);
</pre></div>
</li>
</ol>
</div>
</div>
<a id="ADXDK19138"></a><a id="ADXDK19137"></a>
<div class="props_rev_3"><a id="GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3"></a>
<h3 id="ADXDK-GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3" class="sect3"><span class="enumeration_section">4.3.7</span> Performing DOM Operations with Ranges</h3>
<div>
<div class="section">
<p>According to the W3C DOM specification, a <span class="bold">range</span> identifies a range of content in a <code>Document</code>, <code>DocumentFragment</code>, or <code>Attr</code>. The range selects the content between a pair of boundary points that correspond to the start and end of the range. <a href="adx_j_parser.htm#GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3__CCHBADDC" title="This table describes useful range methods in the XMLDocument class.">Table 4-8</a> describes range methods accessible through <code>XMLDocument</code>.</p>
<div class="tblformal" id="GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3__CCHBADDC">
<p class="titleintable">Table 4-8 Range Class Methods</p>
<table class="cellalignment650" title="Range Class Methods" summary="This table describes useful range methods in the XMLDocument class.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment681" id="d18956e6488">Method</th>
<th class="cellalignment682" id="d18956e6491">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e6496" headers="d18956e6488">
<p><code>cloneContents()</code></p>
</td>
<td class="cellalignment684" headers="d18956e6496 d18956e6491">
<p>Duplicates the contents of a range</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e6504" headers="d18956e6488">
<p><code>deleteContents()</code></p>
</td>
<td class="cellalignment684" headers="d18956e6504 d18956e6491">
<p>Deletes the contents of a range</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e6512" headers="d18956e6488">
<p><code>getCollapsed()</code></p>
</td>
<td class="cellalignment684" headers="d18956e6512 d18956e6491">
<p>Returns <code>TRUE</code> is the range is collapsed</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e6523" headers="d18956e6488">
<p><code>getEndContainer()</code></p>
</td>
<td class="cellalignment684" headers="d18956e6523 d18956e6491">
<p>Gets the node within which the range ends</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e6531" headers="d18956e6488">
<p><code>getStartContainer()</code></p>
</td>
<td class="cellalignment684" headers="d18956e6531 d18956e6491">
<p>Gets the node within which the range starts</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e6539" headers="d18956e6488">
<p><code>selectNode()</code></p>
</td>
<td class="cellalignment684" headers="d18956e6539 d18956e6491">
<p>Selects a node and its contents</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e6547" headers="d18956e6488">
<p><code>selectNodeContents()</code></p>
</td>
<td class="cellalignment684" headers="d18956e6547 d18956e6491">
<p>Selects the contents of a node</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e6555" headers="d18956e6488">
<p><code>setEnd()</code></p>
</td>
<td class="cellalignment684" headers="d18956e6555 d18956e6491">
<p>Sets the attributes describing the end of a range</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment683" id="d18956e6563" headers="d18956e6488">
<p><code>setStart()</code></p>
</td>
<td class="cellalignment684" headers="d18956e6563 d18956e6491">
<p>Sets the attributes describing the start of a range</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The <code>DOMRangeSample.java</code> program shows some operations that you can perform with ranges. This section includes some code from the <code>DOMRangeSample.java</code> program. For more detail, see the program itself.</p>
<p>The first four steps of the <span class="q">&#34;<a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53">Performing Basic DOM Parsing</a>,&#34;</span> from parser creation to the <code>getDocument()</code> invocation, are the same for <code>DOMRangeSample.java</code>. Then, the <code>DOMRangeSample.java</code> program follows these steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>After invoking <code>getDocument()</code> to create the <code>XMLDocument</code>, create a range object with <code>createRange()</code> and invoke <code>setStart()</code> and <code>setEnd()</code> to set its boundaries, as this code fragment from <code>DOMRangeSample.java</code> does:</span>
<div>
<pre dir="ltr">XMLDocument doc = parser.getDocument();
...
Range r = (Range) doc.createRange();
XMLNode c = (XMLNode) doc.getDocumentElement();
 
// set the boundaries
r.setStart(c,0);
r.setEnd(c,1);
</pre></div>
</li>
<li class="stepexpand"><span>Invoke <code>XMLDocument</code> methods to get information about the range and manipulate its contents.</span>
<div>
<p>This code fragment from <code>DOMRangeSample.java</code> selects and prints the contents of the current node:</p>
<pre dir="ltr">r.selectNodeContents(c);
System.out.println(r.toString());
</pre>
<p>This code fragment clones and prints the contents of a range:</p>
<pre dir="ltr">XMLDocumentFragment df =(XMLDocumentFragment) r.cloneContents();
df.print(System.out);
</pre>
<p>This code fragment gets and prints the start and end containers for the range:</p>
<pre dir="ltr">c = (XMLNode) r.getStartContainer();
System.out.println(c.getText());
c = (XMLNode) r.getEndContainer();
System.out.println(c.getText());
</pre></div>
</li>
</ol>
</div>
</div>
<a id="ADXDK19140"></a><a id="ADXDK19141"></a><a id="ADXDK19139"></a>
<div class="props_rev_3"><a id="GUID-7F97E630-D288-4D31-9880-D74B12B63FB0"></a>
<h3 id="ADXDK-GUID-7F97E630-D288-4D31-9880-D74B12B63FB0" class="sect3"><span class="enumeration_section">4.3.8</span> Performing DOM Operations with TreeWalker</h3>
<div>
<div class="section">
<p>XDK implements the <code>NodeFilter</code> and <code>TreeWalker</code> interfaces, which are defined by the W3C DOM Level 2 Traversal and Range specification.</p>
<p>A node filter is an object that can filter out certain types of <code>Node</code> objects. For example, it can filter out entity reference nodes but accept element and attribute nodes. You create a node filter by implementing the <code>NodeFilter</code> interface and then passing a <code>Node</code> object to the <code>acceptNode()</code> method. Typically, the <code>acceptNode()</code> method implementation invokes <code>getNodeType()</code> to get the type of the node and compares it to static variables such as <code>ELEMENT_TYPE</code>, <code>ATTRIBUTE_TYPE</code>, and so forth, and then returns one of the static fields listed in <a href="adx_j_parser.htm#GUID-7F97E630-D288-4D31-9880-D74B12B63FB0__CCHHHHAH" title="This table describes useful variables in the NodeFilter interface.">Table 4-9</a>, based on what it finds.</p>
<div class="tblformal" id="GUID-7F97E630-D288-4D31-9880-D74B12B63FB0__CCHHHHAH">
<p class="titleintable">Table 4-9 Static Fields in the NodeFilter Interface</p>
<table class="cellalignment650" title="Static Fields in the NodeFilter Interface" summary="This table describes useful variables in the NodeFilter interface.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment677" id="d18956e6772">Field</th>
<th class="cellalignment702" id="d18956e6775">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment679" id="d18956e6780" headers="d18956e6772">
<p><code>FILTER_ACCEPT</code></p>
</td>
<td class="cellalignment703" headers="d18956e6780 d18956e6775">
<p>Accepts the node. Navigation methods defined for <code>NodeIterator</code> or <code>TreeWalker</code> return this node.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment679" id="d18956e6794" headers="d18956e6772">
<p><code>FILTER_REJECT</code></p>
</td>
<td class="cellalignment703" headers="d18956e6794 d18956e6775">
<p>Rejects the node. Navigation methods defined for <code>NodeIterator</code> or <code>TreeWalker</code> do not return this node. For <code>TreeWalker</code>, the children of this node are also rejected. <code>NodeIterator</code> treats <code>FILTER_REJECT</code> as a synonym for <code>FILTER_SKIP</code>.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment679" id="d18956e6821" headers="d18956e6772">
<p><code>FILTER_SKIP</code></p>
</td>
<td class="cellalignment703" headers="d18956e6821 d18956e6775">
<p>Skips this single node. Navigation methods defined for <code>NodeIterator</code> or <code>TreeWalker</code> do not return this node. For both <code>NodeIterator</code> and <code>TreeWalker</code>, children of this node are considered.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>You can use a <code>TreeWalker</code> object to traverse a document tree or subtree, using the view of the document defined by the <code>whatToShow</code> flag and filters of the <code>TreeWalker</code> object.</p>
<p>To create a <code>TreeWalker</code> object, use the <code>XMLDocument.createTreeWalker()</code> method, specifying:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>A root node for the tree or subtree</p>
</li>
<li>
<p>A flag that governs the type of nodes to include in the logical view</p>
</li>
<li>
<p>A node filter (optional)</p>
</li>
<li>
<p>A flag that determines whether to include entity references and their descendents</p>
</li>
</ul>
<p><a href="adx_j_parser.htm#GUID-7F97E630-D288-4D31-9880-D74B12B63FB0__CCHGGBGD" title="This table describes methods in the TreeWalker interface.">Table 4-10</a> describes methods in the <code>org.w3c.dom.traversal.TreeWalker</code> interface.</p>
<div class="tblformal" id="GUID-7F97E630-D288-4D31-9880-D74B12B63FB0__CCHGGBGD">
<p class="titleintable">Table 4-10 TreeWalker Interface Methods</p>
<table class="cellalignment650" title="TreeWalker Interface Methods" summary="This table describes methods in the TreeWalker interface.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment704" id="d18956e6892">Method</th>
<th class="cellalignment708" id="d18956e6895">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment706" id="d18956e6900" headers="d18956e6892">
<p><code>firstChild()</code></p>
</td>
<td class="cellalignment709" headers="d18956e6900 d18956e6895">
<p>Moves the tree walker to the first visible child of the current node and returns the new node. If the current node has no visible children, then the method returns <code>null</code> and retains the current node.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment706" id="d18956e6911" headers="d18956e6892">
<p><code>getRoot()</code></p>
</td>
<td class="cellalignment709" headers="d18956e6911 d18956e6895">
<p>Gets the root node of the tree walker (specified when the <code>TreeWalker</code> object was created).</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment706" id="d18956e6922" headers="d18956e6892">
<p><code>lastChild()</code></p>
</td>
<td class="cellalignment709" headers="d18956e6922 d18956e6895">
<p>Moves the tree walker to the last visible child of the current node and returns the new node. If the current node has no visible children, then the method returns <code>null</code> and retains the current node.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment706" id="d18956e6933" headers="d18956e6892">
<p><code>nextNode()</code></p>
</td>
<td class="cellalignment709" headers="d18956e6933 d18956e6895">
<p>Moves the tree walker to the next visible node in document order relative to the current node and returns the new node.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The <code>TreeWalkerSample.java</code> program shows some operations that you can perform with node filters and tree walkers. This section includes some code from the <code>TreeWalkerSample.java</code> program. For more detail, see the program itself.</p>
<p>The first four steps of the <span class="q">&#34;<a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53">Performing Basic DOM Parsing</a>,&#34;</span> from parser creation to the <code>getDocument()</code> invocation, are the same for <code>TreeWalkerSample.java</code>. The, the <code>TreeWalkerSample.java</code> program follows these steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a node filter object.</span>
<div>
<p>The <code>acceptNode()</code> method in the <code>nf</code> class, which implements the <code>NodeFilter</code> interface, invokes <code>getNodeType()</code> to get the type of node, as this code fragment from <code>TreeWalkerSample.java</code> does:</p>
<pre dir="ltr">NodeFilter n2 = new nf();
...
class nf implements NodeFilter
{
  public short acceptNode(Node node)
  {
    short type = node.getNodeType();
 
    if ((type == Node.ELEMENT_NODE) || (type == Node.ATTRIBUTE_NODE))
       return FILTER_ACCEPT;
    if ((type == Node.ENTITY_REFERENCE_NODE))
       return FILTER_REJECT;
    return FILTER_SKIP;
  }
}
</pre></div>
</li>
<li class="stepexpand"><span>Invoke the <code>XMLDocument.createTreeWalker()</code> method to create a tree walker.</span>
<div>
<p>This code fragment from <code>TreeWalkerSample.java</code> uses the root node of the <code>XMLDocument</code> as the root node of the tree walker and includes all nodes in the tree:</p>
<pre dir="ltr">XMLDocument doc = parser.getDocument();
...
TreeWalker tw = doc.createTreeWalker(doc.getDocumentElement(),NodeFilter.SHOW_ALL,n2,true);
</pre></div>
</li>
<li class="stepexpand"><span>Get the root element of the <code>TreeWalker</code> object, as this code fragment from <code>TreeWalkerSample.java</code> does:</span>
<div>
<pre dir="ltr">XMLNode nn = (XMLNode)tw.getRoot();
</pre></div>
</li>
<li class="stepexpand"><span>Traverse the tree.</span>
<div>
<p>This code fragment from <code>TreeWalkerSample.java</code> walks the tree in document order by invoking the <code>TreeWalker.nextNode()</code> method:</p>
<pre dir="ltr">while (nn != null)
{
  System.out.println(nn.getNodeName() + &#34; &#34; + nn.getNodeValue());
  nn = (XMLNode)tw.nextNode();
}
</pre>
<p>This code fragment from <code>TreeWalkerSample.java</code> walks the left depth of the tree by invoking the <code>firstChild()</code> method:</p>
<pre dir="ltr"> while (nn != null)
 {
   System.out.println(nn.getNodeName() + &#34; &#34; + nn.getNodeValue());
   nn = (XMLNode)tw.firstChild();
 }
</pre>
<p>You can walk the right depth of the tree by invoking the <code>lastChild()</code> method.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<a id="ADXDK980"></a><a id="ADXDK19142"></a>
<div class="props_rev_3"><a id="GUID-2E469495-7D6C-4EB4-9123-6C3C0CDE1218"></a>
<h2 id="ADXDK-GUID-2E469495-7D6C-4EB4-9123-6C3C0CDE1218" class="sect2"><span class="enumeration_section">4.4</span> Parsing XML with SAX</h2>
<div>
<div class="section">
<p>Simple API for XML (SAX) is a standard interface for event-based XML parsing.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3">Using the SAX API</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-75C097ED-7247-4C80-9D34-3F1AD9AFBD1E">Performing Basic SAX Parsing</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-7E284DE1-049C-43D9-9C15-1B01B2F00123">Performing Basic SAX Parsing with Namespaces</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C">Performing SAX Parsing with XMLTokenizer</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19144"></a><a id="ADXDK1079"></a><a id="ADXDK19145"></a><a id="ADXDK19146"></a><a id="ADXDK19143"></a>
<div class="props_rev_3"><a id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3"></a>
<h3 id="ADXDK-GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3" class="sect3"><span class="enumeration_section">4.4.1</span> Using the SAX API</h3>
<div>
<p>The SAX API, which is released in a Level 1 and Level 2 version, has these interfaces and classes:</p>
<ul style="list-style-type: disc;">
<li>
<p>Interfaces implemented by the Oracle XML parser</p>
</li>
<li>
<p>Interfaces that your application must implement (see <a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI" title="This table describes SAX 2.0 handler interfaces.">Table 4-11</a>)</p>
</li>
<li>
<p>Standard SAX classes</p>
</li>
<li>
<p>SAX 2.0 helper classes in the <code>org.xml.sax.helper</code> package (see <a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__BGBBCBED" title="Lists the SAX 2.0 helper classes in the left column and briefly describes them in the right column.">Table 4-12</a>)</p>
</li>
<li>
<p>Demonstration classes in the <code>nul</code> package</p>
</li>
</ul>
<p><a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI" title="This table describes SAX 2.0 handler interfaces.">Table 4-11</a> lists and describes the SAX 2.0 interfaces that your application must implement.</p>
<div class="tblformal" id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI">
<p class="titleintable">Table 4-11 SAX 2.0 Handler Interfaces</p>
<table class="cellalignment650" title="SAX 2.0 Handler Interfaces" summary="This table describes SAX 2.0 handler interfaces.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment673" id="d18956e7283">Interface</th>
<th class="cellalignment736" id="d18956e7286">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment675" id="d18956e7291" headers="d18956e7283">
<p><code>ContentHandler</code></p>
</td>
<td class="cellalignment737" headers="d18956e7291 d18956e7286">
<p>Receives notifications from the XML parser. Implements the major event-handling methods <code>startDocument()</code>, <code>endDocument()</code>, <code>startElement()</code>, and <code>endElement()</code>, which are invoked when the XML parser identifies an XML tag. Implements the methods <code>characters()</code> and <code>processingInstruction()</code>, which are invoked when the XML parser encounters the text in an XML element or an inline processing instruction.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment675" id="d18956e7318" headers="d18956e7283">
<p><code>DeclHandler</code></p>
</td>
<td class="cellalignment737" headers="d18956e7318 d18956e7286">
<p>Receives notifications about DTD declarations in the XML document.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment675" id="d18956e7326" headers="d18956e7283">
<p><code>DTDHandler</code></p>
</td>
<td class="cellalignment737" headers="d18956e7326 d18956e7286">
<p>Processes notations and unparsed (binary) entities.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment675" id="d18956e7334" headers="d18956e7283">
<p><code>EntityResolver</code></p>
</td>
<td class="cellalignment737" headers="d18956e7334 d18956e7286">
<p>Supports redirection of URIs in documents. Implements the method <code>resolveEntity()</code>, which is invoked when the XML parser must identify data identified by a URI.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment675" id="d18956e7345" headers="d18956e7283">
<p><code>ErrorHandler</code></p>
</td>
<td class="cellalignment737" headers="d18956e7345 d18956e7286">
<p>Handles parser errors. Implements the methods <code>error()</code>, <code>fatalError()</code>, and <code>warning()</code>, which the program invokes in response to various parsing errors.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment675" id="d18956e7362" headers="d18956e7283">
<p><code>LexicalHandler</code></p>
</td>
<td class="cellalignment737" headers="d18956e7362 d18956e7286">
<p>Receives notifications about lexical information, such as comments and character data (CDATA) section boundaries.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__BGBBCBED" title="Lists the SAX 2.0 helper classes in the left column and briefly describes them in the right column.">Table 4-12</a> lists and describes the SAX 2.0 helper classes.</p>
<div class="tblformal" id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__BGBBCBED">
<p class="titleintable">Table 4-12 SAX 2.0 Helper Classes</p>
<table class="cellalignment650" title="SAX 2.0 Helper Classes" summary="Lists the SAX 2.0 helper classes in the left column and briefly describes them in the right column.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment739" id="d18956e7385">Class</th>
<th class="cellalignment740" id="d18956e7388">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment741" id="d18956e7393" headers="d18956e7385">
<p><code>AttributeImpl</code></p>
</td>
<td class="cellalignment742" headers="d18956e7393 d18956e7388">
<p>Makes a persistent copy of an <code>AttributeList</code>.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment741" id="d18956e7404" headers="d18956e7385">
<p><code>DefaultHandler</code></p>
</td>
<td class="cellalignment742" headers="d18956e7404 d18956e7388">
<p>Base class with default implementations of the interfaces in <a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI" title="This table describes SAX 2.0 handler interfaces.">Table 4-11</a>.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment741" id="d18956e7417" headers="d18956e7385">
<p><code>LocatorImpl</code></p>
</td>
<td class="cellalignment742" headers="d18956e7417 d18956e7388">
<p>Makes a persistent snapshot of the values of a Locator at a specified point in the parse.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment741" id="d18956e7425" headers="d18956e7385">
<p><code>NamespaceSupport</code></p>
</td>
<td class="cellalignment742" headers="d18956e7425 d18956e7388">
<p>Supports XML namespaces.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment741" id="d18956e7433" headers="d18956e7385">
<p><code>XMLFilterImpl</code></p>
</td>
<td class="cellalignment742" headers="d18956e7433 d18956e7388">
<p>Base class used by applications that modify the stream of events.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment741" id="d18956e7441" headers="d18956e7385">
<p><code>XMLReaderFactory</code></p>
</td>
<td class="cellalignment742" headers="d18956e7441 d18956e7388">
<p>Supports loading SAX parsers dynamically.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__i1013043">Figure 4-5</a> shows how to create a SAX parser and use it to parse an input document.</p>
<div class="figure" id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__i1013043">
<p class="titleinfigure">Figure 4-5 Using the SAXParser Class</p>
<img width="453" height="320" src="img/GUID-C927F8EC-F391-4B13-97E8-63863F4B167B-default.gif" alt="Description of Figure 4-5 follows" title="Description of Figure 4-5 follows"/><br/>
<a href="img_text/GUID-C927F8EC-F391-4B13-97E8-63863F4B167B-print.htm">Description of &#34;Figure 4-5 Using the SAXParser Class&#34;</a></div>
<!-- class="figure" -->
<p>The basic steps for parsing an input XML document with SAX are:</p>
<ol>
<li>
<p>Create a <code>SAXParser</code> object and configure its properties.</p>
<p>For example, set the validation mode. For configuration methods, see <a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHHJABF" title="This table describes methods that you can use to set various properties of the DOM parser.">Table 4-5</a>.</p>
</li>
<li>
<p>Instantiate an event handler.</p>
<p>Your application must implement the handler interfaces in <a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI" title="This table describes SAX 2.0 handler interfaces.">Table 4-11</a>.</p>
</li>
<li>
<p>Register your event handlers with the XML parser.</p>
<p>This step enables the parser to invoke the correct methods when a given event occurs. For information about <code>SAXParser</code> methods for registering event handlers, see <a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHEIGGF" title="This table describes SAXParser methods for registering event handlers.">Table 4-13</a>.</p>
</li>
<li>
<p>Parse the input document with the <code>SAXParser.parse()</code> method.</p>
<p>All SAX interfaces are assumed to be synchronous: the parse method must not return until parsing is complete. Readers must wait for an event-handler callback to return before reporting the next event.</p>
<p>When the <code>SAXParser.parse()</code> method is invoked, the program invokes one of several callback methods implemented in the application. The methods are defined by the <code>ContentHandler</code>, <code>ErrorHandler</code>, <code>DTDHandler</code>, and <code>EntityResolver</code> interfaces implemented in the event handler. For example, the application can invoke the <code>startElement()</code> method when a start element is encountered.</p>
</li>
</ol>
<p><a href="adx_j_parser.htm#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHEIGGF" title="This table describes SAXParser methods for registering event handlers.">Table 4-13</a> lists and describes the <code>SAXParser</code> methods for registering event handlers and explains when to use them. An application can register a new or different handler in the middle of a parse; the SAX parser must begin using the newly registered handler immediately.</p>
<div class="tblformal" id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHEIGGF">
<p class="titleintable">Table 4-13 SAXParser Methods for Registering Event Handlers</p>
<table class="cellalignment650" title="SAXParser Methods for Registering Event Handlers" summary="This table describes SAXParser methods for registering event handlers.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment722" id="d18956e7544">Method</th>
<th class="cellalignment745" id="d18956e7547">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment724" id="d18956e7552" headers="d18956e7544">
<p><code>setContentHandler()</code></p>
</td>
<td class="cellalignment746" headers="d18956e7552 d18956e7547">
<p>Registers a content event handler with an application.</p>
<p>The <code>org.xml.sax.DefaultHandler</code> class implements the <code>org.xml.sax.ContentHandler</code> interface.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment724" id="d18956e7568" headers="d18956e7544">
<p><code>setDTDHandler()</code></p>
</td>
<td class="cellalignment746" headers="d18956e7568 d18956e7547">
<p>Registers a DTD event handler with an application.</p>
<p>If the application does not register a DTD handler, DTD events reported by the SAX parser are silently ignored.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment724" id="d18956e7578" headers="d18956e7544">
<p><code>setErrorHandler()</code></p>
</td>
<td class="cellalignment746" headers="d18956e7578 d18956e7547">
<p>Registers an error event handler with an application.</p>
<p>If the application does not register an error handler, all error events reported by the SAX parser are silently ignored; however, normal processing may not continue. Oracle highly recommends that all SAX applications implement an error handler to avoid unexpected bugs.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment724" id="d18956e7588" headers="d18956e7544">
<p><code>setEntityResolver()</code></p>
</td>
<td class="cellalignment746" headers="d18956e7588 d18956e7547">
<p>Registers an entity resolver with an application.</p>
<p>If the application does not register an entity resolver, the <code>XMLReader</code> performs its own default resolution.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADXDK19147"></a>
<div class="props_rev_3"><a id="GUID-75C097ED-7247-4C80-9D34-3F1AD9AFBD1E"></a>
<h3 id="ADXDK-GUID-75C097ED-7247-4C80-9D34-3F1AD9AFBD1E" class="sect3"><span class="enumeration_section">4.4.2</span> Performing Basic SAX Parsing</h3>
<div>
<div class="section">
<p>The <code>SAXSample.java</code> sample program shows the basic steps of SAX parsing. The <code>SAXSample</code> class extends <code>HandlerBase</code>. The program receives an XML file as input, parses it, and prints information about the contents of the file.</p>
<p>The <code>SAXSample.java</code> program follows these steps (which are illustrated with code fragments from the program):</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Store the <code>Locator</code>:</span>
<div>
<pre dir="ltr">Locator locator;
</pre>
<p>The <code>Locator</code> associates a SAX event with a document location. The SAX parser provides location information to the application by passing a <code>Locator</code> instance to the <code>setDocumentLocator()</code> method in the content handler. The application can use the object to get the location of any other content handler event in the XML source document.</p>
</div>
</li>
<li class="stepexpand"><span>Instantiate a new event handler.:</span>
<div>
<pre dir="ltr">SAXSample sample = new SAXSample();
</pre></div>
</li>
<li class="stepexpand"><span>Instantiate the SAX parser and configure it:</span>
<div>
<pre dir="ltr">Parser parser = new SAXParser();
((SAXParser)parser).setValidationMode(SAXParser.DTD_VALIDATION);
</pre>
<p>The preceding code sets the mode to DTD validation.</p>
</div>
</li>
<li class="stepexpand"><span>Register event handlers with the SAX parser:</span>
<div>
<pre dir="ltr">parser.setDocumentHandler(sample);
parser.setEntityResolver(sample);
parser.setDTDHandler(sample);
parser.setErrorHandler(sample);
</pre>
<p>You can use the registration methods in the <code>SAXParser</code> class, but you must implement the event handler interfaces yourself.</p>
<p>Here is part of the <code>DocumentHandler</code> interface implementation:</p>
<pre dir="ltr">public void setDocumentLocator (Locator locator)
{
  System.out.println(&#34;SetDocumentLocator:&#34;);
  this.locator = locator;
}
public void startDocument()
{
  System.out.println(&#34;StartDocument&#34;);
}
public void endDocument() throws SAXException
{
  System.out.println(&#34;EndDocument&#34;);
}
public void startElement(String name, AttributeList atts)
                                               throws SAXException
{
  System.out.println(&#34;StartElement:&#34;+name);
  for (int i=0;i&lt;atts.getLength();i++)
  {
    String aname = atts.getName(i);
    String type = atts.getType(i);
    String value = atts.getValue(i); 
    System.out.println(&#34;   &#34;+aname+&#34;(&#34;+type+&#34;)&#34;+&#34;=&#34;+value);
  }  
}
...
</pre>
<p>The following code implements the <code>EntityResolver</code> interface:</p>
<pre dir="ltr">public InputSource resolveEntity (String publicId, String systemId)
                      throws SAXException
{
  System.out.println(&#34;ResolveEntity:&#34;+publicId+&#34; &#34;+systemId);
  System.out.println(&#34;Locator:&#34;+locator.getPublicId()+&#34; locator.getSystemId()+
                    &#34; &#34;+locator.getLineNumber()+&#34; &#34;+locator.getColumnNumber());
  return null;
}
</pre>
<p>The following code implements the <code>DTDHandler</code> interface:</p>
<pre dir="ltr">public void notationDecl (String name, String publicId, String systemId)
{
  System.out.println(&#34;NotationDecl:&#34;+name+&#34; &#34;+publicId+&#34; &#34;+systemId);
}
public void unparsedEntityDecl (String name, String publicId,
                                String systemId, String notationName)
{
  System.out.println(&#34;UnparsedEntityDecl:&#34;+name + &#34; &#34;+publicId+&#34; &#34;+
                      systemId+&#34; &#34;+notationName);
}
</pre>
<p>The following code implements the <code>ErrorHandler</code> interface:</p>
<pre dir="ltr">public void warning (SAXParseException e)
           throws SAXException
{
  System.out.println(&#34;Warning:&#34;+e.getMessage());
}
public void error (SAXParseException e)
           throws SAXException
{
  throw new SAXException(e.getMessage());
}
public void fatalError (SAXParseException e)
          throws SAXException
{
  System.out.println(&#34;Fatal error&#34;);
  throw new SAXException(e.getMessage());
}
</pre></div>
</li>
<li class="stepexpand"><span>Parse the input XML document:</span>
<div>
<pre dir="ltr">parser.parse(DemoUtil.createURL(argv[0]).toString());
</pre>
<p>The preceding code converts the document to a URL and then parses it.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="ADXDK19148"></a>
<div class="props_rev_3"><a id="GUID-7E284DE1-049C-43D9-9C15-1B01B2F00123"></a>
<h3 id="ADXDK-GUID-7E284DE1-049C-43D9-9C15-1B01B2F00123" class="sect3"><span class="enumeration_section">4.4.3</span> Performing Basic SAX Parsing with Namespaces</h3>
<div>
<div class="section">
<p>The <code>SAX2Namespace.java</code> sample program implements an event handler named <code>XMLDefaultHandler</code> as a subclass of the <code>org.xml.sax.helpers.DefaultHandler</code> class. The easiest way to implement the <code>ContentHandler</code> interface is to extend the <code>org.xml.sax.helpers.DefaultHandler</code> class. The <code>DefaultHandler</code> class provides some default behavior for handling events, although the typical behavior is to do nothing.</p>
<p>The <code>SAX2Namespace.java</code> program overrides methods only for relevant events. Specifically, the <code>XMLDefaultHandler</code> class implements only two methods: <code>startElement()</code> and <code>endElement()</code>. Whenever <code>SAXParser</code> encounters a new element in the XML document, it triggers the <code>startElement</code> event, and the <code>startElement()</code> method prints the namespace information for the element.</p>
<p>The <code>SAX2Namespace.java</code> sample program follows these steps (which are illustrated with code fragments from the program):</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Instantiate a new event handler of type <code>DefaultHandler</code>:</span>
<div>
<pre dir="ltr">DefaultHandler defHandler = new XMLDefaultHandler();
</pre></div>
</li>
<li class="stepexpand"><span>Create a SAX parser and set its validation mode:</span>
<div>
<pre dir="ltr">Parser parser = new SAXParser();
((SAXParser)parser).setValidationMode(SAXParser.DTD_VALIDATION);
</pre>
<p>The preceding code sets the mode to DTD validation.</p>
</div>
</li>
<li class="stepexpand"><span>Register event handlers with the SAX parser:</span>
<div>
<pre dir="ltr">parser.setContentHandler(defHandler);
parser.setEntityResolver(defHandler);
parser.setDTDHandler(defHandler);
parser.setErrorHandler(defHandler);
</pre>
<p>The preceding code registers handlers for the input document, the DTD, entities, and errors.</p>
<p>The following code shows the <code>XMLDefaultHandler</code> implementation. The <code>startElement()</code> and <code>endElement()</code> methods print the qualified name, local name, and namespace URI for each element (for an explanation of these terms, see <a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBDBGE" title="This table describes useful methods of the XMLDocument class.">Table 4-7</a>).</p>
<pre dir="ltr">class XMLDefaultHandler extends DefaultHandler
{
   public void XMLDefaultHandler(){}
   public void startElement(String uri, String localName,
                            String qName, Attributes atts)
   throws SAXException
   {
      System.out.println(&#34;ELEMENT Qualified Name:&#34; + qName);
      System.out.println(&#34;ELEMENT Local Name    :&#34; + localName);
      System.out.println(&#34;ELEMENT Namespace     :&#34; + uri);
 
      for (int i=0; i&lt;atts.getLength(); i++)
      {
         qName = atts.getQName(i);
         localName = atts.getLocalName(i);
         uri = atts.getURI(i);
 
         System.out.println(&#34; ATTRIBUTE Qualified Name   :&#34; + qName);
         System.out.println(&#34; ATTRIBUTE Local Name       :&#34; + localName);
         System.out.println(&#34; ATTRIBUTE Namespace        :&#34; + uri);
 
         // You can get the type and value of the attributes either
         // by index or by the Qualified Name.
 
         String type = atts.getType(qName);
         String value = atts.getValue(qName);
 
         System.out.println(&#34; ATTRIBUTE Type             :&#34; + type);
         System.out.println(&#34; ATTRIBUTE Value            :&#34; + value);
 
         System.out.println();
 
      }
   }
   public void endElement(String uri, String localName,
                          String qName) throws SAXException
   {
      System.out.println(&#34;ELEMENT Qualified Name:&#34; + qName);
      System.out.println(&#34;ELEMENT Local Name    :&#34; + localName);
      System.out.println(&#34;ELEMENT Namespace     :&#34; + uri);
   }
}
</pre></div>
</li>
<li class="stepexpand"><span>Parse the input XML document:</span>
<div>
<pre dir="ltr">parser.parse(DemoUtil.createURL(argv[0]).toString());
</pre>
<p>The preceding code converts the document to a URL and then parses it.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="ADXDK19150"></a><a id="ADXDK19149"></a>
<div class="props_rev_3"><a id="GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C"></a>
<h3 id="ADXDK-GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C" class="sect3"><span class="enumeration_section">4.4.4</span> Performing SAX Parsing with XMLTokenizer</h3>
<div>
<div class="section">
<p>You can create a simple SAX parser as a instance of the <code>XMLTokenizer</code> class and use the parser to tokenize the input XML. <a href="adx_j_parser.htm#GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C__CCHJDBGJ" title="This table describes XMLTokenizer methods.">Table 4-14</a> lists useful methods in the class.</p>
<div class="tblformal" id="GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C__CCHJDBGJ">
<p class="titleintable">Table 4-14 XMLTokenizer Methods</p>
<table class="cellalignment650" title="XMLTokenizer Methods" summary="This table describes XMLTokenizer methods.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment739" id="d18956e8053">Method</th>
<th class="cellalignment740" id="d18956e8056">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment741" id="d18956e8061" headers="d18956e8053">
<p><code>setToken()</code></p>
</td>
<td class="cellalignment742" headers="d18956e8061 d18956e8056">
<p>Registers a new token for XML tokenizer.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment741" id="d18956e8069" headers="d18956e8053">
<p><code>setErrorStream()</code></p>
</td>
<td class="cellalignment742" headers="d18956e8069 d18956e8056">
<p>Registers a output stream for errors</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment741" id="d18956e8077" headers="d18956e8053">
<p><code>tokenize()</code></p>
</td>
<td class="cellalignment742" headers="d18956e8077 d18956e8056">
<p>Tokenizes the input XML</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>SAX parsers with <code>Tokenizer</code> features must implement the <code>XMLToken</code> interface. The callback method for <code>XMLToken</code> is <code>token()</code>, which receives an XML token and its corresponding value and performs an action. For example, you can implement <code>token()</code> so that it prints the token name followed by the value of the token.</p>
<p>The <code>Tokenizer.java</code> sample program accepts an XML document as input, parses it, and prints a list of the XML tokens. The program implements a <code>doParse()</code> method that follows these steps (which are illustrated with code fragments from the program):</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a URL from the input XML stream:</span>
<div>
<pre dir="ltr">URL url = DemoUtil.createURL(arg);
</pre></div>
</li>
<li class="stepexpand"><span>Create an <code>XMLTokenizer</code> parser:</span>
<div>
<pre dir="ltr">parser  = new XMLTokenizer ((XMLToken)new Tokenizer());
</pre></div>
</li>
<li class="stepexpand"><span>Register an output error stream:</span>
<div>
<pre dir="ltr">parser.setErrorStream  (System.out);
</pre></div>
</li>
<li class="stepexpand"><span>Register tokens with the parser:</span>
<div>
<pre dir="ltr">parser.setToken (STagName, true);
parser.setToken (EmptyElemTag, true);
parser.setToken (STag, true);
parser.setToken (ETag, true);
parser.setToken (ETagName, true);
...
</pre></div>
</li>
<li class="stepexpand"><span>Tokenize the XML document:</span>
<div>
<pre dir="ltr">parser.tokenize (url);
</pre>
<p>The <code>token()</code> callback method determines the action to take upon encountering a particular token. The following code is part of the implementation of this method:</p>
<pre dir="ltr">public void token (int token, String value)
{
   switch (token)
   {
   case XMLToken.STag:
      System.out.println (&#34;STag: &#34; + value);
      break;
   case XMLToken.ETag:
      System.out.println (&#34;ETag: &#34; + value);
      break;
   case XMLToken.EmptyElemTag:
      System.out.println (&#34;EmptyElemTag: &#34; + value);
      break;
   case XMLToken.AttValue:
      System.out.println (&#34;AttValue: &#34; + value);
      break;
   ...
   default:
      break;
   }
}
</pre></div>
</li>
</ol>
</div>
</div>
</div>
<a id="ADXDK981"></a><a id="ADXDK19151"></a>
<div class="props_rev_3"><a id="GUID-FD056430-78F8-4507-8D6F-9BFB8D95EA8D"></a>
<h2 id="ADXDK-GUID-FD056430-78F8-4507-8D6F-9BFB8D95EA8D" class="sect2"><span class="enumeration_section">4.5</span> Parsing XML with JAXP</h2>
<div>
<div class="section">
<p>JAXP enables your Java program to use the SAX and DOM parsers and the XSLT processor.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-9188A2DD-F117-4D27-8709-3073321C31D8">JAXP Structure</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-C2FF46DA-F711-4D7E-A96D-637877143375">Using the SAX API Through JAXP</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-D3EDB994-4754-495B-9D90-EE9CED327A16">Using the DOM API Through JAXP</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-5C17A64B-092E-437F-A38A-400E488156FE">Transforming XML Through JAXP</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-D1B88BA0-9D18-40C7-A704-D53DC41D3BA3">Parsing with JAXP</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-CE9DE31B-8870-4944-9491-EB067D5D5F6E">Performing Basic Transformations with JAXP</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19153"></a><a id="ADXDK1080"></a><a id="ADXDK19152"></a>
<div class="props_rev_3"><a id="GUID-9188A2DD-F117-4D27-8709-3073321C31D8"></a>
<h3 id="ADXDK-GUID-9188A2DD-F117-4D27-8709-3073321C31D8" class="sect3"><span class="enumeration_section">4.5.1</span> JAXP Structure</h3>
<div>
<p>JAXP consists of abstract classes that provide a thin layer for parser pluggability. Oracle implemented JAXP based on the Sun reference implementation.</p>
<p><a href="adx_j_parser.htm#GUID-9188A2DD-F117-4D27-8709-3073321C31D8__CCHDAAFH" title="Describes JAXP packages.">Table 4-15</a> lists and describes the packages that comprise JAXP.</p>
<div class="tblformal" id="GUID-9188A2DD-F117-4D27-8709-3073321C31D8__CCHDAAFH">
<p class="titleintable">Table 4-15 JAXP Packages</p>
<table class="cellalignment650" title="JAXP Packages" summary="Describes JAXP packages.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment718" id="d18956e8365">Package</th>
<th class="cellalignment719" id="d18956e8368">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment720" id="d18956e8373" headers="d18956e8365">
<p><code>javax.xml.parsers</code></p>
</td>
<td class="cellalignment721" headers="d18956e8373 d18956e8368">
<p>Provides standard APIs for DOM 2.0 and SAX 1.0 parsers. Contains vendor-neutral factory classes, including <code>SAXParser</code> and a <code>DocumentBuilder</code>. <code>DocumentBuilder</code> creates a DOM-compliant <code>Document</code> object.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment720" id="d18956e8393" headers="d18956e8365">
<p><code>javax.xml.transform</code></p>
</td>
<td class="cellalignment721" headers="d18956e8393 d18956e8368">
<p>Defines the generic APIs for processing XML transformation and performing a transformation from a source to a result.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment720" id="d18956e8401" headers="d18956e8365">
<p><code>javax.xml.transform.dom</code></p>
</td>
<td class="cellalignment721" headers="d18956e8401 d18956e8368">
<p>Provides DOM-specific transformation APIs.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment720" id="d18956e8409" headers="d18956e8365">
<p><code>javax.xml.transform.sax</code></p>
</td>
<td class="cellalignment721" headers="d18956e8409 d18956e8368">
<p>Provides SAX2-specific transformation APIs.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment720" id="d18956e8417" headers="d18956e8365">
<p><code>javax.xml.transform.stream</code></p>
</td>
<td class="cellalignment721" headers="d18956e8417 d18956e8368">
<p>Provides stream- and URI-specific transformation APIs.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADXDK19155"></a><a id="ADXDK19154"></a>
<div class="props_rev_3"><a id="GUID-C2FF46DA-F711-4D7E-A96D-637877143375"></a>
<h3 id="ADXDK-GUID-C2FF46DA-F711-4D7E-A96D-637877143375" class="sect3"><span class="enumeration_section">4.5.2</span> Using the SAX API Through JAXP</h3>
<div>
<div class="section">
<p>You can rely on the factory design pattern to create new SAX parser engines with JAXP. <a href="adx_j_parser.htm#GUID-C2FF46DA-F711-4D7E-A96D-637877143375__CCHBFEID">Figure 4-6</a> shows the basic process.</p>
<div class="figure" id="GUID-C2FF46DA-F711-4D7E-A96D-637877143375__CCHBFEID">
<p class="titleinfigure">Figure 4-6 SAX Parsing with JAXP</p>
<img width="414" height="198" src="img/GUID-A4A851FE-9AAC-46EF-9053-B6048CC1EEBD-default.gif" alt="Description of Figure 4-6 follows" title="Description of Figure 4-6 follows"/><br/>
<a href="img_text/GUID-A4A851FE-9AAC-46EF-9053-B6048CC1EEBD-print.htm">Description of &#34;Figure 4-6 SAX Parsing with JAXP&#34;</a></div>
<!-- class="figure" -->
<p>The basic steps for parsing with SAX through JAXP are:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>Create a new SAX parser factory with the <code>SAXParserFactory</code> class.</span></li>
<li><span>Configure the factory.</span></li>
<li><span>Create a new SAX parser (<code>SAXParser</code>) object from the factory.</span></li>
<li><span>Set the event handlers for the SAX parser.</span></li>
<li><span>Parse the input XML documents.</span></li>
</ol>
</div>
</div>
<a id="ADXDK19157"></a><a id="ADXDK19156"></a>
<div class="props_rev_3"><a id="GUID-D3EDB994-4754-495B-9D90-EE9CED327A16"></a>
<h3 id="ADXDK-GUID-D3EDB994-4754-495B-9D90-EE9CED327A16" class="sect3"><span class="enumeration_section">4.5.3</span> Using the DOM API Through JAXP</h3>
<div>
<div class="section">
<p>You can rely on the factory design pattern to create new DOM document builder engines with JAXP. <a href="adx_j_parser.htm#GUID-D3EDB994-4754-495B-9D90-EE9CED327A16__CCHEJCHF">Figure 4-7</a> shows the basic process.</p>
<div class="figure" id="GUID-D3EDB994-4754-495B-9D90-EE9CED327A16__CCHEJCHF">
<p class="titleinfigure">Figure 4-7 DOM Parsing with JAXP</p>
<img width="456" height="207" src="img/GUID-6C6072F7-910D-4F6F-9015-DC9B84031590-default.gif" alt="Description of Figure 4-7 follows" title="Description of Figure 4-7 follows"/><br/>
<a href="img_text/GUID-6C6072F7-910D-4F6F-9015-DC9B84031590-print.htm">Description of &#34;Figure 4-7 DOM Parsing with JAXP&#34;</a></div>
<!-- class="figure" -->
<p>The basic steps for parsing with DOM through JAXP are:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>Create a new DOM parser factory with the <code>DocumentBuilderFactory</code> class.</span></li>
<li><span>Configure the factory.</span></li>
<li><span>Create a new DOM builder (<code>DocumentBuilder</code>) object from the factory.</span></li>
<li><span>Set the error handler and entity resolver for the DOM builder.</span></li>
<li><span>Parse the input XML documents.</span></li>
</ol>
</div>
</div>
<a id="ADXDK19158"></a>
<div class="props_rev_3"><a id="GUID-5C17A64B-092E-437F-A38A-400E488156FE"></a>
<h3 id="ADXDK-GUID-5C17A64B-092E-437F-A38A-400E488156FE" class="sect3"><span class="enumeration_section">4.5.4</span> Transforming XML Through JAXP</h3>
<div>
<div class="section">
<p>The basic steps for transforming XML through JAXP are:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>Create a new transformer factory with the <code>TransformerFactory</code> class.</span></li>
<li><span>Configure the factory.</span></li>
<li><span>Create a new transformer from the factory and specify an XSLT style sheet.</span></li>
<li><span>Configure the transformer.</span></li>
<li><span>Transform the document.</span></li>
</ol>
</div>
</div>
<a id="ADXDK19159"></a>
<div class="props_rev_3"><a id="GUID-D1B88BA0-9D18-40C7-A704-D53DC41D3BA3"></a>
<h3 id="ADXDK-GUID-D1B88BA0-9D18-40C7-A704-D53DC41D3BA3" class="sect3"><span class="enumeration_section">4.5.5</span> Parsing with JAXP</h3>
<div>
<div class="section">
<p>The <code>JAXPExamples.java</code> program shows the basic steps of parsing with JAXP. The program implements these methods and uses them to parse and perform additional processing on XML files in the <code>/jaxp</code> directory:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code>basic()</code></p>
</li>
<li>
<p><code>identity()</code></p>
</li>
<li>
<p><code>namespaceURI()</code></p>
</li>
<li>
<p><code>templatesHandler()</code></p>
</li>
<li>
<p><code>contentHandler2contentHandler()</code></p>
</li>
<li>
<p><code>contentHandler2DOM()</code></p>
</li>
<li>
<p><code>reader()</code></p>
</li>
<li>
<p><code>xmlFilter()</code></p>
</li>
<li>
<p><code>xmlFilterChain()</code></p>
</li>
</ul>
<p>The program creates URLs for the sample XML files <code>jaxpone.xml</code> and <code>jaxpone.xsl</code> and then invokes the preceding methods in sequence. The basic design of the demo is as follows (to save space, only the <code>basic()</code> method is shown):</p>
<pre dir="ltr">public class JAXPExamples
{
        public static void main(String argv[])
        throws TransformerException, TransformerConfigurationException,
               IOException, SAXException, ParserConfigurationException,                 
               FileNotFoundException
        {
        try {
         URL xmlURL = createURL(&#34;jaxpone.xml&#34;);
         String xmlID = xmlURL.toString();
         URL xslURL = createURL(&#34;jaxpone.xsl&#34;);
         String xslID = xslURL.toString();
         //
         System.out.println(&#34;--- basic ---&#34;);
         basic(xmlID, xslID);
         System.out.println();
         ...
      } catch(Exception err) {
        err.printStackTrace();
      }
   }
   //
   public static void basic(String xmlID, String xslID)
      throws TransformerException, TransformerConfigurationException
   {
      TransformerFactory tfactory = TransformerFactory.newInstance();
      Transformer transformer = tfactory.newTransformer(new StreamSource(xslID));
      StreamSource source = new StreamSource(xmlID);
      transformer.transform(source, new StreamResult(System.out));
   }
...
}
</pre>
<p>The <code>reader()</code> method in the program <code>JAXPExamples.java</code> shows a simple technique for parsing an XML document with SAX, using these steps (which are illustrated with code fragments from the program):</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a new instance of a <code>TransformerFactory</code> and cast it to a <code>SAXTransformerFactory</code>:</span>
<div>
<pre dir="ltr">TransformerFactory tfactory = TransformerFactory.newInstance();
SAXTransformerFactory stfactory = (SAXTransformerFactory)tfactory;
</pre></div>
</li>
<li class="stepexpand"><span>Create an XML reader by creating a <code>StreamSource</code> object from a style sheet and passing it to the factory method <code>newXMLFilter()</code>:</span>
<div>
<pre dir="ltr">URL xslURL = createURL(&#34;jaxpone.xsl&#34;);
String xslID = xslURL.toString();
...
StreamSource streamSource = new StreamSource(xslID);
XMLReader reader = stfactory.newXMLFilter(streamSource);
</pre>
<p><code>newXMLFilter()</code> returns an <code>XMLFilter</code> object that uses the specified <code>Source</code> as the transformation instructions.</p>
</div>
</li>
<li class="stepexpand"><span>Create a content handler and register it with the XML reader:</span>
<div>
<pre dir="ltr">ContentHandler contentHandler = new oraContentHandler();
reader.setContentHandler(contentHandler);
</pre>
<p>The preceding code creates an instance of the class <code>oraContentHandler</code> by compiling the <code>oraContentHandler.java</code> program in the demo directory.</p>
<p>The following code shows part of the implementation of the <code>oraContentHandler</code> class:</p>
<pre dir="ltr">public class oraContentHandler implements ContentHandler
{
   private static final String TRADE_MARK = &#34;Oracle 9i &#34;;
 
   public void setDocumentLocator(Locator locator)
   {
      System.out.println(TRADE_MARK + &#34;- setDocumentLocator&#34;);
   }
 
   public void startDocument()
      throws SAXException
   {
      System.out.println(TRADE_MARK + &#34;- startDocument&#34;);
   }
 
   public void endDocument()
      throws SAXException
   {
      System.out.println(TRADE_MARK + &#34;- endDocument&#34;);
   }
   ...
</pre></div>
</li>
<li class="stepexpand"><span>Parse the input XML document by passing the <code>InputSource</code> to the <code>XMLReader.parse()</code> method:</span>
<div>
<pre dir="ltr">InputSource is = new InputSource(xmlID);
reader.parse(is);
</pre></div>
</li>
</ol>
</div>
</div>
<a id="ADXDK19160"></a>
<div class="props_rev_3"><a id="GUID-CE9DE31B-8870-4944-9491-EB067D5D5F6E"></a>
<h3 id="ADXDK-GUID-CE9DE31B-8870-4944-9491-EB067D5D5F6E" class="sect3"><span class="enumeration_section">4.5.6</span> Performing Basic Transformations with JAXP</h3>
<div>
<div class="section">
<p>JAXP can transform these types of input:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>XML documents</p>
</li>
<li>
<p>Style sheets</p>
</li>
<li>
<p><code>ContentHandler</code> class defined in <code>oraContentHandler.java</code></p>
</li>
</ul>
<p>You can use JAXP to perform basic transformations. For example:</p>
<ul style="list-style-type: disc;">
<li>
<p>You can use the <code>identity()</code> method to perform a transformation in which the output XML document and the input XML document are the same.</p>
</li>
<li>
<p>You can use the <code>xmlFilterChain()</code> method to apply three style sheets in a chain.</p>
</li>
<li>
<p>You can transform any class of the interface <code>Source</code> into a class of the interface <code>Result</code> (<code>DOMSource</code> to <code>DOMResult</code>, <code>StreamSource</code> to <code>StreamResult</code>, <code>SAXSource</code> to <code>SAXResult</code>, and so on).</p>
</li>
</ul>
<p>The <code>basic()</code> method in the program <code>JAXPExamples.java</code> shows how to perform a basic XSLT transformation, using these steps (which are illustrated with code fragments from the program):</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a new instance of a <code>TransformerFactory</code>:</span>
<div>
<pre dir="ltr">TransformerFactory tfactory = TransformerFactory.newInstance();
</pre></div>
</li>
<li class="stepexpand"><span>Create a new XSL transformer from the factory and specify the style sheet to use for the transformation:</span>
<div>
<pre dir="ltr">URL xslURL = createURL(&#34;<span class="bold">jaxpone.xsl</span>&#34;);
String xslID = xslURL.toString();
...
Transformer transformer = tfactory.newTransformer(new StreamSource(xslID));
</pre>
<p>In the preceding code, the style sheet is <code>jaxpone.xsl</code>.</p>
</div>
</li>
<li class="stepexpand"><span>Set the stream source to the input XML document:</span>
<div>
<pre dir="ltr">URL xmlURL = createURL(&#34;<span class="bold">jaxpone.xml</span>&#34;);
String xmlID = xmlURL.toString();
...
StreamSource source = new StreamSource(xmlID);
</pre>
<p>In the preceding code, the stream source is <code>jaxpone.xml</code>.</p>
</div>
</li>
<li class="stepexpand"><span>Transform the document from a <code>StreamSource</code> to a <code>StreamResult</code>:</span>
<div>
<pre dir="ltr">transformer.transform(source, new StreamResult(System.out));
</pre></div>
</li>
</ol>
</div>
</div>
</div>
<a id="ADXDK982"></a><a id="ADXDK19162"></a>
<div class="props_rev_3"><a id="GUID-7C87A9E2-000B-4A33-8D86-11FDA13E1CCA"></a>
<h2 id="ADXDK-GUID-7C87A9E2-000B-4A33-8D86-11FDA13E1CCA" class="sect2"><span class="enumeration_section">4.6</span> Compressing and Decompressing XML</h2>
<div>
<div class="section">
<p>XDK lets you use SAX or DOM to parse XML and then write the parsed data to a compressed binary stream. XDK also lets you reverse the process, decompressing the binary stream to reconstruct the XML data.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-AF615325-9E89-47D9-85B0-2FC9891CF0DF">Compressing a DOM Object</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-71F74D4E-1A6C-4696-AA42-DB3AE952B4A1">Decompressing a DOM Object</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-7EDACFCC-90A8-4B1D-BC28-106A54A03DF8">Compressing a SAX Object</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-AB4A91C9-319C-47AA-B3F3-C963B5BDC0AD">Decompressing a SAX Object</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19164"></a>
<div class="props_rev_3"><a id="GUID-AF615325-9E89-47D9-85B0-2FC9891CF0DF"></a>
<h3 id="ADXDK-GUID-AF615325-9E89-47D9-85B0-2FC9891CF0DF" class="sect3"><span class="enumeration_section">4.6.1</span> Compressing a DOM Object</h3>
<div>
<div class="section">
<p>The program <code>DOMCompression.java</code> shows the basic steps of DOM compression. The most important DOM compression method is <code>XMLDocument.writeExternal()</code>, which saves the state of the object by creating a binary compressed stream with information about the object.</p>
<p>The <code>DOMCompression.java</code> program uses these steps (which are illustrated with code fragments from the program):</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a DOM parser, parse an input XML document, and get the DOM representation:</span>
<div>
<pre dir="ltr">public class DOMCompression
{
   static OutputStream out = System.out;
   public static void main(String[] args)
   {
      XMLDocument doc = new XMLDocument();
      DOMParser parser = new DOMParser();
      try
      {
        parser.setValidationMode(XMLParser.SCHEMA_VALIDATION);
        parser.setPreserveWhitespace(false);
        parser.retainCDATASection(true);
        parser.parse(createURL(args[0]));
        doc = parser.getDocument();
        ...
</pre>
<p>For a description of this technique, see <span class="q">&#34;<a href="adx_j_parser.htm#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53">Performing Basic DOM Parsing</a>.&#34;</span></p>
</div>
</li>
<li class="stepexpand"><span>Create a <code>FileOutputStream</code> and wrap it in an <code>ObjectOutputStream</code> for serialization:</span>
<div>
<pre dir="ltr">OutputStream os = new FileOutputStream(&#34;xml.ser&#34;);
ObjectOutputStream oos = new ObjectOutputStream(os);
</pre></div>
</li>
<li class="stepexpand"><span>Serialize the object to the file by invoking <code>XMLDocument.writeExternal()</code>:</span>
<div>
<pre dir="ltr">doc.writeExternal(oos);
</pre>
<p>This method saves the state of the object by creating a binary compressed stream with information about this object.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="ADXDK19165"></a>
<div class="props_rev_3"><a id="GUID-71F74D4E-1A6C-4696-AA42-DB3AE952B4A1"></a>
<h3 id="ADXDK-GUID-71F74D4E-1A6C-4696-AA42-DB3AE952B4A1" class="sect3"><span class="enumeration_section">4.6.2</span> Decompressing a DOM Object</h3>
<div>
<div class="section">
<p>The program <code>DOMDeCompression.java</code> shows the basic steps of DOM decompression. The most important DOM decompression method is <code>XMLDocument.readExternal()</code>, which reads the information that the <code>writeExternal()</code> method wrote (the compressed stream) and restores the object.</p>
<p>The <code>DOMDeCompression.java</code> program uses these steps (which are illustrated with code fragments from the program):</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a file input stream for the compressed file and wrap it in an <code>ObjectInputStream</code>:</span>
<div>
<pre dir="ltr">InputStream is;
ObjectInputStream ois;
...
is = new FileInputStream(&#34;xml.ser&#34;);
ois = new ObjectInputStream(is);
</pre>
<p>The preceding code creates a <code>FileInputStream</code> from the compressed file created in <span class="q">&#34;<a href="adx_j_parser.htm#GUID-AF615325-9E89-47D9-85B0-2FC9891CF0DF">Compressing a DOM Object</a>.&#34;</span></p>
</div>
</li>
<li class="stepexpand"><span>Create a new XML document object to contain the decompressed data:</span>
<div>
<pre dir="ltr">XMLDocument serializedDoc = null;
serializedDoc = new XMLDocument();
</pre></div>
</li>
<li class="stepexpand"><span>Read the compressed file by invoking <code>XMLDocument.readExternal()</code>:</span>
<div>
<pre dir="ltr">serializedDoc.readExternal(ois);
serializedDoc.print(System.out);
</pre>
<p>The preceding code data and prints it to <code>System.out</code>.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="ADXDK19167"></a>
<div class="props_rev_3"><a id="GUID-7EDACFCC-90A8-4B1D-BC28-106A54A03DF8"></a>
<h3 id="ADXDK-GUID-7EDACFCC-90A8-4B1D-BC28-106A54A03DF8" class="sect3"><span class="enumeration_section">4.6.3</span> Compressing a SAX Object</h3>
<div>
<div class="section">
<p>The <code>SAXCompression.java</code> program shows the basic steps of parsing a file with SAX and writing the compressed stream to a file. The important class is <code>CXMLHandlerBase</code>, which is a SAX <code>Handler</code> that compresses XML data based on SAX events. To use SAX compression, implement this interface and register it with the SAX parser by invoking <code>Parser.setDocumentHandler()</code>.</p>
<p>The <code>SAXCompression.java</code> program uses these steps (which are illustrated with code fragments from the program):</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a <code>FileOutputStream</code> and wrap it in an <code>ObjectOutputStream</code>:</span>
<div>
<pre dir="ltr">String compFile = &#34;xml.ser&#34;;
FileOutputStream outStream = new FileOutputStream(compFile);
ObjectOutputStream out = new ObjectOutputStream(outStream);
</pre></div>
</li>
<li class="stepexpand"><span>Create the SAX event handler:</span>
<div>
<pre dir="ltr">CXMLHandlerBase cxml = new CXMLHandlerBase(out);

</pre>
<p>The <code>CXMLHandlerBase</code> class implements the <code>ContentHandler</code>, <code>DTDHandler</code>, <code>EntityResolver</code>, and <code>ErrorHandler</code> interfaces.</p>
</div>
</li>
<li class="stepexpand"><span>Create the SAX parser:</span>
<div>
<pre dir="ltr">SAXParser parser = new SAXParser();
</pre></div>
</li>
<li class="stepexpand"><span>Configure the SAX parser:</span>
<div>
<pre dir="ltr">parser.setContentHandler(cxml);
parser.setEntityResolver(cxml);
parser.setValidationMode(XMLConstants.NONVALIDATING);
</pre>
<p>The preceding code sets the content handler, entity resolver, and validation mode.</p>
<div class="infobox-note" id="GUID-7EDACFCC-90A8-4B1D-BC28-106A54A03DF8__GUID-E8C339BD-622D-4958-BF47-B777BE33FE74">
<p class="notep1">Note:</p>
<p>Although <code>oracle.xml.comp.CXMLHandlerBase</code> implements both <code>DocumentHandler</code> and <code>ContentHandler</code> interfaces, Oracle recommends using the SAX 2.0 <code>ContentHandler</code> interface.</p>
</div>
</div>
</li>
<li class="stepexpand"><span>Parse the XML:</span>
<div>
<pre dir="ltr">parser.parse(url);
</pre>
<p>The <code>SAXCompression.java</code> program writes the serialized data to the <code>ObjectOutputStream</code>.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="ADXDK19168"></a>
<div class="props_rev_3"><a id="GUID-AB4A91C9-319C-47AA-B3F3-C963B5BDC0AD"></a>
<h3 id="ADXDK-GUID-AB4A91C9-319C-47AA-B3F3-C963B5BDC0AD" class="sect3"><span class="enumeration_section">4.6.4</span> Decompressing a SAX Object</h3>
<div>
<div class="section">
<p>The <code>SAXDeCompression.java</code> program shows the basic steps of reading the serialized data from the file that <code>SAXCompression.java</code> wrote. The important class is <code>CXMLParser</code>, which is an XML parser that regenerates SAX events from a compressed stream.</p>
<p>The <code>SAXDeCompression.java</code> program follows these steps (which are illustrated with code fragments from the program):</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create a SAX event handler:</span>
<div>
<pre dir="ltr">SampleSAXHandler xmlHandler = new SampleSAXHandler();
</pre></div>
</li>
<li class="stepexpand"><span>Create the SAX parser by instantiating the <code>CXMLParser</code> class:</span>
<div>
<pre dir="ltr">CXMLParser parser = new CXMLParser();
</pre>
<p>The <code>CXMLParser</code> class implements the regeneration of XML documents from a compressed stream by generating SAX events from them.</p>
</div>
</li>
<li class="stepexpand"><span>Set the event handler for the SAX parser:</span>
<div>
<pre dir="ltr">parser.setContentHandler(xmlHandler);
</pre></div>
</li>
<li class="stepexpand"><span>Parse the compressed stream and generate the SAX events:</span>
<div>
<pre dir="ltr">parser.parse(args[0]);
</pre>
<p>The preceding code receives a file name from the command line and parses the XML.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<a id="ADXDK983"></a><a id="ADXDK19169"></a>
<div class="props_rev_3"><a id="GUID-BB57C7AC-2962-4617-B26F-FEE6B5114A7A"></a>
<h2 id="ADXDK-GUID-BB57C7AC-2962-4617-B26F-FEE6B5114A7A" class="sect2"><span class="enumeration_section">4.7</span> Tips and Techniques for Parsing XML</h2>
<div>
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-A0AE622C-44E2-4849-9C6D-7338970E026E">Extracting Node Values from a DOM Tree</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD">Merging Documents with appendChild()</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-FC4F9DE4-2636-4069-8732-3F7FE137AF1C">Parsing DTDs</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-5F9B55B9-9AA9-4C2C-A59D-A5C97289F641">Handling Character Sets with the XML Parser</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19171"></a><a id="ADXDK19170"></a>
<div class="props_rev_3"><a id="GUID-A0AE622C-44E2-4849-9C6D-7338970E026E"></a>
<h3 id="ADXDK-GUID-A0AE622C-44E2-4849-9C6D-7338970E026E" class="sect3"><span class="enumeration_section">4.7.1</span> Extracting Node Values from a DOM Tree</h3>
<div>
<div class="section">
<p>You can use the <code>selectNodes()</code> method in the <code>XMLNode</code> class to extract content from a DOM tree or subtree based on the select patterns allowed by XSL. You can use the optional second parameter of <code>selectNodes()</code> to resolve namespace prefixes; that is, to return the expanded namespace URL when given a prefix. The <code>XMLElement</code> class implements <code>NSResolver</code>, so a reference to an <code>XMLElement</code> object can be sent as the second parameter. <code>XMLElement</code> resolves the prefixes based on the input document. You can use the <code>NSResolver</code> interface to override the namespace definitions.</p>
<p>The sample code in <a href="adx_j_parser.htm#GUID-A0AE622C-44E2-4849-9C6D-7338970E026E__CCHHEIGA">Example 4-4</a> shows how to use <code>selectNodes()</code>.</p>
<p>To test the program, create a file with the code in <a href="adx_j_parser.htm#GUID-A0AE622C-44E2-4849-9C6D-7338970E026E__CCHHEIGA">Example 4-4</a>, and then compile it in the <code>$ORACLE_HOME/xdk/demo/java/parser/</code><code>common</code> directory. Pass the file name <code>family.xml</code> to the program as a parameter to traverse the <code>&lt;family&gt;</code> tree. The output is similar to this:</p>
<pre dir="ltr">% java selectNodesTest family.xml
Sarah
Bob
Joanne
Jim
</pre>
<p>Now run the following code to determine the values of the <code>memberid</code> attributes of all <code>&lt;member&gt;</code> elements in the document:</p>
<pre dir="ltr">% java selectNodesTest family.xml //member/@memberid
m1
m2
m3
m4
</pre></div>
<!-- class="section" -->
<div class="example" id="GUID-A0AE622C-44E2-4849-9C6D-7338970E026E__CCHHEIGA">
<p class="titleinexample">Example 4-4 Extracting Contents of a DOM Tree with selectNodes()</p>
<pre dir="ltr">//
// selectNodesTest.java
//
import java.io.*;
import oracle.xml.parser.v2.*;
import org.w3c.dom.Node;
import org.w3c.dom.Element;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
 
public class selectNodesTest
{
  public static void main(String[] args)
    throws Exception
  {
    // supply an xpath expression
    String pattern = &#34;/family/member/text()&#34;;
    // accept a filename on the command line
    // run the program with $ORACLE_HOME/xdk/demo/java/parser/common/family.xml
    String file    = args[0];
 
    if (args.length == 2)
      pattern = args[1];
 
    DOMParser dp = new DOMParser();
 
    dp.parse(DemoUtil.createURL(file));  // include createURL from DemoUtil
    XMLDocument xd = dp.getDocument();
    XMLElement element = (XMLElement) xd.getDocumentElement();
    NodeList nl = element.selectNodes(pattern, element);
    for (int i = 0; i &lt; nl.getLength(); i++)
    {
      System.out.println(nl.item(i).getNodeValue());
    } // end for
  } // end main
} // end selectNodesTest
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDK19173"></a><a id="ADXDK19174"></a><a id="ADXDK19172"></a>
<div class="props_rev_3"><a id="GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD"></a>
<h3 id="ADXDK-GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD" class="sect3"><span class="enumeration_section">4.7.2</span> Merging Documents with appendChild()</h3>
<div>
<div class="section">
<p>To write a program that lets a user complete a client-side Java form and get an XML document, your Java program can contain these variables:</p>
<pre dir="ltr">String firstname = &#34;Gianfranco&#34;;
String lastname = &#34;Pietraforte&#34;;
</pre>
<p>To insert this information into an XML document, you can use either of these techniques:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Create an XML document in a string and then parse it. For example:</p>
<pre dir="ltr">String xml = &#34;&lt;person&gt;&lt;first&gt;&#34;+firstname+&#34;&lt;/first&gt;&#34;+
     &#34;&lt;last&gt;&#34;+lastname+&#34;&lt;/last&gt;&lt;/person&gt;&#34;;
DOMParser d = new DOMParser();
d.parse(new StringReader(xml));
Document xmldoc = d.getDocument();
</pre></li>
<li>
<p>Use DOM APIs to construct an XML document, creating elements and then appending them to one another. For example:</p>
<pre dir="ltr">Document xmldoc = new XMLDocument();
Element e1 = xmldoc.createElement(&#34;person&#34;);
xmldoc.appendChild(e1);
Element e2 = xmldoc.createElement(&#34;firstname&#34;);
e1.appendChild(e2);
Text t = xmldoc.createText(&#34;Larry&#34;);
e2.appendChild(t);
</pre></li>
</ul>
<p>You can use the second technique only on a <span class="italic">single</span> DOM tree.</p>
<p><a href="adx_j_parser.htm#GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD__CCHHCEFA">Example 4-5</a> uses two trees&mdash;the owner document of <code>e1</code> is <code>xmldoc1</code> and the owner document of <code>e2</code> is <code>xmldoc2</code>. The <code>appendChild()</code> method works only within a single tree. Therefore, invoking <code>XMLElement.appendChild()</code> raises a DOM exception of <code>WRONG_DOCUMENT_ERR</code>.</p>
<p>To copy and paste a DOM document fragment or a DOM node across different XML documents, use the <code>XMLDocument.importNode()</code> method (introduced in DOM 2) and the <code>XMLDocument.adoptNode()</code> method (introduced in DOM 3). The comments in <a href="adx_j_parser.htm#GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD__CCHGICFG">Example 4-6</a> show this technique.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD__CCHHCEFA">
<p class="titleinexample">Example 4-5 Incorrect Use of appendChild()</p>
<pre dir="ltr">XMLDocument xmldoc1 = new XMLDocument();
XMLElement e1 = xmldoc1.createElement(&#34;person&#34;);
XMLDocument xmldoc2 = new XMLDocument();
XMLElement e2 = xmldoc2.createElement(&#34;firstname&#34;);
e1.appendChild(e2);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD__CCHGICFG">
<p class="titleinexample">Example 4-6 Merging Documents with appendChild</p>
<pre dir="ltr">XMLDocument doc1 = new XMLDocument();
XMLElement element1 = doc1.createElement(&#34;person&#34;);
XMLDocument doc2 = new XMLDocument();
XMLElement element2 = doc2.createElement(&#34;firstname&#34;);
<span class="bold">// element2 = doc1.importNode(element2);</span>
<span class="bold">// element2 = doc1.adoptNode(element2);</span>
element1.appendChild(element2);
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDK1081"></a><a id="ADXDK19175"></a>
<div class="props_rev_3"><a id="GUID-FC4F9DE4-2636-4069-8732-3F7FE137AF1C"></a>
<h3 id="ADXDK-GUID-FC4F9DE4-2636-4069-8732-3F7FE137AF1C" class="sect3"><span class="enumeration_section">4.7.3</span> Parsing DTDs</h3>
<div>
<div class="section">
<p class="subhead3">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-B69C71EF-C5F4-4397-A18B-1666A4064286">Loading External DTDs</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39">Caching DTDs with setDoctype</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19176"></a>
<div class="props_rev_3"><a id="GUID-B69C71EF-C5F4-4397-A18B-1666A4064286"></a>
<h4 id="ADXDK-GUID-B69C71EF-C5F4-4397-A18B-1666A4064286" class="sect4"><span class="enumeration_section">4.7.3.1</span> Loading External DTDs</h4>
<div>
<div class="section">
<p>If you invoke the <code>DOMParser.parse()</code> method to parse the XML document as an <code>InputStream</code>, then use the <code>DOMParser.setBaseURL()</code> method to recognize external DTDs within your Java program. <code>DOMParser.setBaseURL()</code> points to a location where the DTDs are exposed.</p>
<p>The procedure for loading and parsing a DTD is:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Load the DTD as an <code>InputStream</code>.</span>
<div>
<p>For example, this code validates documents against the <code>/mydir/my.dtd</code> external DTD:</p>
<pre dir="ltr">InputStream is = MyClass.class.getResourceAsStream(&#34;/mydir/my.dtd&#34;);
</pre>
<p>The preceding code opens <code>./mydir/my.dtd</code> in the first relative location in the <code>CLASSPATH</code> where it can be found, including the JAR file if it is in the <code>CLASSPATH</code>.</p>
</div>
</li>
<li class="stepexpand"><span>Create a DOM parser and set the validation mode.</span>
<div>
<p>For example:</p>
<pre dir="ltr">DOMParser d = new DOMParser();
d.setValidationMode(DTD_VALIDATION);
</pre></div>
</li>
<li class="stepexpand"><span>Parse the DTD.</span>
<div>
<p>For example, this code passes the <code>InputStream</code> object to the <code>DOMParser.parseDTD()</code> method:</p>
<pre dir="ltr">d.parseDTD(is, &#34;rootelementname&#34;);
</pre></div>
</li>
<li class="stepexpand"><span>Get the document type and then set it.</span>
<div>
<p>For example, in this code, the <code>getDoctype()</code> method gets the DTD object and the <code>setDoctype()</code> method sets the DTD to use for parsing:</p>
<pre dir="ltr">d.setDoctype(d.getDoctype());
</pre>
<p>Alternatively, you can invoke the <code>parseDTD()</code> method to parse a DTD file separately and get a DTD object:</p>
<pre dir="ltr">d.parseDTD(new FileReader(&#34;/mydir/my.dtd&#34;));
DTD dtd = d.getDoctype();
parser.setDoctype(dtd);
</pre></div>
</li>
<li class="stepexpand"><span>Parse the input XML document:</span>
<div>
<pre dir="ltr">d.parse(&#34;mydoc.xml&#34;);
</pre></div>
</li>
</ol>
</div>
</div>
<a id="ADXDK19178"></a><a id="ADXDK19177"></a>
<div class="props_rev_3"><a id="GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39"></a>
<h4 id="ADXDK-GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39" class="sect4"><span class="enumeration_section">4.7.3.2</span> Caching DTDs with setDoctype</h4>
<div>
<div class="section">
<p>The XML parser for Java provides for DTD caching in validation and nonvalidation modes through the <code>DOMParser.setDoctype()</code> method. After you set the DTD with this method, the parser caches it for further parsing.</p>
<div class="infobox-note" id="GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39__GUID-6551157D-2FA2-4106-AE11-6A894E626C02">
<p class="notep1">Note:</p>
<p>DTD caching is optional, and is not enabled automatically.</p>
</div>
<p>Suppose that your program must parse several XML documents with the same DTD. After you parse the first XML document, you can get the DTD from the parser and set it. For example:</p>
<pre dir="ltr">DOMParser parser = new DOMParser();
DTD dtd = parser.getDoctype();
parser.setDoctype(dtd);
</pre>
<p><a href="adx_j_parser.htm#GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39__CCHDIBGH">Example 4-7</a> invokes <code>DOMParser.setDoctype()</code> to cache the DTD.</p>
<p>If the cached DTD object is used only for validation, then set the <code>DOMParser.USE_DTD_ONLY_FOR_VALIDATION</code> attribute:</p>
<pre dir="ltr">parser.setAttribute(DOMParser.USE_DTD_ONLY_FOR_VALIDATION,Boolean.TRUE);
</pre>
<p>Otherwise, the XML parser copies the DTD object and adds it to the resulting DOM tree.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39__CCHDIBGH">
<p class="titleinexample">Example 4-7 DTDSample.java</p>
<pre dir="ltr">/**
 * DESCRIPTION
 * This program illustrates DTD caching.
 */

import java.net.URL;
import java.io.*;
import org.xml.sax.InputSource;
import oracle.xml.parser.v2.*;
 
public class DTDSample
{
   static public void main(String[] args)
   {
      try
      {
         if (args.length != 3)
         {
            System.err.println(&#34;Usage: java DTDSample dtd rootelement xmldoc&#34;);
            System.exit(1);
         }
 
         // Create a DOM parser
         DOMParser parser = new DOMParser();
 
         // Configure the parser
         parser.setErrorStream(System.out);
         parser.showWarnings(true);
 
        // Create a FileReader for the DTD file specified on the command
        // line and wrap it in an InputSource
        FileReader r = new FileReader(args[0]);
        InputSource inSource = new InputSource(r);
 
        // Create a URL from the command-line argument and use it to set the 
        // system identifier
        inSource.setSystemId(DemoUtil.createURL(args[0]).toString());
 
        // Parse the external DTD from the input source. The second argument is 
        // the name of the root element.
        parser.parseDTD(inSource, args[1]);
        DTD dtd = parser.getDoctype();
 
        // Create a FileReader object from the XML document specified on the
        // command line
        r = new FileReader(args[2]);
 
        // Wrap the FileReader in an InputSource,
        // create a URL from the filename,
        // and set the system identifier
        inSource = new InputSource(r);
        inSource.setSystemId(DemoUtil.createURL(args[2]).toString());

        // ********************
        parser.setDoctype(dtd);
        // ********************

        parser.setValidationMode(DOMParser.DTD_VALIDATION);
       // parser.setAttribute
       //   (DOMParser.USE_DTD_ONLY_FOR_VALIDATION,Boolean.TRUE);
        parser.parse(inSource);
 
        // Get the DOM tree and print
        XMLDocument doc = parser.getDocument();
        doc.print(new PrintWriter(System.out));
 
      }
      catch (Exception e)
      {
         System.out.println(e.toString());
      }
   }
}
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDK984"></a><a id="ADXDK19179"></a>
<div class="props_rev_3"><a id="GUID-5F9B55B9-9AA9-4C2C-A59D-A5C97289F641"></a>
<h3 id="ADXDK-GUID-5F9B55B9-9AA9-4C2C-A59D-A5C97289F641" class="sect3"><span class="enumeration_section">4.7.4</span> Handling Character Sets with the XML Parser</h3>
<div>
<div class="section">
<p class="subhead3">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_j_parser.htm#GUID-A2896B6B-A1EE-4EBA-8CAD-E936ED3D2323">Detecting the Encoding of an XML File on the Operating System</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-DB29764D-7BEA-41D6-8B35-76B5C0F65139">Preventing Distortion of XML Stored in an NCLOB Column</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-00C4A795-47D4-4E77-BA29-915C5DC12E91">Writing an XML File in a Nondefault Encoding</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA">Parsing XML Stored in Strings</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265">Parsing XML Documents with Accented Characters</a></p>
</li>
<li>
<p><a href="adx_j_parser.htm#GUID-3E59A02D-6A61-473E-A1A0-93BC17DACB61">Handling Special Characters in Tag Names</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19180"></a>
<div class="props_rev_3"><a id="GUID-A2896B6B-A1EE-4EBA-8CAD-E936ED3D2323"></a>
<h4 id="ADXDK-GUID-A2896B6B-A1EE-4EBA-8CAD-E936ED3D2323" class="sect4"><span class="enumeration_section">4.7.4.1</span> Detecting the Encoding of an XML File on the Operating System</h4>
<div>
<div class="section">
<p>When reading an XML file stored on the operating system, do not use the <code>FileReader</code> class. Instead, use the XML parser to detect the character encoding of the document automatically. Given a binary <code>FileInputStream</code> with no external encoding information, the parser automatically determines the character encoding based on the byte-order mark and encoding declaration of the XML document. You can parse any well-formed document in any supported encoding with the sample code in the <code>AutoDetectEncoding.java</code> demo, which is located in <code>$ORACLE_HOME/xdk/demo/java/parser/dom</code>.</p>
<div class="infobox-note" id="GUID-A2896B6B-A1EE-4EBA-8CAD-E936ED3D2323__GUID-C94CE09B-9D7D-4E28-B8B5-1A6535793F7A">
<p class="notep1">Note:</p>
<p>Include the proper encoding declaration in your document, according to the specification. <code>setEncoding()</code> cannot set the encoding for your input document. <code>setEncoding()</code> is used with <code>oracle.xml.parser.v2.XMLDocument</code> to set the correct encoding for printing.</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19181"></a>
<div class="props_rev_3"><a id="GUID-DB29764D-7BEA-41D6-8B35-76B5C0F65139"></a>
<h4 id="ADXDK-GUID-DB29764D-7BEA-41D6-8B35-76B5C0F65139" class="sect4"><span class="enumeration_section">4.7.4.2</span> Preventing Distortion of XML Stored in an NCLOB Column</h4>
<div>
<div class="section">
<p>Suppose that you load XML into a national character large object (<code>NCLOB</code>) column of a database using 8-bit encoding of Unicode (UTF-8), and the XML contains two UTF-8 multibyte characters:</p>
<pre dir="ltr">G<span class="bold">(0xc2,0x82)</span>otingen, Br<span class="bold">(0xc3,0xbc)</span>ck_W
</pre>
<p>You write a Java stored function that does this:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Uses the default connection object to connect to the database.</span></li>
<li class="stepexpand"><span>Runs a <code>SELECT</code> query.</span></li>
<li class="stepexpand"><span>Gets the <code>oracle.jdbc.OracleResultSet</code> object.</span></li>
<li class="stepexpand"><span>Invokes the <code>OracleResultSet.getCLOB()</code> method.</span></li>
<li class="stepexpand"><span>Invokes the <code>getAsciiStream()</code> method on the <code>CLOB</code> object.</span></li>
<li class="stepexpand"><span>Executes this code to get the XML into a DOM object:</span>
<div>
<pre dir="ltr">DOMParser parser = new DOMParser();
parser.setPreserveWhitespace(true);
parser.parse(istr);
// istr getAsciiStream XMLDocument xmldoc = parser.getDocument();
</pre></div>
</li>
</ol>
<div class="section">
<p>The program throws an exception stating that the XML contains an invalid UTF-8 encoding even though the character (<code>0xc2</code>, <code>0x82</code>) is valid UTF-8. The problem is that the character can be distorted when the program invokes the <code>OracleResultSet.getAsciiStream()</code> method. To solve this problem, invoke the <code>getUnicodeStream()</code> and <code>getBinaryStream()</code> methods instead of <code>getAsciiStream()</code>. If this technique does not work, then try to print the characters to ensure that they are not distorted before they are sent to the parser when you invoke <code>DOMParser.parse(istr)</code>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19182"></a>
<div class="props_rev_3"><a id="GUID-00C4A795-47D4-4E77-BA29-915C5DC12E91"></a>
<h4 id="ADXDK-GUID-00C4A795-47D4-4E77-BA29-915C5DC12E91" class="sect4"><span class="enumeration_section">4.7.4.3</span> Writing an XML File in a Nondefault Encoding</h4>
<div>
<div class="section">
<p>UTF-8 encoding is popular for XML documents, but UTF-8 is not usually the default file encoding of Java. Using a Java class in your program that assumes the default file encoding can cause problems.</p>
<p>For example, the Java class <code>FileWriter</code> depends on the default character encoding of the runtime environment. If you use the <code>FileWriter</code> class when writing XML files that contain characters that are not available in the default character encoding, then the output file can suffer parsing errors or data loss.</p>
<p>To avoid such problems, use the technique shown in the <code>I18nSafeXMLFileWritingSample.java</code> program in <code>$ORACLE_HOME/xdk/demo/java/parser/dom</code>.</p>
<p>You cannot use <code>System.out.println()</code> to output special characters. You must use a binary output stream that is encoding-aware, such as <code>OutputStreamWriter</code>. Construct an <code>OutputStreamWriter</code> and use the <code>write(char[]</code>, <code>int</code>, <code>int)</code> method to print, as in this example:</p>
<pre dir="ltr">/* Java encoding string for ISO8859-1*/
OutputStreamWriter out = new OutputStreamWriter(System.out, &#34;8859_1&#34;);
OutputStreamWriter.write(...);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19184"></a><a id="ADXDK19183"></a>
<div class="props_rev_3"><a id="GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA"></a>
<h4 id="ADXDK-GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA" class="sect4"><span class="enumeration_section">4.7.4.4</span> Parsing XML Stored in Strings</h4>
<div>
<div class="section">
<p>To parse an XML document contained in a <code>String</code>, you must first convert the string to an <code>InputStream</code> or <code>InputSource</code> object.</p>
<p><a href="adx_j_parser.htm#GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA__CCHFBJDJ">Example 4-8</a> converts a string of XML (referenced by <code>xmlDoc</code>) to a byte array, converts the byte array to a <code>ByteArrwayInputStream</code>, and then parses it.</p>
<p>You can convert the <code>XMLDocument</code> object created in the previous code back to a string by wrapping a <code>StringWriter</code> in a <code>PrintWriter</code>. This example shows this technique:</p>
<p>To convert the <code>XMLDocument</code> object created in <a href="adx_j_parser.htm#GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA__CCHFBJDJ">Example 4-8</a> back to a string, you can wrap a <code>StringWriter</code> in a <code>PrintWriter</code>:</p>
<pre dir="ltr">StringWriter sw = new StringWriter();
PrintWriter  pw = new PrintWriter(sw);
doc.print(pw);
String YourDocInString = sw.toString();
</pre>
<p><code>ParseXMLFromString.java</code>, which is located in <code>$ORACLE_HOME/xdk/demo/java/parser/dom</code>, is a complete program that creates an XML document as a string and parses it.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA__CCHFBJDJ">
<p class="titleinexample">Example 4-8 Converting XML in a String</p>
<pre dir="ltr">// create parser
DOMParser parser=new DOMParser();
// create XML document in a string
String xmlDoc =
       &#34;&lt;?xml version=&#39;1.0&#39;?&gt;&#34;+
       &#34;&lt;hello&gt;&#34;+
       &#34;  &lt;world/&gt;&#34;+
       &#34;&lt;/hello&gt;&#34;;
// convert string to bytes to stream
byte aByteArr [] = xmlDoc.getBytes();
ByteArrayInputStream bais = new ByteArrayInputStream(aByteArr,0,aByteArr.length);
//  parse and get DOM tree
DOMParser.parse(bais);
XMLDocument doc = parser.getDocument();
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDK19186"></a><a id="ADXDK19185"></a>
<div class="props_rev_3"><a id="GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265"></a>
<h4 id="ADXDK-GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265" class="sect4"><span class="enumeration_section">4.7.4.5</span> Parsing XML Documents with Accented Characters</h4>
<div>
<div class="section">
<p><a href="adx_j_parser.htm#GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265__CCHCBEEG">Example 4-9</a> shows one way to parse an XML document with accented characters (such as <code>&eacute;</code>).</p>
<p>When you try to parse the XML file, the parser might throw an &#34;Invalid UTF-8 encoding&#34; exception. The encoding is a scheme used to write the Unicode character number representation to disk. If you explicitly set the encoding to UTF-8 or do not specify the encoding, then the parser interprets an accented character&mdash;which has an ASCII value greater than 127&mdash;as the first byte of a UTF-8 multibyte sequence. If the subsequent bytes do not form a valid UTF-8 sequence, then you get an error.</p>
<p>The error means that your XML editor did not save the file with UTF-8 encoding. The editor might have saved the file with ISO-8859-1 (Western European ASCII) encoding. Adding the following element to the top of an XML document does not cause your editor to write the bytes representing the file to disk with UTF-8 encoding:</p>
<pre dir="ltr">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
</pre>
<p>One solution is to read accented characters in their hexadecimal or decimal format within the XML document; for example, <code>&amp;#xd9;</code>. If you prefer not to use this technique, then you can set the encoding based on the character set that you were using when you created the XML file (for example, ISO-8859-1).</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265__CCHCBEEG">
<p class="titleinexample">Example 4-9 Parsing a Document with Accented Characters</p>
<pre dir="ltr">DOMParser parser=new DOMParser();
parser.setPreserveWhitespace(true);
parser.setErrorStream(System.err);
parser.setValidationMode(false);
parser.showWarnings(true);
parser.parse (new FileInputStream(new File(&#34;file_with_accents.xml&#34;)));
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDK19187"></a>
<div class="props_rev_3"><a id="GUID-3E59A02D-6A61-473E-A1A0-93BC17DACB61"></a>
<h4 id="ADXDK-GUID-3E59A02D-6A61-473E-A1A0-93BC17DACB61" class="sect4"><span class="enumeration_section">4.7.4.6</span> Handling Special Characters in Tag Names</h4>
<div>
<div class="section">
<p>If a tag name contains special characters (<code>&amp;</code>, <code>$</code>, and <code>#</code>, and so on), then the parser issues an error about invalid characters.</p>
<p>If you are creating a new XML document, choose tag names that have no invalid <code>NameChar</code> characters. For example, if you want to name the tags after companies, and one company has the name A&amp;B, then instead of the invalid tag <code>&lt;A&amp;B&gt;</code>, choose <code>&lt;A_B&gt;</code>, <code>&lt;AB&gt;</code>, or <code>&lt;A_AND_B&gt;</code>.</p>
<p>If you are generating XML from external data sources such as database tables, then:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>XML 1.0 does not address this problem.</p>
</li>
<li>
<p>In XML 1.1, the data type <code>XMLType</code> addresses this problem by providing the <code>setConvertSpecialChars</code> and <code>convert</code> functions in the <code>DBMS_XMLGEN</code> package.</p>
<p>You can use these functions to control the use of special characters in structured query language (SQL) names and XML names. The SQL-to-XML name-mapping functions escape invalid XML <code>NameChar</code> characters in the format of <span class="italic"><code>_XHHHH_</code></span>, where <span class="italic"><code>HHHH</code></span> is the Unicode value of the invalid character. For example, table name <code>V$SESSION</code> is mapped to XML name <code>V_X0024_SESSION</code>.</p>
<p>Escaping invalid characters provides a way to serialize names so that they can be reloaded somewhere else.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment643">
<tr>
<td class="cellalignment670">
<table class="cellalignment648">
<tr>
<td class="cellalignment647"><a href="adx_j_gs.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment647"><a href="adx_j_xmlbin.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment672">
<table class="cellalignment646">
<tr>
<td class="cellalignment647"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment647"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment647"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment647"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment647"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment647"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>