<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-1640"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Using%20the%20XML%20Parser%20for%20C"></a><title>Using the XML Parser for C</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="keywords" content="XML parser for C, sample programs, C components, demos, samples, orastream functions, XML Pull Parser for C, XML Pull Parser error handling, XML pull parser, example, OCI and the XDK for C, OCI examples"/>
<meta name="dcterms.created" content="2016-12-08T13:58:19Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="XML Developer&#39;s Kit Programmer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E54405-06"/>
<meta name="dcterms.isVersionOf" content="ADXDK"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="adx_c_xslt.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adx_c_xmlbin.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E54405-06.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-6A39885C-865B-4386-B49C-1FBAB09529C6"></a> <span id="PAGE" style="display:none;">29/50</span> <!-- End Header -->
<a id="ADXDK1035"></a><a id="ADXDK1400"></a>
<h1 id="ADXDK-GUID-6A39885C-865B-4386-B49C-1FBAB09529C6" class="sect1"><span class="enumeration_chapter">20</span> Using the XML Parser for C</h1>
<div>
<p>This chapter explains how to use the Extensible Markup Language (XML) parser for C.</p>
<div class="section">
<p class="subhead1">Topics:</p>
</div>
<!-- class="section" -->
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_c_parser.htm#GUID-26A982BF-4D33-4C90-8BFA-F227D3C5CE5B">Introduction to the XML Parser for C</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-39C29945-6705-46C8-815B-DBBBF5D37C03">Using the XML Parser for C</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-0C749FC8-C0B3-41AF-9382-82F0E4FC3BEF">Using the DOM API for C</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-B36E81CE-DD87-4619-B308-708175CCDD0B">Using orastream Functions</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-34FE324C-DF9F-4FE7-B2EF-48FE4FB38B6E">Using the SAX API for C</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC">Using the XML Pull Parser for C</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-0B3D2810-F81E-4748-9E2B-152865F2A8B3">Using OCI and the XDK for C API</a></p>
</li>
</ul>
</div>
<a id="ADXDK1036"></a><a id="ADXDK19749"></a>
<div class="props_rev_3"><a id="GUID-26A982BF-4D33-4C90-8BFA-F227D3C5CE5B"></a>
<h2 id="ADXDK-GUID-26A982BF-4D33-4C90-8BFA-F227D3C5CE5B" class="sect2"><span class="enumeration_section">20.1</span> Introduction to the XML Parser for C</h2>
<div>
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_c_parser.htm#GUID-A2821602-38A1-4613-8DB4-5FEBD5C8027E">Prerequisites</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-80662259-9C17-4F27-A03B-99CC6E1196EB">Standards and Specifications</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-26A982BF-4D33-4C90-8BFA-F227D3C5CE5B__GUID-121BFA4D-E639-4F87-B8AC-D5E30303ADCB">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="adx_j_parser.htm#GUID-4BC9CC77-9343-421D-A5A0-9F073961DC75">Introduction to XML Parsing for Java</a>&#34;</span> for a generic introduction to XML parsing with Document Object Model (DOM) and Simple API for XML (SAX). Much of the information in the introduction is language-independent and applies equally to C.</p>
</div>
</div>
<!-- class="section" --></div>
<a id="ADXDK19750"></a>
<div class="sect3"><a id="GUID-A2821602-38A1-4613-8DB4-5FEBD5C8027E"></a>
<h3 id="ADXDK-GUID-A2821602-38A1-4613-8DB4-5FEBD5C8027E" class="sect3"><span class="enumeration_section">20.1.1</span> Prerequisites</h3>
<div>
<p>The Oracle XML parser for C reads an XML document and uses DOM or SAX application programming interfaces (APIs) to provide programmatic access to its content and structure. You can use the parser in validating or nonvalidating mode. A pull parser is also available.</p>
<p>This chapter assumes that you are familiar with these technologies:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="glossary.htm#GUID-0969F796-24C8-4A02-B671-B2EE8BD49F5B"><span class="xrefglossterm">Document Object Model (DOM)</span></a>. DOM is an in-memory tree representation of the structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-6B57591D-3889-4BCD-8598-58ED2DC9E9EE"><span class="xrefglossterm">Simple API for XML (SAX)</span></a>. SAX is a standard for event-based XML parsing.</p>
</li>
<li>
<p><span class="bold"><a href="adx_c_parser.htm#GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC">Using the XML Pull Parser for C</a></span>. Pull Parser uses XML events.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-F2AC11F4-F0D2-4EFB-B28B-8114CC0D7C38"><span class="xrefglossterm">document type definition (DTD)</span></a>. An XML DTD defines the legal structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-25F8F1D2-58B2-4A3F-B38C-3C2652C9C19C"><span class="xrefglossterm">XML Schema</span></a>. Like a DTD, an XML schema defines the legal structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#GUID-55AB1901-F16B-4FBD-9C2B-7164C71662B0"><span class="xrefglossterm">XML Namespaces</span></a>. Namespaces are a mechanism for differentiating element and attribute names.</p>
</li>
</ul>
<p>If you require a general introduction to the preceding technologies, consult the XML resources listed in <span class="q">&#34;<a href="preface.htm#GUID-2CD1F6B6-C8EC-42E3-97F2-589AABF9AFFB">Related Documents</a>.&#34;</span></p>
</div>
</div>
<a id="ADXDK19751"></a>
<div class="props_rev_3"><a id="GUID-80662259-9C17-4F27-A03B-99CC6E1196EB"></a>
<h3 id="ADXDK-GUID-80662259-9C17-4F27-A03B-99CC6E1196EB" class="sect3"><span class="enumeration_section">20.1.2</span> Standards and Specifications</h3>
<div>
<p>XML 1.0 is a W3C Recommendation. The Oracle XML Developer&#39;s Kit (XDK) for C API provides full support for XML 1.0 (Second Edition). You can find the specification for the Second Edition here:</p>
<pre dir="ltr"><a href="http://www.w3.org/TR/2000/REC-xml-20001006" target="_blank">http://www.w3.org/TR/2000/REC-xml-20001006</a>
</pre>
<p>The DOM Level 1, Level 2, and Level 3 specifications are World Wide Web Consortium (W3C) Recommendations. The XDK for C API provides full support for DOM Level 1 and 2, but no support for Level 3. You can find links to the specifications for all three levels here:</p>
<pre dir="ltr"><a href="http://www.w3.org/DOM/DOMTR" target="_blank">http://www.w3.org/DOM/DOMTR</a>
</pre>
<p>SAX is available in version 1.0, which is deprecated, and 2.0. SAX is not a W3C specification. The XDK for C API provides full support for both SAX 1.0 and 2.0. You can find the documentation for SAX here:</p>
<pre dir="ltr"><a href="http://www.saxproject.org" target="_blank">http://www.saxproject.org</a>
</pre>
<p>XML Namespaces are a W3C Recommendation. You can find the specification here:</p>
<pre dir="ltr"><a href="http://www.w3.org/TR/REC-xml-names" target="_blank">http://www.w3.org/TR/REC-xml-names</a>
</pre>
<div class="infoboxnotealso" id="GUID-80662259-9C17-4F27-A03B-99CC6E1196EB__GUID-561AC4BD-FAC8-4900-9A5C-7B2CF96BA3E5">
<p class="notep1">See Also:</p>
<p><a href="adx_ref_standards.htm#GUID-795A483B-12AC-4F6D-A606-6BE9DA963F0F">Oracle XML Developer&#39;s Kit Standards</a> for a summary of the standards supported by XDK</p>
</div>
</div>
</div>
</div>
<a id="ADXDK19752"></a>
<div class="props_rev_3"><a id="GUID-39C29945-6705-46C8-815B-DBBBF5D37C03"></a>
<h2 id="ADXDK-GUID-39C29945-6705-46C8-815B-DBBBF5D37C03" class="sect2"><span class="enumeration_section">20.2</span> Using the XML Parser for C</h2>
<div>
<div class="section">
<p>Oracle XML parser for C checks if an XML document is well-formed, and optionally validates it against a DTD. Your application can access the parsed data through the DOM or SAX APIs.</p>
</div>
<!-- class="section" --></div>
<a id="ADXDK19754"></a><a id="ADXDK19753"></a>
<div class="props_rev_3"><a id="GUID-CDED5CE7-8514-4680-90EE-47C82C4303E8"></a>
<h3 id="ADXDK-GUID-CDED5CE7-8514-4680-90EE-47C82C4303E8" class="sect3"><span class="enumeration_section">20.2.1</span> Overview of the Parser API for C</h3>
<div>
<p>The core of the XML parsing API are the XML, DOM, and SAX APIs. <a href="adx_c_parser.htm#GUID-CDED5CE7-8514-4680-90EE-47C82C4303E8__CCHEDFAC" title="Summarizes the C APIs for the XML parser.">Table 20-1</a> describes the interfaces for these APIs. See <a class="olink CAXML00100" target="_blank" href="../CAXML/datatypes.htm#CAXML00100"><span class="italic">Oracle Database XML C API Reference</span></a> for the complete API documentation.</p>
<div class="tblformalwide" id="GUID-CDED5CE7-8514-4680-90EE-47C82C4303E8__CCHEDFAC">
<p class="titleintable">Table 20-1 Interfaces for XML, DOM, and SAX APIs</p>
<table class="cellalignment655" title="Interfaces for XML, DOM, and SAX APIs" summary="Summarizes the C APIs for the XML parser.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment757" id="d102267e632">Package</th>
<th class="cellalignment733" id="d102267e635">Interfaces</th>
<th class="cellalignment758" id="d102267e638">Function Name Convention</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment759" id="d102267e643" headers="d102267e632">
<p>XML</p>
</td>
<td class="cellalignment735" headers="d102267e643 d102267e635">
<p>This package implements a single <code>XML</code> interface. The interface defines functions for these tasks:</p>
<ul style="list-style-type: disc;">
<li>
<p>Creating and destroying contexts. A top-level XML context (<code>xmlctx</code>) shares common information between cooperating XML components.</p>
</li>
<li>
<p>Creating and parsing XML documents and DTDs.</p>
</li>
</ul>
</td>
<td class="cellalignment760" headers="d102267e643 d102267e638">
<p>Function names begin with the string <code>Xml</code>.</p>
<p>See <a class="olink CAXML6192" target="_blank" href="../CAXML/xmldiff.htm#CAXML6192"><span class="italic">Oracle Database XML C API Reference</span></a> for API documentation.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment759" id="d102267e676" headers="d102267e632">
<p>DOM</p>
</td>
<td class="cellalignment735" headers="d102267e676 d102267e635">
<p>This package provides programmatic access to parsed XML. The package implements these interfaces:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>Attr</code> defines get and set functions for XML attributes.</p>
</li>
<li>
<p><code>CharacterData</code> defines functions for manipulating character data.</p>
</li>
<li>
<p><code>Document</code> defines functions for creating XML nodes, getting information about an XML document, and setting the DTD for a document.</p>
</li>
<li>
<p><code>DocumentType</code> defines get functions for DTDs.</p>
</li>
<li>
<p><code>Element</code> defines get and set functions for XML elements.</p>
</li>
<li>
<p><code>Entity</code> defines get functions for XML entities.</p>
</li>
<li>
<p><code>NamedNodeMap</code> defines get functions for named nodes.</p>
</li>
<li>
<p><code>Node</code> defines get and set functions for XML nodes.</p>
</li>
<li>
<p><code>NodeList</code> defines functions that free a node list and get a node from a list.</p>
</li>
<li>
<p><code>Notation</code> defines functions that get the system and public ID from a node.</p>
</li>
<li>
<p><code>ProcessingInstruction</code> defines get and set functions for processing instructions.</p>
</li>
<li>
<p><code>Text</code> defines a function that splits a text node into two.</p>
</li>
</ul>
</td>
<td class="cellalignment760" headers="d102267e676 d102267e638">
<p>Function names begin with the string <code>XmlDom</code>.</p>
<p>See <a class="olink CAXML00300" target="_blank" href="../CAXML/dom.htm#CAXML00300"><span class="italic">Oracle Database XML C API Reference</span></a> for API documentation.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment759" id="d102267e758" headers="d102267e632">
<p>SAX</p>
</td>
<td class="cellalignment735" headers="d102267e758 d102267e635">
<p>This package provides programmatic access to parsed XML. The package implements the <code>SAX</code> interface, which defines functions that receive notifications for SAX events.</p>
</td>
<td class="cellalignment760" headers="d102267e758 d102267e638">
<p>Function names begin with the string <code>XmlSax</code>.</p>
<p>See <a class="olink CAXML5908" target="_blank" href="../CAXML/sax.htm#CAXML5908"><span class="italic">Oracle Database XML C API Reference</span></a> for API documentation.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment759" id="d102267e781" headers="d102267e632">
<p>XML Pull Parser</p>
</td>
<td class="cellalignment735" headers="d102267e781 d102267e635">
<p>XML events is a representation of an XML document which is similar to SAX events in that the document is represented as a sequence of events like start tag, end tag, comment, and so on. The difference is that SAX events are driven by the parser (producer) and XML events are driven by the application (consumer).</p>
</td>
<td class="cellalignment760" headers="d102267e781 d102267e638">
<p>Function names begin with the string <code>XmlEv</code>.</p>
<p>See <a class="olink CAXML02000" target="_blank" href="../CAXML/event.htm#CAXML02000"><span class="italic">Oracle Database XML C API Reference</span></a> for API documentation.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<a id="ADXDK19756"></a><a id="ADXDK19755"></a>
<div class="props_rev_3"><a id="GUID-8D335450-FD8E-483D-974E-5BD5C05E2BB3"></a>
<h4 id="ADXDK-GUID-8D335450-FD8E-483D-974E-5BD5C05E2BB3" class="sect4"><span class="enumeration_section">20.2.1.1</span> XML Parser for C Data Types</h4>
<div>
<p>See <a class="olink CAXML00100" target="_blank" href="../CAXML/datatypes.htm#CAXML00100"><span class="italic">Oracle Database XML C API Reference</span></a> for the complete list of data types for XDK for C. <a href="adx_c_parser.htm#GUID-8D335450-FD8E-483D-974E-5BD5C05E2BB3__g455054" title="Datatype and Description are the column names.">Table 20-2</a> describes the data types used in the XML parser for C.</p>
<div class="tblformal" id="GUID-8D335450-FD8E-483D-974E-5BD5C05E2BB3__g455054">
<p class="titleintable">Table 20-2 Data Types Used in the XML Parser for C</p>
<table class="cellalignment650" title=" Data Types Used in the XML Parser for C " summary="Datatype and Description are the column names.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment761" id="d102267e899">Data Type</th>
<th class="cellalignment762" id="d102267e902">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment763" id="d102267e907" headers="d102267e899">
<p><code>oratext</code></p>
</td>
<td class="cellalignment764" headers="d102267e907 d102267e902">
<p>String pointer</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment763" id="d102267e915" headers="d102267e899">
<p><code>xmlctx</code></p>
</td>
<td class="cellalignment764" headers="d102267e915 d102267e902">
<p>Master XML context</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment763" id="d102267e923" headers="d102267e899">
<p><code>xmlsaxcb</code></p>
</td>
<td class="cellalignment764" headers="d102267e923 d102267e902">
<p>SAX callback structure (SAX only)</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment763" id="d102267e931" headers="d102267e899">
<p><code>ub4</code></p>
</td>
<td class="cellalignment764" headers="d102267e931 d102267e902">
<p>32-bit (or larger) unsigned integer</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment763" id="d102267e939" headers="d102267e899">
<p><code>uword</code></p>
</td>
<td class="cellalignment764" headers="d102267e939 d102267e902">
<p>Native unsigned integer</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADXDK19757"></a>
<div class="props_rev_3"><a id="GUID-42B8F527-3013-4896-80EF-624B983BA725"></a>
<h4 id="ADXDK-GUID-42B8F527-3013-4896-80EF-624B983BA725" class="sect4"><span class="enumeration_section">20.2.1.2</span> XML Parser for C Defaults</h4>
<div>
<p>The defaults for the XML parser for C are:</p>
<ul style="list-style-type: disc;">
<li>
<p>Character set encoding is 8-bit encoding of Unicode (UTF-8). If all your documents are ASCII, then setting the encoding to US-ASCII increases performance.</p>
</li>
<li>
<p>The parser prints messages to <code>stderr</code> unless an error handler is provided.</p>
</li>
<li>
<p>The parser checks inputs documents for well-formedness but not validity. You can set the property &#34;validate&#34; to validate the input.</p>
<div class="infobox-note" id="GUID-42B8F527-3013-4896-80EF-624B983BA725__GUID-8184CEC3-4F19-435D-97AA-FB84D46DC180">
<p class="notep1">Note:</p>
<p>Oracle recommends that you set the default encoding explicitly if using only single byte character sets (such as US-ASCII or any of the ISO-8859 character sets) for faster performance than is possible with multibyte character sets such as UTF-8.</p>
</div>
</li>
<li>
<p>The parser conforms with the XML 1.0 specification when processing white space, that is, the parser reports all white space to the application but indicates which white space can be ignored. However, some applications may prefer to set the property &#34;discard-white space,&#34; which discards all white space between an end-element tag and this start-element tag.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-42B8F527-3013-4896-80EF-624B983BA725__GUID-0A91D34B-745C-4173-9F04-CF2D34969529">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink CAXML00300" target="_blank" href="../CAXML/dom.htm#CAXML00300"><span class="italic">Oracle Database XML C API Reference</span></a> for the DOM, SAX, pull parser, and callback APIs.</p>
</li>
<li>
<p><a href="http://www.oracle.com/technetwork/database-features/xdk/overview/index.html" target="_blank"><code>http://www.oracle.com/technetwork/database-features/xdk/overview/index.html</code></a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="ADXDK19759"></a><a id="ADXDK19758"></a>
<div class="props_rev_3"><a id="GUID-4C2307E5-610E-470C-B1BB-BA81D6D1D9D5"></a>
<h3 id="ADXDK-GUID-4C2307E5-610E-470C-B1BB-BA81D6D1D9D5" class="sect3"><span class="enumeration_section">20.2.2</span> XML Parser for C Calling Sequence</h3>
<div>
<p><a href="adx_c_parser.htm#GUID-4C2307E5-610E-470C-B1BB-BA81D6D1D9D5__BABCDCDC">Figure 20-1</a> shows the calling sequence for the XML parser for C.</p>
<div class="figure" id="GUID-4C2307E5-610E-470C-B1BB-BA81D6D1D9D5__BABCDCDC">
<p class="titleinfigure">Figure 20-1 XML Parser for C Calling Sequence</p>
<img width="660" height="944" src="img/GUID-E5EEBDDE-5157-4A95-AFDA-DFC33B04FD10-default.gif" alt="Description of Figure 20-1 follows" title="Description of Figure 20-1 follows"/><br/>
<a href="img_text/GUID-E5EEBDDE-5157-4A95-AFDA-DFC33B04FD10-print.htm">Description of &#34;Figure 20-1 XML Parser for C Calling Sequence&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="ADXDK19760"></a>
<div class="props_rev_3"><a id="GUID-12636E6D-1E3A-4B2C-941E-FF59196FD7DA"></a>
<h3 id="ADXDK-GUID-12636E6D-1E3A-4B2C-941E-FF59196FD7DA" class="sect3"><span class="enumeration_section">20.2.3</span> Using the XML Parser for C: Basic Process</h3>
<div>
<div class="section">
<p>Perform these steps in your application:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Initialize the parsing process with the <code>XmlCreate()</code> function. The following sample code fragment is from <code>DOMNamespace.c</code>:</span>
<div>
<pre dir="ltr">xmlctx     *xctx;
...
xctx = XmlCreate(&amp;ecode, (oratext *) &#34;namespace_xctx&#34;, NULL);
</pre></div>
</li>
<li class="stepexpand"><span>Parse the input item, which can be an XML document or string buffer.</span>
<div>
<p>If you are parsing with DOM, invoke the <code>XmlLoadDom()</code> function. The following sample code fragment is from <code>DOMNamespace.c</code>:</p>
<pre dir="ltr">xmldocnode *doc;
...
doc = XmlLoadDom(xctx, &amp;ecode, &#34;file&#34;, DOCUMENT,
                 &#34;validate&#34;, TRUE, &#34;discard_whitespace&#34;, TRUE, NULL);
</pre>
<p>If you are parsing with SAX, invoke the <code>XmlLoadSax()</code> function. The following sample code fragment is from <code>SAXNamespace.c</code>:</p>
<pre dir="ltr">xmlerr      ecode;
...
ecode = XmlLoadSax(xctx, &amp;sax_callback, &amp;sc, &#34;file&#34;, DOCUMENT,
                   &#34;validate&#34;, TRUE, &#34;discard_whitespace&#34;, TRUE, NULL);
</pre>
<p>If you are using the pull parser, then include these steps to create the event context and load the document to parse:</p>
<pre dir="ltr">evctx = XmlEvCreatePPCtx(xctx, &amp;xerr, NULL);
XmlEvLoadPPDoc(xctx, evctx, &#34;File&#34;, input_filenames[i], 0, NULL);
</pre></div>
</li>
<li class="stepexpand"><span>If you are using the DOM interface, then include these steps:</span>
<div>
<ul style="list-style-type: disc;">
<li>
<p>Use the <code>XmlLoadDom()</code> function to invoke <code>XmlDomGetDocElem()</code>. This step invokes other DOM functions, which are typically node or print functions that output the DOM document, as required. The following sample code fragment is from <code>DOMNamespace.c</code>:</p>
<pre dir="ltr">printElements(xctx, XmlDomGetDocElem(xctx, doc));
</pre></li>
<li>
<p>Invoke the <code>XmlFreeDocument()</code> function to clean up any data structures created during the parse process. The following sample code fragment is from <code>DOMNamespace.c</code>:</p>
<pre dir="ltr">XmlFreeDocument(xctx, doc);
</pre></li>
</ul>
<p>If you are using the SAX interface, then include these steps:</p>
<ul style="list-style-type: disc;">
<li>
<p>Process the results of the invocation of <code>XmlLoadSax()</code> with a callback function, such as:</p>
<pre dir="ltr">xmlsaxcb saxcb = {
 UserStartDocument,  /* user&#39;s own callback functions */
 UserEndDocument,
 /* ... */
}; 

if (XmlLoadSax(xctx, &amp;saxcb, NULL, &#34;file&#34;, &#34;some_file.xml&#34;, NULL) != 0)
  /* an error occured */
</pre></li>
<li>
<p>Register the callback functions. You can set any of the SAX callback functions to <code>NULL</code> if not needed.</p>
</li>
</ul>
<p>If you are using the pull parser, iterate over the events using:</p>
<pre dir="ltr">cur_event = XmlEvNext(evctx);
</pre>
<p>Use the Get APIs to get information about that event.</p>
</div>
</li>
<li class="stepexpand"><span>Use <code>XmlFreeDocument()</code> to clean up the memory and structures used during a parse. The program does not free memory allocated for parameters passed to the SAX callbacks or for nodes and data stored with the DOM parse tree until you invoke <code>XMLFreeDocument()</code> or <code>XMLDestroy()</code>. The following sample code fragment is from <code>DOMNamespace.c</code>:</span>
<div>
<pre dir="ltr">XmlFreeDocument(xctx, doc);
</pre>
<p>Either return to Step 2 or proceed to the next step.</p>
<p>For the pull parser invoke <code>XmlEvCleanPPCtx()</code> to release memory and structures used during the parse. The application can invoke <code>XmlEvLoadPPDoc()</code> again to parse another document. Or, it can invoke <code>XMLEvDestroyPPCtx()</code> after which the pull parser context cannot be used again.</p>
<pre dir="ltr">XmlEvCleanPPCtx(xctx, evctx);
...
XmlEvDestroyPPCtx(xctx, evctx);
</pre></div>
</li>
<li class="stepexpand"><span>Terminate the parsing process with <code>XmlDestroy()</code>. The following sample code fragment is from <code>DOMNamespace.c</code>:</span>
<div>
<pre dir="ltr">(void) XmlDestroy(xctx);
</pre>
<p>If threads fork off somewhere in the sequence of invocations between initialization and termination, the application produces unpredictable behavior and results.</p>
</div>
</li>
</ol>
<div class="section">
<p>You can use the memory callback functions <code>XML_ALLOC_F</code> and <code>XML_FREE_F</code> for your own memory allocation. If you do, then specify both functions.</p>
<div class="infoboxnotealso" id="GUID-12636E6D-1E3A-4B2C-941E-FF59196FD7DA__GUID-90EFD446-EB19-40DC-BBE7-DF6FBCEA1B81">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="adx_c_parser.htm#GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC">Using the XML Pull Parser for C</a>&#34;</span></p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19762"></a><a id="ADXDK19761"></a>
<div class="props_rev_3"><a id="GUID-247C9003-4689-447B-94B1-1EAAD497C45C"></a>
<h3 id="ADXDK-GUID-247C9003-4689-447B-94B1-1EAAD497C45C" class="sect3"><span class="enumeration_section">20.2.4</span> Running the XML Parser for C Demo Programs</h3>
<div>
<div class="section">
<p>The <code>$ORACLE_HOME/xdk/demo/c/</code> (UNIX) and <code>%ORACLE_HOME%\xdk\demo\c</code> (Windows) directories include several XML applications that show how to use the XML parser for C with the DOM and SAX interfaces. <a href="adx_c_parser.htm#GUID-247C9003-4689-447B-94B1-1EAAD497C45C__CCHJHGCD" title="Describes the subdirectories of the /demo/java directory.">Table 20-3</a> describes the demos.</p>
<p>The <code>make</code> utility compiles the source file <span class="italic"><code>fileName.c</code></span> to produce the demo program <span class="italic"><code>fileName</code></span> and the output file <span class="italic"><code>fileName.out</code></span> . The <span class="italic"><code>fileName.std</code></span> is the expected output.</p>
<div class="tblformalwide" id="GUID-247C9003-4689-447B-94B1-1EAAD497C45C__CCHJHGCD">
<p class="titleintable">Table 20-3 C Parser Demos</p>
<table class="cellalignment655" title="C Parser Demos" summary="Describes the subdirectories of the /demo/java directory.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment757" id="d102267e1526">Directory</th>
<th class="cellalignment765" id="d102267e1529">Contents</th>
<th class="cellalignment743" id="d102267e1532">Demos</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment759" id="d102267e1537" headers="d102267e1526">
<p><code>dom</code></p>
</td>
<td class="cellalignment766" headers="d102267e1537 d102267e1529">
<pre dir="ltr">DOMNamespace.c
DOMSample.c
FullDom.c
FullDom.xml
NSExample.xml
Traverse.c
XPointer.c
class.xml
cleo.xml
pantry.xml
</pre></td>
<td class="cellalignment744" headers="d102267e1537 d102267e1532">
<p>The following demo programs use the DOM API:</p>
<ul style="list-style-type: disc;">
<li>
<p>The <code>DOMNamespace</code> program uses Namespace extensions to the DOM API. It prints out all elements and attributes of <code>NSExample.xml</code> along with full namespace information.</p>
</li>
<li>
<p>The <code>DOMSample</code> program uses DOM APIs to display an outline of <span class="italic">Cleopatra</span>, that is, the XML elements <code>ACT</code> and <code>SCENE</code>. The <code>cleo.xml</code> document contains the XML version of Shakespeare&#39;s <span class="italic">The Tragedy of Antony and Cleopatra</span>.</p>
</li>
<li>
<p>The <code>FullDom</code> program shows sample usage of the full DOM interface. It exercises all the invocations. The program accepts <code>FullDom.xml</code>, which shows the use of entities, as input.</p>
</li>
<li>
<p>The <code>Traverse</code> program shows the use of DOM iterators, tree walkers, and ranges. The program accepts the <code>class.xml</code> document, which describes a college Calculus course, as input.</p>
</li>
<li>
<p>The <code>XPointer</code> program shows the use of the XML Pointer Language by locating the children of the <code>&lt;pantry&gt;</code> element in <code>pantry.xml</code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment759" id="d102267e1610" headers="d102267e1526">
<p><code>sax</code></p>
</td>
<td class="cellalignment766" headers="d102267e1610 d102267e1529">
<pre dir="ltr">NSExample.xml
SAXNamespace.c
SAXSample.c
cleo.xml
</pre></td>
<td class="cellalignment744" headers="d102267e1610 d102267e1532">
<p>The following demo programs use the SAX APIs:</p>
<ul style="list-style-type: disc;">
<li>
<p>The <code>SAXNamespace</code> program uses namespace extensions to the SAX API. It prints out all elements and attributes of <code>NSExample.xml</code> along with full namespace information.</p>
</li>
<li>
<p>The <code>SAXSample</code> program uses SAX APIs to show all lines in the play <span class="italic">Cleopatra</span> containing a given word. If you do not specify a word, then it uses the word &#34;death.&#34; The <code>cleo.xml</code> document contains the XML version of Shakespeare&#39;s <span class="italic">The Tragedy of Antony and Cleopatra</span>.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>You can find documentation that describes how to compile and run the sample programs in the <code>README</code> in the same directory. The basic steps are:</p>
<ol>
<li>
<p>Change into the <code>$ORACLE_HOME/xdk/demo/c</code> directory (UNIX) or <code>%ORACLE_HOME%\xdk\demo\c</code> directory (Windows).</p>
</li>
<li>
<p>Make sure that your environment variables are set as described in <span class="q">&#34;<a href="adx_c_gs.htm#GUID-8BCD12B3-3D56-4F00-8C2E-B46AA6A428B7">Setting XDK for C Environment Variables on UNIX</a>&#34;</span> and <span class="q">&#34;<a href="adx_c_gs.htm#GUID-C64E22E0-7FAE-4409-8A04-758F4458F0D9">Setting XDK for C Environment Variables on Windows</a>.&#34;</span></p>
</li>
<li>
<p>Run <code>make</code> (UNIX) or <code>Make.bat</code> (Windows) at the system prompt. The <code>make</code> utility changes into each demo subdirectory and runs <code>make</code> to do this:</p>
<ol>
<li>
<p>Compiles the C source files with the <code>cc</code> utility. For example, the <code>Makefile</code> in the <code>$ORACLE_HOME/xdk/demo/c/dom</code> directory includes these line:</p>
<pre dir="ltr">$(CC) -o DOMSample $(INCLUDE) $@.c $(LIB)
</pre></li>
<li>
<p>Runs each demo program and redirects the output to a file. For example, the <code>Makefile</code> in the <code>$ORACLE_HOME/xdk/demo/c/dom</code> directory includes this line:</p>
<pre dir="ltr">./DOMSample &gt; DOMSample.out
</pre></li>
</ol>
</li>
<li>
<p>Compare the <code>*.std</code> files to the <code>*.out</code> files for each program. The <code>*.std</code> file contains the expected output for each program. For example, <code>DOMSample.std</code> contains the expected output from running <code>DOMSample</code>.</p>
</li>
</ol>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19764"></a><a id="ADXDK19763"></a>
<div class="props_rev_3"><a id="GUID-D7F8125B-A91C-41FA-A75E-5B9E0C620645"></a>
<h3 id="ADXDK-GUID-D7F8125B-A91C-41FA-A75E-5B9E0C620645" class="sect3"><span class="enumeration_section">20.2.5</span> Using the C XML Parser Command-Line Utility</h3>
<div>
<div class="section">
<p>The <code>xml</code> utility, which is located in <code>$ORACLE_HOME/bin</code> (UNIX) or <code>%ORACLE_HOME%\bin</code> (Windows), is a command-line interface that parses XML documents. It checks for both well-formedness and validity.</p>
<p>To use <code>xml</code> ensure that your environment is set up as described in <span class="q">&#34;<a href="adx_c_gs.htm#GUID-8BCD12B3-3D56-4F00-8C2E-B46AA6A428B7">Setting XDK for C Environment Variables on UNIX</a>&#34;</span> and <span class="q">&#34;<a href="adx_c_gs.htm#GUID-C64E22E0-7FAE-4409-8A04-758F4458F0D9">Setting XDK for C Environment Variables on Windows</a>.&#34;</span></p>
<p>Use this syntax on the command line to invoke <code>xml</code>. Use <code>xml.exe</code> for Windows:</p>
<pre dir="ltr">xml [options] [document URI]
xml -f [options] [document filespec]
</pre>
<p><a href="adx_c_parser.htm#GUID-D7F8125B-A91C-41FA-A75E-5B9E0C620645__g1016893" title="Option and Meaning are the columns.">Table 20-4</a> describes the command-line options.</p>
<div class="tblformal" id="GUID-D7F8125B-A91C-41FA-A75E-5B9E0C620645__g1016893">
<p class="titleintable">Table 20-4 C XML Parser Command-Line Options</p>
<table class="cellalignment650" title="C XML Parser Command-Line Options " summary="Option and Meaning are the columns.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment688" id="d102267e1862">Option</th>
<th class="cellalignment743" id="d102267e1865">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1870" headers="d102267e1862">
<p><code>-B</code> BaseURI</p>
</td>
<td class="cellalignment744" headers="d102267e1870 d102267e1865">
<p>Sets the base URI for the XSLT processor. The base URI of <code>http://pqr/xsl.txt</code> resolves <code>pqr.txt</code> to <code>http://pqr/pqr.txt</code>.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1888" headers="d102267e1862">
<p><code>-c</code></p>
</td>
<td class="cellalignment744" headers="d102267e1888 d102267e1865">
<p>Checks well-formedness, but performs no validation.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1896" headers="d102267e1862">
<p><code>-e</code> <span class="italic"><code>encoding</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e1896 d102267e1865">
<p>Specifies default input file encoding (&#34;incoding&#34;).</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1907" headers="d102267e1862">
<p><code>-E</code> <span class="italic"><code>encoding</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e1907 d102267e1865">
<p>Specifies DOM/SAX encoding (&#34;outcoding&#34;).</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1920" headers="d102267e1862">
<p><code>-f</code> <span class="italic"><code>file</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e1920 d102267e1865">
<p>Interprets the file as filespec, not URI.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1932" headers="d102267e1862">
<p><code>-G</code> <span class="italic"><code>xptr_exprs</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e1932 d102267e1865">
<p>Evaluates <code>XPointer</code> scheme examples given in a file.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1947" headers="d102267e1862">
<p><code>-h</code></p>
</td>
<td class="cellalignment744" headers="d102267e1947 d102267e1865">
<p>Shows usage help and basic list of command-line options.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1955" headers="d102267e1862">
<p><code>-hh</code></p>
</td>
<td class="cellalignment744" headers="d102267e1955 d102267e1865">
<p>Shows complete list command-line options.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1963" headers="d102267e1862">
<p><code>-i</code> <span class="italic"><code>n</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e1963 d102267e1865">
<p>Specifies the number of times to iterate the <code>XSLT</code> processing.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1977" headers="d102267e1862">
<p><code>-l</code> <span class="italic"><code>language</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e1977 d102267e1865">
<p>Specifies the language for error reporting.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e1989" headers="d102267e1862">
<p><code>-n</code></p>
</td>
<td class="cellalignment744" headers="d102267e1989 d102267e1865">
<p>Traverses the DOM and reports the number of elements, as shown in this sample output:</p>
<pre dir="ltr">ELEMENT       1
 PCDATA       1
    DOC       1
  TOTAL       3 * 60 = 180
</pre></td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2000" headers="d102267e1862">
<p><code>-o</code> <span class="italic"><code>XSLoutfile</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e2000 d102267e1865">
<p>Specifies the output file of the <code>XSLT</code> processor.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2014" headers="d102267e1862">
<p><code>-p</code></p>
</td>
<td class="cellalignment744" headers="d102267e2014 d102267e1865">
<p>Prints the document/DTD structures after the parse. For example, the root element <code>&lt;greeting&gt;hello&lt;/greeting&gt;</code> is printed as:</p>
<pre dir="ltr">+---ELEMENT greeting 
    +---PCDATA &#34;hello&#34;
</pre></td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2027" headers="d102267e1862">
<p><code>-P</code></p>
</td>
<td class="cellalignment744" headers="d102267e2027 d102267e1865">
<p>Prints the document from the root element. For example, the root element <code>&lt;greeting&gt;hello&lt;/greeting&gt;</code> is printed as:</p>
<pre dir="ltr">&lt;greeting&gt;hello&lt;/greeting&gt;
</pre></td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2040" headers="d102267e1862">
<p><code>-PP</code></p>
</td>
<td class="cellalignment744" headers="d102267e2040 d102267e1865">
<p>Prints from the root node (DOC) and includes the XML declaration.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2048" headers="d102267e1862">
<p><span class="italic"><code>-PE encoding</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e2048 d102267e1865">
<p>Specifies the encoding for <code>-P</code> or <code>-PP</code> output.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2063" headers="d102267e1862">
<p><code>-PX</code></p>
</td>
<td class="cellalignment744" headers="d102267e2063 d102267e1865">
<p>Includes the XML declaration in the output.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2071" headers="d102267e1862">
<p><code>-s</code> <span class="italic"><code>stylesheet</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e2071 d102267e1865">
<p>Specifies the <code>XSLT</code> style sheet.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2085" headers="d102267e1862">
<p><code>-v</code></p>
</td>
<td class="cellalignment744" headers="d102267e2085 d102267e1865">
<p>Displays the XDK parser version, and then exits.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2093" headers="d102267e1862">
<p><code>-V</code> <span class="italic"><code>var value</code></span></p>
</td>
<td class="cellalignment744" headers="d102267e2093 d102267e1865">
<p>Tests top-level variables in <code>CXSLT</code>.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2107" headers="d102267e1862">
<p><code>-w</code></p>
</td>
<td class="cellalignment744" headers="d102267e2107 d102267e1865">
<p>Preserves all white space.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2115" headers="d102267e1862">
<p><code>-W</code></p>
</td>
<td class="cellalignment744" headers="d102267e2115 d102267e1865">
<p>Stops parsing after a warning.</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment690" id="d102267e2124" headers="d102267e1862">
<p><code>-x</code></p>
</td>
<td class="cellalignment744" headers="d102267e2124 d102267e1865">
<p>Exercises the SAX interface and prints the document, as shown in this sample output:</p>
<pre dir="ltr">StartDocument
XMLDECL version=&#39;1.0&#39; encoding=FALSE
&lt;greeting&gt;
    &#34;hello&#34;
&lt;/greeting&gt;
EndDocument
</pre></td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" --></div>
<a id="ADXDK19766"></a><a id="ADXDK19767"></a><a id="ADXDK19765"></a>
<div class="props_rev_3"><a id="GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445"></a>
<h4 id="ADXDK-GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445" class="sect4"><span class="enumeration_section">20.2.5.1</span> Using the XML Parser Command-Line Utility: Example</h4>
<div>
<div class="section">
<p>You can test <code>xml</code> on the various XML files located in <code>$ORACLE_HOME/xdk/demo/c</code>. <a href="adx_c_parser.htm#GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445__BGBFHECI">Example 20-1</a> displays the contents of <code>NSExample.xml</code>.</p>
<p>You can parse this file, count the number of elements, and display the DOM tree as shown in this example:</p>
<pre dir="ltr">xml -np NSEample.xml &gt; xml.out
</pre>
<p><a href="adx_c_parser.htm#GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445__GUID-D6CBD9FF-F2C6-452A-9C86-BA2C70A5973D">Example 20-2</a>shows the output.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445__BGBFHECI">
<p class="titleinexample">Example 20-1 NSExample.xml</p>
<pre dir="ltr">&lt;!DOCTYPE doc [
&lt;!ELEMENT doc (child*)&gt;
&lt;!ATTLIST doc xmlns:nsprefix CDATA #IMPLIED&gt;
&lt;!ATTLIST doc xmlns CDATA #IMPLIED&gt;
&lt;!ATTLIST doc nsprefix:a1 CDATA #IMPLIED&gt;
&lt;!ELEMENT child (#PCDATA)&gt;
]&gt;
&lt;doc nsprefix:a1 = &#34;v1&#34; xmlns=&#34;http://www.w3c.org&#34; 
     xmlns:nsprefix=&#34;http://www.oracle.com&#34;&gt;
&lt;child&gt;
This element inherits the default Namespace of doc.
&lt;/child&gt;
&lt;/doc&gt;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445__GUID-D6CBD9FF-F2C6-452A-9C86-BA2C70A5973D">
<p class="titleinexample">Example 20-2 xml.out</p>
<pre dir="ltr">   ELEMENT       2
    PCDATA       1
       DOC       1
       DTD       1
  ELEMDECL       2
  ATTRDECL       3
     TOTAL      10 * 112 = 1120
+---ELEMENT doc [nsprefix:a1=&#39;v1&#39;*, xmlns=&#39;http://www.w3c.org&#39;*, xmlns:nsprefix=
&#39;http://www.oracle.com&#39;*]
    +---ELEMENT child
        +---PCDATA &#34;
This element inherits the default Namespace of doc.
&#34;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="ADXDK1037"></a><a id="ADXDK19768"></a>
<div class="props_rev_3"><a id="GUID-0C749FC8-C0B3-41AF-9382-82F0E4FC3BEF"></a>
<h2 id="ADXDK-GUID-0C749FC8-C0B3-41AF-9382-82F0E4FC3BEF" class="sect2"><span class="enumeration_section">20.3</span> Using the DOM API for C</h2>
<div>
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_c_parser.htm#GUID-8C9F7915-889D-417F-8E6A-3118AD8C883B">Controlling the Data Encoding of XML Documents for the C API</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646">Using NULL-Terminated and Length-Encoded C API Functions</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-462C7E68-35A3-4CD9-A767-B0F900E92BE8">Handling Errors with the C API</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19769"></a>
<div class="props_rev_3"><a id="GUID-8C9F7915-889D-417F-8E6A-3118AD8C883B"></a>
<h3 id="ADXDK-GUID-8C9F7915-889D-417F-8E6A-3118AD8C883B" class="sect3"><span class="enumeration_section">20.3.1</span> Controlling the Data Encoding of XML Documents for the C API</h3>
<div>
<div class="section">
<p>XML data occurs in many encodings. You can control the XML encoding in these ways:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Specify a default encoding to assume for files that are not self-describing</p>
</li>
<li>
<p>Specify the presentation encoding for DOM or SAX</p>
</li>
<li>
<p>Re-encode when a DOM is serialized</p>
</li>
</ul>
<p>Input XML data is always encoded. Some encodings are entirely self-describing, such as 16-bit encoding of Unicode (UTF-16), which requires a specific Byte Order Mark (BOM) before the start of the actual data. The <code>XMLDecl</code> or Multipurpose Internet Mail Extensions (MIME) header of the document can also specify an encoding. If the application cannot determine the specific encoding, then it applies the default input encoding. If you do not provide a default, then the application assumes UTF-8 on ASCII platforms and UTF-EBCDIC on EBCDIC platforms.</p>
<p>The API makes a provision for cases when the encoding data of the input document is corrupt. For example, suppose an ASCII document with an <code>XMLDecl</code> of <code>encoding=ascii</code> is blindly converted to EBCDIC. The new EBCDIC document contains (in EBCDIC) an <code>XMLDecl</code> that incorrectly claims the document is ASCII. The correct behavior for a program that is re-encoding XML data is to regenerate but not convert the <code>XMLDecl</code>. The <code>XMLDecl</code> is metadata, not data itself. This rule is often ignored, however, which causes corrupt documents. To work around this problem, the API provides an additional flag that enables you to forcibly set the input encoding, thereby overcoming an incorrect <code>XMLDecl</code>.</p>
<p>The precedence rules for determining input encoding are:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Forced encoding as specified by the user</span>
<div>
<div class="infobox-note" id="GUID-8C9F7915-889D-417F-8E6A-3118AD8C883B__GUID-6E34C31E-0805-4430-B307-A0C0686AA8CC">
<p class="notep1">Note:</p>
<p>Forced encoding can cause a fatal error if there is a conflict. For example, the input document is UTF-16 and starts with a UTF-16 BOM, but the user specifies a forced UTF-8 encoding. In this case, the parser objects about the conflict.</p>
</div>
</div>
</li>
<li class="stepexpand"><span>Protocol specification (HTTP header, and so on)</span></li>
<li class="stepexpand"><span><code>XMLDecl</code> specification</span></li>
<li class="stepexpand"><span>User&#39;s default input encoding</span></li>
<li class="stepexpand"><span>The default, which is UTF-8 on ASCII platforms or UTF-E on EBCDIC platforms</span></li>
</ol>
<div class="section">
<p>After the application has determined the input encoding, it can parse the document and present the data. You are allowed to choose the presentation encoding; the data is in that encoding regardless of the original input encoding.</p>
<p>When an application writes back a DOM in serialized form, it can choose at that time to re-encode the presentation data. Thus, you can place the serialized document in any encoding.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19771"></a><a id="ADXDK19770"></a>
<div class="props_rev_3"><a id="GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646"></a>
<h3 id="ADXDK-GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646" class="sect3"><span class="enumeration_section">20.3.2</span> Using NULL-Terminated and Length-Encoded C API Functions</h3>
<div>
<p>The native string representation in C is null-terminated. Thus, the primary DOM interface takes and returns null-terminated strings. When stored in table form, however, Oracle XML DB data is <span class="italic">not</span> null-terminated but <span class="italic">length-encoded</span>. Consequently, XDK provides an additional set of length-encoded APIs for the high-frequency cases to improve performance. In particular, the DOM functions in <a href="adx_c_parser.htm#GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646__CCHBCCCF" title="NULL-Terminated API and Length-Encoded API are the columns.">Table 20-5</a> have dual APIs.</p>
<div class="tblformal" id="GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646__CCHBCCCF">
<p class="titleintable">Table 20-5 NULL-Terminated and Length-Encoded C API Functions</p>
<table class="cellalignment650" title="NULL-Terminated and Length-Encoded C API Functions " summary="NULL-Terminated API and Length-Encoded API are the columns.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment689" id="d102267e2585">NULL-Terminated API</th>
<th class="cellalignment730" id="d102267e2588">Length-Encoded API</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment691" id="d102267e2593" headers="d102267e2585">
<p><code>XmlDomGetNodeName()</code></p>
</td>
<td class="cellalignment731" headers="d102267e2593 d102267e2588">
<p><code>XmlDomGetNodeNameLen()</code></p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment691" id="d102267e2602" headers="d102267e2585">
<p><code>XmlDomGetNodeLocal()</code></p>
</td>
<td class="cellalignment731" headers="d102267e2602 d102267e2588">
<p><code>XmlDomGetNodeLocalLen()</code></p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment691" id="d102267e2611" headers="d102267e2585">
<p><code>XmlDomGetNodeURI()</code></p>
</td>
<td class="cellalignment731" headers="d102267e2611 d102267e2588">
<p><code>XmlDomGetNodeURILen()</code></p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment691" id="d102267e2620" headers="d102267e2585">
<p><code>XmlDomGetNodeValue()</code></p>
</td>
<td class="cellalignment731" headers="d102267e2620 d102267e2588">
<p><code>XmlDomGetNodeValueLen()</code></p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment691" id="d102267e2629" headers="d102267e2585">
<p><code>XmlDomGetAttrName()</code></p>
</td>
<td class="cellalignment731" headers="d102267e2629 d102267e2588">
<p><code>XmlDomGetAttrNameLen()</code></p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment691" id="d102267e2638" headers="d102267e2585">
<p><code>XmlDomGetAttrLocal()</code></p>
</td>
<td class="cellalignment731" headers="d102267e2638 d102267e2588">
<p><code>XmlDomGetAttrLocalLen()</code></p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment691" id="d102267e2647" headers="d102267e2585">
<p><code>XmlDomGetAttrURI()</code></p>
</td>
<td class="cellalignment731" headers="d102267e2647 d102267e2588">
<p><code>XmlDomGetAttrURILen()</code></p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment691" id="d102267e2656" headers="d102267e2585">
<p><code>XmlDomGetAttrValue()</code></p>
</td>
<td class="cellalignment731" headers="d102267e2656 d102267e2588">
<p><code>XmlDomGetAttrValueLen()</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="ADXDK19772"></a>
<div class="props_rev_3"><a id="GUID-462C7E68-35A3-4CD9-A767-B0F900E92BE8"></a>
<h3 id="ADXDK-GUID-462C7E68-35A3-4CD9-A767-B0F900E92BE8" class="sect3"><span class="enumeration_section">20.3.3</span> Handling Errors with the C API</h3>
<div>
<div class="section">
<p>The C API functions typically either return a numeric error code (0 for success, nonzero on failure), or pass back an error code through a variable. In all cases, the API stores error codes. Your application can retrieve the most recent error by invoking the <code>XmlDomGetLastError()</code> function.</p>
<p>By default, the functions output error messages to <code>stderr</code>. However, you can register an error message callback at initialization time. When an error occurs, the application invokes the registered callback and does not print an error.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDK99935"></a><a id="ADXDK99918"></a>
<div class="props_rev_3"><a id="GUID-B36E81CE-DD87-4619-B308-708175CCDD0B"></a>
<h2 id="ADXDK-GUID-B36E81CE-DD87-4619-B308-708175CCDD0B" class="sect2"><span class="enumeration_section">20.4</span> Using orastream Functions</h2>
<div>
<div class="section">
<p>The orastream function API is an interface that enables you to stream large chunks of data out of a node instead of getting it all in one piece. Nodes of greater than 64 KB are thus accessible.</p>
<p>The orastream API represents a generic input or output stream. This interface is available to XDK users through <code>xml.h</code> and is defined by the <code>orastream</code> data structure and a set of functions that implement the interface. The creator of the stream passes a list of stream function addresses, along with a stream context to <code>OraStreamInit</code>. This function returns an instance of an <code>orastream</code> structure.</p>
<p>Several stream properties are specified at the time of initialization. If read or write is provided, the stream operates in byte mode using <code>OraStreamRead()</code> and <code>OraStreamWrite()</code>. If &#34;read_char&#34; or &#34;write_char&#34; is provided, the stream operates in character mode using <code>OraStreamReadChar()</code> and <code>OraStreamWriteChar()</code>. In character mode only complete characters are read or written and are never split over buffer boundaries.</p>
<p>A stream context is used to represent the state of the orastream and it persists for the lifetime of a stream.</p>
<p>Just like the input or output streams in Java, a source or a sink for the data is always specified. Output streams store the address of the external stream or object where they must populate the data. Similarly, input streams store the address of the object that is read.</p>
<p>Here are the orastream functions:</p>
<pre dir="ltr">struct orastream;
typedef struct orastream orastream;
typedef ub4 oraerr; /* Error code: zero is success, non-zero is failure */
</pre>
<pre dir="ltr">/* Initialize (Create) &amp; Destroy (Terminate) stream object */
 
orastream  *OraStreamInit(void *sctx, void *sid, oraerr *err, ...);
oraerr     OraStreamTerm(orastream *stream);
 
/* Set or Change SID (streamID) for stream (returns old stream ID through osid)*/
 
oraerr     OraStreamSid(orastream *stream, void *sid, void **osid);
 
/* Is a stream readable or writable? */
 
boolean    OraStreamReadable(orastream *stream);
boolean    OraStreamWritable(orastream *stream);
 
/* Open &amp; Close stream */
 
oraerr     OraStreamOpen(orastream *stream, ubig_ora *length);
oraerr     OraStreamClose(orastream *stream);
 
/* Read | Write byte stream */
 
oraerr     OraStreamRead(orastream *stream, oratext *dest, ubig_ora size,
           oratext **start, ubig_ora *nread, ub1 *eoi);
oraerr     OraStreamWrite(orastream *stream, oratext *src, ubig_ora size,
           ubig_ora *nwrote);
 
/* Read | Write char stream */
 
oraerr     OraStreamReadChar(orastream *stream, oratext *dest, ubig_ora size,
           oratext **start, ubig_ora *nread, ub1 *eoi);
oraerr     OraStreamWriteChar(orastream *stream, oratext *src, ubig_ora size,
           ubig_ora *nwrote);
 
/* Return handles for stream */
 
orastreamhdl *OraStreamHandle(orastream *stream);
 
/* Returns status: if the stream object is currently opened or not */

boolean OraStreamIsOpen(orastream *stream);
</pre>
<p>The stream error codes are:</p>
<pre dir="ltr">#define ORASTREAM_ERR_NULL_POINTER      1      /* NULL pointer given */
#define ORASTREAM_ERR_BAD_STREAM        2      /* invalid stream object */
#define ORASTREAM_ERR_WRONG_DECTION     3      /* tried wrong-direction I/O */
#define ORASTREAM_ERR_UNKNOWN_PROPERTY  4      /* unknown creation prop */
#define ORASTREAM_ERR_NO_DIRECTION      5      /* neither read nor write? */
#define ORASTREAM_ERR_BI_DIRECTION      6      /* both read any write? */
#define ORASTREAM_ERR_NOT_OPEN          7      /* stream not open */
#define ORASTREAM_ERR_WRONG_MODE        8      /* wrote byte/char mode */
/* --- Open errors --- */
#define ORASTREAM_ERR_CANT_OPEN         10     /* can&#39;t open stream */
/* --- Close errors --- */
#define ORASTREAM_ERR_CANT_CLOSE        20     /* can&#39;t close stream */
</pre>
<div class="infoboxnotealso" id="GUID-B36E81CE-DD87-4619-B308-708175CCDD0B__GUID-A39B7D88-BB54-490A-A7C1-B6A327B1FC53">
<p class="notep1">See Also:</p>
<p><a class="olink CAXML01400" target="_blank" href="../CAXML/orastream.htm#CAXML01400"><span class="italic">Oracle Database XML C API Reference</span></a> for reference information such as parameter definitions in the orastream API</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-B36E81CE-DD87-4619-B308-708175CCDD0B__GUID-C03C7044-B5BF-4362-9F13-A1CD877C0ED2">
<p class="titleinexample">Example 20-3 Using orastream Functions</p>
<pre dir="ltr">int test_read()
{
   xmlctx *xctx = NULL;
   oratext *barray, *docName = &#34;NSExample.xml&#34;;
   orastream* ostream = (orastream *) 0;
   xmlerr ecode = 0;
   ub4 wcount = 0;
   ubig_ora  destsize, nread;
   oraerr oerr = 0;
   ub1 eoi = 0;
   nread = destsize = 1024;
   if (!(xctx = XmlCreateNew(&amp;ecode, (oratext *)&#34;stream_xctx&#34;, NULL, wcount,
                             NULL)))
    {
       printf(&#34;Failed to create XML context, error %u\n&#34;, (unsigned)ecode);
       return -1;
    }
 
   barray = XmlAlloc(xctx, sizeof(oratext) * destsize);
    
   /* open function should be specified in order to read correctly. */
   if (!(ostream = OraStreamInit(NULL,docName, (oraerr *)&amp;ecode,
                                 &#34;open&#34;, fileopen,  
                                 &#34;read&#34;, fileread,
                                 NULL)))
   {
      printf(&#34;Failed to initialize OrsStream, error %u\n&#34;,(unsigned)ecode);
      return -1;
   }  
 
   /* check readable and writable  */
    if (OraStreamReadable(ostream))
       printf(&#34;ostream is readable\n&#34;);
    else
       printf(&#34;ostream is not readable\n&#34;);
 
     if (OraStreamWritable(ostream))
       printf(&#34;ostream is writable\n&#34;);
    else
       printf(&#34;ostream is not writable\n&#34;);
    
    if (oerr = OraStreamRead(ostream, barray, destsize, &amp;barray, &amp;nread, &amp;eoi))
    {
      printf(&#34;Failed to read due to orastream was not open, error %u\n&#34;, oerr);
    }
 
   /* open orastream */
   OraStreamOpen(ostream, NULL);
 
   /* read document */
   OraStreamRead(ostream, barray, destsize, &amp;barray, &amp;nread, &amp;eoi);
   
   OraStreamTerm(ostream);
    
   XmlDestroy(xctx);
   return 0;
}
ORASTREAM_OPEN_F(fileopen, sctx, sid, hdl, length)
{
    FILE *fh = NULL;
 
    printf(&#34;Opening orastream %s...\n&#34;, (oratext *)sid);
 
    if (sid &amp;&amp; ((fh= fopen(sid, &#34;r&#34;)) != NULL))
    {
        printf(&#34;Opening orastream %s...\n&#34;, (oratext *)sid);
    }
    else
    {
         printf(&#34;Failed to open input file.\n&#34;);
         return -1;
     }
 
    /* store file handle generically, NULL means stdout */
    hdl-&gt;ptr_orastreamhdl = fh;
 
    return XMLERR_OK;
}
 
ORASTREAM_READ_F(fileread, sctx, sid, hdl,
                         dest, size, start, nread, eoi)
{
    FILE *fh = NULL;
    int i =0;
    printf(&#34;Reading orastream %s ...\n&#34;, (oratext *)sid);
    
    // read data from file to dest
    if ((fh = (FILE *) hdl-&gt;ptr_orastreamhdl) != NULL)
        *nread = fread(dest, 1, size, fh);
    printf(&#34;Read %d bytes from orastream...\n&#34;, (int) *nread);
 
    *eoi = (*nread &lt; size);
    if (start)
        *start = dest;
 
    printf(&#34;printing document ...\n&#34;);
    for(i =0; i &lt; *nread; i++)
    printf(&#34;%c&#34;, (char)dest[i]);
    printf(&#34;\nend ...\n&#34;);
    return ORAERR_OK;
}
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDK19773"></a>
<div class="props_rev_3"><a id="GUID-34FE324C-DF9F-4FE7-B2EF-48FE4FB38B6E"></a>
<h2 id="ADXDK-GUID-34FE324C-DF9F-4FE7-B2EF-48FE4FB38B6E" class="sect2"><span class="enumeration_section">20.5</span> Using the SAX API for C</h2>
<div>
<div class="section">
<p>To use SAX, initialize an <code>xmlsaxcb</code> structure with function pointers and pass it to <code>XmlLoadSax()</code>. You can also include a pointer to a user-defined context structure, which you pass to each SAX function.</p>
<div class="infoboxnotealso" id="GUID-34FE324C-DF9F-4FE7-B2EF-48FE4FB38B6E__GUID-883F4A36-85D5-40CA-B3D1-BCD12F56ED17">
<p class="notep1">See Also:</p>
<p><a class="olink CAXML5908" target="_blank" href="../CAXML/sax.htm#CAXML5908"><span class="italic">Oracle Database XML C API Reference</span></a> for the SAX callback structure</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK1038"></a><a id="ADXDK1410"></a>
<div class="props_rev_3"><a id="GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC"></a>
<h2 id="ADXDK-GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC" class="sect2"><span class="enumeration_section">20.6</span> Using the XML Pull Parser for C</h2>
<div>
<div class="section">
<p>The XML Pull Parser is an implementation of the XML Events interface.</p>
<p>The XML Pull Parser and the SAX parser are similar, but using the Pull Parser, the application (consumer) drives the events, while in SAX, the parser (producer) drives the events. Both the XML Pull Parser and SAX represent the document as a sequence of events, with start tags, end tags, and comments.XML Pull Parser gives control to the application by exposing a simple set of APIs and an underlying set of events. Methods such as <code>XmlEvNext</code> allow an application to ask for (or pull) the next event, rather than handling the event in a callback, as in SAX. Thus, the application has more procedural control over XML processing. Also, the application can decide to stop further processing, unlike a SAX application, which parses the entire document.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Topics:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="adx_c_parser.htm#GUID-9440C355-936A-44ED-99A9-80B49758D000">Using Basic XML Pull Parsing Capabilities</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-75020C67-9F3A-46DA-81C9-08CA086135E8">Parsing Multiple XML Documents</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-48E4B443-A445-4BAA-9A5F-11096A355BFE">ID Callback</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-D17D4D58-50E4-4C6E-BA79-91E5F196F04C">Error Handling for the XML Pull Parser</a></p>
</li>
<li>
<p><a href="adx_c_parser.htm#GUID-DAE9B130-2651-403C-8442-A71634C12312">Sample Pull Parser Application</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="ADXDK19774"></a>
<div class="props_rev_3"><a id="GUID-9440C355-936A-44ED-99A9-80B49758D000"></a>
<h3 id="ADXDK-GUID-9440C355-936A-44ED-99A9-80B49758D000" class="sect3"><span class="enumeration_section">20.6.1</span> Using Basic XML Pull Parsing Capabilities</h3>
<div>
<div class="section">
<p>To use the XML Pull Parser, your application must do these steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Invoke <code>XmlCreate</code> to initialize the XML meta-context.</span></li>
<li class="stepexpand"><span>Initialize the Pull Parser context by invoking the <code>XmlEvCreatePPCtx</code> function, which creates and returns the event context.</span>
<div>
<p>The <code>XmlEvCreatePPCtx</code> function supports all the properties supported by <code>XmlLoadDom</code> and <code>XmlLoadSax</code>, plus some additional ones.</p>
<p>The <code>XmlEvCreatePPCtx</code> and <code>XmlEvCreatePPCtxVA</code> functions are fully implemented.</p>
</div>
</li>
<li class="stepexpand"><span>Ensure that the event context is passed to all subsequent invocations of the Pull Parser.</span></li>
<li class="stepexpand"><span>Terminate the Pull Parser context by invoking the <code>XmlEvDestoryPPCtx</code> function, to clean up memory.</span></li>
<li class="stepexpand"><span>Destroy the XML meta-context by invoking the <code>XmlDestoryCtx</code> function.</span></li>
</ol>
</div>
<a id="ADXDK19776"></a><a id="ADXDK19775"></a>
<div class="props_rev_3"><a id="GUID-DC1CF9B5-DCD1-4743-950B-EDBFD9E5ABEF"></a>
<h4 id="ADXDK-GUID-DC1CF9B5-DCD1-4743-950B-EDBFD9E5ABEF" class="sect4"><span class="enumeration_section">20.6.1.1</span> XML Event Context</h4>
<div>
<p><a href="adx_c_parser.htm#GUID-DC1CF9B5-DCD1-4743-950B-EDBFD9E5ABEF__CCHJDIHJ">Example 20-4</a> shows the structure of the event context.</p>
<div class="example" id="GUID-DC1CF9B5-DCD1-4743-950B-EDBFD9E5ABEF__CCHJDIHJ">
<p class="titleinexample">Example 20-4 XML Event Context</p>
<pre dir="ltr">typedef  struct {
   void *ctx_xmlevctx;                   /* implementation specific context */
   xmlevdisp *disp_xmlevctx;             /* dispatch table */
   ub4 checkword_xmlevctx;               /* checkword for integrity check */
   ub4 flags_xmlevctx;                   /* mode; default: expand_entity */
   struct xmlevctx *input_xmlevctx;      /* input xmlevctx; chains the XML Event
                                            context */
} xmlevctx;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="ADXDK19777"></a>
<div class="props_rev_3"><a id="GUID-60864BD6-729A-409C-B06E-D5454040A0B3"></a>
<h4 id="ADXDK-GUID-60864BD6-729A-409C-B06E-D5454040A0B3" class="sect4"><span class="enumeration_section">20.6.1.2</span> About the XML Event Context</h4>
<div>
<p>Each XML Pull Parser is allowed to create its own context and implement its own API functions.</p>
<ul style="list-style-type: disc;">
<li>
<p>Dispatch Table</p>
<p>The dispatch table, <code>disp_xmlevctx</code>, contains one pointer for each API function, except for the <code>XmlEvCreatePPCtx</code>, <code>XmlEvCreatePPCtxVA</code>, <code>XmlEvDestoryPPCtx</code>, <code>XmlEvLoadPPDoc</code>, and <code>XmlEvCleanPPCtx</code> functions.</p>
<p>When the event context is created, the pointer <code>disp_xmlevctx</code> is initialized with the address of that static table.</p>
</li>
<li>
<p>Implementation-Specific Event Context</p>
<p>The field <code>ctx_xmlevctx</code> must be initialized with the address of the context specific to this invocation of the particular implementation. The implementation-specific event context is of type <code>*void</code>, so that it can differ for different applications.</p>
</li>
<li>
<p>Input Event Context</p>
<p>Each Pull Parser can specify an input event context, <code>xmlevctx</code>. This field enables the parser to chain multiple event producers. As a result, if a dispatch function is specified as <code>NULL</code> in a context, the application uses the next non-null dispatch function in the chain of input event contexts. The base <code>xmlevctx</code> must ensure that all dispatch function pointers are non-null.</p>
</li>
</ul>
</div>
</div>
</div>
<a id="ADXDK19778"></a>
<div class="props_rev_3"><a id="GUID-75020C67-9F3A-46DA-81C9-08CA086135E8"></a>
<h3 id="ADXDK-GUID-75020C67-9F3A-46DA-81C9-08CA086135E8" class="sect3"><span class="enumeration_section">20.6.2</span> Parsing Multiple XML Documents</h3>
<div>
<div class="section">
<p>After creating and initializing the XML Event Context, the application can parse multiple documents with repeated invocations of <code>XmlEvLoadPPDoc</code> and <code>XmlEvCleanPPCtx</code>. These functions are fully implemented.</p>
<p>The properties defined by the application during the XML Event Context creation cannot be changed for each invocation of the <code>XmlLoadPPDoc</code> function. to change the properties, destroy the event context and then re-create it.</p>
<p>After <code>XmlEvCleanPPCtx</code> cleans up the internal structure of the current parser, the event context can be reused to parse another document.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19780"></a><a id="ADXDK19781"></a><a id="ADXDK19782"></a><a id="ADXDK19779"></a>
<div class="props_rev_3"><a id="GUID-48E4B443-A445-4BAA-9A5F-11096A355BFE"></a>
<h3 id="ADXDK-GUID-48E4B443-A445-4BAA-9A5F-11096A355BFE" class="sect3"><span class="enumeration_section">20.6.3</span> ID Callback</h3>
<div>
<p>You can provide a callback to convert text-based names to 8-byte identifiers (IDs).</p>
<div class="section">
<p class="subhead3">Callback Function Signature</p>
</div>
<!-- class="section" -->
<div class="section">
<pre dir="ltr">typedef  sb8 (*xmlev_id_cb_funcp)( void *ctx , ub1 type, ub1 *token, ub4 tok_len,
              sb8 nmspid, boolean isAttribute);
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Return Value</p>
</div>
<!-- class="section" -->
<div class="section">
<p><code>sb8</code>: an 8-byte ID.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Arguments</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>*<code>ctx</code>: The implementation context.</p>
</li>
<li>
<p><code>type</code>: The type, which is indicated by this enumeration:</p>
<pre dir="ltr">typedef enum 
{
  XML_EVENT_ID_URI,
  XML_EVENT_ID_QNAME,
}xmlevidtype;
</pre></li>
<li>
<p>*<code>token</code> and <code>tok_len</code>: The actual text to be converted.</p>
</li>
<li>
<p><code>nmspid</code>: The namespace ID.</p>
</li>
<li>
<p><code>isAttribute</code>: A Boolean value indicating an attribute.</p>
</li>
</ul>
<p>Internally, the <code>XmlEvGetTagId</code> and <code>XmlEvGetAttrID</code> APIs invoke this callback twice, once to fetch the namespace ID and once to fetch the actual ID of the tag or the attribute <code>Qname</code>.</p>
<p>The <code>XmlEvGetTagUriID</code> and <code>XmlEvGetAttrUriID</code> functions invoke this callback once to get the ID of the corresponding Universal Resource Identifier (URI).</p>
<p>If a callback is not supplied, an error <code>XML_ERR_EVENT_NOIDCBK</code> is returned when these APIs are used.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19783"></a>
<div class="props_rev_3"><a id="GUID-D17D4D58-50E4-4C6E-BA79-91E5F196F04C"></a>
<h3 id="ADXDK-GUID-D17D4D58-50E4-4C6E-BA79-91E5F196F04C" class="sect3"><span class="enumeration_section">20.6.4</span> Error Handling for the XML Pull Parser</h3>
<div>
<p>The following sections describe error handling for the XML Pull Parser.</p>
</div>
<a id="ADXDK19784"></a>
<div class="props_rev_3"><a id="GUID-1D5E95DB-55EE-44A7-8360-D530BEAD6477"></a>
<h4 id="ADXDK-GUID-1D5E95DB-55EE-44A7-8360-D530BEAD6477" class="sect4"><span class="enumeration_section">20.6.4.1</span> Parser Errors</h4>
<div>
<p>The XML Pull Parser returns the message <code>XML_EVENT_FATAL_ERROR</code> when it throws an error because the input document is malformed. The <code>XmlEvGetError</code> function is provided to get the error number and message.</p>
<p>During the <code>XmlEvCreatePPCtx</code> operation, any error handler supplied by the application during <code>XmlCreate</code> is overridden. The application must invoke the <code>XmlErrSetHandler</code> function after the <code>XmlEvDestroyPPCtx</code> operation to restore the original callback.</p>
</div>
</div>
<a id="ADXDK19785"></a>
<div class="props_rev_3"><a id="GUID-A32A6E3E-CA3E-4ED5-9FA3-AFC9DC357331"></a>
<h4 id="ADXDK-GUID-A32A6E3E-CA3E-4ED5-9FA3-AFC9DC357331" class="sect4"><span class="enumeration_section">20.6.4.2</span> Programming Errors</h4>
<div>
<div class="section">
<p>To handle programmatic errors. XDK provides a callback that the application can supply when creating an event context. This callback is invoked when the application invokes an illegal API. The callback signature is:</p>
<pre dir="ltr">typedef  void (* xmlev_err_cb_funcp)(xmlctx *xctx, xmlevctx *evctx, 
        xmlevtype cur_event);
</pre>
<p>An example of an illegal API invocation is:</p>
<p><code>XmlEvGetName</code> cannot be called for the <code>XML_EVENT_CHARACTERS</code> event.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="ADXDK19788"></a><a id="ADXDK19790"></a><a id="ADXDK19792"></a><a id="ADXDK19786"></a>
<div class="props_rev_3"><a id="GUID-DAE9B130-2651-403C-8442-A71634C12312"></a>
<h3 id="ADXDK-GUID-DAE9B130-2651-403C-8442-A71634C12312" class="sect3"><span class="enumeration_section">20.6.5</span> Sample Pull Parser Application</h3>
<div>
<p>This section contains a sample pull parser application, a document to be parsed, and a list of the events that the application generates from the document.</p>
<p><a href="adx_c_parser.htm#GUID-DAE9B130-2651-403C-8442-A71634C12312__BABCJHAB">Example 20-5</a> shows the sample application code.</p>
<p><a href="adx_c_parser.htm#GUID-DAE9B130-2651-403C-8442-A71634C12312__BGBCACGI">Example 20-6</a> shows the sample document to be parsed.</p>
<p><a href="adx_c_parser.htm#GUID-DAE9B130-2651-403C-8442-A71634C12312__BGBBEAEB">Example 20-7</a> shows the sequence of events generated when the attribute events property is <code>FALSE</code> and the expand entities properties is <code>TRUE</code>.</p>
<div class="example" id="GUID-DAE9B130-2651-403C-8442-A71634C12312__BABCJHAB">
<p class="titleinexample">Example 20-5 Sample Pull Parser Application Example</p>
<pre dir="ltr"># include &#34;xml.h&#34;
# include &#34;xmlev.h&#34;
...
xmlctx *xctx;
xmlevctx *evtcx;
if (!(xctx = XmlCreate(&amp;xerr, (oratext *) &#34;test&#34;)))
{
    printf(&#34;Failed to create XML context, error %u\n&#34;, (unsigned) xerr);
    return -1;
}
...
if(!(evctx = XmlEvCreatePPCtx(xctx, &amp;xerr, NULL)))
{
   printf(&#34;Failed to create EVENT context, error %u\n&#34;, (unsigned) xerr);
   return -1;
 }
for(i = 0; i &lt; numDocs; i++)
{
  if (xerr = XmlEvLoadPPDoc(xctx, evctx, &#34;file&#34;, input_filenames[i], 0, NULL)
     {
       printf(&#34;Failed to load the document, error %u\n&#34;, (unsigned) xerr);
       return -1;
     }
...
  for(;;)
  {
    xmlevtype cur_event;
    cur_event = XmlEvNext(evctx);
    switch(cur_event)
         {
               case XML_EVENT_FATAL_ERROR:
                     XmlEvGetError(evctx, (oratext **)&amp;errmsg);
                          printf(&#34;Error %s\n&#34;, errmsg);
               return;
               case XML_EVENT_START_ELEMENT:
                     printf(&#34;&lt;%s&gt;&#34;, XmlEvGetName0(evctx));
               break;
               case XML_EVENT_END_DOCUMENT:
                     printf(&#34;&lt;%s&gt;&#34;, XmlEvGetName0(evctx));
               return;
         }
  }
  XmlEvCleanPPCtx(xctx, evctx);
}
XmlEvDestroyPPCtx(xctx, evctx);
XmlDestroy(xctx);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-DAE9B130-2651-403C-8442-A71634C12312__BGBCACGI">
<p class="titleinexample">Example 20-6 Sample Document to Parse</p>
<pre dir="ltr">&lt;!DOCTYPE doc [
&lt;!ENTITY ent SYSTEM &#34;file:attendees.txt&#34;&gt;
&lt;!ELEMENT doc ANY&gt;
&lt;!ELEMENT meeting (topic, date, publishAttendees)&gt;
&lt;!ELEMENT publishAttendees (#PCDATA)&gt;
&lt;!ELEMENT topic (#PCDATA)&gt;
&lt;!ELEMENT date (#PCDATA)&gt;
]&gt;
&lt;!-- Begin Document --&gt;
&lt;doc&gt;
  &lt;!-- Info about the meeting --&gt;
  &lt;meeting&gt;
    &lt;topic&gt;Group meeting&lt;/topic&gt;
    &lt;date&gt;April 25, 2005&lt;/date&gt;
    &lt;publishAttendees&gt;&amp;ent;&lt;/publishAttendees&gt;
  &lt;/meeting&gt;
&lt;/doc&gt;
&lt;!-- End Document --&gt;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-DAE9B130-2651-403C-8442-A71634C12312__BGBBEAEB">
<p class="titleinexample">Example 20-7 Events Generated by Parsing a Sample Document</p>
<pre dir="ltr">XML_EVENT_START_DOCUMENT
XML_EVENT_START_DTD
XML_EVENT_PE_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_END_DTD 
XML_EVENT_COMMENT
XML_EVENT_START_ELEMENT
XML_EVENT_SPACE
XML_EVENT_COMMENT
XML_EVENT_SPACE
XML_EVENT_START_ELEMENT
XML_EVENT_START_ELEMENT
XML_EVENT_CHARACTERS
XML_EVENT_END_ELEMENT
XML_EVENT_START_ELEMENT
XML_EVENT_CHARACTERS
XML_EVENT_END_ELEMENT
XML_EVENT_START_ELEMENT
XML_EVENT_START_ENTITY
XML_EVENT_CHARACTERS
XML_EVENT_END_ENTITY
XML_EVENT_END_ELEMENT
XML_EVENT_END_ELEMENT
XML_EVENT_SPACE
XML_EVENT_END_ELEMENT
XML_EVENT_COMMENT
XML_EVENT_END_DOCUMENT
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="ADXDK19793"></a>
<div class="props_rev_3"><a id="GUID-0B3D2810-F81E-4748-9E2B-152865F2A8B3"></a>
<h2 id="ADXDK-GUID-0B3D2810-F81E-4748-9E2B-152865F2A8B3" class="sect2"><span class="enumeration_section">20.7</span> Using OCI and the XDK for C API</h2>
<div>
<div class="section">
<p>This section describes accessing XDK for C functions from Oracle Call Interface (OCI).</p>
</div>
<!-- class="section" --></div>
<a id="ADXDK19795"></a><a id="ADXDK19794"></a>
<div class="props_rev_3"><a id="GUID-0E4FBFA3-1B16-4886-A5B9-A0F5A8FA9693"></a>
<h3 id="ADXDK-GUID-0E4FBFA3-1B16-4886-A5B9-A0F5A8FA9693" class="sect3"><span class="enumeration_section">20.7.1</span> Using XMLType Functions and Descriptions</h3>
<div>
<div class="section">
<p>You can use the C API for XML with <code>XMLType</code> columns in the database. An Oracle Call Interface (OCI) program can access XML data stored in a table by initializing the values of OCI handles such as:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Environment handle</p>
</li>
<li>
<p>Service handle</p>
</li>
<li>
<p>Error handle</p>
</li>
<li>
<p>Optional parameters</p>
</li>
</ul>
<p>The program can pass these input values to the function <code>OCIXmlDbInitXmlCtx()</code>, which returns an XML context. After the program invokes the C API, the function <code>OCIXmlDbFreeXmlCtx()</code> frees the context.</p>
<p><a href="adx_c_parser.htm#GUID-0E4FBFA3-1B16-4886-A5B9-A0F5A8FA9693__CCHBDJDE" title="Description and Function Name are the columns.">Table 20-6</a> describes a few of the functions for XML operations.</p>
<div class="tblformal" id="GUID-0E4FBFA3-1B16-4886-A5B9-A0F5A8FA9693__CCHBDJDE">
<p class="titleintable">Table 20-6 XMLType Functions</p>
<table class="cellalignment650" title="XMLType Functions " summary="Description and Function Name are the columns.">
<thead>
<tr class="cellalignment644">
<th class="cellalignment767" id="d102267e4292">Function Name</th>
<th class="cellalignment768" id="d102267e4295">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4300" headers="d102267e4292">
<p><code>XmlCreateDocument()</code></p>
</td>
<td class="cellalignment770" headers="d102267e4300 d102267e4295">
<p>Create empty <code>XMLType</code> instance</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4311" headers="d102267e4292">
<p><code>XmlLoadDom()</code> and so on</p>
</td>
<td class="cellalignment770" headers="d102267e4311 d102267e4295">
<p>Create from a source buffer</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4320" headers="d102267e4292">
<p><code>XmlXPathEvalexpr()</code> and family</p>
</td>
<td class="cellalignment770" headers="d102267e4320 d102267e4295">
<p>Extract an <code>XPath</code> expression</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4332" headers="d102267e4292">
<p><code>XmlXslProcess()</code> and family</p>
</td>
<td class="cellalignment770" headers="d102267e4332 d102267e4295">
<p>Transform using an Extensible Stylesheet Language Transformation (XSLT) style sheet</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4341" headers="d102267e4292">
<p><code>XmlXPathEvalexpr()</code> and family</p>
</td>
<td class="cellalignment770" headers="d102267e4341 d102267e4295">
<p>Check if an <code>XPath</code> exists</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4353" headers="d102267e4292">
<p><code>XmlDomIsSchemaBased()</code></p>
</td>
<td class="cellalignment770" headers="d102267e4353 d102267e4295">
<p>Is document schema-based?</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4361" headers="d102267e4292">
<p><code>XmlDomGetSchema()</code></p>
</td>
<td class="cellalignment770" headers="d102267e4361 d102267e4295">
<p>Get schema information</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4369" headers="d102267e4292">
<p><code>XmlDomGetNodeURI()</code></p>
</td>
<td class="cellalignment770" headers="d102267e4369 d102267e4295">
<p>Get document namespace</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4377" headers="d102267e4292">
<p><code>XmlSchemaValidate()</code></p>
</td>
<td class="cellalignment770" headers="d102267e4377 d102267e4295">
<p>Validate using schema</p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4385" headers="d102267e4292">
<p>Cast <code>(void *)</code> to <code>(xmldocnode *)</code></p>
</td>
<td class="cellalignment770" headers="d102267e4385 d102267e4295">
<p>Get DOM from <code>XMLType</code></p>
</td>
</tr>
<tr class="cellalignment644">
<td class="cellalignment769" id="d102267e4399" headers="d102267e4292">
<p>Cast <code>(xmldocnode *)</code> to <code>(void *)</code></p>
</td>
<td class="cellalignment770" headers="d102267e4399 d102267e4295">
<p>Get <code>XMLType</code> from DOM</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19796"></a>
<div class="props_rev_3"><a id="GUID-AFBCF39A-784B-4D78-9613-6E11EEBE4A20"></a>
<h3 id="ADXDK-GUID-AFBCF39A-784B-4D78-9613-6E11EEBE4A20" class="sect3"><span class="enumeration_section">20.7.2</span> Initializing an XML Context for Oracle XML DB</h3>
<div>
<div class="section">
<p>An XML context is a required parameter in all the C DOM API functions. This opaque context encapsulates information pertaining to data encoding, error message language, and so on. The contents of this XML context are different for XDK applications and for Oracle XML DB applications.</p>
<div class="infobox-note" id="GUID-AFBCF39A-784B-4D78-9613-6E11EEBE4A20__GUID-0EF7C0D6-C9B5-4ED6-8B63-7C282A5E238F">
<p class="notep1">Note:</p>
<p>Do not use an XML context for XDK in an Oracle XML DB application, or an XML context for Oracle XML DB in an XDK application.</p>
</div>
<p>For Oracle XML DB, the two OCI functions that initialize and free an XML context have these prototypes:</p>
<pre dir="ltr">xmlctx *OCIXmlDbInitXmlCtx (OCIEnv *envhp, OCISvcCtx *svchp, OCIError *errhp,
       ocixmldbparam *params, ub4 num_params);

void OCIXmlDbFreeXmlCtx (xmlctx *xctx);
</pre>
<div class="infoboxnotealso" id="GUID-AFBCF39A-784B-4D78-9613-6E11EEBE4A20__GUID-F3A2423D-C0FF-4FF9-82D3-3C6377347C10">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink LNOCI220" target="_blank" href="../LNOCI/oci23xml.htm#LNOCI220"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for reference material on the functions</p>
</li>
<li>
<p><a class="olink LNOCI1390" target="_blank" href="../LNOCI/oci14oca.htm#LNOCI1390"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for a discussion about OCI support for XML</p>
</li>
<li>
<p><a class="olink CAXML00300" target="_blank" href="../CAXML/dom.htm#CAXML00300"><span class="italic">Oracle Database XML C API Reference</span></a> for reference information on the DOM APIs</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19797"></a>
<div class="props_rev_3"><a id="GUID-E6F4271E-BBF5-46C2-B8AB-C1702175BBB0"></a>
<h3 id="ADXDK-GUID-E6F4271E-BBF5-46C2-B8AB-C1702175BBB0" class="sect3"><span class="enumeration_section">20.7.3</span> Creating XMLType Instances on the Client</h3>
<div>
<div class="section">
<p>You can construct new <code>XMLType</code> instances on the client by using the <code>XmlLoadDom()</code> invocations. Follow these basic steps:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>You must initialize the <code>xmlctx</code>, as showd in the example in <span class="q">&#34;<a href="adx_c_parser.htm#GUID-0C749FC8-C0B3-41AF-9382-82F0E4FC3BEF">Using the DOM API for C</a>.&#34;</span></span></li>
<li class="stepexpand"><span>You can construct the XML data itself from these sources:</span>
<div>
<ul style="list-style-type: disc;">
<li>
<p>User buffer</p>
</li>
<li>
<p>Local file</p>
</li>
<li>
<p>URI</p>
</li>
</ul>
<p>The return value from these is an <code>(xmldocnode *)</code>, which you can use in the rest of the common C API.</p>
</div>
</li>
<li class="stepexpand"><span>You can cast the <code>(xmldocnode *)</code> to a (<code>void *)</code> and directly provide it as the bind value if required.</span></li>
</ol>
<div class="section">
<p>You can construct empty <code>XMLType</code> instances by invoking <code>XmlCreateDocument()</code>. This function would be equivalent to an <code>OCIObjectNew()</code> for other types. You can operate on the <code>(xmldocnode *)</code> returned by the preceding invocation and finally cast it to a <code>(void *)</code> if it must be provided as a bind value.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19798"></a>
<div class="props_rev_3"><a id="GUID-62F87C40-EB28-4B61-9CE1-2692C7EB5F60"></a>
<h3 id="ADXDK-GUID-62F87C40-EB28-4B61-9CE1-2692C7EB5F60" class="sect3"><span class="enumeration_section">20.7.4</span> Operating on XML Data in the Database Server</h3>
<div>
<div class="section">
<p>You can operate on XML data in Oracle Database with OCI statement invocations. You can bind and define <code>XMLType</code> values using <code>xmldocnode</code> and use OCI statements to select XML data from the database. You can use this data directly in the C DOM functions. Similarly, you can bind the values directly to SQL statements.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="ADXDK19800"></a><a id="ADXDK19801"></a><a id="ADXDK19799"></a>
<div class="props_rev_3"><a id="GUID-649191E3-099B-49C4-97E3-4DC58F3960C0"></a>
<h3 id="ADXDK-GUID-649191E3-099B-49C4-97E3-4DC58F3960C0" class="sect3"><span class="enumeration_section">20.7.5</span> Using OCI and the XDK for C API: Examples</h3>
<div>
<div class="section">
<p><a href="adx_c_parser.htm#GUID-649191E3-099B-49C4-97E3-4DC58F3960C0__CCHHJFAE">Example 20-8</a> shows how to construct a schema-based document with the DOM API and save it to the database. You must include the header files <code>xml.h</code> and <code>ocixmldb.h</code>.</p>
<p><a href="adx_c_parser.htm#GUID-649191E3-099B-49C4-97E3-4DC58F3960C0__CCHDJDBE">Example 20-9</a> shows how to get a document from the database and modify it with the DOM API.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-649191E3-099B-49C4-97E3-4DC58F3960C0__CCHHJFAE">
<p class="titleinexample">Example 20-8 Constructing a Schema-Based Document with the DOM API</p>
<pre dir="ltr">#include &lt;xml.h&gt;
#include &lt;ocixmldb.h&gt;
static oratext tlpxml_test_sch[] = &#34;&lt;TOP xmlns=&#39;example1.xsd&#39;\n\
xmlns:xsi=&#39;http://www.w3.org/2001/XMLSchema-instance&#39; \n\
xsi:schemaLocation=&#39;example1.xsd example1.xsd&#39;/&gt;&#34;;

void example1()
{
    OCIEnv *envhp;
    OCIError *errhp;
    OCISvcCtx *svchp;
    OCIStmt *stmthp;
    OCIDuration dur;
    OCIType *xmltdo;

    xmldocnode  *doc;
    ocixmldbparam params[1];
    xmlnode *quux, *foo, *foo_data;
    xmlerr       err;

    /* Initialize envhp, svchp, errhp, dur, stmthp */
    /* ........ */

    /* Get an xml context */
    params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
    params[0].value_ocixmldbparam = &amp;dur;
    xctx = OCIXmlDbInitXmlCtx(envhp, svchp, errhp, params, 1);

    /* Start processing */ 
    printf(&#34;Supports XML 1.0: %s\n&#34;,
       XmlHasFeature(xctx, (oratext *) &#34;xml&#34;, (oratext *) &#34;1.0&#34;) ? &#34;YES&#34; : &#34;NO&#34;);

    /* Parsing a schema-based document */
    if (!(doc = XmlLoadDom(xctx, &amp;err, &#34;buffer&#34;, tlpxml_test_sch,
                          &#34;buffer_length&#34;, sizeof(tlpxml_test_sch)-1,
                          &#34;validate&#34;, TRUE, NULL)))
    {
       printf(&#34;Parse failed, code %d\n&#34;);
       return;
    }

    /* Create some elements and add them to the document */
    top = XmlDomGetDocElem(xctx, doc);
    quux = (xmlnode *) XmlDomCreateElem(xctx ,doc, (oratext *) &#34;QUUX&#34;);
    foo = (xmlnode *) XmlDomCreateElem(xctx, doc, (oratext *) &#34;FOO&#34;);
    foo_data = (xmlnode *) XmlDomCreateText(xctx, doc, (oratext *)&#34;foo&#39;s data&#34;);
    foo_data = XmlDomAppendChild(xctx, (xmlnode *) foo, (xmlnode *) foo_data);
    foo = XmlDomAppendChild(xctx, quux, foo);
    quux = XmlDomAppendChild(xctx, top, quux);

    XmlSaveDom(xctx, &amp;err, top, &#34;stdio&#34;, stdout, NULL);
    XmlSaveDom(xctx, &amp;err, doc, &#34;stdio&#34;, stdout, NULL);

    /* Insert the document to my_table */
    ins_stmt = &#34;insert into my_table values (:1)&#34;;

    status = OCITypeByName(envhp, errhp, svchp, (const text *) &#34;SYS&#34;,
                   (ub4) strlen((char *)&#34;SYS&#34;), (const text *) &#34;XMLTYPE&#34;,
                   (ub4) strlen((char *)&#34;XMLTYPE&#34;), (CONST text *) 0,
                   (ub4) 0, dur, OCI_TYPEGET_HEADER,
                   (OCIType **) &amp;xmltdo)) ;

    if (status == OCI_SUCCESS)
    {
       exec_bind_xml(svchp, errhp, stmthp, (void *)doc, xmltdo, ins_stmt));
    }

   /* free xml ctx */
   OCIXmlDbFreeXmlCtx(xctx);
}

/*--------------------------------------------------------*/
/* execute a sql statement which binds xml data */
/*--------------------------------------------------------*/
sword exec_bind_xml(svchp, errhp, stmthp, xml, xmltdo, sqlstmt)
OCISvcCtx *svchp;
OCIError *errhp;
OCIStmt *stmthp;
void *xml;
OCIType *xmltdo;
OraText *sqlstmt;
{
   OCIBind *bndhp1 = (OCIBind *) 0;
   OCIBind *bndhp2 = (OCIBind *) 0;
   sword  status = 0;
   OCIInd ind = OCI_IND_NOTNULL;
   OCIInd *indp = &amp;ind;

   if(status = OCIStmtPrepare(stmthp, errhp, (OraText *)sqlstmt,
                    (ub4)strlen((char *)sqlstmt),
                    (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT)) {
     return OCI_ERROR;
   }

   if(status = OCIBindByPos(stmthp, &amp;bndhp1, errhp, (ub4) 1, (dvoid *) 0,
                   (sb4) 0, SQLT_NTY, (dvoid *) 0, (ub2 *)0,
                   (ub2 *)0, (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT)) {
     return OCI_ERROR;
   }

   if(status = OCIBindObject(bndhp1, errhp, (CONST OCIType *) xmltdo,
               (dvoid **) &amp;xml, (ub4 *) 0, (dvoid **) &amp;indp, (ub4 *) 0)) {
     return OCI_ERROR;
   }

   if(status = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                (CONST OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT)) {
     return OCI_ERROR;
  }

   return OCI_SUCCESS;
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-649191E3-099B-49C4-97E3-4DC58F3960C0__CCHDJDBE">
<p class="titleinexample">Example 20-9 Modifying a Database Document with the DOM API</p>
<pre dir="ltr">#include &lt;xml.h&gt;
#include &lt;ocixmldb.h&gt;
sword example2()
{
    OCIEnv *envhp;
    OCIError *errhp;
    OCISvcCtx *svchp;
    OCIStmt *stmthp;
    OCIDuration dur;
    OCIType *xmltdo;
  
    xmldocnode  *doc;
    xmlnodelist *item_list; ub4 ilist_l;
    ocixmldbparam params[1];
    text *sel_xml_stmt = (text *)&#34;SELECT xml_col FROM my_table&#34;;
    ub4    xmlsize = 0;
    sword  status = 0;
    OCIDefine *defnp = (OCIDefine *) 0;

    /* Initialize envhp, svchp, errhp, dur, stmthp */
    /* ... */

    /* Get an xml context */
    params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
    params[0].value_ocixmldbparam = &amp;dur;
    xctx = OCIXmlDbInitXmlCtx(envhp, svchp, errhp, params, 1);

    /* Start processing */
    if(status = OCITypeByName(envhp, errhp, svchp, (const text *) &#34;SYS&#34;,
                   (ub4) strlen((char *)&#34;SYS&#34;), (const text *) &#34;XMLTYPE&#34;,
                   (ub4) strlen((char *)&#34;XMLTYPE&#34;), (CONST text *) 0,
                   (ub4) 0, dur, OCI_TYPEGET_HEADER,
                   (OCIType **) xmltdo_p)) {
       return OCI_ERROR;
    }

    if(!(*xmltdo_p)) {
       printf(&#34;NULL tdo returned\n&#34;);
       return OCI_ERROR;
    }

    if(status = OCIStmtPrepare(stmthp, errhp, (OraText *)selstmt,
                    (ub4)strlen((char *)selstmt),
                    (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT)) {
      return OCI_ERROR;
    }

    if(status = OCIDefineByPos(stmthp, &amp;defnp, errhp, (ub4) 1, (dvoid *) 0,
                   (sb4) 0, SQLT_NTY, (dvoid *) 0, (ub2 *)0,
                   (ub2 *)0, (ub4) OCI_DEFAULT)) {
       return OCI_ERROR;
    }

    if(status = OCIDefineObject(defnp, errhp, (OCIType *) *xmltdo_p,
                            (dvoid **) &amp;doc,
                            &amp;xmlsize, (dvoid **) 0, (ub4 *) 0)) {
      return OCI_ERROR;
    }

    if(status = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                 (CONST OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT)) {
      return OCI_ERROR;
    }

    /* We have the doc. Now we can operate on it */
    printf(&#34;Getting Item list...\n&#34;);

   item_list = XmlDomGetElemsByTag(xctx,(xmlelemnode *) elem,(oratext *)&#34;Item&#34;); 
    ilist_l   = XmlDomGetNodeListLength(xctx, item_list);
    printf(&#34; Item list length = %d \n&#34;, ilist_l);

    for (i = 0; i &lt; ilist_l; i++)
    {
      elem = XmlDomGetNodeListItem(xctx, item_list, i);
      printf(&#34;Elem Name:%s\n&#34;, XmlDomGetNodeName(xctx, fragelem));
      XmlDomRemoveChild(xctx, fragelem);
    }

    XmlSaveDom(xctx, &amp;err, doc, &#34;stdio&#34;, stdout, NULL);

   /* free xml ctx */
   OCIXmlDbFreeXmlCtx(xctx);

   return OCI_SUCCESS;
}
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment643">
<tr>
<td class="cellalignment670">
<table class="cellalignment648">
<tr>
<td class="cellalignment647"><a href="adx_c_xslt.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment647"><a href="adx_c_xmlbin.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment672">
<table class="cellalignment646">
<tr>
<td class="cellalignment647"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment647"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment647"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment647"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment647"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment647"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>