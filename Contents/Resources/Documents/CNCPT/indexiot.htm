<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-4088"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Indexes%20and%20Index-Organized%20Tables"></a><title>Indexes and Index-Organized Tables</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="Indexes are schema objects that can speed access to table rows. Index-organized tables are tables stored in an index structure."/>
<meta name="keywords" content="schema objects, indexes, overview, benefits, full table scans, scans, full table, tables, access paths, data, locks, table, primary keys, unusable, optimizer, invisible indexes, DML (data manipulation language), invisible, foreign keys, indexing, CREATE INDEX statement, keys, expressions, SQL, SQL, expressions, columns, multiple indexes on, multiple, composite, composite indexes, concatenated, concatenated indexes, nulls, indexed, unique, unique indexes, nonunique, nonunique indexes, rowids, index, types, indexes, updates, storage, segments, B-tree, B-tree indexes, prefixed index, branch level, height, height, index, branch blocks, leaf blocks, branch blocks, index, leaf blocks, index, predicates, predicates, SQL, full index, full index scans, fast full index, fast full index scans, fast full scans, range scans, index, selectivity, BOOLEAN data type, data types, BOOLEAN, range scans, unique index, index unique scans, index skip, index clustering factor, Oracle Real Application Clusters, reverse key indexes, reverse key, reverse, ascending, descending, ascending indexes, descending indexes, compression, index compression, concatenation of index, compressed, prefix index, prefixes, key compression, prefix compression, advanced index compression, advanced index, cardinality, column, cardinality, indexed columns, bitmap indexes, data warehouses, bitmap indexes in, bitmap, single-table, equijoins, joins, table, conditions, joins, bitmap joins, bitmap join, function-based, function-based indexes, functions, virtual columns, virtual, cartridges, application domain indexes, application domain, domain, extensible, index-organized, index-organized tables, heap-organized tables, heap-organized, OLAP, characteristics, pseudocolumns, row overflow, secondary indexes, logical, logical rowids, secondary, physical guesses, mapping tables, mapping table"/>
<meta name="dcterms.created" content="2017-07-10T11:33:29Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Concepts"/>
<meta name="dcterms.identifier" content="E41396-15"/>
<meta name="dcterms.isVersionOf" content="CNCPT"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1993, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="tablecls.htm" title="Previous" type="text/html"/>
<link rel="Next" href="schemaob.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41396-15.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-797E49E6-2DCE-4FD4-8E4A-6E761F1383D1"></a> <span id="PAGE" style="display:none;">8/34</span> <!-- End Header -->
<a id="CNCPT721"></a>
<h1 id="CNCPT-GUID-797E49E6-2DCE-4FD4-8E4A-6E761F1383D1" class="sect1"><span class="enumeration_chapter">3</span> Indexes and Index-Organized Tables</h1>
<div>
<p>Indexes are schema objects that can speed access to table rows. Index-organized tables are tables stored in an index structure.</p>
<p>This chapter contains the following sections:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="indexiot.htm#GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access. Indexes are schema objects that are logically and physically independent of the data in the objects with which they are associated. Thus, you can drop or create an index without physically affecting the indexed table.">Introduction to Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-FC93A85B-C237-4249-AD1E-FF54576ED050" title="B-trees, short for balanced trees, are the most common type of database index. A B-tree index is an ordered list of values divided into ranges. By associating a key with a row or range of rows, B-trees provide excellent retrieval performance for a wide range of queries, including exact match and range searches.">Overview of B-Tree Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-B15C4817-7748-456D-9740-8B9628AF9F47" title="In a bitmap index, the database stores a bitmap for each index key. In a conventional B-tree index, one index entry points to a single row. In a bitmap index, each index key stores pointers to multiple rows.">Overview of Bitmap Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6" title="A function-based index computes the value of a function or expression involving one or more columns and stores it in an index. A function-based index can be either a B-tree or a bitmap index.">Overview of Function-Based Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-9586EB86-4B84-4A43-A66D-958776FE558B" title="An application domain index is a customized index specific to an application.">Overview of Application Domain Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" title="An index-organized table is a table stored in a variation of a B-tree index structure. In contrast, a heap-organized table inserts rows where they fit.">Overview of Index-Organized Tables</a></p>
</li>
</ul>
</div>
<a id="CNCPT811"></a>
<div class="props_rev_3"><a id="GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41"></a>
<h2 id="CNCPT-GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" class="sect2">Introduction to Indexes</h2>
<div>
<p>An <span class="bold">index</span> is an optional structure, associated with a table or <span class="bold">table cluster</span>, that can sometimes speed data access. Indexes are schema objects that are logically and physically independent of the data in the objects with which they are associated. Thus, you can drop or create an index without physically affecting the indexed table.</p>
<div class="infobox-note" id="GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41__GUID-5B11D472-55A2-4B54-85FF-BA64D9BBC4B1">
<p class="notep1">Note:</p>
<p>If you drop an index, then applications still work. However, access of previously indexed data can be slower.</p>
</div>
<p>For an analogy, suppose an HR manager has a shelf of cardboard boxes. Folders containing employee information are inserted randomly in the boxes. The folder for employee Whalen (ID 200) is 10 folders up from the bottom of box 1, whereas the folder for King (ID 100) is at the bottom of box 3. To locate a folder, the manager looks at every folder in box 1 from bottom to top, and then moves from box to box until the folder is found. To speed access, the manager could create an index that sequentially lists every employee ID with its folder location:</p>
<pre dir="ltr">ID 100: Box 3, position 1 (bottom)
ID 101: Box 7, position 8 
ID 200: Box 1, position 10
.
.
.
</pre>
<p>Similarly, the manager could create separate indexes for employee last names, department IDs, and so on.</p>
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="indexiot.htm#GUID-A444A178-67BE-45E2-8D2F-A64B95E1D31F" title="The absence or presence of an index does not require a change in the wording of any SQL statement. An index is a fast access path to a single row of data. It affects only the speed of execution. Given a data value that has been indexed, the index points directly to the location of the rows containing that value.">Benefits of Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-D0C53854-D92E-49D0-822A-39F3E7573752" title="Indexes are usable (default) or unusable, visible (default) or invisible.">Index Usability and Visibility</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929" title="A key is a set of columns or expressions on which you can build an index. Although the terms are often used interchangeably, indexes and keys are different. Indexes are structures stored in the database that users manage using SQL statements. Keys are strictly a logical concept.">Keys and Columns</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464" title="A composite index, also called a concatenated index, is an index on multiple columns in a table. Place columns in a composite index in the order that makes the most sense for the queries that will retrieve data. The columns need not be adjacent in the table.">Composite Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-F6EFE752-18FA-4BCE-BDE0-F2C386361187" title="Indexes can be unique or nonunique. Unique indexes guarantee that no two rows of a table have duplicate values in the key column or columns.">Unique and Nonunique Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695" title="Oracle Database provides several indexing schemes, which provide complementary performance functionality.">Types of Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-1DA0A7D9-1EAB-40B8-B882-75B8EC9498D7" title="The database automatically maintains and uses indexes after they are created. Indexes automatically reflect data changes, such as adding, updating, and deleting rows in their underlying tables, with no additional actions required by users.">How the Database Maintains Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970" title="Oracle Database stores index data in an index segment. Space available for index data in a data block is the data block size minus block overhead, entry overhead, rowid, and one length byte for each value indexed.">Index Storage</a></p>
</li>
</ul>
</div>
<a id="CNCPT1895"></a>
<div class="props_rev_3"><a id="GUID-A444A178-67BE-45E2-8D2F-A64B95E1D31F"></a>
<h3 id="CNCPT-GUID-A444A178-67BE-45E2-8D2F-A64B95E1D31F" class="sect3">Benefits of Indexes</h3>
<div>
<p>The absence or presence of an index does not require a change in the wording of any SQL statement. An index is a fast access path to a single row of data. It affects only the speed of execution. Given a data value that has been indexed, the index points directly to the location of the rows containing that value.</p>
<p>When an index exists on one or more columns of a table, the database can in some cases retrieve a small set of randomly distributed rows from the table. Indexes are one of many means of reducing disk I/O. If a heap-organized table has no indexes, then the database must perform a <a href="glossary.htm#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">full table scan</span></a> to find a value. For example, a <a href="glossary.htm#GUID-CCF91C9F-A98A-498F-A84B-58A0FA16CD6E"><span class="xrefglossterm">query</span></a> of location <code class="codeph">2700</code> in the unindexed <code class="codeph">hr.departments</code> table requires the database to search every row in every block. This approach does not scale well as data volumes increase.</p>
<p>In general, consider creating an index on a column in any of the following situations:</p>
<ul style="list-style-type: disc;">
<li>
<p>The indexed columns are queried frequently and return a small percentage of the total number of rows in the table.</p>
</li>
<li>
<p>A referential <a href="glossary.htm#GUID-67F8FE8C-EBA5-4796-820A-8919982A1411"><span class="xrefglossterm">integrity constraint</span></a> exists on the indexed column or columns. The index is a means to avoid a full table <a href="glossary.htm#GUID-6D016291-A487-4F88-BE0B-ACF8FA2AE72C"><span class="xrefglossterm">lock</span></a> that would otherwise be required if you update the parent table <a href="glossary.htm#GUID-8640EFA5-276C-4812-A078-1F21F55F4200"><span class="xrefglossterm">primary key</span></a>, merge into the parent table, or delete from the parent table.</p>
</li>
<li>
<p>A unique key constraint will be placed on the table and you want to manually specify the index and all index options.</p>
</li>
</ul>
</div>
</div>
<a id="CNCPT94781"></a>
<div class="props_rev_3"><a id="GUID-D0C53854-D92E-49D0-822A-39F3E7573752"></a>
<h3 id="CNCPT-GUID-D0C53854-D92E-49D0-822A-39F3E7573752" class="sect3">Index Usability and Visibility</h3>
<div>
<p>Indexes are usable (default) or unusable, visible (default) or invisible.</p>
<p>These properties are defined as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>Usability</p>
<p>An <a href="glossary.htm#GUID-5EEB4F35-818F-4478-8BE3-F70CF22CD11F"><span class="xrefglossterm">unusable index</span></a>, which is ignored by the <a href="glossary.htm#GUID-54114749-0A81-41D7-8E16-7B76D93CEE2B"><span class="xrefglossterm">optimizer</span></a>, is not maintained by DML operations. An unusable index can improve the performance of bulk loads. Instead of dropping an index and later re-creating it, you can make the index unusable and then rebuild it. Unusable indexes and index partitions do not consume space. When you make a usable index unusable, the database drops its index <a href="glossary.htm#GUID-EC12AA68-8C89-43B3-B1F9-3AABF7CAEB9F"><span class="xrefglossterm">segment</span></a>.</p>
</li>
<li>
<p>Visibility</p>
<p>An <a href="glossary.htm#GUID-B60609DA-2397-4715-B7E2-75AEC3FAD0BF"><span class="xrefglossterm">invisible index</span></a> is maintained by DML operations, but is not used by default by the optimizer. Making an index invisible is an alternative to making it unusable or dropping it. Invisible indexes are especially useful for testing the removal of an index before dropping it or using indexes temporarily without affecting the overall application.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-D0C53854-D92E-49D0-822A-39F3E7573752__GUID-D0718D07-2617-4BC6-8A80-CD5EB89B5ADE">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="sqllangu.htm#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="To understand how Oracle Database processes SQL statements, it is necessary to understand the part of the database called the optimizer (also known as the query optimizer or cost-based optimizer). All SQL statements use the optimizer to determine the most efficient means of accessing the specified data.">Overview of the Optimizer</a>&#34;</span></p>
</div>
</div>
</div>
<a id="CNCPT1159"></a>
<div class="props_rev_3"><a id="GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929"></a>
<h3 id="CNCPT-GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929" class="sect3">Keys and Columns</h3>
<div>
<p>A <span class="bold">key</span> is a set of columns or expressions on which you can build an index. Although the terms are often used interchangeably, indexes and keys are different. Indexes are structures stored in the database that users manage using SQL statements. Keys are strictly a logical concept.</p>
<p>The following statement creates an index on the <code class="codeph">customer_id</code> column of the sample table <code class="codeph">oe.orders</code>:</p>
<pre dir="ltr">CREATE INDEX ord_customer_ix ON orders (customer_id);
</pre>
<p>In the preceding statement, the <code class="codeph">customer_id</code> column is the index key. The index itself is named <code class="codeph">ord_customer_ix</code>.</p>
<div class="infobox-note" id="GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929__GUID-0EC2E430-7F35-4D7A-AD24-89992309D384">
<p class="notep1">Note:</p>
<p>Primary and unique keys automatically have indexes, but you might want to create an index on a <a href="glossary.htm#GUID-EEE8A67D-6B0E-468E-9554-48FEE552BC9A"><span class="xrefglossterm">foreign key</span></a>.</p>
</div>
<div class="infoboxnotealso" id="GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929__GUID-AC6D0D78-B3F4-4653-8258-C19669D57D49">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="datainte.htm#GUID-6A89FF39-AD42-4399-BD1B-E51ECEE50B4E" title="This chapter explains how integrity constraints enforce the business rules associated with a database and prevent the entry of invalid information into tables.">Data Integrity</a></p>
</li>
<li>
<p><a class="olink SQLRF01209" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF01209"><span class="italic">Oracle Database SQL Language Reference</span></a> <code class="codeph">CREATE INDEX</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
</div>
<a id="CNCPT88833"></a>
<div class="props_rev_3"><a id="GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464"></a>
<h3 id="CNCPT-GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464" class="sect3">Composite Indexes</h3>
<div>
<p>A <span class="bold">composite index</span>, also called a <span class="bold">concatenated index</span>, is an index on multiple columns in a table. Place columns in a composite index in the order that makes the most sense for the queries that will retrieve data. The columns need not be adjacent in the table.</p>
<p>Composite indexes can speed retrieval of data for <code class="codeph">SELECT</code> statements in which the <code class="codeph">WHERE</code> clause references all or the leading portion of the columns in the composite index. Therefore, the order of the columns used in the definition is important. In general, the most commonly accessed columns go first.</p>
<p>For example, suppose an application frequently queries the <code class="codeph">last_name</code>, <code class="codeph">job_id</code>, and <code class="codeph">salary</code> columns in the <code class="codeph">employees</code> table. Also assume that <code class="codeph">last_name</code> has high <a href="glossary.htm#GUID-5CD22620-6D7A-40DC-BA09-EE3B5339C7F8"><span class="xrefglossterm">cardinality</span></a>, which means that the number of distinct values is large compared to the number of table rows. You create an index with the following column order:</p>
<pre dir="ltr">CREATE INDEX employees_ix
   ON employees (last_name, job_id, salary);
</pre>
<p>Queries that access all three columns, only the <code class="codeph">last_name</code> column, or only the <code class="codeph">last_name</code> and <code class="codeph">job_id</code> columns use this index. In this example, queries that do not access the <code class="codeph">last_name</code> column do not use the index.</p>
<div class="infobox-note" id="GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464__GUID-F7C85618-6D07-4F9D-8E4F-1FCFD5DBD318">
<p class="notep1">Note:</p>
<p>In some cases, such as when the leading column has very low cardinality, the database may use a skip scan of this index (see <span class="q">&#34;<a href="indexiot.htm#GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181" title="An index skip scan uses logical subindexes of a composite index. The database &#34;skips&#34; through a single index as if it were searching separate indexes.">Index Skip Scan</a>&#34;</span>).</p>
</div>
<p>Multiple indexes can exist on the same table with the same column order when they meet any of the following conditions:</p>
<ul style="list-style-type: disc;">
<li>
<p>The indexes are of different types.</p>
<p>For example, you can create bitmap and B-tree indexes on the same columns.</p>
</li>
<li>
<p>The indexes use different partitioning schemes.</p>
<p>For example, you can create indexes that are locally partitioned and indexes that are globally partitioned.</p>
</li>
<li>
<p>The indexes have different uniqueness properties.</p>
<p>For example, you can create both a unique and a non-unique index on the same set of columns.</p>
</li>
</ul>
<p>For example, a nonpartitioned index, global partitioned index, and locally partitioned index can exist for the same table columns in the same order. Only one index with the same number of columns in the same order can be visible at any one time.</p>
<p>This capability enables you to migrate applications without the need to drop an existing index and re-create it with different attributes. Also, this capability is useful in an OLTP database when an index key keeps increasing, causing the database to insert new entries into the same set of index blocks. To alleviate such &#34;hot spots,&#34; you could evolve the index from a nonpartitioned index into a global partitioned index.</p>
<p>If indexes on the same set of columns do not differ in type or partitioning scheme, then these indexes must use different column permutations. For example, the following SQL statements specify valid column permutations:</p>
<pre dir="ltr">CREATE INDEX employee_idx1 ON employees (last_name, job_id);
CREATE INDEX employee_idx2 ON employees (job_id, last_name);
</pre>
<div class="infoboxnotealso" id="GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464__GUID-E5E3CAEE-6846-46F9-A6D1-EBF514AE079A">
<p class="notep1">See Also:</p>
<p><a class="olink TGSQL855" target="_blank" href="../TGSQL/tgsql_indc.htm#TGSQL855"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for more information about using composite indexes</p>
</div>
</div>
</div>
<a id="CNCPT1157"></a>
<div class="props_rev_3"><a id="GUID-F6EFE752-18FA-4BCE-BDE0-F2C386361187"></a>
<h3 id="CNCPT-GUID-F6EFE752-18FA-4BCE-BDE0-F2C386361187" class="sect3">Unique and Nonunique Indexes</h3>
<div>
<p>Indexes can be unique or nonunique. Unique indexes guarantee that no two rows of a table have duplicate values in the key column or columns.</p>
<p>For example, your application may require that no two employees have the same employee ID. In a unique index, one <a href="glossary.htm#GUID-647822F1-EFF1-4E26-BE22-D54081BE1C7B"><span class="xrefglossterm">rowid</span></a> exists for each data value. The data in the leaf blocks is sorted only by key.</p>
<p>Nonunique indexes permit duplicates values in the indexed column or columns. For example, the <code class="codeph">first_name</code> column of the <code class="codeph">employees</code> table may contain multiple <code class="codeph">Mike</code> values. For a nonunique index, the rowid is included in the key in sorted order, so nonunique indexes are sorted by the index key and rowid (ascending).</p>
<p>Oracle Database does not index table rows in which all key columns are <a href="glossary.htm#GUID-8854502F-2B8F-4ABC-98FA-BBFC3695A964"><span class="xrefglossterm">null</span></a>, except for bitmap indexes or when the cluster key column value is null.</p>
</div>
</div>
<a id="CNCPT88834"></a>
<div class="props_rev_3"><a id="GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695"></a>
<h3 id="CNCPT-GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695" class="sect3">Types of Indexes</h3>
<div>
<p>Oracle Database provides several indexing schemes, which provide complementary performance functionality.</p>
<p>Indexes are categorized as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>B-tree indexes</p>
<p>These indexes are the standard index type. They are excellent for highly selective indexes (few rows correspond to each index entry) and primary key indexes. Used as concatenated indexes, a <a href="glossary.htm#GUID-8D6D0C64-6AC8-4B22-A9AF-1B62F61AE10B"><span class="xrefglossterm">B-tree index</span></a> can retrieve data sorted by the indexed columns. B-tree indexes have the following subtypes:</p>
<ul style="list-style-type: disc;">
<li>
<p>Index-organized tables</p>
<p>An index-organized table differs from a heap-organized because the data is itself the index. See <span class="q">&#34;<a href="indexiot.htm#GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" title="An index-organized table is a table stored in a variation of a B-tree index structure. In contrast, a heap-organized table inserts rows where they fit.">Overview of Index-Organized Tables</a>&#34;</span>.</p>
</li>
<li>
<p>Reverse key indexes</p>
<p>In this type of index, the bytes of the index key are reversed, for example, 103 is stored as 301. The reversal of bytes spreads out inserts into the index over many blocks. See <span class="q">&#34;<a href="indexiot.htm#GUID-2646BDA9-F776-4C98-9487-C7EBC2EECF0B" title="A reverse key index is a type of B-tree index that physically reverses the bytes of each index key while keeping the column order. For example, if the index key is 20, and if the two bytes stored for this key in hexadecimal are C1,15 in a standard B-tree index, then a reverse key index stores the bytes as 15,C1.">Reverse Key Indexes</a>&#34;</span>.</p>
</li>
<li>
<p>Descending indexes</p>
<p>This type of index stores data on a particular column or columns in descending order. See <span class="q">&#34;<a href="indexiot.htm#GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A" title="In an ascending index, Oracle Database stores data in ascending order. By default, character data is ordered by the binary values contained in each byte of the value, numeric data from smallest to largest number, and date from earliest to latest value.">Ascending and Descending Indexes</a>&#34;</span>.</p>
</li>
<li>
<p>B-tree cluster indexes</p>
<p>This type indexes a table cluster key. Instead of pointing to a row, the key points to the block that contains rows related to the cluster key. See <span class="q">&#34;<a href="tablecls.htm#GUID-CC31365B-83B0-4E09-A047-BF1B79AC887A" title="An index cluster is a table cluster that uses an index to locate data. The cluster index is a B-tree index on the cluster key. A cluster index must be created before any rows can be inserted into clustered tables.">Overview of Indexed Clusters</a>&#34;</span>.</p>
</li>
</ul>
</li>
<li>
<p>Bitmap and bitmap join indexes</p>
<p>In a bitmap index, an index entry uses a bitmap to point to multiple rows. In contrast, a B-tree index entry points to a single row. A bitmap join index is a bitmap index for the join of two or more tables. See <span class="q">&#34;<a href="indexiot.htm#GUID-B15C4817-7748-456D-9740-8B9628AF9F47" title="In a bitmap index, the database stores a bitmap for each index key. In a conventional B-tree index, one index entry points to a single row. In a bitmap index, each index key stores pointers to multiple rows.">Overview of Bitmap Indexes</a>&#34;</span>.</p>
</li>
<li>
<p>Function-based indexes</p>
<p>This type of index includes columns that are either transformed by a function, such as the <code class="codeph">UPPER</code> function, or included in an expression. B-tree or bitmap indexes can be function-based. See <span class="q">&#34;<a href="indexiot.htm#GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6" title="A function-based index computes the value of a function or expression involving one or more columns and stores it in an index. A function-based index can be either a B-tree or a bitmap index.">Overview of Function-Based Indexes</a>&#34;</span>.</p>
</li>
<li>
<p>Application domain indexes</p>
<p>A user creates this type of index for data in an application-specific domain. The physical index need not use a traditional index structure and can be stored either in the Oracle database as tables or externally as a file. See <span class="q">&#34;<a href="indexiot.htm#GUID-9586EB86-4B84-4A43-A66D-958776FE558B" title="An application domain index is a customized index specific to an application.">Overview of Application Domain Indexes</a>&#34;</span>.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695__GUID-F10A32F9-14B5-43E8-A4BE-AF168C4F402E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADMIN016" target="_blank" href="../ADMIN/indexes.htm#ADMIN016"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to manage indexes</p>
</li>
<li>
<p><a class="olink TGSQL850" target="_blank" href="../TGSQL/tgsql_indc.htm#TGSQL850"><span class="italic">Oracle Database SQL Tuning Guide</span></a> to learn about different index types</p>
</li>
</ul>
</div>
</div>
</div>
<a id="CNCPT94782"></a>
<div class="props_rev_3"><a id="GUID-1DA0A7D9-1EAB-40B8-B882-75B8EC9498D7"></a>
<h3 id="CNCPT-GUID-1DA0A7D9-1EAB-40B8-B882-75B8EC9498D7" class="sect3">How the Database Maintains Indexes</h3>
<div>
<div><span>The database automatically maintains and uses indexes after they are created. Indexes automatically reflect data changes, such as adding, updating, and deleting rows in their underlying tables, with no additional actions required by users.</span></div>
<p>Retrieval performance of indexed data remains almost constant, even as rows are inserted. However, the presence of many indexes on a table degrades <a href="glossary.htm#GUID-B5F2F112-1B33-41B5-B63D-9DC8F99A369D"><span class="xrefglossterm">DML</span></a> performance because the database must also update the indexes.</p>
</div>
</div>
<a id="CNCPT1168"></a>
<div class="props_rev_3"><a id="GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970"></a>
<h3 id="CNCPT-GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970" class="sect3">Index Storage</h3>
<div>
<p>Oracle Database stores index data in an index segment. Space available for index data in a data block is the data block size minus block overhead, entry overhead, rowid, and one length byte for each value indexed.</p>
<p>The <a href="glossary.htm#GUID-AA66891C-71B2-4D55-8F64-0E427AE24E88"><span class="xrefglossterm">tablespace</span></a> of an index segment is either the default tablespace of the owner or a tablespace specifically named in the <code class="codeph">CREATE INDEX</code> statement. For ease of administration you can store an index in a separate tablespace from its table. For example, you may choose not to back up tablespaces containing only indexes, which can be rebuilt, and so decrease the time and storage required for backups.</p>
<div class="infoboxnotealso" id="GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970__GUID-96EFABC4-25FE-4359-9C2D-1E4E87D93BD6">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="logical.htm#GUID-82531CDF-407E-4D70-AFD0-8E8929B72783" title="An index block is a special type of data block that manages space differently from table blocks. Oracle Database uses index blocks to manage the logical storage space in an index.">Overview of Index Blocks</a>&#34;</span></p>
</div>
</div>
</div>
</div>
<a id="CNCPT88835"></a><a id="CNCPT1170"></a>
<div class="props_rev_3"><a id="GUID-FC93A85B-C237-4249-AD1E-FF54576ED050"></a>
<h2 id="CNCPT-GUID-FC93A85B-C237-4249-AD1E-FF54576ED050" class="sect2">Overview of B-Tree Indexes</h2>
<div>
<p>B-trees, short for <span class="italic">balanced trees</span>, are the most common type of database index. A <span class="bold">B-tree index</span> is an ordered list of values divided into ranges. By associating a key with a row or range of rows, B-trees provide excellent retrieval performance for a wide range of queries, including exact match and range searches.</p>
<p>The following figure illustrates the structure of a B-tree index. The example shows an index on the <code class="codeph">department_id</code> column, which is a foreign key column in the <code class="codeph">employees</code> table.</p>
<div class="figure" id="GUID-FC93A85B-C237-4249-AD1E-FF54576ED050__I5765">
<p class="titleinfigure">Figure 3-1 Internal Structure of a B-tree Index</p>
<img width="662" height="474" src="img/GUID-83032A7C-64B8-4705-A1A4-9289C791DBE2-default.gif" alt="Description of Figure 3-1 follows" title="Description of Figure 3-1 follows"/><br/>
<a href="img_text/GUID-83032A7C-64B8-4705-A1A4-9289C791DBE2-print.htm">Description of &#34;Figure 3-1 Internal Structure of a B-tree Index&#34;</a></div>
<!-- class="figure" -->
<p>This section contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="indexiot.htm#GUID-89A9F85F-BE0E-4596-AEC3-CAF0D821B1CA" title="A B-tree index has two types of blocks: the branch block for searching, and the leaf block for storing key values. The upper-level branch blocks of a B-tree index contain index data that points to lower-level index blocks.">Branch Blocks and Leaf Blocks</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-D54BD14D-0065-4B61-B2F6-5567913B16CD" title="In an index scan, the database retrieves a row by traversing the index, using the indexed column values specified by the statement. If the database scans the index for a value, then it will find this value in n I/Os where n is the height of the B-tree index. This is the basic principle behind Oracle Database indexes.">Index Scans</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-2646BDA9-F776-4C98-9487-C7EBC2EECF0B" title="A reverse key index is a type of B-tree index that physically reverses the bytes of each index key while keeping the column order. For example, if the index key is 20, and if the two bytes stored for this key in hexadecimal are C1,15 in a standard B-tree index, then a reverse key index stores the bytes as 15,C1.">Reverse Key Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A" title="In an ascending index, Oracle Database stores data in ascending order. By default, character data is ordered by the binary values contained in each byte of the value, numeric data from smallest to largest number, and date from earliest to latest value.">Ascending and Descending Indexes</a></p>
</li>
<li>
<p><a href="indexiot.htm#GUID-33AEA2E3-1355-4224-BB39-890A71784062" title="To reduce space in indexes, Oracle Database can employ different compression algorithms.">Index Compression</a></p>
</li>
</ul>
</div>
<a id="CNCPT88836"></a>
<div class="props_rev_3"><a id="GUID-89A9F85F-BE0E-4596-AEC3-CAF0D821B1CA"></a>
<h3 id="CNCPT-GUID-89A9F85F-BE0E-4596-AEC3-CAF0D821B1CA" class="sect3">Branch Blocks and Leaf Blocks</h3>
<div>
<p>A B-tree index has two types of blocks: the <span class="bold">branch block</span> for searching, and the <span class="bold">leaf block</span> for storing key values. The upper-level branch blocks of a B-tree index contain index data that points to lower-level index blocks.</p>
<p>In <a href="indexiot.htm#GUID-FC93A85B-C237-4249-AD1E-FF54576ED050__I5765">Figure 3-1</a>, the root branch block has an entry <code class="codeph">0-40</code>, which points to the leftmost block in the next branch level. This branch block contains entries such as <code class="codeph">0-10</code> and <code class="codeph">11-19</code>. Each of these entries points to a leaf block that contains key values that fall in the range.</p>
<p>A B-tree index is balanced because all leaf blocks automatically stay at the same depth. Thus, retrieval of any record from anywhere in the index takes approximately the same amount of time. The height of the index is the number of blocks required to go from the root block to a leaf block. The branch level is the height minus 1. In <a href="indexiot.htm#GUID-FC93A85B-C237-4249-AD1E-FF54576ED050__I5765">Figure 3-1</a>, the index has a height of 3 and a branch level of 2.</p>
<p>Branch blocks store the minimum key prefix needed to make a branching decision between two keys. This technique enables the database to fit as much data as possible on each branch block. The branch blocks contain a pointer to the child block containing the key. The number of keys and pointers is limited by the block size.</p>
<p>The leaf blocks contain every indexed data value and a corresponding rowid used to locate the actual row. Each entry is sorted by (key, rowid). Within a leaf block, a key and rowid is linked to its left and right sibling entries. The leaf blocks themselves are also doubly linked. In <a href="indexiot.htm#GUID-FC93A85B-C237-4249-AD1E-FF54576ED050__I5765">Figure 3-1</a> the leftmost leaf block (<code class="codeph">0-10</code>) is linked to the second leaf block (<code class="codeph">11-19</code>).</p>
<div class="infobox-note" id="GUID-89A9F85F-BE0E-4596-AEC3-CAF0D821B1CA__GUID-9ED9997A-EFAE-40A3-8893-53E5E30EC07A">
<p class="notep1">Note:</p>
<p>Indexes in columns with character data are based on the binary values of the characters in the database character set.</p>
</div>
</div>
</div>
<a id="CNCPT88837"></a>
<div class="props_rev_3"><a id="GUID-D54BD14D-0065-4B61-B2F6-5567913B16CD"></a>
<h3 id="CNCPT-GUID-D54BD14D-0065-4B61-B2F6-5567913B16CD" class="sect3">Index Scans</h3>
<div>
<p>In an <span class="bold">index scan</span>, the database retrieves a row by traversing the index, using the indexed column values specified by the statement. If the database scans the index for a value, then it will find this value in <span class="italic">n</span> I/Os where <span class="italic">n</span> is the height of the B-tree index. This is the basic principle behind Oracle Database indexes.</p>
<p>If a SQL statement accesses only indexed columns, then the database reads values directly from the index rather than from the table. If the statement accesses nonindexed columns in addition to the indexed columns, then the database uses rowids to find the rows in the table. Typically, the database retrieves table data by alternately reading an index block and then a table block.</p>
<div class="infoboxnotealso" id="GUID-D54BD14D-0065-4B61-B2F6-5567913B16CD__GUID-1C97560E-F717-433A-9CB6-031474B6AC4B">
<p class="notep1">See Also:</p>
<p><a class="olink TGSQL234" target="_blank" href="../TGSQL/tgsql_optop.htm#TGSQL234"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for detailed information about index scans</p>
</div>
</div>
<a id="CNCPT88838"></a>
<div class="props_rev_3"><a id="GUID-F8439C86-0C6A-4FA8-85C5-1D49AE590180"></a>
<h4 id="CNCPT-GUID-F8439C86-0C6A-4FA8-85C5-1D49AE590180" class="sect4">Full Index Scan</h4>
<div>
<p>In a <span class="bold">full index scan</span>, the database reads the entire index in order. A full index scan is available if a <span class="bold">predicate</span> (<code class="codeph">WHERE</code> clause) in the SQL statement references a column in the index, and in some circumstances when no predicate is specified. A full scan can eliminate sorting because the data is ordered by index key.</p>
<div class="example" id="GUID-F8439C86-0C6A-4FA8-85C5-1D49AE590180__GUID-85A598E5-2460-4080-8823-2FC085079DE2">
<p class="titleinexample">Example 3-1 Full Index Scan</p>
<p>Suppose that an application runs the following query:</p>
<pre dir="ltr">SELECT department_id, last_name, salary 
FROM   employees
WHERE  salary &gt; 5000 
ORDER BY department_id, last_name;
</pre>
<p>In this example, the <code class="codeph">department_id</code>, <code class="codeph">last_name</code>, and <code class="codeph">salary</code> are a composite key in an index. Oracle Database performs a full scan of the index, reading it in sorted order (ordered by department ID and last name) and filtering on the salary attribute. In this way, the database scans a set of data smaller than the <code class="codeph">employees</code> table, which contains more columns than are included in the query, and avoids sorting the data.</p>
<p>The full scan could read the index entries as follows:</p>
<pre dir="ltr">50,Atkinson,2800,rowid
60,Austin,4800,rowid
70,Baer,10000,rowid
80,Abel,11000,rowid
80,Ande,6400,rowid
110,Austin,7200,rowid
.
.
.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="CNCPT88839"></a>
<div class="props_rev_3"><a id="GUID-2C8A7262-DEBE-4932-8EFB-64E61AD041C1"></a>
<h4 id="CNCPT-GUID-2C8A7262-DEBE-4932-8EFB-64E61AD041C1" class="sect4">Fast Full Index Scan</h4>
<div>
<p>A <span class="bold">fast full index scan</span> is a full index scan in which the database accesses the data in the index itself without accessing the table, and the database reads the index blocks in no particular order.</p>
<p>Fast full index scans are an alternative to a <a href="glossary.htm#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">full table scan</span></a> when both of the following conditions are met:</p>
<ul style="list-style-type: disc;">
<li>
<p>The index must contain all columns needed for the query.</p>
</li>
<li>
<p>A row containing all nulls must not appear in the query result set. For this result to be guaranteed, at least one column in the index must have either:</p>
<ul style="list-style-type: disc;">
<li>
<p>A <code class="codeph">NOT NULL</code> constraint</p>
</li>
<li>
<p>A predicate applied to the column that prevents nulls from being considered in the query result set</p>
</li>
</ul>
</li>
</ul>
<div class="example" id="GUID-2C8A7262-DEBE-4932-8EFB-64E61AD041C1__GUID-912E57FB-14C7-4243-81D1-94E9D906B7BF">
<p class="titleinexample">Example 3-2 Fast Full Index Scan</p>
<p>Assume that an application issues the following query, which does not include an <code class="codeph">ORDER BY</code> clause:</p>
<pre dir="ltr">SELECT last_name, salary
FROM   employees;
</pre>
<p>The <code class="codeph">last_name</code> column has a not null constraint. If the last name and salary are a composite key in an index, then a fast full index scan can read the index entries to obtain the requested information:</p>
<pre dir="ltr">Baida,2900,rowid
Atkinson,2800,rowid
Zlotkey,10500,rowid
Austin,7200,rowid
Baer,10000,rowid
Austin,4800,rowid
.
.
.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="CNCPT88840"></a>
<div class="props_rev_3"><a id="GUID-E1BD4FBF-8A6D-4EF8-8892-7B1CBFA9D5C6"></a>
<h4 id="CNCPT-GUID-E1BD4FBF-8A6D-4EF8-8892-7B1CBFA9D5C6" class="sect4">Index Range Scan</h4>
<div>
<div>
<div>An <span class="bold">index range scan</span> is an ordered scan of an index in which one or more leading columns of an index are specified in conditions, and 0, 1, or more values are possible for an index key.</div>
<p>A <a href="glossary.htm#GUID-B5AA8627-E7DC-487B-8D4B-2DE3F1497A83"><span class="xrefglossterm">condition</span></a> specifies a combination of one or more expressions and logical (Boolean) operators and returns a value of <code class="codeph">TRUE</code>, <code class="codeph">FALSE</code>, or <code class="codeph">UNKNOWN</code>.</p>
</div>
<p>The database commonly uses an index range scan to access selective data. The <a href="glossary.htm#GUID-AA830B4F-E5E8-4CCC-A960-0FA0E2F8DE12"><span class="xrefglossterm">selectivity</span></a> is the percentage of rows in the table that the query selects, with 0 meaning no rows and 1 meaning all rows. Selectivity is tied to a query <a href="glossary.htm#GUID-891CF9E9-78CD-470C-9C4A-D65A101B2C38"><span class="xrefglossterm">predicate</span></a>, such as <code class="codeph">WHERE last_name LIKE &#39;A%&#39;</code>, or a combination of predicates. A predicate becomes more selective as the value approaches 0 and less selective (or more unselective) as the value approaches 1.</p>
<p>For example, a user queries employees whose last names begin with <code class="codeph">A</code>. Assume that the <code class="codeph">last_name</code> column is indexed, with entries as follows:</p>
<pre dir="ltr">Abel,rowid
Ande,rowid
Atkinson,rowid
Austin,rowid
Austin,rowid
Baer,rowid
.
.
.
</pre>
<p>The database could use a range scan because the <code class="codeph">last_name</code> column is specified in the predicate and multiples rowids are possible for each index key. For example, two employees are named Austin, so two rowids are associated with the key <code class="codeph">Austin</code>.</p>
<p>An index range scan can be bounded on both sides, as in a query for departments with IDs between 10 and 40, or bounded on only one side, as in a query for IDs over 40. To scan the index, the database moves backward or forward through the leaf blocks. For example, a scan for IDs between 10 and 40 locates the first index leaf block that contains the lowest key value that is 10 or greater. The scan then proceeds horizontally through the linked list of leaf nodes until it locates a value greater than 40.</p>
</div>
</div>
<a id="CNCPT88841"></a>
<div class="props_rev_3"><a id="GUID-4675513E-A498-455B-A610-B70823E32A30"></a>
<h4 id="CNCPT-GUID-4675513E-A498-455B-A610-B70823E32A30" class="sect4">Index Unique Scan</h4>
<div>
<p>In contrast to an index range scan, an <span class="bold">index unique scan</span> must have either 0 or 1 rowid associated with an index key. The database performs a unique scan when a predicate references all of the columns in the key of a <code class="codeph">UNIQUE</code> index using an equality operator. An index unique scan stops processing as soon as it finds the first record because no second record is possible.</p>
<p>As an illustration, suppose that a user runs the following query:</p>
<pre dir="ltr">SELECT *
FROM   employees
WHERE  employee_id = 5;
</pre>
<p>Assume that the <code class="codeph">employee_id</code> column is the primary key and is indexed with entries as follows:</p>
<pre dir="ltr">1,rowid
2,rowid
4,rowid
5,rowid
6,rowid
.
.
.
</pre>
<p>In this case, the database can use an index unique scan to locate the rowid for the employee whose ID is 5.</p>
</div>
</div>
<a id="CNCPT88843"></a><a id="CNCPT88842"></a>
<div class="props_rev_3"><a id="GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181"></a>
<h4 id="CNCPT-GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181" class="sect4">Index Skip Scan</h4>
<div>
<p>An <span class="bold">index skip scan</span> uses logical subindexes of a composite index. The database &#34;skips&#34; through a single index as if it were searching separate indexes.</p>
<p>Skip scanning is beneficial if there are few distinct values in the leading column of a composite index and many distinct values in the nonleading key of the index. The database may choose an index skip scan when the leading column of the composite index is not specified in a query predicate.</p>
<div class="example" id="GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181__CBBIFEAH">
<p class="titleinexample">Example 3-3 Skip Scan of a Composite Index</p>
<p>Assume that you run the following query for a customer in the <code class="codeph">sh.customers</code> table:</p>
<pre dir="ltr">SELECT * FROM sh.customers WHERE cust_email = &#39;Abbey@company.example.com&#39;;
</pre>
<p>The <code class="codeph">customers</code> table has a column <code class="codeph">cust_gender</code> whose values are either <code class="codeph">M</code> or <code class="codeph">F</code>. Assume that a composite index exists on the columns (<code class="codeph">cust_gender</code>, <code class="codeph">cust_email</code>). The following example shows a portion of the index entries:</p>
<pre dir="ltr">F,Wolf@company.example.com,rowid
F,Wolsey@company.example.com,rowid
F,Wood@company.example.com,rowid
F,Woodman@company.example.com,rowid
F,Yang@company.example.com,rowid
F,Zimmerman@company.example.com,rowid
M,Abbassi@company.example.com,rowid
M,Abbey@company.example.com,rowid
</pre>
<p>The database can use a skip scan of this index even though <code class="codeph">cust_gender</code> is not specified in the <code class="codeph">WHERE</code> clause.</p>
<p>In a skip scan, the number of logical subindexes is determined by the number of distinct values in the leading column. In the preceding example, the leading column has two possible values. The database logically splits the index into one subindex with the key <code class="codeph">F</code> and a second subindex with the key <code class="codeph">M</code>.</p>
<p>When searching for the record for the customer whose email is <code class="codeph">Abbey@company.example.com</code>, the database searches the subindex with the value <code class="codeph">F</code> first and then searches the subindex with the value <code class="codeph">M</code>. Conceptually, the database processes the query as follows:</p>
<pre dir="ltr">SELECT * FROM sh.customers WHERE cust_gender = &#39;F&#39; 
  AND cust_email = &#39;Abbey@company.example.com&#39;
UNION ALL
SELECT * FROM sh.customers WHERE cust_gender = &#39;M&#39;
  AND cust_email = &#39;Abbey@company.example.com&#39;;
</pre>
<div class="infoboxnotealso" id="GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181__GUID-C060F5C4-0A5C-49BC-901B-3DFFD209F527">
<p class="notep1">See Also:</p>
<p><a class="olink TGSQL238" target="_blank" href="../TGSQL/tgsql_optop.htm#TGSQL238"><span class="italic">Oracle Database SQL Tuning Guide</span></a> to learn more about skip scans</p>
</div>
</div>
<!-- class="example" --></div>
</div>
<a id="CNCPT89181"></a><a id="CNCPT89182"></a><a id="CNCPT89180"></a>
<div class="props_rev_3"><a id="GUID-9F572458-50AF-4B7C-BC84-807FB815AC39"></a>
<h4 id="CNCPT-GUID-9F572458-50AF-4B7C-BC84-807FB815AC39" class="sect4">Index Clustering Factor</h4>
<div>
<p>The <span class="bold">index clustering factor</span> measures row order in relation to an indexed value such as employee last name. As the degree of order increases, the clustering factor decreases.</p>
<p>The clustering factor is useful as a rough measure of the number of I/Os required to read an entire table using an index:</p>
<ul style="list-style-type: disc;">
<li>
<p>If the clustering factor is high, then Oracle Database performs a relatively high number of I/Os during a large index range scan. The index entries point to random table blocks, so the database may have to read and reread the same blocks over and over again to retrieve the data pointed to by the index.</p>
</li>
<li>
<p>If the clustering factor is low, then Oracle Database performs a relatively low number of I/Os during a large index range scan. The index keys in a range tend to point to the same data block, so the database does not have to read and reread the same blocks over and over.</p>
</li>
</ul>
<p>The clustering factor is relevant for index scans because it can show:</p>
<ul style="list-style-type: disc;">
<li>
<p>Whether the database will use an index for large range scans</p>
</li>
<li>
<p>The degree of table organization in relation to the index key</p>
</li>
<li>
<p>Whether you should consider using an index-organized table, partitioning, or table cluster if rows must be ordered by the index key</p>
</li>
</ul>
<div class="example" id="GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__CHDGAIIF">
<p class="titleinexample">Example 3-4 Clustering Factor</p>
<p>Assume that the <code class="codeph">employees</code> table fits into two data blocks. <a href="indexiot.htm#GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__CHDEIDBA" title="This table compares the contents of two data blocks.">Table 3-1</a> depicts the rows in the two data blocks (the ellipses indicate data that is not shown).</p>
<div class="tblformal" id="GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__CHDEIDBA">
<p class="titleintable">Table 3-1 Contents of Two Data Blocks in the Employees Table</p>
<table class="cellalignment1206" title="Contents of Two Data Blocks in the Employees Table" summary="This table compares the contents of two data blocks.">
<thead>
<tr class="cellalignment1197">
<th class="cellalignment1214" id="d20070e5661">Data Block 1</th>
<th class="cellalignment1214" id="d20070e5664">Data Block 2</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1197">
<td class="cellalignment1217" id="d20070e5669" headers="d20070e5661">
<pre dir="ltr">100 Steven    <span class="bold">King</span>    SKING    ...
156 Janette   <span class="bold">King</span>    JKING    ...
115 Alexander <span class="bold">Khoo</span>    AKHOO    ...
.
.
.
116 Shelli  <span class="bold">Baida</span>     SBAIDA   ...
204 Hermann <span class="bold">Baer</span>      HBAER    ...
105 David   <span class="bold">Austin</span>    DAUSTIN  ...
130 Mozhe   <span class="bold">Atkinson</span>  MATKINSO ...
166 Sundar  <span class="bold">Ande</span>      SANDE    ...
174 Ellen   <span class="bold">Abel</span>      EABEL    ...
</pre></td>
<td class="cellalignment1217" headers="d20070e5669 d20070e5664">
<pre dir="ltr"> 


149 Eleni   <span class="bold"> Zlotkey</span> EZLOTKEY ...
200 Jennifer<span class="bold"> Whalen</span>  JWHALEN  ...
.
.
.
137 Renske   <span class="bold">Ladwig</span>  RLADWIG  ...
173 Sundita  <span class="bold">Kumar</span>   SKUMAR   ...
101 Neena    <span class="bold">Kochar</span>  NKOCHHAR ...
</pre></td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Rows are stored in the blocks in order of last name (shown in bold). For example, the bottom row in data block 1 describes Abel, the next row up describes Ande, and so on alphabetically until the top row in block 1 for Steven King. The bottom row in block 2 describes Kochar, the next row up describes Kumar, and so on alphabetically until the last row in the block for Zlotkey.</p>
<p>Assume that an index exists on the last name column. Each name entry corresponds to a rowid. Conceptually, the index entries would look as follows:</p>
<pre dir="ltr">Abel,block1row1
Ande,block1row2
Atkinson,block1row3
Austin,block1row4
Baer,block1row5
.
.
.
</pre>
<p>Assume that a separate index exists on the employee ID column. Conceptually, the index entries might look as follows, with employee IDs distributed in almost random locations throughout the two blocks:</p>
<pre dir="ltr">100,block1row50
101,block2row1
102,block1row9
103,block2row19
104,block2row39
105,block1row4
.
.
.
</pre>
<p>The following statement queries the <code class="codeph">ALL_INDEXES</code> view for the clustering factor for these two indexes:</p>
<pre dir="ltr">SQL&gt; SELECT INDEX_NAME, CLUSTERING_FACTOR 
  2  FROM ALL_INDEXES 
  3  WHERE INDEX_NAME IN (&#39;EMP_NAME_IX&#39;,&#39;EMP_EMP_ID_PK&#39;);
 
INDEX_NAME           CLUSTERING_FACTOR
-------------------- -----------------
EMP_EMP_ID_PK                       19
EMP_NAME_IX                          2
</pre>
<p>The clustering factor for <code class="codeph">EMP_NAME_IX</code> is low, which means that adjacent index entries in a single leaf block tend to point to rows in the same data blocks. The clustering factor for <code class="codeph">EMP_EMP_ID_PK</code> is high, which means that adjacent index entries in the same leaf block are much less likely to point to rows in the same data blocks.</p>
<div class="infoboxnotealso" id="GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__GUID-EED6A7AD-249F-44EC-B1F2-FF8F20CBD617">
<p class="notep1">See Also:</p>
<p><a class="olink REFRN20088" target="_blank" href="../REFRN/GUID-E39825BA-70AC-45D8-AF30-C7FF561373B6.htm#REFRN20088"><span><cite>Oracle Database Reference</cite></span></a> to learn about <code class="codeph">ALL_INDEXES</code></p>
</div>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="CNCPT1181"></a>
<div class="props_rev_3"><a id="GUID-2646BDA9-F776-4C98-9487-C7EBC2EECF0B"></a>
<h3 id="CNCPT-GUID-2646BDA9-F776-4C98-9487-C7EBC2EECF0B" class="sect3">Reverse Key Indexes</h3>
<div>
<p>A <span class="bold">reverse key index</span> is a type of B-tree index that physically reverses the bytes of each index key while keeping the column order. For example, if the index key is <code class="codeph">20</code>, and if the two bytes stored for this key in hexadecimal are <code class="codeph">C1,15</code> in a standard B-tree index, then a reverse key index stores the bytes as <code class="codeph">15,C1</code>.</p>
<p>Reversing the key solves the problem of contention for leaf blocks in the right side of a B-tree index. This problem can be especially acute in an Oracle Real Application Clusters (Oracle RAC) database in which multiple instances repeatedly modify the same block. For example, in an <code class="codeph">orders</code> table the primary keys for orders are sequential. One instance in the cluster adds order 20, while another adds 21, with each instance writing its key to the same leaf block on the right-hand side of the index.</p>
<p>In a reverse key index, the reversal of the byte order distributes inserts across all leaf keys in the index. For example, keys such as 20 and 21 that would have been adjacent in a standard key index are now stored far apart in separate blocks. Thus, I/O for insertions of sequential keys is more evenly distributed.</p>
<p>Because the data in the index is not sorted by column key when it is stored, the reverse key arrangement eliminates the ability to run an index range scanning query in some cases. For example, if a user issues a query for order IDs greater than 20, then the database cannot start with the block containing this ID and proceed horizontally through the leaf blocks.</p>
</div>
</div>
<a id="CNCPT88844"></a>
<div class="props_rev_3"><a id="GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A"></a>
<h3 id="CNCPT-GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A" class="sect3">Ascending and Descending Indexes</h3>
<div>
<p>In an <span class="bold">ascending index</span>, Oracle Database stores data in ascending order. By default, character data is ordered by the binary values contained in each byte of the value, numeric data from smallest to largest number, and date from earliest to latest value.</p>
<p>For an example of an ascending index, consider the following SQL statement:</p>
<pre dir="ltr">CREATE INDEX emp_deptid_ix ON hr.employees(department_id); 
</pre>
<p>Oracle Database sorts the <code class="codeph">hr.employees</code> table on the <code class="codeph">department_id</code> column. It loads the ascending index with the <code class="codeph">department_id</code> and corresponding rowid values in ascending order, starting with <code class="codeph">0</code>. When it uses the index, Oracle Database searches the sorted <code class="codeph">department_id</code> values and uses the associated rowids to locate rows having the requested <code class="codeph">department_id</code> value.</p>
<p>By specifying the <code class="codeph">DESC</code> keyword in the <code class="codeph">CREATE INDEX</code> statement, you can create a <a href="glossary.htm#GUID-77ADFA8C-BBA8-4E2D-B122-2D490FC35CFE"><span class="xrefglossterm">descending index</span></a>. In this case, the index stores data on a specified column or columns in descending order. If the index in <a href="indexiot.htm#GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__CHDEIDBA" title="This table compares the contents of two data blocks.">Table 3-1</a> on the <code class="codeph">employees.department_id</code> column were descending, then the leaf blocking containing <code class="codeph">250</code> would be on the left side of the tree and block with <code class="codeph">0</code> on the right. The default search through a descending index is from highest to lowest value.</p>
<p>Descending indexes are useful when a query sorts some columns ascending and others descending. For an example, assume that you create a composite index on the <code class="codeph">last_name</code> and <code class="codeph">department_id</code> columns as follows:</p>
<pre dir="ltr">CREATE INDEX emp_name_dpt_ix ON hr.employees(last_name ASC, department_id DESC); 
</pre>
<p>If a user queries <code class="codeph">hr.employees</code> for last names in ascending order (A to Z) and department IDs in descending order (high to low), then the database can use this index to retrieve the data and avoid the extra step of sorting it.</p>
<div class="infoboxnotealso" id="GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A__GUID-161534A7-C2BD-4842-842D-5364A8438D78">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink TGSQL236" target="_blank" href="../TGSQL/tgsql_optop.htm#TGSQL236"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a> to learn more about ascending and descending index searches</p>
</li>
<li>
<p><a class="olink SQLRF53994" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF53994"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for descriptions of the <code class="codeph">ASC</code> and <code class="codeph">DESC</code> options of <code class="codeph">CREATE INDEX</code></p>
</li>
</ul>
</div>
</div>
</div>
<a id="CNCPT94783"></a>
<div class="props_rev_3"><a id="GUID-33AEA2E3-1355-4224-BB39-890A71784062"></a>
<h3 id="CNCPT-GUID-33AEA2E3-1355-4224-BB39-890A71784062" class="sect3">Index Compression</h3>
<div>
<p>To reduce space in indexes, Oracle Database can employ different compression algorithms.</p>
</div>
<a id="CNCPT88845"></a><a id="CNCPT1177"></a>
<div class="props_rev_3"><a id="GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B"></a>
<h4 id="CNCPT-GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B" class="sect4">Prefix Compression</h4>
<div>
<p>Oracle Database can use <span class="bold">prefix compression</span>, also known as <span class="bold">key compression</span>, to compress portions of the primary key column values in a B-tree index or an index-organized table. Prefix compression can greatly reduce the space consumed by the index.</p>
<p>An uncompressed index entry has one piece. An index entry using prefix compression has two pieces: a prefix entry, which is the grouping piece, and a suffix entry, which is the unique or nearly unique piece. The database achieves compression by sharing the prefix entries among the suffix entries in an index block.</p>
<div class="infobox-note" id="GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B__GUID-CEB8FC84-6C4D-4C87-9080-328F6B9BBCA7">
<p class="notep1">Note:</p>
<p>If a key is not defined to have a unique piece, then the database provides one by appending a rowid to the grouping piece.</p>
</div>
<p>By default, the prefix of a unique index consists of all key columns excluding the last one, whereas the prefix of a nonunique index consists of all key columns. Suppose you create a composite, unique index on two columns of the <code class="codeph">oe.orders</code> table as follows:</p>
<pre dir="ltr">CREATE UNIQUE INDEX orders_mod_stat_ix ON orders ( order_mode, order_status );
</pre>
<p>In the preceding example, an index key might be <code class="codeph">online,0</code>. The rowid is stored in the key data portion of the entry, and is not part of the key itself.</p>
<div class="infobox-note" id="GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B__GUID-A718E5A1-E1F7-4E2C-BAEB-3D1AEB50F56A">
<p class="notep1">Note:</p>
<p>If you create a unique index on a single column, then Oracle Database cannot use prefix key compression because no common prefixes exist.</p>
</div>
<p>Alternatively, suppose you create a nonunique index on the same columns:</p>
<pre dir="ltr">CREATE INDEX orders_mod_stat_ix ON orders ( order_mode, order_status );
</pre>
<p>Also assume that repeated values occur in the <code class="codeph">order_mode</code> and <code class="codeph">order_status</code> columns. An index block could have entries as shown in the follow example:</p>
<pre dir="ltr">online,0,AAAPvCAAFAAAAFaAAa
online,0,AAAPvCAAFAAAAFaAAg
online,0,AAAPvCAAFAAAAFaAAl
online,2,AAAPvCAAFAAAAFaAAm
online,3,AAAPvCAAFAAAAFaAAq
online,3,AAAPvCAAFAAAAFaAAt
</pre>
<p>In the preceding example, the key prefix would consist of a concatenation of the <code class="codeph">order_mode</code> and <code class="codeph">order_status</code> values, as in <code class="codeph">online,0</code>. The suffix consists in the rowid, as in <code class="codeph">AAAPvCAAFAAAAFaAAa</code>. The rowid makes the whole index entry unique because a rowid is itself unique in the database.</p>
<p>If the index in the preceding example were created with default prefix compression (specified by the <code class="codeph">COMPRESS</code> keyword), then duplicate key prefixes such as <code class="codeph">online</code>,<code class="codeph">0</code> and <code class="codeph">online</code>,<code class="codeph">3</code> would be compressed. Conceptually, the database achieves compression as follows:</p>
<pre dir="ltr">online,0
AAAPvCAAFAAAAFaAAa
AAAPvCAAFAAAAFaAAg
AAAPvCAAFAAAAFaAAl
online,2
AAAPvCAAFAAAAFaAAm
online,3
AAAPvCAAFAAAAFaAAq
AAAPvCAAFAAAAFaAAt
</pre>
<p>Suffix entries (the rowids) form the compressed version of index rows. Each suffix entry references a prefix entry, which is stored in the same index block as the suffix.</p>
<p>Alternatively, you could specify a prefix length when creating an index that uses prefix compression. For example, if you specified <code class="codeph">COMPRESS 1</code>, then the prefix would be <code class="codeph">order_mode</code> and the suffix would be <code class="codeph">order_status,rowid</code>. For the values in the index block example, the index would factor out duplicate occurrences of the prefix <code class="codeph">online</code>, which can be represented conceptually as follows:</p>
<pre dir="ltr">online
0,AAAPvCAAFAAAAFaAAa
0,AAAPvCAAFAAAAFaAAg
0,AAAPvCAAFAAAAFaAAl
2,AAAPvCAAFAAAAFaAAm
3,AAAPvCAAFAAAAFaAAq
3,AAAPvCAAFAAAAFaAAt
</pre>
<p>The index stores a specific prefix once per leaf block at most. Only keys in the leaf blocks of a B-tree index are compressed. In the branch blocks the key suffix can be truncated, but the key is not compressed.</p>
<div class="infoboxnotealso" id="GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B__GUID-40F35D81-661B-4287-8E5E-90883711EE65">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADMIN11692" target="_blank" href="../ADMIN/tables.htm#ADMIN11692"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to use compressed indexes</p>
</li>
<li>
<p><a class="olink VLDBG1111" target="_blank" href="../VLDBG/GUID-0C13E8A8-568B-4A60-8A46-F1120D193EFE.htm#VLDBG1111"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> to learn how to use prefix compression for partitioned indexes</p>
</li>
<li>
<p><a class="olink SQLRF53999" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF53999"><span class="italic">Oracle Database SQL Language Reference</span></a> for descriptions of the <span class="italic"><code class="codeph">key_compression</code></span> clause of <code class="codeph">CREATE INDEX</code></p>
</li>
</ul>
</div>
</div>
</div>
<a id="CNCPT94784"></a>
<div class="props_rev_3"><a id="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9"></a>
<h4 id="CNCPT-GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9" class="sect4">Advanced Index Compression</h4>
<div>
<p>Starting with Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.2), <span class="bold">advanced index compression</span> improves on traditional prefix compression for indexes on heap-organized tables. Unlike prefix compression, which uses fixed duplicate key elimination for every block, advanced compression uses adaptive duplicate key elimination on a per-block basis.</p>
<p>Advanced index compression works at the block level in the following situations:</p>
<ul style="list-style-type: disc;">
<li>
<p>During index creation, as a leaf block becomes full, the database automatically compresses the block to the optimal level.</p>
</li>
<li>
<p>When reorganizing an index block as a result of DML, if the database can create sufficient space for the incoming index entry, then a block split does not occur. During DML without advanced index compression, however, an index block split always occurs when the block becomes full.</p>
</li>
</ul>
<p>The main advantage of this form of compression is that the database automatically chooses the best compression for each block, so that the user does not require knowledge of data characteristics.</p>
<p>Enable advanced index compression using the <code class="codeph">COMPRESS ADVANCED LOW</code> clause, as in the following example:</p>
<pre dir="ltr">CREATE INDEX hr.emp_mndp_ix ON hr.employees(manager_id, department_id)
  COMPRESS ADVANCED LOW;
</pre>
<div class="infoboxnotealso" id="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9__GUID-099AB742-E00B-481D-97D2-EEF0784CD65E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADMIN14308" target="_blank" href="../ADMIN/indexes.htm#ADMIN14308"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to enable advanced index compression</p>
</li>
<li>
<p><a class="olink SQLRF53999" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF53999"><span class="italic">Oracle Database SQL Language Reference</span></a> for descriptions of the <span class="italic"><code class="codeph">key_compression</code></span> clause of <code class="codeph">CREATE INDEX</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<a id="CNCPT1182"></a>
<div class="props_rev_3"><a id="GUID-B15C4817-7748-456D-9740-8B9628AF9F47"></a>
<h2 id="CNCPT-GUID-B15C4817-7748-456D-9740-8B9628AF9F47" class="sect2">Overview of Bitmap Indexes</h2>
<div>
<p>In a <span class="bold">bitmap index</span>, the database stores a bitmap for each index key. In a conventional B-tree index, one index entry points to a single row. In a bitmap index, each index key stores pointers to multiple rows.</p>
<p>Bitmap indexes are primarily designed for data warehousing or environments in which queries reference many columns in an ad hoc fashion. Situations that may call for a bitmap index include:</p>
<ul style="list-style-type: disc;">
<li>
<p>The indexed columns have low <a href="glossary.htm#GUID-5CD22620-6D7A-40DC-BA09-EE3B5339C7F8"><span class="xrefglossterm">cardinality</span></a>, that is, the number of distinct values is small compared to the number of table rows.</p>
</li>
<li>
<p>The indexed table is either read-only or not subject to significant modification by DML statements.</p>
</li>
</ul>
<p>For a data warehouse example, the <code class="codeph">sh.customers</code> table has a <code class="codeph">cust_gender</code> column with only two possible values: <code class="codeph">M</code> and <code class="codeph">F</code>. Suppose that queries for the number of customers of a particular gender are common. In this case, the <code class="codeph">customers.cust_gender</code> column would be a candidate for a bitmap index.</p>
<p>Each bit in the bitmap corresponds to a possible rowid. If the bit is set, then the row with the corresponding rowid contains the key value. A mapping function converts the bit position to an actual rowid, so the bitmap index provides the same functionality as a B-tree index although it uses a different internal representation.</p>
<p>If the indexed column in a single row is updated, then the database locks the index key entry (for example, <code class="codeph">M</code> or <code class="codeph">F</code>) and not the individual bit mapped to the updated row. Because a key points to many rows, DML on indexed data typically locks all of these rows. For this reason, bitmap indexes are not appropriate for many <a href="glossary.htm#GUID-709E943F-FF0E-4AA6-979A-C4CB2A7B0C29"><span class="xrefglossterm">OLTP</span></a> applications.</p>
<div class="infoboxnotealso" id="GUID-B15C4817-7748-456D-9740-8B9628AF9F47__GUID-057CB997-4E44-484C-891D-C9F0476DE020">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink TGSQL867" target="_blank" href="../TGSQL/tgsql_indc.htm#TGSQL867"><span class="italic">Oracle Database SQL Tuning Guide</span></a> to learn how to use bitmap indexes for performance</p>
</li>
<li>
<p><a class="olink DWHSG8130" target="_blank" href="../DWHSG/schemas.htm#DWHSG8130"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn how to use bitmap indexes in a data warehouse</p>
</li>
</ul>
</div>
</div>
<a id="CNCPT88848"></a><a id="CNCPT88849"></a><a id="CNCPT88847"></a><a id="CNCPT88846"></a>
<div class="props_rev_3"><a id="GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729"></a>
<h3 id="CNCPT-GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729" class="sect3">Example: Bitmap Indexes on a Single Table</h3>
<div>
<p>In this example, some columns of <code class="codeph">sh.customers</code> table are candidates for a bitmap index.</p>
<div class="section">
<p>Consider the following query:</p>
<pre dir="ltr">SQL&gt; SELECT cust_id, cust_last_name, cust_marital_status, cust_gender
  2  FROM   sh.customers 
  3  WHERE  ROWNUM &lt; 8 ORDER BY cust_id;
 
   CUST_ID CUST_LAST_ CUST_MAR C
---------- ---------- -------- -
         1 Kessel              M
         2 Koch                F
         3 Emmerson            M
         4 Hardy               M
         5 Gowen               M
         6 Charles    single   F
         7 Ingram     single   F
 
7 rows selected.
</pre>
<p>The <code class="codeph">cust_marital_status</code> and <code class="codeph">cust_gender</code> columns have low cardinality, whereas <code class="codeph">cust_id</code> and <code class="codeph">cust_last_name</code> do not. Thus, bitmap indexes may be appropriate on <code class="codeph">cust_marital_status</code> and <code class="codeph">cust_gender</code>. A bitmap index is probably not useful for the other columns. Instead, a unique B-tree index on these columns would likely provide the most efficient representation and retrieval.</p>
<p><a href="indexiot.htm#GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__CBBGCGFC" title="This table illustrates the bitmap index for the cust_gender column output shown in the preceding example. It consists of two separate bitmaps, one for each gender.">Table 3-2</a> illustrates the bitmap index for the <code class="codeph">cust_gender</code> column output shown in the preceding example. It consists of two separate bitmaps, one for each gender.</p>
<div class="tblformal" id="GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__CBBGCGFC">
<p class="titleintable">Table 3-2 Sample Bitmap for One Column</p>
<table class="cellalignment1206" title="Sample Bitmap for One Column" summary="This table illustrates the bitmap index for the cust_gender column output shown in the preceding example. It consists of two separate bitmaps, one for each gender.">
<thead>
<tr class="cellalignment1197">
<th class="cellalignment1262" id="d20070e7916">Value</th>
<th class="cellalignment1263" id="d20070e7919">Row 1</th>
<th class="cellalignment1263" id="d20070e7922">Row 2</th>
<th class="cellalignment1263" id="d20070e7925">Row 3</th>
<th class="cellalignment1263" id="d20070e7928">Row 4</th>
<th class="cellalignment1263" id="d20070e7931">Row 5</th>
<th class="cellalignment1263" id="d20070e7934">Row 6</th>
<th class="cellalignment1263" id="d20070e7937">Row 7</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1197">
<td class="cellalignment1264" id="d20070e7942" headers="d20070e7916">
<p><code class="codeph">M</code></p>
</td>
<td class="cellalignment1265" headers="d20070e7942 d20070e7919">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e7942 d20070e7922">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e7942 d20070e7925">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e7942 d20070e7928">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e7942 d20070e7931">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e7942 d20070e7934">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e7942 d20070e7937">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1264" id="d20070e7968" headers="d20070e7916">
<p><code class="codeph">F</code></p>
</td>
<td class="cellalignment1265" headers="d20070e7968 d20070e7919">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e7968 d20070e7922">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e7968 d20070e7925">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e7968 d20070e7928">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e7968 d20070e7931">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e7968 d20070e7934">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e7968 d20070e7937">
<p>1</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>A mapping function converts each bit in the bitmap to a rowid of the <code class="codeph">customers</code> table. Each bit value depends on the values of the corresponding row in the table. For example, the bitmap for the <code class="codeph">M</code> value contains a <code class="codeph">1</code> as its first bit because the gender is <code class="codeph">M</code> in the first row of the <code class="codeph">customers</code> table. The bitmap <code class="codeph">cust_gender=&#39;M&#39;</code> has a <code class="codeph">0</code> for the bits in rows 2, 6, and 7 because these rows do not contain <code class="codeph">M</code> as their value.</p>
<div class="infobox-note" id="GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__GUID-5191B3F6-6882-40D9-A54D-F61697A4C391">
<p class="notep1">Note:</p>
<p>Bitmap indexes can include keys that consist entirely of null values, unlike B-tree indexes. Indexing nulls can be useful for some SQL statements, such as queries with the aggregate function <code class="codeph">COUNT</code>.</p>
</div>
<p>An analyst investigating demographic trends of the customers may ask, &#34;How many of our female customers are single or divorced?&#34; This question corresponds to the following SQL query:</p>
<pre dir="ltr">SELECT COUNT(*) 
FROM   customers  
WHERE  cust_gender = &#39;F&#39; 
AND    cust_marital_status IN (&#39;single&#39;, &#39;divorced&#39;); 
</pre>
<p>Bitmap indexes can process this query efficiently by counting the number of <code class="codeph">1</code> values in the resulting bitmap, as illustrated in <a href="indexiot.htm#GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__CBBGEJDG" title="Sample bitmap for bitmap index">Table 3-3</a>. To identify the customers who satisfy the criteria, Oracle Database can use the resulting bitmap to access the table.</p>
<div class="tblformal" id="GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__CBBGEJDG">
<p class="titleintable">Table 3-3 Sample Bitmap for Two Columns</p>
<table class="cellalignment1206" title="Sample Bitmap for Two Columns" summary="Sample bitmap for bitmap index">
<thead>
<tr class="cellalignment1197">
<th class="cellalignment1207" id="d20070e8056">Value</th>
<th class="cellalignment1263" id="d20070e8059">Row 1</th>
<th class="cellalignment1263" id="d20070e8062">Row 2</th>
<th class="cellalignment1263" id="d20070e8065">Row 3</th>
<th class="cellalignment1263" id="d20070e8068">Row 4</th>
<th class="cellalignment1263" id="d20070e8071">Row 5</th>
<th class="cellalignment1263" id="d20070e8074">Row 6</th>
<th class="cellalignment1263" id="d20070e8077">Row 7</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1197">
<td class="cellalignment1209" id="d20070e8082" headers="d20070e8056">
<p><code class="codeph">M</code></p>
</td>
<td class="cellalignment1265" headers="d20070e8082 d20070e8059">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e8082 d20070e8062">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8082 d20070e8065">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e8082 d20070e8068">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e8082 d20070e8071">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e8082 d20070e8074">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8082 d20070e8077">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1209" id="d20070e8108" headers="d20070e8056">
<p><code class="codeph">F</code></p>
</td>
<td class="cellalignment1265" headers="d20070e8108 d20070e8059">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8108 d20070e8062">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e8108 d20070e8065">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8108 d20070e8068">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8108 d20070e8071">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8108 d20070e8074">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e8108 d20070e8077">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1209" id="d20070e8134" headers="d20070e8056">
<p><code class="codeph">single</code></p>
</td>
<td class="cellalignment1265" headers="d20070e8134 d20070e8059">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8134 d20070e8062">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8134 d20070e8065">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8134 d20070e8068">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8134 d20070e8071">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8134 d20070e8074">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e8134 d20070e8077">
<p>1</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1209" id="d20070e8160" headers="d20070e8056">
<p><code class="codeph">divorced</code></p>
</td>
<td class="cellalignment1265" headers="d20070e8160 d20070e8059">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8160 d20070e8062">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8160 d20070e8065">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8160 d20070e8068">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8160 d20070e8071">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8160 d20070e8074">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8160 d20070e8077">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1209" id="d20070e8186" headers="d20070e8056">
<p><code class="codeph">single</code> or <code class="codeph">divorced</code>, and <code class="codeph">F</code></p>
</td>
<td class="cellalignment1265" headers="d20070e8186 d20070e8059">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8186 d20070e8062">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8186 d20070e8065">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8186 d20070e8068">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8186 d20070e8071">
<p>0</p>
</td>
<td class="cellalignment1265" headers="d20070e8186 d20070e8074">
<p>1</p>
</td>
<td class="cellalignment1265" headers="d20070e8186 d20070e8077">
<p>1</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Bitmap indexing efficiently merges indexes that correspond to several conditions in a <code class="codeph">WHERE</code> clause. Rows that satisfy some, but not all, conditions are filtered out before the table itself is accessed. This technique improves response time, often dramatically.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="CNCPT88850"></a><a id="CNCPT89157"></a><a id="CNCPT1188"></a>
<div class="props_rev_3"><a id="GUID-3286EBA4-0D5B-423D-815B-997A3E4B4B6C"></a>
<h3 id="CNCPT-GUID-3286EBA4-0D5B-423D-815B-997A3E4B4B6C" class="sect3">Bitmap Join Indexes</h3>
<div>
<p>A <span class="bold">bitmap join index</span> is a bitmap index for the <span class="bold">join</span> of two or more tables. For each value in a table column, the index stores the rowid of the corresponding row in the indexed table. In contrast, a standard bitmap index is created on a single table.</p>
<p>A bitmap join index is an efficient means of reducing the volume of data that must be joined by performing restrictions in advance. For an example of when a bitmap join index would be useful, assume that users often query the number of employees with a particular job type. A typical query might look as follows:</p>
<pre dir="ltr">SELECT COUNT(*) 
FROM   employees, jobs 
WHERE  employees.job_id = jobs.job_id 
AND    jobs.job_title = &#39;Accountant&#39;;
</pre>
<p>The preceding query would typically use an index on <code class="codeph">jobs.job_title</code> to retrieve the rows for <code class="codeph">Accountant</code> and then the job ID, and an index on <code class="codeph">employees.job_id</code> to find the matching rows. To retrieve the data from the index itself rather than from a scan of the tables, you could create a bitmap join index as follows:</p>
<pre dir="ltr">CREATE BITMAP INDEX employees_bm_idx 
ON     employees (jobs.job_title) 
FROM   employees, jobs
WHERE  employees.job_id = jobs.job_id;
</pre>
<p>As illustrated in the following figure, the index key is <code class="codeph">jobs.job_title</code> and the indexed table is <code class="codeph">employees</code>.</p>
<div class="figure" id="GUID-3286EBA4-0D5B-423D-815B-997A3E4B4B6C__CBBDIJFJ">
<p class="titleinfigure">Figure 3-2 Bitmap Join Index</p>
<img width="600" height="432" src="img/GUID-3D4A9BDE-80EF-40BD-998C-3D34F82B5D78-default.gif" alt="Description of Figure 3-2 follows" title="Description of Figure 3-2 follows"/><br/>
<a href="img_text/GUID-3D4A9BDE-80EF-40BD-998C-3D34F82B5D78-print.htm">Description of &#34;Figure 3-2 Bitmap Join Index&#34;</a></div>
<!-- class="figure" -->
<p>Conceptually, <code class="codeph">employees_bm_idx</code> is an index of the <code class="codeph">jobs.title</code> column in the SQL query shown in the following query (sample output included). The <code class="codeph">job_title</code> key in the index points to rows in the <code class="codeph">employees</code> table. A query of the number of accountants can use the index to avoid accessing the <code class="codeph">employees</code> and <code class="codeph">jobs</code> tables because the index itself contains the requested information.</p>
<pre dir="ltr">SELECT jobs.job_title AS &#34;jobs.job_title&#34;, employees.rowid AS &#34;employees.rowid&#34;
FROM   employees, jobs
WHERE  employees.job_id = jobs.job_id
ORDER BY job_title;
 
jobs.job_title                      employees.rowid
----------------------------------- ------------------
Accountant                          AAAQNKAAFAAAABSAAL
Accountant                          AAAQNKAAFAAAABSAAN
Accountant                          AAAQNKAAFAAAABSAAM
Accountant                          AAAQNKAAFAAAABSAAJ
Accountant                          AAAQNKAAFAAAABSAAK
Accounting Manager                  AAAQNKAAFAAAABTAAH
Administration Assistant            AAAQNKAAFAAAABTAAC
Administration Vice President       AAAQNKAAFAAAABSAAC
Administration Vice President       AAAQNKAAFAAAABSAAB
.
.
.
</pre>
<p>In a data warehouse, the <a href="glossary.htm#GUID-6DF529B9-611D-4C00-BAF8-614E86BCB39E"><span class="xrefglossterm">join condition</span></a> is an <a href="glossary.htm#GUID-2DD43111-489E-4F08-9949-AD0C21858DCB"><span class="xrefglossterm">equijoin</span></a> (it uses the equality operator) between the primary key columns of the dimension tables and the foreign key columns in the fact table. Bitmap join indexes are sometimes much more efficient in storage than materialized join views, an alternative for materializing joins in advance.</p>
<div class="infoboxnotealso" id="GUID-3286EBA4-0D5B-423D-815B-997A3E4B4B6C__GUID-4833E0A3-8614-4682-8DE5-BAA464EC3FBB">
<p class="notep1">See Also:</p>
<p><a class="olink DWHSG9047" target="_blank" href="../DWHSG/schemas.htm#DWHSG9047"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> for more information on bitmap join indexes</p>
</div>
</div>
</div>
<a id="CNCPT88851"></a>
<div class="props_rev_3"><a id="GUID-AB4829E0-C1B7-4554-9ECB-7CCB7A992FE9"></a>
<h3 id="CNCPT-GUID-AB4829E0-C1B7-4554-9ECB-7CCB7A992FE9" class="sect3">Bitmap Storage Structure</h3>
<div>
<p>Oracle Database uses a B-tree index structure to store bitmaps for each indexed key. For example, if <code class="codeph">jobs.job_title</code> is the key column of a bitmap index, then the index data is stored in one B-tree. The individual bitmaps are stored in the leaf blocks.</p>
<div class="example" id="GUID-AB4829E0-C1B7-4554-9ECB-7CCB7A992FE9__GUID-A03E8FE5-7204-488F-8DC6-8536D2A21AE3">
<p class="titleinexample">Example 3-5 Bitmap Storage Example</p>
<p>Assume that the <code class="codeph">jobs.job_title</code> column has unique values <code class="codeph">Shipping Clerk</code>, <code class="codeph">Stock Clerk</code>, and several others. A bitmap index entry for this index has the following components:</p>
<ul style="list-style-type: disc;">
<li>
<p>The job title as the index key</p>
</li>
<li>
<p>A low rowid and high rowid for a range of rowids</p>
</li>
<li>
<p>A bitmap for specific rowids in the range</p>
</li>
</ul>
<p>Conceptually, an index leaf block in this index could contain entries as follows:</p>
<pre dir="ltr">Shipping Clerk,AAAPzRAAFAAAABSABQ,AAAPzRAAFAAAABSABZ,0010000100
Shipping Clerk,AAAPzRAAFAAAABSABa,AAAPzRAAFAAAABSABh,010010
Stock Clerk,AAAPzRAAFAAAABSAAa,AAAPzRAAFAAAABSAAc,1001001100
Stock Clerk,AAAPzRAAFAAAABSAAd,AAAPzRAAFAAAABSAAt,0101001001
Stock Clerk,AAAPzRAAFAAAABSAAu,AAAPzRAAFAAAABSABz,100001
.
.
.
</pre>
<p>The same job title appears in multiple entries because the rowid range differs.</p>
<p>A session updates the job ID of one employee from <code class="codeph">Shipping Clerk</code> to <code class="codeph">Stock Clerk</code>. In this case, the session requires exclusive access to the index key entry for the old value (<code class="codeph">Shipping Clerk</code>) and the new value (<code class="codeph">Stock Clerk</code>). Oracle Database locks the rows pointed to by these two entries&mdash;but not the rows pointed to by <code class="codeph">Accountant</code> or any other key&mdash;until the <code class="codeph">UPDATE</code> commits.</p>
<p>The data for a bitmap index is stored in one segment. Oracle Database stores each bitmap in one or more pieces. Each piece occupies part of a single data block.</p>
<div class="infoboxnotealso" id="GUID-AB4829E0-C1B7-4554-9ECB-7CCB7A992FE9__GUID-B222837E-5C0E-43A6-A20E-DEF98D490AA7">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="logical.htm#GUID-EFB292CB-87EA-42AA-808C-BD85E540BACC" title="A single data segment in a database stores the data for one user object.">User Segments</a>&#34;</span></p>
</div>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="CNCPT1161"></a>
<div class="props_rev_3"><a id="GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6"></a>
<h2 id="CNCPT-GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6" class="sect2">Overview of Function-Based Indexes</h2>
<div>
<p>A <span class="bold">function-based index</span> computes the value of a function or expression involving one or more columns and stores it in an index. A function-based index can be either a B-tree or a bitmap index.</p>
<p>The indexed function can be an arithmetic expression or an expression that contains a SQL function, user-defined PL/SQL function, package function, or C callout. For example, a function could add the values in two columns.</p>
<div class="infoboxnotealso" id="GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6__GUID-D2E28556-0B8E-4A14-8792-D5D589290717">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADMIN11730" target="_blank" href="../ADMIN/indexes.htm#ADMIN11730"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to create function-based indexes</p>
</li>
<li>
<p><a class="olink TGSQL864" target="_blank" href="../TGSQL/tgsql_indc.htm#TGSQL864"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for more information about using function-based indexes</p>
</li>
<li>
<p><a class="olink SQLRF53993" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF53993"><span class="italic">Oracle Database SQL Language Reference</span></a> for restrictions and usage notes for function-based indexes</p>
</li>
</ul>
</div>
</div>
<a id="CNCPT88852"></a><a id="CNCPT1162"></a>
<div class="props_rev_3"><a id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10"></a>
<h3 id="CNCPT-GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10" class="sect3">Uses of Function-Based Indexes</h3>
<div>
<p>Function-based indexes are efficient for evaluating statements that contain functions in their <code class="codeph">WHERE</code> clauses. The database only uses the function-based index when the function is included in a query. When the database processes <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> statements, however, it must still evaluate the function to process the statement.</p>
<div class="example" id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-66A7BA6D-17B4-4F72-A490-81D10C4A58D6">
<p class="titleinexample">Example 3-6 Index Based on Arithmetic Expression</p>
<p>For example, suppose you create the following function-based index:</p>
<pre dir="ltr">CREATE INDEX emp_total_sal_idx
  ON employees (12 * salary * commission_pct, salary, commission_pct);
</pre>
<p>The database can use the preceding index when processing queries such as the following (partial sample output included):</p>
<pre dir="ltr">SELECT   employee_id, last_name, first_name, 
         12*salary*commission_pct AS &#34;ANNUAL SAL&#34;
FROM     employees
WHERE    (12 * salary * commission_pct) &lt; 30000
ORDER BY &#34;ANNUAL SAL&#34; DESC;

EMPLOYEE_ID LAST_NAME                 FIRST_NAME           ANNUAL SAL
----------- ------------------------- -------------------- ----------
        159 Smith                     Lindsey                   28800
        151 Bernstein                 David                     28500
        152 Hall                      Peter                     27000
        160 Doran                     Louise                    27000
        175 Hutton                    Alyssa                    26400
        149 Zlotkey                   Eleni                     25200
        169 Bloom                     Harrison                  24000
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-B70EEB84-D9A8-4683-97C7-7BF726E6DD5A">
<p class="titleinexample">Example 3-7 Index Based on an UPPER Function</p>
<p>Function-based indexes defined on the SQL functions <code class="codeph">UPPER(</code><span class="italic"><code class="codeph">column_name</code></span><code class="codeph">)</code> or <code class="codeph">LOWER(</code><span class="italic"><code class="codeph">column_name</code></span><code class="codeph">)</code> facilitate case-insensitive searches. For example, suppose that the <code class="codeph">first_name</code> column in <code class="codeph">employees</code> contains mixed-case characters. You create the following function-based index on the <code class="codeph">hr.employees</code> table:</p>
<pre dir="ltr">CREATE INDEX emp_fname_uppercase_idx 
ON employees ( UPPER(first_name) ); 
</pre>
<p>The <code class="codeph">emp_fname_uppercase_idx</code> index can facilitate queries such as the following:</p>
<pre dir="ltr">SELECT * 
FROM   employees
WHERE  UPPER(first_name) = &#39;AUDREY&#39;;
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-DB850AB8-07E0-4764-92D2-3D556E646E8B">
<p class="titleinexample">Example 3-8 Indexing Specific Rows in a Table</p>
<p>A function-based index is also useful for indexing only specific rows in a table. For example, the <code class="codeph">cust_valid</code> column in the <code class="codeph">sh.customers</code> table has either <code class="codeph">I</code> or <code class="codeph">A</code> as a value. To index only the <code class="codeph">A</code> rows, you could write a function that returns a null value for any rows other than the <code class="codeph">A</code> rows. You could create the index as follows:</p>
<pre dir="ltr">CREATE INDEX cust_valid_idx
ON customers ( CASE cust_valid WHEN &#39;A&#39; THEN &#39;A&#39; END );
</pre>
<div class="infoboxnotealso" id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-55C7CC87-08AC-48F3-BA1E-01469D9B59AD">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink NLSPG294" target="_blank" href="../NLSPG/ch5lingsort.htm#NLSPG294"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information about linguistic indexes</p>
</li>
<li>
<p><a class="olink SQLRF51173" target="_blank" href="../SQLRF/functions001.htm#SQLRF51173"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn more about SQL functions</p>
</li>
</ul>
</div>
</div>
<!-- class="example" --></div>
</div>
<a id="CNCPT1163"></a>
<div class="props_rev_3"><a id="GUID-851F9DC0-F91B-474E-9CB4-E48F81588147"></a>
<h3 id="CNCPT-GUID-851F9DC0-F91B-474E-9CB4-E48F81588147" class="sect3">Optimization with Function-Based Indexes</h3>
<div>
<div>
<div>For queries with expressions in a <code class="codeph">WHERE</code> clause, the optimizer can use an index range scan on a function-based index.</div>
The range scan <a href="glossary.htm#GUID-56F7FB03-3499-4D51-8D23-F86C45194F09"><span class="xrefglossterm">access path</span></a> is especially beneficial when the predicate is highly selective, that is, when it chooses relatively few rows.</div>
<p>In <a href="indexiot.htm#GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-66A7BA6D-17B4-4F72-A490-81D10C4A58D6">Example 3-6</a>, if an index is built on the expression <code class="codeph">12*salary*commission_pct</code>, then the <a href="glossary.htm#GUID-54114749-0A81-41D7-8E16-7B76D93CEE2B"><span class="xrefglossterm">optimizer</span></a> can use an index range scan.</p>
<p>A <a href="glossary.htm#GUID-E95FC6AD-C932-4DE2-9D7B-B98D1168E7DA"><span class="xrefglossterm">virtual column</span></a> is also useful for speeding access to data derived from expressions. For example, you could define virtual column <code class="codeph">annual_sal</code> as <code class="codeph">12*salary*commission_pct</code> and create a function-based index on <code class="codeph">annual_sal</code>.</p>
<p>The optimizer performs expression matching by parsing the expression in a SQL statement and then comparing the expression trees of the statement and the function-based index. This comparison is case-insensitive and ignores blank spaces.</p>
<div class="infoboxnotealso" id="GUID-851F9DC0-F91B-474E-9CB4-E48F81588147__GUID-A02B5DF8-7746-4A7C-A9E4-F827E25AB901">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="sqllangu.htm#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="To understand how Oracle Database processes SQL statements, it is necessary to understand the part of the database called the optimizer (also known as the query optimizer or cost-based optimizer). All SQL statements use the optimizer to determine the most efficient means of accessing the specified data.">Overview of the Optimizer</a>&#34;</span></p>
</li>
<li>
<p><a class="olink TGSQL389" target="_blank" href="../TGSQL/tgsql_stats.htm#TGSQL389"><span class="italic">Oracle Database SQL Tuning Guide</span></a> to learn more about gathering statistics</p>
</li>
<li>
<p><a class="olink ADMIN12494" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=ADMIN12494"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to add virtual columns to a table</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="CNCPT607"></a>
<div class="props_rev_3"><a id="GUID-9586EB86-4B84-4A43-A66D-958776FE558B"></a>
<h2 id="CNCPT-GUID-9586EB86-4B84-4A43-A66D-958776FE558B" class="sect2">Overview of Application Domain Indexes</h2>
<div>
<p>An <span class="bold">application domain index</span> is a customized index specific to an application.</p>
<p>Extensive indexing can:</p>
<ul style="list-style-type: disc;">
<li>
<p>Accommodate indexes on customized, complex data types such as documents, spatial data, images, and video clips (see <span class="q">&#34;<a href="cncptdev.htm#GUID-B39E395E-99FF-4FF1-AC65-E581BD53EFA9" title="Oracle XML DB is a set of Oracle Database technologies related to high-performance XML manipulation, storage, and retrieval. Oracle XML DB provides native XML support by encompassing both SQL and XML data models in an interoperable manner.Oracle Database provides native support for JavaScript Object Notation (JSON) data, including querying and indexing.JavaScript Object Notation (JSON) is a language-independent, text-based data format that can represent objects, arrays, and scalar data. A variety of programming languages can parse and generate JSON data.Both JSON and XML are commonly used as data-interchange languages. Unlike relational data, both JSON data and XML data can be stored, indexed, and queried in the database without any schema that defines the data.JSON is widely stored in noSQL databases that lack relational database features. In contrast, Oracle Database supports JSON natively with features such as transactions, indexing, declarative querying, and views.An internal LOB stores data in the database itself rather than in external files.Oracle Text (Text) is a full-text retrieval technology integrated with Oracle Database. Oracle Text indexes any document or textual content stored in file systems, databases, or on the Web. These documents can be searched based on their textual content, metadata, or attributes.Oracle Multimedia enables Oracle Database to store, manage, and retrieve images, DICOM format medical images and other objects, audio, video, or other heterogeneous media data in an integrated fashion with other enterprise information.">Unstructured Data</a>&#34;</span>)</p>
</li>
<li>
<p>Make use of specialized indexing techniques</p>
</li>
</ul>
<p>You can encapsulate application-specific index management routines as an indextype schema object, and then define a domain index on table columns or attributes of an object type. Extensible indexing can efficiently process application-specific operators.</p>
<p>The application software, called the <span class="italic">cartridge</span>, controls the structure and content of a domain index. The database interacts with the application to build, maintain, and search the domain index. The index structure itself can be stored in the database as an index-organized table or externally as a file.</p>
<div class="infoboxnotealso" id="GUID-9586EB86-4B84-4A43-A66D-958776FE558B__GUID-F972C008-870C-4F2F-9BFB-D1F8D482D4A3">
<p class="notep1">See Also:</p>
<p><a class="olink ADDCI110" target="_blank" href="../ADDCI/introduction.htm#ADDCI110"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a> for information about using data cartridges within the Oracle Database extensibility architecture</p>
</div>
</div>
</div>
<a id="CNCPT911"></a>
<div class="props_rev_3"><a id="GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C"></a>
<h2 id="CNCPT-GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" class="sect2">Overview of Index-Organized Tables</h2>
<div>
<p>An <span class="bold">index-organized table</span> is a table stored in a variation of a B-tree index structure. In contrast, a <span class="bold">heap-organized table</span> inserts rows where they fit.</p>
<p>In an index-organized table, rows are stored in an index defined on the primary key for the table. Each index entry in the B-tree also stores the non-key column values. Thus, the index is the data, and the data is the index. Applications manipulate index-organized tables just like heap-organized tables, using SQL statements.</p>
<p>For an analogy of an index-organized table, suppose a human resources manager has a book case of cardboard boxes. Each box is labeled with a number&mdash;1, 2, 3, 4, and so on&mdash;but the boxes do not sit on the shelves in sequential order. Instead, each box contains a pointer to the shelf location of the next box in the sequence.</p>
<p>Folders containing employee records are stored in each box. The folders are sorted by employee ID. Employee King has ID 100, which is the lowest ID, so his folder is at the bottom of box 1. The folder for employee 101 is on top of 100, 102 is on top of 101, and so on until box 1 is full. The next folder in the sequence is at the bottom of box 2.</p>
<p>In this analogy, ordering folders by employee ID makes it possible to search efficiently for folders without having to maintain a separate index. Suppose a user requests the records for employees 107, 120, and 122. Instead of searching an index in one step and retrieving the folders in a separate step, the manager can search the folders in sequential order and retrieve each folder as found.</p>
<p>Index-organized tables provide faster access to table rows by primary key or a valid prefix of the key. The presence of non-key columns of a row in the leaf block avoids an additional data block I/O. For example, the salary of employee 100 is stored in the index row itself. Also, because rows are stored in primary key order, range access by the primary key or prefix involves minimal block I/Os. Another benefit is the avoidance of the space overhead of a separate primary key index.</p>
<p>Index-organized tables are useful when related pieces of data must be stored together or data must be physically stored in a specific order. A typical use of this type of table is for information retrieval, spatial data, and <a href="glossary.htm#GUID-A6734D1E-A45B-4BE3-ABF8-F6201A40F6B3"><span class="xrefglossterm">OLAP</span></a> applications.</p>
<div class="infoboxnotealso" id="GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C__GUID-3C453C0E-ED98-4335-8E9D-E76C9AE05A35">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="cncptdev.htm#GUID-F3C48565-B360-40F2-A201-239D614139B5">Overview of Oracle Spatial and Graph</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="cmntopc.htm#GUID-8905A5A6-1546-47E8-A7D7-C83E9D7F4903" title="Oracle online analytical processing (OLAP) provides native multidimensional storage and rapid response times when analyzing data across multiple dimensions. OLAP enables analysts to quickly obtain answers to complex, iterative queries during interactive sessions.">OLAP</a>&#34;</span></p>
</li>
<li>
<p><a class="olink ADMIN01506" target="_blank" href="../ADMIN/tables.htm#ADMIN01506"><span><cite>Oracle Database Administrator&rsquo;s Guide</cite></span></a> to learn how to manage index-organized tables</p>
</li>
<li>
<p><a class="olink TGSQL866" target="_blank" href="../TGSQL/tgsql_indc.htm#TGSQL866"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a> to learn how to use index-organized tables to improve performance</p>
</li>
<li>
<p><a class="olink SQLRF54492" target="_blank" href="../SQLRF/statements_7002.htm#SQLRF54492"><span><cite>Oracle Database SQL Language Reference</cite></span></a>for <code class="codeph">CREATE TABLE ... ORGANIZATION INDEX</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
<a id="CNCPT88854"></a><a id="CNCPT88855"></a><a id="CNCPT88853"></a>
<div class="props_rev_3"><a id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A"></a>
<h3 id="CNCPT-GUID-279309E0-3D53-47C5-8FA8-249BD835C88A" class="sect3">Index-Organized Table Characteristics</h3>
<div>
<p>The database system performs all operations on index-organized tables by manipulating the B-tree index structure.</p>
<p>The following table summarizes the differences between index-organized tables and heap-organized tables.</p>
<div class="tblformal" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__G37535">
<p class="titleintable">Table 3-4 Comparison of Heap-Organized Tables with Index-Organized Tables</p>
<table class="cellalignment1206" title="Comparison of Heap-Organized Tables with Index-Organized Tables" summary="This table compares index-organized tables with ordinary tables.">
<thead>
<tr class="cellalignment1197">
<th class="cellalignment1214" id="d20070e10674">Heap-Organized Table</th>
<th class="cellalignment1214" id="d20070e10677">Index-Organized Table</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1197">
<td class="cellalignment1217" id="d20070e10682" headers="d20070e10674">
<p>The rowid uniquely identifies a row. Primary key constraint may optionally be defined.</p>
</td>
<td class="cellalignment1217" headers="d20070e10682 d20070e10677">
<p>Primary key uniquely identifies a row. Primary key constraint must be defined.</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1217" id="d20070e10689" headers="d20070e10674">
<p>Physical rowid in <code class="codeph">ROWID</code> <a href="glossary.htm#GUID-175D4923-5C7E-4FF0-A69B-C4D8F3D93A3D"><span class="xrefglossterm">pseudocolumn</span></a> allows building secondary indexes.</p>
</td>
<td class="cellalignment1217" headers="d20070e10689 d20070e10677">
<p>Logical rowid in <code class="codeph">ROWID</code> pseudocolumn allows building secondary indexes.</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1217" id="d20070e10705" headers="d20070e10674">
<p>Individual rows may be accessed directly by rowid.</p>
</td>
<td class="cellalignment1217" headers="d20070e10705 d20070e10677">
<p>Access to individual rows may be achieved indirectly by primary key.</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1217" id="d20070e10712" headers="d20070e10674">
<p>Sequential <a href="glossary.htm#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">full table scan</span></a> returns all rows in some order.</p>
</td>
<td class="cellalignment1217" headers="d20070e10712 d20070e10677">
<p>A full index scan or fast full index scan returns all rows in some order.</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1217" id="d20070e10722" headers="d20070e10674">
<p>Can be stored in a <a href="glossary.htm#GUID-1C56177E-6BEE-4FE7-B45E-38298CDB946D"><span class="xrefglossterm">table cluster</span></a> with other tables.</p>
</td>
<td class="cellalignment1217" headers="d20070e10722 d20070e10677">
<p>Cannot be stored in a table cluster.</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1217" id="d20070e10732" headers="d20070e10674">
<p>Can contain a column of the <code class="codeph">LONG</code> data type and columns of <a href="glossary.htm#GUID-A85748CE-C4D4-43ED-BD49-29AFC4AD3A02"><span class="xrefglossterm">LOB</span></a> data types.</p>
</td>
<td class="cellalignment1217" headers="d20070e10732 d20070e10677">
<p>Can contain LOB columns but not <code class="codeph">LONG</code> columns.</p>
</td>
</tr>
<tr class="cellalignment1197">
<td class="cellalignment1217" id="d20070e10748" headers="d20070e10674">
<p>Can contain virtual columns (only relational heap tables are supported).</p>
</td>
<td class="cellalignment1217" headers="d20070e10748 d20070e10677">
<p>Cannot contain virtual columns.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="indexiot.htm#GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__CHDJGJHG">Figure 3-3</a> illustrates the structure of an index-organized <code class="codeph">departments</code> table. The leaf blocks contain the rows of the table, ordered sequentially by primary key. For example, the first value in the first leaf block shows a department ID of <code class="codeph">20</code>, department name of <code class="codeph">Marketing</code>, manager ID of <code class="codeph">201</code>, and location ID of <code class="codeph">1800</code>.</p>
<div class="figure" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__CHDJGJHG">
<p class="titleinfigure">Figure 3-3 Index-Organized Table</p>
<img width="662" height="474" src="img/GUID-BC216AA8-3A01-4CD3-8A50-BF94EF40B544-default.gif" alt="Description of Figure 3-3 follows" title="Description of Figure 3-3 follows"/><br/>
<a href="img_text/GUID-BC216AA8-3A01-4CD3-8A50-BF94EF40B544-print.htm">Description of &#34;Figure 3-3 Index-Organized Table&#34;</a></div>
<!-- class="figure" -->
<div class="example" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__GUID-C167D691-2FEF-4C6A-9607-353330F31869">
<p class="titleinexample">Example 3-9 Scan of Index-Organized Table</p>
<p>An index-organized table stores all data in the same structure and does not need to store the rowid. As shown in <a href="indexiot.htm#GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__CHDJGJHG">Figure 3-3</a>, leaf block 1 in an index-organized table might contain entries as follows, ordered by primary key:</p>
<pre dir="ltr">20,Marketing,201,1800
30,Purchasing,114,1700
</pre>
<p>Leaf block 2 in an index-organized table might contain entries as follows:</p>
<pre dir="ltr">50,Shipping,121,1500
60,IT,103,1400
</pre>
<p>A scan of the index-organized table rows in primary key order reads the blocks in the following sequence:</p>
<ol>
<li>
<p>Block 1</p>
</li>
<li>
<p>Block 2</p>
</li>
</ol>
</div>
<!-- class="example" -->
<div class="example" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__GUID-A6077072-BF54-48FC-B3FF-5A2679A2A120">
<p class="titleinexample">Example 3-10 Scan of Heap-Organized Table</p>
<p>To contrast data access in a heap-organized table to an index-organized table, suppose block 1 of a heap-organized <code class="codeph">departments</code> table segment contains rows as follows:</p>
<pre dir="ltr">50,Shipping,121,1500
20,Marketing,201,1800
</pre>
<p>Block 2 contains rows for the same table as follows:</p>
<pre dir="ltr">30,Purchasing,114,1700
60,IT,103,1400
</pre>
<p>A B-tree index leaf block for this heap-organized table contains the following entries, where the first value is the primary key and the second is the rowid:</p>
<pre dir="ltr">20,AAAPeXAAFAAAAAyAAD
30,AAAPeXAAFAAAAAyAAA
50,AAAPeXAAFAAAAAyAAC
60,AAAPeXAAFAAAAAyAAB
</pre>
<p>A scan of the table rows in primary key order reads the table segment blocks in the following sequence:</p>
<ol>
<li>
<p>Block 1</p>
</li>
<li>
<p>Block 2</p>
</li>
<li>
<p>Block 1</p>
</li>
<li>
<p>Block 2</p>
</li>
</ol>
<p>Thus, the number of block I/Os in this example is double the number in the index-organized example.</p>
<div class="infoboxnotealso" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__GUID-8E876764-17B1-4861-871E-470A331296A3">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="tablecls.htm#GUID-4C718D65-D7AF-4596-9A31-C11938047224" title="By default, a table is organized as a heap, which means that the database places rows where they fit best rather than in a user-specified order. Thus, a heap-organized table is an unordered collection of rows.">Table Organization</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="logical.htm#GUID-52FE1A8C-74EA-4B81-B1AC-69FD34252659" title="Oracle Database allocates logical space for all data in the database. The logical units of database space allocation are data blocks, extents, segments, and tablespaces. At a physical level, the data is stored in data files on disk. The data in the data files is stored in operating system blocks.">Introduction to Logical Storage Structures</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="example" --></div>
</div>
<a id="CNCPT1190"></a>
<div class="props_rev_3"><a id="GUID-6AB23645-4BE6-4958-A9C3-0B05077C23D6"></a>
<h3 id="CNCPT-GUID-6AB23645-4BE6-4958-A9C3-0B05077C23D6" class="sect3">Index-Organized Tables with Row Overflow Area</h3>
<div>
<p>When creating an index-organized table, you can specify a separate segment as a row overflow area. In index-organized tables, B-tree index entries can be large because they contain an entire row, so a separate segment to contain the entries is useful. In contrast, B-tree entries are usually small because they consist of the key and rowid.</p>
<p>If a row overflow area is specified, then the database can divide a row in an index-organized table into the following parts:</p>
<ul style="list-style-type: disc;">
<li>
<p>The index entry</p>
<p>This part contains column values for all the primary key columns, a physical rowid that points to the overflow part of the row, and optionally a few of the non-key columns. This part is stored in the index segment.</p>
</li>
<li>
<p>The overflow part</p>
<p>This part contains column values for the remaining non-key columns. This part is stored in the overflow storage area segment.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-6AB23645-4BE6-4958-A9C3-0B05077C23D6__GUID-EA3976D6-59E6-4AA7-BFE4-2B84744E2806">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADMIN11685" target="_blank" href="../ADMIN/tables.htm#ADMIN11685"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to use the <code class="codeph">OVERFLOW</code> clause of <code class="codeph">CREATE TABLE</code> to set a row overflow area</p>
</li>
<li>
<p><a class="olink SQLRF54499" target="_blank" href="../SQLRF/statements_7002.htm#SQLRF54499"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code class="codeph">CREATE TABLE ... OVERFLOW</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
</div>
<a id="CNCPT912"></a>
<div class="props_rev_3"><a id="GUID-1A9D370B-12F0-4161-875E-3121C8DEF2AD"></a>
<h3 id="CNCPT-GUID-1A9D370B-12F0-4161-875E-3121C8DEF2AD" class="sect3">Secondary Indexes on Index-Organized Tables</h3>
<div>
<p>A <span class="bold">secondary index</span> is an index on an index-organized table. In a sense, it is an index on an index. The secondary index is an independent schema object and is stored separately from the index-organized table.</p>
<p>As explained in <span class="q">&#34;<a href="tablecls.htm#GUID-0258C4C2-2BF2-445F-B1E1-F282A57A6859" title="Every row stored in the database has an address. Oracle Database uses a ROWID data type to store the address (rowid) of every row in the database.">Rowid Data Types</a>&#34;</span>, Oracle Database uses row identifiers called logical rowids for index-organized tables. A <a href="glossary.htm#GUID-92AE2643-9DA4-4364-942F-81F006759302"><span class="xrefglossterm">logical rowid</span></a> is a base64-encoded representation of the table primary key. The logical rowid length depends on the primary key length.</p>
<p>Rows in index leaf blocks can move within or between blocks because of insertions. Rows in index-organized tables do not migrate as heap-organized rows do (see <span class="q">&#34;<a href="logical.htm#GUID-49D4E586-57BF-4310-9EE9-2DD54108E651" title="Oracle Database uses chaining and migration to manage rows that are too large to fit into a single block.">Chained and Migrated Rows</a>&#34;</span>). Because rows in index-organized tables do not have permanent physical addresses, the database uses logical rowids based on primary key.</p>
<p>For example, assume that the <code class="codeph">departments</code> table is index-organized. The <code class="codeph">location_id</code> column stores the ID of each department. The table stores rows as follows, with the last value as the location ID:</p>
<pre dir="ltr">10,Administration,200,1700
20,Marketing,201,1800
30,Purchasing,114,1700
40,Human Resources,203,2400
</pre>
<p>A secondary index on the <code class="codeph">location_id</code> column might have index entries as follows, where the value following the comma is the logical rowid:</p>
<pre dir="ltr">1700,*BAFAJqoCwR/+ 
1700,*BAFAJqoCwQv+
1800,*BAFAJqoCwRX+
2400,*BAFAJqoCwSn+
</pre>
<p>Secondary indexes provide fast and efficient access to index-organized tables using columns that are neither the primary key nor a prefix of the primary key. For example, a query of the names of departments whose ID is greater than 1700 could use the secondary index to speed data access.</p>
<div class="infoboxnotealso" id="GUID-1A9D370B-12F0-4161-875E-3121C8DEF2AD__GUID-DF695A0D-E1BD-49B2-89B5-E99B2391D4A1">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADMIN11696" target="_blank" href="../ADMIN/tables.htm#ADMIN11696"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to create secondary indexes on an index-organized table</p>
</li>
<li>
<p><a class="olink VLDBG003" target="_blank" href="../VLDBG/GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34.htm#VLDBG003"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> to learn about creating secondary indexes on indexed-organized table partitions</p>
</li>
</ul>
</div>
</div>
<a id="CNCPT88856"></a>
<div class="props_rev_3"><a id="GUID-59126A72-B986-4EF7-9BF2-963F454853A1"></a>
<h4 id="CNCPT-GUID-59126A72-B986-4EF7-9BF2-963F454853A1" class="sect4">Logical Rowids and Physical Guesses</h4>
<div>
<p>Secondary indexes use the logical rowids to locate table rows. A logical rowid includes a <span class="bold">physical guess</span>, which is the physical rowid of the index entry when it was first made. Oracle Database can use physical guesses to probe directly into the leaf block of the index-organized table, bypassing the primary key search. When the physical location of a row changes, the logical rowid remains valid even if it contains a physical guess that is stale.</p>
<p>For a heap-organized table, access by a secondary index involves a scan of the secondary index and an additional I/O to fetch the data block containing the row. For index-organized tables, access by a secondary index varies, depending on the use and accuracy of physical guesses:</p>
<ul style="list-style-type: disc;">
<li>
<p>Without physical guesses, access involves two index scans: a scan of the secondary index followed by a scan of the primary key index.</p>
</li>
<li>
<p>With physical guesses, access depends on their accuracy:</p>
<ul style="list-style-type: disc;">
<li>
<p>With accurate physical guesses, access involves a secondary index scan and an additional I/O to fetch the data block containing the row.</p>
</li>
<li>
<p>With inaccurate physical guesses, access involves a secondary index scan and an I/O to fetch the wrong data block (as indicated by the guess), followed by an index unique scan of the index organized table by primary key value.</p>
</li>
</ul>
</li>
</ul>
</div>
</div>
<a id="CNCPT89183"></a><a id="CNCPT88857"></a>
<div class="props_rev_3"><a id="GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F"></a>
<h4 id="CNCPT-GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F" class="sect4">Bitmap Indexes on Index-Organized Tables</h4>
<div>
<p>A secondary index on an index-organized table can be a <span class="bold">bitmap index</span>. A bitmap index stores a bitmap for each index key.</p>
<p>When bitmap indexes exist on an index-organized table, all the bitmap indexes use a heap-organized mapping table. The mapping table stores the logical rowids of the index-organized table. Each mapping table row stores one logical rowid for the corresponding index-organized table row.</p>
<p>The database accesses a bitmap index using a search key. If the database finds the key, then the bitmap entry is converted to a physical rowid. With heap-organized tables, the database uses the physical rowid to access the base table. With index-organized tables, the database uses the physical rowid to access the mapping table, which in turn yields a logical rowid that the database uses to access the index-organized table. The following figure illustrates index access for a query of the <code class="codeph">departments_iot</code> table.</p>
<div class="figure" id="GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F__CIHHIFGD">
<p class="titleinfigure">Figure 3-4 Bitmap Index on Index-Organized Table</p>
<img width="437" height="287" src="img/GUID-96D91CD9-5032-417A-B9C6-E581131835E6-default.gif" alt="Description of Figure 3-4 follows" title="Description of Figure 3-4 follows"/><br/>
<a href="img_text/GUID-96D91CD9-5032-417A-B9C6-E581131835E6-print.htm">Description of &#34;Figure 3-4 Bitmap Index on Index-Organized Table&#34;</a></div>
<!-- class="figure" -->
<div class="infobox-note" id="GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F__GUID-7EAC029C-AA29-4805-BDD5-170622A71572">
<p class="notep1">Note:</p>
<p>Movement of rows in an index-organized table does not leave the bitmap indexes built on that index-organized table unusable.</p>
</div>
<div class="infoboxnotealso" id="GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F__GUID-38D6F037-9DE4-421B-9BF9-CB288D15FB6C">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="tablecls.htm#GUID-83BDB6CC-8CE1-44FE-9BCB-B018AC316FFC" title="A rowid is effectively a 10-byte physical address of a row.">Rowids of Row Pieces</a>&#34;</span></p>
</div>
</div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1196">
<tr>
<td class="cellalignment1203">
<table class="cellalignment1201">
<tr>
<td class="cellalignment1200"><a href="tablecls.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1200"><a href="schemaob.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1205">
<table class="cellalignment1199">
<tr>
<td class="cellalignment1200"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1200"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1200"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1200"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1200"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1200"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>