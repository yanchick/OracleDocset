<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-4103"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Partitions%2C%20Views%2C%20and%20Other%20Schema%20Objects"></a><title>Partitions, Views, and Other Schema Objects</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter."/>
<meta name="keywords" content="partitions, overview, data warehouses, partitioning in, query plans, partitioning and, optimizer, partitions in query plans, characteristics, partitioning, key, tables, partitioned, keys, partition, single-level, single-level partitioning, range partitions, range, strategies, composite partitioning, composite, table partitions, table, range partitioning, by range, by list, list partitioning, partitioned tables, by hash, hash functions, functions, hash, hash partitioning, compression, indexes, local, local indexes, global indexes, indexes, global, index, local partitioned indexes, partitioned indexes, local partitioned, elimination from queries, prefixed, local, nonprefixed, local, storage, storage space, partitions, table, indexes, partitioned, partial global, partial global partitioned indexes, index-organized tables, index-organized, subqueries, queries, SQL, joins, table, views, security, uses, tables, base, base tables, views of, stored, base, schema object dependencies, schema objects, dependencies, DML, integrity constraints, shared SQL areas, data access, updatable join views, result sets, result sets, SQL, data dictionary, updatable columns, updatability, updates, updatability of views, join views, joins, object types, data types, user-defined, object, object views, CREATE MATERIALIZED VIEW statement, replication, Oracle Streams, master database, master tables, master, warehouse, materialized views, summaries, materialized, decision support systems (DSS), refreshing, refresh, incremental refresh, fast refresh, incremental, complete refresh, log-based refresh, partitioned change tracking refresh, out-of-place refresh method, in-place refresh method, in-place and out-of-place refresh, execution plans, query transformer, sequences, definition, CREATE SEQUENCE statement, sessions, sequence generation in, concurrent access, query rewrite, dimensions, dimension tables, fact tables, fact, dimension, CREATE DIMENSION statement, normalized or denormalized tables, hierarchies, join key, normalized tables, denormalized tables, normalized or denormalized, attributes, levels, GRANT statement, synonyms, securability, public, private, private synonyms, public synonyms, CREATE SYNONYM statement"/>
<meta name="dcterms.created" content="2017-07-10T11:33:29Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Concepts"/>
<meta name="dcterms.identifier" content="E41396-15"/>
<meta name="dcterms.isVersionOf" content="CNCPT"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1993, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="indexiot.htm" title="Previous" type="text/html"/>
<link rel="Next" href="datainte.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E41396-15.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-3E154566-50D6-48C1-BAE5-57EF20266B43"></a> <span id="PAGE" style="display:none;">9/34</span> <!-- End Header -->
<a id="CNCPT88858"></a>
<h1 id="CNCPT-GUID-3E154566-50D6-48C1-BAE5-57EF20266B43" class="sect1"><span class="enumeration_chapter">4</span> Partitions, Views, and Other Schema Objects</h1>
<div>
<p>Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter.</p>
<p>This chapter contains the following sections:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="schemaob.htm#GUID-91498562-1809-4E67-B7AD-9718ED60DEFF" title="In an Oracle database, partitioning enables you to decompose very large tables and indexes into smaller and more manageable pieces called partitions. Each partition is an independent object with its own name and optionally its own storage characteristics.">Overview of Partitions</a></p>
</li>
<li>
<p><a href="schemaob.htm#GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5" title="A view is a logical representation of one or more tables. In essence, a view is a stored query.">Overview of Views</a></p>
</li>
<li>
<p><a href="schemaob.htm#GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" title="A materialized view is a query result that has been stored or &#34;materialized&#34; in advance as schema objects. The FROM clause of the query can name tables, views, or materialized views.">Overview of Materialized Views</a></p>
</li>
<li>
<p><a href="schemaob.htm#GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B" title="A sequence is a schema object from which multiple users can generate unique integers. A sequence generator provides a highly scalable and well-performing method to generate surrogate keys for a number data type.">Overview of Sequences</a></p>
</li>
<li>
<p><a href="schemaob.htm#GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2" title="A typical data warehouse has two important components: dimensions and facts. A dimension is any category used in specifying business questions, for example, time, geography, product, department, and distribution channel. A fact is an event or entity associated with a particular set of dimension values, for example, units sold or profits.">Overview of Dimensions</a></p>
</li>
<li>
<p><a href="schemaob.htm#GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2" title="A synonym is an alias for a schema object. For example, you can create a synonym for a table or view, sequence, PL/SQL program unit, user-defined object type, or another synonym. Because a synonym is simply an alias, it requires no storage other than its definition in the data dictionary.">Overview of Synonyms</a></p>
</li>
</ul>
</div>
<a id="CNCPT112"></a>
<div class="props_rev_3"><a id="GUID-91498562-1809-4E67-B7AD-9718ED60DEFF"></a>
<h2 id="CNCPT-GUID-91498562-1809-4E67-B7AD-9718ED60DEFF" class="sect2">Overview of Partitions</h2>
<div>
<p>In an Oracle database, <span class="bold">partitioning</span> enables you to decompose very large tables and indexes into smaller and more manageable pieces called <span class="bold">partitions</span>. Each partition is an independent object with its own name and optionally its own storage characteristics.</p>
<p>For an analogy that illustrates partitioning, suppose an HR manager has one big box that contains employee folders. Each folder lists the employee hire date. Queries are often made for employees hired in a particular month. One approach to satisfying such requests is to create an index on employee hire date that specifies the locations of the folders scattered throughout the box. In contrast, a partitioning strategy uses many smaller boxes, with each box containing folders for employees hired in a given month.</p>
<p>Using smaller boxes has several advantages. When asked to retrieve the folders for employees hired in June, the HR manager can retrieve the June box. Furthermore, if any small box is temporarily damaged, the other small boxes remain available. Moving offices also becomes easier because instead of moving a single heavy box, the manager can move several small boxes.</p>
<p>From the perspective of an application, only one schema object exists. SQL statements require no modification to access partitioned tables. Partitioning is useful for many different types of database applications, particularly those that manage large volumes of data. Benefits include:</p>
<ul style="list-style-type: disc;">
<li>
<p>Increased availability</p>
<p>The unavailability of a partition does not entail the unavailability of the object. The query <a href="glossary.htm#GUID-54114749-0A81-41D7-8E16-7B76D93CEE2B"><span class="xrefglossterm">optimizer</span></a> automatically removes unreferenced partitions from the <a href="glossary.htm#GUID-78BCF1CD-1865-4AEB-8F14-AFA4FF1981BF"><span class="xrefglossterm">query plan</span></a> so queries are not affected when the partitions are unavailable.</p>
</li>
<li>
<p>Easier administration of schema objects</p>
<p>A partitioned object has pieces that can be managed either collectively or individually. <a href="glossary.htm#GUID-64F19D78-A73F-44A5-AA2E-60EBC800CB22"><span class="xrefglossterm">DDL</span></a> statements can manipulate partitions rather than entire tables or indexes. Thus, you can break up resource-intensive tasks such as rebuilding an index or table. For example, you can move one table partition at a time. If a problem occurs, then only the partition move must be redone, not the table move. Also, dropping a partition avoids executing numerous <code class="codeph">DELETE</code> statements.</p>
</li>
<li>
<p>Reduced contention for shared resources in <a href="glossary.htm#GUID-709E943F-FF0E-4AA6-979A-C4CB2A7B0C29"><span class="xrefglossterm">OLTP</span></a> systems</p>
<p>In some OLTP systems, partitions can decrease contention for a shared resource. For example, DML is distributed over many segments rather than one segment.</p>
</li>
<li>
<p>Enhanced query performance in data warehouses</p>
<p>In a <a href="glossary.htm#GUID-0881E18F-D245-4980-8272-64964B64E3CC"><span class="xrefglossterm">data warehouse</span></a>, partitioning can speed processing of ad hoc queries. For example, a sales table containing a million rows can be partitioned by quarter.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-91498562-1809-4E67-B7AD-9718ED60DEFF__GUID-1B96F7A7-B650-46B5-81B1-85980E541F0C">
<p class="notep1">See Also:</p>
<p><a class="olink VLDBG00101" target="_blank" href="../VLDBG/GUID-D01AB935-0567-42C5-B21E-FB36BA9C7BAD.htm#VLDBG00101"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> for an introduction to partitioning</p>
</div>
</div>
<a id="CNCPT88859"></a>
<div class="props_rev_3"><a id="GUID-E3C5EDAA-01F2-4077-915E-133045C43095"></a>
<h3 id="CNCPT-GUID-E3C5EDAA-01F2-4077-915E-133045C43095" class="sect3">Partition Characteristics</h3>
<div>
<p>Each partition of a table or index must have the same logical attributes, such as column names, data types, and constraints. For example, all partitions in a table share the same column and constraint definitions. However, each partition can have separate physical attributes, such as the tablespace to which it belongs.</p>
</div>
<a id="CNCPT1512"></a>
<div class="props_rev_3"><a id="GUID-B854D440-23E4-4374-8EC8-AE6D0BBC390D"></a>
<h4 id="CNCPT-GUID-B854D440-23E4-4374-8EC8-AE6D0BBC390D" class="sect4">Partition Key</h4>
<div>
<p>The <span class="bold">partition key</span> is a set of one or more columns that determines the partition in which each row in a partitioned table should go. Each row is unambiguously assigned to a single partition.</p>
<p>In the <code class="codeph">sales</code> table, you could specify the <code class="codeph">time_id</code> column as the key of a range partition. The database assigns rows to partitions based on whether the date in this column falls in a specified range. Oracle Database automatically directs insert, update, and delete operations to the appropriate partition by using the partition key.</p>
</div>
</div>
<a id="CNCPT1911"></a>
<div class="props_rev_3"><a id="GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914"></a>
<h4 id="CNCPT-GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914" class="sect4">Partitioning Strategies</h4>
<div>
<p>Oracle Partitioning offers several partitioning strategies that control how the database places data into partitions. The basic strategies are range, list, and hash partitioning.</p>
<p>A <a href="glossary.htm#GUID-33A45DE7-008D-4724-9BCC-9CEA6ED95337"><span class="xrefglossterm">single-level partitioning</span></a> uses only one method of data distribution, for example, only list partitioning or only range partitioning. In <a href="glossary.htm#GUID-2CBB2535-77AE-43F7-97C9-5AB9543A4742"><span class="xrefglossterm">composite partitioning</span></a>, a table is partitioned by one data distribution method and then each partition is further divided into subpartitions using a second data distribution method. For example, you could use a list partition for <code class="codeph">channel_id</code> and a range subpartition for <code class="codeph">time_id</code>.</p>
<div class="example" id="GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">
<p class="titleinexample">Example 4-1 Sample Row Set for Partitioned Table</p>
<p>This partitioning example assumes that you want to populate a partitioned table <code class="codeph">sales</code> with the following rows:</p>
<pre dir="ltr">  PROD_ID    CUST_ID TIME_ID   CHANNEL_ID   PROMO_ID QUANTITY_SOLD AMOUNT_SOLD
---------- ---------- --------- ---------- ---------- ------------- -----------
      116      11393 05-JUN-99          2        999             1       12.18
       40     100530 30-NOV-98          9         33             1       44.99
      118        133 06-JUN-01          2        999             1       17.12
      133       9450 01-DEC-00          2        999             1       31.28
       36       4523 27-JAN-99          3        999             1       53.89
      125       9417 04-FEB-98          3        999             1       16.86
       30        170 23-FEB-01          2        999             1         8.8
       24      11899 26-JUN-99          4        999             1       43.04
       35       2606 17-FEB-00          3        999             1       54.94
       45       9491 28-AUG-98          4        350             1       47.45 
</pre></div>
<!-- class="example" --></div>
<a id="CNCPT89159"></a><a id="CNCPT89158"></a><a id="CNCPT88860"></a><a id="CNCPT88862"></a>
<div class="props_rev_3"><a id="GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967"></a>
<h5 id="CNCPT-GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" class="sect5">Range Partitioning</h5>
<div>
<p>In <span class="bold">range partitioning</span>, the database maps rows to partitions based on ranges of values of the partitioning key. Range partitioning is the most common type of partitioning and is often used with dates.</p>
<p>Suppose that you create <code class="codeph">time_range_sales</code> as a partitioned table using the following SQL statement, with the <code class="codeph">time_id</code> column as the partition key:</p>
<pre dir="ltr">CREATE TABLE time_range_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , <span class="bold">time_id</span>        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY RANGE (<span class="bold">time_id</span>)
 (PARTITION SALES_1998 VALUES LESS THAN (TO_DATE(&#39;01-JAN-1999&#39;,&#39;DD-MON-YYYY&#39;)),
  PARTITION SALES_1999 VALUES LESS THAN (TO_DATE(&#39;01-JAN-2000&#39;,&#39;DD-MON-YYYY&#39;)),
  PARTITION SALES_2000 VALUES LESS THAN (TO_DATE(&#39;01-JAN-2001&#39;,&#39;DD-MON-YYYY&#39;)),
  PARTITION SALES_2001 VALUES LESS THAN (MAXVALUE)
 ); 
</pre>
<p>Afterward, you load <code class="codeph">time_range_sales</code> with the rows from <a href="schemaob.htm#GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">Example 4-1</a>. <a href="schemaob.htm#GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967__BABHEGFF">Figure 4-1</a> shows the row distributions in the four partitions. The database chooses the partition for each row based on the <code class="codeph">time_id</code> value according to the rules specified in the <code class="codeph">PARTITION BY RANGE</code> clause.</p>
<div class="figure" id="GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967__BABHEGFF">
<p class="titleinfigure">Figure 4-1 Range Partitions</p>
<img width="650" height="660" src="img/GUID-54580E24-98CA-4667-9A35-75BAD0F9D700-default.gif" alt="Description of Figure 4-1 follows" title="Description of Figure 4-1 follows"/><br/>
<a href="img_text/GUID-54580E24-98CA-4667-9A35-75BAD0F9D700-print.htm">Description of &#34;Figure 4-1 Range Partitions&#34;</a></div>
<!-- class="figure" -->
<p>The range partition key value determines the non-inclusive high bound for a specified partition. In <a href="schemaob.htm#GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967__BABHEGFF">Figure 4-1</a>, the <code class="codeph">SALES_1998</code> partition contains rows with partitioning key <code class="codeph">time_id</code> dates earlier than <code class="codeph">01-JAN-1999</code>.</p>
</div>
</div>
<a id="CNCPT89161"></a><a id="CNCPT89160"></a><a id="CNCPT88863"></a>
<div class="props_rev_3"><a id="GUID-B8381DAE-3187-4137-9A07-065A3F40E881"></a>
<h5 id="CNCPT-GUID-B8381DAE-3187-4137-9A07-065A3F40E881" class="sect5">List Partitioning</h5>
<div>
<p>In <span class="bold">list partitioning</span>, the database uses a list of discrete values as the partition key for each partition. You can use list partitioning to control how individual rows map to specific partitions. By using lists, you can group and organize related sets of data when the key used to identify them is not conveniently ordered.</p>
<p>Assume that you create <code class="codeph">list_sales</code> as a list-partitioned table using the following statement, where the<code class="codeph">channel_id</code> column is the partition key:</p>
<pre dir="ltr">CREATE TABLE list_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , <span class="bold">channel_id</span>     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY LIST (<span class="bold">channel_id</span>)
 ( PARTITION even_channels VALUES (&#39;2&#39;,&#39;4&#39;),
   PARTITION odd_channels VALUES (&#39;3&#39;,&#39;9&#39;)
 ); 
</pre>
<p>Afterward, you load the table with the rows from <a href="schemaob.htm#GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">Example 4-1</a>. <a href="schemaob.htm#GUID-B8381DAE-3187-4137-9A07-065A3F40E881__BABFAIJE">Figure 4-2</a> shows the row distribution in the two partitions. The database chooses the partition for each row based on the <code class="codeph">channel_id</code> value according to the rules specified in the <code class="codeph">PARTITION BY LIST</code> clause. Rows with a <code class="codeph">channel_id</code> value of 2 or 4 are stored in the <code class="codeph">EVEN_CHANNELS</code> partitions, while rows with a <code class="codeph">channel_id</code> value of 3 or 9 are stored in the <code class="codeph">ODD_CHANNELS</code> partition.</p>
<div class="figure" id="GUID-B8381DAE-3187-4137-9A07-065A3F40E881__BABFAIJE">
<p class="titleinfigure">Figure 4-2 List Partitions</p>
<img width="650" height="369" src="img/GUID-F8D3898F-B7F9-4543-8354-64BDA46B85C1-default.gif" alt="Description of Figure 4-2 follows" title="Description of Figure 4-2 follows"/><br/>
<a href="img_text/GUID-F8D3898F-B7F9-4543-8354-64BDA46B85C1-print.htm">Description of &#34;Figure 4-2 List Partitions&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="CNCPT89163"></a><a id="CNCPT89162"></a><a id="CNCPT88864"></a>
<div class="props_rev_3"><a id="GUID-4BF963D2-948F-45C5-B015-B5E329A513D0"></a>
<h5 id="CNCPT-GUID-4BF963D2-948F-45C5-B015-B5E329A513D0" class="sect5">Hash Partitioning</h5>
<div>
<p>In <span class="bold">hash partitioning</span>, the database maps rows to partitions based on a hashing algorithm that the database applies to the user-specified partitioning key.</p>
<p>The destination of a row is determined by the internal <a href="glossary.htm#GUID-DDDDC4BC-ADB8-40D7-9733-60CED8E4A83E"><span class="xrefglossterm">hash function</span></a> applied to the row by the database. When the number of partitions is a power of 2, the hashing algorithm creates a roughly even distribution of rows across all partitions.</p>
<p>Hash partitioning is useful for dividing large tables to increase manageability. Instead of one large table to manage, you have several smaller pieces. The loss of a single hash partition does not affect the remaining partitions and can be recovered independently. Hash partitioning is also useful in <a href="glossary.htm#GUID-709E943F-FF0E-4AA6-979A-C4CB2A7B0C29"><span class="xrefglossterm">OLTP</span></a> systems with high update contention. For example, a segment is divided into several pieces, each of which is updated, instead of a single segment that experiences contention.</p>
<p>Assume that you create the partitioned <code class="codeph">hash_sales</code> table using the following statement, with the <code class="codeph">prod_id</code> column as the partition key:</p>
<pre dir="ltr">CREATE TABLE hash_sales
   ( <span class="bold">prod_id</span>        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY HASH (<span class="bold">prod_id</span>)
PARTITIONS 2; 
</pre>
<p>Afterward, you load the table with the rows from <a href="schemaob.htm#GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">Example 4-1</a>. <a href="schemaob.htm#GUID-4BF963D2-948F-45C5-B015-B5E329A513D0__BABBFIAG">Figure 4-3</a> shows a possible row distribution in the two partitions. The names of these partitions are system-generated.</p>
<p>As you insert rows, the database attempts to randomly and evenly distribute them across partitions. You cannot specify the partition into which a row is placed. The database applies the hash function, whose outcome determines which partition contains the row.</p>
<div class="figure" id="GUID-4BF963D2-948F-45C5-B015-B5E329A513D0__BABBFIAG">
<p class="titleinfigure">Figure 4-3 Hash Partitions</p>
<img width="651" height="360" src="img/GUID-6E1495D8-5502-4419-B3F3-0B42074E4739-default.gif" alt="Description of Figure 4-3 follows" title="Description of Figure 4-3 follows"/><br/>
<a href="img_text/GUID-6E1495D8-5502-4419-B3F3-0B42074E4739-print.htm">Description of &#34;Figure 4-3 Hash Partitions&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-4BF963D2-948F-45C5-B015-B5E329A513D0__GUID-1CA60423-2800-4131-A8EC-68CB612BA4CF">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink VLDBG003" target="_blank" href="../VLDBG/GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34.htm#VLDBG003"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn how to create partitions</p>
</li>
<li>
<p><a class="olink SQLRF54655" target="_blank" href="../SQLRF/statements_7002.htm#SQLRF54655"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">CREATE TABLE ... PARTITION BY</code> examples</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<a id="CNCPT1136"></a>
<div class="props_rev_3"><a id="GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649"></a>
<h3 id="CNCPT-GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649" class="sect3">Partitioned Tables</h3>
<div>
<p>A <span class="bold">partitioned table</span> consists of one or more partitions, which are managed individually and can operate independently of the other partitions. A table is either partitioned or nonpartitioned. Even if a partitioned table consists of only one partition, this table is different from a nonpartitioned table, which cannot have partitions added to it.</p>
<p>A partitioned table is made up of one or more table partition segments (see <span class="q">&#34;<a href="schemaob.htm#GUID-E3C5EDAA-01F2-4077-915E-133045C43095" title="Each partition of a table or index must have the same logical attributes, such as column names, data types, and constraints. For example, all partitions in a table share the same column and constraint definitions. However, each partition can have separate physical attributes, such as the tablespace to which it belongs.">Partition Characteristics</a>&#34;</span> gives examples of partitioned tables). If you create a partitioned table named <code class="codeph">hash_products</code>, then no table <a href="glossary.htm#GUID-EC12AA68-8C89-43B3-B1F9-3AABF7CAEB9F"><span class="xrefglossterm">segment</span></a> is allocated for this table. Instead, the database stores data for each table partition in its own partition segment. Each table partition segment contains a portion of the table data.</p>
<p>Some or all partitions of a heap-organized table can be stored in a compressed format. Compression saves space and can speed query execution. Thus, compression can be useful in environments such as data warehouses, where the amount of insert and update operations is small, and in OLTP environments.</p>
<p>You can declare the attributes for <a href="glossary.htm#GUID-9C21768F-A722-47F1-B54C-5563BDA38074"><span class="xrefglossterm">table compression</span></a> for a tablespace, table, or table partition. If declared at the tablespace level, then tables created in the tablespace are compressed by default. You can alter the compression attribute for a table, in which case the change only applies to new data going into that table. Consequently, a single table or partition may contain compressed and uncompressed blocks, which guarantees that data size will not increase because of compression. If compression could increase the size of a block, then the database does not apply it to the block.</p>
<div class="infoboxnotealso" id="GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649__GUID-D2A5C288-F202-4118-81B2-037FE495D585">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="tablecls.htm#GUID-54EE5325-0894-4869-B3AD-8912D9B4A329" title="The database can use table compression to reduce the amount of storage required for the table.">Table Compression</a>&#34;</span> and <span class="q">&#34;<a href="logical.htm#GUID-7DA83E64-9FF1-45A7-A9AC-D4997DDE0866" title="A segment is a set of extents that contains all the data for a logical storage structure within a tablespace.">Overview of Segments</a>&#34;</span></p>
</li>
<li>
<p><a class="olink DWHSG8913" target="_blank" href="../DWHSG/schemas.htm#DWHSG8913"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn about table compression in a data warehouse</p>
</li>
</ul>
</div>
</div>
</div>
<a id="CNCPT312"></a>
<div class="props_rev_3"><a id="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7"></a>
<h3 id="CNCPT-GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7" class="sect3">Partitioned Indexes</h3>
<div>
<p>A <span class="bold">partitioned index</span> is an index that, like a partitioned table, has been divided into smaller and more manageable pieces.</p>
<p>Global indexes are partitioned independently of the table on which they are created, whereas local indexes are automatically linked to the partitioning method for a table. Like partitioned tables, partitioned indexes improve manageability, availability, performance, and scalability.</p>
<p>The following graphic shows index partitioning options.</p>
<div class="figure" id="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7__GUID-949D2696-9990-4E05-986A-4442C882B558">
<p class="titleinfigure">Figure 4-4 Index Partitioning Options</p>
<img width="476" height="195" src="img/GUID-14880F7C-87E0-4A66-8FC2-D0D2BAAB8410-default.gif" alt="Description of Figure 4-4 follows" title="Description of Figure 4-4 follows"/><br/>
<a href="img_text/GUID-14880F7C-87E0-4A66-8FC2-D0D2BAAB8410-print.htm">Description of &#34;Figure 4-4 Index Partitioning Options&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7__GUID-E9A650C9-525A-457B-B035-81EA4712229C">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="indexiot.htm#GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access. Indexes are schema objects that are logically and physically independent of the data in the objects with which they are associated. Thus, you can drop or create an index without physically affecting the indexed table.">Introduction to Indexes</a>&#34;</span></p>
</li>
<li>
<p><a class="olink VLDBG00203" target="_blank" href="../VLDBG/GUID-EE0A6FF8-50BB-4D9D-A7EB-E9FF9DCBEE06.htm#VLDBG00203"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> and <a class="olink TGSQL865" target="_blank" href="../TGSQL/tgsql_indc.htm#TGSQL865"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a> for more information about partitioned indexes and how to decide which type to use</p>
</li>
</ul>
</div>
</div>
<a id="CNCPT88867"></a><a id="CNCPT88866"></a><a id="CNCPT1520"></a>
<div class="props_rev_3"><a id="GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF"></a>
<h4 id="CNCPT-GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF" class="sect4">Local Partitioned Indexes</h4>
<div>
<p>In a <span class="bold">local partitioned index</span>, the index is partitioned on the same columns, with the same number of partitions and the same partition bounds as its table.</p>
<p>Each index partition is associated with exactly one partition of the underlying table, so that all keys in an index partition refer only to rows stored in a single table partition. In this way, the database automatically synchronizes index partitions with their associated table partitions, making each table-index pair independent.</p>
<p>Local partitioned indexes are common in data warehousing environments. Local indexes offer the following advantages:</p>
<ul style="list-style-type: disc;">
<li>
<p>Availability is increased because actions that make data invalid or unavailable in a partition affect this partition only.</p>
</li>
<li>
<p>Partition maintenance is simplified. When moving a table partition, or when data ages out of a partition, only the associated local index partition must be rebuilt or maintained. In a global index, all index partitions must be rebuilt or maintained.</p>
</li>
<li>
<p>If point-in-time recovery of a partition occurs, then the indexes can be recovered to the recovery time (see <span class="q">&#34;<a href="cncptdba.htm#GUID-7F5703F9-CAE5-4736-895B-B45A51974A7C" title="Data file recovery repairs a lost or damaged current data file or control file. It can also recover changes lost when a tablespace went offline without the OFFLINE NORMAL option.">Data File Recovery</a>&#34;</span>). The entire index does not need to be rebuilt.</p>
</li>
</ul>
<p>The example in <a href="schemaob.htm#GUID-4BF963D2-948F-45C5-B015-B5E329A513D0" title="In hash partitioning, the database maps rows to partitions based on a hashing algorithm that the database applies to the user-specified partitioning key.">Hash Partitioning</a> shows the creation statement for the partitioned <code class="codeph">hash_sales</code> table, using the <code class="codeph">prod_id</code> column as partition key. The following example creates a local partitioned index on the <code class="codeph">time_id</code> column of the <code class="codeph">hash_sales</code> table:</p>
<pre dir="ltr">CREATE INDEX hash_sales_idx ON hash_sales(time_id) LOCAL;
</pre>
<p>In <a href="schemaob.htm#GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF__CFAIJFJI">Figure 4-5</a>, the <code class="codeph">hash_products</code> table has two partitions, so <code class="codeph">hash_sales_idx</code> has two partitions. Each index partition is associated with a different table partition. Index partition <code class="codeph">SYS_P38</code> indexes rows in table partition <code class="codeph">SYS_P33</code>, whereas index partition <code class="codeph">SYS_P39</code> indexes rows in table partition <code class="codeph">SYS_P34</code>.</p>
<div class="figure" id="GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF__CFAIJFJI">
<p class="titleinfigure">Figure 4-5 Local Index Partitions</p>
<img width="626" height="573" src="img/GUID-D7A58AC5-B404-42D3-8F92-2D5D0AD34DBB-default.gif" alt="Description of Figure 4-5 follows" title="Description of Figure 4-5 follows"/><br/>
<a href="img_text/GUID-D7A58AC5-B404-42D3-8F92-2D5D0AD34DBB-print.htm">Description of &#34;Figure 4-5 Local Index Partitions&#34;</a></div>
<!-- class="figure" -->
<p>You cannot explicitly add a partition to a local index. Instead, new partitions are added to local indexes only when you add a partition to the underlying table. Likewise, you cannot explicitly drop a partition from a local index. Instead, local index partitions are dropped only when you drop a partition from the underlying table.</p>
<p>Like other indexes, you can create a <a href="glossary.htm#GUID-20C91FE3-E7A0-44AC-8AC1-9C4301877B65"><span class="xrefglossterm">bitmap index</span></a> on partitioned tables. The only restriction is that bitmap indexes must be local to the partitioned table&mdash;they cannot be global indexes. Global bitmap indexes are supported only on nonpartitioned tables.</p>
</div>
<a id="CNCPT88868"></a>
<div class="props_rev_3"><a id="GUID-C83926F0-9AEA-4437-942C-9A80394DB63F"></a>
<h5 id="CNCPT-GUID-C83926F0-9AEA-4437-942C-9A80394DB63F" class="sect5">Local Prefixed and Nonprefixed Indexes</h5>
<div>
<p>Local partitioned indexes are either prefixed or nonprefixed.</p>
<p>The index subtypes are defined as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>Local prefixed indexes</p>
<p>In this case, the partition keys are on the leading edge of the index definition. In the <code class="codeph">time_range_sales</code> example in <a href="schemaob.htm#GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" title="In range partitioning, the database maps rows to partitions based on ranges of values of the partitioning key. Range partitioning is the most common type of partitioning and is often used with dates.">Range Partitioning</a>, the table is partitioned by range on <code class="codeph">time_id</code>. A local prefixed index on this table would have <code class="codeph">time_id</code> as the first column in its list.</p>
</li>
<li>
<p>Local nonprefixed indexes</p>
<p>In this case, the partition keys are not on the leading edge of the indexed column list and need not be in the list at all. In the <code class="codeph">hash_sales_idx</code> example in <a href="schemaob.htm#GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF" title="In a local partitioned index, the index is partitioned on the same columns, with the same number of partitions and the same partition bounds as its table.">Local Partitioned Indexes</a>, the index is local nonprefixed because the partition key <code class="codeph">product_id</code> is not on the leading edge.</p>
</li>
</ul>
<p>Both types of indexes can take advantage of <a href="glossary.htm#GUID-17D46EB4-6C99-419E-86D7-91C4370BE8BF"><span class="xrefglossterm">partition elimination</span></a> (also called <span class="italic">partition pruning</span>), which occurs when the optimizer speeds data access by excluding partitions from consideration. Whether a <a href="glossary.htm#GUID-CCF91C9F-A98A-498F-A84B-58A0FA16CD6E"><span class="xrefglossterm">query</span></a> can eliminate partitions depends on the query <a href="glossary.htm#GUID-891CF9E9-78CD-470C-9C4A-D65A101B2C38"><span class="xrefglossterm">predicate</span></a>. A query that uses a local prefixed index always allows for index partition elimination, whereas a query that uses a local nonprefixed index might not.</p>
<div class="infoboxnotealso" id="GUID-C83926F0-9AEA-4437-942C-9A80394DB63F__GUID-691674B7-CCA0-4CE4-A78C-7EFEC8993E2B">
<p class="notep1">See Also:</p>
<p><a class="olink VLDBG1251" target="_blank" href="../VLDBG/GUID-554495C0-6FE9-4F27-96A9-1562727AD401.htm#VLDBG1251"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn how to use prefixed and nonprefixed indexes</p>
</div>
</div>
</div>
<a id="CNCPT88869"></a>
<div class="props_rev_3"><a id="GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277"></a>
<h5 id="CNCPT-GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277" class="sect5">Local Partitioned Index Storage</h5>
<div>
<p>Like a table partition, a local index partition is stored in its own segment. Each segment contains a portion of the total index data. Thus, a local index made up of four partitions is not stored in a single index segment, but in four separate segments.</p>
<div class="infoboxnotealso" id="GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277__GUID-A58D2412-6CA0-4982-8145-2A2B837F95D5">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF54053" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF54053"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code class="codeph">CREATE INDEX ... LOCAL</code> examples</p>
</div>
</div>
</div>
</div>
<a id="CNCPT88870"></a><a id="CNCPT89164"></a><a id="CNCPT1521"></a>
<div class="props_rev_3"><a id="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB"></a>
<h4 id="CNCPT-GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB" class="sect4">Global Partitioned Indexes</h4>
<div>
<p>A <span class="bold">global partitioned index</span> is a B-tree index that is partitioned independently of the underlying table on which it is created. A single index partition can point to any or all table partitions, whereas in a locally partitioned index, a one-to-one parity exists between index partitions and table partitions.</p>
<p>In general, global indexes are useful for OLTP applications, where rapid access, data integrity, and availability are important. In an OLTP system, a table may be partitioned by one key, for example, the <code class="codeph">employees.department_id</code> column, but an application may need to access the data with many different keys, for example, by <code class="codeph">employee_id</code> or <code class="codeph">job_id</code>. Global indexes can be useful in this scenario.</p>
<p>As an illustration, suppose that you create a global partitioned index on the <code class="codeph">time_range_sales</code> table from <span class="q">&#34;<a href="schemaob.htm#GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" title="In range partitioning, the database maps rows to partitions based on ranges of values of the partitioning key. Range partitioning is the most common type of partitioning and is often used with dates.">Range Partitioning</a>&#34;</span>. In this table, rows for sales from 1998 are stored in one partition, rows for sales from 1999 are in another, and so on. The following example creates a global index partitioned by range on the <code class="codeph">channel_id</code> column:</p>
<pre dir="ltr">CREATE INDEX time_channel_sales_idx ON time_range_sales (<span class="bold">channel_id</span>)
   GLOBAL PARTITION BY RANGE (<span class="bold">channel_id</span>)
      (PARTITION p1 VALUES LESS THAN (3),
       PARTITION p2 VALUES LESS THAN (4),
       PARTITION p3 VALUES LESS THAN (MAXVALUE));
</pre>
<p>As shown in <a href="schemaob.htm#GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__CFAEBFFA">Figure 4-6</a>, a global index partition can contain entries that point to multiple table partitions. Index partition <code class="codeph">p1</code> points to the rows with a <code class="codeph">channel_id</code> of 2, index partition <code class="codeph">p2</code> points to the rows with a <code class="codeph">channel_id</code> of 3, and index partition <code class="codeph">p3</code> points to the rows with a <code class="codeph">channel_id</code> of 4 or 9.</p>
<div class="figure" id="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__CFAEBFFA">
<p class="titleinfigure">Figure 4-6 Global Partitioned Index</p>
<img width="654" height="770" src="img/GUID-0B8FDC8D-3612-4733-A09B-973E30692366-default.gif" alt="Description of Figure 4-6 follows" title="Description of Figure 4-6 follows"/><br/>
<a href="img_text/GUID-0B8FDC8D-3612-4733-A09B-973E30692366-print.htm">Description of &#34;Figure 4-6 Global Partitioned Index&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__GUID-5B2F1E5D-76C6-40AB-AD1C-556AE76689C5">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink VLDBG1256" target="_blank" href="../VLDBG/GUID-D1E775A0-669B-4E51-8D40-858847B64BEF.htm#VLDBG1256"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> to learn how to manage global partitioned indexes</p>
</li>
<li>
<p><a class="olink SQLRF54012" target="_blank" href="../SQLRF/statements_5013.htm#SQLRF54012"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">GLOBAL PARTITION</code> clause of <code class="codeph">CREATE INDEX</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="CNCPT89215"></a><a id="CNCPT89298"></a>
<div class="props_rev_3"><a id="GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316"></a>
<h3 id="CNCPT-GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316" class="sect3">Partial Indexes for Partitioned Tables</h3>
<div>
<p>A <span class="bold">partial index</span> is an index that is correlated with the indexing properties of an associated partitioned table. The correlation enables you to specify which table partitions are indexed.</p>
<p>Partial indexes provide the following advantages:</p>
<ul style="list-style-type: disc;">
<li>
<p>Table partitions that are not indexed avoid consuming unnecessary index storage space.</p>
</li>
<li>
<p>Performance of loads and queries can improve.</p>
<p>Before Oracle Database 12<span class="italic">c</span>, an exchange partition operation required a physical update of an associated global index to retain it as usable. Starting with Oracle Database 12<span class="italic">c</span>, if the partitions involved in a partition maintenance operation are not part of a partial global index, then the index remains usable without requiring any global index maintenance.</p>
</li>
<li>
<p>If you index only some table partitions at index creation, and if you later index other partitions, then you can reduce the sort space required by index creation.</p>
</li>
</ul>
<p>You can turn indexing on or off for the individual partitions of a table. A partial local index does not have usable index partitions for all table partitions that have indexing turned off. A global index, whether partitioned or not, excludes the data from all partitions that have indexing turned off. The database does not support partial indexes for indexes that enforce unique constraints.</p>
<p><a href="schemaob.htm#GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316__CHDGFHDC">Figure 4-7</a> shows the same global index as in <a href="schemaob.htm#GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__CFAEBFFA">Figure 4-6</a>, except that the global index is partial. Table partitions <code class="codeph">SALES_1998</code> and <code class="codeph">SALES_2000</code> have the indexing property set to <code class="codeph">OFF</code>, so the partial global index does not index them.</p>
<div class="figure" id="GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316__CHDGFHDC">
<p class="titleinfigure">Figure 4-7 Partial Global Partitioned Index</p>
<img width="656" height="771" src="img/GUID-7AF08DE9-7802-4DE7-889C-B6901254BF58-default.png" alt="Description of Figure 4-7 follows" title="Description of Figure 4-7 follows"/><br/>
<a href="img_text/GUID-7AF08DE9-7802-4DE7-889C-B6901254BF58-print.htm">Description of &#34;Figure 4-7 Partial Global Partitioned Index&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="CNCPT1514"></a>
<div class="props_rev_3"><a id="GUID-812AEDDB-466C-46F0-BAE3-4B3D1A969F00"></a>
<h3 id="CNCPT-GUID-812AEDDB-466C-46F0-BAE3-4B3D1A969F00" class="sect3">Partitioned Index-Organized Tables</h3>
<div>
<p>An <span class="bold">index-organized table</span> (IOT) supports partitioning by range, list, or hash. Partitioning is useful for providing improved manageability, availability, and performance for IOTs. In addition, data cartridges that use IOTs can take advantage of the ability to partition their stored data.</p>
<p>Note the following characteristics of partitioned IOTs:</p>
<ul style="list-style-type: disc;">
<li>
<p>Partition columns must be a subset of primary key columns.</p>
</li>
<li>
<p>Secondary indexes can be partitioned locally and globally.</p>
</li>
<li>
<p><code class="codeph">OVERFLOW</code> data segments are always equipartitioned with the table partitions.</p>
</li>
</ul>
<p>Oracle Database supports bitmap indexes on partitioned and nonpartitioned index-organized tables. A mapping table is required for creating bitmap indexes on an index-organized table.</p>
<div class="infoboxnotealso" id="GUID-812AEDDB-466C-46F0-BAE3-4B3D1A969F00__GUID-565D4317-0C71-4359-9A48-10E31385DBBB">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="indexiot.htm#GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" title="An index-organized table is a table stored in a variation of a B-tree index structure. In contrast, a heap-organized table inserts rows where they fit.">Overview of Index-Organized Tables</a>&#34;</span></p>
</div>
</div>
</div>
</div>
<a id="CNCPT88871"></a><a id="CNCPT311"></a>
<div class="props_rev_3"><a id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5"></a>
<h2 id="CNCPT-GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5" class="sect2">Overview of Views</h2>
<div>
<p>A <span class="bold">view</span> is a logical representation of one or more tables. In essence, a view is a stored query.</p>
<p>A view derives its data from the tables on which it is based, called <span class="italic">base tables</span>. Base tables can be tables or other views. All operations performed on a view actually affect the base tables. You can use views in most places where tables are used.</p>
<div class="infobox-note" id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__GUID-7E33B4D0-E237-4051-A508-011502739BC5">
<p class="notep1">Note:</p>
<p>Materialized views use a different data structure from standard views.</p>
</div>
<p>Views enable you to tailor the presentation of data to different types of users. Views are often used to:</p>
<ul style="list-style-type: disc;">
<li>
<p>Provide an additional level of table security by restricting access to a predetermined set of rows or columns of a table</p>
<p>For example, <a href="schemaob.htm#GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__I5739">Figure 4-8</a> shows how the <code class="codeph">staff</code> view does not show the <code class="codeph">salary</code> or <code class="codeph">commission_pct</code> columns of the base table <code class="codeph">employees</code>.</p>
</li>
<li>
<p>Hide data complexity</p>
<p>For example, a single view can be defined with a <a href="glossary.htm#GUID-71A4D429-D0A6-4979-AACA-EDE5F4BCFC8B"><span class="xrefglossterm">join</span></a>, which is a collection of related columns or rows in multiple tables. However, the view hides the fact that this information actually originates from several tables. A query might also perform extensive calculations with table information. Thus, users can query a view without knowing how to perform a join or calculations.</p>
</li>
<li>
<p>Present the data in a different perspective from that of the base table</p>
<p>For example, the columns of a view can be renamed without affecting the tables on which the view is based.</p>
</li>
<li>
<p>Isolate applications from changes in definitions of base tables</p>
<p>For example, if the defining query of a view references three columns of a four column table, and a fifth column is added to the table, then the definition of the view is not affected, and all applications using the view are not affected.</p>
</li>
</ul>
<p>For an example of the use of views, consider the <code class="codeph">hr.employees</code> table, which has several columns and numerous rows. To allow users to see only five of these columns or only specific rows, you could create a view as follows:</p>
<pre dir="ltr">CREATE VIEW staff AS
  SELECT employee_id, last_name, job_id, manager_id, department_id
  FROM   employees;
</pre>
<p>As with all subqueries, the query that defines a view cannot contain the <code class="codeph">FOR UPDATE</code> clause. The following graphic illustrates the view named <code class="codeph">staff</code>. Notice that the view shows only five of the columns in the base table.</p>
<div class="figure" id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__I5739">
<p class="titleinfigure">Figure 4-8 View</p>
<img width="648" height="327" src="img/GUID-3089311D-ED7B-400F-B5F2-DC486BB78F48-default.gif" alt="Description of Figure 4-8 follows" title="Description of Figure 4-8 follows"/><br/>
<a href="img_text/GUID-3089311D-ED7B-400F-B5F2-DC486BB78F48-print.htm">Description of &#34;Figure 4-8 View&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__GUID-E83635A7-C789-413E-954F-8BE44F222B84">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="schemaob.htm#GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" title="A materialized view is a query result that has been stored or &#34;materialized&#34; in advance as schema objects. The FROM clause of the query can name tables, views, or materialized views.">Overview of Materialized Views</a>&#34;</span></p>
</li>
<li>
<p><a class="olink ADMIN11774" target="_blank" href="../ADMIN/views.htm#ADMIN11774"><span><cite>Oracle Database Administrator&rsquo;s Guide</cite></span></a> to learn how to manage views</p>
</li>
<li>
<p><a class="olink SQLRF01504" target="_blank" href="../SQLRF/statements_8004.htm#SQLRF01504"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">CREATE VIEW</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
<a id="CNCPT1145"></a>
<div class="props_rev_3"><a id="GUID-B79EF730-11A8-4620-A0BE-7609F9B4E586"></a>
<h3 id="CNCPT-GUID-B79EF730-11A8-4620-A0BE-7609F9B4E586" class="sect3">Characteristics of Views</h3>
<div>
<p>Unlike a table, a view is not allocated storage space, nor does a view contain data. Rather, a view is defined by a query that extracts or derives data from the base tables referenced by the view. Because a view is based on other objects, it requires no storage other than storage for the query that defines the view in the data dictionary.</p>
<p>A view has dependencies on its referenced objects, which are automatically handled by the database. For example, if you drop and re-create a base table of a view, then the database determines whether the new base table is acceptable to the view definition.</p>
</div>
<a id="CNCPT88872"></a>
<div class="props_rev_3"><a id="GUID-322500BA-F86A-4C80-834F-7AD46C921817"></a>
<h4 id="CNCPT-GUID-322500BA-F86A-4C80-834F-7AD46C921817" class="sect4">Data Manipulation in Views</h4>
<div>
<p>Because views are derived from tables, they have many similarities. Users can query views, and with some restrictions they can perform DML on views. Operations performed on a view affect data in some base table of the view and are subject to the integrity constraints and triggers of the base tables.</p>
<p>The following example creates a view of the <code class="codeph">hr.employees</code> table:</p>
<pre dir="ltr">CREATE VIEW staff_dept_10 AS
SELECT employee_id, last_name, job_id, 
       manager_id, department_id
FROM   employees
WHERE  department_id = 10
WITH CHECK OPTION CONSTRAINT staff_dept_10_cnst;
</pre>
<p>The defining query references only rows for department 10. The <code class="codeph">CHECK OPTION</code> creates the view with a constraint so that <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> statements issued against the view cannot result in rows that the view cannot select. Thus, rows for employees in department 10 can be inserted, but not rows for department 30.</p>
<div class="infoboxnotealso" id="GUID-322500BA-F86A-4C80-834F-7AD46C921817__GUID-F5A74FC6-EDB3-48B9-9564-172C45D76F62">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF55299" target="_blank" href="../SQLRF/statements_10002.htm#SQLRF55299"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about subquery restrictions in <code class="codeph">CREATE VIEW</code> statements</p>
</div>
</div>
</div>
<a id="CNCPT1147"></a>
<div class="props_rev_3"><a id="GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A"></a>
<h4 id="CNCPT-GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A" class="sect4">How Data Is Accessed in Views</h4>
<div>
<p>Oracle Database stores a view definition in the data dictionary as the text of the query that defines the view.</p>
<p>When you reference a view in a SQL statement, Oracle Database performs the following tasks:</p>
<ol>
<li>
<p>Merges a query (whenever possible) against a view with the queries that define the view and any underlying views</p>
<p>Oracle Database optimizes the merged query as if you issued the query without referencing the views. Therefore, Oracle Database can use indexes on any referenced base table columns, whether the columns are referenced in the view definition or in the user query against the view.</p>
<p>Sometimes Oracle Database cannot merge the view definition with the user query. In such cases, Oracle Database may not use all indexes on referenced columns.</p>
</li>
<li>
<p>Parses the merged statement in a <a href="glossary.htm#GUID-E0BE3164-B0A9-4ED8-AD19-2048ADFFC9BB"><span class="xrefglossterm">shared SQL area</span></a></p>
<p>Oracle Database parses a statement that references a view in a new shared SQL area <span class="italic">only</span> if no existing shared SQL area contains a similar statement. Thus, views provide the benefit of reduced memory use associated with shared SQL.</p>
</li>
<li>
<p>Executes the SQL statement</p>
</li>
</ol>
<p>The following example illustrates data access when a view is queried. Assume that you create <code class="codeph">employees_view</code> based on the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables:</p>
<pre dir="ltr">CREATE VIEW employees_view AS 
  SELECT employee_id, last_name, salary, location_id
  FROM   employees JOIN departments USING (department_id)
  WHERE  department_id = 10; 
</pre>
<p>A user executes the following query of <code class="codeph">employees_view</code>:</p>
<pre dir="ltr">SELECT last_name 
FROM   employees_view
WHERE  employee_id = 200;
</pre>
<p>Oracle Database merges the view and the user query to construct the following query, which it then executes to retrieve the data:</p>
<pre dir="ltr">SELECT last_name
FROM   employees, departments
WHERE  employees.department_id = departments.department_id 
AND    departments.department_id = 10 
AND    employees.employee_id = 200;
</pre>
<div class="infoboxnotealso" id="GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A__GUID-FA88DF34-4E10-4C30-B024-91266535E864">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="sqllangu.htm#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="To understand how Oracle Database processes SQL statements, it is necessary to understand the part of the database called the optimizer (also known as the query optimizer or cost-based optimizer). All SQL statements use the optimizer to determine the most efficient means of accessing the specified data.">Overview of the Optimizer</a>&#34;</span> and <a class="olink TGSQL193" target="_blank" href="../TGSQL/tgsql_optcncpt.htm#TGSQL193"><span class="italic">Oracle Database SQL Tuning Guide</span></a> to learn about query optimization</p>
</li>
<li>
<p><span class="q">&#34;<a href="memory.htm#GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8" title="The database represents each SQL statement that it runs in the shared SQL area and private SQL area.">Shared SQL Areas</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="CNCPT88873"></a><a id="CNCPT1151"></a>
<div class="props_rev_3"><a id="GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA"></a>
<h3 id="CNCPT-GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA" class="sect3">Updatable Join Views</h3>
<div>
<p>A <span class="bold">join view</span> has multiple tables or views in its <code class="codeph">FROM</code> clause.</p>
<p>In the following example, the <code class="codeph">staff_dept_10_30</code> view joins the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables, including only employees in departments 10 or 30:</p>
<pre dir="ltr">CREATE VIEW staff_dept_10_30 AS
SELECT employee_id, last_name, job_id, e.department_id
FROM   employees e, departments d
WHERE  e.department_id IN (10, 30)
AND    e.department_id = d.department_id;
</pre>
<p>An <a href="glossary.htm#GUID-F510D35A-83C5-4974-B6F0-5E4073F73DE1"><span class="xrefglossterm">updatable join view</span></a>, also called a <span class="italic">modifiable join view</span>, involves two or more base tables or views and permits DML operations. An updatable view contains multiple tables in the top-level <code class="codeph">FROM</code> clause of the <code class="codeph">SELECT</code> statement and is not restricted by the <code class="codeph">WITH READ ONLY</code> clause.</p>
<p>To be inherently updatable, a view must meet several criteria. For example, a general rule is that an <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> operation on a join view can modify only one base table at a time. The following query of the <code class="codeph">USER_UPDATABLE_COLUMNS</code> data dictionary view shows that the <code class="codeph">staff_dept_10_30</code> view is updatable:</p>
<pre dir="ltr">SQL&gt; SELECT TABLE_NAME, COLUMN_NAME, UPDATABLE 
  2  FROM   USER_UPDATABLE_COLUMNS 
  3  WHERE  TABLE_NAME = &#39;STAFF_DEPT_10_30&#39;;
 
TABLE_NAME                     COLUMN_NAME                    UPD
------------------------------ ------------------------------ ---
STAFF_DEPT_10_30               EMPLOYEE_ID                    YES
STAFF_DEPT_10_30               LAST_NAME                      YES
STAFF_DEPT_10_30               JOB_ID                         YES
STAFF_DEPT_10_30               DEPARTMENT_ID                  YES
</pre>
<p>All updatable columns of a join view must map to columns of a <a href="glossary.htm#GUID-481043B7-88C3-4492-8949-68ECE8077702"><span class="xrefglossterm">key-preserved table</span></a>, which is a table in which each row of the underlying table appears at most one time in the query output. In the <code class="codeph">staff_dept_10_30</code> view, <code class="codeph">department_id</code> is the primary key of the <code class="codeph">departments</code> table, so each row from the <code class="codeph">employees</code> table appears at most once in the result set, making the <code class="codeph">employees</code> table key-preserved. The <code class="codeph">departments</code> table is not key-preserved because each of its rows may appear many times in the result set.</p>
<div class="infoboxnotealso" id="GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA__GUID-871DBA67-313B-456B-B688-763137512B0F">
<p class="notep1">See Also:</p>
<p><a class="olink ADMIN11782" target="_blank" href="../ADMIN/views.htm#ADMIN11782"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to update join views</p>
</div>
</div>
</div>
<a id="CNCPT1152"></a>
<div class="props_rev_3"><a id="GUID-15BCE53C-7A32-40B9-923F-151DABF4647F"></a>
<h3 id="CNCPT-GUID-15BCE53C-7A32-40B9-923F-151DABF4647F" class="sect3">Object Views</h3>
<div>
<p>Just as a view is a virtual table, an <span class="bold">object view</span> is a virtual object table. Each row in the view is an object, which is an instance of an <span class="bold">object type</span>. An object type is a user-defined data type.</p>
<p>You can retrieve, update, insert, and delete relational data as if it were stored as an object type. You can also define views with columns that are object data types, such as objects, <code class="codeph">REF</code>s, and collections (nested tables and <code class="codeph">VARRAY</code>s).</p>
<p>Like relational views, object views can present only the data that database administrators want users to see. For example, an object view could present data about IT programmers but omit sensitive data about salaries. The following example creates an <code class="codeph">employee_type</code> object and then the view <code class="codeph">it_prog_view</code> based on this object:</p>
<pre dir="ltr">CREATE TYPE employee_type AS OBJECT
(
  employee_id  NUMBER (6),
  last_name    VARCHAR2 (25),
  job_id       VARCHAR2 (10)
);
/

CREATE VIEW it_prog_view OF employee_type
  WITH OBJECT IDENTIFIER (employee_id) AS 
SELECT  e.employee_id, e.last_name, e.job_id
FROM    employees e
WHERE   job_id = &#39;IT_PROG&#39;;
</pre>
<p>Object views are useful in prototyping or transitioning to object-oriented applications because the data in the view can be taken from relational tables and accessed as if the table were defined as an object table. You can run object-oriented applications without converting existing tables to a different physical structure.</p>
<div class="infoboxnotealso" id="GUID-15BCE53C-7A32-40B9-923F-151DABF4647F__GUID-27CDE188-60BC-4A5D-A834-04C427FD4DE2">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADOBJ7026" target="_blank" href="../ADOBJ/adobjint.htm#ADOBJ7026"><span class="italic">Oracle Database Object-Relational Developer&#39;s Guide</span></a> to learn about object types and object views</p>
</li>
<li>
<p><a class="olink SQLRF01506" target="_blank" href="../SQLRF/statements_8001.htm#SQLRF01506"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the <code class="codeph">CREATE TYPE</code> statement</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="CNCPT88874"></a><a id="CNCPT411"></a>
<div class="props_rev_3"><a id="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829"></a>
<h2 id="CNCPT-GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" class="sect2">Overview of Materialized Views</h2>
<div>
<p>A <span class="bold">materialized view</span> is a query result that has been stored or &#34;materialized&#34; in advance as schema objects. The <code class="codeph">FROM</code> clause of the query can name tables, views, or materialized views.</p>
<p>A materialized view often serves as a <a href="glossary.htm#GUID-9C63F1D2-89B7-4AAF-B10F-325A82078B76"><span class="xrefglossterm">master table</span></a> in <a href="glossary.htm#GUID-A011519D-7113-462D-B9A5-9BAC31E50B8D"><span class="xrefglossterm">replication</span></a> and a <a href="glossary.htm#GUID-B6DD258C-FFA5-4CDC-B5FB-98B3B9F20F99"><span class="xrefglossterm">fact table</span></a> in data warehousing.</p>
<p>Materialized views summarize, compute, replicate, and distribute data. They are suitable in various computing environments, such as the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>In data warehouses, materialized views can compute and store data generated from aggregate functions such as sums and averages.</p>
<p>A <a href="glossary.htm#GUID-6952CA8E-DB69-4C4B-887F-9624565B1835"><span class="xrefglossterm">summary</span></a> is an aggregate view that reduces query time by precalculating joins and aggregation operations and storing the results in a table. Materialized views are equivalent to summaries (see <span class="q">&#34;<a href="cmntopc.htm#GUID-8B11C762-AF20-4B7A-A95B-D5423FE7B646" title="In a simple data warehouse architecture, end users directly access data that was transported from several source systems to the data warehouse.">Data Warehouse Architecture (Basic)</a>&#34;</span>). You can also use materialized views to compute joins with or without aggregations. If compatibility is set to Oracle9<span class="italic">i</span> or higher, then queries that include filter selections can use materialized views.</p>
</li>
<li>
<p>In materialized view replication, the view contains a complete or partial copy of a table from a single point in time. Materialized views replicate data at distributed sites and synchronize updates performed at several sites. This form of replication is suitable for environments such as field sales when databases are not always connected to the network.</p>
</li>
<li>
<p>In mobile computing environments, materialized views can download a data subset from central servers to mobile clients, with periodic refreshes from the central servers and propagation of updates by clients to the central servers.</p>
</li>
</ul>
<p>In a replication environment, a materialized view shares data with a table in a different database, called a <a href="glossary.htm#GUID-DC13C5A2-6D35-4169-B546-C8B8AC393163"><span class="xrefglossterm">master database</span></a>. The table associated with the materialized view at the master site is the master table. <a href="schemaob.htm#GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829__CFACFDIG">Figure 4-9</a> illustrates a materialized view in one database based on a master table in another database. Updates to the master table replicate to the materialized view database.</p>
<div class="figure" id="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829__CFACFDIG">
<p class="titleinfigure">Figure 4-9 Materialized View</p>
<img width="371" height="362" src="img/GUID-8935C7D9-A6EA-47DB-BC94-AC23880358D1-default.gif" alt="Description of Figure 4-9 follows" title="Description of Figure 4-9 follows"/><br/>
<a href="img_text/GUID-8935C7D9-A6EA-47DB-BC94-AC23880358D1-print.htm">Description of &#34;Figure 4-9 Materialized View&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829__GUID-00B3BCAB-1185-4782-820B-AF1B8E4E9BD9">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="cmntopc.htm#GUID-1E03C284-42EE-4542-AB79-A966AD7BEA47" title="Oracle GoldenGate is an asynchronous, log-based, real-time data replication product. It moves high volumes of transactional data in real time across heterogeneous database, hardware, and operating system environments with minimal impact.Advanced Queuing stores user messages in abstract storage units called queues. Oracle Database Advanced Queuing (AQ) supports all the standard features of message queuing systems.">Information Sharing</a>&#34;</span> to learn about replication with Oracle Streams</p>
</li>
<li>
<p><a class="olink STREP574" target="_blank" href="../STREP/rep2strm.htm#STREP574"><span class="italic">Oracle Streams Replication Administrator&#39;s Guide</span></a> and <a class="olink REPLN003" target="_blank" href="../REPLN/repmview.htm#REPLN003"><span class="italic">Oracle Database Advanced Replication</span></a> to learn how to use materialized views</p>
</li>
<li>
<p><a class="olink SQLRF01302" target="_blank" href="../SQLRF/statements_6002.htm#SQLRF01302"><span class="italic">Oracle Database SQL Language Reference</span></a> to learn about the <code class="codeph">CREATE MATERIALIZED VIEW</code> statement</p>
</li>
</ul>
</div>
</div>
<a id="CNCPT88875"></a>
<div class="props_rev_3"><a id="GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193"></a>
<h3 id="CNCPT-GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193" class="sect3">Characteristics of Materialized Views</h3>
<div>
<p>Materialized views share some characteristics of indexes and nonmaterialized views.</p>
<p>Materialized views are similar to indexes in the following ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>They contain actual data and consume storage space.</p>
</li>
<li>
<p>They can be refreshed when the data in their master tables changes.</p>
</li>
<li>
<p>They can improve performance of SQL execution when used for query rewrite operations.</p>
</li>
<li>
<p>Their existence is transparent to SQL applications and users.</p>
</li>
</ul>
<p>A materialized view is similar to a nonmaterialized view because it represents data in other tables and views. Unlike indexes, users can query materialized views directly using <code class="codeph">SELECT</code> statements. Depending on the types of refresh that are required, the views can also be updated with DML statements.</p>
<p>The following example creates and populates a materialized aggregate view based on three master tables in the <code class="codeph">sh</code> sample schema:</p>
<pre dir="ltr">CREATE MATERIALIZED VIEW sales_mv AS 
  SELECT t.calendar_year, p.prod_id, SUM(s.amount_sold) AS sum_sales
  FROM   times t, products p, sales s
  WHERE  t.time_id = s.time_id 
  AND    p.prod_id = s.prod_id
  GROUP BY t.calendar_year, p.prod_id;
</pre>
<p>The following example drops table <code class="codeph">sales</code>, which is a master table for <code class="codeph">sales_mv</code>, and then queries <code class="codeph">sales_mv</code>. The query selects data because the rows are stored (materialized) separately from the data in the master tables.</p>
<pre dir="ltr">SQL&gt; DROP TABLE sales;

Table dropped.

SQL&gt; SELECT * FROM sales_mv WHERE ROWNUM &lt; 4;
 
CALENDAR_YEAR    PROD_ID  SUM_SALES
------------- ---------- ----------
         1998         13  936197.53
         1998         26  567533.83
         1998         27  107968.24
</pre>
<p>A materialized view can be partitioned. You can define a materialized view on a partitioned table and one or more indexes on the materialized view.</p>
<div class="infoboxnotealso" id="GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193__GUID-37CC358F-64EF-4BCF-ADAD-AFB8DFA770ED">
<p class="notep1">See Also:</p>
<p><a class="olink DWHSG008" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG008"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn how to use materialized views in a data warehouse</p>
</div>
</div>
</div>
<a id="CNCPT1155"></a>
<div class="props_rev_3"><a id="GUID-824BEF3A-193B-4A72-894A-105F0AEAD607"></a>
<h3 id="CNCPT-GUID-824BEF3A-193B-4A72-894A-105F0AEAD607" class="sect3">Refresh Methods for Materialized Views</h3>
<div>
<p>The database maintains data in materialized views by refreshing them after changes to the base tables. The refresh method can be incremental or a complete refresh.</p>
</div>
<a id="CNCPT89392"></a>
<div class="props_rev_3"><a id="GUID-1975D1E6-EE50-4F4B-881B-C18A42A7DED3"></a>
<h4 id="CNCPT-GUID-1975D1E6-EE50-4F4B-881B-C18A42A7DED3" class="sect4">Complete Refresh</h4>
<div>
<p>A <span class="bold">complete refresh</span> executes the query that defines the materialized view. A complete refresh occurs when you initially create the materialized view, unless the materialized view references a prebuilt table, or you define the table as <code class="codeph">BUILD DEFERRED</code>.</p>
<p>A complete refresh can be slow, especially if the database must read and process huge amounts of data. You can perform a complete refresh at any time after creation of the materialized view.</p>
</div>
</div>
<a id="CNCPT89393"></a>
<div class="props_rev_3"><a id="GUID-956728C1-A1F7-4C4D-9BD5-685F2DD4086F"></a>
<h4 id="CNCPT-GUID-956728C1-A1F7-4C4D-9BD5-685F2DD4086F" class="sect4">Incremental Refresh</h4>
<div>
<p>An <span class="bold">incremental refresh</span>, also called a <span class="italic">fast refresh</span>, processes only the changes to the existing data. This method eliminates the need to rebuild materialized views from the beginning. Processing only the changes can result in a very fast refresh time.</p>
<p>You can refresh materialized views either on demand or at regular time intervals. Alternatively, you can configure materialized views in the same database as their base tables to refresh whenever a transaction commits changes to the base tables.</p>
<p>Fast refresh comes in either of the following forms:</p>
<ul style="list-style-type: disc;">
<li>
<p>Log-Based refresh</p>
<p>In this type of refresh, a materialized view log or a direct loader log keeps a record of changes to the base tables. A materialized view log is a schema object that records changes to a base table so that a materialized view defined on the base table can be refreshed incrementally. Each materialized view log is associated with a single base table.</p>
</li>
<li>
<p>Partition change tracking (PCT) refresh</p>
<p>PCT refresh is valid only when the base tables are partitioned. PCT refresh removes all data in the affected materialized view partitions or affected portions of data, and then recomputes them. The database uses the modified base table partitions to identify the affected partitions or portions of data in the view. When partition maintenance operations have occurred on the base tables, PCT refresh is the only usable incremental refresh method.</p>
</li>
</ul>
</div>
</div>
<a id="CNCPT89394"></a>
<div class="props_rev_3"><a id="GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC"></a>
<h4 id="CNCPT-GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC" class="sect4">In-Place and Out-of-Place Refresh</h4>
<div>
<p>For the complete and incremental methods, the database can refresh the materialized view in place, which refreshes statements directly on the view, or out of place.</p>
<p>An out-of-place refresh creates one or more outside tables, executes the refresh statements on them, and then switches the materialized view or affected partitions with the outside tables. This technique achieves high availability during refresh, especially when refresh statements take a long time to finish.</p>
<p>Oracle Database 12<span class="italic">c</span> introduces synchronous refresh, which is a type of out-of-place refresh. A synchronous refresh does not modify the contents of the base tables, but instead uses the APIs in the synchronous refresh package, which ensures consistency by applying these changes to the base tables and materialized views at the same time. This approach enables a set of tables and the materialized views defined on them to be always synchronized. In a data warehouse, synchronous refresh method is well-suited for the following reasons:</p>
<ul style="list-style-type: disc;">
<li>
<p>The loading of incremental data is tightly controlled and occurs at periodic intervals.</p>
</li>
<li>
<p>Tables and their materialized views are often partitioned in the same way, or their partitions are related by a functional dependency.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC__GUID-8B615BF7-7A10-4E97-8B09-04CBBD4659EE">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink DWHSG03003" target="_blank" href="../DWHSG/refresh.htm#DWHSG03003"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a>to learn how to refresh materialized views</p>
</li>
<li>
<p><a class="olink REPLN107" target="_blank" href="../REPLN/repmview.htm#REPLN107"><span><cite>Oracle Database Advanced Replication</cite></span></a>to learn about materialized view logs</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="CNCPT88877"></a><a id="CNCPT88876"></a>
<div class="props_rev_3"><a id="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62"></a>
<h3 id="CNCPT-GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62" class="sect3">Query Rewrite</h3>
<div>
<p>An optimization technique known as <span class="bold">query rewrite</span> transforms a user request written in terms of master tables into a semantically equivalent request that includes materialized views.</p>
<p>When base tables contain large amounts of data, computing an aggregate or join is expensive and time-consuming. Because materialized views contain precomputed aggregates and joins, query rewrite can quickly answer queries using materialized views.</p>
<p>The <a href="glossary.htm#GUID-648CCA52-2DB0-405D-9737-B7CB9B8E7CBC"><span class="xrefglossterm">query transformer</span></a> transparently rewrites the request to use the materialized view, requiring no user intervention and no reference to the materialized view in the SQL statement. Because query rewrite is transparent, materialized views can be added or dropped without invalidating the SQL in the application code.</p>
<p>In general, rewriting queries to use materialized views rather than detail tables improves response time. The following figure shows the database generating an <a href="glossary.htm#GUID-2DF33B85-94BB-44F3-93B7-06916FB18361"><span class="xrefglossterm">execution plan</span></a> for the original and rewritten query and choosing the lowest-cost plan.</p>
<div class="figure" id="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62__CFABICCA">
<p class="titleinfigure">Figure 4-10 Query Rewrite</p>
<img width="593" height="300" src="img/GUID-EC5CC76D-B390-4733-A451-675AD63549A5-default.gif" alt="Description of Figure 4-10 follows" title="Description of Figure 4-10 follows"/><br/>
<a href="img_text/GUID-EC5CC76D-B390-4733-A451-675AD63549A5-print.htm">Description of &#34;Figure 4-10 Query Rewrite&#34;</a></div>
<!-- class="figure" -->
<div class="infoboxnotealso" id="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62__GUID-9D58C628-DD88-43B6-889E-1631F9CD099F">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="sqllangu.htm#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="To understand how Oracle Database processes SQL statements, it is necessary to understand the part of the database called the optimizer (also known as the query optimizer or cost-based optimizer). All SQL statements use the optimizer to determine the most efficient means of accessing the specified data.">Overview of the Optimizer</a>&#34;</span></p>
</li>
<li>
<p><a class="olink DWHSG018" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG018"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> to learn how to use query rewrite</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="CNCPT611"></a>
<div class="props_rev_3"><a id="GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B"></a>
<h2 id="CNCPT-GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B" class="sect2">Overview of Sequences</h2>
<div>
<p>A <span class="bold">sequence</span> is a schema object from which multiple users can generate unique integers. A sequence generator provides a highly scalable and well-performing method to generate surrogate keys for a number data type.</p>
</div>
<a id="CNCPT88878"></a>
<div class="props_rev_3"><a id="GUID-F485DFE7-DA07-4943-9844-C97D31064EED"></a>
<h3 id="CNCPT-GUID-F485DFE7-DA07-4943-9844-C97D31064EED" class="sect3">Sequence Characteristics</h3>
<div>
<p>A sequence definition indicates general information about the sequence, including its name and whether the sequence ascends or descends.</p>
<p>A sequence definition also indicates:</p>
<ul style="list-style-type: disc;">
<li>
<p>The interval between numbers</p>
</li>
<li>
<p>Whether the database should cache sets of generated sequence numbers in memory</p>
</li>
<li>
<p>Whether the sequence should cycle when a limit is reached</p>
</li>
</ul>
<p>The following example creates the sequence <code class="codeph">customers_seq</code> in the sample schema <code class="codeph">oe</code>. An application could use this sequence to provide customer ID numbers when rows are added to the <code class="codeph">customers</code> table.</p>
<pre dir="ltr">CREATE SEQUENCE customers_seq
START WITH      1000
INCREMENT BY    1
NOCACHE
NOCYCLE;
</pre>
<p>The first reference to <code class="codeph">customers_seq.nextval</code> returns <code class="codeph">1000</code>. The second returns <code class="codeph">1001</code>. Each subsequent reference returns a value 1 greater than the previous reference.</p>
<div class="infoboxnotealso" id="GUID-F485DFE7-DA07-4943-9844-C97D31064EED__GUID-26613A8B-F33C-470A-822E-E5BE33328734">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink TDDDG34000" target="_blank" href="../TDDDG/tdddg_objects.htm#TDDDG34000"><span class="italic">Oracle Database 2 Day Developer&#39;s Guide</span></a> and <a class="olink ADMIN11796" target="_blank" href="../ADMIN/views.htm#ADMIN11796"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to manage sequences</p>
</li>
<li>
<p><a class="olink SQLRF01314" target="_blank" href="../SQLRF/statements_6017.htm#SQLRF01314"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code class="codeph">CREATE SEQUENCE</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
</div>
<a id="CNCPT88879"></a>
<div class="props_rev_3"><a id="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65"></a>
<h3 id="CNCPT-GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65" class="sect3">Concurrent Access to Sequences</h3>
<div>
<p>The same sequence generator can generate numbers for multiple tables. In this way, the database can generate primary keys automatically and coordinate keys across multiple rows or tables. For example, a sequence can generate primary keys for an <code class="codeph">orders</code> table and a <code class="codeph">customers</code> table.</p>
<p>The sequence generator is useful in multiuser environments for generating unique numbers without the overhead of disk I/O or transaction locking. For example, two users simultaneously insert new rows into the <code class="codeph">orders</code> table. By using a sequence to generate unique numbers for the <code class="codeph">order_id</code> column, neither user has to wait for the other to enter the next available order number. The sequence automatically generates the correct values for each user.</p>
<p>Each user that references a sequence has access to his or her current sequence number, which is the last sequence generated in the <a href="glossary.htm#GUID-0F44C072-9841-4E2E-B846-FB16A2E54139"><span class="xrefglossterm">session</span></a>. A user can issue a statement to generate a new sequence number or use the current number last generated by the session. After a statement in a session generates a sequence number, it is available only to this session. Individual sequence numbers can be skipped if they were generated and used in a transaction that was ultimately rolled back.</p>
<div class="infoboxnotewarn" id="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65__GUID-99A0F55F-E395-4BCA-A175-3A03407A1CAC">
<p class="notep1">WARNING:</p>
<p>If your application requires a gap-free set of numbers, then you cannot use Oracle sequences. You must serialize activities in the database using your own developed code.</p>
</div>
<div class="infoboxnotealso" id="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65__GUID-5AB1218F-539E-494A-A189-1F337C191888">
<p class="notep1">See Also:</p>
<p><a href="consist.htm#GUID-E8CBA9C5-58E3-460F-A82A-850E0152E95C" title="In a single-user database, a user can modify data without concern for other users modifying the same data at the same time. However, in a multiuser database, statements within multiple simultaneous transactions may update the same data. Transactions executing simultaneously must produce meaningful and consistent results. In Oracle Database, multiversioning is the ability to simultaneously materialize multiple versions of data. Oracle Database maintains multiversion read consistency.To manage the multiversion read consistency model, the database must create a read-consistent set of data when a table is simultaneously queried and updated.This example shows a query that uses undo data to provide statement-level read consistency in the read committed isolation level.The SQL standard, which has been adopted by both ANSI and ISO/IEC, defines four levels of transaction isolation. These levels have differing degrees of impact on transaction processing throughput.In a read committed transaction, a conflicting write occurs when the transaction attempts to change a row updated by an uncommitted concurrent transaction, sometimes called a blocking transaction. The read committed transaction waits for the blocking transaction to end and release its row lock.In the serializable isolation level, a transaction sees only changes committed at the time the transaction&mdash;not the query&mdash;began and changes made by the transaction itself. A serializable transaction operates in an environment that makes it appear as if no other users were modifying data in the database.The database maintains several different types of locks, depending on the operation that acquired the lock.In a single-user database, locks are not necessary because only one user is modifying information. However, when multiple users are accessing and modifying data, the database must provide a way to prevent concurrent modification of the same data.A deadlock is a situation in which two or more users are waiting for data locked by each other. Deadlocks prevent some transactions from continuing to work.Oracle Database automatically locks a resource on behalf of a transaction to prevent other transactions from doing something that requires exclusive access to the same resource. The database automatically acquires different types of locks at different levels of restrictiveness depending on the resource and the operation being performed.A row lock, also called a TX lock, is a lock on a single row of table. A transaction acquires a row lock for each row modified by an INSERT, UPDATE, DELETE, MERGE, or SELECT ... FOR UPDATE statement. The row lock exists until the transaction commits or rolls back.This scenario illustrates how Oracle Database uses row locks for concurrency. Oracle Database maximizes the concurrency control of parent keys in relation to dependent foreign keys.The database acquires a full table lock on the child table when no index exists on the foreign key column of the child table, and a session modifies a primary key in the parent table (for example, deletes a row or modifies primary key attributes) or merges rows into the parent table.The database does not acquire a full table lock on the child table when a foreign key column in the child table is indexed, and a session modifies a primary key in the parent table (for example, deletes a row or modifies primary key attributes) or merges rows into the parent table.Oracle Database uses various types of system locks to protect internal database and memory structures. These mechanisms are inaccessible to users because users have no control over their occurrence or duration.A latch is a simple, low-level serialization mechanism that coordinates multiuser access to shared data structures, objects, and files.A mutual exclusion object (mutex) is a low-level mechanism that prevents an object in memory from aging out or from being corrupted when accessed by concurrent processes. A mutex is similar to a latch, but whereas a latch typically protects a group of objects, a mutex protects a single object.Internal locks are higher-level, more complex mechanisms than latches and mutexes and serve various purposes.">Data Concurrency and Consistency</a></p>
</div>
</div>
</div>
</div>
<a id="CNCPT511"></a>
<div class="props_rev_3"><a id="GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2"></a>
<h2 id="CNCPT-GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2" class="sect2">Overview of Dimensions</h2>
<div>
<p>A typical data warehouse has two important components: dimensions and facts. A <span class="bold">dimension</span> is any category used in specifying business questions, for example, time, geography, product, department, and distribution channel. A <span class="bold">fact</span> is an event or entity associated with a particular set of dimension values, for example, units sold or profits.</p>
<p>Examples of multidimensional requests include the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Show total sales across all products at increasing aggregation levels for a geography dimension, from state to country to region, for 2013 and 2014.</p>
</li>
<li>
<p>Create a cross-tabular analysis of our operations showing expenses by territory in South America for 2013 and 2014. Include all possible subtotals.</p>
</li>
<li>
<p>List the top 10 sales representatives in Asia according to 2014 sales revenue for automotive products, and rank their commissions.</p>
</li>
</ul>
<p>Many multidimensional questions require aggregated data and comparisons of data sets, often across time, geography or budgets.</p>
<p>Creating a dimension permits the broader use of the query rewrite feature. By transparently rewriting queries to use materialized views, the database can improve query performance.</p>
<div class="infoboxnotealso" id="GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2__GUID-AAC63A16-C1F3-424D-9D09-5AF520FD0414">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="cmntopc.htm#GUID-E1451108-464E-4B5F-B173-11212278E308" title="Data warehouses and their architectures vary depending on the business requirements.In a simple data warehouse architecture, end users directly access data that was transported from several source systems to the data warehouse.Some data warehouses use a staging area, which is a place where data is preprocessed before entering the warehouse. A staging area simplifies the tasks of building summaries and managing the warehouse.You may want to customize your warehouse architecture for different groups within your organization. You can achieve this goal by transporting data in the warehouse to data marts, which are independent databases designed for a specific business or project. Typically, data marts include many summary tables.The process of extracting data from source systems and bringing it into the warehouse is commonly called ETL: extraction, transformation, and loading. ETL refers to a broad process rather than three well-defined steps. Oracle Database has introduced many SQL operations for performing analytic operations. These operations include ranking, moving averages, cumulative sums, ratio-to-reports, and period-over-period comparisons.Oracle online analytical processing (OLAP) provides native multidimensional storage and rapid response times when analyzing data across multiple dimensions. OLAP enables analysts to quickly obtain answers to complex, iterative queries during interactive sessions.">Overview of Data Warehousing and Business Intelligence</a>&#34;</span></p>
</div>
</div>
<a id="CNCPT88880"></a>
<div class="props_rev_3"><a id="GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C"></a>
<h3 id="CNCPT-GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C" class="sect3">Hierarchical Structure of a Dimension</h3>
<div>
<p>A <span class="bold">dimension table</span> is a logical structure that defines hierarchical (parent/child) relationships between pairs of columns or column sets. For example, a dimension can indicate that within a row the <code class="codeph">city</code> column implies the value of the <code class="codeph">state</code> column, the <code class="codeph">state</code> column implies the value of the <code class="codeph">country</code> column, and so on.</p>
<p>Within a customer dimension, customers could roll up to city, state, country, subregion, and region. Data analysis typically starts at higher levels in the dimensional hierarchy and gradually drills down if the situation warrants such analysis.</p>
<p>Each value at the child level is associated with one and only one value at the parent level. A hierarchical relationship is a functional dependency from one level of a hierarchy to the next level in the hierarchy.</p>
<p>A dimension has no data storage assigned to it. Dimensional information is stored in dimension tables, whereas fact information is stored in a fact table.</p>
<div class="infoboxnotealso" id="GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C__GUID-C26CCE50-EDA0-4E1C-B691-6B6E232A5E83">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink DWHSG010" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=DWHSG010"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn about dimensions</p>
</li>
<li>
<p><a class="olink OLAUG300" target="_blank" href="../OLAUG/cubes.htm#OLAUG300"><span class="italic">Oracle OLAP User&#39;s Guide</span></a> to learn how to create dimensions</p>
</li>
</ul>
</div>
</div>
</div>
<a id="CNCPT88881"></a>
<div class="props_rev_3"><a id="GUID-62DD0306-D019-4B21-AA81-17670CB44DDA"></a>
<h3 id="CNCPT-GUID-62DD0306-D019-4B21-AA81-17670CB44DDA" class="sect3">Creation of Dimensions</h3>
<div>
<p>You create dimensions with the <code class="codeph">CREATE DIMENSION</code> SQL statement.</p>
<p>This statement specifies:</p>
<ul style="list-style-type: disc;">
<li>
<p>Multiple <code class="codeph">LEVEL</code> clauses, each of which identifies a column or column set in the dimension</p>
</li>
<li>
<p>One or more <code class="codeph">HIERARCHY</code> clauses that specify the parent/child relationships between adjacent levels</p>
</li>
<li>
<p>Optional <code class="codeph">ATTRIBUTE</code> clauses, each of which identifies an additional column or column set associated with an individual level</p>
</li>
</ul>
<p>The following statement was used to create the <code class="codeph">customers_dim</code> dimension in the sample schema <code class="codeph">sh</code>:</p>
<pre dir="ltr">CREATE DIMENSION customers_dim 
   LEVEL customer   IS (customers.cust_id)
   LEVEL city       IS (customers.cust_city) 
   LEVEL state      IS (customers.cust_state_province) 
   LEVEL country    IS (countries.country_id) 
   LEVEL subregion  IS (countries.country_subregion) 
   LEVEL region     IS (countries.country_region) 
   HIERARCHY geog_rollup (
      customer      CHILD OF
      city          CHILD OF 
      state         CHILD OF 
      country       CHILD OF 
      subregion     CHILD OF 
      region 
   JOIN KEY (customers.country_id) REFERENCES country )
   ATTRIBUTE customer DETERMINES
   (cust_first_name, cust_last_name, cust_gender, 
    cust_marital_status, cust_year_of_birth, 
    cust_income_level, cust_credit_limit) 
   ATTRIBUTE country DETERMINES (countries.country_name);
</pre>
<p>The columns in a dimension can come either from the same table (denormalized) or from multiple tables (fully or partially normalized). For example, a normalized time dimension can include a date table, a month table, and a year table, with join conditions that connect each date row to a month row, and each month row to a year row. In a fully denormalized time dimension, the date, month, and year columns are in the same table. Whether normalized or denormalized, the hierarchical relationships among the columns must be specified in the <code class="codeph">CREATE DIMENSION</code> statement.</p>
<div class="infoboxnotealso" id="GUID-62DD0306-D019-4B21-AA81-17670CB44DDA__GUID-E30202F0-1006-4254-A07F-12A9A49BC9AE">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF01206" target="_blank" href="../SQLRF/statements_5007.htm#SQLRF01206"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for <code class="codeph">CREATE DIMENSION</code> syntax and semantics</p>
</div>
</div>
</div>
</div>
<a id="CNCPT88882"></a><a id="CNCPT88883"></a><a id="CNCPT711"></a>
<div class="props_rev_3"><a id="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2"></a>
<h2 id="CNCPT-GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2" class="sect2">Overview of Synonyms</h2>
<div>
<p>A <span class="bold">synonym</span> is an alias for a schema object. For example, you can create a synonym for a table or view, sequence, PL/SQL program unit, user-defined object type, or another synonym. Because a synonym is simply an alias, it requires no storage other than its definition in the data dictionary.</p>
<p>Synonyms can simplify SQL statements for database users. Synonyms are also useful for hiding the identity and location of an underlying schema object. If the underlying object must be renamed or moved, then only the synonym must be redefined. Applications based on the synonym continue to work without modification.</p>
<p>You can create both private and public synonyms. A private synonym is in the schema of a specific user who has control over its availability to others. A public synonym is owned by the user group named <code class="codeph">PUBLIC</code> and is accessible by every database user.</p>
<div class="example" id="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2__GUID-B139ADF2-8005-4FA1-B503-052F39700285">
<p class="titleinexample">Example 4-2 Public Synonym</p>
<p>Suppose that a database administrator creates a public synonym named <code class="codeph">people</code> for the <code class="codeph">hr.employees</code> table. The user then connects to the <code class="codeph">oe</code> schema and counts the number of rows in the table referenced by the synonym.</p>
<pre dir="ltr">SQL&gt; CREATE PUBLIC SYNONYM people FOR hr.employees;
 
Synonym created.
 
SQL&gt; CONNECT oe
Enter password: <span class="italic">password</span>
Connected.

SQL&gt; SELECT COUNT(*) FROM people;

  COUNT(*)
----------
       107
</pre>
<p>Use public synonyms sparingly because they make database consolidation more difficult. As shown in the following example, if another administrator attempts to create the public synonym <code class="codeph">people</code>, then the creation fails because only one public synonym <code class="codeph">people</code> can exist in the database. Overuse of public synonyms causes namespace conflicts between applications.</p>
<pre dir="ltr">SQL&gt; CREATE PUBLIC SYNONYM people FOR oe.customers;
CREATE PUBLIC SYNONYM people FOR oe.customers
                      *
ERROR at line 1:
ORA-00955: name is already used by an existing object

SQL&gt; SELECT OWNER, SYNONYM_NAME, TABLE_OWNER, TABLE_NAME 
  2  FROM DBA_SYNONYMS 
  3  WHERE SYNONYM_NAME = &#39;PEOPLE&#39;;
 
OWNER      SYNONYM_NAME TABLE_OWNER TABLE_NAME
---------- ------------ ----------- ----------
PUBLIC     PEOPLE       HR          EMPLOYEES
</pre>
<p>Synonyms themselves are not securable. When you grant object privileges on a synonym, you are really granting privileges on the underlying object. The synonym is acting only as an alias for the object in the <code class="codeph">GRANT</code> statement.</p>
<div class="infoboxnotealso" id="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2__GUID-02F272D0-B29B-49AA-8A14-09A1BE53EC9E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADMIN11805" target="_blank" href="../ADMIN/views.htm#ADMIN11805"><span class="italic">Oracle Database Administrator&#39;s Guide</span></a> to learn how to manage synonyms</p>
</li>
<li>
<p><a class="olink SQLRF01401" target="_blank" href="../SQLRF/statements_7001.htm#SQLRF01401"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code class="codeph">CREATE SYNONYM</code> syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="example" --></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1196">
<tr>
<td class="cellalignment1203">
<table class="cellalignment1201">
<tr>
<td class="cellalignment1200"><a href="indexiot.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1200"><a href="datainte.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1205">
<table class="cellalignment1199">
<tr>
<td class="cellalignment1200"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1200"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1200"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1200"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1200"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1200"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>