<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-960"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Introduction%20to%20Oracle%20Database%20Advanced%20Queuing"></a><title>Introduction to Oracle Database Advanced Queuing</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-07-01T0:30:45Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Advanced Queuing User&#39;s Guide"/>
<meta name="dcterms.identifier" content="E17945-14"/>
<meta name="dcterms.isVersionOf" content="ADQUE"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="release_change.htm" title="Previous" type="text/html"/>
<link rel="Next" href="componet.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E17945-14.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/34</span> <!-- End Header -->
<div id="ADQUE0100" class="chapter"><a id="g1019446"></a> <a id="i1005550"></a>
<h1 class="chapter"><span class="secnum">1</span> Introduction to Oracle Database Advanced Queuing</h1>
<p>This chapter discusses Oracle Database Advanced Queuing (AQ) and the requirements for complex information handling in an integrated environment.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDFJEFA">What Is Queuing?</a></p>
</li>
<li>
<p><a href="#i1008588">Oracle Database Advanced Queuing Leverages Oracle Database</a></p>
</li>
<li>
<p><a href="#i1008590">Oracle Database Advanced Queuing in Integrated Application Environments</a></p>
</li>
<li>
<p><a href="#CHDGDCDA">Buffered Messaging</a></p>
</li>
<li>
<p><a href="#CHDFIFFJ">Asynchronous Notifications</a></p>
</li>
<li>
<p><a href="#CHDJDBCE">Enqueue Features</a></p>
</li>
<li>
<p><a href="#CHDJGIJG">Dequeue Features</a></p>
</li>
<li>
<p><a href="#CHDCEFBD">Propagation Features</a></p>
</li>
<li>
<p><a href="#i1010261">Message Format Transformation</a></p>
</li>
<li>
<p><a href="#CHDJCFBI">Other Oracle Database Advanced Queuing Features</a></p>
</li>
<li>
<p><a href="#i1009241">Interfaces to Oracle Database Advanced Queuing</a></p>
</li>
<li>
<p><a href="#i1006541">Oracle Database Advanced Queuing Demonstrations</a></p>
</li>
</ul>
<a id="CHDFJEFA"></a>
<div id="ADQUE2418" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref13"></a>What Is Queuing?</h2>
<p>When Web-based business applications communicate with each other, <a href="glossary.htm#CBAJDCHC"><span class="xrefglossterm">producer</span></a> applications <a href="glossary.htm#CBAJCGCH"><span class="xrefglossterm">enqueue</span></a> messages and <a href="glossary.htm#CBAJDFJA"><span class="xrefglossterm">consumer</span></a> applications <a href="glossary.htm#CBAGEGIF"><span class="xrefglossterm">dequeue</span></a> messages. At the most basic level of queuing, one producer enqueues one or more messages into one <a href="glossary.htm#CBAHIIAB"><span class="xrefglossterm">queue</span></a>. Each <a href="glossary.htm#CBACDHGB"><span class="xrefglossterm">message</span></a> is dequeued and processed once by one of the consumers. A message stays in the queue until a consumer dequeues it or the message expires. A producer can stipulate a delay before the message is available to be consumed, and a time after which the message expires. Likewise, a consumer can wait when trying to dequeue a message if no message were available. An agent program or application could act as both a producer and a consumer.</p>
<p>Producers can enqueue messages in any sequence. Messages are not necessarily dequeued in the order in which they are enqueued. Messages can be enqueued without being dequeued.</p>
<p>At a slightly higher level of complexity, many producers enqueue messages into a queue, all of which are processed by one consumer. Or many producers enqueue messages, each message being processed by a different consumer depending on type and correlation identifier.</p>
<p>Enqueued messages are said to be propagated when they are reproduced on another queue, which can be in the same database or in a remote database.</p>
<p>Applications often use data in different formats. A <a href="glossary.htm#BGBCCBIF">transformation</a> defines a mapping from one data type to another. The transformation is represented by a SQL function that takes the source data type as input and returns an object of the target data type. You can arrange transformations to occur when a message is enqueued, when it is dequeued, or when it is propagated to a remote <a href="glossary.htm#i432798">subscriber</a>.</p>
</div>
<!-- class="sect1" -->
<a id="i1008588"></a>
<div id="ADQUE2419" class="sect1">
<h2 class="sect1"><a id="sthref14"></a>Oracle Database Advanced Queuing Leverages Oracle Database</h2>
<p>Oracle Database Advanced Queuing provides database-integrated message queuing functionality. It is built on top of Oracle Streams and leverages the functions of Oracle Database so that messages can be stored persistently, propagated between queues on different computers and databases, and transmitted using Oracle Net Services and HTTP(S).</p>
<p>Because Oracle Database Advanced Queuing is implemented in database tables, all operational benefits of high availability, scalability, and reliability are also applicable to queue data. Standard database features such as recovery, restart, and security are supported by Oracle Database Advanced Queuing. You can use database development and management tools such as Oracle Enterprise Manager to monitor queues. Like other database tables, queue tables can be imported and exported.</p>
<p>Messages can be queried using standard SQL. This means that you can use SQL to access the message properties, the message history, and the payload. With SQL access you can also audit and track messages. All available SQL technology, such as indexes, can be used to optimize access to messages.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Database Advanced Queuing does not support <a href="glossary.htm#CBADHEBI"><span class="xrefglossterm">data manipulation language</span></a> (DML) operations on a queue table or an associated <a href="glossary.htm#CBAFGGGG"><span class="xrefglossterm">index-organized table</span></a> (IOT), if any. The only supported means of modifying queue tables is through the supplied APIs. Queue tables and IOTs can become inconsistent and therefore effectively ruined, if DML operations are performed on them.</div>
<p class="subhead1"><a id="ADQUE2420"></a><a id="sthref15"></a>System-Level Access Control</p>
<p>Oracle Database Advanced Queuing supports system-level access control for all queuing operations, allowing an application developer or DBA to designate users as queue administrators. A queue administrator can invoke Oracle Database Advanced Queuing administrative and operational interfaces on any queue in the database. This simplifies administrative work because all administrative scripts for the queues in a database can be managed under one schema.</p>
<p class="subhead1"><a id="ADQUE2421"></a><a id="sthref16"></a>Queue-Level Access Control</p>
<p>Oracle Database Advanced Queuing supports queue-level access control for enqueue and dequeue operations. This feature allows the application developer to protect queues created in one schema from applications running in other schemas. The application developer can grant only minimal access privileges to applications that run outside the queue schema.</p>
<p class="subhead1"><a id="ADQUE2422"></a><a id="sthref17"></a>Performance</p>
<p>Requests for service must be separated from the supply of services to increase efficiency and enable complex scheduling. Oracle Database Advanced Queuing exhibits high performance as measured by:</p>
<ul>
<li>
<p>Number of messages enqueued and dequeued each second</p>
</li>
<li>
<p>Time to evaluate a complex query on a message warehouse</p>
</li>
<li>
<p>Time to recover and restart the messaging process after a failure</p>
</li>
</ul>
<p class="subhead1"><a id="ADQUE2423"></a><a id="sthref18"></a>Scalability</p>
<p>Queuing systems must be scalable. Oracle Database Advanced Queuing exhibits high performance when the number of programs using the application increases, when the number of messages increases, and when the size of the message warehouse increases.</p>
<p class="subhead1"><a id="ADQUE2424"></a><a id="sthref19"></a><a id="sthref20"></a>Persistence for Security</p>
<p>Messages that constitute requests for service must be stored persistently and processed exactly once for deferred execution to work correctly in the presence of network, computer, and application failures. Oracle Database Advanced Queuing can meet requirements in the following situations:</p>
<ul>
<li>
<p>Applications do not have the resources to handle multiple unprocessed messages arriving simultaneously from external clients or from programs internal to the application.</p>
</li>
<li>
<p>Communication links between databases are not available all the time or are reserved for other purposes. If the system falls short in its capacity to deal with these messages immediately, then the application must be able to store the messages until they can be processed.</p>
</li>
<li>
<p>External clients or internal programs are not ready to receive messages that have been processed.</p>
</li>
</ul>
<p class="subhead1"><a id="ADQUE2425"></a><a id="sthref21"></a>Persistence for Scheduling</p>
<p>Queuing systems must deal with priorities, and those priorities can change:</p>
<ul>
<li>
<p>Messages arriving later can be of higher priority than messages arriving earlier.</p>
</li>
<li>
<p>Messages may wait for later messages before actions are taken.</p>
</li>
<li>
<p>The same message may be accessed by different processes.</p>
</li>
<li>
<p>Messages in a specific queue can become more important, and so must be processed with less delay or interference from messages in other queues.</p>
</li>
<li>
<p>Messages sent to some destinations can have a higher priority than others.</p>
</li>
</ul>
<p class="subhead1"><a id="ADQUE2426"></a><a id="sthref22"></a>Persistence for Accessing and Analyzing Metadata</p>
<p>Queuing systems must preserve message metadata, which can be as important as the payload data. For example, the time that a message is received or dispatched can be crucial for business and legal reasons. With the persistence features of Oracle Database Advanced Queuing, you can analyze periods of greatest demand or evaluate the lag between receiving and completing an order.</p>
<p class="subhead1"><a id="CHDEADFG"></a><a id="ADQUE2427"></a><a id="sthref23"></a><a id="sthref24"></a><a id="sthref25"></a>Object Type Support</p>
<p>Oracle Database Advanced Queuing supports enqueue, dequeue, and propagation operations where the queue type is an abstract datatype, <a href="glossary.htm#i432184">ADT</a>. It also supports enqueue and dequeue operations if the types are inherited types of a base ADT. Propagation between two queues where the types are inherited from a base ADT is not supported.</p>
<p>Oracle Database Advanced Queuing also supports <code>ANYDATA</code> queues, which enable applications to enqueue different message types in a single queue. Oracle Database Advanced Queuing supports the <code>LONG VARCHAR</code> data type from 12c Release 1 (12.1) onwards.</p>
<p>If you plan to enqueue, propagate, or dequeue user-defined type messages, then each type used in these messages must exist at every database where the message can be enqueued in a queue. Some environments use directed networks to route messages through intermediate databases before they reach their destination. In such environments, the type must exist at each intermediate database, even if the messages of this type are never enqueued or dequeued at a particular intermediate database.</p>
<p>In addition, the following requirements must be met for such types:</p>
<ul>
<li>
<p>Type name must be the same at each database.</p>
</li>
<li>
<p>Type must be in the same schema at each database.</p>
</li>
<li>
<p>Shape of the type must match exactly at each database.</p>
</li>
<li>
<p>Type cannot use inheritance or type evolution at any database.</p>
</li>
<li>
<p>Type cannot contain varrays, nested tables, LOBs, rowids, or urowids.</p>
</li>
</ul>
<p>The object identifier need not match at each database.</p>
<p class="subhead1"><a id="CHDGJDEI"></a><a id="ADQUE2428"></a><a id="sthref26"></a><a id="sthref27"></a><a id="sthref28"></a><a id="sthref29"></a>Structured and XMLType Payloads</p>
<p>You can use object types to structure and manage message payloads. Relational database systems in general have a richer typing system than messaging systems. Because Oracle Database is an object-relational database system, it supports traditional relational and user-defined types. Many powerful features are enabled because of having strongly typed content, such as content whose format is defined by an external type system. These include:</p>
<ul>
<li>
<p>Content-based routing</p>
<p>Oracle Database Advanced Queuing can examine the content and automatically route the message to another queue based on the content.</p>
</li>
<li>
<p>Content-based subscription</p>
<p>A publish and subscribe system is built on top of a messaging system so that you can create subscriptions based on content.</p>
</li>
<li>
<p>Querying</p>
<p>The ability to run queries on the content of the message enables message warehousing.</p>
</li>
</ul>
<p>You can create queues that use the new opaque type, <code>XMLType.</code> These queues can be used to transmit and store messages that are XML documents. Using <code>XMLType</code>, you can do the following:</p>
<ul>
<li>
<p>Store any type of message in a queue</p>
</li>
<li>
<p>Store <code>m</code>ore than one type of payload in a queue</p>
</li>
<li>
<p>Query XMLType columns using the operator <code>ExistsNode()</code></p>
</li>
<li>
<p>Specify the operators in subscriber rules or dequeue conditions</p>
</li>
</ul>
<p class="subhead1"><a id="ADQUE2429"></a><a id="sthref30"></a>Integration with Oracle Internet Directory</p>
<p>You can register system events, user events, and notifications on queues with Oracle Internet Directory. System events are database startup, database shutdown, and system error events. User events include user log on and user log off, DDL statements (create, drop, alter), and <a href="glossary.htm#CBAICGCD"><span class="xrefglossterm">DML</span></a> statement triggers. Notifications on queues include OCI notifications, PL/SQL notifications, and e-mail notifications.</p>
<p>You can also create aliases for Oracle Database Advanced Queuing agents in Oracle Internet Directory. These aliases can be specified while performing Oracle Database Advanced Queuing enqueue, dequeue, and notification operations. This is useful when you do not want to expose an internal agent name.</p>
<p class="subhead1"><a id="CHDIJAIJ"></a><a id="ADQUE2430"></a><a id="sthref31"></a>Support for Oracle Real Application Clusters(Oracle RAC)</p>
<p>Oracle Real Application Clusters can be used to improve Oracle Database Advanced Queuing performance by allowing different queues to be managed by different instances. You do this by specifying different instance affinities (preferences) for the queue tables that store the queues. This allows queue operations (enqueue and dequeue) on different queues to occur in parallel.</p>
<p><a id="sthref32"></a>If compatibility is set to Oracle8<span class="italic">i</span> release 8.1.5 or higher, then an application can specify the instance affinity for a queue table. When Oracle Database Advanced Queuing is used with Oracle RAC and multiple instances, this information is used to partition the queue tables between instances for queue-monitor scheduling and, also for propagation. The queue table is monitored by the queue monitors of the instance specified by the user. If the owner of the queue table is terminated, then the secondary instance or some available instance takes over the ownership for the queue table.</p>
<p>If an instance affinity is not specified, then the queue tables are arbitrarily partitioned among the available instances. This can result in pinging between the application accessing the queue table and the queue monitor monitoring it. Specifying the instance affinity prevents this, but does not prevent the application from accessing the queue table and its queues from other instances.</p>
</div>
<!-- class="sect1" -->
<a id="i1008590"></a>
<div id="ADQUE2431" class="sect1">
<h2 class="sect1"><a id="sthref33"></a><a id="sthref34"></a>Oracle Database Advanced Queuing in Integrated Application Environments</h2>
<p>Oracle Database Advanced Queuing provides the message management and communication needed for application integration. In an integrated environment, messages travel between the Oracle Database server, applications, and users, as shown in <a href="#i1008337">Figure 1-1</a>.</p>
<p><a id="sthref35"></a><a id="sthref36"></a>Messages are exchanged between a client and the Oracle Database server or between two Oracle Database servers using Oracle Net Services. Oracle Net Services also propagates messages from one Oracle Database queue to another. Or, as shown in <a href="#i1008337">Figure 1-1</a>, you can perform Oracle Database Advanced Queuing operations over the Internet using HTTP(S). In this case, the client, a user or Internet application, produces structured XML messages. During <a href="glossary.htm#CBADIFJC"><span class="xrefglossterm">propagation</span></a> over the Internet, Oracle Database servers communicate using structured XML also.</p>
<p><a id="sthref37"></a><a id="sthref38"></a>Application integration also involves the integration of heterogeneous messaging systems. Oracle Database Advanced Queuing seamlessly integrates with existing non-Oracle Database messaging systems like IBM WebSphere MQ through Messaging Gateway, thus allowing existing WebSphere MQ-based applications to be integrated into an Oracle Database Advanced Queuing environment.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#CHDJHJHF">Oracle Database Advanced Queuing Client/Server Communication</a></p>
</li>
<li>
<p><a href="#CHDGGIEH">Multiconsumer Dequeuing of the Same Message</a></p>
</li>
<li>
<p><a href="#CHDFIFGC">Oracle Database Advanced Queuing Implementation of Workflows</a></p>
</li>
<li>
<p><a href="#CHDGJGAH">Oracle Database Advanced Queuing Implementation of Publish/Subscribe</a></p>
</li>
</ul>
<div id="ADQUE2432" class="figure">
<p class="titleinfigure"><a id="i1008337"></a>Figure 1-1 Integrated Application Environment Using Oracle Database Advanced Queuing</p>
<img width="636" height="407" src="img/adque437.gif" alt="Surrounding text describes Figure 1-1 ."/><br/></div>
<!-- class="figure" -->
<a id="CHDJHJHF"></a>
<div id="ADQUE2433" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref39"></a>Oracle Database Advanced Queuing Client/Server Communication</h3>
<p>Client/Server applications usually run in a <a href="glossary.htm#i432468"><span class="xrefglossterm">synchronous</span></a> manner. <a href="#CHDIAHBF">Figure 1-2</a> demonstrates the <a href="glossary.htm#i432195"><span class="xrefglossterm">asynchronous</span></a> alternative using Oracle Database Advanced Queuing. In this example Application B (a server) provides service to Application A (a client) using a request/response queue.</p>
<p>Application A enqueues a request into the request queue. In a different transaction, Application B dequeues and processes the request. Application B enqueues the result in the response queue, and in yet another transaction, Application A dequeues it.</p>
<p>The client need not wait to establish a connection with the server, and the server dequeues the message at its own pace. When the server is finished processing the message, there is no need for the client to be waiting to receive the result. A process of double-deferral frees both client and server.</p>
<div id="ADQUE2434" class="figure">
<p class="titleinfigure"><a id="CHDIAHBF"></a>Figure 1-2 Client/Server Communication Using Oracle Database Advanced Queuing</p>
<img width="240" height="312" src="img/adque035.gif" alt="Description of Figure 1-2 follows"/><br/>
<a id="sthref40" href="img_text/adque035.htm">Description of &#34;Figure 1-2 Client/Server Communication Using Oracle Database Advanced Queuing&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="CHDGGIEH"></a>
<div id="ADQUE2435" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref41"></a><a id="sthref42"></a>Multiconsumer Dequeuing of the Same Message</h3>
<p>A message can only be enqueued into one queue at a time. If a producer had to insert the same message into several queues in order to reach different consumers, then this would require management of a very large number of queues. To allow multiple consumers to dequeue the same message, Oracle Database Advanced Queuing provides for queue subscribers and message recipients.</p>
<p>To allow for <a href="glossary.htm#CBADJIIA"><span class="xrefglossterm">subscriber</span></a> and <a href="glossary.htm#CBACHAEI"><span class="xrefglossterm">recipient</span></a> lists, the queue must reside in a <a href="glossary.htm#CBAFHDDD"><span class="xrefglossterm">queue table</span></a> that is created with the multiple consumer option. Each message remains in the queue until it is consumed by all its intended consumers.</p>
<p class="subhead1"><a id="ADQUE2436"></a><a id="sthref43"></a><a id="sthref44"></a>Queue Subscribers</p>
<p>Multiple consumers, which can be either applications or other queues, can be associated with a queue as subscribers. This causes all messages enqueued in the queue to be made available to be consumed by each of the queue subscribers. The subscribers to the queue can be changed dynamically without any change to the messages or message producers.</p>
<p>You cannot add subscriptions to single-consumer queues or exception queues. A consumer that is added as a subscriber to a queue is only able to dequeue messages that are enqueued after the subscriber is added. No two subscribers can have the same values for name, address, and protocol. At least one of these attributes must be different for two subscribers.</p>
<p><a id="sthref45"></a>It cannot be known which subscriber will dequeue which message first, second, and so on, because there is no priority among subscribers. More formally, the order of dequeuing by subscribers is indeterminate.</p>
<p>Subscribers can also be rule-based. Similar in syntax to the <code>WHERE</code> clause of a SQL query, rules are expressed in terms of attributes that represent message properties or message content. These subscriber rules are evaluated against incoming messages, and those rules that match are used to determine message recipients.</p>
<p>In <a href="#CHDEIABI">Figure 1-3</a>, Application B and Application C each need messages produced by Application A, so a multiconsumer queue is specially configured with Application B and Application C as queue subscribers. Each receives every message placed in the queue.</p>
<div id="ADQUE2437" class="figure">
<p class="titleinfigure"><a id="CHDEIABI"></a>Figure 1-3 Communication Using a Multiconsumer Queue</p>
<img width="320" height="281" src="img/adque037.gif" alt="Description of Figure 1-3 follows"/><br/>
<a id="sthref46" href="img_text/adque037.htm">Description of &#34;Figure 1-3 Communication Using a Multiconsumer Queue&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p class="subhead1"><a id="ADQUE2438"></a><a id="sthref47"></a><a id="sthref48"></a>Message Recipients</p>
<p>A message producer can submit a list of recipients at the time a message is enqueued. This allows for a unique set of recipients for each message in the queue. The recipient list associated with the message overrides the subscriber list associated with the queue, if there is one. The recipients need not be in the subscriber list. However, recipients can be selected from among the subscribers.</p>
<p>A recipient can be specified only by its name, in which case the recipient must dequeue the message from the queue in which the message was enqueued. It can be specified by its name and an address with a protocol value of 0. The address should be the name of another queue in the same database or another installation of Oracle Database (identified by the database link), in which case the message is propagated to the specified queue and can be dequeued by a consumer with the specified name. If the recipient&#39;s name is NULL, then the message is propagated to the specified queue in the address and can be dequeued by the subscribers of the queue specified in the address. If the protocol field is nonzero, then the name and address are not interpreted by the system and the message can be dequeued by a special consumer.</p>
<p>Subscribing to a queue is like subscribing to a magazine: each subscriber can dequeue all the messages placed into a specific queue, just as each magazine subscriber has access to all its articles. Being a recipient, however, is like getting a letter: each recipient is a designated target of a particular message.</p>
<p><a href="#CHDBDGHJ">Figure 1-4</a> shows how Oracle Database Advanced Queuing can accommodate both kinds of consumers. Application A enqueues messages. Application B and Application C are subscribers. But messages can also be explicitly directed toward recipients like Application D, which may or may not be subscribers to the queue. The list of such recipients for a given message is specified in the enqueue call for that message. It overrides the list of subscribers for that queue.</p>
<div id="ADQUE2439" class="figure">
<p class="titleinfigure"><a id="CHDBDGHJ"></a>Figure 1-4 Explicit and Implicit Recipients of Messages</p>
<img width="336" height="432" src="img/adque039.gif" alt="Description of Figure 1-4 follows"/><br/>
<a id="sthref49" href="img_text/adque039.htm">Description of &#34;Figure 1-4 Explicit and Implicit Recipients of Messages&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Multiple producers can simultaneously enqueue messages aimed at different targeted recipients.</div>
</div>
<!-- class="sect2" -->
<a id="CHDFIFGC"></a>
<div id="ADQUE2440" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref50"></a>Oracle Database Advanced Queuing Implementation of Workflows</h3>
<p><a href="#CHDHEIBE">Figure 1-5</a> illustrates the use of Oracle Database Advanced Queuing for implementing a <a href="glossary.htm#i432481"><span class="xrefglossterm">workflow</span></a>, also known as a chained application transaction:</p>
<ol>
<li>
<p>Application A begins a workflow by enqueuing Message 1.</p>
</li>
<li>
<p>Application B dequeues it, performs whatever activity is required, and enqueues Message 2.</p>
</li>
<li>
<p>Application C dequeues Message 2 and generates Message 3.</p>
</li>
<li>
<p>Application D, the final step in the workflow, dequeues it.</p>
</li>
</ol>
<div id="ADQUE2441" class="figure">
<p class="titleinfigure"><a id="CHDHEIBE"></a>Figure 1-5 Implementing a Workflow using Oracle Database Advanced Queuing</p>
<img width="408" height="323" src="img/adque040.gif" alt="Description of Figure 1-5 follows"/><br/>
<a id="sthref51" href="img_text/adque040.htm">Description of &#34;Figure 1-5 Implementing a Workflow using Oracle Database Advanced Queuing&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The contents of the messages 1, 2 and 3 can be the same or different. Even when they are different, messages can contain parts of the contents of previous messages.</div>
<p>The queues are used to buffer the flow of information between different processing stages of the business process. By specifying delay interval and expiration time for a message, a window of execution can be provided for each of the applications.</p>
<p>From a workflow perspective, knowledge of the volume and timing of message flows is a business asset quite apart from the value of the payload data. Oracle Database Advanced Queuing helps you gain this knowledge by supporting the optional retention of messages for analysis of historical patterns and prediction of future trends.</p>
</div>
<!-- class="sect2" -->
<a id="CHDGJGAH"></a>
<div id="ADQUE2442" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref52"></a><a id="sthref53"></a>Oracle Database Advanced Queuing Implementation of Publish/Subscribe</h3>
<p>A point-to-point message is aimed at a specific target. Senders and receivers decide on a common queue in which to exchange messages. Each message is consumed by only one receiver. <a href="#CHDEABII">Figure 1-6</a> shows that each application has its own message queue, known as a single-consumer queue.</p>
<div id="ADQUE2443" class="figure">
<p class="titleinfigure"><a id="CHDEABII"></a>Figure 1-6 Point-to-Point Messaging</p>
<img width="496" height="112" src="img/adque250.gif" alt="Description of Figure 1-6 follows"/><br/>
<a id="sthref54" href="img_text/adque250.htm">Description of &#34;Figure 1-6 Point-to-Point Messaging&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>A <a href="glossary.htm#CBAIJICJ"><span class="xrefglossterm">publish/subscribe</span></a> message can be consumed by multiple receivers, as shown in <a href="#CHDICBHA">Figure 1-7</a>. Publish/subscribe messaging has a wide dissemination mode called <a href="glossary.htm#CBADDJBF"><span class="xrefglossterm">broadcast</span></a> and a more narrowly aimed mode called <a href="glossary.htm#CBABFGJI"><span class="xrefglossterm">multicast</span></a>.</p>
<p><a id="sthref55"></a><a id="sthref56"></a>Broadcasting is like a radio station not knowing exactly who the audience is for a given program. The dequeuers are subscribers to multiconsumer queues. In contrast, multicast is like a magazine publisher who knows who the subscribers are. Multicast is also referred to as point-to-multipoint, because a single publisher sends messages to multiple receivers, called recipients, who may or may not be subscribers to the queues that serve as exchange mechanisms.</p>
<div id="ADQUE2444" class="figure">
<p class="titleinfigure"><a id="CHDICBHA"></a>Figure 1-7 Publish/Subscribe Mode</p>
<img width="496" height="110" src="img/adque249.gif" alt="Description of Figure 1-7 follows"/><br/>
<a id="sthref57" href="img_text/adque249.htm">Description of &#34;Figure 1-7 Publish/Subscribe Mode&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Publish/subscribe describes a situation in which a publisher application enqueues messages to a queue anonymously (no recipients specified). The messages are then delivered to subscriber applications based on <a href="glossary.htm#CBABGGGG"><span class="xrefglossterm">rules</span></a> specified by each application. The rules can be defined on message properties, message data content, or both.</p>
<p><a id="sthref58"></a>You can implement a publish/subscribe model of communication using Oracle Database Advanced Queuing as follows:</p>
<ol>
<li>
<p>Set up one or more queues to hold messages. These queues should represent an area or subject of interest. For example, a queue can be used to represent billed orders.</p>
</li>
<li>
<p>Set up a set of rule-based subscribers. Each subscriber can specify a rule which represents a specification for the messages that the subscriber wishes to receive. A null rule indicates that the subscriber wishes to receive all messages.</p>
</li>
<li>
<p>Publisher applications publish messages to the queue by invoking an enqueue call.</p>
</li>
<li>
<p>Subscriber applications can receive messages with a dequeue call. This retrieves messages that match the subscription criteria.</p>
</li>
<li>
<p><a id="sthref59"></a>Subscriber applications can also use a listen call to monitor multiple queues for subscriptions on different queues. This is a more scalable solution in cases where a subscriber application has subscribed to many queues and wishes to receive messages that arrive in any of the queues.</p>
</li>
<li>
<p>Subscriber applications can also use the Oracle Call Interface (OCI) notification mechanism. This allows a push mode of message delivery. The subscriber application registers the queues (and subscriptions specified as subscribing agent) from which to receive messages. This registers a callback to be invoked when messages matching the subscriptions arrive.</p>
</li>
</ol>
<p><a href="#CHDJEHDI">Figure 1-8</a> illustrates the use of Oracle Database Advanced Queuing for implementing a publish/subscribe relationship between publisher Application A and subscriber Applications B, C, and D:</p>
<ul>
<li>
<p>Application B subscribes with rule &#34;priority = 1&#34;.</p>
</li>
<li>
<p>Application C subscribes with rule &#34;priority &gt; 1&#34;.</p>
</li>
<li>
<p>Application D subscribes with rule &#34;priority = 3&#34;.</p>
</li>
</ul>
<div id="ADQUE2445" class="figure">
<p class="titleinfigure"><a id="CHDJEHDI"></a>Figure 1-8 Implementing Publish/Subscribe using Oracle Database Advanced Queuing</p>
<img width="336" height="426" src="img/adque041.gif" alt="Description of Figure 1-8 follows"/><br/>
<a id="sthref60" href="img_text/adque041.htm">Description of &#34;Figure 1-8 Implementing Publish/Subscribe using Oracle Database Advanced Queuing&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>If Application A enqueues three messages with priorities 1, 2, and 3 respectively, then the messages will be delivered as follows:</p>
<ul>
<li>
<p>Application B receives a single message (priority 1).</p>
</li>
<li>
<p>Application C receives two messages (priority 2, 3).</p>
</li>
<li>
<p>Application D receives a single message (priority 3).</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDGDCDA"></a>
<div id="ADQUE0102" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Buffered Messaging<a id="sthref61"></a><a id="sthref62"></a></h2>
<p>Buffered messaging, a new feature in Oracle Database Advanced Queuing 10<span class="italic">g</span> Release 2 (10.2), combines the rich functionality that this product has always offered with a much faster queuing implementation. Buffered messaging is ideal for applications that do not require the reliability and transaction support of Oracle Database Advanced Queuing persistent messaging.</p>
<p>Buffered messaging is faster than persistent messaging, because its messages reside in shared memory. They are usually written to disk only when the total memory consumption of buffered messages approaches the available shared memory limit.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The portion of a queue that stores buffered messages in memory is sometimes referred to as a buffered queue.</div>
<p>Message retention is not supported for buffered messaging.</p>
<p>When using buffered messaging, Oracle recommends that you do one of the following:</p>
<ul>
<li>
<p><a id="sthref63"></a>Set parameter <code>streams_pool_size</code></p>
<p>This parameter controls the size of shared memory available to Oracle Database Advanced Queuing. If unspecified, up to 10% of the shared pool size may be allocated for the Oracle Database Advanced Queuing pool from the database cache.</p>
</li>
<li>
<p>Turn on SGA autotuning</p>
<p>Oracle will automatically allocate the appropriate amount of memory from the SGA for Oracle Database Advanced Queuing, based on Oracle Database Advanced Queuing usage and, also usage of other components that use the SGA. Examples of such other components are buffer cache and library cache. If <code>streams_pool_size</code> is specified, it is used as the lower bound.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
&#34;Setting Initialization Parameters Relevant to Streams&#34; in <a class="olink STRMS010" href="../STRMS/strms_adprop.htm#STRMS010"><span class="italic">Oracle Streams Concepts and Administration</span></a></div>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDFICID">Enqueuing Buffered Messages</a></p>
</li>
<li>
<p><a href="#CHDIJDFH">Dequeuing Buffered Messages</a></p>
</li>
<li>
<p><a href="#CHDHFACF">Propagating Buffered Messages</a></p>
</li>
<li>
<p><a href="#CHDDBCFA">Flow Control</a></p>
</li>
<li>
<p><a href="#CHDFJCAC">Buffered Messaging with Oracle Real Application Clusters (Oracle RAC)</a></p>
</li>
<li>
<p><a href="#CHDHGAGE">Buffered Messaging Restrictions</a></p>
</li>
<li>
<p><a href="#CHDFCFBF">Error Handling</a></p>
</li>
</ul>
<p class="subhead1"><a id="CHDFICID"></a><a id="ADQUE2446"></a><a id="sthref64"></a><a id="sthref65"></a>Enqueuing Buffered Messages</p>
<p>Buffered and persistent messages use the same single-consumer or multiconsumer queues and the same administrative and operational interfaces. They are distinguished from each other by a delivery mode parameter, set by the application when enqueuing the message to an Oracle Database Advanced Queuing queue.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="aq_opers.htm#i1005596">&#34;Enqueuing Messages&#34;</a></div>
<p>Recipient lists are supported for buffered messaging enqueue.</p>
<p>Buffered messaging is supported in all queue tables created with compatibility 8.1 or higher. Transaction grouping queues and array enqueues are not supported for buffered messages in this release. You can still use the array enqueue procedure to enqueue buffered messages, but the array size must be set to one.</p>
<p><a id="sthref66"></a>Buffered messages can be queried using the <code>AQ$</code><code><span class="codeinlineitalic">Queue_Table_Name</span></code> view. They appear with states <code>IN-MEMORY</code> or <code>SPILLED</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="aq_views.htm#i1006503">&#34;AQ$&lt;<span class="italic">Queue_Table_Name</span>&gt;: Messages in Queue Table&#34;</a></div>
<p><a id="sthref67"></a><a id="sthref68"></a>The queue type for buffered messaging can be <code>ADT</code>, <code>XML</code>, <code>ANYDATA</code>, or <code>RAW</code>. For <code>ADT</code> types with <code>LOB</code> attributes, only buffered messages with null <code>LOB</code> attributes can be enqueued.</p>
<p><a id="sthref69"></a><a id="sthref70"></a>All ordering schemes available for persistent messages are also available for buffered messages, but only within each message class. Ordering among persistent and buffered messages enqueued in the same session is not currently supported.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDIAGFG">&#34;Priority and Ordering of Messages in Enqueuing&#34;</a></div>
<p><a id="sthref71"></a><a id="sthref72"></a>Both enqueue and dequeue buffered messaging operations must be with <code>IMMEDIATE</code> visibility mode. Thus they cannot be part of another transaction. You cannot specify delay when enqueuing buffered messages.</p>
<p class="subhead1"><a id="CHDIJDFH"></a><a id="ADQUE2447"></a><a id="sthref73"></a><a id="sthref74"></a>Dequeuing Buffered Messages</p>
<p>Rule-based subscriptions are supported with buffered messaging. The procedure for adding subscribers is enhanced to allow an application to express interest in persistent messages only, buffered messages only, or both.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="aq_admin.htm#i1006671">&#34;Adding a Subscriber&#34;</a></div>
<p>Array dequeue is not supported for buffered messaging, but you can still use the array dequeue procedure by setting array size to one message.</p>
<p><a id="sthref75"></a><a id="sthref76"></a>Dequeuing applications can choose to dequeue persistent messages only, buffered messages only, or both types. Visibility must be set to <code>IMMEDIATE</code> for dequeuing buffered messages. All of the following dequeue options are supported:</p>
<ul>
<li>
<p>Dequeue modes <code>BROWSE</code>, <code>LOCK</code>, <code>REMOVE</code>, and <code>REMOVE_NO_DATA</code></p>
</li>
<li>
<p>Navigation modes <code>FIRST_MESSAGE</code> and <code>NEXT_MESSAGE</code></p>
</li>
<li>
<p>Correlation identifier</p>
</li>
<li>
<p>Dequeue condition</p>
</li>
<li>
<p>Message identifier</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="aq_opers.htm#CHDBBGGE">&#34;Dequeue Options&#34;</a></div>
<p class="subhead1"><a id="CHDHFACF"></a><a id="ADQUE2448"></a><a id="sthref77"></a><a id="sthref78"></a>Propagating Buffered Messages</p>
<p>Propagation of buffered messages is supported. A single propagation schedule serves both persistent and buffered messages. The <code>DBA_QUEUE_SCHEDULES</code> view displays statistics and error information.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="aq_views.htm#i1006030">&#34;DBA_QUEUE_SCHEDULES: All Propagation Schedules&#34;</a></div>
<p>Oracle Database AQ deletes buffered messages once they are propagated to the remote sites. If the receiving site fails before these messages are consumed, then these messages will be lost. The source site will not be able to re-send them. Duplicate delivery of messages is also possible.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDFJCAC">&#34;Buffered Messaging with Oracle Real Application Clusters (Oracle RAC)&#34;</a></div>
<p class="subhead1"><a id="CHDDBCFA"></a><a id="ADQUE2449"></a><a id="sthref79"></a><a id="sthref80"></a>Flow Control</p>
<p>Oracle Database Advanced Queuing implements a flow control system that prevents applications from flooding the shared memory with messages. If the number of outstanding messages per sender exceeds a system-defined threshold, the enqueue call will block and timeout with an error message. A message sender is identified by <span class="italic">sender_id.name</span> in the enqueue options. A sender blocked due to flow control on a queue does not affect other message senders. The resolution is to dequeue messages, thereby resolving flow control, after which new messages can be enqueued.</p>
<p>Flow control threshold varies with memory pressure and could come down to the system-defined limit if streams pool usage becomes significant. Message senders will block on event <code>Streams AQ: enqueue blocked due to flow control</code> and time out with error <code>ORA-25307</code> if flow control is not resolved. Applications are expected to handle this error, and re-enqueue the failed message.</p>
<p>Even with flow control, slow consumers of a multiconsumer queue can cause the number of messages stored in memory to grow without limit. Provided there is at least one subscriber who is keeping pace, older messages are spilled to disk and removed from the pool to free up memory. This ensures that the cost of disk access is paid by the slower consumers, and faster subscribers can proceed unhindered.</p>
<p class="subhead1"><a id="CHDFJCAC"></a><a id="ADQUE2450"></a><a id="sthref81"></a><a id="sthref82"></a><a id="sthref83"></a><a id="sthref84"></a>Buffered Messaging with Oracle Real Application Clusters (Oracle RAC)</p>
<p>An application can enqueue and dequeue buffered messages from any Oracle RAC instance as long as it uses password-based authentication to connect to the database. The structures required for buffered messaging are implemented on one Oracle RAC instance. The instance where the buffered messaging structures are implemented is the <code>OWNER_INSTANCE</code> of the queue table containing the queue. Enqueue and dequeue requests received at other instances are forwarded to the <code>OWNER_INSTANCE</code> over the interconnect. The <code>REMOTE_LISTENER</code> parameter in <code>listener.ora</code> must also be set to enable forwarding of buffered messaging requests to correct instance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="aq_views.htm#CHDHEECI">&#34;ALL_QUEUE_TABLES: Queue Tables Accessible to the Current User&#34;</a> for more information on <code>OWNER_INSTANCE</code></p>
</li>
<li>
<p>&#34;REMOTE_LISTENER&#34; in <a class="olink REFRN10183" href="../REFRN/GUID-FEE2E8B5-CE02-4158-A6B4-030E59316756.htm#REFRN10183"><span class="italic">Oracle Database Reference</span></a> for more information on setting the <code>REMOTE_LISTENER</code> parameter</p>
</li>
</ul>
</div>
<p><a id="sthref85"></a>A service name is associated with each queue in Oracle RAC and displayed in the <code>DBA_QUEUES</code> and <code>USER_QUEUES</code> views. This service name always points to the instance with the most efficient access for buffered messaging, minimizing pinging between instances. OCI clients can use the service name for buffered messaging operations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="aq_views.htm#i1005903">&#34;DBA_QUEUES: All Queues in Database&#34;</a> or <a href="aq_views.htm#i1006883">&#34;USER_QUEUES: Queues In User Schema&#34;</a></div>
<p><a id="sthref86"></a><a id="sthref87"></a>Oracle recommends that you use buffered messaging with queue-to-queue propagation. This results in transparent failover when propagating messages to a destination Oracle RAC system. You do not need to re-point your database links if the primary AQ Oracle RAC instance fails.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDIJAIJ">&#34;Support for Oracle Real Application Clusters(Oracle RAC)&#34;</a></div>
<p class="subhead1"><a id="CHDHGAGE"></a><a id="ADQUE2451"></a><a id="sthref88"></a><a id="sthref89"></a>Buffered Messaging Restrictions</p>
<p>The following Oracle Database Advanced Queuing features are not currently supported for buffered messaging:</p>
<ul>
<li>
<p>Message retention</p>
</li>
<li>
<p>Message delay</p>
</li>
<li>
<p>Transaction grouping</p>
</li>
<li>
<p>Array enqueue</p>
</li>
<li>
<p>Array dequeue</p>
</li>
<li>
<p>Message export and import</p>
</li>
<li>
<p>Posting for subscriber notification</p>
</li>
<li>
<p>Messaging Gateway</p>
</li>
</ul>
<p class="subhead1"><a id="CHDFCFBF"></a><a id="ADQUE2452"></a><a id="sthref90"></a><a id="sthref91"></a>Error Handling</p>
<p>Retry count and retry delay are not supported for buffered messages. Message expiration is supported. When a buffered message has been in the queue beyond its expiration period, it is moved into the exception queue as a persistent message.</p>
</div>
<!-- class="sect1" -->
<a id="CHDFIFFJ"></a>
<div id="ADQUE0101" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref92"></a><a id="sthref93"></a>Asynchronous Notifications</h2>
<p>Asynchronous notification allows clients to receive notifications of messages of interest. The client can use these notifications to monitor multiple subscriptions. The client need not be connected to the database to receive notifications regarding its subscriptions. Asynchronous notification is supported for buffered messages. The delivery mode of the message is available in the message descriptor of the notification descriptor.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In releases before Oracle Database 10<span class="italic">g</span> Release 2 (10.2), the Oracle Database Advanced Queuing notification feature was not supported for queues with names longer than 30 characters. This restriction no longer applies. The 24-character limit on names of user-generated queues still applies. See <a href="aq_admin.htm#i1006091">&#34;Creating a Queue&#34;</a>.</div>
<p>The client specifies a callback function which is run for each message. Asynchronous notification cannot be used to invoke an executable, but it is possible for the callback function to invoke a stored procedure.</p>
<p>Clients can receive notifications procedurally using PL/SQL, Java Message Service (JMS), or OCI callback functions, or clients can receive notifications through e-mail or HTTP post. Clients can also specify the presentation for notifications as either <code>RAW</code> or <code>XML</code>.</p>
<p>For JMS queues, the dequeue is accomplished as part of the notification; explicit dequeue is not required. For RAW queues, clients can specify payload delivery; but they still must dequeue the message in <code>REMOVE_NO_DATA</code> mode. For all other persistent queues, the notification contains only the message properties; clients explicitly dequeue to receive the message.</p>
<p class="subhead1"><a id="CHDCFCGE"></a><a id="ADQUE2453"></a><a id="sthref94"></a><a id="sthref95"></a><a id="sthref96"></a>Payload Delivery for RAW Queues</p>
<p>For RAW queues, Oracle Database Advanced Queuing clients can now specify that the message payload be delivered along with its notification.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="componet.htm#i1005777">&#34;AQ Registration Information Type&#34;</a></div>
<p class="subhead1"><a id="CHDIBBEA"></a><a id="ADQUE2454"></a><a id="sthref97"></a><a id="sthref98"></a><a id="sthref99"></a>Reliable Notification</p>
<p>In earlier releases of Oracle Database Advanced Queuing, message notifications were stored in shared memory and were lost if the instance failed. Clients can now specify persistent message notification. If an Oracle RAC instance fails, its notifications are delivered by another Oracle RAC node. If a standalone instance fails, its notifications are delivered when the instance restarts.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Notification reliability refers only to server failures. If Oracle Database Advanced Queuing cannot deliver client notifications for any other reason, then the notifications are purged along with the client registration.</div>
<p class="subhead1"><a id="CHDCGEEE"></a><a id="ADQUE2455"></a><a id="sthref100"></a><a id="sthref101"></a><a id="sthref102"></a>Designated Port Notification</p>
<p>Oracle Database Advanced Queuing clients can now use the OCI subscription handle attribute <code>OCI_ATTR_SUBSCR_PORTNO</code> to designate the port at which notifications are delivered. This is especially useful for clients on a computer behind a firewall. The port for the listener thread can be designated before the first registration, using an attribute in the environment handle. The thread is started the first time an <code>OCISubscriptionRegister</code> is called. If the client attempts to start another thread on a different port using a different environment handle, then Oracle Database Advanced Queuing returns an error.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Designated port notification and IP address notification apply only to OCI clients.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
&#34;Publish-Subscribe Registration Functions in OCI&#34; in <a class="olink LNOCI090" href="../LNOCI/oci09adv.htm#LNOCI090"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a></div>
<p class="subhead1"><a id="ADQUE2456"></a>IPv6 Compliance and Designated IP Support</p>
<p>Oracle Database AQ supports IPv6 and Oracle Database AQ clients can use the OCI subscription handle attribute <code>OCI_ATTR_SUBSCR_IPADDR</code> to designate the IP address at which notifications are delivered. This is especially useful for clients on a computer that has multiple network interface cards or IP addresses. The IP address for the listener thread can be designated before the first registration using an attribute in the environment handle. The thread is started the first time an <code>OCISubscriptionRegister</code> is called. If the client attempts to start another thread on a different IP address using a different environment handle, Oracle Database AQ returns an error. If no IP address is specified, Oracle Database AQ will deliver notifications on all IP addresses of the computer the client is on.</p>
<p class="subhead1"><a id="CHDIJDBB"></a><a id="ADQUE2457"></a><a id="sthref103"></a><a id="sthref104"></a><a id="sthref105"></a>Registration Timeout</p>
<p>In earlier releases of Oracle Database Advanced Queuing, registrations for notification persisted until explicitly removed by the client or purged in case of extended client failure. In Oracle Database Advanced Queuing 10<span class="italic">g</span> Release 2 (10.2) clients can register for a specified time, after which the registration is automatically purged.</p>
<p>When the registration is purged, Oracle Database Advanced Queuing sends a notification to the client, so the client can invoke its callback and take any necessary action.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="componet.htm#i1005777">&#34;AQ Registration Information Type&#34;</a> for information on the <code>timeout</code> parameter</div>
<p class="subhead1"><a id="CHDDAAEF"></a><a id="ADQUE2458"></a><a id="sthref106"></a><a id="sthref107"></a><a id="sthref108"></a>Purge on Notification</p>
<p>Clients can also register to receive only the first notification, after which the registration is automatically purged.</p>
<p>An example where purge on notification is useful is a client waiting for enqueues to start. In this case, only the first notification is useful; subsequent notifications provide no additional information. Previously, this client would be required to unregister once enqueuing started; now the registration can be configured to go away automatically.</p>
<p class="subhead1"><a id="CHDFAHIE"></a><a id="ADQUE2459"></a><a id="sthref109"></a><a id="sthref110"></a><a id="sthref111"></a>Buffered Message Notification</p>
<p>Clients can register for notification of buffered messages. The registration requests apply to both buffered and persistent messages. The message properties delivered with the PL/SQL or OCI notification specify whether the message is buffered or persistent.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="aq_opers.htm#i1007235">&#34;Registering for Notification&#34;</a> for more information on PL/SQL notification</p>
</li>
<li>
<p>Appendix&nbsp;C, &#34;OCI Examples&#34;, which appears only in the HTML version of this guide, for an example of OCI notification</p>
</li>
</ul>
</div>
<p>Reliable notification is not supported.</p>
<div id="ADQUE2460" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref112"></a>
<h3 class="sect2">Views on Registration</h3>
<p>The dictionary views <code>DBA_SUBSCR_REGISTRATIONS</code> and <code>USER_SUBSCR_REGISTRATIONS</code> display the various registrations in the system. The diagnostic view <code>GV$SUBSCR_REGISTRATION_STATS</code> may be used to monitor notification statistics and performance.</p>
</div>
<!-- class="sect2" -->
<div id="ADQUE2461" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref113"></a>
<h3 class="sect2">Event-Based Notification</h3>
<p>Event-based notifications are processed by a set of coordinator (<code>EMNC</code>) and subordinate processes. The event notification load is distributed among these processes. These processes work on the system notifications in parallel, offering a capability to process a larger volume of notifications, a faster response time and lower shared memory use for staging notifications.</p>
</div>
<!-- class="sect2" -->
<div id="ADQUE2462" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref114"></a>
<h3 class="sect2">Notification Grouping by Time</h3>
<p>Notification applications may register to receive a single notification for all events that occur within a specified time interval. Notification Clients may specify a start time for the notifications. Additionally, they must specify a time as the grouping class and the time interval as the grouping value. A repeat count may be used to limit the number of notifications delivered.Clients can receive two types of grouping events, Summary or Last. A summary notification is a list of Message Identifiers of all the messages for the subscription. If last was specified as a grouping type, notification would have information about the last message in the notification interval. A count of the number of messages in the interval is also sent.The registration interfaces in PLSQL and OCI allow for specification of the <code>START_TIME</code>, <code>REPEAT_COUNT</code>, <code>GROUPING CLASS</code>, <code>GROUPING VALUE</code>, <code>GROUPING TYPE</code> in the <code>AQ$_REGISTRATION_INFO</code> and the OCI subscription Handle.</p>
<p>The notification descriptor received by the client initiated AQ notification provides information about the group of message identifiers and the number of notifications in the group.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS" href="../ARPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p>
</li>
<li>
<p><a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDJDBCE"></a>
<div id="ADQUE2463" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref115"></a><a id="sthref116"></a>Enqueue Features</h2>
<p>The following features apply to enqueuing messages:</p>
<ul>
<li>
<p><a href="#CHDDIFAC">Enqueue an Array of Messages</a></p>
</li>
<li>
<p><a href="#CHDHBIBH">Correlation Identifiers</a></p>
</li>
<li>
<p><a href="#CHDIAGFG">Priority and Ordering of Messages in Enqueuing</a></p>
</li>
<li>
<p><a href="#CHDFEHHB">Message Grouping</a></p>
</li>
<li>
<p><a href="#CHDCHGII">Sender Identification</a></p>
</li>
<li>
<p><a href="#CHDFFCIA">Time Specification and Scheduling</a></p>
</li>
</ul>
<p class="subhead1"><a id="CHDDIFAC"></a><a id="ADQUE2464"></a><a id="sthref117"></a><a id="sthref118"></a><a id="sthref119"></a>Enqueue an Array of Messages</p>
<p>When enqueuing messages into a queue, you can operate on an array of messages simultaneously, instead of one message at a time. This can improve the performance of enqueue operations. When enqueuing an array of messages into a queue, each message shares the same enqueue options, but each message can have different message properties. You can perform array enqueue operations using PL/SQL or OCI.</p>
<p>Array enqueuing is not supported for buffered messages in this release.</p>
<p class="subhead1"><a id="CHDHBIBH"></a><a id="ADQUE2465"></a><a id="sthref120"></a><a id="sthref121"></a><a id="sthref122"></a>Correlation Identifiers</p>
<p>You can assign an identifier to each message, thus providing a means to retrieve specific messages at a later time.</p>
<p class="subhead1"><a id="CHDIAGFG"></a><a id="ADQUE2466"></a><a id="sthref123"></a><a id="sthref124"></a><a id="sthref125"></a><a id="sthref126"></a><a id="sthref127"></a>Priority and Ordering of Messages in Enqueuing<a id="sthref128"></a><a id="sthref129"></a></p>
<p>You can specify the priority of an enqueued message and its exact position in the queue. This means that users can specify the order in which messages are consumed in three ways:</p>
<ul>
<li>
<p>A priority can be assigned to each message.</p>
</li>
<li>
<p>A sort order specifies which properties are used to order all messages in a queue. This is set when the queue table is created and cannot be changed. You can choose to sort messages by priority, enqueue time, or commit time. The commit-time option, a new feature in Oracle Database Advanced Queuing 10<span class="italic">g</span> Release 2 (10.2), orders messages by an <a href="glossary.htm#CHDJJEDH"><span class="xrefglossterm">approximate CSCN</span></a> calculated for each transaction.</p>
<p>Commit-time ordering is useful when transactions are interdependent or when browsing the messages in a queue must yield consistent results.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>&#34;Commit-Time Queues&#34; in <a class="olink STRMS003" href="../STRMS/strms_prop.htm#STRMS003"><span class="italic">Oracle Streams Concepts and Administration</span></a></p>
</li>
<li>
<p><a href="aq_admin.htm#CACECDGA">&#34;Creating a Queue Table&#34;</a> for more information on sort order</p>
</li>
</ul>
</div>
</li>
<li>
<p>A sequence deviation positions a message in relation to other messages.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The sequence deviation feature is deprecated in 10<span class="italic">g</span> Release 2 (10.2).</div>
<p>If several consumers act on the same queue, then each consumer gets the first message that is available for immediate consumption. A message that is in the process of being consumed by another consumer is skipped.</p>
<p>Priority ordering of messages is achieved by specifying priority, enqueue time as the sort order. If priority ordering is chosen, then each message is assigned a priority at enqueue time by the enqueuing agent. At dequeue time, the messages are dequeued in the order of the priorities assigned. If two messages have the same priority, then the order in which they are dequeued is determined by the enqueue time. A first-in, first-out (FIFO) priority queue can also be created by specifying enqueue time, priority as the sort order of the messages.</p>
<p class="subhead1"><a id="CHDFEHHB"></a><a id="ADQUE2467"></a><a id="sthref130"></a><a id="sthref131"></a><a id="sthref132"></a>Message Grouping</p>
<p>Messages belonging to one queue can be grouped to form a set that can only be consumed by one user at a time. This requires that the queue be created in a queue table that is enabled for message grouping. All messages belonging to a group must be created in the same transaction, and all messages created in one transaction belong to the same group.</p>
<p>This feature allows users to segment complex messages into simple messages. For example, messages directed to a queue containing invoices can be constructed as a group of messages starting with a header message, followed by messages representing details, followed by a trailer message.</p>
<p>Message grouping is also useful if the message payload contains complex large objects such as images and video that can be segmented into smaller objects.</p>
<p>Group message properties priority, delay, and expiration are determined solely by the message properties specified for the first message in a group, irrespective of which properties are specified for subsequent messages in the group.</p>
<p>The message grouping property is preserved across propagation. However, the destination queue where messages are propagated must also be enabled for transactional grouping. There are also some restrictions you must keep in mind if the message grouping property is to be preserved while dequeuing messages from a queue enabled for transactional grouping.</p>
<p class="subhead1"><a id="CHDCHGII"></a><a id="ADQUE2468"></a><a id="sthref133"></a><a id="sthref134"></a><a id="sthref135"></a>Sender Identification</p>
<p>Applications can mark the messages they send with a custom identification. Oracle Database Advanced Queuing also automatically identifies the queue from which a message was dequeued. This allows applications to track the pathway of a propagated message or a string message within the same database.</p>
<p class="subhead1"><a id="CHDFFCIA"></a><a id="ADQUE2469"></a><a id="sthref136"></a><a id="sthref137"></a><a id="sthref138"></a><a id="sthref139"></a>Time Specification and Scheduling</p>
<p>Messages can be enqueued with an expiration that specifies the interval of time the message is available for dequeuing. The default for expiration is never. When a message expires, it is moved to an exception queue. Expiration processing requires that the queue monitor be running.</p>
</div>
<!-- class="sect1" -->
<a id="CHDJGIJG"></a>
<div id="ADQUE2470" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref140"></a><a id="sthref141"></a>Dequeue Features</h2>
<p>The following features apply to dequeuing messages:</p>
<ul>
<li>
<p><a href="#CHDIJCEE">Concurrent Dequeues</a></p>
</li>
<li>
<p><a href="#CHDCEJDG">Dequeue Methods</a></p>
</li>
<li>
<p><a href="#CHDCEDDG">Dequeue Modes</a></p>
</li>
<li>
<p><a href="#CHDIBGDA">Dequeue an Array of Messages</a></p>
</li>
<li>
<p><a href="#CHDIECFG">Message States</a></p>
</li>
<li>
<p><a href="#CHDEDCCI">Navigation of Messages in Dequeuing</a></p>
</li>
<li>
<p><a href="#CHDCBGHJ">Waiting for Messages</a></p>
</li>
<li>
<p><a href="#CHDFCFEA">Retries with Delays</a></p>
</li>
<li>
<p><a href="#CHDBAEED">Optional Transaction Protection</a></p>
</li>
<li>
<p><a href="#CHDICJFH">Exception Queues</a></p>
</li>
</ul>
<p class="subhead1"><a id="CHDIJCEE"></a><a id="ADQUE2471"></a><a id="sthref142"></a><a id="sthref143"></a>Concurrent Dequeues</p>
<p>When there are multiple processes dequeuing from a single-consumer queue or dequeuing for a single consumer on the multiconsumer queue, different processes skip the messages that are being worked on by a concurrent process. This allows multiple processes to work concurrently on different messages for the same consumer.</p>
<p class="subhead1"><a id="CHDCEJDG"></a><a id="ADQUE2472"></a><a id="sthref144"></a><a id="sthref145"></a><a id="sthref146"></a>Dequeue Methods</p>
<p>A message can be dequeued using one of the following dequeue methods:</p>
<ul>
<li>
<p>Specifying a correlation identifier</p>
<p><a id="sthref147"></a><a id="sthref148"></a>A correlation identifier is a user-defined message property. Multiple messages with the same correlation identifier can be present in a queue, which means that the ordering (enqueue order) between messages might not be preserved on dequeue calls.</p>
</li>
<li>
<p>Specifying a message identifier</p>
<p><a id="sthref149"></a><a id="sthref150"></a>A message identifier is a system-assigned value (of <code>RAW</code> datatype). Only one message with a given message identifier can be present in the queue.</p>
</li>
<li>
<p>Specifying a dequeue condition</p>
<p>A dequeue condition is expressed in terms of message properties or message content and is similar in syntax to the <code>WHERE</code> clause of a SQL query. Messages in the queue are evaluated against the condition, and messages that satisfy the given condition are returned. When a dequeue condition is used, the order of the messages dequeued is indeterminate, and the sort order of the queue is not honored.</p>
</li>
<li>
<p>Default dequeue</p>
<p>A default dequeue retrieves the first available message.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Dequeuing with correlation identifier, message identifier, or dequeue condition does not preserve the message grouping property.</div>
<p class="subhead1"><a id="CHDCEDDG"></a><a id="ADQUE2473"></a><a id="sthref151"></a><a id="sthref152"></a>Dequeue Modes</p>
<p>A dequeue request can browse a message, remove it, or remove it with no data. If a message is browsed, then it remains available for further processing. If a message is removed or removed with no data, then it is no longer available for dequeue requests. Depending on the queue properties, a removed message can be retained in the queue table. A message is retained in the queue table after it has been consumed only if a retention time is specified for its queue.</p>
<p>The browse mode has three risks. First, there is no guarantee that the message can be dequeued again after it is browsed, because a dequeue call from a concurrent user might have removed the message. To prevent a viewed message from being dequeued by a concurrent user, you should view the message in the locked mode.</p>
<p>Second, your dequeue position in browse mode is automatically changed to the beginning of the queue if a nonzero wait time is specified and the navigating position reaches the end of the queue. If you repeat a dequeue call in the browse mode with the <code>NEXT_MESSAGE</code> navigation option and a nonzero wait time, then you can end up dequeuing the same message over and over again. Oracle recommends that you use a nonzero wait time for the first dequeue call on a queue in a session, and then use a zero wait time with the <code>NEXT_MESSAGE</code> navigation option for subsequent dequeue calls. If a dequeue call gets an &#34;end of queue&#34; error message, then the dequeue position can be explicitly set by the dequeue call to the beginning of the queue using the <code>FIRST_MESSAGE</code> navigation option, following which the messages in the queue can be browsed again.</p>
<p>Third, if the sort order of the queue is <code>ENQ_TIME</code>, <code>PRIORITY</code>, or a combination of these two, then results may not be repeatable from one browse to the next. If you must have consistent browse results, then you should use a <a href="glossary.htm#CHDDDEGD"><span class="xrefglossterm">commit-time queue</span></a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>&#34;Commit-Time Queues&#34; in <a class="olink STRMS003" href="../STRMS/strms_prop.htm#STRMS003"><span class="italic">Oracle Streams Concepts and Administration</span></a></p>
</li>
<li>
<p><a href="aq_admin.htm#CACECDGA">&#34;Creating a Queue Table&#34;</a></p>
</li>
</ul>
</div>
<p>When a message is dequeued using <code>REMOVE_NODATA</code> mode, the payload of the message is not retrieved. This mode can be useful when the user has already examined the message payload, possibly by means of a previous <code>BROWSE</code> dequeue.</p>
<p class="subhead1"><a id="CHDIBGDA"></a><a id="ADQUE2474"></a><a id="sthref153"></a><a id="sthref154"></a><a id="sthref155"></a>Dequeue an Array of Messages</p>
<p>When dequeuing messages from a queue, you can operate on an array of messages simultaneously, instead of one message at a time. This can improve the performance of dequeue operations. If you are dequeuing from a transactional queue, you can dequeue all the messages for a transaction with a single call, which makes application programming easier.</p>
<p>When dequeuing an array of messages from a queue, each message shares the same dequeue options, but each message can have different message properties. You can perform array enqueue and array dequeue operations using PL/SQL or OCI.</p>
<p>Array dequeuing is not supported for buffered messages in this release.</p>
<p class="subhead1"><a id="CHDIECFG"></a><a id="ADQUE2475"></a><a id="sthref156"></a><a id="sthref157"></a>Message States</p>
<p>Multiple processes or operating system threads can use the same consumer name to dequeue concurrently from a queue. In that case Oracle Database Advanced Queuing provides the first unlocked message that is at the head of the queue and is intended for the consumer. Unless the message identifier of a specific message is specified during dequeue, consumers can dequeue messages that are in the <code>READY</code> state.</p>
<p>A message is considered <code>PROCESSED</code> only when all intended consumers have successfully dequeued the message. A message is considered <code>EXPIRED</code> if one or more consumers did not dequeue the message before the <code>EXPIRATION</code> time. When a message has expired, it is moved to an exception queue.</p>
<p>Expired messages from multiconsumer queues cannot be dequeued by the intended recipients of the message. However, they can be dequeued in the <code>REMOVE</code> mode exactly once by specifying a <code>NULL</code> consumer name in the dequeue options.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the multiconsumer exception queue was created in a queue table with the <code>compatible</code> parameter set to <code>8.0</code>, then expired messages can be dequeued only by specifying a message identifier.
<p>Queues created in a queue table with <code>compatible</code> set to <code>8.0</code> (referred to in this guide as 8.0-style queues) are deprecated in Oracle Database Advanced Queuing 10<span class="italic">g</span> Release 2 (10.2). Oracle recommends that any new queues you create be 8.1-style or newer and that you migrate existing 8.0-style queues at your earliest convenience.</p>
</div>
<p>Beginning with Oracle Database Advanced Queuing release 8.1.6, only the queue monitor removes messages from multiconsumer queues. This allows dequeuers to complete the dequeue operation by not locking the message in the queue table. Because the queue monitor removes messages that have been processed by all consumers from multiconsumer queues approximately once every minute, users can see a delay between when the messages have been completely processed and when they are physically removed from the queue.</p>
<p class="subhead1"><a id="CHDEDCCI"></a><a id="ADQUE2476"></a><a id="sthref158"></a><a id="sthref159"></a><a id="sthref160"></a><a id="sthref161"></a><a id="sthref162"></a><a id="sthref163"></a>Navigation of Messages in Dequeuing</p>
<p>You have several options for selecting a message from a queue. You can select the first message with the <code>FIRST_MESSAGE</code> navigation option. Alternatively, once you have selected a message and established its position in the queue, you can then retrieve the next message with the <code>NEXT_MESSAGE</code> navigation option.</p>
<p>The <code>FIRST_MESSAGE</code> navigation option performs a <code>SELECT</code> on the queue. The <code>NEXT_MESSAGE</code> navigation option fetches from the results of the <code>SELECT</code> run in the <code>FIRST_MESSAGE</code> navigation. Thus performance is optimized because subsequent dequeues need not run the entire <code>SELECT</code> again.</p>
<p>If the queue is enabled for transactional grouping, then the navigation options work in a slightly different way. If <code>FIRST_MESSAGE</code> is requested, then the dequeue position is still reset to the beginning of the queue. But if <code>NEXT_MESSAGE</code> is requested, then the position is set to the next message in the same <span class="italic">transaction</span>. Transactional grouping also offers a <code>NEXT_TRANSACTION</code> option. It sets the dequeue position to the first message of the next transaction.</p>
<p><a id="sthref164"></a><a id="sthref165"></a>Transaction grouping has no effect if you dequeue by specifying a correlation identifier or message identifier, or if you dequeue some of the messages of a transaction and then commit.</p>
<p>If you reach the end of the queue while using the <code>NEXT_MESSAGE</code> or <code>NEXT_TRANSACTION</code> option, and you have specified a nonzero wait time, then the navigating position is automatically changed to the beginning of the queue. If a zero wait time is specified, then you can get an exception when the end of the queue is reached.</p>
<p class="subhead1"><a id="CHDCBGHJ"></a><a id="ADQUE2477"></a><a id="sthref166"></a><a id="sthref167"></a><a id="sthref168"></a><a id="sthref169"></a>Waiting for Messages</p>
<p>Oracle Database Advanced Queuing allows applications to block on one or more queues waiting for the arrival of either a newly enqueued message or a message that becomes ready. You can use the <code>DEQUEUE</code> operation to wait for the arrival of a message in a single queue or the <code>LISTEN</code> operation to wait for the arrival of a message in more than one queue.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Applications can also perform a blocking dequeue on exception queues to wait for arrival of <code>EXPIRED</code> messages.</div>
<p>When the blocking <code>DEQUEUE</code> call returns, it returns the message properties and the message payload. When the blocking <code>LISTEN</code> call returns, it discloses only the name of the queue where a message has arrived. A subsequent <code>DEQUEUE</code> operation is needed to dequeue the message.</p>
<p>When there are messages for multiple agents in the agent list, <code>LISTEN</code> returns with the first agent for whom there is a message. To prevent one agent from starving other agents for messages, the application can change the order of the agents in the agent list.</p>
<p>Applications can optionally specify a timeout of zero or more seconds to indicate the time that Oracle Database Advanced Queuing must wait for the arrival of a message. The default is to wait forever until a message arrives in the queue. This removes the burden of continually polling for messages from the application, and it saves CPU and network resources because the application remains blocked until a new message is enqueued or becomes <code>READY</code> after its <code>DELAY</code> time.</p>
<p>An application that is blocked on a dequeue is either awakened directly by the enqueuer if the new message has no <code>DELAY</code> or is awakened by the queue monitor process when the <code>DELAY</code> or <code>EXPIRATION</code> time has passed. If an application is waiting for the arrival of a message in a remote queue, then the Oracle Database Advanced Queuing propagator wakes up the blocked dequeuer after a message has been propagated.</p>
<p class="subhead1"><a id="CHDFCFEA"></a><a id="ADQUE2478"></a><a id="sthref170"></a><a id="sthref171"></a><a id="sthref172"></a><a id="sthref173"></a>Retries with Delays</p>
<p>If the transaction dequeuing a message from a queue fails, then it is regarded as an unsuccessful attempt to consume the message. Oracle Database Advanced Queuing records the number of failed attempts to consume the message in the message history. Applications can query the <code>RETRY_COUNT</code> column of the queue table view to find out the number of unsuccessful attempts on a message. In addition, Oracle Database Advanced Queuing allows the application to specify, at the queue level, the maximum number of retries for messages in the queue. The default value for maximum retries is 5. If the number of failed attempts to remove a message exceeds this number, then the message is moved to the exception queue and is no longer available to applications.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a dequeue transaction fails because the server process dies (including <code>ALTER</code> <code>SYSTEM</code> <code>KILL</code> <code>SESSION</code>) or <code>SHUTDOWN</code> <code>ABORT</code> on the instance, then <code>RETRY_COUNT</code> is not incremented.</div>
<p>A bad condition can cause the transaction receiving a message to end. Oracle Database Advanced Queuing allows users to hide the bad message for a specified retry delay interval, during which it is in the WAITING state. After the retry delay, the failed message is again available for dequeue. The Oracle Database Advanced Queuing time manager enforces the retry delay property. The default value for retry delay is 0.</p>
<p><a id="sthref174"></a>If multiple sessions are dequeuing messages from a queue simultaneously, then <code>RETRY_COUNT</code> information might not always be updated correctly. If session one dequeues a message and rolls back the transaction, then Oracle Database AQ notes that the <code>RETRY_COUNT</code> information for this message must be updated. However <code>RETRY_COUNT</code> cannot be incremented until session one completes the rollback. If session two attempts to dequeue the same message after session one has completed the rollback but before it has incremented <code>RETRY_COUNT</code>, then the dequeue by session two succeeds. When session one attempts to increment <code>RETRY_COUNT</code>, it finds that the message is locked by session two and <code>RETRY_COUNT</code> is not incremented. A trace file is then generated in the <code>USER_DUMP_DESTINATION</code> for the instance with the following message:</p>
<pre>Error on rollback: ORA-25263: no message in queue <span class="italic">schema.qname</span> with message ID ...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Maximum retries and retry delay are not available with 8.0-style multiconsumer queues.
<p>Queues created in a queue table with <code>compatible</code> set to <code>8.0</code> (referred to in this guide as 8.0-style queues) are deprecated in Oracle Database Advanced Queuing 10<span class="italic">g</span> Release 2 (10.2). Oracle recommends that any new queues you create be 8.1-style or newer and that you migrate existing 8.0-style queues at your earliest convenience.</p>
</div>
<p class="subhead1"><a id="CHDBAEED"></a><a id="ADQUE2479"></a><a id="sthref175"></a><a id="sthref176"></a><a id="sthref177"></a>Optional Transaction Protection</p>
<p>Enqueue and dequeue requests are usually part of a transaction that contains the requests, thereby providing the wanted <a href="glossary.htm#CBACAHAA"><span class="xrefglossterm">transactional</span></a> action. You can, however, specify that a specific request is a transaction by itself, making the result of that request immediately visible to other transactions. This means that messages can be made visible to the external world when the enqueue or dequeue statement is applied or after the transaction is committed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Transaction protection is not supported for buffered messaging.</div>
<p class="subhead1"><a id="CHDICJFH"></a><a id="ADQUE0104"></a><a id="sthref178"></a><a id="sthref179"></a><a id="sthref180"></a><a id="sthref181"></a>Exception Queues</p>
<p>An exception queue is a repository for expired or unserviceable messages. Applications cannot directly enqueue into exception queues. Also, a multiconsumer exception queue cannot have subscribers associated with it. However, an application that intends to handle these expired or unserviceable messages can dequeue them exactly once from the exception queue using remove mode. The consumer name specified while dequeuing should be null. Messages can also be dequeued from the exception queue by specifying the message identifier.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Expired or unserviceable buffered messages are moved to an exception queue as persistent messages.
<p>Messages intended for single-consumer queues, or for 8.0-style multiconsumer queues, can only be dequeued by their message identifiers once the messages have been moved to an exception queue.</p>
<p>Queues created in a queue table with <code>compatible</code> set to <code>8.0</code> (referred to in this guide as 8.0-style queues) are deprecated in Oracle Database Advanced Queuing 10<span class="italic">g</span> Release 2 (10.2). Oracle recommends that any new queues you create be 8.1-style or newer and that you migrate existing 8.0-style queues at your earliest convenience.</p>
</div>
<p>After a message has been moved to an exception queue, there is no way to identify which queue the message resided in before moving to the exception queue. If this information is important, then the application must save this information in the message itself.</p>
<p>The exception queue is a message property that can be specified during enqueue time. If an exception queue is not specified, then a default exception queue is used. The default exception queue is automatically created when the queue table is created.</p>
<p>A message is moved to an exception queue under the following conditions:</p>
<ul>
<li>
<p>It was not dequeued within the specified expiration interval.</p>
<p>For a message intended for multiple recipients, the message is moved to the exception queue if one or more of the intended recipients was not able to dequeue the message within the specified expiration interval. The default expiration interval is never, meaning the messages does not expire.</p>
</li>
<li>
<p>The message was dequeued successfully, but the application that dequeued it rolled back the transaction because of an error that arose while processing the message. If the message has been dequeued but rolled back more than the number of times specified by the retry limit, then the message is moved to the exception queue.</p>
<p>For a message intended for multiple recipients, a separate retry count is kept for each recipient. The message is moved to the exception queue only when retry counts for all recipients of the message have exceeded the specified retry limit.</p>
<p>The default retry limit is five for single-consumer queues and 8.1-style multiconsumer queues. No retry limit is supported for 8.0-style multiconsumer queues, which are deprecated in Oracle Database Advanced Queuing 10<span class="italic">g</span> Release 2 (10.2).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a dequeue transaction fails because the server process dies (including <code>ALTER</code> <code>SYSTEM</code> <code>KILL</code> <code>SESSION</code>) or <code>SHUTDOWN</code> <code>ABORT</code> on the instance, then <code>RETRY_COUNT</code> is not incremented.</div>
</li>
<li>
<p>The statement processed by the client contains a dequeue that succeeded but the statement itself was undone later due to an exception.</p>
<p>If the dequeue procedure succeeds but the PL/SQL procedure raises an exception, then Oracle Database Advanced Queuing increments the retry count of the message returned by the dequeue procedure.</p>
</li>
<li>
<p>The client program successfully dequeued a message but terminated before committing the transaction.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDCEFBD"></a>
<div id="ADQUE2480" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref182"></a><a id="sthref183"></a><a id="sthref184"></a>Propagation Features</h2>
<p>Messages can be propagated from one queue to another, allowing applications to communicate with each other without being connected to the same database or to the same queue. The destination queue can be located in the same database or in a remote database.</p>
<p>Propagation enables you to fan out messages to a large number of recipients without requiring them all to dequeue messages from a single queue. You can also use propagation to combine messages from different queues into a single queue. This is known as compositing or funneling messages.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can propagate messages from a multiconsumer queue to a single-consumer queue. Propagation from a single-consumer queue to a multiconsumer queue is not possible.</div>
<p>A message is marked as processed in the source queue immediately after the message has been propagated, even if the consumer has not dequeued the message at the remote queue. Similarly, when a propagated message expires at the remote queue, the message is moved to the exception queue of the remote queue, and not to the exception queue of the local queue. Oracle Database Advanced Queuing does not currently propagate the exceptions to the source queue.</p>
<p>To enable propagation, one or more subscribers are defined for the queue from which messages are to be propagated and a schedule is defined for each destination where messages are to be propagated from the queue.</p>
<p>Oracle Database Advanced Queuing automatically checks if the type of the remote queue is structurally equivalent to the type of the local queue within the context of the character sets in which they are created. Messages enqueued in the source queue are then propagated and automatically available for dequeuing at the destination queue or queues.</p>
<p>When messages arrive at the destination queues, sessions based on the source queue schema name are used for enqueuing the newly arrived messages into the destination queues. This means that you must grant schemas of the source queues enqueue privileges to the destination queues.</p>
<p>Propagation runs as an Oracle Scheduler job. A background process, the <code>JOB_QUEUE_PROCESS</code> will run the job. Propagation scheduling may be a dedicated process, running continuously and without end, or it may be event driven, in which case it runs only if there is a message to be propagated.</p>
<p>Oracle Database Advanced Queuing offers two kinds of propagation:</p>
<ul>
<li>
<p>Queue-to-dblink propagation</p>
</li>
<li>
<p>Queue-to-queue propagation</p>
</li>
</ul>
<p><a id="sthref185"></a>Queue-to-dblink propagation delivers messages or events from the source queue to all subscribing queues at the destination database identified by the dblink.</p>
<p>A single propagation schedule is used to propagate messages to all subscribing queues. Hence any changes made to this schedule will affect message delivery to all the subscribing queues.</p>
<p><a id="sthref186"></a>Queue-to-queue propagation delivers messages or events from the source queue to a specific destination queue identified on the dblink. This allows the user to have fine-grained control on the propagation schedule for message delivery.</p>
<p>This new propagation mode also supports transparent failover when propagating to a destination Oracle RAC system. With queue-to-queue propagation, you are no longer required to re-point a database link if the owner instance of the queue fails on Oracle RAC.</p>
<p>Oracle Database Advanced Queuing provides detailed statistics about the messages propagated and the schedule itself. This information can be used to tune propagation schedules for best performance.</p>
<p class="subhead1"><a id="CHDDDHDF"></a><a id="ADQUE2481"></a><a id="sthref187"></a><a id="sthref188"></a><a id="sthref189"></a>Remote Consumers</p>
<p>Consumers of a message in multiconsumer queues can be local or remote. Local consumers dequeue messages from the same queues into which the producer enqueued the messages. Local consumers have a name but no address or protocol in their agent descriptions.</p>
<p>Remote consumers dequeue from queues that are different from the queues where the messages were enqueued. Remote consumers fall into three categories:</p>
<ul>
<li>
<p>The address refers to a queue in the same database.</p>
<p>In this case the consumer dequeues the message from a different queue in the same database. These addresses are of the form <code>[schema]</code>.<code>queue_name</code>. If the schema is not specified, then the schema of the current user is used.</p>
</li>
<li>
<p>The address refers to a queue in a different database.</p>
<p>In this case the database must be reachable using database links and the protocol must be either <code>NULL</code> or 0. These addresses are of the form <code>[schema]</code>.<code>queue_name@dblink</code>. If the schema is not specified, then the schema of the current user is used. If the database link does not have a domain name specified, then the default domain as specified by the <code>DB_DOMAIN</code> <code>init</code>.<code>ora</code> parameter is used.</p>
</li>
<li>
<p>The address refers to a destination that can be reached by a third party protocol.</p>
<p>You must refer to the documentation of the third party software to determine how to specify the address and the protocol database link and schedule propagation.</p>
</li>
</ul>
<p class="subhead2"><a id="ADQUE2482"></a>Propagation to Remote Subscribers</p>
<p>Oracle Database Advanced Queuing validates the database link specified in a propagation schedule when the schedule runs, but not when the schedule is created. It is possible, therefore, to create a queue-to-dblink or queue-to-queue propagation before creating its associated database link. Also, the propagation schedule is not disabled if you remove the database link.</p>
<p>Oracle Database AQ offers two kinds of propagation:</p>
<p>A) <span class="bold">Queue-to-dblink propagation</span> - specified by providing a (source) queue and (destination) databaselink. Messages from the source queue for any queues at the destination specified by the dblink will be handled by this propagation.</p>
<p>In this scenario, we cannot have multiple propagations from a source queue, with dblinks connecting to the same database. Thus(q1, dblink1) and (q1, dblink2) cannot coexist if both dblinks connect to the same database. However (q1, dblink1) and (q2, dblink1) OR (q1, dblink1) and (q2, dblink2) can coexist as source queues are different.</p>
<p>B) <span class="bold">Queue-to-queue propagation</span> - specified by providing a (source) queue, (destination) dblink and (destination) queue. Messages from the source queue for the indicated queue at the destination dblink will be handled by this propagation. Here, either (q1, dblink1, dq1), (q1, dblink1, dq2) OR (q1, dblink1, dq1), (q1, dblink2, dq2) succeeds. This strategy works because the destination queues are different even though source queue is the same and dblink connects to the same database.</p>
<p>In this scenario, we cannot have multiple propagations between a source queue, destination queue, even if using different dblinks: (q1, dblink1, q2) and (q1, dblink2, q2) cannot coexist, if dblink1 and dblink2 are pointing to the same database.</p>
<p class="subhead1"><a id="ADQUE2483"></a><a id="sthref190"></a><a id="sthref191"></a><a id="sthref192"></a><a id="sthref193"></a><a id="sthref194"></a>Priority and Ordering of Messages in Propagation</p>
<p>The delay, expiration, and priority parameters apply identically to both local and remote consumers in both queue-to-dblink and queue-to-queue propagation. Oracle Database Advanced Queuing accounts for any delay in propagation by adjusting the delay and expiration parameters accordingly. For example, if expiration is set to one hour, and the message is propagated after 15 minutes, then the expiration at the remote queue is set to 45 minutes.</p>
<p class="subhead1"><a id="CHDECECJ"></a><a id="ADQUE2484"></a><a id="sthref195"></a><a id="sthref196"></a><a id="sthref197"></a><a id="sthref198"></a>Inboxes and Outboxes</p>
<p><a href="#CHDHCDCH">Figure 1-9</a> illustrates applications on different databases communicating using Oracle Database Advanced Queuing. Each application has an inbox for handling incoming messages and an outbox for handling outgoing messages. Whenever an application enqueues a message, it goes into its outbox regardless of the message destination. Similarly, an application dequeues messages from its inbox no matter where the message originates.</p>
<div id="ADQUE2485" class="figure">
<p class="titleinfigure"><a id="CHDHCDCH"></a>Figure 1-9 Message Propagation in Oracle Database Advanced Queuing</p>
<img width="400" height="592" src="img/adque042.gif" alt="Description of Figure 1-9 follows"/><br/>
<a id="sthref199" href="img_text/adque042.htm">Description of &#34;Figure 1-9 Message Propagation in Oracle Database Advanced Queuing&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p class="subhead1"><a id="CHDEEIGG"></a><a id="ADQUE2486"></a><a id="sthref200"></a><a id="sthref201"></a><a id="sthref202"></a>Propagation Scheduling</p>
<p><a id="sthref203"></a><a id="sthref204"></a>A queue-to-dblink propagation schedule is defined for a pair of source and destination database links. A queue-to-queue propagation schedule is defined for a pair of source and destination queues. If a queue has messages to be propagated to several queues, then a schedule must be defined for each of the destination queues. With queue-to-dblink propagation, all schedules for a particular remote database have the same frequency. With queue-to-queue propagation, the frequency of each schedule can be adjusted independently of the others</p>
<p>A schedule indicates the time frame during which messages can be propagated from the source queue. This time frame can depend on several factors such as network traffic, load at the source database, and load at the destination database. If the duration is unspecified, then the time frame is an infinite single window. If a window must be repeated periodically, then a finite duration is specified along with a <code>NEXT_TIME</code> function that defines the periodic interval between successive windows.</p>
<p>When a schedule is created, a job is automatically submitted to the job queue facility to handle propagation.</p>
<p><a id="sthref205"></a>The propagation schedules defined for a queue can be changed or dropped at any time during the life of the queue. You can also temporarily disable a schedule instead of dropping it. All administrative calls can be made irrespective of whether the schedule is active or not. If a schedule is active, then it takes a few seconds for the calls to be processed.</p>
<p class="subhead1"><a id="CHDBIJGH"></a><a id="ADQUE2487"></a><a id="sthref206"></a><a id="sthref207"></a><a id="sthref208"></a>Propagation of Messages with LOBs</p>
<p>Large Objects can be propagated using Oracle Database Advanced Queuing using two methods:</p>
<ul>
<li>
<p>Propagation from <code>RAW</code> queues</p>
<p>In <code>RAW</code> queues the message payload is stored as a BLOB. This allows users to store up to 32KB of data when using the PL/SQL interface and as much data as can be contiguously allocated by the client when using OCI. This method is supported by all releases after 8.0.4 inclusive.</p>
</li>
<li>
<p>Propagation from object queues with LOB attributes</p>
<p>The user can populate the <code>LOB</code> and read from the <code>LOB</code> using Oracle Database <code>LOB</code> handling routines. The <code>LOB</code> attributes can be <code>BLOB</code>s or <code>CLOB</code>s (not NCLOBs). If the attribute is a <code>CLOB</code>, then Oracle Database Advanced Queuing automatically performs any necessary character set conversion between the source queue and the destination queue. This method is supported by all releases from 8.1.3 inclusive.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Payloads containing LOBs require users to grant explicit <code>Select</code>, <code>Insert</code> and <code>Update</code> privileges on the queue table for doing enqueues and dequeues.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a></div>
</li>
</ul>
<p class="subhead1"><a id="CHDGBBCG"></a><a id="ADQUE2488"></a><a id="sthref209"></a><a id="sthref210"></a><a id="sthref211"></a>Propagation Statistics</p>
<p>Detailed runtime information about propagation is gathered and stored in the <code>DBA_QUEUE_SCHEDULES</code> view for each propagation schedule. This information can be used by queue designers and administrators to fix problems or tune performance. Similarly, errors reported by the view can be used to diagnose and fix problems. The view also describes additional information such as the session ID of the session handling the propagation and the process name of the job queue process handling the propagation.</p>
<p>For each schedule, detailed propagation statistics are maintained:</p>
<ul>
<li>
<p>Total number of messages propagated in a schedule</p>
</li>
<li>
<p>Total number of bytes propagated in a schedule</p>
</li>
<li>
<p>Maximum number of messages propagated in a window</p>
</li>
<li>
<p>Maximum number of bytes propagated in a window</p>
</li>
<li>
<p>Average number of messages propagated in a window</p>
</li>
<li>
<p>Average size of propagated messages</p>
</li>
<li>
<p>Average time to propagated a message</p>
</li>
</ul>
<p class="subhead1"><a id="ADQUE2489"></a><a id="sthref212"></a><a id="sthref213"></a><a id="sthref214"></a>Propagation Error Handling</p>
<p>Propagation has built-in support for handling failures and reporting errors. For example, if the specified database link is invalid, if the remote database is unavailable, or if the remote queue is not enabled for enqueuing, then the appropriate error message is reported. Propagation uses a linear backoff scheme for retrying propagation from a schedule that encountered a failure.</p>
<p>If a schedule continuously encounters failures, then the first retry happens after 30 seconds, the second after 60 seconds, the third after 120 seconds and so forth. If the retry time is beyond the expiration time of the current window, then the next retry is attempted at the start time of the next window. A maximum of 16 retry attempts is made, after which the schedule is automatically disabled.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Once a retry attempt slips to the next propagation window, it will always do so; the exponential backoff scheme no longer governs retry scheduling. If the date function specified in the <code>next_time</code> parameter of <code>DBMS_AQADM.SCHEDULE_PROPAGATION</code> results in a short interval between windows, then the number of unsuccessful retry attempts can quickly reach 16, disabling the schedule.</div>
<p>When a schedule is disabled automatically due to failures, the relevant information is written into the alert log. A check for scheduling failures indicates:</p>
<ul>
<li>
<p>How many successive failures were encountered</p>
</li>
<li>
<p>The error message indicating the cause for the failure</p>
</li>
<li>
<p>The time at which the last failure was encountered</p>
</li>
</ul>
<p>By examining this information, a queue administrator can fix the failure and enable the schedule. If propagation is successful during a retry, then the number of failures is reset to 0.</p>
<p>In some situations that indicate application errors in queue-to-dblink propagations, Oracle Database Advanced Queuing marks messages as <code>UNDELIVERABLE</code> and logs a message in <code>alert.log</code>. Examples of such errors are when the remote queue does not exist or when there is a type mismatch between the source queue and the remote queue. The trace files in the <code>background_dump_dest</code> directory can provide additional information about the error.</p>
<p><a id="sthref215"></a>When a new job queue process starts, it clears the mismatched type errors so the types can be reverified. If you have capped the number of job queue processes and propagation remains busy, then you might not want to wait for the job queue process to terminate and restart. Queue types can be reverified at any time using <code>DBMS_AQADM.VERIFY_QUEUE_TYPES</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When a type mismatch is detected in queue-to-queue propagation, propagation stops and throws an error. In such situations you must query the <code>DBA_SCHEDULES</code> view to determine the last error that occurred during propagation to a particular destination. The message is not marked as <code>UNDELIVERABLE</code>.</div>
<p class="subhead1"><a id="CHDIIDBJ"></a><a id="ADQUE2490"></a><a id="sthref216"></a><a id="sthref217"></a><a id="sthref218"></a>Propagation with Oracle Real Application Clusters</p>
<p>Propagation has support built-in for Oracle Real Application Clusters. It is transparent to the user and the queue administrator. The job that handles propagation is submitted to the same instance as the owner of the queue table where the queue resides.</p>
<p>If there is a failure at an instance and the queue table that stores the source queue is migrated to a different instance, then the propagation job is also migrated to the new instance. This minimizes pinging between instances and thus offers better performance.</p>
<p><a id="sthref219"></a><a id="sthref220"></a>The destination can be identified by a database link or by destination queue name. Specifying the destination database results in queue-to-dblink propagation. If you propagate messages to several queues in another database, then all queue-to-dblink propagations to that database have the same frequency. Specifying the destination queue name results in queue-to-queue propagation, a new feature in Oracle Database Advanced Queuing 10<span class="italic">g</span> Release 2 (10.2). If you propagate messages to several queues in another database, then queue-to-queue propagation enables you to adjust the frequency of each schedule independently of the others. You can even enable or disable individual propagations.</p>
<p>This new queue-to-queue propagation mode also supports transparent failover when propagating to a destination Oracle RAC system. With queue-to-queue propagation, you are no longer required to re-point a database link if the owner instance of the queue fails on Oracle RAC.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="aq_admin.htm#i1006952">&#34;Scheduling a Queue Propagation&#34;</a> for more information on queue-to-queue propagation</div>
<p>Propagation has been designed to handle any number of concurrent schedules. The number of job queue processes is limited to a maximum of 1000, and some of these can be used to handle jobs unrelated to propagation. Hence, propagation has built-in support for multitasking and load balancing.</p>
<p>The propagation algorithms are designed such that multiple schedules can be handled by a single job queue process. The propagation load on a job queue process can be skewed based on the arrival rate of messages in the different source queues.</p>
<p>If one process is overburdened with several active schedules while another is less loaded with many passive schedules, then propagation automatically redistributes the schedules so they are loaded uniformly.</p>
<p class="subhead1"><a id="CHDBEGHA"></a><a id="ADQUE2491"></a><a id="sthref221"></a><a id="sthref222"></a>Third-Party Support</p>
<p>If the protocol number for a recipient is in the range 128 - 255, then the address of the recipient is not interpreted by Oracle Database Advanced Queuing and the message is not propagated by the Oracle Database Advanced Queuing system. Instead, a third-party propagator can dequeue the message by specifying a reserved consumer name in the dequeue operation. The reserved consumer names are of the form <code>AQ$_P</code><code><span class="codeinlineitalic">protocol_number</span></code>. For example, the consumer name <code>AQ$_P128</code> can be used to dequeue messages for recipients with protocol number 128. The list of recipients for a message with the specific protocol number is returned in the <code>recipient_list</code> message property on dequeue.</p>
<p>Another way for Oracle Database Advanced Queuing to propagate messages to and from third-party messaging systems is through Messaging Gateway. Messaging Gateway dequeues messages from an Oracle Database Advanced Queuing queue and guarantees delivery to supported third-party messaging systems. Messaging Gateway can also dequeue messages from these systems and enqueue them to an Oracle Database Advanced Queuing queue.</p>
<p class="subhead1"><a id="CHDDGAII"></a><a id="ADQUE2492"></a><a id="sthref223"></a><a id="sthref224"></a><a id="sthref225"></a>Propagation Using HTTP</p>
<p>In Oracle Database 10<span class="italic">g</span> you can set up Oracle Database Advanced Queuing propagation over HTTP and HTTPS (HTTP over SSL). HTTP propagation uses the Internet access infrastructure and requires that the Oracle Database Advanced Queuing servlet that connects to the destination database be deployed. The database link must be created with the connect string indicating the Web server address and port and indicating HTTP as the protocol. The source database must be created for running Java and XML. Otherwise, the setup for HTTP propagation is more or less the same as Oracle Net Services propagation.</p>
</div>
<!-- class="sect1" -->
<a id="i1010261"></a>
<div id="ADQUE2493" class="sect1">
<h2 class="sect1"><a id="sthref226"></a><a id="sthref227"></a><a id="sthref228"></a>Message Format Transformation</h2>
<p>Applications often use data in different formats. A <a href="glossary.htm#CBACGHDB"><span class="xrefglossterm">transformation</span></a> defines a mapping from one Oracle data type to another. The transformation is represented by a SQL function that takes the source data type as input and returns an object of the target data type. Only one-to-one message transformations are supported.</p>
<p>To transform a message during enqueue, specify a mapping in the enqueue options. To transform a message during dequeue, specify a mapping either in the dequeue options or when you add a subscriber. A dequeue mapping overrides a subscriber mapping. To transform a message during propagation, specify a mapping when you add a subscriber.</p>
<p>You can create transformations by creating a single PL/SQL function or by creating an expression for each target type attribute. The PL/SQL function returns an object of the target type or the constructor of the target type. This representation is preferable for simple transformations or those not easily broken down into independent transformations for each attribute.</p>
<p>Creating a separate expression specified for each attribute of the target type simplifies transformation mapping creation and management for individual attributes of the destination type. It is useful when the destination type has many attributes.</p>
<p>As <a href="#i1008572">Figure 1-10</a> shows, queuing, routing, and transformation are essential building blocks to an integrated application architecture. The figure shows how data from the Out queue of a CRM application is routed and transformed in the integration hub and then propagated to the In queue of the Web application. The transformation engine maps the message from the format of the Out queue to the format of the In queue.</p>
<div id="ADQUE2494" class="figure">
<p class="titleinfigure"><a id="i1008572"></a>Figure 1-10 Transformations in Application Integration</p>
<img width="600" height="76" src="img/adque448.gif" alt="Description of Figure 1-10 follows"/><br/>
<a id="sthref229" href="img_text/adque448.htm">Description of &#34;Figure 1-10 Transformations in Application Integration&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p class="subhead1"><a id="ADQUE2495"></a><a id="sthref230"></a><a id="sthref231"></a><a id="sthref232"></a>XML Data Transformation</p>
<p>You can transform XML data using the <code>extract()</code> method supported on <code>XMLType</code> to return an object of <code>XMLType</code> after applying the supplied <code>XPath</code> expression. You can also create a PL/SQL function that transforms the <code>XMLType</code> object by applying an XSLT transformation to it, using the package <code>XSLPROCESSOR</code>.</p>
</div>
<!-- class="sect1" -->
<a id="CHDJCFBI"></a>
<div id="ADQUE2496" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Other Oracle Database Advanced Queuing Features</h2>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#CHDHCDAH">Queue Monitor Coordinator</a></p>
</li>
<li>
<p><a href="#CHDCAFEJ">Integration with Oracle Internet Directory</a></p>
</li>
<li>
<p><a href="#CHDIHIHF">Integration with Oracle Enterprise Manager</a></p>
</li>
<li>
<p><a href="#CHDJHHHI">Retention and Message History</a></p>
</li>
<li>
<p><a href="#CHDHCGIB">Cleaning Up Message Queues</a></p>
</li>
<li>
<p><a href="#CHDIGIDI">Tracking and Event Journals</a></p>
</li>
<li>
<p><a href="#CHDBGIGB">Non-repudiation</a></p>
</li>
<li>
<p><a href="#CHDDEDHD">Internet Integration</a></p>
</li>
</ul>
<p class="subhead1"><a id="CHDHCDAH"></a><a id="ADQUE2497"></a><a id="sthref233"></a><a id="sthref234"></a>Queue Monitor Coordinator</p>
<p>Before 10<span class="italic">g</span> Release 1 (10.1), the Oracle Database Advanced Queuing time manager process was called queue monitor (<code>QMNn</code>), a background process controlled by setting the dynamic <code>init.ora</code> parameter <code>AQ_TM_PROCESSES</code>. Beginning with 10<span class="italic">g</span> Release 1 (10.1), time management and many other background processes are automatically controlled by a coordinator-slave architecture called Queue Monitor Coordinator (<code>QMNC</code>). <code>QMNC</code> dynamically spawns slaves named <code>qXXX depending</code> on the system load. The slaves provide mechanisms for:</p>
<ul>
<li>
<p>Message delay</p>
</li>
<li>
<p>Message expiration</p>
</li>
<li>
<p>Retry delay</p>
</li>
<li>
<p>Garbage collection for the queue table</p>
</li>
<li>
<p>Memory management tasks for buffered messages</p>
</li>
</ul>
<p>Because the number of processes is determined automatically and tuned constantly, you are saved the trouble of setting it with <code>AQ_TM_PROCESSES</code>.</p>
<p>Although it is no longer necessary to set <code>init.ora</code> parameter <code>AQ_TM_PROCESSES</code>, it is still supported. If you do set it (up to a maximum of 40), then QMNC still autotunes the number of processes. But you are guaranteed at least the set number of processes for persistent queues. Processes for a <a href="glossary.htm#CBAEHBDD"><span class="xrefglossterm">buffered queue</span></a> and other Oracle Streams tasks, however, are not affected by this parameter.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you want to disable the Queue Monitor Coordinator, then you must set <code>AQ_TM_PROCESSES = 0</code> in your <code>pfile</code> or <code>spfile</code>. Oracle strongly recommends that you do NOT set <code>AQ_TM_PROCESSES = 0</code>. If you are using Oracle Streams, setting this parameter to zero (which Oracle Database respects no matter what) can cause serious problems.</div>
<p class="subhead1"><a id="CHDCAFEJ"></a><a id="ADQUE2498"></a><a id="sthref235"></a>Integration with Oracle Internet Directory</p>
<p>Oracle Internet Directory is a native LDAPv3 directory service built on Oracle Database that centralizes a wide variety of information, including e-mail addresses, telephone numbers, passwords, security certificates, and configuration data for many types of networked devices. You can look up enterprise-wide queuing information&mdash;queues, subscriptions, and events&mdash;from one location, the Oracle Internet Directory. Refer to the <a class="olink OIDAG" href="http://www.oracle.com/pls/topic/lookup?ctx=E50529-01&amp;id=OIDAG"><span class="italic">Oracle Fusion Middleware Administrator&#39;s Guide for Oracle Internet Directory</span></a> for more information.</p>
<p class="subhead1"><a id="CHDIHIHF"></a><a id="ADQUE2499"></a><a id="sthref236"></a>Integration with Oracle Enterprise Manager</p>
<p>You can use Oracle Enterprise Manager to:</p>
<ul>
<li>
<p>Create and manage queues, queue tables, propagation schedules, and transformations</p>
</li>
<li>
<p>Monitor your Oracle Database Advanced Queuing environment using its topology at the database and queue levels, and by viewing queue errors and queue and session statistics</p>
</li>
</ul>
<p class="subhead1"><a id="CHDJHHHI"></a><a id="ADQUE2500"></a><a id="sthref237"></a><a id="sthref238"></a>Retention and Message History</p>
<p>The systems administrator specifies the retention duration to retain messages after consumption. Oracle Database Advanced Queuing stores information about the history of each message, preserving the queue and message properties of delay, expiration, and retention for messages destined for local or remote receivers. The information contains the enqueue and dequeue times and the identification of the transaction that executed each request. This allows users to keep a history of relevant messages. The history can be used for tracking, data warehouse, data mining operations, and, also specific auditing functions.</p>
<p>Message retention is not supported for buffered messaging.</p>
<p class="subhead1"><a id="CHDHCGIB"></a><a id="ADQUE2501"></a><a id="sthref239"></a>Cleaning Up Message Queues</p>
<p>The Oracle Database Advanced Queuing retention feature can be used to automatically clean up messages after the user-specified duration after consumption.</p>
<p>If messages are accidentally inserted into a queue for the wrong subscriber, you can dequeue them with the subscriber name or by message identifier. This consumes the messages, which are cleaned up after their retention time expires.</p>
<p>To clean up messages for a particular subscriber, you can remove the subscriber and add the subscriber again. Removing the subscriber removes all the messages for that subscriber.</p>
<p class="subhead1"><a id="CHDIGIDI"></a><a id="ADQUE2502"></a><a id="sthref240"></a><a id="sthref241"></a>Tracking and Event Journals</p>
<p>Retained messages can be related to each other to form sequences. These sequences represent event journals, which are often constructed by applications. Oracle Database Advanced Queuing is designed to let applications create event journals automatically.</p>
<p class="subhead1"><a id="CHDBGIGB"></a><a id="ADQUE2503"></a><a id="sthref242"></a><a id="sthref243"></a>Non-repudiation</p>
<p>Oracle Database Advanced Queuing maintains the entire history of information about a message along with the message itself. This information serves as proof of sending and receiving of messages and can be used for non-repudiation of the sender and non-repudiation of the receiver.</p>
<p>The following information is kept at enqueue for non-repudiation of the enqueuer:</p>
<ul>
<li>
<p>Oracle Database Advanced Queuing agent doing the enqueue</p>
</li>
<li>
<p>Database user doing the enqueue</p>
</li>
<li>
<p>Enqueue time</p>
</li>
<li>
<p>Transaction ID of the transaction doing enqueue</p>
</li>
</ul>
<p>The following information is kept at dequeue for non-repudiation of the dequeuer:</p>
<ul>
<li>
<p>Oracle Database Advanced Queuing agent doing dequeue</p>
</li>
<li>
<p>Database user doing dequeue</p>
</li>
<li>
<p>Dequeue time</p>
</li>
<li>
<p>Transaction ID of the transaction doing dequeue</p>
</li>
</ul>
<p>After propagation, the <code>ORIGINAL_MSGID</code> field in the destination queue of the propagation corresponds to the message ID of the source message. This field can be used to correlate the propagated messages. This is useful for non-repudiation of the dequeuer of propagated messages.</p>
<p>Stronger non-repudiation can be achieved by enqueuing the digital signature of the sender at the time of enqueue with the message and by storing the digital signature of the dequeuer at the time of dequeue.</p>
<p class="subhead1"><a id="CHDDEDHD"></a><a id="ADQUE2504"></a><a id="sthref244"></a><a id="sthref245"></a>Internet Integration</p>
<p>You can access Oracle Database Advanced Queuing over the Internet by using <a href="glossary.htm#CBABEDEC"><span class="xrefglossterm">Simple Object Access Protocol</span></a> (SOAP). <a href="glossary.htm#CBADFCDG"><span class="xrefglossterm">Internet Data Access Presentation</span></a> (IDAP) is the SOAP specification for Oracle Database Advanced Queuing operations. IDAP defines the XML message structure for the body of the SOAP request.</p>
<p>An IDAP message encapsulates the Oracle Database Advanced Queuing request and response in XML. IDAP is used to perform Oracle Database Advanced Queuing operations such as enqueue, dequeue, send notifications, register for notifications, and propagation over the Internet standard transports&mdash;HTTP(s) and e-mail. In addition, IDAP encapsulates transactions, security, transformation, and the character set ID for requests.</p>
<p>You can create an alias to an Oracle Database Advanced Queuing agent in Oracle Internet Directory and then use the alias in IDAP documents sent over the Internet to perform Oracle Database Advanced Queuing operations. Using aliases prevents exposing the internal name of the Oracle Database Advanced Queuing agent.</p>
<p><a href="#i1009521">Figure 1-11</a> shows the architecture for performing Oracle Database Advanced Queuing operations over HTTP. The major components are:</p>
<ul>
<li>
<p>Oracle Database Advanced Queuing client program</p>
</li>
<li>
<p>Web server/servlet runner hosting the Oracle Database Advanced Queuing <a href="glossary.htm#CBADJIFE"><span class="xrefglossterm">servlet</span></a></p>
</li>
<li>
<p>Oracle Database server</p>
</li>
</ul>
<p>The Oracle Database Advanced Queuing client program sends XML messages (conforming to IDAP) to the Oracle Database Advanced Queuing servlet, which understands the XML message and performs Oracle Database Advanced Queuing operations. Any HTTP client, a Web browser for example, can be used. The Web server/servlet runner hosting the Oracle Database Advanced Queuing servlet, Apache/Jserv or Tomcat for example, interprets the incoming XML messages. The Oracle Database Advanced Queuing servlet connects to the Oracle Database server and performs operations on user queues.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This feature is certified to work with Apache, along with the Tomcat or Jserv servlet execution engines. However, the code does not prevent the servlet from working with other Web server and servlet execution engines that support Java Servlet 2.0 or higher interfaces.</div>
<div id="ADQUE2505" class="figure">
<p class="titleinfigure"><a id="i1009521"></a>Figure 1-11 Architecture for Performing Oracle Database Advanced Queuing Operations Using HTTP</p>
<img width="509" height="156" src="img/adque430.gif" alt="Description of Figure 1-11 follows"/><br/>
<a id="sthref246" href="img_text/adque430.htm">Description of &#34;Figure 1-11 Architecture for Performing Oracle Database Advanced Queuing Operations Using HTTP&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect1" -->
<a id="i1009241"></a>
<div id="ADQUE2506" class="sect1">
<h2 class="sect1"><a id="sthref247"></a><a id="sthref248"></a>Interfaces to Oracle Database Advanced Queuing</h2>
<p>You can access Oracle Database Advanced Queuing functionality through the following interfaces:</p>
<ul>
<li>
<p>PL/SQL using <code>DBMS_AQ</code>, <code>DBMS_AQADM</code>, and <code>DBMS_AQELM</code></p>
</li>
<li>
<p>Java Message Service (JMS) using the <code>oracle.jms</code> Java package</p>
</li>
<li>
<p>Internet access using HTTP(S)</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>oracle.AQ</code> Java package was deprecated in Oracle Database Advanced Queuing 10<span class="italic">g</span> Release 1 (10.1). Oracle recommends that you migrate existing Java AQ applications to Oracle JMS and use Oracle JMS to design your future Java AQ applications.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS" href="../ARPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1006541"></a>
<div id="ADQUE2507" class="sect1">
<h2 class="sect1"><a id="sthref249"></a>Oracle Database Advanced Queuing Demonstrations</h2>
<p>Oracle Database Advanced Queuing demos can be installed from the Oracle Database Companion CD. Once they are installed, you can find them in the <code>$ORACLE_HOME/rdbms/demo</code> directory. Refer to <code>aqxmlREADME.txt</code> and <code>aqjmsREADME.txt</code> in the <code>demo</code> directory for more information.</p>
<p><a href="#CHDFCIDJ">Table 1-1</a> lists and briefly describes the PL/SQL and OCI demos. <a href="#CHDEBDJG">Table 1-2</a> lists and briefly describes the JMS demos. <a href="#CHDGGIJB">Table 1-3</a> lists and briefly describes the XML demos.</p>
<div id="ADQUE2508" class="tblformal">
<p class="titleintable"><a id="sthref250"></a><a id="CHDFCIDJ"></a>Table 1-1 <a id="sthref251"></a>Oracle Database Advanced Queuing Demonstrations</p>
<table class="cellalignment1005" title="Oracle Database Advanced Queuing Demonstrations" summary="This table describes Oracle Streams AQ demos. The first column is the name of the demo, and the second column provides a brief description of it." dir="ltr">
<thead>
<tr class="cellalignment994">
<th class="cellalignment1001" id="r1c1-t46">Demo and Locations</th>
<th class="cellalignment1001" id="r1c2-t46">Topic</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r2c1-t46" headers="r1c1-t46">
<p><code>aqdemo00.sql</code></p>
</td>
<td class="cellalignment1002" headers="r2c1-t46 r1c2-t46">
<p>Create users, message types, and tables</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r3c1-t46" headers="r1c1-t46">
<p><code>aqdemo01.sql</code></p>
</td>
<td class="cellalignment1002" headers="r3c1-t46 r1c2-t46">
<p>Create queue tables, queues, subscribers, and propagation schedule</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r4c1-t46" headers="r1c1-t46">
<p><a id="sthref252"></a><code>aqdemo02.sql</code></p>
</td>
<td class="cellalignment1002" headers="r4c1-t46 r1c2-t46">
<p>Enqueue messages into input queue</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r5c1-t46" headers="r1c1-t46">
<p><code>aqdemo03.sql</code></p>
</td>
<td class="cellalignment1002" headers="r5c1-t46 r1c2-t46">
<p>Install dequeue procedures</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r6c1-t46" headers="r1c1-t46">
<p><a id="sthref253"></a><code>aqdemo04.sql</code></p>
</td>
<td class="cellalignment1002" headers="r6c1-t46 r1c2-t46">
<p>Perform blocking dequeues</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r7c1-t46" headers="r1c1-t46">
<p><a id="sthref254"></a><code>aqdemo05.sql</code></p>
</td>
<td class="cellalignment1002" headers="r7c1-t46 r1c2-t46">
<p>Perform listen for multiple agents</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r8c1-t46" headers="r1c1-t46">
<p><code>aqdemo06.sql</code></p>
</td>
<td class="cellalignment1002" headers="r8c1-t46 r1c2-t46">
<p>Clean up users, queue tables, queues, and subscribers in <code>aqdemo00.sql</code> to <code>aqdemo05.sql</code></p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r9c1-t46" headers="r1c1-t46">
<p><code>aqdemo07.sql</code></p>
</td>
<td class="cellalignment1002" headers="r9c1-t46 r1c2-t46">
<p>Enqueue and dequeue to XMLType queue using XPATH expressions</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r10c1-t46" headers="r1c1-t46">
<p><a id="sthref255"></a><code>aqdemo08.sql</code></p>
</td>
<td class="cellalignment1002" headers="r10c1-t46 r1c2-t46">
<p>Demonstrates server-to-server email notifications with default XML presentation</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r11c1-t46" headers="r1c1-t46">
<p><code>aqdemo09.sql</code></p>
</td>
<td class="cellalignment1002" headers="r11c1-t46 r1c2-t46">
<p>Set up queues and subscribers for array enqueue and dequeue (for OCI array demos also)</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r12c1-t46" headers="r1c1-t46">
<p><a id="sthref256"></a><code>aqdemo10.sql</code></p>
</td>
<td class="cellalignment1002" headers="r12c1-t46 r1c2-t46">
<p>Array enqueue 10 messages</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r13c1-t46" headers="r1c1-t46">
<p><a id="sthref257"></a><code>aqdemo11.sql</code></p>
</td>
<td class="cellalignment1002" headers="r13c1-t46 r1c2-t46">
<p>Array dequeue 10 messages</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r14c1-t46" headers="r1c1-t46">
<p><code>aqdemo12.sql</code></p>
</td>
<td class="cellalignment1002" headers="r14c1-t46 r1c2-t46">
<p>Clean up queues and subscribers for array enqueue and dequeue (for OCI array demos also)</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r15c1-t46" headers="r1c1-t46">
<p><code>ociaqdemo00.c</code></p>
</td>
<td class="cellalignment1002" headers="r15c1-t46 r1c2-t46">
<p>Enqueue messages</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r16c1-t46" headers="r1c1-t46">
<p><code>ociaqdemo01.c</code></p>
</td>
<td class="cellalignment1002" headers="r16c1-t46 r1c2-t46">
<p>Perform blocking dequeues</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r17c1-t46" headers="r1c1-t46">
<p><code>ociaqdemo02.c</code></p>
</td>
<td class="cellalignment1002" headers="r17c1-t46 r1c2-t46">
<p>Perform listen for multiple agents</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r18c1-t46" headers="r1c1-t46">
<p><code>ociaqarrayenq.c</code></p>
</td>
<td class="cellalignment1002" headers="r18c1-t46 r1c2-t46">
<p>Array enqueue 10 messages</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r19c1-t46" headers="r1c1-t46">
<p><code>ociaqarraydeq.c</code></p>
</td>
<td class="cellalignment1002" headers="r19c1-t46 r1c2-t46">
<p>Array dequeue 10 messages</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="ADQUE2509" class="tblformal">
<p class="titleintable"><a id="sthref258"></a><a id="CHDEBDJG"></a>Table 1-2 <a id="sthref259"></a>Oracle Database Advanced Queuing JMS Demonstrations</p>
<table class="cellalignment1005" title="Oracle Database Advanced Queuing JMS Demonstrations" summary="This table describes Oracle Streams AQ demos. The first column is the name of the demo, and the second column provides a brief description of it." dir="ltr">
<thead>
<tr class="cellalignment994">
<th class="cellalignment1001" id="r1c1-t47">Demo and Locations</th>
<th class="cellalignment1001" id="r1c2-t47">Topic</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r2c1-t47" headers="r1c1-t47">
<p><code>aqjmsREADME.txt</code></p>
</td>
<td class="cellalignment1002" headers="r2c1-t47 r1c2-t47">
<p>Describes the Oracle Database Advanced Queuing Java API and JMS demos</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r3c1-t47" headers="r1c1-t47">
<p><code>aqjmsdmo.sql</code></p>
</td>
<td class="cellalignment1002" headers="r3c1-t47 r1c2-t47">
<p>Set up Oracle Database Advanced Queuing JMS demos</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r4c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo01.java</code></p>
</td>
<td class="cellalignment1002" headers="r4c1-t47 r1c2-t47">
<p>Enqueue text messages and dequeue based on message properties</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r5c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo02.java</code></p>
</td>
<td class="cellalignment1002" headers="r5c1-t47 r1c2-t47">
<p>Message listener demo (enqueue messages)</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r6c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo03.java</code></p>
</td>
<td class="cellalignment1002" headers="r6c1-t47 r1c2-t47">
<p>Message listener demo (set up listener and dequeue messages)</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r7c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo04.java</code></p>
</td>
<td class="cellalignment1002" headers="r7c1-t47 r1c2-t47">
<p>Oracle type payload: dequeue on payload content</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r8c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo05.java</code></p>
</td>
<td class="cellalignment1002" headers="r8c1-t47 r1c2-t47">
<p>Queue browser example</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r9c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo06.java</code></p>
</td>
<td class="cellalignment1002" headers="r9c1-t47 r1c2-t47">
<p>Schedule propagation between queues in the database</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r10c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo07.java</code></p>
</td>
<td class="cellalignment1002" headers="r10c1-t47 r1c2-t47">
<p>Send and receive an ADT message containing XML data</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r11c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo08.java</code></p>
</td>
<td class="cellalignment1002" headers="r11c1-t47 r1c2-t47">
<p>JMS 1.1 domain unification demo</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r12c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo09.java</code></p>
</td>
<td class="cellalignment1002" headers="r12c1-t47 r1c2-t47">
<p>JMS bulk array enqueue and dequeue</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r13c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo10.java</code></p>
</td>
<td class="cellalignment1002" headers="r13c1-t47 r1c2-t47">
<p>ANYDATA messaging with JMS message types and ADT messages</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r14c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo11.java</code></p>
</td>
<td class="cellalignment1002" headers="r14c1-t47 r1c2-t47">
<p>Single consumer Sharded Queue demo</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r15c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo12.java</code></p>
</td>
<td class="cellalignment1002" headers="r15c1-t47 r1c2-t47">
<p>Multiple consumer Sharded Queue demo</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r16c1-t47" headers="r1c1-t47">
<p><code>aqjmsdemo13.java</code></p>
</td>
<td class="cellalignment1002" headers="r16c1-t47 r1c2-t47">
<p>Message Selectors with Sharded Queue demo</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r17c1-t47" headers="r1c1-t47">
<p><code>aqjmsdrp.sql</code></p>
</td>
<td class="cellalignment1002" headers="r17c1-t47 r1c2-t47">
<p>Clean up AQ JMS demos</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r18c1-t47" headers="r1c1-t47">
<p><code>aqoradmo.sql</code></p>
</td>
<td class="cellalignment1002" headers="r18c1-t47 r1c2-t47">
<p>Set up Oracle Database Advanced Queuing Java API demos</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r19c1-t47" headers="r1c1-t47">
<p><code>aqorademo01.java</code></p>
</td>
<td class="cellalignment1002" headers="r19c1-t47 r1c2-t47">
<p>Enqueue and dequeue RAW messages</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r20c1-t47" headers="r1c1-t47">
<p><code>aqorademo02.java</code></p>
</td>
<td class="cellalignment1002" headers="r20c1-t47 r1c2-t47">
<p>Enqueue and dequeue object type messages using ORAData interface</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r21c1-t47" headers="r1c1-t47">
<p><code>aqoradrp.sql</code></p>
</td>
<td class="cellalignment1002" headers="r21c1-t47 r1c2-t47">
<p>Clean up AQ Java API demos</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r22c1-t47" headers="r1c1-t47">
<p><code>aqjmskprb01.java</code></p>
</td>
<td class="cellalignment1002" headers="r22c1-t47 r1c2-t47">
<p>Enqueues and dequeues a message within the database</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r23c1-t47" headers="r1c1-t47">
<p><code>aqjmskprb01a.sql</code></p>
</td>
<td class="cellalignment1002" headers="r23c1-t47 r1c2-t47">
<p>Set up kprb driver demo</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r24c1-t47" headers="r1c1-t47">
<p><code>aqjmskprb01b.sql</code></p>
</td>
<td class="cellalignment1002" headers="r24c1-t47 r1c2-t47">
<p>Defines Java program <code>aqjmskprb01.java</code> as stored procedure</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r25c1-t47" headers="r1c1-t47">
<p><code>aqjmskprb01c.sql</code></p>
</td>
<td class="cellalignment1002" headers="r25c1-t47 r1c2-t47">
<p>Runs <code>aqjmskprb01.java</code> as stored procedure</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r26c1-t47" headers="r1c1-t47">
<p><code>aqjmskprb01d.sql</code></p>
</td>
<td class="cellalignment1002" headers="r26c1-t47 r1c2-t47">
<p>Clean up AQ kprb driver demo</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div id="ADQUE2510" class="tblformal">
<p class="titleintable"><a id="sthref260"></a><a id="CHDGGIJB"></a>Table 1-3 <a id="sthref261"></a>Oracle Database Advanced Queuing XML Demonstrations</p>
<table class="cellalignment1005" title="Oracle Database Advanced Queuing XML Demonstrations" summary="This table describes Oracle Streams AQ demos. The first column is the name of the demo, and the second column provides a brief description of it." dir="ltr">
<thead>
<tr class="cellalignment994">
<th class="cellalignment1001" id="r1c1-t48">Demo and Locations</th>
<th class="cellalignment1001" id="r1c2-t48">Topic</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r2c1-t48" headers="r1c1-t48">
<p><code>aqxmlREADME.txt</code></p>
</td>
<td class="cellalignment1002" headers="r2c1-t48 r1c2-t48">
<p>Describes the Internet access demos</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r3c1-t48" headers="r1c1-t48">
<p><code>aqxmldmo.sql</code></p>
</td>
<td class="cellalignment1002" headers="r3c1-t48 r1c2-t48">
<p>Create users, queue tables, and queues</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r4c1-t48" headers="r1c1-t48">
<p><code>aqxml01.xml</code></p>
</td>
<td class="cellalignment1002" headers="r4c1-t48 r1c2-t48">
<p>AQXmlSend: Enqueue three messages to an ADT single- consumer queue with piggyback commit</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r5c1-t48" headers="r1c1-t48">
<p><code>aqxml02.xml</code></p>
</td>
<td class="cellalignment1002" headers="r5c1-t48 r1c2-t48">
<p>AQXmlReceive: Dequeue messages from ADT single-consumer queue with piggyback commit</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r6c1-t48" headers="r1c1-t48">
<p><code>aqxml03.xml</code></p>
</td>
<td class="cellalignment1002" headers="r6c1-t48 r1c2-t48">
<p>AQXmlPublish: Enqueue two messages to an ADT multiconsumer queue</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r7c1-t48" headers="r1c1-t48">
<p><code>aqxml04.xml</code></p>
</td>
<td class="cellalignment1002" headers="r7c1-t48 r1c2-t48">
<p>AQXmlReceive: Dequeue messages from an ADT (with LOB) multiconsumer queue</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r8c1-t48" headers="r1c1-t48">
<p><code>aqxml05.xml</code></p>
</td>
<td class="cellalignment1002" headers="r8c1-t48 r1c2-t48">
<p>AQXmlCommit: Commit previous operation</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r9c1-t48" headers="r1c1-t48">
<p><code>aqxml06.xml</code></p>
</td>
<td class="cellalignment1002" headers="r9c1-t48 r1c2-t48">
<p>AQXmlSend: Enqueue a message to a JMS TEXT single-consumer queue with piggyback commit</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r10c1-t48" headers="r1c1-t48">
<p><code>aqxml07.xml</code></p>
</td>
<td class="cellalignment1002" headers="r10c1-t48 r1c2-t48">
<p>AQXmlReceive: Dequeue messages from a JMS TEXT single-consumer queue with piggyback commit</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r11c1-t48" headers="r1c1-t48">
<p><code>aqxml08.xml</code></p>
</td>
<td class="cellalignment1002" headers="r11c1-t48 r1c2-t48">
<p>AQXmlPublish: Enqueue a JMS MAP message with recipient into multiconsumer queue</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r12c1-t48" headers="r1c1-t48">
<p><code>aqxml09.xml</code></p>
</td>
<td class="cellalignment1002" headers="r12c1-t48 r1c2-t48">
<p>AQXmlReceive: Dequeue JMS MAP messages from a multiconsumer queue</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r13c1-t48" headers="r1c1-t48">
<p><code>aqxml10.xml</code></p>
</td>
<td class="cellalignment1002" headers="r13c1-t48 r1c2-t48">
<p>AQXmlRollback: Roll back previous operation</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r14c1-t48" headers="r1c1-t48">
<p><code>aqxmlhtp.sql</code></p>
</td>
<td class="cellalignment1002" headers="r14c1-t48 r1c2-t48">
<p>HTTP propagation</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r15c1-t48" headers="r1c1-t48">
<p><code>AQDemoServlet.java</code></p>
</td>
<td class="cellalignment1002" headers="r15c1-t48 r1c2-t48">
<p>Servlet to post Oracle Database Advanced Queuing XML files (for Jserv)</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r16c1-t48" headers="r1c1-t48">
<p><code>AQPropServlet.java</code></p>
</td>
<td class="cellalignment1002" headers="r16c1-t48 r1c2-t48">
<p>Servlet for Oracle Database Advanced Queuing HTTP propagation</p>
</td>
</tr>
<tr class="cellalignment994">
<td class="cellalignment1002" id="r17c1-t48" headers="r1c1-t48">
<p><code>aqxmldrp.sql</code></p>
</td>
<td class="cellalignment1002" headers="r17c1-t48 r1c2-t48">
<p>Clean up AQ XML demo</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment993">
<tr>
<td class="cellalignment1002">
<table class="cellalignment998">
<tr>
<td class="cellalignment997"><a href="release_change.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment997"><a href="componet.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1004">
<table class="cellalignment996">
<tr>
<td class="cellalignment997"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment997"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment997"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment997"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment997"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment997"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>