<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-107516"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Class%20Descriptions"></a><title>Class Descriptions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1033"/>
<meta name="dcterms.created" content="2015-03-17T11:50:26Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="TimesTen In-Memory Database TTClasses Guide"/>
<meta name="dcterms.identifier" content="E21640-08"/>
<meta name="dcterms.isVersionOf" content="TTCLS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2006, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="usage.htm" title="Previous" type="text/html"/>
<link rel="Next" href="index.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E21640-08.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/8</span> <!-- End Header -->
<div id="TTCLS144" class="chapter"><a id="i94857"></a>
<h1 class="chapter"><span class="secnum">3</span> Class Descriptions</h1>
<p>This reference chapter contains descriptions of TTClasses external classes and their methods. It is divided into the following sections:</p>
<ul>
<li>
<p><a href="#i95340">Commonly used TTClasses</a></p>
</li>
<li>
<p><a href="#i95345">System catalog classes</a></p>
</li>
<li>
<p><a href="#i96833">XLA classes</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Most methods documented in this chapter also support a signature with a <code dir="ltr">TTStatus&amp;</code> parameter at the end of the calling sequence. This is for situations when you want to suppress exceptions for the method call and instead process the <code dir="ltr">TTStatus</code> object manually for errors. These signatures are not specifically documented, however, because this is not a recommended mode of use. For additional information and an example, see the &#34;Usage&#34; section under <a href="#i83881">&#34;TTStatus&#34;</a>.</div>
<a id="i95340"></a>
<div id="TTCLS145" class="sect1">
<h2 class="sect1">Commonly used TTClasses</h2>
<p>This section discusses the following classes:</p>
<ul>
<li>
<p><code dir="ltr"><a href="#i95316">TTGlobal</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#i83881">TTStatus</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#i95276">TTConnection</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#i95299">TTConnectionPool</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#i95294">TTCmd</a></code></p>
</li>
</ul>
<a id="i95316"></a>
<div id="TTCLS238" class="sect2">
<h3 class="sect2"><a id="sthref148"></a><a id="sthref149"></a>TTGlobal</h3>
<p>The <code dir="ltr">TTGlobal</code> class provides a logging facility within TTClasses.</p>
<div id="TTCLS245" class="sect3"><a id="sthref150"></a>
<h4 class="sect3">Usage</h4>
<p>The <code dir="ltr">TTGlobal</code> logging facility can be very useful for debugging problems inside a TTClasses program. Note, however, that the most verbose logging levels (<code dir="ltr">TTLog::TTLOG_INFO</code> and <code dir="ltr">TTLog::TTLOG_DEBUG</code>) can generate an extremely large amount of output. Use these logging levels during development or when trying to diagnose a bug. They are not appropriate for most production environments.</p>
<p>When logging from a multithreaded program, you may encounter a problem where log output from different program threads is intermingled when written to disk. To alleviate this problem, disable <code dir="ltr">ostream</code> buffering with the <code dir="ltr">ios_base::unitbuf</code> I/O stream manipulator, as in the following example, which sends TTClasses logging to the <code dir="ltr">app_log.txt</code> file at logging level <code dir="ltr">TTLog::TTLOG_ERR</code>.</p>
<pre dir="ltr">ofstream log_file(&#34;app_log.txt&#34;);
log_file &lt;&lt; std::ios_base::unitbuf; 
TTGlobal::setLogStream(log_file); 
TTGlobal::setLogLevel(TTLog::TTLOG_ERR);
</pre>
<p>See <a href="usage.htm#i83245">&#34;Using TTClasses logging&#34;</a> for more information about using <code dir="ltr">TTGlobal</code>.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS239" class="sect3"><a id="sthref151"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS240" class="sect3"><a id="sthref152"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods for TTGlobal." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t3">Method</th>
<th class="cellalignment2190" id="r1c2-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t3" headers="r1c1-t3"><code dir="ltr"><a href="#i99310">disableLogging()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t3 r1c2-t3">Disables TTClasses logging.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t3" headers="r1c1-t3"><code dir="ltr"><a href="#i99305">setLogLevel()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t3 r1c2-t3">Specifies the verbosity level of TTClasses logging.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t3" headers="r1c1-t3"><code dir="ltr"><a href="#i99300">setLogStream()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t3 r1c2-t3">Specifies where TTClasses logging information should be sent.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t3" headers="r1c1-t3"><code dir="ltr"><a href="#CHDIHEEJ">sqlhenv()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t3 r1c2-t3">Returns the underlying ODBC environment object (type <code dir="ltr">SQLHENV</code>).</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="i99310"></a>
<div id="TTCLS244" class="sect4">
<h5 class="sect4">disable<a id="sthref153"></a><a id="sthref154"></a>Logging()</h5>
<pre dir="ltr">static void disableLogging()
</pre>
<p>This method disables all TTClasses logging. Note that the following two statements are identical:</p>
<pre dir="ltr">TTGlobal::disableLogging();  
TTGlobal::setLogLevel(TTLog::TTLOG_NIL);
</pre></div>
<!-- class="sect4" -->
<a id="i99305"></a>
<div id="TTCLS242" class="sect4">
<h5 class="sect4">setLog<a id="sthref155"></a><a id="sthref156"></a>Level()</h5>
<pre dir="ltr">static void setLogLevel(TTLog::TTLOG_LEVEL <span class="italic">level</span>)
</pre>
<p>This method specifies the verbosity level of TTClasses logging. <a href="#g135919">Table 3-1</a> describes TTClasses logging levels. The levels are cumulative.</p>
<div id="TTCLS243" class="tblhruleformal">
<p class="titleintable"><a id="sthref157"></a><a id="g135919"></a>Table 3-1 TTClasses logging levels</p>
<table class="cellalignment2189" title="TTClasses logging levels" summary="This table contains descriptions of TTClasses logging levels." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t4">Logging level</th>
<th class="cellalignment2190" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TTLog::TTLOG_NIL</code></p>
</td>
<td class="cellalignment2191" headers="r2c1-t4 r1c2-t4">
<p>There is no logging.</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TTLog::TTLOG_FATAL_ERR</code></p>
</td>
<td class="cellalignment2191" headers="r3c1-t4 r1c2-t4">
<p>Logs fatal errors (serious misuse of TTClasses methods).</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TTLog::TTLOG_ERR</code></p>
</td>
<td class="cellalignment2191" headers="r4c1-t4 r1c2-t4">
<p>Logs all errors, such as <code dir="ltr">SQL_ERROR</code> return codes.</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TTLog::TTLOG_WARN</code></p>
</td>
<td class="cellalignment2191" headers="r5c1-t4 r1c2-t4">
<p>(Default) Also logs warnings and all calls to <code dir="ltr">TTCmd::Prepare()</code>, including the SQL string being prepared. Prints all database optimizer query plans.</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TTLog::TTLOG_INFO</code></p>
</td>
<td class="cellalignment2191" headers="r6c1-t4 r1c2-t4">
<p>Also logs informational messages, such as calls to most methods on <code dir="ltr">TTCmd</code> and <code dir="ltr">TTConnection</code> objects, including the SQL string where appropriate.</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TTLog::TTLOG_DEBUG</code></p>
</td>
<td class="cellalignment2191" headers="r7c1-t4 r1c2-t4">
<p>Also logs debugging information, such as all bound parameter values for each call to <code dir="ltr">TTCmd::Execute()</code>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p>To set the logging level to <code dir="ltr">TTLog::TTLOG_ERR</code>, for example, add the following line to your program:</p>
<pre dir="ltr">TTGlobal::setLogLevel(TTLog::TTLOG_ERR);
</pre></div>
<!-- class="sect4" -->
<a id="i99300"></a>
<div id="TTCLS241" class="sect4">
<h5 class="sect4">set<a id="sthref158"></a><a id="sthref159"></a>LogStream()</h5>
<pre dir="ltr">static void setLogStream(ostream&amp; <span class="italic">stream</span>)
</pre>
<p>Specifies where TTClasses logging information should be sent. By default, if TTClasses logging is enabled, logging is to <code dir="ltr">stderr</code>. Using this method, an application can specify logging to a file (or any other <code dir="ltr">ostream&amp;</code>), such as in the following example that sets logging to <code dir="ltr">app_log.txt</code>:</p>
<pre dir="ltr">ofstream log_file(&#34;app_log.txt&#34;);
TTGlobal::setLogStream(log_file);
</pre></div>
<!-- class="sect4" -->
<a id="CHDIHEEJ"></a>
<div id="TTCLS387" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">sqlh<a id="sthref160"></a><a id="sthref161"></a><a id="sthref162"></a><a id="sthref163"></a>env()</h5>
<pre dir="ltr">static SQLHENV sqlhenv()
</pre>
<p>Retrieves the underlying ODBC environment object.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i83881"></a>
<div id="TTCLS146" class="sect2">
<h3 class="sect2">TTSt<a id="sthref164"></a><a id="sthref165"></a>atus</h3>
<p>The <code dir="ltr">TTStatus</code> class is used by other classes in the TTClasses library to catch error and warning exceptions. You can think of <code dir="ltr">TTStatus</code> as a value-added C++ wrapper around the <code dir="ltr">SQLError</code> ODBC function.</p>
<a id="CHDIFJBB"></a>
<div id="TTCLS153" class="sect3">
<h4 class="sect3">Usa<a id="sthref166"></a>ge</h4>
<p>The preferred mode for TTClasses error handling is for a <code dir="ltr">TTStatus</code> object to be thrown as an exception whenever an error or warning occurs. To accomplish this, the TTClasses library, as well as your applications, must be compiled with the <code dir="ltr">TTEXCEPT</code> preprocessor variable enabled. (TTClasses is compiled this way by default.) This allows C++ applications to use <code dir="ltr">{try/catch}</code> blocks to detect and recover from failure.</p>
<p><a href="#CHDBEHDB">Example 3-1</a> shows typical use of <code dir="ltr">TTStatus</code>. Also see <a href="#CHDDJCDI">Example 3-3</a>.</p>
<div id="TTCLS154" class="example">
<p class="titleinexample"><a id="CHDBEHDB"></a>Example 3-1 Exception handling</p>
<pre dir="ltr">...
TTCmd    myCmd;

try {
  myCmd.ExecuteImmediate(&amp;conn, &#34;create table dummy (c1 int)&#34;);
}

catch (TTStatus st) {
  cerr &lt;&lt; &#34;Error creating table: &#34; &lt;&lt; st &lt;&lt; endl;
  // Rollback, exit(), throw -- whatever is appropriate
}
</pre></div>
<!-- class="example" -->
<p><a id="sthref167"></a><a id="sthref168"></a>Another supported (but not typical) mode of use for <code dir="ltr">TTStatus</code>, when <code dir="ltr">TTEXCEPT</code> is enabled, is to selectively suppress exceptions and allow the application to manually check a <code dir="ltr">TTStatus</code> object for error conditions. You can use this mode for a particular method call by initializing a <code dir="ltr">TTStatus</code> object with the value <code dir="ltr">TTStatus::DO_NOT_THROW</code>, then passing that object as the last parameter of a method call. Most TTClasses methods documented in this chapter also support a signature with this <code dir="ltr">TTStatus&amp;</code> parameter as the last parameter in the calling sequence.</p>
<p><a href="#CHDECEHF">Example 3-2</a> that follows shows this usage.</p>
<div id="TTCLS496" class="example">
<p class="titleinexample"><a id="CHDECEHF"></a>Example 3-2 Suppressing exceptions</p>
<pre dir="ltr">...
TTCmd    myCmd;
TTStatus myStat(TTStatus::DO_NOT_THROW);
 
myCmd.ExecuteImmediate(&amp;conn, &#34;create table dummy (c1 int)&#34;, myStat);
if (myStat.rc == SQL_ERROR)
{
  // handle the error
}
...
</pre></div>
<!-- class="example" -->
<p>Another mode of operation, which is not recommended, is to compile TTClasses and your application without the <code dir="ltr">TTEXCEPT</code> flag enabled. In this case, exceptions are not thrown, and the only way to process errors is through <code dir="ltr">TTStatus&amp;</code> parameters in your method calls. When you compile this way, the newer method signatures (without <code dir="ltr">TTStatus&amp;</code> parameters) are unavailable.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS147" class="sect3"><a id="sthref169"></a>
<h4 class="sect3">Subclasses</h4>
<p><code dir="ltr">TTStatus</code> has the following subclasses:</p>
<ul>
<li>
<p><code dir="ltr"><a href="#i99011">TTError</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#i99024">TTWarning</a></code></p>
</li>
</ul>
<a id="i99011"></a>
<div id="TTCLS148" class="sect4">
<h5 class="sect4">T<a id="sthref170"></a><a id="sthref171"></a>TError</h5>
<p><code dir="ltr">TTError</code> is a subclass of <code dir="ltr">TTStatus</code> and is used to encapsulate ODBC errors (return codes <code dir="ltr">SQL_ERROR</code> and <code dir="ltr">SQL_INVALID_HANDLE</code>).</p>
</div>
<!-- class="sect4" -->
<a id="i99024"></a>
<div id="TTCLS149" class="sect4">
<h5 class="sect4">T<a id="sthref172"></a><a id="sthref173"></a>TWarning</h5>
<p><code dir="ltr">TTWarning</code> is a subclass of <code dir="ltr">TTStatus</code> and is used to encapsulate ODBC warnings (return code <code dir="ltr">SQL_SUCCESS_WITH_INFO</code>).</p>
<p>ODBC warnings (the Return Receipt warning, for example) are usually not as serious as ODBC errors and should typically be handled with different logic. ODBC errors should be handled programmatically. There may be circumstances where handling ODBC warnings programmatically is warranted, but it is usually sufficient to simply log them.</p>
<p><a href="#CHDDJCDI">Example 3-3</a> shows usage of the <code dir="ltr">TTError</code> and <code dir="ltr">TTWarning</code> subclasses.</p>
<div id="TTCLS155" class="example">
<p class="titleinexample"><a id="CHDDJCDI"></a>Example 3-3 Exception handling, distinguishing between errors and warnings</p>
<p>This example shows the use of <code dir="ltr">TTError</code> and <code dir="ltr">TTWarning</code>. <code dir="ltr">TTError</code> objects are thrown for ODBC errors. <code dir="ltr">TTWarning</code> objects are thrown for ODBC warnings.</p>
<pre dir="ltr">// catching TTError &amp; TTWarning exceptions

try {
  // some TTClasses method calls
}
catch (TTWarning warn) {
  cerr &lt;&lt; &#34;Warning encountered: &#34; &lt;&lt; warn &lt;&lt; endl;
}
catch (TTError err) {
  // handle the error; this could be a serious problem
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="TTCLS150" class="sect3"><a id="sthref174"></a>
<h4 class="sect3">Public members</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Member descriptions" summary="This table contains descriptions of the public members of TTWarning." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t5">Member</th>
<th class="cellalignment2190" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t5" headers="r1c1-t5"><code dir="ltr">rc</code></td>
<td class="cellalignment2191" headers="r2c1-t5 r1c2-t5">Return code from the failing ODBC call: <code dir="ltr">SQL_SUCCESS</code>, <code dir="ltr">SQL_SUCCESS_WITH_INFO</code>, <code dir="ltr">SQL_ERROR</code>, <code dir="ltr">SQL_NO_DATA_FOUND</code>, or <code dir="ltr">SQL_INVALID_HANDLE</code></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t5" headers="r1c1-t5"><code dir="ltr">native_error</code></td>
<td class="cellalignment2191" headers="r3c1-t5 r1c2-t5">TimesTen native error number (if any) for the failing ODBC call</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t5" headers="r1c1-t5"><code dir="ltr">odbc_error</code></td>
<td class="cellalignment2191" headers="r4c1-t5 r1c2-t5">ODBC error state for the failing ODBC call</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t5" headers="r1c1-t5"><code dir="ltr">err_msg</code></td>
<td class="cellalignment2191" headers="r5c1-t5 r1c2-t5">ASCII printable error message for the failing ODBC call</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t5" headers="r1c1-t5"><code dir="ltr">TTSTATUS_ENUM</code></td>
<td class="cellalignment2191" headers="r6c1-t5 r1c2-t5">Enumeration for error status and error handling
<p>Use the value <code dir="ltr">TTStatus::DO_NOT_THROW</code> to initialize a <code dir="ltr">TTStatus</code> object to suppress exceptions for a method call. See <a href="#CHDECEHF">Example 3-2</a>.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect3" -->
<div id="TTCLS151" class="sect3"><a id="sthref175"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method description" summary="This table contains a description of the public method for TTWarning." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t6">Method</th>
<th class="cellalignment2190" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t6" headers="r1c1-t6"><code dir="ltr"><a href="#CHDHJCHJ">isConnectionInvalid()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t6 r1c2-t6">Indicates whether the database connection is invalid.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t6" headers="r1c1-t6"><code dir="ltr"><a href="#i105981">ostream()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t6 r1c2-t6">Prints errors to a stream.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t6" headers="r1c1-t6"><code dir="ltr"><a href="#CHDCIAJD">throwError()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t6 r1c2-t6">Throws an error from the <code dir="ltr">TTStatus</code> object (not typical use).</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDHJCHJ"></a>
<div id="TTCLS377" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">isCon<a id="sthref176"></a><a id="sthref177"></a>nectionInvalid()</h5>
<pre dir="ltr">bool isConnectionInvalid() const
</pre>
<p>Returns <code dir="ltr">TRUE</code> if the database connection is invalid, or <code dir="ltr">FALSE</code> if it is valid. Specifically, &#34;invalid&#34; refers to situations when a TimesTen error 846 or 994 is encountered. See <a class="olink TTERR117" href="../TTERR/error.htm#TTERR117">&#34;Errors 0 - 999&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Error Messages and SNMP Traps</span> for information about those errors.</p>
</div>
<!-- class="sect4" -->
<a id="i105981"></a>
<div id="TTCLS152" class="sect4">
<h5 class="sect4">ost<a id="sthref178"></a><a id="sthref179"></a>ream()</h5>
<pre dir="ltr">friend ostream&amp; operator&lt;&lt;(ostream&amp;, TTStatus&amp; <span class="italic">stat</span>)
</pre>
<p>This method prints the error to a stream.</p>
</div>
<!-- class="sect4" -->
<a id="CHDCIAJD"></a>
<div id="TTCLS378" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">th<a id="sthref180"></a>rowError()</h5>
<pre dir="ltr">void throwError()
</pre>
<p>This is an alternative, but not typical, way to throw an exception. In most cases the following two blocks of code are equivalent, but the former is more typical.</p>
<pre dir="ltr">try {
  // ...
  if (/* something has gone wrong */)
    throw stat;
}
catch (TTStatus st) {
  cerr &lt;&lt; &#34;Caught exception: &#34; &lt;&lt; st &lt;&lt; endl;
}
</pre>
<p>Or:</p>
<pre dir="ltr">try {
  // ...
  if (/* something has gone wrong */)
    stat.throwError();
}
catch (TTStatus st) {
  cerr &lt;&lt; &#34;Caught exception: &#34; &lt;&lt; st &lt;&lt; endl;
}
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i95276"></a>
<div id="TTCLS156" class="sect2">
<h3 class="sect2"><a id="sthref181"></a><a id="sthref182"></a>TTConnection</h3>
<p>The <code dir="ltr">TTConnection</code> class encapsulates the concept of a connection to a database. You can think of <code dir="ltr">TTConnection</code> as a value-added C++ wrapper around the ODBC connection handle (<code dir="ltr">SQLHDBC</code>).</p>
<div id="TTCLS157" class="sect3"><a id="sthref183"></a>
<h4 class="sect3">Usage</h4>
<p>All applications that use TimesTen must create at least one <code dir="ltr">TTConnection</code> object.</p>
<p>Multithreaded applications that use TimesTen from multiple threads simultaneously must create multiple <code dir="ltr">TTConnection</code> objects. Use one of the following strategies:</p>
<ul>
<li>
<p>Create one <code dir="ltr">TTConnection</code> object for each thread when the thread is created.</p>
</li>
<li>
<p>Create a pool of <code dir="ltr">TTConnection</code> objects when the application process starts. They are shared by the threads in the process. See <a href="#i95299">&#34;TTConnectionPool&#34;</a> for additional information about this option.</p>
</li>
</ul>
<p>A TimesTen connection cannot be inherited from a parent process. If a process opens a database connection before creating (forking) a child process, the child cannot use the same connection. Any attempt by a child to use a database connection of a parent can cause application failure or a core dump.</p>
<p>Applications should not frequently make and then drop database connections, because connecting and disconnecting are both relatively expensive operations. In addition, short-lived connections eliminate the benefits of prepared statements. Instead, establish database connections at the beginning of the application process and reuse them for the life of the process.</p>
<p>Also see <a href="usage.htm#i82204">&#34;Using TTCmd, TTConnection, and TTConnectionPool&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you must manipulate the underlying ODBC connection object directly, use the <code dir="ltr">TTConnection::getHdbc()</code> method.</div>
<p>Privilege to connect to a database must be granted to users through the <code dir="ltr">CREATE SESSION</code> privilege, either directly or through the <code dir="ltr">PUBLIC</code> role. See <a href="usage.htm#CDEJBGDF">&#34;Access control for connections&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<a id="CHDHHECE"></a>
<div id="TTCLS158" class="sect3">
<h4 class="sect3">Public members</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Member descriptions" summary="This table contains descriptions of the public members of TTConnection." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t8">Member</th>
<th class="cellalignment2190" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t8" headers="r1c1-t8"><code dir="ltr">DRIVER_COMPLETION_ENUM</code></td>
<td class="cellalignment2191" headers="r2c1-t8 r1c2-t8">Specifies whether there is a prompt for the database to connect to (also depending on whether a database is specified in the connect string).
<p>Valid values are <code dir="ltr">TTConnection::DRIVER_NOPROMPT</code>, <code dir="ltr">TTConnection::DRIVER_COMPLETE</code>, <code dir="ltr">TTConnection::DRIVER_PROMPT</code>, and <code dir="ltr">TTConnection::DRIVER_COMPLETE_REQUIRED</code>. These correspond to the values <code dir="ltr">SQL_DRIVER_NOPROMPT</code>, <code dir="ltr">SQL_DRIVER_COMPLETE</code>, <code dir="ltr">SQL_DRIVER_PROMPT</code>, and <code dir="ltr">SQL_DRIVER_COMPLETE_REQUIRED</code> for the standard ODBC <code dir="ltr">SQLDriverConnect</code> function.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect3" -->
<div id="TTCLS159" class="sect3"><a id="sthref184"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods for TTConnection." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t9">Method</th>
<th class="cellalignment2190" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98845">Commit()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t9 r1c2-t9">Commits a transaction to the database.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98835">Connect()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t9 r1c2-t9">Opens a new database connection.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i103841">Disconnect()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t9 r1c2-t9">Closes a database connection.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98890">DurableCommit()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t9 r1c2-t9">Performs a durable commit operation on the database.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98860">getHdbc()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t9 r1c2-t9">Returns the ODBC connection handle (type <code dir="ltr">SQLHDBC</code>) associated with this connection.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98925">GetTTContext()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t9 r1c2-t9">Returns the connection context value.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98855">isConnected()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t9 r1c2-t9">Returns <code dir="ltr">TRUE</code> if the object is connected to TimesTen.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98850">Rollback()</a></code></td>
<td class="cellalignment2191" headers="r9c1-t9 r1c2-t9">Rolls back changes made to the database through this connection since the last call to <code dir="ltr">Commit()</code> or <code dir="ltr">Rollback()</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98915">SetAutoCommitOff()</a></code></td>
<td class="cellalignment2191" headers="r10c1-t9 r1c2-t9">Disables autocommit for the connection.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r11c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98920">SetAutoCommitOn()</a></code></td>
<td class="cellalignment2191" headers="r11c1-t9 r1c2-t9">Enables autocommit for the connection.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r12c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98865">SetIsoReadCommitted()</a></code></td>
<td class="cellalignment2191" headers="r12c1-t9 r1c2-t9">Sets the transaction isolation level of the connection to be <code dir="ltr">TXN_READ_COMMITTED</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r13c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98870">SetIsoSerializable()</a></code></td>
<td class="cellalignment2191" headers="r13c1-t9 r1c2-t9">Sets the transaction isolation level of the connection to be <code dir="ltr">TXN_SERIALIZABLE</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r14c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98895">SetLockWait()</a></code></td>
<td class="cellalignment2191" headers="r14c1-t9 r1c2-t9">Sets the lock timeout interval for the connection by calling the <code dir="ltr">ttLockWait</code> TimesTen built-in procedure.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r15c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98905">SetPrefetchCloseOff()</a></code></td>
<td class="cellalignment2191" headers="r15c1-t9 r1c2-t9">Turns off the <code dir="ltr">TT_PREFETCH_CLOSE</code> connection option.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r16c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98900">SetPrefetchCloseOn()</a></code></td>
<td class="cellalignment2191" headers="r16c1-t9 r1c2-t9">Turns on the <code dir="ltr">TT_PREFETCH_CLOSE</code> connection option. This is useful for optimizing <code dir="ltr">SELECT</code> query performance for client/server connections to TimesTen.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r17c1-t9" headers="r1c1-t9"><code dir="ltr"><a href="#i98910">SetPrefetchCount()</a></code></td>
<td class="cellalignment2191" headers="r17c1-t9 r1c2-t9">Allows a user application to tune the number of rows that the TimesTen ODBC driver <code dir="ltr">SQLFetch</code> call prefetches for a <code dir="ltr">SELECT</code> statement.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="i98845"></a>
<div id="TTCLS163" class="sect4">
<h5 class="sect4">Com<a id="sthref185"></a><a id="sthref186"></a>mit()</h5>
<pre dir="ltr">void Commit()
</pre>
<p>Commits a transaction to the database. This commits all operations performed on the connection since the last call to the <code dir="ltr">Commit()</code> or <code dir="ltr">Rollback()</code> method. A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs. Also see <code dir="ltr"><a href="#i98850">Rollback()</a></code>.</p>
</div>
<!-- class="sect4" -->
<a id="i98835"></a>
<div id="TTCLS160" class="sect4">
<h5 class="sect4">Con<a id="sthref187"></a><a id="sthref188"></a>nect()</h5>
<pre dir="ltr">virtual void Connect(const char* <span class="italic">connStr</span>)
virtual void Connect(const char* <span class="italic">connStr</span>, const char* <span class="italic">username</span>, 
                     const char* <span class="italic">password</span>)
virtual void Connect(const char* <span class="italic">connStr</span>, DRIVER_COMPLETION_ENUM <span class="italic">driverCompletion</span>)
</pre>
<p>Opens a new database connection. The connection string specified in the <code dir="ltr"><span class="codeinlineitalic">connStr</span></code> parameter is used to create the connection. Specify a user and password, either as part of the connect string or as separate parameters, or a <code dir="ltr">DRIVER_COMPLETION_ENUM</code> value (refer to <a href="#CHDHHECE">&#34;Public members&#34;</a>). Also see the following method, <code dir="ltr">Disconnect()</code>.</p>
<p>Privilege to connect to a database must be granted to users through the <code dir="ltr">CREATE SESSION</code> privilege, either directly or through the <code dir="ltr">PUBLIC</code> role. See <a href="usage.htm#CDEJBGDF">&#34;Access control for connections&#34;</a>.</p>
<div id="TTCLS161" class="example">
<p class="titleinexample"><a id="sthref189"></a>Example 3-4 Using the Connect() method and checking for errors</p>
<p>A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs. Any exception warnings are usually informational and can often be safely ignored. The following logic is preferred for use of the <code dir="ltr">Connect()</code> method.</p>
<p><code dir="ltr">TTWarning</code> and <code dir="ltr">TTError</code> are subclasses of <code dir="ltr">TTStatus</code>.</p>
<pre dir="ltr">TTConnection conn;
...

try {
  conn.Connect(&#34;DSN=mydsn&#34;, &#34;myuser&#34;, &#34;mypassword&#34;);
}
catch (TTWarning warn) {
  // warnings from Connect() are usually informational
  cerr &lt;&lt; &#39;&#39;Warning while connecting to TimesTen: &#39;&#39; &lt;&lt; warn &lt;&lt; endl;
}
catch (TTError err) {
  // handle the error; this could be a serious problem
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="i103841"></a>
<div id="TTCLS162" class="sect4">
<h5 class="sect4">Discon<a id="sthref190"></a><a id="sthref191"></a>nect()</h5>
<pre dir="ltr">void Disconnect()
</pre>
<p>Closes a database connection. A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs. Also see the preceding method, <code dir="ltr">Connect()</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i98890"></a>
<div id="TTCLS171" class="sect4">
<h5 class="sect4">DurableCom<a id="sthref192"></a><a id="sthref193"></a>mit()</h5>
<pre dir="ltr">void DurableCommit()
</pre>
<p>Performs a durable commit operation on the database. A durable commit operation flushes the in-memory transaction log buffer to disk. It calls the <code dir="ltr">ttDurableCommit</code> TimesTen built-in procedure.</p>
<p>See <a class="olink TTREF247" href="../TTREF/proced.htm#TTREF247">&#34;ttDurableCommit&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</div>
<!-- class="sect4" -->
<a id="i98860"></a>
<div id="TTCLS166" class="sect4">
<h5 class="sect4">get<a id="sthref194"></a><a id="sthref195"></a><a id="sthref196"></a><a id="sthref197"></a>Hdbc()</h5>
<pre dir="ltr">SQLHDBC getHdbc()
</pre>
<p>Returns the ODBC connection handle associated with this connection.</p>
</div>
<!-- class="sect4" -->
<a id="i98925"></a>
<div id="TTCLS178" class="sect4">
<h5 class="sect4">GetTTConte<a id="sthref198"></a><a id="sthref199"></a>xt()</h5>
<pre dir="ltr">void GetTTContext(char* <span class="italic">output</span>)
</pre>
<p>Returns the context value of the connection, a value that is unique for each database connection. The context of a connection can be used to correlate TimesTen connections with PIDs (process IDs) using the <code dir="ltr">ttStatus</code> TimesTen utility, for example.</p>
<p>The context value is returned through the <code dir="ltr"><span class="codeinlineitalic">output</span></code> parameter, which requires an array of <code dir="ltr">CHAR[17]</code> or larger.</p>
<p>This method calls the <code dir="ltr">ttContext</code> TimesTen built-in procedure. See <a class="olink TTREF245" href="../TTREF/proced.htm#TTREF245">&#34;ttContext&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</div>
<!-- class="sect4" -->
<a id="i98855"></a>
<div id="TTCLS165" class="sect4">
<h5 class="sect4">isCon<a id="sthref200"></a><a id="sthref201"></a>nected()</h5>
<pre dir="ltr">bool isConnected()
</pre>
<p>Returns <code dir="ltr">TRUE</code> if the object is connected to TimesTen using the <code dir="ltr">Connect()</code> method or <code dir="ltr">FALSE</code> if not.</p>
</div>
<!-- class="sect4" -->
<a id="i98850"></a>
<div id="TTCLS164" class="sect4">
<h5 class="sect4">Rol<a id="sthref202"></a><a id="sthref203"></a>lback()</h5>
<pre dir="ltr">void Rollback()
</pre>
<p>Rolls back (cancels) a transaction. This undoes any changes made to the database through the connection since the last call to <code dir="ltr">Commit()</code> or <code dir="ltr">Rollback()</code>. A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs. Also see <code dir="ltr"><a href="#i98845">Commit()</a></code>.</p>
</div>
<!-- class="sect4" -->
<a id="i98915"></a>
<div id="TTCLS176" class="sect4">
<h5 class="sect4"><a id="sthref204"></a>SetAutoCommitOff()</h5>
<pre dir="ltr">void SetAutoCommitOff()
</pre>
<p>Disables autocommit for the connection. Also see the following method, <code dir="ltr">SetAutoCommitOn()</code>.</p>
<p>This method is automatically called by <code dir="ltr">TTConnection::Connect()</code>, because TimesTen runs with optimal performance only with autocommit disabled.</p>
<p>Note that when autocommit is disabled, committing <code dir="ltr">SELECT</code> statements requires explicit calls to <code dir="ltr">TTCmd::Close()</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i98920"></a>
<div id="TTCLS177" class="sect4">
<h5 class="sect4">SetAutoCom<a id="sthref205"></a><a id="sthref206"></a><a id="sthref207"></a><a id="sthref208"></a>mitOn()</h5>
<pre dir="ltr">void SetAutoCommitOn()
</pre>
<p>Enables autocommit for the connection, which means that every SQL statement occurs in its own transaction. Also see the preceding method, <code dir="ltr">SetAutoCommitOff()</code>.</p>
<p><code dir="ltr">SetAutoCommitOn()</code> is generally not advisable, because TimesTen runs much faster with autocommit disabled.</p>
</div>
<!-- class="sect4" -->
<a id="i98865"></a>
<div id="TTCLS167" class="sect4">
<h5 class="sect4">SetIsoReadCom<a id="sthref209"></a><a id="sthref210"></a><a id="sthref211"></a>mitted()</h5>
<pre dir="ltr">void SetIsoReadCommitted()
</pre>
<p>Sets the transaction isolation level of the connection to be <code dir="ltr">TXN_READ_COMMITTED</code>. The Read Committed isolation level offers the best combination of single-transaction performance and good multiconnection concurrency. Also see the following method, <code dir="ltr">SetIsoSerializable()</code>, following.</p>
</div>
<!-- class="sect4" -->
<a id="i98870"></a>
<div id="TTCLS168" class="sect4">
<h5 class="sect4">Se<a id="sthref212"></a><a id="sthref213"></a><a id="sthref214"></a>tIsoSerializable()</h5>
<pre dir="ltr">void SetIsoSerializable()
</pre>
<p>Sets the transaction isolation level of the connection to be <code dir="ltr">TXN_SERIALIZABLE</code>. In general, Serializable isolation level offers fair individual transaction performance but extremely poor concurrency. Read Committed isolation level is preferable over Serializable isolation level in almost all situations. Also see the preceding method, <code dir="ltr">SetIsoReadCommitted()</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i98895"></a>
<div id="TTCLS172" class="sect4">
<h5 class="sect4">SetLo<a id="sthref215"></a><a id="sthref216"></a>ckWait()</h5>
<pre dir="ltr">void SetLockWait(int <span class="italic">secs</span>)
</pre>
<p>Sets the lock timeout interval for the connection by calling the <code dir="ltr">ttLockWait</code> TimesTen built-in procedure with the <code dir="ltr"><span class="codeinlineitalic">secs</span></code> parameter. In general, a two-second or three-second lock timeout is sufficient for most applications. The default lock timeout interval is 10 seconds.</p>
<p>See <a class="olink TTREF260" href="../TTREF/proced.htm#TTREF260">&#34;ttLockWait&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</div>
<!-- class="sect4" -->
<a id="i98905"></a>
<div id="TTCLS174" class="sect4">
<h5 class="sect4">SetPr<a id="sthref217"></a>efetchCloseOff()</h5>
<pre dir="ltr">void SetPrefetchCloseOff()
</pre>
<p>Turns off the <code dir="ltr">TT_PREFETCH_CLOSE</code> connection option. Also see the following method, <code dir="ltr">SetPrefetchCloseOn()</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i98900"></a>
<div id="TTCLS173" class="sect4">
<h5 class="sect4">Se<a id="sthref218"></a><a id="sthref219"></a>tPrefetchCloseOn()</h5>
<pre dir="ltr">void SetPrefetchCloseOn()
</pre>
<p>Turns on the <code dir="ltr">TT_PREFETCH_CLOSE</code> connection option, which is useful for optimizing <code dir="ltr">SELECT</code> query performance for serializable transactions in client/server applications. Note that this method provides no benefit for an application using a direct connection to TimesTen. Also see the preceding method, <code dir="ltr">SetPrefetchCloseOff()</code>.</p>
<p>See <a class="olink TTOPR449" href="../TTOPR/perform.htm#TTOPR449">&#34;Enable TT_PREFETCH_CLOSE for Serializable transactions&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Operations Guide</span>.</p>
</div>
<!-- class="sect4" -->
<a id="i98910"></a>
<div id="TTCLS175" class="sect4">
<h5 class="sect4">Se<a id="sthref220"></a>tPrefetchCount()</h5>
<pre dir="ltr">void SetPrefetchCount(int <span class="italic">numrows</span>)
</pre>
<p>Allows a client/server application to tune the number of rows that the TimesTen ODBC driver internally fetches at a time for a <code dir="ltr">SELECT</code> statement. The value of <code dir="ltr"><span class="codeinlineitalic">numrows</span></code> must be between 1 and 128, inclusive.</p>
<p>Note that this method provides no benefit for an application using a direct connection to TimesTen.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This method is not equivalent to executing <code dir="ltr">TTCmd::FetchNext()</code> multiple times. Instead, proper use of this parameter reduces the amount of time for each call to <code dir="ltr">TTCmd::FetchNext()</code>.</div>
<p>See <a class="olink TTCDV149" href="../TTCDV/writing_app.htm#TTCDV149">&#34;Prefetching multiple rows of data&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span> for more information about <code dir="ltr">TT_PREFETCH_COUNT</code>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i95299"></a>
<div id="TTCLS229" class="sect2">
<h3 class="sect2"><a id="sthref221"></a><a id="sthref222"></a><a id="sthref223"></a><a id="sthref224"></a>TTConnectionPool</h3>
<p>The <code dir="ltr">TTConnectionPool</code> class is used by multithreaded applications to manage a pool of connections.</p>
<p>In general, multithreaded applications can be written using one of the following strategies:</p>
<ul>
<li>
<p>If there is a relatively small number of threads and the threads are long-lived, each thread can be assigned to a different connection, which is used for the duration of the application. In this scenario, the <code dir="ltr">TTConnectionPool</code> class is not necessary.</p>
</li>
<li>
<p>If there is a large number of threads in the process, or if the threads are short-lived, a pool of idle connections can be established. These connections are used for the duration of the application. When a thread must perform a database transaction, it checks out an idle connection from the pool, performs its transaction, then returns the connection to the pool. This is the scenario that the <code dir="ltr">TTConnectionPool</code> class assists with.</p>
</li>
</ul>
<p>The constructor has two forms:</p>
<pre dir="ltr">TTConnectionPool()
</pre>
<p>Or:</p>
<pre dir="ltr">TTConnectionPool(const int <span class="italic">size</span>);
</pre>
<p>Where <code dir="ltr"><span class="codeinlineitalic">size</span></code> specifies the maximum number of connections in a pool. Without specifying this, the maximum number of connections is 128. Note that if you specify the <code dir="ltr"><span class="codeinlineitalic">size</span></code> setting, and you specify a value that is larger than the maximum number of connections according to the setting of the TimesTen <code dir="ltr">Connections</code> attribute, you will get an error when the number of connections exceeds the <code dir="ltr">Connections</code> value. Also see <a class="olink TTREF140" href="../TTREF/attribute.htm#TTREF140">&#34;Connections&#34;</a> in the <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For best overall performance, TimesTen recommends having one or two concurrent direct connections to the database for each CPU of the database server. For no reason should your number of concurrent direct connections (the size of your connection pool) be more than twice the number of CPUs on the database server. For client/server connections, however, TimesTen supports many more connections per CPU efficiently.</div>
<div id="TTCLS380" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref225"></a>
<h4 class="sect3">Usage</h4>
<p>To use the <code dir="ltr">TTConnectionPool</code> class, an application creates a single instance of the class. It then creates several <code dir="ltr"><a href="#i95276">TTConnection</a></code> objects, instances of either the <code dir="ltr">TTConnection</code> class or a user class that extends it, but does not call their <code dir="ltr">Connect()</code> methods directly. Instead, the application uses the <code dir="ltr">TTConnectionPool::AddConnectionToPool()</code> method to place connection objects into the pool, then calls <code dir="ltr">TTConnectionPool::ConnectAll()</code> to establish all the connections to TimesTen. In the background, <code dir="ltr">ConnectAll()</code> loops through all the <code dir="ltr">TTConnection</code> objects to call their <code dir="ltr">Connect()</code> methods.</p>
<p>Threads for TimesTen applications use the <code dir="ltr">getConnection()</code> and <code dir="ltr">freeConnection()</code> methods to get and return idle connections.</p>
<p>Also see <a href="usage.htm#i82204">&#34;Using TTCmd, TTConnection, and TTConnectionPool&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
If you want to use <code dir="ltr">TTConnectionPool</code> and extend <code dir="ltr">TTConnection</code>, do not override the <code dir="ltr">TTConnection::Connect()</code> method that has <code dir="ltr"><span class="codeinlineitalic">driverCompletion</span></code> in the calling sequence, because there is no corresponding <code dir="ltr">TTConnectionPool::ConnectAll()</code> method. Instead, override either of the following <code dir="ltr">Connect()</code> methods:
<pre dir="ltr">virtual void Connect(const char* <span class="italic">connStr</span>)
virtual void Connect(const char* <span class="italic">connStr</span>, const char* <span class="italic">username</span>, 
                     const char* <span class="italic">password</span>)
</pre>
<p>Then use the appropriate corresponding <code dir="ltr">ConnectAll()</code> method.</p>
</div>
<p>Privilege to connect to a database must be granted to users through the <code dir="ltr">CREATE SESSION</code> privilege, either directly or through the <code dir="ltr">PUBLIC</code> role. See <a href="usage.htm#CDEJBGDF">&#34;Access control for connections&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS230" class="sect3"><a id="sthref226"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS231" class="sect3"><a id="sthref227"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods for TTConnectionPool." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t13">Method</th>
<th class="cellalignment2190" id="r1c2-t13">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t13" headers="r1c1-t13"><code dir="ltr"><a href="#i99266">AddConnectionToPool()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t13 r1c2-t13">Adds a <code dir="ltr">TTConnection</code> object (possibly an object of a class derived from <code dir="ltr">TTConnection</code>) to the connection pool.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t13" headers="r1c1-t13"><code dir="ltr"><a href="#i99271">ConnectAll()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t13 r1c2-t13">Connects all the <code dir="ltr">TTConnection</code> objects to TimesTen simultaneously.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t13" headers="r1c1-t13"><code dir="ltr"><a href="#i99286">DisconnectAll()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t13 r1c2-t13">Disconnects all connections in the connection pool from TimesTen.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t13" headers="r1c1-t13"><code dir="ltr"><a href="#i99281">freeConnection()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t13 r1c2-t13">Returns a connection to the pool for reassignment to another thread.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t13" headers="r1c1-t13"><code dir="ltr"><a href="#i99276">getConnection()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t13 r1c2-t13">Checks out an idle connection from the connection pool for a thread.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t13" headers="r1c1-t13"><code dir="ltr"><a href="#i99291">getStats()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t13 r1c2-t13">Queries the <code dir="ltr">TTConnectionPool</code> object for connection pool status information.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="i99266"></a>
<div id="TTCLS232" class="sect4">
<h5 class="sect4">Add<a id="sthref228"></a><a id="sthref229"></a>ConnectionToPool()</h5>
<pre dir="ltr">int AddConnectionToPool(TTConnection* <span class="italic">connP</span>)
</pre>
<p>This method is used to add a <code dir="ltr">TTConnection</code> object (possibly an object of a class derived from <code dir="ltr">TTConnection</code>) to the connection pool. It returns -1 if there is an error. Also see <code dir="ltr"><a href="#i99281">freeConnection()</a></code>.</p>
</div>
<!-- class="sect4" -->
<a id="i99271"></a>
<div id="TTCLS233" class="sect4">
<h5 class="sect4">Con<a id="sthref230"></a>nectAll()</h5>
<pre dir="ltr">void ConnectAll(const char* <span class="italic">connStr</span>)
void ConnectAll(const char* <span class="italic">connStr</span>, const char* <span class="italic">username</span>, const char* <span class="italic">password</span>)
</pre>
<p>After all the <code dir="ltr">TTConnection</code> objects of an application have been added to the connection pool by <code dir="ltr">AddConnectionToPool()</code>, the <code dir="ltr">ConnectAll()</code> method can be used to connect all of the <code dir="ltr">TTConnection</code> objects to TimesTen simultaneously. The connection string specified in the <code dir="ltr"><span class="codeinlineitalic">connStr</span></code> parameter is used to create the connection. Specify a user and password, either as part of the connect string or as separate parameters. Also see the next method, <code dir="ltr">DisconnectAll()</code>.</p>
<p>A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs.</p>
<p>Privilege to connect to a database must be granted to users through the <code dir="ltr">CREATE SESSION</code> privilege, either directly or through the <code dir="ltr">PUBLIC</code> role. See <a href="usage.htm#CDEJBGDF">&#34;Access control for connections&#34;</a>.</p>
</div>
<!-- class="sect4" -->
<a id="i99286"></a>
<div id="TTCLS236" class="sect4">
<h5 class="sect4">Discon<a id="sthref231"></a><a id="sthref232"></a>nectAll()</h5>
<pre dir="ltr">void DisconnectAll()
</pre>
<p>Disconnects all connections in the connection pool from TimesTen. Also see the preceding method, <code dir="ltr">ConnectAll()</code>.</p>
<p>Applications must call <code dir="ltr">DisconnectAll()</code> before termination to avoid overhead associated with process failure analysis and recovery. A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs.</p>
</div>
<!-- class="sect4" -->
<a id="i99281"></a>
<div id="TTCLS235" class="sect4">
<h5 class="sect4">fre<a id="sthref233"></a><a id="sthref234"></a>eConnection()</h5>
<pre dir="ltr">void freeConnection(TTConnection* <span class="italic">connP</span>)
</pre>
<p>Returns a connection to the pool for reassignment to another thread. Applications should not free connections that are in the middle of a transaction. <code dir="ltr">TTConnection::Commit()</code> or <code dir="ltr">Rollback()</code> should be called immediately before the <code dir="ltr">TTConnection</code> object is passed to <code dir="ltr">freeConnection()</code>. Also see <code dir="ltr"><a href="#i99266">AddConnectionToPool()</a></code>.</p>
</div>
<!-- class="sect4" -->
<a id="i99276"></a>
<div id="TTCLS234" class="sect4">
<h5 class="sect4">ge<a id="sthref235"></a>tConnection()</h5>
<pre dir="ltr">TTConnection* getConnection(int <span class="italic">timeout_millis</span>=0)
</pre>
<p>Checks out an idle connection from the connection pool for use by a thread. A pointer to an idle <code dir="ltr">TTConnection</code> object is returned. The thread should then perform a transaction, ending with either <code dir="ltr">Commit()</code> or <code dir="ltr">Rollback()</code>, and then should return the connection to the pool using the <code dir="ltr">freeConnection()</code> method.</p>
<p>If no idle connections are in the pool, the thread calling <code dir="ltr">getConnection()</code> blocks until a connection is returned to the pool by a call to <code dir="ltr">freeConnection()</code>. An optional timeout, in milliseconds, can be provided. If this is provided, <code dir="ltr">getConnection()</code> waits for a free connection for no more than <code dir="ltr"><span class="codeinlineitalic">timeout_millis</span></code> milliseconds. If no connection is available in that time then <code dir="ltr">getConnection()</code> returns <code dir="ltr">NULL</code> to the caller.</p>
</div>
<!-- class="sect4" -->
<a id="i99291"></a>
<div id="TTCLS237" class="sect4">
<h5 class="sect4">g<a id="sthref236"></a><a id="sthref237"></a>etStats()</h5>
<pre dir="ltr">void getStats(int* <span class="italic">nGets</span>, int* <span class="italic">nFrees</span>, int* <span class="italic">nWaits</span>, int* <span class="italic">nTimeouts</span>,
              int* <span class="italic">maxInUse</span>, int* <span class="italic">nForcedCommits</span>)
</pre>
<p>Queries the <code dir="ltr">TTConnectionPool</code> for status information. The following data are returned:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">nGets</span></code>: Number of calls to <code dir="ltr">getConnection()</code></p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">nFrees</span></code>: Number of calls to <code dir="ltr">freeConnection()</code></p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">nWaits</span></code>: Number of times a call to <code dir="ltr">getConnection()</code> had to wait before returning a connection</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">nTimeouts</span></code>: Number of calls to <code dir="ltr">getConnection()</code> that timed out</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">maxInUse</span></code>: High point for the most number of connections in use simultaneously</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">nForcedCommits</span></code>: Number of times that <code dir="ltr">freeConnection()</code> had to call <code dir="ltr">Commit()</code> on a connection before checking it into the pool</p>
<p>If this counter is nonzero, the user application is not calling <code dir="ltr">TTConnection::Commit()</code> or <code dir="ltr">Rollback()</code> before returning a connection to the pool.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i95294"></a>
<div id="TTCLS179" class="sect2">
<h3 class="sect2"><a id="sthref238"></a><a id="sthref239"></a><a id="sthref240"></a><a id="sthref241"></a><a id="sthref242"></a>TTCmd</h3>
<p>A <code dir="ltr">TTCmd</code> object encapsulates a single SQL statement that is used multiple times in an application program. You can think of <code dir="ltr">TTCmd</code> as a value-added C++ wrapper around the ODBC statement (<code dir="ltr">SQLHSTMT</code>) handle.</p>
<p><code dir="ltr">TTCmd</code> has three categories of public methods:</p>
<ul>
<li>
<p><a href="#i113446">Public methods for general use and non-batch operations</a></p>
</li>
<li>
<p><a href="#i113460">Public methods for obtaining TTCmd object properties</a></p>
</li>
<li>
<p><a href="#i113465">Public methods for batch operations</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Important:</p>
Several <code dir="ltr">TTCmd</code> methods return an error if used with an ODBC driver manager. See <a href="compiling.htm#BCGEIJGG">&#34;Considerations when using an ODBC driver manager (Windows)&#34;</a> for information.</div>
<div id="TTCLS211" class="sect3"><a id="sthref243"></a>
<h4 class="sect3">Usage</h4>
<p>Each SQL statement executed multiple times in a program should have its own <code dir="ltr">TTCmd</code> object. Each of these <code dir="ltr">TTCmd</code> objects should be prepared once during program initialization, then executed with the <code dir="ltr">Execute()</code> method multiple times as the program runs.</p>
<p>Only database operations that are to be executed a small number of times should use the <code dir="ltr"><a href="#i99086">ExecuteImmediate()</a></code> method. Note that <code dir="ltr">ExecuteImmediate()</code> is not compatible with any type of <code dir="ltr">SELECT</code> statement. All queries must use <code dir="ltr">Prepare()</code> plus <code dir="ltr">Execute()</code> instead. <code dir="ltr">ExecuteImmediate()</code> is also incompatible with <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statements that are subsequently polled using <code dir="ltr">getRowcount()</code> to see how many rows were inserted, updated or deleted. These limitations have been placed on <code dir="ltr">ExecuteImmediate()</code> to discourage its use except in a few particular situations (for example, for creating or dropping a table).</p>
<p>Also see <a href="usage.htm#i82204">&#34;Using TTCmd, TTConnection, and TTConnectionPool&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you have reason to manipulate the underlying ODBC statement object directly, use the <code dir="ltr">TTCmd::getHandle()</code> method.</div>
<p>TimesTen has features to control database access with object-level resolution for database objects such as tables, views, materialized views, sequences, and synonyms. See <a href="usage.htm#CDEHEBFE">&#34;Considering TimesTen features for access control&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS180" class="sect3"><a id="sthref244"></a>
<h4 class="sect3">Public members</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Member descriptions" summary="This table contains descriptions of the public members of TTCmd." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t16">Member</th>
<th class="cellalignment2190" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t16" headers="r1c1-t16"><code dir="ltr">TTCMD_PARAM_INPUTOUTPUT_TYPE</code></td>
<td class="cellalignment2191" headers="r2c1-t16 r1c2-t16">This is used to specify whether a parameter is input, output, or input/output when registering the parameter. Supported values are <code dir="ltr">PARAM_IN</code>, <code dir="ltr">PARAM_INOUT</code>, and <code dir="ltr">PARAM_OUT</code>. See <a href="usage.htm#CDEIIABF">&#34;Registering parameters&#34;</a>.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect3" -->
<a id="i113446"></a>
<div id="TTCLS181" class="sect3">
<h4 class="sect3">Public me<a id="sthref245"></a><a id="sthref246"></a>thods for general use and non-batch operations</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions for public methods of TTCmd." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t17">Method</th>
<th class="cellalignment2190" id="r1c2-t17">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i109057">Close()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t17 r1c2-t17">Closes the result set when the application has finished fetching rows.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i109063">Drop()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t17 r1c2-t17">Frees a prepared SQL statement and all resources associated with it.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i99072">Execute()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t17 r1c2-t17">Invokes a SQL statement that has been prepared for execution.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i99086">ExecuteImmediate()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t17 r1c2-t17">Invokes a SQL statement that has not been previously prepared.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i99091">FetchNext()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t17 r1c2-t17">Fetches rows from the result set, one at a time. It returns 0 when a row was successfully fetched or 1 when no more rows are available.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i99121">getColumn()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t17 r1c2-t17">Retrieves the value in the specified column of the current row of the result set.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i99149">getColumnLength()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t17 r1c2-t17">Returns the length of the specified column, in bytes.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i115276">getColumnNullable()</a></code></td>
<td class="cellalignment2191" headers="r9c1-t17 r1c2-t17">Retrieves the value in the specified column of the current row of the result set and returns a boolean to indicate whether the value is <code dir="ltr">NULL</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#CHDFCHHG">getHandle()</a></code></td>
<td class="cellalignment2191" headers="r10c1-t17 r1c2-t17">Retrieves the underlying ODBC statement handle.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r11c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i99106">getMaxRows()</a></code></td>
<td class="cellalignment2191" headers="r11c1-t17 r1c2-t17">Returns the current limit on the number of rows returned by a <code dir="ltr">SELECT</code> statement.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r12c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i117666">getNextColumn()</a></code></td>
<td class="cellalignment2191" headers="r12c1-t17 r1c2-t17">Retrieves the value in the next column of the current row of the result set.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r13c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i117169">getNextColumnNullable()</a></code></td>
<td class="cellalignment2191" headers="r13c1-t17 r1c2-t17">Retrieves the value in the next column of the current row of the result set and returns a boolean to indicate whether the value is <code dir="ltr">NULL</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r14c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#CHDFFAII">getParam()</a></code></td>
<td class="cellalignment2191" headers="r14c1-t17 r1c2-t17">Each call gets the output value of a specified output or input/output parameter after executing a prepared SQL statement.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r15c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#CHDJFGEB">getQueryThreshold()</a></code></td>
<td class="cellalignment2191" headers="r15c1-t17 r1c2-t17">Retrieves the query threshold value.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r16c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i115044">getRowCount()</a></code></td>
<td class="cellalignment2191" headers="r16c1-t17 r1c2-t17">Returns the number of rows that were affected by the recently executed SQL operation.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r17c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i99144">isColumnNull()</a></code></td>
<td class="cellalignment2191" headers="r17c1-t17 r1c2-t17">Indicates whether the value in the specified column of the current row is <code dir="ltr">NULL</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r18c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i104817">Prepare()</a></code></td>
<td class="cellalignment2191" headers="r18c1-t17 r1c2-t17">Associates a SQL statement with the <code dir="ltr">TTCmd</code> object.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r19c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i117218">printColumn()</a></code></td>
<td class="cellalignment2191" headers="r19c1-t17 r1c2-t17">Prints the value in the specified column of the current row to an output stream.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r20c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#CHDCEHGD">registerParam()</a></code></td>
<td class="cellalignment2191" headers="r20c1-t17 r1c2-t17">Registers a parameter for binding. This is required for output or input/output parameters.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r21c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i116963">RePrepare()</a></code></td>
<td class="cellalignment2191" headers="r21c1-t17 r1c2-t17">In situations where the statement handle for a prepared statement has been invalidated, this allows the statement to be re-prepared.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r22c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i99101">setMaxRows()</a></code></td>
<td class="cellalignment2191" headers="r22c1-t17 r1c2-t17">Sets a limit on the number of rows returned by a <code dir="ltr">SELECT</code> statement.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r23c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i99116">setParam()</a></code></td>
<td class="cellalignment2191" headers="r23c1-t17 r1c2-t17">Each call sets the value of a specified parameter before executing a prepared SQL statement.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r24c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#CHDBIBBC">setParamLength()</a></code></td>
<td class="cellalignment2191" headers="r24c1-t17 r1c2-t17">Sets the length, in bytes, of the specified input parameter.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r25c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i111602">setParamNull()</a></code></td>
<td class="cellalignment2191" headers="r25c1-t17 r1c2-t17">Sets the value of a parameter to <code dir="ltr">NULL</code> before executing a prepared SQL statement.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r26c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#CHDFEEJC">setQueryThreshold()</a></code></td>
<td class="cellalignment2191" headers="r26c1-t17 r1c2-t17">Sets a threshold time limit for execution of each SQL statement. If it is exceeded, a warning is written to the support log and an SNMP trap is thrown.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r27c1-t17" headers="r1c1-t17"><code dir="ltr"><a href="#i114811">setQueryTimeout()</a></code></td>
<td class="cellalignment2191" headers="r27c1-t17 r1c2-t17">Sets a timeout value for SQL statements.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="i109057"></a>
<div id="TTCLS189" class="sect4">
<h5 class="sect4">Clo<a id="sthref247"></a><a id="sthref248"></a>se()</h5>
<pre dir="ltr">void Close()
</pre>
<p>If a SQL <code dir="ltr">SELECT</code> statement is executed using the <code dir="ltr">Execute()</code> method, a cursor is opened which may be used to fetch rows from the result set. When the application is finished fetching rows from the result set, it must be closed with the <code dir="ltr">Close()</code> method.</p>
<p>Failure to close the result set may result in locks being held on rows for too long, causing concurrency problems, memory leaks, and other errors.</p>
<p>A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs.</p>
</div>
<!-- class="sect4" -->
<a id="i109063"></a>
<div id="TTCLS190" class="sect4">
<h5 class="sect4">Dr<a id="sthref249"></a><a id="sthref250"></a>op()</h5>
<pre dir="ltr">void Drop()
</pre>
<p>If a prepared SQL statement will not be used in the future, the statement and resources associated with it can be freed by a call to the <code dir="ltr">Drop()</code> method. The <code dir="ltr">TTCmd</code> object may be reused for another statement if <code dir="ltr">Prepare()</code> is called again.</p>
<p>It is more efficient to use multiple <code dir="ltr">TTCmd</code> objects to execute multiple SQL statements. Use the <code dir="ltr">Drop()</code> method only if a particular SQL statement will not be used again.</p>
<p>A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs.</p>
</div>
<!-- class="sect4" -->
<a id="i99072"></a>
<div id="TTCLS186" class="sect4">
<h5 class="sect4">Exe<a id="sthref251"></a><a id="sthref252"></a>cute()</h5>
<pre dir="ltr">void Execute()
</pre>
<p>This method invokes a SQL statement that has been prepared for execution with the <code dir="ltr">Prepare()</code> method, after any necessary parameter values are defined using <code dir="ltr">setParam()</code> calls. A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs.</p>
<p>If the SQL statement is a <code dir="ltr">SELECT</code> statement, this method executes the query but does not return any rows from the result set. Use the <code dir="ltr">FetchNext()</code> method to fetch rows from the result set one at a time. Use the <code dir="ltr">Close()</code> method to close the result set when all appropriate rows have been fetched. For SQL statements other than <code dir="ltr">SELECT</code>, no cursor is opened, and a call to the <code dir="ltr">Close()</code> method is not necessary.</p>
<p>TimesTen has features to control database access with object-level resolution for database objects such as tables, views, materialized views, sequences, and synonyms. Access control privileges are checked both when SQL is prepared and when it is executed in the database, with most of the performance cost coming at prepare time. See <a href="usage.htm#CDEHEBFE">&#34;Considering TimesTen features for access control&#34;</a>.</p>
</div>
<!-- class="sect4" -->
<a id="i99086"></a>
<div id="TTCLS187" class="sect4">
<h5 class="sect4">ExecuteIm<a id="sthref253"></a><a id="sthref254"></a>mediate()</h5>
<pre dir="ltr">int ExecuteImmediate(TTConnection* <span class="italic">cP</span>, const char* <span class="italic">sqlp</span>)
</pre>
<p>This method invokes a SQL statement that has not been previously prepared.</p>
<p><code dir="ltr">ExecuteImmediate()</code> is a convenient alternative to using <code dir="ltr">Prepare()</code> and <code dir="ltr">Execute()</code> when a SQL statement is to be executed only a small number of times. Use <code dir="ltr">ExecuteImmediate()</code> for DDL statements such as <code dir="ltr">CREATE TABLE</code> and <code dir="ltr">DROP TABLE</code>, and infrequently used DML statements that do not return a result set (for example, <code dir="ltr">DELETE FROM</code> <code dir="ltr"><span class="codeinlineitalic">table_name</span></code>).</p>
<p><code dir="ltr">ExecuteImmediate()</code> is incompatible with SQL statements that return a result set. In addition, statements executed through <code dir="ltr">ExecuteImmediate()</code> cannot subsequently be queried by <code dir="ltr">getRowCount()</code> to get the number of rows affected by a DML operation. Because of this, <code dir="ltr">ExecuteImmediate()</code> calls <code dir="ltr">getRowCount()</code> automatically, and its value is the integer return value of this method.</p>
<p>A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs.</p>
</div>
<!-- class="sect4" -->
<a id="i99091"></a>
<div id="TTCLS188" class="sect4">
<h5 class="sect4">Fe<a id="sthref255"></a><a id="sthref256"></a><a id="sthref257"></a>tchNext()</h5>
<pre dir="ltr">int FetchNext()
</pre>
<p>After executing a prepared SQL <code dir="ltr">SELECT</code> statement using the <code dir="ltr">Execute()</code> method, use the <code dir="ltr">FetchNext()</code> method to fetch rows from the result set, one at a time.</p>
<p>After fetching a row of the result set, use the appropriate overloaded <code dir="ltr">getColumn()</code> method to fetch values from the current row.</p>
<p>If no more rows remain in the result set, <code dir="ltr">FetchNext()</code> returns 1. If a row is returned, <code dir="ltr">FetchNext()</code> returns 0.</p>
<p>After executing a <code dir="ltr">SELECT</code> statement using the <code dir="ltr">Execute()</code> method, the result set must be closed using the <code dir="ltr">Close()</code> method after all desired rows have been fetched. Note that after the <code dir="ltr">Close()</code> method is called, the <code dir="ltr">FetchNext()</code> method cannot be used to fetch additional rows from the result set.</p>
<p>A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs.</p>
</div>
<!-- class="sect4" -->
<a id="i99121"></a>
<div id="TTCLS202" class="sect4">
<h5 class="sect4">get<a id="sthref258"></a><a id="sthref259"></a>Column()</h5>
<pre dir="ltr">void getColumn (int <span class="italic">cno</span>, TYPE* <span class="italic">valueP</span>)
void getColumn (int <span class="italic">cno</span>, TYPE* <span class="italic">valueP</span>, int* <span class="italic">byteLenP</span>)
</pre>
<p>The <code dir="ltr">getColumn()</code> method, as well as the <code dir="ltr"><a href="#i115276">getColumnNullable()</a></code> method, fetches the values for columns of the current row of the result set. Before <code dir="ltr">getColumn()</code> or <code dir="ltr">getColumnNullable()</code> can be called, the <code dir="ltr">FetchNext()</code> method must be called to fetch the next (or first) row from the result set of a <code dir="ltr">SELECT</code> statement. SQL statements are executed using the <code dir="ltr">Execute()</code> method.</p>
<p>Each <code dir="ltr">getColumn()</code> call retrieves the value associated with a particular column. Columns are referred to by ordinal number, with &#34;1&#34; indicating the first column specified in the <code dir="ltr">SELECT</code> statement. In all cases the first argument passed to the <code dir="ltr">getColumn()</code> method, <code dir="ltr"><span class="codeinlineitalic">cno</span></code>, is the ordinal number of the column whose value is to be fetched. The second argument, <code dir="ltr"><span class="codeinlineitalic">valueP</span></code>, is a pointer to a variable that stores the value of the specified column. The type of this argument varies depending on the type of the column being returned. For <code dir="ltr">NCHAR</code>, <code dir="ltr">NVARCHAR</code>, and binary types, as shown in the table, the method call also specifies <code dir="ltr"><span class="codeinlineitalic">byteLenP</span></code>, a pointer to an integer value for the number of bytes written into the <code dir="ltr"><span class="codeinlineitalic">valueP</span></code> buffer.</p>
<p>The TTClasses library does not support a large set of data type conversions. The appropriate version of <code dir="ltr">getColumn()</code> must be called for each output column in the prepared SQL. Calling the wrong version, such as attempting to fetch an integer column into a <code dir="ltr">char*</code> value, results in a thrown exception (<code dir="ltr">TTStatus</code> object).</p>
<p>When fetching integer-type data from <code dir="ltr">NUMBER</code> columns, <code dir="ltr">getColumn()</code> supports the following variants: <code dir="ltr">SQLTINYINT</code>, <code dir="ltr">SQLSMALLINT</code>, <code dir="ltr">SQLINTEGER</code>, and <code dir="ltr">SQLBIGINT</code>. They are appropriate only for <code dir="ltr">NUMBER</code> fields with the scale parameter set to zero, such as <code dir="ltr">NUMBER(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code> or <code dir="ltr">NUMBER(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">,0)</code>. The functions have the following range of precision.</p>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Function ranges" summary="Precision ranges for integer type functions." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t18">Function</th>
<th class="cellalignment2190" id="r1c2-t18">Precision Range</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t18" headers="r1c1-t18"><code dir="ltr">SQLTINYINT</code></td>
<td class="cellalignment2191" headers="r2c1-t18 r1c2-t18">0&lt;=<code dir="ltr"><span class="codeinlineitalic">p</span></code>&lt;=2</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t18" headers="r1c1-t18"><code dir="ltr">SQLSMALLINT</code></td>
<td class="cellalignment2191" headers="r3c1-t18 r1c2-t18">0&lt;=<code dir="ltr"><span class="codeinlineitalic">p</span></code>&lt;=4</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t18" headers="r1c1-t18"><code dir="ltr">SQLINTEGER</code></td>
<td class="cellalignment2191" headers="r4c1-t18 r1c2-t18">0&lt;=<code dir="ltr"><span class="codeinlineitalic">p</span></code>&lt;=9</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t18" headers="r1c1-t18"><code dir="ltr">SQLBIGINT</code></td>
<td class="cellalignment2191" headers="r5c1-t18 r1c2-t18">0&lt;=<code dir="ltr"><span class="codeinlineitalic">p</span></code>&lt;=18</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<p>To ensure that all values in the column fit into the variable that the application uses to retrieve information from the database, you can use <code dir="ltr">SQLBIGINT</code> for all table columns of data type <code dir="ltr">NUMBER(</code><code dir="ltr"><span class="codeinlineitalic">p</span></code><code dir="ltr">)</code>, where 0 &lt;= <code dir="ltr"><span class="codeinlineitalic">p</span></code> &lt;= 18. For example:</p>
<pre dir="ltr">getColumn(int <span class="italic">cno</span>, SQLBIGINT* <span class="italic">iP</span>)
</pre>
<p><a href="#g135331">Table 3-2</a> shows the supported TimesTen column types and the appropriate versions of <code dir="ltr">getColumn()</code> and <code dir="ltr">getColumnNullable()</code> to use for each parameter type.</p>
<div id="TTCLS203" class="tblhruleformal">
<p class="titleintable"><a id="sthref260"></a><a id="g135331"></a>Table 3-2 getColumn() variants for supported TimesTen table column types</p>
<table class="cellalignment2189" title="getColumn() variants for supported TimesTen table column types" summary="This table shows the supported SQL data types and the appropriate versions of getColumn and getColumnNullable to use for each parameter type." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t19">Data type</th>
<th class="cellalignment2190" id="r1c2-t19">getColumn() variants supported</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t19" headers="r1c1-t19">
<p><code dir="ltr">TT_TINYINT</code></p>
</td>
<td class="cellalignment2191" headers="r2c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLTINYINT* <span class="italic">iP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t19" headers="r1c1-t19">
<p><code dir="ltr">TT_SMALLINT</code></p>
</td>
<td class="cellalignment2191" headers="r3c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLSMALLINT* <span class="italic">iP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t19" headers="r1c1-t19">
<p><code dir="ltr">TT_INTEGER</code></p>
</td>
<td class="cellalignment2191" headers="r4c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLINTEGER* <span class="italic">iP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t19" headers="r1c1-t19">
<p><code dir="ltr">TT_BIGINT</code></p>
</td>
<td class="cellalignment2191" headers="r5c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLBIGINT* <span class="italic">iP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t19" headers="r1c1-t19">
<p><code dir="ltr">BINARY_FLOAT</code></p>
</td>
<td class="cellalignment2191" headers="r6c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, float* <span class="italic">fP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t19" headers="r1c1-t19">
<p><code dir="ltr">BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment2191" headers="r7c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, double* <span class="italic">dP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t19" headers="r1c1-t19">
<p><code dir="ltr">NUMBER</code></p>
<p><code dir="ltr">TT_DECIMAL</code></p>
</td>
<td class="cellalignment2191" headers="r8c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre>
<pre dir="ltr">getColumn(<span class="italic">cno</span>, char* <span class="italic">cP</span>)
</pre>
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLTINYINT* <span class="italic">iP</span>)
</pre>
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLSMALLINT* <span class="italic">iP</span>)
</pre>
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLINTEGER* <span class="italic">iP</span>)
</pre>
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLBIGINT* <span class="italic">iP</span>)
</pre>
<p><span class="bold">Note:</span> The <code dir="ltr">char*</code> version allows TTClasses to pass in an array of preallocated storage, and TTClasses copies the <code dir="ltr">char</code> output fetched from the database into this array. The integer type methods are appropriate only for columns declared with the scale parameter set to zero.</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t19" headers="r1c1-t19">
<p><code dir="ltr">TT_CHAR</code></p>
<p><code dir="ltr">CHAR</code></p>
<p><code dir="ltr">TT_VARCHAR</code></p>
<p><code dir="ltr">VARCHAR2</code></p>
</td>
<td class="cellalignment2191" headers="r9c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre>
<pre dir="ltr">getColumn(<span class="italic">cno</span>, char* <span class="italic">cP</span>)
</pre>
<p><span class="bold">Note</span>: The <code dir="ltr">char*</code> version enables you to preallocate the output buffer.</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t19" headers="r1c1-t19">
<p><code dir="ltr">TT_NCHAR</code></p>
<p><code dir="ltr">NCHAR</code></p>
<p><code dir="ltr">TT_NVARCHAR</code></p>
<p><code dir="ltr">NVARCHAR2</code></p>
</td>
<td class="cellalignment2191" headers="r10c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLWCHAR** <span class="italic">wcPP</span>)
</pre>
<pre dir="ltr">getColumn(<span class="italic">cno</span>, SQLWCHAR** <span class="italic">wcPP</span>, <span class="italic">byteLenP</span>)
</pre>
<p><span class="bold">Note</span>: Optionally use the <code dir="ltr"><span class="codeinlineitalic">byteLenP</span></code> parameter for the number of bytes in the returned value.</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r11c1-t19" headers="r1c1-t19">
<p><code dir="ltr">BINARY</code></p>
<p><code dir="ltr">VARBINARY</code></p>
</td>
<td class="cellalignment2191" headers="r11c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, void** <span class="italic">binPP</span>, <span class="italic">byteLenP</span>)
</pre>
<pre dir="ltr">getColumn(<span class="italic">cno</span>, void* <span class="italic">binP</span>, <span class="italic">byteLenP</span>)
</pre>
<p><span class="bold">Note</span>: The <code dir="ltr">void*</code> version enables you to preallocate the output buffer.</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r12c1-t19" headers="r1c1-t19">
<p><code dir="ltr">DATE</code></p>
<p><code dir="ltr">TT_TIMESTAMP</code></p>
<p><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment2191" headers="r12c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, TIMESTAMP_STRUCT* <span class="italic">tsP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r13c1-t19" headers="r1c1-t19">
<p><code dir="ltr">TT_DATE</code></p>
</td>
<td class="cellalignment2191" headers="r13c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, DATE_STRUCT* <span class="italic">dP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r14c1-t19" headers="r1c1-t19">
<p><code dir="ltr">TT_TIME</code></p>
</td>
<td class="cellalignment2191" headers="r14c1-t19 r1c2-t19">
<pre dir="ltr">getColumn(<span class="italic">cno</span>, TIME_STRUCT* <span class="italic">tP</span>)
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" -->
<p>Other TimesTen table column types are not supported in this release of the TTClasses library.</p>
</div>
<!-- class="sect4" -->
<a id="i99149"></a>
<div id="TTCLS205" class="sect4">
<h5 class="sect4">getColum<a id="sthref261"></a>nLength()</h5>
<pre dir="ltr">int getColumnLength(int <span class="italic">cno</span>)
</pre>
<p>Returns the length, in bytes, of the value in column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> of the current row, not counting the <code dir="ltr">NULL</code> terminator. Or it returns <code dir="ltr">SQL_NULL_DATA</code> if the value is <code dir="ltr">NULL</code>. (For those familiar with ODBC, this is the value stored by ODBC in the last parameter, <code dir="ltr"><span class="codeinlineitalic">pcbValue</span></code>, from <code dir="ltr">SQLBindCol</code> after a call to <code dir="ltr">SQLFetch</code>.) When there is a non-null value, the length returned is between 0 and the column precision, inclusive. See <a href="#i99228">&#34;getColumnPrecision()&#34;</a>.</p>
<p>For example, assume a <code dir="ltr">VARCHAR2(25)</code> column. If the value is null, the length returned is -1. If the value is &#39;<code dir="ltr">abcde</code>&#39;, the length returned is 5.</p>
<p>This method is generally useful only when accessing columns of type <code dir="ltr">CHAR</code>, <code dir="ltr">VARCHAR2</code>, <code dir="ltr">NCHAR</code>, <code dir="ltr">NVARCHAR2</code>, <code dir="ltr">BINARY</code>, and <code dir="ltr">VARBINARY</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i115276"></a>
<div id="TTCLS206" class="sect4">
<h5 class="sect4">get<a id="sthref262"></a>ColumnNullable()</h5>
<pre dir="ltr">bool getColumnNullable(int <span class="italic">cno</span>, TYPE* <span class="italic">valueP</span>)
bool getColumnNullable(int <span class="italic">cno</span>, TYPE* <span class="italic">valueP</span>, int* <span class="italic">byteLenP</span>)
</pre>
<p>The <code dir="ltr">getColumnNullable()</code> method is similar to the <code dir="ltr"><a href="#i99121">getColumn()</a></code> method and supports the same data types and signatures as documented in <a href="#g135331">Table 3-2</a> above. However, in addition to the behavior of <code dir="ltr">getColumn()</code>, the <code dir="ltr">getColumnNullable()</code> method also returns a boolean indicating whether the value is the SQL <code dir="ltr">NULL</code> pseudo-value. If the value is <code dir="ltr">NULL</code>, the second parameter is set to a distinctive value (for example, -9999) and the return value from the method is <code dir="ltr">TRUE</code>. If the value is not <code dir="ltr">NULL</code>, it is returned through the variable pointed to by the second parameter and the <code dir="ltr">getColumnNullable()</code> method returns <code dir="ltr">FALSE</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDFCHHG"></a>
<div id="TTCLS381" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">g<a id="sthref263"></a><a id="sthref264"></a><a id="sthref265"></a>etHandle()</h5>
<pre dir="ltr">SQLHSTMT getHandle()
</pre>
<p>If you must manipulate the underlying ODBC statement object, use this method to retrieve the statement handle.</p>
</div>
<!-- class="sect4" -->
<a id="i99106"></a>
<div id="TTCLS194" class="sect4">
<h5 class="sect4">ge<a id="sthref266"></a>tMaxRows()</h5>
<pre dir="ltr">int getMaxRows()
</pre>
<p>This method returns the current limit of the number of rows returned by a <code dir="ltr">SELECT</code> statement from this <code dir="ltr">TTCmd</code> object. A return value of 0 means all rows are returned. Also see <code dir="ltr"><a href="#i99101">setMaxRows()</a></code>.</p>
</div>
<!-- class="sect4" -->
<a id="i117666"></a>
<div id="TTCLS207" class="sect4">
<h5 class="sect4">get<a id="sthref267"></a><a id="sthref268"></a>NextColumn()</h5>
<pre dir="ltr">void getNextColumn(TYPE* <span class="italic">valueP</span>)
void getNextColumn(TYPE* <span class="italic">valueP</span>, int* <span class="italic">byteLenP</span>)
</pre>
<p>The <code dir="ltr">getNextColumn()</code> method, as well as the <code dir="ltr">getNextColumnNullable()</code> method, fetches the value of the next column of the current row of the result set. Before <code dir="ltr">getNextColumn()</code> or <code dir="ltr">getNextColumnNullable()</code> can be called, the <code dir="ltr">FetchNext()</code> method must be called to fetch the next (or first) row from the result set of a <code dir="ltr">SELECT</code> statement. When you use <code dir="ltr">getNextColumn()</code>, the columns are fetched in order. You cannot change the fetch order.</p>
<p>See <a href="#g135331">Table 3-2</a> for the supported SQL data types and the appropriate method version to use for each data type. This information can be used for <code dir="ltr">getNextColumn()</code>, except there is no column number parameter for <code dir="ltr">getNextColumn()</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i117169"></a>
<div id="TTCLS208" class="sect4">
<h5 class="sect4">get<a id="sthref269"></a>NextColumnNullable()</h5>
<pre dir="ltr">bool getNextColumnNullable(TYPE* <span class="italic">valueP</span>)
bool getNextColumnNullable(TYPE* <span class="italic">valueP</span>, int* <span class="italic">byteLenP</span>)
</pre>
<p>The <code dir="ltr">getNextColumnNullable()</code> method is similar to the <code dir="ltr"><a href="#i117666">getNextColumn()</a></code> method. However, in addition to the behavior of <code dir="ltr">getNextColumn()</code>, the <code dir="ltr">getNextColumnNullable()</code> method returns a boolean indicating whether the value is the SQL <code dir="ltr">NULL</code> pseudo-value. If the value is <code dir="ltr">NULL</code>, the second parameter is set to a distinctive value (for example, -9999) and the return value from the method is <code dir="ltr">TRUE</code>. If the value is not <code dir="ltr">NULL</code>, it is returned through the variable pointed to by the second parameter, and the method returns <code dir="ltr">FALSE</code>. When you use <code dir="ltr">getNextColumnNullable()</code>, the columns are fetched in order. You cannot change the fetch order.</p>
<p>See <a href="#g135331">Table 3-2</a> for the supported SQL data types and the appropriate method versions to use for each data type. This information can be used for <code dir="ltr">getNextColumnNullable()</code>, except there is no column number parameter for <code dir="ltr">getNextColumnNullable()</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDFFAII"></a>
<div id="TTCLS383" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref270"></a><a id="sthref271"></a>Param()</h5>
<pre dir="ltr">bool getParam(int <span class="italic">pno</span>, TYPE* <span class="italic">valueP</span>)
bool getParam(int <span class="italic">pno</span>, TYPE* <span class="italic">valueP</span>, int* <span class="italic">byteLenP</span>)
</pre>
<p>Each <code dir="ltr">getParam()</code> version is used to retrieve the value of an output or input/output parameter, specified by parameter number, after executing a prepared SQL statement. SQL statements are prepared before use with the <code dir="ltr">Prepare()</code> method and are executed with the <code dir="ltr">Execute()</code> method. The <code dir="ltr">getParam()</code> method is used to provide a variable of appropriate data type for the value for each output parameter after executing the statement.</p>
<p>The first argument passed to <code dir="ltr">getParam()</code> is the position of the parameter for the output value. The first parameter in a SQL statement is parameter 1. The second argument passed to <code dir="ltr">getParam()</code> is a variable for the output value. Overloaded versions of <code dir="ltr">getParam()</code> take different data types for the second argument.</p>
<p>The <code dir="ltr">getParam()</code> method supports the same data types documented for <code dir="ltr"><a href="#i99121">getColumn()</a></code> in <a href="#g135331">Table 3-2</a>. For <code dir="ltr">NCHAR</code>, <code dir="ltr">NVARCHAR</code>, and binary types, as shown in that table, the method call specifies <code dir="ltr"><span class="codeinlineitalic">byteLenP</span></code>, a pointer to an integer value for the number of bytes in the parameter value.</p>
<p>The <code dir="ltr">getParam()</code> return is a boolean that is <code dir="ltr">TRUE</code> if the parameter value is <code dir="ltr">NULL</code>, or <code dir="ltr">FALSE</code> otherwise.</p>
<p>The TTClasses library does not support a large set of data type conversions. The appropriate overloaded version of <code dir="ltr">getParam()</code> must be called for each output parameter in the prepared SQL. Calling the wrong version (attempting to use an integer parameter for a <code dir="ltr">char*</code> value, for example) may result in program failure.</p>
<p>See <a href="usage.htm#CDEEICCH">&#34;Binding output or input/output parameters&#34;</a> for examples using <code dir="ltr">getParam()</code>.</p>
<p>For R<a id="sthref272"></a>EF CURSORs, the following signature is supported to use a <code dir="ltr">TTCmd</code> object as a statement handle for the REF CURSOR (data type <code dir="ltr">SQL_REFCURSOR</code>). See <a href="usage.htm#CDEBAFHB">&#34;Working with REF CURSORs&#34;</a> for information and an example.</p>
<pre dir="ltr">bool getParam(int <span class="italic">pno</span>, TTCmd** <span class="italic">rcCmd</span>)
</pre></div>
<!-- class="sect4" -->
<a id="CHDJFGEB"></a>
<div id="TTCLS209" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">ge<a id="sthref273"></a>tQueryThreshold()</h5>
<pre dir="ltr">int getQueryThreshold()
</pre>
<p>Returns the threshold value for the <code dir="ltr">TTCmd</code> object, as described in <a href="#CHDFEEJC">&#34;setQueryThreshold()&#34;</a>.</p>
<p>If no value has been set with <code dir="ltr">setQueryThreshold()</code>, this method returns the value of the ODBC connection option <code dir="ltr">TT_QUERY_THRESHOLD</code> (if set) or of the TimesTen general connection attribute <code dir="ltr">QueryThreshold</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i115044"></a>
<div id="TTCLS195" class="sect4">
<h5 class="sect4">getRo<a id="sthref274"></a><a id="sthref275"></a>wCount()</h5>
<pre dir="ltr">int getRowCount()
</pre>
<p>This method can be called immediately after <code dir="ltr">Execute()</code> to return the number of rows that were affected by the executed SQL operation. For example, after execution of a <code dir="ltr">DELETE</code> statement that deletes 10 rows, <code dir="ltr">getRowCount()</code> returns 10.</p>
</div>
<!-- class="sect4" -->
<a id="i99144"></a>
<div id="TTCLS204" class="sect4">
<h5 class="sect4">isColu<a id="sthref276"></a>mnNull()</h5>
<pre dir="ltr">bool isColumnNull(int <span class="italic">cno</span>)
</pre>
<p>This method provides another way to determine whether the value in column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> of the current row is <code dir="ltr">NULL</code>, returning <code dir="ltr">TRUE</code> if so, or <code dir="ltr">FALSE</code> otherwise.</p>
<p>Also see information about the <code dir="ltr"><a href="#i115276">getColumnNullable()</a></code> method.</p>
</div>
<!-- class="sect4" -->
<a id="i104817"></a>
<div id="TTCLS184" class="sect4">
<h5 class="sect4">Pre<a id="sthref277"></a><a id="sthref278"></a>pare()</h5>
<pre dir="ltr">void Prepare(TTConnection* <span class="italic">cP</span>, const char* <span class="italic">sqlp</span>)
</pre>
<p>This method associates a SQL statement with the <code dir="ltr">TTCmd</code> object. It takes two parameters:</p>
<ul>
<li>
<p>A pointer to a <code dir="ltr">TTConnection</code> object</p>
<p>The connection object should be connected to the database by a call to <code dir="ltr">TTConnection::Connect()</code>.</p>
</li>
<li>
<p>A <code dir="ltr">const char*</code> parameter for the SQL statement being prepared</p>
</li>
</ul>
<p>TimesTen has features to control database access with object-level resolution for database objects such as tables, views, materialized views, sequences, and synonyms. Access control privileges are checked both when SQL is prepared and when it is executed in the database, with most of the performance cost coming at prepare time. See <a href="usage.htm#CDEHEBFE">&#34;Considering TimesTen features for access control&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>To<a id="sthref279"></a><a id="sthref280"></a> avoid unwanted round trips between client and server in client/server connections, the <code dir="ltr">Prepare()</code> method performs what is referred to as a &#34;deferred prepare&#34;, where the request is not sent to the server until required. See <a class="olink TTCDV129" href="../TTCDV/writing_app.htm#TTCDV129">&#34;TimesTen deferred prepare&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span> for more information.</p>
</li>
<li>
<p>By default (when connection attribute <code dir="ltr">PrivateCommands=0</code>), TimesTen shares prepared SQL statements between connections, so subsequent prepares of the same SQL statement on different connections execute very quickly.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<a id="i117218"></a>
<div id="TTCLS210" class="sect4">
<h5 class="sect4">printColu<a id="sthref281"></a><a id="sthref282"></a>mn()</h5>
<pre dir="ltr">void printColumn(int <span class="italic">cno</span>, STDOSTREAM&amp; <span class="italic">os</span>, const char*  <span class="italic">nullString</span>) const
</pre>
<p>This method prints the value in column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> of the current row to the output stream <code dir="ltr"><span class="codeinlineitalic">os</span></code>. Use this for debugging or for demo programs. Use <code dir="ltr"><span class="codeinlineitalic">nullString</span></code> to specify what should be printed if the column value is <code dir="ltr">NULL</code> (for example, &#34;NULL&#34; or &#34;?&#34;).</p>
</div>
<!-- class="sect4" -->
<a id="CHDCEHGD"></a>
<div id="TTCLS382" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">register<a id="sthref283"></a><a id="sthref284"></a>Param()</h5>
<pre dir="ltr">void registerParam(int <span class="italic">pno</span>, TTCMD_PARAM_INPUTOUTPUT_TYPE <span class="italic">inputOutputType</span>,
                   int <span class="italic">sqltype</span>)
void registerParam(int <span class="italic">pno</span>, TTCMD_PARAM_INPUTOUTPUT_TYPE <span class="italic">inputOutputType</span>, 
                   int <span class="italic">sqltype</span>, int <span class="italic">precision</span>)
void registerParam(int <span class="italic">pno</span>, TTCMD_PARAM_INPUTOUTPUT_TYPE <span class="italic">inputOutputType</span>, 
                   int <span class="italic">sqltype</span>, int <span class="italic">precision</span>, int <span class="italic">scale</span>)
</pre>
<p>Use this method to register a parameter for binding. This is required for output and input/output parameters and can also be used as appropriate to specify SQL type, precision (maximum number of digits that are used by the data type, where applicable), and scale (maximum number of digits to the right of the decimal point, where applicable). See <a href="usage.htm#CDEIIABF">&#34;Registering parameters&#34;</a>.</p>
</div>
<!-- class="sect4" -->
<a id="i116963"></a>
<div id="TTCLS185" class="sect4">
<h5 class="sect4">RePre<a id="sthref285"></a><a id="sthref286"></a>pare()</h5>
<pre dir="ltr">void RePrepare(TTConnection* <span class="italic">cP</span>)
</pre>
<p>This method prepares the statement again. It is useful only when a statement handle in a prepared statement has been invalidated, such as when a table referenced by the SQL statement has been altered, for example. Also see <code dir="ltr"><a href="#i104817">Prepare()</a></code>.</p>
</div>
<!-- class="sect4" -->
<a id="i99101"></a>
<div id="TTCLS193" class="sect4">
<h5 class="sect4">se<a id="sthref287"></a><a id="sthref288"></a>tMaxRows()</h5>
<pre dir="ltr">void setMaxRows(const int <span class="italic">nMaxRows</span>)
</pre>
<p>This method sets a limit on the number of rows returned by a <code dir="ltr">SELECT</code> statement. If the number of rows in the result set exceeds the set limit, the <code dir="ltr">TTCmd::<a href="#i99091">FetchNext()</a></code> method returns 1 when it has fetched the last row in the requested set size. Also see <code dir="ltr"><a href="#i99106">getMaxRows()</a></code>.</p>
<p>The default is to return all rows. To reset a limit to again return all rows, call <code dir="ltr">setMaxRows()</code> with <code dir="ltr"><span class="codeinlineitalic">nMaxRows</span></code> set to 0. The limit is only meaningful for <code dir="ltr">SELECT</code> statements.</p>
</div>
<!-- class="sect4" -->
<a id="i99116"></a>
<div id="TTCLS196" class="sect4">
<h5 class="sect4">set<a id="sthref289"></a><a id="sthref290"></a>Param()</h5>
<pre dir="ltr">void setParam(int <span class="italic">pno</span>, TYPE <span class="italic">value</span>)
void setParam(int <span class="italic">pno</span>, TYPE* <span class="italic">valueP</span>)
void setParam(int <span class="italic">pno</span>, TYPE* <span class="italic">valueP</span>, int <span class="italic">byteLen</span>)
</pre>
<p>All overloaded <code dir="ltr">setParam()</code> versions are described in this section.</p>
<p>Each <code dir="ltr">setParam()</code> version is used to set the value of a parameter, specified by parameter number, before executing a prepared SQL statement. SQL statements are prepared before use with the <code dir="ltr">Prepare()</code> method and are executed with the <code dir="ltr">Execute()</code> method. If the SQL statement contains any parameter markers (the &#34;?&#34; character used where a literal constant would be legal), values must be assigned to these parameters before the SQL statement can be executed. The <code dir="ltr">setParam()</code> method is used to define a value for each parameter before executing the statement. See <a class="olink TTSQL191" href="../TTSQL/names.htm#TTSQL191">&#34;Dynamic parameters&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database SQL Reference</span>.</p>
<p>The first argument passed to <code dir="ltr">setParam()</code> is the position of the parameter to be set. The first parameter in a SQL statement is parameter 1. The second argument passed to <code dir="ltr">setParam()</code> is the value of the parameter. Overloaded versions of <code dir="ltr">setParam()</code> take different data types for the second argument.</p>
<p>The TTClasses library does not support a large set of data type conversions. The appropriate overloaded version of <code dir="ltr">setParam()</code> must be called for each parameter in the prepared SQL. Calling the wrong version (attempting to set an integer parameter to a <code dir="ltr">char*</code> value, for example) may result in program failure.</p>
<p>Values passed to <code dir="ltr">setParam()</code> are copied into internal buffers maintained by the <code dir="ltr">TTCmd</code> object. These buffers are statically allocated and bound by the <code dir="ltr">Prepare()</code> method. The parameter value is the value passed into <code dir="ltr">setParam()</code> at the time of the <code dir="ltr">setParam()</code> call, not the value at the time of a subsequent <code dir="ltr">Execute()</code> method call.</p>
<p><a href="#g135285">Table 3-3</a> shows the supported SQL data types and the appropriate versions of <code dir="ltr">setParam()</code> to use for each type. SQL data types not mentioned are not supported in this version of TTClasses. For <code dir="ltr">NCHAR</code>, <code dir="ltr">NVARCHAR</code>, and binary types, as shown in the table, the method call specifies <code dir="ltr"><span class="codeinlineitalic">byteLen</span></code>, an integer value for the number of bytes in the parameter value.</p>
<p>See <a href="usage.htm#CDEFCHCG">&#34;Binding input parameters&#34;</a> and <a href="usage.htm#CDEEICCH">&#34;Binding output or input/output parameters&#34;</a> for examples using <code dir="ltr">setParam()</code>. See <a href="usage.htm#CDEEDEAC">&#34;Binding duplicate parameters&#34;</a> regarding duplicate parameters and the difference between TimesTen mode and Oracle mode in handling them.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>To set the length of the value for a bound parameter, see <code dir="ltr"><a href="#CHDBIBBC">setParamLength()</a></code>.</p>
</li>
<li>
<p>To set a value of <code dir="ltr">NULL</code> for a bound parameter, see <code dir="ltr"><a href="#i111602">setParamNull()</a></code>.</p>
</li>
</ul>
</div>
<div id="TTCLS197" class="tblhruleformal">
<p class="titleintable"><a id="sthref291"></a><a id="g135285"></a>Table 3-3 setParam() variants for supported TimesTen table column types</p>
<table class="cellalignment2189" title="setParam() variants for supported TimesTen table column types" summary="This table shows the supported SQL data types and the appropriate versions of setParam to use for each parameter type." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t22">Data type</th>
<th class="cellalignment2190" id="r1c2-t22">setParam() variants supported</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t22" headers="r1c1-t22">
<p><code dir="ltr">TT_TINYINT</code></p>
</td>
<td class="cellalignment2191" headers="r2c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLTINYINT <span class="italic">value</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t22" headers="r1c1-t22">
<p><code dir="ltr">TT_SMALLINT</code></p>
</td>
<td class="cellalignment2191" headers="r3c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLSMALLINT <span class="italic">value</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t22" headers="r1c1-t22">
<p><code dir="ltr">TT_INTEGER</code></p>
</td>
<td class="cellalignment2191" headers="r4c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLINTEGER <span class="italic">value</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t22" headers="r1c1-t22">
<p><code dir="ltr">TT_BIGINT</code></p>
</td>
<td class="cellalignment2191" headers="r5c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLBIGINT <span class="italic">value</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t22" headers="r1c1-t22">
<p><code dir="ltr">BINARY_FLOAT</code></p>
<p><code dir="ltr">REAL</code></p>
</td>
<td class="cellalignment2191" headers="r6c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, float <span class="italic">value</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t22" headers="r1c1-t22">
<p><code dir="ltr">BINARY_DOUBLE</code></p>
<p><code dir="ltr">DOUBLE</code></p>
</td>
<td class="cellalignment2191" headers="r7c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, double <span class="italic">value</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t22" headers="r1c1-t22">
<p><code dir="ltr">NUMBER</code></p>
<p><code dir="ltr">TT_DECIMAL</code></p>
</td>
<td class="cellalignment2191" headers="r8c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, char* <span class="italic">valueP</span>)
</pre>
<pre dir="ltr">setParam(<span class="italic">pno</span>, const char* <span class="italic">valueP</span>)
</pre>
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLCHAR* <span class="italic">valueP</span>)
</pre>
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLTINYINT <span class="italic">value</span>)
</pre>
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLSMALLINT <span class="italic">value</span>)
</pre>
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLINTEGER <span class="italic">value</span>)
</pre>
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLBIGINT <span class="italic">value</span>)
</pre>
<p><span class="bold">Note:</span> The integer versions are appropriate only for columns declared with the scale parameter set to zero, such as <code dir="ltr">NUMBER(8)</code> or <code dir="ltr">NUMBER(8,0)</code>.</p>
</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t22" headers="r1c1-t22">
<p><code dir="ltr">TT_CHAR</code></p>
<p><code dir="ltr">CHAR</code></p>
<p><code dir="ltr">TT_VARCHAR</code></p>
<p><code dir="ltr">VARCHAR2</code></p>
</td>
<td class="cellalignment2191" headers="r9c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, char* <span class="italic">valueP</span>)
</pre>
<pre dir="ltr">setParam(<span class="italic">pno</span>, const char* <span class="italic">valueP</span>)
</pre>
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLCHAR* <span class="italic">valueP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t22" headers="r1c1-t22">
<p><code dir="ltr">TT_NCHAR</code></p>
<p><code dir="ltr">NCHAR</code></p>
<p><code dir="ltr">TT_NVARCHAR</code></p>
<p><code dir="ltr">NVARCHAR2</code></p>
</td>
<td class="cellalignment2191" headers="r10c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, SQLWCHAR* <span class="italic">valueP</span>, <span class="italic">byteLen</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r11c1-t22" headers="r1c1-t22">
<p><code dir="ltr">BINARY</code></p>
<p><code dir="ltr">VARBINARY</code></p>
</td>
<td class="cellalignment2191" headers="r11c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, const void* <span class="italic">valueP</span>, <span class="italic">byteLen</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r12c1-t22" headers="r1c1-t22">
<p><code dir="ltr">DATE</code></p>
<p><code dir="ltr">TT_TIMESTAMP</code></p>
<p><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment2191" headers="r12c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, TIMESTAMP_STRUCT* <span class="italic">valueP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r13c1-t22" headers="r1c1-t22">
<p><code dir="ltr">TT_DATE</code></p>
</td>
<td class="cellalignment2191" headers="r13c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, DATE_STRUCT* <span class="italic">valueP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r14c1-t22" headers="r1c1-t22">
<p><code dir="ltr">TT_TIME</code></p>
</td>
<td class="cellalignment2191" headers="r14c1-t22 r1c2-t22">
<pre dir="ltr">setParam(<span class="italic">pno</span>, TIME_STRUCT* <span class="italic">valueP</span>)
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect4" -->
<a id="CHDBIBBC"></a>
<div id="TTCLS341" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">setPara<a id="sthref292"></a><a id="sthref293"></a>mLength()</h5>
<p>(Version for non-batch operations)</p>
<pre dir="ltr">void setParamLength(int <span class="italic">pno</span>, int <span class="italic">byteLen</span>)
</pre>
<p>Sets the length, in bytes, of the bound value for an input parameter specified by parameter number, before execution of the prepared statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is also a batch version of this method. See <a href="#i99244">&#34;setParamLength()&#34;</a>.</div>
</div>
<!-- class="sect4" -->
<a id="i111602"></a>
<div id="TTCLS198" class="sect4">
<h5 class="sect4">setPara<a id="sthref294"></a><a id="sthref295"></a>mNull()</h5>
<p>(Version for non-batch operations)</p>
<pre dir="ltr">void setParamNull(int <span class="italic">pno</span>)
</pre>
<p>Sets a value of SQL <code dir="ltr">NULL</code> for a bound input parameter specified by parameter number.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is also a batch version of this method. See <a href="#i99252">&#34;setParamNull()&#34;</a>.</div>
</div>
<!-- class="sect4" -->
<a id="CHDFEEJC"></a>
<div id="TTCLS192" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">setQu<a id="sthref296"></a>eryThreshold()</h5>
<pre dir="ltr">void setQueryThreshold(const int <span class="italic">nSecs</span>)
</pre>
<p>Use this method to specify a threshold time limit, in seconds, for the <code dir="ltr">TTCmd</code> object. (This applies to any SQL statement, not just queries.) If the execution time of a statement exceeds the threshold, a warning is written to the support log and an SNMP trap is thrown. Execution continues and is not affected by the threshold. Also see <a href="#CHDJFGEB">&#34;getQueryThreshold()&#34;</a>.</p>
<p>The <code dir="ltr">setQueryThreshold()</code> method has the same effect as using <code dir="ltr">SQLSetStmtOption</code> to set <code dir="ltr">TT_QUERY_THRESHOLD</code> or setting the TimesTen general connection attribute <code dir="ltr">QueryThreshold</code>.</p>
<p>See <a href="usage.htm#CDEJEJEF">&#34;Setting a timeout or threshold for executing SQL statements&#34;</a>.</p>
</div>
<!-- class="sect4" -->
<a id="i114811"></a>
<div id="TTCLS191" class="sect4">
<h5 class="sect4">se<a id="sthref297"></a>tQueryTimeout()</h5>
<pre dir="ltr">void setQueryTimeout(const int <span class="italic">nSecs</span>)
</pre>
<p>Use this method to specify how long, in seconds, any SQL statement (not just a query) executes before timing out. By default there is no timeout.</p>
<p>This has the same effect as using <code dir="ltr">SQLSetStmtOption</code> to set <code dir="ltr">SQL_QUERY_TIMEOUT</code> or setting the TimesTen general connection attribute <code dir="ltr">SqlQueryTimeout</code>.</p>
<p>See <a href="usage.htm#CDEJEJEF">&#34;Setting a timeout or threshold for executing SQL statements&#34;</a>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i113460"></a>
<div id="TTCLS182" class="sect3">
<h4 class="sect3">Pu<a id="sthref298"></a>blic methods for obtaining TTCmd object properties</h4>
<p>There are several useful methods for asking questions about properties of the bound input parameters and output columns of a prepared <code dir="ltr">TTCmd</code> object. These methods generally provide meaningful results only when a statement has previously been prepared.</p>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of public methods for obtaining properties of a TTCmd object." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t25">Method</th>
<th class="cellalignment2190" id="r1c2-t25">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i117428">getColumnName()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t25 r1c2-t25">Returns the name of the specified column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#CHDBCEHG">getColumnNullability()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t25 r1c2-t25">Indicates whether data in the specified column can have the value <code dir="ltr">NULL</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i99228">getColumnPrecision()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t25 r1c2-t25">Returns the precision of the specified column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i117348">getColumnScale()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t25 r1c2-t25">Returns the scale of the specified column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i99218">getColumnType()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t25 r1c2-t25">Returns the ODBC data type of the specified column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i99208">getNColumns()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t25 r1c2-t25">Returns the number of output columns.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i99200">getNParameters()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t25 r1c2-t25">Returns the number of input parameters.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i117104">getParamNullability()</a></code></td>
<td class="cellalignment2191" headers="r9c1-t25 r1c2-t25">Indicates whether the value of the specified parameter can be <code dir="ltr">NULL</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i117096">getParamPrecision()</a></code></td>
<td class="cellalignment2191" headers="r10c1-t25 r1c2-t25">Returns the precision of the specified parameter in a prepared statement.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r11c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i117100">getParamScale()</a></code></td>
<td class="cellalignment2191" headers="r11c1-t25 r1c2-t25">Returns the scale of the specified parameter in a prepared statement.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r12c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#i99213">getParamType()</a></code></td>
<td class="cellalignment2191" headers="r12c1-t25 r1c2-t25">Returns the ODBC data type of the specified parameter.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r13c1-t25" headers="r1c1-t25"><code dir="ltr"><a href="#CHDBGHII">isBeingExecuted</a></code></td>
<td class="cellalignment2191" headers="r13c1-t25 r1c2-t25">Indicates whether the statement represented by the <code dir="ltr">TTCmd</code> object is being executed.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="i117428"></a>
<div id="TTCLS216" class="sect4">
<h5 class="sect4">getColum<a id="sthref299"></a>nName()</h5>
<pre dir="ltr">const char* getColumnName(int <span class="italic">cno</span>)
</pre>
<p>Returns the name of column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDBCEHG"></a>
<div id="TTCLS384" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref300"></a>ColumnNullability()</h5>
<pre dir="ltr">int getColumnNullability(int <span class="italic">cno</span>)
</pre>
<p>Indicates whether column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> can <code dir="ltr">NULL</code> data. It returns <code dir="ltr">SQL_NO_NULLS</code>, <code dir="ltr">SQL_NULLABLE</code>, or <code dir="ltr">SQLNULLABLE_UNKNOWN</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i99228"></a>
<div id="TTCLS218" class="sect4">
<h5 class="sect4">getColum<a id="sthref301"></a>nPrecision()</h5>
<pre dir="ltr">int getColumnPrecision(int <span class="italic">cno</span>)
</pre>
<p>Returns the precision of data in column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code>, referring to the size of the column in the database. For example, for a <code dir="ltr">VARCHAR2(25)</code> column, the precision returned would be 25.</p>
<p>This value is generally interesting only when generating output from table columns of type <code dir="ltr">CHAR</code>, <code dir="ltr">VARCHAR2</code>, <code dir="ltr">NCHAR</code>, <code dir="ltr">NVARCHAR2</code>, <code dir="ltr">BINARY</code>, and <code dir="ltr">VARBINARY</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i117348"></a>
<div id="TTCLS219" class="sect4">
<h5 class="sect4">g<a id="sthref302"></a>etColumnScale()</h5>
<pre dir="ltr">int getColumnScale(int <span class="italic">cno</span>)
</pre>
<p>Returns the scale of data in column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code>, referring to the maximum number of digits to the right of the decimal point.</p>
</div>
<!-- class="sect4" -->
<a id="i99218"></a>
<div id="TTCLS217" class="sect4">
<h5 class="sect4">getColu<a id="sthref303"></a>mnType()</h5>
<pre dir="ltr">int getColumnType(int <span class="italic">cno</span>)
</pre>
<p>Returns the data type of column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code>. The value returned is the ODBC type of the parameter (for example, <code dir="ltr">SQL_INTEGER</code>, <code dir="ltr">SQL_REAL</code>, <code dir="ltr">SQL_BINARY</code>, <code dir="ltr">SQL_CHAR</code>) as found in <code dir="ltr">sql.h</code>. Additional TimesTen ODBC types (<code dir="ltr">SQL_WCHAR</code>, <code dir="ltr">SQL_WVARCHAR</code>) can be found in the TimesTen header file <code dir="ltr">timesten.h</code>.</p>
</div>
<!-- class="sect4" -->
<a id="i99208"></a>
<div id="TTCLS214" class="sect4">
<h5 class="sect4">getNColu<a id="sthref304"></a>mns()</h5>
<pre dir="ltr">int getNColumns()
</pre>
<p>Returns the number of output columns.</p>
</div>
<!-- class="sect4" -->
<a id="i99200"></a>
<div id="TTCLS213" class="sect4">
<h5 class="sect4">getNParam<a id="sthref305"></a>eters()</h5>
<pre dir="ltr">int getNParameters()
</pre>
<p>Returns the number of input parameters for the SQL statement.</p>
</div>
<!-- class="sect4" -->
<a id="i117104"></a>
<div id="TTCLS201" class="sect4">
<h5 class="sect4">getPara<a id="sthref306"></a>mNullability()</h5>
<pre dir="ltr">int getParamNullability(int <span class="italic">pno</span>)
</pre>
<p>Indicates whether parameter number <code dir="ltr"><span class="codeinlineitalic">pno</span></code> can have the value <code dir="ltr">NULL</code>. It returns <code dir="ltr">SQL_NO_NULLS</code>, <code dir="ltr">SQL_NULLABLE</code>, or <code dir="ltr">SQLNULLABLE_UNKNOWN</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In earlier releases this method returned <code dir="ltr">bool</code> instead of <code dir="ltr">int</code>.</div>
</div>
<!-- class="sect4" -->
<a id="i117096"></a>
<div id="TTCLS199" class="sect4">
<h5 class="sect4">getPar<a id="sthref307"></a>amPrecision()</h5>
<pre dir="ltr">int getParamPrecision(int <span class="italic">pno</span>)
</pre>
<p>Returns the precision of parameter number <code dir="ltr"><span class="codeinlineitalic">pno</span></code>, referring to the maximum number of digits that are used by the data type. Also see information for <code dir="ltr"><a href="#i99228">getColumnPrecision()</a></code>, above.</p>
</div>
<!-- class="sect4" -->
<a id="i117100"></a>
<div id="TTCLS200" class="sect4">
<h5 class="sect4">getPara<a id="sthref308"></a>mScale()</h5>
<pre dir="ltr">int getParamScale(int <span class="italic">pno</span>)
</pre>
<p>Returns the scale of parameter number <code dir="ltr"><span class="codeinlineitalic">pno</span></code>, referring to the maximum number of digits to the right of the decimal point.</p>
</div>
<!-- class="sect4" -->
<a id="i99213"></a>
<div id="TTCLS215" class="sect4">
<h5 class="sect4">getPara<a id="sthref309"></a>mType()</h5>
<pre dir="ltr">int getParamType(int <span class="italic">pno</span>)
</pre>
<p>Returns the data type of parameter number <code dir="ltr"><span class="codeinlineitalic">pno</span></code>. The value returned is the ODBC type (for example, <code dir="ltr">SQL_INTEGER</code>, <code dir="ltr">SQL_REAL</code>, <code dir="ltr">SQL_BINARY</code>, <code dir="ltr">SQL_CHAR</code>) as found in <code dir="ltr">sql.h</code>. Additional TimesTen types (<code dir="ltr">SQL_WCHAR</code>, <code dir="ltr">SQL_WVARCHAR</code>) can be found in the TimesTen header file <code dir="ltr">timesten.h</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDBGHII"></a>
<div id="TTCLS385" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">i<a id="sthref310"></a><a id="sthref311"></a>sBeingExecuted</h5>
<pre dir="ltr">bool isBeingExecuted()
</pre>
<p>Indicates whether the statement represented by the <code dir="ltr">TTCmd</code> object is being executed.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i113465"></a>
<div id="TTCLS183" class="sect3">
<h4 class="sect3">Public methods for b<a id="sthref312"></a><a id="sthref313"></a>atch operations</h4>
<p>TimesTen supports the ODBC function <code dir="ltr">SQLBindParams</code> for batch insert, update and delete operations. TTClasses provides an interface to the ODBC function <code dir="ltr">SQLBindParams</code>.</p>
<p>Performing batch operations with TTClasses is similar to performing non-batch operations. SQL statements are first compiled using <code dir="ltr">PrepareBatch()</code>. Then each parameter in that statement is bound to an array of values using <code dir="ltr">BindParameter()</code>. Finally, the statement is executed using <code dir="ltr">ExecuteBatch()</code>.</p>
<p>See the TTClasses <code dir="ltr">bulktest</code> sample program in the TimesTen Quick Start for an example of using a batch operation. Refer to <a href="compiling.htm#BCGGJCJF">&#34;About the TimesTen TTClasses demos&#34;</a>.</p>
<p>This section describes the <code dir="ltr">TTCmd</code> methods that expose the batch <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, and <code dir="ltr">DELETE</code> functionality to TTClasses users.</p>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of public methods of TTCmd for batch operations." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t27">Method</th>
<th class="cellalignment2190" id="r1c2-t27">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t27" headers="r1c1-t27"><code dir="ltr"><a href="#CHDIABDF">batchSize()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t27 r1c2-t27">Returns the number of statements in the batch.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t27" headers="r1c1-t27"><code dir="ltr"><a href="#i116505">BindParameter()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t27 r1c2-t27">Binds an array of values for one parameter of a statement prepared using <code dir="ltr">PrepareBatch()</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t27" headers="r1c1-t27"><code dir="ltr"><a href="#i99257">ExecuteBatch()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t27 r1c2-t27">Invokes a SQL statement that has been prepared for execution by <code dir="ltr">PrepareBatch()</code>. It returns the number of rows in the batch that were updated.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t27" headers="r1c1-t27"><code dir="ltr"><a href="#i104823">PrepareBatch()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t27 r1c2-t27">Prepares batch <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, and <code dir="ltr">DELETE</code> statements.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t27" headers="r1c1-t27"><code dir="ltr"><a href="#i99244">setParamLength()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t27 r1c2-t27">Sets the length, in bytes, of the value of the specified bound parameter before execution of the prepared statement.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t27" headers="r1c1-t27"><code dir="ltr"><a href="#i99252">setParamNull()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t27 r1c2-t27">Sets the specified bound parameter to <code dir="ltr">NULL</code> before execution of the prepared statement.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDIABDF"></a>
<div id="TTCLS386" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">batch<a id="sthref314"></a><a id="sthref315"></a><a id="sthref316"></a>Size()</h5>
<pre dir="ltr">u_short batchSize()
</pre>
<p>Returns the number of statements in the batch.</p>
</div>
<!-- class="sect4" -->
<a id="i116505"></a>
<div id="TTCLS222" class="sect4">
<h5 class="sect4">Bind<a id="sthref317"></a><a id="sthref318"></a><a id="sthref319"></a>Parameter()</h5>
<pre dir="ltr">void BindParameter(int <span class="italic">pno</span>, unsigned short <span class="italic">batSz</span>, TYPE* <span class="italic">valueP</span>)
void BindParameter(int <span class="italic">pno</span>, unsigned short <span class="italic">batSz</span>, TYPE* <span class="italic">valueP</span>, size_t <span class="italic">maxByteLen</span>)
void BindParameter(int <span class="italic">pno</span>, unsigned short <span class="italic">batSz</span>, TYPE* <span class="italic">valueP</span>, 
                   SQLLEN* <span class="italic">userByteLenP</span>, size_t <span class="italic">maxByteLen</span>)
</pre>
<p>The overloaded <code dir="ltr">BindParameter()</code> method is used to bind an array of values for a specified parameter in a SQL statement compiled using <code dir="ltr">PrepareBatch()</code>. This allows iterating through a batch of repeated executions of the statement with different values. The <code dir="ltr"><span class="codeinlineitalic">pno</span></code> parameter indicates the position in the statement of the parameter to be bound, starting from the left, where the first parameter is 1, the next is 2, and so on.</p>
<p>See <a href="usage.htm#CDEEDEAC">&#34;Binding duplicate parameters&#34;</a> regarding duplicate parameters and the difference between TimesTen mode and Oracle mode in handling them.</p>
<p>The <code dir="ltr"><span class="codeinlineitalic">batSz</span></code> (batch size) value of this call must match the <code dir="ltr"><span class="codeinlineitalic">batSz</span></code> value specified in <code dir="ltr">PrepareBatch()</code>, and the bound arrays should contain at least the <code dir="ltr"><span class="codeinlineitalic">batSz</span></code> number of values. You must determine the correct data type for each parameter. If an invalid parameter number is specified, the specified batch size is a mismatch, or the data buffer is null, then a <code dir="ltr">TTStatus</code> object is thrown as an exception and a runtime error is written to the TTClasses global logging facility at the <code dir="ltr">TTLog::TTLOG_ERR</code> logging level.</p>
<p><a href="#g135236">Table 3-4</a> below shows the supported SQL data types and the appropriate versions of <code dir="ltr">BindParameter()</code> to use for each parameter type.</p>
<p>Before each invocation of <code dir="ltr">ExecuteBatch()</code>, the application should fill the bound arrays with valid parameter values. Note that you can use the <code dir="ltr">setParamNull()</code> method to set null values, as described in <a href="#i99252">&#34;setParamNull()&#34;</a>. (Be aware that for batch mode, you must use the two-parameter version of <code dir="ltr">setParamNull()</code> that specifies <code dir="ltr"><span class="codeinlineitalic">rowno</span></code>. The one-parameter version is for non-batch use only.)</p>
<p>For the SQL types <code dir="ltr">TT_CHAR</code>, <code dir="ltr">CHAR</code>, <code dir="ltr">TT_VARCHAR</code>, and <code dir="ltr">VARCHAR2</code>, an additional maximum length parameter is required in the <code dir="ltr">BindParameter()</code> call:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">maxByteLen</span></code> of type <code dir="ltr">size_t</code> is for the maximum length, in bytes, of any value for this parameter position.</p>
</li>
</ul>
<p>For the SQL types <code dir="ltr">TT_NCHAR</code>, <code dir="ltr">NCHAR</code>, <code dir="ltr">TT_NVARCHAR</code>, <code dir="ltr">NVARCHAR2</code>, <code dir="ltr">BINARY</code>, and <code dir="ltr">VARBINARY</code>, two additional parameters are required in the <code dir="ltr">BindParameter()</code> call, an array of parameter lengths and a maximum length:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">userByteLenP</span></code> is an array of <code dir="ltr">SQLLEN</code> parameter lengths, in bytes, to specify the length of each value in the batch for this parameter position in the SQL statement. This array must be at least <code dir="ltr"><span class="codeinlineitalic">batSz</span></code> in length and filled with valid length values before <code dir="ltr">ExecuteBatch()</code> is called. (You can store <code dir="ltr">SQL_NULL_DATA</code> in the array of parameter lengths for a null value, which is equivalent to using the <code dir="ltr">setParamNull()</code> batch method.)</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">maxByteLen</span></code> is as described above. This indicates the maximum length value that can be specified in any element of the <code dir="ltr"><span class="codeinlineitalic">userByteLenP</span></code> array.</p>
</li>
</ul>
<p>For data types where <code dir="ltr"><span class="codeinlineitalic">userByteLenP</span></code> is not available (or as an alternative where it is available), you can optionally use the <code dir="ltr">setParamLength()</code> batch method to set data lengths, as described in <a href="#i99244">&#34;setParamLength()&#34;</a>, and use the <code dir="ltr">setParamNull()</code> batch method to set null values, as described in <a href="#i99252">&#34;setParamNull()&#34;</a>.</p>
<p>See <a href="#BABHHBHI">Example 3-5</a> in <a href="#i99257">&#34;ExecuteBatch()&#34;</a> below for examples of <code dir="ltr">BindParameter()</code> usage.</p>
<div id="TTCLS223" class="tblhruleformal">
<p class="titleintable"><a id="sthref320"></a><a id="g135236"></a>Table 3-4 BindParameter() variants for supported TimesTen table column types</p>
<table class="cellalignment2189" title="BindParameter() variants for supported TimesTen table column types" summary="This table shows the supported SQL data types and the appropriate versions of BindParameter to use for each parameter type." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t28">SQL data type</th>
<th class="cellalignment2190" id="r1c2-t28">BindParameter() variants supported</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t28" headers="r1c1-t28">
<p><code dir="ltr">TT_TINYINT</code></p>
</td>
<td class="cellalignment2191" headers="r2c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, SQLTINYINT* <span class="italic">user_tiP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t28" headers="r1c1-t28">
<p><code dir="ltr">TT_SMALLINT</code></p>
</td>
<td class="cellalignment2191" headers="r3c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, SQLSMALLINT* <span class="italic">user_siP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t28" headers="r1c1-t28">
<p><code dir="ltr">TT_INTEGER</code></p>
</td>
<td class="cellalignment2191" headers="r4c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, SQLINTEGER* <span class="italic">user_iP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t28" headers="r1c1-t28">
<p><code dir="ltr">TT_BIGINT</code></p>
</td>
<td class="cellalignment2191" headers="r5c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, SQLBIGINT* <span class="italic">user_biP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t28" headers="r1c1-t28">
<p><code dir="ltr">BINARY_FLOAT</code></p>
</td>
<td class="cellalignment2191" headers="r6c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, float* <span class="italic">user_fP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t28" headers="r1c1-t28">
<p><code dir="ltr">BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment2191" headers="r7c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, double* <span class="italic">user_dP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t28" headers="r1c1-t28">
<p><code dir="ltr">NUMBER</code></p>
<p><code dir="ltr">TT_DECIMAL</code></p>
</td>
<td class="cellalignment2191" headers="r8c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, char** <span class="italic">user_cPP</span>, <span class="italic">maxByteLen</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t28" headers="r1c1-t28">
<p><code dir="ltr">TT_CHAR</code></p>
<p><code dir="ltr">CHAR</code></p>
<p><code dir="ltr">TT_VARCHAR</code></p>
<p><code dir="ltr">VARCHAR2</code></p>
</td>
<td class="cellalignment2191" headers="r9c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, char** <span class="italic">user_cPP</span>, <span class="italic">maxByteLen</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t28" headers="r1c1-t28">
<p><code dir="ltr">TT_NCHAR</code></p>
<p><code dir="ltr">NCHAR</code></p>
<p><code dir="ltr">TT_NVARCHAR</code></p>
<p><code dir="ltr">NVARCHAR2</code></p>
</td>
<td class="cellalignment2191" headers="r10c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, SQLWCHAR** <span class="italic">user_wcPP</span>, <span class="italic">userByteLenP</span>,
              <span class="italic">maxByteLen</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r11c1-t28" headers="r1c1-t28">
<p><code dir="ltr">BINARY</code></p>
<p><code dir="ltr">VARBINARY</code></p>
</td>
<td class="cellalignment2191" headers="r11c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, const void** <span class="italic">user_binPP</span>, <span class="italic">userByteLenP</span>,
              <span class="italic">maxByteLen</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r12c1-t28" headers="r1c1-t28">
<p><code dir="ltr">DATE</code></p>
<p><code dir="ltr">TT_TIMESTAMP</code></p>
<p><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment2191" headers="r12c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, TIMESTAMP_STRUCT* <span class="italic">user_tssP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r13c1-t28" headers="r1c1-t28">
<p><code dir="ltr">TT_DATE</code></p>
</td>
<td class="cellalignment2191" headers="r13c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, DATE_STRUCT* <span class="italic">user_dsP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r14c1-t28" headers="r1c1-t28">
<p><code dir="ltr">TT_TIME</code></p>
</td>
<td class="cellalignment2191" headers="r14c1-t28 r1c2-t28">
<pre dir="ltr">BindParameter(<span class="italic">pno</span>, <span class="italic">batSz</span>, TIME_STRUCT* <span class="italic">user_tsP</span>)
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect4" -->
<a id="i99257"></a>
<div id="TTCLS226" class="sect4">
<h5 class="sect4">Execute<a id="sthref321"></a><a id="sthref322"></a>Batch()</h5>
<pre dir="ltr">int ExecuteBatch(unsigned short <span class="italic">numRows</span>)
</pre>
<p>After preparing a SQL statement with <code dir="ltr">PrepareBatch()</code> and calling <code dir="ltr">BindParameter()</code> for each parameter in the SQL statement, use <code dir="ltr">ExecuteBatch()</code> to execute the statement <code dir="ltr"><span class="codeinlineitalic">numRows</span></code> times. The value of <code dir="ltr"><span class="codeinlineitalic">numRows</span></code> must be no more than the <code dir="ltr"><span class="codeinlineitalic">batSz</span></code> (batch size) value specified in the <code dir="ltr">PrepareBatch()</code> and <code dir="ltr">BindParameter()</code> calls, but can be less than <code dir="ltr"><span class="codeinlineitalic">batSz</span></code> as required by application logic.</p>
<p>This method returns the number of rows that were updated, with possible values in the range 0 to <code dir="ltr"><span class="codeinlineitalic">batSz</span></code>, inclusive. (For those familiar with ODBC, this is the third parameter, <code dir="ltr"><span class="codeinlineitalic">*pirow</span></code>, of an ODBC <code dir="ltr">SQLParamOptions</code> call. Refer to ODBC API reference documentation for information about <code dir="ltr">SQLParamOptions</code>.)</p>
<p>Before calling <code dir="ltr">ExecuteBatch()</code>, the application should fill the arrays of parameters previously bound by <code dir="ltr"><a href="#i116505">BindParameter()</a></code> with valid values.</p>
<p>A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs (often due to violation of a uniqueness constraint). In this event, the return value is not valid and the batch is incomplete and should generally be rolled back.</p>
<p><a href="#BABHHBHI">Example 3-5</a> shows how to use the <code dir="ltr">ExecuteBatch()</code> method. The <code dir="ltr">bulktest</code> Quick Start demo also shows usage of this method. (See <a href="compiling.htm#BCGGJCJF">&#34;About the TimesTen TTClasses demos&#34;</a>.)</p>
<div id="TTCLS227" class="example">
<p class="titleinexample"><a id="BABHHBHI"></a>Example 3-5 Using the ExecuteBatch() method</p>
<p>First, create a table with two columns:</p>
<pre dir="ltr">CREATE TABLE batch_table (a TT_INTEGER, b VARCHAR2(100));
</pre>
<p>Following is the sample code. Populate the rows of the table in batches of 50.</p>
<pre dir="ltr">#define BATCH_SIZE 50
#define VARCHAR_SIZE 100
 
int int_array[BATCH_SIZE];
char char_array[BATCH_SIZE][VARCHAR_SIZE];
 
// Prepare the statement
 
TTCmd insert;
TTConnection connection;
 
// (assume a connection has been established)
 
try {
 
  insert.PrepareBatch (&amp;connection,
                       (const char*)&#34;insert into batch_table values (?,?)&#34;,
                       BATCH_SIZE);
 
  // Commit the prepared statement
  connection.Commit();
 
  // Bind the arrays of parameters
  insert.BindParameter(1, BATCH_SIZE, int_array);
  insert.BindParameter(2, BATCH_SIZE, (char **)char_array, VARCHAR_SIZE);
 
  // Execute 5 batches, inserting a total of 5 * BATCH_SIZE rows into
  // the database
  for (int iter = 0; iter &lt; 5; iter++)
  {
    // Populate the value arrays with values.
    // (A more meaningful way of putting data into
    // the database is to read values from a file, for example,
    // rather than generating them arbitrarily.)
 
    for (int i = 0; i &lt; BATCH_SIZE; i++)
    {
      int_array[i] = i * iter + i;
      sprintf(char_array[i], &#34;varchar value # %d&#34;, i*iter+ i);
    }
 
    // Execute the batch insert statement,
    // which inserts the entire contents of the
    // integer and char arrays in one operation.
    int num_ins = insert.ExecuteBatch(BATCH_SIZE);
 
    cerr &lt;&lt; &#34;Inserted &#34; &lt;&lt; num_ins &lt;&lt; &#34; rows.&#34; &lt;&lt; endl;
 
    connection.Commit();
 
  } // for iter
 
} catch (TTError er1) {
  cerr &lt;&lt; er1 &lt;&lt; endl;
}
</pre>
<p>The number of rows updated (<code dir="ltr"><span class="codeinlineitalic">num_ins</span></code> in the example) can be less than <code dir="ltr">BATCH_SIZE</code> if, for example, there is a violation of a uniqueness constraint on a column. You can use code similar to that in <a href="#BABDJCAJ">Example 3-6</a> to check for this situation and roll back the transaction as necessary.</p>
</div>
<!-- class="example" -->
<p>TimesTen has features to control database access with object-level resolution for database objects such as tables, views, materialized views, sequences, and synonyms. Access control privileges are checked both when SQL is prepared and when it is executed in the database, with most of the performance cost coming at prepare time. See <a href="usage.htm#CDEHEBFE">&#34;Considering TimesTen features for access control&#34;</a>.</p>
<div id="TTCLS228" class="example">
<p class="titleinexample"><a id="BABDJCAJ"></a>Example 3-6 Using ExecuteBatch() and checking against BATCH_SIZE</p>
<pre dir="ltr">for (int iter = 0; iter &lt; 5; iter++)
{

  // Populate the value arrays with values.
  // (A better way of putting meaningful data into
  // the database is to read values from a file,
  // rather than generating them arbitrarily.)

  for (int i = 0; i &lt; BATCH_SIZE; i++)
  {
    int_array[i] = i * iter + i;
    sprintf(char_array[i], &#34;varchar value # %d&#34;, i*iter+i);
  }

  // now we execute the batch insert statement,
  // which does the work of inserting the entire
  // contents of the integer and char arrays in
  // one operation

  int num_ins = insert.ExecuteBatch(BATCH_SIZE);

  cerr &lt;&lt; &#34;Inserted &#34; &lt;&lt; num_ins &lt;&lt; &#34; rows (expected &#34;
       &lt;&lt; BATCH_SIZE &lt;&lt; &#34; rows).&#34; &lt;&lt; endl;

  if (num_ins == BATCH_SIZE) {
    cerr &lt;&lt; &#34;Committing batch&#34; &lt;&lt; endl;
    connection.Commit();
  }
  else {
    cerr &lt;&lt; &#34;Some rows were not inserted as expected, rolling back &#34;
         &lt;&lt; &#34;transaction.&#34; &lt;&lt; endl;
    connection.Rollback();
    break; // jump out of batch insert loop
  }

} // for loop
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="i104823"></a>
<div id="TTCLS221" class="sect4">
<h5 class="sect4">Prepare<a id="sthref323"></a><a id="sthref324"></a>Batch()</h5>
<pre dir="ltr">void PrepareBatch(TTConnection* <span class="italic">cP</span>, const char* <span class="italic">sqlp</span>, unsigned short <span class="italic">batSz</span>)
</pre>
<p><code dir="ltr">PrepareBatch()</code> is comparable to the <code dir="ltr">Prepare()</code> method but for batch <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statements. The <code dir="ltr"><span class="codeinlineitalic">cP</span></code> and <code dir="ltr"><span class="codeinlineitalic">sqlp</span></code> parameters are used as with <code dir="ltr">Prepare()</code>. See <a href="#i104817">&#34;Prepare()&#34;</a>.</p>
<p>The <code dir="ltr"><span class="codeinlineitalic">batSz</span></code> (batch size) parameter specifies the maximum number of insert, update, or delete operations that are performed using subsequent calls to <code dir="ltr">ExecuteBatch()</code>.</p>
<p>A <code dir="ltr">TTStatus</code> object is thrown as an exception if an error occurs.</p>
<p>TimesTen has features to control database access with object-level resolution for database objects such as tables, views, materialized views, sequences, and synonyms. Access control privileges are checked both when SQL is prepared and when it is executed in the database, with most of the performance cost coming at prepare time. See <a href="usage.htm#CDEHEBFE">&#34;Considering TimesTen features for access control&#34;</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To avoid unwanted round trips between client and server in client/server connections, the <code dir="ltr">PrepareBatch()</code> method performs what is referred to as a &#34;deferred prepare&#34;, where the request is not sent to the server until required. See <a class="olink TTCDV129" href="../TTCDV/writing_app.htm#TTCDV129">&#34;TimesTen deferred prepare&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span> for more information.</div>
</div>
<!-- class="sect4" -->
<a id="i99244"></a>
<div id="TTCLS224" class="sect4">
<h5 class="sect4">setPara<a id="sthref325"></a><a id="sthref326"></a>mLength()</h5>
<p>(Version for batch operations)</p>
<pre dir="ltr">void setParamLength(int <span class="italic">pno</span>, unsigned short <span class="italic">rowno</span>, int <span class="italic">byteLen</span>)
</pre>
<p>This method sets the length of a bound parameter value before a call to <code dir="ltr">ExecuteBatch()</code>. The <code dir="ltr"><span class="codeinlineitalic">pno</span></code> argument specifies the parameter number in the SQL statement (where the first parameter is number 1). The <code dir="ltr"><span class="codeinlineitalic">rowno</span></code> argument specifies the row number in the array of parameters being bound (where the first row is row number 1). The <code dir="ltr"><span class="codeinlineitalic">byteLen</span></code> parameter specifies the desired length, in bytes, not counting the <code dir="ltr">NULL</code> terminator. Alternatively, <code dir="ltr"><span class="codeinlineitalic">byteLen</span></code> can be set to <code dir="ltr">SQL_NTS</code> for a null-terminated string. (It can also be set to <code dir="ltr">SQL_NULL_DATA</code>, which is equivalent to using the <code dir="ltr">setParamNull()</code> batch method, described next.)</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>For binary and <code dir="ltr">NCHAR</code> types, as shown in <a href="#g135236">Table 3-4</a>, it may be easier to use the <code dir="ltr">BindParameter()</code> <code dir="ltr"><span class="codeinlineitalic">userByteLenP</span></code> array to set parameter lengths. Be aware that row numbering in the array of parameters being bound starts with 0 in the <code dir="ltr"><span class="codeinlineitalic">userByteLenP</span></code> array but with 1 when you use <code dir="ltr">setParamLength()</code>.</p>
</li>
<li>
<p>There is also a non-batch version of this method. See <a href="#CHDBIBBC">&#34;setParamLength()&#34;</a>. (It is important to use only the two-parameter version for non-batch operations, and only the three-parameter version that specifies <code dir="ltr"><span class="codeinlineitalic">rowno</span></code> for batch operations.)</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<a id="i99252"></a>
<div id="TTCLS225" class="sect4">
<h5 class="sect4">setPara<a id="sthref327"></a><a id="sthref328"></a>mNull()</h5>
<p>(Version for batch operations)</p>
<pre dir="ltr">void setParamNull(int <span class="italic">pno</span>, unsigned short <span class="italic">rowno</span>)
</pre>
<p>This method sets a bound parameter value to <code dir="ltr">NULL</code> before a call to <code dir="ltr">ExecuteBatch()</code>. The <code dir="ltr"><span class="codeinlineitalic">pno</span></code> argument specifies the parameter number in the SQL statement (where the first parameter is number 1). The <code dir="ltr"><span class="codeinlineitalic">rowno</span></code> argument specifies the row number in the array of parameters being bound (where the first row is row number 1).</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>For binary and <code dir="ltr">NCHAR</code> types, as shown in <a href="#g135236">Table 3-4</a>, there is a <code dir="ltr">BindParameter()</code> <code dir="ltr"><span class="codeinlineitalic">userByteLenP</span></code> array. For these types, you can have a null value by specifying <code dir="ltr">SQL_NULL_DATA</code> in this array, which is equivalent to using <code dir="ltr">setParamNull()</code>. Be aware that row numbering in the bound array of parameters <code dir="ltr"><span class="codeinlineitalic">userByteLenP</span></code> starts with 0, but numbering starts with 1 when you use <code dir="ltr">setParamNull()</code>.</p>
</li>
<li>
<p>There is also a non-batch version of this method. See <a href="#i111602">&#34;setParamNull()&#34;</a>. (It is important to use only the one-parameter version for non-batch operations, and only the two-parameter version that specifies <code dir="ltr"><span class="codeinlineitalic">rowno</span></code> for batch operations.)</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i95345"></a>
<div id="TTCLS246" class="sect1">
<h2 class="sect1">Sys<a id="sthref329"></a>tem catalog classes</h2>
<p>These classes allow you to examine the TimesTen system catalog.</p>
<p>You can use the <code dir="ltr">TTCatalog</code> class to facilitate reading metadata from the system catalog. A <code dir="ltr">TTCatalog</code> object contains data structures with the information that was read.</p>
<p>Each <code dir="ltr">TTCatalog</code> object internally contains an array of <code dir="ltr">TTCatalogTable</code> objects. Each <code dir="ltr">TTCatalogTable</code> object contains an array of <code dir="ltr">TTCatalogColumn</code> objects and an array of <code dir="ltr">TTCatalogIndex</code> objects.</p>
<p>The following ODBC functions are used inside <code dir="ltr">TTCatalog</code>:</p>
<ul>
<li>
<p><code dir="ltr">SQLTables()</code></p>
</li>
<li>
<p><code dir="ltr">SQLColumns()</code></p>
</li>
<li>
<p><code dir="ltr">SQLSpecialColumns()</code></p>
</li>
<li>
<p><code dir="ltr">SQLStatistics()</code></p>
</li>
</ul>
<p>This section discusses the following classes.</p>
<ul>
<li>
<p><code dir="ltr"><a href="#CHDDCGGA">TTCatalog</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#CHDBBBAH">TTCatalogTable</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#CHDHHCAB">TTCatalogColumn</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#CHDBJJGI">TTCatalogIndex</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#CHDJFAHE">TTCatalogSpecialColumn</a></code></p>
</li>
</ul>
<a id="CHDDCGGA"></a>
<div id="TTCLS388" class="sect2">
<h3 class="sect2"><a id="sthref330"></a><a id="sthref331"></a><a id="sthref332"></a>TTCatalog</h3>
<p>The <code dir="ltr">TTCatalog</code> class is the top-level class used for programmatically accessing metadata information about tables in a database. A <code dir="ltr">TTCatalog</code> object contains an internal array of <code dir="ltr">TTCatalogTable</code> objects. Aside from the class constructor, all public methods of <code dir="ltr">TTCatalog</code> are used to gain read-only access to this <code dir="ltr">TTCatalogTable</code> array.</p>
<p>The <code dir="ltr">TTCatalog</code> constructor caches the <code dir="ltr"><span class="codeinlineitalic">conn</span></code> parameter and initializes all the internal data structures appropriately.</p>
<pre dir="ltr">TTCatalog (TTConnection* <span class="italic">conn</span>)
</pre>
<p>To use the <code dir="ltr">TTCatalog</code> object, call its <code dir="ltr">fetchCatalogData()</code> method, described shortly. The <code dir="ltr">fetchCatalogData()</code> method is the only <code dir="ltr">TTCatalog</code> method that uses the database connection. All other methods simply return data retrieved by <code dir="ltr">fetchCatalogData()</code>.</p>
<div id="TTCLS389" class="sect3"><a id="sthref333"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS390" class="sect3"><a id="sthref334"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods of TTCatalogTable." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t32">Method</th>
<th class="cellalignment2190" id="r1c2-t32">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t32" headers="r1c1-t32"><code dir="ltr"><a href="#CHDCHIID">fetchCatalogData()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t32 r1c2-t32">Reads the catalogs in the database for information about tables and indexes and stores this information into <code dir="ltr">TTCatalog</code> internal data structures.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t32" headers="r1c1-t32"><code dir="ltr"><a href="#CHDCIHIC">getNumSysTables()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t32 r1c2-t32">Returns the number of system tables in the database.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t32" headers="r1c1-t32"><code dir="ltr"><a href="#CHDBICCF">getNumTables()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t32 r1c2-t32">Returns the total number of tables (user tables plus system tables) in the database.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t32" headers="r1c1-t32"><code dir="ltr"><a href="#CHDEFHFC">getNumUserTables()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t32 r1c2-t32">Returns the number of user tables in the database.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t32" headers="r1c1-t32"><code dir="ltr"><a href="#CHDGIIIJ">getTable()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t32 r1c2-t32">Returns a constant reference to the <code dir="ltr">TTCatalogTable</code> object for the specified table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t32" headers="r1c1-t32"><code dir="ltr"><a href="#CHDFGJEC">getTableIndex()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t32 r1c2-t32">Returns the index in the <code dir="ltr">TTCatalog</code> object for the specified table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t32" headers="r1c1-t32"><code dir="ltr"><a href="#CHDEECHJ">getUserTable()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t32 r1c2-t32">Returns a constant reference to the <code dir="ltr">TTCatalogTable</code> object corresponding to the <code dir="ltr"><span class="codeinlineitalic">n</span></code>th user table in the system (where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is specified).</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDCHIID"></a>
<div id="TTCLS391" class="sect4">
<h5 class="sect4">fetc<a id="sthref335"></a><a id="sthref336"></a>hCatalogData()</h5>
<pre dir="ltr">void fetchCatalogData()
</pre>
<p>This is the only <code dir="ltr">TTCatalog</code> method that interacts with the database. It reads the catalogs in the database for information about tables and indexes, storing the information into <code dir="ltr">TTCatalog</code> internal data structures.</p>
<p>Subsequent use of the constructed <code dir="ltr">TTCatalog</code> object is completely offline after it is constructed. It is no longer connected to the database.</p>
<p>You must call this method before you use any of the <code dir="ltr">TTCatalog</code> accessor methods.</p>
<p>This example demonstrates the use of <code dir="ltr">TTCatalog</code>.</p>
<div id="TTCLS392" class="example">
<p class="titleinexample"><a id="sthref337"></a>Example 3-7 Fetching catalog data</p>
<pre dir="ltr">TTConnection conn;
conn.Connect(DSN=TptbmData37);
TTCatalog cat (&amp;conn);
cat.fetchCatalogData(); 
// TTCatalog cat is no longer connected to the database;
// you can now query it through its read-only methods.
cerr &lt;&lt; &#34;There are &#34; &lt;&lt; cat.getNumTables() &lt;&lt; &#34; tables in this database:&#34; &lt;&lt; endl;
for (int i=0; i &lt; cat.getNumTables(); i++)
cerr &lt;&lt; cat.getTable(i).getTableOwner() &lt;&lt; &#34;.&#34; 
     &lt;&lt; cat.getTable(i).getTableName() &lt;&lt; endl;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CHDCIHIC"></a>
<div id="TTCLS395" class="sect4">
<h5 class="sect4">getNu<a id="sthref338"></a><a id="sthref339"></a>mSysTables()</h5>
<pre dir="ltr">int getNumSysTables()
</pre>
<p>Returns the number of system tables in the database. Also see the following methods, <code dir="ltr">getNumTables()</code> and <code dir="ltr">getNumUserTables()</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDBICCF"></a>
<div id="TTCLS393" class="sect4">
<h5 class="sect4">get<a id="sthref340"></a><a id="sthref341"></a>NumTables()</h5>
<pre dir="ltr">int getNumTables() 
</pre>
<p>Returns the total number of tables in the database (user plus system tables). Also see the preceding method, <code dir="ltr">getNumSysTables()</code>, and the following method, <code dir="ltr">getNumUserTables()</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDEFHFC"></a>
<div id="TTCLS394" class="sect4">
<h5 class="sect4">ge<a id="sthref342"></a><a id="sthref343"></a>tNumUserTables()</h5>
<pre dir="ltr">int getNumUserTables() 
</pre>
<p>Returns the number of user tables in the database. Also see the preceding methods, <code dir="ltr">getNumSysTables()</code> and <code dir="ltr">getNumTables()</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDGIIIJ"></a>
<div id="TTCLS396" class="sect4">
<h5 class="sect4">get<a id="sthref344"></a><a id="sthref345"></a>Table()</h5>
<pre dir="ltr">const TTCatalogTable&amp; getTable(const char* <span class="italic">owner</span>, const char* <span class="italic">tblname</span>)
const TTCatalogTable&amp; getTable(int <span class="italic">tno</span>) 
</pre>
<p>Returns a constant reference to the <code dir="ltr">TTCatalogTable</code> object for the specified table. Also see <code dir="ltr"><a href="#CHDEECHJ">getUserTable()</a></code>.</p>
<p>For the first signature, this is for the table named <code dir="ltr"><span class="codeinlineitalic">tblname</span></code> and owned by <code dir="ltr"><span class="codeinlineitalic">owner</span></code>.</p>
<p>For the second signature, this is for the table corresponding to table number <code dir="ltr"><span class="codeinlineitalic">tno</span></code> in the system. This is intended to facilitate iteration through all the tables in the system. The order of the tables in this array is arbitrary.</p>
<p>The following relationship is true:</p>
<pre dir="ltr">0 &lt;= <span class="italic">tno</span> &lt; getNumTables()
</pre>
<p>Also see <a href="#CHDBBBAH">&#34;TTCatalogTable&#34;</a>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDFGJEC"></a>
<div id="TTCLS398" class="sect4">
<h5 class="sect4">get<a id="sthref346"></a>TableIndex()</h5>
<pre dir="ltr">int getTableIndex(const char* <span class="italic">owner</span>, const char* <span class="italic">tblname</span>) const
</pre>
<p>This method fetches the index in the <code dir="ltr">TTCatalog</code> object for the specified <code dir="ltr"><span class="codeinlineitalic">owner.tblname</span></code> object. It returns -2 if <code dir="ltr"><span class="codeinlineitalic">owner.tblname</span></code> does not exist. It returns -1 if <code dir="ltr">fetchCatalogData()</code> was not called first.</p>
<p><a href="#CHDBICIC">Example 3-8</a> retrieves information about the <code dir="ltr">TTUSER.MYDATA</code> table from a <code dir="ltr">TTCatalog</code> object. You can then call methods of <code dir="ltr">TTCatalogTable</code>, described next, to get information about this table.</p>
<div id="TTCLS399" class="example">
<p class="titleinexample"><a id="CHDBICIC"></a>Example 3-8 Retrieving table information from a catalog</p>
<pre dir="ltr">TTConnection conn;
conn.Connect(...);
TTCatalog cat (&amp;conn);
cat.fetchCatalogData();

int idx = cat.getTableIndex(&#34;TTUSER&#34;, &#34;MYDATA&#34;);
if (idx &lt; 0) {
  cerr &lt;&lt; &#34;Table TTUSER.MYDATA does not exist.&#34; &lt;&lt; endl;
  return;
}
 
TTCatalogTable &amp;table = cat.getTable(idx);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CHDEECHJ"></a>
<div id="TTCLS397" class="sect4">
<h5 class="sect4">get<a id="sthref347"></a>UserTable()</h5>
<pre dir="ltr">const TTCatalogTable&amp; getUserTable(int <span class="italic">tno</span>)
</pre>
<p>Returns a constant reference to the <code dir="ltr">TTCatalogTable</code> object corresponding to user table number <code dir="ltr"><span class="codeinlineitalic">tno</span></code> in the system. This method is intended to facilitate iteration through all of the user tables in the system. The order of the user tables in this array is arbitrary. Also see <code dir="ltr"><a href="#CHDGIIIJ">getTable()</a></code>.</p>
<p>The following relationship is true:</p>
<pre dir="ltr">0 &lt;= <span class="italic">tno</span> &lt; getNumUserTables()
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is no equivalent method for system tables.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBBBAH"></a>
<div id="TTCLS400" class="sect2">
<h3 class="sect2"><a id="sthref348"></a><a id="sthref349"></a><a id="sthref350"></a><a id="sthref351"></a>TTCatalogTable</h3>
<p>A <code dir="ltr">TTCatalogTable</code> object is retrieved through the <code dir="ltr">TTCatalog::<a href="#CHDGIIIJ">getTable()</a></code> method and stores all metadata information about the columns and indexes of a table.</p>
<div id="TTCLS401" class="sect3"><a id="sthref352"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS402" class="sect3"><a id="sthref353"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="Table Summary value required!!!" dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t34">Method</th>
<th class="cellalignment2190" id="r1c2-t34">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDHGIIC">getColumn()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t34 r1c2-t34">Returns a constant reference to the <code dir="ltr">TTCatalogColumn</code> corresponding to the <code dir="ltr"><span class="codeinlineitalic">i</span></code>th column in the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDEFEHH">getIndex()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t34 r1c2-t34">Returns a constant reference to the <code dir="ltr">TTCatalogIndex</code> object corresponding to the <code dir="ltr"><span class="codeinlineitalic">n</span></code>th index in the table, where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is specified.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDEIJCA">getNumColumns()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t34 r1c2-t34">Returns the number of columns in the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDGEABC">getNumIndexes()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t34 r1c2-t34">Returns the number of indexes on the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDIHBDJ">getNumSpecialColumns()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t34 r1c2-t34">Returns the number of <span class="italic">special columns</span> in this table. See <a href="#CHDJFAHE">&#34;TTCatalogSpecialColumn&#34;</a>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDDCEHH">getSpecialColumn()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t34 r1c2-t34">Returns a special column (<code dir="ltr">TTCatalogSpecialColumn</code> object) from this table, according to the specified column number.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDFEEJB">getTableName()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t34 r1c2-t34">Returns the name of the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDHBJFH">getTableOwner()</a></code></td>
<td class="cellalignment2191" headers="r9c1-t34 r1c2-t34">Returns the owner of the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDJFFHI">getTableType()</a></code></td>
<td class="cellalignment2191" headers="r10c1-t34 r1c2-t34">Returns the table type as returned by the ODBC <code dir="ltr">SQLTables</code> function.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r11c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDHEIBJ">isSystemTable()</a></code></td>
<td class="cellalignment2191" headers="r11c1-t34 r1c2-t34">Returns <code dir="ltr">TRUE</code> if the table is a system table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r12c1-t34" headers="r1c1-t34"><code dir="ltr"><a href="#CHDJACDC">isUserTable()</a></code></td>
<td class="cellalignment2191" headers="r12c1-t34 r1c2-t34">Returns <code dir="ltr">TRUE</code> if the table is a user table.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDHGIIC"></a>
<div id="TTCLS407" class="sect4">
<h5 class="sect4">get<a id="sthref354"></a><a id="sthref355"></a>Column()</h5>
<pre dir="ltr">const TTCatalogColumn&amp; getColumn(int <span class="italic">cno</span>)
</pre>
<p>Returns a constant reference to the <code dir="ltr"><a href="#CHDHHCAB">TTCatalogColumn</a></code> object corresponding to column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> in the table. This method is intended to facilitate iteration through all the columns in the table.</p>
<p>The following relationship is true:</p>
<pre dir="ltr">0 &lt;= <span class="italic">cno</span> &lt; getNumColumns()
</pre></div>
<!-- class="sect4" -->
<a id="CHDEFEHH"></a>
<div id="TTCLS408" class="sect4">
<h5 class="sect4">get<a id="sthref356"></a><a id="sthref357"></a>Index()</h5>
<pre dir="ltr">const TTCatalogIndex&amp; getIndex(int <span class="italic">num</span>)
</pre>
<p>Returns a constant reference to the <code dir="ltr"><a href="#CHDBJJGI">TTCatalogIndex</a></code> object corresponding to index number <code dir="ltr"><span class="codeinlineitalic">num</span></code> in the table. This method is intended to facilitate iteration through all the indexes of the table. The order of the indexes of a table in this array is arbitrary.</p>
<p>The following relationship is true:</p>
<pre dir="ltr">0 &lt;= <span class="italic">num</span> &lt; getNumIndexes()
</pre></div>
<!-- class="sect4" -->
<a id="CHDEIJCA"></a>
<div id="TTCLS405" class="sect4">
<h5 class="sect4">get<a id="sthref358"></a><a id="sthref359"></a>NumColumns()</h5>
<pre dir="ltr">int getNumColumns()
</pre>
<p>Returns the number of columns in the table.</p>
</div>
<!-- class="sect4" -->
<a id="CHDGEABC"></a>
<div id="TTCLS406" class="sect4">
<h5 class="sect4">get<a id="sthref360"></a><a id="sthref361"></a>NumIndexes()</h5>
<pre dir="ltr">int getNumIndexes()
</pre>
<p>Returns the number of indexes on the table.</p>
</div>
<!-- class="sect4" -->
<a id="CHDIHBDJ"></a>
<div id="TTCLS412" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">getNu<a id="sthref362"></a>mSpecialColumns()</h5>
<pre dir="ltr">int getNumSpecialColumns()
</pre>
<p>Returns the number of <span class="italic">special columns</span> in this <code dir="ltr">TTCatalogTable</code> object. Because TimesTen supports only rowid special columns, this always returns 1.</p>
<p>Also see <a href="#CHDJFAHE">&#34;TTCatalogSpecialColumn&#34;</a>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDDCEHH"></a>
<div id="TTCLS413" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref363"></a><a id="sthref364"></a>SpecialColumn()</h5>
<pre dir="ltr">const TTCatalogSpecialColumn&amp; getSpecialColumn(int <span class="italic">num</span>) const
</pre>
<p>Returns a <span class="italic">special column</span> (<code dir="ltr">TTCatalogSpecialColumn</code> object) from this <code dir="ltr">TTCatalogTable</code> object, according to the specified column number. In TimesTen this can be only a rowid pseudocolumn.</p>
<p>Also see <a href="#CHDJFAHE">&#34;TTCatalogSpecialColumn&#34;</a>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDFEEJB"></a>
<div id="TTCLS404" class="sect4">
<h5 class="sect4">get<a id="sthref365"></a><a id="sthref366"></a>TableName()</h5>
<pre dir="ltr">const char* getTableName()
</pre>
<p>Returns the name of the table.</p>
</div>
<!-- class="sect4" -->
<a id="CHDHBJFH"></a>
<div id="TTCLS403" class="sect4">
<h5 class="sect4">get<a id="sthref367"></a><a id="sthref368"></a>TableOwner()</h5>
<pre dir="ltr">const char* getTableOwner()
</pre>
<p>Returns the owner of the table.</p>
</div>
<!-- class="sect4" -->
<a id="CHDJFFHI"></a>
<div id="TTCLS409" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref369"></a>TableType()</h5>
<pre dir="ltr">const char* getTableType() const
</pre>
<p>Returns the table type of this <code dir="ltr">TTCatalogTable</code> object, as from an ODBC <code dir="ltr">SQLTables</code> call. In TimesTen this may be <code dir="ltr">TABLE</code>, <code dir="ltr">SYSTEM TABLE</code>, <code dir="ltr">VIEW</code>, or <code dir="ltr">SYNONYM</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDHEIBJ"></a>
<div id="TTCLS410" class="sect4">
<h5 class="sect4">is<a id="sthref370"></a>SystemTable()</h5>
<pre dir="ltr">bool isSystemTable()
</pre>
<p>Returns <code dir="ltr">TRUE</code> if the table is a system table (owned by <code dir="ltr">SYS</code>, <code dir="ltr">TTREP</code>, or <code dir="ltr">GRID</code>), or <code dir="ltr">FALSE</code> otherwise.</p>
<p>The <code dir="ltr">isSystemTable()</code> method and <code dir="ltr">isUserTable()</code> method (described next) are useful for applications that iterate over all tables in a database after a call to <code dir="ltr"><a href="#CHDDCGGA">TTCatalog</a></code><code dir="ltr">::fetchCatalogData()</code>, so that you can filter or annotate tables to differentiate the system and user tables. The TTClasses demo program <code dir="ltr">catalog</code> provides an example of how this can be done. (See <a href="compiling.htm#BCGGJCJF">&#34;About the TimesTen TTClasses demos&#34;</a>.)</p>
</div>
<!-- class="sect4" -->
<a id="CHDJACDC"></a>
<div id="TTCLS411" class="sect4">
<h5 class="sect4">is<a id="sthref371"></a>UserTable()</h5>
<pre dir="ltr">bool isUserTable()
</pre>
<p>Returns <code dir="ltr">TRUE</code> if this is a user table, which is to say it is not a system table, or <code dir="ltr">FALSE</code> otherwise. Note that <code dir="ltr">isUserTable()</code> returns the opposite of <code dir="ltr">isSystemTable()</code> for any table. The description of <code dir="ltr">isSystemTable()</code> discusses the usage and usefulness of these methods.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDHHCAB"></a>
<div id="TTCLS414" class="sect2">
<h3 class="sect2"><a id="sthref372"></a><a id="sthref373"></a><a id="sthref374"></a><a id="sthref375"></a>TTCatalogColumn</h3>
<p>The <code dir="ltr">TTCatalogColumn</code> class is used to store all metadata information about a single column of a table. This table is represented by the <code dir="ltr"><a href="#CHDBBBAH">TTCatalogTable</a></code> object from which the column was retrieved through a <code dir="ltr">TTCatalogTable::getColumn()</code> call.</p>
<div id="TTCLS415" class="sect3"><a id="sthref376"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS416" class="sect3"><a id="sthref377"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods of TTCatalogColumn." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t35">Method</th>
<th class="cellalignment2190" id="r1c2-t35">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t35" headers="r1c1-t35"><code dir="ltr"><a href="#CHDHHHJF">getColumnName()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t35 r1c2-t35">Return the name of the column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t35" headers="r1c1-t35"><code dir="ltr"><a href="#CHDCGJFF">getDataType()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t35 r1c2-t35">Returns an integer representing the ODBC SQL data type of the column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t35" headers="r1c1-t35"><code dir="ltr"><a href="#CHDFBJFG">getLength()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t35 r1c2-t35">Returns the length of the column, in bytes.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t35" headers="r1c1-t35"><code dir="ltr"><a href="#CHDDIEHC">getNullable()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t35 r1c2-t35">Indicates whether the column can contain <code dir="ltr">NULL</code> values. (This is not a boolean value, as noted in the description below.)</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t35" headers="r1c1-t35"><code dir="ltr"><a href="#CHDBHACI">getPrecision()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t35 r1c2-t35">Returns the precision of the column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t35" headers="r1c1-t35"><code dir="ltr"><a href="#CHDHCJIB">getRadix()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t35 r1c2-t35">Returns the radix of the column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t35" headers="r1c1-t35"><code dir="ltr"><a href="#CHDGCGBD">getScale()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t35 r1c2-t35">Returns the scale of the column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t35" headers="r1c1-t35"><code dir="ltr"><a href="#CHDDEJFE">getTypeName()</a></code></td>
<td class="cellalignment2191" headers="r9c1-t35 r1c2-t35">Returns the TimesTen name for the type returned by <code dir="ltr">getDataType()</code>.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDHHHJF"></a>
<div id="TTCLS417" class="sect4">
<h5 class="sect4">get<a id="sthref378"></a>ColumnName()</h5>
<pre dir="ltr">const char* getColumnName()
</pre>
<p>Returns the name of the column.</p>
</div>
<!-- class="sect4" -->
<a id="CHDCGJFF"></a>
<div id="TTCLS418" class="sect4">
<h5 class="sect4">get<a id="sthref379"></a>DataType()</h5>
<pre dir="ltr">int getDataType()
</pre>
<p>Returns an integer representing the data type of the column. This is the standard ODBC SQL type code or a TimesTen extension type code.</p>
</div>
<!-- class="sect4" -->
<a id="CHDFBJFG"></a>
<div id="TTCLS421" class="sect4">
<h5 class="sect4">get<a id="sthref380"></a>Length()</h5>
<pre dir="ltr">int getLength()
</pre>
<p>Returns the length of data in the column, in bytes.</p>
</div>
<!-- class="sect4" -->
<a id="CHDDIEHC"></a>
<div id="TTCLS420" class="sect4">
<h5 class="sect4">get<a id="sthref381"></a>Nullable()</h5>
<pre dir="ltr">int getNullable()
</pre>
<p>Indicates whether the column can contain <code dir="ltr">NULL</code> values. It returns <code dir="ltr">SQL_NO_NULLS</code>, <code dir="ltr">SQL_NULLABLE</code>, or <code dir="ltr">SQL_NULLABLE_UNKNOWN</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDBHACI"></a>
<div id="TTCLS422" class="sect4">
<h5 class="sect4">get<a id="sthref382"></a>Precision()</h5>
<pre dir="ltr">int getPrecision()
</pre>
<p>Returns the precision of data in the column, referring to the maximum number of digits that are used by the data type.</p>
</div>
<!-- class="sect4" -->
<a id="CHDHCJIB"></a>
<div id="TTCLS424" class="sect4">
<h5 class="sect4">get<a id="sthref383"></a>Radix()</h5>
<pre dir="ltr">int getRadix()
</pre>
<p>Returns the radix of the column, according to ODBC <code dir="ltr">SQLColumns</code> function output.</p>
</div>
<!-- class="sect4" -->
<a id="CHDGCGBD"></a>
<div id="TTCLS423" class="sect4">
<h5 class="sect4">get<a id="sthref384"></a>Scale()</h5>
<pre dir="ltr">int getScale()
</pre>
<p>Returns the scale of data in the column, which is the maximum number of digits to the right of the decimal point.</p>
</div>
<!-- class="sect4" -->
<a id="CHDDEJFE"></a>
<div id="TTCLS419" class="sect4">
<h5 class="sect4">get<a id="sthref385"></a>TypeName()</h5>
<pre dir="ltr">const char* getTypeName()
</pre>
<p>Returns the TimesTen name of the type returned by <code dir="ltr">getDataType()</code>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBJJGI"></a>
<div id="TTCLS425" class="sect2">
<h3 class="sect2"><a id="sthref386"></a><a id="sthref387"></a><a id="sthref388"></a><a id="sthref389"></a>TTCatalogIndex</h3>
<p>The <code dir="ltr">TTCatalogIndex</code> class is used to store all metadata information about an index of a table. This table is represented by the <code dir="ltr"><a href="#CHDBBBAH">TTCatalogTable</a></code> object from which the index was retrieved through a <code dir="ltr">TTCatalogTable::getIndex()</code> call.</p>
<div id="TTCLS426" class="sect3"><a id="sthref390"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS427" class="sect3"><a id="sthref391"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of public methods for TTCatalogIndex." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t36">Method</th>
<th class="cellalignment2190" id="r1c2-t36">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t36" headers="r1c1-t36"><code dir="ltr"><a href="#CHDBGEFJ">getCollation()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t36 r1c2-t36">Returns the collation of the specified column in the index.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t36" headers="r1c1-t36"><code dir="ltr"><a href="#CHDBGACB">getColumnName()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t36 r1c2-t36">Returns the name of the specified column in the index.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t36" headers="r1c1-t36"><code dir="ltr"><a href="#CHDIIGGG">getIndexName()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t36 r1c2-t36">Returns the name of the index.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t36" headers="r1c1-t36"><code dir="ltr"><a href="#CHDHEHIC">getIndexOwner()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t36 r1c2-t36">Returns the owner of the index.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t36" headers="r1c1-t36"><code dir="ltr"><a href="#CHDHFCIF">getNumColumns()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t36 r1c2-t36">Returns the number of columns in the index.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t36" headers="r1c1-t36"><code dir="ltr"><a href="#CHDBFHCG">getTableName()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t36 r1c2-t36">Returns the name of the table for which the index was created.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t36" headers="r1c1-t36"><code dir="ltr"><a href="#CHDFCACI">getType()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t36 r1c2-t36">Returns the type of the index.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t36" headers="r1c1-t36"><code dir="ltr"><a href="#CHDEDDBA">isUnique()</a></code></td>
<td class="cellalignment2191" headers="r9c1-t36 r1c2-t36">Indicates whether the index is a unique index.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDBGEFJ"></a>
<div id="TTCLS435" class="sect4">
<h5 class="sect4">get<a id="sthref392"></a>Collation()</h5>
<pre dir="ltr">char getCollation (int <span class="italic">num</span>)
</pre>
<p>Returns the collation of column number <code dir="ltr"><span class="codeinlineitalic">num</span></code> in the index. Values returned are &#34;A&#34; for ascending order or &#34;D&#34; for descending order.</p>
</div>
<!-- class="sect4" -->
<a id="CHDBGACB"></a>
<div id="TTCLS434" class="sect4">
<h5 class="sect4">get<a id="sthref393"></a>ColumnName()</h5>
<pre dir="ltr">const char* getColumnName(int <span class="italic">num</span>)
</pre>
<p>Returns the name of column number <code dir="ltr"><span class="codeinlineitalic">num</span></code> in the index.</p>
</div>
<!-- class="sect4" -->
<a id="CHDIIGGG"></a>
<div id="TTCLS428" class="sect4">
<h5 class="sect4">get<a id="sthref394"></a>IndexName()</h5>
<pre dir="ltr">const char* getIndexName()
</pre>
<p>Returns the name of the index.</p>
</div>
<!-- class="sect4" -->
<a id="CHDHEHIC"></a>
<div id="TTCLS429" class="sect4">
<h5 class="sect4">get<a id="sthref395"></a>IndexOwner()</h5>
<pre dir="ltr">const char* getIndexOwner()
</pre>
<p>Returns the owner of the index.</p>
</div>
<!-- class="sect4" -->
<a id="CHDHFCIF"></a>
<div id="TTCLS433" class="sect4">
<h5 class="sect4">get<a id="sthref396"></a>NumColumns()</h5>
<pre dir="ltr">int getNumColumns()
</pre>
<p>Returns the number of columns in the index.</p>
</div>
<!-- class="sect4" -->
<a id="CHDBFHCG"></a>
<div id="TTCLS430" class="sect4">
<h5 class="sect4">get<a id="sthref397"></a>TableName()</h5>
<pre dir="ltr">const char* getTableName()
</pre>
<p>Returns the name of the table for which the index was created. This is the table represented by the <code dir="ltr"><a href="#CHDBBBAH">TTCatalogTable</a></code> object from which the index was retrieved through a <code dir="ltr">TTCatalogTable::getIndex()</code> call.</p>
</div>
<!-- class="sect4" -->
<a id="CHDFCACI"></a>
<div id="TTCLS431" class="sect4">
<h5 class="sect4">get<a id="sthref398"></a>Type()</h5>
<pre dir="ltr">int getType()
</pre>
<p>Returns the type of the index. For TimesTen, the allowable values are <code dir="ltr">PRIMARY_KEY</code>, <code dir="ltr">HASH_INDEX</code> (the same as <code dir="ltr">PRIMARY_KEY</code>), and <code dir="ltr">RANGE_INDEX</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDEDDBA"></a>
<div id="TTCLS432" class="sect4">
<h5 class="sect4">is<a id="sthref399"></a>Unique()</h5>
<pre dir="ltr">bool isUnique()
</pre>
<p>Returns <code dir="ltr">TRUE</code> if the index is a unique index, or <code dir="ltr">FALSE</code> otherwise.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDJFAHE"></a>
<div id="TTCLS436" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">TTCatalo<a id="sthref400"></a><a id="sthref401"></a><a id="sthref402"></a><a id="sthref403"></a>gSpecialColumn</h3>
<p>This class is a wrapper for results from an ODBC <code dir="ltr">SQLSpecialColumns</code> function call on a table represented by a <code dir="ltr"><a href="#CHDBBBAH">TTCatalogTable</a></code> object. In TimesTen, a rowid pseudocolumn is the only type of special column supported, so a <code dir="ltr">TTCatalogSpecialColumn</code> object can only contain information about rowids.</p>
<div id="TTCLS437" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref404"></a>
<h4 class="sect3">Usage</h4>
<p>Obtain a <code dir="ltr">TTCatalogSpecialColumn</code> object by calling the <code dir="ltr">getSpecialColumn()</code> method on the relevant <code dir="ltr">TTCatalogTable</code> object.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS438" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref405"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS439" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref406"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods for TTCatalogSpecialColumn." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t37">Method</th>
<th class="cellalignment2190" id="r1c2-t37">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t37" headers="r1c1-t37"><code dir="ltr"><a href="#CHDBAIIA">getColumnName()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t37 r1c2-t37">Returns the name of the special column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t37" headers="r1c1-t37"><code dir="ltr"><a href="#CHDGAGCH">getDataType()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t37 r1c2-t37">Returns the data type of the special column, as an integer.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t37" headers="r1c1-t37"><code dir="ltr"><a href="#CHDGBIAJ">getLength()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t37 r1c2-t37">Returns the length of data in the special column, in bytes.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t37" headers="r1c1-t37"><code dir="ltr"><a href="#CHDFEECB">getPrecision()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t37 r1c2-t37">Returns the precision of the special column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t37" headers="r1c1-t37"><code dir="ltr"><a href="#CHDBJEHG">getScale()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t37 r1c2-t37">Returns the scale of the special column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t37" headers="r1c1-t37"><code dir="ltr"><a href="#CHDDHCJD">getTypeName()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t37 r1c2-t37">Returns the data type of the special column, as a character string.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDBAIIA"></a>
<div id="TTCLS440" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">g<a id="sthref407"></a>etColumnName()</h5>
<pre dir="ltr">const char* getColumnName()
</pre>
<p>Returns the name of the special column.</p>
</div>
<!-- class="sect4" -->
<a id="CHDGAGCH"></a>
<div id="TTCLS441" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">ge<a id="sthref408"></a>tDataType()</h5>
<pre dir="ltr">int getDataType()
</pre>
<p>Returns an integer representing the ODBC SQL data type of the special column. In TimesTen this can be only <code dir="ltr">SQL_ROWID</code>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDGBIAJ"></a>
<div id="TTCLS442" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref409"></a>Length()</h5>
<pre dir="ltr">int getLength()
</pre>
<p>Returns the length of data in the special column, in bytes.</p>
</div>
<!-- class="sect4" -->
<a id="CHDFEECB"></a>
<div id="TTCLS443" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref410"></a>Precision()</h5>
<pre dir="ltr">int getPrecision()
</pre>
<p>Returns the precision for data in the special column, referring to the maximum number of digits used by the data type.</p>
</div>
<!-- class="sect4" -->
<a id="CHDBJEHG"></a>
<div id="TTCLS444" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref411"></a>Scale()</h5>
<pre dir="ltr">int getScale()
</pre>
<p>Returns the scale for data in the special column, referring to the maximum number of digits to the right of the decimal point.</p>
</div>
<!-- class="sect4" -->
<a id="CHDDHCJD"></a>
<div id="TTCLS445" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref412"></a>TypeName()</h5>
<pre dir="ltr">const char* getTypeName()
</pre>
<p>Returns the data type name that corresponds to the ODBC SQL data type value returned by <code dir="ltr">getDataType()</code>. In TimesTen this can be only <code dir="ltr">ROWID</code>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i96833"></a>
<div id="TTCLS293" class="sect1">
<h2 class="sect1"><a id="sthref413"></a>XLA classes</h2>
<p>TTClasses provides a set of classes for applications to use with the TimesTen Transaction Log API (XLA).</p>
<p>XLA is a set of C-callable functions that allow an application to monitor changes made to one or more database tables. Whenever another application changes a monitored table, the application using XLA is informed of the changes. For more information about XLA, see <a class="olink TTCDV246" href="../TTCDV/xla_event.htm#TTCDV246">&#34;XLA and TimesTen Event Management&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span>.</p>
<p>The XLA classes support as many XLA columns as the maximum number of columns supported by TimesTen. For more information, see <a class="olink TTREF455" href="../TTREF/limit.htm#TTREF455">&#34;System Limits&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
As noted in <a href="compiling.htm#BCGEIJGG">&#34;Considerations when using an ODBC driver manager (Windows)&#34;</a>, XLA functionality is not supported with TTClasses when you use an ODBC driver manager.</div>
<p>This section discusses the following classes:</p>
<ul>
<li>
<p><code dir="ltr"><a href="#i111047">TTXlaPersistConnection</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#i99749">TTXlaRowViewer</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#i96093">TTXlaTableHandler</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#i96097">TTXlaTableList</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#CHDBCDFD">TTXlaTable</a></code></p>
</li>
<li>
<p><code dir="ltr"><a href="#CHDIGJJB">TTXlaColumn</a></code></p>
</li>
</ul>
<a id="i111047"></a>
<div id="TTCLS295" class="sect2">
<h3 class="sect2">TTXla<a id="sthref414"></a><a id="sthref415"></a>PersistConnection</h3>
<p>Use <code dir="ltr">TTXlaPersistConnection</code> to create an XLA connection to a database.</p>
<div id="TTCLS306" class="sect3"><a id="sthref416"></a>
<h4 class="sect3">Usage</h4>
<p>An XLA application can create multiple <code dir="ltr">TTXlaPersistConnection</code> objects if needed. Each <code dir="ltr">TTXlaPersistConnection</code> object must be associated with its own bookmark, which is specified at connect time and must be maintained through the <code dir="ltr">ackUpdates()</code> and <code dir="ltr">deleteBookmarkAndDisconnect()</code> methods. Most applications require only one or two XLA bookmarks.</p>
<p>After an XLA connection is established, the application should enter a loop in which the <code dir="ltr">fetchUpdatesWait()</code> method is called repeatedly until application termination. This loop should fetch updates from XLA as rapidly as possible to ensure that the transaction log does not fill up available disk space.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>The transaction log is in a file system location according to the TimesTen <code dir="ltr">LogDir</code> attribute setting, if specified, or the <code dir="ltr">DataStore</code> attribute setting if <code dir="ltr">LogDir</code> is not specified. Refer to <a class="olink TTREF126" href="../TTREF/attribute.htm#TTREF126">&#34;Data store attributes&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</li>
<li>
<p>Each bookmark establishes its own log hold on the transaction log. (See <a class="olink TTREF261" href="../TTREF/proced.htm#TTREF261">&#34;ttLogHolds&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span> for related information.) If any bookmark is not moved forward periodically, transaction logs cannot be purged by checkpoint operations. This can fill up disk space over time.</p>
</li>
</ul>
</div>
<p>After processing a batch of updates, the application should call <code dir="ltr">ackUpdates()</code> to acknowledge those updates and get ready for the next call to <code dir="ltr">fetchUpdatesWait()</code>. A batch of updates can be replayed using the <code dir="ltr">setBookmarkIndex()</code> and <code dir="ltr">getBookmarkIndex()</code> methods. Also, if the XLA application disconnects after <code dir="ltr">fetchUpdatesWait()</code> but before <code dir="ltr">ackUpdates()</code>, the next connection (with the same bookmark name) that calls <code dir="ltr">fetchUpdatesWait()</code> sees that same batch of updates.</p>
<p>Updates that occur while a <code dir="ltr">TTXlaPersistConnection</code> object is disconnected from the database are not lost. They are stored in the transaction log until another <code dir="ltr">TTXlaPersistConnection</code> object connects with the same bookmark name.</p>
<p>Privilege to connect to a database must be granted to users through the <code dir="ltr">CREATE SESSION</code> privilege, either directly or through the <code dir="ltr">PUBLIC</code> role. See <a href="usage.htm#CDEJBGDF">&#34;Access control for connections&#34;</a>. In addition, the <code dir="ltr">XLA</code> privilege is required for XLA connections and functionality.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS296" class="sect3"><a id="sthref417"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS297" class="sect3"><a id="sthref418"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods of TTXlaPersistConnection." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t40">Method</th>
<th class="cellalignment2190" id="r1c2-t40">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t40" headers="r1c1-t40"><code dir="ltr"><a href="#i110235">ackUpdates()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t40 r1c2-t40">Advances the bookmark to the next set of updates.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t40" headers="r1c1-t40"><code dir="ltr"><a href="#i110210">Connect()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t40 r1c2-t40">Connects with the specified bookmark, or creates one if it does not exist (depending on the method signature).</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t40" headers="r1c1-t40"><code dir="ltr"><a href="#i110229">deleteBookmarkAndDisconnect()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t40 r1c2-t40">Deletes the bookmark and disconnects from the database.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t40" headers="r1c1-t40"><code dir="ltr"><a href="#i110769">Disconnect()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t40 r1c2-t40">Closes an XLA connection to a database, leaving the bookmark in place.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t40" headers="r1c1-t40"><code dir="ltr"><a href="#i110252">fetchUpdatesWait()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t40 r1c2-t40">Fetches updates to the transaction log within the specified wait period.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t40" headers="r1c1-t40"><code dir="ltr"><a href="#i110239">getBookmarkIndex()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t40 r1c2-t40">Gets the current transaction log position.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t40" headers="r1c1-t40"><code dir="ltr"><a href="#i110246">setBookmarkIndex()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t40 r1c2-t40">Returns to the transaction log position that was acquired by a <code dir="ltr">getBookmarkIndex()</code> call.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="i110235"></a>
<div id="TTCLS302" class="sect4">
<h5 class="sect4">ack<a id="sthref419"></a><a id="sthref420"></a><a id="sthref421"></a>Updates()</h5>
<pre dir="ltr">void ackUpdates()
</pre>
<p>Use this method to advance the bookmark to the next set of updates. After you have acknowledged a set of updates, the updates cannot be viewed again by this bookmark. Therefore, a <code dir="ltr">setBookmarkIndex()</code> call does not allow you to replay XLA records that have been acknowledged by a call to <code dir="ltr">ackUpdates()</code>. (See the descriptions of <code dir="ltr"><a href="#i110239">getBookmarkIndex()</a></code> and <code dir="ltr"><a href="#i110246">setBookmarkIndex()</a></code> for information about replaying a set of updates.)</p>
<p>Applications should acknowledge updates when a batch of XLA records have been read and processed, so that the transaction log does not fill up available disk space; however, do not call <code dir="ltr">ackUpdates()</code> too frequently, because it is a relatively expensive operation.</p>
<p>If an application uses XLA to read a batch of records and then a failure occurs before <code dir="ltr">ackUpdates()</code> is called, the records are retrieved when the application reestablishes its XLA connection.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The transaction log is in a file system location according to the TimesTen <code dir="ltr">LogDir</code> attribute setting, if specified, or the <code dir="ltr">DataStore</code> attribute setting if <code dir="ltr">LogDir</code> is not specified. Refer to <a class="olink TTREF126" href="../TTREF/attribute.htm#TTREF126">&#34;Data store attributes&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</div>
</div>
<!-- class="sect4" -->
<a id="i110210"></a>
<div id="TTCLS298" class="sect4">
<h5 class="sect4">Con<a id="sthref422"></a><a id="sthref423"></a><a id="sthref424"></a>nect()</h5>
<pre dir="ltr">virtual void Connect(const char* <span class="italic">connStr</span>, const char* <span class="italic">bookmarkStr</span>, 
                     bool <span class="italic">createBookmarkFlag</span>)
virtual void Connect(const char* <span class="italic">connStr</span>, const char* <span class="italic">username</span>, 
                     const char* <span class="italic">password</span>, const char* <span class="italic">bookmarkStr</span>, 
                     bool <span class="italic">createBookmarkFlag</span>)
virtual void Connect(const char* <span class="italic">connStr</span>, 
                     TTConnection::DRIVER_COMPLETION_ENUM <span class="italic">driverCompletion</span>,
                     const char* <span class="italic">bookmarkStr</span>, bool <span class="italic">createBookmarkFlag</span>)

virtual void Connect(const char* <span class="italic">connStr</span>, const char* <span class="italic">bookmarkStr</span>)
virtual void Connect(const char* <span class="italic">connStr</span>, const char* <span class="italic">username</span>, 
                     const char* <span class="italic">password</span>, const char* <span class="italic">bookmarkStr</span>)
virtual void Connect(const char* <span class="italic">connStr</span>,
                     TTConnection::DRIVER_COMPLETION_ENUM <span class="italic">driverCompletion</span>,
                     const char* <span class="italic">bookmarkStr</span>)
</pre>
<p>Each XLA connection has a bookmark name associated with it, so that after disconnecting and reconnecting, the same place in the transaction log can be found. The name for the bookmark of a connection is specified in the <code dir="ltr"><span class="codeinlineitalic">bookmarkStr</span></code> parameter.</p>
<p>For the first set of methods listed above, the <code dir="ltr"><span class="codeinlineitalic">createBookmarkFlag</span></code> boolean parameter indicates whether the specified bookmark is new or was previously created. If you indicate that a bookmark is new (<code dir="ltr"><span class="codeinlineitalic">createBookmarkFlag</span></code><code dir="ltr">==true</code>) and it already exists, an error is returned. Similarly, if you indicate that a bookmark already exists (<code dir="ltr"><span class="codeinlineitalic">createBookmarkFlag</span></code><code dir="ltr">==false</code>) and it does not exist, an error is returned.</p>
<p>For the second set of methods listed, without <code dir="ltr"><span class="codeinlineitalic">createBookmarkFlag</span></code>, TTClasses first tries to connect reusing the supplied bookmark (behavior equivalent to <code dir="ltr"><span class="codeinlineitalic">createBookmarkFlag</span></code><code dir="ltr">==false</code>). If that bookmark does not exist, TTClasses then tries to connect and create a new bookmark with the name <code dir="ltr"><span class="codeinlineitalic">bookmarkStr</span></code> (behavior equivalent to <code dir="ltr"><span class="codeinlineitalic">createBookmarkFlag</span></code><code dir="ltr">==true</code>). These methods are provided as a convenience, to simplify XLA connection logic if you would rather not concern yourself with whether the XLA bookmark exists.</p>
<p>In either mode, with or without <code dir="ltr"><span class="codeinlineitalic">createBookmarkFlag</span></code>, specify a user name and password either through the connection string or through the separate parameters, or specify a <code dir="ltr">DRIVER_COMPLETION_ENUM</code> value. Refer to <a href="#i95276">&#34;TTConnection&#34;</a> for information about <code dir="ltr">DRIVER_COMPLETION_ENUM</code>.</p>
<p>Privilege to connect to a database must be granted to users through the <code dir="ltr">CREATE SESSION</code> privilege, either directly or through the <code dir="ltr">PUBLIC</code> role. See <a href="usage.htm#CDEJBGDF">&#34;Access control for connections&#34;</a>. In addition, the <code dir="ltr">XLA</code> privilege is required to create an XLA connection.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Only one XLA connection can connect with a given bookmark name. An error is returned if multiple connections try to connect to the same bookmark.</div>
</div>
<!-- class="sect4" -->
<a id="i110229"></a>
<div id="TTCLS300" class="sect4">
<h5 class="sect4">delete<a id="sthref425"></a><a id="sthref426"></a><a id="sthref427"></a>BookmarkAndDisconnect()</h5>
<pre dir="ltr">void deleteBookmarkAndDisconnect()
</pre>
<p>This method first deletes the bookmark that is currently associated with the connection, so that the database no longer keeps records relevant to that bookmark, then disconnects from the database.</p>
<p>To disconnect without deleting the bookmark, use the <code dir="ltr">Disconnect()</code> method instead.</p>
</div>
<!-- class="sect4" -->
<a id="i110769"></a>
<div id="TTCLS301" class="sect4">
<h5 class="sect4">Dis<a id="sthref428"></a><a id="sthref429"></a><a id="sthref430"></a>connect()</h5>
<pre dir="ltr">virtual void Disconnect()
</pre>
<p>This method closes an XLA connection to a database. The XLA bookmark persists after you call this method.</p>
<p>To delete the bookmark and disconnect from the database, use <code dir="ltr">deleteBookmarkAndDisconnect()</code> instead.</p>
</div>
<!-- class="sect4" -->
<a id="i110252"></a>
<div id="TTCLS305" class="sect4">
<h5 class="sect4">fetch<a id="sthref431"></a><a id="sthref432"></a>UpdatesWait()</h5>
<pre dir="ltr">void fetchUpdatesWait(ttXlaUpdateDesc_t*** <span class="italic">arry</span>, int <span class="italic">maxrecs</span>,
                      int* <span class="italic">recsP</span>, int <span class="italic">seconds</span>)
</pre>
<p>Use this method to fetch a set of records describing changes to a database. A list of <code dir="ltr">ttXlaUpdateDesc_t</code> structures is returned. If there are no XLA updates to be fetched, this method waits the specified number of seconds before returning.</p>
<p>Specify the number of seconds to wait, <code dir="ltr"><span class="codeinlineitalic">seconds</span></code>, and the maximum number of records to receive, <code dir="ltr"><span class="codeinlineitalic">maxrecs</span></code>. The method returns the number of records actually received, <code dir="ltr"><span class="codeinlineitalic">recsP</span></code>, and an array of pointers, <code dir="ltr"><span class="codeinlineitalic">arry</span></code>, that point to structures defining the changes.</p>
<p>The <code dir="ltr">ttXlaUpdateDesc_t</code> structures that are returned by this method are defined in the XLA specification. No C++ object-oriented encapsulation of these methods is provided. Typically, after calling <code dir="ltr">fetchUpdatesWait()</code>, an application processes these <code dir="ltr">ttXlaUpdateDesc_t</code> structures in a sequence of calls to <code dir="ltr">TTXlaTableList::<a href="#i99821">HandleChange()</a></code>.</p>
<p>See <a class="olink TTCDV447" href="../TTCDV/xla_ref.htm#TTCDV447">&#34;ttXlaUpdateDesc_t&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span> for information about that data structure.</p>
</div>
<!-- class="sect4" -->
<a id="i110239"></a>
<div id="TTCLS303" class="sect4">
<h5 class="sect4">get<a id="sthref433"></a><a id="sthref434"></a><a id="sthref435"></a>BookmarkIndex()</h5>
<pre dir="ltr">void getBookmarkIndex()
</pre>
<p>This method gets the current bookmark location, storing it into a class private data member where it is available for use by subsequent <code dir="ltr">setBookmarkIndex()</code> calls.</p>
</div>
<!-- class="sect4" -->
<a id="i110246"></a>
<div id="TTCLS304" class="sect4">
<h5 class="sect4">set<a id="sthref436"></a><a id="sthref437"></a><a id="sthref438"></a>BookmarkIndex()</h5>
<pre dir="ltr">void setBookmarkIndex()
</pre>
<p>This method returns to the saved transaction log index, restoring the bookmark to the address previously acquired by a <code dir="ltr">getBookmarkIndex()</code> call. Use this method to replay a batch of XLA records.</p>
<p>Note that <code dir="ltr">ackUpdates()</code> invalidates the stored transaction log placeholder. After <code dir="ltr">ackUpdates()</code>, a call to <code dir="ltr">setBookmarkIndex()</code> returns an error because it is no longer possible to go back to the previously acquired bookmark location.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i99749"></a>
<div id="TTCLS307" class="sect2">
<h3 class="sect2"><a id="sthref439"></a><a id="sthref440"></a>TTXlaRowViewer</h3>
<p>Use <code dir="ltr">TTXlaRowViewer</code>, which represents a row image from change notification records, to examine XLA change notification record structures and old and new column values.</p>
<div id="TTCLS315" class="sect3"><a id="sthref441"></a>
<h4 class="sect3">Usage</h4>
<p>Methods of this class are used to examine column values from row images contained in change notification records. Also see related information about the <code dir="ltr">TTXlaTable</code> class (<a href="#CHDBCDFD">&#34;TTXlaTable&#34;</a>).</p>
<p>Before a row can be examined, the <code dir="ltr">TTXlaRowViewer</code> object must be associated with a row using the <code dir="ltr">setTuple()</code> method, which is invoked inside the <code dir="ltr">TTXlaTableHandler::HandleInsert()</code>, <code dir="ltr">HandleUpdate()</code>, or <code dir="ltr">HandleDelete()</code> method, or by a user-written overloaded method. Columns can be checked for null values using the <code dir="ltr">isNull()</code> method. Non-null column values can be examined using the appropriate overloaded <code dir="ltr">Get()</code> method.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS308" class="sect3"><a id="sthref442"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS309" class="sect3"><a id="sthref443"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods of TTXlaRowViewer." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t43">Method</th>
<th class="cellalignment2190" id="r1c2-t43">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t43" headers="r1c1-t43"><code dir="ltr"><a href="#CHDJGAFA">columnPrec()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t43 r1c2-t43">Returns the precision of the specified column in the row image.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t43" headers="r1c1-t43"><code dir="ltr"><a href="#CHDHJJIF">columnScale()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t43 r1c2-t43">Returns the scale of the specified column in the row image.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t43" headers="r1c1-t43"><code dir="ltr"><a href="#i99778">Get()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t43 r1c2-t43">Fetches the value of the specified column in the row image.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t43" headers="r1c1-t43"><code dir="ltr"><a href="#CHDHFBAH">getColumn()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t43 r1c2-t43">Returns the specified column from the row image.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t43" headers="r1c1-t43"><code dir="ltr"><a href="#CHDIHFEG">isColumnTTTimestamp()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t43 r1c2-t43">Indicates whether the specified column in the row image is a <code dir="ltr">TT_TIMESTAMP</code> column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t43" headers="r1c1-t43"><code dir="ltr"><a href="#i99773">isNull()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t43 r1c2-t43">Indicates whether the specified column in the row image has the value <code dir="ltr">NULL</code>.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t43" headers="r1c1-t43"><code dir="ltr"><a href="#CHDHFGHC">numUpdatedCols()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t43 r1c2-t43">Returns the number of columns in the row image that have been updated.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t43" headers="r1c1-t43"><code dir="ltr"><a href="#i99768">setTuple()</a></code></td>
<td class="cellalignment2191" headers="r9c1-t43 r1c2-t43">Associates the <code dir="ltr">TTXlaRowViewer</code> object with the specified row image.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t43" headers="r1c1-t43"><code dir="ltr"><a href="#CHDGEEFH">updatedCol()</a></code></td>
<td class="cellalignment2191" headers="r10c1-t43 r1c2-t43">Returns the column number in the row image of a column that has been updated, typically during iteration through all updated columns.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDJGAFA"></a>
<div id="TTCLS447" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">column<a id="sthref444"></a>Prec()</h5>
<pre dir="ltr">int columnPrec(int <span class="italic">cno</span>)
</pre>
<p>Returns the precision of data in column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> of the row image, referring to the maximum number of digits that are used by the data type.</p>
</div>
<!-- class="sect4" -->
<a id="CHDHJJIF"></a>
<div id="TTCLS448" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">column<a id="sthref445"></a>Scale()</h5>
<pre dir="ltr">int columnScale(int <span class="italic">cno</span>)
</pre>
<p>Returns the scale of data in column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> of the row image, referring to the maximum number of digits to the right of the decimal point.</p>
</div>
<!-- class="sect4" -->
<a id="i99778"></a>
<div id="TTCLS313" class="sect4">
<h5 class="sect4">G<a id="sthref446"></a>et()</h5>
<pre dir="ltr">void Get(int <span class="italic">cno</span>, TYPE* <span class="italic">valueP</span>)
void Get(int <span class="italic">cno</span>, TYPE* <span class="italic">valueP</span>, int* <span class="italic">byteLenP</span>)
</pre>
<p>Fetches the value of column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> in the row image. These methods are very similar to the <code dir="ltr"><a href="#i95294">TTCmd</a></code><code dir="ltr">::getColumn()</code> methods.</p>
<p><a href="#g135380">Table 3-5</a> that follows shows the supported SQL data types and the appropriate versions of <code dir="ltr">Get()</code> to use for each data type. Design the application according to the types of data that are stored. For example, data of type <code dir="ltr">NUMBER(9,0)</code> can be accessed by the <code dir="ltr">Get(int, int*)</code> method without loss of information.</p>
<div id="TTCLS314" class="tblhruleformal">
<p class="titleintable"><a id="sthref447"></a><a id="g135380"></a>Table 3-5 Get() variants for supported table column types</p>
<table class="cellalignment2189" title="Get() variants for supported table column types" summary="This table shows the supported SQL data types and the appropriate versions of Get to use for each parameter type." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t44">XLA data type</th>
<th class="cellalignment2190" id="r1c2-t44">Database data type</th>
<th class="cellalignment2190" id="r1c3-t44">Get() variant</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_CHAR_TT</code></p>
</td>
<td class="cellalignment2191" headers="r2c1-t44 r1c2-t44">
<p><code dir="ltr">TT_CHAR</code></p>
</td>
<td class="cellalignment2191" headers="r2c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_NCHAR_TT</code></p>
</td>
<td class="cellalignment2191" headers="r3c1-t44 r1c2-t44">
<p><code dir="ltr">TT_NCHAR</code></p>
</td>
<td class="cellalignment2191" headers="r3c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, SQLWCHAR** <span class="italic">wcPP</span>, <span class="italic">byteLenP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_VARCHAR_TT</code></p>
</td>
<td class="cellalignment2191" headers="r4c1-t44 r1c2-t44">
<p><code dir="ltr">TT_VARCHAR</code></p>
</td>
<td class="cellalignment2191" headers="r4c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_NVARCHAR_TT</code></p>
</td>
<td class="cellalignment2191" headers="r5c1-t44 r1c2-t44">
<p><code dir="ltr">TT_NVARCHAR</code></p>
</td>
<td class="cellalignment2191" headers="r5c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, SQLWCHAR** <span class="italic">wcPP</span>, <span class="italic">byteLenP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_TINYINT</code></p>
</td>
<td class="cellalignment2191" headers="r6c1-t44 r1c2-t44">
<p><code dir="ltr">TT_TINYINT</code></p>
</td>
<td class="cellalignment2191" headers="r6c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, SQLTINYINT* <span class="italic">iP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_SMALLINT</code></p>
</td>
<td class="cellalignment2191" headers="r7c1-t44 r1c2-t44">
<p><code dir="ltr">TT_SMALLINT</code></p>
</td>
<td class="cellalignment2191" headers="r7c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, short* <span class="italic">iP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_INTEGER</code></p>
</td>
<td class="cellalignment2191" headers="r8c1-t44 r1c2-t44">
<p><code dir="ltr">TT_INTEGER</code></p>
</td>
<td class="cellalignment2191" headers="r8c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, int* <span class="italic">iP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_BIGINT</code></p>
</td>
<td class="cellalignment2191" headers="r9c1-t44 r1c2-t44">
<p><code dir="ltr">TT_BIGINT</code></p>
</td>
<td class="cellalignment2191" headers="r9c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, SQLBIGINT* <span class="italic">biP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_BINARY_FLOAT</code></p>
</td>
<td class="cellalignment2191" headers="r10c1-t44 r1c2-t44">
<p><code dir="ltr">BINARY_FLOAT</code></p>
</td>
<td class="cellalignment2191" headers="r10c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, float* <span class="italic">fP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r11c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment2191" headers="r11c1-t44 r1c2-t44">
<p><code dir="ltr">BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment2191" headers="r11c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, double* <span class="italic">dP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r12c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_DECIMAL_TT</code></p>
</td>
<td class="cellalignment2191" headers="r12c1-t44 r1c2-t44">
<p><code dir="ltr">TT_DECIMAL</code></p>
</td>
<td class="cellalignment2191" headers="r12c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r13c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_TIME</code></p>
</td>
<td class="cellalignment2191" headers="r13c1-t44 r1c2-t44">
<p><code dir="ltr">TT_TIME</code></p>
</td>
<td class="cellalignment2191" headers="r13c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, TIME_STRUCT* <span class="italic">tP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r14c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_DATE_TT</code></p>
</td>
<td class="cellalignment2191" headers="r14c1-t44 r1c2-t44">
<p><code dir="ltr">TT_DATE</code></p>
</td>
<td class="cellalignment2191" headers="r14c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, DATE_STRUCT* <span class="italic">dP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r15c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_TIMESTAMP_TT</code></p>
</td>
<td class="cellalignment2191" headers="r15c1-t44 r1c2-t44">
<p><code dir="ltr">TT_TIMESTAMP</code></p>
</td>
<td class="cellalignment2191" headers="r15c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, TIMESTAMP_STRUCT* <span class="italic">tsP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r16c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_BINARY</code></p>
</td>
<td class="cellalignment2191" headers="r16c1-t44 r1c2-t44">
<p><code dir="ltr">BINARY</code></p>
</td>
<td class="cellalignment2191" headers="r16c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, const void** <span class="italic">binPP</span>,
    <span class="italic">byteLenP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r17c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_VARBINARY</code></p>
</td>
<td class="cellalignment2191" headers="r17c1-t44 r1c2-t44">
<p><code dir="ltr">VARBINARY</code></p>
</td>
<td class="cellalignment2191" headers="r17c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, const void** <span class="italic">binPP</span>,
    <span class="italic">byteLenP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r18c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_NUMBER</code></p>
</td>
<td class="cellalignment2191" headers="r18c1-t44 r1c2-t44">
<p><code dir="ltr">NUMBER</code></p>
</td>
<td class="cellalignment2191" headers="r18c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, double* <span class="italic">dP</span>)
</pre>
<pre dir="ltr">Get(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre>
<pre dir="ltr">Get(<span class="italic">cno</span>, short* <span class="italic">iP</span>)
</pre>
<pre dir="ltr">Get(<span class="italic">cno</span>, int* <span class="italic">iP</span>)
</pre>
<pre dir="ltr">Get(<span class="italic">cno</span>, SQLBIGINT* <span class="italic">biP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r19c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_DATE</code></p>
</td>
<td class="cellalignment2191" headers="r19c1-t44 r1c2-t44">
<p><code dir="ltr">DATE</code></p>
</td>
<td class="cellalignment2191" headers="r19c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, TIMESTAMP_STRUCT* <span class="italic">tsP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r20c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_TIMESTAMP</code></p>
</td>
<td class="cellalignment2191" headers="r20c1-t44 r1c2-t44">
<p><code dir="ltr">TIMESTAMP</code></p>
</td>
<td class="cellalignment2191" headers="r20c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, TIMESTAMP_STRUCT* <span class="italic">tsP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r21c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_CHAR</code></p>
</td>
<td class="cellalignment2191" headers="r21c1-t44 r1c2-t44">
<p><code dir="ltr">CHAR</code></p>
</td>
<td class="cellalignment2191" headers="r21c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r22c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_NCHAR</code></p>
</td>
<td class="cellalignment2191" headers="r22c1-t44 r1c2-t44">
<p><code dir="ltr">NCHAR</code></p>
</td>
<td class="cellalignment2191" headers="r22c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, SQLWCHAR** <span class="italic">wcPP</span>, <span class="italic">byteLenP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r23c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_VARCHAR</code></p>
</td>
<td class="cellalignment2191" headers="r23c1-t44 r1c2-t44">
<p><code dir="ltr">VARCHAR2</code></p>
</td>
<td class="cellalignment2191" headers="r23c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r24c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_NVARCHAR</code></p>
</td>
<td class="cellalignment2191" headers="r24c1-t44 r1c2-t44">
<p><code dir="ltr">NVARCHAR2</code></p>
</td>
<td class="cellalignment2191" headers="r24c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, SQLWCHAR** <span class="italic">wcPP</span>, <span class="italic">byteLenP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r25c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_FLOAT</code></p>
</td>
<td class="cellalignment2191" headers="r25c1-t44 r1c2-t44">
<p><code dir="ltr">FLOAT</code></p>
</td>
<td class="cellalignment2191" headers="r25c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, double* <span class="italic">dP</span>)
</pre>
<pre dir="ltr">Get(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r26c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_BLOB</code></p>
</td>
<td class="cellalignment2191" headers="r26c1-t44 r1c2-t44">
<p><code dir="ltr">BLOB</code></p>
</td>
<td class="cellalignment2191" headers="r26c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, const void** <span class="italic">binPP</span>,
    <span class="italic">byteLenP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r27c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_CLOB</code></p>
</td>
<td class="cellalignment2191" headers="r27c1-t44 r1c2-t44">
<p><code dir="ltr">CLOB</code></p>
</td>
<td class="cellalignment2191" headers="r27c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, char** <span class="italic">cPP</span>)
</pre></td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r28c1-t44" headers="r1c1-t44">
<p><code dir="ltr">TTXLA_NCLOB</code></p>
</td>
<td class="cellalignment2191" headers="r28c1-t44 r1c2-t44">
<p><code dir="ltr">NCLOB</code></p>
</td>
<td class="cellalignment2191" headers="r28c1-t44 r1c3-t44">
<pre dir="ltr">Get(<span class="italic">cno</span>, SQLWCHAR** <span class="italic">wcPP</span>, <span class="italic">byteLenP</span>)
</pre></td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect4" -->
<a id="CHDHFBAH"></a>
<div id="TTCLS446" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref448"></a>Column()</h5>
<pre dir="ltr">const TTXlaColumn* getColumn(u_int <span class="italic">cno</span>) const
</pre>
<p>Returns a <code dir="ltr"><a href="#CHDIGJJB">TTXlaColumn</a></code> object with metadata for column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> in the row image.</p>
</div>
<!-- class="sect4" -->
<a id="CHDIHFEG"></a>
<div id="TTCLS449" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">isColumn<a id="sthref449"></a>TTTimestamp()</h5>
<pre dir="ltr">bool isColumnTTTimestamp(int <span class="italic">cno</span>)
</pre>
<p>Returns <code dir="ltr">TRUE</code> if column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> in the row image is a <code dir="ltr">TT_TIMESTAMP</code> column, or <code dir="ltr">FALSE</code> otherwise.</p>
</div>
<!-- class="sect4" -->
<a id="i99773"></a>
<div id="TTCLS312" class="sect4">
<h5 class="sect4">is<a id="sthref450"></a>Null()</h5>
<pre dir="ltr">bool isNull(int <span class="italic">cno</span>)
</pre>
<p>Indicates whether the column number <code dir="ltr"><span class="codeinlineitalic">cno</span></code> in the row image has the value <code dir="ltr">NULL</code>, returning <code dir="ltr">TRUE</code> if so or <code dir="ltr">FALSE</code> if not.</p>
</div>
<!-- class="sect4" -->
<a id="CHDHFGHC"></a>
<div id="TTCLS450" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">num<a id="sthref451"></a>UpdatedCols()</h5>
<pre dir="ltr">SQLUSMALLINT numUpdatedCols()
</pre>
<p>Returns the number of columns that have been updated in the row image.</p>
</div>
<!-- class="sect4" -->
<a id="i99768"></a>
<div id="TTCLS311" class="sect4">
<h5 class="sect4">set<a id="sthref452"></a>Tuple()</h5>
<pre dir="ltr">void setTuple(ttXlaUpdateDesc_t* <span class="italic">updateDescP</span>, int <span class="italic">whichTuple</span>)
</pre>
<p>Before a row can be examined, this method must be called to associate the <code dir="ltr">TTXlaRowViewer</code> object with a particular row image. It is invoked inside the <code dir="ltr"><a href="#i96093">TTXlaTableHandler</a>::HandleInsert()</code>, <code dir="ltr">HandleUpdate()</code>, or <code dir="ltr">HandleDelete()</code> method, or by a user-written overloaded method. You would typically call it when overloading the <code dir="ltr">TTXlaTableHandler::HandleChange()</code> method. The Quick Start <code dir="ltr">xlasubscriber1</code> demo provides an example of its usage. (See <a href="compiling.htm#BCGGJCJF">&#34;About the TimesTen TTClasses demos&#34;</a>.)</p>
<p>The <code dir="ltr">ttXlaUpdateDesc_t</code> structures that are returned by <code dir="ltr"><a href="#i111047">TTXlaPersistConnection</a></code><code dir="ltr">::fetchUpdatesWait()</code> contain either zero, one, or two rows. Note the following:</p>
<ul>
<li>
<p>Structures that define a row that was inserted into a table contain the row image of the inserted row.</p>
</li>
<li>
<p>Structures that define a row that was deleted from a table contain the row image of the deleted row.</p>
</li>
<li>
<p>Structures that define a row that was updated in a table contain the images of the row before and after the update.</p>
</li>
<li>
<p>Structures that define other changes to the table or the database contain no row images. For example, structures reporting that an index was dropped contain no row images.</p>
</li>
</ul>
<p>The <code dir="ltr">setTuple()</code> method takes two arguments:</p>
<ul>
<li>
<p>A pointer to a particular <code dir="ltr">ttXlaUpdateDesc_t</code> structure defining a database change</p>
</li>
<li>
<p>An integer specifying which type of row image in the update structure should be examined</p>
<p>The following are valid values:</p>
<ul>
<li>
<p><code dir="ltr">INSERTED_TUP</code>: Examine the inserted row.</p>
</li>
<li>
<p><code dir="ltr">DELETED_TUP</code>: Examine the deleted row.</p>
</li>
<li>
<p><code dir="ltr">UPDATE_OLD_TUP</code>: Examine the row before it was updated.</p>
</li>
<li>
<p><code dir="ltr">UPDATE_NEW_TUP</code>: Examine the row after it was updated.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="CHDGEEFH"></a>
<div id="TTCLS451" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">updated<a id="sthref453"></a>Col()</h5>
<pre dir="ltr">SQLUSMALLINT updatedCol(u_int <span class="italic">cno</span>)
</pre>
<p>Returns the column number of a column that has been updated. For the input parameter you can iterate from 1 through <code dir="ltr"><span class="codeinlineitalic">n</span></code>, where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is the number returned by <code dir="ltr">numUpdatedCols()</code>. <a href="#CHDDFHDC">Example 3-9</a> shows a snippet from the TimesTen Quick Start demo <code dir="ltr">xlasubscriber1</code>, where <code dir="ltr">updatedCol()</code> is used with <code dir="ltr">numUpdatedCols()</code> to retrieve each column that has been updated. (See <a href="compiling.htm#BCGGJCJF">&#34;About the TimesTen TTClasses demos&#34;</a>.)</p>
<div id="TTCLS452" class="example">
<p class="titleinexample"><a id="CHDDFHDC"></a>Example 3-9 Using TTXlaRowViewer::numUpdatedCols() and updatedCol()</p>
<pre dir="ltr">void
SampleHandler::HandleUpdate(ttXlaUpdateDesc_t* )
{
  cerr &lt;&lt; row2.numUpdatedCols() &lt;&lt; &#34; column(s) updated: &#34;;
  for ( int i = 1; i &lt;= row2.numUpdatedCols(); i++ )
  {
    cerr &lt;&lt; row2.updatedCol(i) &lt;&lt; &#34;(&#34;
         &lt;&lt; row2.getColumn(row2.updatedCol(i)-1)-&gt;getColName() &lt;&lt; &#34;) &#34;;
  }
  cerr &lt;&lt; endl;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i96093"></a>
<div id="TTCLS316" class="sect2">
<h3 class="sect2"><a id="sthref454"></a><a id="sthref455"></a>TTXlaTableHandler</h3>
<p>The <code dir="ltr">TTXlaTableHandler</code> class provides methods that enable and disable change tracking for a table. Methods are also provided to handle update notification records from XLA. It is intended as a base class from which application developers write customized classes to process changes to a particular table.</p>
<p>The constructor associates the <code dir="ltr">TTXlaTableHandler</code> object with a particular table and initializes the <code dir="ltr">TTXlaTable</code> data member contained within the <code dir="ltr">TTXlaTableHandler</code> object:</p>
<pre dir="ltr">TTXlaTableHandler(TTXlaPersistConnection&amp; <span class="italic">conn</span>, const char* <span class="italic">ownerP</span>, 
                  const char* <span class="italic">nameP</span>)
</pre>
<p>Also see <a href="#CHDBCDFD">&#34;TTXlaTable&#34;</a>.</p>
<div id="TTCLS327" class="sect3"><a id="sthref456"></a>
<h4 class="sect3">Usage</h4>
<p>Application developers can derive one or more classes from <code dir="ltr">TTXlaTableHandler</code> and can put most of the application logic in the <code dir="ltr">HandleInsert()</code>, <code dir="ltr">HandleDelete()</code>, and <code dir="ltr">HandleUpdate()</code> methods of that class.</p>
<p>One possible design is to derive multiple classes from <code dir="ltr">TTXlaTableHandler</code>, one for each table. Business logic to handle changes to customer data might be implemented in a <code dir="ltr">CustomerTableHandler</code> class, for example, while business logic to handle changes to order data might be implemented in an <code dir="ltr">OrderTableHandler</code> class.</p>
<p>Another possible design is to derive one or more generic classes from <code dir="ltr">TTXlaTableHandler</code> to handle various scenarios. For example, a generic class derived from <code dir="ltr">TTXlaTableHandler</code> could be used to publish changes using a publish/subscribe system.</p>
<p>See the <code dir="ltr">xlasubscriber1</code> and <code dir="ltr">xlasubscriber2</code> demos in the TimesTen Quick Start for examples of classes that extend <code dir="ltr">TTXlaTableHandler</code>. (Refer to <a href="compiling.htm#BCGGJCJF">&#34;About the TimesTen TTClasses demos&#34;</a>.)</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS317" class="sect3"><a id="sthref457"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS488" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref458"></a>
<h4 class="sect3">Protected members</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Member descriptions" summary="This table contains descriptions of the protected members of TTXlaTableHandler." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t45">Member</th>
<th class="cellalignment2190" id="r1c2-t45">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t45" headers="r1c1-t45"><code dir="ltr">TTXlaTable tbl</code></td>
<td class="cellalignment2191" headers="r2c1-t45 r1c2-t45">This is for the metadata associated with the table being handled.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t45" headers="r1c1-t45"><code dir="ltr">TTXlaRowViewer row</code></td>
<td class="cellalignment2191" headers="r3c1-t45 r1c2-t45">This is used to view the row being inserted or deleted, or the old image of the row being updated, in user-written <code dir="ltr">HandleInsert()</code>, <code dir="ltr">HandleDelete()</code>, and <code dir="ltr">HandleUpdate()</code> methods.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t45" headers="r1c1-t45"><code dir="ltr">TTXlaRowViewer row2</code></td>
<td class="cellalignment2191" headers="r4c1-t45 r1c2-t45">This is used to view the new image of the row being updated in user-written <code dir="ltr">HandleUpdate()</code> methods.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect3" -->
<div id="TTCLS319" class="sect3"><a id="sthref459"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods of TTXlaTableHandler." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t46">Method</th>
<th class="cellalignment2190" id="r1c2-t46">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t46" headers="r1c1-t46"><code dir="ltr"><a href="#i103623">DisableTracking()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t46 r1c2-t46">Disables XLA update tracking for the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t46" headers="r1c1-t46"><code dir="ltr"><a href="#i103689">EnableTracking()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t46 r1c2-t46">Enables XLA update tracking for the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t46" headers="r1c1-t46"><code dir="ltr"><a href="#i103658">generateSQL()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t46 r1c2-t46">Returns the SQL associated with a given XLA record.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t46" headers="r1c1-t46"><code dir="ltr"><a href="#i103631">HandleChange()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t46 r1c2-t46">Dispatches a record from <code dir="ltr">ttXlaUpdateDesc_t</code> to the appropriate handling routine for processing.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t46" headers="r1c1-t46"><code dir="ltr"><a href="#i103639">HandleDelete()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t46 r1c2-t46">This is invoked when the <code dir="ltr">HandleChange()</code> method is called to process a delete operation.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t46" headers="r1c1-t46"><code dir="ltr"><a href="#i105850">HandleInsert()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t46 r1c2-t46">This is invoked when the <code dir="ltr">HandleChange()</code> method is called to process an insert operation.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t46" headers="r1c1-t46"><code dir="ltr"><a href="#i103654">HandleUpdate()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t46 r1c2-t46">This is invoked when the <code dir="ltr">HandleChange()</code> method is called to process an update operation.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="i103623"></a>
<div id="TTCLS321" class="sect4">
<h5 class="sect4">Disable<a id="sthref460"></a>Tracking()</h5>
<pre dir="ltr">virtual void DisableTracking()
</pre>
<p>Disables XLA update tracking for the table. After this method is called, the XLA bookmark no longer captures information about changes to the table.</p>
</div>
<!-- class="sect4" -->
<a id="i103689"></a>
<div id="TTCLS320" class="sect4">
<h5 class="sect4">Enable<a id="sthref461"></a>Tracking()</h5>
<pre dir="ltr">virtual void EnableTracking()
</pre>
<p>Enables XLA update tracking for the table. Until this method is called, the XLA bookmark does not capture information about changes to the table.</p>
</div>
<!-- class="sect4" -->
<a id="i103658"></a>
<div id="TTCLS326" class="sect4">
<h5 class="sect4">generate<a id="sthref462"></a>SQL()</h5>
<pre dir="ltr">void generateSQL (ttXlaUpdateDesc_t* <span class="italic">updateDescP</span>, char* <span class="italic">buffer</span>, 
                  SQLINTEGER <span class="italic">maxByteLen</span>, SQLINTEGER* <span class="italic">actualByteLenP</span>)
</pre>
<p>This method prints the SQL associated with a given XLA record. The SQL string is returned through the <code dir="ltr"><span class="codeinlineitalic">buffer</span></code> parameter. Allocate space for the buffer and specify its maximum length, <code dir="ltr"><span class="codeinlineitalic">maxByteLen</span></code>. The <code dir="ltr"><span class="codeinlineitalic">actualByteLenP</span></code> parameter returns information about the actual length of the SQL string returned.</p>
<p>If <code dir="ltr"><span class="codeinlineitalic">maxByteLen</span></code> is less than the length of the generated SQL string, a <code dir="ltr">TTStatus</code> error is thrown and the contents of <code dir="ltr"><span class="codeinlineitalic">buffer</span></code> and <code dir="ltr"><span class="codeinlineitalic">actualByteLenP</span></code> are not modified.</p>
</div>
<!-- class="sect4" -->
<a id="i103631"></a>
<div id="TTCLS322" class="sect4">
<h5 class="sect4">Handle<a id="sthref463"></a>Change()</h5>
<pre dir="ltr">virtual void HandleChange(ttXlaUpdateDesc_t* <span class="italic">updateDescP</span>)
virtual void HandleChange(ttXlaUpdateDesc_t* <span class="italic">updateDescP</span>, void* <span class="italic">pData</span>)
</pre>
<p>Dispatches a <code dir="ltr">ttXlaUpdateDesc_t</code> object to the appropriate handling routine for processing. The update description is analyzed to determine if it is for a delete, insert or update operation. The appropriate handing method is then called: <code dir="ltr">HandleDelete()</code>, <code dir="ltr">HandleInsert()</code>, or <code dir="ltr">HandleUpdate()</code>.</p>
<p>Classes that inherit from <code dir="ltr">TTXlaTableHandler</code> can use the optional <code dir="ltr"><span class="codeinlineitalic">pData</span></code> parameter when they overload the <code dir="ltr">TTXlaTableHandler::HandleChange()</code> method. This optional parameter is useful for determining whether the batch of XLA records that was just processed ends on a transaction boundary. Knowing this helps an application decide the appropriate time to invoke <code dir="ltr">TTConnection::ackUpdates()</code>. See <a href="usage.htm#CDEBFJJA">&#34;Acknowledging XLA updates at transaction boundaries&#34;</a> for an example that uses the <code dir="ltr"><span class="codeinlineitalic">pData</span></code> parameter.</p>
<p>Also see <a href="#i99821">&#34;HandleChange()&#34;</a> for <code dir="ltr">TTXlaTableList</code> objects.</p>
</div>
<!-- class="sect4" -->
<a id="i103639"></a>
<div id="TTCLS323" class="sect4">
<h5 class="sect4">Handle<a id="sthref464"></a>Delete()</h5>
<pre dir="ltr">virtual void HandleDelete(ttXlaUpdateDesc_t* <span class="italic">updateDescP</span>) = 0
</pre>
<p>This method is invoked whenever the <code dir="ltr">HandleChange()</code> method is called to process a delete operation.</p>
<p><code dir="ltr">HandleDelete()</code> is not implemented in the <code dir="ltr">TTXlaTableHandler</code> base class. It must be implemented by any classes derived from it, with appropriate logic to handle deleted rows.</p>
<p>The row that was deleted from the table is available through the protected member <code dir="ltr">row</code> of type <code dir="ltr"><a href="#i99749">TTXlaRowViewer</a></code>.</p>
</div>
<!-- class="sect4" -->
<a id="i105850"></a>
<div id="TTCLS324" class="sect4">
<h5 class="sect4">Handle<a id="sthref465"></a>Insert()</h5>
<pre dir="ltr">virtual void HandleInsert(ttXlaUpdateDesc_t* <span class="italic">updateDescP</span>) = 0
</pre>
<p>This method is invoked whenever the <code dir="ltr">HandleChange()</code> method is called to process an insert operation.</p>
<p><code dir="ltr">HandleInsert()</code> is not implemented in the <code dir="ltr">TTXlaTableHandler</code> base class. It must be implemented by any classes derived from it, with appropriate logic to handle inserted rows.</p>
<p>The row that was inserted into the table is available through the protected member <code dir="ltr">row</code> of type <code dir="ltr"><a href="#i99749">TTXlaRowViewer</a></code>.</p>
</div>
<!-- class="sect4" -->
<a id="i103654"></a>
<div id="TTCLS325" class="sect4">
<h5 class="sect4">Handle<a id="sthref466"></a>Update()</h5>
<pre dir="ltr">virtual void HandleUpdate(ttXlaUpdateDesc_t* <span class="italic">updateDescP</span>) = 0
</pre>
<p>This method is invoked whenever the <code dir="ltr">HandleChange()</code> method is called to process an update operation.</p>
<p><code dir="ltr">HandleUpdate()</code> is not implemented in the <code dir="ltr">TTXlaTableHandler</code> base class. It must be implemented by any classes derived from it, with appropriate logic to handle updated rows.</p>
<p>The previous version of the row that was updated from the table is available through the protected member <code dir="ltr">row</code> of type <code dir="ltr"><a href="#i99749">TTXlaRowViewer</a></code>. The new version of the row is available through the protected member <code dir="ltr">row2</code>, also of type <code dir="ltr">TTXlaRowViewer</code>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i96097"></a>
<div id="TTCLS328" class="sect2">
<h3 class="sect2"><a id="sthref467"></a><a id="sthref468"></a>TTXlaTableList</h3>
<p>The <code dir="ltr">TTXlaTableList</code> class provides a list of <code dir="ltr"><a href="#i96093">TTXlaTableHandler</a></code> objects and is used to dispatch update notification events to the appropriate <code dir="ltr">TTXlaTableHandler</code> object. When an update notification is received from XLA, the appropriate <code dir="ltr">Handle</code><code dir="ltr"><span class="codeinlineitalic">Xxx</span></code><code dir="ltr">()</code> method of the appropriate <code dir="ltr">TTXlaTableHandler</code> object is called to process the record.</p>
<p>For example, if an object of type <code dir="ltr">CustomerTableHandler</code> is handling changes to table <code dir="ltr">CUSTOMER</code>, and an object of type <code dir="ltr">OrderTableHandler</code> is handling changes to table <code dir="ltr">ORDERS</code>, the application should have both of these objects in a <code dir="ltr">TTXlaTableList</code> object. As XLA update notification records are fetched from XLA, they can be dispatched to the correct handler by a call to <code dir="ltr">TTXlaTableList::HandleChange()</code>.</p>
<p>The constructor has two forms:</p>
<pre dir="ltr">TTXlaTableList(TTXlaPersistConnection* <span class="italic">cP</span>, unsigned int <span class="italic">num_tbls_to_monitor</span>)
</pre>
<p>Where <code dir="ltr"><span class="codeinlineitalic">num_tbls_to_monitor</span></code> is the number of database objects to monitor.</p>
<p>Or:</p>
<pre dir="ltr">TTXlaTableList(TTXlaPersistConnection* <span class="italic">cP</span>);
</pre>
<p>Where <code dir="ltr"><span class="codeinlineitalic">cP</span></code> references the database connection to be used for XLA operations. This form of the constructor can monitor up to 150 database objects.</p>
<div id="TTCLS334" class="sect3"><a id="sthref469"></a>
<h4 class="sect3">Usage</h4>
<p>By registering <code dir="ltr">TTXlaTableHandler</code> objects in a <code dir="ltr">TTXlaTableList</code> object, the process of fetching update notification records from XLA and dispatching them to the appropriate methods for processing can be accomplished using a loop.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS329" class="sect3"><a id="sthref470"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS330" class="sect3"><a id="sthref471"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods for TTXlaTableList." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t47">Method</th>
<th class="cellalignment2190" id="r1c2-t47">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t47" headers="r1c1-t47"><code dir="ltr"><a href="#i99804">add()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t47 r1c2-t47">Adds a <code dir="ltr">TTXlaTableHandler</code> object to the list.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t47" headers="r1c1-t47"><code dir="ltr"><a href="#i99809">del()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t47 r1c2-t47">Deletes a <code dir="ltr">TTXlaTableHandler</code> object from the list.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t47" headers="r1c1-t47"><code dir="ltr"><a href="#i99821">HandleChange()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t47 r1c2-t47">Processes a record obtained from a <code dir="ltr">ttXlaUpdateDesc_t</code> structure.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="i99804"></a>
<div id="TTCLS331" class="sect4">
<h5 class="sect4">a<a id="sthref472"></a>dd()</h5>
<pre dir="ltr">void add(TTXlaTableHandler* <span class="italic">tblh</span>)
</pre>
<p>Adds a <code dir="ltr">TTXlaTableHandler</code> object to the list.</p>
</div>
<!-- class="sect4" -->
<a id="i99809"></a>
<div id="TTCLS332" class="sect4">
<h5 class="sect4">d<a id="sthref473"></a>el()</h5>
<pre dir="ltr">void del(TTXlaTableHandler* <span class="italic">tblh</span>)
</pre>
<p>Deletes a <code dir="ltr">TTXlaTableHandler</code> object from the list.</p>
</div>
<!-- class="sect4" -->
<a id="i99821"></a>
<div id="TTCLS333" class="sect4">
<h5 class="sect4">Handle<a id="sthref474"></a>Change()</h5>
<pre dir="ltr">void HandleChange(ttXlaUpdateDesc_t* <span class="italic">updateDescP</span>)
void HandleChange(ttXlaUpdateDesc_t* <span class="italic">updateDescP</span>, void* <span class="italic">pData</span>)
</pre>
<p>When a <code dir="ltr">ttXlaUpdateDesc_t</code> object is received from XLA, it can be processed by calling this method, which determines which table the record references and calls the <code dir="ltr">HandleChange()</code> method of the appropriate <code dir="ltr"><a href="#i96093">TTXlaTableHandler</a></code> object.</p>
<p>See <a href="#i103631">&#34;HandleChange()&#34;</a> for <code dir="ltr">TTXlaTableHandler</code> objects, including a discussion of the <code dir="ltr"><span class="codeinlineitalic">pData</span></code> parameter.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBCDFD"></a>
<div id="TTCLS453" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">T<a id="sthref475"></a><a id="sthref476"></a>TXlaTable</h3>
<p>The <code dir="ltr">TTXlaTable</code> class encapsulates the metadata for a table being monitored for changes. It acts as a metadata interface for the TimesTen <code dir="ltr">ttXlaTblDesc_t</code> C data structure. (See <a class="olink TTCDV467" href="../TTCDV/xla_ref.htm#TTCDV467">&#34;ttXlaTblDesc_t&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span>.)</p>
<div id="TTCLS454" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref477"></a>
<h4 class="sect3">Usage</h4>
<p>When a user application creates a class that extends <code dir="ltr"><a href="#i96093">TTXlaTableHandler</a></code>, it typically calls <code dir="ltr">TTXlaTable::getColNumber()</code> to map a column name to its XLA column number. You can then use the column number as input to the <code dir="ltr">TTXlaRowViewer::<a href="#i99778">Get()</a></code> method. This is shown in the <code dir="ltr">xlasubscriber2</code> demo in the TimesTen Quick Start. (Refer to <a href="compiling.htm#BCGGJCJF">&#34;About the TimesTen TTClasses demos&#34;</a>.)</p>
<p>This class also provides useful metadata functions to return the name, owner, and number of columns in the table.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS455" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref478"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS456" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref479"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods for TTXlaTable." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t48">Method</th>
<th class="cellalignment2190" id="r1c2-t48">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t48" headers="r1c1-t48"><code dir="ltr"><a href="#CHDBJBFA">getColNumber()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t48 r1c2-t48">Returns the column number of the specified column in the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t48" headers="r1c1-t48"><code dir="ltr"><a href="#CHDEAFDE">getNCols()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t48 r1c2-t48">Returns the number of columns in the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t48" headers="r1c1-t48"><code dir="ltr"><a href="#CHDJDBEC">getOwnerName()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t48 r1c2-t48">Returns the name of owner of the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t48" headers="r1c1-t48"><code dir="ltr"><a href="#CHDGDFGE">getTableName()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t48 r1c2-t48">Returns the name of the table.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDBJBFA"></a>
<div id="TTCLS457" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref480"></a>ColNumber()</h5>
<pre dir="ltr">int getColNumber(const char* <span class="italic">colNameP</span>) const
</pre>
<p>For a specified column name in the table, this method returns its column number, or -1 if there is no column by that name.</p>
</div>
<!-- class="sect4" -->
<a id="CHDEAFDE"></a>
<div id="TTCLS458" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">ge<a id="sthref481"></a>tNCols()</h5>
<pre dir="ltr">int getNCols() const
</pre>
<p>Returns the number of columns in the table.</p>
</div>
<!-- class="sect4" -->
<a id="CHDJDBEC"></a>
<div id="TTCLS459" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref482"></a>OwnerName()</h5>
<pre dir="ltr">const char* getOwnerName() const
</pre>
<p>Returns the user name of the owner of the table.</p>
</div>
<!-- class="sect4" -->
<a id="CHDGDFGE"></a>
<div id="TTCLS460" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref483"></a>TableName()</h5>
<pre dir="ltr">const char* getTableName() const
</pre>
<p>Returns the name of the table.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDIGJJB"></a>
<div id="TTCLS461" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">T<a id="sthref484"></a><a id="sthref485"></a>TXlaColumn</h3>
<p>A <code dir="ltr">TTXlaColumn</code> object contains the metadata for a single column of a table being monitored for changes. It acts as a metadata interface for the TimesTen <code dir="ltr">ttXlaColDesc_t</code> C data structure. (See <a class="olink TTCDV469" href="../TTCDV/xla_ref.htm#TTCDV469">&#34;ttXlaColDesc_t&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span>.) Information including the column name, type, precision, and scale can be retrieved.</p>
<div id="TTCLS462" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref486"></a>
<h4 class="sect3">Usage</h4>
<p>Applications can associate a column with a <code dir="ltr">TTXlaColumn</code> object by using the <code dir="ltr">TTXlaRowViewer::<a href="#CHDHFBAH">getColumn()</a></code> method.</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS463" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref487"></a>
<h4 class="sect3">Public members</h4>
<p>None</p>
</div>
<!-- class="sect3" -->
<div id="TTCLS464" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref488"></a>
<h4 class="sect3">Public methods</h4>
<div class="inftblhruleinformal">
<table class="cellalignment2189" title="Method descriptions" summary="This table contains descriptions of the public methods for TTXlaColumn." dir="ltr">
<thead>
<tr class="cellalignment2183">
<th class="cellalignment2190" id="r1c1-t49">Method</th>
<th class="cellalignment2190" id="r1c2-t49">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r2c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDGCJDC">getColName()</a></code></td>
<td class="cellalignment2191" headers="r2c1-t49 r1c2-t49">Returns the name of the column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r3c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDCHGEG">getPrecision()</a></code></td>
<td class="cellalignment2191" headers="r3c1-t49 r1c2-t49">Returns the precision of the column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r4c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDBJAHE">getScale()</a></code></td>
<td class="cellalignment2191" headers="r4c1-t49 r1c2-t49">Returns the scale of the column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r5c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDDAEED">getSize()</a></code></td>
<td class="cellalignment2191" headers="r5c1-t49 r1c2-t49">Returns the size of the column data, in bytes.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r6c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDGIFEA">getSysColNum()</a></code></td>
<td class="cellalignment2191" headers="r6c1-t49 r1c2-t49">Returns the system-generated column number of this column as stored in the database.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r7c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDBJCDH">getType()</a></code></td>
<td class="cellalignment2191" headers="r7c1-t49 r1c2-t49">Returns the data type of the column, as an integer.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r8c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDEFDAJ">getUserColNum()</a></code></td>
<td class="cellalignment2191" headers="r8c1-t49 r1c2-t49">Returns a column number optionally specified by the user, or 0.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r9c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDCEAFH">isNullable()</a></code></td>
<td class="cellalignment2191" headers="r9c1-t49 r1c2-t49">Indicates whether the column allows <code dir="ltr">NULL</code> values.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r10c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDDICGH">isPKColumn()</a></code></td>
<td class="cellalignment2191" headers="r10c1-t49 r1c2-t49">Indicates whether the column is the primary key for the table.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r11c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDHJIGE">isTTTimestamp()</a></code></td>
<td class="cellalignment2191" headers="r11c1-t49 r1c2-t49">Indicates whether the column is a <code dir="ltr">TT_TIMESTAMP</code> column.</td>
</tr>
<tr class="cellalignment2183">
<td class="cellalignment2191" id="r12c1-t49" headers="r1c1-t49"><code dir="ltr"><a href="#CHDIDJHJ">isUpdated()</a></code></td>
<td class="cellalignment2191" headers="r12c1-t49 r1c2-t49">Indicates whether the column was updated.</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="inftblhruleinformal" -->
<a id="CHDGCJDC"></a>
<div id="TTCLS465" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref489"></a>ColName()</h5>
<pre dir="ltr">const char* getColName() const
</pre>
<p>Returns the name of the column.</p>
</div>
<!-- class="sect4" -->
<a id="CHDCHGEG"></a>
<div id="TTCLS466" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref490"></a>Precision()</h5>
<pre dir="ltr">SQLULEN getPrecision() const
</pre>
<p>Returns the precision for data in the column, referring to the maximum number of digits that are used by the data type.</p>
</div>
<!-- class="sect4" -->
<a id="CHDBJAHE"></a>
<div id="TTCLS467" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">ge<a id="sthref491"></a>tScale()</h5>
<pre dir="ltr">int getScale() const
</pre>
<p>Returns the scale for data in the column, referring to the maximum number of digits to the right of the decimal point.</p>
</div>
<!-- class="sect4" -->
<a id="CHDDAEED"></a>
<div id="TTCLS468" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref492"></a>Size()</h5>
<pre dir="ltr">SQLUINTEGER getSize() const
</pre>
<p>Returns the size of values in the column, in bytes.</p>
</div>
<!-- class="sect4" -->
<a id="CHDGIFEA"></a>
<div id="TTCLS471" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">getSys<a id="sthref493"></a>ColNum()</h5>
<pre dir="ltr">SQLUINTEGER getSysColNum() const
</pre>
<p>This is the system-generated column number of the column, numbered from 1. It equals the corresponding <code dir="ltr">COLNUM</code> value in <code dir="ltr">SYS.COLUMNS</code>. (See <a class="olink TTSYS363" href="../TTSYS/systemtables.htm#TTSYS363">&#34;SYS.COLUMNS&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database System Tables and Views Reference</span>.)</p>
</div>
<!-- class="sect4" -->
<a id="CHDBJCDH"></a>
<div id="TTCLS469" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">get<a id="sthref494"></a>Type()</h5>
<pre dir="ltr">int getType() const
</pre>
<p>Returns an integer representing the TimesTen XLA data type (<code dir="ltr">TTXLA_</code><code dir="ltr"><span class="codeinlineitalic">xxx</span></code>) of the column. This is a value from the <code dir="ltr"><span class="codeinlineitalic">dataType</span></code> field of the TimesTen <code dir="ltr">ttXlaColDesc_t</code> data structure. In some cases this corresponds to an ODBC SQL data type (<code dir="ltr">SQL_</code><code dir="ltr"><span class="codeinlineitalic">xxx</span></code>) and the corresponding standard integer value.</p>
<p>Refer to <a class="olink TTCDV260" href="../TTCDV/xla_event.htm#TTCDV260">&#34;About XLA data types&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span> for information regarding TimesTen XLA data types. The corresponding integer values are defined for use in any TTClasses application that includes the <code dir="ltr">TTXla.h</code> header file.</p>
<p>Also refer to <a class="olink TTCDV469" href="../TTCDV/xla_ref.htm#TTCDV469">&#34;ttXlaColDesc_t&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database C Developer&#39;s Guide</span> for information about that data structure.</p>
</div>
<!-- class="sect4" -->
<a id="CHDEFDAJ"></a>
<div id="TTCLS470" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">getUser<a id="sthref495"></a>ColNum()</h5>
<pre dir="ltr">SQLUINTEGER getUserColNum() const
</pre>
<p>Returns a column number optionally specified by the user through the <code dir="ltr">ttSetUserColumnID</code> TimesTen built-in procedure, or 0.</p>
<p>See <a class="olink TTREF303" href="../TTREF/proced.htm#TTREF303">&#34;ttSetUserColumnID&#34;</a> in <span class="italic">Oracle TimesTen In-Memory Database Reference</span>.</p>
</div>
<!-- class="sect4" -->
<a id="CHDCEAFH"></a>
<div id="TTCLS472" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">is<a id="sthref496"></a>Nullable()</h5>
<pre dir="ltr">bool isNullable() const
</pre>
<p>Returns <code dir="ltr">TRUE</code> if null values are allowed in the column, or <code dir="ltr">FALSE</code> otherwise.</p>
</div>
<!-- class="sect4" -->
<a id="CHDDICGH"></a>
<div id="TTCLS473" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">is<a id="sthref497"></a>PKColumn()</h5>
<pre dir="ltr">bool isPKColumn() const
</pre>
<p>Returns <code dir="ltr">TRUE</code> if this column is the primary key for the table, or <code dir="ltr">FALSE</code> otherwise.</p>
</div>
<!-- class="sect4" -->
<a id="CHDHJIGE"></a>
<div id="TTCLS474" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">is<a id="sthref498"></a>TTTimestamp()</h5>
<pre dir="ltr">bool isTTTimestamp() const
</pre>
<p>Returns <code dir="ltr">TRUE</code> if this column is a <code dir="ltr">TT_TIMESTAMP</code> column, or <code dir="ltr">FALSE</code> otherwise.</p>
</div>
<!-- class="sect4" -->
<a id="CHDIDJHJ"></a>
<div id="TTCLS475" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">is<a id="sthref499"></a>Updated()</h5>
<pre dir="ltr">bool isUpdated() const
</pre>
<p>Returns <code dir="ltr">TRUE</code> if this column was updated, or <code dir="ltr">FALSE</code> otherwise.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2182">
<tr>
<td class="cellalignment2191">
<table class="cellalignment2187">
<tr>
<td class="cellalignment2186"><a href="usage.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2186"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2006, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2193">
<table class="cellalignment2185">
<tr>
<td class="cellalignment2186"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2186"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2186"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2186"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2186"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2186"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>