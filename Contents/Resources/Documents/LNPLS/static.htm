<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-78352"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/PL%2FSQL%20Static%20SQL"></a><title>PL/SQL Static SQL</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="Static SQL is a PL/SQL feature that allows SQL syntax directly in a PL/SQL statement."/>
<meta name="keywords" content="static SQL, SQL, static, See, embedded SQL, SELECT INTO statement, query, DML statement, PL/SQL syntax of, TCL statement, Transaction Control Language, identifier, in static SQL, PL/SQL identifier in, placeholder for bind variable, placeholder for bind variable in, variable, with undefined value, pseudocolumn, LEVEL pseudocolumn, ROWID pseudocolumn, sequence, CURRVAL pseudocolumn, NEXTVAL pseudocolumn, dot notation, for pseudocolumn, cursor, session cursor, cursor attribute, where you can use, attribute, implicit cursor, implicit, for implicit cursor, SQL cursor, SQL%ISOPEN, %ISOPEN cursor attribute, SQL%FOUND, %FOUND cursor attribute, SQL%FOUND cursor attribute, SQL%NOTFOUND, %NOTFOUND cursor attribute, SQL%NOTFOUND cursor attribute, SQL%NOTFOUND attribute and, aggregate function, SQL%ROWCOUNT, %ROWCOUNT cursor attribute, SQL%ROWCOUNT cursor attribute, SQL%ROWCOUNT attribute and, transaction, SQL%ROWCOUNT cursor attribute and, explicit cursor, explicit, named cursor, named, explicit cursor and cursor variable, explicit cursor, See also, and, FETCH statement, with explicit cursor, that returns no row, in explicit cursor query, column alias, in explicit cursor, alias, column, expression, virtual column, explicit cursors and, calculated column, generated column, %ROWTYPE attribute, explicit cursor and, column alias and, parameter, cursor parameter, default value, of cursor parameter, for explicit cursor, %ISOPEN, for named cursor, %FOUND, %NOTFOUND, %ROWCOUNT, processing result set of, query result processing with, with SELECT INTO statement, query result set processing with, ROWNUM pseudocolumn, single-row result set and, BULK COLLECT clause, query result set processing and, cursor FOR LOOP statement, with cursor FOR LOOP statement, in FOR LOOP statement, in cursor FOR LOOP, exception, raised in cursor FOR LOOP statement, with OPEN, FETCH, and CLOSE statements, subquery, result set processing with, correlated subquery, correlated, SYS_REFCURSOR type, REF CURSOR type, REF CURSOR, strong REF CURSOR type, creating, weak REF CURSOR type, table function, weak cursor variable argument to, OPEN FOR statement and, with cursor variable, FETCH statement and, in cursor variable query, collection, querying, with static SQL, TABLE operator, for cursor variable, subprogram parameter, cursor variable as, query result as, host variable, host, Oracle Call Interface (OCI), cursor variable and, OCI, CURSOR expression, CURSOR, nested cursor, nested, CURSOR expression as actual, CURSOR expression with, COMMIT statement, ending, with COMMIT statement, ROLLBACK statement, with ROLLBACK statement, SAVEPOINT statement, implicit ROLLBACK statement, deadlock, implicit rollback and, SET TRANSACTION statement, read-only transaction, read-only, read-write transaction, read-write, locking, overriding default, LOCK TABLE statement, table, lock mode, mode, lock, SELECT FOR UPDATE statement, result set row, FOR UPDATE cursor, FOR UPDATE, CURRENT OF clause, FOR UPDATE cursor and, after COMMIT or ROLLBACK, across COMMIT, ROWID pseudocolumn instead of, instead of CURRENT OF clause, autonomous transaction, autonomous, independent transaction, autonomous routine, nested transaction, context of transaction, context of, visibility, of transaction, visibility of, isolation level of transaction, isolation level of, declaring, AUTONOMOUS_TRANSACTION pragma, controlling, in autonomous transaction, autonomous transaction and, TRANSACTIONS initialization parameter, concurrent transactions, PIPE ROW statement, in autonomous routine, autonomous trigger, trigger, in trigger, TCL statement in, DDL statement, DDL statement in, data definition language statement"/>
<meta name="dcterms.created" content="2017-05-09T17:03:42Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database PL/SQL Language Reference"/>
<meta name="dcterms.identifier" content="E50727-06"/>
<meta name="dcterms.isVersionOf" content="LNPLS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="composites.htm" title="Previous" type="text/html"/>
<link rel="Next" href="dynamic.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E50727-06.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313"></a> <span id="PAGE" style="display:none;">13/100</span> <!-- End Header -->
<a id="LNPLS453"></a><a id="LNPLS006"></a>
<h1 id="LNPLS-GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313" class="sect1"><span class="enumeration_chapter">6</span> PL/SQL Static SQL</h1>
<div>
<p><span class="bold">Static SQL</span> is a PL/SQL feature that allows SQL syntax directly in a PL/SQL statement.</p>
<p>This chapter describes static SQL and explains how to use it.</p>
<div class="section">
<p class="subhead1">Topics</p>
</div>
<!-- class="section" -->
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C" title="Static SQL has the same syntax as SQL, except as noted.">Description of Static SQL</a></p>
</li>
<li>
<p><a href="static.htm#GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" title="A cursor is a pointer to a private SQL area that stores information about processing a specific SELECT or DML statement.">Cursors Overview</a></p>
</li>
<li>
<p><a href="static.htm#GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D" title="In PL/SQL, as in traditional database programming, you use cursors to process query result sets. However, in PL/SQL, you can use either implicit or explicit cursors.">Processing Query Result Sets</a></p>
</li>
<li>
<p><a href="static.htm#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="To create a cursor variable, either declare a variable of the predefined type SYS_REFCURSOR or define a REF CURSOR type and then declare a variable of that type.After opening a cursor variable, you can fetch the rows of the query result set with the FETCH statement.You can assign to a PL/SQL cursor variable the value of another PL/SQL cursor variable or host cursor variable.The query associated with a cursor variable can reference any variable in its scope.You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.You can use a cursor variable as a host variable, which makes it useful for passing query results between PL/SQL stored subprograms and their clients.">Cursor Variables</a></p>
</li>
<li>
<p><a href="static.htm#GUID-77FF2850-F338-4C77-9577-0FE3399D39BA" title="A CURSOR expression returns a nested cursor.">CURSOR Expressions</a></p>
</li>
<li>
<p><a href="static.htm#GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1" title="Transaction processing is an Oracle Database feature that lets multiple users work on the database concurrently, and ensures that each user sees a consistent version of data and that all changes are applied in the right order.">Transaction Processing and Control</a></p>
</li>
<li>
<p><a href="static.htm#GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099" title="An autonomous transaction is an independent transaction started by another transaction, the main transaction.">Autonomous Transactions</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313__GUID-CCA1F5D9-AC64-4312-AE51-5719B87520F0">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="nameresolution.htm#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C">Resolution of Names in Static SQL Statements</a>&#34;</span></p>
</div>
</div>
<a id="LNPLS454"></a><a id="LNPLS00601"></a>
<div class="props_rev_3"><a id="GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C"></a>
<h2 id="LNPLS-GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C" class="sect2">Description of Static SQL</h2>
<div>
<p>Static SQL has the same syntax as SQL, except as noted.</p>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D">Statements</a></p>
</li>
<li>
<p><a href="static.htm#GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6" title="A pseudocolumn behaves like a table column, but it is not stored in the table.">Pseudocolumns</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS455"></a><a id="LNPLS99878"></a>
<div class="props_rev_3"><a id="GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D"></a>
<h3 id="LNPLS-GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D" class="sect3">Statements</h3>
<div>
<p>These are the PL/SQL static SQL statements, which have the same syntax as the corresponding SQL statements, except as noted:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">SELECT</code> (this statement is also called a <span class="bold">query</span>)</p>
<p>For the PL/SQL syntax, see <span class="q">&#34;<a href="selectinto_statement.htm#GUID-6E14E04D-4344-45F3-BE80-979DD26C7A90" title="The SELECT INTO statement retrieves values from one or more database tables (as the SQL SELECT statement does) and stores them in variables (which the SQL SELECT statement does not do).">SELECT INTO Statement</a>&#34;</span>.</p>
</li>
<li>
<p>Data manipulation language (DML) statements:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">INSERT</code></p>
<p>For the PL/SQL syntax, see <span class="q">&#34;<a href="insert_statement.htm#GUID-D81224C4-06DE-4635-A850-41D29D4A8E1B" title="The PL/SQL extension to the SQL INSERT statement lets you specify a record name in the values_clause of the single_table_insert instead of specifying a column list in the insert_into_clause">INSERT Statement Extension</a>&#34;</span>.</p>
</li>
<li>
<p><code class="codeph">UPDATE</code></p>
<p>For the PL/SQL syntax, see <span class="q">&#34;<a href="update_statement.htm#GUID-8FA29ACC-5E0F-4BE1-BC33-2B882C87E36D">UPDATE Statement Extensions</a>&#34;</span>.</p>
</li>
<li>
<p><code class="codeph">DELETE</code></p>
<p>For the PL/SQL syntax, see <span class="q">&#34;<a href="delete_statement.htm#GUID-9BEEC5E0-EF77-4E88-9DD4-B9BA1EABABCF" title="The PL/SQL extension to the where_clause of the SQL DELETE statement lets you specify a CURRENT OF clause, which restricts the DELETE statement to the current row of the specified cursor.">DELETE Statement Extension</a>&#34;</span>.</p>
</li>
<li>
<p><code class="codeph">MERGE</code> (for syntax, see <a class="olink SQLRF01606" target="_blank" href="../SQLRF/statements_9017.htm#SQLRF01606"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
</ul>
<div class="infobox-note" id="GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D__GUID-4C5BCA30-28A7-415C-8678-AA636907106B">
<p class="notep1">Note:</p>
<p><a class="olink SQLRF30042" target="_blank" href="../SQLRF/statements_1001.htm#SQLRF30042"><span class="italic">Oracle Database SQL Language Reference</span></a> defines DML differently.</p>
</div>
</li>
<li>
<p>Transaction control language (TCL) statements:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">COMMIT</code> (for syntax, see <a class="olink SQLRF01110" target="_blank" href="../SQLRF/statements_4011.htm#SQLRF01110"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code class="codeph">ROLLBACK</code> (for syntax, see <a class="olink SQLRF01610" target="_blank" href="../SQLRF/statements_9023.htm#SQLRF01610"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code class="codeph">SAVEPOINT</code> (for syntax, see <a class="olink SQLRF01701" target="_blank" href="../SQLRF/statements_10001.htm#SQLRF01701"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code class="codeph">SET</code> <code class="codeph">TRANSACTION</code> (for syntax, see <a class="olink SQLRF01705" target="_blank" href="../SQLRF/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
</ul>
</li>
<li>
<p><code class="codeph">LOCK</code> <code class="codeph">TABLE</code> (for syntax, see <a class="olink SQLRF01605" target="_blank" href="../SQLRF/statements_9016.htm#SQLRF01605"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
</ul>
<p>A PL/SQL static SQL statement can have a PL/SQL identifier wherever its SQL counterpart can have a placeholder for a bind variable. The PL/SQL identifier must identify either a variable or a formal parameter.</p>
<p>To use PL/SQL identifiers for table names, column names, and so on, use the <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement, explained in <span class="q">&#34;<a href="dynamic.htm#GUID-D2613968-6660-4AA2-9057-28E425A3040D" title="Native dynamic SQL processes most dynamic SQL statements with the EXECUTE IMMEDIATE statement.">Native Dynamic SQL</a>&#34;</span></p>
<div class="infobox-note" id="GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D__GUID-492EA28F-D11F-430E-8649-DF7A1D03232F">
<p class="notep1">Note:</p>
<p>After PL/SQL code runs a DML statement, the values of some variables are undefined. For example:</p>
<ul style="list-style-type: disc;">
<li>
<p>After a <code class="codeph">FETCH</code> or <code class="codeph">SELECT</code> statement raises an exception, the values of the define variables after that statement are undefined.</p>
</li>
<li>
<p>After a DML statement that affects zero rows, the values of the <code class="codeph">OUT</code> bind variables are undefined, unless the DML statement is a <code class="codeph">BULK</code> or multiple-row operation.</p>
</li>
</ul>
</div>
<div class="example" id="GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D__BABIEJGE">
<p class="titleinexample">Example 6-1 Static SQL Statements</p>
<p>In this example, a PL/SQL anonymous block declares three PL/SQL variables and uses them in the static SQL statements <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>. The block also uses the static SQL statement <code class="codeph">COMMIT</code>.</p>
<pre dir="ltr">DROP TABLE employees_temp;
CREATE TABLE employees_temp AS
  SELECT employee_id, first_name, last_name 
  FROM employees;
 
DECLARE
  emp_id          employees_temp.employee_id%TYPE := 299;
  emp_first_name  employees_temp.first_name%TYPE  := &#39;Bob&#39;;
  emp_last_name   employees_temp.last_name%TYPE   := &#39;Henry&#39;;
BEGIN
  <span class="bold">INSERT</span> INTO employees_temp (employee_id, first_name, last_name) 
  VALUES (<span class="bold">emp_id</span>, <span class="bold">emp_first_name</span>, <span class="bold">emp_last_name</span>);
 
  <span class="bold">UPDATE</span> employees_temp
  SET first_name = &#39;Robert&#39;
  WHERE employee_id = <span class="bold">emp_id</span>;
 
  <span class="bold">DELETE</span> FROM employees_temp
  WHERE employee_id = <span class="bold">emp_id</span>
  RETURNING first_name, last_name
  INTO <span class="bold">emp_first_name</span>, <span class="bold">emp_last_name</span>;
 
  <span class="bold">COMMIT</span>;
  DBMS_OUTPUT.PUT_LINE (emp_first_name || &#39; &#39; || emp_last_name);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Robert Henry
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS00611"></a>
<div class="props_rev_3"><a id="GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6"></a>
<h3 id="LNPLS-GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6" class="sect3">Pseudocolumns</h3>
<div>
<p>A pseudocolumn behaves like a table column, but it is not stored in the table.</p>
<p>For general information about pseudocolumns, including restrictions, see <a class="olink SQLRF0025" target="_blank" href="../SQLRF/pseudocolumns.htm#SQLRF0025"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>Static SQL includes these SQL pseudocolumns:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">CURRVAL</code> and <code class="codeph">NEXTVAL</code>, described in <span class="q">&#34;<a href="static.htm#GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187" title="After a sequence is created, you can access its values in SQL statements with the CURRVAL pseudocolumn, which returns the current value of the sequence, or the NEXTVAL pseudocolumn, which increments the sequence and returns the new value.">CURRVAL and NEXTVAL in PL/SQL</a>&#34;</span>.</p>
</li>
<li>
<p><code class="codeph">LEVEL</code>, described in <a class="olink SQLRF50942" target="_blank" href="../SQLRF/pseudocolumns001.htm#SQLRF50942"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><code class="codeph">OBJECT_VALUE</code>, described in <a class="olink SQLRF50952" target="_blank" href="../SQLRF/pseudocolumns006.htm#SQLRF50952"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
<div class="infoboxnotealso" id="GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6__GUID-4879ECB2-5EBD-47A7-B80D-3526D1531E2F">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="triggers.htm#GUID-C42CC16B-EAC1-4093-85C8-6359D08C912F">OBJECT_VALUE Pseudocolumn</a>&#34;</span> for information about using <code class="codeph">OBJECT_VALUE</code> in triggers</p>
</div>
</li>
<li>
<p><code class="codeph">ROWID</code>, described in <a class="olink SQLRF00254" target="_blank" href="../SQLRF/pseudocolumns008.htm#SQLRF00254"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
<div class="infoboxnotealso" id="GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6__GUID-E2BF1953-13E8-4C78-B636-9AE92081B1A6">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="static.htm#GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9">Simulating CURRENT OF Clause with ROWID Pseudocolumn</a>&#34;</span></p>
</div>
</li>
<li>
<p><code class="codeph">ROWNUM</code>, described in <a class="olink SQLRF00255" target="_blank" href="../SQLRF/pseudocolumns009.htm#SQLRF00255"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
</div>
<a id="LNPLS512"></a><a id="LNPLS00610"></a>
<div class="props_rev_3"><a id="GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187"></a>
<h4 id="LNPLS-GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187" class="sect4">CURRVAL and NEXTVAL in PL/SQL</h4>
<div>
<p>After a sequence is created, you can access its values in SQL statements with the <code class="codeph">CURRVAL</code> pseudocolumn, which returns the current value of the sequence, or the <code class="codeph">NEXTVAL</code> pseudocolumn, which increments the sequence and returns the new value.</p>
<p>To reference these pseudocolumns, use dot notation&mdash;for example, <span class="italic"><code class="codeph">sequence_name</code></span>.<code class="codeph">CURRVAL</code>.</p>
<div class="infobox-note" id="GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187__GUID-CD274D00-0FA6-43E3-B66B-1CC5A40B1A08">
<p class="notep1">Note:</p>
<p>Each time you reference <span class="italic"><code class="codeph">sequence_name</code></span>.<code class="codeph">NEXTVAL</code>, the sequence is incremented immediately and permanently, whether you commit or roll back the transaction.</p>
</div>
<p>You can use <span class="italic"><code class="codeph">sequence_name</code></span>.<code class="codeph">CURRVAL</code> and <span class="italic"><code class="codeph">sequence_name</code></span>.<code class="codeph">NEXTVAL</code> in a PL/SQL expression wherever you can use a <code class="codeph">NUMBER</code> expression. However:</p>
<ul style="list-style-type: disc;">
<li>
<p>Using <span class="italic"><code class="codeph">sequence_name</code></span>.<code class="codeph">CURRVAL</code> or <span class="italic"><code class="codeph">sequence_name</code></span>.<code class="codeph">NEXTVAL</code> to provide a default value for an ADT method parameter causes a compilation error.</p>
</li>
<li>
<p>PL/SQL evaluates every occurrence of <span class="italic"><code class="codeph">sequence_name</code></span>.<code class="codeph">CURRVAL</code> and <span class="italic"><code class="codeph">sequence_name</code></span>.<code class="codeph">NEXTVAL</code> (unlike SQL, which evaluates a sequence expression for every row in which it appears).</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187__GUID-E343B5C4-8B0D-4646-A4AF-7899196288DC">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF01314" target="_blank" href="../SQLRF/statements_6017.htm#SQLRF01314"><span class="italic">Oracle Database SQL Language Reference</span></a> for general information about sequences</p>
</li>
<li>
<p><a class="olink SQLRF00253" target="_blank" href="../SQLRF/pseudocolumns002.htm#SQLRF00253"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code class="codeph">CURRVAL</code> and <code class="codeph">NEXTVAL</code> complete syntax</p>
</li>
</ul>
</div>
<div class="example" id="GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187__BABDDFGI">
<p class="titleinexample">Example 6-2 CURRVAL and NEXTVAL Pseudocolumns</p>
<p>This example generates a sequence number for the sequence <code class="codeph">HR.EMPLOYEES_SEQ</code> and refers to that number in multiple statements.</p>
<pre dir="ltr">DROP TABLE employees_temp;
CREATE TABLE employees_temp AS
  SELECT employee_id, first_name, last_name
  FROM employees;
 
DROP TABLE employees_temp2;
CREATE TABLE employees_temp2 AS
  SELECT employee_id, first_name, last_name
  FROM employees;
 
DECLARE
  seq_value NUMBER;
BEGIN
  <span class="bold">-- Generate initial sequence number</span>
 
  seq_value := <span class="bold">employees_seq.NEXTVAL</span>;
 
  -- Print initial sequence number:
 
  DBMS_OUTPUT.PUT_LINE (
    &#39;Initial sequence value: &#39; || TO_CHAR(seq_value)
  );
 
  <span class="bold">-- Use NEXTVAL to create unique number when inserting data:</span>
 
     INSERT INTO employees_temp (employee_id, first_name, last_name) 
     VALUES (<span class="bold">employees_seq.NEXTVAL</span>, &#39;Lynette&#39;, &#39;Smith&#39;);
 
  <span class="bold">-- Use CURRVAL to store same value somewhere else:</span>
 
     INSERT INTO employees_temp2 VALUES (<span class="bold">employees_seq.CURRVAL</span>,
                                         &#39;Morgan&#39;, &#39;Smith&#39;);
 
  /* Because NEXTVAL values might be referenced
     by different users and applications,
     and some NEXTVAL values might not be stored in database,
     there might be gaps in sequence. */
 
  <span class="bold">-- Use CURRVAL to specify record to delete:</span>
 
     seq_value := <span class="bold">employees_seq.CURRVAL</span>;
 
     DELETE FROM employees_temp2
     WHERE employee_id = seq_value;
 
  <span class="bold">-- Update employee_id with NEXTVAL for specified record:</span>
 
     UPDATE employees_temp
     SET employee_id = <span class="bold">employees_seq.NEXTVAL</span>
     WHERE first_name = &#39;Lynette&#39;
     AND last_name = &#39;Smith&#39;;
 
  <span class="bold">-- Display final value of CURRVAL:</span>
 
     seq_value := <span class="bold">employees_seq.CURRVAL</span>;
 
     DBMS_OUTPUT.PUT_LINE (
       &#39;Ending sequence value: &#39; || TO_CHAR(seq_value)
     );
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="LNPLS00602"></a>
<div class="props_rev_3"><a id="GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1"></a>
<h2 id="LNPLS-GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" class="sect2">Cursors Overview</h2>
<div>
<p>A <span class="bold">cursor</span> is a pointer to a private SQL area that stores information about processing a specific <code class="codeph">SELECT</code> or DML statement.</p>
<div class="infobox-note" id="GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1__GUID-4244A2F2-6C24-4E81-8271-9E17BE532025">
<p class="notep1">Note:</p>
<p>The cursors that this topic explains are session cursors. A <span class="bold">session cursor</span> lives in session memory until the session ends, when it ceases to exist.</p>
</div>
<p>A cursor that is constructed and managed by PL/SQL is an <span class="bold">implicit cursor</span>. A cursor that you construct and manage is an <span class="bold">explicit cursor</span>.</p>
<p>You can get information about any session cursor from its attributes (which you can reference in procedural statements, but not in SQL statements).</p>
<p>To list the session cursors that each user session currently has opened and parsed, query the dynamic performance view <code class="codeph">V$OPEN_CURSOR</code>.</p>
<p>The number of cursors that a session can have open simultaneously is determined by:</p>
<ul style="list-style-type: disc;">
<li>
<p>The amount of memory available to the session</p>
</li>
<li>
<p>The value of the initialization parameter <code class="codeph">OPEN_CURSORS</code></p>
</li>
</ul>
<div class="infobox-note" id="GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1__GUID-ACE515DD-F096-46B3-A049-7C0864ABAB0F">
<p class="notep1">Note:</p>
<p>Generally, PL/SQL parses an explicit cursor only the first time the session opens it and parses a SQL statement (creating an implicit cursor) only the first time the statement runs.</p>
<p>All parsed SQL statements are cached. A SQL statement is reparsed only if it is aged out of the cache by a new SQL statement. Although you must close an explicit cursor before you can reopen it, PL/SQL need not reparse the associated query. If you close and immediately reopen an explicit cursor, PL/SQL does not reparse the associated query.</p>
</div>
<p>Topics</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-596C1961-5A94-40ED-9920-668BB05632C5">Implicit Cursors</a></p>
</li>
<li>
<p><a href="static.htm#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">Explicit Cursors</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1__GUID-5583E783-B15B-4DF4-BA25-EC5BE962CFA5">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink REFRN30166" target="_blank" href="../REFRN/GUID-E255F28A-D435-476A-891C-2EF9C4717337.htm#REFRN30166"><span class="italic">Oracle Database Reference</span></a> for information about the dynamic performance view <code class="codeph">V$OPEN_CURSOR</code></p>
</li>
<li>
<p><a class="olink REFRN10137" target="_blank" href="../REFRN/GUID-FAFD1247-06E5-4E64-917F-AEBD4703CF40.htm#REFRN10137"><span class="italic">Oracle Database Reference</span></a> for information about the initialization parameter <code class="codeph">OPEN_CURSORS</code></p>
</li>
</ul>
</div>
</div>
<a id="LNPLS99957"></a>
<div class="props_rev_3"><a id="GUID-596C1961-5A94-40ED-9920-668BB05632C5"></a>
<h3 id="LNPLS-GUID-596C1961-5A94-40ED-9920-668BB05632C5" class="sect3">Implicit Cursors</h3>
<div>
<p>An <span class="bold">implicit cursor</span> is a session cursor that is constructed and managed by PL/SQL. PL/SQL opens an implicit cursor every time you run a <code class="codeph">SELECT</code> or DML statement. You cannot control an implicit cursor, but you can get information from its attributes.</p>
<p>The syntax of an implicit cursor attribute value is <code class="codeph">SQL</code><span class="italic"><code class="codeph">attribute</code></span> (therefore, an implicit cursor is also called a <span class="bold">SQL cursor</span>). <code class="codeph">SQL</code><span class="italic"><code class="codeph">attribute</code></span> always refers to the most recently run <code class="codeph">SELECT</code> or DML statement. If no such statement has run, the value of <code class="codeph">SQL</code><span class="italic"><code class="codeph">attribute</code></span> is <code class="codeph">NULL</code>.</p>
<p>An implicit cursor closes after its associated statement runs; however, its attribute values remain available until another <code class="codeph">SELECT</code> or DML statement runs.</p>
<p>The most recently run <code class="codeph">SELECT</code> or DML statement might be in a different scope. To save an attribute value for later use, assign it to a local variable immediately. Otherwise, other operations, such as subprogram invocations, might change the value of the attribute before you can test it.</p>
<p>The implicit cursor attributes are:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-122BA765-31BB-4BA5-AEF7-F7EAD3960AF5">SQL%ISOPEN Attribute: Is the Cursor Open?</a></p>
</li>
<li>
<p><a href="static.htm#GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8">SQL%FOUND Attribute: Were Any Rows Affected?</a></p>
</li>
<li>
<p><a href="static.htm#GUID-87C3CAFD-625D-4785-A32F-14E2440335DC">SQL%NOTFOUND Attribute: Were No Rows Affected?</a></p>
</li>
<li>
<p><a href="static.htm#GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5">SQL%ROWCOUNT Attribute: How Many Rows Were Affected?</a></p>
</li>
<li>
<p><code class="codeph">SQL%BULK_ROWCOUNT</code> (see <span class="q">&#34;<a href="tuning.htm#GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412" title="After a FORALL statement completes, you can get the number of rows that each DML statement affected from the implicit cursor attribute SQL%BULK_ROWCOUNT.">Getting Number of Rows Affected by FORALL Statement</a>&#34;</span></p>
</li>
<li>
<p><code class="codeph">SQL%BULK_EXCEPTIONS</code> (see <span class="q">&#34;<a href="tuning.htm#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" title="To allow a FORALL statement to continue even if some of its DML statements fail, include the SAVE EXCEPTIONS clause. When a DML statement fails, PL/SQL does not raise an exception; instead, it saves information about the failure. After the FORALL statement completes, PL/SQL raises a single exception for the FORALL statement (ORA-24381).">Handling FORALL Exceptions After FORALL Statement Completes</a>&#34;</span></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-596C1961-5A94-40ED-9920-668BB05632C5__GUID-1B7BAB86-1B59-4C39-BBF2-0214DC309676">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="implicit_cursor_attribute.htm#GUID-5A938EE7-E8D2-468C-B60F-81898F110BE1" title="An implicit cursor has attributes that return information about the most recently run SELECT or DML statement that is not associated with a named cursor.">Implicit Cursor Attribute</a>&#34;</span> for complete syntax and semantics</p>
</div>
</div>
<a id="LNPLS526"></a>
<div class="props_rev_3"><a id="GUID-122BA765-31BB-4BA5-AEF7-F7EAD3960AF5"></a>
<h4 id="LNPLS-GUID-122BA765-31BB-4BA5-AEF7-F7EAD3960AF5" class="sect4">SQL%ISOPEN Attribute: Is the Cursor Open?</h4>
<div>
<p><code class="codeph">SQL%ISOPEN</code> always returns <code class="codeph">FALSE</code>, because an implicit cursor always closes after its associated statement runs.</p>
</div>
</div>
<a id="LNPLS525"></a><a id="LNPLS524"></a>
<div class="props_rev_3"><a id="GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8"></a>
<h4 id="LNPLS-GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8" class="sect4">SQL%FOUND Attribute: Were Any Rows Affected?</h4>
<div>
<p><code class="codeph">SQL%FOUND</code> returns:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">NULL</code> if no <code class="codeph">SELECT</code> or DML statement has run</p>
</li>
<li>
<p><code class="codeph">TRUE</code> if a <code class="codeph">SELECT</code> statement returned one or more rows or a DML statement affected one or more rows</p>
</li>
<li>
<p><code class="codeph">FALSE</code> otherwise</p>
</li>
</ul>
<p><a href="static.htm#GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8__BABJGHAI">Example 6-3</a> uses <code class="codeph">SQL%FOUND</code> to determine if a <code class="codeph">DELETE</code> statement affected any rows.</p>
<div class="example" id="GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8__BABJGHAI">
<p class="titleinexample">Example 6-3 SQL%FOUND Implicit Cursor Attribute</p>
<pre dir="ltr">DROP TABLE dept_temp;
CREATE TABLE dept_temp AS
  SELECT * FROM departments;
 
CREATE OR REPLACE PROCEDURE p (
  dept_no NUMBER
) AUTHID CURRENT_USER AS
BEGIN
  DELETE FROM dept_temp
  WHERE department_id = dept_no;
 
  IF <span class="bold">SQL%FOUND</span> THEN
    DBMS_OUTPUT.PUT_LINE (
      &#39;Delete succeeded for department number &#39; || dept_no
    );
  ELSE
    DBMS_OUTPUT.PUT_LINE (&#39;No department number &#39; || dept_no);
  END IF;
END;
/
BEGIN
  p(270);
  p(400);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Delete succeeded for department number 270
No department number 400
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS527"></a>
<div class="props_rev_3"><a id="GUID-87C3CAFD-625D-4785-A32F-14E2440335DC"></a>
<h4 id="LNPLS-GUID-87C3CAFD-625D-4785-A32F-14E2440335DC" class="sect4">SQL%NOTFOUND Attribute: Were No Rows Affected?</h4>
<div>
<p><code class="codeph">SQL%NOTFOUND</code> (the logical opposite of <code class="codeph">SQL%FOUND</code>) returns:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">NULL</code> if no <code class="codeph">SELECT</code> or DML statement has run</p>
</li>
<li>
<p><code class="codeph">FALSE</code> if a <code class="codeph">SELECT</code> statement returned one or more rows or a DML statement affected one or more rows</p>
</li>
<li>
<p><code class="codeph">TRUE</code> otherwise</p>
</li>
</ul>
<p>The <code class="codeph">SQL%NOTFOUND</code> attribute is not useful with the PL/SQL <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement, because:</p>
<ul style="list-style-type: disc;">
<li>
<p>If the <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement returns no rows, PL/SQL raises the predefined exception <code class="codeph">NO_DATA_FOUND</code> immediately, before you can check <code class="codeph">SQL%NOTFOUND</code>.</p>
</li>
<li>
<p>A <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement that invokes a SQL aggregate function always returns a value (possibly <code class="codeph">NULL</code>). After such a statement, the <code class="codeph">SQL%NOTFOUND</code> attribute is always <code class="codeph">FALSE</code>, so checking it is unnecessary.</p>
</li>
</ul>
</div>
</div>
<a id="LNPLS529"></a><a id="LNPLS528"></a>
<div class="props_rev_3"><a id="GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5"></a>
<h4 id="LNPLS-GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5" class="sect4">SQL%ROWCOUNT Attribute: How Many Rows Were Affected?</h4>
<div>
<p><code class="codeph">SQL%ROWCOUNT</code> returns:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">NULL</code> if no <code class="codeph">SELECT</code> or DML statement has run</p>
</li>
<li>
<p>Otherwise, the number of rows returned by a <code class="codeph">SELECT</code> statement or affected by a DML statement (an <code class="codeph">INTEGER</code>)</p>
</li>
</ul>
<div class="infobox-note" id="GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5__GUID-6AB908BC-FED4-473E-B060-2AA2BF821667">
<p class="notep1">Note:</p>
<p>If a server is Oracle Database 12<span class="italic">c</span> or later and its client is Oracle Database 11<span class="italic">g</span>2 or earlier (or the reverse), then the maximum number that <code class="codeph">SQL%ROWCOUNT</code> returns is 4,294,967,295.</p>
</div>
<p><a href="static.htm#GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5__BABJCAAG">Example 6-4</a> uses <code class="codeph">SQL%ROWCOUNT</code> to determine the number of rows that were deleted.</p>
<p>If a <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement without a <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause returns multiple rows, PL/SQL raises the predefined exception <code class="codeph">TOO_MANY_ROWS</code> and <code class="codeph">SQL%ROWCOUNT</code> returns 1, not the actual number of rows that satisfy the query.</p>
<p>The value of <code class="codeph">SQL%ROWCOUNT</code> attribute is unrelated to the state of a transaction. Therefore:</p>
<ul style="list-style-type: disc;">
<li>
<p>When a transaction rolls back to a savepoint, the value of <code class="codeph">SQL%ROWCOUNT</code> is not restored to the value it had before the savepoint.</p>
</li>
<li>
<p>When an autonomous transaction ends, <code class="codeph">SQL%ROWCOUNT</code> is not restored to the original value in the parent transaction.</p>
</li>
</ul>
<div class="example" id="GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5__BABJCAAG">
<p class="titleinexample">Example 6-4 SQL%ROWCOUNT Implicit Cursor Attribute</p>
<pre dir="ltr">DROP TABLE employees_temp;
CREATE TABLE employees_temp AS
  SELECT * FROM employees;

DECLARE
  mgr_no NUMBER(6) := 122;
BEGIN
  DELETE FROM employees_temp WHERE manager_id = mgr_no;
  DBMS_OUTPUT.PUT_LINE
    (&#39;Number of employees deleted: &#39; || TO_CHAR(<span class="bold">SQL%ROWCOUNT</span>));
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Number of employees deleted: 8
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS456"></a><a id="LNPLS99956"></a>
<div class="props_rev_3"><a id="GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9"></a>
<h3 id="LNPLS-GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9" class="sect3">Explicit Cursors</h3>
<div>
<p>An <span class="bold">explicit cursor</span> is a session cursor that you construct and manage. You must declare and define an explicit cursor, giving it a name and associating it with a query (typically, the query returns multiple rows). Then you can process the query result set in either of these ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>Open the explicit cursor (with the <code class="codeph">OPEN</code> statement), fetch rows from the result set (with the <code class="codeph">FETCH</code> statement), and close the explicit cursor (with the <code class="codeph">CLOSE</code> statement).</p>
</li>
<li>
<p>Use the explicit cursor in a cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement (see <span class="q">&#34;<a href="static.htm#GUID-25917214-FD91-499D-AB39-CE21484AB167" title="The cursor FOR LOOP statement lets you run a SELECT statement and then immediately loop through the rows of the result set.">Processing Query Result Sets With Cursor FOR LOOP Statements</a>&#34;</span>.</p>
</li>
</ul>
<p>You cannot assign a value to an explicit cursor, use it in an expression, or use it as a formal subprogram parameter or host variable. You <span class="italic">can</span> do those things with a cursor variable (see <span class="q">&#34;<a href="static.htm#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="To create a cursor variable, either declare a variable of the predefined type SYS_REFCURSOR or define a REF CURSOR type and then declare a variable of that type.After opening a cursor variable, you can fetch the rows of the query result set with the FETCH statement.You can assign to a PL/SQL cursor variable the value of another PL/SQL cursor variable or host cursor variable.The query associated with a cursor variable can reference any variable in its scope.You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.You can use a cursor variable as a host variable, which makes it useful for passing query results between PL/SQL stored subprograms and their clients.">Cursor Variables</a>&#34;</span>).</p>
<p>Unlike an implicit cursor, you can reference an explicit cursor or cursor variable by its name. Therefore, an explicit cursor or cursor variable is called a <span class="bold">named cursor</span>.</p>
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA">Declaring and Defining Explicit Cursors</a></p>
</li>
<li>
<p><a href="static.htm#GUID-3FD3219B-E28D-47D0-A447-812C758BCDFB">Opening and Closing Explicit Cursors</a></p>
</li>
<li>
<p><a href="static.htm#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C">Fetching Data with Explicit Cursors</a></p>
</li>
<li>
<p><a href="static.htm#GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2">Variables in Explicit Cursor Queries</a></p>
</li>
<li>
<p><a href="static.htm#GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44">When Explicit Cursor Queries Need Column Aliases</a></p>
</li>
<li>
<p><a href="static.htm#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20">Explicit Cursors that Accept Parameters</a></p>
</li>
<li>
<p><a href="static.htm#GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D">Explicit Cursor Attributes</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS532"></a><a id="LNPLS531"></a>
<div class="props_rev_3"><a id="GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA"></a>
<h4 id="LNPLS-GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA" class="sect4">Declaring and Defining Explicit Cursors</h4>
<div>
<div class="section">
<p>You can either declare an explicit cursor first and then define it later in the same block, subprogram, or package, or declare and define it at the same time.</p>
<p>An <span class="bold">explicit cursor declaration</span>, which only declares a cursor, has this syntax:</p>
<pre dir="ltr">CURSOR <span class="italic">cursor_name</span> [ <span class="italic">parameter_list</span> ] RETURN <span class="italic">return_type</span>;
</pre>
<p>An <span class="bold">explicit cursor definition</span> has this syntax:</p>
<pre dir="ltr">CURSOR <span class="italic">cursor_name</span> [ <span class="italic">parameter_list</span> ] [ RETURN <span class="italic">return_type</span> ]
  IS <span class="italic">select_statement</span>;
</pre>
<p>If you declared the cursor earlier, then the explicit cursor definition defines it; otherwise, it both declares and defines it.</p>
<p><a href="static.htm#GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA__BABHICAF">Example 6-5</a> declares and defines three explicit cursors.</p>
<div class="infoboxnotealso" id="GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA__GUID-E69B13F7-541F-462F-93B4-91174935D8AC">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="explicit_cursor.htm#GUID-38C5DBA3-9DEC-4AF2-9B5E-7B721D11A77C" title="An explicit cursor is a named pointer to a private SQL area that stores information for processing a specific query or DML statement&mdash;typically, one that returns or affects multiple rows.">Explicit Cursor Declaration and Definition</a>&#34;</span> for the complete syntax and semantics of explicit cursor declaration and definition</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20">Explicit Cursors that Accept Parameters</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA__BABHICAF">
<p class="titleinexample">Example 6-5 Explicit Cursor Declaration and Definition</p>
<pre dir="ltr">DECLARE
  CURSOR c1 RETURN departments%ROWTYPE;    -- Declare c1
 
  CURSOR c2 IS                             -- Declare and define c2
    SELECT employee_id, job_id, salary FROM employees
    WHERE salary &gt; 2000; 
 
  CURSOR c1 RETURN departments%ROWTYPE IS  -- Define c1,
    SELECT * FROM departments              -- repeating return type
    WHERE department_id = 110;
 
  CURSOR c3 RETURN locations%ROWTYPE;      -- Declare c3
 
  CURSOR c3 IS                             -- Define c3,
    SELECT * FROM locations                -- omitting return type
    WHERE country_id = &#39;JP&#39;;
BEGIN
  NULL;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS533"></a>
<div class="props_rev_3"><a id="GUID-3FD3219B-E28D-47D0-A447-812C758BCDFB"></a>
<h4 id="LNPLS-GUID-3FD3219B-E28D-47D0-A447-812C758BCDFB" class="sect4">Opening and Closing Explicit Cursors</h4>
<div>
<div class="section">
<p>After declaring and defining an explicit cursor, you can open it with the <code class="codeph">OPEN</code> statement, which does the following:</p>
<ol>
<li>
<p>Allocates database resources to process the query</p>
</li>
<li>
<p>Processes the query; that is:</p>
<ol>
<li>
<p>Identifies the result set</p>
<p>If the query references variables or cursor parameters, their values affect the result set. For details, see <span class="q">&#34;<a href="static.htm#GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2">Variables in Explicit Cursor Queries</a>&#34;</span> and <span class="q">&#34;<a href="static.htm#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20">Explicit Cursors that Accept Parameters</a>&#34;</span>.</p>
</li>
<li>
<p>If the query has a <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> clause, locks the rows of the result set</p>
<p>For details, see <span class="q">&#34;<a href="static.htm#GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08">SELECT FOR UPDATE and FOR UPDATE Cursors</a>&#34;</span>.</p>
</li>
</ol>
</li>
<li>
<p>Positions the cursor before the first row of the result set</p>
</li>
</ol>
<p>You close an open explicit cursor with the <code class="codeph">CLOSE</code> statement, thereby allowing its resources to be reused. After closing a cursor, you cannot fetch records from its result set or reference its attributes. If you try, PL/SQL raises the predefined exception <code class="codeph">INVALID_CURSOR</code>.</p>
<p>You can reopen a closed cursor. You must close an explicit cursor before you try to reopen it. Otherwise, PL/SQL raises the predefined exception <code class="codeph">CURSOR_ALREADY_OPEN</code>.</p>
<div class="infoboxnotealso" id="GUID-3FD3219B-E28D-47D0-A447-812C758BCDFB__GUID-D945F31C-5E0A-4010-A8D6-8B168E04C84A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="open_statement.htm#GUID-FB5A9CC3-655F-4AF4-8105-14CB39F2FEA8" title="The OPEN statement opens an explicit cursor, allocates database resources to process the associated query, identifies the result set, and positions the cursor before the first row of the result set.">OPEN Statement</a>&#34;</span> for its syntax and semantics</p>
</li>
<li>
<p><span class="q">&#34;<a href="close_statement.htm#GUID-46E7086C-8C29-4689-A062-0FF059E268FD" title="The CLOSE statement closes a named cursor, freeing its resources for reuse.">CLOSE Statement</a>&#34;</span> for its syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS535"></a><a id="LNPLS537"></a><a id="LNPLS534"></a>
<div class="props_rev_3"><a id="GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C"></a>
<h4 id="LNPLS-GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C" class="sect4">Fetching Data with Explicit Cursors</h4>
<div>
<div class="section">
<p>After opening an explicit cursor, you can fetch the rows of the query result set with the <code class="codeph">FETCH</code> statement. The basic syntax of a <code class="codeph">FETCH</code> statement that returns one row is:</p>
<pre dir="ltr">FETCH <span class="italic">cursor_name</span> INTO <span class="italic">into_clause</span>
</pre>
<p>The <span class="italic"><code class="codeph">into_clause</code></span> is either a list of variables or a single record variable. For each column that the query returns, the variable list or record must have a corresponding type-compatible variable or field. The <code class="codeph">%TYPE</code> and <code class="codeph">%ROWTYPE</code> attributes are useful for declaring variables and records for use in <code class="codeph">FETCH</code> statements.</p>
<p>The <code class="codeph">FETCH</code> statement retrieves the current row of the result set, stores the column values of that row into the variables or record, and advances the cursor to the next row.</p>
<p>Typically, you use the <code class="codeph">FETCH</code> statement inside a <code class="codeph">LOOP</code> statement, which you exit when the <code class="codeph">FETCH</code> statement runs out of rows. To detect this exit condition, use the cursor attribute <code class="codeph">%NOTFOUND</code> (described in <span class="q">&#34;<a href="static.htm#GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5">%NOTFOUND Attribute: Has No Row Been Fetched?</a>&#34;</span>). PL/SQL does not raise an exception when a <code class="codeph">FETCH</code> statement returns no rows.</p>
<p><a href="static.htm#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__BABCFDJE">Example 6-6</a> fetches the result sets of two explicit cursors one row at a time, using <code class="codeph">FETCH</code> and <code class="codeph">%NOTFOUND</code> inside <code class="codeph">LOOP</code> statements. The first <code class="codeph">FETCH</code> statement retrieves column values into variables. The second <code class="codeph">FETCH</code> statement retrieves column values into a record. The variables and record are declared with <code class="codeph">%TYPE</code> and <code class="codeph">%ROWTYPE</code>, respectively.</p>
<p><a href="static.htm#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__CJADGBJE">Example 6-7</a> fetches the first five rows of a result set into five records, using five <code class="codeph">FETCH</code> statements, each of which fetches into a different record variable. The record variables are declared with <code class="codeph">%ROWTYPE</code>.</p>
<div class="infoboxnotealso" id="GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__GUID-FA715B02-74FD-47E3-AEE5-F0023325FCEC">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="fetch_statement.htm#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="The FETCH statement retrieves rows of data from the result set of a multiple-row query&mdash;one row at a time, several rows at a time, or all rows at once&mdash;and stores the data in variables, records, or collections.">FETCH Statement</a>&#34;</span> for its complete syntax and semantics</p>
</li>
<li>
<p><span class="q">&#34;<a href="tuning.htm#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" title="The FETCH statement with the BULK COLLECT clause (also called the FETCH BULK COLLECT statement) fetches an entire result set into one or more collection variables.">FETCH Statement with BULK COLLECT Clause</a>&#34;</span> for information about <code class="codeph">FETCH</code> statements that return more than one row at a time</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__BABCFDJE">
<p class="titleinexample">Example 6-6 FETCH Statements Inside LOOP Statements</p>
<pre dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT last_name, job_id FROM employees
    WHERE REGEXP_LIKE (job_id, &#39;S[HT]_CLERK&#39;)
    ORDER BY last_name;

  v_lastname  employees.last_name<span class="bold">%TYPE</span>;  -- variable for last_name
  v_jobid     employees.job_id<span class="bold">%TYPE</span>;     -- variable for job_id

  CURSOR c2 IS
    SELECT * FROM employees
    WHERE REGEXP_LIKE (job_id, &#39;[ACADFIMKSA]_M[ANGR]&#39;)
    ORDER BY job_id;

  v_employees employees<span class="bold">%ROWTYPE</span>;  -- record variable for row of table

BEGIN
  OPEN c1;
  <span class="bold">LOOP</span>  -- Fetches 2 columns into variables
    <span class="bold">FETCH c1 INTO v_lastname, v_jobid;</span>
    <span class="bold">EXIT WHEN c1%NOTFOUND;</span>
    DBMS_OUTPUT.PUT_LINE( RPAD(v_lastname, 25, &#39; &#39;) || v_jobid );
  <span class="bold">END LOOP;</span>
  CLOSE c1;
  DBMS_OUTPUT.PUT_LINE( &#39;-------------------------------------&#39; );

  OPEN c2;
  <span class="bold">LOOP</span>  -- Fetches entire row into the v_employees record
    <span class="bold">FETCH c2 INTO v_employees;</span>
    <span class="bold">EXIT WHEN c2%NOTFOUND;</span>
    DBMS_OUTPUT.PUT_LINE( RPAD(v_employees.last_name, 25, &#39; &#39;) ||
                               v_employees.job_id );
  <span class="bold">END LOOP;</span>
  CLOSE c2;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Atkinson                 ST_CLERK
Bell                     SH_CLERK
Bissot                   ST_CLERK
...
Walsh                    SH_CLERK
-------------------------------------
Higgins                  AC_MGR
Greenberg                FI_MGR
Hartstein                MK_MAN
...
Zlotkey                  SA_MAN
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__CJADGBJE">
<p class="titleinexample">Example 6-7 Fetching Same Explicit Cursor into Different Variables</p>
<pre dir="ltr">DECLARE
  CURSOR c IS
    SELECT e.job_id, j.job_title
    FROM employees e, jobs j
    WHERE e.job_id = j.job_id AND e.manager_id = 100
    ORDER BY last_name;
 
  -- Record variables for rows of cursor result set:
 
  job1 c<span class="bold">%ROWTYPE</span>;
  job2 c<span class="bold">%ROWTYPE</span>;
  job3 c<span class="bold">%ROWTYPE</span>;
  job4 c<span class="bold">%ROWTYPE</span>;
  job5 c<span class="bold">%ROWTYPE</span>;
 
BEGIN
  OPEN c;
  <span class="bold">FETCH c INTO job1;</span>  -- fetches first row
  <span class="bold">FETCH c INTO job2;</span>  -- fetches second row
  <span class="bold">FETCH c INTO job3;</span>  -- fetches third row
  <span class="bold">FETCH c INTO job4;</span>  -- fetches fourth row
  <span class="bold">FETCH c INTO job5;</span>  -- fetches fifth row
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE(job1.job_title || &#39; (&#39; || job1.job_id || &#39;)&#39;);
  DBMS_OUTPUT.PUT_LINE(job2.job_title || &#39; (&#39; || job2.job_id || &#39;)&#39;);
  DBMS_OUTPUT.PUT_LINE(job3.job_title || &#39; (&#39; || job3.job_id || &#39;)&#39;);
  DBMS_OUTPUT.PUT_LINE(job4.job_title || &#39; (&#39; || job4.job_id || &#39;)&#39;);
  DBMS_OUTPUT.PUT_LINE(job5.job_title || &#39; (&#39; || job5.job_id || &#39;)&#39;);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Sales Manager (SA_MAN)
Administration Vice President (AD_VP)
Sales Manager (SA_MAN)
Stock Manager (ST_MAN)
Marketing Manager (MK_MAN)

PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS536"></a><a id="LNPLS457"></a><a id="LNPLS99879"></a>
<div class="props_rev_3"><a id="GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2"></a>
<h4 id="LNPLS-GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2" class="sect4">Variables in Explicit Cursor Queries</h4>
<div>
<p>An explicit cursor query can reference any variable in its scope. When you open an explicit cursor, PL/SQL evaluates any variables in the query and uses those values when identifying the result set. Changing the values of the variables later does not change the result set.</p>
<p>In <a href="static.htm#GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2__CJAJAIFF">Example 6-8</a>, the explicit cursor query references the variable <code class="codeph">factor</code>. When the cursor opens, <code class="codeph">factor</code> has the value 2. Therefore, <code class="codeph">sal_multiple</code> is always 2 times <code class="codeph">sal</code>, despite that <code class="codeph">factor</code> is incremented after every fetch.</p>
<p>To change the result set, you must close the cursor, change the value of the variable, and then open the cursor again, as in <a href="static.htm#GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2__BABCAAFB">Example 6-9</a>.</p>
<div class="example" id="GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2__CJAJAIFF">
<p class="titleinexample">Example 6-8 Variable in Explicit Cursor Query&mdash;No Result Set Change</p>
<pre dir="ltr">DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  <span class="bold">factor        INTEGER := 2;</span>
 
  CURSOR c1 IS
    SELECT salary, salary*<span class="bold">factor</span> FROM employees
    WHERE job_id LIKE &#39;AD_%&#39;;
 
BEGIN
  <span class="bold">OPEN c1;  -- PL/SQL evaluates factor</span>
 
  LOOP
    <span class="bold">FETCH c1 INTO sal, sal_multiple;</span>
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(&#39;factor = &#39; || factor);
    DBMS_OUTPUT.PUT_LINE(&#39;sal          = &#39; || sal);
    DBMS_OUTPUT.PUT_LINE(&#39;sal_multiple = &#39; || sal_multiple);
    <span class="bold">factor := factor + 1;  -- Does not affect sal_multiple</span>
  END LOOP;
 
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">factor = 2
sal          = 4400
sal_multiple = 8800
factor = 3
sal          = 24000
sal_multiple = 48000
factor = 4
sal          = 17000
sal_multiple = 34000
factor = 5
sal          = 17000
sal_multiple = 34000
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2__BABCAAFB">
<p class="titleinexample">Example 6-9 Variable in Explicit Cursor Query&mdash;Result Set Change</p>
<pre dir="ltr">DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  factor        INTEGER := 2;
 
  CURSOR c1 IS
    SELECT salary, salary*factor FROM employees
    WHERE job_id LIKE &#39;AD_%&#39;;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;factor = &#39; || factor);
  <span class="bold">OPEN c1;  -- PL/SQL evaluates factor</span>
  LOOP
    FETCH c1 INTO sal, sal_multiple;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(&#39;sal          = &#39; || sal);
    DBMS_OUTPUT.PUT_LINE(&#39;sal_multiple = &#39; || sal_multiple);
  END LOOP;
  <span class="bold">CLOSE c1;</span>
 
  <span class="bold">factor := factor + 1;</span>
 
  DBMS_OUTPUT.PUT_LINE(&#39;factor = &#39; || factor);
  <span class="bold">OPEN c1;  -- PL/SQL evaluates factor</span>
  LOOP
    FETCH c1 INTO sal, sal_multiple;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(&#39;sal          = &#39; || sal);
    DBMS_OUTPUT.PUT_LINE(&#39;sal_multiple = &#39; || sal_multiple);
  END LOOP;
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">factor = 2
sal          = 4400
sal_multiple = 8800
sal          = 24000
sal_multiple = 48000
sal          = 17000
sal_multiple = 34000
sal          = 17000
sal_multiple = 34000
factor = 3
sal          = 4400
sal_multiple = 13200
sal          = 24000
sal_multiple = 72000
sal          = 17000
sal_multiple = 51000
sal          = 17000
sal_multiple = 51000
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS458"></a><a id="LNPLS225"></a>
<div class="props_rev_3"><a id="GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44"></a>
<h4 id="LNPLS-GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44" class="sect4">When Explicit Cursor Queries Need Column Aliases</h4>
<div>
<p>When an explicit cursor query includes a virtual column (an expression), that column must have an alias if either of the following is true:</p>
<ul style="list-style-type: disc;">
<li>
<p>You use the cursor to fetch into a record that was declared with <code class="codeph">%ROWTYPE</code>.</p>
</li>
<li>
<p>You want to reference the virtual column in your program.</p>
</li>
</ul>
<p>In <a href="static.htm#GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44__CHDCEGIF">Example 6-10</a>, the virtual column in the explicit cursor needs an alias for both of the preceding reasons.</p>
<div class="infoboxnotealso" id="GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44__GUID-A233946B-25CA-49F8-9493-FB44F67F35F2">
<p class="notep1">See Also:</p>
<p><a href="static.htm#GUID-25917214-FD91-499D-AB39-CE21484AB167__CJAIBIDJ">Example 6-21</a></p>
</div>
<div class="example" id="GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44__CHDCEGIF">
<p class="titleinexample">Example 6-10 Explicit Cursor with Virtual Column that Needs Alias</p>
<pre dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT employee_id,
           <span class="bold">(salary * .05) raise</span>
    FROM employees
    WHERE job_id LIKE &#39;%_MAN&#39;
    ORDER BY employee_id;
  <span class="bold">emp_rec c1%ROWTYPE;</span>
BEGIN
  OPEN c1;
  LOOP
    <span class="bold">FETCH c1 INTO emp_rec;</span>
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (
      &#39;Raise for employee #&#39; || emp_rec.employee_id ||
      &#39; is $&#39; || <span class="bold">emp_rec.raise</span>
    ); 
  END LOOP;
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Raise for employee #114 is $550
Raise for employee #120 is $400
Raise for employee #121 is $410
Raise for employee #122 is $395
Raise for employee #123 is $325
Raise for employee #124 is $368.445
Raise for employee #145 is $700
Raise for employee #146 is $675
Raise for employee #147 is $600
Raise for employee #148 is $550
Raise for employee #149 is $525
Raise for employee #201 is $650
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS460"></a><a id="LNPLS459"></a><a id="LNPLS564"></a>
<div class="props_rev_3"><a id="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20"></a>
<h4 id="LNPLS-GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20" class="sect4">Explicit Cursors that Accept Parameters</h4>
<div>
<p>You can create an explicit cursor that has formal parameters, and then pass different actual parameters to the cursor each time you open it. In the cursor query, you can use a formal cursor parameter anywhere that you can use a constant. Outside the cursor query, you cannot reference formal cursor parameters.</p>
<div class="infoboxnotealso" id="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__GUID-DB204128-EE4F-4115-A179-DD3CEC4B2DD9">
<p class="notep1">Tip:</p>
<p>To avoid confusion, use different names for formal and actual cursor parameters.</p>
</div>
<p><a href="static.htm#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__BABHBHIC">Example 6-11</a> creates an explicit cursor whose two formal parameters represent a job and its maximum salary. When opened with a specified job and maximum salary, the cursor query selects the employees with that job who are overpaid (for each such employee, the query selects the first and last name and amount overpaid). Next, the example creates a procedure that prints the cursor query result set (for information about procedures, see <a href="subprograms.htm#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B">PL/SQL Subprograms</a>). Finally, the example opens the cursor with one set of actual parameters, prints the result set, closes the cursor, opens the cursor with different actual parameters, prints the result set, and closes the cursor.</p>
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC">Formal Cursor Parameters with Default Values</a></p>
</li>
<li>
<p><a href="static.htm#GUID-D23657CD-9AC5-4690-B78A-018445D59FC7">Adding Formal Cursor Parameters with Default Values</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__GUID-FD37D50D-87B7-4FD3-8085-DC7DE7D3F544">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="explicit_cursor.htm#GUID-38C5DBA3-9DEC-4AF2-9B5E-7B721D11A77C" title="An explicit cursor is a named pointer to a private SQL area that stores information for processing a specific query or DML statement&mdash;typically, one that returns or affects multiple rows.">Explicit Cursor Declaration and Definition</a>&#34;</span> for more information about formal cursor parameters</p>
</li>
<li>
<p><span class="q">&#34;<a href="open_statement.htm#GUID-FB5A9CC3-655F-4AF4-8105-14CB39F2FEA8" title="The OPEN statement opens an explicit cursor, allocates database resources to process the associated query, identifies the result set, and positions the cursor before the first row of the result set.">OPEN Statement</a>&#34;</span> for more information about actual cursor parameters</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__BABHBHIC">
<p class="titleinexample">Example 6-11 Explicit Cursor that Accepts Parameters</p>
<pre dir="ltr">DECLARE
  CURSOR c <span class="bold">(job VARCHAR2, max_sal NUMBER)</span> IS
    SELECT last_name, first_name, (salary - <span class="bold">max_sal</span>) overpayment
    FROM employees
    WHERE job_id = <span class="bold">job</span>
    AND salary &gt; <span class="bold">max_sal</span>
    ORDER BY salary;
 
  PROCEDURE print_overpaid IS
    last_name_   employees.last_name%TYPE;
    first_name_  employees.first_name%TYPE;
    overpayment_      employees.salary%TYPE;
  BEGIN
    LOOP
      FETCH c INTO last_name_, first_name_, overpayment_;
      EXIT WHEN c%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(last_name_ || &#39;, &#39; || first_name_ ||
        &#39; (by &#39; || overpayment_ || &#39;)&#39;);
    END LOOP;
  END print_overpaid;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;----------------------&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;Overpaid Stock Clerks:&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;----------------------&#39;);
  <span class="bold">OPEN c(&#39;ST_CLERK&#39;, 5000);</span>
  print_overpaid; 
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE(&#39;-------------------------------&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;Overpaid Sales Representatives:&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;-------------------------------&#39;);
  <span class="bold">OPEN c(&#39;SA_REP&#39;, 10000);</span>
  print_overpaid; 
  CLOSE c;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">----------------------
Overpaid Stock Clerks:
----------------------
-------------------------------
Overpaid Sales Representatives:
-------------------------------
Vishney, Clara (by 500)
Abel, Ellen (by 1000)
Ozer, Lisa (by 1500)
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<a id="LNPLS465"></a><a id="LNPLS99874"></a>
<div class="props_rev_3"><a id="GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC"></a>
<h5 id="LNPLS-GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC" class="sect5">Formal Cursor Parameters with Default Values</h5>
<div>
<p>When you create an explicit cursor with formal parameters, you can specify default values for them. When a formal parameter has a default value, its corresponding actual parameter is optional. If you open the cursor without specifying the actual parameter, then the formal parameter has its default value.</p>
<p><a href="static.htm#GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC__BABHCIAC">Example 6-12</a> creates an explicit cursor whose formal parameter represents a location ID. The default value of the parameter is the location ID of company headquarters.</p>
<div class="example" id="GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC__BABHCIAC">
<p class="titleinexample">Example 6-12 Cursor Parameters with Default Values</p>
<pre dir="ltr">DECLARE
  CURSOR c (<span class="bold">location</span> NUMBER <span class="bold">DEFAULT 1700</span>) IS
    SELECT d.department_name,
           e.last_name manager,
           l.city
    FROM departments d, employees e, locations l
    WHERE l.location_id = <span class="bold">location</span>
      AND l.location_id = d.location_id
      AND d.department_id = e.department_id
    ORDER BY d.department_id;
 
  PROCEDURE print_depts IS
    dept_name  departments.department_name%TYPE;
    mgr_name   employees.last_name%TYPE;
    city_name  locations.city%TYPE;
  BEGIN
    LOOP
      FETCH c INTO dept_name, mgr_name, city_name;
      EXIT WHEN c%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(dept_name || &#39; (Manager: &#39; || mgr_name || &#39;)&#39;);
    END LOOP;
  END print_depts;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;DEPARTMENTS AT HEADQUARTERS:&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;--------------------------------&#39;);
  <span class="bold">OPEN c;</span>
  print_depts; 
  DBMS_OUTPUT.PUT_LINE(&#39;--------------------------------&#39;);
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE(&#39;DEPARTMENTS IN CANADA:&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;--------------------------------&#39;);
  <span class="bold">OPEN c(1800);</span> -- Toronto
  print_depts; 
  CLOSE c;
  <span class="bold">OPEN c(1900);</span> -- Whitehorse
  print_depts; 
  CLOSE c;
END;
/
 
</pre>
<p>Result is similar to:</p>
<pre dir="ltr">DEPARTMENTS AT HEADQUARTERS:
--------------------------------
Administration (Manager: Whalen)
Purchasing (Manager: Colmenares)
Purchasing (Manager: Baida)
Purchasing (Manager: Himuro)
Purchasing (Manager: Raphaely)
Purchasing (Manager: Khoo)
Purchasing (Manager: Tobias)
Executive (Manager: Kochhar)
Executive (Manager: De Haan)
Executive (Manager: King)
Finance (Manager: Popp)
Finance (Manager: Greenberg)
Finance (Manager: Faviet)
Finance (Manager: Chen)
Finance (Manager: Urman)
Finance (Manager: Sciarra)
Accounting (Manager: Gietz)
Accounting (Manager: Higgins)
--------------------------------
DEPARTMENTS IN CANADA:
--------------------------------
Marketing (Manager: Hartstein)
Marketing (Manager: Fay)
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS466"></a><a id="LNPLS99873"></a>
<div class="props_rev_3"><a id="GUID-D23657CD-9AC5-4690-B78A-018445D59FC7"></a>
<h5 id="LNPLS-GUID-D23657CD-9AC5-4690-B78A-018445D59FC7" class="sect5">Adding Formal Cursor Parameters with Default Values</h5>
<div>
<div class="section">
<p>If you add formal parameters to a cursor, and you specify default values for the added parameters, then you need not change existing references to the cursor. Compare <a href="static.htm#GUID-D23657CD-9AC5-4690-B78A-018445D59FC7__BABCBJGC">Example 6-13</a> to <a href="static.htm#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__BABHBHIC">Example 6-11</a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-D23657CD-9AC5-4690-B78A-018445D59FC7__BABCBJGC">
<p class="titleinexample">Example 6-13 Adding Formal Parameter to Existing Cursor</p>
<pre dir="ltr">DECLARE
  CURSOR c (job VARCHAR2, max_sal NUMBER,
            <span class="bold">hired DATE DEFAULT TO_DATE(&#39;31-DEC-1999&#39;, &#39;DD-MON-YYYY&#39;)</span>) IS
    SELECT last_name, first_name, (salary - max_sal) overpayment
    FROM employees
    WHERE job_id = job
    AND salary &gt; max_sal
    <span class="bold">AND hire_date &gt; hired</span>
    ORDER BY salary;
 
  PROCEDURE print_overpaid IS
    last_name_   employees.last_name%TYPE;
    first_name_  employees.first_name%TYPE;
    overpayment_      employees.salary%TYPE;
  BEGIN
    LOOP
      FETCH c INTO last_name_, first_name_, overpayment_;
      EXIT WHEN c%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(last_name_ || &#39;, &#39; || first_name_ ||
        &#39; (by &#39; || overpayment_ || &#39;)&#39;);
    END LOOP;
  END print_overpaid;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;-------------------------------&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;Overpaid Sales Representatives:&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;-------------------------------&#39;);
  OPEN c(&#39;SA_REP&#39;, 10000);  <span class="bold">-- existing reference</span>
  print_overpaid; 
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE(&#39;------------------------------------------------&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;Overpaid Sales Representatives Hired After 2004:&#39;);
  DBMS_OUTPUT.PUT_LINE(&#39;------------------------------------------------&#39;);
  OPEN c(&#39;SA_REP&#39;, 10000, <span class="bold">TO_DATE(&#39;31-DEC-2004&#39;, &#39;DD-MON-YYYY&#39;)</span>);
                          <span class="bold">-- new reference</span>
  print_overpaid; 
  CLOSE c;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">-------------------------------
Overpaid Sales Representatives:
-------------------------------
Vishney, Clara (by 500)
Abel, Ellen (by 1000)
Ozer, Lisa (by 1500)
------------------------------------------------
Overpaid Sales Representatives Hired After 2004:
------------------------------------------------
Vishney, Clara (by 500)
Ozer, Lisa (by 1500)
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS541"></a>
<div class="props_rev_3"><a id="GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D"></a>
<h4 id="LNPLS-GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D" class="sect4">Explicit Cursor Attributes</h4>
<div>
<p>The syntax for the value of an explicit cursor attribute is <span class="italic"><code class="codeph">cursor_name</code></span> immediately followed by <span class="italic"><code class="codeph">attribute</code></span> (for example, <code class="codeph">c1%ISOPEN</code>).</p>
<div class="infobox-note" id="GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D__GUID-DC0AC2F4-95E7-4366-ACC5-E226BF048DD6">
<p class="notep1">Note:</p>
<p>Explicit cursors and cursor variables (named cursors) have the same attributes. This topic applies to all named cursors except where noted.</p>
</div>
<p>The explicit cursor attributes are:</p>
<ul style="list-style-type: disc;">
<li>
<p>%ISOPEN Attribute: Is the Cursor Open?</p>
</li>
<li>
<p>%FOUND Attribute: Has a Row Been Fetched?</p>
</li>
<li>
<p>%NOTFOUND Attribute: Has No Row Been Fetched?</p>
</li>
<li>
<p>%ROWCOUNT Attribute: How Many Rows Were Fetched?</p>
</li>
</ul>
<p>If an explicit cursor is not open, referencing any attribute except <code class="codeph">%ISOPEN</code> raises the predefined exception <code class="codeph">INVALID_CURSOR</code>.</p>
<div class="infoboxnotealso" id="GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D__GUID-E5596E88-D8EF-448C-9AA4-705A244B5C89">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="named_cursor_attribute.htm#GUID-CD8D8415-FF19-4D81-99BA-7825FD40CC96" title="Every named cursor (explicit cursor or cursor variable) has four attributes, each of which returns information about the execution of a DML statement.">Named Cursor Attribute</a>&#34;</span> for complete syntax and semantics of named cursor (explicit cursor and cursor variable) attributes</p>
</div>
</div>
<a id="LNPLS545"></a><a id="LNPLS544"></a>
<div class="props_rev_3"><a id="GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80"></a>
<h5 id="LNPLS-GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80" class="sect5">%ISOPEN Attribute: Is the Cursor Open?</h5>
<div>
<p><code class="codeph">%ISOPEN</code> returns <code class="codeph">TRUE</code> if its explicit cursor is open; <code class="codeph">FALSE</code> otherwise.</p>
<p><code class="codeph">%ISOPEN</code> is useful for:</p>
<ul style="list-style-type: disc;">
<li>
<p>Checking that an explicit cursor is not already open before you try to open it.</p>
<p>If you try to open an explicit cursor that is already open, PL/SQL raises the predefined exception <code class="codeph">CURSOR_ALREADY_OPEN</code>. You must close an explicit cursor before you can reopen it.</p>
<div class="infobox-note" id="GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80__GUID-8630BBEF-BC2D-4856-BFCE-247A5BC1E80B">
<p class="notep1">Note:</p>
<p>The preceding paragraph does not apply to cursor variables.</p>
</div>
</li>
<li>
<p>Checking that an explicit cursor is open before you try to close it.</p>
</li>
</ul>
<p><a href="static.htm#GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80__BABJHBGA">Example 6-14</a> opens the explicit cursor <code class="codeph">c1</code> only if it is not open and closes it only if it is open.</p>
<div class="example" id="GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80__BABJHBGA">
<p class="titleinexample">Example 6-14 %ISOPEN Explicit Cursor Attribute</p>
<pre dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT last_name, salary FROM employees
    WHERE ROWNUM &lt; 11;

  the_name employees.last_name%TYPE;
  the_salary employees.salary%TYPE;
BEGIN
  IF <span class="bold">NOT c1%ISOPEN</span> THEN
    OPEN c1;
  END IF;

  FETCH c1 INTO the_name, the_salary;

  IF <span class="bold">c1%ISOPEN</span> THEN
    CLOSE c1;
  END IF;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS543"></a><a id="LNPLS542"></a>
<div class="props_rev_3"><a id="GUID-585F5F92-FB36-4950-AF08-C3AA63DB9470"></a>
<h5 id="LNPLS-GUID-585F5F92-FB36-4950-AF08-C3AA63DB9470" class="sect5">%FOUND Attribute: Has a Row Been Fetched?</h5>
<div>
<p><code class="codeph">%FOUND</code> returns:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">NULL</code> after the explicit cursor is opened but before the first fetch</p>
</li>
<li>
<p><code class="codeph">TRUE</code> if the most recent fetch from the explicit cursor returned a row</p>
</li>
<li>
<p><code class="codeph">FALSE</code> otherwise</p>
</li>
</ul>
<p><code class="codeph">%FOUND</code> is useful for determining whether there is a fetched row to process.</p>
<p><a href="static.htm#GUID-585F5F92-FB36-4950-AF08-C3AA63DB9470__CJAEDJEE">Example 6-15</a> loops through a result set, printing each fetched row and exiting when there are no more rows to fetch.</p>
<div class="example" id="GUID-585F5F92-FB36-4950-AF08-C3AA63DB9470__CJAEDJEE">
<p class="titleinexample">Example 6-15 %FOUND Explicit Cursor Attribute</p>
<pre dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT last_name, salary FROM employees
    WHERE ROWNUM &lt; 11
    ORDER BY last_name;

  my_ename   employees.last_name%TYPE;
  my_salary  employees.salary%TYPE;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO my_ename, my_salary;
    IF <span class="bold">c1%FOUND</span> THEN  -- fetch succeeded
      DBMS_OUTPUT.PUT_LINE(&#39;Name = &#39; || my_ename || &#39;, salary = &#39; || my_salary);
    ELSE  -- fetch failed
      EXIT;
    END IF;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Name = Austin, salary = 4800
Name = De Haan, salary = 17000
Name = Ernst, salary = 6000
Name = Faviet, salary = 9000
Name = Greenberg, salary = 12008
Name = Hunold, salary = 9000
Name = King, salary = 24000
Name = Kochhar, salary = 17000
Name = Lorentz, salary = 4200
Name = Pataballa, salary = 4800
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS547"></a><a id="LNPLS546"></a>
<div class="props_rev_3"><a id="GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5"></a>
<h5 id="LNPLS-GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5" class="sect5">%NOTFOUND Attribute: Has No Row Been Fetched?</h5>
<div>
<p><code class="codeph">%NOTFOUND</code> (the logical opposite of <code class="codeph">%FOUND</code>) returns:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">NULL</code> after the explicit cursor is opened but before the first fetch</p>
</li>
<li>
<p><code class="codeph">FALSE</code> if the most recent fetch from the explicit cursor returned a row</p>
</li>
<li>
<p><code class="codeph">TRUE</code> otherwise</p>
</li>
</ul>
<p><code class="codeph">%NOTFOUND</code> is useful for exiting a loop when <code class="codeph">FETCH</code> fails to return a row, as in <a href="static.htm#GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5__CJAHDJIF">Example 6-16</a>.</p>
<div class="example" id="GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5__CJAHDJIF">
<p class="titleinexample">Example 6-16 %NOTFOUND Explicit Cursor Attribute</p>
<pre dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT last_name, salary FROM employees
    WHERE ROWNUM &lt; 11
    ORDER BY last_name;

   my_ename   employees.last_name%TYPE;
   my_salary  employees.salary%TYPE;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO my_ename, my_salary;
    IF <span class="bold">c1%NOTFOUND</span> THEN -- fetch failed
      EXIT;
    ELSE  -- fetch succeeded
      DBMS_OUTPUT.PUT_LINE
        (&#39;Name = &#39; || my_ename || &#39;, salary = &#39; || my_salary);
    END IF;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Name = Austin, salary = 4800
Name = De Haan, salary = 17000
Name = Ernst, salary = 6000
Name = Faviet, salary = 9000
Name = Greenberg, salary = 12008
Name = Hunold, salary = 9000
Name = King, salary = 24000
Name = Kochhar, salary = 17000
Name = Lorentz, salary = 4200
Name = Pataballa, salary = 4800
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS549"></a><a id="LNPLS548"></a>
<div class="props_rev_3"><a id="GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09"></a>
<h5 id="LNPLS-GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09" class="sect5">%ROWCOUNT Attribute: How Many Rows Were Fetched?</h5>
<div>
<p><code class="codeph">%ROWCOUNT</code> returns:</p>
<ul style="list-style-type: disc;">
<li>
<p>Zero after the explicit cursor is opened but before the first fetch</p>
</li>
<li>
<p>Otherwise, the number of rows fetched (an <code class="codeph">INTEGER</code>)</p>
<div class="infobox-note" id="GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09__GUID-6A6BA1B8-8298-4C00-BFDC-0C2818EB2B72">
<p class="notep1">Note:</p>
<p>If a server is Oracle Database 12<span class="italic">c</span> or later and its client is Oracle Database 11<span class="italic">g</span>2 or earlier (or the reverse), then the maximum number that <code class="codeph">SQL%ROWCOUNT</code> returns is 4,294,967,295.</p>
</div>
</li>
</ul>
<p><a href="static.htm#GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09__CJAFIFIB">Example 6-17</a> numbers and prints the rows that it fetches and prints a message after fetching the fifth row.</p>
<div class="example" id="GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09__CJAFIFIB">
<p class="titleinexample">Example 6-17 %ROWCOUNT Explicit Cursor Attribute</p>
<pre dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT last_name FROM employees
    WHERE ROWNUM &lt; 11
    ORDER BY last_name;

  name  employees.last_name%TYPE;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO name;
    EXIT WHEN c1%NOTFOUND OR c1%NOTFOUND IS NULL;
    DBMS_OUTPUT.PUT_LINE(<span class="bold">c1%ROWCOUNT</span> || &#39;. &#39; || name);
    <span class="bold">IF c1%ROWCOUNT = 5</span> THEN
       DBMS_OUTPUT.PUT_LINE(&#39;--- Fetched 5th row ---&#39;);
    END IF;
  END LOOP;
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">1. Abel
2. Ande
3. Atkinson
4. Austin
5. Baer
--- Fetched 5th row ---
6. Baida
7. Banda
8. Bates
9. Bell
10. Bernstein
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
</div>
<a id="LNPLS467"></a><a id="LNPLS00603"></a>
<div class="props_rev_3"><a id="GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D"></a>
<h2 id="LNPLS-GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D" class="sect2">Processing Query Result Sets</h2>
<div>
<p>In PL/SQL, as in traditional database programming, you use cursors to process query result sets. However, in PL/SQL, you can use either implicit or explicit cursors.</p>
<div class="section">
<p>The former need less code, but the latter are more flexible. For example, explicit cursors can accept parameters.</p>
<p>The following PL/SQL statements use implicit cursors that PL/SQL defines and manages for you:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">SELECT</code> <code class="codeph">INTO</code></p>
</li>
<li>
<p>Implicit cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code></p>
</li>
</ul>
<p>The following PL/SQL statements use explicit cursors:</p>
<ul style="list-style-type: disc;">
<li>
<p>Explicit cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code></p>
<p>You define the explicit cursor, but PL/SQL manages it while the statement runs.</p>
</li>
<li>
<p><code class="codeph">OPEN</code>, <code class="codeph">FETCH</code>, and <code class="codeph">CLOSE</code></p>
<p>You define and manage the explicit cursor.</p>
</li>
</ul>
<div class="infobox-note" id="GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D__GUID-D1C31C73-B244-40DF-8E7A-1AFFF5B55283">
<p class="notep1">Note:</p>
<p>If a query returns no rows, PL/SQL raises the exception <code class="codeph">NO_DATA_FOUND</code>.</p>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647" title="Using an implicit cursor, the SELECT INTO statement retrieves values from one or more database tables (as the SQL SELECT statement does) and stores them in variables (which the SQL SELECT statement does not do).">Processing Query Result Sets With SELECT INTO Statements</a></p>
</li>
<li>
<p><a href="static.htm#GUID-25917214-FD91-499D-AB39-CE21484AB167" title="The cursor FOR LOOP statement lets you run a SELECT statement and then immediately loop through the rows of the result set.">Processing Query Result Sets With Cursor FOR LOOP Statements</a></p>
</li>
<li>
<p><a href="static.htm#GUID-BCCE0985-AB78-48B8-A453-F44FCC4DA595" title="For full control over query result set processing, declare explicit cursors and manage them with the statements OPEN, FETCH, and CLOSE.">Processing Query Result Sets With Explicit Cursors, OPEN, FETCH, and CLOSE</a></p>
</li>
<li>
<p><a href="static.htm#GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70" title="If you process a query result set by looping through it and running another query for each row, then you can improve performance by removing the second query from inside the loop and making it a subquery of the first query.">Processing Query Result Sets with Subqueries</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D__GUID-9F4F9353-7798-4A67-83C1-53E7C7C12A96">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20">Explicit Cursors that Accept Parameters</a>&#34;</span></p>
</li>
<li>
<p><a class="olink ADFNS00903" target="_blank" href="../ADFNS/adfns_packages.htm#ADFNS00903"><span class="italic">Oracle Database Development Guide</span></a> for information about returning result sets to clients</p>
</li>
<li>
<p><span class="q">&#34;<a href="exception_handler.htm#GUID-3FECF29B-A240-4191-A635-92C612D00C4D" title="An exception handler processes a raised exception.">Exception Handler</a>&#34;</span> for information about handling exceptions</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="LNPLS476"></a><a id="LNPLS551"></a>
<div class="props_rev_3"><a id="GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647"></a>
<h3 id="LNPLS-GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647" class="sect3">Processing Query Result Sets With SELECT INTO Statements</h3>
<div>
<p>Using an implicit cursor, the <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement retrieves values from one or more database tables (as the SQL <code class="codeph">SELECT</code> statement does) and stores them in variables (which the SQL <code class="codeph">SELECT</code> statement does not do).</p>
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-93E44519-5370-4E5B-B157-4C12509DFDEF">Handling Single-Row Result Sets</a></p>
</li>
<li>
<p><a href="static.htm#GUID-8E633AC0-3EA2-4500-8338-09D39C24FE92">Handling Large Multiple-Row Result Sets</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647__GUID-32355F98-83A3-46F8-9FE3-54B6B2FA1742">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="selectinto_statement.htm#GUID-6E14E04D-4344-45F3-BE80-979DD26C7A90" title="The SELECT INTO statement retrieves values from one or more database tables (as the SQL SELECT statement does) and stores them in variables (which the SQL SELECT statement does not do).">SELECT INTO Statement</a>&#34;</span> for its complete syntax and semantics</p>
</div>
</div>
<!-- class="section" --></div>
<a id="LNPLS99881"></a>
<div class="props_rev_3"><a id="GUID-93E44519-5370-4E5B-B157-4C12509DFDEF"></a>
<h4 id="LNPLS-GUID-93E44519-5370-4E5B-B157-4C12509DFDEF" class="sect4">Handling Single-Row Result Sets</h4>
<div>
<div class="section">
<p>If you expect the query to return only one row, then use the <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement to store values from that row in either one or more scalar variables (see <span class="q">&#34;<a href="fundamentals.htm#GUID-EDB2297F-A80D-48B3-8EF1-5437BF981CC2">Assigning Values to Variables with the SELECT INTO Statement</a>&#34;</span>) or one record variable (see <span class="q">&#34;<a href="composites.htm#GUID-785E5E7E-7FCD-4291-8F62-389814A261EC">Using SELECT INTO to Assign a Row to a Record Variable</a>&#34;</span>).</p>
<p>If the query might return multiple rows, but you care about only the <span class="italic">n</span>th row, then restrict the result set to that row with the clause <code class="codeph">WHERE</code> <code class="codeph">ROWNUM=</code><span class="italic"><code class="codeph">n</code></span>. For more information about the <code class="codeph">ROWNUM</code> pseudocolumn, see <a class="olink SQLRF00255" target="_blank" href="../SQLRF/pseudocolumns009.htm#SQLRF00255"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS99880"></a>
<div class="props_rev_3"><a id="GUID-8E633AC0-3EA2-4500-8338-09D39C24FE92"></a>
<h4 id="LNPLS-GUID-8E633AC0-3EA2-4500-8338-09D39C24FE92" class="sect4">Handling Large Multiple-Row Result Sets</h4>
<div>
<div class="section">
<p>If you must assign a large quantity of table data to variables, Oracle recommends using the <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement with the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause. This statement retrieves an entire result set into one or more collection variables. For more information, see <span class="q">&#34;<a href="tuning.htm#GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE" title="The SELECT INTO statement with the BULK COLLECT clause (also called the SELECT BULK COLLECT INTO statement) selects an entire result set into one or more collection variables.">SELECT INTO Statement with BULK COLLECT Clause</a>&#34;</span>.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="LNPLS477"></a><a id="LNPLS481"></a><a id="LNPLS565"></a><a id="LNPLS559"></a><a id="LNPLS553"></a>
<div class="props_rev_3"><a id="GUID-25917214-FD91-499D-AB39-CE21484AB167"></a>
<h3 id="LNPLS-GUID-25917214-FD91-499D-AB39-CE21484AB167" class="sect3">Processing Query Result Sets With Cursor FOR LOOP Statements</h3>
<div>
<p>The cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement lets you run a <code class="codeph">SELECT</code> statement and then immediately loop through the rows of the result set.</p>
<div class="section">
<p>This statement can use either an implicit or explicit cursor (but not a cursor variable).</p>
<p>If you use the <code class="codeph">SELECT</code> statement only in the cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement, then specify the <code class="codeph">SELECT</code> statement inside the cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement, as in <a href="static.htm#GUID-25917214-FD91-499D-AB39-CE21484AB167__CHDBJBJE">Example 6-18</a>. This form of the cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement uses an implicit cursor, and is called an <span class="bold">implicit cursor</span> <span class="bold"><code class="codeph">FOR</code></span> <span class="bold"><code class="codeph">LOOP</code></span> <span class="bold">statement</span>. Because the implicit cursor is internal to the statement, you cannot reference it with the name <code class="codeph">SQL</code>.</p>
<p>If you use the <code class="codeph">SELECT</code> statement multiple times in the same PL/SQL unit, then define an explicit cursor for it and specify that cursor in the cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement, as in <a href="static.htm#GUID-25917214-FD91-499D-AB39-CE21484AB167__BABGJBEA">Example 6-19</a>. This form of the cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement is called an <span class="bold">explicit cursor</span> <span class="bold"><code class="codeph">FOR</code></span> <span class="bold"><code class="codeph">LOOP</code></span> <span class="bold">statement</span>. You can use the same explicit cursor elsewhere in the same PL/SQL unit.</p>
<p>The cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement implicitly declares its loop index as a <code class="codeph">%ROWTYPE</code> record variable of the type that its cursor returns. This record is local to the loop and exists only during loop execution. Statements inside the loop can reference the record and its fields. They can reference virtual columns only by aliases, as in <a href="static.htm#GUID-25917214-FD91-499D-AB39-CE21484AB167__CJAIBIDJ">Example 6-21</a>.</p>
<p>After declaring the loop index record variable, the <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement opens the specified cursor. With each iteration of the loop, the <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement fetches a row from the result set and stores it in the record. When there are no more rows to fetch, the cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement closes the cursor. The cursor also closes if a statement inside the loop transfers control outside the loop or if PL/SQL raises an exception.</p>
<div class="infoboxnotealso" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__GUID-9AA02AEA-24F7-4AC9-BADE-6FBC8077FC72">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="cursor_for_loop_statement.htm#GUID-62C9A3C8-82F9-468F-8D84-81672E67736D" title="The cursor FOR LOOP statement implicitly declares its loop index as a record variable of the row type that a specified cursor returns, and then opens a cursor.">Cursor FOR LOOP Statement</a>&#34;</span> for its complete syntax and semantics</p>
</div>
<div class="infobox-note" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__GUID-130BE73A-42C2-4AC5-91B9-C542A371CD3E">
<p class="notep1">Note:</p>
<p>When an exception is raised inside a cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement, the cursor closes before the exception handler runs. Therefore, the values of explicit cursor attributes are not available in the handler.</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__CHDBJBJE">
<p class="titleinexample">Example 6-18 Implicit Cursor FOR LOOP Statement</p>
<p>In this example, an implicit cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement prints the last name and job ID of every clerk whose manager has an ID greater than 120.</p>
<pre dir="ltr">BEGIN
  FOR item IN (
    SELECT last_name, job_id
    FROM employees
    WHERE job_id LIKE &#39;%CLERK%&#39;
    AND manager_id &gt; 120
    ORDER BY last_name
  )
  LOOP
    DBMS_OUTPUT.PUT_LINE
      (&#39;Name = &#39; || item.last_name || &#39;, Job = &#39; || item.job_id);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Name = Atkinson, Job = ST_CLERK
Name = Bell, Job = SH_CLERK
Name = Bissot, Job = ST_CLERK
...
Name = Walsh, Job = SH_CLERK
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__BABGJBEA">
<p class="titleinexample">Example 6-19 Explicit Cursor FOR LOOP Statement</p>
<p>This exmaple is like <a href="static.htm#GUID-25917214-FD91-499D-AB39-CE21484AB167__CHDBJBJE">Example 6-18</a>, except that it uses an explicit cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement.</p>
<pre dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT last_name, job_id FROM employees
    WHERE job_id LIKE &#39;%CLERK%&#39; AND manager_id &gt; 120
    ORDER BY last_name;
BEGIN
  FOR item IN c1
  LOOP
    DBMS_OUTPUT.PUT_LINE
      (&#39;Name = &#39; || item.last_name || &#39;, Job = &#39; || item.job_id);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Name = Atkinson, Job = ST_CLERK
Name = Bell, Job = SH_CLERK
Name = Bissot, Job = ST_CLERK
...
Name = Walsh, Job = SH_CLERK
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__I45976">
<p class="titleinexample">Example 6-20 Passing Parameters to Explicit Cursor FOR LOOP Statement</p>
<p>This example declares and defines an explicit cursor that accepts two parameters, and then uses it in an explicit cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement to display the wages paid to employees who earn more than a specified wage in a specified department.</p>
<pre dir="ltr">DECLARE
  CURSOR c1 <span class="bold">(job VARCHAR2, max_wage NUMBER)</span> IS
    SELECT * FROM employees
    WHERE job_id = job
    AND salary &gt; max_wage;
BEGIN
  FOR person IN <span class="bold">c1(&#39;ST_CLERK&#39;, 3000)</span>
  LOOP
     -- process data record
    DBMS_OUTPUT.PUT_LINE (
      &#39;Name = &#39; || person.last_name || &#39;, salary = &#39; ||
      person.salary || &#39;, Job Id = &#39; || person.job_id
    );
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Name = Nayer, salary = 3200, Job Id = ST_CLERK
Name = Bissot, salary = 3300, Job Id = ST_CLERK
Name = Mallin, salary = 3300, Job Id = ST_CLERK
Name = Ladwig, salary = 3600, Job Id = ST_CLERK
Name = Stiles, salary = 3200, Job Id = ST_CLERK
Name = Rajs, salary = 3500, Job Id = ST_CLERK
Name = Davies, salary = 3100, Job Id = ST_CLERK
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__CJAIBIDJ">
<p class="titleinexample">Example 6-21 Cursor FOR Loop References Virtual Columns</p>
<p>In this example, the implicit cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> references virtual columns by their aliases, <code class="codeph">full_name</code> and <code class="codeph">dream_salary</code>.</p>
<pre dir="ltr">BEGIN
  FOR item IN (
    SELECT first_name || &#39; &#39; || last_name AS <span class="bold">full_name</span>,
           salary * 10                    AS <span class="bold">dream_salary</span> 
    FROM employees
    WHERE ROWNUM &lt;= 5
    ORDER BY dream_salary DESC, last_name ASC
  ) LOOP
    DBMS_OUTPUT.PUT_LINE
      (item.<span class="bold">full_name</span> || &#39; dreams of making &#39; || item.<span class="bold">dream_salary</span>);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Stephen King dreams of making 240000
Lex De Haan dreams of making 170000
Neena Kochhar dreams of making 170000
Alexander Hunold dreams of making 90000
Bruce Ernst dreams of making 60000
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS554"></a>
<div class="props_rev_3"><a id="GUID-BCCE0985-AB78-48B8-A453-F44FCC4DA595"></a>
<h3 id="LNPLS-GUID-BCCE0985-AB78-48B8-A453-F44FCC4DA595" class="sect3">Processing Query Result Sets With Explicit Cursors, OPEN, FETCH, and CLOSE</h3>
<div>
<p>For full control over query result set processing, declare explicit cursors and manage them with the statements OPEN, FETCH, and CLOSE.</p>
<div class="section">
<p>This result set processing technique is more complicated than the others, but it is also more flexible. For example, you can:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Process multiple result sets in parallel, using multiple cursors.</p>
</li>
<li>
<p>Process multiple rows in a single loop iteration, skip rows, or split the processing into multiple loops.</p>
</li>
<li>
<p>Specify the query in one PL/SQL unit but retrieve the rows in another.</p>
</li>
</ul>
<p>For instructions and examples, see <span class="q">&#34;<a href="static.htm#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">Explicit Cursors</a>&#34;</span>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS561"></a><a id="LNPLS563"></a><a id="LNPLS00604"></a>
<div class="props_rev_3"><a id="GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70"></a>
<h3 id="LNPLS-GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70" class="sect3">Processing Query Result Sets with Subqueries</h3>
<div>
<p>If you process a query result set by looping through it and running another query for each row, then you can improve performance by removing the second query from inside the loop and making it a subquery of the first query.</p>
<div class="section">
<p>While an ordinary subquery is evaluated for each table, a <span class="bold">correlated subquery</span> is evaluated for each row.</p>
<p>For more information about subqueries, see <a class="olink SQLRF52357" target="_blank" href="../SQLRF/queries007.htm#SQLRF52357"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70__CJABHDCB">
<p class="titleinexample">Example 6-22 Subquery in FROM Clause of Parent Query</p>
<p>This example defines explicit cursor <code class="codeph">c1</code> with a query whose <code class="codeph">FROM</code> clause contains a subquery.</p>
<pre dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT t1.department_id, department_name, staff
    FROM departments t1,
         <span class="bold">( SELECT department_id, COUNT(*) AS staff</span>
           <span class="bold">FROM employees</span>
           <span class="bold">GROUP BY department_id</span>
         <span class="bold">)</span> t2
    WHERE (t1.department_id = t2.department_id) AND staff &gt;= 5
    ORDER BY staff;

BEGIN
   FOR dept IN c1
   LOOP
     DBMS_OUTPUT.PUT_LINE (&#39;Department = &#39;
       || dept.department_name || &#39;, staff = &#39; || dept.staff);
   END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Department = IT, staff = 5
Department = Finance, staff = 6
Department = Purchasing, staff = 6
Department = Sales, staff = 34
Department = Shipping, staff = 45
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70__BABCEJBA">
<p class="titleinexample">Example 6-23 Correlated Subquery</p>
<p>This example returns the name and salary of each employee whose salary exceeds the departmental average. For each row in the table, the correlated subquery computes the average salary for the corresponding department.</p>
<pre dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT department_id, last_name, salary
    FROM employees t
    WHERE salary &gt; <span class="bold">( SELECT AVG(salary)</span>
                     <span class="bold">FROM employees</span>
                     <span class="bold">WHERE t.department_id = department_id</span>
                   )
    ORDER BY department_id, last_name;
BEGIN
  FOR person IN c1
  LOOP
    DBMS_OUTPUT.PUT_LINE(&#39;Making above-average salary = &#39; || person.last_name);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Making above-average salary = Hartstein
Making above-average salary = Raphaely
Making above-average salary = Bell
...
Making above-average salary = Higgins
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS482"></a><a id="LNPLS00605"></a>
<div class="props_rev_3"><a id="GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5"></a>
<h2 id="LNPLS-GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" class="sect2">Cursor Variables</h2>
<div>
<p>A <span class="bold">cursor variable</span> is like an explicit cursor, except that:</p>
<ul style="list-style-type: disc;">
<li>
<p>It is not limited to one query.</p>
<p>You can open a cursor variable for a query, process the result set, and then use the cursor variable for another query.</p>
</li>
<li>
<p>You can assign a value to it.</p>
</li>
<li>
<p>You can use it in an expression.</p>
</li>
<li>
<p>It can be a subprogram parameter.</p>
<p>You can use cursor variables to pass query result sets between subprograms.</p>
</li>
<li>
<p>It can be a host variable.</p>
<p>You can use cursor variables to pass query result sets between PL/SQL stored subprograms and their clients.</p>
</li>
<li>
<p>It cannot accept parameters.</p>
<p>You cannot pass parameters to a cursor variable, but you can pass whole queries to it. The queries can include variables.</p>
</li>
</ul>
<p>A cursor variable has this flexibility because it is a pointer; that is, its value is the address of an item, not the item itself.</p>
<p>Before you can reference a cursor variable, you must make it point to a SQL work area, either by opening it or by assigning it the value of an open PL/SQL cursor variable or open host cursor variable.</p>
<div class="infobox-note" id="GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5__GUID-8DFBB3C0-B415-451C-90CC-3001FBAC0E39">
<p class="notep1">Note:</p>
<p>Cursor variables and explicit cursors are not interchangeable&mdash;you cannot use one where the other is expected. For example, you cannot reference a cursor variable in a cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement.</p>
</div>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-470A7A99-888A-46C2-BDAF-D4710E650F27" title="To create a cursor variable, either declare a variable of the predefined type SYS_REFCURSOR or define a REF CURSOR type and then declare a variable of that type.">Creating Cursor Variables</a></p>
</li>
<li>
<p><a href="static.htm#GUID-87B4D958-520C-4483-BC63-2D1FE4C4CC01">Opening and Closing Cursor Variables</a></p>
</li>
<li>
<p><a href="static.htm#GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2" title="After opening a cursor variable, you can fetch the rows of the query result set with the FETCH statement.">Fetching Data with Cursor Variables</a></p>
</li>
<li>
<p><a href="static.htm#GUID-7251E068-86C3-4B82-A8CE-54E0C9B9FCB2" title="You can assign to a PL/SQL cursor variable the value of another PL/SQL cursor variable or host cursor variable.">Assigning Values to Cursor Variables</a></p>
</li>
<li>
<p><a href="static.htm#GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C" title="The query associated with a cursor variable can reference any variable in its scope.">Variables in Cursor Variable Queries</a></p>
</li>
<li>
<p><a href="static.htm#GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248">Querying a Collection</a></p>
</li>
<li>
<p><a href="static.htm#GUID-1361A503-BA2D-400B-987A-59B2824E316E">Cursor Variable Attributes</a></p>
</li>
<li>
<p><a href="static.htm#GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619" title="You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.">Cursor Variables as Subprogram Parameters</a></p>
</li>
<li>
<p><a href="static.htm#GUID-04CBBBFB-959B-4991-9580-521DC6156489" title="You can use a cursor variable as a host variable, which makes it useful for passing query results between PL/SQL stored subprograms and their clients.">Cursor Variables as Host Variables</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5__GUID-A8A3AA92-B472-4461-81DD-776DE1D0965D">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">Explicit Cursors</a>&#34;</span> for more information about explicit cursors</p>
</li>
<li>
<p><span class="q">&#34;<a href="cursor_variable.htm#GUID-CE884B31-07F0-46AA-8067-EBAF73821F3D__CJABEBDA">Restrictions on Cursor Variables</a>&#34;</span></p>
</li>
<li>
<p><a class="olink ADFNS159" target="_blank" href="../ADFNS/adfns_packages.htm#ADFNS159"><span class="italic">Oracle Database Development Guide</span></a> for advantages of cursor variables</p>
</li>
<li>
<p><a class="olink ADFNS160" target="_blank" href="../ADFNS/adfns_packages.htm#ADFNS160"><span class="italic">Oracle Database Development Guide</span></a> for disadvantages of cursor variables</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="LNPLS483"></a><a id="LNPLS571"></a><a id="LNPLS568"></a>
<div class="props_rev_3"><a id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27"></a>
<h3 id="LNPLS-GUID-470A7A99-888A-46C2-BDAF-D4710E650F27" class="sect3">Creating Cursor Variables</h3>
<div>
<p>To create a cursor variable, either declare a variable of the predefined type <code class="codeph">SYS_REFCURSOR</code> or define a <code class="codeph">REF</code> <code class="codeph">CURSOR</code> type and then declare a variable of that type.</p>
<div class="section">
<div class="infobox-note" id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__GUID-1451E4B1-0D00-451E-A2F3-6C2186557C9A">
<p class="notep1">Note:</p>
<p>Informally, a cursor variable is sometimes called a <code class="codeph">REF</code> <code class="codeph">CURSOR</code>).</p>
</div>
<p>The basic syntax of a <code class="codeph">REF</code> <code class="codeph">CURSOR</code> type definition is:</p>
<pre dir="ltr">TYPE <span class="italic">type_name</span> IS REF CURSOR [ RETURN <span class="italic">return_type</span> ]
</pre>
<p>(For the complete syntax and semantics, see <span class="q">&#34;<a href="cursor_variable.htm#GUID-CE884B31-07F0-46AA-8067-EBAF73821F3D" title="A cursor variable is like an explicit cursor that is not limited to one query.">Cursor Variable Declaration</a>&#34;</span>.)</p>
<p>If you specify <span class="italic"><code class="codeph">return_type</code></span>, then the <code class="codeph">REF</code> <code class="codeph">CURSOR</code> type and cursor variables of that type are <span class="bold">strong</span>; if not, they are <span class="bold">weak</span>. <code class="codeph">SYS_REFCURSOR</code> and cursor variables of that type are weak.</p>
<p>With a strong cursor variable, you can associate only queries that return the specified type. With a weak cursor variable, you can associate any query.</p>
<p>Weak cursor variables are more error-prone than strong ones, but they are also more flexible. Weak <code class="codeph">REF</code> <code class="codeph">CURSOR</code> types are interchangeable with each other and with the predefined type <code class="codeph">SYS_REFCURSOR</code>. You can assign the value of a weak cursor variable to any other weak cursor variable.</p>
<p>You can assign the value of a strong cursor variable to another strong cursor variable only if both cursor variables have the same type (not merely the same return type).</p>
<div class="infobox-note" id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__GUID-75DC04C0-C04D-4CA1-AD89-F5E3623EB8FB">
<p class="notep1">Note:</p>
<p>You can partition weak cursor variable arguments to table functions only with the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> <code class="codeph">ANY</code> clause, not with <code class="codeph">PARTITION</code> <code class="codeph">BY</code> <code class="codeph">RANGE</code> or <code class="codeph">PARTITION</code> <code class="codeph">BY</code> <code class="codeph">HASH</code>. For syntax and semantics, see <span class="q">&#34;<a href="create_function.htm#GUID-B71BC5BD-B87C-4054-AAA5-213E856651F2__CIHJFAGA">parallel_enable_clause ::=</a>&#34;</span> and <span class="q">&#34;<a href="create_function.htm#GUID-B71BC5BD-B87C-4054-AAA5-213E856651F2__CIHBCCBF">parallel_enable_clause</a>&#34;</span>.</p>
</div>
<p><a href="static.htm#GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__BABFHFHH">Example 6-24</a> defines strong and weak <code class="codeph">REF</code> <code class="codeph">CURSOR</code> types, variables of those types, and a variable of the predefined type <code class="codeph">SYS_REFCURSOR</code>.</p>
<p>In <a href="static.htm#GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__BABHIJGD">Example 6-25</a>, <span class="italic"><code class="codeph">return_type</code></span> is a user-defined <code class="codeph">RECORD</code> type.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__BABFHFHH">
<p class="titleinexample">Example 6-24 Cursor Variable Declarations</p>
<pre dir="ltr">DECLARE
  TYPE empcurtyp IS REF CURSOR <span class="bold">RETURN employees%ROWTYPE</span>;  -- strong type
  TYPE genericcurtyp IS REF CURSOR;                       -- weak type

  cursor1  empcurtyp;       -- strong cursor variable
  cursor2  genericcurtyp;   -- weak cursor variable
  my_cursor SYS_REFCURSOR;  -- weak cursor variable

  TYPE deptcurtyp IS REF CURSOR <span class="bold">RETURN departments%ROWTYPE</span>;  -- strong type
  dept_cv deptcurtyp;  -- strong cursor variable
BEGIN
  NULL;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__BABHIJGD">
<p class="titleinexample">Example 6-25 Cursor Variable with User-Defined Return Type</p>
<pre dir="ltr">DECLARE
  <span class="bold">TYPE EmpRecTyp IS RECORD</span> (
    employee_id NUMBER,
    last_name VARCHAR2(25),
    salary   NUMBER(8,2));

  TYPE EmpCurTyp IS REF CURSOR <span class="bold">RETURN EmpRecTyp</span>;
  emp_cv EmpCurTyp;
BEGIN
  NULL;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS575"></a>
<div class="props_rev_3"><a id="GUID-87B4D958-520C-4483-BC63-2D1FE4C4CC01"></a>
<h3 id="LNPLS-GUID-87B4D958-520C-4483-BC63-2D1FE4C4CC01" class="sect3">Opening and Closing Cursor Variables</h3>
<div>
<div class="section">
<p>After declaring a cursor variable, you can open it with the <code class="codeph">OPEN</code> <code class="codeph">FOR</code> statement, which does the following:</p>
<ol>
<li>
<p>Associates the cursor variable with a query (typically, the query returns multiple rows)</p>
<p>The query can include placeholders for bind variables, whose values you specify in the <code class="codeph">USING</code> clause of the <code class="codeph">OPEN</code> <code class="codeph">FOR</code> statement.</p>
</li>
<li>
<p>Allocates database resources to process the query</p>
</li>
<li>
<p>Processes the query; that is:</p>
<ol>
<li>
<p>Identifies the result set</p>
<p>If the query references variables, their values affect the result set. For details, see <span class="q">&#34;<a href="static.htm#GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C" title="The query associated with a cursor variable can reference any variable in its scope.">Variables in Cursor Variable Queries</a>&#34;</span>.</p>
</li>
<li>
<p>If the query has a <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> clause, locks the rows of the result set</p>
<p>For details, see <span class="q">&#34;<a href="static.htm#GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08">SELECT FOR UPDATE and FOR UPDATE Cursors</a>&#34;</span>.</p>
</li>
</ol>
</li>
<li>
<p>Positions the cursor before the first row of the result set</p>
</li>
</ol>
<p>You need not close a cursor variable before reopening it (that is, using it in another <code class="codeph">OPEN</code> <code class="codeph">FOR</code> statement). After you reopen a cursor variable, the query previously associated with it is lost.</p>
<p>When you no longer need a cursor variable, close it with the <code class="codeph">CLOSE</code> statement, thereby allowing its resources to be reused. After closing a cursor variable, you cannot fetch records from its result set or reference its attributes. If you try, PL/SQL raises the predefined exception <code class="codeph">INVALID_CURSOR</code>.</p>
<p>You can reopen a closed cursor variable.</p>
<div class="infoboxnotealso" id="GUID-87B4D958-520C-4483-BC63-2D1FE4C4CC01__GUID-FB759EEE-5DC8-4B19-818E-57305E7A2305">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="openfor_statement.htm#GUID-EB7AF439-FDD3-4461-9E3F-B621E8ABFB96" title="The OPEN FOR statement associates a cursor variable with a query, allocates database resources to process the query, identifies the result set, and positions the cursor before the first row of the result set.">OPEN FOR Statement</a>&#34;</span> for its syntax and semantics</p>
</li>
<li>
<p><span class="q">&#34;<a href="close_statement.htm#GUID-46E7086C-8C29-4689-A062-0FF059E268FD" title="The CLOSE statement closes a named cursor, freeing its resources for reuse.">CLOSE Statement</a>&#34;</span> for its syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS484"></a><a id="LNPLS583"></a><a id="LNPLS581"></a>
<div class="props_rev_3"><a id="GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2"></a>
<h3 id="LNPLS-GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2" class="sect3">Fetching Data with Cursor Variables</h3>
<div>
<p>After opening a cursor variable, you can fetch the rows of the query result set with the <code class="codeph">FETCH</code> statement.</p>
<div class="section">
<p>The return type of the cursor variable must be compatible with the <span class="italic"><code class="codeph">into_clause</code></span> of the <code class="codeph">FETCH</code> statement. If the cursor variable is strong, PL/SQL catches incompatibility at compile time. If the cursor variable is weak, PL/SQL catches incompatibility at run time, raising the predefined exception <code class="codeph">ROWTYPE_MISMATCH</code> before the first fetch.</p>
<div class="infoboxnotealso" id="GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2__GUID-E31F3575-D2FD-44EC-876B-AA95BA3D1869">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C">Fetching Data with Explicit Cursors</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="fetch_statement.htm#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="The FETCH statement retrieves rows of data from the result set of a multiple-row query&mdash;one row at a time, several rows at a time, or all rows at once&mdash;and stores the data in variables, records, or collections.">FETCH Statement</a>&#34;</span> for its complete syntax and semantics</p>
</li>
<li>
<p><span class="q">&#34;<a href="tuning.htm#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" title="The FETCH statement with the BULK COLLECT clause (also called the FETCH BULK COLLECT statement) fetches an entire result set into one or more collection variables.">FETCH Statement with BULK COLLECT Clause</a>&#34;</span> for information about <code class="codeph">FETCH</code> statements that return more than one row at a time</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2__BABDJIFB">
<p class="titleinexample">Example 6-26 Fetching Data with Cursor Variables</p>
<p>This example uses one cursor variable to do what <a href="static.htm#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__BABCFDJE">Example 6-6</a> does with two explicit cursors. The first <code class="codeph">OPEN</code> <code class="codeph">FOR</code> statement includes the query itself. The second <code class="codeph">OPEN</code> <code class="codeph">FOR</code> statement references a variable whose value is a query.</p>
<pre dir="ltr">DECLARE
  <span class="bold">cv SYS_REFCURSOR;  -- cursor variable</span>
 
  v_lastname  employees.last_name%TYPE;  -- variable for last_name
  v_jobid     employees.job_id%TYPE;     -- variable for job_id
 
  <span class="bold">query_2 VARCHAR2(200) :=</span>
    <span class="bold">&#39;SELECT * FROM employees</span>
    <span class="bold">WHERE REGEXP_LIKE (job_id, &#39;&#39;[ACADFIMKSA]_M[ANGR]&#39;&#39;)</span>
    <span class="bold">ORDER BY job_id&#39;;</span>
 
  v_employees employees%ROWTYPE;  -- record variable row of table
 
BEGIN
  <span class="bold">OPEN cv FOR</span>
    <span class="bold">SELECT last_name, job_id FROM employees</span>
    <span class="bold">WHERE REGEXP_LIKE (job_id, &#39;S[HT]_CLERK&#39;)</span>
    <span class="bold">ORDER BY last_name;</span>
 
  LOOP  -- Fetches 2 columns into variables
    FETCH <span class="bold">cv</span> INTO v_lastname, v_jobid;
    EXIT WHEN <span class="bold">cv</span>%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE( RPAD(v_lastname, 25, &#39; &#39;) || v_jobid );
  END LOOP;
 
  DBMS_OUTPUT.PUT_LINE( &#39;-------------------------------------&#39; );
 
  <span class="bold">OPEN cv FOR query_2;</span>
 
  LOOP  -- Fetches entire row into the v_employees record
    FETCH <span class="bold">cv</span> INTO v_employees;
    EXIT WHEN <span class="bold">cv</span>%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE( RPAD(v_employees.last_name, 25, &#39; &#39;) ||
                               v_employees.job_id );
  END LOOP;
 
  CLOSE <span class="bold">cv</span>;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Atkinson                 ST_CLERK
Bell                     SH_CLERK
Bissot                   ST_CLERK
...
Walsh                    SH_CLERK
-------------------------------------
Higgins                  AC_MGR
Greenberg                FI_MGR
Hartstein                MK_MAN
...
Zlotkey                  SA_MAN
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2__BABGAICI">
<p class="titleinexample">Example 6-27 Fetching from Cursor Variable into Collections</p>
<p>This example fetches from a cursor variable into two collections (nested tables), using the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause of the <code class="codeph">FETCH</code> statement.</p>
<pre dir="ltr">DECLARE
  TYPE empcurtyp IS REF CURSOR;
  TYPE namelist IS TABLE OF employees.last_name%TYPE;
  TYPE sallist IS TABLE OF employees.salary%TYPE;
  emp_cv  empcurtyp;
  names   namelist;
  sals    sallist;
BEGIN
  OPEN emp_cv FOR
    SELECT last_name, salary FROM employees
    WHERE job_id = &#39;SA_REP&#39;
    ORDER BY salary DESC;

  <span class="bold">FETCH emp_cv BULK COLLECT INTO names, sals;</span>
  CLOSE emp_cv;
  -- loop through the names and sals collections
  FOR i IN names.FIRST .. names.LAST
  LOOP
    DBMS_OUTPUT.PUT_LINE
      (&#39;Name = &#39; || names(i) || &#39;, salary = &#39; || sals(i));
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Name = Ozer, salary = 11500
Name = Abel, salary = 11000
Name = Vishney, salary = 10500
...
Name = Kumar, salary = 6100
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS485"></a>
<div class="props_rev_3"><a id="GUID-7251E068-86C3-4B82-A8CE-54E0C9B9FCB2"></a>
<h3 id="LNPLS-GUID-7251E068-86C3-4B82-A8CE-54E0C9B9FCB2" class="sect3">Assigning Values to Cursor Variables</h3>
<div>
<p>You can assign to a PL/SQL cursor variable the value of another PL/SQL cursor variable or host cursor variable.</p>
<div class="section">
<p>The syntax is:</p>
<pre dir="ltr"><span class="italic">target_cursor_variable</span> := <span class="italic">source_cursor_variable</span>;
</pre>
<p>If <span class="italic"><code class="codeph">source_cursor_variable</code></span> is open, then after the assignment, <span class="italic"><code class="codeph">target_cursor_variable</code></span> is also open. The two cursor variables point to the same SQL work area.</p>
<p>If <span class="italic"><code class="codeph">source_cursor_variable</code></span> is not open, opening <span class="italic"><code class="codeph">target_cursor_variable</code></span> after the assignment does not open <span class="italic"><code class="codeph">source_cursor_variable</code></span>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS488"></a><a id="LNPLS489"></a><a id="LNPLS487"></a>
<div class="props_rev_3"><a id="GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C"></a>
<h3 id="LNPLS-GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C" class="sect3">Variables in Cursor Variable Queries</h3>
<div>
<p>The query associated with a cursor variable can reference any variable in its scope.</p>
<p>When you open a cursor variable with the <code class="codeph">OPEN</code> <code class="codeph">FOR</code> statement, PL/SQL evaluates any variables in the query and uses those values when identifying the result set. Changing the values of the variables later does not change the result set.</p>
<p>To change the result set, you must change the value of the variable and then open the cursor variable again for the same query, as in <a href="static.htm#GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C__BABIHIBA">Example 6-29</a>.</p>
<div class="example" id="GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C__BABCHEGG">
<p class="titleinexample">Example 6-28 Variable in Cursor Variable Query&mdash;No Result Set Change</p>
<p>This example opens a cursor variable for a query that references the variable <code class="codeph">factor</code>, which has the value 2. Therefore, <code class="codeph">sal_multiple</code> is always 2 times <code class="codeph">sal</code>, despite that <code class="codeph">factor</code> is incremented after every fetch.</p>
<pre dir="ltr">DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  <span class="bold">factor        INTEGER := 2;</span>
 
  cv SYS_REFCURSOR;
 
BEGIN
  <span class="bold">OPEN cv FOR</span>
    <span class="bold">SELECT salary, salary*factor</span>
    <span class="bold">FROM employees</span>
    <span class="bold">WHERE job_id LIKE &#39;AD_%&#39;;   -- PL/SQL evaluates factor</span>
 
  LOOP
    <span class="bold">FETCH cv INTO sal, sal_multiple;</span>
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(&#39;factor = &#39; || factor);
    DBMS_OUTPUT.PUT_LINE(&#39;sal          = &#39; || sal);
    DBMS_OUTPUT.PUT_LINE(&#39;sal_multiple = &#39; || sal_multiple);
    <span class="bold">factor := factor + 1;  -- Does not affect sal_multiple</span>
  END LOOP;
 
  CLOSE cv;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">factor = 2
sal          = 4400
sal_multiple = 8800
factor = 3
sal          = 24000
sal_multiple = 48000
factor = 4
sal          = 17000
sal_multiple = 34000
factor = 5
sal          = 17000
sal_multiple = 34000
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C__BABIHIBA">
<p class="titleinexample">Example 6-29 Variable in Cursor Variable Query&mdash;Result Set Change</p>
<pre dir="ltr">DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  <span class="bold">factor        INTEGER := 2;</span>
 
  cv SYS_REFCURSOR;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;factor = &#39; || factor);
 
  <span class="bold">OPEN cv FOR</span>
    <span class="bold">SELECT salary, salary*factor</span>
    <span class="bold">FROM employees</span>
    <span class="bold">WHERE job_id LIKE &#39;AD_%&#39;;   -- PL/SQL evaluates factor</span>
 
  LOOP
    FETCH cv INTO sal, sal_multiple;
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(&#39;sal          = &#39; || sal);
    DBMS_OUTPUT.PUT_LINE(&#39;sal_multiple = &#39; || sal_multiple);
  END LOOP;
 
  <span class="bold">factor := factor + 1;</span>
 
  DBMS_OUTPUT.PUT_LINE(&#39;factor = &#39; || factor);
 
  <span class="bold">OPEN cv FOR</span>
    <span class="bold">SELECT salary, salary*factor</span>
    <span class="bold">FROM employees</span>
    <span class="bold">WHERE job_id LIKE &#39;AD_%&#39;;   -- PL/SQL evaluates factor</span>
 
  LOOP
    FETCH cv INTO sal, sal_multiple;
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(&#39;sal          = &#39; || sal);
    DBMS_OUTPUT.PUT_LINE(&#39;sal_multiple = &#39; || sal_multiple);
  END LOOP;
 
  CLOSE cv;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">factor = 2
sal          = 4400
sal_multiple = 8800
sal          = 24000
sal_multiple = 48000
sal          = 17000
sal_multiple = 34000
sal          = 17000
sal_multiple = 34000
factor = 3
sal          = 4400
sal_multiple = 13200
sal          = 24000
sal_multiple = 72000
sal          = 17000
sal_multiple = 51000
sal          = 17000
sal_multiple = 51000
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS491"></a><a id="LNPLS590"></a>
<div class="props_rev_3"><a id="GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248"></a>
<h3 id="LNPLS-GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248" class="sect3">Querying a Collection</h3>
<div>
<div class="section">
<p>You can query a collection if all of the following are true:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The data type of the collection was either created at schema level or declared in a package specification.</p>
</li>
<li>
<p>The data type of the collection element is either a scalar data type, a user-defined type, or a record type.</p>
</li>
</ul>
<p>In the query <code class="codeph">FROM</code> clause, the collection appears in <span class="italic"><code class="codeph">table_collection_expression</code></span> as the argument of the <code class="codeph">TABLE</code> operator.</p>
<div class="infobox-note" id="GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248__GUID-F4EE93B3-BA9A-4212-877F-8CB0F63EB33C">
<p class="notep1">Note:</p>
<p>In SQL contexts, you cannot use a function whose return type was declared in a package specification.</p>
</div>
<div class="infoboxnotealso" id="GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248__GUID-68A74A5E-1207-423A-A260-15AC3B635EB9">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF55241" target="_blank" href="../SQLRF/statements_10002.htm#SQLRF55241"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <span class="italic"><code class="codeph">table_collection_expression</code></span></p>
</li>
<li>
<p><span class="q">&#34;<a href="create_package.htm#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5">CREATE PACKAGE Statement</a>&#34;</span> for information about the <code class="codeph">CREATE</code> <code class="codeph">PACKAGE</code> statement</p>
</li>
<li>
<p><span class="q">&#34;<a href="composites.htm#GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" title="PL/SQL lets you define two kinds of composite data types, collection and record.">PL/SQL Collections and Records</a>&#34;</span> for information about collection types and collection variables</p>
</li>
<li>
<p><a href="dynamic.htm#GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2__CHDDBFJB">Example 7-9</a>, <span class="q">&#34;Querying a Collection with Native Dynamic SQL&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248__BABJDADA">
<p class="titleinexample">Example 6-30 Querying a Collection with Static SQL</p>
<p>In this example, the cursor variable is associated with a query on an associative array of records. The nested table type, <code class="codeph">mytab</code>, is declared in a package specification.</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE pkg AUTHID DEFINER AS
  TYPE rec IS RECORD(f1 NUMBER, f2 VARCHAR2(30));
  TYPE mytab IS TABLE OF rec INDEX BY pls_integer;
END;

DECLARE
  <span class="bold">v1 pkg.mytab;  -- collection of records</span>
  v2 pkg.rec;
  c1 SYS_REFCURSOR;
BEGIN
  v1(1).f1 := 1;
  v1(1).f2 := &#39;one&#39;;
  <span class="bold">OPEN c1 FOR SELECT * FROM TABLE(v1);</span>
  FETCH c1 INTO v2;
  CLOSE c1;
  DBMS_OUTPUT.PUT_LINE(&#39;Values in record are &#39; || v2.f1 || &#39; and &#39; || v2.f2);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Values in record are 1 and one
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS494"></a>
<div class="props_rev_3"><a id="GUID-1361A503-BA2D-400B-987A-59B2824E316E"></a>
<h3 id="LNPLS-GUID-1361A503-BA2D-400B-987A-59B2824E316E" class="sect3">Cursor Variable Attributes</h3>
<div>
<p>A cursor variable has the same attributes as an explicit cursor (see <a href="static.htm#GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D">Explicit Cursor Attributes</a>.). The syntax for the value of a cursor variable attribute is <span class="italic"><code class="codeph">cursor_variable_name</code></span> immediately followed by <span class="italic"><code class="codeph">attribute</code></span> (for example, <code class="codeph">cv%ISOPEN</code>). If a cursor variable is not open, referencing any attribute except <code class="codeph">%ISOPEN</code> raises the predefined exception <code class="codeph">INVALID_CURSOR</code>.</p>
</div>
</div>
<a id="LNPLS577"></a><a id="LNPLS578"></a><a id="LNPLS579"></a><a id="LNPLS572"></a>
<div class="props_rev_3"><a id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619"></a>
<h3 id="LNPLS-GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619" class="sect3">Cursor Variables as Subprogram Parameters</h3>
<div>
<p>You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.</p>
<p>For example:</p>
<ul style="list-style-type: disc;">
<li>
<p>You can open a cursor variable in one subprogram and process it in a different subprogram.</p>
</li>
<li>
<p>In a multilanguage application, a PL/SQL subprogram can use a cursor variable to return a result set to a subprogram written in a different language.</p>
</li>
</ul>
<div class="infobox-note" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__GUID-0AC269D2-89A3-45DA-80A0-5873F394FDF3">
<p class="notep1">Note:</p>
<p>The invoking and invoked subprograms must be in the same database instance. You cannot pass or return cursor variables to subprograms invoked through database links.</p>
</div>
<div class="infobox-note" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__GUID-0A68C42F-B015-47F0-A777-56ADCE4BA2E8">
<p class="notep1">Caution:</p>
<p>Because cursor variables are pointers, using them as subprogram parameters increases the likelihood of subprogram parameter aliasing, which can have unintended results. For more information, see <span class="q">&#34;<a href="subprograms.htm#GUID-2CCDEA03-F0ED-463A-BEC1-3F9430047692">Subprogram Parameter Aliasing with Cursor Variable Parameters</a>&#34;</span>.</p>
</div>
<p>When declaring a cursor variable as the formal parameter of a subprogram:</p>
<ul style="list-style-type: disc;">
<li>
<p>If the subprogram opens or assigns a value to the cursor variable, then the parameter mode must be <code class="codeph">IN</code> <code class="codeph">OUT</code>.</p>
</li>
<li>
<p>If the subprogram only fetches from, or closes, the cursor variable, then the parameter mode can be either <code class="codeph">IN</code> or <code class="codeph">IN</code> <code class="codeph">OUT</code>.</p>
</li>
</ul>
<p>Corresponding formal and actual cursor variable parameters must have compatible return types. Otherwise, PL/SQL raises the predefined exception <code class="codeph">ROWTYPE_MISMATCH</code>.</p>
<p>To pass a cursor variable parameter between subprograms in different PL/SQL units, define the <code class="codeph">REF</code> <code class="codeph">CURSOR</code> type of the parameter in a package. When the type is in a package, multiple subprograms can use it. One subprogram can declare a formal parameter of that type, and other subprograms can declare variables of that type and pass them to the first subprogram.</p>
<div class="infoboxnotealso" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__GUID-70AC559A-0CBE-4CEA-8798-F1F604760F5D">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="subprograms.htm#GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB">Subprogram Parameters</a>&#34;</span> for more information about subprogram parameters</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-77FF2850-F338-4C77-9577-0FE3399D39BA" title="A CURSOR expression returns a nested cursor.">CURSOR Expressions</a>&#34;</span> for information about <code class="codeph">CURSOR</code> expressions, which can be actual parameters for formal cursor variable parameters</p>
</li>
<li>
<p><a href="packages.htm#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">PL/SQL Packages</a>, for more information about packages</p>
</li>
</ul>
</div>
<div class="example" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__BABIIGAG">
<p class="titleinexample">Example 6-31 Procedure to Open Cursor Variable for One Query</p>
<p>This example defines, in a package, a <code class="codeph">REF</code> <code class="codeph">CURSOR</code> type and a procedure that opens a cursor variable parameter of that type.</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE emp_data AUTHID DEFINER AS
  TYPE empcurtyp IS REF CURSOR RETURN employees%ROWTYPE;
  PROCEDURE open_emp_cv (emp_cv IN OUT empcurtyp);
END emp_data;
/
CREATE OR REPLACE PACKAGE BODY emp_data AS
  PROCEDURE open_emp_cv (<span class="bold">emp_cv IN OUT EmpCurTyp</span>) IS
  BEGIN
    <span class="bold">OPEN emp_cv FOR SELECT * FROM employees;</span>
  END open_emp_cv;
END emp_data;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__BABFEJED">
<p class="titleinexample">Example 6-32 Opening Cursor Variable for Chosen Query (Same Return Type)</p>
<p>In this example ,the stored procedure opens its cursor variable parameter for a chosen query. The queries have the same return type.</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE emp_data AUTHID DEFINER AS
  TYPE empcurtyp IS REF CURSOR RETURN employees%ROWTYPE;
  PROCEDURE open_emp_cv (emp_cv IN OUT empcurtyp, choice INT);
END emp_data;
/
CREATE OR REPLACE PACKAGE BODY emp_data AS
  PROCEDURE open_emp_cv (<span class="bold">emp_cv IN OUT empcurtyp, choice INT</span>) IS
  BEGIN
    IF <span class="bold">choice = 1</span> THEN
      OPEN emp_cv FOR SELECT *
      FROM employees
      <span class="bold">WHERE commission_pct IS NOT NULL</span>;
    ELSIF <span class="bold">choice = 2</span> THEN
      OPEN emp_cv FOR SELECT *
      FROM employees
      <span class="bold">WHERE salary &gt; 2500</span>;
    ELSIF <span class="bold">choice = 3</span> THEN
      OPEN emp_cv FOR SELECT *
      FROM employees
      <span class="bold">WHERE department_id = 100</span>;
    END IF;
  END;
END emp_data;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__BABEJEII">
<p class="titleinexample">Example 6-33 Opening Cursor Variable for Chosen Query (Different Return Types)</p>
<p>In this example,the stored procedure opens its cursor variable parameter for a chosen query. The queries have the different return types.</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE admin_data AUTHID DEFINER AS
  TYPE gencurtyp IS REF CURSOR;
  PROCEDURE open_cv (generic_cv IN OUT gencurtyp, choice INT);
END admin_data;
/
CREATE OR REPLACE PACKAGE BODY admin_data AS
  PROCEDURE open_cv (<span class="bold">generic_cv IN OUT gencurtyp, choice INT</span>) IS
  BEGIN
    IF <span class="bold">choice = 1</span> THEN
      OPEN generic_cv FOR SELECT * FROM <span class="bold">employees</span>;
    ELSIF <span class="bold">choice = 2</span> THEN
      OPEN generic_cv FOR SELECT * FROM <span class="bold">departments</span>;
    ELSIF <span class="bold">choice = 3</span> THEN
      OPEN generic_cv FOR SELECT * FROM <span class="bold">jobs</span>;
    END IF;
  END;
END admin_data;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS498"></a><a id="LNPLS580"></a>
<div class="props_rev_3"><a id="GUID-04CBBBFB-959B-4991-9580-521DC6156489"></a>
<h3 id="LNPLS-GUID-04CBBBFB-959B-4991-9580-521DC6156489" class="sect3">Cursor Variables as Host Variables</h3>
<div>
<p>You can use a cursor variable as a host variable, which makes it useful for passing query results between PL/SQL stored subprograms and their clients.</p>
<p>When a cursor variable is a host variable, PL/SQL and the client (the host environment) share a pointer to the SQL work area that stores the result set.</p>
<p>To use a cursor variable as a host variable, declare the cursor variable in the host environment and then pass it as an input host variable (bind variable) to PL/SQL. Host cursor variables are compatible with any query return type (like weak PL/SQL cursor variables).</p>
<p>A SQL work area remains accessible while any cursor variable points to it, even if you pass the value of a cursor variable from one scope to another. For example, in <a href="static.htm#GUID-04CBBBFB-959B-4991-9580-521DC6156489__CHDJEEFC">Example 6-34</a>, the Pro*C program passes a host cursor variable to an embedded PL/SQL anonymous block. After the block runs, the cursor variable still points to the SQL work area.</p>
<p>If you have a PL/SQL engine on the client side, calls from client to server impose no restrictions. For example, you can declare a cursor variable on the client side, open and fetch from it on the server side, and continue to fetch from it on the client side. You can also reduce network traffic with a PL/SQL anonymous block that opens or closes several host cursor variables in a single round trip. For example:</p>
<pre dir="ltr">/* PL/SQL anonymous block in host environment */
BEGIN
  OPEN :emp_cv FOR SELECT * FROM employees;
  OPEN :dept_cv FOR SELECT * FROM departments;
  OPEN :loc_cv FOR SELECT * FROM locations;
END;
/
</pre>
<p>Because the cursor variables still point to the SQL work areas after the PL/SQL anonymous block runs, the client program can use them. When the client program no longer needs the cursors, it can use a PL/SQL anonymous block to close them. For example:</p>
<pre dir="ltr">/* PL/SQL anonymous block in host environment */
BEGIN
  CLOSE :emp_cv;
  CLOSE :dept_cv;
  CLOSE :loc_cv;
END;
/
</pre>
<p>This technique is useful for populating a multiblock form, as in Oracle Forms. For example, you can open several SQL work areas in a single round trip, like this:</p>
<pre dir="ltr">/* PL/SQL anonymous block in host environment */
BEGIN
  OPEN :c1 FOR SELECT 1 FROM DUAL;
  OPEN :c2 FOR SELECT 1 FROM DUAL;
  OPEN :c3 FOR SELECT 1 FROM DUAL;
END;
/
</pre>
<div class="infobox-note" id="GUID-04CBBBFB-959B-4991-9580-521DC6156489__GUID-D5A3C4B8-C0F1-4E40-BCF5-598B6CE0CE32">
<p class="notep1">Note:</p>
<p>If you bind a host cursor variable into PL/SQL from an Oracle Call Interface (OCI) client, then you cannot fetch from it on the server side unless you also open it there on the same server call.</p>
</div>
<div class="example" id="GUID-04CBBBFB-959B-4991-9580-521DC6156489__CHDJEEFC">
<p class="titleinexample">Example 6-34 Cursor Variable as Host Variable in Pro*C Client Program</p>
<p>In this example, a Pro*C client program declares a cursor variable and a selector and passes them as host variables to a PL/SQL anonymous block, which opens the cursor variable for the selected query.</p>
<pre dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
  SQL_CURSOR  generic_cv;  -- Declare host cursor variable.
  int         choice;      -- Declare selector.
EXEC SQL END DECLARE SECTION;
EXEC SQL ALLOCATE :generic_cv;  -- Initialize host cursor variable.
-- Pass host cursor variable and selector to PL/SQL block.
/
EXEC SQL EXECUTE
BEGIN
  IF :choice = 1 THEN
    OPEN :generic_cv FOR SELECT * FROM employees;
  ELSIF :choice = 2 THEN
    OPEN :generic_cv FOR SELECT * FROM departments;
  ELSIF :choice = 3 THEN
    OPEN :generic_cv FOR SELECT * FROM jobs;
  END IF;
END;
END-EXEC;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS589"></a><a id="LNPLS00606"></a>
<div class="props_rev_3"><a id="GUID-77FF2850-F338-4C77-9577-0FE3399D39BA"></a>
<h2 id="LNPLS-GUID-77FF2850-F338-4C77-9577-0FE3399D39BA" class="sect2">CURSOR Expressions</h2>
<div>
<p>A <code class="codeph">CURSOR</code> expression returns a nested cursor.</p>
<p>It has this syntax:</p>
<pre dir="ltr">CURSOR ( <span class="italic">subquery</span> )
</pre>
<p>You can use a <code class="codeph">CURSOR</code> expression in a <code class="codeph">SELECT</code> statement that is not a subquery (as in <a href="static.htm#GUID-77FF2850-F338-4C77-9577-0FE3399D39BA__BABFGHDG">Example 6-35</a>) or pass it to a function that accepts a cursor variable parameter (see <span class="q">&#34;<a href="tuning.htm#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6">Passing CURSOR Expressions to Pipelined Table Functions</a>&#34;</span>). You cannot use a cursor expression with an implicit cursor.</p>
<div class="infoboxnotealso" id="GUID-77FF2850-F338-4C77-9577-0FE3399D39BA__GUID-6AF346EB-B050-4754-9D1F-1EE3960FF72F">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF52077" target="_blank" href="../SQLRF/expressions006.htm#SQLRF52077"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code class="codeph">CURSOR</code> expressions, including restrictions</p>
</div>
<div class="example" id="GUID-77FF2850-F338-4C77-9577-0FE3399D39BA__BABFGHDG">
<p class="titleinexample">Example 6-35 CURSOR Expression</p>
<p>This example declares and defines an explicit cursor for a query that includes a cursor expression. For each department in the <code class="codeph">departments</code> table, the nested cursor returns the last name of each employee in that department (which it retrieves from the <code class="codeph">employees</code> table).</p>
<pre dir="ltr">DECLARE
  TYPE emp_cur_typ IS REF CURSOR;
 
  emp_cur    emp_cur_typ;
  dept_name  departments.department_name%TYPE;
  emp_name   employees.last_name%TYPE;
 
  CURSOR c1 IS
    SELECT department_name,
      <span class="bold">CURSOR ( SELECT e.last_name</span>
                <span class="bold">FROM employees e</span>
                <span class="bold">WHERE e.department_id = d.department_id</span>
                <span class="bold">ORDER BY e.last_name</span>
              <span class="bold">)</span> employees
    FROM departments d
    WHERE department_name LIKE &#39;A%&#39;
    ORDER BY department_name;
BEGIN
  OPEN c1;
  LOOP  -- Process each row of query result set
    FETCH c1 INTO dept_name, emp_cur;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(&#39;Department: &#39; || dept_name);
 
    LOOP -- Process each row of subquery result set
      FETCH emp_cur INTO emp_name;
      EXIT WHEN emp_cur%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(&#39;-- Employee: &#39; || emp_name);
    END LOOP;
  END LOOP;
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Department: Accounting
-- Employee: Gietz
-- Employee: Higgins
Department: Administration
-- Employee: Whalen
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS503"></a><a id="LNPLS00608"></a>
<div class="props_rev_3"><a id="GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1"></a>
<h2 id="LNPLS-GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1" class="sect2">Transaction Processing and Control</h2>
<div>
<p><span class="bold">Transaction processing</span> is an Oracle Database feature that lets multiple users work on the database concurrently, and ensures that each user sees a consistent version of data and that all changes are applied in the right order.</p>
<p>A <span class="bold">transaction</span> is a sequence of one or more SQL statements that Oracle Database treats as a unit: either all of the statements are performed, or none of them are.</p>
<p>Different users can write to the same data structures without harming each other&#39;s data or coordinating with each other, because Oracle Database locks data structures automatically. To maximize data availability, Oracle Database locks the minimum amount of data for the minimum amount of time.</p>
<p>You rarely must write extra code to prevent problems with multiple users accessing data concurrently. However, if you do need this level of control, you can manually override the Oracle Database default locking mechanisms.</p>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C" title="The COMMIT statement ends the current transaction, making its changes permanent and visible to other users.">COMMIT Statement</a></p>
</li>
<li>
<p><a href="static.htm#GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8" title="The ROLLBACK statement ends the current transaction and undoes any changes made during that transaction.">ROLLBACK Statement</a></p>
</li>
<li>
<p><a href="static.htm#GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6" title="The SAVEPOINT statement names and marks the current point in the processing of a transaction.">SAVEPOINT Statement</a></p>
</li>
<li>
<p><a href="static.htm#GUID-A0771963-D96F-4AC5-A74A-242D064825DA" title="Before running an INSERT, UPDATE, DELETE, or MERGE statement, the database marks an implicit savepoint (unavailable to you). If the statement fails, the database rolls back to the savepoint.">Implicit Rollbacks</a></p>
</li>
<li>
<p><a href="static.htm#GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D" title="You use the SET TRANSACTION statement to begin a read-only or read-write transaction, establish an isolation level, or assign your current transaction to a specified rollback segment.">SET TRANSACTION Statement</a></p>
</li>
<li>
<p><a href="static.htm#GUID-213C196F-7FE4-425C-93E4-54B9FAFF5030" title="By default, Oracle Database locks data structures automatically, which lets different applications write to the same data structures without harming each other&#39;s data or coordinating with each other.">Overriding Default Locking</a></p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<div class="infoboxnotealso" id="GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1__GUID-1B6E192B-EA8C-4869-B85F-0D57624C8570">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink CNCPT016" target="_blank" href="../CNCPT/transact.htm#CNCPT016"><span class="italic">Oracle Database Concepts</span></a> for more information about transactions</p>
</li>
<li>
<p><a class="olink CNCPT1118" target="_blank" href="../CNCPT/transact.htm#CNCPT1118"><span class="italic">Oracle Database Concepts</span></a> for more information about transaction processing</p>
</li>
<li>
<p><a class="olink CNCPT1331" target="_blank" href="../CNCPT/consist.htm#CNCPT1331"><span class="italic">Oracle Database Concepts</span></a> for more information about the Oracle Database locking mechanism</p>
</li>
<li>
<p><a class="olink CNCPT1363" target="_blank" href="../CNCPT/consist.htm#CNCPT1363"><span class="italic">Oracle Database Concepts</span></a> for more information about manual data locks</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="LNPLS593"></a><a id="LNPLS592"></a>
<div class="props_rev_3"><a id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C"></a>
<h3 id="LNPLS-GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C" class="sect3">COMMIT Statement</h3>
<div>
<p>The <code class="codeph">COMMIT</code> statement ends the current transaction, making its changes permanent and visible to other users.</p>
<div class="infobox-note" id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C__GUID-F935E073-45EA-4A5D-8D4A-B7E74BF15B1A">
<p class="notep1">Note:</p>
<p>A transaction can span multiple blocks, and a block can contain multiple transactions.</p>
</div>
<p>The <code class="codeph">WRITE</code> clause of the <code class="codeph">COMMIT</code> statement specifies the priority with which Oracle Database writes to the redo log the information that the commit operation generates.</p>
<div class="infobox-note" id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C__GUID-737F1A89-C919-4A16-9D47-3AD09A1DBE65">
<p class="notep1">Note:</p>
<p>The default PL/SQL commit behavior for nondistributed transactions is <code class="codeph">BATCH</code> <code class="codeph">NOWAIT</code> if the <code class="codeph">COMMIT_LOGGING</code> and <code class="codeph">COMMIT_WAIT</code> database initialization parameters have not been set.</p>
</div>
<div class="infoboxnotealso" id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C__GUID-52B32BCE-69B5-4130-A284-2A9E1A0C9CE6">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink CNCPT1119" target="_blank" href="../CNCPT/transact.htm#CNCPT1119"><span class="italic">Oracle Database Concepts</span></a> for more information about committing transactions</p>
</li>
<li>
<p><a class="olink CNCPT016" target="_blank" href="../CNCPT/transact.htm#CNCPT016"><span class="italic">Oracle Database Concepts</span></a> for information about distributed transactions</p>
</li>
<li>
<p><a class="olink SQLRF01110" target="_blank" href="../SQLRF/statements_4011.htm#SQLRF01110"><span class="italic">Oracle Database SQL Language Reference</span></a>for information about the <code class="codeph">COMMIT</code> statement</p>
</li>
<li>
<p><a class="olink SBYDB02000" target="_blank" href="../SBYDB/protection.htm#SBYDB02000"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for information about ensuring no loss of data during a failover to a standby database</p>
</li>
</ul>
</div>
<div class="example" id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C__CJAIDJID">
<p class="titleinexample">Example 6-36 COMMIT Statement with COMMENT and WRITE Clauses</p>
<p>In this example, a transaction transfers money from one bank account to another. It is important that the money both leaves one account and enters the other, hence the <code class="codeph">COMMIT</code> <code class="codeph">WRITE</code> <code class="codeph">IMMEDIATE</code> <code class="codeph">NOWAIT</code> statement.</p>
<pre dir="ltr">DROP TABLE accounts;
CREATE TABLE accounts (
  account_id  NUMBER(6),
  balance     NUMBER (10,2)
);
 
INSERT INTO accounts (account_id, balance)
VALUES (7715, 6350.00);
 
INSERT INTO accounts (account_id, balance)
VALUES (7720, 5100.50);
 
CREATE OR REPLACE PROCEDURE transfer (
  from_acct  NUMBER,
  to_acct    NUMBER,
  amount     NUMBER
) AUTHID CURRENT_USER AS
BEGIN
  UPDATE accounts
  SET balance = balance - amount
  WHERE account_id = from_acct;
 
  UPDATE accounts
  SET balance = balance + amount
  WHERE account_id = to_acct;
 
  COMMIT WRITE IMMEDIATE NOWAIT;
END;
/
</pre>
<p>Query before transfer:</p>
<pre dir="ltr">SELECT * FROM accounts;
</pre>
<p>Result:</p>
<pre dir="ltr">ACCOUNT_ID    BALANCE
---------- ----------
      7715       6350
      7720     5100.5
 
BEGIN
  transfer(7715, 7720, 250);
END;
/
 
</pre>
<p>Query after transfer:</p>
<pre dir="ltr">SELECT * FROM accounts;
</pre>
<p>Result:</p>
<pre dir="ltr">ACCOUNT_ID    BALANCE
---------- ----------
      7715       6100
      7720     5350.5
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS595"></a><a id="LNPLS594"></a>
<div class="props_rev_3"><a id="GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8"></a>
<h3 id="LNPLS-GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8" class="sect3">ROLLBACK Statement</h3>
<div>
<p>The <code class="codeph">ROLLBACK</code> statement ends the current transaction and undoes any changes made during that transaction.</p>
<p>If you make a mistake, such as deleting the wrong row from a table, a rollback restores the original data. If you cannot finish a transaction because a SQL statement fails or PL/SQL raises an exception, a rollback lets you take corrective action and perhaps start over.</p>
<div class="infoboxnotealso" id="GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8__GUID-F68D2A1D-18A5-4A42-BECB-A1E9B0457C3B">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF01601" target="_blank" href="../SQLRF/statements_9010.htm#SQLRF01601"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code class="codeph">ROLLBACK</code> statement</p>
</div>
<div class="example" id="GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8__CJACGAFD">
<p class="titleinexample">Example 6-37 ROLLBACK Statement</p>
<p>This example inserts information about an employee into three different tables. If an <code class="codeph">INSERT</code> statement tries to store a duplicate employee number, PL/SQL raises the predefined exception <code class="codeph">DUP_VAL_ON_INDEX</code>. To ensure that changes to all three tables are undone, the exception handler runs a <code class="codeph">ROLLBACK</code>.</p>
<pre dir="ltr">DROP TABLE emp_name;
CREATE TABLE emp_name AS 
  SELECT employee_id, last_name
  FROM employees;
 
CREATE UNIQUE INDEX empname_ix
ON emp_name (employee_id);
 
 
DROP TABLE emp_sal;
CREATE TABLE emp_sal AS
  SELECT employee_id, salary
  FROM employees;
 
CREATE UNIQUE INDEX empsal_ix
ON emp_sal (employee_id);
 
 
DROP TABLE emp_job;
CREATE TABLE emp_job AS
  SELECT employee_id, job_id
  FROM employees;
 
CREATE UNIQUE INDEX empjobid_ix
ON emp_job (employee_id);
 
 
DECLARE
  emp_id        NUMBER(6);
  emp_lastname  VARCHAR2(25);
  emp_salary    NUMBER(8,2);
  emp_jobid     VARCHAR2(10);
BEGIN
  SELECT employee_id, last_name, salary, job_id
  INTO emp_id, emp_lastname, emp_salary, emp_jobid
  FROM employees
  WHERE employee_id = 120;
 
  INSERT INTO emp_name (employee_id, last_name)
  VALUES (emp_id, emp_lastname);
 
  INSERT INTO emp_sal (employee_id, salary) 
  VALUES (emp_id, emp_salary);
 
  INSERT INTO emp_job (employee_id, job_id)
  VALUES (emp_id, emp_jobid);
 
<span class="bold">EXCEPTION</span>
  <span class="bold">WHEN DUP_VAL_ON_INDEX THEN</span>
    <span class="bold">ROLLBACK;</span>
    DBMS_OUTPUT.PUT_LINE(&#39;Inserts were rolled back&#39;);
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS596"></a><a id="LNPLS597"></a><a id="LNPLS99976"></a>
<div class="props_rev_3"><a id="GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6"></a>
<h3 id="LNPLS-GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6" class="sect3">SAVEPOINT Statement</h3>
<div>
<p>The <code class="codeph">SAVEPOINT</code> statement names and marks the current point in the processing of a transaction.</p>
<p>Savepoints let you roll back part of a transaction instead of the whole transaction. The number of active savepoints for each session is unlimited.</p>
<p>When you roll back to a savepoint, any savepoints marked after that savepoint are erased. The savepoint to which you roll back is not erased. A simple rollback or commit erases all savepoints.</p>
<p>If you mark a savepoint in a recursive subprogram, new instances of the <code class="codeph">SAVEPOINT</code> statement run at each level in the recursive descent, but you can only roll back to the most recently marked savepoint.</p>
<p>Savepoint names are undeclared identifiers. Reusing a savepoint name in a transaction moves the savepoint from its old position to the current point in the transaction, which means that a rollback to the savepoint affects only the current part of the transaction.</p>
<div class="infoboxnotealso" id="GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6__GUID-3398D4C6-C6FA-4429-8529-16C6F34CE613">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF01705" target="_blank" href="../SQLRF/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code class="codeph">SET</code> <code class="codeph">TRANSACTION</code> SQL statement</p>
</div>
<div class="example" id="GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6__BABGAAIG">
<p class="titleinexample">Example 6-38 SAVEPOINT and ROLLBACK Statements</p>
<p>This example marks a savepoint before doing an insert. If the <code class="codeph">INSERT</code> statement tries to store a duplicate value in the <code class="codeph">employee_id</code> column, PL/SQL raises the predefined exception <code class="codeph">DUP_VAL_ON_INDEX</code> and the transaction rolls back to the savepoint, undoing only the <code class="codeph">INSERT</code> statement.</p>
<pre dir="ltr">DROP TABLE emp_name;
CREATE TABLE emp_name AS
  SELECT employee_id, last_name, salary
  FROM employees;
 
CREATE UNIQUE INDEX empname_ix
ON emp_name (employee_id);
 
DECLARE
  emp_id        employees.employee_id%TYPE;
  emp_lastname  employees.last_name%TYPE;
  emp_salary    employees.salary%TYPE;
 
BEGIN
  SELECT employee_id, last_name, salary
  INTO emp_id, emp_lastname, emp_salary 
  FROM employees
  WHERE employee_id = 120;
 
  UPDATE emp_name
  SET salary = salary * 1.1
  WHERE employee_id = emp_id;
 
  DELETE FROM emp_name
  WHERE employee_id = 130;
 
  <span class="bold">SAVEPOINT do_insert;</span>
 
  INSERT INTO emp_name (employee_id, last_name, salary)
  VALUES (emp_id, emp_lastname, emp_salary);
 
<span class="bold">EXCEPTION</span>
  <span class="bold">WHEN DUP_VAL_ON_INDEX THEN</span>
    <span class="bold">ROLLBACK TO do_insert;</span>
  DBMS_OUTPUT.PUT_LINE(&#39;Insert was rolled back&#39;);
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6__GUID-94B674C0-0259-4A04-9BF5-0A4A0687B82B">
<p class="titleinexample">Example 6-39 Reusing SAVEPOINT with ROLLBACK</p>
<pre dir="ltr">DROP TABLE emp_name;
CREATE TABLE emp_name AS
  SELECT employee_id, last_name, salary
  FROM employees;
 
CREATE UNIQUE INDEX empname_ix
ON emp_name (employee_id);
 
DECLARE
  emp_id        employees.employee_id%TYPE;
  emp_lastname  employees.last_name%TYPE;
  emp_salary    employees.salary%TYPE;
 
BEGIN
  SELECT employee_id, last_name, salary
  INTO emp_id, emp_lastname, emp_salary
  FROM employees
  WHERE employee_id = 120;
 
  <span class="bold">SAVEPOINT my_savepoint;</span>
 
  UPDATE emp_name
  SET salary = salary * 1.1
  WHERE employee_id = emp_id;
 
  DELETE FROM emp_name
  WHERE employee_id = 130;
 
  <span class="bold">SAVEPOINT my_savepoint;</span>
 
  INSERT INTO emp_name (employee_id, last_name, salary)
  VALUES (emp_id, emp_lastname, emp_salary);
 
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    <span class="bold">ROLLBACK TO my_savepoint;</span>
    DBMS_OUTPUT.PUT_LINE(&#39;Transaction rolled back.&#39;);
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS598"></a>
<div class="props_rev_3"><a id="GUID-A0771963-D96F-4AC5-A74A-242D064825DA"></a>
<h3 id="LNPLS-GUID-A0771963-D96F-4AC5-A74A-242D064825DA" class="sect3">Implicit Rollbacks</h3>
<div>
<p>Before running an <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, or <code class="codeph">MERGE</code> statement, the database marks an implicit savepoint (unavailable to you). If the statement fails, the database rolls back to the savepoint.</p>
<p>Usually, just the failed SQL statement is rolled back, not the whole transaction. If the statement raises an unhandled exception, the host environment determines what is rolled back.</p>
<p>The database can also roll back single SQL statements to break deadlocks. The database signals an error to a participating transaction and rolls back the current statement in that transaction.</p>
<p>Before running a SQL statement, the database must parse it, that is, examine it to ensure it follows syntax rules and refers to valid schema objects. Errors detected while running a SQL statement cause a rollback, but errors detected while parsing the statement do not.</p>
<p>If you exit a stored subprogram with an unhandled exception, PL/SQL does not assign values to <code class="codeph">OUT</code> parameters, and does not do any rollback.</p>
<p>For information about handling exceptions, see <a href="errors.htm#GUID-0502DC1A-F0A5-4180-A912-6A5CDC855F56" title="While compiling stored PL/SQL units, the PL/SQL compiler generates warnings for conditions that are not serious enough to cause errors and prevent compilation&mdash;for example, using a deprecated PL/SQL feature.">PL/SQL Error Handling</a></p>
</div>
</div>
<a id="LNPLS600"></a><a id="LNPLS99975"></a>
<div class="props_rev_3"><a id="GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D"></a>
<h3 id="LNPLS-GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D" class="sect3">SET TRANSACTION Statement</h3>
<div>
<p>You use the <code class="codeph">SET</code> <code class="codeph">TRANSACTION</code> statement to begin a read-only or read-write transaction, establish an isolation level, or assign your current transaction to a specified rollback segment.</p>
<p>Read-only transactions are useful for running multiple queries while other users update the same tables.</p>
<p>During a read-only transaction, all queries refer to the same snapshot of the database, providing a multi-table, multi-query, read-consistent view. Other users can continue to query or update data as usual. A commit or rollback ends the transaction.</p>
<p>The <code class="codeph">SET</code> <code class="codeph">TRANSACTION</code> statement must be the first SQL statement in a read-only transaction and can appear only once in a transaction. If you set a transaction to <code class="codeph">READ</code> <code class="codeph">ONLY</code>, subsequent queries see only changes committed before the transaction began. The use of <code class="codeph">READ</code> <code class="codeph">ONLY</code> does not affect other users or transactions.</p>
<p>Only the <code class="codeph">SELECT</code>, <code class="codeph">OPEN</code>, <code class="codeph">FETCH</code>, <code class="codeph">CLOSE</code>, <code class="codeph">LOCK</code> <code class="codeph">TABLE</code>, <code class="codeph">COMMIT</code>, and <code class="codeph">ROLLBACK</code> statements are allowed in a read-only transaction. Queries cannot be <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>.</p>
<div class="infoboxnotealso" id="GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D__GUID-B5DFDC80-BFC2-4091-908A-8C024D8BFAC2">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF01705" target="_blank" href="../SQLRF/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the SQL statement <code class="codeph">SET</code> <code class="codeph">TRANSACTION</code></p>
</div>
<div class="example" id="GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D__BABJIHCC">
<p class="titleinexample">Example 6-40 SET TRANSACTION Statement in Read-Only Transaction</p>
<p>In this example, a read-only transaction gather order totals for the day, the past week, and the past month. The totals are unaffected by other users updating the database during the transaction. The <code class="codeph">orders</code> table is in the sample schema OE.</p>
<pre dir="ltr">DECLARE
  daily_order_total    NUMBER(12,2);
  weekly_order_total   NUMBER(12,2); 
  monthly_order_total  NUMBER(12,2);
BEGIN
   COMMIT; -- end previous transaction
   SET TRANSACTION READ ONLY NAME &#39;Calculate Order Totals&#39;;

   SELECT SUM (order_total)
   INTO daily_order_total
   FROM orders
   WHERE order_date = SYSDATE;

   SELECT SUM (order_total)
   INTO weekly_order_total
   FROM orders
   WHERE order_date = SYSDATE - 7;

   SELECT SUM (order_total)
   INTO monthly_order_total
   FROM orders
   WHERE order_date = SYSDATE - 30;

   COMMIT; -- ends read-only transaction
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS504"></a><a id="LNPLS602"></a>
<div class="props_rev_3"><a id="GUID-213C196F-7FE4-425C-93E4-54B9FAFF5030"></a>
<h3 id="LNPLS-GUID-213C196F-7FE4-425C-93E4-54B9FAFF5030" class="sect3">Overriding Default Locking</h3>
<div>
<p>By default, Oracle Database locks data structures automatically, which lets different applications write to the same data structures without harming each other&#39;s data or coordinating with each other.</p>
<div class="section">
<p>If you must have exclusive access to data during a transaction, you can override default locking with these SQL statements:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">LOCK</code> <code class="codeph">TABLE</code>, which explicitly locks entire tables.</p>
</li>
<li>
<p><code class="codeph">SELECT</code> with the <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> clause (<code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>), which explicitly locks specific rows of a table.</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-4596DC9D-6011-4B4E-B14D-8C232334712F">LOCK TABLE Statement</a></p>
</li>
<li>
<p><a href="static.htm#GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08">SELECT FOR UPDATE and FOR UPDATE Cursors</a></p>
</li>
<li>
<p><a href="static.htm#GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9">Simulating CURRENT OF Clause with ROWID Pseudocolumn</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS605"></a>
<div class="props_rev_3"><a id="GUID-4596DC9D-6011-4B4E-B14D-8C232334712F"></a>
<h4 id="LNPLS-GUID-4596DC9D-6011-4B4E-B14D-8C232334712F" class="sect4">LOCK TABLE Statement</h4>
<div>
<p>The <code class="codeph">LOCK</code> <code class="codeph">TABLE</code> statement explicitly locks one or more tables in a specified lock mode so that you can share or deny access to them.</p>
<p>The lock mode determines what other locks can be placed on the table. For example, many users can acquire row share locks on a table at the same time, but only one user at a time can acquire an exclusive lock. While one user has an exclusive lock on a table, no other users can insert, delete, or update rows in that table.</p>
<p>A table lock never prevents other users from querying a table, and a query never acquires a table lock. Only if two different transactions try to modify the same row does one transaction wait for the other to complete. The <code class="codeph">LOCK</code> <code class="codeph">TABLE</code> statement lets you specify how long to wait for another transaction to complete.</p>
<p>Table locks are released when the transaction that acquired them is either committed or rolled back.</p>
<div class="infoboxnotealso" id="GUID-4596DC9D-6011-4B4E-B14D-8C232334712F__GUID-0FF274D4-3739-4D6D-AC3F-C4E5BDC8B33E">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ADFNS00203" target="_blank" href="../ADFNS/adfns_sqlproc.htm#ADFNS00203"><span class="italic">Oracle Database Development Guide</span></a> for more information about locking tables explicitly</p>
</li>
<li>
<p><a class="olink SQLRF01605" target="_blank" href="../SQLRF/statements_9016.htm#SQLRF01605"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code class="codeph">LOCK</code> <code class="codeph">TABLE</code> statement</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNPLS505"></a><a id="LNPLS506"></a><a id="LNPLS603"></a>
<div class="props_rev_3"><a id="GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08"></a>
<h4 id="LNPLS-GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08" class="sect4">SELECT FOR UPDATE and FOR UPDATE Cursors</h4>
<div>
<p>The <code class="codeph">SELECT</code> statement with the <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> clause (<code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> statement) selects the rows of the result set and locks them. <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> lets you base an update on the existing values in the rows, because it ensures that no other user can change those values before you update them. You can also use <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> to lock rows that you do not want to update, as in <a href="triggers.htm#GUID-2DC16B21-35B1-4D09-BD4E-02797AA278EA__BCFGAHIB">Example 9-6</a>.</p>
<div class="infobox-note" id="GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08__GUID-F0317D70-A128-4F29-A62E-A7A71FA43D76">
<p class="notep1">Note:</p>
<p>In tables compressed with Hybrid Columnar Compression (HCC), DML statements lock compression units rather than rows. HCC, a feature of certain Oracle storage systems, is described in <a class="olink CNCPT89198" target="_blank" href="../CNCPT/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a>.</p>
</div>
<p>By default, the <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> statement waits until the requested row lock is acquired. To change this behavior, use the <code class="codeph">NOWAIT</code>, <code class="codeph">WAIT</code>, or <code class="codeph">SKIP</code> <code class="codeph">LOCKED</code> clause of the <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> statement. For information about these clauses, see <a class="olink SQLRF01702" target="_blank" href="../SQLRF/statements_10002.htm#SQLRF01702"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>When <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> is associated with an explicit cursor, the cursor is called a <span class="bold"><code class="codeph">FOR</code></span> <span class="bold"><code class="codeph">UPDATE</code></span> <span class="bold">cursor</span>. Only a <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> cursor can appear in the <code class="codeph">CURRENT</code> <code class="codeph">OF</code> clause of an <code class="codeph">UPDATE</code> or <code class="codeph">DELETE</code> statement. (The <code class="codeph">CURRENT</code> <code class="codeph">OF</code> clause, a PL/SQL extension to the <code class="codeph">WHERE</code> clause of the SQL statements <code class="codeph">UPDATE</code> and <code class="codeph">DELETE</code>, restricts the statement to the current row of the cursor.)</p>
<p>When <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> queries multiple tables, it locks only rows whose columns appear in the <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> clause.</p>
</div>
</div>
<a id="LNPLS507"></a><a id="LNPLS607"></a><a id="LNPLS606"></a>
<div class="props_rev_3"><a id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9"></a>
<h4 id="LNPLS-GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9" class="sect4">Simulating CURRENT OF Clause with ROWID Pseudocolumn</h4>
<div>
<div class="section">
<p>The rows of the result set are locked when you open a <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> cursor, not as they are fetched. The rows are unlocked when you commit or roll back the transaction. After the rows are unlocked, you cannot fetch from the <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> cursor, as <a href="static.htm#GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__CHDHIIAI">Example 6-41</a> shows (the result is the same if you substitute <code class="codeph">ROLLBACK</code> for <code class="codeph">COMMIT</code>).</p>
<p>The workaround is to simulate the <code class="codeph">CURRENT</code> <code class="codeph">OF</code> clause with the <code class="codeph">ROWID</code> pseudocolumn (described in <a class="olink SQLRF00254" target="_blank" href="../SQLRF/pseudocolumns008.htm#SQLRF00254"><span class="italic">Oracle Database SQL Language Reference</span></a>). Select the rowid of each row into a <code class="codeph">UROWID</code> variable and use the rowid to identify the current row during subsequent updates and deletes, as in <a href="static.htm#GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__CIHIJAAE">Example 6-42</a>. (To print the value of a <code class="codeph">UROWID</code> variable, convert it to <code class="codeph">VARCHAR2</code>, using the <code class="codeph">ROWIDTOCHAR</code> function described in <a class="olink SQLRF06101" target="_blank" href="../SQLRF/functions171.htm#SQLRF06101"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<div class="infobox-note" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__GUID-05A0BC49-8B11-4249-8610-E64198D512A4">
<p class="notep1">Note:</p>
<p>When you update a row in a table compressed with Hybrid Columnar Compression (HCC), the <code class="codeph">ROWID</code> of the row changes. HCC, a feature of certain Oracle storage systems, is described in <a class="olink CNCPT89198" target="_blank" href="../CNCPT/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a>.</p>
</div>
<div class="infobox-note" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__GUID-F5F3D45B-6DBA-4D89-8273-79D15B9A74E7">
<p class="notep1">Caution:</p>
<p>Because no <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> clause locks the fetched rows, other users might unintentionally overwrite your changes.</p>
</div>
<div class="infobox-note" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__GUID-E4E27B50-9407-4F19-A37D-B00F023AEA50">
<p class="notep1">Note:</p>
<p>The extra space needed for read consistency is not released until the cursor is closed, which can slow down processing for large updates.</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__CHDHIIAI">
<p class="titleinexample">Example 6-41 FETCH with FOR UPDATE Cursor After COMMIT Statement</p>
<pre dir="ltr">DROP TABLE emp;
CREATE TABLE emp AS SELECT * FROM employees;
 
DECLARE
  CURSOR c1 IS
    SELECT * FROM emp
    <span class="bold">FOR UPDATE OF salary</span>
    ORDER BY employee_id;
 
  emp_rec  emp%ROWTYPE;
BEGIN
  OPEN c1;
  LOOP
    <span class="bold">FETCH c1 INTO emp_rec;  -- fails on second iteration</span>
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (
      &#39;emp_rec.employee_id = &#39; ||
      TO_CHAR(emp_rec.employee_id)
    );
    
    UPDATE emp
    SET salary = salary * 1.05
    WHERE employee_id = 105;
 
    <span class="bold">COMMIT;  -- releases locks</span>
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">emp_rec.employee_id = 100
DECLARE
*
ERROR at line 1:
ORA-01002: fetch out of sequence
ORA-06512: at line 11
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__CIHIJAAE">
<p class="titleinexample">Example 6-42 Simulating CURRENT OF Clause with ROWID Pseudocolumn</p>
<pre dir="ltr">DROP TABLE emp;
CREATE TABLE emp AS SELECT * FROM employees;
 
DECLARE
  CURSOR c1 IS
    SELECT last_name, job_id, <span class="bold">rowid</span>
    FROM emp;  <span class="bold">-- no FOR UPDATE clause</span>
 
  my_lastname   employees.last_name%TYPE;
  my_jobid      employees.job_id%TYPE;
  <span class="bold">my_rowid      UROWID;</span>
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO my_lastname, my_jobid, my_rowid;
    EXIT WHEN c1%NOTFOUND;
 
    UPDATE emp
    SET salary = salary * 1.02
    <span class="bold">WHERE rowid = my_rowid;  -- simulates WHERE CURRENT OF c1</span>
 
    COMMIT;
  END LOOP;
  CLOSE c1;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="LNPLS608"></a><a id="LNPLS508"></a><a id="LNPLS00609"></a>
<div class="props_rev_3"><a id="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099"></a>
<h2 id="LNPLS-GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099" class="sect2">Autonomous Transactions</h2>
<div>
<p>An <span class="bold">autonomous transaction</span> is an independent transaction started by another transaction, the main transaction.</p>
<p>Autonomous transactions do SQL operations and commit or roll back, without committing or rolling back the main transaction.</p>
<p><a href="static.htm#GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099__I28274">Figure 6-1</a> shows how control flows from the main transaction (MT) to an autonomous routine (<code class="codeph">proc2</code>) and back again. The autonomous routine commits two autonomous transactions (AT1 and AT2).</p>
<div class="figure" id="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099__I28274">
<p class="titleinfigure">Figure 6-1 Transaction Control Flow</p>
<img width="513" height="233" src="img/lnpls028.gif" alt="Description of Figure 6-1 follows" title="Description of Figure 6-1 follows"/><br/>
<a href="img_text/lnpls028.htm">Description of &#34;Figure 6-1 Transaction Control Flow&#34;</a></div>
<!-- class="figure" -->
<div class="infobox-note" id="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099__GUID-6BBCB951-D541-4057-8B9D-9C80C7BA20BF">
<p class="notep1">Note:</p>
<p>Although an autonomous transaction is started by another transaction, it is not a nested transaction, because:</p>
<ul style="list-style-type: disc;">
<li>
<p>It does not share transactional resources (such as locks) with the main transaction.</p>
</li>
<li>
<p>It does not depend on the main transaction.</p>
<p>For example, if the main transaction rolls back, nested transactions roll back, but autonomous transactions do not.</p>
</li>
<li>
<p>Its committed changes are visible to other transactions immediately.</p>
<p>A nested transaction&#39;s committed changes are not visible to other transactions until the main transaction commits.</p>
</li>
<li>
<p>Exceptions raised in an autonomous transaction cause a transaction-level rollback, not a statement-level rollback.</p>
</li>
</ul>
</div>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-4B7E30F5-61CB-4A94-B198-09E2706C4CA5">Advantages of Autonomous Transactions</a></p>
</li>
<li>
<p><a href="static.htm#GUID-E6F6EE1A-5BEB-426A-9EBC-A3C1FFD3A237">Transaction Context</a></p>
</li>
<li>
<p><a href="static.htm#GUID-F8D52E78-230A-4DCE-ACC6-823C214C0C4E">Transaction Visibility</a></p>
</li>
<li>
<p><a href="static.htm#GUID-FBD2040A-9047-44DB-8C82-5F6D08990227" title="To declare an autonomous routine, use the AUTONOMOUS_TRANSACTION pragma.">Declaring Autonomous Routines</a></p>
</li>
<li>
<p><a href="static.htm#GUID-F3D2490E-09A3-4EC4-9E31-45402099E23F">Controlling Autonomous Transactions</a></p>
</li>
<li>
<p><a href="static.htm#GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908" title="A trigger must be autonomous to run TCL or DDL statements.">Autonomous Triggers</a></p>
</li>
<li>
<p><a href="static.htm#GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE" title="A function invoked from SQL statements must obey rules meant to control side effects.">Invoking Autonomous Functions from SQL</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099__GUID-F810458A-DFF7-46D1-9361-64EE39C976DB">
<p class="notep1">See Also:</p>
<p><a class="olink ADFNS00205" target="_blank" href="../ADFNS/adfns_sqlproc.htm#ADFNS00205"><span class="italic">Oracle Database Development Guide</span></a> for more information about autonomous transactions</p>
</div>
</div>
<!-- class="section" --></div>
<a id="LNPLS509"></a>
<div class="props_rev_3"><a id="GUID-4B7E30F5-61CB-4A94-B198-09E2706C4CA5"></a>
<h3 id="LNPLS-GUID-4B7E30F5-61CB-4A94-B198-09E2706C4CA5" class="sect3">Advantages of Autonomous Transactions</h3>
<div>
<p>After starting, an autonomous transaction is fully independent. It shares no locks, resources, or commit-dependencies with the main transaction. You can log events, increment retry counters, and so on, even if the main transaction rolls back.</p>
<p>Autonomous transactions help you build modular, reusable software components. You can encapsulate autonomous transactions in stored subprograms. An invoking application needs not know whether operations done by that stored subprogram succeeded or failed.</p>
</div>
</div>
<a id="LNPLS616"></a>
<div class="props_rev_3"><a id="GUID-E6F6EE1A-5BEB-426A-9EBC-A3C1FFD3A237"></a>
<h3 id="LNPLS-GUID-E6F6EE1A-5BEB-426A-9EBC-A3C1FFD3A237" class="sect3">Transaction Context</h3>
<div>
<p>The main transaction shares its context with nested routines, but not with autonomous transactions. When one autonomous routine invokes another (or itself, recursively), the routines share no transaction context. When an autonomous routine invokes a nonautonomous routine, the routines share the same transaction context.</p>
</div>
</div>
<a id="LNPLS617"></a>
<div class="props_rev_3"><a id="GUID-F8D52E78-230A-4DCE-ACC6-823C214C0C4E"></a>
<h3 id="LNPLS-GUID-F8D52E78-230A-4DCE-ACC6-823C214C0C4E" class="sect3">Transaction Visibility</h3>
<div>
<p>Changes made by an autonomous transaction become visible to other transactions when the autonomous transaction commits. These changes become visible to the main transaction when it resumes, if its isolation level is set to <code class="codeph">READ</code> <code class="codeph">COMMITTED</code> (the default).</p>
<p>If you set the isolation level of the main transaction to <code class="codeph">SERIALIZABLE</code>, changes made by its autonomous transactions are <span class="italic">not</span> visible to the main transaction when it resumes:</p>
<pre dir="ltr">SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
</pre>
<div class="infobox-note" id="GUID-F8D52E78-230A-4DCE-ACC6-823C214C0C4E__GUID-6BF7A85D-6C03-444B-86F2-07CD00B71AA3">
<p class="notep1">Note:</p>
<ul style="list-style-type: disc;">
<li>
<p>Transaction properties apply only to the transaction in which they are set.</p>
</li>
<li>
<p>Cursor attributes are not affected by autonomous transactions.</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNPLS611"></a><a id="LNPLS612"></a><a id="LNPLS613"></a><a id="LNPLS610"></a>
<div class="props_rev_3"><a id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227"></a>
<h3 id="LNPLS-GUID-FBD2040A-9047-44DB-8C82-5F6D08990227" class="sect3">Declaring Autonomous Routines</h3>
<div>
<p>To declare an autonomous routine, use the <code class="codeph">AUTONOMOUS_TRANSACTION</code> pragma.</p>
<div class="section">
<p>For information about this pragma, see <span class="q">&#34;<a href="autotransaction_pragma.htm#GUID-AD33D949-081B-4CD3-A240-C29773E908C3" title="The AUTONOMOUS_TRANSACTION pragma marks a routine as autonomous; that is, independent of the main transaction.">AUTONOMOUS_TRANSACTION Pragma</a>&#34;</span>.</p>
<div class="infoboxnotealso" id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227__GUID-49741028-4EE8-4AF6-898F-E5B757B2F340">
<p class="notep1">Tip:</p>
<p>For readability, put the <code class="codeph">AUTONOMOUS_TRANSACTION</code> pragma at the top of the declarative section. (The pragma is allowed anywhere in the declarative section.)</p>
</div>
<p>You cannot apply the <code class="codeph">AUTONOMOUS_TRANSACTION</code> pragma to an entire package or ADT, but you can apply it to each subprogram in a package or each method of an ADT.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227__BABIIHBJ">
<p class="titleinexample">Example 6-43 Declaring Autonomous Function in Package</p>
<p>This example marks a package function as autonomous.</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE emp_actions AUTHID DEFINER AS  -- <span class="bold">package specification</span>
  <span class="bold">FUNCTION raise_salary</span> (emp_id NUMBER, sal_raise NUMBER)
  RETURN NUMBER;
END emp_actions;
/
CREATE OR REPLACE PACKAGE BODY emp_actions AS  -- <span class="bold">package body</span>
  -- code for function raise_salary
  <span class="bold">FUNCTION raise_salary</span> (emp_id NUMBER, sal_raise NUMBER)
  RETURN NUMBER IS
    <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION</span>;
    new_sal NUMBER(8,2);
  BEGIN
    UPDATE employees SET salary =
      salary + sal_raise WHERE employee_id = emp_id;
    COMMIT;
    SELECT salary INTO new_sal FROM employees
      WHERE employee_id = emp_id;
    RETURN new_sal;
  END raise_salary;
END emp_actions;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227__BABEECAF">
<p class="titleinexample">Example 6-44 Declaring Autonomous Standalone Procedure</p>
<p>This example marks a standalone subprogram as autonomous.</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE lower_salary
  (emp_id NUMBER, amount NUMBER)
AUTHID DEFINER AS
  <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION</span>;
BEGIN
  UPDATE employees
  SET salary =  salary - amount
  WHERE employee_id = emp_id;

  COMMIT;
END lower_salary;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227__BABIJEID">
<p class="titleinexample">Example 6-45 Declaring Autonomous PL/SQL Block</p>
<p>This example marks a schema-level PL/SQL block as autonomous. (A nested PL/SQL block cannot be autonomous.)</p>
<pre dir="ltr">DROP TABLE emp;
CREATE TABLE emp AS SELECT * FROM employees;
 
DECLARE
  <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span>
  emp_id NUMBER(6)   := 200;
  amount NUMBER(6,2) := 200;
BEGIN
  UPDATE employees
  SET salary =  salary - amount
  WHERE employee_id = emp_id;
 
  COMMIT;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS510"></a><a id="LNPLS99982"></a>
<div class="props_rev_3"><a id="GUID-F3D2490E-09A3-4EC4-9E31-45402099E23F"></a>
<h3 id="LNPLS-GUID-F3D2490E-09A3-4EC4-9E31-45402099E23F" class="sect3">Controlling Autonomous Transactions</h3>
<div>
<div class="section">
<p>The first SQL statement in an autonomous routine begins a transaction. When one transaction ends, the next SQL statement begins another transaction. All SQL statements run since the last commit or rollback comprise the current transaction. To control autonomous transactions, use these statements, which apply only to the current (active) transaction:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">COMMIT</code></p>
</li>
<li>
<p><code class="codeph">ROLLBACK</code> [<code class="codeph">TO</code> <span class="italic"><code class="codeph">savepoint_name</code></span>]</p>
</li>
<li>
<p><code class="codeph">SAVEPOINT</code> <span class="italic"><code class="codeph">savepoint_name</code></span></p>
</li>
<li>
<p><code class="codeph">SET</code> <code class="codeph">TRANSACTION</code></p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="static.htm#GUID-B3C2CC11-3554-4E96-8544-C5FA4A6163A9">Entering and Exiting Autonomous Routines</a></p>
</li>
<li>
<p><a href="static.htm#GUID-9D2A3D88-8454-486F-919D-34CB27935EE3">Committing and Rolling Back Autonomous Transactions</a></p>
</li>
<li>
<p><a href="static.htm#GUID-68AF5B28-83ED-4D1B-AB8E-4A7EFEBCE5CB">Savepoints</a></p>
</li>
<li>
<p><a href="static.htm#GUID-CD2A248B-A1F7-474D-A1A9-73743A318B52">Avoiding Errors with Autonomous Transactions</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS618"></a>
<div class="props_rev_3"><a id="GUID-B3C2CC11-3554-4E96-8544-C5FA4A6163A9"></a>
<h4 id="LNPLS-GUID-B3C2CC11-3554-4E96-8544-C5FA4A6163A9" class="sect4">Entering and Exiting Autonomous Routines</h4>
<div>
<div class="section">
<p>When you enter the executable section of an autonomous routine, the main transaction suspends. When you exit the routine, the main transaction resumes.</p>
<p>If you try to exit an active autonomous transaction without committing or rolling back, the database raises an exception. If the exception is unhandled, or if the transaction ends because of some other unhandled exception, then the transaction rolls back.</p>
<p>To exit normally, the routine must explicitly commit or roll back all autonomous transactions. If the routine (or any routine invoked by it) has pending transactions, then PL/SQL raises an exception and the pending transactions roll back.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS619"></a>
<div class="props_rev_3"><a id="GUID-9D2A3D88-8454-486F-919D-34CB27935EE3"></a>
<h4 id="LNPLS-GUID-9D2A3D88-8454-486F-919D-34CB27935EE3" class="sect4">Committing and Rolling Back Autonomous Transactions</h4>
<div>
<div class="section">
<p><code class="codeph">COMMIT</code> and <code class="codeph">ROLLBACK</code> end the active autonomous transaction but do not exit the autonomous routine. When one transaction ends, the next SQL statement begins another transaction. A single autonomous routine can contain several autonomous transactions, if it issues several <code class="codeph">COMMIT</code> statements.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS620"></a>
<div class="props_rev_3"><a id="GUID-68AF5B28-83ED-4D1B-AB8E-4A7EFEBCE5CB"></a>
<h4 id="LNPLS-GUID-68AF5B28-83ED-4D1B-AB8E-4A7EFEBCE5CB" class="sect4">Savepoints</h4>
<div>
<p>The scope of a savepoint is the transaction in which it is defined. Savepoints defined in the main transaction are unrelated to savepoints defined in its autonomous transactions. In fact, the main transaction and an autonomous transaction can use the same savepoint names.</p>
<p>You can roll back only to savepoints marked in the current transaction. In an autonomous transaction, you cannot roll back to a savepoint marked in the main transaction. To do so, you must resume the main transaction by exiting the autonomous routine.</p>
<p>When in the main transaction, rolling back to a savepoint marked before you started an autonomous transaction does <span class="italic">not</span> roll back the autonomous transaction. Remember, autonomous transactions are fully independent of the main transaction.</p>
</div>
</div>
<a id="LNPLS621"></a>
<div class="props_rev_3"><a id="GUID-CD2A248B-A1F7-474D-A1A9-73743A318B52"></a>
<h4 id="LNPLS-GUID-CD2A248B-A1F7-474D-A1A9-73743A318B52" class="sect4">Avoiding Errors with Autonomous Transactions</h4>
<div>
<p>To avoid some common errors, remember:</p>
<ul style="list-style-type: disc;">
<li>
<p>If an autonomous transaction tries to access a resource held by the main transaction, a deadlock can occur. The database raises an exception in the autonomous transaction, which rolls back if the exception is unhandled.</p>
</li>
<li>
<p>The database initialization parameter <code class="codeph">TRANSACTIONS</code> specifies the maximum number of concurrent transactions. That number might be exceeded because an autonomous transaction runs concurrently with the main transaction.</p>
</li>
<li>
<p>If you try to exit an active autonomous transaction without committing or rolling back, the database raises an exception. If the exception is unhandled, the transaction rolls back.</p>
</li>
<li>
<p>You cannot run a <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement in an autonomous routine while an autonomous transaction is open. You must close the autonomous transaction before running the <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement. This is normally accomplished by committing or rolling back the autonomous transaction before running the <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement.</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNPLS623"></a><a id="LNPLS511"></a><a id="LNPLS622"></a>
<div class="props_rev_3"><a id="GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908"></a>
<h3 id="LNPLS-GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908" class="sect3">Autonomous Triggers</h3>
<div>
<p>A trigger must be autonomous to run TCL or DDL statements.</p>
<p>To run DDL statements, the trigger must use native dynamic SQL.</p>
<div class="infoboxnotealso" id="GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908__GUID-4DA66B6D-2367-47E1-B6A3-6DA87E2464B3">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="triggers.htm#GUID-217E8B13-29EF-45F3-8D0F-2384F9F1D231" title="A trigger is like a stored procedure that Oracle Database invokes automatically whenever a specified event occurs.">PL/SQL Triggers</a>, for general information about triggers</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C" title="Static SQL has the same syntax as SQL, except as noted.">Description of Static SQL</a>&#34;</span> for general information about TCL statements</p>
</li>
<li>
<p><a class="olink SQLRF30041" target="_blank" href="../SQLRF/statements_1001.htm#SQLRF30041"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about DDL statements</p>
</li>
<li>
<p><span class="q">&#34;<a href="dynamic.htm#GUID-D2613968-6660-4AA2-9057-28E425A3040D" title="Native dynamic SQL processes most dynamic SQL statements with the EXECUTE IMMEDIATE statement.">Native Dynamic SQL</a>&#34;</span> for information about native dynamic SQL</p>
</li>
</ul>
</div>
<p>One use of triggers is to log events transparently&mdash;for example, to log all inserts into a table, even those that roll back.</p>
<div class="example" id="GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908__CJAICEDA">
<p class="titleinexample">Example 6-46 Autonomous Trigger Logs INSERT Statements</p>
<p>In this example, whenever a row is inserted into the <code class="codeph">EMPLOYEES</code> table, a trigger inserts the same row into a log table. Because the trigger is autonomous, it can commit changes to the log table regardless of whether they are committed to the main table.</p>
<pre dir="ltr">DROP TABLE emp;
CREATE TABLE emp AS SELECT * FROM employees;
 
-- Log table:
 
DROP TABLE log;
CREATE TABLE log (
  log_id   NUMBER(6),
  up_date  DATE,
  new_sal  NUMBER(8,2),
  old_sal  NUMBER(8,2)
);
 
-- Autonomous trigger on emp table:
 
CREATE OR REPLACE <span class="bold">TRIGGER log_sal</span>
  BEFORE UPDATE OF salary ON emp FOR EACH ROW
DECLARE
  <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span>
BEGIN
  INSERT INTO log (
    log_id,
    up_date,
    new_sal,
    old_sal
  )
  VALUES (
    :old.employee_id,
    SYSDATE,
    :new.salary,
    :old.salary
  );
  <span class="bold">COMMIT;</span>
END;
/
UPDATE emp
SET salary = salary * 1.05
WHERE employee_id = 115;
 
<span class="bold">COMMIT;</span>
 
UPDATE emp
SET salary = salary * 1.05
WHERE employee_id = 116;
 
<span class="bold">ROLLBACK;</span>
 
-- Show that both committed and rolled-back updates
-- add rows to log table
 
<span class="bold">SELECT * FROM log</span>
<span class="bold">WHERE log_id = 115 OR log_id = 116;</span>
</pre>
<p>Result:</p>
<pre dir="ltr">    LOG_ID UP_DATE      NEW_SAL    OLD_SAL
---------- --------- ---------- ----------
       115 02-OCT-12    3255          3100
       116 02-OCT-12    3045          2900
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908__CHDFJBDA">
<p class="titleinexample">Example 6-47 Autonomous Trigger Uses Native Dynamic SQL for DDL</p>
<p>In this example, an autonomous trigger uses native dynamic SQL (an <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement) to drop a temporary table after a row is inserted into the table <code class="codeph">log</code>.</p>
<pre dir="ltr">DROP TABLE temp;
CREATE TABLE temp (
  temp_id NUMBER(6),
  up_date DATE
);

CREATE OR REPLACE <span class="bold">TRIGGER drop_temp_table</span>
  AFTER INSERT ON log
DECLARE 
  <span class="bold">PRAGMA</span> <span class="bold">AUTONOMOUS_TRANSACTION</span>;
BEGIN
  <span class="bold">EXECUTE IMMEDIATE &#39;DROP TABLE temp&#39;;</span>
  COMMIT;
END;
/
-- Show how trigger works
<span class="bold">SELECT * FROM temp;</span>
 
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">no rows selected</span>

INSERT INTO log (log_id, up_date, new_sal, old_sal)
VALUES (999, SYSDATE, 5000, 4500);
 
1 row created.
 
<span class="bold">SELECT * FROM temp;</span>
 
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">SELECT * FROM temp</span>
              <span class="bold">*</span>
<span class="bold">ERROR at line 1:</span>
<span class="bold">ORA-00942: table or view does not exist</span>
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS625"></a><a id="LNPLS624"></a>
<div class="props_rev_3"><a id="GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE"></a>
<h3 id="LNPLS-GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE" class="sect3">Invoking Autonomous Functions from SQL</h3>
<div>
<p>A function invoked from SQL statements must obey rules meant to control side effects.</p>
<div class="section">
<p>By definition, an autonomous routine never reads or writes database state (that is, it neither queries nor modifies any database table).</p>
<div class="infoboxnotealso" id="GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE__GUID-F1DC804B-7EB8-40B4-BA64-B636FD3A8C65">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="subprograms.htm#GUID-6C6A828F-8FA0-4278-97D2-6D5649A66A9A">Subprogram Side Effects</a>&#34;</span> for more information</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE__CJAIGCJF">
<p class="titleinexample">Example 6-48 Invoking Autonomous Function</p>
<p>The package function <code class="codeph">log_msg</code> is autonomous. Therefore, when the query invokes the function, the function inserts a message into database table <code class="codeph">debug_output</code> without violating the rule against writing database state (modifying database tables).</p>
<pre dir="ltr">DROP TABLE debug_output;
CREATE TABLE debug_output (message VARCHAR2(200));
 
CREATE OR REPLACE PACKAGE debugging AUTHID DEFINER AS
  FUNCTION log_msg (msg VARCHAR2) RETURN VARCHAR2;
END debugging;
/
CREATE OR REPLACE PACKAGE BODY debugging AS
  FUNCTION log_msg (msg VARCHAR2) RETURN VARCHAR2 IS
    <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span>
  BEGIN
    INSERT INTO debug_output (message) VALUES (msg);
    COMMIT;
    RETURN msg;
  END;
END debugging;
/
-- Invoke package function from query
DECLARE
  my_emp_id    NUMBER(6);
  my_last_name VARCHAR2(25);
  my_count     NUMBER;
BEGIN
  my_emp_id := 120;
 
  SELECT <span class="bold">debugging.log_msg(last_name)</span>
  INTO my_last_name
  FROM employees
  WHERE employee_id = my_emp_id;
 
  /* Even if you roll back in this scope,
     the insert into &#39;debug_output&#39; remains committed,
     because it is part of an autonomous transaction. */
 
  ROLLBACK;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment869">
<tr>
<td class="cellalignment912">
<table class="cellalignment874">
<tr>
<td class="cellalignment873"><a href="composites.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment873"><a href="dynamic.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment914">
<table class="cellalignment872">
<tr>
<td class="cellalignment873"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment873"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment873"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment873"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment873"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment873"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>