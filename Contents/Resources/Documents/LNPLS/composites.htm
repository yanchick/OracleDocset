<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-78078"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/PL%2FSQL%20Collections%20and%20Records"></a><title>PL/SQL Collections and Records</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="PL/SQL lets you define two kinds of composite data types, collection and record."/>
<meta name="keywords" content="composite data type, data type, composite, collection, See, RECORD, record, subprogram parameter, composite variable as, composite variable, variable, remote subprogram, with composite parameter, subprogram, remote, element of collection, index of collection, field of record, dot notation, for record field, types of, associative array, characteristics of, array, associative, varray, nested table, table, nested, dense collection, sparse collection, empty collection, empty, null, null collection, atomically null collection, hash table, hash, unordered table, unordered, set data structure, bag data structure, non-PL/SQL, PL/SQL table, PL/SQL, index-by table, index-by, key-value pair, constant, declaring, declaring constant, NLS parameters, associative array and, NLS parameters and, Oracle Call Interface (OCI), OCI, variable-size array, initial value, of variable, store table, store, collection constructor, constructor, creating with constructor, assignment of value, to composite variable, assigning one to another, compatible data type, for collection variables, compatible, type-compatible data type, assigning null value to, NULL value, for collection variable, assigning to collection variable, assigning set operation result to, SQL MULTISET operator, multidimensional collection, multidimensional, comparing one to another, comparisons, comparing to collection, relational operator, collection and, operator, relational, comparing to NULL, IS [NOT] NULL operator, collections and, comparing two, SQL multiset conditions and, SQL multiset condition, multiset condition, condition, SQL multiset, collection method, method, collection, collection method and, null collection and, for collection method, SQL statement, invoking collection method in, collection as, as subprogram parameter, DELETE collection method, internal size of, DELETE method and, TRIM collection method, TRIM method and, EXTEND collection method, NOT NULL constraint, EXTEND method and, EXISTS collection method, EXISTS method and, FIRST collection method, LAST collection method, FIRST method and, LAST method and, FIRST and LAST methods for, COUNT collection method, COUNT method and, COUNT method for, LIMIT collection method, PRIOR collection method, NEXT collection method, PRIOR method and, NEXT method and, traversing, public package item, collection type as, as public package item, creating, nested record, declaration example, RECORD type as, %ROWTYPE attribute, attribute, %ROWTYPE, representing row, virtual columns and, virtual column, %ROWTYPE attribute and, invisible columns and, invisible column, assigning value to, assignment example, SELECT INTO statement, assigning values with, to record variable, FETCH statement, record variable and, assigning to record variable, INSERT statement, inserting record with, UPDATE statement, with values in record, restrictions on"/>
<meta name="dcterms.created" content="2017-05-09T17:03:42Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database PL/SQL Language Reference"/>
<meta name="dcterms.identifier" content="E50727-06"/>
<meta name="dcterms.isVersionOf" content="LNPLS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="controlstatements.htm" title="Previous" type="text/html"/>
<link rel="Next" href="static.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E50727-06.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A"></a> <span id="PAGE" style="display:none;">12/100</span> <!-- End Header -->
<a id="LNPLS345"></a><a id="LNPLS349"></a><a id="LNPLS005"></a>
<h1 id="LNPLS-GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" class="sect1"><span class="enumeration_chapter">5</span> PL/SQL Collections and Records</h1>
<div>
<p>PL/SQL lets you define two kinds of composite data types, collection and record.</p>
<p>A <span class="bold">composite data type</span> stores values that have internal components. You can pass entire composite variables to subprograms as parameters, and you can access internal components of composite variables individually. Internal components can be either scalar or composite. You can use scalar components wherever you can use scalar variables. You can use composite components wherever you can use composite variables of the same type.</p>
<div class="infobox-note" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__GUID-6EF2AA46-838A-412C-BEA8-34DE2B62FDFF">
<p class="notep1">Note:</p>
<p>If you pass a composite variable as a parameter to a remote subprogram, then you must create a redundant loop-back <code class="codeph">DATABASE</code> <code class="codeph">LINK</code>, so that when the remote subprogram compiles, the type checker that verifies the source uses the same definition of the user-defined composite variable type as the invoker uses.</p>
</div>
<p>In a <span class="bold">collection</span>, the internal components always have the same data type, and are called <span class="bold">elements</span>. You can access each element of a collection variable by its unique index, with this syntax: <span class="italic"><code class="codeph">variable_name</code></span><code class="codeph">(</code><span class="italic"><code class="codeph">index</code></span><code class="codeph">)</code>. To create a collection variable, you either define a collection type and then create a variable of that type or use <code class="codeph">%TYPE</code>.</p>
<p>In a <span class="bold">record</span>, the internal components can have different data types, and are called <span class="bold">fields</span>. You can access each field of a record variable by its name, with this syntax: <span class="italic"><code class="codeph">variable_name.field_name</code></span>. To create a record variable, you either define a <code class="codeph">RECORD</code> type and then create a variable of that type or use <code class="codeph">%ROWTYPE</code> or <code class="codeph">%TYPE</code>.</p>
<p>You can create a collection of records, and a record that contains collections.</p>
<div class="section" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__CHDFGHJF">
<p class="subhead1">Collection Topics</p>
</div>
<!-- class="section" -->
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-7E9034D5-0D33-43A1-9012-918350FE148C" title="PL/SQL has three collection types&mdash;associative array, VARRAY (variable-size array), and nested table.">Collection Types</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-8060F01F-B53B-48D4-9239-7EA8461C2170" title="An associative array (formerly called PL/SQL table or index-by table) is a set of key-value pairs. Each key is a unique index, used to locate the associated value with the syntax variable_name(index).">Associative Arrays</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8" title="A varray (variable-size array) is an array whose number of elements can vary from zero (empty) to the declared maximum size.">Varrays (Variable-Size Arrays)</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37" title="In the database, a nested table is a column type that stores an unspecified number of rows in no particular order.">Nested Tables</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="A collection constructor (constructor) is a system-defined function with the same name as a collection type, which returns a collection of that type.">Collection Constructors</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-7836EEC3-2642-4CF8-AA50-81034855119D" title="You can assign a collection to a collection variable only if they have the same data type. Having the same element type is not enough.To a varray or nested table variable, you can assign the value NULL or a null collection of the same data type. Either assignment makes the variable null.To a nested table variable, you can assign the result of a SQL MULTISET operation or SQL SET function invocation.">Assigning Values to Collection Variables</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F" title="Although a collection has only one dimension, you can model a multidimensional collection with a collection whose elements are collections.">Multidimensional Collections</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B" title="To determine if one collection variable is less than another (for example), you must define what less than means in that context and write a function that returns TRUE or FALSE.">Collection Comparisons</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="A collection method is a PL/SQL subprogram&mdash;either a function that returns information about a collection or a procedure that operates on a collection. Collection methods make collections easier to use and your applications easier to maintain.">Collection Methods</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47" title="A collection type defined in a package specification is incompatible with an identically defined local or standalone collection type.">Collection Types Defined in Package Specifications</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__GUID-B0D95F51-E52C-495B-A702-92017F35FB1A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF01205" target="_blank" href="../SQLRF/statements_5006.htm#SQLRF01205"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code class="codeph">CREATE</code> <code class="codeph">DATABASE</code> <code class="codeph">LINK</code> statement</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248">Querying a Collection</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="tuning.htm#GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" title="The BULK COLLECT clause, a feature of bulk SQL, returns results from SQL to PL/SQL in batches rather than one at a time.">BULK COLLECT Clause</a>&#34;</span> for information about retrieving query results into a collection</p>
</li>
<li>
<p><span class="q">&#34;<a href="collection_variable.htm#GUID-89A1863C-65A1-40CF-9392-86E9FDC21BE9" title="A collection variable is a composite variable whose internal components, called elements, have the same data type.">Collection Variable Declaration</a>&#34;</span> for syntax and semantics of collection type definition and collection variable declaration</p>
</li>
</ul>
</div>
<div class="section" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__CHDHCIAF">
<p class="subhead1">Record Topics</p>
</div>
<!-- class="section" -->
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-75875E26-FC7B-4513-A5E2-EDA26F1D67B1" title="For a record variable of a RECORD type, the initial value of each field is NULL unless you specify a different initial value for it when you define the type.When declaring a record constant, you must create a function that populates the record with its initial value and then invoke the function in the constant declaration.The %ROWTYPE attribute lets you declare a record variable that represents either a full or partial row of a database table or view.">Record Variables</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-794AD0D6-2D97-4C4A-B7DA-6126025EF2A5" title="A record variable means either a record variable or a record component of a composite variable.">Assigning Values to Record Variables</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-DFDE40BD-4B61-4C8A-B9CE-3FE01E21F658" title="Records cannot be tested natively for nullity, equality, or inequality.">Record Comparisons</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1" title="The PL/SQL extension to the SQL INSERT statement lets you insert a record into a table.">Inserting Records into Tables</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-11D63245-591D-4CBF-BFBA-8F3C0AE0E968" title="The PL/SQL extension to the SQL UPDATE statement lets you update one or more table rows with a record.">Updating Rows with Records</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-EC8E43E9-8356-4256-857A-D8109F2CF324">Restrictions on Record Inserts and Updates</a></p>
</li>
</ul>
<div class="infobox-note" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__GUID-0D9E1838-C09A-4C67-835C-6FFB729B07E0">
<p class="notep1">Note:</p>
<p>The components of an explicitly listed composite data structure (such as a collection constructor or record initializer) can be evaluated in any order. If a program determines order of evaluation, then at the point where the program does so, its behavior is undefined.</p>
</div>
</div>
<a id="LNPLS350"></a><a id="LNPLS351"></a><a id="LNPLS352"></a><a id="LNPLS353"></a><a id="LNPLS354"></a><a id="LNPLS355"></a><a id="LNPLS356"></a><a id="LNPLS00501"></a>
<div class="props_rev_3"><a id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C"></a>
<h2 id="LNPLS-GUID-7E9034D5-0D33-43A1-9012-918350FE148C" class="sect2">Collection Types</h2>
<div>
<p>PL/SQL has three collection types&mdash;associative array, <code class="codeph">VARRAY</code> (variable-size array), and nested table.</p>
<p><a href="composites.htm#GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF" title="Summarizes the similarities and differences of the three types of PL/SQL collections.">Table 5-1</a> summarizes their similarities and differences.</p>
<div class="tblformalwide" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF">
<p class="titleintable">Table 5-1 PL/SQL Collection Types</p>
<table class="cellalignment885" title="PL/SQL Collection Types" summary="Summarizes the similarities and differences of the three types of PL/SQL collections.">
<thead>
<tr class="cellalignment870">
<th class="cellalignment881" id="d35329e605">Collection Type</th>
<th class="cellalignment915" id="d35329e607">Number of Elements</th>
<th class="cellalignment929" id="d35329e609">Index Type</th>
<th class="cellalignment930" id="d35329e611">Dense or Sparse</th>
<th class="cellalignment930" id="d35329e613">Uninitialized Status</th>
<th class="cellalignment894" id="d35329e615">Where Defined</th>
<th class="cellalignment886" id="d35329e617">Can Be ADT Attribute Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment870">
<td class="cellalignment883" id="d35329e621" headers="d35329e605">
<p>Associative array (or index-by table)</p>
</td>
<td class="cellalignment917" headers="d35329e621 d35329e607">
<p>Unspecified</p>
</td>
<td class="cellalignment931" headers="d35329e621 d35329e609">
<p>String or <code class="codeph">PLS_INTEGER</code></p>
</td>
<td class="cellalignment932" headers="d35329e621 d35329e611">
<p>Either</p>
</td>
<td class="cellalignment932" headers="d35329e621 d35329e613">
<p>Empty</p>
</td>
<td class="cellalignment897" headers="d35329e621 d35329e615">
<p>In PL/SQL block or package</p>
</td>
<td class="cellalignment890" headers="d35329e621 d35329e617">
<p>No</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment883" id="d35329e645" headers="d35329e605">
<p><code class="codeph">VARRAY</code> (variable-size array)</p>
</td>
<td class="cellalignment917" headers="d35329e645 d35329e607">
<p>Specified</p>
</td>
<td class="cellalignment931" headers="d35329e645 d35329e609">
<p>Integer</p>
</td>
<td class="cellalignment932" headers="d35329e645 d35329e611">
<p>Always dense</p>
</td>
<td class="cellalignment932" headers="d35329e645 d35329e613">
<p>Null</p>
</td>
<td class="cellalignment897" headers="d35329e645 d35329e615">
<p>In PL/SQL block or package or at schema level</p>
</td>
<td class="cellalignment890" headers="d35329e645 d35329e617">
<p>Only if defined at schema level</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment883" id="d35329e669" headers="d35329e605">
<p>Nested table</p>
</td>
<td class="cellalignment917" headers="d35329e669 d35329e607">
<p>Unspecified</p>
</td>
<td class="cellalignment931" headers="d35329e669 d35329e609">
<p>Integer</p>
</td>
<td class="cellalignment932" headers="d35329e669 d35329e611">
<p>Starts dense, can become sparse</p>
</td>
<td class="cellalignment932" headers="d35329e669 d35329e613">
<p>Null</p>
</td>
<td class="cellalignment897" headers="d35329e669 d35329e615">
<p>In PL/SQL block or package or at schema level</p>
</td>
<td class="cellalignment890" headers="d35329e669 d35329e617">
<p>Only if defined at schema level</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHHHAG">
<p class="subhead2">Number of Elements</p>
</div>
<!-- class="section" -->
<div class="section">
<p>If the number of elements is specified, it is the maximum number of elements in the collection. If the number of elements is unspecified, the maximum number of elements in the collection is the upper limit of the index type.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHDHIFD">
<p class="subhead2">Dense or Sparse</p>
</div>
<!-- class="section" -->
<div class="section">
<p>A <span class="bold">dense collection</span> has no gaps between elements&mdash;every element between the first and last element is defined and has a value (the value can be <code class="codeph">NULL</code> unless the element has a <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint). A <span class="bold">sparse collection</span> has gaps between elements.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHCDDDG">
<p class="subhead2">Uninitialized Status</p>
</div>
<!-- class="section" -->
<div class="section">
<p>An <span class="bold">empty collection</span> exists but has no elements. To add elements to an empty collection, invoke the <code class="codeph">EXTEND</code> method (described in <span class="q">&#34;<a href="composites.htm#GUID-03F74821-BC33-4544-9304-5FBBE6EFE450" title="EXTEND is a procedure that adds elements to the end of a varray or nested table.">EXTEND Collection Method</a>&#34;</span>).</p>
<p>A <span class="bold">null collection</span> (also called an <span class="bold">atomically null collection</span>) does not exist. To change a null collection to an existing collection, you must initialize it, either by making it empty or by assigning a non-<code class="codeph">NULL</code> value to it (for details, see <span class="q">&#34;<a href="composites.htm#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="A collection constructor (constructor) is a system-defined function with the same name as a collection type, which returns a collection of that type.">Collection Constructors</a>&#34;</span> and <span class="q">&#34;<a href="composites.htm#GUID-7836EEC3-2642-4CF8-AA50-81034855119D" title="You can assign a collection to a collection variable only if they have the same data type. Having the same element type is not enough.To a varray or nested table variable, you can assign the value NULL or a null collection of the same data type. Either assignment makes the variable null.To a nested table variable, you can assign the result of a SQL MULTISET operation or SQL SET function invocation.">Assigning Values to Collection Variables</a>&#34;</span>). You cannot use the <code class="codeph">EXTEND</code> method to initialize a null collection.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHFCEAE">
<p class="subhead2">Where Defined</p>
</div>
<!-- class="section" -->
<div class="section">
<p>A collection type defined in a PL/SQL block is a <span class="bold">local type</span>. It is available only in the block, and is stored in the database only if the block is in a standalone or package subprogram. (Standalone and package subprograms are explained in <span class="q">&#34;<a href="subprograms.htm#GUID-E03F512B-1A30-43B4-8DCA-64DA68AE7CE4">Nested, Package, and Standalone Subprograms</a>&#34;</span>.)</p>
<p>A collection type defined in a package specification is a <span class="bold">public item</span>. You can reference it from outside the package by qualifying it with the package name (<span class="italic"><code class="codeph">package_name.type_name</code></span>). It is stored in the database until you drop the package. (Packages are explained in <a href="packages.htm#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">PL/SQL Packages</a>.)</p>
<p>A collection type defined at schema level is a <span class="bold">standalone type</span>. You create it with the <span class="q">&#34;<a href="create_type.htm#GUID-389D603D-FBD0-452A-8414-240BBBC57034" title="The CREATE TYPE statement specifies the name of the type and its attributes, methods, and other properties.">CREATE TYPE Statement</a>&#34;</span>. It is stored in the database until you drop it with the <span class="q">&#34;<a href="drop_type.htm#GUID-EDB83D12-26B5-42D1-9DB6-BD8AAB6490EC" title="The DROP TYPE statement drops the specification and body of an ADT, VARRAY type, or nested table type.">DROP TYPE Statement</a>&#34;</span>.</p>
<div class="infobox-note" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-B496A4B0-5BE4-4189-A0AD-41B60A82018A">
<p class="notep1">Note:</p>
<p>A collection type defined in a package specification is incompatible with an identically defined local or standalone collection type (see <a href="composites.htm#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CHDIHDIJ">Example 5-31</a> and <a href="composites.htm#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CIHBGBBH">Example 5-32</a>).</p>
</div>
</div>
<!-- class="section" -->
<div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHDDDIG">
<p class="subhead2">Can Be ADT Attribute Data Type</p>
</div>
<!-- class="section" -->
<div class="section">
<p>To be an ADT attribute data type, a collection type must be a standalone collection type. For other restrictions, see <span class="bold"><a href="create_type.htm#GUID-389D603D-FBD0-452A-8414-240BBBC57034__BABEHDBJ">Restrictions on datatype</a></span>.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Translating Non-PL/SQL Composite Types to PL/SQL Composite Types</p>
</div>
<!-- class="section" -->
<div class="section">
<p>If you have code or business logic that uses another language, you can usually translate the array and set types of that language directly to PL/SQL collection types. For example:</p>
<div class="tblformal" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-40D3ACE9-7926-4D89-BD10-2A576AC86A6C">
<table class="cellalignment876" summary="This table gives five examples of non-PL/SQL composite types and their equivalent PL/SQL composite types.">
<thead>
<tr class="cellalignment870">
<th class="cellalignment901" id="d35329e876">Non-PL/SQL Composite Type</th>
<th class="cellalignment933" id="d35329e878">Equivalent PL/SQL Composite Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment870">
<td class="cellalignment904" id="d35329e882" headers="d35329e876">
<p>Hash table</p>
</td>
<td class="cellalignment934" headers="d35329e882 d35329e878">
<p>Associative array</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment904" id="d35329e889" headers="d35329e876">
<p>Unordered table</p>
</td>
<td class="cellalignment934" headers="d35329e889 d35329e878">
<p>Associative array</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment904" id="d35329e896" headers="d35329e876">
<p>Set</p>
</td>
<td class="cellalignment934" headers="d35329e896 d35329e878">
<p>Nested table</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment904" id="d35329e903" headers="d35329e876">
<p>Bag</p>
</td>
<td class="cellalignment934" headers="d35329e903 d35329e878">
<p>Nested table</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment904" id="d35329e910" headers="d35329e876">
<p>Array</p>
</td>
<td class="cellalignment934" headers="d35329e910 d35329e878">
<p><code class="codeph">VARRAY</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="infoboxnotealso" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-6AEE21F7-4CEB-4628-9515-2AA6D78C4601">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF00613" target="_blank" href="../SQLRF/functions024.htm#SQLRF00613"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code class="codeph">CAST</code> function, which converts one SQL data type or collection-typed value into another SQL data type or collection-typed value.</p>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS357"></a><a id="LNPLS440"></a><a id="LNPLS461"></a><a id="LNPLS99969"></a>
<div class="props_rev_3"><a id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170"></a>
<h2 id="LNPLS-GUID-8060F01F-B53B-48D4-9239-7EA8461C2170" class="sect2">Associative Arrays</h2>
<div>
<p>An <span class="bold">associative array</span> (formerly called <span class="bold">PL/SQL table</span> or <span class="bold">index-by table</span>) is a set of key-value pairs. Each key is a unique index, used to locate the associated value with the syntax <span class="italic"><code class="codeph">variable_name</code></span><code class="codeph">(</code><span class="italic"><code class="codeph">index</code></span><code class="codeph">)</code>.</p>
<p>The data type of <span class="italic"><code class="codeph">index</code></span> can be either a string type (<code class="codeph">VARCHAR2</code>, <code class="codeph">VARCHAR</code>, <code class="codeph">STRING</code>, or <code class="codeph">LONG</code>) or <code class="codeph">PLS_INTEGER</code>. Indexes are stored in sort order, not creation order. For string types, sort order is determined by the initialization parameters <code class="codeph">NLS_SORT</code> and <code class="codeph">NLS_COMP</code>.</p>
<p>Like a database table, an associative array:</p>
<ul style="list-style-type: disc;">
<li>
<p>Is empty (but not null) until you populate it</p>
</li>
<li>
<p>Can hold an unspecified number of elements, which you can access without knowing their positions</p>
</li>
</ul>
<p>Unlike a database table, an associative array:</p>
<ul style="list-style-type: disc;">
<li>
<p>Does not need disk space or network operations</p>
</li>
<li>
<p>Cannot be manipulated with DML statements</p>
</li>
</ul>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763" title="When declaring an associative array constant, you must create a function that populates the associative array with its initial value and then invoke the function in the constant declaration.">Declaring Associative Array Constants</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26" title="National Language Support (NLS) parameters such as NLS_SORT, NLS_COMP, and NLS_DATE_FORMAT affect associative arrays indexed by string.">NLS Parameter Values Affect Associative Arrays Indexed by String</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF">Appropriate Uses for Associative Arrays</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__GUID-A68FDBE6-7DCC-4851-AF57-C794CAB47DCE">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF" title="Summarizes the similarities and differences of the three types of PL/SQL collections.">Table 5-1</a> for a summary of associative array characteristics</p>
</li>
<li>
<p><span class="q">&#34;<a href="collection_variable.htm#GUID-89A1863C-65A1-40CF-9392-86E9FDC21BE9__CJABHAHJ">assoc_array_type_def ::=</a>&#34;</span> for the syntax of an associative array type definition</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__BABHGFHJ">
<p class="titleinexample">Example 5-1 Associative Array Indexed by String</p>
<p>This example defines a type of associative array indexed by string, declares a variable of that type, populates the variable with three elements, changes the value of one element, and prints the values (in sort order, not creation order). (<code class="codeph">FIRST</code> and <code class="codeph">NEXT</code> are collection methods, described in <span class="q">&#34;<a href="composites.htm#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="A collection method is a PL/SQL subprogram&mdash;either a function that returns information about a collection or a procedure that operates on a collection. Collection methods make collections easier to use and your applications easier to maintain.">Collection Methods</a>&#34;</span>.)</p>
<div class="infobox-note" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__GUID-0C29D90D-C33F-48C2-BB9D-F36CD3C16912">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites1.html" target="_blank">Associative Array Indexed by String</a></p>
</div>
<pre dir="ltr">DECLARE
  -- Associative array indexed by string:
  
  TYPE population IS TABLE OF NUMBER  -- Associative array type
    INDEX BY VARCHAR2(64);            --  indexed by string
  
  city_population  population;        -- Associative array variable
  i  VARCHAR2(64);                    -- Scalar variable
  
BEGIN
  -- Add elements (key-value pairs) to associative array:
 
  city_population(&#39;Smallville&#39;)  := 2000;
  city_population(&#39;Midland&#39;)     := 750000;
  city_population(&#39;Megalopolis&#39;) := 1000000;
 
  -- Change value associated with key &#39;Smallville&#39;:
 
  city_population(&#39;Smallville&#39;) := 2001;
 
  -- Print associative array:
 
  i := city_population.FIRST;  -- Get first element of array
 
  WHILE i IS NOT NULL LOOP
    DBMS_Output.PUT_LINE
      (&#39;Population of &#39; || i || &#39; is &#39; || city_population(i));
    i := city_population.NEXT(i);  -- Get next element of array
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Population of Megalopolis is 1000000
Population of Midland is 750000
Population of Smallville is 2001
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__BEIEBJJI">
<p class="titleinexample">Example 5-2 Function Returns Associative Array Indexed by PLS_INTEGER</p>
<p>This example defines a type of associative array indexed by <code class="codeph">PLS_INTEGER</code> and a function that returns an associative array of that type.</p>
<div class="infobox-note" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__GUID-C0815BC3-A861-4AC9-A667-DA0C20C3BA6C">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites16.html" target="_blank">Function Returns Associative Array Indexed by PLS_INTEGER</a></p>
</div>
<pre dir="ltr">DECLARE
  <span class="bold">TYPE sum_multiples IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;</span>
  n  PLS_INTEGER := 5;   -- number of multiples to sum for display
  sn PLS_INTEGER := 10;  -- number of multiples to sum
  m  PLS_INTEGER := 3;   -- multiple

  <span class="bold">FUNCTION get_sum_multiples (</span>
    multiple IN PLS_INTEGER,
    num      IN PLS_INTEGER
  <span class="bold">) RETURN sum_multiples</span>
  IS
    s sum_multiples;
  BEGIN
    FOR i IN 1..num LOOP
      s(i) := multiple * ((i * (i + 1)) / 2);  -- sum of multiples
    END LOOP;
    RETURN s;
  END get_sum_multiples;

BEGIN
  DBMS_OUTPUT.PUT_LINE (
    &#39;Sum of the first &#39; || TO_CHAR(n) || &#39; multiples of &#39; ||
    TO_CHAR(m) || &#39; is &#39; || TO_CHAR(get_sum_multiples (m, sn)(n))
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Sum of the first 5 multiples of 3 is 45
</pre></div>
<!-- class="example" --></div>
<a id="LNPLS358"></a><a id="LNPLS99857"></a>
<div class="props_rev_3"><a id="GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763"></a>
<h3 id="LNPLS-GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763" class="sect3">Declaring Associative Array Constants</h3>
<div>
<p>When declaring an associative array constant, you must create a function that populates the associative array with its initial value and then invoke the function in the constant declaration.</p>
<div class="section">
<p>For information about constructors, see <span class="q">&#34;<a href="composites.htm#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="A collection constructor (constructor) is a system-defined function with the same name as a collection type, which returns a collection of that type.">Collection Constructors</a>&#34;</span>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763__BABIBCCB">
<p class="titleinexample">Example 5-3 Declaring Associative Array Constant</p>
<p>In this example, the function does for the associative array what a constructor does for a varray or nested table.</p>
<div class="infobox-note" id="GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763__GUID-2B3FA43D-9805-4E4E-8850-E796A810D4CE">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites89.html" target="_blank">Declaring Associative Array Constant</a></p>
</div>
<pre dir="ltr">CREATE OR REPLACE PACKAGE My_Types AUTHID CURRENT_USER IS
  TYPE My_AA IS TABLE OF VARCHAR2(20) INDEX BY PLS_INTEGER;
  FUNCTION Init_My_AA RETURN My_AA;
END My_Types;
/
CREATE OR REPLACE PACKAGE BODY My_Types IS
  <span class="bold">FUNCTION Init_My_AA RETURN My_AA IS</span>
    <span class="bold">Ret My_AA;</span>
  <span class="bold">BEGIN</span>
    <span class="bold">Ret(-10) := &#39;-ten&#39;;</span>
    <span class="bold">Ret(0) := &#39;zero&#39;;</span>
    <span class="bold">Ret(1) := &#39;one&#39;;</span>
    <span class="bold">Ret(2) := &#39;two&#39;;</span>
    <span class="bold">Ret(3) := &#39;three&#39;;</span>
    <span class="bold">Ret(4) := &#39;four&#39;;</span>
    <span class="bold">Ret(9) := &#39;nine&#39;;</span>
    <span class="bold">RETURN Ret;</span>
  <span class="bold">END Init_My_AA;</span>
END My_Types;
/
DECLARE
  <span class="bold">v CONSTANT My_Types.My_AA := My_Types.Init_My_AA();</span>
BEGIN
  DECLARE
    Idx PLS_INTEGER := v.FIRST();
  BEGIN
    WHILE Idx IS NOT NULL LOOP
      DBMS_OUTPUT.PUT_LINE(TO_CHAR(Idx, &#39;999&#39;)||LPAD(v(Idx), 7));
      Idx := v.NEXT(Idx);
    END LOOP;
  END;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">-10   -ten
0   zero
1    one
2    two
3  three
4   four
9   nine
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS359"></a><a id="LNPLS99931"></a>
<div class="props_rev_3"><a id="GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26"></a>
<h3 id="LNPLS-GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26" class="sect3">NLS Parameter Values Affect Associative Arrays Indexed by String</h3>
<div>
<p>National Language Support (NLS) parameters such as <code class="codeph">NLS_SORT</code>, <code class="codeph">NLS_COMP</code>, and <code class="codeph">NLS_DATE_FORMAT</code> affect associative arrays indexed by string.</p>
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-7B7C16A9-7252-430B-83D6-71A2B7B56500" title="The initialization parameters NLS_SORT and NLS_COMP determine the storage order of string indexes of an associative array.">Changing NLS Parameter Values After Populating Associative Arrays</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-3D25039B-4ACD-492A-B913-1548FA2FE624" title="In the declaration of an associative array indexed by string, the string type must be VARCHAR2 or one of its subtypes.">Indexes of Data Types Other Than VARCHAR2</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-897FB965-310B-4C34-BDC5-A272E0618324">Passing Associative Arrays to Remote Databases</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26__GUID-F60389E0-55A8-4899-845E-EF26AAD91B07">
<p class="notep1">See Also:</p>
<p><a class="olink NLSPG229" target="_blank" href="../NLSPG/ch3globenv.htm#NLSPG229"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information about linguistic sort parameters</p>
</div>
</div>
<!-- class="section" --></div>
<a id="LNPLS360"></a>
<div class="props_rev_3"><a id="GUID-7B7C16A9-7252-430B-83D6-71A2B7B56500"></a>
<h4 id="LNPLS-GUID-7B7C16A9-7252-430B-83D6-71A2B7B56500" class="sect4">Changing NLS Parameter Values After Populating Associative Arrays</h4>
<div>
<p>The initialization parameters <code class="codeph">NLS_SORT</code> and <code class="codeph">NLS_COMP</code> determine the storage order of string indexes of an associative array.</p>
<div class="section">
<p>If you change the value of either parameter after populating an associative array indexed by string, then the collection methods <code class="codeph">FIRST</code>, <code class="codeph">LAST</code>, <code class="codeph">NEXT</code>, and <code class="codeph">PRIOR</code> might return unexpected values or raise exceptions. If you must change these parameter values during your session, restore their original values before operating on associative arrays indexed by string.</p>
<div class="infoboxnotealso" id="GUID-7B7C16A9-7252-430B-83D6-71A2B7B56500__GUID-64241E6E-7963-443D-AD8A-CF40081FD266">
<p class="notep1">See Also:</p>
<a href="composites.htm#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="A collection method is a PL/SQL subprogram&mdash;either a function that returns information about a collection or a procedure that operates on a collection. Collection methods make collections easier to use and your applications easier to maintain.">Collection Methods</a> for more information about <code class="codeph">FIRST</code>, <code class="codeph">LAST</code>, <code class="codeph">NEXT</code>, and <code class="codeph">PRIOR</code></div>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS361"></a>
<div class="props_rev_3"><a id="GUID-3D25039B-4ACD-492A-B913-1548FA2FE624"></a>
<h4 id="LNPLS-GUID-3D25039B-4ACD-492A-B913-1548FA2FE624" class="sect4">Indexes of Data Types Other Than VARCHAR2</h4>
<div>
<p>In the declaration of an associative array indexed by string, the string type must be <code class="codeph">VARCHAR2</code> or one of its subtypes.</p>
<p>However, you can populate the associative array with indexes of any data type that the <code class="codeph">TO_CHAR</code> function can convert to <code class="codeph">VARCHAR2</code>.</p>
<p>If your indexes have data types other than <code class="codeph">VARCHAR2</code> and its subtypes, ensure that these indexes remain consistent and unique if the values of initialization parameters change. For example:</p>
<ul style="list-style-type: disc;">
<li>
<p>Do not use <code class="codeph">TO_CHAR(SYSDATE)</code> as an index.</p>
<p>If the value of <code class="codeph">NLS_DATE_FORMAT</code> changes, then the value of <code class="codeph">(TO_CHAR(SYSDATE))</code> might also change.</p>
</li>
<li>
<p>Do not use different <code class="codeph">NVARCHAR2</code> indexes that might be converted to the same <code class="codeph">VARCHAR2</code> value.</p>
</li>
<li>
<p>Do not use <code class="codeph">CHAR</code> or <code class="codeph">VARCHAR2</code> indexes that differ only in case, accented characters, or punctuation characters.</p>
<p>If the value of <code class="codeph">NLS_SORT</code> ends in <code class="codeph">_CI</code> (case-insensitive comparisons) or <code class="codeph">_AI</code> (accent- and case-insensitive comparisons), then indexes that differ only in case, accented characters, or punctuation characters might be converted to the same value.</p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-3D25039B-4ACD-492A-B913-1548FA2FE624__GUID-8CCB8EE5-678F-4CC3-A7DA-AD1B031124D5">
<p class="notep1">See Also:</p>
<a class="olink SQLRF06128" target="_blank" href="../SQLRF/functions215.htm#SQLRF06128"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code class="codeph">TO_CHAR</code></div>
</div>
</div>
<a id="LNPLS362"></a>
<div class="props_rev_3"><a id="GUID-897FB965-310B-4C34-BDC5-A272E0618324"></a>
<h4 id="LNPLS-GUID-897FB965-310B-4C34-BDC5-A272E0618324" class="sect4">Passing Associative Arrays to Remote Databases</h4>
<div>
<div class="section">
<p>If you pass an associative array as a parameter to a remote database, and the local and the remote databases have different <code class="codeph">NLS_SORT</code> or <code class="codeph">NLS_COMP</code> values, then:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The collection method <code class="codeph">FIRST</code>, <code class="codeph">LAST</code>, <code class="codeph">NEXT</code> or <code class="codeph">PRIOR</code> (described in <span class="q">&#34;<a href="composites.htm#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="A collection method is a PL/SQL subprogram&mdash;either a function that returns information about a collection or a procedure that operates on a collection. Collection methods make collections easier to use and your applications easier to maintain.">Collection Methods</a>&#34;</span>) might return unexpected values or raise exceptions.</p>
</li>
<li>
<p>Indexes that are unique on the local database might not be unique on the remote database, raising the predefined exception <code class="codeph">VALUE_ERROR</code>.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="LNPLS99930"></a>
<div class="props_rev_3"><a id="GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF"></a>
<h3 id="LNPLS-GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF" class="sect3">Appropriate Uses for Associative Arrays</h3>
<div>
<p>An associative array is appropriate for:</p>
<ul style="list-style-type: disc;">
<li>
<p>A relatively small lookup table, which can be constructed in memory each time you invoke the subprogram or initialize the package that declares it</p>
</li>
<li>
<p>Passing collections to and from the database server</p>
<p>Declare formal subprogram parameters of associative array types. With Oracle Call Interface (OCI) or an Oracle precompiler, bind the host arrays to the corresponding actual parameters. PL/SQL automatically converts between host arrays and associative arrays indexed by <code class="codeph">PLS_INTEGER</code>.</p>
<div class="infobox-note" id="GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF__GUID-1E9C9625-EDDE-417E-8952-00976CE0D5F8">
<p class="notep1">Note:</p>
<p>You cannot bind an associative array indexed by <code class="codeph">VARCHAR</code>.</p>
</div>
<div class="infobox-note" id="GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF__GUID-7C2C33A5-9B95-4EB8-A50C-4131EE3F2F93">
<p class="notep1">Note:</p>
<p>You cannot declare an associative array type at schema level. Therefore, to pass an associative array variable as a parameter to a standalone subprogram, you must declare the type of that variable in a package specification. Doing so makes the type available to both the invoked subprogram (which declares a formal parameter of that type) and the invoking subprogram or anonymous block (which declares and passes the variable of that type). See <a href="packages.htm#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">Example 10-2</a>.</p>
</div>
<div class="infoboxnotealso" id="GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF__GUID-7A878904-CEF4-47DD-BCC4-0EFE3C2C913A">
<p class="notep1">Tip:</p>
<p>The most efficient way to pass collections to and from the database server is to use associative arrays with the <code class="codeph">FORALL</code> statement or <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause. For details, see <span class="q">&#34;<a href="tuning.htm#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="The FORALL statement, a feature of bulk SQL, sends DML statements from PL/SQL to SQL in batches rather than one at a time.">FORALL Statement</a>&#34;</span> and <span class="q">&#34;<a href="tuning.htm#GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" title="The BULK COLLECT clause, a feature of bulk SQL, returns results from SQL to PL/SQL in batches rather than one at a time.">BULK COLLECT Clause</a>&#34;</span>.</p>
</div>
</li>
</ul>
<p>An associative array is intended for temporary data storage. To make an associative array persistent for the life of a database session, declare it in a package specification and populate it in the package body.</p>
</div>
</div>
</div>
<a id="LNPLS363"></a><a id="LNPLS365"></a><a id="LNPLS364"></a><a id="LNPLS443"></a>
<div class="props_rev_3"><a id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8"></a>
<h2 id="LNPLS-GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8" class="sect2">Varrays (Variable-Size Arrays)</h2>
<div>
<p>A <span class="bold">varray (variable-size array)</span> is an array whose number of elements can vary from zero (empty) to the declared maximum size.</p>
<p>To access an element of a varray variable, use the syntax <span class="italic"><code class="codeph">variable_name</code></span><code class="codeph">(</code><span class="italic"><code class="codeph">index</code></span><code class="codeph">)</code>. The lower bound of <span class="italic"><code class="codeph">index</code></span> is 1; the upper bound is the current number of elements. The upper bound changes as you add or delete elements, but it cannot exceed the maximum size. When you store and retrieve a varray from the database, its indexes and element order remain stable.</p>
<p><a href="composites.htm#GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__CIHGHIBH">Figure 5-1</a>shows a varray variable named <code class="codeph">Grades</code>, which has maximum size 10 and contains seven elements. <code class="codeph">Grades</code>(<span class="italic"><code class="codeph">n</code></span>) references the <span class="italic">n</span>th element of <code class="codeph">Grades</code>. The upper bound of <code class="codeph">Grades</code> is 7, and it cannot exceed 10.</p>
<div class="figure" id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__CIHGHIBH">
<p class="titleinfigure">Figure 5-1 Varray of Maximum Size 10 with 7 Elements</p>
<img width="443" height="65" src="img/lnpls017.gif" alt="Description of Figure 5-1 follows" title="Description of Figure 5-1 follows"/><br/>
<a href="img_text/lnpls017.htm">Description of &#34;Figure 5-1 Varray of Maximum Size 10 with 7 Elements&#34;</a></div>
<!-- class="figure" -->
<p>The database stores a varray variable as a single object. If a varray variable is less than 4 KB, it resides inside the table of which it is a column; otherwise, it resides outside the table but in the same tablespace.</p>
<p>An uninitialized varray variable is a null collection. You must initialize it, either by making it empty or by assigning a non-<code class="codeph">NULL</code> value to it. For details, see <span class="q">&#34;<a href="composites.htm#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="A collection constructor (constructor) is a system-defined function with the same name as a collection type, which returns a collection of that type.">Collection Constructors</a>&#34;</span> and <span class="q">&#34;<a href="composites.htm#GUID-7836EEC3-2642-4CF8-AA50-81034855119D" title="You can assign a collection to a collection variable only if they have the same data type. Having the same element type is not enough.To a varray or nested table variable, you can assign the value NULL or a null collection of the same data type. Either assignment makes the variable null.To a nested table variable, you can assign the result of a SQL MULTISET operation or SQL SET function invocation.">Assigning Values to Collection Variables</a>&#34;</span>.</p>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-45577352-2701-472B-88FA-CF2AC8B09153">Appropriate Uses for Varrays</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__GUID-3125AF89-4B88-408A-A64B-3EAE1EB7C406">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF" title="Summarizes the similarities and differences of the three types of PL/SQL collections.">Table 5-1</a> for a summary of varray characteristics</p>
</li>
<li>
<p><span class="q">&#34;<a href="collection_variable.htm#GUID-89A1863C-65A1-40CF-9392-86E9FDC21BE9__CJAEAJJA">varray_type_def ::=</a>&#34;</span> for the syntax of a <code class="codeph">VARRAY</code> type definition</p>
</li>
<li>
<p><span class="q">&#34;<a href="create_type.htm#GUID-389D603D-FBD0-452A-8414-240BBBC57034" title="The CREATE TYPE statement specifies the name of the type and its attributes, methods, and other properties.">CREATE TYPE Statement</a>&#34;</span> for information about creating standalone <code class="codeph">VARRAY</code> types</p>
</li>
<li>
<p><a class="olink SQLRF51007" target="_blank" href="../SQLRF/sql_elements001.htm#SQLRF51007"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about varrays</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__CIHFJAAD">
<p class="titleinexample">Example 5-4 Varray (Variable-Size Array)</p>
<p>This example defines a local <code class="codeph">VARRAY</code> type, declares a variable of that type (initializing it with a constructor), and defines a procedure that prints the varray. The example invokes the procedure three times: After initializing the variable, after changing the values of two elements individually, and after using a constructor to the change the values of all elements. (For an example of a procedure that prints a varray that might be null or empty, see <a href="composites.htm#GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089__CIHHAEGC">Example 5-24</a>.)</p>
<div class="infobox-note" id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__GUID-C7D9FA81-C8E7-4071-A007-0DEAD0186D27">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites57.html" target="_blank">Varray (Variable-Size Array)</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE Foursome IS VARRAY(4) OF VARCHAR2(15);  -- VARRAY type
 
  -- varray variable initialized with constructor:
 
  team Foursome := Foursome(&#39;John&#39;, &#39;Mary&#39;, &#39;Alberto&#39;, &#39;Juanita&#39;);
 
  PROCEDURE print_team (heading VARCHAR2) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    FOR i IN 1..4 LOOP
      DBMS_OUTPUT.PUT_LINE(i || &#39;.&#39; || team(i));
    END LOOP;
 
    DBMS_OUTPUT.PUT_LINE(&#39;---&#39;); 
  END;
  
BEGIN 
  print_team(&#39;2001 Team:&#39;);
 
  team(3) := &#39;Pierre&#39;;  -- Change values of two elements
  team(4) := &#39;Yvonne&#39;;
  print_team(&#39;2005 Team:&#39;);
 
  -- Invoke constructor to assign new values to varray variable:
 
  team := Foursome(&#39;Arun&#39;, &#39;Amitha&#39;, &#39;Allan&#39;, &#39;Mae&#39;);
  print_team(&#39;2009 Team:&#39;);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">2001 Team:
1.John
2.Mary
3.Alberto
4.Juanita
---
2005 Team:
1.John
2.Mary
3.Pierre
4.Yvonne
---
2009 Team:
1.Arun
2.Amitha
3.Allan
4.Mae
---
</pre></div>
<!-- class="example" --></div>
<a id="LNPLS99929"></a>
<div class="props_rev_3"><a id="GUID-45577352-2701-472B-88FA-CF2AC8B09153"></a>
<h3 id="LNPLS-GUID-45577352-2701-472B-88FA-CF2AC8B09153" class="sect3">Appropriate Uses for Varrays</h3>
<div>
<p>A varray is appropriate when:</p>
<ul style="list-style-type: disc;">
<li>
<p>You know the maximum number of elements.</p>
</li>
<li>
<p>You usually access the elements sequentially.</p>
</li>
</ul>
<p>Because you must store or retrieve all elements at the same time, a varray might be impractical for large numbers of elements.</p>
</div>
</div>
</div>
<a id="LNPLS368"></a><a id="LNPLS366"></a><a id="LNPLS367"></a><a id="LNPLS99981"></a>
<div class="props_rev_3"><a id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37"></a>
<h2 id="LNPLS-GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37" class="sect2">Nested Tables</h2>
<div>
<p>In the database, a <span class="bold">nested table</span> is a column type that stores an unspecified number of rows in no particular order.</p>
<p>When you retrieve a nested table value from the database into a PL/SQL nested table variable, PL/SQL gives the rows consecutive indexes, starting at 1. Using these indexes, you can access the individual rows of the nested table variable. The syntax is <span class="italic"><code class="codeph">variable_name</code></span><code class="codeph">(</code><span class="italic"><code class="codeph">index</code></span><code class="codeph">)</code>. The indexes and row order of a nested table might not remain stable as you store and retrieve the nested table from the database.</p>
<p>The amount of memory that a nested table variable occupies can increase or decrease dynamically, as you add or delete elements.</p>
<p>An uninitialized nested table variable is a null collection. You must initialize it, either by making it empty or by assigning a non-<code class="codeph">NULL</code> value to it. For details, see <span class="q">&#34;<a href="composites.htm#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="A collection constructor (constructor) is a system-defined function with the same name as a collection type, which returns a collection of that type.">Collection Constructors</a>&#34;</span> and <span class="q">&#34;<a href="composites.htm#GUID-7836EEC3-2642-4CF8-AA50-81034855119D" title="You can assign a collection to a collection variable only if they have the same data type. Having the same element type is not enough.To a varray or nested table variable, you can assign the value NULL or a null collection of the same data type. Either assignment makes the variable null.To a nested table variable, you can assign the result of a SQL MULTISET operation or SQL SET function invocation.">Assigning Values to Collection Variables</a>&#34;</span>.</p>
<div class="infobox-note" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__GUID-ACFCAB54-5BD4-45FC-A1CA-9D09EA721CEC">
<p class="notep1">Note:</p>
<p><a href="composites.htm#GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173__CIHJFHJE">Example 5-17</a>, <a href="composites.htm#GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1__BABHDBGC">Example 5-19</a>, and <a href="composites.htm#GUID-03F74821-BC33-4544-9304-5FBBE6EFE450__BABBGAIB">Example 5-20</a> reuse <code class="codeph">nt_type</code> and <code class="codeph">print_nt</code>.</p>
</div>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9">Important Differences Between Nested Tables and Arrays</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-70EC41EA-4ED2-42FE-A03D-6CED02C3A393">Appropriate Uses for Nested Tables</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__GUID-088AABC4-65DC-4124-B7AA-0ACF3737F3A2">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF" title="Summarizes the similarities and differences of the three types of PL/SQL collections.">Table 5-1</a> for a summary of nested table characteristics</p>
</li>
<li>
<p><span class="q">&#34;<a href="collection_variable.htm#GUID-89A1863C-65A1-40CF-9392-86E9FDC21BE9__CJAFJBHF">nested_table_type_def ::=</a>&#34;</span> for the syntax of a nested table type definition</p>
</li>
<li>
<p><span class="q">&#34;<a href="create_type.htm#GUID-389D603D-FBD0-452A-8414-240BBBC57034" title="The CREATE TYPE statement specifies the name of the type and its attributes, methods, and other properties.">CREATE TYPE Statement</a>&#34;</span> for information about creating standalone nested table types</p>
</li>
<li>
<p><span class="q">&#34;<a href="triggers.htm#GUID-9F06D45C-7C60-434E-A597-114A0C445671" title="An INSTEAD OF DML trigger is a DML trigger created on a noneditioning view, or on a nested table column of a noneditioning view. The database fires the INSTEAD OF trigger instead of running the triggering DML statement.">INSTEAD OF DML Triggers</a>&#34;</span> for information about triggers that update nested table columns of views</p>
</li>
<li>
<p><a class="olink SQLRF51008" target="_blank" href="../SQLRF/sql_elements001.htm#SQLRF51008"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about nested tables</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHCICAE">
<p class="titleinexample">Example 5-5 Nested Table of Local Type</p>
<p>This example defines a local nested table type, declares a variable of that type (initializing it with a constructor), and defines a procedure that prints the nested table. (The procedure uses the collection methods <code class="codeph">FIRST</code> and <code class="codeph">LAST</code>, described in <span class="q">&#34;<a href="composites.htm#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="A collection method is a PL/SQL subprogram&mdash;either a function that returns information about a collection or a procedure that operates on a collection. Collection methods make collections easier to use and your applications easier to maintain.">Collection Methods</a>&#34;</span>.) The example invokes the procedure three times: After initializing the variable, after changing the value of one element, and after using a constructor to the change the values of all elements. After the second constructor invocation, the nested table has only two elements. Referencing element 3 would raise error ORA-06533.</p>
<div class="infobox-note" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__GUID-4BED2D46-827C-4279-9627-A1D7C710097B">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites56.html" target="_blank">Nested Table of Local Type</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE Roster IS TABLE OF VARCHAR2(15);  -- nested table type
 
  -- nested table variable initialized with constructor:
 
  names Roster := Roster(&#39;D Caruso&#39;, &#39;J Hamil&#39;, &#39;D Piro&#39;, &#39;R Singh&#39;);
 
  PROCEDURE print_names (heading VARCHAR2) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    FOR i IN names.FIRST .. names.LAST LOOP  -- For first to last element
      DBMS_OUTPUT.PUT_LINE(names(i));
    END LOOP;
 
    DBMS_OUTPUT.PUT_LINE(&#39;---&#39;);
  END;
  
BEGIN 
  print_names(&#39;Initial Values:&#39;);
 
  names(3) := &#39;P Perez&#39;;  -- Change value of one element
  print_names(&#39;Current Values:&#39;);
 
  names := Roster(&#39;A Jansen&#39;, &#39;B Gupta&#39;);  -- Change entire table
  print_names(&#39;Current Values:&#39;);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Initial Values:
D Caruso
J Hamil
D Piro
R Singh
---
Current Values:
D Caruso
J Hamil
P Perez
R Singh
---
Current Values:
A Jansen
B Gupta
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHDEIIG">
<p class="titleinexample">Example 5-6 Nested Table of Standalone Type</p>
<p>This example defines a standalone nested table type, <code class="codeph">nt_type</code>, and a standalone procedure to print a variable of that type, <code class="codeph">print_nt</code>. An anonymous block declares a variable of type <code class="codeph">nt_type</code>, initializing it to empty with a constructor, and invokes <code class="codeph">print_nt</code> twice: After initializing the variable and after using a constructor to the change the values of all elements.</p>
<div class="infobox-note" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__GUID-412F7CC0-0E25-4222-AA95-D67063B8BE2F">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites86.html" target="_blank">Nested Table of Standalone Type</a></p>
</div>
<pre dir="ltr">CREATE OR REPLACE TYPE nt_type IS TABLE OF NUMBER;
/
CREATE OR REPLACE PROCEDURE print_nt (nt nt_type) AUTHID DEFINER IS
  i  NUMBER;
BEGIN
  i := nt.FIRST;
 
  IF i IS NULL THEN
    DBMS_OUTPUT.PUT_LINE(&#39;nt is empty&#39;);
  ELSE
    WHILE i IS NOT NULL LOOP
      DBMS_OUTPUT.PUT(&#39;nt.(&#39; || i || &#39;) = &#39;);
      DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(nt(i)), &#39;NULL&#39;));
      i := nt.NEXT(i);
    END LOOP;
  END IF;
 
  DBMS_OUTPUT.PUT_LINE(&#39;---&#39;);
END print_nt;
/
DECLARE
  nt nt_type := nt_type();  -- nested table variable initialized to empty
BEGIN
  print_nt(nt);
  nt := nt_type(90, 9, 29, 58);
  print_nt(nt);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">nt is empty
---
nt.(1) = 90
nt.(2) = 9
nt.(3) = 29
nt.(4) = 58
---
</pre></div>
<!-- class="example" --></div>
<a id="LNPLS369"></a><a id="LNPLS99928"></a>
<div class="props_rev_3"><a id="GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9"></a>
<h3 id="LNPLS-GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9" class="sect3">Important Differences Between Nested Tables and Arrays</h3>
<div>
<p>Conceptually, a nested table is like a one-dimensional array with an arbitrary number of elements. However, a nested table differs from an array in these important ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>An array has a declared number of elements, but a nested table does not. The size of a nested table can increase dynamically.</p>
</li>
<li>
<p>An array is always dense. A nested array is dense initially, but it can become sparse, because you can delete elements from it.</p>
</li>
</ul>
<p><a href="composites.htm#GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9__CIHBBFBJ">Figure 5-2</a> shows the important differences between a nested table and an array.</p>
<div class="figure" id="GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9__CIHBBFBJ">
<p class="titleinfigure">Figure 5-2 Array and Nested Table</p>
<img width="470" height="156" src="img/lnpls016.gif" alt="Description of Figure 5-2 follows" title="Description of Figure 5-2 follows"/><br/>
<a href="img_text/lnpls016.htm">Description of &#34;Figure 5-2 Array and Nested Table&#34;</a></div>
<!-- class="figure" --></div>
</div>
<a id="LNPLS99927"></a>
<div class="props_rev_3"><a id="GUID-70EC41EA-4ED2-42FE-A03D-6CED02C3A393"></a>
<h3 id="LNPLS-GUID-70EC41EA-4ED2-42FE-A03D-6CED02C3A393" class="sect3">Appropriate Uses for Nested Tables</h3>
<div>
<p>A nested table is appropriate when:</p>
<ul style="list-style-type: disc;">
<li>
<p>The number of elements is not set.</p>
</li>
<li>
<p>Index values are not consecutive.</p>
</li>
<li>
<p>You must delete or update some elements, but not all elements simultaneously.</p>
<p>Nested table data is stored in a separate store table, a system-generated database table. When you access a nested table, the database joins the nested table with its store table. This makes nested tables suitable for queries and updates that affect only some elements of the collection.</p>
</li>
<li>
<p>You would create a separate lookup table, with multiple entries for each row of the main table, and access it through join queries.</p>
</li>
</ul>
</div>
</div>
</div>
<a id="LNPLS370"></a><a id="LNPLS00504"></a>
<div class="props_rev_3"><a id="GUID-92967CC1-481E-472A-BB4C-90C60F75296D"></a>
<h2 id="LNPLS-GUID-92967CC1-481E-472A-BB4C-90C60F75296D" class="sect2">Collection Constructors</h2>
<div>
<p>A <span class="bold">collection constructor (constructor)</span> is a system-defined function with the same name as a collection type, which returns a collection of that type.</p>
<div class="infobox-note" id="GUID-92967CC1-481E-472A-BB4C-90C60F75296D__GUID-410640AA-4FCD-4CC4-AD84-19709A900724">
<p class="notep1">Note:</p>
<p>This topic applies only to varrays and nested tables. Associative arrays do not have constructors. In this topic, <span class="italic">collection</span> means <span class="italic">varray or nested table</span>.</p>
</div>
<p>The syntax of a constructor invocation is:</p>
<pre dir="ltr"><span class="italic">collection_type</span> ( [ <span class="italic">value</span> [, <span class="italic">value</span> ]... ] )
</pre>
<p>If the parameter list is empty, the constructor returns an empty collection. Otherwise, the constructor returns a collection that contains the specified values. For semantic details, see <span class="q">&#34;<a href="expression.htm#GUID-D4700B45-F2C8-443E-AEE7-2BD20FFD45B8__CHDGAFDC">collection_constructor</a>&#34;</span>.</p>
<p>You can assign the returned collection to a collection variable (of the same type) in the variable declaration and in the executable part of a block.</p>
<div class="example" id="GUID-92967CC1-481E-472A-BB4C-90C60F75296D__CIHCBBJJ">
<p class="titleinexample">Example 5-7 Initializing Collection (Varray) Variable to Empty</p>
<p>This example invokes a constructor twice: to initialize the varray variable <code class="codeph">team</code> to empty in its declaration, and to give it new values in the executable part of the block. The procedure <code class="codeph">print_team</code> shows the initial and final values of <code class="codeph">team</code>. To determine when <code class="codeph">team</code> is empty, <code class="codeph">print_team</code> uses the collection method <code class="codeph">COUNT</code>, described in <span class="q">&#34;<a href="composites.htm#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="A collection method is a PL/SQL subprogram&mdash;either a function that returns information about a collection or a procedure that operates on a collection. Collection methods make collections easier to use and your applications easier to maintain.">Collection Methods</a>&#34;</span>. (For an example of a procedure that prints a varray that might be null, see <a href="composites.htm#GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089__CIHHAEGC">Example 5-24</a>.)</p>
<div class="infobox-note" id="GUID-92967CC1-481E-472A-BB4C-90C60F75296D__GUID-D21F87EC-07AF-4B95-8234-80C89992617E">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites58.html" target="_blank">Initializing Collection (Varray) Variable to Empty</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE Foursome IS VARRAY(4) OF VARCHAR2(15);
  <span class="bold">team Foursome := Foursome();  -- initialize to empty</span>
 
  PROCEDURE print_team (heading VARCHAR2)
  IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    IF team.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE(&#39;Empty&#39;);
    ELSE 
      FOR i IN 1..4 LOOP
        DBMS_OUTPUT.PUT_LINE(i || &#39;.&#39; || team(i));
      END LOOP;
    END IF;
 
    DBMS_OUTPUT.PUT_LINE(&#39;---&#39;); 
  END;
 
BEGIN
  print_team(&#39;Team:&#39;);
  <span class="bold">team := Foursome(&#39;John&#39;, &#39;Mary&#39;, &#39;Alberto&#39;, &#39;Juanita&#39;);</span>
  print_team(&#39;Team:&#39;);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Team:
Empty
---
Team:
1.John
2.Mary
3.Alberto
4.Juanita
---
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS371"></a><a id="LNPLS00505"></a>
<div class="props_rev_3"><a id="GUID-7836EEC3-2642-4CF8-AA50-81034855119D"></a>
<h2 id="LNPLS-GUID-7836EEC3-2642-4CF8-AA50-81034855119D" class="sect2">Assigning Values to Collection Variables</h2>
<div>
<div class="section">
<p>You can assign a value to a collection variable in these ways:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Invoke a constructor to create a collection and assign it to the collection variable.</p>
</li>
<li>
<p>Use the assignment statement to assign it the value of another existing collection variable.</p>
</li>
<li>
<p>Pass it to a subprogram as an <code class="codeph">OUT</code> or <code class="codeph">IN</code> <code class="codeph">OUT</code> parameter, and then assign the value inside the subprogram.</p>
</li>
</ul>
<p>To assign a value to a scalar element of a collection variable, reference the element as <span class="italic"><code class="codeph">collection_variable_name</code></span><code class="codeph">(</code><span class="italic"><code class="codeph">index</code></span><code class="codeph">)</code> and assign it a value.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0" title="You can assign a collection to a collection variable only if they have the same data type. Having the same element type is not enough.">Data Type Compatibility</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D" title="To a varray or nested table variable, you can assign the value NULL or a null collection of the same data type. Either assignment makes the variable null.">Assigning Null Values to Varray or Nested Table Variables</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA" title="To a nested table variable, you can assign the result of a SQL MULTISET operation or SQL SET function invocation.">Assigning Set Operation Results to Nested Table Variables</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-7836EEC3-2642-4CF8-AA50-81034855119D__GUID-15BBFAEB-BBCC-4581-9A80-ED2CA38DE31F">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="composites.htm#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="A collection constructor (constructor) is a system-defined function with the same name as a collection type, which returns a collection of that type.">Collection Constructors</a>&#34;</span></p>
</li>
<li>
<p><span class="q">&#34;<a href="assignment_statement.htm#GUID-4C3BEFDF-3FFA-4E9D-96D0-4C5E13E08643" title="The assignment statement sets the value of a data item to a valid value.">Assignment Statement</a>&#34;</span> syntax diagram</p>
</li>
<li>
<p><span class="q">&#34;<a href="fundamentals.htm#GUID-356CB656-68ED-4869-8C67-FE93A78AEC9A">Assigning Values to Variables</a>&#34;</span> for instructions on how to assign a value to a scalar element of a collection variable</p>
</li>
<li>
<p><span class="q">&#34;<a href="tuning.htm#GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" title="The BULK COLLECT clause, a feature of bulk SQL, returns results from SQL to PL/SQL in batches rather than one at a time.">BULK COLLECT Clause</a>&#34;</span></p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="LNPLS462"></a><a id="LNPLS99918"></a>
<div class="props_rev_3"><a id="GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0"></a>
<h3 id="LNPLS-GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0" class="sect3">Data Type Compatibility</h3>
<div>
<p>You can assign a collection to a collection variable only if they have the same data type. Having the same element type is not enough.</p>
<div class="example" id="GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0__BABHBDJJ">
<p class="titleinexample">Example 5-8 Data Type Compatibility for Collection Assignment</p>
<p>In this example, <code class="codeph">VARRAY</code> types <code class="codeph">triplet</code> and <code class="codeph">trio</code> have the same element type, <code class="codeph">VARCHAR(15)</code>. Collection variables <code class="codeph">group1</code> and <code class="codeph">group2</code> have the same data type, <code class="codeph">triplet</code>, but collection variable <code class="codeph">group3</code> has the data type <code class="codeph">trio</code>. The assignment of <code class="codeph">group1</code> to <code class="codeph">group2</code> succeeds, but the assignment of <code class="codeph">group1</code> to <code class="codeph">group3</code> fails.</p>
<div class="infobox-note" id="GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0__GUID-085C20D7-9BCF-4553-BD1E-2F215249C3FA">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites59err.html" target="_blank">Data Type Compatibility for Collection Assignment</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE triplet IS VARRAY(3) OF VARCHAR2(15);
  TYPE trio    IS VARRAY(3) OF VARCHAR2(15);
 
  group1 triplet := triplet(&#39;Jones&#39;, &#39;Wong&#39;, &#39;Marceau&#39;);
  <span class="bold">group2 triplet;</span>
  <span class="bold">group3 trio;</span>
BEGIN
  group2 := group1;  -- succeeds
  <span class="bold">group3 := group1;  -- fails</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">ORA-06550: line 10, column 13:
PLS-00382: expression is of wrong type
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS463"></a><a id="LNPLS99917"></a>
<div class="props_rev_3"><a id="GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D"></a>
<h3 id="LNPLS-GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D" class="sect3">Assigning Null Values to Varray or Nested Table Variables</h3>
<div>
<p>To a varray or nested table variable, you can assign the value <code class="codeph">NULL</code> or a null collection of the same data type. Either assignment makes the variable null.</p>
<div class="section">
<p><a href="composites.htm#GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D__ASSIGNINGNULLVALUETONESTEDTABLEVARI-9A2B377F">Example 5-9</a> initializes the nested table variable <code class="codeph">dept_names</code> to a non-null value; assigns a null collection to it, making it null; and re-initializes it to a different non-null value.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D__ASSIGNINGNULLVALUETONESTEDTABLEVARI-9A2B377F">
<p class="titleinexample">Example 5-9 Assigning Null Value to Nested Table Variable</p>
<div class="infobox-note" id="GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D__GUID-25768810-059A-4A3B-8D3A-E5A33A0329EA">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites18.html" target="_blank">Assigning Null Value to Nested Table Variable</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE dnames_tab IS TABLE OF VARCHAR2(30);
 
  dept_names dnames_tab := dnames_tab(
    &#39;Shipping&#39;,&#39;Sales&#39;,&#39;Finance&#39;,&#39;Payroll&#39;);  -- Initialized to non-null value
 
  empty_set dnames_tab;  -- Not initialized, therefore null
 
  PROCEDURE print_dept_names_status IS
  BEGIN
    IF dept_names IS NULL THEN
      DBMS_OUTPUT.PUT_LINE(&#39;dept_names is null.&#39;);
    ELSE
      DBMS_OUTPUT.PUT_LINE(&#39;dept_names is not null.&#39;);
    END IF;
  END  print_dept_names_status;
 
BEGIN
  print_dept_names_status;
  <span class="bold">dept_names := empty_set;  -- Assign null collection to dept_names.</span>
  print_dept_names_status;
  dept_names := dnames_tab (
    &#39;Shipping&#39;,&#39;Sales&#39;,&#39;Finance&#39;,&#39;Payroll&#39;);  -- Re-initialize dept_names
  print_dept_names_status;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">dept_names is not null.
<span class="bold">dept_names is null.</span>
dept_names is not null.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS464"></a><a id="LNPLS99916"></a>
<div class="props_rev_3"><a id="GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA"></a>
<h3 id="LNPLS-GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA" class="sect3">Assigning Set Operation Results to Nested Table Variables</h3>
<div>
<p>To a nested table variable, you can assign the result of a SQL <code class="codeph">MULTISET</code> operation or SQL <code class="codeph">SET</code> function invocation.</p>
<div class="section">
<p>The SQL <code class="codeph">MULTISET</code> operators combine two nested tables into a single nested table. The elements of the two nested tables must have comparable data types. For information about the <code class="codeph">MULTISET</code> operators, see <a class="olink SQLRF0032" target="_blank" href="../SQLRF/operators006.htm#SQLRF0032"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>The SQL <code class="codeph">SET</code> function takes a nested table argument and returns a nested table of the same data type whose elements are distinct (the function eliminates duplicate elements). For information about the <code class="codeph">SET</code> function, see <a class="olink SQLRF06308" target="_blank" href="../SQLRF/functions177.htm#SQLRF06308"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA__BABFIDIG">
<p class="titleinexample">Example 5-10 Assigning Set Operation Results to Nested Table Variable</p>
<p>This example assigns the results of several <code class="codeph">MULTISET</code> operations and one <code class="codeph">SET</code> function invocation of the nested table variable <code class="codeph">answer</code>, using the procedure <code class="codeph">print_nested_table</code> to print <code class="codeph">answer</code> after each assignment. The procedure uses the collection methods <code class="codeph">FIRST</code> and <code class="codeph">LAST</code>, described in <span class="q">&#34;<a href="composites.htm#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="A collection method is a PL/SQL subprogram&mdash;either a function that returns information about a collection or a procedure that operates on a collection. Collection methods make collections easier to use and your applications easier to maintain.">Collection Methods</a>&#34;</span>.</p>
<div class="infobox-note" id="GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA__GUID-41AE5027-02C6-4C63-8184-EE095362230C">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites19.html" target="_blank">Assigning Set Operation Results to Nested Table Variable</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE nested_typ IS TABLE OF NUMBER;
 
  nt1    nested_typ := nested_typ(1,2,3);
  nt2    nested_typ := nested_typ(3,2,1);
  nt3    nested_typ := nested_typ(2,3,1,3);
  nt4    nested_typ := nested_typ(1,2,4);
  answer nested_typ;
 
  PROCEDURE print_nested_table (nt nested_typ) IS
    output VARCHAR2(128);
  BEGIN
    IF nt IS NULL THEN
      DBMS_OUTPUT.PUT_LINE(&#39;Result: null set&#39;);
    ELSIF nt.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE(&#39;Result: empty set&#39;);
    ELSE
      FOR i IN nt.FIRST .. nt.LAST LOOP  -- For first to last element
        output := output || nt(i) || &#39; &#39;;
      END LOOP;
      DBMS_OUTPUT.PUT_LINE(&#39;Result: &#39; || output);
    END IF;
  END print_nested_table;
 
BEGIN
  <span class="bold">answer := nt1 MULTISET UNION nt4;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt1 MULTISET UNION nt3;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt1 MULTISET UNION DISTINCT nt3;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt2 MULTISET INTERSECT nt3;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt2 MULTISET INTERSECT DISTINCT nt3;</span>
  print_nested_table(answer);
  <span class="bold">answer := SET(nt3);</span>
  print_nested_table(answer);
  <span class="bold">answer := nt3 MULTISET EXCEPT nt2;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt3 MULTISET EXCEPT DISTINCT nt2;</span>
  print_nested_table(answer);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Result: 1 2 3 1 2 4
Result: 1 2 3 2 3 1 3
Result: 1 2 3
Result: 3 2 1
Result: 3 2 1
Result: 2 3 1
Result: 3
Result: empty set
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS470"></a><a id="LNPLS471"></a><a id="LNPLS472"></a><a id="LNPLS00507"></a>
<div class="props_rev_3"><a id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F"></a>
<h2 id="LNPLS-GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F" class="sect2">Multidimensional Collections</h2>
<div>
<p>Although a collection has only one dimension, you can model a multidimensional collection with a collection whose elements are collections.</p>
<div class="example" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__BABHFDCF">
<p class="titleinexample">Example 5-11 Two-Dimensional Varray (Varray of Varrays)</p>
<p>In this example, <code class="codeph">nva</code> is a two-dimensional varray&mdash;a varray of varrays of integers.</p>
<div class="infobox-note" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__GUID-39EFB002-C4C5-46D6-8EF2-1C0FA92C8BAA">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites25.html" target="_blank">Two-Dimensional Varray (Varray of Varrays)</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE t1 IS VARRAY(10) OF INTEGER;  -- varray of integer
  va t1 := t1(2,3,5);

  TYPE nt1 IS VARRAY(10) OF t1;      -- varray of varray of integer
  nva nt1 := nt1(va, t1(55,6,73), t1(2,4), va);

  i INTEGER;
  va1 t1;
BEGIN
  i := nva(2)(3);
  DBMS_OUTPUT.PUT_LINE(&#39;i = &#39; || i);

  nva.EXTEND;
  nva(5) := t1(56, 32);          -- replace inner varray elements
  nva(4) := t1(45,43,67,43345);  -- replace an inner integer element
  nva(4)(4) := 1;                -- replace 43345 with 1

  nva(4).EXTEND;    -- add element to 4th varray element
  nva(4)(5) := 89;  -- store integer 89 there
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">i = 73
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__BABBHGFG">
<p class="titleinexample">Example 5-12 Nested Tables of Nested Tables and Varrays of Integers</p>
<p>In this example, <code class="codeph">ntb1</code> is a nested table of nested tables of strings, and <code class="codeph">ntb2</code> is a nested table of varrays of integers.</p>
<div class="infobox-note" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__GUID-82E6A5EF-43E6-4DA8-90C3-DBF30B97028E">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites26.html" target="_blank">Nested Tables of Nested Tables and Varrays of Integers</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE tb1 IS TABLE OF VARCHAR2(20);  -- nested table of strings
  vtb1 tb1 := tb1(&#39;one&#39;, &#39;three&#39;);

  TYPE ntb1 IS TABLE OF tb1; -- nested table of nested tables of strings
  vntb1 ntb1 := ntb1(vtb1);

  TYPE tv1 IS VARRAY(10) OF INTEGER;  -- varray of integers
  TYPE ntb2 IS TABLE OF tv1;          -- nested table of varrays of integers
  vntb2 ntb2 := ntb2(tv1(3,5), tv1(5,7,3));

BEGIN
  vntb1.EXTEND;
  vntb1(2) := vntb1(1);
  vntb1.DELETE(1);     -- delete first element of vntb1
  vntb1(2).DELETE(1);  -- delete first string from second table in nested table
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__BABIBDDG">
<p class="titleinexample">Example 5-13 Nested Tables of Associative Arrays and Varrays of Strings</p>
<p>In this example, <code class="codeph">aa1</code> is an associative array of associative arrays, and <code class="codeph">ntb2</code> is a nested table of varrays of strings.</p>
<div class="infobox-note" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__GUID-73F8EB37-5293-4C8B-83B8-FAB13E1C496F">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites27.html" target="_blank">Nested Tables of Associative Arrays and Varrays of Strings</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE tb1 IS TABLE OF INTEGER INDEX BY PLS_INTEGER;  -- associative arrays
  v4 tb1;
  v5 tb1;

  TYPE aa1 IS TABLE OF tb1 INDEX BY PLS_INTEGER;  -- associative array of
  v2 aa1;                                         --  associative arrays

  TYPE va1 IS VARRAY(10) OF VARCHAR2(20);  -- varray of strings
  v1 va1 := va1(&#39;hello&#39;, &#39;world&#39;);

  TYPE ntb2 IS TABLE OF va1 INDEX BY PLS_INTEGER;  -- associative array of varrays
  v3 ntb2;

BEGIN
  v4(1)   := 34;     -- populate associative array
  v4(2)   := 46456;
  v4(456) := 343;

  v2(23) := v4;  -- populate associative array of associative arrays

  v3(34) := va1(33, 456, 656, 343);  -- populate associative array varrays

  v2(35) := v5;      -- assign empty associative array to v2(35)
  v2(35)(2) := 78;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS372"></a><a id="LNPLS00506"></a>
<div class="props_rev_3"><a id="GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B"></a>
<h2 id="LNPLS-GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B" class="sect2">Collection Comparisons</h2>
<div>
<p>To determine if one collection variable is less than another (for example), you must define what less than means in that context and write a function that returns <code class="codeph">TRUE</code> or <code class="codeph">FALSE</code>.</p>
<p>You cannot compare associative array variables to the value <code class="codeph">NULL</code> or to each other.</p>
<p>Except for <a href="composites.htm#GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20" title="Two nested table variables are equal if and only if they have the same set of elements (in any order).">Comparing Nested Tables for Equality and Inequality</a>, you cannot natively compare two collection variables with relational operators. This restriction also applies to implicit comparisons. For example, a collection variable cannot appear in a <code class="codeph">DISTINCT</code>, <code class="codeph">GROUP</code> <code class="codeph">BY</code>, or <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause.</p>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC" title="Use the IS[NOT] NULL operator when comparing to the NULL value.">Comparing Varray and Nested Table Variables to NULL</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20" title="Two nested table variables are equal if and only if they have the same set of elements (in any order).">Comparing Nested Tables for Equality and Inequality</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8" title="You can compare nested table variables, and test some of their properties, with SQL multiset conditions.">Comparing Nested Tables with SQL Multiset Conditions</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B__GUID-A6339B04-4122-4670-B998-0CC3DC833967">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="fundamentals.htm#GUID-2EB964C8-9B36-4009-A45F-B340F44EE2A2__CIHCCCBB" title="This table lists the relational operators and gives their meanings.">Table 2-5</a></p>
</li>
<li>
<p><a href="subprograms.htm#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B">PL/SQL Subprograms</a> for information about writing functions</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="LNPLS373"></a><a id="LNPLS99915"></a>
<div class="props_rev_3"><a id="GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC"></a>
<h3 id="LNPLS-GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC" class="sect3">Comparing Varray and Nested Table Variables to NULL</h3>
<div>
<p>Use the <code class="codeph">IS[NOT] NULL</code> operator when comparing to the NULL value.</p>
<div class="section">
<p>You can compare varray and nested table variables to the value <code class="codeph">NULL</code> with the <span class="q">&#34;<a href="fundamentals.htm#GUID-D02FA4D0-0074-4227-9624-F01E3D219BAB" title="The IS NULL operator returns the BOOLEAN value TRUE if its operand is NULL or FALSE if it is not NULL. The IS NOT NULL operator does the opposite.">IS [NOT] NULL Operator</a>&#34;</span>, but not with the relational operators equal (<code class="codeph">=</code>) and not equal (<code class="codeph">&lt;&gt;</code>, <code class="codeph">!=</code>, <code class="codeph">~=</code>, or <code class="codeph">^=</code>).</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC__CIHCGJIC">
<p class="titleinexample">Example 5-14 Comparing Varray and Nested Table Variables to NULL</p>
<p>This example compares a varray variable and a nested table variable to <code class="codeph">NULL</code> correctly.</p>
<div class="infobox-note" id="GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC__GUID-80CFA1AD-739B-4317-A746-AB388C707678">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites60.html" target="_blank">Comparing Varray and Nested Table Variables to NULL</a></p>
</div>
<pre dir="ltr">DECLARE  
  TYPE Foursome IS VARRAY(4) OF VARCHAR2(15);  -- VARRAY type
  team Foursome;                               -- varray variable
  
  TYPE Roster IS TABLE OF VARCHAR2(15);        -- nested table type
  names Roster := Roster(&#39;Adams&#39;, &#39;Patel&#39;);    -- nested table variable
  
BEGIN
  <span class="bold">IF team IS NULL THEN</span>
    DBMS_OUTPUT.PUT_LINE(&#39;team IS NULL&#39;);
  ELSE
    DBMS_OUTPUT.PUT_LINE(&#39;team IS NOT NULL&#39;);
  END IF;
 
  <span class="bold">IF names IS NOT NULL THEN</span>
    DBMS_OUTPUT.PUT_LINE(&#39;names IS NOT NULL&#39;);
  ELSE
    DBMS_OUTPUT.PUT_LINE(&#39;names IS NULL&#39;);
  END IF;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">team IS NULL
names IS NOT NULL
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS468"></a><a id="LNPLS99914"></a>
<div class="props_rev_3"><a id="GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20"></a>
<h3 id="LNPLS-GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20" class="sect3">Comparing Nested Tables for Equality and Inequality</h3>
<div>
<p>Two nested table variables are equal if and only if they have the same set of elements (in any order).</p>
<div class="section">
<p>If two nested table variables have the same nested table type, and that nested table type does not have elements of a record type, then you can compare the two variables for equality or inequality with the relational operators equal (<code class="codeph">=</code>) and not equal (<code class="codeph">&lt;&gt;</code>, <code class="codeph">!=</code>, <code class="codeph">~=</code>, <code class="codeph">^=</code>).</p>
<div class="infoboxnotealso" id="GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20__GUID-85F1649A-C788-45AB-8A5E-312B0F1859AD">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="composites.htm#GUID-DFDE40BD-4B61-4C8A-B9CE-3FE01E21F658" title="Records cannot be tested natively for nullity, equality, or inequality.">Record Comparisons</a>&#34;</span></p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20__BABCBFHA">
<p class="titleinexample">Example 5-15 Comparing Nested Tables for Equality and Inequality</p>
<p>This example compares nested table variables for equality and inequality with relational operators.</p>
<div class="infobox-note" id="GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20__GUID-E9F9AC23-0889-4B50-BDBD-5BF909917E4C">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/lnplscomposites95.html" target="_blank">Comparing Nested Tables for Equality and Inequality</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE dnames_tab IS TABLE OF <span class="bold">VARCHAR2(30)</span>; <span class="bold">-- element type is not record type</span>

  dept_names1 dnames_tab :=
    dnames_tab(&#39;Shipping&#39;,&#39;Sales&#39;,&#39;Finance&#39;,&#39;Payroll&#39;);

  dept_names2 dnames_tab :=
    dnames_tab(&#39;Sales&#39;,&#39;Finance&#39;,&#39;Shipping&#39;,&#39;Payroll&#39;);

  dept_names3 dnames_tab :=
    dnames_tab(&#39;Sales&#39;,&#39;Finance&#39;,&#39;Payroll&#39;);

BEGIN
  <span class="bold">IF dept_names1 = dept_names2 THEN</span>
    DBMS_OUTPUT.PUT_LINE(&#39;dept_names1 = dept_names2&#39;);
  END IF;

  <span class="bold">IF dept_names2 != dept_names3 THEN</span>
    DBMS_OUTPUT.PUT_LINE(&#39;dept_names2 != dept_names3&#39;);
  END IF;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">dept_names1 = dept_names2</span>
<span class="bold">dept_names2 != dept_names3</span>
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS469"></a><a id="LNPLS99913"></a>
<div class="props_rev_3"><a id="GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8"></a>
<h3 id="LNPLS-GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8" class="sect3">Comparing Nested Tables with SQL Multiset Conditions</h3>
<div>
<p>You can compare nested table variables, and test some of their properties, with SQL multiset conditions.</p>
<div class="section">
<div class="infoboxnotealso" id="GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8__GUID-EEA8688E-5515-4365-B5FF-EBB0D0923F87">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink SQLRF52128" target="_blank" href="../SQLRF/conditions006.htm#SQLRF52128"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about multiset conditions</p>
</li>
<li>
<p><a class="olink SQLRF06305" target="_blank" href="../SQLRF/functions023.htm#SQLRF06305"><span class="italic">Oracle Database SQL Language Reference</span></a> for details about <code class="codeph">CARDINALITY</code> syntax</p>
</li>
<li>
<p><a class="olink SQLRF06308" target="_blank" href="../SQLRF/functions177.htm#SQLRF06308"><span class="italic">Oracle Database SQL Language Reference</span></a>for details about <code class="codeph">SET</code> syntax</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8__BABCDABC">
<p class="titleinexample">Example 5-16 Comparing Nested Tables with SQL Multiset Conditions</p>
<p>This example uses the SQL multiset conditions and two SQL functions that take nested table variable arguments, <code class="codeph">CARDINALITY</code> and <code class="codeph">SET</code> .</p>
<div class="infobox-note" id="GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8__GUID-FEC0F6A2-0678-408C-9036-8530378EEEF4">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites24.html" target="_blank">Comparing Nested Tables with SQL Multiset Conditions</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE nested_typ IS TABLE OF NUMBER;
  nt1 nested_typ := nested_typ(1,2,3);
  nt2 nested_typ := nested_typ(3,2,1);
  nt3 nested_typ := nested_typ(2,3,1,3);
  nt4 nested_typ := nested_typ(1,2,4);
 
  PROCEDURE testify (
    truth BOOLEAN := NULL,
    quantity NUMBER := NULL
  ) IS
  BEGIN
    IF truth IS NOT NULL THEN
      DBMS_OUTPUT.PUT_LINE (
        CASE truth
           WHEN TRUE THEN &#39;True&#39;
           WHEN FALSE THEN &#39;False&#39;
        END
      );
    END IF;
    IF quantity IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE(quantity);
    END IF;
  END;
BEGIN
  testify(truth =&gt; (<span class="bold">nt1 IN (nt2,nt3,nt4)</span>));        -- condition
  testify(truth =&gt; (<span class="bold">nt1 SUBMULTISET OF nt3</span>));      -- condition
  testify(truth =&gt; (<span class="bold">nt1 NOT SUBMULTISET OF nt4</span>));  -- condition
  testify(truth =&gt; (<span class="bold">4 MEMBER OF nt1</span>));             -- condition
  testify(truth =&gt; (<span class="bold">nt3 IS A SET</span>));                -- condition
  testify(truth =&gt; (<span class="bold">nt3 IS NOT A SET</span>));            -- condition
  testify(truth =&gt; (<span class="bold">nt1 IS EMPTY</span>));                -- condition
  testify(quantity =&gt; (<span class="bold">CARDINALITY(nt3)</span>));         -- function
  testify(quantity =&gt; (<span class="bold">CARDINALITY(SET(nt3))</span>));    -- 2 functions
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">True
True
True
False
False
True
False
4
3
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS375"></a><a id="LNPLS376"></a><a id="LNPLS00508"></a>
<div class="props_rev_3"><a id="GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F"></a>
<h2 id="LNPLS-GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" class="sect2">Collection Methods</h2>
<div>
<p>A collection method is a PL/SQL subprogram&mdash;either a function that returns information about a collection or a procedure that operates on a collection. Collection methods make collections easier to use and your applications easier to maintain.</p>
<p><a href="composites.htm#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F__CHDDJGFA" title="This table summarizes the collection methods. The first column lists their names, in alphabetical order. The second column lists their types (function or procedure). The third column gives brief descriptions of them.">Table 5-2</a> summarizes the collection methods.</p>
<div class="infobox-note" id="GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F__GUID-90978ED7-FEC6-4C44-8D56-3AD02168AD6D">
<p class="notep1">Note:</p>
<p>With a null collection, <code class="codeph">EXISTS</code> is the only collection method that does not raise the predefined exception <code class="codeph">COLLECTION_IS_NULL</code>.</p>
</div>
<div class="tblformal" id="GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F__CHDDJGFA">
<p class="titleintable">Table 5-2 Collection Methods</p>
<table class="cellalignment876" title="Collection Methods" summary="This table summarizes the collection methods. The first column lists their names, in alphabetical order. The second column lists their types (function or procedure). The third column gives brief descriptions of them.">
<thead>
<tr class="cellalignment870">
<th class="cellalignment919" id="d35329e4407">Method</th>
<th class="cellalignment919" id="d35329e4410">Type</th>
<th class="cellalignment935" id="d35329e4413">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4418" headers="d35329e4407">
<p><code class="codeph">DELETE</code></p>
</td>
<td class="cellalignment921" headers="d35329e4418 d35329e4410">
<p>Procedure</p>
</td>
<td class="cellalignment936" headers="d35329e4418 d35329e4413">
<p>Deletes elements from collection.</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4429" headers="d35329e4407">
<p><code class="codeph">TRIM</code></p>
</td>
<td class="cellalignment921" headers="d35329e4429 d35329e4410">
<p>Procedure</p>
</td>
<td class="cellalignment936" headers="d35329e4429 d35329e4413">
<p>Deletes elements from end of varray or nested table.</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4440" headers="d35329e4407">
<p><code class="codeph">EXTEND</code></p>
</td>
<td class="cellalignment921" headers="d35329e4440 d35329e4410">
<p>Procedure</p>
</td>
<td class="cellalignment936" headers="d35329e4440 d35329e4413">
<p>Adds elements to end of varray or nested table.</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4451" headers="d35329e4407">
<p><code class="codeph">EXISTS</code></p>
</td>
<td class="cellalignment921" headers="d35329e4451 d35329e4410">
<p>Function</p>
</td>
<td class="cellalignment936" headers="d35329e4451 d35329e4413">
<p>Returns <code class="codeph">TRUE</code> if and only if specified element of varray or nested table exists.</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4465" headers="d35329e4407">
<p><code class="codeph">FIRST</code></p>
</td>
<td class="cellalignment921" headers="d35329e4465 d35329e4410">
<p>Function</p>
</td>
<td class="cellalignment936" headers="d35329e4465 d35329e4413">
<p>Returns first index in collection.</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4476" headers="d35329e4407">
<p><code class="codeph">LAST</code></p>
</td>
<td class="cellalignment921" headers="d35329e4476 d35329e4410">
<p>Function</p>
</td>
<td class="cellalignment936" headers="d35329e4476 d35329e4413">
<p>Returns last index in collection.</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4487" headers="d35329e4407">
<p><code class="codeph">COUNT</code></p>
</td>
<td class="cellalignment921" headers="d35329e4487 d35329e4410">
<p>Function</p>
</td>
<td class="cellalignment936" headers="d35329e4487 d35329e4413">
<p>Returns number of elements in collection.</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4498" headers="d35329e4407">
<p><code class="codeph">LIMIT</code></p>
</td>
<td class="cellalignment921" headers="d35329e4498 d35329e4410">
<p>Function</p>
</td>
<td class="cellalignment936" headers="d35329e4498 d35329e4413">
<p>Returns maximum number of elements that collection can have.</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4509" headers="d35329e4407">
<p><code class="codeph">PRIOR</code></p>
</td>
<td class="cellalignment921" headers="d35329e4509 d35329e4410">
<p>Function</p>
</td>
<td class="cellalignment936" headers="d35329e4509 d35329e4413">
<p>Returns index that precedes specified index.</p>
</td>
</tr>
<tr class="cellalignment870">
<td class="cellalignment921" id="d35329e4520" headers="d35329e4407">
<p><code class="codeph">NEXT</code></p>
</td>
<td class="cellalignment921" headers="d35329e4520 d35329e4410">
<p>Function</p>
</td>
<td class="cellalignment936" headers="d35329e4520 d35329e4413">
<p>Returns index that succeeds specified index.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The basic syntax of a collection method invocation is:</p>
<pre dir="ltr"><span class="italic">collection_name</span>.<span class="italic">method</span>
</pre>
<p>For detailed syntax, see <span class="q">&#34;<a href="collection_method.htm#GUID-7AF1A3C4-D04B-4F91-9D7B-C92C75E3A300" title="A collection method is a PL/SQL subprogram that either returns information about a collection or operates on a collection.">Collection Method Invocation</a>&#34;</span>.</p>
<p>A collection method invocation can appear anywhere that an invocation of a PL/SQL subprogram of its type (function or procedure) can appear, except in a SQL statement. (For general information about PL/SQL subprograms, see <a href="subprograms.htm#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B">PL/SQL Subprograms</a>.)</p>
<p>In a subprogram, a collection parameter assumes the properties of the argument bound to it. You can apply collection methods to such parameters. For varray parameters, the value of <code class="codeph">LIMIT</code> is always derived from the parameter type definition, regardless of the parameter mode.</p>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173" title="DELETE is a procedure that deletes elements from a collection.">DELETE Collection Method</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1" title="TRIM is a procedure that deletes elements from the end of a varray or nested table.">TRIM Collection Method</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-03F74821-BC33-4544-9304-5FBBE6EFE450" title="EXTEND is a procedure that adds elements to the end of a varray or nested table.">EXTEND Collection Method</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-31E27176-042B-4BA8-8FBC-14CCEDC33095" title="EXISTS is a function that tells you whether the specified element of a varray or nested table exists.">EXISTS Collection Method</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-33E18BC6-C0A8-456B-A47C-A4504240D962" title="FIRST and LAST are functions.">FIRST and LAST Collection Methods</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-5700158F-FF45-4964-89B3-1EF614BA3B7D" title="COUNT is a function that returns the number of elements in the collection (ignoring deleted elements, even if DELETE kept placeholders for them).">COUNT Collection Method</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-1E0E1010-FFC5-4F4A-AD87-58BE9CE8146D" title="LIMIT is a function that returns the maximum number of elements that the collection can have. If the collection has no maximum number of elements, LIMIT returns NULL. Only a varray has a maximum size.">LIMIT Collection Method</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09" title="PRIOR and NEXT are functions that let you move backward and forward in the collection (ignoring deleted elements, even if DELETE kept placeholders for them). These methods are useful for traversing sparse collections.">PRIOR and NEXT Collection Methods</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS377"></a><a id="LNPLS378"></a><a id="LNPLS99961"></a>
<div class="props_rev_3"><a id="GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173"></a>
<h3 id="LNPLS-GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173" class="sect3">DELETE Collection Method</h3>
<div>
<p><code class="codeph">DELETE</code> is a procedure that deletes elements from a collection.</p>
<p>This method has these forms:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">DELETE</code> deletes all elements from a collection of any type.</p>
<p>This operation immediately frees the memory allocated to the deleted elements.</p>
</li>
<li>
<p>From an associative array or nested table (but not a varray):</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">DELETE(</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code> deletes the element whose index is <span class="italic">n</span>, if that element exists; otherwise, it does nothing.</p>
</li>
<li>
<p><code class="codeph">DELETE(</code><span class="italic"><code class="codeph">m,n</code></span><code class="codeph">)</code> deletes all elements whose indexes are in the range <span class="italic">m</span>..<span class="italic">n</span>, if both <span class="italic">m</span> and <span class="italic">n</span> exist and <span class="italic">m</span> &lt;= <span class="italic">n</span>; otherwise, it does nothing.</p>
</li>
</ul>
<p>For these two forms of <code class="codeph">DELETE</code>, PL/SQL keeps placeholders for the deleted elements. Therefore, the deleted elements are included in the internal size of the collection, and you can restore a deleted element by assigning a valid value to it.</p>
</li>
</ul>
<div class="example" id="GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173__CIHJFHJE">
<p class="titleinexample">Example 5-17 DELETE Method with Nested Table</p>
<p>This example declares a nested table variable, initializing it with six elements; deletes and then restores the second element; deletes a range of elements and then restores one of them; and then deletes all elements. The restored elements occupy the same memory as the corresponding deleted elements. The procedure <code class="codeph">print_nt</code> prints the nested table variable after initialization and after each <code class="codeph">DELETE</code> operation. The type <code class="codeph">nt_type</code> and procedure <code class="codeph">print_nt</code> are defined in <a href="composites.htm#GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHDEIIG">Example 5-6</a>.</p>
<pre dir="ltr">DECLARE
  nt nt_type := nt_type(11, 22, 33, 44, 55, 66);
BEGIN
  print_nt(nt);
 
  <span class="bold">nt.DELETE(2);     -- Delete second element</span>
  print_nt(nt);
 
  <span class="bold">nt(2) := 2222;    -- Restore second element</span>
  print_nt(nt);
 
  <span class="bold">nt.DELETE(2, 4);  -- Delete range of elements</span>
  print_nt(nt);
 
  <span class="bold">nt(3) := 3333;    -- Restore third element</span>
  print_nt(nt);
 
  <span class="bold">nt.DELETE;        -- Delete all elements</span>
  print_nt(nt);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(2) = 2222
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(3) = 3333
nt.(5) = 55
nt.(6) = 66
---
nt is empty
---
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173__CIHHFHFJ">
<p class="titleinexample">Example 5-18 DELETE Method with Associative Array Indexed by String</p>
<p>This example populates an associative array indexed by string and deletes all elements, which frees the memory allocated to them. Next, the example replaces the deleted elements&mdash;that is, adds new elements that have the same indexes as the deleted elements. The new replacement elements do not occupy the same memory as the corresponding deleted elements. Finally, the example deletes one element and then a range of elements. The procedure <code class="codeph">print_aa_str</code> shows the effects of the operations.</p>
<pre dir="ltr">DECLARE
  TYPE aa_type_str IS TABLE OF INTEGER INDEX BY VARCHAR2(10);
  aa_str  aa_type_str;
 
  PROCEDURE print_aa_str IS
    i  VARCHAR2(10);
  BEGIN
    i := aa_str.FIRST;
 
    IF i IS NULL THEN
      DBMS_OUTPUT.PUT_LINE(&#39;aa_str is empty&#39;);
    ELSE
      WHILE i IS NOT NULL LOOP
        DBMS_OUTPUT.PUT(&#39;aa_str.(&#39; || i || &#39;) = &#39;);
        DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(aa_str(i)), &#39;NULL&#39;));
        i := aa_str.NEXT(i);
      END LOOP;
    END IF;
 
    DBMS_OUTPUT.PUT_LINE(&#39;---&#39;);
  END print_aa_str;
 
BEGIN
  aa_str(&#39;M&#39;) := 13;
  aa_str(&#39;Z&#39;) := 26;
  aa_str(&#39;C&#39;) := 3;
  print_aa_str;
 
  <span class="bold">aa_str.DELETE;  -- Delete all elements</span>
  print_aa_str;
 
  <span class="bold">aa_str(&#39;M&#39;) := 13;   -- Replace deleted element with same value</span>
  <span class="bold">aa_str(&#39;Z&#39;) := 260;  -- Replace deleted element with new value</span>
  <span class="bold">aa_str(&#39;C&#39;) := 30;   -- Replace deleted element with new value</span>
  aa_str(&#39;W&#39;) := 23;   -- Add new element
  aa_str(&#39;J&#39;) := 10;   -- Add new element
  aa_str(&#39;N&#39;) := 14;   -- Add new element
  aa_str(&#39;P&#39;) := 16;   -- Add new element
  aa_str(&#39;W&#39;) := 23;   -- Add new element
  aa_str(&#39;J&#39;) := 10;   -- Add new element
  print_aa_str;
 
  <span class="bold">aa_str.DELETE(&#39;C&#39;);      -- Delete one element</span>
  print_aa_str;
 
  <span class="bold">aa_str.DELETE(&#39;N&#39;,&#39;W&#39;);  -- Delete range of elements</span>
  print_aa_str;
 
  <span class="bold">aa_str.DELETE(&#39;Z&#39;,&#39;M&#39;);  -- Does nothing</span>
  print_aa_str;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">aa_str.(C) = 3
aa_str.(M) = 13
aa_str.(Z) = 26
---
aa_str is empty
---
aa_str.(C) = 30
aa_str.(J) = 10
aa_str.(M) = 13
aa_str.(N) = 14
aa_str.(P) = 16
aa_str.(W) = 23
aa_str.(Z) = 260
---
aa_str.(J) = 10
aa_str.(M) = 13
aa_str.(N) = 14
aa_str.(P) = 16
aa_str.(W) = 23
aa_str.(Z) = 260
---
aa_str.(J) = 10
aa_str.(M) = 13
aa_str.(Z) = 260
---
aa_str.(J) = 10
aa_str.(M) = 13
aa_str.(Z) = 260
---
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS480"></a><a id="LNPLS99962"></a>
<div class="props_rev_3"><a id="GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1"></a>
<h3 id="LNPLS-GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1" class="sect3">TRIM Collection Method</h3>
<div>
<p><code class="codeph">TRIM</code> is a procedure that deletes elements from the end of a varray or nested table.</p>
<p>This method has these forms:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">TRIM</code> removes one element from the end of the collection, if the collection has at least one element; otherwise, it raises the predefined exception <code class="codeph">SUBSCRIPT_BEYOND_COUNT</code>.</p>
</li>
<li>
<p><code class="codeph">TRIM(</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code> removes <span class="italic">n</span> elements from the end of the collection, if there are at least <span class="italic">n</span> elements at the end; otherwise, it raises the predefined exception <code class="codeph">SUBSCRIPT_BEYOND_COUNT</code>.</p>
</li>
</ul>
<p><code class="codeph">TRIM</code> operates on the internal size of a collection. That is, if <code class="codeph">DELETE</code> deletes an element but keeps a placeholder for it, then <code class="codeph">TRIM</code> considers the element to exist. Therefore, <code class="codeph">TRIM</code> can delete a deleted element.</p>
<p>PL/SQL does not keep placeholders for trimmed elements. Therefore, trimmed elements are not included in the internal size of the collection, and you cannot restore a trimmed element by assigning a valid value to it.</p>
<div class="infobox-note" id="GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1__GUID-A04D945B-4A9F-413F-8B52-A8AA6EC8522B">
<p class="notep1">Caution:</p>
<p>Do not depend on interaction between <code class="codeph">TRIM</code> and <code class="codeph">DELETE</code>. Treat nested tables like either fixed-size arrays (and use only <code class="codeph">DELETE</code>) or stacks (and use only <code class="codeph">TRIM</code> and <code class="codeph">EXTEND</code>).</p>
</div>
<div class="example" id="GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1__BABHDBGC">
<p class="titleinexample">Example 5-19 TRIM Method with Nested Table</p>
<p>This example declares a nested table variable, initializing it with six elements; trims the last element; deletes the fourth element; and then trims the last two elements&mdash;one of which is the deleted fourth element. The procedure <code class="codeph">print_nt</code> prints the nested table variable after initialization and after the <code class="codeph">TRIM</code> and <code class="codeph">DELETE</code> operations. The type <code class="codeph">nt_type</code> and procedure <code class="codeph">print_nt</code> are defined in <a href="composites.htm#GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHDEIIG">Example 5-6</a>.</p>
<pre dir="ltr">DECLARE
  nt nt_type := nt_type(11, 22, 33, 44, 55, 66);
BEGIN
  print_nt(nt);

  <span class="bold">nt.TRIM;       -- Trim last element</span>
  print_nt(nt);

  <span class="bold">nt.DELETE(4);  -- Delete fourth element</span>
  print_nt(nt);

  <span class="bold">nt.TRIM(2);    -- Trim last two elements</span>
  print_nt(nt);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(5) = 55
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
---
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS479"></a><a id="LNPLS99963"></a>
<div class="props_rev_3"><a id="GUID-03F74821-BC33-4544-9304-5FBBE6EFE450"></a>
<h3 id="LNPLS-GUID-03F74821-BC33-4544-9304-5FBBE6EFE450" class="sect3">EXTEND Collection Method</h3>
<div>
<p><code class="codeph">EXTEND</code> is a procedure that adds elements to the end of a varray or nested table.</p>
<p>The collection can be empty, but not null. (To make a collection empty or add elements to a null collection, use a constructor. For more information, see <span class="q">&#34;<a href="composites.htm#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="A collection constructor (constructor) is a system-defined function with the same name as a collection type, which returns a collection of that type.">Collection Constructors</a>&#34;</span>.)</p>
<p>The <code class="codeph">EXTEND</code> method has these forms:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">EXTEND</code> appends one null element to the collection.</p>
</li>
<li>
<p><code class="codeph">EXTEND(</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code> appends <span class="italic">n</span> null elements to the collection.</p>
</li>
<li>
<p><code class="codeph">EXTEND(</code><span class="italic"><code class="codeph">n</code></span>,<span class="italic"><code class="codeph">i</code></span><code class="codeph">)</code> appends <span class="italic">n</span> copies of the <span class="italic">i</span>th element to the collection.</p>
<div class="infobox-note" id="GUID-03F74821-BC33-4544-9304-5FBBE6EFE450__GUID-3C462AE3-0B51-43F2-9969-BF9D747ACA66">
<p class="notep1">Note:</p>
<p><code class="codeph">EXTEND(</code><span class="italic"><code class="codeph">n</code></span>,<span class="italic"><code class="codeph">i</code></span><code class="codeph">)</code> is the only form that you can use for a collection whose elements have the <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint.</p>
</div>
</li>
</ul>
<p><code class="codeph">EXTEND</code> operates on the internal size of a collection. That is, if <code class="codeph">DELETE</code> deletes an element but keeps a placeholder for it, then <code class="codeph">EXTEND</code> considers the element to exist.</p>
<div class="example" id="GUID-03F74821-BC33-4544-9304-5FBBE6EFE450__BABBGAIB">
<p class="titleinexample">Example 5-20 EXTEND Method with Nested Table</p>
<p>This example declares a nested table variable, initializing it with three elements; appends two copies of the first element; deletes the fifth (last) element; and then appends one null element. Because <code class="codeph">EXTEND</code> considers the deleted fifth element to exist, the appended null element is the sixth element. The procedure <code class="codeph">print_nt</code> prints the nested table variable after initialization and after the <code class="codeph">EXTEND</code> and <code class="codeph">DELETE</code> operations. The type <code class="codeph">nt_type</code> and procedure <code class="codeph">print_nt</code> are defined in <a href="composites.htm#GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHDEIIG">Example 5-6</a>.</p>
<pre dir="ltr">DECLARE
  nt nt_type := nt_type(11, 22, 33);
BEGIN
  print_nt(nt);
 
  <span class="bold">nt.EXTEND(2,1);  -- Append two copies of first element</span>
  print_nt(nt);
 
  <span class="bold">nt.DELETE(5);    -- Delete fifth element</span>
  print_nt(nt);
 
  <span class="bold">nt.EXTEND;       -- Append one null element</span>
  print_nt(nt);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 11
nt.(5) = 11
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 11
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 11
<span class="bold">nt.(6) = NULL</span>
---
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS473"></a><a id="LNPLS99968"></a>
<div class="props_rev_3"><a id="GUID-31E27176-042B-4BA8-8FBC-14CCEDC33095"></a>
<h3 id="LNPLS-GUID-31E27176-042B-4BA8-8FBC-14CCEDC33095" class="sect3">EXISTS Collection Method</h3>
<div>
<p><code class="codeph">EXISTS</code> is a function that tells you whether the specified element of a varray or nested table exists.</p>
<p><code class="codeph">EXISTS(</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code> returns <code class="codeph">TRUE</code> if the <span class="italic">n</span>th element of the collection exists and <code class="codeph">FALSE</code> otherwise. If <span class="italic">n</span> is out of range, <code class="codeph">EXISTS</code> returns <code class="codeph">FALSE</code> instead of raising the predefined exception <code class="codeph">SUBSCRIPT_OUTSIDE_LIMIT</code>.</p>
<p>For a deleted element, <code class="codeph">EXISTS(</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code> returns <code class="codeph">FALSE</code>, even if <code class="codeph">DELETE</code> kept a placeholder for it.</p>
<div class="example" id="GUID-31E27176-042B-4BA8-8FBC-14CCEDC33095__BABEDEGG">
<p class="titleinexample">Example 5-21 EXISTS Method with Nested Table</p>
<p>This example initializes a nested table with four elements, deletes the second element, and prints either the value or status of elements 1 through 6.</p>
<pre dir="ltr">DECLARE
  TYPE NumList IS TABLE OF INTEGER;
  n NumList := NumList(1,3,5,7);
BEGIN
  <span class="bold">n.DELETE(2); -- Delete second element</span>
 
  FOR i IN 1..6 LOOP
    IF <span class="bold">n.EXISTS(i)</span> THEN
      DBMS_OUTPUT.PUT_LINE(&#39;n(&#39; || i || &#39;) = &#39; || n(i));
    ELSE
      DBMS_OUTPUT.PUT_LINE(&#39;n(&#39; || i || &#39;) does not exist&#39;);
    END IF;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">n(1) = 1
n(2) does not exist
n(3) = 5
n(4) = 7
n(5) does not exist
n(6) does not exist
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS380"></a><a id="LNPLS99965"></a>
<div class="props_rev_3"><a id="GUID-33E18BC6-C0A8-456B-A47C-A4504240D962"></a>
<h3 id="LNPLS-GUID-33E18BC6-C0A8-456B-A47C-A4504240D962" class="sect3">FIRST and LAST Collection Methods</h3>
<div>
<p><code class="codeph">FIRST</code> and <code class="codeph">LAST</code> are functions.</p>
<p>If the collection has at least one element, <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> return the indexes of the first and last elements, respectively (ignoring deleted elements, even if <code class="codeph">DELETE</code> kept placeholders for them). If the collection has only one element, <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> return the same index. If the collection is empty, <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> return <code class="codeph">NULL</code>.</p>
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8" title="For an associative array indexed by PLS_INTEGER, the first and last elements are those with the smallest and largest indexes, respectively. For an associative array indexed by string, the first and last elements are those with the lowest and highest key values, respectively.">FIRST and LAST Methods for Associative Array</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089" title="For a varray that is not empty, FIRST always returns 1. For every varray, LAST always equals COUNT.">FIRST and LAST Methods for Varray</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2" title="For a nested table, LAST equals COUNT unless you delete elements from its middle, in which case LAST is larger than COUNT.">FIRST and LAST Methods for Nested Table</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS382"></a><a id="LNPLS383"></a><a id="LNPLS381"></a>
<div class="props_rev_3"><a id="GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8"></a>
<h4 id="LNPLS-GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8" class="sect4">FIRST and LAST Methods for Associative Array</h4>
<div>
<p>For an associative array indexed by <code class="codeph">PLS_INTEGER</code>, the first and last elements are those with the smallest and largest indexes, respectively. For an associative array indexed by string, the first and last elements are those with the lowest and highest key values, respectively.</p>
<p>Key values are in sorted order (for more information, see <span class="q">&#34;<a href="composites.htm#GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26" title="National Language Support (NLS) parameters such as NLS_SORT, NLS_COMP, and NLS_DATE_FORMAT affect associative arrays indexed by string.">NLS Parameter Values Affect Associative Arrays Indexed by String</a>&#34;</span>).</p>
<div class="example" id="GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8__CIHCAHDE">
<p class="titleinexample">Example 5-22 FIRST and LAST Values for Associative Array Indexed by PLS_INTEGER</p>
<p>This example shows the values of <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> for an associative array indexed by <code class="codeph">PLS_INTEGER</code>, deletes the first and last elements, and shows the values of <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> again.</p>
<pre dir="ltr">DECLARE
  TYPE aa_type_int IS TABLE OF INTEGER INDEX BY PLS_INTEGER;
  aa_int  aa_type_int;
 
  PROCEDURE print_first_and_last IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(&#39;FIRST = &#39; || <span class="bold">aa_int.FIRST</span>);
    DBMS_OUTPUT.PUT_LINE(&#39;LAST = &#39; || <span class="bold">aa_int.LAST</span>);
  END print_first_and_last;
 
BEGIN
  aa_int(1) := 3;
  aa_int(2) := 6;
  aa_int(3) := 9;
  aa_int(4) := 12;
 
  DBMS_OUTPUT.PUT_LINE(&#39;Before deletions:&#39;);
  print_first_and_last;
 
  <span class="bold">aa_int.DELETE(1);</span>
  <span class="bold">aa_int.DELETE(4);</span>
 
  DBMS_OUTPUT.PUT_LINE(&#39;After deletions:&#39;);
  print_first_and_last;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Before deletions:
FIRST = 1
LAST = 4
After deletions:
FIRST = 2
LAST = 3
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8__CIHFDDDJ">
<p class="titleinexample">Example 5-23 FIRST and LAST Values for Associative Array Indexed by String</p>
<p>This example shows the values of <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> for an associative array indexed by string, deletes the first and last elements, and shows the values of <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> again.</p>
<pre dir="ltr">DECLARE
  TYPE aa_type_str IS TABLE OF INTEGER INDEX BY VARCHAR2(10);
  aa_str  aa_type_str;
 
  PROCEDURE print_first_and_last IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(&#39;FIRST = &#39; || <span class="bold">aa_str.FIRST</span>);
    DBMS_OUTPUT.PUT_LINE(&#39;LAST = &#39; || <span class="bold">aa_str.LAST</span>);
  END print_first_and_last;
 
BEGIN
  aa_str(&#39;Z&#39;) := 26;
  aa_str(&#39;A&#39;) := 1;
  aa_str(&#39;K&#39;) := 11;
  aa_str(&#39;R&#39;) := 18;
 
  DBMS_OUTPUT.PUT_LINE(&#39;Before deletions:&#39;);
  print_first_and_last;
 
  <span class="bold">aa_str.DELETE(&#39;A&#39;);</span>
  <span class="bold">aa_str.DELETE(&#39;Z&#39;);</span>
 
  DBMS_OUTPUT.PUT_LINE(&#39;After deletions:&#39;);
  print_first_and_last;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Before deletions:
FIRST = A
LAST = Z
After deletions:
FIRST = K
LAST = R
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS385"></a><a id="LNPLS384"></a>
<div class="props_rev_3"><a id="GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089"></a>
<h4 id="LNPLS-GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089" class="sect4">FIRST and LAST Methods for Varray</h4>
<div>
<p>For a varray that is not empty, <code class="codeph">FIRST</code> always returns 1. For every varray, <code class="codeph">LAST</code> always equals <code class="codeph">COUNT</code>.</p>
<div class="example" id="GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089__CIHHAEGC">
<p class="titleinexample">Example 5-24 Printing Varray with FIRST and LAST in FOR LOOP</p>
<p>This example prints the varray <code class="codeph">team</code> using a <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement with the bounds <code class="codeph">team</code>.<code class="codeph">FIRST</code> and <code class="codeph">team</code>.<code class="codeph">LAST</code>. Because a varray is always dense, <code class="codeph">team(i)</code> inside the loop always exists.</p>
<pre dir="ltr">DECLARE
  TYPE team_type IS VARRAY(4) OF VARCHAR2(15);
  team team_type;
 
  PROCEDURE print_team (heading VARCHAR2)
  IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    IF team IS NULL THEN
      DBMS_OUTPUT.PUT_LINE(&#39;Does not exist&#39;);
    ELSIF <span class="bold">team.FIRST</span> IS NULL THEN
      DBMS_OUTPUT.PUT_LINE(&#39;Has no members&#39;);
    ELSE
      FOR i IN <span class="bold">team.FIRST</span>..<span class="bold">team.LAST</span> LOOP
        DBMS_OUTPUT.PUT_LINE(i || &#39;. &#39; || team(i));
      END LOOP;
    END IF;
 
    DBMS_OUTPUT.PUT_LINE(&#39;---&#39;); 
  END;
  
BEGIN 
  print_team(&#39;Team Status:&#39;);
 
  team := team_type();  -- Team is funded, but nobody is on it.
  print_team(&#39;Team Status:&#39;);
 
  team := team_type(&#39;John&#39;, &#39;Mary&#39;);  -- Put 2 members on team.
  print_team(&#39;Initial Team:&#39;);
 
  team := team_type(&#39;Arun&#39;, &#39;Amitha&#39;, &#39;Allan&#39;, &#39;Mae&#39;);  -- Change team.
  print_team(&#39;New Team:&#39;);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Team Status:
Does not exist
---
Team Status:
Has no members
---
Initial Team:
1. John
2. Mary
---
New Team:
1. Arun
2. Amitha
3. Allan
4. Mae
---
</pre></div>
<!-- class="example" -->
<div class="section">
<p class="subhead3">Related Topic</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758__CIHIHFGI">Example 5-26</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<a id="LNPLS397"></a><a id="LNPLS396"></a>
<div class="props_rev_3"><a id="GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2"></a>
<h4 id="LNPLS-GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2" class="sect4">FIRST and LAST Methods for Nested Table</h4>
<div>
<p>For a nested table, <code class="codeph">LAST</code> equals <code class="codeph">COUNT</code> unless you delete elements from its middle, in which case <code class="codeph">LAST</code> is larger than <code class="codeph">COUNT</code>.</p>
<div class="example" id="GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2__CIHGFDJA">
<p class="titleinexample">Example 5-25 Printing Nested Table with FIRST and LAST in FOR LOOP</p>
<p>This example prints the nested table <code class="codeph">team</code> using a <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement with the bounds <code class="codeph">team</code>.<code class="codeph">FIRST</code> and <code class="codeph">team</code>.<code class="codeph">LAST</code>. Because a nested table can be sparse, the <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement prints <code class="codeph">team(i)</code> only if <code class="codeph">team</code>.<code class="codeph">EXISTS(i)</code> is <code class="codeph">TRUE</code>.</p>
<pre dir="ltr">DECLARE
  TYPE team_type IS TABLE OF VARCHAR2(15);
  team team_type;
 
  PROCEDURE print_team (heading VARCHAR2) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    IF team IS NULL THEN
      DBMS_OUTPUT.PUT_LINE(&#39;Does not exist&#39;);
    ELSIF <span class="bold">team.FIRST</span> IS NULL THEN
      DBMS_OUTPUT.PUT_LINE(&#39;Has no members&#39;);
    ELSE
      FOR i IN <span class="bold">team.FIRST</span>..<span class="bold">team.LAST</span> LOOP
        DBMS_OUTPUT.PUT(i || &#39;. &#39;);
        IF <span class="bold">team.EXISTS(i)</span> THEN
          DBMS_OUTPUT.PUT_LINE(team(i));
        ELSE
          DBMS_OUTPUT.PUT_LINE(&#39;(to be hired)&#39;);
        END IF;
      END LOOP;
    END IF;
 
    DBMS_OUTPUT.PUT_LINE(&#39;---&#39;); 
  END;
  
BEGIN 
  print_team(&#39;Team Status:&#39;);
 
  team := team_type();  -- Team is funded, but nobody is on it.
  print_team(&#39;Team Status:&#39;);
 
  team := team_type(&#39;Arun&#39;, &#39;Amitha&#39;, &#39;Allan&#39;, &#39;Mae&#39;);  -- Add members.
  print_team(&#39;Initial Team:&#39;);
 
  team.DELETE(2,3);  -- Remove 2nd and 3rd members.
  print_team(&#39;Current Team:&#39;);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Team Status:
Does not exist
---
Team Status:
Has no members
---
Initial Team:
1. Arun
2. Amitha
3. Allan
4. Mae
---
Current Team:
1. Arun
2. (to be hired)
3. (to be hired)
4. Mae
---
</pre></div>
<!-- class="example" -->
<div class="section">
<p class="subhead3">Related Topic</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89__BABHFIGG">Example 5-27</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="LNPLS398"></a><a id="LNPLS99967"></a>
<div class="props_rev_3"><a id="GUID-5700158F-FF45-4964-89B3-1EF614BA3B7D"></a>
<h3 id="LNPLS-GUID-5700158F-FF45-4964-89B3-1EF614BA3B7D" class="sect3">COUNT Collection Method</h3>
<div>
<p><code class="codeph">COUNT</code> is a function that returns the number of elements in the collection (ignoring deleted elements, even if <code class="codeph">DELETE</code> kept placeholders for them).</p>
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758" title="For a varray, COUNT always equals LAST. If you increase or decrease the size of a varray (with the EXTEND or TRIM method), the value of COUNT changes.">COUNT Method for Varray</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89" title="For a nested table, COUNT equals LAST unless you delete elements from the middle of the nested table, in which case COUNT is smaller than LAST.">COUNT Method for Nested Table</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS403"></a><a id="LNPLS401"></a>
<div class="props_rev_3"><a id="GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758"></a>
<h4 id="LNPLS-GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758" class="sect4">COUNT Method for Varray</h4>
<div>
<p>For a varray, <code class="codeph">COUNT</code> always equals <code class="codeph">LAST</code>. If you increase or decrease the size of a varray (with the <code class="codeph">EXTEND</code> or <code class="codeph">TRIM</code> method), the value of <code class="codeph">COUNT</code> changes.</p>
<div class="example" id="GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758__CIHIHFGI">
<p class="titleinexample">Example 5-26 COUNT and LAST Values for Varray</p>
<p>This example shows the values of <code class="codeph">COUNT</code> and <code class="codeph">LAST</code> for a varray after initialization with four elements, after <code class="codeph">EXTEND(3)</code>, and after <code class="codeph">TRIM(5)</code>.</p>
<pre dir="ltr">DECLARE
  TYPE NumList IS VARRAY(10) OF INTEGER;
  n NumList := NumList(1,3,5,7);
 
  PROCEDURE print_count_and_last IS
  BEGIN
    DBMS_OUTPUT.PUT(&#39;n.COUNT = &#39; || <span class="bold">n.COUNT</span> || &#39;, &#39;);
    DBMS_OUTPUT.PUT_LINE(&#39;n.LAST = &#39; || <span class="bold">n.LAST</span>);
  END  print_count_and_last;
 
BEGIN
  print_count_and_last;
 
  <span class="bold">n.EXTEND(3);</span>
  print_count_and_last;
 
  <span class="bold">n.TRIM(5);</span>
  print_count_and_last;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">n.COUNT = 4, n.LAST = 4
n.COUNT = 7, n.LAST = 7
n.COUNT = 2, n.LAST = 2
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS474"></a><a id="LNPLS405"></a>
<div class="props_rev_3"><a id="GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89"></a>
<h4 id="LNPLS-GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89" class="sect4">COUNT Method for Nested Table</h4>
<div>
<p>For a nested table, <code class="codeph">COUNT</code> equals <code class="codeph">LAST</code> unless you delete elements from the middle of the nested table, in which case <code class="codeph">COUNT</code> is smaller than <code class="codeph">LAST</code>.</p>
<div class="example" id="GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89__BABHFIGG">
<p class="titleinexample">Example 5-27 COUNT and LAST Values for Nested Table</p>
<p>This example shows the values of <code class="codeph">COUNT</code> and <code class="codeph">LAST</code> for a nested table after initialization with four elements, after deleting the third element, and after adding two null elements to the end. Finally, the example prints the status of elements 1 through 8.</p>
<pre dir="ltr">DECLARE
  TYPE NumList IS TABLE OF INTEGER;
  n NumList := NumList(1,3,5,7);
 
  PROCEDURE print_count_and_last IS
  BEGIN
    DBMS_OUTPUT.PUT(&#39;n.COUNT = &#39; || <span class="bold">n.COUNT</span> || &#39;, &#39;);
    DBMS_OUTPUT.PUT_LINE(&#39;n.LAST = &#39; || <span class="bold">n.LAST</span>);
  END  print_count_and_last;
 
BEGIN
  print_count_and_last;
 
  <span class="bold">n.DELETE(3);</span>  -- Delete third element
  print_count_and_last;
 
  <span class="bold">n.EXTEND(2);</span>  -- Add two null elements to end
  print_count_and_last;
 
  FOR i IN 1..8 LOOP
    IF <span class="bold">n.EXISTS(i)</span> THEN
      IF n(i) IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE(&#39;n(&#39; || i || &#39;) = &#39; || n(i));
      ELSE
        DBMS_OUTPUT.PUT_LINE(&#39;n(&#39; || i || &#39;) = NULL&#39;);
      END IF;
    ELSE
      DBMS_OUTPUT.PUT_LINE(&#39;n(&#39; || i || &#39;) does not exist&#39;);
    END IF;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">n.COUNT = 4, n.LAST = 4
n.COUNT = 3, n.LAST = 4
n.COUNT = 5, n.LAST = 6
n(1) = 1
n(2) = 3
n(3) does not exist
n(4) = 7
n(5) = NULL
n(6) = NULL
n(7) does not exist
n(8) does not exist
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS475"></a><a id="LNPLS99966"></a>
<div class="props_rev_3"><a id="GUID-1E0E1010-FFC5-4F4A-AD87-58BE9CE8146D"></a>
<h3 id="LNPLS-GUID-1E0E1010-FFC5-4F4A-AD87-58BE9CE8146D" class="sect3">LIMIT Collection Method</h3>
<div>
<p><code class="codeph">LIMIT</code> is a function that returns the maximum number of elements that the collection can have. If the collection has no maximum number of elements, <code class="codeph">LIMIT</code> returns <code class="codeph">NULL</code>. Only a varray has a maximum size.</p>
<div class="example" id="GUID-1E0E1010-FFC5-4F4A-AD87-58BE9CE8146D__BABFCAGJ">
<p class="titleinexample">Example 5-28 LIMIT and COUNT Values for Different Collection Types</p>
<p>This example prints the values of <code class="codeph">LIMIT</code> and <code class="codeph">COUNT</code> for an associative array with four elements, a varray with two elements, and a nested table with three elements.</p>
<pre dir="ltr">DECLARE
  TYPE aa_type IS TABLE OF INTEGER INDEX BY PLS_INTEGER;
  aa aa_type;                          -- associative array
 
  TYPE va_type IS VARRAY(4) OF INTEGER;
  va  va_type := va_type(2,4);   -- varray
 
  TYPE nt_type IS TABLE OF INTEGER;
  nt  nt_type := nt_type(1,3,5);  -- nested table
 
BEGIN
  aa(1):=3; aa(2):=6; aa(3):=9; aa(4):= 12;
 
  DBMS_OUTPUT.PUT(&#39;aa.COUNT = &#39;);
  DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(<span class="bold">aa.COUNT</span>), &#39;NULL&#39;));
 
  DBMS_OUTPUT.PUT(&#39;aa.LIMIT = &#39;);
  DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(<span class="bold">aa.LIMIT</span>), &#39;NULL&#39;));
 
  DBMS_OUTPUT.PUT(&#39;va.COUNT = &#39;);
  DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(<span class="bold">va.COUNT</span>), &#39;NULL&#39;));
 
  DBMS_OUTPUT.PUT(&#39;va.LIMIT = &#39;);
  DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(<span class="bold">va.LIMIT</span>), &#39;NULL&#39;));
 
  DBMS_OUTPUT.PUT(&#39;nt.COUNT = &#39;);
  DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(<span class="bold">nt.COUNT</span>), &#39;NULL&#39;));
 
  DBMS_OUTPUT.PUT(&#39;nt.LIMIT = &#39;);
  DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(<span class="bold">nt.LIMIT</span>), &#39;NULL&#39;));
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">aa.COUNT = 4
aa.LIMIT = NULL
va.COUNT = 2
va.LIMIT = 4
nt.COUNT = 3
nt.LIMIT = NULL
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS407"></a><a id="LNPLS478"></a><a id="LNPLS99964"></a>
<div class="props_rev_3"><a id="GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09"></a>
<h3 id="LNPLS-GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09" class="sect3">PRIOR and NEXT Collection Methods</h3>
<div>
<p><code class="codeph">PRIOR</code> and <code class="codeph">NEXT</code> are functions that let you move backward and forward in the collection (ignoring deleted elements, even if <code class="codeph">DELETE</code> kept placeholders for them). These methods are useful for traversing sparse collections.</p>
<p>Given an index:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">PRIOR</code> returns the index of the preceding existing element of the collection, if one exists. Otherwise, <code class="codeph">PRIOR</code> returns <code class="codeph">NULL</code>.</p>
<p>For any collection <code class="codeph">c</code>, <code class="codeph">c.PRIOR(c.FIRST)</code> returns <code class="codeph">NULL</code>.</p>
</li>
<li>
<p><code class="codeph">NEXT</code> returns the index of the succeeding existing element of the collection, if one exists. Otherwise, <code class="codeph">NEXT</code> returns <code class="codeph">NULL</code>.</p>
<p>For any collection <code class="codeph">c</code>, <code class="codeph">c.NEXT(c.LAST)</code> returns <code class="codeph">NULL</code>.</p>
</li>
</ul>
<p>The given index need not exist. However, if the collection <code class="codeph">c</code> is a varray, and the index exceeds <code class="codeph">c.LIMIT</code>, then:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">c.PRIOR(</code><span class="italic"><code class="codeph">index</code></span><code class="codeph">)</code> returns <code class="codeph">c.LAST</code>.</p>
</li>
<li>
<p><code class="codeph">c.NEXT(</code><span class="italic"><code class="codeph">index</code></span><code class="codeph">)</code> returns <code class="codeph">NULL</code>.</p>
</li>
</ul>
<p>For example:</p>
<pre dir="ltr">DECLARE
  TYPE Arr_Type IS VARRAY(10) OF NUMBER;
  v_Numbers Arr_Type := Arr_Type();
BEGIN
  v_Numbers.EXTEND(4);
 
  v_Numbers (1) := 10;
  v_Numbers (2) := 20;
  v_Numbers (3) := 30;
  v_Numbers (4) := 40;
 
  DBMS_OUTPUT.PUT_LINE(NVL(v_Numbers.prior (3400), -1));
  DBMS_OUTPUT.PUT_LINE(NVL(v_Numbers.next (3400), -1));
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">4
-1
</pre>
<p>For an associative array indexed by string, the prior and next indexes are determined by key values, which are in sorted order (for more information, see <span class="q">&#34;<a href="composites.htm#GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26" title="National Language Support (NLS) parameters such as NLS_SORT, NLS_COMP, and NLS_DATE_FORMAT affect associative arrays indexed by string.">NLS Parameter Values Affect Associative Arrays Indexed by String</a>&#34;</span>). <a href="composites.htm#GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__BABHGFHJ">Example 5-1</a> uses <code class="codeph">FIRST</code>, <code class="codeph">NEXT</code>, and a <code class="codeph">WHILE</code> <code class="codeph">LOOP</code> statement to print the elements of an associative array.</p>
<div class="example" id="GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09__CIHHHICG">
<p class="titleinexample">Example 5-29 PRIOR and NEXT Methods</p>
<p>This example initializes a nested table with six elements, deletes the fourth element, and then shows the values of <code class="codeph">PRIOR</code> and <code class="codeph">NEXT</code> for elements 1 through 7. Elements 4 and 7 do not exist. Element 2 exists, despite its null value.</p>
<pre dir="ltr">DECLARE
  TYPE nt_type IS TABLE OF NUMBER;
  nt nt_type := nt_type(18, NULL, 36, 45, 54, 63);
 
BEGIN
  <span class="bold">nt.DELETE(4);</span>
  DBMS_OUTPUT.PUT_LINE(&#39;nt(4) was deleted.&#39;);
 
  FOR i IN 1..7 LOOP
    DBMS_OUTPUT.PUT(&#39;nt.PRIOR(&#39; || i || &#39;) = &#39;);
    DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(<span class="bold">nt.PRIOR(i)</span>), &#39;NULL&#39;));

    DBMS_OUTPUT.PUT(&#39;nt.NEXT(&#39; || i || &#39;)  = &#39;);
    DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(<span class="bold">nt.NEXT(i)</span>), &#39;NULL&#39;));
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">nt(4) was deleted.
nt.PRIOR(1) = NULL
nt.NEXT(1)  = 2
nt.PRIOR(2) = 1
nt.NEXT(2)  = 3
nt.PRIOR(3) = 2
nt.NEXT(3)  = 5
nt.PRIOR(4) = 3
nt.NEXT(4)  = 5
nt.PRIOR(5) = 3
nt.NEXT(5)  = 6
nt.PRIOR(6) = 5
nt.NEXT(6)  = NULL
nt.PRIOR(7) = 6
nt.NEXT(7)  = NULL
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09__BEIBJDBF">
<p class="titleinexample">Example 5-30 Printing Elements of Sparse Nested Table</p>
<p>This example prints the elements of a sparse nested table from first to last, using <code class="codeph">FIRST</code> and <code class="codeph">NEXT</code>, and from last to first, using <code class="codeph">LAST</code> and <code class="codeph">PRIOR</code>.</p>
<pre dir="ltr">DECLARE
  TYPE NumList IS TABLE OF NUMBER;
  n NumList := NumList(1, 2, NULL, NULL, 5, NULL, 7, 8, 9, NULL);
  idx INTEGER;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;First to last:&#39;);
  idx := <span class="bold">n.FIRST</span>;
  WHILE idx IS NOT NULL LOOP
    DBMS_OUTPUT.PUT(&#39;n(&#39; || idx || &#39;) = &#39;);
    DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(n(idx)), &#39;NULL&#39;));
    idx := <span class="bold">n.NEXT(idx)</span>;
  END LOOP;
    
  DBMS_OUTPUT.PUT_LINE(&#39;--------------&#39;);
 
  DBMS_OUTPUT.PUT_LINE(&#39;Last to first:&#39;);
  idx := <span class="bold">n.LAST</span>;
  WHILE idx IS NOT NULL LOOP
    DBMS_OUTPUT.PUT(&#39;n(&#39; || idx || &#39;) = &#39;);
    DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(n(idx)), &#39;NULL&#39;));
    idx := <span class="bold">n.PRIOR(idx)</span>;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">First to last:
n(1) = 1
n(2) = 2
n(3) = NULL
n(4) = NULL
n(5) = 5
n(6) = NULL
n(7) = 7
n(8) = 8
n(9) = 9
n(10) = NULL
--------------
Last to first:
n(10) = NULL
n(9) = 9
n(8) = 8
n(7) = 7
n(6) = NULL
n(5) = 5
n(4) = NULL
n(3) = NULL
n(2) = 2
n(1) = 1
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS486"></a><a id="LNPLS408"></a><a id="LNPLS00511"></a>
<div class="props_rev_3"><a id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47"></a>
<h2 id="LNPLS-GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47" class="sect2">Collection Types Defined in Package Specifications</h2>
<div>
<p>A collection type defined in a package specification is incompatible with an identically defined local or standalone collection type.</p>
<div class="infobox-note" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__GUID-93F5F845-5596-4777-9650-D42E713F92E3">
<p class="notep1">Note:</p>
<p>The examples in this topic define packages and procedures, which are explained in <a href="packages.htm#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">PL/SQL Packages</a> and <a href="subprograms.htm#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B">PL/SQL Subprograms</a>, respectively.</p>
</div>
<div class="example" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CHDIHDIJ">
<p class="titleinexample">Example 5-31 Identically Defined Package and Local Collection Types</p>
<p>In this example, the package specification and the anonymous block define the collection type <code class="codeph">NumList</code> identically. The package defines a procedure, <code class="codeph">print_numlist</code>, which has a <code class="codeph">NumList</code> parameter. The anonymous block declares the variable <code class="codeph">n1</code> of the type <code class="codeph">pkg.NumList</code> (defined in the package) and the variable <code class="codeph">n2</code> of the type <code class="codeph">NumList</code> (defined in the block). The anonymous block can pass <code class="codeph">n1</code> to <code class="codeph">print_numlist</code>, but it cannot pass <code class="codeph">n2</code> to <code class="codeph">print_numlist</code>.</p>
<div class="infobox-note" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__GUID-052A4211-A3C9-40BC-BC7C-8EA1A5AA4F6C">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites40err.html" target="_blank">Identically Defined Package and Local Collection Types</a></p>
</div>
<pre dir="ltr">CREATE OR REPLACE PACKAGE pkg AS
  <span class="bold">TYPE NumList IS TABLE OF NUMBER;</span>
  PROCEDURE print_numlist (nums NumList);
END pkg;
/
CREATE OR REPLACE PACKAGE BODY pkg AS
  PROCEDURE print_numlist (nums NumList) IS
  BEGIN
    FOR i IN nums.FIRST..nums.LAST LOOP
      DBMS_OUTPUT.PUT_LINE(nums(i));
    END LOOP;
  END;
END pkg;
/
DECLARE
  <span class="bold">TYPE NumList IS TABLE OF NUMBER;  -- local type identical to package type</span>
  n1 pkg.NumList := pkg.NumList(2,4);  -- package type
  n2     NumList :=     NumList(6,8);  -- local type
BEGIN
  pkg.print_numlist(n1);  -- succeeds
  <span class="bold">pkg.print_numlist(n2);  -- fails</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">  pkg.print_numlist(n2);  -- fails
  *
ERROR at line 7:
ORA-06550: line 7, column 3:
PLS-00306: wrong number or types of arguments in call to &#39;PRINT_NUMLIST&#39;
ORA-06550: line 7, column 3:
PL/SQL: Statement ignored
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CIHBGBBH">
<p class="titleinexample">Example 5-32 Identically Defined Package and Standalone Collection Types</p>
<p>This example defines a standalone collection type <code class="codeph">NumList</code> that is identical to the collection type <code class="codeph">NumList</code> defined in the package specification in <a href="composites.htm#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CHDIHDIJ">Example 5-31</a>. The anonymous block declares the variable <code class="codeph">n1</code> of the type <code class="codeph">pkg.NumList</code> (defined in the package) and the variable <code class="codeph">n2</code> of the standalone type <code class="codeph">NumList</code>. The anonymous block can pass <code class="codeph">n1</code> to <code class="codeph">print_numlist</code>, but it cannot pass <code class="codeph">n2</code> to <code class="codeph">print_numlist</code>.</p>
<div class="infobox-note" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__GUID-EA1DDCDE-E9A0-4B6E-9DF4-76BC998BBB60">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites74err.html" target="_blank">Identically Defined Package and Standalone Collection Types</a></p>
</div>
<pre dir="ltr"><span class="bold">CREATE OR REPLACE TYPE NumList IS TABLE OF NUMBER;</span>
  <span class="bold">-- standalone collection type identical to package type</span>
/
DECLARE
  n1 pkg.NumList := pkg.NumList(2,4);  -- package type
  n2     NumList :=     NumList(6,8);  -- standalone type
 
BEGIN
  pkg.print_numlist(n1);  -- succeeds
  <span class="bold">pkg.print_numlist(n2);  -- fails</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">  pkg.print_numlist(n2);  -- fails
  *
ERROR at line 7:
ORA-06550: line 7, column 3:
PLS-00306: wrong number or types of arguments in call to &#39;PRINT_NUMLIST&#39;
ORA-06550: line 7, column 3:
PL/SQL: Statement ignored
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS417"></a><a id="LNPLS00509"></a>
<div class="props_rev_3"><a id="GUID-75875E26-FC7B-4513-A5E2-EDA26F1D67B1"></a>
<h2 id="LNPLS-GUID-75875E26-FC7B-4513-A5E2-EDA26F1D67B1" class="sect2">Record Variables</h2>
<div>
<p>You can create a record variable in any of these ways:</p>
<ul style="list-style-type: disc;">
<li>
<p>Define a <code class="codeph">RECORD</code> type and then declare a variable of that type.</p>
</li>
<li>
<p>Use <code class="codeph">%ROWTYPE</code> to declare a record variable that represents either a full or partial row of a database table or view.</p>
</li>
<li>
<p>Use <code class="codeph">%TYPE</code> to declare a record variable of the same type as a previously declared record variable.</p>
</li>
</ul>
<p>For syntax and semantics, see <span class="q">&#34;<a href="record_definition.htm#GUID-704FC014-561E-422C-9636-EDCA3B996AAD" title="A record variable is a composite variable whose internal components, called fields, can have different data types. The value of a record variable and the values of its fields can change.">Record Variable Declaration</a>&#34;</span>.</p>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-AD93581B-6F16-4E84-9C05-30B251755782" title="For a record variable of a RECORD type, the initial value of each field is NULL unless you specify a different initial value for it when you define the type.">Initial Values of Record Variables</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8" title="When declaring a record constant, you must create a function that populates the record with its initial value and then invoke the function in the constant declaration.">Declaring Record Constants</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F">RECORD Types</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-EBF66B92-8A94-4E3A-A837-253D5DA79D5F" title="The %ROWTYPE attribute lets you declare a record variable that represents either a full or partial row of a database table or view.">Declaring Items using the %ROWTYPE Attribute</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS419"></a>
<div class="props_rev_3"><a id="GUID-AD93581B-6F16-4E84-9C05-30B251755782"></a>
<h3 id="LNPLS-GUID-AD93581B-6F16-4E84-9C05-30B251755782" class="sect3">Initial Values of Record Variables</h3>
<div>
<p>For a record variable of a <code class="codeph">RECORD</code> type, the initial value of each field is <code class="codeph">NULL</code> unless you specify a different initial value for it when you define the type.</p>
<p>For a record variable declared with <code class="codeph">%ROWTYPE</code> or <code class="codeph">%TYPE</code>, the initial value of each field is <code class="codeph">NULL</code>. The variable does not inherit the initial value of the referenced item.</p>
</div>
</div>
<a id="LNPLS426"></a><a id="LNPLS99856"></a>
<div class="props_rev_3"><a id="GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8"></a>
<h3 id="LNPLS-GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8" class="sect3">Declaring Record Constants</h3>
<div>
<p>When declaring a record constant, you must create a function that populates the record with its initial value and then invoke the function in the constant declaration.</p>
<div class="example" id="GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8__BABCGFCE">
<p class="titleinexample">Example 5-33 Declaring Record Constant</p>
<p>This example creates a function that populates the record with its initial value and then invoke the function in the constant declaration.</p>
<div class="infobox-note" id="GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8__GUID-F0637744-DA65-44DD-B8E5-226D68F8FE7C">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites90.html" target="_blank">Declaring Record Constant</a></p>
</div>
<pre dir="ltr">CREATE OR REPLACE PACKAGE My_Types AUTHID CURRENT_USER IS
  TYPE My_Rec IS RECORD (a NUMBER, b NUMBER);
  FUNCTION Init_My_Rec RETURN My_Rec;
END My_Types;
/
CREATE OR REPLACE PACKAGE BODY My_Types IS
  <span class="bold">FUNCTION Init_My_Rec RETURN My_Rec IS</span>
    <span class="bold">Rec My_Rec;</span>
  <span class="bold">BEGIN</span>
    <span class="bold">Rec.a := 0;</span>
    <span class="bold">Rec.b := 1;</span>
    <span class="bold">RETURN Rec;</span>
  <span class="bold">END Init_My_Rec;</span>
END My_Types;
/
DECLARE
  <span class="bold">r CONSTANT My_Types.My_Rec := My_Types.Init_My_Rec();</span>
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;r.a = &#39; || r.a);
  DBMS_OUTPUT.PUT_LINE(&#39;r.b = &#39; || r.b);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">r.a = 0
r.b = 1
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS427"></a><a id="LNPLS433"></a><a id="LNPLS439"></a><a id="LNPLS441"></a><a id="LNPLS99971"></a>
<div class="props_rev_3"><a id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F"></a>
<h3 id="LNPLS-GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F" class="sect3">RECORD Types</h3>
<div>
<p>A <code class="codeph">RECORD</code> type defined in a PL/SQL block is a <span class="bold">local type</span>. It is available only in the block, and is stored in the database only if the block is in a standalone or package subprogram.</p>
<p>A <code class="codeph">RECORD</code> type defined in a package specification is a <span class="bold">public item</span>. You can reference it from outside the package by qualifying it with the package name (<span class="italic"><code class="codeph">package_name.type_name</code></span>). It is stored in the database until you drop the package with the <code class="codeph">DROP</code> <code class="codeph">PACKAGE</code> statement.</p>
<p>You cannot create a <code class="codeph">RECORD</code> type at schema level. Therefore, a <code class="codeph">RECORD</code> type cannot be an ADT attribute data type.</p>
<p>To define a <code class="codeph">RECORD</code> type, specify its name and define its fields. To define a field, specify its name and data type. By default, the initial value of a field is <code class="codeph">NULL</code>. You can specify the <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint for a field, in which case you must also specify a non-<code class="codeph">NULL</code> initial value. Without the <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint, a non-<code class="codeph">NULL</code> initial value is optional.</p>
<p>A <code class="codeph">RECORD</code> type defined in a package specification is incompatible with an identically defined local <code class="codeph">RECORD</code> type.</p>
<div class="infoboxnotealso" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-06DEDBF8-F8E5-43D2-96FA-EAE7D433F380">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="packages.htm#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">PL/SQL Packages</a></p>
</li>
<li>
<p><a href="subprograms.htm#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B">PL/SQL Subprograms</a></p>
</li>
<li>
<p><a href="subprograms.htm#GUID-E03F512B-1A30-43B4-8DCA-64DA68AE7CE4">Nested, Package, and Standalone Subprograms</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHFBIAF">Example 5-37</a>, <span class="q">&#34;&#34;</span></p>
</li>
</ul>
</div>
<div class="example" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHHBIDA">
<p class="titleinexample">Example 5-34 RECORD Type Definition and Variable Declaration</p>
<p>This example defines a <code class="codeph">RECORD</code> type named <code class="codeph">DeptRecTyp</code>, specifying an initial value for each field. Then it declares a variable of that type named <code class="codeph">dept_rec</code> and prints its fields.</p>
<div class="infobox-note" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-7B368681-6234-47FB-81F9-3CEC4C078E1A">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites76.html" target="_blank">RECORD Type Definition and Variable Declaration</a></p>
</div>
<pre dir="ltr">DECLARE
  TYPE DeptRecTyp IS RECORD (
    dept_id    NUMBER(4) NOT NULL := 10,
    dept_name  VARCHAR2(30) NOT NULL := &#39;Administration&#39;,
    mgr_id     NUMBER(6) := 200,
    loc_id     NUMBER(4) := 1700
  );
 
  dept_rec DeptRecTyp;
BEGIN
  DBMS_OUTPUT.PUT_LINE(&#39;dept_id:   &#39; || dept_rec.dept_id);
  DBMS_OUTPUT.PUT_LINE(&#39;dept_name: &#39; || dept_rec.dept_name);
  DBMS_OUTPUT.PUT_LINE(&#39;mgr_id:    &#39; || dept_rec.mgr_id);
  DBMS_OUTPUT.PUT_LINE(&#39;loc_id:    &#39; || dept_rec.loc_id);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">dept_id:   10
dept_name: Administration
mgr_id:    200
loc_id:    1700
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHEGIFD">
<p class="titleinexample">Example 5-35 RECORD Type with RECORD Field (Nested Record)</p>
<p>This example defines two <code class="codeph">RECORD</code> types, <code class="codeph">name_rec</code> and <code class="codeph">contact</code>. The type <code class="codeph">contact</code> has a field of type <code class="codeph">name_rec</code>.</p>
<div class="infobox-note" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-A4286E0A-9DD8-4E7C-9A1B-66906484BCDA">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites77.html" target="_blank">RECORD Type with RECORD Field (Nested Record)</a></p>
</div>
<pre dir="ltr">DECLARE
  <span class="bold">TYPE name_rec IS RECORD</span> (
    first  employees.first_name%TYPE,
    last   employees.last_name%TYPE
  );
 
  <span class="bold">TYPE contact IS RECORD</span> (
    <span class="bold">name  name_rec,                    -- nested record</span>
    phone employees.phone_number%TYPE
  );
 
  friend contact;
BEGIN
  friend.name.first := &#39;John&#39;;
  friend.name.last := &#39;Smith&#39;;
  friend.phone := &#39;1-650-555-1234&#39;;
  
  DBMS_OUTPUT.PUT_LINE (
    friend.name.first  || &#39; &#39; ||
    friend.name.last   || &#39;, &#39; ||
    friend.phone
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">John Smith, 1-650-555-1234
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHDJFDB">
<p class="titleinexample">Example 5-36 RECORD Type with Varray Field</p>
<p>This defines a <code class="codeph">VARRAY</code> type, <code class="codeph">full_name</code>, and a <code class="codeph">RECORD</code> type, <code class="codeph">contact</code>. The type <code class="codeph">contact</code> has a field of type <code class="codeph">full_name</code>.</p>
<div class="infobox-note" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-23794D86-103A-4A5E-96E4-350C1451D3CF">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites78.html" target="_blank">RECORD Type with Varray Field</a></p>
</div>
<pre dir="ltr">DECLARE
  <span class="bold">TYPE full_name IS VARRAY(2) OF VARCHAR2(20);</span>
 
  <span class="bold">TYPE contact IS RECORD</span> (
    <span class="bold">name  full_name</span> := full_name(&#39;John&#39;, &#39;Smith&#39;),  <span class="bold">-- varray field</span>
    phone employees.phone_number%TYPE
  );
 
  friend contact;
BEGIN
  friend.phone := &#39;1-650-555-1234&#39;;
  
  DBMS_OUTPUT.PUT_LINE (
    friend.name(1) || &#39; &#39; ||
    friend.name(2) || &#39;, &#39; ||
    friend.phone
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">John Smith, 1-650-555-1234
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHFBIAF">
<p class="titleinexample">Example 5-37 Identically Defined Package and Local RECORD Types</p>
<p>In this example, the package <code class="codeph">pkg</code> and the anonymous block define the <code class="codeph">RECORD</code> type <code class="codeph">rec_type</code> identically. The package defines a procedure, <code class="codeph">print_rec_type</code>, which has a <code class="codeph">rec_type</code> parameter. The anonymous block declares the variable <code class="codeph">r1</code> of the package type (<code class="codeph">pkg.rec_type</code>) and the variable <code class="codeph">r2</code> of the local type (<code class="codeph">rec_type</code>). The anonymous block can pass <code class="codeph">r1</code> to <code class="codeph">print_rec_type</code>, but it cannot pass <code class="codeph">r2</code> to <code class="codeph">print_rec_type</code>.</p>
<div class="infobox-note" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-5A99E590-8A58-4B7B-AB10-86A3638FA58C">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites75err.html" target="_blank">Identically Defined Package and Local RECORD Types</a></p>
</div>
<pre dir="ltr">CREATE OR REPLACE PACKAGE pkg AS
  <span class="bold">TYPE rec_type IS RECORD (       -- package RECORD type</span>
    <span class="bold">f1 INTEGER,</span>
    <span class="bold">f2 VARCHAR2(4)</span>
  <span class="bold">);</span>
  PROCEDURE print_rec_type (rec rec_type);
END pkg;
/
CREATE OR REPLACE PACKAGE BODY pkg AS
  PROCEDURE print_rec_type (rec rec_type) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(rec.f1);
    DBMS_OUTPUT.PUT_LINE(rec.f2);
  END; 
END pkg;
/
DECLARE
  <span class="bold">TYPE rec_type IS RECORD (       -- local RECORD type</span>
    <span class="bold">f1 INTEGER,</span>
    <span class="bold">f2 VARCHAR2(4)</span>
  <span class="bold">);</span>
  r1 pkg.rec_type;                -- package type
  r2     rec_type;                -- local type
 
BEGIN
  r1.f1 := 10; r1.f2 := &#39;abcd&#39;;
  r2.f1 := 25; r2.f2 := &#39;wxyz&#39;;
 
  pkg.print_rec_type(r1);  -- succeeds
  <span class="bold">pkg.print_rec_type(r2);  -- fails</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">  pkg.print_rec_type(r2);  -- fails
  *
ERROR at line 14:
ORA-06550: line 14, column 3:
PLS-00306: wrong number or types of arguments in call to &#39;PRINT_REC_TYPE&#39;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS442"></a><a id="LNPLS99912"></a>
<div class="props_rev_3"><a id="GUID-EBF66B92-8A94-4E3A-A837-253D5DA79D5F"></a>
<h3 id="LNPLS-GUID-EBF66B92-8A94-4E3A-A837-253D5DA79D5F" class="sect3">Declaring Items using the %ROWTYPE Attribute</h3>
<div>
<p>The <code class="codeph">%ROWTYPE</code> attribute lets you declare a record variable that represents either a full or partial row of a database table or view.</p>
<p>For the syntax and semantics details, see <a href="rowtype_attribute.htm#GUID-4E0B9FE2-909D-444A-9B4A-E0243B7FCB99" title="The %ROWTYPE attribute lets you declare a record that represents either a full or partial row of a database table or view.">%ROWTYPE Attribute</a>.</p>
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-9D20CCCC-E34B-473B-8499-4787D17C1980">Declaring a Record Variable that Always Represents Full Row</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB">Declaring a Record Variable that Can Represent Partial Row</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-FE47FF68-8720-48EF-9091-88476E31C589">%ROWTYPE Attribute and Virtual Columns</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-058B062C-C429-422B-AD64-B2CFF63075FC">%ROWTYPE Attribute and Invisible Columns</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS445"></a><a id="LNPLS219"></a><a id="LNPLS444"></a>
<div class="props_rev_3"><a id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980"></a>
<h4 id="LNPLS-GUID-9D20CCCC-E34B-473B-8499-4787D17C1980" class="sect4">Declaring a Record Variable that Always Represents Full Row</h4>
<div>
<p>To declare a record variable that always represents a full row of a database table or view, use this syntax:</p>
<pre dir="ltr"><span class="italic">variable_name</span> <span class="italic">table_or_view_name</span>%ROWTYPE;
</pre>
<p>For every column of the table or view, the record has a field with the same name and data type.</p>
<div class="infoboxnotealso" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__GUID-62B73CAF-71C4-48D0-95BA-E9459947F14F">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="rowtype_attribute.htm#GUID-4E0B9FE2-909D-444A-9B4A-E0243B7FCB99" title="The %ROWTYPE attribute lets you declare a record that represents either a full or partial row of a database table or view.">%ROWTYPE Attribute</a>&#34;</span> for more information about <code class="codeph">%ROWTYPE</code></p>
</div>
<div class="example" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__CIHJDGEJ">
<p class="titleinexample">Example 5-38 %ROWTYPE Variable Represents Full Database Table Row</p>
<p>This example declares a record variable that represents a row of the table <code class="codeph">departments</code>, assigns values to its fields, and prints them. Compare this example to <a href="composites.htm#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHHBIDA">Example 5-34</a>.</p>
<div class="infobox-note" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__GUID-F617EC90-7E08-44FD-ACFA-987A3F0A2214">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites80.html" target="_blank">%ROWTYPE Variable Represents Full Database Table Row</a></p>
</div>
<pre dir="ltr">DECLARE
  <span class="bold">dept_rec departments%ROWTYPE;</span>
BEGIN
  -- Assign values to fields:
  
  dept_rec.department_id   := 10;
  dept_rec.department_name := &#39;Administration&#39;;
  dept_rec.manager_id      := 200;
  dept_rec.location_id     := 1700;
 
  -- Print fields:
 
  DBMS_OUTPUT.PUT_LINE(&#39;dept_id:   &#39; || dept_rec.department_id);
  DBMS_OUTPUT.PUT_LINE(&#39;dept_name: &#39; || dept_rec.department_name);
  DBMS_OUTPUT.PUT_LINE(&#39;mgr_id:    &#39; || dept_rec.manager_id);
  DBMS_OUTPUT.PUT_LINE(&#39;loc_id:    &#39; || dept_rec.location_id);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">dept_id:   10
dept_name: Administration
mgr_id:    200
loc_id:    1700
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__BEIBGEFH">
<p class="titleinexample">Example 5-39 %ROWTYPE Variable Does Not Inherit Initial Values or Constraints</p>
<p>This example creates a table with two columns, each with an initial value and a <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint. Then it declares a record variable that represents a row of the table and prints its fields, showing that they did not inherit the initial values or <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints.</p>
<div class="infobox-note" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__GUID-58CE7EE5-5FE0-40DB-9FEC-A5226B37865B">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites79.html" target="_blank">%ROWTYPE Variable Does Not Inherit Initial Values or Constraints</a></p>
</div>
<pre dir="ltr">DROP TABLE t1;
CREATE TABLE t1 (
  c1 INTEGER <span class="bold">DEFAULT 0 NOT NULL</span>,
  c2 INTEGER <span class="bold">DEFAULT 1 NOT NULL</span>
);
 
DECLARE
  <span class="bold">t1_row t1%ROWTYPE;</span>
BEGIN
  DBMS_OUTPUT.PUT(&#39;t1.c1 = &#39;);
  DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(t1_row.c1), &#39;NULL&#39;));

  DBMS_OUTPUT.PUT(&#39;t1.c2 = &#39;); print(t1_row.c2);
  DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(t1_row.c2), &#39;NULL&#39;));
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">t1.c1 = NULL</span>
<span class="bold">t1.c2 = NULL</span>
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS220"></a><a id="LNPLS221"></a><a id="LNPLS446"></a>
<div class="props_rev_3"><a id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB"></a>
<h4 id="LNPLS-GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB" class="sect4">Declaring a Record Variable that Can Represent Partial Row</h4>
<div>
<div class="section">
<p>To declare a record variable that can represent a partial row of a database table or view, use this syntax:</p>
<pre dir="ltr"><span class="italic">variable_name</span> <span class="italic">cursor</span>%ROWTYPE;
</pre>
<p>A cursor is associated with a query. For every column that the query selects, the record variable must have a corresponding, type-compatible field. If the query selects every column of the table or view, then the variable represents a full row; otherwise, the variable represents a partial row. The cursor must be either an explicit cursor or a strong cursor variable.</p>
<div class="infoboxnotealso" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__GUID-516FA222-71B5-4F4B-B6E1-14419BA783F5">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="fetch_statement.htm#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="The FETCH statement retrieves rows of data from the result set of a multiple-row query&mdash;one row at a time, several rows at a time, or all rows at once&mdash;and stores the data in variables, records, or collections.">FETCH Statement</a>&#34;</span> for complete syntax</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" title="A cursor is a pointer to a private SQL area that stores information about processing a specific SELECT or DML statement.">Cursors Overview</a>&#34;</span> for information about cursors</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">Explicit Cursors</a>&#34;</span> for information about explicit cursors</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="To create a cursor variable, either declare a variable of the predefined type SYS_REFCURSOR or define a REF CURSOR type and then declare a variable of that type.After opening a cursor variable, you can fetch the rows of the query result set with the FETCH statement.You can assign to a PL/SQL cursor variable the value of another PL/SQL cursor variable or host cursor variable.The query associated with a cursor variable can reference any variable in its scope.You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.You can use a cursor variable as a host variable, which makes it useful for passing query results between PL/SQL stored subprograms and their clients.">Cursor Variables</a>&#34;</span> for information about cursor variables</p>
</li>
<li>
<p><a class="olink SQLRF30046" target="_blank" href="../SQLRF/queries006.htm#SQLRF30046"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about joins</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__CBJCGDHB">
<p class="titleinexample">Example 5-40 %ROWTYPE Variable Represents Partial Database Table Row</p>
<p>This example defines an explicit cursor whose query selects only the columns <code class="codeph">first_name</code>, <code class="codeph">last_name</code>, and <code class="codeph">phone_number</code> from the <code class="codeph">employees</code> table in the sample schema <code class="codeph">HR</code>. Then the example declares a record variable that has a field for each column that the cursor selects. The variable represents a partial row of <code class="codeph">employees</code>. Compare this example to <a href="composites.htm#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHEGIFD">Example 5-35</a>.</p>
<div class="infobox-note" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__GUID-74DD35A4-972D-447C-B920-46A4050397B3">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites81.html" target="_blank">%ROWTYPE Variable Represents Partial Database Table Row</a></p>
</div>
<pre dir="ltr">DECLARE
  CURSOR c IS
    SELECT first_name, last_name, phone_number
    FROM employees;
 
  <span class="bold">friend c%ROWTYPE;</span>
BEGIN
  friend.first_name   := &#39;John&#39;;
  friend.last_name    := &#39;Smith&#39;;
  friend.phone_number := &#39;1-650-555-1234&#39;;
  
  DBMS_OUTPUT.PUT_LINE (
    friend.first_name  || &#39; &#39; ||
    friend.last_name   || &#39;, &#39; ||
    friend.phone_number
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">John Smith, 1-650-555-1234
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__CIHIFJHG">
<p class="titleinexample">Example 5-41 %ROWTYPE Variable Represents Join Row</p>
<p>This example defines an explicit cursor whose query is a join and then declares a record variable that has a field for each column that the cursor selects.</p>
<div class="infobox-note" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__GUID-C0B244F8-2E16-4FEF-BEC3-31F95C4E18A5">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites82.html" target="_blank">%ROWTYPE Variable Represents Join Row</a></p>
</div>
<pre dir="ltr">DECLARE
  CURSOR c2 IS
    SELECT employee_id, email, employees.manager_id, location_id
    FROM employees, departments
    WHERE employees.department_id = departments.department_id;
  
  <span class="bold">join_rec c2%ROWTYPE;</span>  -- includes columns from two tables
  
BEGIN
  NULL;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<div class="props_rev_3"><a id="GUID-FE47FF68-8720-48EF-9091-88476E31C589"></a>
<h4 id="LNPLS-GUID-FE47FF68-8720-48EF-9091-88476E31C589" class="sect4">%ROWTYPE Attribute and Virtual Columns</h4>
<div>
<p>If you use the <code class="codeph">%ROWTYPE</code> attribute to define a record variable that represents a full row of a table that has a virtual column, then you cannot insert that record into the table. Instead, you must insert the individual record fields into the table, excluding the virtual column.</p>
<div class="example" id="GUID-FE47FF68-8720-48EF-9091-88476E31C589__BABBCHAI">
<p class="titleinexample">Example 5-42 Inserting %ROWTYPE Record into Table (Wrong)</p>
<p>This example creates a record variable that represents a full row of a table that has a virtual column, populates the record, and inserts the record into the table, causing ORA-54013.</p>
<pre dir="ltr">DROP TABLE plch_departure;
 
CREATE TABLE plch_departure (
  destination    VARCHAR2(100),
  departure_time DATE,
  delay          NUMBER(10),
  <span class="bold">expected       GENERATED ALWAYS AS (departure_time + delay/24/60/60)</span>
);
 
 
DECLARE
 <span class="bold">dep_rec plch_departure%ROWTYPE;</span>
BEGIN
  dep_rec.destination := &#39;X&#39;; 
  dep_rec.departure_time := SYSDATE;
  dep_rec.delay := 1500;
 
  <span class="bold">INSERT INTO plch_departure VALUES dep_rec;</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">DECLARE
*
ERROR at line 1:
<span class="bold">ORA-54013: INSERT operation disallowed on virtual columns</span>
ORA-06512: at line 8
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-FE47FF68-8720-48EF-9091-88476E31C589__BABGHFEI">
<p class="titleinexample">Example 5-43 Inserting %ROWTYPE Record into Table (Right)</p>
<p>This solves the problem in <a href="composites.htm#GUID-FE47FF68-8720-48EF-9091-88476E31C589__BABBCHAI">Example 5-42</a> by inserting the individual record fields into the table, excluding the virtual column.</p>
<pre dir="ltr">DECLARE
  dep_rec plch_departure%rowtype;
BEGIN
  dep_rec.destination := &#39;X&#39;;
  dep_rec.departure_time := SYSDATE;
  dep_rec.delay := 1500;
 
  <span class="bold">INSERT INTO plch_departure (destination, departure_time, delay)</span>
  <span class="bold">VALUES (dep_rec.destination, dep_rec.departure_time, dep_rec.delay);</span>
end;
/
</pre>
<p>Result:</p>
<pre dir="ltr">PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS447"></a><a id="LNPLS99854"></a>
<div class="props_rev_3"><a id="GUID-058B062C-C429-422B-AD64-B2CFF63075FC"></a>
<h4 id="LNPLS-GUID-058B062C-C429-422B-AD64-B2CFF63075FC" class="sect4">%ROWTYPE Attribute and Invisible Columns</h4>
<div>
<p>Suppose that you use the <code class="codeph">%ROWTYPE</code> attribute to define a record variable that represents a row of a table that has an invisible column, and then you make the invisible column visible.</p>
<p>If you define the record variable with a cursor, as in <span class="q">&#34;<a href="composites.htm#GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB">Declaring a Record Variable that Can Represent Partial Row</a>&#34;</span>, then making the invisible column visible does not change the structure of the record variable.</p>
<p>However, if you define the record variable as in <span class="q">&#34;<a href="composites.htm#GUID-9D20CCCC-E34B-473B-8499-4787D17C1980">Declaring a Record Variable that Always Represents Full Row</a>&#34;</span> and use a <code class="codeph">SELECT</code> <code class="codeph">*</code> <code class="codeph">INTO</code> statement to assign values to the record, then making the invisible column visible does change the structure of the record&mdash;see <a href="composites.htm#GUID-058B062C-C429-422B-AD64-B2CFF63075FC__BABJBIGE">Example 5-44</a>.</p>
<div class="infoboxnotealso" id="GUID-058B062C-C429-422B-AD64-B2CFF63075FC__GUID-43D186FB-DFB2-4369-AEFC-728C6F69FF10">
<p class="notep1">See Also:</p>
<p><a class="olink SQLRF55897" target="_blank" href="../SQLRF/statements_7002.htm#SQLRF55897"><span class="italic">Oracle Database SQL Language Reference</span></a> for general information about invisible columns</p>
</div>
<div class="example" id="GUID-058B062C-C429-422B-AD64-B2CFF63075FC__BABJBIGE">
<p class="titleinexample">Example 5-44 %ROWTYPE Affected by Making Invisible Column Visible</p>
<pre dir="ltr">CREATE <span class="bold">TABLE t</span> (a INT, b INT, <span class="bold">c INT INVISIBLE</span>);
INSERT INTO t (a, b, <span class="bold">c</span>) VALUES (1, 2, <span class="bold">3</span>);
COMMIT;

DECLARE
  <span class="bold">t_rec t%ROWTYPE;  -- t_rec has fields a and b, but not c</span>
BEGIN
  <span class="bold">SELECT * INTO t_rec FROM t</span> WHERE ROWNUM &lt; 2;  <span class="bold">-- t_rec(a)=1, t_rec(b)=2</span>
  DBMS_OUTPUT.PUT_LINE(&#39;c = &#39; || <span class="bold">t_rec.c</span>);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">  DBMS_OUTPUT.PUT_LINE(&#39;c = &#39; || t_rec.c);
                                       *
ERROR at line 5:
ORA-06550: line 5, column 40:
<span class="bold">PLS-00302: component &#39;C&#39; must be declared</span>
ORA-06550: line 5, column 3:
PL/SQL: Statement ignored
 
</pre>
<p>Make invisible column visible:</p>
<pre dir="ltr">ALTER TABLE t MODIFY (<span class="bold">c VISIBLE</span>);
 
</pre>
<p>Result:</p>
<pre dir="ltr">Table altered.
 
</pre>
<p>Repeat preceding anonymous block:</p>
<pre dir="ltr">DECLARE
  <span class="bold">t_rec t%ROWTYPE;  -- t_rec has fields a, b, and c</span>
BEGIN
  <span class="bold">SELECT * INTO t_rec</span> FROM t WHERE ROWNUM &lt; 2;  <span class="bold">-- t_rec(a)=1, t_rec(b)=2,</span>
                                                  <span class="bold">-- t_rec(c)=3</span>
  DBMS_OUTPUT.PUT_LINE(&#39;c = &#39; || <span class="bold">t_rec.c</span>);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">c = 3</span>
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="LNPLS448"></a><a id="LNPLS00510"></a>
<div class="props_rev_3"><a id="GUID-794AD0D6-2D97-4C4A-B7DA-6126025EF2A5"></a>
<h2 id="LNPLS-GUID-794AD0D6-2D97-4C4A-B7DA-6126025EF2A5" class="sect2">Assigning Values to Record Variables</h2>
<div>
<p>A <span class="italic">record variable</span> means either a record variable or a record component of a composite variable.</p>
<div class="section">
<p>To any record variable, you can assign a value to each field individually.</p>
<p>In some cases, you can assign the value of one record variable to another record variable.</p>
<p>If a record variable represents a full or partial row of a database table or view, you can assign the represented row to the record variable.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73">Assigning One Record Variable to Another</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-59D7C4DF-4CE0-4E82-81FA-CBE17282E1EF" title="The SQL statements INSERT, UPDATE, and DELETE have an optional RETURNING INTO clause that can return the affected row in a PL/SQL record variable.">Assigning Full or Partial Rows to Record Variables</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-6AB78084-231F-4BCA-A905-DB2069E4B885" title="Assigning the value NULL to a record variable assigns the value NULL to each of its fields.">Assigning NULL to a Record Variable</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS449"></a><a id="LNPLS450"></a><a id="LNPLS492"></a><a id="LNPLS99910"></a>
<div class="props_rev_3"><a id="GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73"></a>
<h3 id="LNPLS-GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73" class="sect3">Assigning One Record Variable to Another</h3>
<div>
<div class="section">
<p>You can assign the value of one record variable to another record variable only in these cases:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>The two variables have the same <code class="codeph">RECORD</code> type.</p>
</li>
<li>
<p>The target variable is declared with a <code class="codeph">RECORD</code> type, the source variable is declared with <code class="codeph">%ROWTYPE</code>, their fields match in number and order, and corresponding fields have the same data type.</p>
</li>
</ul>
<p>For record components of composite variables, the types of the composite variables need not match.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73__CIHDEIBG">
<p class="titleinexample">Example 5-45 Assigning Record to Another Record of Same RECORD Type</p>
<p>In this example, name1 and name2 have the same RECORD type, so you can assign the value of name1 to name2.</p>
<pre dir="ltr">DECLARE
  TYPE name_rec IS RECORD (
    first  employees.first_name%TYPE DEFAULT &#39;John&#39;,
    last   employees.last_name%TYPE DEFAULT &#39;Doe&#39;
  );
 
  <span class="bold">name1 name_rec;</span>
  <span class="bold">name2 name_rec;</span>
 
BEGIN
  name1.first := &#39;Jane&#39;; name1.last := &#39;Smith&#39;; 
  DBMS_OUTPUT.PUT_LINE(&#39;name1: &#39; || name1.first || &#39; &#39; || name1.last);
  <span class="bold">name2 := name1;</span>
  DBMS_OUTPUT.PUT_LINE(&#39;name2: &#39; || name2.first || &#39; &#39; || name2.last); 
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">name1: Jane Smith
name2: Jane Smith
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73__CIHDGDHE">
<p class="titleinexample">Example 5-46 Assigning %ROWTYPE Record to RECORD Type Record</p>
<p>In this example, the target variable is declared with a <code class="codeph">RECORD</code> type, the source variable is declared with <code class="codeph">%ROWTYPE</code>, their fields match in number and order, and corresponding fields have the same data type.</p>
<pre dir="ltr">DECLARE
  TYPE name_rec IS RECORD (
    first  <span class="bold">employees.first_name%TYPE</span> DEFAULT &#39;John&#39;,
    last   <span class="bold">employees.last_name%TYPE</span> DEFAULT &#39;Doe&#39;
  );
 
  CURSOR c IS
    SELECT <span class="bold">first_name</span>, <span class="bold">last_name</span>
    FROM <span class="bold">employees</span>;
 
  <span class="bold">target name_rec;</span>
  <span class="bold">source c%ROWTYPE;</span>
 
BEGIN
  source.first_name := &#39;Jane&#39;; source.last_name := &#39;Smith&#39;;
 
  DBMS_OUTPUT.PUT_LINE (
    &#39;source: &#39; || source.first_name || &#39; &#39; || source.last_name
  );
 
 <span class="bold">target := source;</span>
 
 DBMS_OUTPUT.PUT_LINE (
   &#39;target: &#39; || target.first || &#39; &#39; || target.last
 );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">source: Jane Smith
target: Jane Smith
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73__BEIDCCBE">
<p class="titleinexample">Example 5-47 Assigning Nested Record to Another Record of Same RECORD Type</p>
<p>This example assigns the value of one nested record to another nested record. The nested records have the same <code class="codeph">RECORD</code> type, but the records in which they are nested do not.</p>
<pre dir="ltr">DECLARE
  TYPE name_rec IS RECORD (
    first  employees.first_name%TYPE,
    last   employees.last_name%TYPE
  );
 
  TYPE <span class="bold">phone_rec</span> IS RECORD (
    name  <span class="bold">name_rec</span>,                    -- nested record
    phone employees.phone_number%TYPE
  );
 
  TYPE <span class="bold">email_rec</span> IS RECORD (
    name  <span class="bold">name_rec</span>,                    -- nested record
    email employees.email%TYPE
  );
 
  <span class="bold">phone_contact phone_rec;</span>
  <span class="bold">email_contact email_rec;</span>
 
BEGIN
  phone_contact.name.first := &#39;John&#39;;
  phone_contact.name.last := &#39;Smith&#39;;
  phone_contact.phone := &#39;1-650-555-1234&#39;;
 
  <span class="bold">email_contact.name := phone_contact.name;</span>
  email_contact.email := (
    email_contact.name.first || &#39;.&#39; ||
    email_contact.name.last  || &#39;@&#39; ||
    &#39;example.com&#39; 
  );
 
  DBMS_OUTPUT.PUT_LINE (email_contact.email);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">John.Smith@example.com
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS451"></a><a id="LNPLS99909"></a>
<div class="props_rev_3"><a id="GUID-59D7C4DF-4CE0-4E82-81FA-CBE17282E1EF"></a>
<h3 id="LNPLS-GUID-59D7C4DF-4CE0-4E82-81FA-CBE17282E1EF" class="sect3">Assigning Full or Partial Rows to Record Variables</h3>
<div>
<div class="section">
<p>If a record variable represents a full or partial row of a database table or view, you can assign the represented row to the record variable.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="composites.htm#GUID-785E5E7E-7FCD-4291-8F62-389814A261EC">Using SELECT INTO to Assign a Row to a Record Variable</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F">Using FETCH to Assign a Row to a Record Variable</a></p>
</li>
<li>
<p><a href="composites.htm#GUID-95EA1F91-8196-4F77-8EA3-36CAD9B43855" title="The SQL statements INSERT, UPDATE, and DELETE have an optional RETURNING INTO clause that can return the affected row in a PL/SQL record variable.">Using SQL Statements to Return Rows in PL/SQL Record Variables</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS495"></a><a id="LNPLS99906"></a>
<div class="props_rev_3"><a id="GUID-785E5E7E-7FCD-4291-8F62-389814A261EC"></a>
<h4 id="LNPLS-GUID-785E5E7E-7FCD-4291-8F62-389814A261EC" class="sect4">Using SELECT INTO to Assign a Row to a Record Variable</h4>
<div>
<div class="section">
<p>The syntax of a simple <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement is:</p>
<pre dir="ltr">SELECT <span class="italic">select_list</span> INTO <span class="italic">record_variable_name</span> FROM <span class="italic">table_or_view_name</span>;
</pre>
<p>For each column in <span class="italic"><code class="codeph">select_list</code></span>, the record variable must have a corresponding, type-compatible field. The columns in <span class="italic"><code class="codeph">select_list</code></span> must appear in the same order as the record fields.</p>
<div class="infoboxnotealso" id="GUID-785E5E7E-7FCD-4291-8F62-389814A261EC__GUID-B9EA5C16-A4FF-485D-920E-252A62E1CDE8">
<p class="notep1">See Also:</p>
<p><span class="q">&#34;<a href="selectinto_statement.htm#GUID-6E14E04D-4344-45F3-BE80-979DD26C7A90" title="The SELECT INTO statement retrieves values from one or more database tables (as the SQL SELECT statement does) and stores them in variables (which the SQL SELECT statement does not do).">SELECT INTO Statement</a>&#34;</span> for complete syntax</p>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-785E5E7E-7FCD-4291-8F62-389814A261EC__CIHBFCAE">
<p class="titleinexample">Example 5-48 SELECT INTO Assigns Values to Record Variable</p>
<p>In this example, the record variable <code class="codeph">rec1</code> represents a partial row of the <code class="codeph">employees</code> table&mdash;the columns <code class="codeph">last_name</code> and <code class="codeph">employee_id</code>. The <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement selects from <code class="codeph">employees</code> the row for which <code class="codeph">job_id</code> is <code class="codeph">&#39;AD_PRES&#39;</code> and assigns the values of the columns <code class="codeph">last_name</code> and <code class="codeph">employee_id</code> in that row to the corresponding fields of <code class="codeph">rec1</code>.</p>
<pre dir="ltr">DECLARE
  TYPE RecordTyp IS RECORD (
    last employees.last_name%TYPE,
    id   employees.employee_id%TYPE
  );
  rec1 RecordTyp;
BEGIN
  <span class="bold">SELECT last_name, employee_id INTO rec1</span>
  <span class="bold">FROM employees</span>
  <span class="bold">WHERE job_id = &#39;AD_PRES&#39;;</span>

  DBMS_OUTPUT.PUT_LINE (&#39;Employee #&#39; || rec1.id || &#39; = &#39; || rec1.last);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Employee #100 = King
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS490"></a><a id="LNPLS99905"></a>
<div class="props_rev_3"><a id="GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F"></a>
<h4 id="LNPLS-GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F" class="sect4">Using FETCH to Assign a Row to a Record Variable</h4>
<div>
<div class="section">
<p>The syntax of a simple <code class="codeph">FETCH</code> statement is:</p>
<pre dir="ltr">FETCH <span class="italic">cursor</span> INTO <span class="italic">record_variable_name</span>;
</pre>
<p>A cursor is associated with a query. For every column that the query selects, the record variable must have a corresponding, type-compatible field. The cursor must be either an explicit cursor or a strong cursor variable.</p>
<div class="infoboxnotealso" id="GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F__GUID-5EE013A6-0700-48CE-81CF-EF69997A0E48">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="fetch_statement.htm#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="The FETCH statement retrieves rows of data from the result set of a multiple-row query&mdash;one row at a time, several rows at a time, or all rows at once&mdash;and stores the data in variables, records, or collections.">FETCH Statement</a>&#34;</span> for complete syntax</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" title="A cursor is a pointer to a private SQL area that stores information about processing a specific SELECT or DML statement.">Cursors Overview</a>&#34;</span> for information about all cursors</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">Explicit Cursors</a>&#34;</span> for information about explicit cursors</p>
</li>
<li>
<p><span class="q">&#34;<a href="static.htm#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="To create a cursor variable, either declare a variable of the predefined type SYS_REFCURSOR or define a REF CURSOR type and then declare a variable of that type.After opening a cursor variable, you can fetch the rows of the query result set with the FETCH statement.You can assign to a PL/SQL cursor variable the value of another PL/SQL cursor variable or host cursor variable.The query associated with a cursor variable can reference any variable in its scope.You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.You can use a cursor variable as a host variable, which makes it useful for passing query results between PL/SQL stored subprograms and their clients.">Cursor Variables</a>&#34;</span> for information about cursor variables</p>
</li>
</ul>
</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F__BEIDDADJ">
<p class="titleinexample">Example 5-49 FETCH Assigns Values to Record that Function Returns</p>
<p>In this example, each variable of <code class="codeph">RECORD</code> type <code class="codeph">EmpRecTyp</code> represents a partial row of the <code class="codeph">employees</code> table&mdash;the columns <code class="codeph">employee_id</code> and <code class="codeph">salary</code>. Both the cursor and the function return a value of type <code class="codeph">EmpRecTyp</code>. In the function, a <code class="codeph">FETCH</code> statement assigns the values of the columns <code class="codeph">employee_id</code> and <code class="codeph">salary</code> to the corresponding fields of a local variable of type <code class="codeph">EmpRecTyp</code>.</p>
<pre dir="ltr">DECLARE
  TYPE EmpRecTyp IS RECORD (
    emp_id  employees.employee_id%TYPE,
    salary  employees.salary%TYPE
  );
 
  CURSOR desc_salary RETURN EmpRecTyp IS
    SELECT employee_id, salary
    FROM employees
    ORDER BY salary DESC;
 
  highest_paid_emp       EmpRecTyp;
  next_highest_paid_emp  EmpRecTyp;
 
  FUNCTION nth_highest_salary (n INTEGER) RETURN EmpRecTyp IS
    emp_rec  EmpRecTyp;
  BEGIN
    OPEN desc_salary;
    FOR i IN 1..n LOOP
      <span class="bold">FETCH desc_salary INTO emp_rec;</span>
    END LOOP;
    CLOSE desc_salary;
    RETURN emp_rec;
  END nth_highest_salary;
 
BEGIN
  highest_paid_emp := nth_highest_salary(1);
  next_highest_paid_emp := nth_highest_salary(2);
 
  DBMS_OUTPUT.PUT_LINE(
    &#39;Highest Paid: #&#39; ||
    highest_paid_emp.emp_id || &#39;, $&#39; ||
    highest_paid_emp.salary 
  );
  DBMS_OUTPUT.PUT_LINE(
    &#39;Next Highest Paid: #&#39; ||
    next_highest_paid_emp.emp_id || &#39;, $&#39; ||
    next_highest_paid_emp.salary
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Highest Paid: #100, $24000
Next Highest Paid: #101, $17000
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS501"></a><a id="LNPLS99953"></a>
<div class="props_rev_3"><a id="GUID-95EA1F91-8196-4F77-8EA3-36CAD9B43855"></a>
<h4 id="LNPLS-GUID-95EA1F91-8196-4F77-8EA3-36CAD9B43855" class="sect4">Using SQL Statements to Return Rows in PL/SQL Record Variables</h4>
<div>
<p>The SQL statements <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">DELETE</code> have an optional <code class="codeph">RETURNING</code> <code class="codeph">INTO</code> clause that can return the affected row in a PL/SQL record variable.</p>
<div class="section">
<p>For information about this clause, see <span class="q">&#34;<a href="returninginto_clause.htm#GUID-38F735B9-1100-45AF-AE71-18FB74A899BE" title="The RETURNING INTO clause specifies the variables in which to store the values returned by the statement to which the clause belongs.">RETURNING INTO Clause</a>&#34;</span>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-95EA1F91-8196-4F77-8EA3-36CAD9B43855__BABHDGIG">
<p class="titleinexample">Example 5-50 UPDATE Statement Assigns Values to Record Variable</p>
<p>In this example, the <code class="codeph">UPDATE</code> statement updates the salary of an employee and returns the name and new salary of the employee in a record variable.</p>
<pre dir="ltr">DECLARE
  TYPE EmpRec IS RECORD (
    last_name  employees.last_name%TYPE,
    salary     employees.salary%TYPE
  );
  <span class="bold">emp_info    EmpRec;</span>
  old_salary  employees.salary%TYPE;
BEGIN
  SELECT salary INTO old_salary
   FROM employees
   WHERE employee_id = 100;
 
  <span class="bold">UPDATE employees</span>
    <span class="bold">SET salary = salary * 1.1</span>
    <span class="bold">WHERE employee_id = 100</span>
    <span class="bold">RETURNING last_name, salary INTO emp_info;</span>
 
  DBMS_OUTPUT.PUT_LINE (
    &#39;Salary of &#39; || emp_info.last_name || &#39; raised from &#39; ||
    old_salary || &#39; to &#39; || emp_info.salary
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Salary of King raised from 24000 to 26400
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS1530"></a><a id="LNPLS1414"></a>
<div class="props_rev_3"><a id="GUID-6AB78084-231F-4BCA-A905-DB2069E4B885"></a>
<h3 id="LNPLS-GUID-6AB78084-231F-4BCA-A905-DB2069E4B885" class="sect3">Assigning NULL to a Record Variable</h3>
<div>
<p>Assigning the value <code class="codeph">NULL</code> to a record variable assigns the value <code class="codeph">NULL</code> to each of its fields.</p>
<div class="section">
<p>This assignment is recursive; that is, if a field is a record, then its fields are also assigned the value <code class="codeph">NULL</code>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-6AB78084-231F-4BCA-A905-DB2069E4B885__BABIFHFJ">
<p class="titleinexample">Example 5-51 Assigning NULL to Record Variable</p>
<p>This example prints the fields of a record variable (one of which is a record) before and after assigning <code class="codeph">NULL</code> to it.</p>
<pre dir="ltr">DECLARE
  TYPE age_rec IS RECORD (
    years  INTEGER DEFAULT 35,
    months INTEGER DEFAULT 6
  );
 
  TYPE name_rec IS RECORD (
    first  employees.first_name%TYPE DEFAULT &#39;John&#39;,
    last   employees.last_name%TYPE DEFAULT &#39;Doe&#39;,
    age    age_rec
  );
 
  name name_rec;
 
  PROCEDURE print_name AS
  BEGIN
    DBMS_OUTPUT.PUT(NVL(name.first, &#39;NULL&#39;) || &#39; &#39;); 
    DBMS_OUTPUT.PUT(NVL(name.last,  &#39;NULL&#39;) || &#39;, &#39;);
    DBMS_OUTPUT.PUT(NVL(TO_CHAR(name.age.years), &#39;NULL&#39;) || &#39; yrs &#39;);
    DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(name.age.months), &#39;NULL&#39;) || &#39; mos&#39;);
  END;
 
BEGIN
  print_name;
  <span class="bold">name := NULL;</span>
  print_name;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">John Doe, 35 yrs 6 mos
NULL NULL, NULL yrs NULL mos
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS496"></a>
<div class="props_rev_3"><a id="GUID-DFDE40BD-4B61-4C8A-B9CE-3FE01E21F658"></a>
<h2 id="LNPLS-GUID-DFDE40BD-4B61-4C8A-B9CE-3FE01E21F658" class="sect2">Record Comparisons</h2>
<div>
<p>Records cannot be tested natively for nullity, equality, or inequality.</p>
<p>These <code class="codeph">BOOLEAN</code> expressions are illegal:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">My_Record IS NULL</code></p>
</li>
<li>
<p><code class="codeph">My_Record_1 = My_Record_2</code></p>
</li>
<li>
<p><code class="codeph">My_Record_1 &gt; My_Record_2</code></p>
</li>
</ul>
<p>You must write your own functions to implement such tests. For information about writing functions, see <a href="subprograms.htm#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B">PL/SQL Subprograms</a>.</p>
</div>
</div>
<a id="LNPLS452"></a><a id="LNPLS497"></a>
<div class="props_rev_3"><a id="GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1"></a>
<h2 id="LNPLS-GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1" class="sect2">Inserting Records into Tables</h2>
<div>
<p>The PL/SQL extension to the SQL <code class="codeph">INSERT</code> statement lets you insert a record into a table.</p>
<div class="section">
<p>The record must represent a row of the table. For more information, see <span class="q">&#34;<a href="insert_statement.htm#GUID-D81224C4-06DE-4635-A850-41D29D4A8E1B" title="The PL/SQL extension to the SQL INSERT statement lets you specify a record name in the values_clause of the single_table_insert instead of specifying a column list in the insert_into_clause">INSERT Statement Extension</a>&#34;</span>. For restrictions on inserting records into tables, see <span class="q">&#34;<a href="composites.htm#GUID-EC8E43E9-8356-4256-857A-D8109F2CF324">Restrictions on Record Inserts and Updates</a>&#34;</span>.</p>
<p>To efficiently insert a collection of records into a table, put the <code class="codeph">INSERT</code> statement inside a <code class="codeph">FORALL</code> statement. For information about the <code class="codeph">FORALL</code> statement, see <span class="q">&#34;<a href="tuning.htm#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="The FORALL statement, a feature of bulk SQL, sends DML statements from PL/SQL to SQL in batches rather than one at a time.">FORALL Statement</a>&#34;</span>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1__CHDBEBEB">
<p class="titleinexample">Example 5-52 Initializing Table by Inserting Record of Default Values</p>
<p>This example creates the table <code class="codeph">schedule</code> and initializes it by putting default values in a record and inserting the record into the table for each week. (The <code class="codeph">COLUMN</code> formatting commands are from SQL*Plus.)</p>
<pre dir="ltr">DROP TABLE schedule;
CREATE TABLE schedule (
  week  NUMBER,
  Mon   VARCHAR2(10),
  Tue   VARCHAR2(10),
  Wed   VARCHAR2(10),
  Thu   VARCHAR2(10),
  Fri   VARCHAR2(10),
  Sat   VARCHAR2(10),
  Sun   VARCHAR2(10)
);
 
DECLARE
  default_week  schedule%ROWTYPE;
  i             NUMBER;
BEGIN
  default_week.Mon := &#39;0800-1700&#39;;
  default_week.Tue := &#39;0800-1700&#39;;
  default_week.Wed := &#39;0800-1700&#39;;
  default_week.Thu := &#39;0800-1700&#39;;
  default_week.Fri := &#39;0800-1700&#39;;
  default_week.Sat := &#39;Day Off&#39;;
  default_week.Sun := &#39;Day Off&#39;;
 
  FOR i IN 1..6 LOOP
    default_week.week    := i;
    
    <span class="bold">INSERT INTO schedule VALUES default_week;</span>
  END LOOP;
END;
/
 
COLUMN week FORMAT 99
COLUMN Mon  FORMAT A9
COLUMN Tue  FORMAT A9
COLUMN Wed  FORMAT A9
COLUMN Thu  FORMAT A9
COLUMN Fri  FORMAT A9
COLUMN Sat  FORMAT A9
COLUMN Sun  FORMAT A9
 
SELECT * FROM schedule;
</pre>
<p>Result:</p>
<pre dir="ltr">WEEK MON       TUE       WED       THU       FRI       SAT       SUN
---- --------- --------- --------- --------- --------- --------- ---------
   1 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   2 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   3 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   4 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   5 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   6 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS500"></a><a id="LNPLS499"></a>
<div class="props_rev_3"><a id="GUID-11D63245-591D-4CBF-BFBA-8F3C0AE0E968"></a>
<h2 id="LNPLS-GUID-11D63245-591D-4CBF-BFBA-8F3C0AE0E968" class="sect2">Updating Rows with Records</h2>
<div>
<p>The PL/SQL extension to the SQL <code class="codeph">UPDATE</code> statement lets you update one or more table rows with a record.</p>
<div class="section">
<p>The record must represent a row of the table. For more information, see <span class="q">&#34;<a href="update_statement.htm#GUID-8FA29ACC-5E0F-4BE1-BC33-2B882C87E36D">UPDATE Statement Extensions</a>&#34;</span>.</p>
<p>For restrictions on updating table rows with a record, see <span class="q">&#34;<a href="composites.htm#GUID-EC8E43E9-8356-4256-857A-D8109F2CF324">Restrictions on Record Inserts and Updates</a>&#34;</span>.</p>
<p>To efficiently update a set of rows with a collection of records, put the <code class="codeph">UPDATE</code> statement inside a <code class="codeph">FORALL</code> statement. For information about the <code class="codeph">FORALL</code> statement, see <span class="q">&#34;<a href="tuning.htm#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="The FORALL statement, a feature of bulk SQL, sends DML statements from PL/SQL to SQL in batches rather than one at a time.">FORALL Statement</a>&#34;</span>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-11D63245-591D-4CBF-BFBA-8F3C0AE0E968__BABDGCDI">
<p class="titleinexample">Example 5-53 Updating Rows with Record</p>
<p>This example updates the first three weeks of the table <code class="codeph">schedule</code> (defined in <a href="composites.htm#GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1__CHDBEBEB">Example 5-52</a>) by putting the new values in a record and updating the first three rows of the table with that record.</p>
<pre dir="ltr">DECLARE
  default_week  schedule%ROWTYPE;
BEGIN
  default_week.Mon := &#39;Day Off&#39;;
  default_week.Tue := &#39;0900-1800&#39;;
  default_week.Wed := &#39;0900-1800&#39;;
  default_week.Thu := &#39;0900-1800&#39;;
  default_week.Fri := &#39;0900-1800&#39;;
  default_week.Sat := &#39;0900-1800&#39;;
  default_week.Sun := &#39;Day Off&#39;;
 
  FOR i IN 1..3 LOOP
    default_week.week    := i;
  
    UPDATE schedule
    SET ROW = default_week
    WHERE week = i;
  END LOOP;
END;
/
 
SELECT * FROM schedule;
</pre>
<p>Result:</p>
<pre dir="ltr">WEEK MON       TUE       WED       THU       FRI       SAT       SUN
---- --------- --------- --------- --------- --------- --------- ---------
   1 Day Off   0900-1800 0900-1800 0900-1800 0900-1800 0900-1800 Day Off
   2 Day Off   0900-1800 0900-1800 0900-1800 0900-1800 0900-1800 Day Off
   3 Day Off   0900-1800 0900-1800 0900-1800 0900-1800 0900-1800 Day Off
   4 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   5 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   6 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS502"></a>
<div class="props_rev_3"><a id="GUID-EC8E43E9-8356-4256-857A-D8109F2CF324"></a>
<h2 id="LNPLS-GUID-EC8E43E9-8356-4256-857A-D8109F2CF324" class="sect2">Restrictions on Record Inserts and Updates</h2>
<div>
<p>These restrictions apply to record inserts and updates:</p>
<ul style="list-style-type: disc;">
<li>
<p>Record variables are allowed only in these places:</p>
<ul style="list-style-type: disc;">
<li>
<p>On the right side of the <code class="codeph">SET</code> clause in an <code class="codeph">UPDATE</code> statement</p>
</li>
<li>
<p>In the <code class="codeph">VALUES</code> clause of an <code class="codeph">INSERT</code> statement</p>
</li>
<li>
<p>In the <code class="codeph">INTO</code> subclause of a <code class="codeph">RETURNING</code> clause</p>
</li>
</ul>
<p>Record variables are not allowed in a <code class="codeph">SELECT</code> list, <code class="codeph">WHERE</code> clause, <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, or <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause.</p>
</li>
<li>
<p>The keyword <code class="codeph">ROW</code> is allowed only on the left side of a <code class="codeph">SET</code> clause. Also, you cannot use <code class="codeph">ROW</code> with a subquery.</p>
</li>
<li>
<p>In an <code class="codeph">UPDATE</code> statement, only one <code class="codeph">SET</code> clause is allowed if <code class="codeph">ROW</code> is used.</p>
</li>
<li>
<p>If the <code class="codeph">VALUES</code> clause of an <code class="codeph">INSERT</code> statement contains a record variable, no other variable or value is allowed in the clause.</p>
</li>
<li>
<p>If the <code class="codeph">INTO</code> subclause of a <code class="codeph">RETURNING</code> clause contains a record variable, no other variable or value is allowed in the subclause.</p>
</li>
<li>
<p>These are not supported:</p>
<ul style="list-style-type: disc;">
<li>
<p>Nested <code class="codeph">RECORD</code> types</p>
</li>
<li>
<p>Functions that return a <code class="codeph">RECORD</code> type</p>
</li>
<li>
<p>Record inserts and updates using the <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement.</p>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment869">
<tr>
<td class="cellalignment912">
<table class="cellalignment874">
<tr>
<td class="cellalignment873"><a href="controlstatements.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment873"><a href="static.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment914">
<table class="cellalignment872">
<tr>
<td class="cellalignment873"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment873"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment873"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment873"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment873"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment873"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>