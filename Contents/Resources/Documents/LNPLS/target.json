{ "docs": [
{ "a": "LNPLSidm139712207942368", "t": "Oracle Database PL/SQL Language Reference", "h": "toc.htm", 
 "c": [{ "a": "LNPLSidm139712207550464", "t": "Preface", "h": "preface.htm#LNPLS100" },
{ "a": "LNPLSidm139712243693936", "t": "Changes in This Release for Oracle Database PL/SQL Language Reference", "h": "release_changes.htm#LNPLS105" },
{ "a": "LNPLSidm139712178422768", "t": "Overview of PL/SQL", "h": "overview.htm#LNPLS001", 
 "c": [{ "a": "LNPLSidm139712255881264", "t": "Advantages of PL/SQL", "h": "overview.htm#LNPLS00101", 
 "c": [ { "t": "Tight Integration with SQL", "h": "overview.htm#LNPLS128" },
 { "t": "High Performance", "h": "overview.htm#LNPLS129" },
 { "t": "High Productivity", "h": "overview.htm#LNPLS131" },
 { "t": "Portability", "h": "overview.htm#LNPLS132" },
 { "t": "Scalability", "h": "overview.htm#LNPLS133" },
 { "t": "Manageability", "h": "overview.htm#LNPLS134" },
 { "t": "Support for Object-Oriented Programming", "h": "overview.htm#LNPLS137" },
 { }
 ]
 },
{ "a": "LNPLSidm139712175742016", "t": "Main Features of PL/SQL", "h": "overview.htm#LNPLS00102", 
 "c": [ { "t": "Error Handling", "h": "overview.htm#LNPLS143" },
 { "t": "Blocks", "h": "overview.htm#LNPLS141" },
 { "t": "Variables and Constants", "h": "overview.htm#LNPLS145" },
 { "t": "Subprograms", "h": "overview.htm#LNPLS174" },
 { "t": "Packages", "h": "overview.htm#LNPLS181" },
 { "t": "Triggers", "h": "overview.htm#LNPLS179" },
 { "t": "Input and Output", "h": "overview.htm#LNPLS144" },
 { "t": "Data Abstraction", "h": "overview.htm#LNPLS154" },
 { "t": "Control Statements", "h": "overview.htm#LNPLS165" },
 { "t": "Conditional Compilation", "h": "overview.htm#LNPLS184" },
 { "t": "Processing a Query Result Set One Row at a Time", "h": "overview.htm#LNPLS185" },
 { }
 ]
 },
{ "a": "LNPLSidm139712172207920", "t": "Architecture of PL/SQL", "h": "overview.htm#LNPLS00103", 
 "c": [ { "t": "PL/SQL Engine", "h": "overview.htm#LNPLS00104" },
 { "t": "PL/SQL Units and Compilation Parameters", "h": "overview.htm#LNPLS0121" },
 { }
 ]
 },
 { }
 ]
 },
{ "a": "LNPLSidm139712211716976", "t": "PL/SQL Language Fundamentals", "h": "fundamentals.htm#LNPLS002", 
 "c": [{ "a": "LNPLSidm139712247780128", "t": "Character Sets", "h": "fundamentals.htm#LNPLS00201", 
 "c": [ { "t": "Database Character Set", "h": "fundamentals.htm#LNPLS99920" },
 { "t": "National Character Set", "h": "fundamentals.htm#LNPLS99919" },
 { }
 ]
 },
{ "a": "LNPLSidm139712207805216", "t": "Lexical Units", "h": "fundamentals.htm#LNPLS147", 
 "c": [ { "t": "Delimiters", "h": "fundamentals.htm#LNPLS189" },
 { "t": "Identifiers", "h": "fundamentals.htm#LNPLS99973" },
 { "t": "Literals", "h": "fundamentals.htm#LNPLS194" },
 { "t": "Pragmas", "h": "fundamentals.htm#LNPLS99954" },
 { "t": "Comments", "h": "fundamentals.htm#LNPLS203" },
 { "t": "Whitespace Characters Between Lexical Units", "h": "fundamentals.htm#LNPLS168" },
 { }
 ]
 },
{ "a": "LNPLSidm139712175890112", "t": "Declarations", "h": "fundamentals.htm#LNPLS00202", 
 "c": [ { "t": "NOT NULL Constraint", "h": "fundamentals.htm#LNPLS176" },
 { "t": "Declaring Variables", "h": "fundamentals.htm#LNPLS208" },
 { "t": "Declaring Constants", "h": "fundamentals.htm#LNPLS210" },
 { "t": "Initial Values of Variables and Constants", "h": "fundamentals.htm#LNPLS173" },
 { "t": "Declaring Items using the %TYPE Attribute", "h": "fundamentals.htm#LNPLS99970" },
 { }
 ]
 },
 { "t": "References to Identifiers", "h": "fundamentals.htm#LNPLS183" },
 { "t": "Scope and Visibility of Identifiers", "h": "fundamentals.htm#LNPLS99945" },
{ "a": "LNPLSidm139712170321760", "t": "Assigning Values to Variables", "h": "fundamentals.htm#LNPLS00205", 
 "c": [ { "t": "Assigning Values to Variables with the Assignment Statement", "h": "fundamentals.htm#LNPLS201" },
 { "t": "Assigning Values to Variables with the SELECT INTO Statement", "h": "fundamentals.htm#LNPLS207" },
 { "t": "Assigning Values to Variables as Parameters of a Subprogram", "h": "fundamentals.htm#LNPLS209" },
 { "t": "Assigning Values to BOOLEAN Variables", "h": "fundamentals.htm#LNPLS242" },
 { }
 ]
 },
{ "a": "LNPLSidm139712242726240", "t": "Expressions", "h": "fundamentals.htm#LNPLS00206", 
 "c": [ { "t": "Concatenation Operator", "h": "fundamentals.htm#LNPLS246" },
 { "t": "Operator Precedence", "h": "fundamentals.htm#LNPLS248" },
 { "t": "Logical Operators", "h": "fundamentals.htm#LNPLS251" },
 { "t": "Short-Circuit Evaluation", "h": "fundamentals.htm#LNPLS258" },
 { "t": "Comparison Operators", "h": "fundamentals.htm#LNPLS260" },
 { "t": "BOOLEAN Expressions", "h": "fundamentals.htm#LNPLS272" },
 { "t": "CASE Expressions", "h": "fundamentals.htm#LNPLS278" },
 { "t": "SQL Functions in PL/SQL Expressions", "h": "fundamentals.htm#LNPLS00212" },
 { }
 ]
 },
 { "t": "Error-Reporting Functions", "h": "fundamentals.htm#LNPLS00299" },
{ "a": "LNPLSidm139712170522336", "t": "Conditional Compilation", "h": "fundamentals.htm#LNPLS00210", 
 "c": [ { "t": "How Conditional Compilation Works", "h": "fundamentals.htm#LNPLS294" },
 { "t": "Conditional Compilation Examples", "h": "fundamentals.htm#LNPLS308" },
 { "t": "Retrieving and Printing Post-Processed Source Text", "h": "fundamentals.htm#LNPLS280" },
 { "t": "Conditional Compilation Directive Restrictions", "h": "fundamentals.htm#LNPLS313" },
 { }
 ]
 },
 { }
 ]
 },
{ "a": "LNPLSidm139712255767024", "t": "PL/SQL Data Types", "h": "datatypes.htm#LNPLS003", 
 "c": [{ "a": "LNPLSidm139712246580656", "t": "SQL Data Types", "h": "datatypes.htm#LNPLS286", 
 "c": [ { "t": "Different Maximum Sizes", "h": "datatypes.htm#LNPLS99943" },
 { "t": "Additional PL/SQL Constants for BINARY_FLOAT and BINARY_DOUBLE", "h": "datatypes.htm#LNPLS326" },
 { "t": "Additional PL/SQL Subtypes of BINARY_FLOAT and BINARY_DOUBLE", "h": "datatypes.htm#LNPLS99942" },
 { "t": "CHAR and VARCHAR2 Variables", "h": "datatypes.htm#LNPLS332" },
 { "t": "LONG and LONG RAW Variables", "h": "datatypes.htm#LNPLS346" },
 { "t": "ROWID and UROWID Variables", "h": "datatypes.htm#LNPLS347" },
 { }
 ]
 },
 { "t": "BOOLEAN Data Type", "h": "datatypes.htm#LNPLS348" },
{ "a": "LNPLSidm139712175627552", "t": "PLS_INTEGER and BINARY_INTEGER Data Types", "h": "datatypes.htm#LNPLS319", 
 "c": [ { "t": "Preventing PLS_INTEGER Overflow", "h": "datatypes.htm#LNPLS99938" },
 { "t": "Predefined PLS_INTEGER Subtypes", "h": "datatypes.htm#LNPLS99937" },
 { "t": "SIMPLE_INTEGER Subtype of PLS_INTEGER", "h": "datatypes.htm#LNPLS00305" },
 { }
 ]
 },
{ "a": "LNPLSidm139712174153712", "t": "User-Defined PL/SQL Subtypes", "h": "datatypes.htm#LNPLS99935", 
 "c": [ { "t": "Unconstrained Subtypes", "h": "datatypes.htm#LNPLS99934" },
 { "t": "Constrained Subtypes", "h": "datatypes.htm#LNPLS99933" },
 { "t": "Subtypes with Base Types in Same Data Type Family", "h": "datatypes.htm#LNPLS99932" },
 { }
 ]
 },
 { }
 ]
 },
{ "a": "LNPLSidm139712243040912", "t": "PL/SQL Control Statements", "h": "controlstatements.htm#LNPLS004", 
 "c": [{ "a": "LNPLSidm139712244271872", "t": "Conditional Selection Statements", "h": "controlstatements.htm#LNPLS00402", 
 "c": [ { "t": "IF THEN Statement", "h": "controlstatements.htm#LNPLS386" },
 { "t": "IF THEN ELSE Statement", "h": "controlstatements.htm#LNPLS388" },
 { "t": "IF THEN ELSIF Statement", "h": "controlstatements.htm#LNPLS391" },
 { "t": "Simple CASE Statement", "h": "controlstatements.htm#LNPLS394" },
 { "t": "Searched CASE Statement", "h": "controlstatements.htm#LNPLS99972" },
 { }
 ]
 },
{ "a": "LNPLSidm139712256327664", "t": "LOOP Statements", "h": "controlstatements.htm#LNPLS00403", 
 "c": [ { "t": "Basic LOOP Statement", "h": "controlstatements.htm#LNPLS399" },
 { "t": "EXIT Statement", "h": "controlstatements.htm#LNPLS400" },
 { "t": "EXIT WHEN Statement", "h": "controlstatements.htm#LNPLS402" },
 { "t": "CONTINUE Statement", "h": "controlstatements.htm#LNPLS404" },
 { "t": "CONTINUE WHEN Statement", "h": "controlstatements.htm#LNPLS406" },
 { "t": "FOR LOOP Statement", "h": "controlstatements.htm#LNPLS411" },
 { "t": "WHILE LOOP Statement", "h": "controlstatements.htm#LNPLS410" },
 { }
 ]
 },
{ "a": "LNPLSidm139712178866160", "t": "Sequential Control Statements", "h": "controlstatements.htm#LNPLS00404", 
 "c": [ { "t": "GOTO Statement", "h": "controlstatements.htm#LNPLS428" },
 { "t": "NULL Statement", "h": "controlstatements.htm#LNPLS435" },
 { }
 ]
 },
 { }
 ]
 },
{ "a": "LNPLSidm139712257304896", "t": "PL/SQL Collections and Records", "h": "composites.htm#LNPLS005", 
 "c": [ { "t": "Collection Types", "h": "composites.htm#LNPLS00501" },
{ "a": "LNPLSidm139712171630800", "t": "Associative Arrays", "h": "composites.htm#LNPLS99969", 
 "c": [ { "t": "Declaring Associative Array Constants", "h": "composites.htm#LNPLS99857" },
 { "t": "NLS Parameter Values Affect Associative Arrays Indexed by String", "h": "composites.htm#LNPLS99931" },
 { "t": "Appropriate Uses for Associative Arrays", "h": "composites.htm#LNPLS99930" },
 { }
 ]
 },
{ "a": "LNPLSidm139712168181488", "t": "Varrays (Variable-Size Arrays)", "h": "composites.htm#LNPLS443", 
 "c": [ { "t": "Appropriate Uses for Varrays", "h": "composites.htm#LNPLS99929" },
 { }
 ]
 },
{ "a": "LNPLSidm139712255680592", "t": "Nested Tables", "h": "composites.htm#LNPLS99981", 
 "c": [ { "t": "Important Differences Between Nested Tables and Arrays", "h": "composites.htm#LNPLS99928" },
 { "t": "Appropriate Uses for Nested Tables", "h": "composites.htm#LNPLS99927" },
 { }
 ]
 },
 { "t": "Collection Constructors", "h": "composites.htm#LNPLS00504" },
{ "a": "LNPLSidm139712244655280", "t": "Assigning Values to Collection Variables", "h": "composites.htm#LNPLS00505", 
 "c": [ { "t": "Data Type Compatibility", "h": "composites.htm#LNPLS99918" },
 { "t": "Assigning Null Values to Varray or Nested Table Variables", "h": "composites.htm#LNPLS99917" },
 { "t": "Assigning Set Operation Results to Nested Table Variables", "h": "composites.htm#LNPLS99916" },
 { }
 ]
 },
 { "t": "Multidimensional Collections", "h": "composites.htm#LNPLS00507" },
{ "a": "LNPLSidm139712243561040", "t": "Collection Comparisons", "h": "composites.htm#LNPLS00506", 
 "c": [ { "t": "Comparing Varray and Nested Table Variables to NULL", "h": "composites.htm#LNPLS99915" },
 { "t": "Comparing Nested Tables for Equality and Inequality", "h": "composites.htm#LNPLS99914" },
 { "t": "Comparing Nested Tables with SQL Multiset Conditions", "h": "composites.htm#LNPLS99913" },
 { }
 ]
 },
{ "a": "LNPLSidm139712242955120", "t": "Collection Methods", "h": "composites.htm#LNPLS00508", 
 "c": [ { "t": "DELETE Collection Method", "h": "composites.htm#LNPLS99961" },
 { "t": "TRIM Collection Method", "h": "composites.htm#LNPLS99962" },
 { "t": "EXTEND Collection Method", "h": "composites.htm#LNPLS99963" },
 { "t": "EXISTS Collection Method", "h": "composites.htm#LNPLS99968" },
 { "t": "FIRST and LAST Collection Methods", "h": "composites.htm#LNPLS99965" },
 { "t": "COUNT Collection Method", "h": "composites.htm#LNPLS99967" },
 { "t": "LIMIT Collection Method", "h": "composites.htm#LNPLS99966" },
 { "t": "PRIOR and NEXT Collection Methods", "h": "composites.htm#LNPLS99964" },
 { }
 ]
 },
 { "t": "Collection Types Defined in Package Specifications", "h": "composites.htm#LNPLS00511" },
{ "a": "LNPLSidm139712258433264", "t": "Record Variables", "h": "composites.htm#LNPLS00509", 
 "c": [ { "t": "Initial Values of Record Variables", "h": "composites.htm#LNPLS419" },
 { "t": "Declaring Record Constants", "h": "composites.htm#LNPLS99856" },
 { "t": "RECORD Types", "h": "composites.htm#LNPLS99971" },
 { "t": "Declaring Items using the %ROWTYPE Attribute", "h": "composites.htm#LNPLS99912" },
 { }
 ]
 },
{ "a": "LNPLSidm139712247089200", "t": "Assigning Values to Record Variables", "h": "composites.htm#LNPLS00510", 
 "c": [ { "t": "Assigning One Record Variable to Another", "h": "composites.htm#LNPLS99910" },
 { "t": "Assigning Full or Partial Rows to Record Variables", "h": "composites.htm#LNPLS99909" },
 { "t": "Assigning NULL to a Record Variable", "h": "composites.htm#LNPLS1414" },
 { }
 ]
 },
 { "t": "Record Comparisons", "h": "composites.htm#LNPLS496" },
 { "t": "Inserting Records into Tables", "h": "composites.htm#LNPLS497" },
 { "t": "Updating Rows with Records", "h": "composites.htm#LNPLS499" },
 { "t": "Restrictions on Record Inserts and Updates", "h": "composites.htm#LNPLS502" },
 { }
 ]
 },
{ "a": "LNPLSidm139712257223008", "t": "PL/SQL Static SQL", "h": "static.htm#LNPLS006", 
 "c": [{ "a": "LNPLSidm139712258833136", "t": "Description of Static SQL", "h": "static.htm#LNPLS00601", 
 "c": [ { "t": "Statements", "h": "static.htm#LNPLS99878" },
 { "t": "Pseudocolumns", "h": "static.htm#LNPLS00611" },
 { }
 ]
 },
{ "a": "LNPLSidm139712244750080", "t": "Cursors Overview", "h": "static.htm#LNPLS00602", 
 "c": [ { "t": "Implicit Cursors", "h": "static.htm#LNPLS99957" },
 { "t": "Explicit Cursors", "h": "static.htm#LNPLS99956" },
 { }
 ]
 },
{ "a": "LNPLSidm139712242872592", "t": "Processing Query Result Sets", "h": "static.htm#LNPLS00603", 
 "c": [ { "t": "Processing Query Result Sets With SELECT INTO Statements", "h": "static.htm#LNPLS551" },
 { "t": "Processing Query Result Sets With Cursor FOR LOOP Statements", "h": "static.htm#LNPLS553" },
 { "t": "Processing Query Result Sets With Explicit Cursors, OPEN, FETCH, and CLOSE", "h": "static.htm#LNPLS554" },
 { "t": "Processing Query Result Sets with Subqueries", "h": "static.htm#LNPLS00604" },
 { }
 ]
 },
{ "a": "LNPLSidm139712243682512", "t": "Cursor Variables", "h": "static.htm#LNPLS00605", 
 "c": [ { "t": "Creating Cursor Variables", "h": "static.htm#LNPLS568" },
 { "t": "Opening and Closing Cursor Variables", "h": "static.htm#LNPLS575" },
 { "t": "Fetching Data with Cursor Variables", "h": "static.htm#LNPLS581" },
 { "t": "Assigning Values to Cursor Variables", "h": "static.htm#LNPLS485" },
 { "t": "Variables in Cursor Variable Queries", "h": "static.htm#LNPLS487" },
 { "t": "Querying a Collection", "h": "static.htm#LNPLS590" },
 { "t": "Cursor Variable Attributes", "h": "static.htm#LNPLS494" },
 { "t": "Cursor Variables as Subprogram Parameters", "h": "static.htm#LNPLS572" },
 { "t": "Cursor Variables as Host Variables", "h": "static.htm#LNPLS580" },
 { }
 ]
 },
 { "t": "CURSOR Expressions", "h": "static.htm#LNPLS00606" },
{ "a": "LNPLSidm139712178096752", "t": "Transaction Processing and Control", "h": "static.htm#LNPLS00608", 
 "c": [ { "t": "COMMIT Statement", "h": "static.htm#LNPLS592" },
 { "t": "ROLLBACK Statement", "h": "static.htm#LNPLS594" },
 { "t": "SAVEPOINT Statement", "h": "static.htm#LNPLS99976" },
 { "t": "Implicit Rollbacks", "h": "static.htm#LNPLS598" },
 { "t": "SET TRANSACTION Statement", "h": "static.htm#LNPLS99975" },
 { "t": "Overriding Default Locking", "h": "static.htm#LNPLS602" },
 { }
 ]
 },
{ "a": "LNPLSidm139712257820656", "t": "Autonomous Transactions", "h": "static.htm#LNPLS00609", 
 "c": [ { "t": "Advantages of Autonomous Transactions", "h": "static.htm#LNPLS509" },
 { "t": "Transaction Context", "h": "static.htm#LNPLS616" },
 { "t": "Transaction Visibility", "h": "static.htm#LNPLS617" },
 { "t": "Declaring Autonomous Routines", "h": "static.htm#LNPLS610" },
 { "t": "Controlling Autonomous Transactions", "h": "static.htm#LNPLS99982" },
 { "t": "Autonomous Triggers", "h": "static.htm#LNPLS622" },
 { "t": "Invoking Autonomous Functions from SQL", "h": "static.htm#LNPLS624" },
 { }
 ]
 },
 { }
 ]
 },
{ "a": "LNPLSidm139712170544640", "t": "PL/SQL Dynamic SQL", "h": "dynamic.htm#LNPLS011", 
 "c": [ { "t": "When You Need Dynamic SQL", "h": "dynamic.htm#LNPLS01101" },
{ "a": "LNPLSidm139712169984544", "t": "Native Dynamic SQL", "h": "dynamic.htm#LNPLS01102", 
 "c": [ { "t": "EXECUTE IMMEDIATE Statement", "h": "dynamic.htm#LNPLS01115" },
 { "t": "OPEN FOR, FETCH, and CLOSE Statements", "h": "dynamic.htm#LNPLS629" },
 { "t": "Repeated Placeholder Names in Dynamic SQL Statements", "h": "dynamic.htm#LNPLS631" },
 { }
 ]
 },
{ "a": "LNPLSidm139712256787840", "t": "DBMS_SQL Package", "h": "dynamic.htm#LNPLS01108", 
 "c": [ { "t": "DBMS_SQL.RETURN_RESULT Procedure", "h": "dynamic.htm#LNPLS2174" },
 { "t": "DBMS_SQL.GET_NEXT_RESULT Procedure", "h": "dynamic.htm#LNPLS2176" },
 { "t": "DBMS_SQL.TO_REFCURSOR Function", "h": "dynamic.htm#LNPLS01113" },
 { "t": "DBMS_SQL.TO_CURSOR_NUMBER Function", "h": "dynamic.htm#LNPLS00001" },
 { }
 ]
 },
{ "a": "LNPLSidm139712176220864", "t": "SQL Injection", "h": "dynamic.htm#LNPLS01109", 
 "c": [ { "t": "SQL Injection Techniques", "h": "dynamic.htm#LNPLS638" },
 { "t": "Guards Against SQL Injection", "h": "dynamic.htm#LNPLS645" },
 { }
 ]
 },
 { }
 ]
 },
{ "a": "LNPLSidm139712258915344", "t": "PL/SQL Subprograms", "h": "subprograms.htm#LNPLS174", 
 "c": [ { "t": "Reasons to Use Subprograms", "h": "subprograms.htm#LNPLS99900" },
 { "t": "Nested, Package, and Standalone Subprograms", "h": "subprograms.htm#LNPLS99899" },
 { "t": "Subprogram Invocations", "h": "subprograms.htm#LNPLS99901" },
{ "a": "LNPLSidm139712171419312", "t": "Subprogram Parts", "h": "subprograms.htm#LNPLS653", 
 "c": [ { "t": "Additional Parts for Functions", "h": "subprograms.htm#LNPLS99898" },
 { "t": "RETURN Statement", "h": "subprograms.htm#LNPLS99897" },
 { }
 ]
 },
 { "t": "Forward Declaration", "h": "subprograms.htm#LNPLS99896" },
{ "a": "LNPLSidm139712176745248", "t": "Subprogram Parameters", "h": "subprograms.htm#LNPLS00806", 
 "c": [ { "t": "Formal and Actual Subprogram Parameters", "h": "subprograms.htm#LNPLS657" },
 { "t": "Subprogram Parameter Passing Methods", "h": "subprograms.htm#LNPLS99952" },
 { "t": "Subprogram Parameter Modes", "h": "subprograms.htm#LNPLS659" },
 { "t": "Subprogram Parameter Aliasing", "h": "subprograms.htm#LNPLS00815" },
 { "t": "Default Values for IN Subprogram Parameters", "h": "subprograms.htm#LNPLS666" },
 { "t": "Positional, Named, and Mixed Notation for Actual Parameters", "h": "subprograms.htm#LNPLS00825" },
 { }
 ]
 },
 { "t": "Subprogram Invocation Resolution", "h": "subprograms.htm#LNPLS00808" },
{ "a": "LNPLSidm139712207914064", "t": "Overloaded Subprograms", "h": "subprograms.htm#LNPLS00807", 
 "c": [ { "t": "Formal Parameters that Differ Only in Numeric Data Type", "h": "subprograms.htm#LNPLS672" },
 { "t": "Subprograms that You Cannot Overload", "h": "subprograms.htm#LNPLS673" },
 { "t": "Subprogram Overload Errors", "h": "subprograms.htm#LNPLS674" },
 { }
 ]
 },
 { "t": "Recursive Subprograms", "h": "subprograms.htm#LNPLS00810" },
 { "t": "Subprogram Side Effects", "h": "subprograms.htm#LNPLS00814" },
{ "a": "LNPLSidm139712257777840", "t": "PL/SQL Function Result Cache", "h": "subprograms.htm#LNPLS00817", 
 "c": [ { "t": "Enabling Result-Caching for a Function", "h": "subprograms.htm#LNPLS698" },
 { "t": "Developing Applications with Result-Cached Functions", "h": "subprograms.htm#LNPLS700" },
 { "t": "Restrictions on Result-Cached Functions", "h": "subprograms.htm#LNPLS701" },
 { "t": "Examples of Result-Cached Functions", "h": "subprograms.htm#LNPLS702" },
 { "t": "Advanced Result-Cached Function Topics", "h": "subprograms.htm#LNPLS706" },
 { }
 ]
 },
 { "t": "PL/SQL Functions that SQL Statements Can Invoke", "h": "subprograms.htm#LNPLS99890" },
{ "a": "LNPLSidm139712244494688", "t": "Invoker's Rights and Definer's Rights (AUTHID Property)", "h": "subprograms.htm#LNPLS00809", 
 "c": [ { "t": "Granting Roles to PL/SQL Packages and Standalone Subprograms", "h": "subprograms.htm#LNPLS599" },
 { "t": "IR Units Need Template Objects", "h": "subprograms.htm#LNPLS684" },
 { }
 ]
 },
 { "t": "External Subprograms", "h": "subprograms.htm#LNPLS00812" },
 { }
 ]
 },
{ "a": "LNPLSidm139712176734720", "t": "PL/SQL Triggers", "h": "triggers.htm#LNPLS179", 
 "c": [ { "t": "Overview of Triggers", "h": "triggers.htm#LNPLS2001" },
 { "t": "Reasons to Use Triggers", "h": "triggers.htm#LNPLS723" },
{ "a": "LNPLSidm139712258135856", "t": "DML Triggers", "h": "triggers.htm#LNPLS99888", 
 "c": [ { "t": "Conditional Predicates for Detecting Triggering DML Statement", "h": "triggers.htm#LNPLS750" },
 { "t": "INSTEAD OF DML Triggers", "h": "triggers.htm#LNPLS20041" },
 { "t": "Compound DML Triggers", "h": "triggers.htm#LNPLS2005" },
 { "t": "Triggers for Ensuring Referential Integrity", "h": "triggers.htm#LNPLS770" },
 { }
 ]
 },
{ "a": "LNPLSidm139712246877552", "t": "Correlation Names and Pseudorecords", "h": "triggers.htm#LNPLS99955", 
 "c": [ { "t": "OBJECT_VALUE Pseudocolumn", "h": "triggers.htm#LNPLS752" },
 { }
 ]
 },
{ "a": "LNPLSidm139712177050608", "t": "System Triggers", "h": "triggers.htm#LNPLS99887", 
 "c": [ { "t": "SCHEMA Triggers", "h": "triggers.htm#LNPLS99886" },
 { "t": "DATABASE Triggers", "h": "triggers.htm#LNPLS99885" },
 { "t": "INSTEAD OF CREATE Triggers", "h": "triggers.htm#LNPLS1915" },
 { }
 ]
 },
 { "t": "Subprograms Invoked by Triggers", "h": "triggers.htm#LNPLS99884" },
 { "t": "Trigger Compilation, Invalidation, and Recompilation", "h": "triggers.htm#LNPLS2007" },
 { "t": "Exception Handling in Triggers", "h": "triggers.htm#LNPLS751" },
 { "t": "Trigger Design Guidelines", "h": "triggers.htm#LNPLS2002" },
{ "a": "LNPLSidm139712170419648", "t": "Trigger Restrictions", "h": "triggers.htm#LNPLS755", 
 "c": [ { "t": "Trigger Size Restriction", "h": "triggers.htm#LNPLS756" },
 { "t": "Trigger LONG and LONG RAW Data Type Restrictions", "h": "triggers.htm#LNPLS758" },
 { "t": "Mutating-Table Restriction", "h": "triggers.htm#LNPLS759" },
 { }
 ]
 },
 { "t": "Order in Which Triggers Fire", "h": "triggers.htm#LNPLS99985" },
 { "t": "Trigger Enabling and Disabling", "h": "triggers.htm#LNPLS2011" },
 { "t": "Trigger Changing and Debugging", "h": "triggers.htm#LNPLS2008" },
 { "t": "Triggers and Oracle Database Data Transfer Utilities", "h": "triggers.htm#LNPLS727" },
{ "a": "LNPLSidm139712173816496", "t": "Triggers for Publishing Events", "h": "triggers.htm#LNPLS2014", 
 "c": [ { "t": "Event Attribute Functions", "h": "triggers.htm#LNPLS794" },
 { "t": "Event Attribute Functions for Database Event Triggers", "h": "triggers.htm#LNPLS20141" },
 { "t": "Event Attribute Functions for Client Event Triggers", "h": "triggers.htm#LNPLS797" },
 { }
 ]
 },
 { "t": "Views for Information About Triggers", "h": "triggers.htm#LNPLS2012" },
 { }
 ]
 },
{ "a": "LNPLSidm139712172380624", "t": "PL/SQL Packages", "h": "packages.htm#LNPLS181", 
 "c": [ { "t": "What is a Package?", "h": "packages.htm#LNPLS00901" },
 { "t": "Reasons to Use Packages", "h": "packages.htm#LNPLS00902" },
{ "a": "LNPLSidm139712256433152", "t": "Package Specification", "h": "packages.htm#LNPLS00904", 
 "c": [ { "t": "Appropriate Public Items", "h": "packages.htm#LNPLS00911" },
 { "t": "Creating Package Specifications", "h": "packages.htm#LNPLS99922" },
 { }
 ]
 },
 { "t": "Package Body", "h": "packages.htm#LNPLS00905" },
 { "t": "Package Instantiation and Initialization", "h": "packages.htm#LNPLS99926" },
 { "t": "Package State", "h": "packages.htm#LNPLS804" },
{ "a": "LNPLSidm139712211728720", "t": "SERIALLY_REUSABLE Packages", "h": "packages.htm#LNPLS99977", 
 "c": [ { "t": "Creating SERIALLY_REUSABLE Packages", "h": "packages.htm#LNPLS99925" },
 { "t": "SERIALLY_REUSABLE Package Work Unit", "h": "packages.htm#LNPLS99924" },
 { "t": "Explicit Cursors in SERIALLY_REUSABLE Packages", "h": "packages.htm#LNPLS99923" },
 { }
 ]
 },
 { "t": "Package Writing Guidelines", "h": "packages.htm#LNPLS00909" },
 { "t": "Package Example", "h": "packages.htm#LNPLS00906" },
 { "t": "How STANDARD Package Defines the PL/SQL Environment", "h": "packages.htm#LNPLS00907" },
 { }
 ]
 },
{ "a": "LNPLSidm139712175000944", "t": "PL/SQL Error Handling", "h": "errors.htm#LNPLS007", 
 "c": [{ "a": "LNPLSidm139712244755008", "t": "Compile-Time Warnings", "h": "errors.htm#LNPLS00711", 
 "c": [ { "t": "DBMS_WARNING Package", "h": "errors.htm#LNPLS861" },
 { }
 ]
 },
{ "a": "LNPLSidm139712177012656", "t": "Overview of Exception Handling", "h": "errors.htm#LNPLS00701", 
 "c": [ { "t": "Exception Categories", "h": "errors.htm#LNPLS99872" },
 { "t": "Advantages of Exception Handlers", "h": "errors.htm#LNPLS00702" },
 { "t": "Guidelines for Avoiding and Handling Exceptions", "h": "errors.htm#LNPLS00712" },
 { }
 ]
 },
 { "t": "Internally Defined Exceptions", "h": "errors.htm#LNPLS99871" },
 { "t": "Predefined Exceptions", "h": "errors.htm#LNPLS00703" },
 { "t": "User-Defined Exceptions", "h": "errors.htm#LNPLS00704" },
 { "t": "Redeclared Predefined Exceptions", "h": "errors.htm#LNPLS99870" },
{ "a": "LNPLSidm139712245055408", "t": "Raising Exceptions Explicitly", "h": "errors.htm#LNPLS00705", 
 "c": [ { "t": "RAISE Statement", "h": "errors.htm#LNPLS99869" },
 { "t": "RAISE_APPLICATION_ERROR Procedure", "h": "errors.htm#LNPLS99960" },
 { }
 ]
 },
{ "a": "LNPLSidm139712255909072", "t": "Exception Propagation", "h": "errors.htm#LNPLS00706", 
 "c": [ { "t": "Propagation of Exceptions Raised in Declarations", "h": "errors.htm#LNPLS844" },
 { "t": "Propagation of Exceptions Raised in Exception Handlers", "h": "errors.htm#LNPLS846" },
 { }
 ]
 },
 { "t": "Unhandled Exceptions", "h": "errors.htm#LNPLS850" },
 { "t": "Retrieving Error Code and Error Message", "h": "errors.htm#LNPLS848" },
 { "t": "Continuing Execution After Handling Exceptions", "h": "errors.htm#LNPLS851" },
 { "t": "Retrying Transactions After Handling Exceptions", "h": "errors.htm#LNPLS853" },
 { "t": "Handling Errors in Distributed Queries", "h": "errors.htm#LNPLS1963" },
 { }
 ]
 },
{ "a": "LNPLSidm139712179090128", "t": "PL/SQL Optimization and Tuning", "h": "tuning.htm#LNPLS012", 
 "c": [{ "a": "LNPLSidm139712207147440", "t": "PL/SQL Optimizer", "h": "tuning.htm#LNPLS01201", 
 "c": [ { "t": "Subprogram Inlining", "h": "tuning.htm#LNPLS99951" },
 { }
 ]
 },
 { "t": "Candidates for Tuning", "h": "tuning.htm#LNPLS01212" },
{ "a": "LNPLSidm139712242102624", "t": "Minimizing CPU Overhead", "h": "tuning.htm#LNPLS863", 
 "c": [ { "t": "Tune SQL Statements", "h": "tuning.htm#LNPLS864" },
 { "t": "Tune Function Invocations in Queries", "h": "tuning.htm#LNPLS865" },
 { "t": "Tune Subprogram Invocations", "h": "tuning.htm#LNPLS01208" },
 { "t": "Tune Loops", "h": "tuning.htm#LNPLS867" },
 { "t": "Tune Computation-Intensive PL/SQL Code", "h": "tuning.htm#LNPLS01206" },
 { "t": "Use SQL Character Functions", "h": "tuning.htm#LNPLS868" },
 { "t": "Put Least Expensive Conditional Tests First", "h": "tuning.htm#LNPLS869" },
 { }
 ]
 },
{ "a": "LNPLSidm139712168066304", "t": "Bulk SQL and Bulk Binding", "h": "tuning.htm#LNPLS01205", 
 "c": [ { "t": "FORALL Statement", "h": "tuning.htm#LNPLS879" },
 { "t": "BULK COLLECT Clause", "h": "tuning.htm#LNPLS891" },
 { "t": "Using FORALL Statement and BULK COLLECT Clause Together", "h": "tuning.htm#LNPLS901" },
 { "t": "Client Bulk-Binding of Host Arrays", "h": "tuning.htm#LNPLS903" },
 { }
 ]
 },
{ "a": "LNPLSidm139712242172048", "t": "Chaining Pipelined Table Functions for Multiple Transformations", "h": "tuning.htm#LNPLS01210", 
 "c": [ { "t": "Overview of Table Functions", "h": "tuning.htm#LNPLS915" },
 { "t": "Creating Pipelined Table Functions", "h": "tuning.htm#LNPLS916" },
 { "t": "Pipelined Table Functions as Transformation Functions", "h": "tuning.htm#LNPLS918" },
 { "t": "Chaining Pipelined Table Functions", "h": "tuning.htm#LNPLS921" },
 { "t": "Fetching from Results of Pipelined Table Functions", "h": "tuning.htm#LNPLS923" },
 { "t": "Passing CURSOR Expressions to Pipelined Table Functions", "h": "tuning.htm#LNPLS924" },
 { "t": "DML Statements on Pipelined Table Function Results", "h": "tuning.htm#LNPLS928" },
 { "t": "NO_DATA_NEEDED Exception", "h": "tuning.htm#LNPLS929" },
 { }
 ]
 },
 { "t": "Updating Large Tables in Parallel", "h": "tuning.htm#LNPLS930" },
 { "t": "Collecting Data About User-Defined Identifiers", "h": "tuning.htm#LNPLS01213" },
{ "a": "LNPLSidm139712175721648", "t": "Profiling and Tracing PL/SQL Programs", "h": "tuning.htm#LNPLS01214", 
 "c": [ { "t": "Profiler API: Package DBMS_PROFILER", "h": "tuning.htm#LNPLS877" },
 { "t": "Trace API: Package DBMS_TRACE", "h": "tuning.htm#LNPLS878" },
 { }
 ]
 },
{ "a": "LNPLSidm139712259174880", "t": "Compiling PL/SQL Units for Native Execution", "h": "tuning.htm#LNPLS01209", 
 "c": [ { "t": "Determining Whether to Use PL/SQL Native Compilation", "h": "tuning.htm#LNPLS910" },
 { "t": "How PL/SQL Native Compilation Works", "h": "tuning.htm#LNPLS911" },
 { "t": "Dependencies, Invalidation, and Revalidation", "h": "tuning.htm#LNPLS912" },
 { "t": "Setting Up a New Database for PL/SQL Native Compilation", "h": "tuning.htm#LNPLS913" },
 { "t": "Compiling the Entire Database for PL/SQL Native or Interpreted Compilation", "h": "tuning.htm#LNPLS914" },
 { }
 ]
 },
 { }
 ]
 },
{ "a": "LNPLSidm139712167858864", "t": "PL/SQL Language Elements", "h": "langelems.htm#LNPLS013", 
 "c": [ { "t": "Assignment Statement", "h": "assignment_statement.htm#LNPLS01301" },
 { "t": "AUTONOMOUS_TRANSACTION Pragma", "h": "autotransaction_pragma.htm#LNPLS01302" },
 { "t": "Basic LOOP Statement", "h": "basic_loop_statement.htm#LNPLS01328" },
 { "t": "Block", "h": "block.htm#LNPLS01303" },
 { "t": "CASE Statement", "h": "case_statement.htm#LNPLS01304" },
 { "t": "CLOSE Statement", "h": "close_statement.htm#LNPLS01305" },
 { "t": "Collection Method Invocation", "h": "collection_method.htm#LNPLS01306" },
 { "t": "Collection Variable Declaration", "h": "collection_variable.htm#LNPLS01307" },
 { "t": "Comment", "h": "comment.htm#LNPLS01308" },
 { "t": "Constant Declaration", "h": "constant.htm#LNPLS01310" },
 { "t": "CONTINUE Statement", "h": "continue_statement.htm#LNPLS01360" },
 { "t": "Cursor FOR LOOP Statement", "h": "cursor_for_loop_statement.htm#LNPLS1143" },
 { "t": "Cursor Variable Declaration", "h": "cursor_variable.htm#LNPLS01312" },
 { "t": "DELETE Statement Extension", "h": "delete_statement.htm#LNPLS1169" },
 { "t": "EXCEPTION_INIT Pragma", "h": "exceptioninit_pragma.htm#LNPLS01315" },
 { "t": "Exception Declaration", "h": "exception_declaration.htm#LNPLS01387" },
 { "t": "Exception Handler", "h": "exception_handler.htm#LNPLS01316" },
 { "t": "EXECUTE IMMEDIATE Statement", "h": "executeimmediate_statement.htm#LNPLS01317" },
 { "t": "EXIT Statement", "h": "exit_statement.htm#LNPLS01318" },
 { "t": "Explicit Cursor Declaration and Definition", "h": "explicit_cursor.htm#LNPLS01313" },
 { "t": "Expression", "h": "expression.htm#LNPLS01319" },
 { "t": "FETCH Statement", "h": "fetch_statement.htm#LNPLS01320" },
 { "t": "FOR LOOP Statement", "h": "for_loop_statement.htm#LNPLS1515" },
 { "t": "FORALL Statement", "h": "forall_statement.htm#LNPLS01321" },
 { "t": "Formal Parameter Declaration", "h": "formal_parameter.htm#LNPLS1271" },
 { "t": "Function Declaration and Definition", "h": "function.htm#LNPLS01322" },
 { "t": "GOTO Statement", "h": "goto_statement.htm#LNPLS01323" },
 { "t": "IF Statement", "h": "if_statement.htm#LNPLS01324" },
 { "t": "Implicit Cursor Attribute", "h": "implicit_cursor_attribute.htm#LNPLS01348" },
 { "t": "INLINE Pragma", "h": "inline_pragma.htm#LNPLS01362" },
 { "t": "INSERT Statement Extension", "h": "insert_statement.htm#LNPLS99950" },
 { "t": "Named Cursor Attribute", "h": "named_cursor_attribute.htm#LNPLS01311" },
 { "t": "NULL Statement", "h": "null_statement.htm#LNPLS01330" },
 { "t": "OPEN Statement", "h": "open_statement.htm#LNPLS01332" },
 { "t": "OPEN FOR Statement", "h": "openfor_statement.htm#LNPLS01333" },
 { "t": "PIPE ROW Statement", "h": "pipe_row_statement.htm#LNPLS99883" },
 { "t": "Procedure Declaration and Definition", "h": "procedure.htm#LNPLS01336" },
 { "t": "RAISE Statement", "h": "raise_statement.htm#LNPLS01337" },
 { "t": "Record Variable Declaration", "h": "record_definition.htm#LNPLS01338" },
 { "t": "RESTRICT_REFERENCES Pragma", "h": "restrictreferences_pragma.htm#LNPLS01339" },
 { "t": "RETURN Statement", "h": "return_statement.htm#LNPLS01340" },
 { "t": "RETURNING INTO Clause", "h": "returninginto_clause.htm#LNPLS01354" },
 { "t": "%ROWTYPE Attribute", "h": "rowtype_attribute.htm#LNPLS01342" },
 { "t": "Scalar Variable Declaration", "h": "scalar_variable_declaration.htm#LNPLS01388" },
 { "t": "SELECT INTO Statement", "h": "selectinto_statement.htm#LNPLS01345" },
 { "t": "SERIALLY_REUSABLE Pragma", "h": "seriallyreusable_pragma.htm#LNPLS01346" },
 { "t": "SQLCODE Function", "h": "sqlcode_function.htm#LNPLS01349" },
 { "t": "SQLERRM Function", "h": "sqlerrm_function.htm#LNPLS01350" },
 { "t": "%TYPE Attribute", "h": "type_attribute.htm#LNPLS01352" },
 { "t": "UDF Pragma", "h": "udf_pragma.htm#LNPLS1851" },
 { "t": "UPDATE Statement Extensions", "h": "update_statement.htm#LNPLS99949" },
 { "t": "WHILE LOOP Statement", "h": "while_loop_statement.htm#LNPLS1863" },
 { }
 ]
 },
{ "a": "LNPLSidm139712177137584", "t": "SQL Statements for Stored PL/SQL Units", "h": "sqlstatements.htm#LNPLS99979", 
 "c": [ { "t": "ALTER FUNCTION Statement", "h": "alter_function.htm#LNPLS99999" },
 { "t": "ALTER LIBRARY Statement", "h": "alter_library.htm#LNPLS99946" },
 { "t": "ALTER PACKAGE Statement", "h": "alter_package.htm#LNPLS99998" },
 { "t": "ALTER PROCEDURE Statement", "h": "alter_procedure.htm#LNPLS99997" },
 { "t": "ALTER TRIGGER Statement", "h": "alter_trigger.htm#LNPLS99996" },
 { "t": "ALTER TYPE Statement", "h": "alter_type.htm#LNPLS99995" },
 { "t": "CREATE FUNCTION Statement", "h": "create_function.htm#LNPLS01370" },
 { "t": "CREATE LIBRARY Statement", "h": "create_library.htm#LNPLS99948" },
 { "t": "CREATE PACKAGE Statement", "h": "create_package.htm#LNPLS01371" },
 { "t": "CREATE PACKAGE BODY Statement", "h": "create_package_body.htm#LNPLS01372" },
 { "t": "CREATE PROCEDURE Statement", "h": "create_procedure.htm#LNPLS01373" },
 { "t": "CREATE TRIGGER Statement", "h": "create_trigger.htm#LNPLS01374" },
 { "t": "CREATE TYPE Statement", "h": "create_type.htm#LNPLS01375" },
 { "t": "CREATE TYPE BODY Statement", "h": "create_type_body.htm#LNPLS01376" },
 { "t": "DROP FUNCTION Statement", "h": "drop_function.htm#LNPLS99993" },
 { "t": "DROP LIBRARY Statement", "h": "drop_library.htm#LNPLS99947" },
 { "t": "DROP PACKAGE Statement", "h": "drop_package.htm#LNPLS99992" },
 { "t": "DROP PROCEDURE Statement", "h": "drop_procedure.htm#LNPLS99991" },
 { "t": "DROP TRIGGER Statement", "h": "drop_trigger.htm#LNPLS99990" },
 { "t": "DROP TYPE Statement", "h": "drop_type.htm#LNPLS99989" },
 { "t": "DROP TYPE BODY Statement", "h": "drop_type_body.htm#LNPLS99988" },
 { }
 ]
 },
{ "a": "LNPLSidm139712176872336", "t": "PL/SQL Source Text Wrapping", "h": "wrap.htm#LNPLS016", 
 "c": [ { "t": "PL/SQL Source Text Wrapping Limitations", "h": "wrap.htm#LNPLS1744" },
 { "t": "PL/SQL Source Text Wrapping Guidelines", "h": "wrap.htm#LNPLS1743" },
 { "t": "Wrapping PL/SQL Source Text with PL/SQL Wrapper Utility", "h": "wrap.htm#LNPLS01602" },
 { "t": "Wrapping PL/SQL Source Text with DBMS_DDL Subprograms", "h": "wrap.htm#LNPLS01603" },
 { }
 ]
 },
{ "a": "LNPLSidm139712178659440", "t": "PL/SQL Name Resolution", "h": "nameresolution.htm#LNPLS017", 
 "c": [ { "t": "Qualified Names and Dot Notation", "h": "nameresolution.htm#LNPLS01702" },
 { "t": "Column Name Precedence", "h": "nameresolution.htm#LNPLS2154" },
 { "t": "Differences Between PL/SQL and SQL Name Resolution Rules", "h": "nameresolution.htm#LNPLS01703" },
 { "t": "Resolution of Names in Static SQL Statements", "h": "nameresolution.htm#LNPLS99882" },
{ "a": "LNPLSidm139712179264576", "t": "What is Capture?", "h": "nameresolution.htm#LNPLS01704", 
 "c": [ { "t": "Outer Capture", "h": "nameresolution.htm#LNPLS1754" },
 { "t": "Same-Scope Capture", "h": "nameresolution.htm#LNPLS1753" },
 { "t": "Inner Capture", "h": "nameresolution.htm#LNPLS1752" },
 { }
 ]
 },
{ "a": "LNPLSidm139712256782816", "t": "Avoiding Inner Capture in SELECT and DML Statements", "h": "nameresolution.htm#LNPLS01705", 
 "c": [ { "t": "Qualifying References to Attributes and Methods", "h": "nameresolution.htm#LNPLS1755" },
 { "t": "Qualifying References to Row Expressions", "h": "nameresolution.htm#LNPLS1756" },
 { }
 ]
 },
 { }
 ]
 },
 { "t": "PL/SQL Program Limits", "h": "limits.htm#LNPLS018" },
 { "t": "PL/SQL Reserved Words and Keywords", "h": "reservedwords.htm#LNPLS019" },
 { "t": "PL/SQL Predefined Data Types", "h": "predefined.htm#LNPLS2163" },
 { "t": "Index", "h": "index.htm" },
  { }
 ] } ]}