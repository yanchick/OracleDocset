<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="UTF-8"/>
<a class="dashingAutolink" name="autolink-78101"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/PL%2FSQL%20Dynamic%20SQL"></a><title>PL/SQL Dynamic SQL</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"/>
<meta name="description" content="Dynamic SQL is a programming methodology for generating and running SQL statements at run time."/>
<meta name="keywords" content="dynamic SQL, SQL, dynamic, See, DDL statement, dynamic SQL for, native dynamic SQL, native, cursor attribute, for implicit cursor, native dynamic SQL and, EXECUTE IMMEDIATE statement, placeholder for bind variable, in dynamic SQL, EXECUTE IMMEDIATE statement and, placeholder for bind variable in, bind variable, placeholder for, NULL value, in USING clause, query, processing result set of, multiple-row dynamic query, collection, querying, with dynamic SQL, repeated, DBMS_SQL package, implicit cursor, dynamic SQL and, DBMS_SQL package and, switching to native dynamic SQL from, switching to DBMS_SQL package from, Method 4, DBMS_SQL.RETURN_RESULT procedure, RETURN_RESULT procedure, implicitly returning results of, implicitly returning query results, returning query results implicitly, cursor variable, DBMS_SQL.RETURN_RESULT procedure and, cursor number, DBMS_SQL.GET_NEXT_RESULT procedure, GET_NEXT_RESULT procedure, DBMS_SQL.GET_NEXT_RESULT procedure and, DBMS_SQL.TO_REFCURSOR function, TO_REFCURSOR function, converting to cursor variable, converting cursor number to, DBMS_SQL.TO_NUMBER function, TO_NUMBER function, converting to cursor number, converting cursor variable to, SQL injection, security mechanism, against SQL injection, statement modification, statement injection, data type conversion, SQL injection and, NLS parameters, avoiding SQL injection with, validation check for avoiding SQL injection, DBMS_ASSERT package, explicit format model, format model"/>
<meta name="dcterms.created" content="2017-05-09T17:03:42Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database PL/SQL Language Reference"/>
<meta name="dcterms.identifier" content="E50727-06"/>
<meta name="dcterms.isVersionOf" content="LNPLS"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Prev" href="static.htm" title="Previous" type="text/html"/>
<link rel="Next" href="subprograms.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E50727-06.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-7E2F596F-9CA3-4DC8-8333-0C117962DB73"></a> <span id="PAGE" style="display:none;">14/100</span> <!-- End Header -->
<a id="LNPLS513"></a><a id="LNPLS011"></a>
<h1 id="LNPLS-GUID-7E2F596F-9CA3-4DC8-8333-0C117962DB73" class="sect1"><span class="enumeration_chapter">7</span> PL/SQL Dynamic SQL</h1>
<div>
<p><span class="bold">Dynamic SQL</span> is a programming methodology for generating and running SQL statements at run time.</p>
<p>It is useful when writing general-purpose and flexible programs like ad hoc query systems, when writing programs that must run database definition language (DDL) statements, or when you do not know at compile time the full text of a SQL statement or the number or data types of its input and output variables.</p>
<p>PL/SQL provides two ways to write dynamic SQL:</p>
<ul style="list-style-type: disc;">
<li>
<p>Native dynamic SQL, a PL/SQL language (that is, native) feature for building and running dynamic SQL statements</p>
</li>
<li>
<p><code class="codeph">DBMS_SQL</code> package, an API for building, running, and describing dynamic SQL statements</p>
</li>
</ul>
<p>Native dynamic SQL code is easier to read and write than equivalent code that uses the <code class="codeph">DBMS_SQL</code> package, and runs noticeably faster (especially when it can be optimized by the compiler). However, to write native dynamic SQL code, you must know at compile time the number and data types of the input and output variables of the dynamic SQL statement. If you do not know this information at compile time, you must use the <code class="codeph">DBMS_SQL</code> package. You must also use the <code class="codeph">DBMS_SQL</code> package if you want a stored subprogram to return a query result implicitly (not through an <code class="codeph">OUT</code> <code class="codeph">REF</code> <code class="codeph">CURSOR</code> parameter).</p>
<p>When you need both the <code class="codeph">DBMS_SQL</code> package and native dynamic SQL, you can switch between them, using the <span class="q">&#34;<a href="dynamic.htm#GUID-A194C9FA-221A-466B-9179-6238FEC5143B">DBMS_SQL.TO_REFCURSOR Function</a>&#34;</span> and <span class="q">&#34;<a href="dynamic.htm#GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF">DBMS_SQL.TO_CURSOR_NUMBER Function</a>&#34;</span>.</p>
<div class="section">
<p class="subhead1">Topics</p>
</div>
<!-- class="section" -->
<ul style="list-style-type: disc;">
<li>
<p><a href="dynamic.htm#GUID-DAFD83C8-FA3A-40A6-95E5-3B2F082E1798">When You Need Dynamic SQL</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-D2613968-6660-4AA2-9057-28E425A3040D" title="Native dynamic SQL processes most dynamic SQL statements with the EXECUTE IMMEDIATE statement.">Native Dynamic SQL</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B" title="The&nbsp;DBMS_SQL&nbsp;package defines an entity called a&nbsp;SQL cursor number. Because the SQL cursor number is a PL/SQL integer, you can pass it across call boundaries and store it.">DBMS_SQL Package</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C" title="SQL injection maliciously exploits applications that use client-supplied data in SQL statements, thereby gaining unauthorized access to a database to view or manipulate restricted data.">SQL Injection</a></p>
</li>
</ul>
</div>
<a id="LNPLS01101"></a>
<div class="props_rev_3"><a id="GUID-DAFD83C8-FA3A-40A6-95E5-3B2F082E1798"></a>
<h2 id="LNPLS-GUID-DAFD83C8-FA3A-40A6-95E5-3B2F082E1798" class="sect2">When You Need Dynamic SQL</h2>
<div>
<p>In PL/SQL, you need dynamic SQL to run:</p>
<ul style="list-style-type: disc;">
<li>
<p>SQL whose text is unknown at compile time</p>
<p>For example, a <code class="codeph">SELECT</code> statement that includes an identifier that is unknown at compile time (such as a table name) or a <code class="codeph">WHERE</code> clause in which the number of subclauses is unknown at compile time.</p>
</li>
<li>
<p>SQL that is not supported as static SQL</p>
<p>That is, any SQL construct not included in <span class="q">&#34;<a href="static.htm#GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C" title="Static SQL has the same syntax as SQL, except as noted.">Description of Static SQL</a>&#34;</span>.</p>
</li>
</ul>
<p>If you do not need dynamic SQL, use static SQL, which has these advantages:</p>
<ul style="list-style-type: disc;">
<li>
<p>Successful compilation verifies that static SQL statements reference valid database objects and that the necessary privileges are in place to access those objects.</p>
</li>
<li>
<p>Successful compilation creates schema object dependencies.</p>
<p>For information about schema object dependencies, see <a class="olink ADFNS99967" target="_blank" href="../ADFNS/adfns_dependencies.htm#ADFNS99967"><span class="italic">Oracle Database Development Guide</span></a>.</p>
</li>
</ul>
<p>For information about using static SQL statements with PL/SQL, see <a href="static.htm#GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313" title="Static SQL is a PL/SQL feature that allows SQL syntax directly in a PL/SQL statement.">PL/SQL Static SQL</a>.</p>
</div>
</div>
<a id="LNPLS514"></a><a id="LNPLS01102"></a>
<div class="props_rev_3"><a id="GUID-D2613968-6660-4AA2-9057-28E425A3040D"></a>
<h2 id="LNPLS-GUID-D2613968-6660-4AA2-9057-28E425A3040D" class="sect2">Native Dynamic SQL</h2>
<div>
<p>Native dynamic SQL processes most dynamic SQL statements with the <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement.</p>
<p>If the dynamic SQL statement is a <code class="codeph">SELECT</code> statement that returns multiple rows, native dynamic SQL gives you these choices:</p>
<ul style="list-style-type: disc;">
<li>
<p>Use the <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement with the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> clause.</p>
</li>
<li>
<p>Use the <code class="codeph">OPEN</code> <code class="codeph">FOR</code>, <code class="codeph">FETCH</code>, and <code class="codeph">CLOSE</code> statements.</p>
</li>
</ul>
<p>The SQL cursor attributes work the same way after native dynamic SQL <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, <code class="codeph">MERGE</code>, and single-row <code class="codeph">SELECT</code> statements as they do for their static SQL counterparts. For more information about SQL cursor attributes, see <span class="q">&#34;<a href="static.htm#GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" title="A cursor is a pointer to a private SQL area that stores information about processing a specific SELECT or DML statement.">Cursors Overview</a>&#34;</span>.</p>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="dynamic.htm#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217" title="The EXECUTE IMMEDIATE statement is the means by which native dynamic SQL processes most dynamic SQL statements.">EXECUTE IMMEDIATE Statement</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2">OPEN FOR, FETCH, and CLOSE Statements</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-4E5C6A4F-C1DB-44DD-964E-C683120B448E" title="If you repeat placeholder names in dynamic SQL statements, be aware that the way placeholders are associated with bind variables depends on the kind of dynamic SQL statement.">Repeated Placeholder Names in Dynamic SQL Statements</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS626"></a><a id="LNPLS515"></a><a id="LNPLS516"></a><a id="LNPLS517"></a><a id="LNPLS1854"></a><a id="LNPLS1855"></a><a id="LNPLS628"></a><a id="LNPLS01115"></a>
<div class="props_rev_3"><a id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217"></a>
<h3 id="LNPLS-GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217" class="sect3">EXECUTE IMMEDIATE Statement</h3>
<div>
<p>The <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement is the means by which native dynamic SQL processes most dynamic SQL statements.</p>
<p>If the dynamic SQL statement is <span class="bold">self-contained</span> (that is, if it has no placeholders for bind variables and the only result that it can possibly return is an error), then the <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement needs no clauses.</p>
<p>If the dynamic SQL statement includes placeholders for bind variables, each placeholder must have a corresponding bind variable in the appropriate clause of the <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement, as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>If the dynamic SQL statement is a <code class="codeph">SELECT</code> statement that can return at most one row, put out-bind variables (defines) in the <code class="codeph">INTO</code> clause and in-bind variables in the <code class="codeph">USING</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is a <code class="codeph">SELECT</code> statement that can return multiple rows, put out-bind variables (defines) in the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> clause and in-bind variables in the <code class="codeph">USING</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is a DML statement without a <code class="codeph">RETURNING</code> <code class="codeph">INTO</code> clause, other than <code class="codeph">SELECT</code>, put all bind variables in the <code class="codeph">USING</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is a DML statement with a <code class="codeph">RETURNING</code> <code class="codeph">INTO</code> clause, put in-bind variables in the <code class="codeph">USING</code> clause and out-bind variables in the <code class="codeph">RETURNING</code> <code class="codeph">INTO</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is an anonymous PL/SQL block or a <code class="codeph">CALL</code> statement, put all bind variables in the <code class="codeph">USING</code> clause.</p>
<p>If the dynamic SQL statement invokes a subprogram, ensure that:</p>
<ul style="list-style-type: disc;">
<li>
<p>The subprogram is either created at schema level or declared and defined in a package specification.</p>
</li>
<li>
<p>Every bind variable that corresponds to a placeholder for a subprogram parameter has the same parameter mode as that subprogram parameter and a data type that is compatible with that of the subprogram parameter.</p>
</li>
<li>
<p>No bind variable is the reserved word <code class="codeph">NULL</code>.</p>
<p>To work around this restriction, use an uninitialized variable where you want to use <code class="codeph">NULL</code>, as in <a href="dynamic.htm#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__BHCBIICB">Example 7-7</a>.</p>
</li>
<li>
<p>No bind variable has a data type that SQL does not support (such as associative array indexed by string).</p>
<p>If the data type is a collection or record type, then it must be declared in a package specification.</p>
</li>
</ul>
</li>
</ul>
<div class="infobox-note" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__GUID-C61A4D55-E5C8-4939-BD57-9D81EF049CC3">
<p class="notep1">Note:</p>
<p>Bind variables can be evaluated in any order. If a program determines order of evaluation, then at the point where the program does so, its behavior is undefined.</p>
</div>
<p>In <a href="dynamic.htm#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDECEFD">Example 7-4</a>, <a href="dynamic.htm#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDFAJCJ">Example 7-5</a>, and <a href="dynamic.htm#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDJAAIJ">Example 7-6</a>, the dynamic PL/SQL block is an anonymous PL/SQL block that invokes a subprogram that has a formal parameter of a PL/SQL collection type. Collection types are not SQL data types. In each example, the collection type is declared in a package specification, and the subprogram is declared in the package specification and defined in the package body.</p>
<div class="infoboxnotealso" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__GUID-DFDCF893-E357-49BA-B39C-5105AEB3E0BB">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="create_function.htm#GUID-B71BC5BD-B87C-4054-AAA5-213E856651F2">CREATE FUNCTION Statement</a>&#34;</span> for information about creating functions at schema level</p>
</li>
<li>
<p><span class="q">&#34;<a href="create_procedure.htm#GUID-5F84DB47-B5BE-4292-848F-756BF365EC54">CREATE PROCEDURE Statement</a>&#34;</span> for information about creating procedures at schema level</p>
</li>
<li>
<p><span class="q">&#34;<a href="packages.htm#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.">PL/SQL Packages</a>&#34;</span> for information about packages</p>
</li>
<li>
<p><span class="q">&#34;<a href="create_package.htm#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5">CREATE PACKAGE Statement</a>&#34;</span> for information about declaring subprograms in packages</p>
</li>
<li>
<p><span class="q">&#34;<a href="create_package_body.htm#GUID-68526FF2-96A1-4F14-A10B-4DD3E1CD80BE">CREATE PACKAGE BODY Statement</a>&#34;</span> for information about declaring and defining subprograms in packages</p>
</li>
<li>
<p><span class="q">&#34;<a href="create_package.htm#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5">CREATE PACKAGE Statement</a>&#34;</span> for more information about declaring types in a package specification</p>
</li>
<li>
<p><span class="q">&#34;<a href="executeimmediate_statement.htm#GUID-C3245A95-B85B-4280-A01F-12307B108DC8" title="The EXECUTE IMMEDIATE statement builds and runs a dynamic SQL statement in a single operation.">EXECUTE IMMEDIATE Statement</a>&#34;</span>for syntax details of the <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement</p>
</li>
<li>
<p><span class="q">&#34;<a href="composites.htm#GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" title="PL/SQL lets you define two kinds of composite data types, collection and record.">PL/SQL Collections and Records</a>&#34;</span> for information about collection types</p>
</li>
</ul>
</div>
<div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDIEFCJ">
<p class="titleinexample">Example 7-1 Invoking Subprogram from Dynamic PL/SQL Block</p>
<p>In this example, the dynamic PL/SQL block is an anonymous PL/SQL block that invokes a subprogram created at schema level.</p>
<pre dir="ltr"><span class="bold">-- Subprogram that dynamic PL/SQL block invokes:</span>
CREATE OR REPLACE PROCEDURE create_dept (
  deptid <span class="bold">IN OUT</span> NUMBER,
  dname  <span class="bold">IN</span>     VARCHAR2,
  mgrid  <span class="bold">IN</span>     NUMBER,
  locid  <span class="bold">IN</span>     NUMBER
) AUTHID DEFINER AS
BEGIN
  deptid := departments_seq.NEXTVAL;

  INSERT INTO departments (
    department_id,
    department_name,
    manager_id,
    location_id
  )
  VALUES (deptid, dname, mgrid, locid);
END;
/
DECLARE
  plsql_block VARCHAR2(500);
  new_deptid  NUMBER(4);
  new_dname   VARCHAR2(30) := &#39;Advertising&#39;;
  new_mgrid   NUMBER(6)    := 200;
  new_locid   NUMBER(4)    := 1700;
BEGIN
<span class="bold"> -- Dynamic PL/SQL block invokes subprogram:</span>
  plsql_block := &#39;BEGIN create_dept(:a, :b, :c, :d); END;&#39;;

<span class="bold"> /* Specify bind variables in USING clause.</span>
<span class="bold">    Specify mode for first parameter.</span>
<span class="bold">    Modes of other parameters are correct by default. */</span>

  EXECUTE IMMEDIATE plsql_block
    USING <span class="bold">IN OUT</span> new_deptid, new_dname, new_mgrid, new_locid;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDFCDFC">
<p class="titleinexample">Example 7-2 Dynamically Invoking Subprogram with BOOLEAN Formal Parameter</p>
<p>In this example, the dynamic PL/SQL block is an anonymous PL/SQL block that invokes a subprogram that has a formal parameter of the PL/SQL (but not SQL) data type <code class="codeph">BOOLEAN</code>.</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE p (x <span class="bold">BOOLEAN</span>) AUTHID DEFINER AS
BEGIN
  IF x THEN
    DBMS_OUTPUT.PUT_LINE(&#39;x is true&#39;);
  END IF;
END;
/

DECLARE
  dyn_stmt VARCHAR2(200);
  <span class="bold">b        BOOLEAN</span> := TRUE;
BEGIN
  dyn_stmt := &#39;BEGIN <span class="bold">p(:x)</span>; END;&#39;;
  EXECUTE IMMEDIATE dyn_stmt USING <span class="bold">b</span>;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">x is true
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDFCAGD">
<p class="titleinexample">Example 7-3 Dynamically Invoking Subprogram with RECORD Formal Parameter</p>
<p>In this example, the dynamic PL/SQL block is an anonymous PL/SQL block that invokes a subprogram that has a formal parameter of the PL/SQL (but not SQL) data type <code class="codeph">RECORD</code>. The record type is declared in a package specification, and the subprogram is declared in the package specification and defined in the package body.</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE pkg AUTHID DEFINER AS
 
  <span class="bold">TYPE rec IS RECORD (n1 NUMBER, n2 NUMBER);</span>
 
  <span class="bold">PROCEDURE p (x OUT rec, y NUMBER, z NUMBER);</span>
END pkg;
/
CREATE OR REPLACE PACKAGE BODY pkg AS
 
  PROCEDURE p (x OUT rec, y NUMBER, z NUMBER) AS
  BEGIN
    x.n1 := y;
    x.n2 := z;
  END p;
END pkg;
/
DECLARE
  <span class="bold">r       pkg.rec;</span>
  dyn_str VARCHAR2(3000);
BEGIN
  dyn_str := &#39;BEGIN <span class="bold">pkg.p(:x, 6, 8);</span> END;&#39;;
 
  EXECUTE IMMEDIATE dyn_str USING <span class="bold">OUT r</span>;
 
  DBMS_OUTPUT.PUT_LINE(&#39;r.n1 = &#39; || r.n1);
  DBMS_OUTPUT.PUT_LINE(&#39;r.n2 = &#39; || r.n2);
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDECEFD">
<p class="titleinexample">Example 7-4 Dynamically Invoking Subprogram with Assoc. Array Formal Parameter</p>
<p>In this example, the dynamic PL/SQL block is an anonymous PL/SQL block that invokes a subprogram that has a formal parameter of the PL/SQL collection type associative array indexed by <code class="codeph">PLS_INTEGER</code>.</p>
<div class="infobox-note" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__GUID-4A3E7FB5-07E9-42AF-B3BD-17B834418F49">
<p class="notep1">Note:</p>
<p>An associative array type used in this context must be indexed by <code class="codeph">PLS_INTEGER</code>.</p>
</div>
<pre dir="ltr">CREATE OR REPLACE PACKAGE pkg AUTHID DEFINER AS
 
  <span class="bold">TYPE number_names IS TABLE OF VARCHAR2(5)</span>
    <span class="bold">INDEX BY PLS_INTEGER;</span>
 
  <span class="bold">PROCEDURE print_number_names (x number_names);</span>
END pkg;
/
CREATE OR REPLACE PACKAGE BODY pkg AS
  PROCEDURE print_number_names (x number_names) IS
  BEGIN
    FOR i IN x.FIRST .. x.LAST LOOP
      DBMS_OUTPUT.PUT_LINE(x(i));
    END LOOP;
  END;
END pkg;
/
DECLARE  
  <span class="bold">digit_names  pkg.number_names;</span>
  dyn_stmt     VARCHAR2(3000);
BEGIN
  digit_names(0) := &#39;zero&#39;;
  digit_names(1) := &#39;one&#39;;
  digit_names(2) := &#39;two&#39;;
  digit_names(3) := &#39;three&#39;;
  digit_names(4) := &#39;four&#39;;
  digit_names(5) := &#39;five&#39;;
  digit_names(6) := &#39;six&#39;;
  digit_names(7) := &#39;seven&#39;;
  digit_names(8) := &#39;eight&#39;;
  digit_names(9) := &#39;nine&#39;;
 
  dyn_stmt := &#39;BEGIN <span class="bold">pkg.print_number_names(:x);</span> END;&#39;;
  EXECUTE IMMEDIATE dyn_stmt USING <span class="bold">digit_names</span>;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDFAJCJ">
<p class="titleinexample">Example 7-5 Dynamically Invoking Subprogram with Nested Table Formal Parameter</p>
<p>In this example, the dynamic PL/SQL block is an anonymous PL/SQL block that invokes a subprogram that has a formal parameter of the PL/SQL collection type nested table.</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE pkg AUTHID DEFINER AS
 
  <span class="bold">TYPE names IS TABLE OF VARCHAR2(10);</span>
 
  <span class="bold">PROCEDURE print_names (x names);</span>
END pkg;
/
CREATE OR REPLACE PACKAGE BODY pkg AS
  PROCEDURE print_names (x names) IS
  BEGIN
    FOR i IN x.FIRST .. x.LAST LOOP
      DBMS_OUTPUT.PUT_LINE(x(i));
    END LOOP;
  END;
END pkg;
/
DECLARE
  <span class="bold">fruits   pkg.names;</span>
  dyn_stmt VARCHAR2(3000);
BEGIN
  fruits := pkg.names(&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;);
  
  dyn_stmt := &#39;BEGIN <span class="bold">pkg.print_names(:x);</span> END;&#39;;
  EXECUTE IMMEDIATE dyn_stmt USING <span class="bold">fruits</span>;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDJAAIJ">
<p class="titleinexample">Example 7-6 Dynamically Invoking Subprogram with Varray Formal Parameter</p>
<p>In this example, the dynamic PL/SQL block is an anonymous PL/SQL block that invokes a subprogram that has a formal parameter of the PL/SQL collection type varray.</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE pkg AUTHID DEFINER AS
 
  <span class="bold">TYPE foursome IS VARRAY(4) OF VARCHAR2(5);</span>
 
  <span class="bold">PROCEDURE print_foursome (x foursome);</span>
END pkg;
/
CREATE OR REPLACE PACKAGE BODY pkg AS
  PROCEDURE print_foursome (x foursome) IS
  BEGIN
    IF x.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE(&#39;Empty&#39;);
    ELSE 
      FOR i IN x.FIRST .. x.LAST LOOP
        DBMS_OUTPUT.PUT_LINE(x(i));
      END LOOP;
    END IF;
  END;
END pkg;
/
DECLARE
  <span class="bold">directions pkg.foursome;</span>
  dyn_stmt VARCHAR2(3000);
BEGIN
  directions := pkg.foursome(&#39;north&#39;, &#39;south&#39;, &#39;east&#39;, &#39;west&#39;);
  
  dyn_stmt := &#39;BEGIN <span class="bold">pkg.print_foursome(:x);</span> END;&#39;;
  EXECUTE IMMEDIATE dyn_stmt USING <span class="bold">directions</span>;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__BHCBIICB">
<p class="titleinexample">Example 7-7 Uninitialized Variable Represents NULL in USING Clause</p>
<p>This example uses an uninitialized variable to represent the reserved word <code class="codeph">NULL</code> in the <code class="codeph">USING</code> clause.</p>
<pre dir="ltr">CREATE TABLE employees_temp AS SELECT * FROM EMPLOYEES;

DECLARE
  a_null  CHAR(1);  <span class="bold">-- Set to NULL automatically at run time</span>
BEGIN
  EXECUTE IMMEDIATE &#39;UPDATE employees_temp SET commission_pct = <span class="bold">:x</span>&#39;
    USING <span class="bold">a_null</span>;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS630"></a><a id="LNPLS519"></a><a id="LNPLS629"></a>
<div class="props_rev_3"><a id="GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2"></a>
<h3 id="LNPLS-GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2" class="sect3">OPEN FOR, FETCH, and CLOSE Statements</h3>
<div>
<p>If the dynamic SQL statement represents a <code class="codeph">SELECT</code> statement that returns multiple rows, you can process it with native dynamic SQL as follows:</p>
<ol>
<li>
<p>Use an <code class="codeph">OPEN</code> <code class="codeph">FOR</code> statement to associate a cursor variable with the dynamic SQL statement. In the <code class="codeph">USING</code> clause of the <code class="codeph">OPEN</code> <code class="codeph">FOR</code> statement, specify a bind variable for each placeholder in the dynamic SQL statement.</p>
<p>The <code class="codeph">USING</code> clause cannot contain the literal <code class="codeph">NULL</code>. To work around this restriction, use an uninitialized variable where you want to use <code class="codeph">NULL</code>, as in <a href="dynamic.htm#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__BHCBIICB">Example 7-7</a>.</p>
</li>
<li>
<p>Use the <code class="codeph">FETCH</code> statement to retrieve result set rows one at a time, several at a time, or all at once.</p>
</li>
<li>
<p>Use the <code class="codeph">CLOSE</code> statement to close the cursor variable.</p>
</li>
</ol>
<p>The dynamic SQL statement can query a collection if the collection meets the criteria in <span class="q">&#34;<a href="static.htm#GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248">Querying a Collection</a>&#34;</span>.</p>
<div class="infoboxnotealso" id="GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2__GUID-A4B16287-D713-478E-8E53-B4F5A63D2C08">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="openfor_statement.htm#GUID-EB7AF439-FDD3-4461-9E3F-B621E8ABFB96" title="The OPEN FOR statement associates a cursor variable with a query, allocates database resources to process the query, identifies the result set, and positions the cursor before the first row of the result set.">OPEN FOR Statement</a>&#34;</span> for syntax details</p>
</li>
<li>
<p><span class="q">&#34;<a href="fetch_statement.htm#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="The FETCH statement retrieves rows of data from the result set of a multiple-row query&mdash;one row at a time, several rows at a time, or all rows at once&mdash;and stores the data in variables, records, or collections.">FETCH Statement</a>&#34;</span> for syntax details</p>
</li>
<li>
<p><span class="q">&#34;<a href="close_statement.htm#GUID-46E7086C-8C29-4689-A062-0FF059E268FD" title="The CLOSE statement closes a named cursor, freeing its resources for reuse.">CLOSE Statement</a>&#34;</span> for syntax details</p>
</li>
</ul>
</div>
<div class="example" id="GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2__BHCFDIAI">
<p class="titleinexample">Example 7-8 Native Dynamic SQL with OPEN FOR, FETCH, and CLOSE Statements</p>
<p>This example lists all employees who are managers, retrieving result set rows one at a time.</p>
<pre dir="ltr">DECLARE
  TYPE EmpCurTyp  IS REF CURSOR;
  v_emp_cursor    EmpCurTyp;
  emp_record      employees%ROWTYPE;
  v_stmt_str      VARCHAR2(200);
  v_e_job         employees.job%TYPE;
BEGIN
  <span class="bold">-- Dynamic SQL statement with placeholder:</span>
  v_stmt_str := &#39;SELECT * FROM employees WHERE job_id = :j&#39;;

  <span class="bold">-- Open cursor &amp; specify bind variable in USING clause:</span>
  OPEN v_emp_cursor FOR v_stmt_str USING &#39;MANAGER&#39;;

  <span class="bold">-- Fetch rows from result set one at a time:</span>
  LOOP
    FETCH v_emp_cursor INTO emp_record;
    EXIT WHEN v_emp_cursor%NOTFOUND;
  END LOOP;

  <span class="bold">-- Close cursor:</span>
  CLOSE v_emp_cursor;
END;
/
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2__CHDDBFJB">
<p class="titleinexample">Example 7-9 Querying a Collection with Native Dynamic SQL</p>
<p>This example is like <a href="static.htm#GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248__BABJDADA">Example 6-30</a> except that the collection variable <code class="codeph">v1</code> is a bind variable.</p>
<pre dir="ltr">CREATE OR REPLACE PACKAGE pkg AUTHID DEFINER AS
  TYPE rec IS RECORD(f1 NUMBER, f2 VARCHAR2(30));
  TYPE mytab IS TABLE OF rec INDEX BY pls_integer;
END;
/

DECLARE
  <span class="bold">v1 pkg.mytab;  -- collection of records</span>
  v2 pkg.rec;
  c1 SYS_REFCURSOR;
BEGIN
  <span class="bold">OPEN c1 FOR &#39;SELECT * FROM TABLE(:1)&#39; USING v1;</span>
  FETCH c1 INTO v2;
  CLOSE c1;
  DBMS_OUTPUT.PUT_LINE(&#39;Values in record are &#39; || v2.f1 || &#39; and &#39; || v2.f2);
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS520"></a><a id="LNPLS631"></a>
<div class="props_rev_3"><a id="GUID-4E5C6A4F-C1DB-44DD-964E-C683120B448E"></a>
<h3 id="LNPLS-GUID-4E5C6A4F-C1DB-44DD-964E-C683120B448E" class="sect3">Repeated Placeholder Names in Dynamic SQL Statements</h3>
<div>
<p>If you repeat placeholder names in dynamic SQL statements, be aware that the way placeholders are associated with bind variables depends on the kind of dynamic SQL statement.</p>
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="dynamic.htm#GUID-D17344F2-3CA5-4F33-A074-47E059CA91CC" title="If the dynamic SQL statement does not represent an anonymous PL/SQL block or a CALL statement, repetition of placeholder names is insignificant.">Dynamic SQL Statement is Not Anonymous Block or CALL Statement</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-A31BBD6E-1CB5-47D2-A01B-48DC3BE203C7" title="If the dynamic SQL statement represents an anonymous PL/SQL block or a CALL statement, repetition of placeholder names is significant.">Dynamic SQL Statement is Anonymous Block or CALL Statement</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS632"></a>
<div class="props_rev_3"><a id="GUID-D17344F2-3CA5-4F33-A074-47E059CA91CC"></a>
<h4 id="LNPLS-GUID-D17344F2-3CA5-4F33-A074-47E059CA91CC" class="sect4">Dynamic SQL Statement is Not Anonymous Block or CALL Statement</h4>
<div>
<p>If the dynamic SQL statement does not represent an anonymous PL/SQL block or a <code class="codeph">CALL</code> statement, repetition of placeholder names is insignificant.</p>
<p>Placeholders are associated with bind variables in the <code class="codeph">USING</code> clause by position, not by name.</p>
<p>For example, in this dynamic SQL statement, the repetition of the name :<code class="codeph">x</code> is insignificant:</p>
<pre dir="ltr">sql_stmt := &#39;INSERT INTO payroll VALUES (:x, :x, :y, :x)&#39;;
</pre>
<p>In the corresponding <code class="codeph">USING</code> clause, you must supply four bind variables. They can be different; for example:</p>
<pre dir="ltr">EXECUTE IMMEDIATE sql_stmt USING a, b, c, d;
</pre>
<p>The preceding <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement runs this SQL statement:</p>
<pre dir="ltr">INSERT INTO payroll VALUES (a, b, c, d)
</pre>
<p>To associate the same bind variable with each occurrence of :<code class="codeph">x</code>, you must repeat that bind variable; for example:</p>
<pre dir="ltr">EXECUTE IMMEDIATE sql_stmt USING a, a, b, a;
</pre>
<p>The preceding <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement runs this SQL statement:</p>
<pre dir="ltr">INSERT INTO payroll VALUES (a, a, b, a)
</pre></div>
</div>
<a id="LNPLS634"></a><a id="LNPLS633"></a>
<div class="props_rev_3"><a id="GUID-A31BBD6E-1CB5-47D2-A01B-48DC3BE203C7"></a>
<h4 id="LNPLS-GUID-A31BBD6E-1CB5-47D2-A01B-48DC3BE203C7" class="sect4">Dynamic SQL Statement is Anonymous Block or CALL Statement</h4>
<div>
<p>If the dynamic SQL statement represents an anonymous PL/SQL block or a <code class="codeph">CALL</code> statement, repetition of placeholder names is significant.</p>
<p>Each unique placeholder name must have a corresponding bind variable in the <code class="codeph">USING</code> clause. If you repeat a placeholder name, you need not repeat its corresponding bind variable. All references to that placeholder name correspond to one bind variable in the <code class="codeph">USING</code> clause.</p>
<div class="example" id="GUID-A31BBD6E-1CB5-47D2-A01B-48DC3BE203C7__CHDFHEAG">
<p class="titleinexample">Example 7-10 Repeated Placeholder Names in Dynamic PL/SQL Block</p>
<p>In this example, all references to the first unique placeholder name, :<code class="codeph">x</code>, are associated with the first bind variable in the <code class="codeph">USING</code> clause, <code class="codeph">a</code>, and the second unique placeholder name, :<code class="codeph">y</code>, is associated with the second bind variable in the <code class="codeph">USING</code> clause, <code class="codeph">b</code>.</p>
<pre dir="ltr">CREATE PROCEDURE calc_stats (
  w NUMBER,
  x NUMBER,
  y NUMBER,
  z NUMBER )
IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(w + x + y + z);
END;
/
DECLARE
  a NUMBER := 4;
  b NUMBER := 7;
  plsql_block VARCHAR2(100);
BEGIN
  plsql_block := &#39;BEGIN calc_stats(:x, :x, :y, :x); END;&#39;;
  EXECUTE IMMEDIATE plsql_block USING a, b;  <span class="bold">-- calc_stats(a, a, b, a)</span>
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
<a id="LNPLS2173"></a><a id="LNPLS01108"></a>
<div class="props_rev_3"><a id="GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B"></a>
<h2 id="LNPLS-GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B" class="sect2">DBMS_SQL Package</h2>
<div>
<p>The&nbsp;DBMS_SQL&nbsp;package defines an entity called a&nbsp;SQL cursor number. Because the SQL cursor number is a PL/SQL integer, you can pass it across call boundaries and store it.</p>
<p>You must use the <code class="codeph">DBMS_SQL</code> package to run a dynamic SQL statement if any of the following are true:</p>
<ul style="list-style-type: disc;">
<li>
<p>You do not know the <code class="codeph">SELECT</code> list until run time.</p>
</li>
<li>
<p>You do not know until run time what placeholders in a <code class="codeph">SELECT</code> or DML statement must be bound.</p>
</li>
<li>
<p>You want a stored subprogram to return a query result implicitly (not through an <code class="codeph">OUT</code> <code class="codeph">REF</code> <code class="codeph">CURSOR</code> parameter), which requires the <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> procedure.</p>
</li>
</ul>
<p>In these situations, you must use native dynamic SQL instead of the <code class="codeph">DBMS_SQL</code> package:</p>
<ul style="list-style-type: disc;">
<li>
<p>The dynamic SQL statement retrieves rows into records.</p>
</li>
<li>
<p>You want to use the SQL cursor attribute <code class="codeph">%FOUND</code>, <code class="codeph">%ISOPEN</code>, <code class="codeph">%NOTFOUND</code>, or <code class="codeph">%ROWCOUNT</code> after issuing a dynamic SQL statement that is an <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, <code class="codeph">MERGE</code>, or single-row <code class="codeph">SELECT</code> statement.</p>
</li>
</ul>
<p>When you need both the <code class="codeph">DBMS_SQL</code> package and native dynamic SQL, you can switch between them, using the functions <code class="codeph">DBMS_SQL</code>.<code class="codeph">TO_REFCURSOR</code> and <code class="codeph">DBMS_SQL</code>.<code class="codeph">TO_CURSOR_NUMBER</code>.</p>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="dynamic.htm#GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B">DBMS_SQL.RETURN_RESULT Procedure</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61">DBMS_SQL.GET_NEXT_RESULT Procedure</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-A194C9FA-221A-466B-9179-6238FEC5143B">DBMS_SQL.TO_REFCURSOR Function</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF">DBMS_SQL.TO_CURSOR_NUMBER Function</a></p>
</li>
</ul>
<div class="infobox-note" id="GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B__GUID-05B48BB9-8E56-451E-A4DD-8E3A6047E821">
<p class="notep1">Note:</p>
<p>You can invoke <code class="codeph">DBMS_SQL</code> subprograms remotely.</p>
</div>
<div class="infoboxnotealso" id="GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B__GUID-9361F58E-E823-4C88-8DA9-00B9EAD77BEA">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="q">&#34;<a href="dynamic.htm#GUID-D2613968-6660-4AA2-9057-28E425A3040D" title="Native dynamic SQL processes most dynamic SQL statements with the EXECUTE IMMEDIATE statement.">Native Dynamic SQL</a>&#34;</span>for information about native dynamic SQL</p>
</li>
<li>
<p><a class="olink ARPLS058" target="_blank" href="../ARPLS/d_sql.htm#ARPLS058"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code class="codeph">DBMS_SQL</code> package, including instructions for running a dynamic SQL statement that has an unknown number of input or output variables (&#34;Method 4&#34;)</p>
</li>
</ul>
</div>
</div>
<!-- class="section" --></div>
<a id="LNPLS2175"></a><a id="LNPLS2174"></a>
<div class="props_rev_3"><a id="GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B"></a>
<h3 id="LNPLS-GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B" class="sect3">DBMS_SQL.RETURN_RESULT Procedure</h3>
<div>
<p>The <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> procedure lets a stored subprogram return a query result implicitly to either the client program (which invokes the subprogram indirectly) or the immediate caller of the subprogram. After <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> returns the result, only the recipient can access it.</p>
<p>The <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> has two overloads:</p>
<pre dir="ltr">PROCEDURE RETURN_RESULT (rc IN OUT <span class="bold">SYS_REFCURSOR</span>,
                         to_client IN BOOLEAN DEFAULT TRUE);

PROCEDURE RETURN_RESULT (rc IN OUT <span class="bold">INTEGER</span>,
                         to_client IN BOOLEAN DEFAULT TRUE);
</pre>
<p>The <code class="codeph">rc</code> parameter is either an open cursor variable (<code class="codeph">SYS_REFCURSOR</code>) or the cursor number (<code class="codeph">INTEGER</code>) of an open cursor. To open a cursor and get its cursor number, invoke the <code class="codeph">DBMS_SQL</code>.<code class="codeph">OPEN_CURSOR</code> function, described in <a class="olink ARPLS68275" target="_blank" href="../ARPLS/d_sql.htm#ARPLS68275"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
<p>When the <code class="codeph">to_client</code> parameter is <code class="codeph">TRUE</code> (the default), the <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> procedure returns the query result to the client program (which invokes the subprogram indirectly); when this parameter is <code class="codeph">FALSE</code>, the procedure returns the query result to the subprogram&#39;s immediate caller.</p>
<div class="infoboxnotealso" id="GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B__GUID-408BA65C-2409-4206-B3EC-27A403EA4EB7">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink ARPLS73893" target="_blank" href="../ARPLS/d_sql.htm#ARPLS73893"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code></p>
</li>
<li>
<p><a class="olink LNOCI73008" target="_blank" href="../LNOCI/oci10new.htm#LNOCI73008"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for information about C and .NET support for implicit query results</p>
</li>
<li>
<p><a class="olink SQPUG200" target="_blank" href="../SQPUG/ch_five.htm#SQPUG200"><span class="italic">SQL*Plus User&#39;s Guide and Reference</span></a> for information about SQL*Plus support for implicit query results</p>
</li>
<li>
<p><a class="olink DRDAA230" target="_blank" href="../DRDAA/migr_tools_feat.htm#DRDAA230"><span class="italic">Oracle Database Migration Guide</span></a> for information about migrating subprograms that use implicit query results</p>
</li>
</ul>
</div>
<div class="example" id="GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B__CHDFBIBJ">
<p class="titleinexample">Example 7-11 DBMS_SQL.RETURN_RESULT Procedure</p>
<p>In this example, the procedure <code class="codeph">p</code> invokes <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> without the optional <code class="codeph">to_client</code> parameter (which is <code class="codeph">TRUE</code> by default). Therefore, <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> returns the query result to the subprogram client (the anonymous block that invokes <code class="codeph">p</code>). After <code class="codeph">p</code> returns a result to the anonymous block, only the anonymous block can access that result.</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE p AUTHID DEFINER AS
  c1 SYS_REFCURSOR;
  c2 SYS_REFCURSOR;
BEGIN
  OPEN c1 FOR
    SELECT first_name, last_name
    FROM employees
    WHERE employee_id = 176;
 
  <span class="bold">DBMS_SQL.RETURN_RESULT (c1);</span>
  <span class="bold">-- Now p cannot access the result.</span>
 
  OPEN c2 FOR
    SELECT city, state_province
    FROM locations
    WHERE country_id = &#39;AU&#39;;
 
  <span class="bold">DBMS_SQL.RETURN_RESULT (c2);</span>
  <span class="bold">-- Now p cannot access the result.</span>
END;
/
BEGIN
  p;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">ResultSet #1

FIRST_NAME           LAST_NAME
-------------------- -------------------------
Jonathon             Taylor

ResultSet #2

CITY                           STATE_PROVINCE
------------------------------ -------------------------
Sydney                         New South Wales
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS2177"></a><a id="LNPLS2176"></a>
<div class="props_rev_3"><a id="GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61"></a>
<h3 id="LNPLS-GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61" class="sect3">DBMS_SQL.GET_NEXT_RESULT Procedure</h3>
<div>
<p>The <code class="codeph">DBMS_SQL</code>.<code class="codeph">GET_NEXT_RESULT</code> procedure gets the next result that the <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> procedure returned to the recipient. The two procedures return results in the same order.</p>
<p>The <code class="codeph">DBMS_SQL</code>.<code class="codeph">GET_NEXT_RESULT</code> has two overloads:</p>
<pre dir="ltr">PROCEDURE GET_NEXT_RESULT (c IN INTEGER, rc OUT <span class="bold">SYS_REFCURSOR</span>);

PROCEDURE GET_NEXT_RESULT (c IN INTEGER, rc OUT <span class="bold">INTEGER</span>);
</pre>
<p>The <code class="codeph">c</code> parameter is the cursor number of an open cursor that directly or indirectly invokes a subprogram that uses the <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> procedure to return a query result implicitly.</p>
<p>To open a cursor and get its cursor number, invoke the <code class="codeph">DBMS_SQL</code>.<code class="codeph">OPEN_CURSOR</code> function. <code class="codeph">DBMS_SQL</code>.<code class="codeph">OPEN_CURSOR</code> has an optional parameter, <code class="codeph">treat_as_client_for_results</code>. When this parameter is <code class="codeph">FALSE</code> (the default), the caller that opens this cursor (to invoke a subprogram) is not treated as the client that receives query results for the client from the subprogram that uses <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code>&mdash;those query results are returned to the client in a upper tier instead. When this parameter is <code class="codeph">TRUE</code>, the caller is treated as the client. For more information about the <code class="codeph">DBMS_SQL</code>.<code class="codeph">OPEN_CURSOR</code> function, see <a class="olink ARPLS68275" target="_blank" href="../ARPLS/d_sql.htm#ARPLS68275"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
<p>The <code class="codeph">rc</code> parameter is either a cursor variable (<code class="codeph">SYS_REFCURSOR</code>) or the cursor number (<code class="codeph">INTEGER</code>) of an open cursor.</p>
<p>In <a href="dynamic.htm#GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61__CHDBBIFI">Example 7-12</a>, the procedure <code class="codeph">get_employee_info</code> uses <code class="codeph">DBMS_SQL</code>.<code class="codeph">RETURN_RESULT</code> to return two query results to a client program and is invoked dynamically by the anonymous block <code class="codeph">&lt;&lt;main&gt;&gt;</code>. Because <code class="codeph">&lt;&lt;main&gt;&gt;</code> needs to receive the two query results that <code class="codeph">get_employee_info</code> returns, <code class="codeph">&lt;&lt;main&gt;&gt;</code> opens a cursor to invoke <code class="codeph">get_employee_info</code> using <code class="codeph">DBMS_SQL</code>.<code class="codeph">OPEN_CURSOR</code> with the parameter <code class="codeph">treat_as_client_for_results</code> set to <code class="codeph">TRUE</code>. Therefore, <code class="codeph">DBMS_SQL</code>.<code class="codeph">GET_NEXT_RESULT</code> returns its results to <code class="codeph">&lt;&lt;main&gt;&gt;</code>, which uses the cursor <code class="codeph">rc</code> to fetch them.</p>
<div class="example" id="GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61__CHDBBIFI">
<p class="titleinexample">Example 7-12 DBMS_SQL.GET_NEXT_RESULT Procedure</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE get_employee_info (id IN VARCHAR2) AUTHID DEFINER AS
  rc  SYS_REFCURSOR;
BEGIN
  -- Return employee info
 
  OPEN rc FOR SELECT first_name, last_name, email, phone_number
              FROM employees
              WHERE employee_id = id;
  <span class="bold">DBMS_SQL.RETURN_RESULT(rc);</span>
 
  -- Return employee job history
 
  OPEN RC FOR SELECT job_title, start_date, end_date
              FROM job_history jh, jobs j
              WHERE jh.employee_id = id AND
                    jh.job_id = j.job_id
              ORDER BY start_date DESC;
  <span class="bold">DBMS_SQL.RETURN_RESULT(rc);</span>
END;
/
<span class="bold">&lt;&lt;main&gt;&gt;</span>
DECLARE
  c            INTEGER;
  rc           SYS_REFCURSOR;
  n            NUMBER;
 
  first_name   VARCHAR2(20);
  last_name    VARCHAR2(25);
  email        VARCHAR2(25);
  phone_number VARCHAR2(20);
 
  job_title    VARCHAR2(35);
  start_date   DATE;
  end_date     DATE;
 
BEGIN
 
  <span class="bold">c := DBMS_SQL.OPEN_CURSOR(true);</span>
  DBMS_SQL.PARSE(<span class="bold">c</span>, &#39;<span class="bold">BEGIN get_employee_info(:id); END;</span>&#39;, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_VARIABLE(c, &#39;:id&#39;, 176);
  n := DBMS_SQL.EXECUTE(c);
 
  -- Get employee info
 
  <span class="bold">dbms_sql.get_next_result(c, rc);</span>
  <span class="bold">FETCH rc INTO first_name, last_name, email, phone_number;</span>
 
  DBMS_OUTPUT.PUT_LINE(&#39;Employee: &#39;||first_name || &#39; &#39; || last_name);
  DBMS_OUTPUT.PUT_LINE(&#39;Email: &#39; ||email);
  DBMS_OUTPUT.PUT_LINE(&#39;Phone: &#39; ||phone_number);
 
  -- Get employee job history
 
  DBMS_OUTPUT.PUT_LINE(&#39;Titles:&#39;);
  <span class="bold">DBMS_SQL.GET_NEXT_RESULT(c, rc);</span>
  LOOP
    <span class="bold">FETCH rc INTO job_title, start_date, end_date;</span>
    EXIT WHEN rc%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE
      (&#39;- &#39;||job_title||&#39; (&#39;||start_date||&#39; - &#39; ||end_date||&#39;)&#39;);
  END LOOP;
 
  DBMS_SQL.CLOSE_CURSOR(c);
END main;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Employee: Jonathon Taylor
Email: JTAYLOR
Phone: 011.44.1644.429265
Titles:
- Sales Manager (01-JAN-07 - 31-DEC-07)
- Sales Representative (24-MAR-06 - 31-DEC-06)
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS635"></a><a id="LNPLS01113"></a>
<div class="props_rev_3"><a id="GUID-A194C9FA-221A-466B-9179-6238FEC5143B"></a>
<h3 id="LNPLS-GUID-A194C9FA-221A-466B-9179-6238FEC5143B" class="sect3">DBMS_SQL.TO_REFCURSOR Function</h3>
<div>
<p>The <code class="codeph">DBMS_SQL</code>.<code class="codeph">TO_REFCURSOR</code> function converts a SQL cursor number to a weak cursor variable, which you can use in native dynamic SQL statements.</p>
<p>Before passing a SQL cursor number to the <code class="codeph">DBMS_SQL</code>.<code class="codeph">TO_REFCURSOR</code> function, you must <code class="codeph">OPEN</code>, <code class="codeph">PARSE</code>, and <code class="codeph">EXECUTE</code> it (otherwise an error occurs).</p>
<p>After you convert a SQL cursor number to a <code class="codeph">REF</code> <code class="codeph">CURSOR</code> variable, <code class="codeph">DBMS_SQL</code> operations can access it only as the <code class="codeph">REF</code> <code class="codeph">CURSOR</code> variable, not as the SQL cursor number. For example, using the <code class="codeph">DBMS_SQL</code>.<code class="codeph">IS_OPEN</code> function to see if a converted SQL cursor number is still open causes an error.</p>
<p><a href="dynamic.htm#GUID-A194C9FA-221A-466B-9179-6238FEC5143B__g1777282">Example 7-13</a> uses the <code class="codeph">DBMS_SQL</code>.<code class="codeph">TO_REFCURSOR</code> function to switch from the <code class="codeph">DBMS_SQL</code> package to native dynamic SQL.</p>
<div class="example" id="GUID-A194C9FA-221A-466B-9179-6238FEC5143B__g1777282">
<p class="titleinexample">Example 7-13 Switching from DBMS_SQL Package to Native Dynamic SQL</p>
<pre dir="ltr">CREATE OR REPLACE TYPE vc_array IS TABLE OF VARCHAR2(200);
/
CREATE OR REPLACE TYPE numlist IS TABLE OF NUMBER;
/
CREATE OR REPLACE PROCEDURE do_query_1 (
  placeholder vc_array,
  bindvars vc_array,
  sql_stmt VARCHAR2
) AUTHID DEFINER
IS
  TYPE curtype IS REF CURSOR;
  src_cur     curtype;
  curid       NUMBER;
  bindnames   vc_array;
  empnos      numlist;
  depts       numlist;
  ret         NUMBER;
  isopen      BOOLEAN;
BEGIN
  <span class="bold">-- Open SQL cursor number:</span>
  curid := DBMS_SQL.OPEN_CURSOR;

  <span class="bold">-- Parse SQL cursor number:</span>
  DBMS_SQL.PARSE(curid, sql_stmt, DBMS_SQL.NATIVE);

  bindnames := placeholder;

  -- Bind variables:
  FOR i IN 1 .. bindnames.COUNT LOOP
    DBMS_SQL.BIND_VARIABLE(curid, bindnames(i), bindvars(i));
  END LOOP;

  <span class="bold">-- Run SQL cursor number:</span>
  ret := DBMS_SQL.EXECUTE(curid);

  <span class="bold">-- Switch from DBMS_SQL to native dynamic SQL:</span>
  src_cur := DBMS_SQL.TO_REFCURSOR(curid);
  FETCH src_cur BULK COLLECT INTO empnos, depts;

  <span class="bold">-- This would cause an error because curid was converted to a REF CURSOR:</span>
  -- isopen := DBMS_SQL.IS_OPEN(curid);

  CLOSE src_cur;
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS636"></a><a id="LNPLS00001"></a>
<div class="props_rev_3"><a id="GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF"></a>
<h3 id="LNPLS-GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF" class="sect3">DBMS_SQL.TO_CURSOR_NUMBER Function</h3>
<div>
<p>The <code class="codeph">DBMS_SQL</code>.<code class="codeph">TO_CURSOR_NUMBER</code> function converts a <code class="codeph">REF</code> <code class="codeph">CURSOR</code> variable (either strong or weak) to a SQL cursor number, which you can pass to <code class="codeph">DBMS_SQL</code> subprograms.</p>
<p>Before passing a <code class="codeph">REF</code> <code class="codeph">CURSOR</code> variable to the <code class="codeph">DBMS_SQL</code>.<code class="codeph">TO_CURSOR_NUMBER</code> function, you must <code class="codeph">OPEN</code> it.</p>
<p>After you convert a <code class="codeph">REF</code> <code class="codeph">CURSOR</code> variable to a SQL cursor number, native dynamic SQL operations cannot access it.</p>
<p><a href="dynamic.htm#GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF__BHCHJBHJ">Example 7-14</a> uses the <code class="codeph">DBMS_SQL</code>.<code class="codeph">TO_CURSOR_NUMBER</code> function to switch from native dynamic SQL to the <code class="codeph">DBMS_SQL</code> package.</p>
<div class="example" id="GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF__BHCHJBHJ">
<p class="titleinexample">Example 7-14 Switching from Native Dynamic SQL to DBMS_SQL Package</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE do_query_2 (
  sql_stmt VARCHAR2
) AUTHID DEFINER
IS
  TYPE curtype IS REF CURSOR;
  src_cur   curtype;
  curid     NUMBER;
  desctab   DBMS_SQL.DESC_TAB;
  colcnt    NUMBER;
  namevar   VARCHAR2(50);
  numvar    NUMBER;
  datevar   DATE;
  empno     NUMBER := 100;
BEGIN
  -- sql_stmt := SELECT ... FROM employees WHERE employee_id = :b1&#39;;

  <span class="bold">-- Open REF CURSOR variable:</span>
  OPEN src_cur FOR sql_stmt USING empno;

  <span class="bold">-- Switch from native dynamic SQL to DBMS_SQL package:</span>
  curid := DBMS_SQL.TO_CURSOR_NUMBER(src_cur);
  DBMS_SQL.DESCRIBE_COLUMNS(curid, colcnt, desctab);

  -- Define columns:
  FOR i IN 1 .. colcnt LOOP
    IF desctab(i).col_type = 2 THEN
      DBMS_SQL.DEFINE_COLUMN(curid, i, numvar);
    ELSIF desctab(i).col_type = 12 THEN
      DBMS_SQL.DEFINE_COLUMN(curid, i, datevar);
      -- statements
    ELSE
      DBMS_SQL.DEFINE_COLUMN(curid, i, namevar, 50);
    END IF;
  END LOOP;

  -- Fetch rows with DBMS_SQL package:
  WHILE DBMS_SQL.FETCH_ROWS(curid) &gt; 0 LOOP
    FOR i IN 1 .. colcnt LOOP
      IF (desctab(i).col_type = 1) THEN
        DBMS_SQL.COLUMN_VALUE(curid, i, namevar);
      ELSIF (desctab(i).col_type = 2) THEN
        DBMS_SQL.COLUMN_VALUE(curid, i, numvar);
      ELSIF (desctab(i).col_type = 12) THEN
        DBMS_SQL.COLUMN_VALUE(curid, i, datevar);
        -- statements
      END IF;
    END LOOP;
  END LOOP;

  DBMS_SQL.CLOSE_CURSOR(curid);
END;
/
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS521"></a><a id="LNPLS637"></a><a id="LNPLS01109"></a>
<div class="props_rev_3"><a id="GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C"></a>
<h2 id="LNPLS-GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C" class="sect2">SQL Injection</h2>
<div>
<p>SQL injection maliciously exploits applications that use client-supplied data in SQL statements, thereby gaining unauthorized access to a database to view or manipulate restricted data.</p>
<p>This section describes SQL injection vulnerabilities in PL/SQL and explains how to guard against them.</p>
<div class="section">
<p class="subhead2">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="dynamic.htm#GUID-9353B33A-460A-4D4F-8FFF-FFF06A8C68D5" title="All SQL injection techniques exploit a single vulnerability: String input is not correctly validated and is concatenated into a dynamic SQL statement.">SQL Injection Techniques</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-4503110E-DF12-487E-B613-6890CC55B6CD" title="If you use dynamic SQL in your PL/SQL applications, you must check the input text to ensure that it is exactly what you expected.">Guards Against SQL Injection</a></p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="example" id="GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C__CHDBJCFF">
<p class="titleinexample">Example 7-15 Setup for SQL Injection Examples</p>
<p>To try the examples, run these statements.</p>
<div class="infobox-note" id="GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C__GUID-38E9A2F6-64C1-49E1-B4CF-50224D594ECD">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-dynamic-sql/tdlnplsdynamic3.html" target="_blank">SQL Injection Demo</a></p>
</div>
<pre dir="ltr">DROP TABLE secret_records;
CREATE TABLE secret_records (
  user_name    VARCHAR2(9),
  service_type VARCHAR2(12),
  value        VARCHAR2(30),
  date_created DATE
);

INSERT INTO secret_records (
  user_name, service_type, value, date_created
)
VALUES (&#39;Andy&#39;, &#39;Waiter&#39;, &#39;Serve dinner at Cafe Pete&#39;, SYSDATE);
 
INSERT INTO secret_records (
  user_name, service_type, value, date_created
)
VALUES (&#39;Chuck&#39;, &#39;Merger&#39;, &#39;Buy company XYZ&#39;, SYSDATE);
</pre></div>
<!-- class="example" --></div>
<a id="LNPLS522"></a><a id="LNPLS638"></a>
<div class="props_rev_3"><a id="GUID-9353B33A-460A-4D4F-8FFF-FFF06A8C68D5"></a>
<h3 id="LNPLS-GUID-9353B33A-460A-4D4F-8FFF-FFF06A8C68D5" class="sect3">SQL Injection Techniques</h3>
<div>
<p>All SQL injection techniques exploit a single vulnerability: String input is not correctly validated and is concatenated into a dynamic SQL statement.</p>
<div class="section">
<p class="subhead3">Topics</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><a href="dynamic.htm#GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F" title="Statement modification means deliberately altering a dynamic SQL statement so that it runs in a way unintended by the application developer.">Statement Modification</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C" title="Statement injection means that a user appends one or more SQL statements to a dynamic SQL statement.">Statement Injection</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75" title="A less known SQL injection technique uses NLS session parameters to modify or inject SQL statements.">Data Type Conversion</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="LNPLS640"></a><a id="LNPLS639"></a>
<div class="props_rev_3"><a id="GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F"></a>
<h4 id="LNPLS-GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F" class="sect4">Statement Modification</h4>
<div>
<p><span class="bold">Statement modification</span> means deliberately altering a dynamic SQL statement so that it runs in a way unintended by the application developer.</p>
<p>Typically, the user retrieves unauthorized data by changing the <code class="codeph">WHERE</code> clause of a <code class="codeph">SELECT</code> statement or by inserting a <code class="codeph">UNION</code> <code class="codeph">ALL</code> clause. The classic example of this technique is bypassing password authentication by making a <code class="codeph">WHERE</code> clause always <code class="codeph">TRUE</code>.</p>
<div class="example" id="GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F__BJEJABIC">
<p class="titleinexample">Example 7-16 Procedure Vulnerable to Statement Modification</p>
<p>This example creates a procedure that is vulnerable to statement modification and then invokes that procedure with and without statement modification. With statement modification, the procedure returns a supposedly secret record.</p>
<div class="infobox-note" id="GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F__GUID-38E9A2F6-64C1-49E1-B4CF-50224D594ECD">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-dynamic-sql/tdlnplsdynamic3.html" target="_blank">SQL Injection Demo</a></p>
</div>
<p>Create vulnerable procedure:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE get_record (
  user_name    IN  VARCHAR2,
  service_type IN  VARCHAR2,
  rec          OUT VARCHAR2
) AUTHID DEFINER
IS
  query VARCHAR2(4000);
BEGIN
  <span class="bold">-- Following SELECT statement is vulnerable to modification</span>
  <span class="bold">-- because it uses concatenation to build WHERE clause.</span>
  query := &#39;SELECT value FROM secret_records WHERE user_name=&#39;&#39;&#39;
           || user_name 
           || &#39;&#39;&#39; AND service_type=&#39;&#39;&#39; 
           || service_type 
           || &#39;&#39;&#39;&#39;;
  DBMS_OUTPUT.PUT_LINE(&#39;Query: &#39; || query);
  EXECUTE IMMEDIATE query INTO rec ;
  DBMS_OUTPUT.PUT_LINE(&#39;Rec: &#39; || rec );
END;
/
</pre>
<p>Demonstrate procedure without SQL injection:</p>
<pre dir="ltr">SET SERVEROUTPUT ON;

DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_record(&#39;Andy&#39;, &#39;Waiter&#39;, record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Query: SELECT value FROM secret_records WHERE user_name=&#39;Andy&#39; AND
service_type=&#39;Waiter&#39;
Rec: Serve dinner at Cafe Pete
 
</pre>
<p>Example of statement modification:</p>
<pre dir="ltr">DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_record(
  <span class="bold">&#39;Anybody &#39;&#39; OR service_type=&#39;&#39;Merger&#39;&#39;--&#39;,</span>
  &#39;Anything&#39;,
  record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">Query: SELECT value FROM secret_records WHERE user_name=&#39;Anybody &#39; OR</span>
<span class="bold">service_type=&#39;Merger&#39;--&#39; AND service_type=&#39;Anything&#39;</span>
<span class="bold">Rec: Buy company XYZ</span>

PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS642"></a><a id="LNPLS641"></a>
<div class="props_rev_3"><a id="GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C"></a>
<h4 id="LNPLS-GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C" class="sect4">Statement Injection</h4>
<div>
<p><span class="bold">Statement injection</span> means that a user appends one or more SQL statements to a dynamic SQL statement.</p>
<p>Anonymous PL/SQL blocks are vulnerable to this technique.</p>
<div class="example" id="GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C__BJEHHAFF">
<p class="titleinexample">Example 7-17 Procedure Vulnerable to Statement Injection</p>
<p>This example creates a procedure that is vulnerable to statement injection and then invokes that procedure with and without statement injection. With statement injection, the procedure deletes the supposedly secret record exposed in <a href="dynamic.htm#GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F__BJEJABIC">Example 7-16</a>.</p>
<div class="infobox-note" id="GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C__GUID-38E9A2F6-64C1-49E1-B4CF-50224D594ECD">
<p class="notep1">Live SQL:</p>
<p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-dynamic-sql/tdlnplsdynamic3.html" target="_blank">SQL Injection Demo</a></p>
</div>
<p>Create vulnerable procedure:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE p (
  user_name    IN  VARCHAR2,
  service_type IN  VARCHAR2
) AUTHID DEFINER
IS
  block1 VARCHAR2(4000);
BEGIN
  <span class="bold">-- Following block is vulnerable to statement injection</span>
  <span class="bold">-- because it is built by concatenation.</span>
  block1 :=
    &#39;BEGIN
    DBMS_OUTPUT.PUT_LINE(&#39;&#39;user_name: &#39; || user_name || &#39;&#39;&#39;);&#39;
    || &#39;DBMS_OUTPUT.PUT_LINE(&#39;&#39;service_type: &#39; || service_type || &#39;&#39;&#39;);
    END;&#39;;

  DBMS_OUTPUT.PUT_LINE(&#39;Block1: &#39; || block1);
  
  EXECUTE IMMEDIATE block1;
END;
/
</pre>
<p>Demonstrate procedure without SQL injection:</p>
<pre dir="ltr">SET SERVEROUTPUT ON;

BEGIN
  p(&#39;Andy&#39;, &#39;Waiter&#39;);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Block1: BEGIN
         DBMS_OUTPUT.PUT_LINE(&#39;user_name: Andy&#39;);
         DBMS_OUTPUT.PUT_LINE(&#39;service_type: Waiter&#39;);
       END;
user_name: Andy
service_type: Waiter
</pre>
<p>SQL*Plus formatting command:</p>
<pre dir="ltr">COLUMN date_created FORMAT A12;
</pre>
<p>Query:</p>
<pre dir="ltr"><span class="bold">SELECT * FROM secret_records ORDER BY user_name;</span>
</pre>
<p>Result:</p>
<pre dir="ltr">USER_NAME SERVICE_TYPE VALUE                          DATE_CREATED
--------- ------------ ------------------------------ ------------
Andy      Waiter       Serve dinner at Cafe Pete      28-APR-10
Chuck     Merger       Buy company XYZ                28-APR-10
</pre>
<p>Example of statement modification:</p>
<pre dir="ltr">BEGIN
  p(&#39;Anybody&#39;, <span class="bold">&#39;Anything&#39;&#39;);</span>
  <span class="bold">DELETE FROM secret_records WHERE service_type=INITCAP(&#39;&#39;Merger&#39;</span>);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Block1: BEGIN
       DBMS_OUTPUT.PUT_LINE(&#39;user_name: Anybody&#39;);
       DBMS_OUTPUT.PUT_LINE(&#39;service_type: Anything<span class="bold">&#39;);</span>
       <span class="bold">DELETE FROM secret_records WHERE service_type=INITCAP(&#39;Merger&#39;</span>);
     END;
user_name: Anybody
service_type: Anything

PL/SQL procedure successfully completed.
</pre>
<p>Query:</p>
<pre dir="ltr"><span class="bold">SELECT * FROM secret_records;</span>
</pre>
<p>Result:</p>
<pre dir="ltr">USER_NAME SERVICE_TYPE VALUE                          DATE_CREATED
--------- ------------ ------------------------------ ------------
Andy      Waiter       Serve dinner at Cafe Pete      18-MAR-09
 
<span class="bold">1 row selected.</span>
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS644"></a><a id="LNPLS643"></a>
<div class="props_rev_3"><a id="GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75"></a>
<h4 id="LNPLS-GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75" class="sect4">Data Type Conversion</h4>
<div>
<p>A less known SQL injection technique uses NLS session parameters to modify or inject SQL statements.</p>
<p>A datetime or numeric value that is concatenated into the text of a dynamic SQL statement must be converted to the <code class="codeph">VARCHAR2</code> data type. The conversion can be either implicit (when the value is an operand of the concatenation operator) or explicit (when the value is the argument of the <code class="codeph">TO_CHAR</code> function). This data type conversion depends on the NLS settings of the database session that runs the dynamic SQL statement. The conversion of datetime values uses format models specified in the parameters <code class="codeph">NLS_DATE_FORMAT</code>, <code class="codeph">NLS_TIMESTAMP_FORMAT</code>, or <code class="codeph">NLS_TIMESTAMP_TZ_FORMAT</code>, depending on the particular datetime data type. The conversion of numeric values applies decimal and group separators specified in the parameter <code class="codeph">NLS_NUMERIC_CHARACTERS</code>.</p>
<p>One datetime format model is <code class="codeph">&#34;</code><span class="italic"><code class="codeph">text</code></span><code class="codeph">&#34;</code>. The <span class="italic"><code class="codeph">text</code></span> is copied into the conversion result. For example, if the value of <code class="codeph">NLS_DATE_FORMAT</code> is <code class="codeph">&#39;&#34;Month:&#34; Month&#39;</code>, then in June, <code class="codeph">TO_CHAR(SYSDATE)</code> returns <code class="codeph">&#39;Month: June&#39;</code>. The datetime format model can be abused as shown in <a href="dynamic.htm#GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75__CHDEIABG">Example 7-18</a>.</p>
<div class="example" id="GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75__CHDEIABG">
<p class="titleinexample">Example 7-18 Procedure Vulnerable to SQL Injection Through Data Type Conversion</p>
<pre dir="ltr">SELECT * FROM secret_records;
 
</pre>
<p>Result:</p>
<pre dir="ltr">USER_NAME SERVICE_TYPE VALUE                          DATE_CREATE
--------- ------------ ------------------------------ -----------
Andy      Waiter       Serve dinner at Cafe Pete      28-APR-2010
Chuck     Merger       Buy company XYZ                28-APR-2010
</pre>
<p>Create vulnerable procedure:</p>
<pre dir="ltr">-- Return records not older than a month

CREATE OR REPLACE PROCEDURE get_recent_record (
  user_name    IN  VARCHAR2,
  service_type IN  VARCHAR2,
  rec          OUT VARCHAR2
) AUTHID DEFINER
IS
  query VARCHAR2(4000);
BEGIN
  <span class="bold">/* Following SELECT statement is vulnerable to modification</span>
  <span class="bold">   because it uses concatenation to build WHERE clause</span>
  <span class="bold">   and because SYSDATE depends on the value of NLS_DATE_FORMAT. */</span>

  query := &#39;SELECT value FROM secret_records WHERE user_name=&#39;&#39;&#39;
           || user_name
           || &#39;&#39;&#39; AND service_type=&#39;&#39;&#39;
           || service_type
           || &#39;&#39;&#39; AND date_created&gt;&#39;&#39;&#39;
           || <span class="bold">(SYSDATE - 30)</span>
           || &#39;&#39;&#39;&#39;;

  DBMS_OUTPUT.PUT_LINE(&#39;Query: &#39; || query);
  EXECUTE IMMEDIATE query INTO rec;
  DBMS_OUTPUT.PUT_LINE(&#39;Rec: &#39; || rec);
END;
/
</pre>
<p>Demonstrate procedure without SQL injection:</p>
<pre dir="ltr">SET SERVEROUTPUT ON;
<span class="bold">ALTER SESSION SET NLS_DATE_FORMAT=&#39;DD-MON-YYYY&#39;;</span>

DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_recent_record(&#39;Andy&#39;, &#39;Waiter&#39;, record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Query: SELECT value FROM secret_records WHERE user_name=&#39;Andy&#39; AND
service_type=&#39;Waiter&#39; AND date_created&gt;&#39;29-MAR-2010&#39;
Rec: Serve dinner at Cafe Pete
  
</pre>
<p>Example of statement modification:</p>
<pre dir="ltr"><span class="bold">ALTER SESSION SET NLS_DATE_FORMAT=&#39;&#34;&#39;&#39; OR service_type=&#39;&#39;Merger&#34;&#39;;</span>

DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_recent_record(&#39;Anybody&#39;, &#39;Anything&#39;, record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">Query: SELECT value FROM secret_records WHERE user_name=&#39;Anybody&#39; AND</span>
<span class="bold">service_type=&#39;Anything&#39; AND date_created&gt;&#39;&#39; OR service_type=&#39;Merger&#39;</span>
<span class="bold">Rec: Buy company XYZ</span>
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="LNPLS645"></a>
<div class="props_rev_3"><a id="GUID-4503110E-DF12-487E-B613-6890CC55B6CD"></a>
<h3 id="LNPLS-GUID-4503110E-DF12-487E-B613-6890CC55B6CD" class="sect3">Guards Against SQL Injection</h3>
<div>
<p>If you use dynamic SQL in your PL/SQL applications, you must check the input text to ensure that it is exactly what you expected.</p>
<p>You can use the following techniques:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="dynamic.htm#GUID-EF9233BB-9570-453D-96EB-E13F43B10596" title="The most effective way to make your PL/SQL code invulnerable to SQL injection attacks is to use bind variables.">Bind Variables</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A" title="Always have your program validate user input to ensure that it is what is intended.">Validation Checks</a></p>
</li>
<li>
<p><a href="dynamic.htm#GUID-4DB96B62-75BE-424E-B6F7-BB0597FCAA58" title="Using explicit locale-independent format models to construct SQL is recommended not only from a security perspective, but also to ensure that the dynamic SQL statement runs correctly in any globalization environment.">Explicit Format Models</a></p>
</li>
</ul>
</div>
<a id="LNPLS647"></a><a id="LNPLS646"></a>
<div class="props_rev_3"><a id="GUID-EF9233BB-9570-453D-96EB-E13F43B10596"></a>
<h4 id="LNPLS-GUID-EF9233BB-9570-453D-96EB-E13F43B10596" class="sect4">Bind Variables</h4>
<div>
<p>The most effective way to make your PL/SQL code invulnerable to SQL injection attacks is to use bind variables.</p>
<p>The database uses the values of bind variables exclusively and does not interpret their contents in any way. (Bind variables also improve performance.)</p>
<div class="example" id="GUID-EF9233BB-9570-453D-96EB-E13F43B10596__BJEIJEBJ">
<p class="titleinexample">Example 7-19 Bind Variables Guarding Against SQL Injection</p>
<p>The procedure in this example is invulnerable to SQL injection because it builds the dynamic SQL statement with bind variables (not by concatenation as in the vulnerable procedure in <a href="dynamic.htm#GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F__BJEJABIC">Example 7-16</a>). The same binding technique fixes the vulnerable procedure shown in <a href="dynamic.htm#GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C__BJEHHAFF">Example 7-17</a>.</p>
<p>Create invulnerable procedure:</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE get_record_2 (
  user_name    IN  VARCHAR2,
  service_type IN  VARCHAR2,
  rec          OUT VARCHAR2
) AUTHID DEFINER
IS
  query VARCHAR2(4000);
BEGIN
  query := &#39;SELECT value FROM secret_records
            WHERE user_name=<span class="bold">:a</span>
            AND service_type=<span class="bold">:b</span>&#39;;
 
  DBMS_OUTPUT.PUT_LINE(&#39;Query: &#39; || query);
 
  EXECUTE IMMEDIATE query INTO rec <span class="bold">USING user_name, service_type</span>;
 
  DBMS_OUTPUT.PUT_LINE(&#39;Rec: &#39; || rec);
END;
/
 
</pre>
<p>Demonstrate procedure without SQL injection:</p>
<pre dir="ltr">SET SERVEROUTPUT ON;
DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_record_2(&#39;Andy&#39;, &#39;Waiter&#39;, record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Query: SELECT value FROM secret_records
            WHERE user_name=<span class="bold">:a</span>
            AND service_type=<span class="bold">:b</span>
Rec: Serve dinner at Cafe Pete
 
PL/SQL procedure successfully completed.
 
</pre>
<p>Try statement modification:</p>
<pre dir="ltr">DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_record_2(&#39;Anybody &#39;&#39; OR service_type=&#39;&#39;Merger&#39;&#39;--&#39;,
               &#39;Anything&#39;,
               record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Query: SELECT value FROM secret_records
            WHERE user_name=<span class="bold">:a</span>
            AND service_type=<span class="bold">:b</span>
DECLARE
*
<span class="bold">ERROR at line 1:</span>
<span class="bold">ORA-01403: no data found</span>
<span class="bold">ORA-06512: at &#34;HR.GET_RECORD_2&#34;, line 15</span>
<span class="bold">ORA-06512: at line 4</span>
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS649"></a><a id="LNPLS648"></a>
<div class="props_rev_3"><a id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A"></a>
<h4 id="LNPLS-GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A" class="sect4">Validation Checks</h4>
<div>
<p>Always have your program validate user input to ensure that it is what is intended.</p>
<p>For example, if the user is passing a department number for a <code class="codeph">DELETE</code> statement, check the validity of this department number by selecting from the <code class="codeph">departments</code> table. Similarly, if a user enters the name of a table to be deleted, check that this table exists by selecting from the static data dictionary view <code class="codeph">ALL_TABLES</code>.</p>
<div class="infobox-note" id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__GUID-EEBA64CB-B62B-4CE1-9661-F0AB2AC2E021">
<p class="notep1">Caution:</p>
<p>When checking the validity of a user name and its password, always return the same error regardless of which item is invalid. Otherwise, a malicious user who receives the error message &#34;invalid password&#34; but not &#34;invalid user name&#34; (or the reverse) can realize that he or she has guessed one of these correctly.</p>
</div>
<p>In validation-checking code, the subprograms in the <code class="codeph">DBMS_ASSERT</code> package are often useful. For example, you can use the <code class="codeph">DBMS_ASSERT</code>.<code class="codeph">ENQUOTE_LITERAL</code> function to enclose a string literal in quotation marks, as <a href="dynamic.htm#GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__CHDGJEGD">Example 7-20</a> does. This prevents a malicious user from injecting text between an opening quotation mark and its corresponding closing quotation mark.</p>
<div class="infobox-note" id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__GUID-4AD6631A-88F3-4964-9000-7C2FB39EC9B2">
<p class="notep1">Caution:</p>
<p>Although the <code class="codeph">DBMS_ASSERT</code> subprograms are useful in validation code, they do not replace it. For example, an input string can be a qualified SQL name (verified by <code class="codeph">DBMS_ASSERT</code>.<code class="codeph">QUALIFIED_SQL_NAME</code>) and still be a fraudulent password.</p>
</div>
<div class="infoboxnotealso" id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__GUID-B11BBB2F-639D-4520-9A31-8F6724B0DA3E">
<p class="notep1">See Also:</p>
<p><a class="olink ARPLS231" target="_blank" href="../ARPLS/d_assert.htm#ARPLS231"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about <code class="codeph">DBMS_ASSERT</code> subprograms</p>
</div>
<div class="example" id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__CHDGJEGD">
<p class="titleinexample">Example 7-20 Validation Checks Guarding Against SQL Injection</p>
<p>In this example, the procedure <code class="codeph">raise_emp_salary</code> checks the validity of the column name that was passed to it before it updates the <code class="codeph">employees</code> table, and then the anonymous block invokes the procedure from both a dynamic PL/SQL block and a dynamic SQL statement.</p>
<pre dir="ltr">CREATE OR REPLACE PROCEDURE raise_emp_salary (
  column_value  NUMBER,
  emp_column    VARCHAR2,
  amount NUMBER ) AUTHID DEFINER
IS
  v_column  VARCHAR2(30);
  sql_stmt  VARCHAR2(200);
BEGIN
  <span class="bold">-- Check validity of column name that was given as input:</span>
  SELECT column_name INTO v_column
  FROM USER_TAB_COLS
  WHERE TABLE_NAME = &#39;EMPLOYEES&#39;
  AND COLUMN_NAME = emp_column;

  sql_stmt := &#39;UPDATE employees SET salary = salary + :1 WHERE &#39;
    || <span class="bold">DBMS_ASSERT.ENQUOTE_NAME(v_column,FALSE)</span> || &#39; = :2&#39;;

  EXECUTE IMMEDIATE sql_stmt USING amount, column_value;

  <span class="bold">-- If column name is valid:</span>
  IF SQL%ROWCOUNT &gt; 0 THEN
    DBMS_OUTPUT.PUT_LINE(&#39;Salaries were updated for: &#39;
      || emp_column || &#39; = &#39; || column_value);
  END IF;

  <span class="bold">-- If column name is not valid:</span>
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      DBMS_OUTPUT.PUT_LINE (&#39;Invalid Column: &#39; || emp_column);
END raise_emp_salary;
/

DECLARE
  plsql_block  VARCHAR2(500);
BEGIN
  <span class="bold">-- Invoke raise_emp_salary from a dynamic PL/SQL block:</span>
  plsql_block :=
    &#39;BEGIN raise_emp_salary(:cvalue, :cname, :amt); END;&#39;;

  EXECUTE IMMEDIATE plsql_block
    USING 110, &#39;DEPARTMENT_ID&#39;, 10;

  <span class="bold">-- Invoke raise_emp_salary from a dynamic SQL statement:</span>
  EXECUTE IMMEDIATE &#39;BEGIN raise_emp_salary(:cvalue, :cname, :amt); END;&#39;
    USING 112, &#39;EMPLOYEE_ID&#39;, 10;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">Salaries were updated for: DEPARTMENT_ID = 110
Salaries were updated for: EMPLOYEE_ID = 112
</pre></div>
<!-- class="example" --></div>
</div>
<a id="LNPLS651"></a><a id="LNPLS650"></a>
<div class="props_rev_3"><a id="GUID-4DB96B62-75BE-424E-B6F7-BB0597FCAA58"></a>
<h4 id="LNPLS-GUID-4DB96B62-75BE-424E-B6F7-BB0597FCAA58" class="sect4">Explicit Format Models</h4>
<div>
<p>Using explicit locale-independent format models to construct SQL is recommended not only from a security perspective, but also to ensure that the dynamic SQL statement runs correctly in any globalization environment.</p>
<p>If you use datetime and numeric values that are concatenated into the text of a SQL or PL/SQL statement, and you cannot pass them as bind variables, convert them to text using explicit format models that are independent from the values of the NLS parameters of the running session. Ensure that the converted values have the format of SQL datetime or numeric literals.</p>
<div class="example" id="GUID-4DB96B62-75BE-424E-B6F7-BB0597FCAA58__CHDFIIEF">
<p class="titleinexample">Example 7-21 Explicit Format Models Guarding Against SQL Injection</p>
<p>This procedure is invulnerable to SQL injection because it converts the datetime parameter value, <code class="codeph">SYSDATE</code> <code class="codeph">-</code> <code class="codeph">30</code>, to a <code class="codeph">VARCHAR2</code> value explicitly, using the <code class="codeph">TO_CHAR</code> function and a locale-independent format model (not implicitly, as in the vulnerable procedure in <a href="dynamic.htm#GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75__CHDEIABG">Example 7-18</a>).</p>
<p>Create invulnerable procedure:</p>
<pre dir="ltr">-- Return records not older than a month

CREATE OR REPLACE PROCEDURE get_recent_record (
  user_name     IN  VARCHAR2,
  service_type  IN  VARCHAR2,
  rec           OUT VARCHAR2
) AUTHID DEFINER
IS
  query VARCHAR2(4000);
BEGIN
  /* Following SELECT statement is vulnerable to modification
     because it uses concatenation to build WHERE clause. */

  query := &#39;SELECT value FROM secret_records WHERE user_name=&#39;&#39;&#39;
           || user_name 
           || &#39;&#39;&#39; AND service_type=&#39;&#39;&#39; 
           || service_type 
           || &#39;&#39;&#39; AND date_created&gt; DATE &#39;&#39;&#39; 
           || <span class="bold">TO_CHAR(SYSDATE - 30,&#39;YYYY-MM-DD&#39;</span>) 
           || &#39;&#39;&#39;&#39;;

  DBMS_OUTPUT.PUT_LINE(&#39;Query: &#39; || query);
  EXECUTE IMMEDIATE query INTO rec;
  DBMS_OUTPUT.PUT_LINE(&#39;Rec: &#39; || rec);
END;
/
</pre>
<p>Try statement modification:</p>
<pre dir="ltr"><span class="bold">ALTER SESSION SET NLS_DATE_FORMAT=&#39;&#34;&#39;&#39; OR service_type=&#39;&#39;Merger&#34;&#39;;</span> 

DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_recent_record(&#39;Anybody&#39;, &#39;Anything&#39;, record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr"><span class="bold">Query: SELECT value FROM secret_records WHERE user_name=&#39;Anybody&#39; AND</span> 
<span class="bold">service_type=&#39;Anything&#39; AND date_created&gt; DATE &#39;2010-03-29&#39;</span> 
<span class="bold">DECLARE</span> 
<span class="bold">*</span> 
<span class="bold">ERROR at line 1:</span> 
<span class="bold">ORA-01403: no data found</span> 
<span class="bold">ORA-06512: at &#34;SYS.GET_RECENT_RECORD&#34;, line 21</span> 
<span class="bold">ORA-06512: at line 4</span> 
</pre></div>
<!-- class="example" --></div>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment869">
<tr>
<td class="cellalignment912">
<table class="cellalignment874">
<tr>
<td class="cellalignment873"><a href="static.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment873"><a href="subprograms.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment914">
<table class="cellalignment872">
<tr>
<td class="cellalignment873"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment873"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment873"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment873"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment873"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment873"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>