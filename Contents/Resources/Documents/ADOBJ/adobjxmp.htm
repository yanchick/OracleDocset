<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-749"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Sample%20Application%20Using%20Object-Relational%20Features"></a><title>Sample Application Using Object-Relational Features</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-08-06T13:19:6Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Object-Relational Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53277-02"/>
<meta name="dcterms.isVersionOf" content="ADOBJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="adobjdes.htm" title="Previous" type="text/html"/>
<link rel="Next" href="glossary.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53277-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/16</span> <!-- End Header -->
<div id="ADOBJ009" class="appendix"><a id="BABCCIBC"></a>
<h1 class="appendix"><span class="secnum">A</span> Sample Application Using Object-Relational Features</h1>
<p><a id="sthref868"></a><a id="sthref869"></a>This appendix describes a sample application that provides an overview of how to create and use user-defined data types (Oracle Objects). An application is first developed with the relational model and then with the object-relational model.</p>
<p>This appendix contains the following sections:</p>
<ul>
<li>
<p><a href="#i431307">Introduction to the Sample Application</a></p>
</li>
<li>
<p><a href="#i455735">Implementing the Schema on the Relational Model</a></p>
</li>
<li>
<p><a href="#i441766">Implementing the Schema on the Object-Relational Model</a></p>
</li>
<li>
<p><a href="#i454651">Evolving Object Types</a></p>
</li>
</ul>
<a id="i431307"></a>
<div id="ADOBJ00901" class="sect1">
<h2 class="sect1">Introduction to the Sample Application</h2>
<p>User-defined types are schema objects in which users formalize the data structures and operations that appear in their applications.</p>
<p>The examples in this appendix illustrate the most important aspects of defining, using, and evolving object types. One important aspect of working with object types is creating methods that perform operations on objects. In the example, definitions of object type methods use the PL/SQL language. Other aspects of using object types, such as defining a type, use SQL.</p>
<p>The examples develop different versions of a database schema for an application that manages customer purchase orders. First, a purely relational version is shown, and then, an equivalent, object-relational version. Both versions provide for the same basic kinds of entities&mdash;customers, purchase orders, line items, and so on. But the object-relational version creates object types for these entities and manages data for particular customers and purchase orders by instantiating instances of the respective object types.</p>
<p>PL/SQL and Java provide additional capabilities beyond those illustrated in this appendix, especially in the area of accessing and manipulating the elements of collections.</p>
<p>Client applications that use the Oracle Call Interface (OCI), Pro*C/C++, or Oracle Data Providers for .NET (ODP.NET) can take advantage of their extensive facilities for accessing objects and collections, and manipulating them on clients.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for a complete description of SQL syntax and usage for user-defined types</p>
</li>
<li>
<p><a class="olink LNPLS" href="../LNPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for a complete discussion of PL/SQL capabilities</p>
</li>
<li>
<p><a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a> for a complete discussion of Java</p>
</li>
<li>
<p><a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a></p>
</li>
<li>
<p><a class="olink LNPCC" href="../LNPCC/toc.htm"><span class="italic">Pro*C/C++ Programmer&#39;s Guide</span></a></p>
</li>
<li>
<p><a class="olink ODPNT" href="../ODPNT/toc.htm"><span class="italic">Oracle Data Provider for .NET Developer&#39;s Guide for Microsoft Windows</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i455735"></a>
<div id="ADOBJ00903" class="sect1">
<h2 class="sect1">Implementing the Schema on the Relational Model</h2>
<p>This section implements the relational version of the purchase order schema depicted in <a href="#i439604">Figure A-1</a>.</p>
<a id="i457015"></a>
<div id="ADOBJ7503" class="sect2">
<h3 class="sect2">Entities and Relationships</h3>
<p><a id="i457017"></a>The basic entities in this example are:</p>
<ul>
<li>
<p>Customers</p>
</li>
<li>
<p>The stock of products for sale</p>
</li>
<li>
<p>Purchase orders</p>
</li>
</ul>
<p>As shown in <a href="#i439604">Figure A-1</a>, a customer has contact information, so that the address and set of telephone numbers is exclusive to that customer. The application does not allow different customers to be associated with the same address or telephone numbers. If a customer changes his address, the previous address ceases to exist. If someone ceases to be a customer, the associated address disappears.</p>
<p>A customer has a one-to-many relationship with a purchase order. A customer can place many orders, but a given purchase order is placed by one customer. Because a customer can be defined before he places an order, the relationship is optional rather than mandatory.</p>
<p>Similarly, a purchase order has a many-to-many relationship with a stock item. Because this relationship does not show which stock items appear on which purchase orders, the entity-relationship has the notion of a line item. A purchase order must contain one or more line items. Each line item is associated only with one purchase order. The relationship between line item and stock item is that a stock item can appear on zero, one, or many line items, but each line item refers to exactly one stock item.</p>
<div id="ADOBJ7504" class="figure">
<p class="titleinfigure"><a id="i439604"></a>Figure A-1 Entity-Relationship Diagram for Purchase Order Application</p>
<img width="358" height="509" src="img/adobj001.gif" alt="Description of Figure A-1 follows"/><br/>
<a id="sthref870" href="img_text/adobj001.htm">Description of &#34;Figure A-1 Entity-Relationship Diagram for Purchase Order Application&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ADOBJ7505" class="sect2"><a id="sthref871"></a>
<h3 class="sect2">Creating Tables Under the Relational Model</h3>
<p>The relational approach <a href="glossary.htm#CHDDBECB"><span class="xrefglossterm">normalize</span></a> everything into tables. The table names are <code>Customer_reltab</code>, <code>PurchaseOrder_reltab</code>, and <code>Stock_reltab</code>.</p>
<p>Each part of an address becomes a column in the <code>Customer_reltab</code> table. Structuring telephone numbers as columns sets an arbitrary limit on the number of telephone numbers a customer can have.</p>
<p>The relational approach separates line items from their purchase orders and puts each into its own table, named <code>PurchaseOrder_reltab</code> and <code>LineItems_reltab</code>.</p>
<p>As depicted in <a href="#i439604">Figure A-1</a>, a line item has a relationship to both a purchase order and a stock item. These are implemented as columns in <code>LineItems_reltab</code> table with foreign keys to <code>PurchaseOrder_reltab</code> and <code>Stock_reltab</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
We have adopted a convention in this section of adding the suffix <code>_reltab</code> to the names of relational tables. Such a self-describing notation can make your code easier to maintain.
<p>You may find it useful to make distinctions between tables (<code>_tab</code>) and types (<code>_typ</code>). But you can choose any names you want; one of the advantages of object-relational constructs is that you can use names that closely model the corresponding real-world objects.</p>
</div>
<p>The relational approach results in the tables described in the following sections.</p>
<div id="ADOBJ7506" class="sect3"><a id="sthref872"></a>
<h4 class="sect3">Customer_reltab</h4>
<p>The <code>Customer_reltab</code> table has the following definition:</p>
<div id="ADOBJ7507" class="example">
<p class="titleinexample"><a id="i458008"></a>Example A-1 Creating the Customer_reltab Table</p>
<pre>CREATE TABLE Customer_reltab (
  CustNo                NUMBER NOT NULL,
  CustName              VARCHAR2(200) NOT NULL,
  Street                VARCHAR2(200) NOT NULL,
  City                  VARCHAR2(200) NOT NULL,
  State                 CHAR(2) NOT NULL,
  Zip                   VARCHAR2(20) NOT NULL,
  Phone1                VARCHAR2(20),
  Phone2                VARCHAR2(20),
  Phone3                VARCHAR2(20),
  PRIMARY KEY (CustNo));
</pre></div>
<!-- class="example" -->
<p>This table, <code>Customer_reltab</code>, stores all the information about customers, which means that it fully contains information that is intrinsic to the customer (defined with the <code>NOT</code> <code>NULL</code> constraint) and information that is not as essential. According to this definition of the table, the application requires that every customer have a shipping address.</p>
<p>Our Entity-Relationship (E-R) diagram showed a customer placing an order, but the table does not make allowance for any relationship between the customer and the purchase order. This relationship must be managed by the purchase order.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7508" class="sect3"><a id="sthref873"></a>
<h4 class="sect3">PurchaseOrder_reltab</h4>
<p>The <code>PurchaseOrder_reltab</code> table has the following definition:</p>
<div id="ADOBJ7509" class="example">
<p class="titleinexample"><a id="sthref874"></a>Example A-2 Creating the PurchaseOrder_reltab Table</p>
<pre>CREATE TABLE PurchaseOrder_reltab (    
   PONo        NUMBER, <span class="italic">/* purchase order no </span>*/  
   Custno      NUMBER references Customer_reltab, /*<span class="italic">  Foreign KEY referencing </span>
<span class="italic">                                                      customer</span> */
   OrderDate   DATE, <span class="italic">/*  date of order */  </span>
   ShipDate    DATE, <span class="italic">/* date to be shipped */    </span>
   ToStreet    VARCHAR2(200), <span class="italic">/* shipto address */  </span>  
   ToCity      VARCHAR2(200),    
   ToState     CHAR(2),    
   ToZip       VARCHAR2(20),    
   PRIMARY KEY(PONo));   
  
</pre>
<p><a id="sthref875"></a><a id="sthref876"></a><code>PurchaseOrder_reltab</code> manages the relationship between the customer and the purchase order by means of the foreign key (FK) column <code>CustNo</code>, which references the <code>CustNo</code> key of the <code>Customer_reltab</code>. The <code>PurchaseOrder_reltab</code> table contains no information about related line items. The line items table, described in the next section, uses the purchase order number to relate a line item to its parent purchase order.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i444515"></a>
<div id="ADOBJ7510" class="sect3">
<h4 class="sect3">Stock_reltab</h4>
<p>The <code>Stock_reltab</code> table has the following definition:</p>
<div id="ADOBJ7511" class="example">
<p class="titleinexample"><a id="sthref877"></a>Example A-3 Creating the Stock_reltab Table</p>
<pre>CREATE TABLE Stock_reltab (
  StockNo      NUMBER PRIMARY KEY,
  Price        NUMBER,
  TaxRate      NUMBER);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADOBJ7512" class="sect3"><a id="sthref878"></a>
<h4 class="sect3">LineItems_reltab</h4>
<p>The <code>LineItems_reltab</code> table has the following definition:</p>
<div id="ADOBJ7513" class="example">
<p class="titleinexample"><a id="sthref879"></a>Example A-4 Creating the LineItems_reltab Table</p>
<pre>CREATE TABLE LineItems_reltab (
  LineItemNo           NUMBER,
  PONo                 NUMBER REFERENCES PurchaseOrder_reltab,
  StockNo              NUMBER REFERENCES Stock_reltab,
  Quantity             NUMBER,
  Discount             NUMBER,
  PRIMARY KEY (PONo, LineItemNo));
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>Stock_reltab</code> and <code>PurchaseOrder_reltab</code> tables must be created before the <code>LineItems_reltab</code> table.</div>
<p>The table name is in the plural form <code>LineItems_reltab</code> to emphasize to someone reading the code that the table holds a collection of line items.</p>
<p>As shown in the E-R diagram, the list of line items has relationships with both the purchase order and the stock item. These relationships are managed by <code>LineItems_reltab</code> by means of two foreign key columns:</p>
<ul>
<li>
<p><code>PONo</code>, which references the <code>PONo</code> column in <code>PurchaseOrder_reltab</code></p>
</li>
<li>
<p><code>StockNo</code>, which references the <code>StockNo</code> column in <code>Stock_reltab</code></p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADOBJ7514" class="sect2"><a id="sthref880"></a>
<h3 class="sect2">Inserting Values Under the Relational Model</h3>
<p>In our application, statements like these insert data into the tables:</p>
<div id="ADOBJ7515" class="example">
<p class="titleinexample"><a id="sthref881"></a>Example A-5 Establish Inventory</p>
<pre>INSERT INTO Stock_reltab VALUES(1004, 6750.00, 2);
INSERT INTO Stock_reltab VALUES(1011, 4500.23, 2);
INSERT INTO Stock_reltab VALUES(1534, 2234.00, 2);
INSERT INTO Stock_reltab VALUES(1535, 3456.23, 2);
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7516" class="example">
<p class="titleinexample"><a id="sthref882"></a>Example A-6 Register Customers</p>
<pre>INSERT INTO Customer_reltab
  VALUES (1, &#39;Jean Nance&#39;, &#39;2 Avocet Drive&#39;,
         &#39;Redwood Shores&#39;, &#39;CA&#39;, &#39;95054&#39;,
         &#39;415-555-0102&#39;, NULL, NULL);

INSERT INTO Customer_reltab
  VALUES (2, &#39;John Nike&#39;, &#39;323 College Drive&#39;,
         &#39;Edison&#39;, &#39;NJ&#39;, &#39;08820&#39;,
         &#39;609-555-0190&#39;, &#39;201-555-0140&#39;, NULL);
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7517" class="example">
<p class="titleinexample"><a id="sthref883"></a>Example A-7 Place Orders</p>
<pre>INSERT INTO PurchaseOrder_reltab
  VALUES (1001, 1, SYSDATE, &#39;10-MAY-1997&#39;,
          NULL, NULL, NULL, NULL);

INSERT INTO PurchaseOrder_reltab
  VALUES (2001, 2, SYSDATE, &#39;20-MAY-1997&#39;,
         &#39;55 Madison Ave&#39;, &#39;Madison&#39;, &#39;WI&#39;, &#39;53715&#39;);
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7518" class="example">
<p class="titleinexample"><a id="sthref884"></a>Example A-8 Detail Line Items</p>
<pre>INSERT INTO LineItems_reltab VALUES(01, 1001, 1534, 12,  0);
INSERT INTO LineItems_reltab VALUES(02, 1001, 1535, 10, 10);
INSERT INTO LineItems_reltab VALUES(01, 2001, 1004,  1,  0);
INSERT INTO LineItems_reltab VALUES(02, 2001, 1011,  2,  1);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="ADOBJ7519" class="sect2"><a id="sthref885"></a>
<h3 class="sect2">Querying Data Under the Relational Model</h3>
<p>The application can execute queries like these:</p>
<div id="ADOBJ7520" class="example">
<p class="titleinexample"><a id="sthref886"></a>Example A-9 Get Customer and Line Item Data for a Specific Purchase Order</p>
<pre>SELECT   C.CustNo, C.CustName, C.Street, C.City, C.State,
         C.Zip, C.phone1, C.phone2, C.phone3,
         P.PONo, P.OrderDate,
         L.StockNo, L.LineItemNo, L.Quantity, L.Discount
 FROM    Customer_reltab C,
         PurchaseOrder_reltab P,
         LineItems_reltab L
 WHERE   C.CustNo = P.CustNo
  AND    P.PONo = L.PONo
  AND    P.PONo = 1001;
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7521" class="example">
<p class="titleinexample"><a id="sthref887"></a>Example A-10 Get the Total Value of Purchase Orders</p>
<pre>SELECT     P.PONo, SUM(S.Price * L.Quantity)
 FROM      PurchaseOrder_reltab P,
           LineItems_reltab L,
           Stock_reltab S
 WHERE     P.PONo = L.PONo
  AND      L.StockNo = S.StockNo
 GROUP BY P.PONo;
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7522" class="example">
<p class="titleinexample"><a id="sthref888"></a>Example A-11 Get the Purchase Order and Line Item Data for Stock Item 1004</p>
<pre>SELECT    P.PONo, P.CustNo,
          L.StockNo, L.LineItemNo, L.Quantity, L.Discount
 FROM     PurchaseOrder_reltab P,
          LineItems_reltab     L
 WHERE    P.PONo = L.PONo
   AND    L.StockNo = 1004;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="ADOBJ7523" class="sect2"><a id="sthref889"></a>
<h3 class="sect2">Updating Data Under the Relational Model</h3>
<p>The application can execute statements like these to update the data:</p>
<div id="ADOBJ7524" class="example">
<p class="titleinexample"><a id="sthref890"></a>Example A-12 Update the Quantity for Purchase Order 1001 and Stock Item 1534</p>
<pre>UPDATE LineItems_reltab
   SET      Quantity = 20
   WHERE    PONo     = 1001
   AND      StockNo  = 1534;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i434073"></a>
<div id="ADOBJ7525" class="sect2">
<h3 class="sect2">Deleting Data Under the Relational Model</h3>
<p>The application can execute statements similar to <a href="#i457998">Example A-13</a> to delete data.</p>
<div id="ADOBJ7526" class="example">
<p class="titleinexample"><a id="i457998"></a>Example A-13 Delete Purchase Order 1001 under the Relational Model</p>
<pre>DELETE
   FROM   LineItems_reltab
   WHERE  PONo = 1001;

DELETE
   FROM   PurchaseOrder_reltab
   WHERE  PONo = 1001;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i441766"></a>
<div id="ADOBJ00905" class="sect1">
<h2 class="sect1">Implementing the Schema on the Object-Relational Model</h2>
<p>The object-relational approach begins with the same entity relationships as in <a href="#i457015">&#34;Entities and Relationships&#34;</a>. Viewing these from the object-oriented perspective, as in the following class diagram, allows us to translate more of the real-world structure into the database schema.</p>
<div id="ADOBJ7527" class="figure">
<p class="titleinfigure"><a id="CHDGDGBE"></a>Figure A-2 Class Diagram for Purchase Order Application</p>
<img width="276" height="366" src="img/adobj002.gif" alt="Description of Figure A-2 follows"/><br/>
<a id="sthref891" href="img_text/adobj002.htm">Description of &#34;Figure A-2 Class Diagram for Purchase Order Application&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Instead of breaking up addresses or multiple phone numbers into unrelated columns in relational tables, the object-relational approach defines types to represent an entire address and an entire list of phone numbers. Similarly, the object-relational approach uses nested tables to keep line items with their purchase orders instead of storing them separately.</p>
<p>The main entities&mdash;customers, stock, and purchase orders&mdash;become object types. Object references are used to express some of the relationships among them. Collection types&mdash;varrays and nested tables&mdash;are used to model multi-valued attributes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This appendix implements an object-relational interface by building an object-relational schema from scratch. With this approach, we create object tables for data storage. Alternatively, instead of object tables, you can use object views to implement an object-relational interface to existing data stored in relational tables. <a href="adobjvew.htm#g444865">Chapter 6</a> discusses object views.</div>
<div id="ADOBJ7528" class="sect2"><a id="sthref892"></a>
<h3 class="sect2"><a id="sthref893"></a><a id="sthref894"></a><a id="sthref895"></a>Defining Types</h3>
<p>You create an object type with a <code>CREATE</code> <code>TYPE</code> statement. For example, the following statement creates the type <code>StockItem_objtyp</code>:</p>
<div id="ADOBJ7529" class="example">
<p class="titleinexample"><a id="CHDBAIJJ"></a>Example A-14 Creating the StockItem_objtyp Object</p>
<pre>CREATE TYPE StockItem_objtyp AS OBJECT (
  StockNo    NUMBER,
  Price      NUMBER,
  TaxRate    NUMBER
  );
/
</pre>
<p>Instances of type <code>StockItem_objtyp</code> are objects representing the stock items that customers order. They have three numeric attributes. <code>StockNo</code> is the primary key.</p>
</div>
<!-- class="example" -->
<p>The order in which you define types can make a difference. Ideally, you want to wait to define types that refer to other types until you have defined the other types they refer to.</p>
<p>For example, the type <code>LineItem_objtyp</code> refers to, and thus presupposes, <code>StockItem_objtyp</code> by containing an attribute that is a <code>REF</code> to objects of <code>StockItem_objtyp</code>. You can see this in the statement that creates the type <code>LineItem_objtyp</code>.</p>
<div id="ADOBJ7530" class="example">
<p class="titleinexample"><a id="CHDFBIJC"></a>Example A-15 Creating the LineItem_objtyp Object</p>
<pre>CREATE TYPE LineItem_objtyp AS OBJECT (
  LineItemNo   NUMBER,
  Stock_ref    REF StockItem_objtyp,
  Quantity     NUMBER,
  Discount     NUMBER
  );
/
</pre></div>
<!-- class="example" -->
<p>Instances of type <code>LineItem_objtyp</code> are objects that represent line items. They have three numeric attributes and one <code>REF</code> attribute. The <code>LineItem_objtyp</code> models the line item entity and includes an object reference to the corresponding stock object.</p>
<p>Sometimes the web of references among types makes it difficult or impossible to avoid creating a type before all the types that it presupposes are created. To deal with this sort of situation, you can create what is called an incomplete type to use as a placeholder for other types that you want to create to refer to. Then, when you have created the other types, you can come back and replace the incomplete type with a complete one.</p>
<p>For example, if we had needed to create <code>LineItem_objtyp</code> before we created <code>StockItem_objtyp</code>, we could have used a statement like the following to create <code>LineItem_objtyp</code> as an incomplete type:</p>
<p><code>CREATE</code> <code>TYPE</code> <code>LineItem_objtyp;</code></p>
<p>The form of the <code>CREATE</code> <code>TYPE</code> statement used to create an incomplete type does not have the phrase <code>AS</code> <code>OBJECT</code> or the specification of attributes.</p>
<p>To replace an incomplete type with a complete definition, include the phrase <code>OR</code> <code>REPLACE</code> as shown in the following example:</p>
<div id="ADOBJ7531" class="example">
<p class="titleinexample"><a id="CHDEGDIJ"></a>Example A-16 Replacing the LineItem_objtyp Object</p>
<pre>CREATE OR REPLACE TYPE LineItem_objtyp AS OBJECT (
  LineItemNo   NUMBER,
  Stock_ref    REF StockItem_objtyp,
  Quantity     NUMBER,
  Discount     NUMBER
  );
/
</pre></div>
<!-- class="example" -->
<p>It is never wrong to include the words <code>OR</code> <code>REPLACE</code>, even if you have no incomplete type to replace.</p>
<p>Now create the remaining types we need for the schema. <a id="sthref896"></a>The following statement defines an array type for the list of phone numbers:</p>
<div id="ADOBJ7532" class="example">
<p class="titleinexample"><a id="i456792"></a>Example A-17 Creating the PhoneList_vartyp Type</p>
<pre>CREATE TYPE PhoneList_vartyp AS VARRAY(10) OF VARCHAR2(20);
/
</pre></div>
<!-- class="example" -->
<p>Any data unit, or instance, of type <code>PhoneList_vartyp</code> is a varray of up to 10 telephone numbers, each represented by a data item of type <code>VARCHAR2</code>.</p>
<p><a id="sthref897"></a><a id="sthref898"></a>Either a varray or a nested table could be used to contain a list of phone numbers. In this case, the list is the set of contact phone numbers for a single customer. A varray is a better choice than a nested table for the following reasons:</p>
<ul>
<li>
<p>The order of the numbers might be important: varrays are ordered while nested tables are unordered.</p>
</li>
<li>
<p>The number of phone numbers for a specific customer is small. Varrays force you to specify a maximum number of elements (10 in this case) in advance. They use storage more efficiently than nested tables, which have no special size limitations.</p>
</li>
<li>
<p>You can query a nested table but not a varray. But there is no reason to query the phone number list, so using a nested table offers no benefit.</p>
</li>
</ul>
<p>In general, if ordering and bounds are not important design considerations, then designers can use the following rule of thumb for deciding between varrays and nested tables: If you need to query the collection, then use nested tables; if you intend to retrieve the collection as a whole, then use varrays.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjdes.htm#g464733">Chapter 9, &#34;Design Considerations for Oracle Objects&#34;</a> for more information about the design considerations for varrays and nested tables</div>
<p>The following statement defines the object type <code>Address_objtyp</code> to represent addresses:</p>
<div id="ADOBJ7533" class="example">
<p class="titleinexample"><a id="i456819"></a>Example A-18 Creating the Address_objtyp Object</p>
<pre>CREATE TYPE Address_objtyp AS OBJECT (
  Street         VARCHAR2(200),
  City           VARCHAR2(200),
  State          CHAR(2),
  Zip            VARCHAR2(20)
  ) 
/
</pre></div>
<!-- class="example" -->
<p>All of the attributes of an address are character strings, representing the usual parts of a simplified mailing address.</p>
<p>The following statement defines the object type <code>Customer_objtyp</code>, which uses other object types as building blocks.</p>
<div id="ADOBJ7534" class="example">
<p class="titleinexample"><a id="i456861"></a>Example A-19 Creating the Customer_objtyp Object</p>
<pre>CREATE TYPE Customer_objtyp AS OBJECT (
  CustNo           NUMBER,
  CustName         VARCHAR2(200),
  Address_obj      Address_objtyp,
  PhoneList_var    PhoneList_vartyp,

  <span class="bold">ORDER</span> MEMBER FUNCTION
    compareCustOrders(x IN Customer_objtyp) RETURN INTEGER
) <span class="bold">NOT FINAL</span>;
/
</pre></div>
<!-- class="example" -->
<p>Instances of the type <code>Customer_objtyp</code> are objects that represent blocks of information about specific customers. The attributes of a <code>Customer_objtyp</code> object are a number, a character string, an <code>Address_objtyp</code> object, and a varray of type <code>PhoneList_vartyp</code>.</p>
<p>The clause <code>NOT</code> <code>FINAL</code> enables us to create subtypes of the customer type later if we wish. By default, types are created as <code>FINAL</code>, which means that the type cannot be further specialized by deriving subtypes from it. We define a subtype of <code>Customer_objtyp</code> for a more specialized kind of customer later in this appendix.</p>
<p><a id="sthref899"></a><a id="sthref900"></a>Every <code>Customer_objtyp</code> object also has an associated order method, one of the two types of comparison methods. Whenever Oracle needs to compare two <code>Customer_objtyp</code> objects, it implicitly invokes the <code>compareCustOrders</code> method to do so.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The PL/SQL to implement the comparison method appears in <a href="#i443229">&#34;The compareCustOrders Method&#34;</a>.</div>
<p><a id="sthref901"></a><a id="sthref902"></a>The two types of comparison methods are map methods and order methods. This application uses one of each for purposes of illustration.</p>
<p>An <code>ORDER</code> method must be called for every two objects being compared, whereas a map method is called once for each object. In general, when sorting a set of objects, the number of times an <code>ORDER</code> method is called is more than the number of times a map method would be called.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="adobjbas.htm#g500167">Chapter 2, &#34;Basic Components of Oracle Objects&#34;</a> for more information about map and order methods</p>
</li>
<li>
<p><a class="olink LNPLS99954" href="../LNPLS/fundamentals.htm#LNPLS99954"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for details about how to use pragma declarations</p>
</li>
</ul>
</div>
<p>The following statement defines a type for a nested table of line items. Each purchase order will use an instance of this nested table type to contain the line items for that purchase order:</p>
<div id="ADOBJ7535" class="example">
<p class="titleinexample"><a id="i456862"></a>Example A-20 Creating the LineItemList_ntabtyp Type</p>
<pre>CREATE TYPE LineItemList_ntabtyp AS TABLE OF LineItem_objtyp;
/
</pre></div>
<!-- class="example" -->
<p><a id="sthref903"></a><a id="sthref904"></a>An instance of this type is a nested table object (in other words, a nested table), each row of which contains an object of type <code>LineItem_objtyp</code>. A nested table of line items is a better choice to represent the multivalued line item list than a varray of <code>LineItem_objtyp</code> objects, because:</p>
<ul>
<li>
<p><a id="sthref905"></a>Most applications will need to query the contents of line items. This can be done using SQL if the line items are stored in a nested table but not if they are stored in a varray.</p>
</li>
<li>
<p>If an application needs to index on line item data, this can be done with nested tables but not with varrays.</p>
</li>
<li>
<p>The order in which line items are stored is probably not important, and a query can order them by line item number when necessary.</p>
</li>
<li>
<p>There is no practical upper bound on the number of line items on a purchase order. Using a varray requires specifying an arbitrary upper bound on the number of elements.</p>
</li>
</ul>
<p>The following statement defines the object type <code>PurchaseOrder_objtyp</code>:</p>
<div id="ADOBJ7536" class="example">
<p class="titleinexample"><a id="sthref906"></a>Example A-21 Creating the PurchaseOrder_objtyp Object</p>
<pre>CREATE TYPE PurchaseOrder_objtyp AUTHID CURRENT_USER AS OBJECT (
  PONo                 NUMBER,
  Cust_ref             REF Customer_objtyp,
  OrderDate            DATE,
  ShipDate             DATE,
  LineItemList_ntab    LineItemList_ntabtyp,
  ShipToAddr_obj       Address_objtyp,

  MAP MEMBER FUNCTION
    getPONo RETURN NUMBER,

  MEMBER FUNCTION
    sumLineItems RETURN NUMBER
  );
/
</pre></div>
<!-- class="example" -->
<p>Instances of type <code>PurchaseOrder_objtyp</code> are objects representing purchase orders. They have six attributes, including a <code>REF</code> to <code>Customer_objtyp</code>, an <code>Address_objtyp</code> object, and a nested table of type <code>LineItemList_ntabtyp</code>, which is based on type <code>LineItem_objtyp</code>. <code>PONo</code> is the primary key and <code>Cust_ref</code> is a foreign key.</p>
<p><a id="sthref907"></a><a id="sthref908"></a><a id="sthref909"></a>Objects of type <code>PurchaseOrder_objtyp</code> have two methods: <code>getPONo</code> and <code>sumLineItems</code>. One, <code>getPONo</code>, is a map method, one of the two kinds of comparison methods. A map method returns the relative position of a given record within the order of records within the object. So, whenever Oracle needs to compare two <code>PurchaseOrder_objtyp</code> objects, it implicitly calls the <code>getPONo</code> method to do so.</p>
<p><a id="sthref910"></a>The two pragma declarations provide information to PL/SQL about what sort of access the two methods need to the database.</p>
<p>The statement does not include the actual PL/SQL programs implementing the methods <code>getPONo</code> and <code>sumLineItems</code>. Those appear in <a href="#i443287">&#34;Method Definitions&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i443287"></a>
<div id="ADOBJ7537" class="sect2">
<h3 class="sect2">Method Definitions</h3>
<p><a id="sthref911"></a><a id="sthref912"></a>If a type has no methods, its definition consists just of a <code>CREATE</code> <code>TYPE</code> statement. However, for a type that has methods, you must also define a type body to complete the definition of the type. You do this with a <code>CREATE</code> <code>TYPE</code> <code>BODY</code> statement. As with <code>CREATE</code> <code>TYPE</code>, you can include the words <code>OR</code> <code>REPLACE</code>. You must include this phrase if you are replacing an existing type body with a new one, to change the methods.</p>
<p>The following statement defines the body of the type <code>PurchaseOrder_objtyp</code>. The statement supplies the PL/SQL programs that implement the type&#39;s methods:</p>
<div id="ADOBJ7538" class="example">
<p class="titleinexample"><a id="sthref913"></a>Example A-22 Creating the PurchaseOrder_objtyp Type Body</p>
<pre>CREATE OR REPLACE TYPE BODY PurchaseOrder_objtyp AS 

MAP MEMBER FUNCTION getPONo RETURN NUMBER is   
   BEGIN  
      RETURN PONo;   
   END;    
   
MEMBER FUNCTION sumLineItems RETURN NUMBER is  
      i             INTEGER;  
      StockVal      StockItem_objtyp;  
      Total         NUMBER := 0;  
   
   BEGIN  
      FOR i in 1..SELF.LineItemList_ntab.COUNT LOOP  
         UTL_REF.SELECT_OBJECT(LineItemList_ntab(i).Stock_ref,StockVal);  
         Total := Total + SELF.LineItemList_ntab(i).Quantity * StockVal.Price;  
      END LOOP;  
      RETURN Total;
   END;
END;
/
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7539" class="sect3"><a id="sthref914"></a>
<h4 class="sect3">The getPONo Method</h4>
<p>The <code>getPONo</code> method simply returns the value of the <code>PONo</code> attribute&mdash;namely, the purchase order number&mdash;of whatever instance of the type <code>PurchaseOrder_objtyp</code> that calls the method. Such <code>get</code> methods allow you to avoid reworking code that uses the object if its internal representation changes.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7540" class="sect3"><a id="sthref915"></a>
<h4 class="sect3">The sumLineItems Method</h4>
<p>The <code>sumLineItems</code> method uses a number of object-relational features:</p>
<ul>
<li>
<p>As already noted, the basic function of the <code>sumLineItems</code> method is to return the sum of the values of the line items of its associated <code>PurchaseOrder_objtyp</code> object. The keyword <code>SELF</code>, which is implicitly created as a parameter to every function, lets you refer to that object.</p>
</li>
<li>
<p><a id="sthref916"></a>The keyword <code>COUNT</code> gives the count of the number of elements in a PL/SQL table or array. Here, in combination with <code>LOOP</code>, the application iterates through all the elements in the collection &mdash; in this case, the items of the purchase order. In this way <code>SELF</code>.<code>LineItemList_ntab</code>.<code>COUNT</code> counts the number of elements in the nested table that match the <code>LineItemList_ntab</code> attribute of the <code>PurchaseOrder_objtyp</code> object, here represented by <code>SELF</code>.</p>
</li>
<li>
<p><a id="sthref917"></a><a id="sthref918"></a><a id="sthref919"></a><a id="sthref920"></a><a id="sthref921"></a>A method from package <code>UTL_REF</code> is used in the implementation. The <code>UTL_REF</code> methods are necessary because Oracle does not support implicit dereferencing of <code>REF</code>s within PL/SQL programs. The <code>UTL_REF</code> package provides methods that operate on object references. Here, the <code>SELECT_OBJECT</code> method is called to obtain the <code>StockItem_objtyp</code> object corresponding to the <code>Stock_ref</code>.</p>
</li>
</ul>
<p>The <code>AUTHID</code> <code>CURRENT_USER</code> syntax specifies that the <code>PurchaseOrder_objtyp</code> is defined using invoker rights: the methods are executed under the rights of the current user, not under the rights of the user who defined the type.</p>
<ul>
<li>
<p>The PL/SQL variable <code>StockVal</code> is of type <code>StockItem_objtyp</code>. The <code>UTL_REF</code>.<code>SELECT_OBJECT</code> sets it to the object whose reference is the following:</p>
<p><code>(LineItemList_ntab(i).Stock_ref)</code></p>
<p>This object is the actual stock item referred to in the currently selected line item.</p>
</li>
<li>
<p>Having retrieved the stock item in question, the next step is to compute its cost. The program refers to the stock item&#39;s cost as <code>StockVal</code>.<code>Price</code>, the <code>Price</code> attribute of the <code>StockItem_objtyp</code> object. But to compute the cost of the item, you also need to know the quantity of items ordered. In the application, the term <code>LineItemList_ntab(i)</code>.<code>Quantity</code> represents the <code>Quantity</code> attribute of the currently selected <code>LineItem_objtyp</code> object.</p>
</li>
</ul>
<p>The remainder of the method program is a loop that sums the values of the line items. The method returns the total.</p>
</div>
<!-- class="sect3" -->
<a id="i443229"></a>
<div id="ADOBJ7541" class="sect3">
<h4 class="sect3">The compareCustOrders Method</h4>
<p>The following statement defines the <code>compareCustOrders</code> method in the type body of the <code>Customer_objtyp</code> object type:</p>
<div id="ADOBJ7542" class="example">
<p class="titleinexample"><a id="sthref922"></a>Example A-23 Creating the Customer_objtyp Type Body</p>
<pre>CREATE OR REPLACE TYPE BODY Customer_objtyp AS
  ORDER MEMBER FUNCTION
  compareCustOrders (x IN Customer_objtyp) RETURN INTEGER IS
  BEGIN
    RETURN CustNo - x.CustNo;
  END;
END;
/
</pre></div>
<!-- class="example" -->
<p><a id="sthref923"></a><a id="sthref924"></a>As mentioned earlier, the order method <code>compareCustOrders</code> operation compares information about two customer orders. It takes another <code>Customer_objtyp</code> object as an input argument and returns the difference of the two <code>CustNo</code> numbers. The return value is:</p>
<ul>
<li>
<p>A negative number if its own object has a smaller value of <code>CustNo</code></p>
</li>
<li>
<p>A positive number if its own object has a larger value of <code>CustNo</code></p>
</li>
<li>
<p>zero if the two objects have the same value of <code>CustNo</code>&mdash;in which case both orders are associated with the same customer.</p>
</li>
</ul>
<p>Whether the return value is positive, negative, or zero signifies the relative order of the customer numbers. For example, perhaps lower numbers are created earlier in time than higher numbers. If either of the input arguments (<code>SELF</code> and the explicit argument) to an <code>ORDER</code> method is <code>NULL</code>, Oracle does not call the <code>ORDER</code> method and simply treats the result as <code>NULL</code>.</p>
<p>We have now defined all of the object types for the object-relational version of the purchase order schema. We have not yet created any instances of these types to contain actual purchase order data, nor have we created any tables in which to store such data. We show how to do this in the next section.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADOBJ7543" class="sect2"><a id="sthref925"></a>
<h3 class="sect2">Creating Object Tables<a id="sthref926"></a></h3>
<p>Creating an object type is not the same as creating a table. Creating a type merely defines a logical structure; it does not create storage. To use an object-relational interface to your data, you must create object types whether you intend to store your data in object tables or leave it in relational tables and access it through object views. Object views and object tables alike presuppose object types: an object table or object view is always a table or view of a certain object type. In this respect, it is like a relational column, which always has a specified data type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjvew.htm#g444865">Chapter 6, &#34;Applying an Object Model to Relational Data&#34;</a> for a discussion of object views</div>
<p>Like a relational column, an object table can contain rows of just one kind of thing, namely, object instances of the same declared type as the table. (And, if the table is substitutable, it can contain instances of subtypes of its declared type as well.)</p>
<p>Each row in an object table is a single object instance. So, in one sense, an object table has, or consists of, only a single column of the declared object type. But this is not as different as it may seem from the case with relational tables. Each row in a relational table theoretically represents a single entity as well&mdash;for example, a customer, in a relational <code>Customers</code> table. The columns of a relational table store data for attributes of this entity.</p>
<p>Similarly, in an object table, attributes of the object type map to columns that can be inserted into and selected from. The major difference is that, in an object table, data is stored&mdash;and can be retrieved&mdash;in the structure defined by the table&#39;s type, making it possible for you to retrieve an entire, multilevel structure of data with a very simple query.</p>
<div id="ADOBJ7544" class="sect3"><a id="sthref927"></a>
<h4 class="sect3">The Object Table Customer_objtab</h4>
<p>The following statement defines an object table <code>Customer_objtab</code> to hold objects of type <code>Customer_objtyp</code>:</p>
<div id="ADOBJ7545" class="example">
<p class="titleinexample"><a id="sthref928"></a>Example A-24 Creating the Customer_objtab Table</p>
<pre>CREATE TABLE Customer_objtab OF Customer_objtyp (CustNo PRIMARY KEY) 
   OBJECT IDENTIFIER IS PRIMARY KEY;
</pre></div>
<!-- class="example" -->
<p>Unlike relational tables, when you create an object table, you specify a data type for it, namely, the type of objects it will contain.</p>
<p>The table has a column for each attribute of <code>Customer_objtyp</code>, namely:</p>
<br/>
<code>CustNo NUMBER /* Primary key */</code><br/>
<code>CustName VARCHAR2(200)</code><br/>
<code>Address_obj Address_objtyp</code><br/>
<code>PhoneList_var PhoneList_vartyp</code><br/>
<p>See <a href="#i456819">Example A-18, &#34;Creating the Address_objtyp Object&#34;</a> and <a href="#i456792">Example A-17, &#34;Creating the PhoneList_vartyp Type&#34;</a> for the definitions of those types.</p>
<div id="ADOBJ7546" class="figure">
<p class="titleinfigure"><a id="CHDBCACA"></a>Figure A-3 Object Relational Representation of Table Customer_objtab</p>
<img width="426" height="376" src="img/adobj008.gif" alt="Description of Figure A-3 follows"/><br/>
<a id="sthref929" href="img_text/adobj008.htm">Description of &#34;Figure A-3 Object Relational Representation of Table Customer_objtab&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADOBJ7547" class="sect2"><a id="sthref930"></a>
<h3 class="sect2">Object Data Types as a Template for Object Tables</h3>
<p>Because there is a type <code>Customer_objtyp</code>, you could create numerous object tables of the same type. For example, you could create an object table <code>Customer_objtab2</code> also of type <code>Customer_objtyp</code>.</p>
<p><a id="sthref931"></a>You can introduce variations when creating multiple tables. The statement that created <code>Customer_objtab</code> defined a primary key constraint on the <code>CustNo</code> column. This constraint applies only to this object table. Another object table of the same type might not have this constraint.</p>
</div>
<!-- class="sect2" -->
<a id="CHDGGDIF"></a>
<div id="ADOBJ7548" class="sect2">
<h3 class="sect2">Object Identifiers and References<a id="sthref932"></a></h3>
<p><code>Customer_objtab</code> contains customer objects, represented as row objects. Oracle allows row objects to be referenceable, meaning that other row objects or relational rows may reference a row object using its object identifier (OID). For example, a purchase order row object may reference a customer row object using its object reference. The object reference is a system-generated value represented by the type <code>REF</code> and is based on the unique OID of the row object.</p>
<p>Oracle requires every row object to have a unique OID. You may specify the unique OID value to be system-generated or specify the row object&#39;s primary key to serve as its unique OID. You indicate this when you execute the <code>CREATE</code> <code>TABLE</code> statement by specifying <code>OBJECT</code> <code>IDENTIFIER</code> <code>IS</code> <code>PRIMARY</code> <code>KEY</code> or <code>OBJECT</code> <code>IDENTIFIER</code> <code>IS</code> <code>SYSTEM</code> <code>GENERATED</code>. The latter is the default. Using the primary key as the object identifier can be more efficient in cases where the primary key value is smaller than the default 16 byte system-generated identifier. For our example, the primary key is used as the row object identifier.</p>
</div>
<!-- class="sect2" -->
<a id="i451799"></a>
<div id="ADOBJ7549" class="sect2">
<h3 class="sect2">Object Tables with Embedded Objects<a id="sthref933"></a></h3>
<p>Note that the <code>Address_obj</code> column of <code>Customer_objtab</code> contains <code>Address_objtyp</code> objects. As this shows, an object type may have attributes that are themselves object types. Object instances of the declared type of an object table are called row objects because one object instance occupies an entire row of the table. But embedded objects such as those in the <code>Address_obj</code> column are referred to as column objects. These differ from row objects in that they do not take up an entire row. Consequently, they are not referenceable&mdash;they cannot be the target of a <code>REF</code>. Also, they can be <code>NULL</code>.</p>
<p>The attributes of <code>Address_objtyp</code> objects are of built-in types. They are scalar rather than complex (that is, they are not object types with attributes of their own), and so are called leaf-level attributes to reflect that they represent an end to branching. Columns for <code>Address_objtyp</code> objects and their attributes are created in the object table <code>Customer_objtab</code>. You can refer or navigate to these columns using the dot notation. For example, if you want to build an index on the <code>Zip</code> column, you can refer to it as <code>Address</code>.<code>Zip</code>.</p>
<p><a id="sthref934"></a>The <code>PhoneList_var</code> column contains varrays of type <code>PhoneList_vartyp</code>. We defined each object of type <code>PhoneList_vartyp</code> as a varray of up to 10 telephone numbers, each represented by a data item of type <code>VARCHAR2</code>. See <a href="#i456792">Example A-17</a>.</p>
<p>Because each varray of type <code>PhoneList_vartyp</code> can contain no more than 200 characters (10 x 20), plus a small amount of overhead, Oracle stores the varray as a single data unit in the <code>PhoneList_var</code> column. Oracle stores varrays that do not exceed 4000 bytes in inline <code>BLOB</code>s, which means that a portion of the varray value could potentially be stored outside the table.</p>
<div id="ADOBJ7550" class="sect3"><a id="sthref935"></a>
<h4 class="sect3">The Object Table Stock_objtab</h4>
<p>The following statement creates an object table for <code>StockItem_objtyp</code> objects:</p>
<div id="ADOBJ7551" class="example">
<p class="titleinexample"><a id="sthref936"></a>Example A-25 Creating the Stock_objtab Table</p>
<pre>CREATE TABLE Stock_objtab OF StockItem_objtyp (StockNo PRIMARY KEY)
   OBJECT IDENTIFIER IS PRIMARY KEY;
</pre></div>
<!-- class="example" -->
<p>Each row of the table is a <code>StockItem_objtyp</code> object having three numeric attributes:</p>
<br/>
<code>StockNo NUMBER</code><br/>
<code>Price NUMBER</code><br/>
<code>TaxRate NUMBER</code><br/>
<p>Oracle creates a column for each attribute. The <code>CREATE</code> <code>TABLE</code> statement places a primary key constraint on the <code>StockNo</code> column and specifies that the primary key be used as the row object&#39;s identifier.</p>
</div>
<!-- class="sect3" -->
<a id="i444726"></a>
<div id="ADOBJ7552" class="sect3">
<h4 class="sect3">The Object Table PurchaseOrder_objtab</h4>
<p>The following statement defines an object table for <code>PurchaseOrder_objtyp</code> objects:</p>
<div id="ADOBJ7553" class="example">
<p class="titleinexample"><a id="sthref937"></a>Example A-26 Creating the PurchaseOrder_objtab Table</p>
<pre>CREATE TABLE PurchaseOrder_objtab OF PurchaseOrder_objtyp (  /* Line 1 */
   PRIMARY KEY (PONo),                                       /* Line 2 */
   FOREIGN KEY (Cust_ref) REFERENCES Customer_objtab)        /* Line 3 */
   OBJECT IDENTIFIER IS PRIMARY KEY                          /* Line 4 */
   NESTED TABLE LineItemList_ntab STORE AS PoLine_ntab (     /* Line 5 */
     (PRIMARY KEY(NESTED_TABLE_ID, LineItemNo))              /* Line 6 */
     ORGANIZATION INDEX COMPRESS)                            /* Line 7 */
   RETURN AS LOCATOR                                         /* Line 8 */
/   
</pre></div>
<!-- class="example" -->
<p>The preceding <code>CREATE</code> <code>TABLE</code> statement creates the <code>PurchaseOrder_objtab</code> object table. The significance of each line is as follows:</p>
<p class="subhead1"><a id="ADOBJ7554"></a>Line 1:</p>
<br/>
<code>CREATE</code> <code>TABLE</code> <code>PurchaseOrder_objtab</code> <code>OF</code> <code>PurchaseOrder_objtyp</code> <code>(</code><br/>
<p>This line indicates that each row of the table is a <code>PurchaseOrder_objtyp</code> object. Attributes of <code>PurchaseOrder_objtyp</code> objects are:</p>
<br/>
<code>PONo NUMBER</code><br/>
<code>Cust_ref REF Customer_objtyp</code><br/>
<code>OrderDate DATE</code><br/>
<code>ShipDate DATE</code><br/>
<code>LineItemList_ntab LineItemList_ntabtyp</code><br/>
<code>ShipToAddr_obj Address_objtyp</code><br/>
<p>See <a href="#i456861">Example A-19, &#34;Creating the Customer_objtyp Object&#34;</a> and <a href="#i456862">Example A-20, &#34;Creating the LineItemList_ntabtyp Type&#34;</a> for the definitions of those types.</p>
<div id="ADOBJ7555" class="figure">
<p class="titleinfigure"><a id="sthref938"></a>Figure A-4 Object Relational Representation of Table PurchaseOrder_objtab</p>
<img width="478" height="324" src="img/adobj009.gif" alt="Description of Figure A-4 follows"/><br/>
<a id="sthref939" href="img_text/adobj009.htm">Description of &#34;Figure A-4 Object Relational Representation of Table PurchaseOrder_objtab&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p class="subhead1"><a id="ADOBJ7556"></a>Line 2:</p>
<p><code>PRIMARY</code> <code>KEY</code> <code>(PONo),</code></p>
<p>This line specifies that the <code>PONo</code> attribute is the primary key for the table.</p>
<p class="subhead1"><a id="ADOBJ7557"></a>Line 3:</p>
<p><code>FOREIGN</code> <code>KEY</code> <code>(Cust_ref)</code> <code>REFERENCES</code> <code>Customer_objtab)</code></p>
<p>This line specifies a referential constraint on the <code>Cust_ref</code> column. This referential constraint is similar to those specified for relational tables. When there is no constraint, the <code>REF</code> column permits you to reference any row object. However, in this case, the <code>Cust_ref</code> <code>REF</code>s can refer only to row objects in the <code>Customer_objtab</code> object table.</p>
<p class="subhead1"><a id="ADOBJ7558"></a>Line 4:</p>
<p><code>OBJECT</code> <code>IDENTIFIER</code> <code>IS</code> <code>PRIMARY</code> <code>KEY</code></p>
<p>This line indicates that the primary key of the <code>PurchaseOrder_objtab</code> object table be used as the row&#39;s OID.</p>
<p class="subhead1"><a id="ADOBJ7559"></a>Line 5 - 8:</p>
<br/>
<code>NESTED</code> <code>TABLE</code> <code>LineItemList_ntab</code> <code>STORE</code> <code>AS</code> <code>PoLine_ntab</code> <code>(</code><br/>
<code>(PRIMARY KEY(NESTED_TABLE_ID, LineItemNo))</code><br/>
<code>ORGANIZATION INDEX COMPRESS)</code><br/>
<code>RETURN AS LOCATOR</code><br/>
<p><a id="sthref940"></a><a id="sthref941"></a><a id="sthref942"></a>These lines pertain to the storage specification and properties of the nested table column, <code>LineItemList_ntab</code>. The rows of a nested table are stored in a separate storage table. This storage table cannot be directly queried by the user but can be referenced in DDL statements for maintenance purposes. A hidden column in the storage table, called the <code>NESTED_TABLE_ID,</code> matches the rows with their corresponding parent row. All the elements in the nested table belonging to a particular parent have the same <code>NESTED_TABLE_ID</code> value. For example, all the elements of the nested table of a given row of <code>PurchaseOrder_objtab</code> have the same value of <code>NESTED_TABLE_ID</code>. The nested table elements that belong to a different row of <code>PurchaseOrder_objtab</code> have a different value of <code>NESTED_TABLE_ID</code>.</p>
<p>In the preceding <code>CREATE</code> <code>TABLE</code> example, Line 5 indicates that the rows of <code>LineItemList_ntab</code> nested table are to be stored in a separate table (referred to as the storage table) named <code>PoLine_ntab</code>. The <code>STORE</code> <code>AS</code> clause also permits you to specify the constraint and storage specification for the storage table. In this example, Line 7 indicates that the storage table is an index-organized table (<code>IOT</code>). In general, storing nested table rows in an IOT is beneficial because it provides clustering of rows belonging to the same parent. The specification of <code>COMPRESS</code> on the <code>IOT</code> saves storage space because, if you do not specify <code>COMPRESS</code>, the <code>NESTED_TABLE_ID</code> part of the <code>IOT</code>&#39;s key is repeated for every row of a parent row object. If, however, you specify <code>COMPRESS</code>, the <code>NESTED_TABLE_ID</code> is stored only once for each parent row object.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjdes.htm#i448918">&#34;Nested Table Storage&#34;</a> for information about the benefits of organizing a nested table as an IOT, specifying nested table compression, and for more information about nested table storage in general</div>
<p><a id="sthref943"></a>In Line 6, the specification of <code>NESTED_TABLE_ID</code> and <code>LineItemNo</code> attribute as the primary key for the storage table serves two purposes: first, it specifies the key for the <code>IOT</code>; second, it enforces uniqueness of the column <code>LineItemNo</code> of the nested table within each row of the parent table. By including the <code>LineItemNo</code> column in the key, the statement ensures that the <code>LineItemNo</code> column contains distinct values within each purchase order.</p>
<p><a id="sthref944"></a><a id="sthref945"></a>Line 8 indicates that the nested table, <code>LineItemList_ntab</code>, is returned in the locator form when retrieved. If you do not specify <code>LOCATOR</code>, the default is <code>VALUE</code>, which causes the entire nested table to be returned instead of just a locator to it. If a nested table collection contains many elements, it is inefficient to return the entire nested table whenever the containing row object or the column is selected.</p>
<p>Specifying that the nested table&#39;s locator is returned enables Oracle to send the client only a locator to the actual collection value. An application can find whether a fetched nested table is in the locator or value form by calling the <code>OCICollIsLocator</code> or <code>UTL_COLL</code>.<code>IS_LOCATOR</code> interfaces. Once you know that the locator has been returned, the application can query using the locator to fetch only the desired subset of row elements in the nested table. This locator-based retrieval of the nested table rows is based on the original statement&#39;s snapshot, to preserve the value or copy semantics of the nested table. That is, when the locator is used to fetch a subset of row elements in the nested table, the nested table snapshot reflects the nested table when the locator was first retrieved.</p>
<p>Recall the implementation of the <code>sumLineItems</code> method of <code>PurchaseOrder_objtyp</code> in <a href="#i443287">&#34;Method Definitions&#34;</a>. That implementation assumed that the <code>LineItemList_ntab</code> nested table would be returned as a <code>VALUE</code>. In order to handle large nested tables more efficiently, and to take advantage of the fact that the nested table in the <code>PurchaseOrder_objtab</code> is returned as a locator, the <code>sumLineItems</code> method must be rewritten as follows:</p>
<div id="ADOBJ7560" class="example">
<p class="titleinexample"><a id="sthref946"></a>Example A-27 Replacing the PurchaseOrder_objtyp Type Body</p>
<pre>CREATE OR REPLACE TYPE BODY PurchaseOrder_objtyp AS 

   MAP MEMBER FUNCTION getPONo RETURN NUMBER is   
      BEGIN  
         RETURN PONo;   
      END;   
    
   MEMBER FUNCTION sumLineItems RETURN NUMBER IS  
      i          INTEGER;  
      StockVal   StockItem_objtyp;  
      Total      NUMBER := 0;
  
   BEGIN
      IF (UTL_COLL.IS_LOCATOR(LineItemList_ntab)) -- check for locator
         THEN
            SELECT SUM(L.Quantity * L.Stock_ref.Price) INTO Total
            FROM   TABLE(CAST(LineItemList_ntab AS LineItemList_ntabtyp)) L;
      ELSE
         FOR i in 1..SELF.LineItemList_ntab.COUNT LOOP  
            UTL_REF.SELECT_OBJECT(LineItemList_ntab(i).Stock_ref,StockVal);  
            Total := Total + SELF.LineItemList_ntab(i).Quantity * 
                                                            StockVal.Price;  
         END LOOP;  
      END IF;  
   RETURN Total;  
   END;  
END;     
/
</pre></div>
<!-- class="example" -->
<p>The rewritten <code>sumLineItems</code> method checks whether the nested table attribute, <code>LineItemList_ntab</code>, is returned as a locator using the <code>UTL_COLL</code>.<code>IS_LOCATOR</code> function. If the condition evaluates to <code>TRUE</code>, the nested table locator is queried using the <code>TABLE</code> expression.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>CAST</code> expression is currently required in such <code>TABLE</code> expressions to tell the SQL compilation engine the actual type of the collection attribute (or parameter or variable) so that it can compile the query.</div>
<p>The querying of the nested table locator results in more efficient processing of the large line item list of a purchase order. The previous code that iterates over the <code>LineItemList_ntab</code> is kept to deal with the case where the nested table is returned as a <code>VALUE</code>.</p>
<p><a id="sthref947"></a><a id="sthref948"></a>After the table is created, the <code>ALTER</code> <code>TABLE</code> statement is issued to add the <code>SCOPE</code> <code>FOR</code> constraint on a <code>REF</code>. The <code>SCOPE</code> <code>FOR</code> constraint on a <code>REF</code> is not allowed in a <code>CREATE</code> <code>TABLE</code> statement. To specify that <code>Stock_ref</code> can reference only the object table <code>Stock_objtab</code>, issue the following <code>ALTER</code> <code>TABLE</code> statement on the <code>PoLine_ntab</code> storage table:</p>
<div id="ADOBJ7561" class="example">
<p class="titleinexample"><a id="sthref949"></a>Example A-28 Adding the SCOPE FOR Constraint</p>
<pre>ALTER TABLE PoLine_ntab
   ADD (SCOPE FOR (Stock_ref) IS stock_objtab) ;
</pre></div>
<!-- class="example" -->
<p>This statement specifies that the <code>Stock_ref</code> column of the nested table is scoped to <code>Stock_objtab</code>. This indicates that the values stored in this column must be references to row objects in <code>Stock_objtab</code>. The <code>SCOPE</code> constraint is different from the referential constraint in that the <code>SCOPE</code> constraint has no dependency on the referenced object. For example, any referenced row object in <code>Stock_objtab</code> may be deleted, even if it is referenced in the <code>Stock_ref</code> column of the nested table. Such a deletion renders the corresponding reference in the nested table a <code>DANGLING&nbsp;REF</code>.</p>
<div id="ADOBJ7562" class="figure">
<p class="titleinfigure"><a id="sthref950"></a>Figure A-5 Object Relational Representation of Nested Table LineItemList_ntab</p>
<img width="396" height="291" src="img/adobj010.gif" alt="Description of Figure A-5 follows"/><br/>
<a id="sthref951" href="img_text/adobj010.htm">Description of &#34;Figure A-5 Object Relational Representation of Nested Table LineItemList_ntab&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>Oracle does not support a referential constraint specification for storage tables. In this situation, specifying the <code>SCOPE</code> clause for a <code>REF</code> column is useful. In general, specifying scope or referential constraints for <code>REF</code> columns has several benefits:</p>
<ul>
<li>
<p>It saves storage space because it allows Oracle to store just the row object&#39;s unique identifier as the <code>REF</code> value in the column.</p>
</li>
<li>
<p>It enables an index to be created on the storage table&#39;s <code>REF</code> column.</p>
</li>
<li>
<p>It allows Oracle to rewrite queries containing dereferences of these <code>REF</code>s as joins involving the referenced table.</p>
</li>
</ul>
<p>At this point, all of the tables for the purchase order application are in place. The next section shows how to operate on these tables.</p>
<div id="ADOBJ7563" class="figure">
<p class="titleinfigure"><a id="sthref952"></a>Figure A-6 Object Relational Representation of Table PurchaseOrder_objtab</p>
<img width="492" height="324" src="img/adobj011.gif" alt="Description of Figure A-6 follows"/><br/>
<a id="sthref953" href="img_text/adobj011.htm">Description of &#34;Figure A-6 Object Relational Representation of Table PurchaseOrder_objtab&#34;</a><br/>
<br/></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<div id="ADOBJ7564" class="sect3"><a id="sthref954"></a>
<h4 class="sect3">Inserting Values<a id="sthref955"></a></h4>
<p>Here is how to insert the same data into the object tables that we inserted earlier into relational tables. Notice how some of the values incorporate calls to the constructors for object types, to create instances of the types.</p>
<div id="ADOBJ7565" class="example">
<p class="titleinexample"><a id="sthref956"></a>Example A-29 Inserting Values in Stock_objtab</p>
<pre>INSERT INTO Stock_objtab VALUES(1004, 6750.00, 2) ;
INSERT INTO Stock_objtab VALUES(1011, 4500.23, 2) ;
INSERT INTO Stock_objtab VALUES(1534, 2234.00, 2) ;
INSERT INTO Stock_objtab VALUES(1535, 3456.23, 2) ;
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7566" class="example">
<p class="titleinexample"><a id="sthref957"></a>Example A-30 Inserting Values in Customer_objtab</p>
<pre>INSERT INTO Customer_objtab
  VALUES (
    1, &#39;Jean Nance&#39;,
    Address_objtyp(&#39;2 Avocet Drive&#39;, &#39;Redwood Shores&#39;, &#39;CA&#39;, &#39;95054&#39;),
    PhoneList_vartyp(&#39;415-555-0102&#39;)
    ) ;

INSERT INTO Customer_objtab
  VALUES (
    2, &#39;John Nike&#39;,
    Address_objtyp(&#39;323 College Drive&#39;, &#39;Edison&#39;, &#39;NJ&#39;, &#39;08820&#39;),
    PhoneList_vartyp(&#39;609-555-0190&#39;,&#39;201-555-0140&#39;)
    ) ;
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7567" class="example">
<p class="titleinexample"><a id="sthref958"></a>Example A-31 Inserting Values in PurchaseOrder_objtab</p>
<pre>INSERT INTO PurchaseOrder_objtab
  SELECT  1001, REF(C),
          SYSDATE, &#39;10-MAY-1999&#39;,
          LineItemList_ntabtyp(),
          NULL
   FROM   Customer_objtab C
   WHERE  C.CustNo = 1 ;
</pre></div>
<!-- class="example" -->
<p>The preceding statement constructs a <code>PurchaseOrder_objtyp</code> object with the following attributes:</p>
<br/>
<code>PONo 1001</code><br/>
<code>Cust_ref REF to customer number 1</code><br/>
<code>OrderDate SYSDATE</code><br/>
<code>ShipDate 10-MAY-1999</code><br/>
<code>LineItemList_ntab an empty LineItem_ntabtyp</code><br/>
<code>ShipToAddr_obj NULL</code><br/>
<p><a id="i434182"></a><a id="sthref959"></a>The statement uses a query to construct a <code>REF</code> to the row object in the <code>Customer_objtab</code> object table that has a <code>CustNo</code> value of <code>1</code>.</p>
<p><a id="i434184"></a>The following statement uses a <code>TABLE</code> expression to identify the nested table as the target for the insertion, namely the nested table in the <code>LineItemList_ntab</code> column of the row object in the <code>PurchaseOrder_objtab</code> table that has a <code>PONo</code> value of 1001.</p>
<div id="ADOBJ7568" class="example">
<p class="titleinexample"><a id="sthref960"></a>Example A-32 Inserting Values in LineItemList_ntab</p>
<pre>INSERT INTO TABLE (
  SELECT  P.LineItemList_ntab
   FROM   PurchaseOrder_objtab P
   WHERE  P.PONo = 1001
  )
  SELECT  01, REF(S), 12, 0
   FROM   Stock_objtab S
   WHERE  S.StockNo = 1534 ;
</pre></div>
<!-- class="example" -->
<p>The preceding statement inserts a line item into the nested table identified by the <code>TABLE</code> expression. The inserted line item contains a <code>REF</code> to the row object with a <code>StockNo</code> value of <code>1534</code> in the object table <code>Stock_objtab</code>.</p>
<p>The following statements follow the same pattern as the previous ones:</p>
<div id="ADOBJ7569" class="example">
<p class="titleinexample"><a id="sthref961"></a>Example A-33 Inserting Values in PurchaseOrder_objtab and LineItemList_ntab</p>
<pre>INSERT INTO PurchaseOrder_objtab
  SELECT  2001, REF(C),
          SYSDATE, &#39;20-MAY-1997&#39;,
          LineItemList_ntabtyp(),
          Address_objtyp(&#39;55 Madison Ave&#39;,&#39;Madison&#39;,&#39;WI&#39;,&#39;53715&#39;)
   FROM   Customer_objtab C
   WHERE  C.CustNo = 2 ;

INSERT INTO TABLE (
  SELECT  P.LineItemList_ntab
   FROM   PurchaseOrder_objtab P
   WHERE  P.PONo = 1001
  )
  SELECT  02, REF(S), 10, 10
   FROM   Stock_objtab S
   WHERE  S.StockNo = 1535 ;

INSERT INTO TABLE (
  SELECT  P.LineItemList_ntab
   FROM   PurchaseOrder_objtab P
   WHERE  P.PONo = 2001
  )
  SELECT  10, REF(S), 1, 0
   FROM   Stock_objtab S
   WHERE  S.StockNo = 1004 ;

INSERT INTO TABLE (
  SELECT  P.LineItemList_ntab
   FROM   PurchaseOrder_objtab P
   WHERE  P.PONo = 2001
  )
  VALUES(11, (SELECT REF(S)
    FROM  Stock_objtab S
    WHERE S.StockNo = 1011), 2, 1) ;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADOBJ7570" class="sect3"><a id="sthref962"></a>
<h4 class="sect3">Querying<a id="sthref963"></a></h4>
<p><a id="i434186"></a><a id="sthref964"></a><a id="sthref965"></a><a id="sthref966"></a>The following query statement implicitly invokes a comparison method. It shows how Oracle orders objects of type <code>PurchaseOrder_objtyp</code> using that type&#39;s comparison method:</p>
<div id="ADOBJ7571" class="example">
<p class="titleinexample"><a id="sthref967"></a>Example A-34 Query Purchase Orders</p>
<pre>SELECT  p.PONo
 FROM   PurchaseOrder_objtab p
 ORDER BY VALUE(p) ;
</pre></div>
<!-- class="example" -->
<p><a id="i440929"></a><a id="sthref968"></a><a id="sthref969"></a>Oracle invokes the map method <code>getPONo</code> for each <code>PurchaseOrder_objtyp</code> object in the selection. Because that method returns the object&#39;s <code>PONo</code> attribute, the selection produces a list of purchase order numbers in ascending numerical order.</p>
<p>The following queries correspond to the queries executed under the relational model.</p>
<div id="ADOBJ7572" class="example">
<p class="titleinexample"><a id="sthref970"></a>Example A-35 Query Customer and Line Item Data for Purchase Order 1001</p>
<pre>SELECT  DEREF(p.Cust_ref), p.ShipToAddr_obj, p.PONo, 
        p.OrderDate, LineItemList_ntab
 FROM   PurchaseOrder_objtab p
 WHERE  p.PONo = 1001 ;
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7573" class="example">
<p class="titleinexample"><a id="sthref971"></a>Example A-36 Query Total Value of Each Purchase Order</p>
<pre>SELECT   p.PONo, p.sumLineItems()
 FROM    PurchaseOrder_objtab p ;
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7574" class="example">
<p class="titleinexample"><a id="sthref972"></a>Example A-37 Query Purchase Order and Line Item Data for Stock Item 1004</p>
<pre>SELECT   po.PONo, po.Cust_ref.CustNo,
         CURSOR (
           SELECT  *
            FROM   TABLE (po.LineItemList_ntab) L
            WHERE  L.Stock_ref.StockNo = 1004
           )
 FROM    PurchaseOrder_objtab po ; 
</pre></div>
<!-- class="example" -->
<p>The preceding query returns a <a id="sthref973"></a>nested cursor for the set of <code>LineItem_obj</code> objects selected from the nested table. The application can fetch from the nested cursor to get the individual <code>LineItem_obj</code> objects. The query can also be expressed by unnesting the nested set with respect to the outer result:</p>
<pre>SELECT   po.PONo, po.Cust_ref.CustNo, L.*
 FROM    PurchaseOrder_objtab po, TABLE (po.LineItemList_ntab) L
 WHERE   L.Stock_ref.StockNo = 1004 ;
</pre>
<p>The preceding query returns the result set as a flattened form (or First Normal Form). This type of query is useful when accessing Oracle collection columns from relational tools and APIs, such as ODBC. In the preceding unnesting example, only the rows of the <code>PurchaseOrder_objtab</code> object table that have any <code>LineItemList_ntab</code> rows are returned. To fetch all rows of the <code>PurchaseOrder_objtab</code> table, regardless of the presence of any rows in their corresponding <code>LineItemList_ntab</code>, then the (+) operator is required:</p>
<pre>SELECT   po.PONo, po.Cust_ref.CustNo, L.*
 FROM    PurchaseOrder_objtab po, TABLE (po.LineItemList_ntab) (+) L
 WHERE   L.Stock_ref.StockNo = 1004 ;
</pre>
<p>In <a href="#BABHFIII">Example A-38</a>, the request requires querying the rows of all <code>LineItemList_ntab</code> nested tables of all <code>PurchaseOrder_objtab</code> rows. Again, unnesting is required:</p>
<div id="ADOBJ7575" class="example">
<p class="titleinexample"><a id="BABHFIII"></a>Example A-38 Query Average Discount across all Line Items of all Purchase Orders</p>
<pre>SELECT AVG(L.DISCOUNT)
  FROM PurchaseOrder_objtab po, TABLE (po.LineItemList_ntab) L ;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADOBJ7576" class="sect3"><a id="sthref974"></a>
<h4 class="sect3">Deleting<a id="sthref975"></a></h4>
<p>The following example has the same effect as the two deletions needed in the relational case shown in <a href="#i457998">Example A-13</a>. In <a href="#i458022">Example A-39</a>, Oracle deletes the entire purchase order object, including its line items, in a single SQL operation. In the relational case, line items for the purchase order must be deleted from the line items table, and the purchase order must be separately deleted from the purchase orders table.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
If you are performing the SQL statements in this sample, do not execute the DELETE statement in <a href="#i458022">Example A-39</a> because the purchase order is needed in the following examples.</div>
<div id="ADOBJ7577" class="example">
<p class="titleinexample"><a id="i458022"></a>Example A-39 Delete Purchase Order 1001 in an Object-Relational Model</p>
<pre>DELETE
 FROM   PurchaseOrder_objtab
 WHERE  PONo = 1001 ;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i454651"></a>
<div id="ADOBJ00910" class="sect1">
<h2 class="sect1">Evolving Object Types</h2>
<p>Even a completed, fully built application tends to be a work in progress. Sometimes requirements change, forcing a change to an underlying object model or schema to adapt it to new circumstances, and sometimes there are ways to improve an object model so that it does a better job of what it was originally intended to do.</p>
<p>Suppose that, after living with our object-relational application for a while, we discover some ways that we could improve the design. In particular, suppose that we discover that users almost always want to see a history of purchases when they bring up the record for a customer. To do this with the present object model requires a join on the two tables <code>Customer_objtab</code> and <code>PurchaseOrder_objtab</code> that hold information about customers and purchase orders. We decide that a better design would be to provide access to data about related purchase orders directly from the customers table.</p>
<p>One way to do this is to change the <code>Customer_objtyp</code> so that information about a customer&#39;s purchase orders is included right in the object instance that represents that customer. In other words, we want to add an attribute for purchase order information to <code>Customer_objtyp</code>. To hold information about multiple purchase orders, the attribute must be a collection type&mdash;a nested table.</p>
<p>Adding an attribute is one of several ways that you can alter, or evolve, an object type. When you evolve a type, Oracle applies your changes to the type itself and to all its dependent schema objects, including subtypes of the type, other object types that have the altered type as an attribute, and tables and columns of the altered type.</p>
<p>To change <code>Customer_objtyp</code> to add an attribute for a nested table of purchase orders, several steps are needed:</p>
<ol>
<li>
<p>Create a new type for a nested table of purchase orders</p>
</li>
<li>
<p>Alter <code>Customer_objtyp</code> to add a new attribute of the new type</p>
</li>
<li>
<p>In the <code>Customer_objtab</code> object table, name and scope the storage tables for the newly added nested tables</p>
<ul>
<li>
<p>Upgrading the <code>Customer_objtab</code> object table for the new attribute actually adds two levels of nested tables, one inside the other, because a purchase order itself contains a nested table of line items.</p>
</li>
<li>
<p>Both the purchase orders nested table and the line items nested table need to be scoped so that they can contain primary key-based <code>REF</code>s. More on this in the next section.</p>
</li>
</ul>
</li>
</ol>
<div id="ADOBJ7578" class="figure">
<p class="titleinfigure"><a id="sthref976"></a>Figure A-7 Nested Tables in the Customer Object Type</p>
<img width="363" height="147" src="img/adobj034.gif" alt="Description of Figure A-7 follows"/><br/>
<a id="sthref977" href="img_text/adobj034.htm">Description of &#34;Figure A-7 Nested Tables in the Customer Object Type&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>When we are done with the preceding steps, information about customers and purchase orders will be more logically related in our model, and we will be able to query the customers table for all information about customers, purchase orders, and line items. We will also be able to insert a new purchase order for a new customer with a single <code>INSERT</code> statement on the customers table.</p>
<a id="i456432"></a>
<div id="ADOBJ7579" class="sect2">
<h3 class="sect2">Adding an Attribute to the Customer Type</h3>
<p>Before we can add a nested table of purchase orders as an attribute of <code>Customer_objtyp</code>, we need to define a type for this sort of nested table. The following statement does this:</p>
<div id="ADOBJ7580" class="example">
<p class="titleinexample"><a id="sthref978"></a>Example A-40 Create PurchaseOrderList_ntabtyp</p>
<pre>CREATE TYPE PurchaseOrderList_ntabtyp AS TABLE OF PurchaseOrder_objtyp;
/
</pre>
<p>Now we can use an <code>ALTER</code> <code>TYPE</code> statement to add an attribute of this type to <code>Customer_objtyp</code>:</p>
</div>
<!-- class="example" -->
<div id="ADOBJ7581" class="example">
<p class="titleinexample"><a id="sthref979"></a>Example A-41 Alter Customer_objtyp</p>
<pre>ALTER TYPE Customer_objtyp
  ADD ATTRIBUTE (PurchaseOrderList_ntab PurchaseOrderList_ntabtyp)
  CASCADE;
</pre></div>
<!-- class="example" -->
<p>If a type being altered has dependent types or tables, an <code>ALTER</code> <code>TYPE</code> statement on the type needs to specify either <code>CASCADE</code> or <code>INVALIDATE</code> to say how to apply the change to the dependents.</p>
<ul>
<li>
<p><code>CASCADE</code> performs validation checks on the dependents before applying a type change. These checks confirm that the change does not entail doing something illegal, such as dropping an attribute that is being used as a partitioning key of a table. If a dependent fails validation, the type change aborts. On the other hand, if all dependents validate successfully, the system goes ahead with whatever changes to metadata and data are required to propagate the change to the type. These can include automatically adding and dropping columns, creating storage tables for nested tables, and so forth.</p>
</li>
<li>
<p>The <code>INVALIDATE</code> option skips the preliminary validation checks and directly applies the type change to dependents. These are then validated the next time that they are accessed. Altering a type this way saves the time required to do the validations, but if a dependent table cannot be validated later when someone tries to access it, its data cannot be accessed until the table is made to pass the validation.</p>
</li>
</ul>
<p>We need to add scope for a <code>REF</code> column in each of the new nested tables of purchase orders and line items that are added to the <code>Customer_objtab</code> table. For convenience, first we rename the new tables from system-generated names to recognizable names. Then, using the names we have given them, we can alter the storage tables to add scope for their <code>REF</code> columns.</p>
<p>The reason we must do all this is that, in order for a column to store <code>REF</code>s to objects in a table that bases its object identifiers on the primary key, the column must be scoped to that table or have a referential constraint placed on it. Scoping a column to a particular table declares that all <code>REF</code>s in the column are <code>REF</code>s to objects in that table. This declaration is necessary because a primary key-based object identifier is guaranteed unique only in the context of the particular table: it may not be unique across all tables. If you try to insert a primary key-based <code>REF</code>, or user-defined <code>REF</code>, into an unscoped column, you will get an error similar to:</p>
<p><code>cannot</code> <code>INSERT</code> <code>object</code> <code>view</code> <code>REF</code> <code>or</code> <code>user-defined</code> <code>REF</code></p>
<p>Line items contain a <code>REF</code> to objects in table <code>Stock_objtab</code>, whose object identifier uses the table&#39;s primary key. This is why we had to add scope for the <code>REF</code> column in the storage table for the line items nested table in table <code>PurchaseOrder_objtab</code> after we created that table. Now we have to do it again for the new nested table of line items in table <code>Customer_objtab</code>.</p>
<p>We have to do the same again for the new nested table of purchase orders we are adding in table <code>Customer_objtab</code>: a purchase order references a customer in the table <code>Customer_objtab</code>, and object identifiers in this table are primary-key based as well.</p>
<p>Using the following statement, we determine the names of the system-generated tables so they can be renamed:</p>
<pre>SELECT table_name, parent_table_name, parent_table_column FROM user_nested_tables;
</pre>
<p>The output is similar to the following:</p>
<pre>TABLE_NAME                    PARENT_TABLE_NAME             PARENT_TABLE_COLUMN
----------------------------- ----------------------------- ----------------------
SYSNTQOFArJyBTHu6iOMMKU4wHw== CUSTOMER_OBJTAB               PURCHASEORDERLIST_NTAB
POLINE_NTAB                   PURCHASEORDER_OBJTAB          LINEITEMLIST_NTAB
SYSNTZqu6IQItR++UAtgz1rMB8A== SYSNTQOFArJyBTHu6iOMMKU4wHw== LINEITEMLIST_NTAB
</pre>
<p>For convenience, rename the system-generated nested tables to appropriate names. For example, using the system-generated names in the previous sample output:</p>
<pre>ALTER TABLE &#34;SYSNTQOFArJyBTHu6iOMMKU4wHw==&#34; RENAME TO PO_List_nt;
ALTER TABLE &#34;SYSNTZqu6IQItR++UAtgz1rMB8A==&#34; RENAME TO Items_List_nt;
</pre>
<p>The process of renaming the system-generated nested tables can also be done automatically with the following PL/SQL procedure:</p>
<pre>DECLARE 
  nested_table_1 VARCHAR2(30);
  nested_table_2 VARCHAR2(30);
  cust_obj_table VARCHAR2(30) := &#39;CUSTOMER_OBJTAB&#39;;
BEGIN 
 EXECUTE IMMEDIATE &#39; SELECT table_name FROM user_nested_tables
    WHERE parent_table_name = :1 &#39; INTO nested_table_1 USING cust_obj_table;
 EXECUTE IMMEDIATE &#39; SELECT table_name FROM user_nested_tables
    WHERE parent_table_name = :1 &#39; INTO nested_table_2 USING nested_table_1;
 EXECUTE IMMEDIATE &#39;ALTER table &#34;&#39;|| nested_table_1 ||&#39;&#34; RENAME TO PO_List_nt&#39;;
 EXECUTE IMMEDIATE &#39;ALTER table &#34;&#39;|| nested_table_2 ||&#39;&#34; RENAME TO Items_List_nt&#39;;
END; 
/
</pre>
<p>The new storage tables are named <code>PO_List_nt</code> and <code>Items_List_nt</code>. The following statements scope the <code>REF</code> columns in these tables to specific tables:</p>
<div id="ADOBJ7582" class="example">
<p class="titleinexample"><a id="sthref980"></a>Example A-42 Add SCOPE for REF to Nested Tables</p>
<pre>ALTER TABLE PO_List_nt ADD (SCOPE FOR (Cust_Ref) IS Customer_objtab);
ALTER TABLE Items_List_nt ADD (SCOPE FOR (Stock_ref) IS Stock_objtab);
</pre></div>
<!-- class="example" -->
<p>There is just one more thing to do before inserting purchase orders for customers in <code>Customer_objtab</code>. An actual nested table of <code>PurchaseOrderList_ntabtyp</code> must be instantiated for each customer in the table.</p>
<p>When a column is added to a table for a new attribute, column values for existing rows are initialized to <code>NULL</code>. This means that each existing customer&#39;s nested table of purchase orders is atomically <code>NULL</code>&mdash;there is no actual nested table there, not even an empty one. Until we instantiate a nested table for each customer, attempts to insert purchase orders will get an error similar to:</p>
<p><code>reference</code> <code>to</code> <code>NULL</code> <code>table</code> <code>value</code></p>
<p>The following statement prepares the column to hold purchase orders by updating each row to contain an actual nested table instance:</p>
<div id="ADOBJ7583" class="example">
<p class="titleinexample"><a id="sthref981"></a>Example A-43 Update Customer_objtab</p>
<pre>UPDATE Customer_objtab c
  SET c.PurchaseOrderList_ntab = PurchaseOrderList_ntabtyp();
</pre></div>
<!-- class="example" -->
<p>In the preceding statement, <code>PurchaseOrderList_ntabtyp()</code> is a call to the nested table type&#39;s constructor method. This call, with no purchase orders specified, creates an empty nested table.</p>
</div>
<!-- class="sect2" -->
<div id="ADOBJ7584" class="sect2"><a id="sthref982"></a>
<h3 class="sect2">Working with Multilevel Collections</h3>
<p>At this point, we have evolved the type <code>Customer_objtyp</code> to add a nested table of purchase orders, and we have set up the table <code>Customer_objtab</code> so that it is ready to store purchase orders in the nested table. Now we are ready to insert purchase orders into <code>Customer_objtab</code>.</p>
<p>There are two purchase orders already in table <code>PurchaseOrder_objtab</code>. The following two statements copy these into <code>Customer_objtab</code>:</p>
<div id="ADOBJ7585" class="example">
<p class="titleinexample"><a id="sthref983"></a>Example A-44 Insert Purchase Orders into Customer_objtab</p>
<pre>INSERT INTO TABLE (
  SELECT   c.PurchaseOrderList_ntab
    FROM   Customer_objtab c
    WHERE  c.CustNo = 1
  )
  SELECT VALUE(p)
    FROM PurchaseOrder_objtab p
    WHERE p.Cust_Ref.CustNo = 1;

INSERT INTO TABLE (
  SELECT   c.PurchaseOrderList_ntab
    FROM   Customer_objtab c
    WHERE  c.CustNo = 2
  )
  SELECT VALUE(p)
    FROM PurchaseOrder_objtab p
    WHERE p.Cust_Ref.CustNo = 2;
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7586" class="sect3"><a id="sthref984"></a>
<h4 class="sect3">Inserting into Nested Tables</h4>
<p>Each of the preceding <code>INSERT</code> statements has two main parts: a <code>TABLE</code> expression that specifies the target table of the insert operation, and a <code>SELECT</code> that gets the data to be inserted. The <code>WHERE</code> clause in each part picks out the customer object to receive the purchase orders (in the <code>TABLE</code> expression) and the customer whose purchase orders are to be selected (in the subquery that gets the purchase orders).</p>
<p>The <code>WHERE</code> clause in the subquery uses dot notation to navigate to the <code>CustNo</code> attribute: <code>p.Cust_Ref.CustNo</code>. Note that a table alias <code>p</code> is required whenever you use dot notation. To omit it and say instead <code>Cust_Ref.CustNo</code> would produce an error.</p>
<p>Another thing to note about the dot notation in this <code>WHERE</code> clause is that we are able to navigate to the <code>CustNo</code> attribute of a customer right through the <code>Cust_Ref</code> <code>REF</code> attribute of a purchase order. SQL (though not PL/SQL) implicitly dereferences a <code>REF</code> used with the dot notation in this way.</p>
<p>The <code>TABLE</code> expression in the first part of the <code>INSERT</code> statement tells the system to treat the collection returned by the expression as a table. The expression is used here to select the nested table of purchase orders for a particular customer as the target of the insert.</p>
<p>In the second part of the <code>INSERT</code> statement, the <code>VALUE()</code> function returns selected rows as objects. In this case, each row is a purchase order object, complete with its own collection of line items. Purchase order rows are selected from one table of type <code>PurchaseOrder_objtyp</code> for insertion into another table of that type.</p>
<p>The preceding <code>INSERT</code> statements use the customer-reference attribute of <code>PurchaseOrder_objtyp</code> to identify the customer to whom each of the existing purchase orders belongs. However, now that all the old purchase orders are copied from the purchase orders table into the upgraded <code>Customer_objtab</code>, this customer-reference attribute of a purchase order is obsolete. Now purchase orders are stored right in the customer object itself.</p>
<p>The following <code>ALTER</code> <code>TYPE</code> statement evolves <code>PurchaseOrder_objtyp</code> to drop the customer-reference attribute. The statement also drops the <code>ShipToAddr_obj</code> attribute as redundant, assuming that the shipping address is always the same as the customer address.</p>
<div id="ADOBJ7587" class="example">
<p class="titleinexample"><a id="sthref985"></a>Example A-45 Alter PurchaseOrder_objtyp</p>
<pre>ALTER TYPE PurchaseOrder_objtyp
    DROP ATTRIBUTE Cust_ref,
    DROP ATTRIBUTE ShipToAddr_obj
    CASCADE;
</pre></div>
<!-- class="example" -->
<p>This time we were able to use the <code>CASCADE</code> option to let the system perform validations and make all necessary changes to dependent types and tables.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7588" class="sect3"><a id="sthref986"></a>
<h4 class="sect3">Inserting a New Purchase Order with Line Items</h4>
<p>The previous <code>INSERT</code> example showed how to use the <code>VALUE()</code> function to select and insert into the nested table of purchase orders an existing purchase order object complete with its own nested table of line items. The following example shows how to insert a new purchase order that has not already been instantiated as a purchase order object. In this case, the purchase order&#39;s nested table of line items must be instantiated, as well as each line item object with its data. Line numbers are shown on the left for reference.</p>
<div id="ADOBJ7589" class="example">
<p class="titleinexample"><a id="sthref987"></a>Example A-46 Insert into LineItemList_ntabtyp with VALUE()</p>
<pre>INSERT INTO TABLE (                                             /* Line 1  */
  SELECT c.PurchaseOrderList_ntab                               /* Line 2  */
    FROM Customer_objtab c                                      /* Line 3  */
    WHERE c.CustName = &#39;John Nike&#39;                              /* Line 4  */
   )                                                            /* Line 5  */
  VALUES (1020, SYSDATE, SYSDATE + 1,                           /* Line 6  */
    LineItemList_ntabtyp(                                       /* Line 7  */
      LineItem_objtyp(1, MAKE_REF(Stock_objtab, 1004), 1, 0),   /* Line 8  */
      LineItem_objtyp(2, MAKE_REF(Stock_objtab, 1011), 3, 5),   /* Line 9  */
      LineItem_objtyp(3, MAKE_REF(Stock_objtab, 1535), 2, 10)   /* Line 10 */
      )                                                         /* Line 11 */
);                                                              /* Line 12 */
</pre></div>
<!-- class="example" -->
<p>Lines 1-5 use a <code>TABLE</code> expression to select the nested table to insert into&mdash;namely, the nested table of purchase orders for customer John Nike.</p>
<p>The <code>VALUES</code> clause (lines 6-12) contains a value for each attribute of the new purchase order, namely:</p>
<br/>
<code>PONo</code><br/>
<code>OrderDate</code><br/>
<code>ShipDate</code><br/>
<code>LineItemList_ntab</code><br/>
<p>Line 6 of the <code>INSERT</code> statement specifies values for the three purchase order attributes <code>PONo</code>, <code>OrderDate</code>, and <code>ShipDate</code>.</p>
<p>Only attribute values are given; no purchase order constructor is specified. You do not need to explicitly specify a purchase order constructor to instantiate a purchase order instance in the nested table because the nested table is declared to be a nested table of purchase orders. If you omit a purchase order constructor, the system instantiates a purchase order automatically. You can, however, specify the constructor if you want to, in which case the <code>VALUES</code> clause will look like this:</p>
<pre>INSERT INTO TABLE (
  SELECT c.PurchaseOrderList_ntab
    FROM Customer_objtab c
    WHERE c.CustName = &#39;John Nike&#39;
   )
VALUES (
  PurchaseOrder_objtyp(1025, SYSDATE, SYSDATE + 1,
    LineItemList_ntabtyp(
      LineItem_objtyp(1, MAKE_REF(Stock_objtab, 1004), 1, 0),
      LineItem_objtyp(2, MAKE_REF(Stock_objtab, 1011), 3, 5),
      LineItem_objtyp(3, MAKE_REF(Stock_objtab, 1535), 2, 10)
     )
  )
)
</pre>
<p>Lines 7-11 instantiate and supply data for a nested table of line items. The constructor method <code>LineItemList_ntabtyp(&hellip;)</code> creates an instance of such a nested table that contains three line items.</p>
<p>The line item constructor <code>LineItem_objtyp()</code> creates an object instance for each line item. Values for line item attributes are supplied as arguments to the constructor.</p>
<p>The <code>MAKE_REF</code> function creates a <code>REF</code> for the <code>Stock_ref</code> attribute of a line item. The arguments to <code>MAKE_REF</code> are the name of the stock table and the primary key value of the stock item there that we want to reference. We can use <code>MAKE_REF</code> here because object identifiers in the stock table are based on the primary key: if they were not, we would have to use the <code>REF</code> function in a subquery to get a <code>REF</code> to a row in the stock table.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7590" class="sect3"><a id="sthref988"></a>
<h4 class="sect3">Querying Multilevel Nested Tables</h4>
<p>You can query a top-level nested table column by naming it in the <code>SELECT</code> list like any other top-level (as opposed to embedded) column or attribute, but the result is not very readable. For instance, the following query selects the nested table of purchase orders for John Nike:</p>
<div id="ADOBJ7591" class="example">
<p class="titleinexample"><a id="sthref989"></a>Example A-47 Query Customer_objtab for Customer John Nike</p>
<pre>SELECT c.PurchaseOrderList_ntab
   FROM Customer_objtab c
   WHERE CustName = &#39;John Nike&#39;;
</pre></div>
<!-- class="example" -->
<p>The query produces a result similar to the following:</p>
<pre>PURCHASEORDERLIST_NTAB(PONO, ORDERDATE, SHIPDATE, LINEITEMLIST_NTAB(LINEITEMNO,
--------------------------------------------------------------------------------
PURCHASEORDERLIST_NTABTYP(PURCHASEORDER_OBJTYP(2001, &#39;25-SEP-01&#39;, &#39;20-MAY-97&#39;, L
INEITEMLIST_NTABTYP(LINEITEM_OBJTYP(10, 00004A038A00468ED552CE6A5803ACE034080020
B8C8340000001426010001000100290000000000090600812A00078401FE0000000B03C20B050000
...
</pre>
<p>For humans, at least, you probably want to display the instance data in an unnested form and not to show the <code>REF</code>s at all. <code>TABLE</code> expressions&mdash;this time in the <code>FROM</code> clause of a query&mdash;can help you do this.</p>
<p>For example, the query in <a href="#BABJHJBA">Example A-48</a> selects the PO number, order date, and shipdate for all purchase orders belonging to John Nike:</p>
<div id="ADOBJ7592" class="example">
<p class="titleinexample"><a id="BABJHJBA"></a>Example A-48 Query Customer_objtab Using TABLE Expression</p>
<pre>SELECT p.PONo, p.OrderDate, p.Shipdate
    FROM Customer_objtab c, TABLE(c.PurchaseOrderList_ntab) p
    WHERE c.CustName = &#39;John Nike&#39;;
</pre></div>
<!-- class="example" -->
<br/>
<code>PONO ORDERDATE SHIPDATE</code><br/>
<code>------- --------- ---------</code><br/>
<code>2001 25-SEP-01 26-SEP-01</code><br/>
<code>1020 25-SEP-01 26-SEP-01</code><br/>
<p>A <code>TABLE</code> expression takes a collection as an argument and can be used like a SQL table in SQL statements. In the preceding query, listing the nested table of purchase orders in a <code>TABLE</code> expression in the <code>FROM</code> clause enables us to select columns of the nested table just as if they were columns of an ordinary table. The columns are identified as belonging to the nested table by the table alias they use: <code>p</code>. As the example shows, a <code>TABLE</code> expression in the <code>FROM</code> clause can have its own table alias.</p>
<p>Inside the <code>TABLE</code> expression, the nested table is identified as a column of customer table <code>Customer_objtab</code> by the customer table&#39;s own table alias <code>c</code>. Note that the table <code>Customer_objtab</code> appears in the <code>FROM</code> clause before the <code>TABLE</code> expression that refers to it. This ability of a <code>TABLE</code> expressions to make use of a table alias that occurs to the left of it in the <code>FROM</code> clause is called left correlation. It enables you to daisy-chain tables and <code>TABLE</code> expressions&mdash;including <code>TABLE</code> expressions that make use of the table alias of another <code>TABLE</code> expression. In fact, this is how you are able to select columns of nested tables that are embedded in other nested tables.</p>
<p>Here, for example, is a query that selects information about all line items for PO number 1020:</p>
<div id="ADOBJ7593" class="example">
<p class="titleinexample"><a id="sthref990"></a>Example A-49 Query Customer_objtab for Purchase Order 1020</p>
<pre>SELECT p.PONo, i.LineItemNo, i.Stock_ref.StockNo, i.Quantity, i.Discount
  FROM Customer_objtab c, TABLE(c.PurchaseOrderList_ntab) p,
    TABLE(p.LineItemList_ntab) i
  WHERE p.PONo = 1020;
 
</pre></div>
<!-- class="example" -->
<br/>
<code>PONO LINEITEMNO STOCK_REF.STOCKNO QUANTITY DISCOUNT</code><br/>
<code>----- ---------- ----------------- ---------- ----------</code><br/>
<code>1020 1 1004 1 0</code><br/>
<code>1020 2 1011 3 5</code><br/>
<code>1020 3 1535 2 10</code><br/>
<p>The query uses two <code>TABLE</code> expressions, the second referring to the first. Line item information is selected from the inner nested table that belongs to purchase order number 1020 in the outer nested table.</p>
<p>Notice that no column from the customer table occurs in either the <code>SELECT</code> list or the <code>WHERE</code> clause. The customer table is listed in the <code>FROM</code> clause solely to provide a starting point from which to access the nested tables.</p>
<p>Here is a variation on the preceding query. This version shows that you can use the <code>*</code> wildcard to specify all columns of a <code>TABLE</code> expression collection:</p>
<pre>SELECT p.PONo, i.*
  FROM Customer_objtab c, TABLE(c.PurchaseOrderList_ntab) p,
    TABLE(p.LineItemList_ntab) i
  WHERE p.PONo = 1020;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADOBJ7594" class="sect2"><a id="sthref991"></a>
<h3 class="sect2">Type Inheritance and Substitutable Columns</h3>
<p>Suppose that we deal with a lot of our larger, regular customers through an account manager. We would like to add a field for the ID of the account manager to the customer record for these customers.</p>
<p>Earlier, when we wanted to add an attribute for a nested table of purchase orders, we evolved the customer type itself. We could do that again to add an attribute for account manager ID, or we could create a subtype of the customer type and add the attribute only in the subtype. Which should we do?</p>
<p>To make this kind of decision, you need to consider whether the proposed new attribute can be meaningfully and usefully applied to all instances of the base type&mdash;to all customers, in other words&mdash;or only to an identifiable subclass of the base type.</p>
<p>All customers have purchase orders, so it was appropriate to alter the type itself to add an attribute for them. But not all customers have an account manager; in fact, it happens that only our corporate customers do. So, instead of evolving the customer type to add an attribute that will not be meaningful for customers in general, it makes more sense to create a new subtype for the special <span class="italic">kind</span> of customer that we have identified and to add the new attribute there.</p>
<div id="ADOBJ7595" class="sect3"><a id="sthref992"></a>
<h4 class="sect3">Creating a Subtype</h4>
<p>You can create a subtype under a base type only if the base type allows subtypes. Whether a type can be subtyped depends on the type&#39;s <code>FINAL</code> property. By default, new types are created as <code>FINAL</code>. This means that they are the last of the series and cannot have subtypes created under them. To create a type that can be subtyped, you must specify <code>NOT</code> <code>FINAL</code> in the <code>CREATE</code> <code>TYPE</code> statement as we did when we created the customer type.</p>
<p>You define a subtype by using a <code>CREATE</code> <code>TYPE</code> statement with the <code>UNDER</code> keyword. The following statement creates a new subtype <code>Corp_Customer_objtyp</code> under <code>Customer_objtyp</code>. The type is created as <code>NOT</code> <code>FINAL</code> so that it can have subtypes if we want to add them later.</p>
<div id="ADOBJ7596" class="example">
<p class="titleinexample"><a id="sthref993"></a>Example A-50 Create Corp_Customer_objtyp</p>
<pre>CREATE TYPE Corp_Customer_objtyp UNDER Customer_objtyp
            (account_mgr_id     NUMBER(6) ) NOT FINAL;
/
</pre></div>
<!-- class="example" -->
<p>When you use a <code>CREATE</code> <code>TYPE</code> statement to create a new subtype, you list only the new attributes and methods that you are adding. The subtype inherits all existing attributes and methods from its base type, so these do not need to be specified. The new attributes and methods are added after the inherited ones. For example, the complete list of attributes for the new <code>Corp_Customer_objtyp</code> subtype looks like this:</p>
<br/>
<code>CustNo</code><br/>
<code>CustName</code><br/>
<code>Address_obj</code><br/>
<code>Phonelist_var</code><br/>
<code>PurchaseOrderList_ntab</code><br/>
<code>Account_mgr_id</code><br/>
<p>By default, you can store instances of a subtype in any column or object table that is of any base type of the subtype. This ability to store subtype instances in a base type slot is called substitutability. Columns and tables are substitutable unless they have been explicitly declared to be <code>NOT</code> <code>SUBSTITUTABLE</code>. The system automatically adds new columns for subtype attributes and another, hidden column for the type ID of the instance stored in each row.</p>
<p>Actually, it is possible to create a subtype of a <code>FINAL</code> type, but first you must use an <code>ALTER</code> <code>TYPE</code> statement to evolve the type from a <code>FINAL</code> type to a <code>NOT</code> <code>FINAL</code> one. If you want existing columns and tables of the altered type to be able to store instances of new subtypes, specify the <code>CASCADE</code> option <code>CONVERT</code> <code>TO</code> <code>SUBSTITUTABLE</code> in the <code>ALTER</code> <code>TYPE</code> statement. See <a href="adobjadv.htm#i1006726">&#34;Type Evolution&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7597" class="sect3"><a id="sthref994"></a>
<h4 class="sect3">Inserting Subtypes</h4>
<p>If a column or object table is substitutable, you can insert into it not only instances of the declared type of the column or table but also instances of any subtype of the declared type. In the case of table <code>Customer_objtab</code>, this means that the table can be used to store information about all kinds of customers, both ordinary and corporate. However, there is one important difference in the way information is inserted for a subtype: you must explicitly specify the subtype&#39;s constructor. Use of the constructor is optional only for instances of the declared type of the column or table.</p>
<p>For example, the following statement inserts a new ordinary customer, William Kidd.</p>
<div id="ADOBJ7598" class="example">
<p class="titleinexample"><a id="sthref995"></a>Example A-51 Insert Data for Ordinary Customer</p>
<pre>INSERT INTO Customer_objtab
  VALUES (
    3, &#39;William Kidd&#39;,
    Address_objtyp(&#39;43 Harbor Drive&#39;, &#39;Redwood Shores&#39;, &#39;CA&#39;, &#39;95054&#39;),
    PhoneList_vartyp(&#39;650-555-0188&#39;),
    PurchaseOrderList_ntabtyp()
  );
</pre></div>
<!-- class="example" -->
<p>The <code>VALUES</code> clause contains data for each <code>Customer_objtyp</code> attribute but omits the <code>Customer_objtyp</code> constructor. The constructor is optional here because the declared type of the table is <code>Customer_objtyp</code>. For the nested table attribute, the constructor <code>PurchaseOrderList_ntabtyp()</code> creates an empty nested table, but no data is specified for any purchase orders.</p>
<p>Here is a statement that inserts a new corporate customer in the same table. Note the use of the constructor <code>Corp_Customer_objtyp()</code> and the extra data value <code>531</code> for the account manager ID:</p>
<div id="ADOBJ7599" class="example">
<p class="titleinexample"><a id="sthref996"></a>Example A-52 Insert Data for Corporate Customer</p>
<pre>INSERT INTO Customer_objtab
  VALUES (
    Corp_Customer_objtyp(   -- Subtype requires a constructor
      4, &#39;Edward Teach&#39;,
      Address_objtyp(&#39;65 Marina Blvd&#39;, &#39;San Francisco&#39;, &#39;CA&#39;, &#39;94777&#39;),
      PhoneList_vartyp(&#39;415-555-0198&#39;, &#39;415-555-0199&#39;),
      PurchaseOrderList_ntabtyp(), 531
    )
  );
</pre></div>
<!-- class="example" -->
<p>The following statements insert a purchase order for each of the two new customers. Unlike the statements that insert the new customers, the two statements that insert purchase orders are structurally the same except for the number of line items in the purchase orders:</p>
<div id="ADOBJ7600" class="example">
<p class="titleinexample"><a id="sthref997"></a>Example A-53 Insert Purchase Order for Ordinary Customer</p>
<pre>INSERT INTO TABLE (
  SELECT c.PurchaseOrderList_ntab
    FROM Customer_objtab c
    WHERE c.CustName = &#39;William Kidd&#39;
   )
  VALUES (1021, SYSDATE, SYSDATE + 1,
    LineItemList_ntabtyp(
      LineItem_objtyp(1, MAKE_REF(Stock_objtab, 1535), 2, 10),
      LineItem_objtyp(2, MAKE_REF(Stock_objtab, 1534), 1, 0)
     )
   );
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7601" class="example">
<p class="titleinexample"><a id="sthref998"></a>Example A-54 Insert Purchase Order for Corporate Customer</p>
<pre>INSERT INTO TABLE (
  SELECT c.PurchaseOrderList_ntab
    FROM Customer_objtab c
    WHERE c.CustName = &#39;Edward Teach&#39;
   )
  VALUES (1022, SYSDATE, SYSDATE + 1,
    LineItemList_ntabtyp(
      LineItem_objtyp(1, MAKE_REF(Stock_objtab, 1011), 1, 0),
      LineItem_objtyp(2, MAKE_REF(Stock_objtab, 1004), 3, 0),
      LineItem_objtyp(3, MAKE_REF(Stock_objtab, 1534), 2, 0)
     )
   );
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADOBJ7602" class="sect3"><a id="sthref999"></a>
<h4 class="sect3">Querying Substitutable Columns</h4>
<p>A substitutable column or table can contain data of several data types. This enables you, for example, to retrieve information about all kinds of customers with a single query of the customers table. But you can also retrieve information just about a particular kind of customer, or about a particular attribute of a particular kind of customer.</p>
<p>The following examples show some useful techniques for getting the information you want from a substitutable table or column.</p>
<p>The query in <a href="#BABGFFII">Example A-55</a> uses a <code>WHERE</code> clause that contains an <code>IS</code> <code>OF</code> predicate to filter out customers that are not some kind of corporate customer. In other words, the query returns all kinds of corporate customers but does not return instances of any other kind of customer:</p>
<div id="ADOBJ7603" class="example">
<p class="titleinexample"><a id="BABGFFII"></a>Example A-55 Selecting All Corporate Customers and Their Subtypes</p>
<pre>SELECT c.*
  FROM Customer_objtab c
  WHERE VALUE(c) IS OF (Corp_Customer_objtyp);
</pre></div>
<!-- class="example" -->
<p>The query in <a href="#BABGEFID">Example A-56</a> is similar to the preceding one except that it adds the <code>ONLY</code> keyword in the <code>IS</code> <code>OF</code> predicate to filter out any subtypes of <code>Corp_Customer_objtyp</code>. Rows are returned only for instances whose most specific type is <code>Corp_Customer_objtyp</code>.</p>
<div id="ADOBJ7604" class="example">
<p class="titleinexample"><a id="BABGEFID"></a>Example A-56 Selecting All Corporate Customers with No Subtypes</p>
<pre>SELECT p.PONo
  FROM Customer_objtab c, TABLE(c.PurchaseOrderList_ntab) p
  WHERE VALUE(c) IS OF (ONLY Corp_Customer_objtyp);
</pre></div>
<!-- class="example" -->
<p>The query in <a href="#BABGBHBA">Example A-57</a> uses a <code>TABLE</code> expression to get purchase order numbers (from the nested table of purchase orders). Every kind of customer has this attribute, but the <code>WHERE</code> clause confines the search just to corporate customers:</p>
<div id="ADOBJ7605" class="example">
<p class="titleinexample"><a id="BABGBHBA"></a>Example A-57 Selecting PONo Just for Corporate Customers</p>
<pre>SELECT p.PONo
  FROM Customer_objtab c, TABLE(c.PurchaseOrderList_ntab) p
  WHERE VALUE(c) IS OF (Corp_Customer_objtyp);
</pre></div>
<!-- class="example" -->
<p>The query in <a href="#BABEDDJF">Example A-58</a> returns data for account manager ID. This is an attribute possessed only by the corporate customer subtype: the declared type of the table lacks it. In the query the <code>TREAT()</code> function is used to cause the system to try to regard or treat each customer as a corporate customer in order to access the subtype attribute <code>Account_mgr_id</code>:</p>
<div id="ADOBJ7606" class="example">
<p class="titleinexample"><a id="BABEDDJF"></a>Example A-58 Selecting a Subtype Attribute Using the TREAT Function</p>
<pre>SELECT CustName, TREAT(VALUE(c) AS Corp_Customer_objtyp).Account_mgr_id
  FROM Customer_objtab c
  WHERE VALUE(c) IS OF (ONLY Corp_Customer_objtyp);
</pre></div>
<!-- class="example" -->
<p><code>TREAT()</code> is necessary in <a href="#BABEDDJF">Example A-58</a> because <code>Account_mgr_id</code> is not an attribute of the table&#39;s declared type <code>Customer_objtyp</code>. If you simply list the attribute in the <code>SELECT</code> list as if it were, a query like the one in <a href="#BABGGDFJ">Example A-59</a> will return the error <code>invalid</code> <code>column</code> <code>name</code> error. This is so even with a <code>WHERE</code> clause that excludes all but instances of <code>Corp_Customer_objtyp</code>. The <code>WHERE</code> clause is not enough here because it merely excludes rows from the result.</p>
<div id="ADOBJ7607" class="example">
<p class="titleinexample"><a id="BABGGDFJ"></a>Example A-59 Selecting a Subtype Attribute Without the TREAT Function</p>
<pre>-- Following statement returns error, invalid column name for Account_mgr_id
SELECT CustName, Account_mgr_id
  FROM Customer_objtab c
  WHERE VALUE(c) IS OF (ONLY Corp_Customer_objtyp);
</pre></div>
<!-- class="example" -->
<p>Every substitutable column or object table has an associated hidden type-ID column that identifies the type of the instance in each row. You can look up the type ID of a type in the <code>USER_TYPES</code> catalog view.</p>
<p>The function <code>SYS_TYPEID()</code> returns the type ID of a particular instance. The query in <a href="#BABCDHBA">Example A-60</a> uses <code>SYS_TYPEID()</code> and a join on the <code>USER_TYPES</code> catalog view to return the type name of each customer instance in the table <code>Customer_objtab</code>:</p>
<div id="ADOBJ7608" class="example">
<p class="titleinexample"><a id="BABCDHBA"></a>Example A-60 Discovering the Type of Each Instance</p>
<pre>SELECT c.CustName, u.TYPE_NAME
  FROM Customer_objtab c, USER_TYPES u
  WHERE SYS_TYPEID(VALUE(c)) = u.TYPEID;
</pre></div>
<!-- class="example" -->
<br/>
<code>--------------------------------- ---------------------</code><br/>
<code>Jean Nance CUSTOMER_OBJTYP</code><br/>
<code>John Nike CUSTOMER_OBJTYP</code><br/>
<code>William Kidd CUSTOMER_OBJTYP</code><br/>
<code>Edward Teach CORP_CUSTOMER_OBJTYP</code><br/>
<p>For more information on <code>SYS_TYPEID()</code>, <code>VALUE()</code>, and <code>TREAT()</code>, see <a href="adobjbas.htm#i463707">&#34;Functions and Operators Useful with Objects&#34;</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="appendix" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3980">
<tr>
<td class="cellalignment3987">
<table class="cellalignment3985">
<tr>
<td class="cellalignment3984"><a href="adobjdes.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3984"><a href="glossary.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3989">
<table class="cellalignment3983">
<tr>
<td class="cellalignment3984"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3984"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3984"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3984"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3984"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3984"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>