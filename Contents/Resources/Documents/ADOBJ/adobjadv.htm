<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-740"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Advanced%20Topics%20for%20Oracle%20Objects"></a><title>Advanced Topics for Oracle Objects</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-08-06T13:19:6Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Object-Relational Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53277-02"/>
<meta name="dcterms.isVersionOf" content="ADOBJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="adobjmng.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adobjdes.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53277-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/16</span> <!-- End Header -->
<div id="ADOBJ006" class="chapter"><a id="g1019159"></a> <a id="i1006903"></a>
<h1 class="chapter"><span class="secnum">8</span> Advanced Topics for Oracle Objects</h1>
<p>The previous chapters in this book discuss topics that you need to get started with Oracle objects. The topics in this chapter are of interest once you start applying object-relational techniques to large-scale applications or complex schemas.</p>
<p>The chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1002766">Storage of Objects</a></p>
</li>
<li>
<p><a href="#CHDCHEAG">Creating Indexes on Typeids or Attributes</a></p>
</li>
<li>
<p><a href="#i1006726">Type Evolution</a></p>
</li>
<li>
<p><a href="#CHDECFFH">System-Defined and User-Defined Constructors</a></p>
</li>
<li>
<p><a href="#i1008081">Transient and Generic Types</a></p>
</li>
<li>
<p><a href="#i1006758">User-Defined Aggregate Functions</a></p>
</li>
<li>
<p><a href="#CHDDGIAG">How Locators Improve the Performance of Nested Tables</a></p>
</li>
</ul>
<a id="i1002766"></a>
<div id="ADOBJ00601" class="sect1">
<h2 class="sect1">Storage of Objects<a id="sthref665"></a><a id="sthref666"></a></h2>
<p>Oracle database automatically maps the complex structure of object types into simple table structure for storage.</p>
<p>This section discusses these related topics:</p>
<ul>
<li>
<p><a href="#CHDEJCDC">Leaf-Level Attributes</a></p>
</li>
<li>
<p><a href="#CHDCADHB">How Row Objects Are Split Across Columns</a></p>
</li>
<li>
<p><a href="#CHDCFBJI">Hidden Columns for Tables with Column Objects</a></p>
</li>
<li>
<p><a href="#i1010837">Hidden Columns for Substitutable Columns and Object Tables</a></p>
</li>
<li>
<p><a href="#CHDEJHFC">Storage of REFs</a></p>
</li>
<li>
<p><a href="#i1003247">Internal Layout of Nested Tables</a></p>
</li>
<li>
<p><a href="#i1002824">Internal Layout of VARRAYs</a></p>
</li>
</ul>
<a id="CHDEJCDC"></a>
<div id="ADOBJ7388" class="sect2">
<h3 class="sect2">Leaf-Level Attributes<a id="sthref667"></a><a id="sthref668"></a><a id="sthref669"></a></h3>
<p>An object type is like a tree structure, where the branches represent the attributes. Attributes that are objects sprout subbranches with their own attributes.</p>
<p>Ultimately, each branch ends at an attribute that is a built-in type; such as <code>NUMBER</code>, <code>VARCHAR2</code>, or <code>REF</code>, or a collection type, such as <code>VARRAY</code> or nested table. Each of these leaf-level attributes of the original object type is stored in a table column.</p>
<p>Leaf-level attributes that are not collection types are called the <a href="glossary.htm#CHDHABDA"><span class="xrefglossterm">leaf-level scalar attribute</span></a>s of the object type.</p>
<p>The following topics relate to the discussion of object tables and relational tables in <a href="adobjint.htm#i458240">&#34;How Objects are Stored in Tables&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDCADHB"></a>
<div id="ADOBJ7389" class="sect2">
<h3 class="sect2">How Row Objects Are Split Across Columns<a id="sthref670"></a><a id="sthref671"></a><a id="sthref672"></a><a id="sthref673"></a><a id="sthref674"></a></h3>
<p>In an <a href="glossary.htm#CHDGBJDA"><span class="xrefglossterm">object table</span></a>, Oracle database stores the data for every leaf-level scalar or <code>REF</code> attribute in a separate column.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Each <code>VARRAY</code> is also stored in a column, unless it is too large. Oracle database stores leaf-level attributes of nested table types in separate tables associated with the object table. You must declare these tables as part of the object table declaration. See <a href="#i1002824">&#34;Internal Layout of VARRAYs&#34;</a> and <a href="#i1003247">&#34;Internal Layout of Nested Tables&#34;</a>.</div>
<p>When you retrieve or change attributes of <a href="glossary.htm#CHDCGBAB"><span class="xrefglossterm">row object</span></a>s in an object table, the database performs the corresponding operations on the columns of the table. Accessing the value of the <a href="glossary.htm#CHDCGBAB"><span class="xrefglossterm">row object</span></a> itself invokes the default constructor for the type, using the columns of the object table as arguments and produces a copy of the object.</p>
<p>The database stores the system-generated object identifier in a hidden column. The database uses the object identifier to construct <code>REF</code>s to the object.</p>
</div>
<!-- class="sect2" -->
<a id="CHDCFBJI"></a>
<div id="ADOBJ7390" class="sect2">
<h3 class="sect2">Hidden Columns for Tables with Column Objects<a id="sthref675"></a></h3>
<p>When a table (relational table) is defined with a column of an object type, the database adds hidden columns to the table for the leaf-level attributes of the object type. Each object-type column also has a corresponding hidden column to store the NULL information for the column objects (that is, the atomic nulls of the top-level and the nested objects).</p>
</div>
<!-- class="sect2" -->
<a id="i1010837"></a>
<div id="ADOBJ7391" class="sect2">
<h3 class="sect2">Hidden Columns for Substitutable Columns and Object Tables</h3>
<p>A substitutable column or object table has a hidden column not only for each attribute of the object type of the column but also for each attribute added in any subtype of the object type. These columns store the values of those attributes for any subtype instances inserted in the substitutable column.</p>
<p>Besides the type-discriminant column and the null-image column, the following are associated with a substitutable column of <code>person_typ</code>, created by <a href="#CJGBCCID">Example 8-1</a></p>
<ul>
<li>
<p>A hidden column for each of the attributes of <code>person_typ</code>: <code>idno</code>, <code>name</code>, and <code>phone</code></p>
</li>
<li>
<p>Hidden columns for attributes of the subtypes of <code>person_typ</code></p>
</li>
</ul>
<p>Thus, the following might be associated with a substitutable column of <code>person_typ</code>: the attributes <code>dept_id</code> and <code>major</code> (for <code>student_typ</code>) and <code>number_hours</code> (for <code>part_time_student_typ</code>).</p>
<p>When you create a subtype, the database automatically adds hidden columns for new attributes in the subtype to tables containing a substitutable column of any of the ancestor types of the new subtype. These retrofit the tables to store data of the new type. If, for some reason, the columns cannot be added, creation of the subtype is rolled back.</p>
<p>When you drop a subtype using <code>DROP TYPE</code> with the <code>VALIDATE</code> option, the database automatically drops hidden columns for attributes unique to the subtype that do not contain data. Errors are raised if these columns contain data.</p>
<p><a href="#CJGBCCID">Example 8-1</a> creates types needed for subsequent examples in this chapter</p>
<div id="ADOBJ7392" class="example">
<p class="titleinexample"><a id="CJGBCCID"></a>Example 8-1 Creating Types and Inserting in Tables</p>
<pre>-- drop any of these objects created for Ex.7-10
CREATE TYPE person_typ AS OBJECT (
  idno           NUMBER,
  name           VARCHAR2(30),
  phone          VARCHAR2(20),
  MAP MEMBER FUNCTION get_idno RETURN NUMBER )
  NOT FINAL;
/
CREATE TYPE BODY person_typ AS
  MAP MEMBER FUNCTION get_idno RETURN NUMBER IS
  BEGIN
    RETURN idno;
  END;
END;
/
CREATE TYPE student_typ UNDER person_typ (
    dept_id NUMBER,
    major VARCHAR2(30))
NOT FINAL;
/
CREATE TYPE part_time_student_typ UNDER student_typ (
  number_hours NUMBER);
/
CREATE TYPE employee_typ UNDER person_typ (
    emp_id NUMBER, 
    mgr VARCHAR2(30));
/
CREATE TABLE person_obj_table OF person_typ;  // an object table
INSERT INTO person_obj_table 
  VALUES (person_typ(12, &#39;Bob Jones&#39;, &#39;650-555-0130&#39;));
INSERT INTO person_obj_table 
  VALUES (student_typ(51, &#39;Joe Lane&#39;, &#39;1-650-555-0140&#39;, 12, &#39;HISTORY&#39;));
INSERT INTO person_obj_table 
  VALUES (part_time_student_typ(52, &#39;Kim Patel&#39;, &#39;1-650-555-0135&#39;, 14,
          &#39;PHYSICS&#39;, 20));
</pre></div>
<!-- class="example" -->
<p>Substitutable columns are associated with hidden type-discriminant columns. The hidden columns contains an identifier, called a typeid, that identifies the most specific type of each object in the substitutable columns. Typically, a typeid (<code>RAW</code>) is one byte, though it can be as big as four bytes for a large hierarchy.</p>
<p>You can find the typeid of a specified object instance using the function <code>SYS_TYPEID</code>.</p>
<p><a href="#CHDICDCE">Example 8-2</a> retrieves typeids of object instances stored in the substitutable object table created in <a href="#CJGBCCID">Example 8-1</a>:</p>
<div id="ADOBJ7654" class="example">
<p class="titleinexample"><a id="CHDICDCE"></a>Example 8-2 Querying for Typeids of Objects Stored in the Table</p>
<pre>-- Requires Ex. 8-1
SELECT name, <span class="bold">SYS_TYPEID</span>(VALUE(p)) typeid 
  FROM person_obj_table p;
</pre></div>
<!-- class="example" -->
<br/>
<code>NAME TYPEID</code><br/>
<code>------------------------------ ---------------------------</code><br/>
<code>Bob Jones 01</code><br/>
<code>Joe Lane 02</code><br/>
<code>Kim Patel 03</code><br/>
<p>The catalog views <code>USER_TYPES</code>, <code>DBA_TYPES,</code> and <code>ALL_TYPES</code> contain a <code>TYPEID</code> column (not hidden) that gives the typeid value for each type. You can join on this column to get the type names corresponding to the typeids in a type-discriminant column.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjbas.htm#i465365">&#34;SYS_TYPEID&#34;</a> for more information about <code>SYS_TYPEID</code>, typeids, and type-discriminant columns.</div>
</div>
<!-- class="sect2" -->
<a id="CHDEJHFC"></a>
<div id="ADOBJ7393" class="sect2">
<h3 class="sect2">Storage of REFs<a id="sthref676"></a><a id="sthref677"></a><a id="sthref678"></a><a id="sthref679"></a><a id="sthref680"></a><a id="sthref681"></a></h3>
<p>When the database constructs a <code>REF</code> to a row object, the constructed <code>REF</code> is made up of the object identifier (OID), some metadata of the object table, and, optionally, the <code>ROWID</code>.</p>
<p>The size of a <code>REF</code> in a column of <code>REF</code> type depends on the storage requirements associated with the column, as follows:</p>
<ul>
<li>
<p>If the column is declared as a <code>REF</code> <code>WITH</code> <code>ROWID</code>, the database stores the <code>ROWID</code> in the <code>REF</code> column. The <code>ROWID</code> hint is ignored for object references in constrained <code>REF</code> columns.</p>
</li>
<li>
<p>If a column is declared as a <code>REF</code> with a <code>SCOPE</code> clause, the column decreases due to the omission of the object table metadata and the <code>ROWID</code>. A scoped <code>REF</code> is 16 bytes long.</p>
</li>
</ul>
<p>If the object identifier is primary-key based, the database may create one or more internal columns to store the values of the primary key, depending on how many columns comprise the primary key.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When a <code>REF</code> column references row objects whose object identifiers are derived from primary keys, it is referred to as a primary-key-based <code>REF</code> or <code>pkREF</code>. Columns containing <code>pkREF</code>s must be scoped or have a referential constraint.</div>
</div>
<!-- class="sect2" -->
<a id="i1003247"></a>
<div id="ADOBJ7394" class="sect2">
<h3 class="sect2">Internal Layout of Nested Tables<a id="sthref682"></a></h3>
<p><a id="i1002816"></a>The rows of a nested table are stored in a separate storage table. Each nested table column has a single associated storage table. The storage table holds all the elements for all of the nested tables in that column. The storage table has a hidden <code>NESTED_TABLE_ID</code> column with a system-generated value that lets Oracle database map the nested table elements back to the appropriate row.</p>
<p>You can speed up queries that retrieve entire collections by making the storage table index-organized. Include the <code>ORGANIZATION&nbsp;INDEX</code> clause inside the <code>STORE&nbsp;AS</code> clause.</p>
<p>See <a href="adobjdes.htm#i448918">&#34;Nested Table Storage&#34;</a>.</p>
<p>A nested table type can contain objects or scalars:</p>
<ul>
<li>
<p>If the elements are objects, the storage table is like an object table: the top-level attributes of the object type become the columns of the storage table. However, you cannot construct <code>REF</code>s to objects in a nested table because a nested table row has no object identifier column.</p>
</li>
<li>
<p>If the elements are scalars, the storage table contains a single column called <code>COLUMN_VALUE</code> that contains the scalar values.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1002824"></a>
<div id="ADOBJ7395" class="sect2">
<h3 class="sect2">Internal Layout of VARRAYs</h3>
<p>All the elements of a <code>VARRAY</code> are stored in a single column. Depending upon the size of the array, it may be stored inline or in a <code>BLOB</code>. See <a href="adobjdes.htm#i450743">Storage Considerations for Varrays</a> for details.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCHEAG"></a>
<div id="ADOBJ00602" class="sect1">
<h2 class="sect1">Creating Indexes on Typeids or Attributes</h2>
<p>This section discusses the use of indexes on typeids and attributes.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDIAGHI">Indexing a Type-Discriminant Column</a></p>
</li>
<li>
<p><a href="#CHDIGJEJ">Indexing Subtype Attributes of a Substitutable Column</a></p>
</li>
</ul>
<a id="CHDIAGHI"></a>
<div id="ADOBJ7396" class="sect2">
<h3 class="sect2">Indexing a Type-Discriminant Column<a id="sthref683"></a><a id="sthref684"></a><a id="sthref685"></a><a id="sthref686"></a><a id="sthref687"></a><a id="sthref688"></a></h3>
<p>Using the <code>SYS_TYPEID</code> function, you can build an index on the hidden type-discriminant column of substitutable columns. The type-discriminant column contains typeids that identify the most specific type of every object instance stored in the substitutable column. The system uses this information to evaluate queries that filter by type using the <code>IS OF</code> predicate, but you can access the typeids for your own purposes using the <code>SYS_TYPEID</code> function.</p>
<p>Generally, a type-discriminant column contains only a small number of distinct typeids: at most, there can be only as many as there are types in the related type hierarchy. The low cardinality of this column makes it a good candidate for a bitmap index.</p>
<p>For example, the following statement creates a bitmap index on the type-discriminant column underlying the substitutable <code>contact</code> column of table <code>contacts</code>. The function <code>SYS_TYPEID</code> references the type-discriminant column:</p>
<div id="ADOBJ7655" class="example">
<p class="titleinexample"><a id="sthref689"></a>Example 8-3 Create bitmap index on type-discriminant column</p>
<pre>-- Requires Ex. 8-1
CREATE TABLE contacts (
  contact         person_typ,
  contact_date    DATE );
INSERT INTO contacts VALUES (
  person_typ (65,&#39;Vrinda Mills&#39;, &#39;1-650-555-0125&#39;),&#39;24 Jun 2003&#39; );
INSERT INTO contacts VALUES (
  person_typ (12, &#39;Bob Jones&#39;, &#39;650-555-0130&#39;),&#39;24 Jun 2003&#39; );
INSERT INTO contacts VALUES (
  student_typ(51, &#39;Joe Lane&#39;, &#39;1-650-555-0140&#39;, 12, &#39;HISTORY&#39;),&#39;24 Jun 2003&#39; );
INSERT INTO contacts VALUES ( part_time_student_typ(52, &#39;Kim Patel&#39;, &#39;1-650-555-0135&#39;, 14, &#39;PHYSICS&#39;, 20),&#39;24 Jun 2003&#39; ); 
<span class="bold">CREATE BITMAP INDEX</span> typeid_idx ON contacts (<span class="bold">SYS_TYPEID</span>(contact));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDIGJEJ"></a>
<div id="ADOBJ7397" class="sect2">
<h3 class="sect2">Indexing Subtype Attributes of a Substitutable Column<a id="sthref690"></a><a id="sthref691"></a></h3>
<p>You can build an index on attributes for any types that can be stored in a substitutable column. You can reference attributes of subtypes in the <code>CREATE INDEX</code> statement by filtering out types other than the desired subtype (and its subtypes) using the <code>TREAT</code> function; you then use dot notation to specify the desired attribute.</p>
<p>For example, the following statement creates an index on the <code>major</code> attribute of all students in the <code>contacts</code> table. The declared type of the <code>contact</code> column is <code>person_typ</code>, of which <code>student_typ</code> is a subtype, so the column may contain instances of <code>person_typ</code>, <code>student_typ</code>, and subtypes of either one:</p>
<div id="ADOBJ7656" class="example">
<p class="titleinexample"><a id="sthref692"></a>Example 8-4 Create index on attribute of all students</p>
<pre>-- Requires Ex.8-1- and 8-3
<span class="bold">CREATE INDEX</span> major1_idx ON contacts 
  (TREAT(contact AS student_typ).<span class="bold">major</span>);
</pre></div>
<!-- class="example" -->
<p>The <code>student_typ</code> type first defined the <code>major</code> attribute: the <code>person_typ</code> supertype does not have it. Consequently, all the values in the hidden column for the <code>major</code> attribute are values for persons of type <code>student_typ</code> or <code>parttimestudent_typ</code> (a <code>student_typ</code> subtype). This means that the values of the hidden column are identical to the values returned by the <code>TREAT</code> expression, <code>major</code> values for all students, including student subtypes: both the hidden column and the <code>TREAT</code> expression list majors for students and nulls for non-students. The system exploits this fact and creates index <code>major1_idx</code> as an ordinary B-tree index on the hidden column.</p>
<p>Values in a hidden column are only identical to the values returned by the <code>TREAT</code> expression just described if the type named as the target of the <code>TREAT</code> function (<code>student_typ</code>) is the type that first defined the <code>major</code> attribute. If the target of the <code>TREAT</code> function is a subtype that merely inherited the attribute, as in the following example, the <code>TREAT</code> expression returns non-null <code>major</code> values for the subtype (part-time students) but not for its supertype (other students).</p>
<pre>CREATE INDEX major2_idx ON contacts 
  (TREAT(contact AS part_time_student_typ).major);
</pre>
<p>Here, the values stored in the hidden column for <code>major</code> may be different from the results of the <code>TREAT</code> expression. Consequently, an ordinary B-tree index cannot be created on the underlying column. Therefore, the database treats the <code>TREAT</code> expression like any other function-based expression and tries to create the index as a function-based index on the result.</p>
<p>The following example, like the previous one, creates a function-based index on the <code>major</code> attribute of part-time students, but in this case, the hidden column for <code>major</code> is associated with a substitutable object table <code>person_obj_table</code>:</p>
<pre>CREATE INDEX major3_idx ON person_obj_table p 
  (TREAT(VALUE(p) AS part_time_student_typ).major);
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006726"></a>
<div id="ADOBJ00603" class="sect1">
<h2 class="sect1">Type Evolution<a id="sthref693"></a><a id="sthref694"></a></h2>
<p>Type evolution is the process of changing a object type. You can make the following changes to an object type:</p>
<ul>
<li>
<p>Add and drop attributes</p>
</li>
<li>
<p>Add and drop methods</p>
</li>
<li>
<p>Modify a numeric attribute to increase its length, precision, or scale</p>
</li>
<li>
<p>Modify a varying length character attribute to increase its length</p>
</li>
<li>
<p>Change the <code>FINAL</code> and <code>INSTANTIABLE</code> properties of a type</p>
</li>
<li>
<p>Modify limit and size of <code>VARRAY</code>s</p>
</li>
<li>
<p>Modify length, precision, and scale of collection elements</p>
</li>
</ul>
<p>Changes to a type affect things that reference the type. For example, if you add a new attribute to a type, data in a column of that type must be presented so as to include the new attribute.</p>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDBABJG">Type Evolution and Dependent Schema Objects</a></p>
</li>
<li>
<p><a href="#CHDFJEHC">Options for Updating Data</a></p>
</li>
<li>
<p><a href="#CHDFAFAI">Effects of Structural Changes to Types</a></p>
</li>
<li>
<p><a href="#CHDHBHDG">Altering a Type by Adding a Nested Table Attribute</a></p>
</li>
<li>
<p><a href="#CHDHFDEI">Validating a Type That Has Been Altered</a></p>
</li>
<li>
<p><a href="#i1006520">If a Type Change Validation Fails</a></p>
</li>
<li>
<p><a href="#i1007112">ALTER TYPE Statement for Type Evolution</a></p>
</li>
<li>
<p><a href="#CHDDAFEF">ALTER TABLE Statement for Type Evolution</a></p>
</li>
</ul>
<a id="CHDBABJG"></a>
<div id="ADOBJ7657" class="sect2">
<h3 class="sect2">Type Evolution and Dependent Schema Objects</h3>
<p>Dependent schema objects of a type are objects that directly or indirectly reference the type and are affected by a change to it.</p>
<p>A type can have these kinds of dependent schema objects: tables; types or subtypes; program units (PL/SQL blocks) such as procedures, functions, packages, and triggers; indextypes; views (including object views); function-based indexes; and operators.</p>
<p>How a dependent schema object is affected by a change to a type depends on the object and on the nature of the change.</p>
<ul>
<li>
<p>Dependent program units, views, operators, and indextypes are marked invalid when the type is modified. The next time one of these invalid schema objects is referenced, it is revalidated using the new type definition. If the object recompiles successfully, it becomes valid and can be used again.</p>
</li>
<li>
<p>Dependent function-based indexes may be dropped or disabled, depending on the type change, and must be rebuilt.</p>
</li>
<li>
<p>Dependent tables have one or more internal columns added for each attribute added to the type, depending on the attribute type. New attributes are added with <code>NULL</code> values. For each dropped attribute, the columns associated with that attribute are dropped. For each modified attribute, the length, precision, or scale of its associated column is changed accordingly.</p>
</li>
</ul>
<p>These changes mainly involve updating the metadata of the tables and can be performed quickly. However, the data in those tables must be updated to the format of the new type version as well, as discussed in <a href="#CHDFJEHC">&#34;Options for Updating Data&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFJEHC"></a>
<div id="ADOBJ7658" class="sect2">
<h3 class="sect2">Options for Updating Data</h3>
<p>Depending on the amount of data, updating can be time-consuming, so the <code>ALTER TYPE</code> command has options to let you choose whether to convert all dependent table data immediately or to leave it in the old format to be converted piecemeal as it is updated in the course of business.</p>
<p>The <code>CASCADE</code> option for <code>ALTER TYPE</code> propagates a type change to dependent types and tables. See <a href="#i1007112">&#34;ALTER TYPE Statement for Type Evolution&#34;</a>. <code>CASCADE</code> itself has the following options that let you choose whether or not to convert table data to the new type format as part of the propagation:</p>
<ul>
<li>
<p><code>INCLUDING TABLE DATA</code>: converts the data (default)</p>
</li>
<li>
<p><code>NOT INCLUDING TABLE DATA</code> : does not convert data</p>
</li>
</ul>
<p>By default, the <code>CASCADE</code> option converts the data. In either case, table data is always returned in the format of the latest type version. If the table data is stored in the format of an earlier type version, the database converts the data to the format of the latest version before returning it, even though the format in which the data is actually stored is not changed until the data is rewritten.</p>
<p>You can retrieve the definition of the latest type from the system view <code>USER_SOURCE</code>. You can view definitions of all versions of a type in the <code>USER_TYPE_VERSIONS</code> view.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a class="olink LNPLS01375" href="../LNPLS/create_type.htm#LNPLS01375"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for details about type specification and body compilation</p>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDFAFAI"></a>
<div id="ADOBJ7398" class="sect2">
<h3 class="sect2">Effects of Structural Changes to Types</h3>
<p>Structural changes to a type affect dependent data and require the data to be converted. This is not true for changes that are confined to method definitions or behavior (implementation) of the type.</p>
<p>These possible changes to a type are structural:</p>
<ul>
<li>
<p>Add or drop an attribute</p>
</li>
<li>
<p>Modify the length, precision, or scale of an attribute</p>
</li>
<li>
<p>Change the finality of a type from <code>FINAL</code> to <code>NOT FINAL</code> or the reverse</p>
</li>
</ul>
<p>These changes result in new versions of the altered type and all its dependent types and require the system to add, drop, or modify internal columns of dependent tables as part of the process of converting to the new version.</p>
<p>When you make any of these kinds of changes to a type that has dependent types or tables, the effects of propagating the change are not confined only to metadata but also affect data storage arrangements and require data conversion.</p>
<p>Besides converting data, you may also need to make other changes. For example, if a new attribute is added to a type, and the type body invokes the constructor of the type, then each constructor in the type body must be modified to specify a value for the new attribute. Similarly, if a new method is added, then the type body must be replaced to add the implementation of the new method. The type body can be modified by using the <code>CREATE OR REPLACE TYPE BODY</code> statement.</p>
</div>
<!-- class="sect2" -->
<div id="ADOBJ7659" class="sect2"><a id="sthref695"></a>
<h3 class="sect2">Altering a Type by Adding and Dropping Attributes</h3>
<p><a href="#CJGFFICH">Example 8-5</a> illustrates how to make a simple change to <code>person_typ</code> by adding one attribute and dropping another. The <code>CASCADE</code> keyword propagates the type change to dependent types and tables, but the phrase <code>NOT</code> <code>INCLUDING</code> <code>TABLE</code> <code>DATA</code> prevents conversion of the related data.</p>
<div id="ADOBJ7399" class="example">
<p class="titleinexample"><a id="CJGFFICH"></a>Example 8-5 Altering an Object Type by Adding and Dropping an Attribute</p>
<pre>-- Drop person_typ and person_obj_table if they exist
CREATE TYPE person_typ AS OBJECT (
  idno           NUMBER,
  name           VARCHAR2(30),
  phone          VARCHAR2(20));
/
CREATE TABLE person_obj_table OF person_typ;

INSERT INTO person_obj_table 
  VALUES (person_typ(12, &#39;Bob Jones&#39;, &#39;650-555-0130&#39;));

SELECT value(p) FROM person_obj_table p;
</pre></div>
<!-- class="example" -->
<br/>
<code>VALUE(P)(IDNO, NAME, PHONE)</code><br/>
<code>--------------------------------------------</code><br/>
<code>PERSON_TYP(12, &#39;Bob Jones&#39;, &#39;650-555-0130&#39;)</code><br/>
<p>You can add the email attribute and drop the phone attribute as follows:</p>
<pre>ALTER TYPE person_typ
  <span class="bold">ADD ATTRIBUTE</span> (email VARCHAR2(80)), 
  <span class="bold">DROP ATTRIBUTE</span> phone <span class="bold">CASCADE NOT INCLUDING TABLE DATA</span>;
</pre>
<p>Then disconnect and reconnect to accommodate the type change:</p>
<pre>connect oe/oe;
connect hr/hr;
ALTER SESSION SET PLSQL_WARNINGS = &#39;enable:all&#39;;
-- The data of table person_obj_table has not been converted yet, but
-- when the data is retrieved, Oracle returns the data based on
-- the latest type version. The new attribute is initialized to NULL.
SELECT value(p) FROM person_obj_table p;
</pre>
<br/>
<code>VALUE(P)(IDNO, NAME, EMAIL)</code><br/>
<code>---------------------------------</code><br/>
<code>PERSON_TYP(12, &#39;Bob Jones&#39;, NULL)</code><br/>
<p>During <code>SELECT</code> statements, even though column data may be converted to the latest type version, the converted data is not written back to the column. If you retrieve a particular user-defined type column in a table often, consider converting that data to the latest type version to eliminate redundant data conversions. Converting is especially beneficial if the column contains <code>VARRAY</code> attributes which typically take more time to convert than objects or nested table columns.</p>
<p>You can convert a column of data by issuing an <code>UPDATE</code> statement to set the column to itself, as indicated in the following code snippet, which is unrelated to previous code.</p>
<pre>UPDATE dept_tab SET <span class="bold">emp_array_col</span> = <span class="bold">emp_array_col</span>;
</pre>
<p>You can convert all columns in a table by using <code>ALTER</code> <code>TABLE</code> with the <code>UPGRADE</code> <code>INCLUDING</code> <code>DATA</code>. For example:</p>
<pre>ALTER TYPE person_typ ADD ATTRIBUTE (photo BLOB)
  CASCADE NOT INCLUDING TABLE DATA;
<span class="bold">ALTER TABLE</span> person_obj_table <span class="bold">UPGRADE INCLUDING DATA</span>;
</pre>
<p>The <code>ALTER</code> <code>TABLE</code> line converts only the table listed. The <code>CASCADE</code> option prevents conversion of other tables or dependents.</p>
</div>
<!-- class="sect2" -->
<a id="CHDHBHDG"></a>
<div id="ADOBJ7400" class="sect2">
<h3 class="sect2">Altering a Type by Adding a Nested Table Attribute<a id="sthref696"></a><a id="sthref697"></a><a id="sthref698"></a><a id="sthref699"></a><a id="sthref700"></a></h3>
<p>This section describes the steps required to make a complex change to a type: the addition of a nested table attribute to an object type that is included in a nested table.</p>
<p><a href="#CHDDJCGJ">Example 8-6</a> provides the initial schema which is altered by <a href="#CACDJFCF">Example 8-7</a>.</p>
<div id="ADOBJ7660" class="example">
<p class="titleinexample"><a id="CHDDJCGJ"></a>Example 8-6 Initial Schema</p>
<pre>-- Drop existing person_typ, department_type, people_typ objects or tables
CREATE TYPE person_typ AS OBJECT (
  idno           NUMBER,
  name           VARCHAR2(30),
  phone          VARCHAR2(20));
/
-- creating a nested table type
CREATE TYPE people_typ AS TABLE OF person_typ;/
CREATE TYPE department_typ AS OBJECT (
  manager    person_typ,
  employee   people_typ);  // a nested table/
CREATE TABLE department OF department_typ
  NESTED TABLE employee STORE AS employee_store_nt;
</pre></div>
<!-- class="example" -->
<p><a href="#CACDJFCF">Example 8-7</a> starts by creating a new object <code>tasks_typ</code> and a nested table type to hold it, <code>tasks_nttab</code>.</p>
<p>The following steps, both in <a href="#CACDJFCF">Example 8-7</a>, and in other programs, are necessary to add the nested table <code>tasks</code> as an attribute to the object type <code>person_typ</code>, which is already included in the nested table <code>people_typ</code>.</p>
<ol>
<li>
<p>Issue an <code>ALTER TYPE..INVALIDATE</code> statement to alter the type <code>person_typ</code>. This statement bypasses all type and table checks to save time and invalidates dependent objects. You cannot access table data until it is validated.</p>
<p>The <code>ALTER</code> <code>TYPE</code> statement includes <code>ADD</code> <code>ATTRIBUTE</code> to add the nested table <code>tasks</code>.</p>
<p>The <code>UPGRADE.. STORE AS</code> clause upgrades the affected nested table, and specifies name of the new storage table.</p>
<div id="ADOBJ7401" class="example">
<p class="titleinexample"><a id="CACDJFCF"></a>Example 8-7 Altering an Object Type by Adding a Nested Table Attribute</p>
<pre>-- Requires Ex. 8-6
CREATE TYPE tasks_typ AS OBJECT (
  priority       VARCHAR2(2),
  description    VARCHAR2(30));
/

CREATE TYPE tasks_nttab AS TABLE OF tasks_typ;
/

<span class="bold">ALTER TYPE</span> person_typ <span class="bold">ADD ATTRIBUTE</span> tasks tasks_nttab
  <span class="bold">INVALIDATE</span>;

-- Propagate the change to employee_store_nt
-- Specify a storage name for the new nested table
<span class="bold">ALTER TABLE</span> employee_store_nt
  <span class="bold">UPGRADE</span> NESTED TABLE tasks <span class="bold">STORE AS</span> tasks_nt;
</pre></div>
<!-- class="example" --></li>
<li>
<p>Use <code>CREATE OR REPLACE TYPE BODY</code> for <code>person_typ</code> to update the corresponding type body to make it current with the new type definition, <span class="italic">if necessary</span>.</p>
</li>
<li>
<p>Upgrade the dependent tables to the latest type version and convert the data in the tables. This validates the table and allow for data access again.</p>
<pre>ALTER TABLE department UPGRADE INCLUDING DATA;
</pre></li>
<li>
<p>Alter dependent PL/SQL program units as needed to take account of changes to the type.</p>
</li>
<li>
<p>Use OTT or JPublisher to generate new header files for applications, depending on whether the application is written in C or Java.</p>
<p>Adding a new attribute to a supertype also increases the number of attributes in all its subtypes because these inherit the new attribute. Inherited attributes always precede declared (locally defined) attributes, so adding a new attribute to a supertype causes the ordinal position of all declared attributes of any subtype to be incremented by one recursively. The mappings of the altered type must be updated to include the new attributes. Oracle Type Translator (OTT) and JPublisher do this. If you use another tool, you must be sure that the type headers are properly synchronized with the type definition in the server; otherwise, unpredictable behavior may result.</p>
</li>
<li>
<p>Modify application code as needed and rebuild the application.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CHDHFDEI"></a>
<div id="ADOBJ7403" class="sect2">
<h3 class="sect2">Validating a Type That Has Been Altered<a id="sthref701"></a></h3>
<p>When the system executes an <code>ALTER TYPE</code> statement, it first validates the requested type change syntactically and semantically to make sure it is legal. The system performs the same validations as for a <code>CREATE TYPE</code> statement plus some additional ones. If the new specification of the target type or any of its dependent types fails the type validations, the <code>ALTER TYPE</code> statement aborts. No new type version is created, and all dependent objects remain unchanged.</p>
<p>If dependent tables exist, further checking ensures that restrictions relating to the tables and indexes are observed. For example, it ensures that an attribute being dropped is not used as a partitioning key. Again, if the <code>ALTER TYPE</code> statement fails the check of table-related restrictions, then the type change is aborted, and no new version of the type is created.</p>
<p>When a single <code>ALTER TYPE</code> statement adds multiple attributes, it is done in the order specified. Multiple type changes can be specified in the same <code>ALTER TYPE</code> statement, but no attribute name or method signature can be specified more than once in the statement. For example, adding and modifying the same attribute in a single statement is not allowed.</p>
<p>The following sections contain other notes on type changes including:</p>
<ul>
<li>
<p><a href="#CHDJEFBB">Dropping an Attribute</a></p>
</li>
<li>
<p><a href="#CHDDFCEG">Modifying the Length, Precision, or Scale of an Attribute Type</a></p>
</li>
<li>
<p><a href="#CHDIAAEH">Dropping a Method</a></p>
</li>
<li>
<p><a href="#CHDEEHAF">Modifying the INSTANTIABLE Property</a></p>
</li>
</ul>
<p class="subhead2"><a id="CHDJEFBB"></a><a id="ADOBJ7404"></a>Dropping an Attribute</p>
<ul>
<li>
<p>Dropping all attributes from a root type is not allowed. Instead, you must drop the type. Because a subtype inherits all the attributes from its supertype, dropping all the attributes from a subtype does not reduce its attribute count to zero; therefore, dropping all attributes declared locally in a subtype is allowed.</p>
</li>
<li>
<p>Only an attribute declared locally in the target type can be dropped. You cannot drop an inherited attribute from a subtype. Instead, drop the attribute from the type where it is locally declared.</p>
</li>
<li>
<p>Dropping an attribute which is part of a table partitioning or sub-partitioning key in a table is not allowed.</p>
</li>
<li>
<p>Dropping an attribute of a primary key OID of an object table or an index-organized table (IOT) is not allowed.</p>
</li>
<li>
<p>When an attribute is dropped, the column corresponding to the dropped attribute is dropped.</p>
</li>
<li>
<p>When an attribute is dropped, any indexes, statistics, constraints, and referential integrity constraints that reference it are removed.</p>
</li>
</ul>
<p class="subhead2"><a id="CHDDFCEG"></a><a id="ADOBJ7405"></a>Modifying the Length, Precision, or Scale of an Attribute Type<a id="sthref702"></a></p>
<ul>
<li>
<p>You are not allowed to expand the length of an attribute referenced in a function-based index, clustered key or domain index on a dependent table.</p>
</li>
<li>
<p>You are not allowed to decrease the length, precision, or scale of an attribute.</p>
</li>
</ul>
<p class="subhead2"><a id="CHDIAAEH"></a><a id="ADOBJ7406"></a>Dropping a Method<a id="sthref703"></a></p>
<ul>
<li>
<p>You can only drop a method from the type in which the method is defined (or redefined): You cannot drop an inherited method from a subtype, and you cannot drop an redefined method from a supertype.</p>
</li>
<li>
<p>If a method is not redefined, dropping it using the <code>CASCADE</code> option removes the method from the target type and all subtypes. However, if a method is redefined in a subtype, the <code>CASCADE</code> will fail and roll back. For the <code>CASCADE</code> to succeed, you must first drop each redefined method from the subtype that defines it and then drop the method from the supertype.</p>
<p>You can consult the <code>USER_DEPENDENCIES</code> table to find all the schema objects, including types, that depend on a given type. You can also run the <code>DBMS_UTILITY.GET_DEPENDENCY</code> utility to find the dependencies of a type.</p>
</li>
<li>
<p>You can use the <code>INVALIDATE</code> option to drop a method that has been redefined, but the redefined versions in the subtypes must still be dropped manually. The subtypes will remain in an invalid state until they are explicitly altered to drop the redefined versions. Until then, an attempt to recompile the subtypes for revalidation will produce the error <code>Method does not override</code>.</p>
<p>Unlike <code>CASCADE</code>, <code>INVALIDATE</code> bypasses all the type and table checks and simply invalidates all schema objects dependent on the type. The objects are revalidated the next time they are accessed. This option is faster than using <code>CASCADE</code>, but you must be certain that no problems occur when revalidating dependent types and tables. Table data cannot be accessed while a table is invalid; if a table cannot be validated, its data remains inaccessible.</p>
<p>See <a href="#i1006520">&#34;If a Type Change Validation Fails&#34;</a>.</p>
</li>
</ul>
<p class="subhead2"><a id="CHDEEHAF"></a><a id="ADOBJ7407"></a>Modifying the INSTANTIABLE Property<a id="sthref704"></a></p>
<ul>
<li>
<p>Altering an object type from <code>INSTANTIABLE</code> to <code>NOT INSTANTIABLE</code> is allowed only if the type has no table dependents.</p>
</li>
<li>
<p>Altering an object type from <code>NOT INSTANTIABLE</code> to <code>INSTANTIABLE</code> is allowed anytime. This change does not affect tables.</p>
</li>
</ul>
<p class="subhead2"><a id="ADOBJ7661"></a>Modifying the FINAL Property<a id="sthref705"></a></p>
<ul>
<li>
<p>Altering an object type from <code>NOT FINAL</code> to <code>FINAL</code> is only allowed if the target type has no subtypes.</p>
</li>
<li>
<p>When you alter an object type from <code>FINAL</code> to <code>NOT FINAL</code> or vice versa, you must use <code>CASCADE</code> to convert data in dependent columns and tables immediately. You may not use the <code>CASCADE</code> option <code>NOT INCLUDING TABLE DATA</code> to defer converting data.</p>
<ul>
<li>
<p>From <code>NOT FINAL</code> to <code>FINAL</code>, you must use <code>CASCADE INCLUDING TABLE DATA</code>.</p>
</li>
<li>
<p>From <code>FINAL</code> to <code>NOT FINAL</code>, you may use either <code>CASCADE INCLUDING TABLE DATA</code> or <code>CASCADE CONVERT TO SUBSTITUTABLE</code>.</p>
<p>When you alter a type from <code>FINAL</code> to <code>NOT</code> <code>FINAL</code>, select the <code>CASCADE</code> option based on whether or not you want to insert new subtypes of the altered types into existing columns and tables.</p>
</li>
</ul>
<p>By default, altering a type from <code>FINAL</code> to <code>NOT</code> <code>FINAL</code> enables you to create new substitutable tables and columns of that type, but it does not automatically make existing columns (or object tables) of that type substitutable. In fact, just the opposite happens: existing columns and tables of the type are marked <code>NOT SUBSTITUTABLE</code> <code>AT</code> <code>ALL</code> <code>LEVELS</code>. If any embedded attribute of these columns is substitutable, an error is generated. New subtypes of the altered type cannot be inserted into these preexisting columns and tables.</p>
<p>To alter an object type to <code>NOT</code> <code>FINAL</code> in a way that makes existing columns and tables of the type substitutable (assuming that they are not marked <code>NOT</code> <code>SUBSTITUTABLE</code>), use the <code>CASCADE</code> option <code>CONVERT TO SUBSTITUTABLE</code>.</p>
<p><a href="#CHDCBDHH">Example 8-8</a> shows the use of <code>CASCADE</code> with the option <code>CONVERT TO SUBSTITUTABLE</code>:</p>
<div id="ADOBJ7408" class="example">
<p class="titleinexample"><a id="CHDCBDHH"></a>Example 8-8 Converting a Type from FINAL to NOT FINAL</p>
<pre>CREATE TYPE shape AS OBJECT (
    name VARCHAR2(30),
    area NUMBER)
    FINAL;/
ALTER TYPE shape NOT FINAL CASCADE <span class="bold">CONVERT TO SUBSTITUTABLE</span>;
</pre></div>
<!-- class="example" -->
<p>This <code>CASCADE</code> option marks each existing column as <code>SUBSTITUTABLE AT ALL LEVELS</code> and causes a new, hidden column to be added for the TypeId of instances stored in the column. The column can then store subtype instances of the altered type.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006520"></a>
<div id="ADOBJ7409" class="sect2">
<h3 class="sect2">If a Type Change Validation Fails<a id="sthref706"></a></h3>
<p>The <code>INVALIDATE</code> option of the <code>ALTER</code> <code>TYPE</code> statement lets you alter a type without propagating the type change to dependent objects. In this case, the system does not validate the dependent types and tables, that is, does not ensure that all the ramifications of the type change are legal. Instead, the system marks all dependent schema objects invalid. These objects, including types and tables, are revalidated the next time they are referenced. If a type cannot be revalidated, it remains invalid, and any tables referencing it become inaccessible until the problem is corrected.</p>
<p>A table may fail validation for reasons such as: the addition of a new attribute to a type increased the number of columns in the table beyond the maximum of 1000, or an attribute used as a partitioning or clustering key of a table was dropped from a type.</p>
<p>To force a revalidation of a type, users can issue the <code>ALTER TYPE COMPILE</code> statement. To force a revalidation of an invalid table, users can issue the <code>ALTER TABLE UPGRADE</code> statement and specify whether or not the data is to be converted to the latest type version.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In a system-triggered table validation, the table is referenced, table data is always updated to the latest type version: you do not have the option to postpone conversion of the data.</div>
<p>If a table cannot be converted to the latest type version, then <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> statements on the table are not allowed, and the table data becomes inaccessible. The following DDLs can be executed on the table, but all other statements which reference an invalid table are not allowed until the table is successfully validated:</p>
<ul>
<li>
<p><code>DROP TABLE</code></p>
</li>
<li>
<p><code>TRUNCATE TABLE</code></p>
</li>
</ul>
<p>All PL/SQL programs containing variables defined using <code>%ROWTYPE</code> of a table or <code>%TYPE</code> of a column or attribute from a table are compiled based on the latest type version. If the table fails the revalidation, then compiling any program units that reference that table also fails.</p>
</div>
<!-- class="sect2" -->
<a id="i1007112"></a>
<div id="ADOBJ7410" class="sect2">
<h3 class="sect2">ALTER TYPE Statement for Type Evolution<a id="sthref707"></a></h3>
<p><a href="#g1011839">Table 8-1</a> lists some of the important options in the <code>ALTER</code> <code>TYPE</code> and <code>ALTER</code> <code>TYPE</code><code>...CASCADE</code> statements for altering the attribute or method definition of a type.</p>
<div id="ADOBJ7411" class="tblformal">
<p class="titleintable"><a id="sthref708"></a><a id="g1011839"></a>Table 8-1 ALTER TYPE Options for Type Evolution</p>
<table class="cellalignment3990" title="ALTER TYPE Options for Type Evolution" summary="options in the ALTER TYPE statement for altering type attributes or methods" dir="ltr">
<thead>
<tr class="cellalignment3981">
<th class="cellalignment3991" id="r1c1-t7">Option</th>
<th class="cellalignment3991" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r2c1-t7" headers="r1c1-t7">
<p><code>INVALIDATE</code></p>
</td>
<td class="cellalignment3987" headers="r2c1-t7 r1c2-t7">
<p>Invalidates all dependent objects. Use this option to bypass all the type and table checks, and save time.</p>
<p>Use this option only if you are certain that problems will not be encountered revalidating dependent types and tables. Table data cannot be accessed again until it is validated; if it cannot be validated, it remains inaccessible.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r3c1-t7" headers="r1c1-t7">
<p><code>CASCADE</code></p>
</td>
<td class="cellalignment3987" headers="r3c1-t7 r1c2-t7">
<p>Propagates the type change to dependent types and tables. The statement aborts if an error is found in dependent types or tables unless the <code>FORCE</code> option is specified.</p>
<p>If <code>CASCADE</code> is specified without other options, then the <code>INCLUDING TABLE DATA</code> option for <code>CASCADE</code> is implied, and the database converts all table data to the latest type version.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r4c1-t7" headers="r1c1-t7">
<p><code>INCLUDING TABLE DATA</code> (Option of <code>CASCADE</code>)</p>
</td>
<td class="cellalignment3987" headers="r4c1-t7 r1c2-t7">
<p>Converts data stored in all user-defined columns to the most recent version of the column type.</p>
<p>For each new attribute added to the column type, a new attribute is added to the data and is initialized to <code>NULL</code>. For each attribute dropped from the referenced type, the corresponding attribute data is removed from the table. All tablespaces containing the table data must be in read-write mode; otherwise, the statement will not succeed.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r5c1-t7" headers="r1c1-t7">
<p><code>NOT INCLUDING TABLE DATA</code> (Option of <code>CASCADE</code>)</p>
</td>
<td class="cellalignment3987" headers="r5c1-t7 r1c2-t7">
<p>Leaves column data as is, does not change type version. If an attribute is dropped from a type referenced by a table, the corresponding column of the dropped attribute is not removed from the table. However, the metadata of the column is marked unused. If the dropped attribute is stored out-of-line (for example, <code>VARRAY</code>, <code>LOB</code>, or nested table attribute), the out-of-line data is not removed. (Unused columns can be removed afterward by using an <code>ALTER TABLE DROP UNUSED COLUMNS</code> statement.)</p>
<p>This option is useful when you have many large tables and may run out of rollback segments if you convert them all in one transaction. This option enables you to convert the data of each dependent table later in a separate transaction (using an <code>ALTER TABLE UPGRADE INCLUDING DATA</code> statement).</p>
<p>Specifying this option speeds up the table upgrade because the table data remains in the format of the old type version. However, selecting data from this table requires converting the images stored in the column to the latest type version. This is likely to affect performance during subsequent <code>SELECT</code> statements.</p>
<p>Because this option only requires updating the table metadata, it does not require that all tablespaces be on-line in read/write mode for the statement to succeed.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r6c1-t7" headers="r1c1-t7">
<p><code>FORCE</code> (Option of <code>CASCADE</code>)</p>
</td>
<td class="cellalignment3987" headers="r6c1-t7 r1c2-t7">
<p>Forces the system to ignore errors from dependent tables and indexes. Errors are logged in a specified exception table so that they can be queried afterward. Use this option with caution because dependent tables can become inaccessible if some table errors occur.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r7c1-t7" headers="r1c1-t7">
<p><code>CONVERT TO SUBSTITUTABLE</code> (Option of <code>CASCADE</code>)</p>
</td>
<td class="cellalignment3987" headers="r7c1-t7 r1c2-t7">
<p>For use when altering a type from <code>FINAL</code> to <code>NOT</code> <code>FINAL</code>: Converts data stored in all user-defined columns to the most recent version of the column type and then marks these existing columns and object tables of the type <code>SUBSTITUTABLE AT ALL LEVELS</code> so that they can store any newly created subtypes of the type.</p>
<p>If the type is altered to <code>NOT FINAL</code> without specifying this option, existing columns and tables of the type are marked <code>NOT SUBSTITUTABLE AT ALL LEVELS</code>, and new subtypes of the type cannot be stored in them. You can only store these subtypes in columns and tables created after the type was altered.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01102" href="../SQLRF/statements_4002.htm#SQLRF01102"><span class="italic">Oracle Database SQL Language Reference</span></a> for further information about <code>ALTER</code> <code>TYPE</code> options</div>
</div>
<!-- class="sect2" -->
<a id="CHDDAFEF"></a>
<div id="ADOBJ7413" class="sect2">
<h3 class="sect2">ALTER TABLE Statement for Type Evolution<a id="sthref709"></a></h3>
<p>You can use <code>ALTER</code> <code>TABLE</code> to convert table data to the latest version of referenced types. For an example, see <a href="#CHDHBHDG">&#34;Altering a Type by Adding a Nested Table Attribute&#34;</a>. See <a href="#g1011839">Table 8-1</a> for a discussion of the <code>INCLUDING</code> <code>DATA</code> option.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF010" href="../SQLRF/statements_3.htm#SQLRF010"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code>ALTER</code> <code>TABLE</code> options</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CACEGCBE"></a>
<div id="ADOBJ7669" class="sect1">
<h2 class="sect1">Storing XMLTypes and LOBs in an ANYDATA Column<a id="sthref710"></a><a id="sthref711"></a><a id="sthref712"></a><a id="sthref713"></a><a id="sthref714"></a><a id="sthref715"></a><a id="sthref716"></a></h2>
<p>Beginning with Oracle Database 12<span class="italic">c</span>, you can use <code>ALTER</code> <code>TABLE</code> to store ADTs with <code>XMLTYPE</code>s and LOB attributes in <code>ANYDATA</code> columns. You can also do the same for standalone XMLTYPEs.</p>
<p>To do this, use the <code>modify_opaque_type</code> clause, which instructs the database to store these types unpacked. Otherwise, they cannot be stored in an <code>ANYDATA</code> column.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF55998" href="../SQLRF/statements_3001.htm#SQLRF55998"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code>ALTER</code> <code>TABLE</code> used with the <code>modify_opaque_type</code> clause</div>
</div>
<!-- class="sect1" -->
<a id="CHDECFFH"></a>
<div id="ADOBJ7662" class="sect1">
<h2 class="sect1">System-Defined and User-Defined Constructors</h2>
<p>This section discusses various aspects of using system-defined constructors, also known as attribute-value constructors, and user-defined constructors.</p>
<p>This section includes these topics:</p>
<ul>
<li>
<p><a href="#CHDJIAJI">The Attribute-Value Constructor</a></p>
</li>
<li>
<p><a href="#CHDFJJIJ">Constructors and Type Evolution</a></p>
</li>
<li>
<p><a href="#CHDJCFAG">Advantages of User-Defined Constructors</a></p>
</li>
<li>
<p><a href="#CHDFADJI">Defining and Implementing User-Defined Constructors</a></p>
</li>
<li>
<p><a href="#CHDBBABE">Overloading and Hiding Constructors</a></p>
</li>
<li>
<p><a href="#CHDFCJHH">Calling User-Defined Constructors</a></p>
</li>
<li>
<p><a href="#CHDBAJBJ">Constructors for SQLJ Object Types</a></p>
</li>
</ul>
<a id="CHDJIAJI"></a>
<div id="ADOBJ7414" class="sect2">
<h3 class="sect2">The Attribute-Value Constructor<a id="sthref717"></a><a id="sthref718"></a><a id="sthref719"></a></h3>
<p>The system-defined constructor, also known as the attribute-value constructor, requires you to pass the constructor a value for each attribute of the type. The constructor then sets the attributes of the new object instance to those values, as shown in <a href="#CACFHAIG">Example 8-9</a>.</p>
<div id="ADOBJ7415" class="example">
<p class="titleinexample"><a id="CACFHAIG"></a>Example 8-9 Setting the attribute-value with the Constructor</p>
<pre>CREATE TYPE shape AS OBJECT (
    name VARCHAR2(30),
    area NUMBER);
/
CREATE TABLE building_blocks of shape;

-- attribute-value constructor: Sets instance attributes to the specified values
INSERT INTO building_blocks
  VALUES (
    <span class="bold">NEW shape</span>(&#39;my_shape&#39;, 4));
</pre></div>
<!-- class="example" -->
<p>The keyword <code>NEW</code> preceding a call to a constructor is optional but recommended.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFJJIJ"></a>
<div id="ADOBJ7416" class="sect2">
<h3 class="sect2">Constructors and Type Evolution<a id="sthref720"></a></h3>
<p>The attribute-value constructor saves you the trouble of defining your own constructors for a type. However, you must supply a value for every attribute declared in the type or the constructor call fails to compile.</p>
<p>This requirement can create a problem if you evolve the type later on, especially because the attribute-value constructor is implicit and not visible in the code, unlike a user-defined constructor. When you change the attributes of a type, the attribute-value constructor of the type changes, too. If you add an attribute, the updated attribute-value constructor expects a value for the new attribute; otherwise, any attribute-value constructor calls in your existing code fail.</p>
<p>See <a href="#i1006726">&#34;Type Evolution&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDJCFAG"></a>
<div id="ADOBJ7417" class="sect2">
<h3 class="sect2">Advantages of User-Defined Constructors<a id="sthref721"></a><a id="sthref722"></a></h3>
<p>User-defined constructors do not need to explicitly set a value for every attribute of a type, unlike attribute-value constructors. A user-defined constructor can have any number of arguments, of any type, and these do not need to map directly to type attributes. When you define a constructor, you can initialize the attributes to any appropriate values. For any attributes which you do not supply values, the system initialized to <code>NULL</code>.</p>
<p>If you evolve a type&mdash;for example, by adding an attribute&mdash;calls to user-defined constructors for the type do not need to be changed. User-defined constructors are not automatically modified when the type evolves, so their signatures remain the same. You may, however, need to change the definition of the constructor if you do not want the new attribute to be initialized to <code>NULL</code>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFADJI"></a>
<div id="ADOBJ7418" class="sect2">
<h3 class="sect2">Defining and Implementing User-Defined Constructors<a id="sthref723"></a><a id="sthref724"></a><a id="sthref725"></a><a id="sthref726"></a><a id="sthref727"></a><a id="sthref728"></a></h3>
<p>You define user-defined constructors in the type body, like an ordinary method. You introduce the declaration and the definition with the phrase <code>CONSTRUCTOR FUNCTION</code> and end with the clause <code>RETURN SELF AS RESULT</code>.</p>
<p>A constructor for a type must have the same name as the type. <a href="#i1011567">Example 8-10</a> defines two constructor functions for the <code>shape</code> type. As the example shows, you can overload user-defined constructors by defining multiple versions with different signatures.</p>
<div id="ADOBJ7419" class="example">
<p class="titleinexample"><a id="i1011567"></a>Example 8-10 Defining and Implementing User-Defined Constructors</p>
<pre>CREATE TYPE shape AS OBJECT (
    name VARCHAR2(30),
    area NUMBER,
    <span class="bold">CONSTRUCTOR FUNCTION</span> shape(SELF IN OUT NOCOPY shape, name VARCHAR2)
                               <span class="bold">RETURN SELF AS RESULT</span>,
    CONSTRUCTOR FUNCTION shape(SELF IN OUT NOCOPY shape, name VARCHAR2, 
                               area NUMBER) RETURN SELF AS RESULT
) NOT FINAL;
/

CREATE <span class="bold">TYPE BODY</span> shape AS
    CONSTRUCTOR FUNCTION shape(SELF IN OUT NOCOPY shape, name VARCHAR2) 
                               RETURN SELF AS RESULT IS
    BEGIN
        SELF.name := name;
        SELF.area := 0;
        <span class="bold">RETURN;</span>
    END;
    CONSTRUCTOR FUNCTION shape(<span class="bold">SELF IN OUT</span> NOCOPY shape, name VARCHAR2, 
                                area NUMBER) RETURN SELF AS RESULT IS
    BEGIN
        SELF.name := name;
        SELF.area := area;
        RETURN;
    END;
END;
/
</pre>
<p>A user-defined constructor has an implicit first parameter <code>SELF</code>. Specifying this parameter in the declaration of a user-defined constructor is optional. If you do specify it, you must declare its mode to be <code>IN OUT</code>.</p>
<p>The required clause <code>RETURN SELF AS RESULT</code> ensures that the most specific type of the instance being returned is the same as the most specific type of the <code>SELF</code> argument. In the case of constructors, this is the type for which the constructor is defined. For example, if the most specific type of the <code>SELF</code> argument on a call to the <code>shape</code> constructor is <code>shape</code>, then this clause ensures that the <code>shape</code> constructor returns an instance of <code>shape</code> (not an instance of a subtype of <code>shape</code>).</p>
<p>When a constructor function is called, the system initializes the attributes of the <code>SELF</code> argument to <code>NULL</code>. Names of attributes subsequently initialized in the function body may be qualified with <code>SELF</code>, such as <code>SELF.name</code> in <a href="#i1011567">Example 8-10</a>, to distinguish them from the names of the arguments of the constructor function, if these are the same. If the argument names are different, this qualification is not necessary.</p>
<p>The function body must include an explicit <code>return;</code> as shown. The <span class="keyword">return</span> keyword must not be followed by a <code>return</code> expression. The system automatically returns the newly constructed <code>SELF</code> instance.</p>
<p>A user-defined constructor may be implemented in PL/SQL, C, or Java.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDBBABE"></a>
<div id="ADOBJ7420" class="sect2">
<h3 class="sect2">Overloading and Hiding Constructors</h3>
<p>You can overload user-defined constructors, like other type methods.</p>
<p>User-defined constructors are not inherited, so a user-defined constructor defined in a supertype cannot be hidden in a subtype. However, a user-defined constructor does hide, and thus supersede, the attribute-value constructor for its type if the signature of the user-defined constructor exactly matches the signature of the attribute-value constructor. For the signatures to match, the names and types of the parameters (after the implicit <code>SELF</code> parameter) of the user-defined constructor must be the same as the names and types of the attributes of the type. The mode of the parameters (after the implicit <code>SELF</code> parameter) of the user-defined constructor must be <code>IN</code>.</p>
<p>If an attribute-value constructor is not hidden by a user-defined constructor that has the same name and signature, the attribute-value constructor can still be called.</p>
<p>Note that, if you evolve a type&mdash;for example, by adding an attribute&mdash;the signature of the attribute-value constructor of the type changes accordingly. This can cause a formerly hidden attribute-value constructor to become usable again.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFCJHH"></a>
<div id="ADOBJ7421" class="sect2">
<h3 class="sect2">Calling User-Defined Constructors<a id="sthref729"></a></h3>
<p>You call a user-defined constructor like any other function and you can use it anywhere you can use an ordinary function.</p>
<p>The <code>SELF</code> argument is passed in implicitly and may not be passed in explicitly. In other words, usages like the following are not allowed:</p>
<p><code>NEW constructor(instance, argument_list)</code></p>
<p>A user-defined constructor cannot occur in the <code>DEFAULT</code> clause of a <code>CREATE</code> or <code>ALTER</code> <code>TABLE</code> statement, but an attribute-value constructor can. The arguments to the attribute-value constructor must not contain references to PL/SQL functions or to other columns, including the pseudocolumns <code>LEVEL</code>, <code>PRIOR</code>, and <code>ROWNUM</code>, or to date constants that are not fully specified. The same is true for check constraint expressions: an attribute-value constructor can be used as part of check constraint expressions while creating or altering a table, but a user-defined constructor cannot.</p>
<p>Parentheses are required in SQL even for constructor calls that have no arguments. In PL/SQL, parentheses are optional when invoking a zero-argument constructor. They do, however, make it more obvious that the constructor call is a function call. The following PL/SQL example omits parentheses in the constructor call to create a new shape:</p>
<p><code>shape s := NEW my_schema.shape;</code></p>
<p>The <code>NEW</code> keyword and the schema name are optional.</p>
<p><a href="#CACEBJGE">Example 8-11</a> creates a subtype under the type created in <a href="#i1011567">Example 8-10</a> and shows examples for calling the user-defined constructors.</p>
<div id="ADOBJ7422" class="example">
<p class="titleinexample"><a id="CACEBJGE"></a>Example 8-11 Calling User-Defined Constructors</p>
<pre>-- Requires Ex. 8-10
CREATE TYPE rectangle <span class="bold">UNDER shape</span> (
    len NUMBER,
    wth NUMBER,
    CONSTRUCTOR FUNCTION rectangle(SELF IN OUT NOCOPY rectangle,
        name VARCHAR2, len NUMBER, wth NUMBER) RETURN SELF as RESULT,
    CONSTRUCTOR FUNCTION rectangle(SELF IN OUT NOCOPY rectangle,
        name VARCHAR2, side NUMBER) RETURN SELF as RESULT);
/
SHOW ERRORS
CREATE TYPE BODY rectangle IS 
    CONSTRUCTOR FUNCTION rectangle(SELF IN OUT NOCOPY rectangle,
        name VARCHAR2, len NUMBER, wth NUMBER) RETURN  SELF AS RESULT IS
    BEGIN 
        SELF.name := name;
        SELF.area := len*wth;
        SELF.len := len;
        SELF.wth := wth;
        RETURN ;
    END;
    CONSTRUCTOR FUNCTION rectangle(SELF IN OUT NOCOPY rectangle,
        name VARCHAR2, side NUMBER) RETURN  SELF AS RESULT IS
    BEGIN 
        SELF.name := name;
        SELF.area := side * side;
        SELF.len := side;
        SELF.wth := side;
        RETURN ;
    END;
END;
/

CREATE TABLE shape_table OF shape;
INSERT INTO shape_table VALUES(shape(&#39;shape1&#39;)); 
INSERT INTO shape_table VALUES(shape(&#39;shape2&#39;, 20)); 
INSERT INTO shape_table VALUES(rectangle(&#39;rectangle&#39;, 2, 5)); 
INSERT INTO shape_table VALUES(rectangle(&#39;quadrangle&#39;, 12, 3));
INSERT INTO shape_table VALUES(rectangle(&#39;square&#39;, 12));
</pre>
<p>The following query selects the rows in the <code>shape_table</code>:</p>
<pre>SELECT VALUE(s) FROM shape_table s;
</pre>
<br/>
<code>VALUE(S)(NAME, AREA)</code><br/>
<code>---------------------------------------------</code><br/>
<code>SHAPE(&#39;shape1&#39;, 0)</code><br/>
<code>SHAPE(&#39;shape2&#39;, 20)</code><br/>
<code>RECTANGLE(&#39;rectangle&#39;, 10, 2, 5)</code><br/>
<code>RECTANGLE(&#39;quadrangle&#39;, 36, 12, 3)</code><br/>
<code>RECTANGLE(&#39;square&#39;, 144, 12, 12)</code><br/>
<p>The following PL/SQL code calls the constructor:</p>
<p><code>s shape := NEW shape(&#39;void&#39;);</code></p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDBAJBJ"></a>
<div id="ADOBJ7423" class="sect2">
<h3 class="sect2">Constructors for SQLJ Object Types</h3>
<p>A SQLJ object type is a SQL object type mapped to a Java class. A SQLJ object type has an attribute-value constructor. It can also have user-defined constructors that are mapped to constructors in the referenced Java class.</p>
<div id="ADOBJ7424" class="example">
<p class="titleinexample"><a id="sthref730"></a>Example 8-12 Creating a SQLJ Object</p>
<pre>CREATE TYPE address AS OBJECT 
   EXTERNAL NAME &#39;university.address&#39; LANGUAGE JAVA
   USING SQLData(
     street   VARCHAR2(100) EXTERNAL NAME &#39;street&#39;,
     city     VARCHAR2(50)  EXTERNAL NAME &#39;city&#39;,
     state    VARCHAR2(50)  EXTERNAL NAME &#39;state&#39;,
     zipcode  NUMBER        EXTERNAL NAME &#39;zipcode&#39;,
    <span class="bold">CONSTRUCTOR FUNCTION</span> address (SELF IN OUT NOCOPY address, street VARCHAR2,
                                  city VARCHAR2, state VARCHAR2, zipcode NUMBER)
      <span class="bold">RETURN SELF AS RESULT AS LANGUAGE JAVA</span>
      NAME  &#39;university.address (java.lang.String, java.lang.String,
                      java.lang.String, int) return address&#39;);
/
</pre>
<p>A SQLJ type of a serialized representation can have only a user-defined constructor. The internal representation of an object of SQLJ type is opaque to SQL, so an attribute-value constructor is not possible for a SQLJ type.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008081"></a>
<div id="ADOBJ010" class="sect1">
<h2 class="sect1">Transient and Generic Types<a id="sthref731"></a><a id="sthref732"></a><a id="sthref733"></a><a id="sthref734"></a><a id="sthref735"></a><a id="sthref736"></a><a id="sthref737"></a><a id="sthref738"></a><a id="sthref739"></a><a id="sthref740"></a></h2>
<p>Oracle database has three generic (that is, generically programmed) SQL data types that enable you to dynamically encapsulate and access type descriptions, data instances, and sets of data instances of any other SQL type, including object and collection types. You can also use these three types to create anonymous types, including anonymous collection types.</p>
<p>The three SQL types are implemented as opaque types. In other words, the internal structure of these types is not known to the database; their data can be queried only by implementing functions (typically 3GL routines) for the purpose. Oracle database provides both an OCI and a PL/SQL API for implementing such functions.</p>
<p>Of the three types, <code>ANYTYPE</code> is transient, and <code>ANYDATA</code> and <code>ANYDATASET</code> are not transient, but rather persistent. Transient types cannot be persistently stored because their structures are opaque to the database. You cannot create columns of transient types or make them attributes of persistent types.</p>
<p>The three generic SQL types are described in <a href="#g1011926">Table 8-2</a>.</p>
<div id="ADOBJ7425" class="tblformal">
<p class="titleintable"><a id="sthref741"></a><a id="g1011926"></a>Table 8-2 Generic SQL Types</p>
<table class="cellalignment3990" title="Generic SQL Types" summary="generic SQL types of the form SYS.*" dir="ltr">
<thead>
<tr class="cellalignment3981">
<th class="cellalignment3991" id="r1c1-t11">Type</th>
<th class="cellalignment3991" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r2c1-t11" headers="r1c1-t11">
<p><code><a id="sthref742"></a>SYS.ANYTYPE</code></p>
</td>
<td class="cellalignment3987" headers="r2c1-t11 r1c2-t11">
<p>A type description type. A <code>SYS.ANYTYPE</code> can contain a type description of any SQL type, named or unnamed, including object types and collection types.</p>
<p>An <code>ANYTYPE</code> can contain a type description of a persistent type, but an <code>ANYTYPE</code> itself is transient: in other words, the value in an <code>ANYTYPE</code> itself is not automatically stored in the database. To create a persistent type, use a <code>CREATE TYPE</code> statement from SQL.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r3c1-t11" headers="r1c1-t11">
<p><code><a id="sthref743"></a>SYS.ANYDATA</code></p>
</td>
<td class="cellalignment3987" headers="r3c1-t11 r1c2-t11">
<p>A self-describing data instance type. A <code>SYS.ANYDATA</code> contains an instance of a given type, with data, plus a description of the type. In this sense, a <code>SYS.ANYDATA</code> is self-describing. An <code>ANYDATA</code> can be persistently stored in the database.</p>
<p>The following cannot be stored in an <code>ANYDATA</code> column:</p>
<ul>
<li>
<p>Another opaque type except <code>XMLTYPE</code></p>
</li>
<li>
<p>LOB types (<code>BLOB</code>/<code>CLOB</code>/<code>NCLOB</code>)</p>
</li>
<li>
<p><code>VARRAY</code> types with maximum size greater than 4K</p>
</li>
<li>
<p>Transient types</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r4c1-t11" headers="r1c1-t11">
<p><code><a id="sthref744"></a>SYS.ANYDATASET</code></p>
</td>
<td class="cellalignment3987" headers="r4c1-t11 r1c2-t11">
<p>A self-describing data set type. A <code>SYS.ANYDATASET</code> type contains a description of a given type plus a set of data instances of that type. An <code>ANYDATASET</code> can be persistently stored in the database.</p>
<p>The following cannot be stored in an <code>ANYDATASET</code> column:</p>
<ul>
<li>
<p>Another opaque type such as <code>ANYDATA</code> or <code>XMLTYPE</code></p>
</li>
<li>
<p>LOB types (<code>BLOB</code>/<code>CLOB</code>/<code>NCLOB</code>)</p>
</li>
<li>
<p><code>VARRAY</code> types with maximum size greater than 4K</p>
</li>
<li>
<p>ADTs that contain any of the above types</p>
</li>
<li>
<p>Transient types</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblformal" -->
<p>Each of these three types can be used with any built-in type native to the database as well as with object types and collection types, both named and unnamed. The types provide a generic way to work dynamically with type descriptions, lone instances, and sets of instances of other types. Using the APIs, you can create a transient <code>ANYTYPE</code> description of any kind of type. Similarly, you can create or convert (cast) a data value of any SQL type to an <code>ANYDATA</code> and can convert an <code>ANYDATA</code> (back) to a SQL type. And similarly again with sets of values and <code>ANYDATASET</code>.</p>
<p>The generic types simplify working with stored procedures. You can use the generic types to encapsulate descriptions and data of standard types and pass the encapsulated information into parameters of the generic types. In the body of the procedure, you can detail how to handle the encapsulated data and type descriptions of whatever type.</p>
<p>You can also store encapsulated data of a variety of underlying types in one table column of type <code>ANYDATA</code> or <code>ANYDATASET</code>. For example, you can use <code>ANYDATA</code> with Advanced Queuing to model queues of heterogeneous types of data. You can query the data of the underlying data types like any other data.</p>
<p><a href="#i1011301">Example 8-13</a> defines and executes a PL/SQL procedure that uses methods built into <code>SYS.ANYDATA</code> to access information about data stored in a <code>SYS.ANYDATA</code> table column.</p>
<div id="ADOBJ7426" class="example">
<p class="titleinexample"><a id="i1011301"></a>Example 8-13 Using SYS.ANYDATA</p>
<pre>CREATE OR REPLACE TYPE dogowner AS OBJECT ( 
    ownerno NUMBER, ownername VARCHAR2(10) );
/
CREATE OR REPLACE TYPE dog AS OBJECT ( 
    breed VARCHAR2(10), dogname VARCHAR2(10) );
/
CREATE TABLE mytab ( id NUMBER, data SYS.ANYDATA );
INSERT INTO mytab VALUES ( 1, SYS.ANYDATA.ConvertNumber (5) );
INSERT INTO mytab VALUES ( 2, SYS.ANYDATA.ConvertObject (
    dogowner ( 5555, &#39;John&#39;) ) );
commit;

CREATE OR REPLACE procedure P IS
  CURSOR cur IS SELECT id, data FROM mytab;

  v_id mytab.id%TYPE;
  v_data mytab.data%TYPE;
  v_type SYS.ANYTYPE;
  v_typecode PLS_INTEGER;
  v_typename VARCHAR2(60);
  v_dummy PLS_INTEGER;
  v_n NUMBER;
  v_dogowner dogowner;
  non_null_anytype_for_NUMBER exception;
  unknown_typename exception;

BEGIN
  OPEN cur;
    LOOP
      FETCH cur INTO v_id, v_data;
      EXIT WHEN cur%NOTFOUND;
      v_typecode := v_data.GetType ( v_type /* OUT */ );
      CASE v_typecode
        WHEN Dbms_Types.Typecode_NUMBER THEN
          IF v_type IS NOT NULL
            THEN RAISE non_null_anytype_for_NUMBER; END IF;
          v_dummy := v_data.GetNUMBER ( v_n /* OUT */ );
          Dbms_Output.Put_Line (
            To_Char(v_id) || &#39;: NUMBER = &#39; || To_Char(v_n) );
        WHEN Dbms_Types.Typecode_Object THEN
          v_typename := v_data.GetTypeName();
          IF v_typename NOT IN ( &#39;HR.DOGOWNER&#39; )
            THEN RAISE unknown_typename; END IF;
          v_dummy := v_data.GetObject ( v_dogowner /* OUT */ );
          Dbms_Output.Put_Line (
            To_Char(v_id) || &#39;: user-defined type = &#39; || v_typename ||
            &#39;(&#39; || v_dogowner.ownerno || &#39;, &#39; || v_dogowner.ownername || &#39; )&#39; );
      END CASE;
    END LOOP;
    CLOSE cur;

EXCEPTION
  WHEN non_null_anytype_for_NUMBER THEN
      RAISE_Application_Error ( -20000,
        &#39;Paradox: the return AnyType instance FROM GetType &#39; ||
        &#39;should be NULL for all but user-defined types&#39; );
  WHEN unknown_typename THEN
      RAISE_Application_Error ( -20000,
        &#39;Unknown user-defined type &#39; || v_typename ||
        &#39; - program written to handle only HR.DOGOWNER&#39; );
END;
/

SELECT t.data.gettypename() FROM mytab t;
SET SERVEROUTPUT ON;
EXEC P;
</pre>
<p>The query and the procedure P in the preceding code sample produce output like the following:</p>
<br/>
<code>T.DATA.GETTYPENAME()</code><br/>
<code>-------------------------------------------------------------</code><br/>
<code>SYS.NUMBER</code><br/>
<code>HR.DOGOWNER</code><br/>
<br/>
<code>1: NUMBER = 5</code><br/>
<code>2: user-defined type = HR.DOGOWNER(5555, John )</code><br/>
<p>Corresponding to the three generic SQL types are three OCI types that model them. Each has a set of functions for creating and accessing the respective type:</p>
</div>
<!-- class="example" -->
<ul>
<li>
<p><code>OCIType</code>: corresponds to <code>SYS.ANYTYPE</code></p>
</li>
<li>
<p><code>OCIAnyData</code>: corresponds to <code>SYS.ANYDATA</code></p>
</li>
<li>
<p><code>OCIAnyDataSet</code>: corresponds to <code>SYS.ANYDATASET</code></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNOCI110" href="../LNOCI/oci12oty.htm#LNOCI110"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for the <code>OCIType</code>, <code>OCIAnyData</code>, and <code>OCIAnyDataSet</code> APIs and details on how to use them</p>
</li>
<li>
<p><a class="olink ARPLS" href="../ARPLS/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the interfaces to the <code>ANYTYPE</code>, <code>ANYDATA</code>, and <code>ANYDATASET</code> types and the <code>DBMS_TYPES</code> package, which defines constants for built-in and user-defined types, for use with <code>ANYTYPE</code>, <code>ANYDATA</code>, and <code>ANYDATASET</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1006758"></a>
<div id="ADOBJ00607" class="sect1">
<h2 class="sect1">User-Defined Aggregate Functions<a id="sthref745"></a></h2>
<p>Oracle database provides a number of pre-defined aggregate functions such as <code>MAX</code>, <code>MIN</code>, <code>SUM</code> for performing operations on a set of records. These pre-defined aggregate functions can be used only with scalar data. However, you can create your own custom implementations of these functions, or define entirely new aggregate functions, to use with complex data&mdash;for example, with multimedia data stored using object types, opaque types, and LOBs.</p>
<p>User-defined aggregate functions are used in SQL DML statements just like the Oracle database built-in aggregates. Once such functions are registered with the server, the database simply invokes the aggregation routines that you supplied instead of the native ones.</p>
<p>User-defined aggregates can be used with scalar data as well. For example, it may be worthwhile to implement special aggregate functions for working with complex statistical data associated with financial or scientific applications.</p>
<p>User-defined aggregates are a feature of the Extensibility Framework. You implement them using <code>ODCIAggregate</code> interface routines.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADDCI2120" href="../ADDCI/aggr_functions.htm#ADDCI2120"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a> for information on using the <code>ODCIAggregate</code> interface routines to implement user-defined aggregate functions</div>
</div>
<!-- class="sect1" -->
<a id="CHDDGIAG"></a>
<div id="ADOBJ7427" class="sect1">
<h2 class="sect1">How Locators Improve the Performance of Nested Tables<a id="sthref746"></a><a id="sthref747"></a></h2>
<p>You can use nested table locators to improve performance when retrieving data.</p>
<p>Collection types do not map directly to a native type or structure in languages such as C++ and Java. An application using those languages must access the contents of a collection through Oracle database interfaces, such as OCI.</p>
<p>Generally, when the client accesses a nested table explicitly or implicitly (by fetching the containing object), the database returns the entire collection value to the client process. For performance reasons, a client may wish to delay or avoid retrieving the entire contents of the collection. Oracle database handles this case for you by using a locator instead of the actual nested table value. When you really access the contents of the collection, they are automatically transferred to the client.</p>
<p>A nested table locator is like a handle to the collection value. It attempts to preserve the value or copy semantics of the nested table by containing the database snapshot as of its time of retrieval. The snapshot helps the database retrieve the correct instantiation of the nested table value at a later time when the collection elements are fetched using the locator. The locator is scoped to a session and cannot be used across sessions. Because database snapshots are used, it is possible to get a <code>snapshot too old</code> error if there is a high update rate on the nested table. Unlike a LOB locator, the nested table locator is truly a locator and cannot be used to modify the collection instance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjdes.htm#CHDHECCA">&#34;Nested Table Locators&#34;</a> for more specific information</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3980">
<tr>
<td class="cellalignment3987">
<table class="cellalignment3985">
<tr>
<td class="cellalignment3984"><a href="adobjmng.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3984"><a href="adobjdes.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3989">
<table class="cellalignment3983">
<tr>
<td class="cellalignment3984"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3984"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3984"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3984"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3984"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3984"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>