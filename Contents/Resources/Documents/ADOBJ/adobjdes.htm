<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-743"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Design%20Considerations%20for%20Oracle%20Objects"></a><title>Design Considerations for Oracle Objects</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-08-06T13:19:6Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Object-Relational Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53277-02"/>
<meta name="dcterms.isVersionOf" content="ADOBJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="adobjadv.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adobjxmp.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53277-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/16</span> <!-- End Header -->
<div id="ADOBJ008" class="chapter"><a id="g464733"></a>
<h1 class="chapter"><span class="secnum">9</span> Design Considerations for Oracle Objects</h1>
<p><a id="sthref748"></a>This chapter explains the implementation and performance characteristics of the Oracle object-relational model. Use this information to map a logical data model into an Oracle physical implementation, and when developing applications that use object-oriented features.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>
<p><a href="#i454166">General Storage Considerations for Objects</a></p>
</li>
<li>
<p><a href="#i454148">Performance of Object Comparisons</a></p>
</li>
<li>
<p><a href="#i453869">Design Considerations for REFs</a></p>
</li>
<li>
<p><a href="#i453969">Design Considerations for Collections</a></p>
</li>
<li>
<p><a href="#i454119">Design Considerations for Methods</a></p>
</li>
<li>
<p><a href="#i452266">Writing Reusable Code Using Invoker Rights</a></p>
</li>
<li>
<p><a href="#CHDEBEDJ">Using Roles with Invoker&#39;s Rights Subprograms</a></p>
</li>
<li>
<p><a href="#CIHFGECI">Object Replication Using Logical Standby</a></p>
</li>
<li>
<p><a href="#i452280">Replicating Object Tables and Columns</a></p>
</li>
<li>
<p><a href="#i452285">Constraints on Objects</a></p>
</li>
<li>
<p><a href="#i452646">Considerations Related to Type Evolution</a></p>
</li>
<li>
<p><a href="#i452294">Parallel Queries with Oracle Objects</a></p>
</li>
<li>
<p><a href="#i453627">Design Consideration Tips and Techniques</a></p>
</li>
</ul>
<a id="i454166"></a>
<div id="ADOBJ00801" class="sect1">
<h2 class="sect1">General Storage Considerations for Objects</h2>
<p>This section discusses general storage considerations for various object types.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i443356">Storing Objects as Columns or Rows</a></p>
</li>
<li>
<p><a href="#i443361">Storage Considerations for Object Identifiers (OIDs)</a></p>
</li>
</ul>
<a id="i443356"></a>
<div id="ADOBJ7428" class="sect2">
<h3 class="sect2">Storing Objects as Columns or Rows<a id="sthref749"></a><a id="sthref750"></a></h3>
<p>You can store objects in relational tables as column objects or in object tables as row objects. Those objects that have meaning outside of the relational database they reside in, should be made referenceable as row objects in an object table. Otherwise, they should be stored as column objects in a relational table.</p>
<p>See <a href="adobjint.htm#i458240">&#34;How Objects are Stored in Tables&#34;</a> for an introduction to table storage.</p>
<p>This section describes the following topics:</p>
<ul>
<li>
<p><a href="#i431312">Column Object Storage in Relational Tables</a></p>
</li>
<li>
<p><a href="#i445477">Row Object Storage in Object Tables</a></p>
</li>
</ul>
<a id="i431312"></a>
<div id="ADOBJ7429" class="sect3">
<h4 class="sect3">Column Object Storage in Relational Tables<a id="sthref751"></a></h4>
<p>The storage of a <a href="glossary.htm#CHDGJBJH"><span class="xrefglossterm">column object</span></a> is similar to the storage of an equivalent set of scalar columns that collectively make up the object. The difference is the additional overhead of maintaining the atomic null values of any noncollection columns objects and their <a href="glossary.htm#CHDBEEAI"><span class="xrefglossterm">embedded object attribute</span></a>s. These values, called null indicators (or sometimes, null images), specify for every column object, whether or not the column object is null and whether or not each of its embedded object attributes is null.</p>
<p>Note that null indicators do not specify whether the scalar attributes of a column object are null. Oracle uses a different method to determine whether scalar attributes are null.</p>
<p>Consider a table that holds the identification number, name, address, and phone numbers of people within an organization. You can create three different object types to hold the name, address, and phone numbers and an object <code>employee_objtyp</code> that contains the name and address objects. Because each person may have more than one phone number, you need to create a nested table type based on the phone number object type</p>
<p>First, enter the SQL statements in <a href="#CJAGGHCG">Example 9-1</a> to create the four object types and a table for phone number objects.</p>
<div id="ADOBJ7430" class="example">
<p class="titleinexample"><a id="CJAGGHCG"></a>Example 9-1 Creating Object Types for Columns in a Relational Table</p>
<pre>CREATE TYPE name_objtyp AS OBJECT (
  first       VARCHAR2(15),
  middle      VARCHAR2(15),
  last        VARCHAR2(15));
/
CREATE TYPE address_objtyp AS OBJECT (
  street       VARCHAR2(200),
  city         VARCHAR2(200),
  state        VARCHAR2(2),
  zipcode      VARCHAR2(20));
NOT FINAL;
/
CREATE TYPE phone_objtyp AS OBJECT (
  location     VARCHAR2(15),
  num          VARCHAR2(14));
/

CREATE TYPE employee_objtyp AS OBJECT (
  name name_objtyp;
  address address_objtyp;
/

CREATE TYPE phone_ntabtyp AS TABLE OF phone_objtyp;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i448939">&#34;Design Considerations for Nested Tables&#34;</a> for more information about nested tables</div>
<p>Next, create a table to hold the information about the people in the organization with the SQL statement in <a href="#CJACHEIF">Example 9-2</a>. This statement also creates an id for people in the organization.</p>
<div id="ADOBJ7431" class="example">
<p class="titleinexample"><a id="CJACHEIF"></a>Example 9-2 Creating a Table with Column Objects</p>
<pre>CREATE TABLE people_reltab (
  id            NUMBER(4)   CONSTRAINT pk_people_reltab PRIMARY KEY,
  employee      employee_objtyp
  phones_ntab   phone_ntabtyp)
  NESTED TABLE  phones_ntab STORE AS phone_store_ntab;
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7432" class="figure">
<p class="titleinfigure"><a id="sthref752"></a>Figure 9-1 Representation of the people_reltab Relational Table</p>
<img width="639" height="398" src="img/adobj014.gif" alt="Description of Figure 9-1 follows"/><br/>
<a id="sthref753" href="img_text/adobj014.htm">Description of &#34;Figure 9-1 Representation of the people_reltab Relational Table&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>The <code>people_reltab</code> table has two column objects: <code>employee</code> and <code>phones_ntab</code>. The <code>phones_ntab</code> column object is a nested table, a collection type of column object.</p>
<p>The storage for each object in the <code>people_reltab</code> table is that of the attributes of the object plus overhead for the null indicator.</p>
<p>The null indicators for an object and its embedded object attributes occupy one bit each. Thus, an object with <code><span class="codeinlineitalic">n</span></code> embedded object attributes (including objects at all levels of nesting) has a storage overhead of <code>CEIL(n/8)</code> bytes. There is one null indicator column for each noncollection column object, <code>name_obj</code> and <code>address_obj</code>. The null indicator column length is one byte, as one bit represents the object itself, which translates to <code>CEIL(1/8)</code> or <code>1</code>.</p>
<p>Since the null indicator is one byte in size, the overhead of null information for each row of the <code>people_reltab</code> table is two bytes, one for each <a href="glossary.htm#CHDGHHHE"><span class="xrefglossterm">object column</span></a>.</p>
<p>Every noncollection object has a null indicator column, whether or not the object is <code>FINAL</code>. The columns in these examples are <code>FINAL</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00614" href="../SQLRF/functions025.htm#SQLRF00614"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code>CEIL</code></div>
</div>
<!-- class="sect3" -->
<a id="i445477"></a>
<div id="ADOBJ7433" class="sect3">
<h4 class="sect3">Row Object Storage in Object Tables<a id="sthref754"></a><a id="sthref755"></a><a id="sthref756"></a></h4>
<p>Row objects are stored in object tables. An <a href="glossary.htm#CHDGBJDA"><span class="xrefglossterm">object table</span></a> is a special kind of table that holds objects and provides a relational view of the attributes of those objects. An object table is logically and physically similar to a relational table whose column types correspond to the top level attributes of the object type stored in the object table. The key difference is that an object table can optionally contain an additional object identifier (OID) column and index.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i443361"></a>
<div id="ADOBJ7434" class="sect2">
<h3 class="sect2">Storage Considerations for Object Identifiers (OIDs)<a id="sthref757"></a><a id="sthref758"></a><a id="sthref759"></a><a id="sthref760"></a></h3>
<p>This section discusses the two types of object identifiers for row objects in object tables and how they are stored and referenced.</p>
<p>An object identifier (OID) allows the corresponding row object to be referred to and from other objects or from relational tables. A built-in data type called a <code>REF</code> represents such references. <code>REF</code>s use object identifiers (OIDs) to point to row objects.</p>
<p>You can use either system-generated OIDs or primary-key based OIDs.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjint.htm#i458258">&#34;Using References to Row Objects&#34;</a></div>
<div id="ADOBJ7435" class="sect3"><a id="sthref761"></a>
<h4 class="sect3">System-Generated Object Identifiers (OIDs)<a id="sthref762"></a></h4>
<p>System-generated OIDs are the default for row objects in an object table.</p>
<p>Oracle assigns to each row object a unique system-generated OID, 16 bytes in length, that is automatically indexed for efficient OID-based lookups. The OID column is the equivalent of having an extra 16-byte primary key column. In a distributed environment, the system-generated unique identifier lets Oracle identify objects unambiguously.</p>
<p>The object identifier column is a hidden column that Oracle uses to construct references to the row objects. Oracle provides no access to the internal structure of object identifiers. This structure can change at any time. Applications are only concerned with using object references for fetching and navigating objects.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7436" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref763"></a>
<h4 class="sect3">Primary-Key Based Object Identifiers (OIDs)<a id="sthref764"></a></h4>
<p>Oracle allows the option of specifying the primary key value of a row object as its object identifier, if there is a primary key column.</p>
<p>Instead of using the system-generated OIDs, you use a <code>CREATE</code> <code>TABLE</code> statement with this clause, <code>OBJECT</code> <code>IDENTIFIER</code> <code>IS</code> <code>PRIMARY</code> <code>KEY</code>. This specifies that the system use the primary key column(s) as the OIDs of the objects in the table. That way, you can use existing columns as the OIDs of the objects or use application generated OIDs that are smaller than the 16-byte globally unique OIDs generated by Oracle.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01402" href="../SQLRF/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a> for further information on <code>OBJECT</code> <code>IDENTIFER</code> syntax</div>
<p>You can enforce referential integrity on columns that store references to these row objects in a way similar to foreign keys in relational tables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Each primary-key based OID is locally (but not necessarily globally) unique. If you require a globally unique identifier, you must ensure that the primary key is globally unique or use system-generated OIDs.</div>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7437" class="sect3"><a id="sthref765"></a>
<h4 class="sect3">System-Generated Versus Primary-Key Based OIDs</h4>
<p>Primary-key based identifiers make it faster and easier to load data into an object table. By contrast, system-generated object identifiers need to be remapped using some user-specified keys, especially when references to them are also stored. If you use system-generated OIDs for an object table, Oracle maintains an index on the column that stores these OIDs. A system-generated OID requires extra storage space for this index and an extra 16 bytes of storage for each row object.</p>
<p>However, if each primary key value requires more than 16 bytes of storage and you have a large number of <code>REF</code>s, using the primary key might require more space than system-generated OIDs because each <code>REF</code> is the size of the primary key.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i454148"></a>
<div id="ADOBJ00803" class="sect1">
<h2 class="sect1">Performance of Object Comparisons<a id="sthref766"></a><a id="sthref767"></a><a id="sthref768"></a><a id="sthref769"></a><a id="sthref770"></a></h2>
<p>You can compare objects by invoking either a map or order method. A map method converts objects into scalar values while preserving the ordering of the objects. Using a map method is preferable because it allows the system to efficiently order objects.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For any one object type, you can implement either a map or an order method, but not both. Neither are required.</div>
<p>The way objects are mapped has significant performance implications when sorting the objects using <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code> processes. An object may need to be compared to other objects many times, and it is much more efficient if the objects can be mapped to scalar values first (the map method). If the comparison semantics are extremely complex, or if the objects cannot be mapped to scalar values for comparison, you can define an order method that, given two objects, returns the ordering determined by the object implementor. Order methods are not as efficient as map methods, so performance may suffer if you use order methods.</p>
<p>Consider an object type <code>address</code> consisting of four character attributes: <code>street</code>, <code>city</code>, <code>state</code>, and <code>zipcode</code>. Here, the most efficient comparison method is a map method because each object can be converted easily into scalar values. For example, you might define a map method that orders all of the objects by state.</p>
<p>On the other hand, suppose you want to compare binary objects, such as images. In this case, the comparison semantics may be too complex to use a map method; if so, you can use an order method to perform comparisons. For example, you could create an order method that compares images according to brightness or the number of pixels in each image.</p>
<p>If an object type does not have either a map or order method, only equality comparisons are allowed on objects of that type. In this case, Oracle performs the comparison by doing a field-by-field comparison of the corresponding object attributes, in the order they are defined. If the comparison fails at any point, a <code>FALSE</code> value is returned. If the comparison matches at every point, a <code>TRUE</code> value is returned. However, if an object has a LOB or <code>ANYDATA</code> attributes, then Oracle does not compare the object on a field-by-field basis. Such objects must have a map or order method to perform comparisons.</p>
</div>
<!-- class="sect1" -->
<a id="i453869"></a>
<div id="ADOBJ00805" class="sect1">
<h2 class="sect1">Design Considerations for REFs</h2>
<p>This section discusses considerations when working with <code>REF</code>s.</p>
<ul>
<li>
<p><a href="#i452226">Storage Size of REFs</a></p>
</li>
<li>
<p><a href="#i452231">Integrity Constraints for REF Columns</a></p>
</li>
<li>
<p><a href="#i452236">Performance and Storage Considerations for Scoped REFs</a></p>
</li>
<li>
<p><a href="#i445527">Speeding up Object Access Using the WITH ROWID Option</a></p>
</li>
</ul>
<a id="i452226"></a>
<div id="ADOBJ7438" class="sect2">
<h3 class="sect2">Storage Size of REFs<a id="sthref771"></a></h3>
<p>A <code>REF</code> contains the following three logical components:</p>
<ul>
<li>
<p>OID of the object referenced. A system-generated OID is 16 bytes long. The size of a primary-key based OID depends on the size of the primary key column(s).</p>
</li>
<li>
<p>OID of the table or view containing the object referenced, which is 16 bytes long.</p>
</li>
<li>
<p>Rowid hint, which is 10 bytes long.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i452231"></a>
<div id="ADOBJ7439" class="sect2">
<h3 class="sect2">Integrity Constraints for REF Columns<a id="sthref772"></a><a id="sthref773"></a></h3>
<p>Referential integrity constraints on <code>REF</code> columns ensure that there is a row object for the <code>REF</code>. Referential integrity constraints on <code>REF</code>s create the same relationship as specifying a primary key/foreign key relationship on relational data. In general, you should use referential integrity constraints wherever possible because they are the only way to ensure that the row object for the <code>REF</code> exists. However, you cannot specify referential integrity constraints on <code>REF</code>s that are in nested tables.</p>
</div>
<!-- class="sect2" -->
<a id="i452236"></a>
<div id="ADOBJ7440" class="sect2">
<h3 class="sect2">Performance and Storage Considerations for Scoped REFs<a id="sthref774"></a></h3>
<p>A scoped <code>REF</code> is constrained to contain only references to a specified object table. You can specify a scoped <code>REF</code> when you declare a column type, collection element, or object type attribute to be a <code>REF</code>.</p>
<p>In general, you should use scoped <code>REF</code>s instead of unscoped <code>REF</code>s because scoped <code>REF</code>s are stored more efficiently. Whereas an unscoped <code>REF</code> takes at least 36 bytes to store (more if it uses rowids), a scoped <code>REF</code> is stored as just the OID of its target object and can take less than 16 bytes, depending on whether the referenced OID is system-generated or primary-key based. A system-generated OID requires 16 bytes; a primary key based (PK-based) OID requires enough space to store the primary key value, which may be less than 16 bytes. However, a <code>REF</code> to a PK-based OID, which must be dynamically constructed upon selection, may take more space in memory than a <code>REF</code> to a system-generated OID.</p>
<p>Besides requiring less storage space, scoped <code>REF</code>s often enable the optimizer to optimize queries that dereference a scoped <code>REF</code> into more efficient joins. This optimization is not possible for unscoped <code>REF</code>s because the optimizer cannot determine the containing table(s) for unscoped <code>REF</code>s at query-optimization time.</p>
<p>Unlike referential integrity constraints, scoped <code>REF</code>s do not ensure that the referenced row object exists; they only ensure that the referenced object table exists. Therefore, if you specify a scoped <code>REF</code> to a row object and then delete the row object, the scoped <code>REF</code> becomes a dangling <code>REF</code> because the referenced object no longer exists.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Referential integrity constraints are scoped implicitly.</div>
<p>Unscoped <code>REF</code>s are useful if the application design requires that the objects referenced be scattered in multiple tables. Because rowid hints are ignored for scoped <code>REF</code>s, you should use unscoped <code>REF</code>s if the performance gain of the rowid hint, as explained in the <a href="#i445527">&#34;Speeding up Object Access Using the WITH ROWID Option&#34;</a>, outweighs the benefits of the storage saving and query optimization of using scoped <code>REF</code>s.</p>
<div id="ADOBJ7441" class="sect3"><a id="sthref775"></a>
<h4 class="sect3">Indexing Scoped REFs<a id="sthref776"></a></h4>
<p>You can build indexes on scoped <code>REF</code> columns using the <code>CREATE</code> <code>INDEX</code> command. This allows you to use the index to efficiently evaluate queries that dereference the scoped <code>REF</code>s. Such queries are turned into joins implicitly. For certain types of queries, Oracle can use an index on the scoped <code>REF</code> column to evaluate the join efficiently.</p>
<p>For example, suppose the object type <code>address_objtyp</code> is used to create an object table named <code>address_objtab</code>:</p>
<pre>CREATE TABLE address_objtab OF address_objtyp ;
</pre>
<p>A <code>people_reltab2</code> table can be created that has the same definition as the <code>people_reltab</code> table shown in <a href="#CJACHEIF">Example 9-2</a>, except that a <code>REF</code> is used for the address. Next, an index can be created on the <code>address_ref</code> column.</p>
<div id="ADOBJ7442" class="example">
<p class="titleinexample"><a id="sthref777"></a>Example 9-3 Creating an Index on Scoped REF Columns</p>
<pre>CREATE TABLE people_reltab2 (
  id            NUMBER(4)   CONSTRAINT pk_people_reltab2 PRIMARY KEY,
  name_obj      name_objtyp,
  address_ref   REF address_objtyp SCOPE IS address_objtab,
  phones_ntab   phone_ntabtyp)
  NESTED TABLE  phones_ntab STORE AS phone_store_ntab2 ;

CREATE INDEX address_ref_idx ON people_reltab2 (address_ref) ;
</pre></div>
<!-- class="example" -->
<p>The following query dereferences the <code>address_ref</code>:</p>
<pre>SELECT id FROM people_reltab2 p
   WHERE p.address_ref.state = &#39;CA&#39; ;
</pre>
<p>When this query is executed, the <code>address_ref_idx</code> index is used to efficiently evaluate it. Here, <code>address_ref</code> is a scoped <code>REF</code> column that stores references to addresses stored in the <code>address_objtab</code> object table. Oracle implicitly transforms the preceding query into a query with a join:</p>
<pre>SELECT p.id FROM people_reltab2 p, address_objtab a
   WHERE p.address_ref = REF(a) AND a.state = &#39;CA&#39; ;
</pre>
<p>The Oracle query optimizer might create a plan to perform a nested-loops join with <code>address_objtab</code> as the outer table and look up matching addresses using the index on the <code>address_ref</code> scoped <code>REF</code> column.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i445527"></a>
<div id="ADOBJ7443" class="sect2">
<h3 class="sect2">Speeding up Object Access Using the WITH ROWID Option<a id="sthref778"></a></h3>
<p>If the <code>WITH</code> <code>ROWID</code> option is specified for a <code>REF</code> column, Oracle maintains the rowid of the object referenced in the <code>REF</code>. Then, Oracle can find the object referenced directly using the rowid contained in the <code>REF</code>, without the need to fetch the rowid from the OID index. Therefore, you use the <code>WITH</code> <code>ROWID</code> option to specify a rowid hint. Maintaining the rowid requires more storage space because the rowid adds 10 bytes to the storage requirements of the <code>REF</code>.</p>
<p>Bypassing the OID index search improves the performance of <code>REF</code> traversal (navigational access) in applications. The actual performance gain may vary from application to application depending on the following factors:</p>
<ul>
<li>
<p>How large the OID indexes are.</p>
</li>
<li>
<p>Whether the OID indexes are cached in the buffer cache.</p>
</li>
<li>
<p>How many <code>REF</code> traversals an application does.</p>
</li>
</ul>
<p>The <code>WITH</code> <code>ROWID</code> option is only a hint because, when you use this option, Oracle checks the OID of the row object with the OID in the <code>REF</code>. If the two OIDs do not match, Oracle uses the OID index instead. The rowid hint is not supported for scoped <code>REF</code>s, for <code>REF</code>s with referential integrity constraints, or for primary key-based <code>REF</code>s.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i453969"></a>
<div id="ADOBJ00807" class="sect1">
<h2 class="sect1">Design Considerations for Collections</h2>
<p>This section discusses considerations when working with collections.</p>
<ul>
<li>
<p><a href="#i449073">Viewing Object Data in Relational Form with Unnesting Queries</a></p>
</li>
<li>
<p><a href="#i450743">Storage Considerations for Varrays</a></p>
</li>
<li>
<p><a href="#i452249">Performance of Varrays Versus Nested Tables</a></p>
</li>
<li>
<p><a href="#i448939">Design Considerations for Nested Tables</a></p>
</li>
<li>
<p><a href="#i452968">Design Considerations for Multilevel Collections</a></p>
</li>
</ul>
<a id="i449073"></a>
<div id="ADOBJ7444" class="sect2">
<h3 class="sect2">Viewing Object Data in Relational Form with Unnesting Queries<a id="sthref779"></a><a id="sthref780"></a><a id="sthref781"></a><a id="sthref782"></a></h3>
<p>An unnesting query on a collection allows the data to be viewed in a flat (relational) form. You can execute unnesting queries on single-level and <a id="sthref783"></a>multilevel collections of either nested tables or varrays. This section contains examples of unnesting queries.</p>
<p>Nested tables can be unnested for queries using the <code>TABLE</code> syntax, as in the following example:</p>
<div id="ADOBJ7445" class="example">
<p class="titleinexample"><a id="sthref784"></a>Example 9-4 Unnesting a Nested Table with the TABLE Function</p>
<pre>SELECT p.name_obj, n.num 
   FROM people_reltab p, TABLE(p.phones_ntab) n ;
</pre></div>
<!-- class="example" -->
<p>Here, <code>phones_ntab</code> specifies the attributes of the <code>phones_ntab</code> nested table. To retrieve even parent rows that have no child rows (no phone numbers, in this case), use the outer join syntax, with the <code>+</code>. For example:</p>
<pre>SELECT p.name_obj, n.num 
   FROM people_reltab p, TABLE(p.phones_ntab) (+) n ;
</pre>
<p>If the <code>SELECT</code> list of a query does not refer to any columns from the parent table other than the nested table column, the query is optimized to execute only against the nested table&#39;s storage table.</p>
<p>The unnesting query syntax is the same for varrays as for nested tables. For instance, suppose the <code>phones_ntab</code> nested table is instead a varray named <code>phones_var</code>. The following example shows how to use the <code>TABLE</code> syntax to query the varray:</p>
<br/>
<code>SELECT p.name_obj, v.num</code><br/>
<code>&nbsp;&nbsp;FROM people_reltab p, TABLE(p.phones_var) v;</code>
<div id="ADOBJ7446" class="sect3"><a id="sthref785"></a>
<h4 class="sect3">Using Procedures and Functions in Unnesting Queries</h4>
<p>You can create procedures and functions that you can then execute to perform unnesting queries. For example, you can create a function called <code>home_phones()</code> that returns only the phone numbers where <code>location</code> is <code>home</code>. To create the <code>home_phones()</code> function, you enter code like the following:</p>
<div id="ADOBJ7447" class="example">
<p class="titleinexample"><a id="sthref786"></a>Example 9-5 Creating the home_phones Function</p>
<pre>CREATE OR REPLACE FUNCTION home_phones(allphones IN phone_ntabtyp)  
         RETURN phone_ntabtyp IS 
   homephones phone_ntabtyp := phone_ntabtyp(); 
   indx1      number; 
   indx2      number := 0; 
BEGIN 
   FOR indx1 IN 1..allphones.count LOOP 
      IF 
         allphones(indx1).location = &#39;home&#39; 
      THEN 
         homephones.extend;    -- extend the local collection 
         indx2 := indx2 + 1;    
         homephones(indx2) := allphones(indx1); 
      END IF; 
   END LOOP; 
 
   RETURN homephones; 
END; 
/ 
</pre></div>
<!-- class="example" -->
<p>Now, to query for a list of people and their home phone numbers, enter the following:</p>
<div id="ADOBJ7448" class="example">
<p class="titleinexample"><a id="sthref787"></a>Example 9-6 Using the TABLE Function to Unnest a Query</p>
<pre>SELECT p.name_obj, n.num 
   FROM people_reltab p, TABLE(
      CAST(home_phones(p.phones_ntab) AS phone_ntabtyp)) n ;  
 
</pre></div>
<!-- class="example" -->
<p>To query for a list of people and their home phone numbers, including those people who do not have a home phone number listed, enter the following:</p>
<pre>SELECT p.name_obj, n.num 
   FROM people_reltab p,  
       TABLE(CAST(home_phones(p.phones_ntab) AS phone_ntabtyp))(+) n ;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> and <a class="olink ADDCI2140" href="../ADDCI/pipe_paral_tbl.htm#ADDCI2140"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a> for more information about the <code>TABLE</code> function</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i450743"></a>
<div id="ADOBJ7449" class="sect2">
<h3 class="sect2">Storage Considerations for Varrays<a id="sthref788"></a></h3>
<p>The size of a stored varray depends only on the current count of the number of elements in the varray and not on the maximum number of elements that it can hold. Because the storage of varrays incurs some overhead, such as null information, the size of the varray stored may be slightly greater than the size of the elements multiplied by the count.</p>
<p>Varrays are stored in columns either as raw values or <code>LOB</code>s. Oracle decides how to store the varray when the varray is defined, based on the maximum possible size of the varray computed using the <code>LIMIT</code> of the declared varray. If the size exceeds approximately 4000 bytes, then the varray is stored in <code>LOB</code>s. Otherwise, the varray is stored in the column itself as a raw value. In addition, Oracle supports inline LOBs which means that elements that fit in the first 4000 bytes of a large varray, with some bytes reserved for the LOB locator, are stored in the column of the row. See also <a class="olink ADLOB" href="../ADLOB/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer&#39;s Guide</span></a>.</p>
<a id="i471407"></a>
<div id="ADOBJ7450" class="sect3">
<h4 class="sect3">Propagating VARRAY Size Change</h4>
<p>When changing the size of a <code>VARRAY</code> type, a new type version is generated for the dependent types. It is important to be aware of this when a <code>VARRAY</code> column is not explicitly stored as a LOB and its maximum size is originally smaller than 4000 bytes. If the size is larger than or equal to 4000 bytes after the increase, the <code>VARRAY</code> column has to be stored as a LOB. This requires an extra operation to upgrade the metadata of the <code>VARRAY</code> column in order to set up the necessary LOB metadata information including the LOB segment and LOB index.</p>
<p>The <code>CASCADE</code> option in the <code>ALTER</code> <code>TYPE</code> statement propagates the <code>VARRAY</code> size change to its dependent types and tables. A new version is generated for each valid dependent type and dependent tables metadata are updated accordingly based on the different case scenarios described previously. If the <code>VARRAY</code> column is in a cluster table, an <code>ALTER</code> <code>TYPE</code> statement with the <code>CASCADE</code> option fails because a cluster table does not support a LOB.</p>
<p>The <code>CASCADE</code> option in the <code>ALTER</code> <code>TYPE</code> statement also provides the <code>[NOT]</code> <code>INCLUDING</code> <code>TABLE</code> <code>DATA</code> option. The <code>NOT</code> <code>INCLUDING</code> <code>TABLE</code> <code>DATA</code> option only updates the metadata of the table, but does not convert the data image. In order to convert the <code>VARRAY</code> image to the latest version format, you can either specify <code>INCLUDING</code> <code>TABLE</code> <code>DATA</code> explicitly in <code>ALTER</code> <code>TYPE</code> <code>CASCADE</code> statement or issue <code>ALTER</code> <code>TABLE</code> <code>UPGRADE</code> statement.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i452249"></a>
<div id="ADOBJ7451" class="sect2">
<h3 class="sect2">Performance of Varrays Versus Nested Tables<a id="sthref789"></a></h3>
<p>If the entire collection is manipulated as a single unit in the application, varrays perform much better than nested tables. The varray is stored packed and requires no joins to retrieve the data, unlike nested tables.</p>
<p class="subhead1"><a id="ADOBJ7452"></a>Varray Querying<a id="sthref790"></a><a id="sthref791"></a></p>
<p>The unnesting syntax can be used to access varray columns similar to the way it is used to access nested tables. See <a href="#i449073">&#34;Viewing Object Data in Relational Form with Unnesting Queries&#34;</a> for more information.</p>
<p class="subhead1"><a id="ADOBJ7453"></a>Varray Updates<a id="sthref792"></a></p>
<p>Piece-wise updates of a varray value are not supported. Thus, when a varray is updated, the entire old collection is replaced by the new collection.</p>
</div>
<!-- class="sect2" -->
<a id="i448939"></a>
<div id="ADOBJ7454" class="sect2">
<h3 class="sect2">Design Considerations for Nested Tables<a id="sthref793"></a></h3>
<p>The following sections contain design considerations for using nested tables.</p>
<a id="i448918"></a>
<div id="ADOBJ7455" class="sect3">
<h4 class="sect3">Nested Table Storage<a id="sthref794"></a></h4>
<p>Oracle stores the rows of a nested table in a separate storage table. A system generated <code>NESTED_TABLE_ID</code>, which is 16 bytes in length, correlates the parent row with the rows in its corresponding storage table.</p>
<p><a href="#i445616">Figure 9-2</a> shows how the storage table works. The storage table contains each value for each nested table in a nested table column. Each value occupies one row in the storage table. The storage table uses the <code>NESTED_TABLE_ID</code> to track the nested table for each value. So, in <a href="#i445616">Figure 9-2</a>, all of the values that belong to nested table <code>A</code> are identified, all of the values that belong to nested table <code>B</code> are identified, and so on.</p>
<div id="ADOBJ7456" class="figure">
<p class="titleinfigure"><a id="i445616"></a>Figure 9-2 Nested Table Storage</p>
<img width="381" height="340" src="img/adobj021.gif" alt="Description of Figure 9-2 follows"/><br/>
<a id="sthref795" href="img_text/adobj021.htm">Description of &#34;Figure 9-2 Nested Table Storage&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p class="subhead1"><a id="ADOBJ7457"></a>Nested Table as an Index-Organized Table (IOT)<a id="sthref796"></a><a id="sthref797"></a></p>
<p>If a nested table has a primary key, you can organize the nested table as an index-organized table (IOT). If the <code>NESTED_TABLE_ID</code> column is a prefix of the primary key for a given parent row, Oracle physically clusters its child rows together. So, when a parent row is accessed, all its child rows can be efficiently retrieved. When only parent rows are accessed, efficiency is maintained because the child rows are not inter-mixed with the parent rows.</p>
<p><a href="#i446399">Figure 9-3</a> shows how the storage table works when the nested table is in an IOT. The storage table groups the values for each nested table in a nested table column by <code>NESTED_TABLE_ID</code>. In <a href="#i446399">Figure 9-3</a>, for each nested table in the <code>NT_DATA</code> column of the parent table, the data is grouped in the storage table: all of the values in nested table <code>A</code> are grouped together, all of the values in nested table <code>B</code> are grouped together, and so on.</p>
<div id="ADOBJ7458" class="figure">
<p class="titleinfigure"><a id="i446399"></a>Figure 9-3 Nested Table in IOT Storage</p>
<img width="381" height="340" src="img/adobj019.gif" alt="Description of Figure 9-3 follows"/><br/>
<a id="sthref798" href="img_text/adobj019.htm">Description of &#34;Figure 9-3 Nested Table in IOT Storage&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p><a id="sthref799"></a><a id="sthref800"></a>In addition, the <code>COMPRESS</code> clause enables prefix compression on the IOT rows. It factors out the key of the parent in every child row. That is, the parent key is not repeated in every child row, thus providing significant storage savings.</p>
<p>In other words, if you specify nested table compression using the <code>COMPRESS</code> clause, the amount of space required for the storage table is reduced because the <code>NESTED_TABLE_ID</code> is not repeated for each value in a group. Instead, the <code>NESTED_TABLE_ID</code> is stored only once for each group, as illustrated in <a href="#i446400">Figure 9-4</a>.</p>
<div id="ADOBJ7459" class="figure">
<p class="titleinfigure"><a id="i446400"></a>Figure 9-4 Nested Table in IOT Storage with Compression</p>
<img width="381" height="340" src="img/adobj020.gif" alt="Description of Figure 9-4 follows"/><br/>
<a id="sthref801" href="img_text/adobj020.htm">Description of &#34;Figure 9-4 Nested Table in IOT Storage with Compression&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>In general, Oracle recommends that nested tables be stored in an IOT with the <code>NESTED_TABLE_ID</code> column as a prefix of the primary key. Further, prefix compression should be enabled on the IOT. However, if you usually do not retrieve the nested table as a unit and you do not want to cluster the child rows, do not store the nested table in an IOT and do not specify compression.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7460" class="sect3"><a id="sthref802"></a>
<h4 class="sect3">Nested Table Indexes<a id="sthref803"></a><a id="sthref804"></a></h4>
<p>When creating nested tables stored in heap tables (as opposed to IOTs), Oracle database automatically creates an index on the NESTED_TABLE_ID column of the storage table and an index on the corresponding ID column of the parent table. Creating an index on the NESTED_TABLE_ID column enables the database to access the child rows of the nested table more efficiently, because the database must perform a join between the parent table and the nested table using the NESTED_TABLE_ID column.</p>
</div>
<!-- class="sect3" -->
<a id="CHDHECCA"></a>
<div id="ADOBJ7461" class="sect3">
<h4 class="sect3">Nested Table Locators<a id="sthref805"></a><a id="sthref806"></a><a id="sthref807"></a></h4>
<p>For large child sets, the parent row and a locator to the child set can be returned so that the child rows can be accessed on demand; the child sets also can be filtered. Using nested table locators enables you to avoid unnecessarily transporting child rows for every parent.</p>
<p>You can perform either one of the following actions to access the child rows using the nested table locator:</p>
<ul>
<li>
<p>Call the OCI collection functions. This action occurs implicitly when you access the elements of the collection in the client-side code, such as <code><span class="codeinlineitalic">OCIColl*</span></code> functions. The entire collection is retrieved implicitly on the first access.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI" href="../LNOCI/toc.htm"><span class="italic">Oracle Call Interface Programmer&#39;s Guide</span></a> for more information about OCI collection functions.</div>
</li>
<li>
<p>Use SQL to retrieve the rows corresponding to the nested table.</p>
</li>
</ul>
<p>In a multilevel collection, you can use a locator with a specified collection at any level of nesting.</p>
<p>The following topics specify ways that a collection can be retrieved as a locator:</p>
<ul>
<li>
<p><a href="#CHDBDHCJ">At Table Creation Time</a></p>
</li>
<li>
<p><a href="#CHDFHGDG">As a HINT During Retrieval</a></p>
</li>
</ul>
<a id="CHDBDHCJ"></a>
<div id="ADOBJ7462" class="sect4">
<h5 class="sect4">At Table Creation Time<a id="sthref808"></a><a id="sthref809"></a></h5>
<p>When the collection type is being used as a column type and the <code>NESTED</code> <code>TABLE</code> storage clause is used, you can use the <code>RETURN</code> <code>AS</code> <code>LOCATOR</code> clause to specify that a particular collection is to be retrieved as a locator.</p>
<p>For instance, suppose that <code>inner_table</code> is a collection type consisting of three levels of nested tables. In the following example, the <code>RETURN</code> <code>AS</code> <code>LOCATOR</code> clause specifies that the third level of nested tables is always to be retrieved as a locator.</p>
<div id="ADOBJ7463" class="example">
<p class="titleinexample"><a id="sthref810"></a>Example 9-7 Using the RETURN AS LOCATOR Clause</p>
<pre>CREATE TYPE inner_table AS TABLE OF NUMBER;/
CREATE TYPE middle_table AS TABLE OF inner_table;/
CREATE TYPE outer_table AS TABLE OF middle_table;/
CREATE TABLE tab1 (
  col1 NUMBER,
  col2 outer_table)
 NESTED TABLE col2 STORE AS col2_ntab
  (NESTED TABLE COLUMN_VALUE STORE AS cval1_ntab 
    (NESTED TABLE COLUMN_VALUE STORE AS cval2_ntab <span class="bold">RETURN AS LOCATOR</span>) );
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CHDFHGDG"></a>
<div id="ADOBJ7464" class="sect4">
<h5 class="sect4">As a HINT During Retrieval<a id="sthref811"></a><a id="sthref812"></a></h5>
<p>A query can retrieve a collection as a locator by means of the hint <code>NESTED_TABLE_GET_REFS</code>. Here is an example of retrieving the column <code>col2</code> from the table <code>tab1</code> as a locator:</p>
<pre>SELECT <span class="bold">/*+ NESTED_TABLE_GET_REFS +*/</span> col2
  FROM tab1
 WHERE col1 = 2;
</pre>
<p>Unlike with the <code>RETURN</code> <code>AS</code> <code>LOCATOR</code> clause, however, you cannot specify a particular inner collection to return as a locator when using the hint.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="ADOBJ7465" class="sect3"><a id="sthref813"></a>
<h4 class="sect3">Optimizing Set Membership Queries<a id="sthref814"></a></h4>
<p>Set membership queries are useful when you want to search for a specific item in a nested table. For example, the following query tests the membership in a child-set; specifically, whether the location <code>home</code> is in the nested table <code>phones_ntab</code>, which is in the parent table <code>people_reltab</code>:</p>
<pre>SELECT * FROM people_reltab p
   WHERE &#39;home&#39; IN (SELECT location FROM TABLE(p.phones_ntab)) ;
</pre>
<p>Oracle can execute a query that tests the membership in a child-set more efficiently by transforming it internally into a semijoin. However, this optimization only happens if the <code>ALWAYS_SEMI_JOIN</code> initialization parameter is set. If you want to perform semijoins, the valid values for this parameter are <code>MERGE</code> and <code>HASH</code>; these parameter values indicate which join method to use.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In the preceding example, <code>home</code> and <code>location</code> are child set elements. If the child set elements are object types, they must have a map or order method to perform a set membership query.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i452968"></a>
<div id="ADOBJ7466" class="sect2">
<h3 class="sect2">Design Considerations for Multilevel Collections</h3>
<p><a href="adobjcol.htm#CHDBDAHH">Chapter 5, &#34;Support for Collection Data Types&#34;</a> describes how to nest <a id="sthref815"></a>collection types to create a true multilevel collection, such as a nested table of nested tables, a nested table of varrays, a varray of nested tables, or a varray or nested table of an object type that has an attribute of a collection type.</p>
<p>You can also nest collections indirectly using <code>REF</code>s. For example, you can create a nested table of an object type that has an attribute that references an object that has a nested table or varray attribute. If you do not actually need to access all elements of a multilevel collection, then nesting a collection with <code>REF</code>s may provide better performance because only the <code>REF</code>s need to be loaded, not the elements themselves.</p>
<p>True multilevel collections (specifically multilevel nested tables) perform better for queries that access individual elements of the collection. Using nested table locators can improve the performance of programmatic access if you do not need to access all elements.</p>
<p>For an example of a collection that uses <code>REF</code>s to nest another collection, suppose you create a new object type called <code>person_objtyp</code> using the object types shown in <a href="#CJAGGHCG">Example 9-1</a>, which are <code>name_objtyp</code>, <code>address_objtyp</code>, and <code>phone_ntabtyp</code>. Remember that the <code>phone_ntabtyp</code> object type is a nested table because each person may have more than one phone number.</p>
<p>To create the <code>person_objtyp</code> object type and an object table called <code>people_objtab</code> of <code>person_objtyp</code> object type, issue the following SQL statement:</p>
<div id="ADOBJ7467" class="example">
<p class="titleinexample"><a id="sthref816"></a>Example 9-8 Creating an Object Table with a Multilevel Collection</p>
<pre>CREATE TYPE person_objtyp AS OBJECT (
   id            NUMBER(4), 
   name_obj      name_objtyp,
   address_obj   address_objtyp,
   phones_ntab   phone_ntabtyp);
/
</pre></div>
<!-- class="example" -->
<pre>CREATE TABLE people_objtab OF person_objtyp (id PRIMARY KEY)
   NESTED TABLE phones_ntab STORE AS phones_store_ntab ;
</pre>
<p>The <code>people_objtab</code> table has the same attributes as the <code>people_reltab</code> table. The difference is that the <code>people_objtab</code> is an object table with row objects, while the <code>people_reltab</code> table is a relational table with column objects.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i431312">&#34;Column Object Storage in Relational Tables&#34;</a></div>
<div id="ADOBJ7468" class="figure">
<p class="titleinfigure"><a id="sthref817"></a>Figure 9-5 Object-Relational Representation of the people_objtab Object Table</p>
<img width="471" height="482" src="img/adobj015.gif" alt="Description of Figure 9-5 follows"/><br/>
<a id="sthref818" href="img_text/adobj015.htm">Description of &#34;Figure 9-5 Object-Relational Representation of the people_objtab Object Table&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>You can reference the row objects in the <code>people_objtab</code> object table from other tables. For example, suppose you want to create a <code>projects_objtab</code> table that contains:</p>
<ul>
<li>
<p>A project identification number for each project.</p>
</li>
<li>
<p>The title of each project.</p>
</li>
<li>
<p>The project lead for each project.</p>
</li>
<li>
<p>A description of each project.</p>
</li>
<li>
<p>Nested table collection of the team of people assigned to each project.</p>
</li>
</ul>
<p>You can use <code>REF</code>s in the <code>people_objtab</code> for the project leads, and you can use a nested table collection of <code>REF</code>s for the team. To begin, create a nested table object type called <code>personref_ntabtyp</code> based on the <code>person_objtyp</code> object type:</p>
<pre>CREATE TYPE personref_ntabtyp AS TABLE OF REF person_objtyp;
/
</pre>
<p>Now you are ready to create the object table <code>projects_objtab</code>. First, create the object type <code>projects_objtyp</code>, then create the object table <code>projects_objtab</code> based on the <code>projects_objtyp</code> as shown in <a href="#CJADDCJI">Example 9-9</a>.</p>
<div id="ADOBJ7469" class="example">
<p class="titleinexample"><a id="CJADDCJI"></a>Example 9-9 Creating an Object Table Using REFs</p>
<pre>CREATE TYPE projects_objtyp AS OBJECT (
   id              NUMBER(4),   
   title           VARCHAR2(15),
   projlead_ref    REF person_objtyp,
   description     CLOB,
   team_ntab       personref_ntabtyp);
/
CREATE TABLE projects_objtab OF projects_objtyp (id PRIMARY KEY)
   NESTED TABLE team_ntab STORE AS team_store_ntab ;
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7470" class="figure">
<p class="titleinfigure"><a id="sthref819"></a>Figure 9-6 Object-Relational Representation of the projects_objtab Object Table</p>
<img width="472" height="295" src="img/adobj016.gif" alt="Description of Figure 9-6 follows"/><br/>
<a id="sthref820" href="img_text/adobj016.htm">Description of &#34;Figure 9-6 Object-Relational Representation of the projects_objtab Object Table&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>After the <code>people_objtab</code> object table and the <code>projects_objtab</code> object table are in place, you indirectly have a nested collection. That is, the <code>projects_objtab</code> table contains a nested table collection of <code>REF</code>s that point to the people in the <code>people_objtab</code> table, and the people in the <code>people_objtab</code> table have a nested table collection of phone numbers.</p>
<p>You can insert values into the <code>people_objtab</code> table as shown in <a href="#CJABFIBA">Example 9-10</a>.</p>
<div id="ADOBJ7471" class="example">
<p class="titleinexample"><a id="CJABFIBA"></a>Example 9-10 Inserting Values into the people_objtab Object Table</p>
<pre>INSERT INTO people_objtab VALUES (
   0001,
   name_objtyp(&#39;JOHN&#39;, &#39;JACOB&#39;, &#39;SCHMIDT&#39;),
   address_objtyp(&#39;1252 Maple Road&#39;, &#39;Fairfax&#39;, &#39;VA&#39;, &#39;22033&#39;),
   phone_ntabtyp(
      phone_objtyp(&#39;home&#39;, &#39;650.555.0141&#39;),
      phone_objtyp(&#39;work&#39;, &#39;510.555.0122&#39;))) ;

INSERT INTO people_objtab VALUES (
   0002,
   name_objtyp(&#39;MARY&#39;, &#39;ELLEN&#39;, &#39;MILLER&#39;),
   address_objtyp(&#39;33 Spruce Street&#39;, &#39;McKees Rocks&#39;, &#39;PA&#39;, &#39;15136&#39;),
   phone_ntabtyp(
      phone_objtyp(&#39;home&#39;, &#39;415.555.0143&#39;),
      phone_objtyp(&#39;work&#39;, &#39;650.555.0192&#39;))) ;

INSERT INTO people_objtab VALUES (
   0003,
   name_objtyp(&#39;SARAH&#39;, &#39;MARIE&#39;, &#39;SINGER&#39;),
   address_objtyp(&#39;525 Pine Avenue&#39;, &#39;San Mateo&#39;, &#39;CA&#39;, &#39;94403&#39;),
   phone_ntabtyp(
      phone_objtyp(&#39;home&#39;, &#39;510.555.0101&#39;),
      phone_objtyp(&#39;work&#39;, &#39;650.555.0178&#39;),
      phone_objtyp(&#39;cell&#39;, &#39;650.555.0143&#39;))) ;
</pre></div>
<!-- class="example" -->
<p>Then, you can insert into the <code>projects_objtab</code> relational table by selecting from the <code>people_objtab</code> object table using a <code>REF</code> operator, as in <a href="#CJAJHHJB">Example 9-11</a>.</p>
<div id="ADOBJ7472" class="example">
<p class="titleinexample"><a id="CJAJHHJB"></a>Example 9-11 Inserting Values into the projects_objtab Object Table</p>
<pre>INSERT INTO projects_objtab VALUES (
   1101,
   &#39;Demo Product&#39;,
   (SELECT REF(p) FROM people_objtab p WHERE id = 0001), 
   &#39;Demo the product, show all the great features.&#39;,
   personref_ntabtyp(
      (SELECT REF(p) FROM people_objtab p WHERE id = 0001),
      (SELECT REF(p) FROM people_objtab p WHERE id = 0002), 
      (SELECT REF(p) FROM people_objtab p WHERE id = 0003))) ;

INSERT INTO projects_objtab VALUES (
   1102,
   &#39;Create PRODDB&#39;,   
   (SELECT REF(p) FROM people_objtab p WHERE id = 0002),
   &#39;Create a database of our products.&#39;,
   personref_ntabtyp(
      (SELECT REF(p) FROM people_objtab p WHERE id = 0002),
      (SELECT REF(p) FROM people_objtab p WHERE id = 0003))) ;
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
This example uses nested tables to store <code>REF</code>s, but you also can store <code>REF</code>s in varrays. That is, you can have a varray of <code>REF</code>s.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i454119"></a>
<div id="ADOBJ00850" class="sect1">
<h2 class="sect1">Design Considerations for Methods</h2>
<p>This section discusses considerations when working with methods.</p>
<ul>
<li>
<p><a href="#i443371">Choosing a Language for Method Functions</a></p>
</li>
<li>
<p><a href="#i449945">Static Methods</a></p>
</li>
<li>
<p><a href="#i454922">Using SELF IN OUT NOCOPY with Member Procedures</a></p>
</li>
<li>
<p><a href="#i454034">Function-Based Indexes on the Return Values of Type Methods</a></p>
</li>
</ul>
<a id="i443371"></a>
<div id="ADOBJ7473" class="sect2">
<h3 class="sect2">Choosing a Language for Method Functions</h3>
<p><a id="sthref821"></a>Method functions can be implemented in any of the languages supported by Oracle, such as PL/SQL, Java, or C. Consider the following factors when you choose the language for a particular application:</p>
<ul>
<li>
<p>Ease of use</p>
</li>
<li>
<p>SQL calls</p>
</li>
<li>
<p>Speed of execution</p>
</li>
<li>
<p>Same/different address space</p>
</li>
</ul>
<p>In general, if the application performs intense computations, C is preferable, but if the application performs a relatively large number of database calls, PL/SQL or Java is preferable.</p>
<p>A method implemented in C executes in a separate process from the server using external procedures. In contrast, a method implemented in Java or PL/SQL executes in the same process as the server.</p>
<p class="subhead1"><a id="ADOBJ7474"></a>Example: Implementing a Method</p>
<p>The example described in this section involves an object type whose methods are implemented in different languages. In the example, the object type <code>ImageType</code> has an <code>ID</code> attribute, which is a <code>NUMBER</code> that uniquely identifies it, and an <code>IMG</code> attribute, which is a <code>BLOB</code> that stores the raw image. The object type <code>ImageType</code> has the following methods:</p>
<ul>
<li>
<p>The method <code>get_name</code> fetches the name of the image by looking it up in the database. This method is implemented in PL/SQL.</p>
</li>
<li>
<p>The method <code>rotate</code> rotates the image. This method is implemented in C.</p>
</li>
<li>
<p>The method <code>clear</code> returns a new image of the specified color. This method is implemented in Java.</p>
</li>
</ul>
<p>For implementing a method in C, a <code>LIBRARY</code> object must be defined to point to the library that contains the external C routines. For implementing a method implemented in Java, this example assumes that the Java class with the method has been compiled and uploaded into Oracle.</p>
<p>The object type specification and its methods are shown in <a href="#CJAGAGIH">Example 9-12</a>.</p>
<div id="ADOBJ7475" class="example">
<p class="titleinexample"><a id="CJAGAGIH"></a>Example 9-12 Creating an Object Type with Methods Implemented in Different Languages</p>
<pre>CREATE LIBRARY myCfuncs TRUSTED AS STATIC
/

CREATE TYPE ImageType AS OBJECT (
   id   NUMBER, 
   img  BLOB, 
   MEMBER FUNCTION get_name return VARCHAR2,
   MEMBER FUNCTION rotate return BLOB,
   STATIC FUNCTION clear(color NUMBER) return BLOB);/

CREATE TYPE BODY ImageType AS 
   MEMBER FUNCTION get_name RETURN VARCHAR2 
   IS 
    imgname  VARCHAR2(100);
    sqlstmt VARCHAR2(200);
   BEGIN 
      sqlstmt := &#39;SELECT name INTO imgname FROM imgtab WHERE imgid = id&#39;; 
      EXECUTE IMMEDIATE sqlstmt;
      RETURN imgname;
   END; 
 
   MEMBER FUNCTION rotate RETURN BLOB
   AS LANGUAGE C 
   NAME &#34;Crotate&#34; 
   LIBRARY myCfuncs;
   
   STATIC FUNCTION clear(color NUMBER) RETURN BLOB 
   AS LANGUAGE JAVA 
   NAME &#39;myJavaClass.clear(oracle.sql.NUMBER) return oracle.sql.BLOB&#39;; 
 
END;
/
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Restriction:</p>
Type methods can be mapped only to static Java methods.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink JJDEV" href="../JJDEV/toc.htm"><span class="italic">Oracle Database Java Developer&#39;s Guide</span></a> for more information</p>
</li>
<li>
<p><a href="adobjenv.htm#i441290">Chapter 4, &#34;Object Support in Oracle Programming Environments&#34;</a> for more information about choosing a language</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i449945"></a>
<div id="ADOBJ7476" class="sect2">
<h3 class="sect2">Static Methods<a id="sthref822"></a></h3>
<p>Static methods differ from member methods in that the <code>SELF</code> value is not passed in as the first parameter. Methods in which the value of <code>SELF</code> is not relevant should be implemented as static methods. Static methods can be used for user-defined constructors.</p>
<p><a href="#CJAGGACH">Example 9-13</a> shows a constructor-like method that constructs an instance of the type based on the explicit input parameters and inserts the instance into the specified table:.</p>
<div id="ADOBJ7477" class="example">
<p class="titleinexample"><a id="CJAGGACH"></a>Example 9-13 Creating an Object Type with a STATIC Method</p>
<pre>CREATE TYPE atype AS OBJECT(
   a1 NUMBER,
   STATIC PROCEDURE newa (
      p1        NUMBER, 
      tabname   VARCHAR2, 
      schname   VARCHAR2));
/
CREATE TYPE BODY atype AS
    STATIC PROCEDURE newa (p1 NUMBER, tabname VARCHAR2, schname VARCHAR2)
      IS
      sqlstmt VARCHAR2(100);
    BEGIN
      sqlstmt := &#39;INSERT INTO &#39;||schname||&#39;.&#39;||tabname|| &#39; VALUES (atype(:1))&#39;;
      EXECUTE IMMEDIATE sqlstmt USING p1;
    END;
END;
/

CREATE TABLE atab OF atype;

BEGIN
   atype.newa(1, &#39;atab&#39;, &#39;HR&#39;);
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i454922"></a>
<div id="ADOBJ00853" class="sect2">
<h3 class="sect2">Using SELF IN OUT NOCOPY with Member Procedures</h3>
<p><a id="sthref823"></a><a id="sthref824"></a><a id="sthref825"></a>In member procedures, if <code>SELF</code> is not declared, its parameter mode defaults to <code>IN</code> <code>OUT</code>. However, the default behavior does not include the <code>NOCOPY</code> compiler hint. See <a href="adobjbas.htm#i477669">&#34;Member Methods&#34;</a>.</p>
<p>Because the value of the <code>IN</code> <code>OUT</code> actual parameter is copied into the corresponding formal parameter, the copying slows down execution when the parameters hold large data structures such as instances of large object types.</p>
<p><a id="sthref826"></a>For performance reasons, you may want to include <code>SELF</code> <code>IN</code> <code>OUT</code> <code>NOCOPY</code> when passing a large object type as a parameter. For example:</p>
<p><code>MEMBER PROCEDURE my_proc (SELF IN OUT NOCOPY my_LOB)</code></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS013" href="../LNPLS/langelems.htm#LNPLS013"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information on performance issues and restrictions on the use of <code>NOCOPY</code></p>
</li>
<li>
<p><a class="olink SQLRF01309" href="../SQLRF/statements_6011.htm#SQLRF01309"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about using <code>NOCOPY</code> in the <code>CREATE</code> <code>PROCEDURE</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i454034"></a>
<div id="ADOBJ7478" class="sect2">
<h3 class="sect2">Function-Based Indexes on the Return Values of Type Methods<a id="sthref827"></a><a id="sthref828"></a></h3>
<p>A function-based index is an index based on the return values of an expression or function. The function may be a method function of an object type.</p>
<p>A function-based index built on a method function precomputes the return value of the function for each object instance in the column or table being indexed and stores those values in the index. There they can be referenced without having to evaluate the function again.</p>
<p>Function-based indexes are useful for improving the performance of queries that have a function in the <code>WHERE</code> clause. For example, the following code contains a query of an object table <code>emps</code>:</p>
<pre>CREATE TYPE emp_t AS OBJECT(
  name   VARCHAR2(36),
  salary NUMBER,
  MEMBER FUNCTION bonus RETURN NUMBER DETERMINISTIC);
/
CREATE TYPE BODY emp_t IS
 MEMBER FUNCTION bonus RETURN NUMBER DETERMINISTIC IS
 BEGIN
  RETURN self.salary * .1;
 END;
END;
/

CREATE TABLE emps OF emp_t ;

SELECT e.name
  FROM emps e
  WHERE e.bonus() &gt; 2000;
</pre>
<p>To evaluate this query, Oracle must evaluate <code>bonus()</code> for each row object in the table. If there is a function-based index on the return values of <code>bonus()</code>, then this work has already been done, and Oracle can simply look up the results in the index. This enables Oracle to return a result from the query more quickly.</p>
<p>Return values of a function can be usefully indexed only if those values are constant, that is, only if the function always returns the same value for each object instance. For this reason, to use a user-written function in a function-based index, the function must have been declared with the <code>DETERMINISTIC</code> keyword, as in the preceding example. This keyword promises that the function always returns the same value for each object instance&#39;s set of input argument values.</p>
<p>The following example creates a function-based index on the method <code>bonus()</code> in the table <code>emps</code>:</p>
<div id="ADOBJ7479" class="example">
<p class="titleinexample"><a id="sthref829"></a>Example 9-14 Creating a Function-Based Index on a Method</p>
<pre>CREATE INDEX emps_bonus_idx ON emps x (x.bonus()) ;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT" href="../CNCPT/toc.htm"><span class="italic">Oracle Database Concepts</span></a> and <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for detailed information about function-based indexes</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i452266"></a>
<div id="ADOBJ00810" class="sect1">
<h2 class="sect1">Writing Reusable Code Using Invoker Rights</h2>
<p><a id="sthref830"></a><a id="sthref831"></a>To create generic object types that can be used in any schema, you must define the type to use invoker rights, through the <code>AUTHID</code> <code>CURRENT_USER</code> option of <code>CREATE</code> <code>OR</code> <code>REPLACE</code> <code>TYPE</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For information on controlling invoker&#39;s rights privileges, see <a class="olink DBSEG653" href="../DBSEG/dr_ir.htm#DBSEG653"><span class="italic">Oracle Database Security Guide</span>.</a></div>
<p>In general, use invoker rights when both of the following conditions are true:</p>
<ul>
<li>
<p>There are type methods that access and manipulate data.</p>
</li>
<li>
<p>Users who did not define these type methods must use them.</p>
</li>
</ul>
<p>For example, you can grant user <code>OE</code> execute privileges on type <code>atype</code> created by HR in <a href="#i449945">&#34;Static Methods&#34;</a>, and then create table <code>atab</code> based on the type:</p>
<pre>GRANT EXECUTE ON atype TO oe;
CONNECT oe;
Enter password: <span class="italic">password</span>
CREATE TABLE atab OF HR.atype ;
</pre>
<p>Now, suppose user <code>OE</code> tries to use <code>atype</code> in the following statement:</p>
<pre>BEGIN -- follwing call raises an error, insufficient privileges
  HR.atype.newa(1, &#39;atab&#39;, &#39;OE&#39;);
END;
/
</pre>
<p>This statement raises an error because the definer of the type (<code>HR</code>) does not have the privileges required to perform the insert in the <code>newa</code> procedure. You can avoid this error by defining <code>atype</code> using invoker rights. Here, you first drop the <code>atab</code> table in both schemas and re-create <code>atype</code> using invoker rights:</p>
<pre>DROP TABLE atab;
CONNECT hr;
Enter password: <span class="italic">password</span>
DROP TABLE atab;
DROP TYPE atype FORCE;
COMMIT;

CREATE TYPE atype AUTHID CURRENT_USER AS OBJECT(
   a1 NUMBER,
   STATIC PROCEDURE newa(p1 NUMBER, tabname VARCHAR2, schname VARCHAR2));
/
CREATE TYPE BODY atype AS
  STATIC PROCEDURE newa(p1 NUMBER, tabname VARCHAR2, schname VARCHAR2)
   IS
     sqlstmt VARCHAR2(100);
   BEGIN
      sqlstmt := &#39;INSERT INTO &#39;||schname||&#39;.&#39;||tabname|| &#39; 
                  VALUES (HR.atype(:1))&#39;;
      EXECUTE IMMEDIATE sqlstmt USING p1;
   END;
END;
/
</pre>
<p>Now, if user <code>OE</code> tries to use <code>atype</code> again, the statement executes successfully:</p>
<pre>GRANT EXECUTE ON atype TO oe;
CONNECT oe;
Enter password: <span class="italic">password</span>
CREATE TABLE atab OF HR.atype;

BEGIN
  HR.atype.newa(1, &#39;atab&#39;, &#39;OE&#39;);
END;
/
DROP TABLE atab;
CONNECT hr;
Enter password: <span class="italic">password</span>
DROP TYPE atype FORCE;
</pre>
<p>The statement is successful this time because the procedure is executed under the privileges of the invoker (<code>OE</code>), not the definer (<code>HR</code>).</p>
<p>In a type hierarchy, a subtype has the same rights model as its immediate supertype. That is, it implicitly inherits the rights model of the supertype and cannot explicitly specify one. Furthermore, if the supertype was declared with definer rights, the subtype must reside in the same schema as the supertype. These rules allow invoker-rights type hierarchies to span schemas. However, type hierarchies that use a definer-rights model must reside within a single schema. For example:</p>
<pre>CREATE TYPE deftype1 AS OBJECT (...); --Definer-rights type
CREATE TYPE subtype1 UNDER deftype1 (...); --subtype in same schema as supertype
CREATE TYPE schema2.subtype2 UNDER deftype1 (...); --ERROR 
CREATE TYPE invtype1 AUTHID CURRENT_USER AS OBJECT (...); --Invoker-rights type
CREATE TYPE schema2.subtype2 UNDER invtype1 (...); --LEGAL
</pre></div>
<!-- class="sect1" -->
<a id="CHDEBEDJ"></a>
<div id="ADOBJ7480" class="sect1">
<h2 class="sect1">Using Roles with Invoker&#39;s Rights Subprograms</h2>
<p><a id="sthref832"></a>The use of roles in a subprogram depends on whether it executes with definer&#39;s rights or invoker&#39;s rights. Within a definer&#39;s rights subprogram, all roles are disabled. Roles are not used for privilege checking, and you cannot set roles.</p>
<p>Within an invoker&#39;s rights subprogram, roles are enabled (unless the subprogram was called directly or indirectly by a definer&#39;s rights subprogram). Roles are used for privilege checking, and you can use native dynamic SQL to set roles for the session. However, you cannot use roles to grant privileges on template objects because roles apply at run time, not at compile time.</p>
</div>
<!-- class="sect1" -->
<a id="CIHFGECI"></a>
<div id="ADOBJ7670" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Object Replication Using Logical Standby<a id="sthref833"></a></h2>
<p>Beginning with Oracle Database release 12<span class="italic">c</span>, release 12.1, the following are now supported, using XML for propagation:</p>
<ul>
<li>
<p>object replication, including type evolution and inheritance</p>
</li>
<li>
<p>varrays</p>
</li>
<li>
<p><code>ANYDATA</code> data types</p>
</li>
</ul>
<p>Objects are now supported data types for logical standbys.</p>
<p>Replication is not supported for nested tables, Varrays, <code>REF</code>s, or piecewise updates of embedded LOBs.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a class="olink SBYDB4935" href="../SBYDB/data_support.htm#SBYDB4935"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for information about data types supported by SQL Apply (logical standby)</p>
</div>
</div>
<!-- class="sect1" -->
<a id="i452280"></a>
<div id="ADOBJ00812" class="sect1">
<h2 class="sect1">Replicating Object Tables and Columns</h2>
<p><a id="sthref834"></a>Object <a id="sthref835"></a>tables and <a id="sthref836"></a>object views can be replicated as materialized views. You can also replicate relational tables that contain columns of an object, collection, or <code>REF</code> type. Such materialized views are called object-relational materialized views.</p>
<p>All user-defined types required by an object-relational materialized view must exist at the materialized view site as well as at the master site. They must have the same object type IDs and versions at both sites.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDGCDFJ">Replicating Columns of Object, Collection, or REF Type</a></p>
</li>
<li>
<p><a href="#CHDJEJCB">Replicating Object Tables</a></p>
</li>
</ul>
<a id="CHDGCDFJ"></a>
<div id="ADOBJ7481" class="sect2">
<h3 class="sect2">Replicating Columns of Object, Collection, or REF Type</h3>
<p>To be updatable, a materialized view based on a table that contains an <a href="glossary.htm#CHDGHHHE"><span class="xrefglossterm">object column</span></a> must select the column as an object in the query that defines the view: if the query selects only certain attributes of the column&#39;s object type, then the materialized view is read-only.</p>
<p>The view-definition query can also select columns of collection or <code>REF</code> type. <code>REF</code>s can be either primary-key based or have a system-generated key, and they can be either scoped or unscoped. Scoped <code>REF</code> columns can be rescoped to a different table at the site of the materialized view&mdash;for example, to a local materialized view of the master table instead of the original, remote table.</p>
</div>
<!-- class="sect2" -->
<a id="CHDJEJCB"></a>
<div id="ADOBJ7482" class="sect2">
<h3 class="sect2">Replicating Object Tables</h3>
<p>A materialized view based on an object table is called an object <a id="sthref837"></a>materialized view. Such a materialized view is itself an object table. An object materialized view is created by adding the <code>OF</code> <code><span class="codeinlineitalic">type</span></code> keyword to the <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement. For example:</p>
<br/>
<code>CREATE MATERIALIZED VIEW customer OF cust_objtyp AS</code><br/>
<code>&nbsp;&nbsp;SELECT * FROM HR.Customer_objtab@dbs1;</code><br/>
<p>As with an ordinary object table, each row of an object materialized view is an object instance, so the view-definition query that creates the materialized view must select entire objects from the master table: the query cannot select only a subset of the object type&#39;s attributes. For example, the following materialized view is not allowed:</p>
<br/>
<code>CREATE MATERIALIZED VIEW customer OF cust_objtyp AS</code><br/>
<code>&nbsp;&nbsp;SELECT CustNo FROM HR.Customer_objtab@dbs1;</code><br/>
<p>You can create an object-relational materialized view from an object table by omitting the <code>OF</code> <code><span class="codeinlineitalic">type</span></code> keyword, but such a view is read-only: you cannot create an updatable object-relational materialized view from an object table.</p>
<p>For example, the following <code>CREATE</code> <code>MATERIALIZED</code> <code>VIEW</code> statement creates a read-only object-relational materialized view of an object table. Even though the view-definition query selects all columns and attributes of the object type, it does not select them as attributes of an object, so the view created is object-relational and read-only:</p>
<br/>
<code>CREATE MATERIALIZED VIEW customer AS</code><br/>
<code>&nbsp;&nbsp;SELECT * FROM HR.Customer_objtab@dbs1;</code><br/>
<p>For both object-relational and object materialized views that are based on an object table, if the type of the master object table is not <code>FINAL</code>, the <code>FROM</code> clause in the materialized view definition query must include the <code>ONLY</code> keyword. For example:</p>
<br/>
<code>CREATE MATERIALIZED VIEW customer OF cust_objtyp AS</code><br/>
<code>&nbsp;&nbsp;SELECT CustNo FROM ONLY HR.Customer_objtab@dbs1;</code><br/>
<p>Otherwise, the <code>FROM</code> clause must omit the <code>ONLY</code> keyword.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REPLN003" href="../REPLN/repmview.htm#REPLN003"><span class="italic">Oracle Database Advanced Replication</span></a> for more information on replicating object tables and columns</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i452285"></a>
<div id="ADOBJ00814" class="sect1">
<h2 class="sect1">Constraints on Objects</h2>
<p><a id="sthref838"></a><a id="sthref839"></a>Oracle does not support constraints and defaults in type specifications. However, you can specify the constraints and defaults when creating the tables:</p>
<div id="ADOBJ7483" class="example">
<p class="titleinexample"><a id="sthref840"></a>Example 9-15 Specifying Constraints on an Object Type When Creating a Table</p>
<pre>CREATE TYPE customer_typ AS OBJECT(  
   cust_id INTEGER);
/
CREATE TYPE department_typ AS OBJECT(
   deptno INTEGER);
/
CREATE TABLE customer_tab OF customer_typ (  
   cust_id default 1 <span class="bold">NOT NULL</span>);

CREATE TABLE department_tab OF department_typ (  
   deptno <span class="bold">PRIMARY KEY</span>);

CREATE TABLE customer_tab1 (  
   cust customer_typ DEFAULT customer_typ(1)   
   CHECK (cust.cust_id IS <span class="bold">NOT NULL</span>),  
   some_other_column VARCHAR2(32));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i452646"></a>
<div id="ADOBJ00816" class="sect1">
<h2 class="sect1">Considerations Related to Type Evolution</h2>
<p>The following sections contain <a id="sthref841"></a>design considerations relating to type evolution.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDJIEFG">Pushing a Type Change Out to Clients</a></p>
</li>
<li>
<p><a href="#CHDCBACI">Changing Default Constructors</a></p>
</li>
<li>
<p><a href="#CHDDJDIF">Altering the FINAL Property of a Type</a></p>
</li>
</ul>
<a id="CHDJIEFG"></a>
<div id="ADOBJ7484" class="sect2">
<h3 class="sect2">Pushing a Type Change Out to Clients</h3>
<p>Once a type has evolved on the server side, all client applications using this type need to make the necessary changes to structures associated with the type. You can do this with OTT/JPUB. You also may need to make programmatic changes associated with the structural change. After making these changes, you must recompile your application and relink.</p>
<p>Types may be altered between releases of a third-party application. To inform client applications that they need to recompile to become compatible with the latest release of the third-party application, you can have the clients call a release-oriented compatibility initialization function. This function could take as input a string that tells it which release the client application is working with. If the release string mismatches with the latest version, an error is generated. The client application must then change the release string as part of the changes required to become compatible with the latest release.</p>
<p>For example:</p>
<br/>
<code>FUNCTION compatibility_init(</code><br/>
<code>&nbsp;&nbsp;rel IN VARCHAR2, errmsg OUT VARCHAR2)</code><br/>
<code>RETURN NUMBER;</code><br/>
<p>where:</p>
<ul>
<li>
<p><code>rel</code> is a release string that is chosen by the product, such as, <code>&#39;Release 10.1&#39;</code></p>
</li>
<li>
<p><code>errmsg</code> is any error message that may need to be returned</p>
</li>
<li>
<p>The function returns <code>0</code> on success and a nonzero value on error</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDCBACI"></a>
<div id="ADOBJ7485" class="sect2">
<h3 class="sect2">Changing Default Constructors</h3>
<p>When a type is altered, its default, system-defined constructors need to be changed in order (for example) to include newly added attributes in the parameter list. If you are using default constructors, you need to modify their invocations in your program in order for the calls to compile.</p>
<p>You can avoid having to modify constructor calls if you define your own constructor functions instead of using the system-defined default ones. See <a href="adobjadv.htm#CHDJCFAG">&#34;Advantages of User-Defined Constructors&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDDJDIF"></a>
<div id="ADOBJ7486" class="sect2">
<h3 class="sect2">Altering the FINAL Property of a Type</h3>
<p>When you alter a type <code>T1</code> from <code><a id="sthref842"></a><a id="sthref843"></a><a id="sthref844"></a>FINAL</code> to <code>NOT FINAL</code>, any attribute of type <code>T1</code> in the client program changes from being an inlined structure to a pointer to <code>T1</code>. This means that you need to change the program to use dereferencing when this attribute is accessed.</p>
<p>Conversely, when you alter a type from <code>NOT FINAL</code> to <code>FINAL</code>, the attributes of that type change from being pointers to inlined structures.</p>
<p>For example, say that you have the types <code>T1(a int)</code> and <code>T2(b T1)</code>, where <code>T1</code>&#39;s property is <code>FINAL</code>. The C/JAVA structure corresponding to <code>T2</code> is <code>T2(T1 b)</code>. But if you change <code>T1</code>&#39;s property to <code>NOT FINAL</code>, then <code>T2</code>&#39;s structure becomes <code>T2(T1 *b)</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i452294"></a>
<div id="ADOBJ00817" class="sect1">
<h2 class="sect1">Parallel Queries with Oracle Objects</h2>
<p><a id="sthref845"></a>Oracle lets you perform <a id="sthref846"></a><a id="sthref847"></a>parallel queries with objects and objects synthesized in views, when you follow these rules:</p>
<ul>
<li>
<p>To make queries involving joins and sorts parallel (using the <code>ORDER</code> <code>BY</code>, <code>GROUP</code> <code>BY</code>, and <code>SET</code> operations), a <code>MAP</code> function is required. In the absence of a <code>MAP</code> function, the query automatically becomes serial.</p>
</li>
<li>
<p>Parallel queries on nested tables are not supported. Even if there are parallel hints or parallel attributes for the table, the query is serial.</p>
</li>
<li>
<p>Parallel DML and parallel DDL are not supported with objects. DML and DDL are always performed in serial.</p>
</li>
<li>
<p>Parallel DML is not supported on views with <code>INSTEAD-OF</code> trigger. However, the individual statements within the trigger may be parallelized.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i453627"></a>
<div id="ADOBJ7487" class="sect1">
<h2 class="sect1">Design Consideration Tips and Techniques</h2>
<p>The following sections provide assorted tips on various aspects of working with Oracle object types.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDDABCF">Deciding Whether to Evolve a Type or Create a Subtype</a></p>
</li>
<li>
<p><a href="#CHDCHJBG">How ANYDATA Differs from User-Defined Types</a></p>
</li>
<li>
<p><a href="#CHDFECHC">Polymorphic Views: An Alternative to an Object View Hierarchy</a></p>
</li>
<li>
<p><a href="#CHDEBHEA">The SQLJ Object Type</a></p>
</li>
<li>
<p><a href="#CHDECGJD">Miscellaneous Design Tips</a></p>
</li>
</ul>
<a id="CHDDABCF"></a>
<div id="ADOBJ7488" class="sect2">
<h3 class="sect2">Deciding Whether to Evolve a Type or Create a Subtype<a id="sthref848"></a><a id="sthref849"></a></h3>
<p>As an application goes through its life cycle, the question often arises whether to <a id="sthref850"></a><a id="sthref851"></a>change an existing object type or to create a specialized subtype to meet new requirements. The answer depends on the nature of the new requirements and their context in the overall application semantics. Here are two examples:</p>
<p class="subhead1"><a id="ADOBJ7489"></a>Changing a Widely Used Base Type</p>
<p>Suppose that we have an object type <code>address</code> with attributes <code>Street</code>, <code>State</code>, and <code>ZIP</code>:</p>
<pre>CREATE TYPE address AS OBJECT (
  Street  VARCHAR2(80),
  State   VARCHAR2(20),
  ZIP     VARCHAR2(10));
/
</pre>
<p>We later find that we need to extend the <code>address</code> type by adding a <code>Country</code> attribute to support addresses internationally. Is it better to create a subtype of <code>address</code> or to evolve the <code>address</code> type itself?</p>
<p>With a general base type that has been widely used throughout an application, it is better to implement the change using type evolution.</p>
<p class="subhead1"><a id="ADOBJ7490"></a>Adding Specialization</p>
<p>Suppose that an existing type hierarchy of Graphic types (for example, curve, circle, square, text) needs to accommodate an additional variation, namely, Bezier curve. To support a new specialization of this sort that does not reflect a shortcoming of the base type, we should use inheritance and create a new subtype <code>BezierCurve</code> under the <code>Curve</code> type.</p>
<p>To sum up, the semantics of the required change dictates whether we should use type evolution or inheritance. For a change that is more general and affects the base type, use type evolution. For a more specialized change, implement the change using inheritance.</p>
</div>
<!-- class="sect2" -->
<a id="CHDCHJBG"></a>
<div id="ADOBJ7491" class="sect2">
<h3 class="sect2">How ANYDATA Differs from User-Defined Types</h3>
<p><code><a id="sthref852"></a>ANYDATA</code> is an Oracle-supplied type that can hold instances of any Oracle data type, whether built-in or user-defined. <code>ANYDATA</code> is a self-describing type and supports a reflection-like API that you can use to determine the shape of an instance.</p>
<p>While both inheritance, through the substitutability feature, and <code>ANYDATA</code> provide the polymorphic ability to store any of a set of possible instances in a placeholder, the two models give the capability two very different forms.</p>
<p>In the inheritance model, the <a id="sthref853"></a>polymorphic set of possible instances must form part of a single type hierarchy. A variable can potentially hold instances only of its defined type or of its subtypes. You can access attributes of the supertype and call methods defined in the supertype (and potentially overridden by the subtype). You can also test the specific type of an instance using the IS OF and the TREAT operators.</p>
<p><code>ANYDATA</code> variables, however, can store heterogeneous instances. You cannot access attributes or call methods of the actual instance stored in an <code>ANYDATA</code> variable (unless you extract out the instance). You use the <code>ANYDATA</code> methods to discover and extract the type of the instance. <code>ANYDATA</code> is a very useful mechanism for parameter passing when the function/procedure does not care about the specific type of the parameter(s).</p>
<p>Inheritance provides better modeling, strong typing, specialization, and so on. Use <code>ANYDATA</code> when you simply want to be able to hold one of any number of possible instances that do not necessarily have anything in common.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFECHC"></a>
<div id="ADOBJ7492" class="sect2">
<h3 class="sect2">Polymorphic Views: An Alternative to an Object View Hierarchy</h3>
<p><a href="adobjvew.htm#g444865">Chapter 6, &#34;Applying an Object Model to Relational Data&#34;</a> describes how to build up a <a id="sthref854"></a><a id="sthref855"></a><a id="sthref856"></a>view hierarchy from a set of object views each of which contains objects of a single type. Such a view hierarchy enables queries on a view within the hierarchy to see a polymorphic set of objects contained by the queried view or its subviews.</p>
<p>As an alternative way to support such polymorphic queries, you can define an object view based on a query that returns a polymorphic set of objects. This approach is especially useful when you want to define a view over a set of tables or views that already exists.</p>
<p>For example, an object view of <code>Person_t</code> can be defined over a query that returns <code>Person_t</code> instances, including <code>Employee_t</code> instances. The following statement creates a view based on queries that select persons from a <code>persons</code> table and employees from an <code>employees</code> table.</p>
<br/>
<code>CREATE VIEW Persons_view OF Person_t AS</code><br/>
<code>&nbsp;&nbsp;SELECT Person_t(...) FROM persons</code><br/>
<code>&nbsp;&nbsp;UNION ALL</code><br/>
<code>&nbsp;&nbsp;SELECT TREAT(Employee_t(...) AS Person_t) FROM employees;</code><br/>
<p>An <code>INSTEAD OF</code> trigger defined for this view can use the <code>VALUE</code> function to access the current object and to take appropriate action based on the object&#39;s most specific type.</p>
<p>Polymorphic views and object view hierarchies have these important differences:</p>
<ul>
<li>
<p><span class="bold">Addressability</span>: In a view hierarchy, each subview can be referenced independently in queries and DML statements. Thus, every set of objects of a particular type has a logical name. However, a polymorphic view is a single view, so you must use predicates to obtain the set of objects of a particular type.</p>
</li>
<li>
<p><span class="bold">Evolution</span>: If a new subtype is added, a subview can be added to a view hierarchy without changing existing view definitions. With a polymorphic view, the single view definition must be modified by adding another <code>UNION</code> branch.</p>
</li>
<li>
<p><span class="bold">DML Statements</span>: In a view hierarchy, each subview can be either inherently updatable or can have its own <code>INSTEAD OF</code> trigger. With a polymorphic view, only one <code>INSTEAD OF</code> trigger can be defined for a given operation on the view.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDEBHEA"></a>
<div id="ADOBJ7493" class="sect2">
<h3 class="sect2">The SQLJ Object Type</h3>
<p>This section discusses the SQLJ object type.</p>
<div id="ADOBJ7494" class="sect3"><a id="sthref857"></a>
<h4 class="sect3">The Intended Use of SQLJ Object Types</h4>
<p>According to the <span class="italic">Information</span> <span class="italic">Technology</span> <span class="italic">-</span> <span class="italic">SQLJ</span> <span class="italic">-</span> <span class="italic">Part</span> <span class="italic">2</span> document (SQLJ Standard), a SQLJ object type is a database object type designed for Java. A <a id="sthref858"></a>SQLJ object type maps to a Java class. Once the mapping is registered through the extended SQL <code>CREATE TYPE</code> command (a DDL statement), the Java application can insert or select the Java objects directly into or from the database through an Oracle JDBC driver. This enables the user to deploy the same class in the client, through JDBC, and in the server, through SQL method dispatch.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7495" class="sect3"><a id="sthref859"></a>
<h4 class="sect3">Actions Performed When Creating a SQLJ Object Type</h4>
<p>The extended SQL <code>CREATE TYPE</code> command:</p>
<ul>
<li>
<p>Populates the database catalog with the external names for attributes, functions, and the Java class. Also, dependencies between the Java class and its corresponding SQLJ object type are maintained.</p>
</li>
<li>
<p>Validates the existence of the Java class and validates that it implements the interface corresponding to the value of the <code>USING</code> clause.</p>
</li>
<li>
<p>Validates the existence of the Java fields (as specified in the <code>EXTERNAL NAME</code> clause) and whether these fields are compatible with corresponding SQL attributes.</p>
</li>
<li>
<p>Generates an internal class to support constructors, external variable names, and external functions that return <code>self</code> as a result.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7496" class="sect3"><a id="sthref860"></a>
<h4 class="sect3">Uses of SQLJ Object Types</h4>
<p>The SQLJ object type is a special case of SQL object type in which all methods are implemented in a Java class. The mapping between a Java class and its corresponding SQL type is managed by the SQLJ object type specification. That is, the SQLJ Object type specification cannot have a corresponding type body specification.</p>
<p>Also, the inheritance rules among SQLJ object types specify the legal mapping between a Java class hierarchy and its corresponding SQLJ object type hierarchy. These rules ensure that the SQLJ Type hierarchy contains a valid mapping. That is, the supertype or subtype of a SQLJ object type has to be another SQLJ object type.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7497" class="sect3"><a id="sthref861"></a>
<h4 class="sect3">Uses of Custom Object Types</h4>
<p>The custom object type is the Java interface for accessing SQL object types. A SQL object type may include methods that are implemented in languages such as PLSQL, Java, and C. Methods implemented in Java in a given SQL object type can belong to different unrelated classes. That is, the SQL object type does not map to a specific Java class.</p>
<p>In order for the client to access these objects, JPublisher can be used to generate the corresponding Java class. Furthermore, the user has to augment the generated classes with the code of the corresponding methods. Alternatively, the user can create the class corresponding to the SQL object type.</p>
<p>At runtime, the JDBC user has to register the correspondence between a SQL Type name and its corresponding Java class in a map.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7498" class="sect3"><a id="sthref862"></a>
<h4 class="sect3">Differences Between SQLJ and Custom Object Types Through JDBC</h4>
<p>The following table summarizes the differences between SQLJ object types and custom object types.</p>
<div id="ADOBJ7499" class="tblruleformalwidekeymax">
<p class="titleintable"><a id="sthref863"></a><a id="sthref864"></a>Table 9-1 Differences Between SQLJ and Custom Object Types</p>
<table class="cellalignment3994" title="Differences Between SQLJ and Custom Object Types" summary="differences between SQLJ and custom object types" dir="ltr">
<thead>
<tr class="cellalignment3981">
<th class="cellalignment3991" id="r1c1-t21">Feature</th>
<th class="cellalignment3991" id="r1c2-t21">SQLJ Object Type Behavior</th>
<th class="cellalignment3991" id="r1c3-t21">Custom Object Type Behavior</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r2c1-t21" headers="r1c1-t21">
<p>Typecodes</p>
</td>
<td class="cellalignment3987" headers="r2c1-t21 r1c2-t21">
<p>Use the <code>OracleTypes.JAVA_STRUCT</code> typecode to register a SQLJ object type as a SQL <code>OUT</code> parameter. The <code>OracleTypes.JAVA_STRUCT</code> typecode is also used in the <code>_SQL_TYPECODE</code> field of a class implementing the <code>ORAData</code> or <code>SQLData</code> interface.</p>
</td>
<td class="cellalignment3987" headers="r2c1-t21 r1c3-t21">
<p>Use the <code>OracleTypes.STRUCT</code> typecode to register a custom object type as a SQL <code>OUT</code> parameter. The <code>OracleTypes.STRUCT</code> typecode is also used in the <code>_SQL_TYPECODE</code> field of a class implementing the <code>ORAData</code> or <code>SQLData</code> interface.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r3c1-t21" headers="r1c1-t21">
<p>Creation</p>
</td>
<td class="cellalignment3987" headers="r3c1-t21 r1c2-t21">
<p>Create a Java class implementing the <code>SQLData</code> or <code>ORAData</code> and <code>ORADataFactory</code> interfaces first and then load the Java class into the database. Next, you issue the extended SQL <code>CREATE TYPE</code> command for SQLJ object type.</p>
</td>
<td class="cellalignment3987" headers="r3c1-t21 r1c3-t21">
<p>Issue the extended SQL <code><a id="sthref865"></a>CREATE TYPE</code> command for a custom object type and then create the <code>SQLData</code> or <code>ORAData</code> Java wrapper class using JPublisher or do this manually.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r4c1-t21" headers="r1c1-t21">
<p>Method Support</p>
</td>
<td class="cellalignment3987" headers="r4c1-t21 r1c2-t21">
<p>Supports external names, constructor calls, and calls for member functions with side effects.</p>
</td>
<td class="cellalignment3987" headers="r4c1-t21 r1c3-t21">
<p>There is no default class for implementing type methods as Java methods. Some methods may also be implemented in SQL.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r5c1-t21" headers="r1c1-t21">
<p>Type Mapping</p>
</td>
<td class="cellalignment3987" headers="r5c1-t21 r1c2-t21">
<p>Type mapping is automatically done by the extended SQL <code>CREATE TYPE</code> command. However, the SQLJ object type must have a defining Java class on the client.</p>
</td>
<td class="cellalignment3987" headers="r5c1-t21 r1c3-t21">
<p>Register the correspondence between SQL and Java in a type map. Otherwise, the type is materialized as <code>oracle.sql.STRUCT</code>.</p>
</td>
</tr>
<tr class="cellalignment3981">
<td class="cellalignment3987" id="r6c1-t21" headers="r1c1-t21">
<p>Inheritance</p>
</td>
<td class="cellalignment3987" headers="r6c1-t21 r1c2-t21">
<p>There are rules for mapping SQL hierarchy to a Java class hierarchy. See the <a class="olink SQLRF" href="../SQLRF/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for a complete description of these rules.</p>
</td>
<td class="cellalignment3987" headers="r6c1-t21 r1c3-t21">
<p>There are no mapping rules.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
<!-- class="tblruleformalwidekeymax" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDECGJD"></a>
<div id="ADOBJ7500" class="sect2">
<h3 class="sect2">Miscellaneous Design Tips</h3>
<p>This section discusses miscellaneous tips for designing with Oracle objects.</p>
<div id="ADOBJ7501" class="sect3"><a id="sthref866"></a>
<h4 class="sect3">Column Substitutability and the Number of Attributes in a Hierarchy</h4>
<p>If a column or table is of type <code>T</code>, Oracle adds a hidden column for each attribute of type <code>T</code> and, if the column or table is substitutable, for each attribute of every subtype of <code>T</code>, to store attribute data. A hidden <code>typeid</code> column is added as well, to keep track of the type of the object instance in a row.</p>
<p>The number of columns in a table is limited to 1,000. A type hierarchy with a number of total attributes approaching 1,000 puts you at risk of running up against this limit when using substitutable columns of a type in the hierarchy. To avoid problems as a result of this, consider one of the following options for dealing with a hierarchy that has a large number of total attributes:</p>
<ul>
<li>
<p>Use views</p>
</li>
<li>
<p>Use <code>REF</code>s</p>
</li>
<li>
<p>Break up the hierarchy</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7502" class="sect3"><a id="sthref867"></a>
<h4 class="sect3">Circular Dependencies Among Types</h4>
<p>Avoid creating circular dependencies among types. In other words, do not create situations in which a method of type <code>T</code> returns a type <code>T1</code>, which has a method that returns a type <code>T</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3980">
<tr>
<td class="cellalignment3987">
<table class="cellalignment3985">
<tr>
<td class="cellalignment3984"><a href="adobjadv.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3984"><a href="adobjxmp.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3989">
<table class="cellalignment3983">
<tr>
<td class="cellalignment3984"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3984"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3984"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3984"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3984"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3984"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>