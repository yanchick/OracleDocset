<!DOCTYPE html><html lang="en"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
<meta charset="utf-8"/>
<a class="dashingAutolink" name="autolink-741"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/Basic%20Components%20of%20Oracle%20Objects"></a><title>Basic Components of Oracle Objects</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023"/>
<meta name="dcterms.created" content="2014-08-06T13:19:5Z"/>
<meta name="robots" content="all"/>
<meta name="dcterms.title" content="Database Object-Relational Developer&#39;s Guide"/>
<meta name="dcterms.identifier" content="E53277-02"/>
<meta name="dcterms.isVersionOf" content="ADOBJ"/>
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved."/>
<link rel="Start" href="../index.htm" title="Home" type="text/html"/>
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html"/>

<script type="application/javascript" src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript" src="../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html"/>
<link rel="Index" href="index.htm" title="Index" type="text/html"/>
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"/>
<link rel="Prev" href="adobjint.htm" title="Previous" type="text/html"/>
<link rel="Next" href="adobjplsql.htm" title="Next" type="text/html"/>
<link rel="alternate" href="E53277-02.pdf" title="PDF version" type="application/pdf"/>
<link rel="schema.dcterms" href="http://purl.org/dc/terms/"/>
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/header.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/footer.css"/>
<link rel="stylesheet" type="text/css" href="../dcommon/css/fonts.css"/>
<link rel="stylesheet" href="../dcommon/css/foundation.css"/>
<link rel="stylesheet" href="../dcommon/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css"/>
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css"/>
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="/s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet" href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"/>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">6/16</span> <!-- End Header -->
<div id="ADOBJ002" class="chapter"><a id="g500167"></a> <a id="i462606"></a>
<h1 class="chapter"><span class="secnum">2</span> Basic Components of Oracle Objects</h1>
<p>This chapter provides basic information about working with Oracle SQL objects. It explains what object types and subprograms are, and describes how to create and work with a hierarchy of object types that are derived from a shared root type and are connected by inheritance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<span class="bold">Running Examples:</span> In order to run examples in chapter 2, you may need to drop any objects you created for Chapter 1.</div>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i454653">SQL Object Types and References</a></p>
</li>
<li>
<p><a href="#i463694">Object Methods</a></p>
</li>
<li>
<p><a href="#i456228">Inheritance in SQL Object Types</a></p>
</li>
<li>
<p><a href="#i463707">Functions and Operators Useful with Objects</a></p>
</li>
</ul>
<a id="i454653"></a>
<div id="ADOBJ00201" class="sect1">
<h2 class="sect1">SQL Object Types and References</h2>
<p>This section describes SQL object types and references, including:</p>
<a id="i454656"></a>
<ul>
<li>
<p><a href="#i454685">Null Objects and Attributes</a></p>
</li>
<li>
<p><a href="#i472900">Character Length Semantics</a></p>
</li>
<li>
<p><a href="#i454743">Constraints for Object Tables</a></p>
</li>
<li>
<p><a href="#i454776">Indexes for Object Tables</a></p>
</li>
<li>
<p><a href="#i454798">Triggers for Object Tables</a></p>
</li>
<li>
<p><a href="#i454824">Rules for REF Columns and Attributes</a></p>
</li>
<li>
<p><a href="#i454831">Name Resolution</a></p>
</li>
<li>
<p><a href="#CIHBIBEA">Restriction on Using User-Defined Types with a Remote Database</a></p>
</li>
</ul>
<p>You create Oracle SQL object types with the <code>CREATE</code> <code>TYPE</code> statement. A typical example of object type creation is shown in <a href="#CIHGJFGD">Example 2-1</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS01375" href="../LNPLS/create_type.htm#LNPLS01375"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information on the <code>CREATE</code> <code>TYPE</code> SQL statement</p>
</li>
<li>
<p><a class="olink LNPLS01376" href="../LNPLS/create_type_body.htm#LNPLS01376"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information on the <code>CREATE</code> <code>TYPE</code> <code>BODY</code> SQL statement</p>
</li>
</ul>
</div>
<a id="i454685"></a>
<div id="ADOBJ7068" class="sect2">
<h3 class="sect2">Null Objects and Attributes<a id="sthref88"></a><a id="sthref89"></a><a id="sthref90"></a><a id="sthref91"></a></h3>
<p>An object whose value is <code>NULL</code> is called atomically null. An <a href="glossary.htm#CHDHHDJC"><span class="xrefglossterm">atomically null object</span></a> is different from an object that has null values for all its attributes. In an object with null values, a table column, object attribute, collection, or collection element might be <code>NULL</code> if it has been initialized to <code>NULL</code> or has not been initialized at all. Usually, a <code>NULL</code> value is replaced by an actual value later on. When all the attributes are null, you can still change these attributes and call the object&#39;s subprograms or methods. With an atomically null object, you can do neither of these things.</p>
<p><a href="#CIHGJFGD">Example 2-1</a> creates the <code>contacts</code> table and defines the <code>person_typ</code> object type and two instances of this type.</p>
<div id="ADOBJ7069" class="example">
<p class="titleinexample"><a id="CIHGJFGD"></a>Example 2-1 Inserting NULLs for Objects in a Table</p>
<pre>CREATE OR REPLACE TYPE person_typ AS OBJECT (
  idno           NUMBER,
  name           VARCHAR2(30),
  phone          VARCHAR2(20),
  MAP MEMBER FUNCTION get_idno RETURN NUMBER, 
  MEMBER PROCEDURE display_details ( SELF IN OUT NOCOPY person_typ ) );
/

CREATE OR REPLACE TYPE BODY person_typ AS
  MAP MEMBER FUNCTION get_idno RETURN NUMBER IS
  BEGIN
    RETURN idno;
  END;
  MEMBER PROCEDURE display_details ( SELF IN OUT NOCOPY person_typ ) IS
  BEGIN
    -- use the PUT_LINE procedure of the DBMS_OUTPUT package to display details
    DBMS_OUTPUT.PUT_LINE(TO_CHAR(idno) || &#39; - &#39;  || name || &#39; - &#39;  || phone);
  END;
END;
/
CREATE TABLE contacts (
  contact        person_typ,
  contact_date   DATE );

INSERT INTO contacts VALUES (
  person_typ (<span class="bold">NULL, NULL, NULL</span>), &#39;24 Jun 2003&#39; );

INSERT INTO contacts VALUES (
  <span class="bold">NULL</span>, &#39;24 Jun 2003&#39; );
</pre></div>
<!-- class="example" -->
<p>Two instances of <code>person_typ</code> are inserted into the table and give two different results. In both cases, Oracle Database allocates space in the <code>contacts</code> table for a new row and sets its <code>DATE</code> column to the value given. But in the first case, Oracle Database allocates space for an object in the <code>contact</code> column and sets each of the object&#39;s attributes to <code>NULL</code>. In the second case, Oracle Database sets the <code>person_typ</code> field itself to <code>NULL</code> and does not allocate space for an object.</p>
<p>In some cases, you can omit checks for null values. A table row or row object cannot be null. A nested table of objects cannot contain an element whose value is <code>NULL</code>.</p>
<p>A nested table or array can be null, so you do need to handle that condition. A null collection is different from an empty one, one that has no elements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjplsql.htm#BJEJFBIA">&#34;How PL/SQL Treats Uninitialized Objects&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i472900"></a>
<div id="ADOBJ7070" class="sect2">
<h3 class="sect2">Character Length Semantics<a id="sthref92"></a><a id="sthref93"></a><a id="sthref94"></a></h3>
<p>Lengths for character types <code>CHAR</code> and <code>VARCHAR2</code> may be specified as a number of characters, instead of bytes, in object attributes and collections even if some of the characters consist of multiple bytes.</p>
<p>To specify character-denominated lengths for <code>CHAR</code> and <code>VARCHAR2</code> attributes, you add the qualifier <code>char</code> to the length specification.</p>
<p>Like <code>CHAR</code> and <code>VARCHAR2</code>, <code>NCHAR</code> and <code>NVARCHAR2</code> may also be used as attribute types in objects and collections. <code>NCHAR</code> and <code>NVARCHAR2</code> are always implicitly measured in terms of characters, so no <code>char</code> qualifier is used.</p>
<p>For example, the following statement creates an object with both a character-length <code>VARCHAR2</code> attribute and an <code>NCHAR</code> attribute:</p>
<div id="ADOBJ7071" class="example">
<p class="titleinexample"><a id="sthref95"></a>Example 2-2 Creating the employee_typ Object Using a char Qualifier</p>
<pre>CREATE OR REPLACE TYPE employee_typ AS OBJECT ( 
  name        VARCHAR2<span class="bold">(30 char)</span>, 
  language    NCHAR(10), 
  phone       VARCHAR2(20) );
/
</pre></div>
<!-- class="example" -->
<p>For <code>CHAR</code> and <code>VARCHAR2</code> attributes whose length is specified without a <code>char</code> qualifier, the <code>NLS_LENGTH_SEMANTICS</code> initialization parameter setting (<code>CHAR</code> or <code>BYTE</code>) indicates the default unit of measure.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG170" href="../NLSPG/ch2charset.htm#NLSPG170"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information on character length semantics</div>
</div>
<!-- class="sect2" -->
<a id="i454743"></a>
<div id="ADOBJ7072" class="sect2">
<h3 class="sect2">Constraints for Object Tables <a id="sthref96"></a><a id="sthref97"></a><a id="sthref98"></a><a id="sthref99"></a></h3>
<p>You can define constraints on an object table just as you can on other tables. You can define constraints on the <a href="glossary.htm#CHDHABDA"><span class="xrefglossterm">leaf-level scalar attribute</span></a>s of a column object, with the exception of <code>REF</code>s that are not scoped.</p>
<p>The following examples illustrate defining constraints.</p>
<p><a href="#CIHEBDIH">Example 2-3</a> places an implicit <code>PRIMARY</code> <code>KEY</code> constraint on the <code>office_id</code> column of the object table <code>office_tab</code>.</p>
<div id="ADOBJ7073" class="example">
<p class="titleinexample"><a id="CIHEBDIH"></a>Example 2-3 Creating the office_tab Object Table with a Constraint</p>
<pre>-- requires Ex. 2-1
CREATE OR REPLACE TYPE location_typ AS OBJECT (
  building_no  NUMBER,
  city         VARCHAR2(40) );
/

CREATE OR REPLACE TYPE office_typ AS OBJECT (
  office_id    VARCHAR(10),
  office_loc   location_typ,
  occupant     person_typ );/

CREATE TABLE office_tab OF office_typ (
             office_id      <span class="bold">PRIMARY KEY</span> );
</pre></div>
<!-- class="example" -->
<p>The object type <code>location_typ</code> defined in <a href="#CIHEBDIH">Example 2-3</a> is the type of the <code>dept_loc</code> column in the <code>department_mgrs</code> table in <a href="#CIHDDDHJ">Example 2-4</a>.</p>
<p><a href="#CIHDDDHJ">Example 2-4</a> defines constraints on scalar attributes of the <code>location_typ</code> objects in the table.</p>
<div id="ADOBJ7074" class="example">
<p class="titleinexample"><a id="CIHDDDHJ"></a>Example 2-4 Creating the department_mgrs Table with Multiple Constraints</p>
<pre>-- requires Ex. 2-1 and 2-3
CREATE TABLE department_mgrs (
  dept_no     NUMBER PRIMARY KEY, 
  dept_name   CHAR(20),
  dept_mgr    person_typ,
  dept_loc    location_typ,
  <span class="bold">CONSTRAINT  dept_loc_cons1</span>
      <span class="bold">UNIQUE (dept_loc.building_no, dept_loc.city)</span>,
  <span class="bold">CONSTRAINT  dept_loc_cons2</span>
       <span class="bold">CHECK (dept_loc.city IS NOT NULL)</span> );

INSERT INTO department_mgrs VALUES 
          ( 101, &#39;Physical Sciences&#39;, 
           person_typ(65,&#39;Vrinda Mills&#39;, &#39;1-1-650-555-0125&#39;),
           location_typ(300, &#39;Palo Alto&#39;));
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjdes.htm#i452285">&#34;Constraints on Objects&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i454776"></a>
<div id="ADOBJ7075" class="sect2">
<h3 class="sect2">Indexes for Object Tables<a id="sthref100"></a><a id="sthref101"></a><a id="sthref102"></a><a id="sthref103"></a><a id="sthref104"></a><a id="sthref105"></a><a id="sthref106"></a> <a id="sthref107"></a><a id="sthref108"></a><a id="sthref109"></a></h3>
<p>You can define indexes on an object table or on the storage table for a nested table column or attribute just as you can on other tables. For an example of an index on a nested table, see <a href="adobjcol.htm#i477859">Example 5-5</a>.</p>
<p>You can define indexes on <a href="glossary.htm#CHDHABDA"><span class="xrefglossterm">leaf-level scalar attribute</span></a>s of column objects, as shown in <a href="#CIHFAIFA">Example 2-5</a>. You can only define indexes on <code>REF</code> attributes or columns if the <code>REF</code> is scoped. This example indexes <code>city</code>, which is a leaf-level scalar attribute of the column object <code>dept_addr</code>.</p>
<div id="ADOBJ7076" class="example">
<p class="titleinexample"><a id="CIHFAIFA"></a>Example 2-5 Creating an Index on an Object Type in a Table</p>
<pre>-- requires Ex. 2-1, 2-3, 
CREATE TABLE department_loc (
  dept_no     NUMBER PRIMARY KEY, 
  dept_name   CHAR(20),
  <span class="bold">dept_addr </span>  location_typ );

<span class="bold">CREATE INDEX</span>  i_dept_addr1
          ON  department_loc (<span class="bold">dept_addr.city</span>);

INSERT INTO department_loc VALUES
          ( 101, &#39;Physical Sciences&#39;,
           location_typ(300, &#39;Palo Alto&#39;));
INSERT INTO department_loc VALUES 
          ( 104, &#39;Life Sciences&#39;, 
           location_typ(400, &#39;Menlo Park&#39;));
INSERT INTO department_loc VALUES 
          ( 103, &#39;Biological Sciences&#39;, 
           location_typ(500, &#39;Redwood Shores&#39;));
</pre></div>
<!-- class="example" -->
<p>Wherever Oracle Database expects a column name in an index definition, you can also specify a scalar attribute of a column object.</p>
</div>
<!-- class="sect2" -->
<a id="i454798"></a>
<div id="ADOBJ7077" class="sect2">
<h3 class="sect2">Triggers for Object Tables<a id="sthref110"></a><a id="sthref111"></a><a id="sthref112"></a><a id="sthref113"></a></h3>
<p>You can define triggers on an object table just as you can on other tables. You cannot define a trigger on the storage table for a nested table column or attribute. You cannot modify <code>LOB</code> values in a trigger body. Otherwise, there are no special restrictions on using object types with triggers.</p>
<p><a href="#CIHDIBJH">Example 2-6</a> defines a trigger on the <code>office_tab</code> table defined in <a href="#i454743">&#34;Constraints for Object Tables&#34;</a>.</p>
<div id="ADOBJ7078" class="example">
<p class="titleinexample"><a id="CIHDIBJH"></a>Example 2-6 Creating a Trigger on Objects in a Table</p>
<pre>-- requires Ex. 2-1 and 2-3
CREATE TABLE movement (
     idno           NUMBER,
     old_office     location_typ,
     new_office     location_typ );

<span class="bold">CREATE TRIGGER</span> trigger1
  BEFORE UPDATE
             OF  office_loc
             ON  <span class="bold">office_tab</span>
   FOR EACH ROW
           WHEN  (new.office_loc.city = &#39;Redwood Shores&#39;)
   BEGIN
     IF :new.office_loc.building_no = 600 THEN
      INSERT INTO movement (idno, old_office, new_office)
       VALUES (:old.occupant.idno, :old.office_loc, :new.office_loc);
     END IF;
   END;/
INSERT INTO office_tab VALUES 
    (&#39;BE32&#39;, location_typ(300, &#39;Palo Alto&#39; ),person_typ(280, &#39;John Chan&#39;, 
       &#39;415-555-0101&#39;));
 
UPDATE office_tab set office_loc =location_typ(600, &#39;Redwood Shores&#39;)
  where office_id = &#39;BE32&#39;; 
 
select * from office_tab;
 
select * from movement;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjvew.htm#i436099">&#34;Using INSTEAD OF Triggers to Control Mutating and Validation&#34;</a></div>
</div>
<!-- class="sect2" -->
<a id="i454824"></a>
<div id="ADOBJ7079" class="sect2">
<h3 class="sect2">Rules for REF Columns and Attributes<a id="sthref114"></a><a id="sthref115"></a><a id="sthref116"></a><a id="sthref117"></a><a id="sthref118"></a></h3>
<p>In Oracle Database, a <code>REF</code> column or attribute can be unconstrained or constrained using a <code>SCOPE</code> clause or a referential constraint clause. When a <code>REF</code> column is unconstrained, it may store object references to row objects contained in any object table of the corresponding object type.</p>
<p>Oracle Database does not ensure that the object references stored in such columns point to valid and existing row objects. Therefore, <code>REF</code> columns may contain object references that do not point to any existing row object. Such <code>REF</code> values are referred to as dangling references.</p>
<p>A <code>SCOPE</code> constraint can be applied to a specific object table. All the <code>REF</code> values stored in a column with a <code>SCOPE</code> constraint point at row objects of the table specified in the <code>SCOPE</code> clause. The <code>REF</code> values may, however, be dangling.</p>
<p>A <code>REF</code> column may be constrained with a <code>REFERENTIAL</code> constraint similar to the specification for foreign keys. The rules for referential constraints apply to such columns. That is, the object reference stored in these columns must point to a valid and existing row object in the specified object table.</p>
<p><code>PRIMARY</code> <code>KEY</code> constraints cannot be specified for <code>REF</code> columns. However, you can specify <code>NOT</code> <code>NULL</code> constraints for such columns.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="adobjint.htm#i458258">&#34;Using References to Row Objects&#34;</a></p>
</li>
<li>
<p><a href="#CHDJEAHI">&#34;Substitution of REF Columns and Attributes&#34;</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i454831"></a>
<div id="ADOBJ7080" class="sect2">
<h3 class="sect2">Name Resolution<a id="sthref119"></a><a id="sthref120"></a><a id="sthref121"></a><a id="sthref122"></a><a id="sthref123"></a></h3>
<p>Oracle SQL lets you omit qualifying table names in some relational operations. For example, if <code>dept_addr</code> is a column in the <code>department_loc</code> table and <code>old_office</code> is a column in the <code>movement</code> table, you can use the following:</p>
<pre>SELECT * FROM department_loc WHERE EXISTS 
  (SELECT * FROM movement WHERE dept_addr = old_office);
</pre>
<p>Oracle Database determines which table each column belongs to.</p>
<p>Using dot notation, you can qualify the column names with table names or table aliases to make things more maintainable. For example:</p>
<div id="ADOBJ7081" class="example">
<p class="titleinexample"><a id="sthref124"></a>Example 2-7 Using the Dot Notation for Name Resolution</p>
<pre>-- requires Ex. 2-1, 2-3, 2-5, and 2-6
SELECT * FROM department_loc WHERE EXISTS 
  (SELECT * FROM movement WHERE <span class="bold">department_loc.dept_addr</span> = <span class="bold">movement.old_office</span>);

SELECT * FROM department_loc d WHERE EXISTS 
  (SELECT * FROM movement m WHERE <span class="bold">d.dept_addr</span> = <span class="bold">m.old_office</span>);
</pre></div>
<!-- class="example" -->
<p>In some cases, object-relational features require you to specify the table aliases.</p>
<div id="ADOBJ7082" class="sect3"><a id="sthref125"></a>
<h4 class="sect3">When Table Aliases Are Required<a id="sthref126"></a><a id="sthref127"></a><a id="sthref128"></a><a id="sthref129"></a><a id="sthref130"></a><a id="sthref131"></a><a id="sthref132"></a><a id="sthref133"></a><a id="sthref134"></a></h4>
<p>Using unqualified names can lead to problems. For example, if you add an <code>assignment</code> column to <code>depts</code> and forget to change the query, Oracle Database automatically recompiles the query so that the inner <code>SELECT</code> uses the <code>assignment</code> column from the <code>depts</code> table. This situation is called inner capture.</p>
<p>To avoid inner capture and similar problems resolving references, Oracle Database requires you to use a table alias to qualify any dot-notational reference to subprograms or attributes of objects.</p>
<p>Use of a table alias is optional when referencing top-level attributes of an object table directly, without using the dot notation. For example, the following statements define two tables that contain the <code>person_typ</code> object type. <code>person_obj_table</code> is an object table for objects of type <code>person_typ</code>, and <code>contacts</code> is a relational table that contains a column of the object <code>person_typ</code>.</p>
<p>The following queries show some correct and incorrect ways to reference attribute <code>idno</code>:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
These statements are not related to other examples in this chapter.</div>
<br/>
#1 <code>SELECT idno FROM person_obj_table; --Correct</code><br/>
<br/>
<code>#2 SELECT contact.idno FROM contacts; --Illegal</code><br/>
<code>#3 SELECT contacts.contact.idno FROM contacts; --Illegal</code><br/>
<code>#4 SELECT p.contact.idno FROM contacts p; --Correct</code><br/>
<ul>
<li>
<p>In #1, <code>idno</code> is the name of a column of <code>person_obj_table</code>. It references this top-level attribute directly, without using the dot notation, so no table alias is required.</p>
</li>
<li>
<p>In #2, <code>idno</code> is the name of an attribute of the <code>person_typ</code> object in the column named <code>contact</code>. This reference uses the dot notation and so requires a table alias, as shown in #4.</p>
</li>
<li>
<p>#3 uses the table name itself to qualify the reference. This is incorrect; a table alias is required.</p>
</li>
</ul>
<p>You must qualify a reference to an object attribute or subprogram with a table alias rather than a table name even if the table name is itself qualified by a schema name.</p>
<p>For example, the following expression incorrectly refers to the <code>HR</code> schema, <code>department_loc</code> table, <code>dept_addr</code> column, and <code>city</code> attribute of that column. The expression is incorrect because <code>department_loc</code> is a table name, not an alias.</p>
<p><code>HR.department_loc.dept_addr.city</code></p>
<p>The same requirement applies to attribute references that use <code>REF</code>s.</p>
<p>Table aliases should uniquely pick out the same table throughout a query and should not be the same as schema names that could legally appear in the query.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Oracle recommends that you define table aliases in all <code>UPDATE</code>, <code>DELETE</code>, and <code>SELECT</code> statements and subqueries and use them to qualify column references whether or not the columns contain object types.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHBIBEA"></a>
<div id="ADOBJ7083" class="sect2">
<h3 class="sect2">Restriction on Using User-Defined Types with a Remote Database<a id="sthref135"></a><a id="sthref136"></a><a id="sthref137"></a><a id="sthref138"></a><a id="sthref139"></a></h3>
<p>Objects or user-defined types (specifically, types declared with a SQL <code>CREATE</code> <code>TYPE</code> statement, as opposed to types declared within a PL/SQL package) are currently useful only within a single database. Oracle Database restricts use of a database link as follows:</p>
<ul>
<li>
<p>You cannot connect to a remote database to select, insert, or update a user-defined type or an object <code>REF</code> on a remote table.</p>
<p>You can use the <code>CREATE</code> <code>TYPE</code> statement with the optional keyword <code>OID</code> to create a user-specified object identifier (OID) that allows an object type to be used in multiple databases. See the discussion on assigning an OID to an object type in the <a class="olink ADDCI210" href="../ADDCI/obj_types.htm#ADDCI210"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a>.</p>
</li>
<li>
<p>You cannot use database links within PL/SQL code to declare a local variable of a remote user-defined type.</p>
</li>
<li>
<p>You cannot convey a user-defined type argument or return value in a PL/SQL remote procedure call.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i463694"></a>
<div id="ADOBJ00202" class="sect1">
<h2 class="sect1">Object Methods<a id="sthref140"></a><a id="sthref141"></a><a id="sthref142"></a></h2>
<p>Object methods, also known as subprograms, are functions or procedures that you can declare in an object type definition to implement behavior that you want objects of that type to perform. An application calls the subprograms to invoke the behavior.</p>
<p>Subprograms can be written in PL/SQL or virtually any other programming language. Methods written in PL/SQL or Java are stored in the database. Methods written in other languages, such as C, are stored externally.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL requires parentheses for all subprogram calls, even those that do not have arguments. This is not true for PL/SQL.</div>
<p>This section focuses on declaring methods. See <a href="adobjplsql.htm#BABECDGC">&#34;Calling Object Constructors and Methods&#34;</a> for further discussion of invoking methods in PL/SQL.</p>
<p>This section describes these methods:</p>
<ul>
<li>
<p><a href="#i477669">Member Methods</a></p>
</li>
<li>
<p><a href="#CHDFGJFB">Static Methods</a></p>
</li>
<li>
<p><a href="#i467634">Constructor Methods</a></p>
</li>
<li>
<p><a href="#i468620">External Implemented Methods</a></p>
</li>
</ul>
<a id="i477669"></a>
<div id="ADOBJ7084" class="sect2">
<h3 class="sect2">Member Methods<a id="sthref143"></a><a id="sthref144"></a><a id="sthref145"></a><a id="sthref146"></a><a id="sthref147"></a><a id="sthref148"></a></h3>
<p>Member methods provide an application with access to an object instance&#39;s data. You define a member method in the object type for each operation that you want an object of that type to be able to perform. Non-comparison member methods are declared as either <code>MEMBER</code> <code>FUNCTION</code> or <code>MEMBER</code> <code>PROCEDURE</code>. Comparison methods use <code>MAP</code> <code>MEMBER</code> <code>FUNCTION</code> or <code>ORDER</code> <code>MEMBER</code> <code>FUNCTION</code> as described in <a href="#i460525">&#34;Member Methods for Comparing Objects&#34;</a>.</p>
<p>As an example of a member method, you might declare a function <code>get_sum()</code> that sums the total cost of a purchase order&#39;s line items. The following line of code calls this function for purchase order <code>po</code> and returns the amount into <code>sum_line_items</code>.</p>
<p><code>sum_line_items:= po.get_sum();</code></p>
<p>Dot notation specifies the current object and the method it calls. Parentheses are required even if there are no parameters.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#CHDCFEEE">SELF Parameters in Member Methods</a></p>
</li>
<li>
<p><a href="#i460525">Member Methods for Comparing Objects</a></p>
</li>
</ul>
<a id="CHDCFEEE"></a>
<div id="ADOBJ7085" class="sect3">
<h4 class="sect3">SELF Parameters in Member Methods<a id="sthref149"></a><a id="sthref150"></a><a id="sthref151"></a><a id="sthref152"></a></h4>
<p>Member methods have a built-in parameter named <code>SELF</code> that denotes the object instance currently invoking the method.</p>
<p><code>SELF</code> can be explicitly declared, but that is not necessary. It is simpler to write member methods that reference the attributes and methods of <code>SELF</code> implicitly without the <code>SELF</code> qualifier. In <a href="#CIHDEDAE">Example 2-8</a>, the code and comments demonstrate method invocations that use an implicit <code>SELF</code> parameter rather than qualify the attributes <code>hgt</code>, <code>len</code>, and <code>wth</code>.</p>
<div id="ADOBJ7086" class="example">
<p class="titleinexample"><a id="CIHDEDAE"></a>Example 2-8 Creating a Member Method</p>
<pre>-- Ex. 2-8 Creating a Member Method
CREATE OR REPLACE TYPE solid_typ AS OBJECT (
  len    INTEGER,
  wth    INTEGER,
  hgt    INTEGER,
  MEMBER FUNCTION surface RETURN INTEGER,
  MEMBER FUNCTION volume RETURN INTEGER,
  MEMBER PROCEDURE display (SELF IN OUT NOCOPY solid_typ) );
/

CREATE OR REPLACE TYPE BODY solid_typ AS
  MEMBER FUNCTION volume RETURN INTEGER IS
  BEGIN
    <span class="bold">RETURN len * wth * hgt;</span>
 <span class="bold">-- RETURN SELF.len * SELF.wth * SELF.hgt; -- equivalent to previous line </span>
  END;
  MEMBER FUNCTION surface RETURN INTEGER IS
  BEGIN -- <span class="bold">not necessary to include SELF in following line</span>
    RETURN 2 * (<span class="bold">len * wth + len * hgt + wth * hgt</span>);
  END;
  MEMBER PROCEDURE display (SELF IN OUT NOCOPY solid_typ) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(&#39;Length: &#39; || len || &#39; - &#39;  || &#39;Width: &#39; || wth 
                          || &#39; - &#39;  || &#39;Height: &#39; || hgt);
    DBMS_OUTPUT.PUT_LINE(&#39;Volume: &#39; || volume || &#39; - &#39; || &#39;Surface area: &#39; 
                          || surface);
  END;
END;
/

CREATE TABLE solids of solid_typ;
INSERT INTO solids VALUES(10, 10, 10);
INSERT INTO solids VALUES(3, 4, 5);
SELECT * FROM solids;
SELECT s.volume(), s.surface() FROM solids s WHERE s.len = 10;
DECLARE
  solid solid_typ;
BEGIN -- PL/SQL block for selecting a solid and displaying details
  SELECT VALUE(s) INTO solid FROM solids s WHERE s.len = 10;
  solid.display();
END;
/
</pre></div>
<!-- class="example" -->
<p><code>SELF</code> is always the first parameter passed to the method.</p>
<ul>
<li>
<p>In member functions, if <code>SELF</code> is not declared, its parameter mode defaults to <code>IN</code>.</p>
</li>
<li>
<p>In member procedures, if <code>SELF</code> is not declared, its parameter mode defaults to <code>IN</code> <code>OUT</code>. The default behavior does not include the <code>NOCOPY</code> compiler hint.</p>
</li>
</ul>
<p>See also <a href="adobjdes.htm#i454922">&#34;Using SELF IN OUT NOCOPY with Member Procedures&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<a id="i460525"></a>
<div id="ADOBJ7087" class="sect3">
<h4 class="sect3">Member Methods for Comparing Objects<a id="sthref153"></a><a id="sthref154"></a><a id="sthref155"></a></h4>
<p>To compare and order variables of an object type, you must specify a basis for comparing them. The values of a scalar data type such as <code>CHAR</code> or <code>REAL</code> have a predefined order, which allows them to be compared. But an object type, such as a <code>person_typ</code>, which can have multiple attributes of various data types, has no predefined axis of comparison. You have the option to define an map method or an order method for comparing objects, but not both.</p>
<p>A map method maps object return values to scalar values and can order multiple values by their position on the scalar axis. An order method directly compares values for two particular objects.</p>
<div id="ADOBJ7088" class="sect4"><a id="sthref156"></a>
<h5 class="sect4">Map Methods<a id="sthref157"></a><a id="sthref158"></a><a id="sthref159"></a></h5>
<p>Map methods return values that can be used for comparing and sorting. Return values can be any Oracle built-in data types (except LOBs and <code>BFILE</code>s) and ANSI SQL types such as <code>CHARACTER</code> or <code>REAL</code>. See the specific sections in <a class="olink SQLRF0021" href="../SQLRF/sql_elements001.htm#SQLRF0021"><span class="italic">Oracle Database SQL Language Quick Reference</span></a>.</p>
<p>Generally, map methods perform calculations on the attributes of the object to produce the return value.</p>
<p>Map methods are called automatically to evaluate such comparisons as <code>obj_1</code> &gt; <code>obj_2</code> and comparisons implied by the <code>DISTINCT</code>, <code>GROUP</code> <code>BY</code>, <code>UNION</code>, and <code>ORDER</code> <code>BY</code> clauses which require sorting by rows.</p>
<p>Where <code>obj_1</code> and <code>obj_2</code> are two object variables that can be compared using a map method <code>map()</code>, the comparison:</p>
<p><code>obj_1 &gt; obj_2</code></p>
<p>is equivalent to:</p>
<p><code>obj_1.map() &gt; obj_2.map()</code></p>
<p>Comparisons are similar for other relational operators.</p>
<p>The following example defines a map method <code>area()</code> that provides a basis for comparing rectangle objects by their area:</p>
<div id="ADOBJ7089" class="example">
<p class="titleinexample"><a id="sthref160"></a>Example 2-9 Creating a Map Method</p>
<pre>CREATE OR REPLACE TYPE rectangle_typ AS OBJECT ( 
  len NUMBER,
  wid NUMBER,
  MAP MEMBER FUNCTION area RETURN NUMBER);
/

CREATE OR REPLACE TYPE BODY rectangle_typ AS 
  MAP MEMBER FUNCTION area RETURN NUMBER IS
  BEGIN
     RETURN len * wid;
  END area;
END;
/
</pre></div>
<!-- class="example" -->
<div id="ADOBJ7090" class="example">
<p class="titleinexample"><a id="CHDDICDH"></a>Example 2-10 Invoking a Map Method</p>
<pre>DECLARE
  po rectangle_typ;
 
BEGIN
  po :=<span class="bold">NEW</span> rectangle_typ(10,5);
 
DBMS_OUTPUT.PUT_LINE(&#39;AREA:&#39; || po.area()); -- prints AREA:50
  END;
/
</pre></div>
<!-- class="example" -->
<p>A subtype can declare a map method only if its root supertype declares one.</p>
<p>See <a href="adobjcol.htm#CHDCJEAJ">&#34;Equal and Not Equal Comparisons&#34;</a> for the use of map methods when comparing collections that contain object types.</p>
</div>
<!-- class="sect4" -->
<div id="ADOBJ7091" class="sect4"><a id="sthref161"></a>
<h5 class="sect4">Order Methods<a id="sthref162"></a><a id="sthref163"></a></h5>
<p>Order methods make direct one-to-one object comparisons. Unlike map methods, they cannot determine the order of a number of objects. They simply tell you that the current object is less than, equal to, or greater than the object that it is being compared to, based on the criterion used.</p>
<p>An order method is a function for an object (<code>SELF</code>), with one declared parameter that is an object of the same type. The method must return either a negative number, zero, or a positive number. This value signifies that the object (the implicit undeclared <code>SELF</code> parameter) is less than, equal to, or greater than the declared parameter object.</p>
<p>As with map methods, an order method, if one is defined, is called automatically whenever two objects of that type need to be compared.</p>
<p>Order methods are useful where comparison semantics may be too complex to use a map method.</p>
<p><a href="#CIHDECAA">Example 2-11</a> shows an order method that compares locations by building number:</p>
<div id="ADOBJ7092" class="example">
<p class="titleinexample"><a id="CIHDECAA"></a>Example 2-11 Creating and Invoking an Order Method</p>
<pre>DROP TYPE location_typ FORCE;
-- above necessary if you have previously created object
CREATE OR REPLACE TYPE location_typ AS OBJECT (
  building_no  NUMBER,
  city         VARCHAR2(40),
  ORDER MEMBER FUNCTION match (l location_typ) RETURN INTEGER );/
CREATE OR REPLACE TYPE BODY location_typ AS 
  ORDER MEMBER FUNCTION match (l location_typ) RETURN INTEGER IS 
  BEGIN 
    IF building_no &lt; l.building_no THEN
      RETURN -1;               -- any negative number will do
    ELSIF building_no &gt; l.building_no THEN 
      RETURN 1;                -- any positive number will do
    ELSE 
      RETURN 0;
    END IF;
  END;
END;/

-- invoking match method
DECLARE
loc location_typ;
secloc location_typ;
a number;
 
BEGIN
 loc :=NEW location_typ(300, &#39;San Francisco&#39;);
 secloc :=NEW location_typ(200, &#39;Redwood Shores&#39;);
 a := loc.match(secloc);
 
DBMS_OUTPUT.PUT_LINE(&#39;order (1 is greater, -1 is lesser):&#39; ||a); -- prints order:1 
 END;
/
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Only a type that is not derived from another type can declare an order method; a subtype cannot define one.</div>
</div>
<!-- class="sect4" -->
<div id="ADOBJ7093" class="sect4"><a id="sthref164"></a>
<h5 class="sect4">Guidelines for Comparison Methods<a id="sthref165"></a><a id="sthref166"></a></h5>
<p>You can declare a map method or an order method but not both. For either method type, you can compare objects using SQL statements and PL/SQL procedural statements. However, if you do not declare one of these methods, you can only compare objects in SQL statements, and only for equality or inequality. Two objects of the same type are considered equal only if the values of their corresponding attributes are equal.</p>
<p>When sorting or merging a large number of objects, use a map method, which maps all the objects into scalars, then sorts the scalars. An order method is less efficient because it must be called repeatedly (it can compare only two objects at a time). See <a href="adobjdes.htm#i454148">&#34;Performance of Object Comparisons&#34;</a>.</p>
</div>
<!-- class="sect4" -->
<div id="ADOBJ7094" class="sect4"><a id="sthref167"></a>
<h5 class="sect4">Comparison Methods in Type Hierarchies<a id="sthref168"></a><a id="sthref169"></a></h5>
<p>In a type hierarchy, if the root type (supertype) does not specify a map or an order method, neither can the subtypes.</p>
<ul>
<li>
<p>Map Method in a Type Hierarchy</p>
<p>If the root type specifies a map method, any of its subtypes can override it. If the root type does not specify a map method, no subtype can specify one either.</p>
</li>
<li>
<p>Order Method in a Type Hierarchy</p>
<p>Only the root type can define an order method. If the root type does not define one, its subtypes cannot add one.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDFGJFB"></a>
<div id="ADOBJ7095" class="sect2">
<h3 class="sect2">Static Methods<a id="sthref170"></a><a id="sthref171"></a></h3>
<p>Static methods are invoked on the object type, not its instances. You use a static method for operations that are global to the type and do not need to reference the data of a particular object instance. A static method has no <code>SELF</code> parameter.</p>
<p>Static methods are declared using <code>STATIC</code> <code>FUNCTION</code> or <code>STATIC</code> <code>PROCEDURE</code>.</p>
<p>You invoke a static method by using dot notation to qualify the method call with the name of the object type, for example:</p>
<p><code><span class="codeinlineitalic">type_name.method()</span></code></p>
<p>See <a href="adobjdes.htm#i449945">&#34;Static Methods&#34;</a> for information on design considerations.</p>
</div>
<!-- class="sect2" -->
<a id="i467634"></a>
<div id="ADOBJ7096" class="sect2">
<h3 class="sect2">Constructor Methods<a id="sthref172"></a><a id="sthref173"></a><a id="sthref174"></a><a id="sthref175"></a><a id="sthref176"></a><a id="sthref177"></a><a id="sthref178"></a><a id="sthref179"></a><a id="sthref180"></a><a id="sthref181"></a></h3>
<p>A constructor method is a function that returns a new instance of the user-defined type and sets up the values of its attributes. Constructor methods are either system-defined or user-defined.</p>
<p>To invoke a constructor, the keyword <code>NEW</code> can be used, but is not required.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
See <a href="#CHDDICDH">Example 2-10</a> and <a href="adobjplsql.htm#BABECDGC">&#34;Calling Object Constructors and Methods&#34;</a></div>
<div id="ADOBJ7097" class="sect3"><a id="sthref182"></a>
<h4 class="sect3">System-Defined Constructors</h4>
<p>By default, the system implicitly defines a constructor function for all object types that have attributes. This constructor is sometimes known as the attribute value constructor.</p>
<p>For the <code>person_typ</code> object type defined in <a href="#CIHGJFGD">Example 2-1</a> the name of the constructor method is the name of the object type, as shown in the following invocation:</p>
<p><code>person_typ (1, &#39;John Smith&#39;, &#39;1-650-555-0135&#39;),</code></p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7098" class="sect3"><a id="sthref183"></a>
<h4 class="sect3">User-Defined Constructors</h4>
<p>You can also define constructor functions of your own to create and initialize user-defined types. The default system-defined constructors (or attribute value constructors) are convenient to use because they already exist, but user-defined constructors have some important advantages with respect to type evolution. See <a href="adobjadv.htm#CHDJCFAG">&#34;Advantages of User-Defined Constructors&#34;</a>. See <a href="adobjcol.htm#CHDHBADC">&#34;Constructor Methods for Collections&#34;</a> for information on user-defined constructors for collections.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7099" class="sect3"><a id="sthref184"></a>
<h4 class="sect3">Literal Invocation of a Constructor Method<a id="sthref185"></a></h4>
<p>A <a href="glossary.htm#CHDICHDB"><span class="xrefglossterm">literal invocation</span></a> of a constructor method is a call to the constructor method in which arguments are either literals (as opposed to bind variables), or further literal invocations of constructor methods. For example:</p>
<pre>CREATE TABLE people_tab OF person_typ;

INSERT INTO people_tab VALUES (
       <span class="bold">person_typ</span>(101, &#39;John Smith&#39;, &#39;1-650-555-0135&#39;) );
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i468620"></a>
<div id="ADOBJ7100" class="sect2">
<h3 class="sect2">External Implemented Methods</h3>
<p>You can use PL/SQL to invoke external subprograms that have been written in other languages. This provides access to the strengths and capabilities of those languages.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adobjenv.htm#i441290">Chapter 4, &#34;Object Support in Oracle Programming Environments&#34;</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i456228"></a>
<div id="ADOBJ00205" class="sect1">
<h2 class="sect1">Inheritance in SQL Object Types<a id="sthref186"></a></h2>
<p>SQL object inheritance is based on a family tree of object types that forms a type hierarchy. The type hierarchy consists of a parent object type, called a supertype, and one or more levels of child object types, called subtypes, which are derived from the parent.</p>
<p>Inheritance is the mechanism that connects subtypes in a hierarchy to their supertypes. Subtypes automatically inherit the attributes and methods of their parent type. Also, the inheritance link remains alive. Subtypes automatically acquire any changes made to these attributes or methods in the parent: any attributes or methods updated in a supertype are updated in subtypes as well.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle only supports single inheritance. Therefore, a subtype can derive directly from only one supertype, not more than one.</div>
<p>With object types in a type hierarchy, you can model an entity such as a customer, and also define different <a href="glossary.htm#CHDHJAIB"><span class="xrefglossterm">specializing</span></a>d subtypes of customers under the original type. You can then perform operations on a hierarchy and have each type implement and execute the operation in a special way.</p>
<p>The topics described in this section are:</p>
<ul>
<li>
<p><a href="#BCFJJADG">Supertypes and Subtypes</a></p>
</li>
<li>
<p><a href="#CIHFBHFC">Defining FINAL and NOT FINAL Types and Methods</a></p>
</li>
<li>
<p><a href="#CHDEFAGF">Creating Subtypes</a></p>
</li>
<li>
<p><a href="#i456586">Declaring Types and Methods NOT INSTANTIABLE</a></p>
</li>
<li>
<p><a href="#i471260">Overloading and Overriding Methods</a></p>
</li>
<li>
<p><a href="#i468270">Dynamic Method Dispatch</a></p>
</li>
<li>
<p><a href="#CIHEJHJJ">Substituting Types in a Type Hierarchy</a></p>
</li>
<li>
<p><a href="#i473078">Column and Row Substitutability</a></p>
</li>
<li>
<p><a href="#CIHHIJEI">Storing Newly Created Subtypes in Substitutable Columns</a></p>
</li>
<li>
<p><a href="#CIHHJIED">Dropping Subtypes After Creating Substitutable Columns</a></p>
</li>
<li>
<p><a href="#i461515">Turning Off Substitutability in a New Table</a></p>
</li>
<li>
<p><a href="#i463421">Constraining Substitutability</a></p>
</li>
<li>
<p><a href="#i468659">Modifying Substitutability</a></p>
</li>
<li>
<p><a href="#CIHGHCCG">Restrictions on Modifying Substitutability</a></p>
</li>
<li>
<p><a href="#i466278">Assignments Across Types</a></p>
</li>
</ul>
<a id="BCFJJADG"></a>
<div id="ADOBJ7101" class="sect2">
<h3 class="sect2">Supertypes and Subtypes<a id="sthref187"></a><a id="sthref188"></a><a id="sthref189"></a></h3>
<p>A subtype can be derived from a supertype either directly or indirectly through intervening levels of other subtypes. A supertype can have multiple sibling subtypes, but a subtype can have at most one direct parent supertype (single inheritance).</p>
<div id="ADOBJ7102" class="figure">
<p class="titleinfigure"><a id="sthref190"></a>Figure 2-1 Supertypes and Subtypes in Type Hierarchy</p>
<img width="315" height="187" src="img/adobj027.gif" alt="Description of Figure 2-1 follows"/><br/>
<a id="sthref191" href="img_text/adobj027.htm">Description of &#34;Figure 2-1 Supertypes and Subtypes in Type Hierarchy&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>To derive a subtype from a supertype, define a specialized variant of the supertype that adds new attributes and methods to the set inherited from the parent or redefine (override) the inherited methods. For example, from a <code>person_typ</code> object type you might derive the specialized types <code>student_typ</code> and <code>employee_typ</code>. Each of these subtypes is still a <code>person_typ</code>, but a special kind of person. What distinguishes a subtype from its parent supertype is some change made to the attributes or methods that the subtype received from its parent.</p>
<p>Unless a subtype redefines an inherited method, it always contains the same core set of attributes and methods that are in the parent type, plus any attributes and methods that it adds. If a <code>person_typ</code> object type has the three attributes <code>idno</code>, <code>name</code>, and <code>phone</code> and the method <code>get_idno()</code>, then any object type that is derived from <code>person_typ</code> will have these same three attributes and a method <code>get_idno()</code>. If the definition of <code>person_typ</code> changes, so do the definitions of any subtypes.</p>
<p>Subtypes are created using the keyword <code>UNDER</code> as follows:</p>
<p><code>CREATE</code> <code>TYPE</code> <code>student_typ</code> <code>UNDER</code> <code>person_typ</code></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCFIEIFE">Example 2-15</a> for a complete example</div>
<p>You can specialize the attributes or methods of a subtype in these ways:</p>
<ul>
<li>
<p>Add new attributes that its parent supertype does not have.</p>
<p>For example, you might specialize <code>student_typ</code> as a special kind of <code>person_typ</code> by adding an attribute for <code>major</code>. A subtype cannot drop or change the type of an attribute it inherited from its parent; it can only add new attributes.</p>
</li>
<li>
<p>Add entirely new methods that the parent does not have.</p>
</li>
<li>
<p>Change the implementation of some of the methods that a subtype inherits so that the subtype&#39;s version executes different code from the parent&#39;s.</p>
<p>For example, a ellipse object might define a method <code>calculate()</code>. Two subtypes of <code>ellipse_typ</code>, <code>circle_typ</code> and <code>sphere_typ</code>, might each implement this method in a different way.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i471260">&#34;Overloading and Overriding Methods&#34;</a></div>
</li>
</ul>
<p>The inheritance relationship between a supertype and its subtypes is the source of much of the power of objects and much of their complexity. Being able to change a method in a supertype and have the change take effect in all the subtypes downstream just by recompiling is very powerful. But this same capability means that you have to consider whether or not you want to allow a type to be specialized or a method to be redefined. Similarly, for a table or column to be able to contain any type in a hierarchy is also powerful, but you must decide whether or not to allow this in a particular case. Also, you may need to constrain DML statements and queries so that they pick out just the range of types that you want from the type hierarchy.</p>
</div>
<!-- class="sect2" -->
<a id="CIHFBHFC"></a>
<div id="ADOBJ7103" class="sect2">
<h3 class="sect2">Defining FINAL and NOT FINAL Types and Methods<a id="sthref192"></a><a id="sthref193"></a><a id="sthref194"></a><a id="sthref195"></a><a id="sthref196"></a><a id="sthref197"></a></h3>
<p>For an object type to be inheritable, the object type definition must specify that it is inheritable. Then subtypes can be derived from it. For a method, the definition must indicate whether or not it can be overridden The keywords <code>FINAL</code> or <code>NOT</code> <code>FINAL</code> are used for both types and methods.</p>
<p>In order for an object type to be inheritable, thus allowing subtypes to be derived from it, the object definition must specify this. For a method, the definition must indicate whether or not it can be overridden The keywords <code>FINAL</code> or <code>NOT</code> <code>FINAL</code> are used for both types and methods.</p>
<ul>
<li>
<p>For a type <code>FINAL</code>, (default) means that no subtypes can be derived from it. <code>NOT</code> <code>FINAL</code> means subtypes can be derived.</p>
</li>
<li>
<p>For a method, <code>FINAL</code> means that subtypes cannot override it by providing their own implementation. <code>NOT</code> <code>FINAL</code> (default) means that you can override the method of the supertype.</p>
</li>
</ul>
<p>Definitions of object types and method includes the <code>NOT</code> <code>FINAL</code> or <code>FINAL</code> keywords in the type and method declarations, as shown in <a href="#CIHHECAA">Example 2-12</a> and <a href="#CIHIHCHI">Example 2-13</a>.</p>
<div id="ADOBJ7104" class="example">
<p class="titleinexample"><a id="CIHHECAA"></a>Example 2-12 Creating the person_typ Object Type as NOT FINAL</p>
<pre>DROP TYPE person_typ FORCE;
-- above necessary if you have previously created object

CREATE OR REPLACE TYPE person_typ AS OBJECT (
   idno           NUMBER,
   name           VARCHAR2(30),
   phone          VARCHAR2(20)) 
NOT FINAL;
/
</pre></div>
<!-- class="example" -->
<p><a href="#CIHHECAA">Example 2-12</a> declares <code>person_typ</code> to be a not final type and therefore subtypes of <code>person_typ</code> can be defined.</p>
<p><a href="#CIHIHCHI">Example 2-13</a> creates a not final object type that contains a final member function.</p>
<div id="ADOBJ7105" class="example">
<p class="titleinexample"><a id="CIHIHCHI"></a>Example 2-13 Creating an Object Type as NOT FINAL with a FINAL Member Function</p>
<pre>DROP TYPE person_typ FORCE;
-- above necessary if you have previously created object

CREATE OR REPLACE TYPE person_typ AS OBJECT (
   idno           NUMBER,
   name           VARCHAR2(30),
   phone          VARCHAR2(20),
   <span class="bold">FINAL</span> MAP MEMBER FUNCTION get_idno RETURN NUMBER)
<span class="bold">NOT FINAL;</span>
/
</pre></div>
<!-- class="example" -->
<p>You can change a final type to a not final type and vice versa with an <code>ALTER</code> <code>TYPE</code> statement. For example, the following statement changes <code>person_typ</code> to a final type:</p>
<pre>ALTER TYPE person_typ <span class="bold">FINAL</span>;
</pre>
<p>You can only alter a type from <code>NOT</code> <code>FINAL</code> to <code>FINAL</code> if the target type has no subtypes.</p>
</div>
<!-- class="sect2" -->
<a id="CHDEFAGF"></a>
<div id="ADOBJ00214" class="sect2">
<h3 class="sect2">Creating Subtypes<a id="sthref198"></a><a id="sthref199"></a><a id="sthref200"></a><a id="sthref201"></a><a id="sthref202"></a><a id="sthref203"></a></h3>
<p>You create a subtype using a <code>CREATE</code> <code>TYPE</code> statement that specifies the immediate parent of the subtype with the <code>UNDER</code> keyword.</p>
<div id="ADOBJ7106" class="sect3"><a id="sthref204"></a>
<h4 class="sect3">Creating a Parent or Supertype Object</h4>
<p><a href="#BCFCAAFG">Example 2-14</a> provides a parent or supertype <code>person_typ</code> object to demonstrate subtype definitions in <a href="#BCFIEIFE">Example 2-15</a>, <a href="#BCFIJGCF">Example 2-18</a>, and <a href="#BCFDIDIE">Example 2-19</a>.</p>
<p>Note the <code>show()</code> in <a href="#BCFCAAFG">Example 2-14</a>. In the subtype examples that follow, the <code>show()</code> function of the parent type is overridden to specifications for each subtype using the <code>OVERRIDING</code> keyword.</p>
<div id="ADOBJ7107" class="example">
<p class="titleinexample"><a id="BCFCAAFG"></a>Example 2-14 Creating the Parent or Supertype person_typ Object</p>
<pre>DROP TYPE person_typ FORCE;
-- if created
CREATE OR REPLACE TYPE person_typ AS OBJECT (
 idno           NUMBER,
 name           VARCHAR2(30),
 phone          VARCHAR2(20),
 MAP MEMBER FUNCTION get_idno RETURN NUMBER,
 MEMBER FUNCTION <span class="bold">show</span> RETURN VARCHAR2)
 NOT FINAL;
/
 
CREATE OR REPLACE TYPE BODY person_typ AS
 MAP MEMBER FUNCTION get_idno RETURN NUMBER IS
 BEGIN
   RETURN idno;
 END;
-- function that can be overriden by subtypes
 MEMBER FUNCTION <span class="bold">show</span> RETURN VARCHAR2 IS
 BEGIN
   RETURN &#39;Id: &#39; || TO_CHAR(idno) || &#39;, Name: &#39; || name;
 END;
 
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDEIIAB"></a>
<div id="ADOBJ7108" class="sect3">
<h4 class="sect3">Creating a Subtype Object<a id="sthref205"></a></h4>
<p>A subtype inherits the following:</p>
<ul>
<li>
<p>All the attributes declared in or inherited by the supertype.</p>
</li>
<li>
<p>Any methods declared in or inherited by supertype.</p>
</li>
</ul>
<p><a href="#BCFIEIFE">Example 2-15</a> defines the <code>student_typ</code> object as a subtype of <code>person_typ</code>, which inherits all the attributes declared in or inherited by <code>person_typ</code> and any methods inherited by or declared in <code>person_typ</code>.</p>
<div id="ADOBJ7109" class="example">
<p class="titleinexample"><a id="BCFIEIFE"></a>Example 2-15 Creating a student_typ Subtype Using the UNDER Clause</p>
<pre>-- requires Ex. 2-14
CREATE TYPE student_typ <span class="bold">UNDER</span> person_typ (
   dept_id NUMBER,
   major VARCHAR2(30),
   <span class="bold">OVERRIDING MEMBER FUNCTION show</span> RETURN VARCHAR2)
   NOT FINAL;
/
 
CREATE TYPE BODY student_typ AS
 OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2 IS
 BEGIN
    <span class="bold">RETURN (self AS person_typ).show</span> || &#39; -- Major: &#39; || major ;
 END;
 
END;
/
</pre></div>
<!-- class="example" -->
<p>The statement that defines <code>student_typ</code> specializes <code>person_typ</code> by adding two new attributes, <code>dept_id</code> and <code>major</code> and overrides the <code>show</code> method. New attributes declared in a subtype must have names that are different from the names of any attributes or methods declared in any of its supertypes, higher up in its type hierarchy.</p>
</div>
<!-- class="sect3" -->
<a id="CHDFBDBI"></a>
<div id="ADOBJ00215" class="sect3">
<h4 class="sect3">Generalized Invocation<a id="sthref206"></a><a id="sthref207"></a><a id="sthref208"></a></h4>
<p>Generalized invocation provides a mechanism to invoke a method of a supertype or a parent type, rather than the specific subtype member method. <a href="#BCFIEIFE">Example 2-15</a> demonstrates this using the following syntax:</p>
<pre>     (SELF AS person_typ).show
</pre>
<p>The <code>student_typ</code> <code>show</code> method first calls the <code>person_typ</code> <code>show</code> method to do the common actions and then does its own specific action, which is to append <code>&#39;--Major:&#39;</code> to the value returned by the <code>person_typ</code> <code>show</code> method. This way, overriding subtype methods can call corresponding overriding parent type methods to do the common actions before doing their own specific actions.</p>
<p>Methods are invoked just like normal member methods, except that the type name after <code>AS</code> should be the type name of the parent type of the type that the expression evaluates to.</p>
<p>In <a href="#CHDFIHIC">Example 2-16</a>, there is an implicit <code>SELF</code> argument just like the implicit self argument of a normal member method invocation. In this case, it invokes the <code>person_typ</code> <code>show</code> method rather than the specific <code>student_typ</code> <code>show</code> method.</p>
<div id="ADOBJ7110" class="example">
<p class="titleinexample"><a id="CHDFIHIC"></a>Example 2-16 Using Generalized Invocation</p>
<pre>-- Requires Ex. 2-14 and 2-15
DECLARE
 myvar student_typ := student_typ(100, &#39;Sam&#39;, &#39;6505556666&#39;, 100, &#39;Math&#39;);
 name VARCHAR2(100);
BEGIN
 name := <span class="bold">(myvar AS person_typ).show</span>; --Generalized invocation
END;
/ 
</pre></div>
<!-- class="example" -->
<p>Generalized expression, like member method invocation, is also supported when a method is invoked with an explicit self argument.</p>
<div id="ADOBJ7111" class="example">
<p class="titleinexample"><a id="CHDIGCHE"></a>Example 2-17 Using Generalized Expression</p>
<pre>-- Requires Ex. 2-14 and 2-15
DECLARE
 myvar2 student_typ := student_typ(101, &#39;Sam&#39;, &#39;6505556666&#39;, 100, &#39;Math&#39;);
 name2 VARCHAR2(100);
BEGIN
 name2 := <span class="bold">person_typ.show((myvar2 AS person_typ))</span>; -- Generalized expression
END;
/ 
</pre></div>
<!-- class="example" -->
<p>Double parentheses are used in this example because <code>((myvar2</code> <code>AS</code> <code>person_typ))</code> is both an expression that must be resolved and the parameter of the <code>show</code> function.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Constructor methods cannot be invoked using this syntax. Also, the type name that appears after <code>AS</code> in this syntax should be one of the parent types of the type of the expression for which method is being invoked.
<p>This syntax can only be used to invoke corresponding overriding member methods of the parent types.</p>
</div>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7112" class="sect3"><a id="sthref209"></a>
<h4 class="sect3">Multiple Subtypes<a id="sthref210"></a><a id="sthref211"></a></h4>
<p>A type can have multiple child subtypes, and these subtypes can also have subtypes. <a href="#BCFIJGCF">Example 2-18</a> creates another subtype <code>employee_typ</code> under <code>person_typ</code> in addition to the already existing subtype, <code>student_typ</code>, created in <a href="#BCFIEIFE">Example 2-15</a>.</p>
<div id="ADOBJ7113" class="example">
<p class="titleinexample"><a id="BCFIJGCF"></a>Example 2-18 Creating an employee_typ Subtype Using the UNDER Clause</p>
<pre>-- requires Ex. 2-14

DROP TYPE employee_typ FORCE;
-- if previously created
CREATE OR REPLACE TYPE employee_typ UNDER person_typ (
    emp_id NUMBER, 
    mgr VARCHAR2(30),
    OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2);
/

CREATE OR REPLACE TYPE BODY employee_typ AS
  OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2 IS
  BEGIN
    RETURN (SELF AS person_typ).show|| &#39; -- Employee Id: &#39; 
           || TO_CHAR(emp_id) || &#39;, Manager: &#39; || mgr ;
  END;
  
END;
/
</pre></div>
<!-- class="example" -->
<p>A subtype can be defined under another subtype. Again, the new subtype inherits all the attributes and methods that its parent type has, both declared and inherited. <a href="#BCFDIDIE">Example 2-19</a> defines a new subtype <code>part_time_student_typ</code> under <code>student_typ</code> created in <a href="#BCFIEIFE">Example 2-15</a>. The new subtype inherits all the attributes and methods of <code>student_typ</code> and adds another attribute, <code>number_hours</code>.</p>
<div id="ADOBJ7114" class="example">
<p class="titleinexample"><a id="BCFDIDIE"></a>Example 2-19 Creating a part_time_student_typ Subtype Using the UNDER Clause</p>
<pre>CREATE TYPE part_time_student_typ UNDER student_typ (
  <span class="bold">number_hours NUMBER</span>,
  OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2);
/

CREATE TYPE BODY part_time_student_typ AS
  OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2 IS
  BEGIN
    RETURN (SELF AS person_typ).show|| &#39; -- Major: &#39; || major ||
           &#39;, Hours: &#39; || TO_CHAR(number_hours);
  END;
  
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADOBJ7115" class="sect3"><a id="sthref212"></a>
<h4 class="sect3">Creating a Table that Contains Supertype and Subtype Objects</h4>
<p>You can create a table that contains supertype and subtype instances and populate the table as shown with the <code>person_obj_table</code> in <a href="#CHDJGIAG">Example 2-20</a>.</p>
<div id="ADOBJ7116" class="example">
<p class="titleinexample"><a id="CHDJGIAG"></a>Example 2-20 Inserting Values into Substitutable Rows of an Object Table</p>
<pre>CREATE TABLE person_obj_table OF person_typ;

INSERT INTO person_obj_table 
  VALUES (person_typ(12, &#39;Bob Jones&#39;, &#39;650-555-0130&#39;));

INSERT INTO person_obj_table 
  VALUES (student_typ(51, &#39;Joe Lane&#39;, &#39;1-650-555-0140&#39;, 12, &#39;HISTORY&#39;));

INSERT INTO person_obj_table 
  VALUES (employee_typ(55, &#39;Jane Smith&#39;, &#39;1-650-555-0144&#39;, 
                       100, &#39;Jennifer Nelson&#39;));

INSERT INTO person_obj_table  
  VALUES (part_time_student_typ(52, &#39;Kim Patel&#39;, &#39;1-650-555-0135&#39;, 14,
         &#39;PHYSICS&#39;, 20));
</pre></div>
<!-- class="example" -->
<p>You can call the <code>show()</code> function for the supertype and subtypes in the table with the following:</p>
<pre>SELECT p.show() FROM person_obj_table p;
</pre>
<p>The output is similar to:</p>
<br/>
Id: 12, Name: Bob Jones<br/>
Id: 51, Name: Joe Lane -- Major: HISTORY<br/>
Id: 55, Name: Jane Smith -- Employee Id: 100, Manager: Jennifer Nelson<br/>
Id: 52, Name: Kim Patel -- Major: PHYSICS, Hours: 20<br/>
<p>Note that data that the <code>show()</code> method displays depends on whether the object is a supertype or subtype, and if the <code>show()</code> method of the subtype is overridden. For example, Bob Jones is a <code>person_typ</code>, that is, an supertype. Only his <code>name</code> and <code>Id</code> are displayed. For Joe Lane, a <code>student_typ</code>, his <code>name</code> and <code>Id</code> are provided by the <code>show()</code> function of the supertype, and his <code>major</code> is provided by the overridden <code>show()</code> function of the subtype.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i456586"></a>
<div id="ADOBJ7117" class="sect2">
<h3 class="sect2">Declaring Types and Methods NOT INSTANTIABLE<a id="sthref213"></a><a id="sthref214"></a><a id="sthref215"></a><a id="sthref216"></a><a id="sthref217"></a></h3>
<p>Types and methods can be declared <code>NOT</code> <code>INSTANTIABLE</code> when they are created.</p>
<ul>
<li>
<p><code>NOT</code> <code>INSTANTIABLE</code> Types</p>
<p>If a type is not instantiable, you cannot instantiate instances of that type. There are no constructors (default or user-defined) for it. You might use this with types intended to serve solely as supertypes from which specialized subtypes are instantiated.</p>
</li>
<li>
<p><code>NOT</code> <code>INSTANTIABLE</code> Methods</p>
<p>A non-instantiable method serves as a placeholder. It is declared but not implemented in the type. You might define a non-instantiable method when you expect every subtype to override the method in a different way. In this case, there is no point in defining the method in the supertype.</p>
</li>
</ul>
<p>A type that contains a non-instantiable method must itself be declared not instantiable, as shown in <a href="#CIHJHCJD">Example 2-21</a>.</p>
<div id="ADOBJ7118" class="example">
<p class="titleinexample"><a id="CIHJHCJD"></a>Example 2-21 Creating an Object Type that is NOT INSTANTIABLE</p>
<pre>DROP TYPE person_typ FORCE;
-- if previously created
CREATE OR REPLACE TYPE person_typ AS OBJECT (
  idno           NUMBER,
  name           VARCHAR2(30),
  phone          VARCHAR2(20),
  NOT INSTANTIABLE MEMBER FUNCTION get_idno RETURN NUMBER)
  NOT INSTANTIABLE NOT FINAL;/
</pre></div>
<!-- class="example" -->
<p>If a subtype does not provide an implementation for every inherited non-instantiable method, the subtype itself, like the supertype, must be declared not instantiable. A non-instantiable subtype can be defined under an instantiable supertype.</p>
<p>You can alter an instantiable type to a non-instantiable type and vice versa with an <code>ALTER</code> <code>TYPE</code> statement. In the following example, the <code>ALTER</code> <code>TYPE</code> statement makes <code>person_typ</code> instantiable:</p>
<div id="ADOBJ7119" class="example">
<p class="titleinexample"><a id="sthref218"></a>Example 2-22 Altering an Object Type to INSTANTIABLE</p>
<pre>CREATE OR REPLACE TYPE person_typ AS OBJECT (
  idno           NUMBER,
  name           VARCHAR2(30),
  phone          VARCHAR2(20))
  NOT INSTANTIABLE NOT FINAL;/
ALTER TYPE person_typ INSTANTIABLE;
</pre></div>
<!-- class="example" -->
<p>You can alter an instantiable type to a non-instantiable type only if the type has no columns, views, tables, or instances that reference that type, either directly, or indirectly through another type or subtype.</p>
<p>You cannot declare a non-instantiable type to be <code>FINAL</code>, which would be pointless anyway.</p>
</div>
<!-- class="sect2" -->
<a id="i471260"></a>
<div id="ADOBJ7120" class="sect2">
<h3 class="sect2">Overloading and Overriding Methods<a id="sthref219"></a><a id="sthref220"></a><a id="sthref221"></a><a id="sthref222"></a><a id="sthref223"></a><a id="sthref224"></a><a id="sthref225"></a></h3>
<p>A subtype can redefine methods it inherits, and it can also add new methods, including methods with the same name.</p>
<p>See the examples in <a href="#CHDEFAGF">&#34;Creating Subtypes&#34;</a> and <a href="adobjadv.htm#i1011567">Example 8-10</a>.</p>
<div id="ADOBJ7121" class="sect3"><a id="sthref226"></a>
<h4 class="sect3">Overloading Methods<a id="sthref227"></a><a id="sthref228"></a></h4>
<p>Adding new methods that have the same names as inherited methods to the subtype is called overloading. When they exist in the same user-defined type, methods that have the same name, but different signatures are called overloads. A method signature consists of the method&#39;s name and the number, types, and the order of the method&#39;s formal parameters, including the implicit <code>self</code> parameter.</p>
<p>Overloading is useful when you want to provide a variety of ways of doing something. For example, an ellipse object might overload a <code>calculate()</code> method with another <code>calculate()</code> method to enable calculation of a different shape.</p>
<p>The compiler uses the method signatures to determine which method to call when a type has several overloaded methods.</p>
<p>In the following pseudocode, subtype <code>circle_typ</code> creates an overload of <code>calculate()</code>:</p>
<br/>
<br/>
<code>CREATE TYPE ellipse_typ AS OBJECT (...,</code><br/>
<code>&nbsp;&nbsp;MEMBER PROCEDURE calculate(x NUMBER, x NUMBER),</code><br/>
<code>) NOT FINAL;</code><br/>
<br/>
<code>CREATE TYPE circle_typ UNDER ellipse_typ (...,</code><br/>
<code>&nbsp;&nbsp;MEMBER PROCEDURE calculate(x NUMBER),</code><br/>
<code>...);</code>
<p>The <code>circle_typ</code> contains two versions of <code>calculate()</code>. One is the inherited version with two <code>NUMBER</code> parameters and the other is the newly created method with one <code>NUMBER</code> parameter.</p>
</div>
<!-- class="sect3" -->
<a id="i463190"></a>
<div id="ADOBJ7122" class="sect3">
<h4 class="sect3">Overriding and Hiding Methods<a id="sthref229"></a><a id="sthref230"></a><a id="sthref231"></a></h4>
<p>Redefining an inherited method to customize its behavior in a subtype is called overriding, in the case of member methods, or hiding, in the case of static methods.</p>
<p>Unlike overloading, you do not create a new method, just redefine an existing one, using the keyword <code>OVERRIDING</code>.</p>
<p>Overriding and hiding redefine an inherited method to make it do something different in the subtype. For example, a subtype <code>circle_typ</code> derived from a <code>ellipse_typ</code> supertype might override a member method <code>calculate()</code> to customize it specifically for calculating the area of a circle. For examples of overriding methods, see <a href="#CHDEFAGF">&#34;Creating Subtypes&#34;</a>.</p>
<p>Overriding and hiding are similar in that, in either case, the version of the method redefined in the subtype eclipses the original version of the same name and signature so that the new version is executed rather than the original one whenever a subtype instance invokes the method. If the subtype itself has subtypes, these inherit the redefined method instead of the original version.</p>
<p>With overriding, the system relies on type information contained in the member method&#39;s implicit self argument to dynamically choose the correct version of the method to execute. With hiding, the correct version is identified at compile time, and dynamic dispatch is not necessary. See <a href="#i468270">&#34;Dynamic Method Dispatch&#34;</a>.</p>
<p>To override or hide a method, you must preserve its signature. Overloads of a method all have the same name, so the compiler uses the signature of the subtype&#39;s method to identify the particular version in the supertype that is superseded.</p>
<p>You signal the override with the <code>OVERRIDING</code> keyword in the <code>CREATE</code> <code>TYPE</code> <code>BODY</code> statement. This is not required when a subtype hides a static method.</p>
<p>In the following pseudocode, the subtype signals that it is overriding method <code>calculate()</code>:</p>
<br/>
<code>CREATE TYPE ellipse_typ AS OBJECT (...,</code><br/>
<code>&nbsp;&nbsp;MEMBER PROCEDURE calculate(),</code><br/>
<code>&nbsp;&nbsp;FINAL MEMBER FUNCTION function_mytype(x NUMBER)...</code><br/>
<code>) NOT FINAL;</code><br/>
<br/>
<code>CREATE TYPE circle_typ UNDER ellipse_typ (...,</code><br/>
<code>&nbsp;&nbsp;OVERRIDING MEMBER PROCEDURE calculate(),</code><br/>
<code>...);</code><br/>
<br/>
For a diagram of this hierarchy, see <a href="#CHDEHFJG">Figure 2-2</a>.</div>
<!-- class="sect3" -->
<div id="ADOBJ7123" class="sect3"><a id="sthref232"></a>
<h4 class="sect3">Restrictions on Overriding Methods<a id="sthref233"></a></h4>
<p>The following are restrictions on overriding methods:</p>
<ul>
<li>
<p>Only methods that are not declared to be final in the supertype can be overridden.</p>
</li>
<li>
<p>Order methods may appear only in the root type of a type hierarchy: they may not be redefined (overridden) in subtypes.</p>
</li>
<li>
<p>A static method in a subtype may not redefine a member method in the supertype.</p>
</li>
<li>
<p>A member method in a subtype may not redefine a static method in the supertype.</p>
</li>
<li>
<p>If a method being overridden provides default values for any parameters, then the overriding method must provide the same default values for the same parameters.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i468270"></a>
<div id="ADOBJ7124" class="sect2">
<h3 class="sect2">Dynamic Method Dispatch<a id="sthref234"></a><a id="sthref235"></a></h3>
<p>Dynamic method dispatch refers to the way that method calls are dispatched to the nearest implementation at run time, working up the type hierarchy from the current or specified type. This feature is only available when overriding member methods and does not apply to static methods.</p>
<p>With method overriding, a type hierarchy can define multiple implementations of the same method. In the following hierarchy of types <code>ellipse_typ</code>, <code>circle_typ</code>, and <code>sphere_typ</code>, each type might define a <code>calculate()</code> method differently.</p>
<div id="ADOBJ7125" class="figure">
<p class="titleinfigure"><a id="CHDEHFJG"></a>Figure 2-2 Hierarchy of Types</p>
<img width="153" height="141" src="img/adobj025.gif" alt="Description of Figure 2-2 follows"/><br/>
<a id="sthref236" href="img_text/adobj025.htm">Description of &#34;Figure 2-2 Hierarchy of Types&#34;</a><br/>
<br/></div>
<!-- class="figure" -->
<p>When one of these methods is invoked, the type of the object instance that invokes it determines which implementation of the method to use. The call is then dispatched to that implementation for execution. This process of selecting a method implementation is called virtual or dynamic method dispatch because it is done at run time, not at compile time.</p>
<p>The method call works up the type hierarchy: never down. If the call invokes a member method of an object instance, the type of that instance is the current type, and the implementation defined or inherited by that type is used. If the call invokes a static method of a type, the implementation defined or inherited by that specified type is used.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS00808" href="../LNPLS/subprograms.htm#LNPLS00808"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information on how subprograms calls are resolved</div>
</div>
<!-- class="sect2" -->
<a id="CIHEJHJJ"></a>
<div id="ADOBJ7126" class="sect2">
<h3 class="sect2">Substituting Types in a Type Hierarchy<a id="sthref237"></a><a id="sthref238"></a></h3>
<p>When you work with types in a type hierarchy, sometimes you need to work at the most general level, for example, to select or update all persons. But at other times, you need to select or update only a specific subtype such as a student, or only persons who are not students.</p>
<p>The (polymorphic) ability to select all persons and get back not only objects whose declared type is <code>person_typ</code> but also objects whose declared subtype is <code>student_typ</code> or <code>employee_typ</code> is called substitutability. A supertype is substitutable if one of its subtypes can substitute or stand in for it in a variable or column whose declared type is the supertype.</p>
<p>In general, types are substitutable. Object attributes, collection elements and <code>REF</code>s are substitutable. An attribute defined as a <code>REF</code>, type, or collection of type <code>person_typ</code> can hold a <code>REF</code> to an instance of, or instances of an instance of <code>person_typ</code>, or an instance of any subtype of <code>person_typ</code>.</p>
<p>This seems expected, given that a subtype is, after all, just a specialized kind of one of its supertypes. Formally, though, a subtype is a type in its own right: it is not the same type as its supertype. A column that holds all persons, including all persons who are students and all persons who are employees, actually holds data of multiple types.</p>
<p>In principle, object attributes, collection elements and <code>REF</code>s are always substitutable: there is no syntax at the level of the type definition to constrain their substitutability to some subtype. You can, however, turn off or constrain substitutability at the storage level, for specific tables and columns. See <a href="#i461515">&#34;Turning Off Substitutability in a New Table&#34;</a> and <a href="#i463421">&#34;Constraining Substitutability&#34;</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i473078"></a>
<div id="ADOBJ7127" class="sect2">
<h3 class="sect2">Column and Row Substitutability<a id="sthref239"></a><a id="sthref240"></a><a id="sthref241"></a><a id="sthref242"></a></h3>
<p>Object type columns and object-type rows in object tables are substitutable, and so are views: a column or row of a specific type can contain instances of that type and any of its subtypes.</p>
<p>For example, consider the <code>person_typ</code> type hierarchy such as the one introduced in <a href="#BCFCAAFG">Example 2-14</a>. You can create an object table of <code>person_typ</code> that contains rows of all types. To do this, you insert an instance of a given type into an object table using the constructor for that type in the <code>VALUES</code> clause of the <code>INSERT</code> statement as shown in <a href="#CHDJGIAG">Example 2-20</a>.</p>
<p>Similarly, <a href="#BCFIABBI">Example 2-23</a> shows that a substitutable column of type <code>person_typ</code> can contain instances of all three types, in a relational table or view. The example recreates person, student, and part-time student objects from that type hierarchy and inserts them into the <code>person_typ</code> column <code>contact</code>.</p>
<div id="ADOBJ7128" class="example">
<p class="titleinexample"><a id="BCFIABBI"></a>Example 2-23 Inserting Values into Substitutable Columns of a Table</p>
<pre>DROP TYPE person_typ FORCE;
-- if previously created

DROP TYPE student_typ FORCE; -- if previously created

DROP TYPE part_time_student_typ FORCE; -- if previously created
DROP TABLE contacts; if previously created
CREATE OR REPLACE TYPE person_typ AS OBJECT (
  idno           NUMBER,
  name           VARCHAR2(30),
  phone          VARCHAR2(20))
  NOT FINAL;/
CREATE TYPE student_typ UNDER person_typ (
    dept_id NUMBER,
    major VARCHAR2(30))
    NOT FINAL;
/
CREATE TYPE part_time_student_typ UNDER student_typ (
  number_hours NUMBER);
/
CREATE TABLE contacts (
  <span class="bold">contact         person_typ</span>,
  contact_date    DATE );

<span class="bold">INSERT INTO contacts</span> 
  <span class="bold">VALUES</span> (person_typ (12, &#39;Bob Jones&#39;, &#39;650-555-0130&#39;), &#39;24 Jun 2003&#39; );

<span class="bold">INSERT INTO contacts</span> 
  <span class="bold">VALUES</span> (student_typ(51, &#39;Joe Lane&#39;, &#39;1-650-555-0178&#39;, 12, &#39;HISTORY&#39;),
         &#39;24 Jun 2003&#39; );

<span class="bold">INSERT INTO contacts</span> 
  <span class="bold">VALUES</span> (part_time_student_typ(52, &#39;Kim Patel&#39;, &#39;1-650-555-0190&#39;, 14,
          &#39;PHYSICS&#39;, 20), &#39;24 Jun 2003&#39; );
</pre></div>
<!-- class="example" -->
<p>A newly created subtype can be stored in any substitutable tables and columns of its supertype, including tables and columns that existed before the subtype was created.</p>
<p>In general, you can access attributes using dot notation. To access attributes of a subtype of a row or column&#39;s declared type, you can use the <code>TREAT</code> function. For example:</p>
<pre>SELECT TREAT(contact AS student_typ).major FROM contacts;
</pre>
<p>See <a href="#i479093">&#34;TREAT&#34;</a>.</p>
<a id="i473105"></a>
<div id="ADOBJ7129" class="sect3">
<h4 class="sect3">Using OBJECT_VALUE and OBJECT_ID with Substitutable Rows<a id="sthref243"></a><a id="sthref244"></a><a id="sthref245"></a><a id="sthref246"></a></h4>
<p>The <code>OBJECT_VALUE</code> and <code>OBJECT_ID</code> pseudocolumns allow you to access and identify the value and object identifier (OID) of a substitutable row in an object table as shown in <a href="#i473472">Example 2-24</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For further information on these pseudocolumns
<ul>
<li>
<p><a class="olink SQLRF50952" href="../SQLRF/pseudocolumns006.htm#SQLRF50952"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><a class="olink SQLRF50951" href="../SQLRF/pseudocolumns005.htm#SQLRF50951"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
</div>
<div id="ADOBJ7130" class="example">
<p class="titleinexample"><a id="i473472"></a>Example 2-24 Using OBJECT_VALUE and OBJECT_ID</p>
<pre>DROP TABLE person_obj_table; -- required if previously created
CREATE TABLE person_obj_table OF person_typ;

INSERT INTO person_obj_table
  VALUES (person_typ(20, &#39;Bob Jones&#39;, &#39;650-555-0130&#39;));

SELECT p.<span class="bold">object_id</span>, p.<span class="bold">object_value</span> FROM person_obj_table p;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i473706"></a>
<div id="ADOBJ7131" class="sect3">
<h4 class="sect3">Subtypes with Attributes of a Supertype<a id="sthref247"></a><a id="sthref248"></a></h4>
<p>A subtype can have an attribute whose type is the type of a supertype. For example:</p>
<div id="ADOBJ7132" class="example">
<p class="titleinexample"><a id="sthref249"></a>Example 2-25 Creating a Subtype with a Supertype Attribute</p>
<pre>-- requires Ex 2-22
CREATE TYPE student_typ UNDER <span class="bold">person_typ</span> (
    dept_id   NUMBER,
    major     VARCHAR2(30),
    advisor   <span class="bold">person_typ</span>);
/
</pre></div>
<!-- class="example" -->
<p>However, columns of such types are not substitutable. Similarly, a subtype can have a collection attribute whose element type is one of its supertypes, but, again, columns of such types are not substitutable. For example, if <code>student_typ</code> had a nested table or varray of <code>person_typ</code>, the <code>student_typ</code> column would not be substitutable.</p>
<p>You can, however, define substitutable columns of subtypes that have <code>REF</code> attributes that reference supertypes. For example, the <code>composite_category_typ</code> subtype shown in <a href="#CHDIFHDA">Example 2-26</a> contains the <code>subcategory_ref_list</code> nested table. This table contains <code>subcategory_ref_list_typ</code> which are REFs to <code>category_typ</code>. The subtype was created as follows:</p>
<div id="ADOBJ7133" class="example">
<p class="titleinexample"><a id="CHDIFHDA"></a>Example 2-26 Defining Columns of Subtypes that have REF Attributes</p>
<pre>-- not to be executed
CREATE TYPE subcategory_ref_list_typ
  AS TABLE OF REF category_typ; 
/ 

CREATE TYPE composite_category_typ
  UNDER category_typ 
    ( 
      subcategory_ref_list subcategory_ref_list_typ 
...
</pre></div>
<!-- class="example" -->
<p>See <a href="#i461515">&#34;Turning Off Substitutability in a New Table&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<a id="CHDJEAHI"></a>
<div id="ADOBJ7134" class="sect3">
<h4 class="sect3">Substitution of REF Columns and Attributes<a id="sthref250"></a></h4>
<p><code>REF</code> columns and attributes are substitutable in both views and tables. For example, in either a view or a table, a column declared to be <code>REF</code> <code>person_typ</code> can hold references to instances of <code>person_typ</code> or any of its subtypes.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7135" class="sect3"><a id="sthref251"></a>
<h4 class="sect3">Substitution of Collection Elements<a id="sthref252"></a></h4>
<p>Collection elements are substitutable in both views and tables. For example, a nested table of <code>person_typ</code> can contain object instances of <code>person_typ</code> or any of its subtypes.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHHIJEI"></a>
<div id="ADOBJ7136" class="sect2">
<h3 class="sect2">Storing Newly Created Subtypes in Substitutable Columns</h3>
<p>If you create a subtype, any table that already has substitutable columns of the supertype can store the new subtype as well. This means that your options for creating subtypes are affected by the existence of such tables. If such a table exists, you can only create subtypes that are substitutable, that is, subtypes that do not violate table limits or constraints.</p>
<p>The following example creates a <code>person_typ</code> and then shows several attempts to create a subtype <code>student_typ</code> under <code>person_typ</code>.</p>
<div id="ADOBJ7137" class="example">
<p class="titleinexample"><a id="sthref253"></a>Example 2-27 Creating a Subtype After Creating Substitutable Columns</p>
<pre>DROP TYPE person_typ FORCE;
DROP TABLE person_obj_table;
DROP TYPE student_typ; 
-- perform above drops if objects/tables created
CREATE OR REPLACE TYPE person_typ AS OBJECT (
  idno           NUMBER,
  name           VARCHAR2(30),
  phone          VARCHAR2(20))
  NOT FINAL;/

CREATE TABLE person_obj_table (<span class="bold">p person_typ</span>);
</pre></div>
<!-- class="example" -->
<p>The following statement fails because <code>student_typ</code> has a supertype attribute, and table <code>person_obj_table</code> has a substitutable column <code>p</code> of the supertype.</p>
<pre>CREATE TYPE student_typ UNDER person_typ ( -- incorrect CREATE subtype
    advisor <span class="bold">person_typ</span>);
/
</pre>
<p>The next attempt succeeds. This version of the <code>student_typ</code> subtype is substitutable. Oracle Database automatically enables table <code>person_obj_table</code> to store instances of this new type.</p>
<pre>CREATE TYPE student_typ UNDER person_typ (
    dept_id NUMBER,
    major VARCHAR2(30));/
INSERT INTO person_obj_table 
  VALUES (student_typ(51, &#39;Joe Lane&#39;, &#39;1-650-555-0178&#39;, 12, &#39;HISTORY&#39;));
</pre></div>
<!-- class="sect2" -->
<a id="CIHHJIED"></a>
<div id="ADOBJ7138" class="sect2">
<h3 class="sect2">Dropping Subtypes After Creating Substitutable Columns<a id="sthref254"></a><a id="sthref255"></a></h3>
<p>When you drop a subtype with the <code>VALIDATE</code> option, it checks that no instances of the subtype are stored in any substitutable column of the supertype. If there are no such instances, the <code>DROP</code> operation completes.</p>
<p>The following statement fails because an instance of <code>student_typ</code> is stored in substitutable column <code>p</code> of table <code>person_obj_table</code>:</p>
<pre>DROP TYPE student_typ VALIDATE -- incorrect: an instance still exists ; 
</pre>
<p>To drop the type, first delete any of its instances in substitutable columns of the supertype:</p>
<pre>DELETE FROM person_obj_table WHERE p IS OF (student_typ); 

DROP TYPE student_typ VALIDATE;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS99989" href="../LNPLS/drop_type.htm#LNPLS99989"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for further information on <code>DROP</code> and <code>VALIDATE</code></div>
</div>
<!-- class="sect2" -->
<a id="i461515"></a>
<div id="ADOBJ7139" class="sect2">
<h3 class="sect2">Turning Off Substitutability in a New Table<a id="sthref256"></a></h3>
<p>When you create a table, you can turn off all substitutability on a column or attribute, including embedded attributes and collections nested to any level, with the clause <code>NOT</code> <code>SUBSTITUTABLE</code> <code>AT</code> <code>ALL</code> <code>LEVELS</code>.</p>
<p>In the following example, the clause confines the column <code>office</code> of a relational table to storing only <code>office_typ</code> instances and disallows any subtype instances:</p>
<div id="ADOBJ7140" class="example">
<p class="titleinexample"><a id="sthref257"></a>Example 2-28 Turning off Substitutability When Creating a Table</p>
<pre>DROP TYPE location_typ FORCE; -- required if previously created
DROP TYPE office_typ FORCE; -- required if previously created
CREATE OR REPLACE TYPE location_typ AS OBJECT (
  building_no  NUMBER,
  city         VARCHAR2(40) );
/

CREATE TYPE people_typ AS TABLE OF person_typ;
/
CREATE TYPE office_typ AS OBJECT (
  office_id    VARCHAR(10),
  location     location_typ,
  occupant     person_typ )
  NOT FINAL;/

CREATE TABLE dept_office (
  dept_no      NUMBER,
  <span class="bold">office       office_typ</span>)
  COLUMN office NOT SUBSTITUTABLE AT ALL LEVELS;
</pre></div>
<!-- class="example" -->
<p>With object tables, the clause can be applied to the table as a whole, such as:</p>
<pre>DROP TABLE office_tab; -- if previously created
CREATE <span class="bold">TABLE</span> office_tab OF office_typ
  <span class="bold">NOT SUBSTITUTABLE AT ALL LEVELS</span>;
</pre>
<p>The clause can also turn off substitutability in a particular column, that is, for a particular attribute of the object type of the table:</p>
<pre>DROP TABLE office_tab; -- if previously created
CREATE TABLE office_tab OF office_typ
  <span class="bold">COLUMN</span> occupant <span class="bold">NOT SUBSTITUTABLE AT ALL LEVELS</span>;
</pre>
<p>You can specify that the element type of a collection is not substitutable using syntax such as the following:</p>
<pre>DROP TABLE people_tab;
-- required if previously created
CREATE TABLE people_tab (
    people_column people_typ )
    NESTED TABLE people_column 
      <span class="bold">NOT SUBSTITUTABLE AT ALL LEVELS</span> STORE AS people_column_nt;
</pre>
<p>There is no mechanism to turn off substitutability for <code>REF</code> columns.</p>
<p>You can use either <code>NOT</code> <code>SUBSTITUTABLE</code> <code>AT</code> <code>ALL</code> <code>LEVELS</code> or <code>IS</code> <code>OF</code> type to constrain an <a href="glossary.htm#CHDGHHHE"><span class="xrefglossterm">object column</span></a>, but you cannot use both.</p>
</div>
<!-- class="sect2" -->
<a id="i463421"></a>
<div id="ADOBJ7141" class="sect2">
<h3 class="sect2">Constraining Substitutability<a id="sthref258"></a></h3>
<p>You can impose a constraint that limits the range of subtypes permitted in an object column or attribute to a particular subtype in the declared type&#39;s hierarchy. You do this using an <code>IS</code> <code>OF</code> <code><span class="codeinlineitalic">type</span></code> constraint.</p>
<p>The following statement creates a table of <code>office_typ</code> in which occupants are constrained to just those persons who are employees:</p>
<div id="ADOBJ7142" class="example">
<p class="titleinexample"><a id="sthref259"></a>Example 2-29 Constraining Substitutability When Creating a Table</p>
<pre>DROP TABLE office_tab;
-- if previously created
CREATE TABLE office_tab OF office_typ
  COLUMN occupant <span class="bold">IS OF </span>(<span class="bold">ONLY</span> employee_typ);
</pre></div>
<!-- class="example" -->
<p>Although the type <code>office_typ</code> allows authors to be of type <code>person_typ</code>, the column declaration imposes a constraint to store only instances of <code>employee_typ</code>.</p>
<p>You can only use the <code>IS</code> <code>OF</code> <code><span class="codeinlineitalic">type</span></code> operator to constrain row and column objects to a single subtype (not several), and you must use the <code>ONLY</code> keyword, as in the preceding example.</p>
<p>You can use either <code>IS</code> <code>OF</code> <code><span class="codeinlineitalic">type</span></code> or <code>NOT</code> <code>SUBSTITUTABLE</code> <code>AT</code> <code>ALL</code> <code>LEVELS</code> to constrain an <a href="glossary.htm#CHDGHHHE"><span class="xrefglossterm">object column</span></a>, but you cannot use both.</p>
</div>
<!-- class="sect2" -->
<a id="i468659"></a>
<div id="ADOBJ7143" class="sect2">
<h3 class="sect2">Modifying Substitutability<a id="sthref260"></a></h3>
<p>In an existing table, you can change an object column from <code>SUBSTITUTABLE</code> to <code>NOT</code> <code>SUBSTITUTABLE</code> (or from <code>NOT</code> <code>SUBSTITUTABLE</code> to <code>SUBSTITUTABLE</code>) by using an <code>ALTER</code> <code>TABLE</code> statement. To do so, you specify the clause [<code>NOT</code>] <code>SUBSTITUTABLE</code> <code>AT</code> <code>ALL</code> <code>LEVELS</code> for the particular column.</p>
<p>You can modify substitutability only for a specific column, not for an object table as a whole.</p>
<p>The following statement makes the column <code>office</code> substitutable:</p>
<div id="ADOBJ7144" class="example">
<p class="titleinexample"><a id="sthref261"></a>Example 2-30 Modifying Substitutability in a Table</p>
<pre>-- Requires Ex. 2-28
ALTER TABLE dept_office
  MODIFY COLUMN office <span class="bold">SUBSTITUTABLE AT ALL LEVELS</span>;  
</pre></div>
<!-- class="example" -->
<p>The following statement makes the column not substitutable. Notice that it also uses the <code>FORCE</code> keyword. This keyword causes any hidden columns containing typeid information or data for subtype attributes to be dropped:</p>
<pre>ALTER TABLE  dept_office
  MODIFY COLUMN office NOT SUBSTITUTABLE AT ALL LEVELS <span class="bold">FORCE</span>;
</pre>
<p>If you do not use the <code>FORCE</code> keyword to make a column not substitutable, the column and all attributes of the type must be <code>FINAL</code> or the <code>ALTER</code> <code>TABLE</code> statement will fail.</p>
<p>A <code>VARRAY</code> column can be modified from <code>SUBSTITUTABLE</code> to <code>NOT</code> <code>SUBSTITUTABLE</code> only if the element type of the varray is final itself and has no embedded types (in its attributes or in their attributes, and so on) that are not final.</p>
<p>See <a href="adobjadv.htm#i1010837">&#34;Hidden Columns for Substitutable Columns and Object Tables&#34;</a> for more information about hidden columns for typeids and subtype attributes.</p>
</div>
<!-- class="sect2" -->
<a id="CIHGHCCG"></a>
<div id="ADOBJ7145" class="sect2">
<h3 class="sect2">Restrictions on Modifying Substitutability<a id="sthref262"></a></h3>
<p>You can change the substitutability of only one column at a time with an <code>ALTER</code> <code>TABLE</code> statement. To change substitutability for multiple columns, you must issue multiple statements.</p>
<p>In an object table, you can only modify substitutability for a column if substitutability was not explicitly set at the table level, when the table was created.</p>
<p>For example, the following attempt to modify substitutability for column address succeeds because substitutability has not been explicitly turned on or off at the table level in the <code>CREATE</code> <code>TABLE</code> statement:</p>
<pre>DROP TABLE office_tab;
-- if previously created
CREATE TABLE office_tab OF office_typ;

ALTER TABLE office_tab
  MODIFY COLUMN occupant NOT SUBSTITUTABLE AT ALL LEVELS FORCE;
</pre>
<p>However, in the following example, substitutability is explicitly set at the table level, so the attempt to modify the setting for column address fails:</p>
<pre>DROP TABLE office_tab;
-- if previously created
CREATE TABLE office_tab OF office_typ
  NOT SUBSTITUTABLE AT ALL LEVELS;

/* Following SQL statement generates an error: */
ALTER TABLE office_tab 
  MODIFY COLUMN occupant SUBSTITUTABLE AT ALL LEVELS FORCE  -- incorrect ALTER;
</pre>
<p>A column whose substitutability is already constrained by an <code>IS</code> <code>OF</code> <code><span class="codeinlineitalic">type</span></code> operator cannot have its substitutability modified with a [<code>NOT</code>] <code>SUBSTITUTABLE</code> <code>AT</code> <code>ALL</code> <code>LEVELS</code> clause. See <a href="#i463421">&#34;Constraining Substitutability&#34;</a> for information about <code>IS</code> <code>OF</code> <code><span class="codeinlineitalic">type</span></code>.</p>
</div>
<!-- class="sect2" -->
<a id="i466278"></a>
<div id="ADOBJ7146" class="sect2">
<h3 class="sect2">Assignments Across Types<a id="sthref263"></a><a id="sthref264"></a></h3>
<p>The assignment rules described in this section apply to <code>INSERT/UPDATE</code> statements, the <code>RETURNING</code> clause, function parameters, and PL/SQL variables.</p>
<a id="CHDHHJDI"></a>
<div id="ADOBJ7147" class="sect3">
<h4 class="sect3">Typical Object to Object Assignment<a id="sthref265"></a><a id="sthref266"></a><a id="sthref267"></a></h4>
<p>Substitutability is the ability of a subtype to stand in for one of its supertypes. Substitution in the other direction, to substitute a supertype for a subtype, raises an error at compile time.</p>
<p>Assigning a source of type <code>source_typ</code> to a target of type <code>target_typ</code> must be of one of the following two patterns:</p>
<ul>
<li>
<p>Case 1: <code>source_typ</code> and <code>target_typ</code> are the same type</p>
</li>
<li>
<p>Case 2: <code>source_typ</code> is a subtype of <code>target_typ</code> (widening)</p>
</li>
</ul>
<p>Case 2 illustrates widening. Widening is an assignment in which the declared type of the source is more specific than the declared type of the target. For example, assigning an employee instance to a variable of person type.</p>
<p>An employee is a more narrowly defined, specialized kind of person, so you can put an employee in a slot meant for a person if you do not mind ignoring whatever extra specialization makes that person an employee. All employees are persons, so a widening assignment always works.</p>
<p>To illustrate widening, suppose that you have the following table:</p>
<br/>
<code>TABLE T(pers_col person_typ, emp_col employee_typ,</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stu_col student_typ)</code><br/>
<p>The following assignments show widening. The assignments are valid unless <code>perscol</code> has been defined to be not substitutable.</p>
<p><code>UPDATE T set pers_col = emp_col;</code></p>
<p>The following is a PL/SQL example, which first requires you to create a <code>person_typ</code> and an <code>employee_typ</code>:</p>
<div id="ADOBJ7148" class="example">
<p class="titleinexample"><a id="sthref268"></a>Example 2-31 PL/SQL Assignment</p>
<pre>DROP TYPE person_typ FORCE;
-- if previously created
CREATE TYPE person_typ AS OBJECT (
 idno           NUMBER,
 name           VARCHAR2(30),
 phone          VARCHAR2(20))
 NOT FINAL;
/
DROP TYPE employee_typ FORCE; -- if previously created
CREATE TYPE employee_typ UNDER person_typ (
   emp_id NUMBER, 
   mgr VARCHAR2(30));
/
-- PL/SQL assignment example
DECLARE
  var1 person_typ;
  var2 employee_typ;
BEGIN
  var2 := employee_typ(55, &#39;Jane Smith&#39;, &#39;1-650-555-0144&#39;, 100, &#39;Jennifer Nelson&#39;);
  var1 := var2;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADOBJ7149" class="sect3"><a id="sthref269"></a>
<h4 class="sect3">Narrowing Assignment<a id="sthref270"></a><a id="sthref271"></a><a id="sthref272"></a></h4>
<p>A narrowing assignment is the reverse of widening. It involves regarding a more general, less specialized type of thing, such as a person, as a more narrowly defined type of thing, such as an employee. Not all persons are employees, so a particular assignment like this works only if the person in question actually happens to be an employee. Thus, in the end, narrowing assignments only work in cases such as Case 1, described in <a href="#CHDHHJDI">&#34;Typical Object to Object Assignment&#34;</a>.</p>
<p>To do a narrowing assignment, you must use the <code>TREAT</code> function to test that the source instance of the more general declared type is in fact an instance of the more specialized target type and can therefore be operated on as such. The <code>TREAT</code> function does a runtime check to confirm this and returns <code>NULL</code> if the source value, the person in question, is not of the target type or one of its subtypes.</p>
<p>For example, the following <code>UPDATE</code> statement sets values of <code>person_typ</code> in column <code>perscol</code> into column <code>empcol</code> of <code>employee_typ</code>. For each value in <code>perscol</code>, the assignment succeeds if that person is also an employee. If the person is not an employee, <code>TREAT</code> returns <code>NULL</code>, and the assignment returns <code>NULL</code>.</p>
<p><code>UPDATE T set emp_col = TREAT(pers_col AS employee_typ);</code></p>
<p>The following statement attempts to do a narrowing assignment without explicitly changing the declared type of the source value. The statement will return an error:</p>
<p><code>UPDATE T set emp_col = pers_col;</code></p>
<p>See <a href="#CHDEBCHE">&#34;Using TREAT for Narrowing Assignments&#34;</a>.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7150" class="sect3"><a id="sthref273"></a>
<h4 class="sect3">Collection Assignments<a id="sthref274"></a><a id="sthref275"></a></h4>
<p>In assignments of expressions of a collection type, the source and target must be of the same declared type. Neither widening nor narrowing is permitted. However, a subtype value can be assigned to a supertype collection. For example, after creating a new <code>student_typ</code>, suppose we have the following collection types:</p>
<div id="ADOBJ7151" class="example">
<p class="titleinexample"><a id="sthref276"></a>Example 2-32 Create Collection person_set</p>
<pre>-- Requires 2-21
DROP student_typ;
-- if previously created
CREATE TYPE student_typ UNDER person_typ (
    dept_id NUMBER,
    major VARCHAR2(30))
  NOT FINAL;
/
CREATE TYPE person_set AS TABLE OF person_typ;
/

CREATE TYPE student_set AS TABLE OF student_typ;
/
</pre></div>
<!-- class="example" -->
<p>Expressions of these different collection types cannot be assigned to each other, but a collection element of <code>student_typ</code> can be assigned to a collection of <code>person_set</code> type:</p>
<pre>DECLARE
  var1 person_set; 
  var2 student_set;
  elem1 person_typ; 
  <span class="bold">elem2</span> student_typ;
BEGIN
--  var1 := var2;   /* ILLEGAL - collections not of same type */
  var1 := <span class="bold">person_set</span> (elem1, <span class="bold">elem2</span>);   /* LEGAL : Element is of subtype */
END;
/
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i463707"></a>
<div id="ADOBJ00206" class="sect1">
<h2 class="sect1">Functions and Operators Useful with Objects</h2>
<p>Several functions and operators are particularly useful for working with objects and references to objects:</p>
<ul>
<li>
<p><a href="#i478986">CAST</a></p>
</li>
<li>
<p><a href="#i479023">CURSOR</a></p>
</li>
<li>
<p><a href="#i479078">DEREF</a></p>
</li>
<li>
<p><a href="#i470492">IS OF <span class="italic">type</span></a></p>
</li>
<li>
<p><a href="#i479180">REF</a></p>
</li>
<li>
<p><a href="#i465365">SYS_TYPEID</a></p>
</li>
<li>
<p><a href="#i472581">TABLE()</a></p>
</li>
<li>
<p><a href="#i479093">TREAT</a></p>
</li>
<li>
<p><a href="#i479050">VALUE</a></p>
</li>
</ul>
<p>Examples are given throughout this book.</p>
<p>In PL/SQL the <code>VALUE</code>, <code>REF</code> and <code>DEREF</code> functions can appear only in a SQL statement. For information about SQL functions, see <a class="olink SQLRF006" href="../SQLRF/functions.htm#SQLRF006"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<a id="i478986"></a>
<div id="ADOBJ7152" class="sect2">
<h3 class="sect2">CAST<a id="sthref277"></a></h3>
<p><code>CAST</code> converts one built-in data type or collection-typed value into another built-in data type or collection-typed value. For example:</p>
<div id="ADOBJ7153" class="example">
<p class="titleinexample"><a id="sthref278"></a>Example 2-33 Using the CAST Function</p>
<pre>CREATE TYPE person_list_typ AS TABLE OF person_typ;/

SELECT <span class="bold">CAST</span>(COLLECT(contact) AS person_list_typ) 
  FROM contacts;
</pre></div>
<!-- class="example" -->
<p>For more information about the SQL <code>CAST</code> function, <a class="olink SQLRF00613" href="../SQLRF/functions024.htm#SQLRF00613"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i479023"></a>
<div id="ADOBJ7154" class="sect2">
<h3 class="sect2">CURSOR<a id="sthref279"></a></h3>
<p>A <code>CURSOR</code> expression returns a nested cursor. This form of expression is equivalent to the PL/SQL <code>REF</code> <code>CURSOR</code> and can be passed as a <code>REF</code> <code>CURSOR</code> argument to a function.</p>
<p>For more information about the SQL <code>CURSOR</code> expression, see <a class="olink SQLRF004" href="../SQLRF/expressions.htm#SQLRF004"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i479078"></a>
<div id="ADOBJ7155" class="sect2">
<h3 class="sect2">DEREF<a id="sthref280"></a><a id="sthref281"></a></h3>
<p>The <code>DEREF</code> function in a SQL statement returns the object instance corresponding to a <code>REF</code>. The object instance returned by <code>DEREF</code> may be of the declared type of the <code>REF</code> or any of its subtypes.</p>
<p>For example, the following statement returns <code>person_typ</code> objects from the table <code>contact_ref</code>.</p>
<div id="ADOBJ7156" class="example">
<p class="titleinexample"><a id="sthref282"></a>Example 2-34 Using the DEREF Function</p>
<pre>SELECT DEREF(c.contact_ref), c.contact_date 
  FROM contacts_ref c;
</pre></div>
<!-- class="example" -->
<p>See <a href="adobjint.htm#CHDGGIFD">&#34;Dereferencing REFs&#34;</a>. For more information about the SQL <code>DEREF</code> function, see <a class="olink SQLRF00634" href="../SQLRF/functions062.htm#SQLRF00634"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i470492"></a>
<div id="ADOBJ7157" class="sect2">
<h3 class="sect2">IS OF <span class="italic">type</span><a id="sthref283"></a><a id="sthref284"></a></h3>
<p>The <code>IS</code> <code>OF</code> <code><span class="codeinlineitalic">type</span></code> predicate tests object instances for the level of specialization of their type.</p>
<p>For example, the following query retrieves all student instances (including any subtypes of students) stored in the <code>person_obj_table</code> table.</p>
<div id="ADOBJ7158" class="example">
<p class="titleinexample"><a id="sthref285"></a>Example 2-35 Using the IS OF type Operator to Query Value of a Subtype</p>
<pre>SELECT VALUE(p) 
  FROM person_obj_table p
WHERE VALUE(p) IS OF (student_typ);
</pre></div>
<!-- class="example" -->
<p>For any object that is not of a specified subtype, or a subtype of a specified subtype, <code>IS</code> <code>OF</code> returns <code>FALSE</code>. Subtypes of a specified subtype are just more specialized versions of the specified subtype. If you want to exclude such subtypes, you can use the <code>ONLY</code> keyword. This keyword causes <code>IS</code> <code>OF</code> to return <code>FALSE</code> for all types except the specified types.</p>
<p>In the following example, the statement tests objects in object table <code>person_obj_table</code>, which contains persons, employees, and students, and returns <code>REF</code>s just to objects of the two specified person subtypes <code>employee_typ</code>, <code>student_typ</code>, and their subtypes, if any:</p>
<pre>SELECT REF(p) 
  FROM person_obj_table p
WHERE VALUE(p) IS OF (employee_typ, student_typ);
</pre>
<p>Here is a similar example in PL/SQL. The code does something if the person is an employee or student:</p>
<pre>DECLARE 
  var person_typ; 
BEGIN 
  var := employee_typ(55, &#39;Jane Smith&#39;, &#39;1-650-555-0144&#39;, 100, &#39;Jennifer Nelson&#39;);
  IF var IS OF (employee_typ, student_typ) THEN 
     DBMS_OUTPUT.PUT_LINE(&#39;Var is an employee_typ or student_typ object.&#39;);
  ELSE
     DBMS_OUTPUT.PUT_LINE(&#39;Var is not an employee_typ or student_typ object.&#39;);
  END IF;
END;
/
</pre>
<p>The following statement returns only students whose most specific or specialized type is <code>student_typ</code>. If the table or view contains any objects of a subtype of <code>student_typ</code>, such as <code>part_time_student_typ</code>, these are excluded. The example uses the <code>TREAT</code> function to convert objects that are students to <code>student_typ</code> from the declared type of the view, <code>person_typ</code>:</p>
<pre>SELECT TREAT(VALUE(p) AS student_typ)
  FROM person_obj_table p 
WHERE VALUE(p) IS OF(ONLY student_typ);
</pre>
<p>To test the type of the object that a <code>REF</code> points to, you can use the <code>DEREF</code> function to dereference the <code>REF</code> before testing with the <code>IS</code> <code>OF</code> <code><span class="codeinlineitalic">type</span></code> predicate.</p>
<p>For example, if <code>contact_ref</code> is declared to be <code>REF</code> <code>person_typ</code>, you can get just the rows for students as follows:</p>
<pre>SELECT * 
  FROM contacts_ref
WHERE DEREF(contact_ref) IS OF (student_typ);
</pre>
<p>For more information about the SQL <code>IS</code> <code>OF</code> <code><span class="codeinlineitalic">type</span></code> condition, see <a class="olink SQLRF005" href="../SQLRF/conditions.htm#SQLRF005"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i479180"></a>
<div id="ADOBJ7159" class="sect2">
<h3 class="sect2">REF<a id="sthref286"></a></h3>
<p>The <code>REF</code> function in a SQL statement takes as an argument a correlation name (or table alias) for an object table or view and returns a reference (a <code>REF</code>) to an object instance from that table or view. The <code>REF</code> function may return references to objects of the declared type of the table, view, or any of its subtypes. For example, the following statement returns the references to all persons, including references to students and employees, whose <code>idno</code> attribute is 12:</p>
<div id="ADOBJ7160" class="example">
<p class="titleinexample"><a id="sthref287"></a>Example 2-36 Using the REF Function</p>
<pre>SELECT REF(p) 
  FROM person_obj_table p
  WHERE p.idno = 12;
</pre></div>
<!-- class="example" -->
<p>For more information about the SQL <code>REF</code> function, see <a class="olink SQLRF00694" href="../SQLRF/functions159.htm#SQLRF00694"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i465365"></a>
<div id="ADOBJ7161" class="sect2">
<h3 class="sect2">SYS_TYPEID<a id="sthref288"></a><a id="sthref289"></a></h3>
<p>The <code>SYS_TYPEID</code> function can be used in a query to return the typeid (a hidden type) of the most specific type of the object instance passed as an argument.</p>
<p>The most specific type of an object instance is the type that the instance belongs to, that is, the farthest removed instance from the root type. For example, if Tim is a part-time student, he is also a student and a person, but his most specific type is part-time student.</p>
<p>The function returns the typeids from the hidden type-discriminant column that is associated with every substitutable column. The function returns a null typeid for a final, root type.</p>
<p>The syntax of the function is:</p>
<p><code>SYS_TYPEID(object_type_value)</code></p>
<p>Function <code>SYS_TYPEID</code> may be used only with arguments of an object type. Its primary purpose is to make it possible to build an index on a hidden type-discriminant column.</p>
<p>All types that belong to a type hierarchy are assigned a non-null typeid that is unique within the type hierarchy. Types that do not belong to a type hierarchy have a null typeid.</p>
<p>Every type except a final root type belongs to a type hierarchy. A final root type has no types related to it by inheritance:</p>
<ul>
<li>
<p>It cannot have subtypes derived from it because it is final.</p>
</li>
<li>
<p>It is not itself derived from some other type because it is a root type, so it does not have any supertypes.</p>
</li>
</ul>
<p>For an example of <code>SYS_TYPEID</code>, consider the substitutable object table <code>person_obj_table</code>, of <code>person_typ</code>. <code>person_typ</code> is the root type of a hierarchy that has <code>student_typ</code> as a subtype and <code>part_time_student_typ</code> as a subtype of <code>student_typ</code>. See <a href="#CHDJGIAG">Example 2-20</a>.</p>
<p>The following query uses <code>SYS_TYPEID</code>. It gets the <code>name</code> attribute and <code>typeid</code> of the object instances in the <code>person_obj_table</code> table. Each of the instances is of a different type:</p>
<div id="ADOBJ7162" class="example">
<p class="titleinexample"><a id="sthref290"></a>Example 2-37 Using the SYS_TYPEID Function</p>
<pre>SELECT name, SYS_TYPEID(VALUE(p)) typeid FROM person_obj_table p;
</pre></div>
<!-- class="example" -->
<p>See <a href="adobjadv.htm#i1010837">&#34;Hidden Columns for Substitutable Columns and Object Tables&#34;</a> for information about the type-discriminant and other hidden columns. For more information about the SQL <code>SYS</code> <code>TYPEID</code> function, see <a class="olink SQLRF00694" href="../SQLRF/functions159.htm#SQLRF00694"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i472581"></a>
<div id="ADOBJ7163" class="sect2">
<h3 class="sect2">TABLE()<a id="sthref291"></a><a id="sthref292"></a></h3>
<p>Table functions are functions that produce a collection of rows, a nested table or a varray, that can be queried like a physical database table or assigned to a PL/SQL collection variable. You can use a table function like the name of a database table, in the <code>FROM</code> clause of a query, or like a column name in the <code>SELECT</code> list of a query.</p>
<p>A table function can take a collection of rows as input. An input collection parameter can be either a collection type, such as a <code>VARRAY</code> or a PL/SQL table, or a <code>REF</code> <code>CURSOR</code>.</p>
<p>Use <code>PIPELINED</code> to instruct Oracle Database to return the results of a table function iteratively. A table function returns a nested table or varray type. You query table functions by using the <code>TABLE</code> keyword before the function name in the <code>FROM</code> clause of the query.</p>
<p>For information on <code>TABLE()</code> functions, see <a class="olink ADDCI2140" href="../ADDCI/pipe_paral_tbl.htm#ADDCI2140"><span class="italic">Oracle Database Data Cartridge Developer&#39;s Guide</span></a> and <a class="olink LNPLS013" href="../LNPLS/langelems.htm#LNPLS013"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i479093"></a>
<div id="ADOBJ7164" class="sect2">
<h3 class="sect2">TREAT<a id="sthref293"></a><a id="sthref294"></a></h3>
<p>The <code>TREAT</code> function does a runtime check to confirm that an expression can be operated on as if it were of a different specified type in the hierarchy, normally a subtype of the declared type of the expression. In other words, the function attempts to treat a supertype instance as a subtype instance, for example, to treat a person as a student. If the person is a student, then the person is returned as a student, with the additional attributes and methods that a student may have. If the person is not a student, <code>TREAT</code> returns <code>NULL</code> in SQL.</p>
<p>The two main uses of <code>TREAT</code> are:</p>
<ul>
<li>
<p>In narrowing assignments, to modify the type of an expression so that the expression can be assigned to a variable of a more specialized type in the hierarchy: that is, to set a supertype value into a subtype.</p>
</li>
<li>
<p>To access attributes or methods of a subtype of the declared type of a row or column.</p>
<p>A substitutable object table or column of type <code>T</code> has a hidden column for every attribute of every subtype of <code>T</code>. These hidden columns contain subtype attribute data, but you cannot list them with a <code>DESCRIBE</code> statement. <code>TREAT</code> enables you to access these columns.</p>
</li>
</ul>
<a id="CHDEBCHE"></a>
<div id="ADOBJ7165" class="sect3">
<h4 class="sect3">Using TREAT for Narrowing Assignments</h4>
<p>The <code>TREAT</code> function is used for narrowing assignments, that is, assignments that set a supertype value into a subtype. For a comparison to widening assignments, see <a href="#i466278">&#34;Assignments Across Types&#34;</a>.</p>
<p>In <a href="#CHDGIGFA">Example 2-38</a>, <code>TREAT</code> returns all (and only) <code>student_typ</code> instances from <code>person_obj_table</code> of type <code>person_typ</code>, a supertype of <code>student_typ</code>. The statement uses <code>TREAT</code> to modify the type of <code>p</code> from <code>person_typ</code> to <code>student_typ</code>.</p>
<div id="ADOBJ7166" class="example">
<p class="titleinexample"><a id="CHDGIGFA"></a>Example 2-38 Using the TREAT Function to Return a Specific Subtype in a Query</p>
<pre>SELECT TREAT(VALUE(p) AS student_typ)
  FROM person_obj_table p;
</pre></div>
<!-- class="example" -->
<p>For each <code>p</code>, the <code>TREAT</code> modification succeeds only if the most specific or specialized type of the value of <code>p</code> is <code>student_typ</code> or one of its subtypes. If <code>p</code> is a person who is not a student, or if <code>p</code> is <code>NULL</code>, <code>TREAT</code> returns <code>NULL</code> in SQL or, in PL/SQL, raises an exception.</p>
<p>You can also use <code>TREAT</code> to modify the declared type of a <code>REF</code> expression. For example:</p>
<pre>SELECT TREAT(REF(p) AS REF student_typ)
  FROM person_obj_table p;
</pre>
<p>The previous example returns <code>REF</code>s to all <code>student_typ</code> instances. In SQL it returns <code>NULL</code> <code>REF</code>s for all person instances that are not students, and in PL/SQL it raises an exception.</p>
</div>
<!-- class="sect3" -->
<div id="ADOBJ7167" class="sect3"><a id="sthref295"></a>
<h4 class="sect3">Using the TREAT Function to Access Subtype Attributes or Methods</h4>
<p>Perhaps the most important use of <code>TREAT</code> is to access attributes or methods of a subtype of a row or column&#39;s declared type. The following query retrieves the <code>major</code> attribute of all persons, students and part-time students, who have this attribute. <code>NULL</code> is returned for persons who are not students:</p>
<div id="ADOBJ7168" class="example">
<p class="titleinexample"><a id="sthref296"></a>Example 2-39 Using the TREAT Function to Access Attributes of a Specific Subtype</p>
<pre>SELECT name, TREAT(VALUE(p) AS student_typ).major major 
  FROM person_obj_table p;
</pre></div>
<!-- class="example" -->
<p>The following query will not work because <code>major</code> is an attribute of <code>student_typ</code> but not of <code>person_typ</code>, the declared type of table <code>persons</code>:</p>
<pre>SELECT name, VALUE(p).major major FROM person_obj_table p -- incorrect;
</pre>
<p>The following is a PL/SQL example:</p>
<pre>DECLARE 
  var person_typ; 
BEGIN 
  var := employee_typ(55, &#39;Jane Smith&#39;, &#39;1-650-555-0144&#39;, 100, &#39;Jennifer Nelson&#39;);
  DBMS_OUTPUT.PUT_LINE(TREAT(var AS employee_typ).mgr);
END;
/
</pre>
<p>For more information about the SQL <code>TREAT</code> function, see <a class="olink SQLRF06148" href="../SQLRF/functions234.htm#SQLRF06148"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i479050"></a>
<div id="ADOBJ7169" class="sect2">
<h3 class="sect2">VALUE<a id="sthref297"></a></h3>
<p>In a SQL statement, the <code>VALUE</code> function takes as its argument a correlation variable (table alias) for an object table or object view and returns object instances corresponding to rows of the table or view. The <code>VALUE</code> function may return instances of the declared type of the row or any of its subtypes.</p>
<p><a href="#CIHFBCJI">Example 2-40</a> first create a <code>part_time_student_typ</code>, and then shows a <code>SELECT</code> query returning all persons, including students and employees, from table <code>person_obj_table</code> of <code>person_typ</code>.</p>
<div id="ADOBJ7170" class="example">
<p class="titleinexample"><a id="CIHFBCJI"></a>Example 2-40 Using the VALUE Function</p>
<pre>-- Requires Ex. 2-31 and 2-32
CREATE TYPE part_time_student_typ UNDER student_typ (
  number_hours NUMBER);
/
SELECT VALUE(p) FROM person_obj_table p;
</pre></div>
<!-- class="example" -->
<p>To retrieve only part time students, that is, instances whose most specific type is <code>part_time_student_typ</code>, use the <code>ONLY</code> keyword to confine the selection:</p>
<pre>SELECT VALUE(p) FROM person_obj_table p 
  WHERE VALUE(p) IS OF (ONLY part_time_student_typ);
</pre>
<p>In the following example, <code>VALUE</code> is used to update a object instance in an object table:</p>
<pre>UPDATE person_obj_table p
   SET VALUE(p) = person_typ(12, &#39;Bob Jones&#39;, &#39;1-650-555-0130&#39;)
   WHERE p.idno = 12;
</pre>
<p>See also <a href="adobjcol.htm#CIHJDAFI">Example 5-22, &#34;Using VALUE to Update a Nested Table&#34;</a>. For more information about the SQL <code>VALUE</code> function, see <a class="olink SQLRF06158" href="../SQLRF/functions245.htm#SQLRF06158"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3980">
<tr>
<td class="cellalignment3987">
<table class="cellalignment3985">
<tr>
<td class="cellalignment3984"><a href="adobjint.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3984"><a href="adobjplsql.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3989">
<table class="cellalignment3983">
<tr>
<td class="cellalignment3984"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3984"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3984"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3984"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3984"><a href="../nav/mindx.htm"><img width="24" height="24" src="../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3984"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>


</body></html>